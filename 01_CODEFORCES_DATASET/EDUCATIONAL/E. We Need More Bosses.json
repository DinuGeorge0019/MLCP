{
    "link": "https://codeforces.com//contest/1000/problem/E",
    "problemId": "193658",
    "problem_idx": "E",
    "shortId": "1000E",
    "contest_number": "1000",
    "problem_submissions": {
        "G": [
            39718562,
            39719543,
            39731044,
            39745353
        ],
        "E": [
            39714455,
            39714380,
            39711396,
            39717344,
            39715216,
            39714198,
            39717274,
            39714849,
            39716315,
            39710033,
            39719087,
            39714919,
            39717269,
            39719314,
            39715149,
            39718067,
            39717227,
            39715819,
            39716698,
            39714956
        ],
        "F": [
            39713460,
            39707084,
            39730558,
            39730512,
            39730296,
            39730270,
            39730256,
            39730239,
            39730221,
            39730211,
            39730154,
            39730127,
            39730113,
            39730102,
            39730087,
            39730070,
            39730054,
            39730038,
            39730029,
            39715353,
            39714587,
            39718375,
            39717776,
            39709495,
            39717288,
            39718275,
            39707695,
            39714904,
            39719561,
            39715859,
            39716309,
            41303353,
            41303333,
            39722296,
            39721263,
            39713335,
            39715356,
            39718313,
            39720559,
            39710578
        ],
        "D": [
            39712036,
            39711284,
            39709815,
            39710348,
            39711331,
            39711469,
            39714291,
            39712438,
            39711322,
            39711986,
            39710186,
            39711296,
            39710596,
            39711080,
            39713011,
            39710269,
            39712921,
            39714356,
            39714670,
            39711775
        ],
        "C": [
            39709789,
            39708273,
            39708437,
            39708497,
            39707490,
            39709711,
            39711470,
            39710285,
            39709663,
            39712657,
            39707054,
            39709385,
            39707981,
            39708400,
            39708339,
            39708579,
            39711654,
            39712280,
            39711950,
            39712277
        ],
        "B": [
            39708786,
            39709741,
            39707292,
            39706954,
            39708573,
            39707999,
            39708997,
            39708329,
            39708450,
            39715462,
            39712282,
            39720742,
            39715883,
            39713342,
            39706846,
            39709837,
            39709912,
            39706999,
            39710604,
            39710245,
            39709682,
            39713043
        ],
        "A": [
            39706953,
            39704546,
            39704256,
            39704278,
            39704401,
            39705070,
            39705301,
            39704306,
            39704491,
            39713520,
            39705360,
            39704298,
            39704641,
            39704487,
            39704983,
            39705096,
            39704429,
            39704776,
            39705211,
            39713228
        ]
    },
    "name": "E. We Need More Bosses",
    "statement": "Your friend is developing a computer game. He has already decided how\r\nthe game world should look like it should consist of n locations\r\nconnected by m passages. The passages are designed in such a way that it\r\nshould be possible to get from any location to any other location.Of\r\ncourse, some passages should be guarded by the monsters (if you just can\r\ngo everywhere without any difficulties, then it’s not fun, right?). Some\r\ncrucial passages will be guarded by really fearsome monsters, requiring\r\nthe hero to prepare for battle and designing his own tactics of\r\ndefeating them (commonly these kinds of monsters are called ). And your\r\nfriend wants you to help him place these bosses.The game will start in\r\nlocation s and end in location t, but these locations are not chosen\r\nyet. After choosing these locations, your friend will place a boss in\r\neach passage such that it is impossible to get from s to t without using\r\nthis passage. Your friend wants to place as much bosses as possible\r\n(because more challenges means more fun, right?), so he asks you to help\r\nhim determine the maximum possible number of bosses, considering that\r\nany location can be chosen as s or as t.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, \"r\", stdin );\n#define fout(s) freopen( s, \"w\", stdout );\n\nconst long long N = 300300;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint m;\nint tim;\nint d[N];\nint tin[N];\nint fin[N];\nbool mo[N];\nbool used[N];\nvector < pair < int, int > > v[N];\n\nvoid dfs(int x, int p)\n{\n        used[x] = 1;\n        fin[x] = tin[x] = ++tim;\n        for(auto pp: v[x]){\n                int y = pp.fi, h = pp.se;\n                if(y == p){\n                        continue;\n                }\n                if(used[y]){\n                        fin[x] = min(fin[x], tin[y]);\n                }\n                else{\n                        dfs(y, x);\n                        fin[x] = min(fin[x], fin[y]);\n                        if(fin[y] > tin[x]){\n                                mo[h] = 1;\n                        }\n                }\n        }\n}\n\nint bfs(int x)\n{\n        for(int i = 1; i <= n; i++){\n                d[i] = 1e9;\n        }\n        queue < int > q;\n        d[x] = 0;\n        q.push(x);\n        while(!q.empty()){\n                x = q.front();\n                q.pop();\n                for(auto pp: v[x]){\n                        int y = pp.fi, h = pp.se;\n                        if(d[x] + mo[h] < d[y]){\n                                d[y] = d[x] + mo[h];\n                                q.push(y);\n                        }\n                }\n        }\n        x = 1;\n        for(int i = 1; i <= n; i++){\n                if(d[i] > d[x]){\n                        x = i;\n                }\n        }\n        return x;\n}\n\nvoid solve()\n{\n        cin >> n >> m;\n        for(int i = 1; i <= m; i++){\n                int x, y;\n                cin >> x >> y;\n                v[x].push_back({y, i});\n                v[y].push_back({x, i});\n        }\n        for(int i = 1; i <= n; i++){\n                if(!used[i]){\n                        dfs(i, -1);\n                }\n        }\n        cout << d[bfs(bfs(1))] << \"\\n\";\n}\n\nbool mtest = false; int main()\n{\n        //fin(\"input.txt\");\n        //fout(\"output.txt\");\n        //fin(\"island.in\");\n        //fout(\"island.out\");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. We Need More Bosses.json",
    "editorial_link": "https://codeforces.com/blog/entry/60288",
    "editorial": "Itâs quite obvious that we can place bosses only on the bridges of the\r\ngiven graph if an edge is not a bridge, then removing it doesnât make\r\nthe graph disconnected, so there still exists a path between any pair of\r\nvertices. And if we fix two vertices and , and then find some simple\r\npath between them, then we will place the bosses on all bridges\r\nbelonging to this path (since the set of bridges would stay the same no\r\nmatter which simple path between and we choose).If we find bridges in\r\nthe given graph and compress all 2-edge-connected components (two\r\nvertices belong to the same 2-edge-connected component iff there exists\r\na path between these vertices such that there are no bridges on this\r\npath) into single vertices, we will obtain a special tree called bridge\r\ntree. Every edge of a bridge tree corresponds to a bridge in the\r\noriginal graph (and vice versa). Since we want to find the path with\r\nmaximum possible number of bridges, we only need to find the diameter of\r\nthe bridge tree, and this will be the answer to the problem.\r\n",
    "hint": []
}