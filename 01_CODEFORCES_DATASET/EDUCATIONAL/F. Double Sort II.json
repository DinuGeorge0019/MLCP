{
    "link": "https://codeforces.com//contest/1783/problem/F",
    "problemId": "1728815",
    "problem_idx": "F",
    "shortId": "1783F",
    "contest_number": "1783",
    "problem_submissions": {
        "G": [
            188483896,
            188470188,
            188490778,
            188491718,
            188493113,
            188527457,
            188526933,
            188518837,
            188481313
        ],
        "F": [
            188457991,
            188459741,
            188468922,
            188473664,
            188468205,
            188471208,
            188461540,
            188473366,
            188477664,
            188473046,
            188489629,
            188473873,
            188484171,
            188480546,
            188485471,
            188484623,
            188483301,
            188466307,
            188469985,
            188485060
        ],
        "E": [
            188452364,
            188453897,
            188463917,
            188466624,
            188459377,
            188459968,
            188455446,
            188466225,
            188471180,
            188466814,
            188462880,
            188467584,
            188467423,
            188462700,
            188463311,
            188503353,
            188474118,
            188475092,
            188461623,
            188502886,
            188463602,
            188475668
        ],
        "D": [
            188448529,
            188449082,
            188455318,
            188454045,
            188455437,
            188454808,
            188471673,
            188459878,
            188455664,
            188459984,
            188457996,
            188455008,
            188460084,
            188450967,
            188459128,
            188456144,
            188459103,
            188459237,
            188463185
        ],
        "C": [
            188443311,
            188439911,
            188447553,
            188445874,
            188449689,
            188446252,
            188448135,
            188452418,
            188447924,
            188450344,
            188449627,
            188448578,
            188449959,
            188467122,
            188452277,
            188450824,
            188449810,
            188450396,
            188451763,
            188456895
        ],
        "B": [
            188434637,
            188433902,
            188440591,
            188436845,
            188440180,
            188437731,
            188434593,
            188440675,
            188439917,
            188436694,
            188436264,
            188437707,
            188438645,
            188437659,
            188440538,
            188439980,
            188442461,
            188440519,
            188465336,
            188436451
        ],
        "A": [
            188432373,
            188432255,
            188432618,
            188432523,
            188433063,
            188432771,
            188432273,
            188433871,
            188432631,
            188433273,
            188432881,
            188432854,
            188433005,
            188432822,
            188435678,
            188432922,
            188432552,
            188432977,
            188432291,
            188432577
        ]
    },
    "name": "F. Double Sort II",
    "statement": "You are given two permutations a and b, both of size n. A permutation of\r\nsize n is an array of n elements, where each integer from 1 to n appears\r\nexactly once. The elements in each permutation are indexed from 1 to\r\nn.You can perform the following operation any number of times: choose an\r\ninteger i from 1 to n; let x be the integer such that a_x = i. Swap a_i\r\nwith a_x; let y be the integer such that b_y = i. Swap b_i with b_y.\r\nYour goal is to make both permutations (i. e. the conditions a_1 < a_2 <\r\ndots < a_n and b_1 < b_2 <\r\ndots < b_n must be satisfied) using . Note that both permutations must\r\nbe sorted after you perform the sequence of operations you have chosen.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Flow {\n    const int n;\n    struct Edge {\n        int to;\n        T cap;\n        Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    \n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    \n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T maxFlow(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n        b[i]--;\n    }\n    \n    std::vector<int> bela(n, -1), belb(n, -1);\n    for (int i = 0; i < n; i++) {\n        if (bela[i] != -1) continue;\n        int j = i;\n        while (bela[j] == -1) {\n            bela[j] = i;\n            j = a[j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (belb[i] != -1) continue;\n        int j = i;\n        while (belb[j] == -1) {\n            belb[j] = i;\n            j = b[j];\n        }\n    }\n    \n    Flow<int> flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(bela[i], n + belb[i], 1);\n    }\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(2 * n, i, 1);\n        flow.addEdge(n + i, 2 * n + 1, 1);\n    }\n    \n    flow.maxFlow(2 * n, 2 * n + 1);\n    \n    std::vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (flow.e[2 * i].cap) {\n            ans.push_back(i);\n        }\n    }\n    \n    std::cout << ans.size() << \"\\n\";\n    for (auto x : ans) {\n        std::cout << x + 1 << \" \\n\"[x == ans.back()];\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "flows",
        "graph matchings",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Double Sort II.json",
    "editorial_link": "https://codeforces.com//blog/entry/111194",
    "editorial": "The solution to this problem uses cyclic decomposition of permutations.\r\nA cyclic decomposition of a permutation is formulated as follows: you\r\ntreat a permutation as a directed graph on vertices, where each vertex\r\nhas an outgoing arc . This graph consists of several cycles, and the\r\nproperties of this graph can be helpful when solving permutation-based\r\nproblems.First of all, how does the cyclic decomposition of a sorted\r\npermutation look? Every vertex belongs to its own cycle formed by a\r\nself-loop going from that vertex to itself. We will try to bring the\r\ncyclic decompositions of the given permutations to this form.What does\r\nan operation with integer do to the cyclic decomposition of the\r\npermutation? If is in its own separate cycle, the operation does nothing\r\n(, so we swap an element with itself). Otherwise, let\u00e2\u0080\u0099s suppose that is\r\nthe element before in the same cycle (), and is the element after in the\r\nsame cycle (). Note that this can be the same element. When we apply an\r\noperation on , we swap with , so after the operation, , and . So, leaves\r\nthe cycle and forms its separate cycle, and becomes the next vertex in\r\nthe cycle after . So, using the operation, we exclude the vertex from\r\nthe cycle.Suppose we want to sort one permutation. Then each cycle\r\nhaving length must be broken down: for a cycle of length , we need to\r\nexclude vertices from it to break it down. The vertex we don\u00e2\u0080\u0099t touch can\r\nbe any vertex from the cycle, and all other vertices from the cycle will\r\nbe extracted using one operation directed at them. It\u00e2\u0080\u0099s easy to see now\r\nthat if we want to sort a permutation, we don\u00e2\u0080\u0099t need to apply the same\r\noperation twice, and the order of operations does not matter.Okay, then\r\nwhat about sorting two permutations in parallel? Let\u00e2\u0080\u0099s change the\r\nproblem a bit: instead of calculating the minimum number of operations,\r\nwe will try to maximize the number of integers such that we don\u00e2\u0080\u0099t\r\nperform operations with them. So, an integer can be left untouched if it\r\nis the only untouched vertex in its cycles in both permutations... Can\r\nyou see where this is going?Suppose we want to leave the vertex\r\nuntouched. It means that in its cycles in both permutations, every other\r\nvertex has to be extracted with an operation. So, if two cycles from\r\ndifferent permutations have a vertex in common, we can leave this vertex\r\nuntouched, as long as there are no other vertices left untouched in both\r\nof these cycles. Let\u00e2\u0080\u0099s build a bipartite graph, where each vertex in the\r\nleft part represents a cycle in the first permutation, and each vertex\r\nin the right part represents a cycle in the second permutation. We will\r\ntreat each integer as an edge between two respective vertices in the\r\nbipartite graph. If the edge corresponding to is \"used\" ( is left\r\nuntouched), we cannot \"use\" any edges incident to the same vertex in\r\nleft or right part. So, maximizing the number of untouched numbers is\r\nactually the same as finding the maximum matching in this bipartite\r\ngraph.After you find the maximum matching, restoring the actual answer\r\nis easy. Remember that the edges saturated by the matching correspond to\r\nthe integers we don\u00e2\u0080\u0099t touch with our operations, the order of operations\r\ndoes not matter, and each integer has to be used in an operation only\r\nonce. So, the actual answer is the set of all integers without those\r\nwhich correspond to the edges from the matching.This solution runs in\r\neven with a straightforward implementation of bipartite matching, since\r\nthe bipartite graph has at most vertices and edges.\r\n"
}