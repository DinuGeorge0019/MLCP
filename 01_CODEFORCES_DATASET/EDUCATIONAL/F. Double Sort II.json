{"link": "https://codeforces.com//contest/1783/problem/F", "problemId": "1728815", "problem_idx": "F", "shortId": "1783F", "contest_number": "1783", "problem_submissions": {"G": [188483896, 188470188, 188490778, 188491718, 188493113, 188527457, 188526933, 188518837, 188481313], "F": [188457991, 188459741, 188468922, 188473664, 188468205, 188471208, 188461540, 188473366, 188477664, 188473046, 188489629, 188473873, 188484171, 188480546, 188485471, 188484623, 188483301, 188466307, 188469985, 188485060], "E": [188452364, 188453897, 188463917, 188466624, 188459377, 188459968, 188455446, 188466225, 188471180, 188466814, 188462880, 188467584, 188467423, 188462700, 188463311, 188503353, 188474118, 188475092, 188461623, 188502886, 188463602, 188475668], "D": [188448529, 188449082, 188455318, 188454045, 188455437, 188454808, 188471673, 188459878, 188455664, 188459984, 188457996, 188455008, 188460084, 188450967, 188459128, 188456144, 188459103, 188459237, 188463185], "C": [188443311, 188439911, 188447553, 188445874, 188449689, 188446252, 188448135, 188452418, 188447924, 188450344, 188449627, 188448578, 188449959, 188467122, 188452277, 188450824, 188449810, 188450396, 188451763, 188456895], "B": [188434637, 188433902, 188440591, 188436845, 188440180, 188437731, 188434593, 188440675, 188439917, 188436694, 188436264, 188437707, 188438645, 188437659, 188440538, 188439980, 188442461, 188440519, 188465336, 188436451], "A": [188432373, 188432255, 188432618, 188432523, 188433063, 188432771, 188432273, 188433871, 188432631, 188433273, 188432881, 188432854, 188433005, 188432822, 188435678, 188432922, 188432552, 188432977, 188432291, 188432577]}, "name": "F. Double Sort II", "statement": "You are given two permutations a and b, both of size n. A permutation of\r\nsize n is an array of n elements, where each integer from 1 to n appears\r\nexactly once. The elements in each permutation are indexed from 1 to\r\nn.You can perform the following operation any number of times: choose an\r\ninteger i from 1 to n; let x be the integer such that a_x = i. Swap a_i\r\nwith a_x; let y be the integer such that b_y = i. Swap b_i with b_y.\r\nYour goal is to make both permutations (i. e. the conditions a_1 < a_2 <\r\ndots < a_n and b_1 < b_2 <\r\ndots < b_n must be satisfied) using . Note that both permutations must\r\nbe sorted after you perform the sequence of operations you have chosen.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Flow {\n    const int n;\n    struct Edge {\n        int to;\n        T cap;\n        Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    \n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    \n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T maxFlow(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n        b[i]--;\n    }\n    \n    std::vector<int> bela(n, -1), belb(n, -1);\n    for (int i = 0; i < n; i++) {\n        if (bela[i] != -1) continue;\n        int j = i;\n        while (bela[j] == -1) {\n            bela[j] = i;\n            j = a[j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (belb[i] != -1) continue;\n        int j = i;\n        while (belb[j] == -1) {\n            belb[j] = i;\n            j = b[j];\n        }\n    }\n    \n    Flow<int> flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(bela[i], n + belb[i], 1);\n    }\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(2 * n, i, 1);\n        flow.addEdge(n + i, 2 * n + 1, 1);\n    }\n    \n    flow.maxFlow(2 * n, 2 * n + 1);\n    \n    std::vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (flow.e[2 * i].cap) {\n            ans.push_back(i);\n        }\n    }\n    \n    std::cout << ans.size() << \"\\n\";\n    for (auto x : ans) {\n        std::cout << x + 1 << \" \\n\"[x == ans.back()];\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "flows", "graph matchings", "graphs"], "dificulty": "2500", "interactive": false}