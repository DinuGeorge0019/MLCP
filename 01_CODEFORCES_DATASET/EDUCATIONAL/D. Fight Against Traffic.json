{
    "link": "https://codeforces.com//contest/954/problem/D",
    "problemId": "167341",
    "problem_idx": "D",
    "shortId": "954D",
    "contest_number": "954",
    "problem_submissions": {
        "I": [
            36483613,
            36489921,
            36491468,
            36492587,
            36489151,
            36505182,
            36498444,
            36489158,
            36493599,
            36495253,
            36493983,
            36523197,
            36517457,
            36494315,
            36517490
        ],
        "E": [
            36478770,
            36477321,
            36476296,
            36476332,
            36477191,
            36479277,
            36478407,
            36484072,
            36476637,
            36483722,
            36476830,
            36479359,
            36479273,
            36481624,
            36479515,
            36473956,
            36477339,
            36477449,
            36476422,
            36481260
        ],
        "D": [
            36478485,
            36475307,
            36474083,
            36478258,
            36474970,
            36476455,
            36476263,
            36472023,
            36474824,
            36478016,
            36474200,
            36476982,
            36476891,
            36474372,
            36477175,
            36479984,
            36487971,
            36474275,
            36474076,
            36475466
        ],
        "C": [
            36476002,
            36474037,
            36473020,
            36474296,
            36473832,
            36473968,
            36474218,
            36474540,
            36483525,
            36476724,
            36472809,
            36474171,
            36499291,
            36473004,
            36474442,
            36477242,
            36486700,
            36473123,
            36472782,
            36473808
        ],
        "G": [
            36475037,
            36479869,
            36479819,
            36482297,
            36479701,
            36481399,
            36480184,
            36480325,
            36481161,
            36480550,
            36485383,
            36482231,
            36482668,
            36492299,
            36483624,
            36487406,
            36490213,
            36485274,
            36478330,
            36479287
        ],
        "F": [
            36474930,
            36486416,
            36483404,
            36528491,
            36484207,
            36482822,
            36485630,
            36483061,
            36477477,
            36481839,
            36487500,
            36482960,
            36488051,
            36485000,
            36479677,
            36489393,
            36482816,
            36484976,
            36483377,
            36483862,
            36487177
        ],
        "H": [
            36473564,
            36483628,
            36486927,
            36487388,
            36497291,
            36492759,
            36492641,
            36496336,
            36493059,
            36491960,
            36490810,
            36488245,
            36487713,
            36489798,
            36483087
        ],
        "B": [
            36472231,
            36471541,
            36471094,
            36471718,
            36471325,
            36471918,
            36470816,
            36471290,
            36470543,
            36472680,
            36470969,
            36471052,
            36470688,
            36471049,
            36472812,
            36475352,
            36471581,
            36471121,
            36470814,
            36470886
        ],
        "A": [
            36470941,
            36470615,
            36469920,
            36470743,
            36470038,
            36470789,
            36469978,
            36470246,
            36469943,
            36471510,
            36470178,
            36469918,
            36469982,
            36470334,
            36471516,
            36475017,
            36470944,
            36470503,
            36470133,
            36470029
        ]
    },
    "name": "D. Fight Against Traffic",
    "statement": "Little town Nsk consists of junctions connected by bidirectional roads.\r\nEach road connects two distinct junctions and no two roads connect the\r\nsame pair of junctions. It is possible to get from any junction to any\r\nother junction by these roads. The distance between two junctions is\r\nequal to the minimum possible number of roads on a path between them.In\r\norder to improve the transportation system, the city council asks mayor\r\nto build one new road. The problem is that the mayor has just bought a\r\nwonderful new car and he really enjoys a ride from his home, located\r\nnear junction to work located near junction . Thus, he wants to build a\r\nnew road in such a way that the distance between these two junctions\r\nwon\u2019t decrease. You are assigned a task to compute the number of pairs\r\nof junctions that are not connected by the road, such that if the new\r\nroad between these two junctions is built the distance between and won\u2019t\r\ndecrease.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MN 1005\nusing namespace std;\nstruct edge{int nex,to;}e[MN<<1];\nint hr[MN],dep[2][MN],q[MN];\nint hd,tl,S,T,pin,n,m,ans;\nbool mp[MN][MN];\n\ninline int read()\n{\n\tint n=0,f=1; char c=getchar();\n\twhile (c<'0' || c>'9') {if(c=='-')f=-1; c=getchar();}\n\twhile (c>='0' && c<='9') {n=n*10+c-'0'; c=getchar();}\n\treturn n*f;\n}\ninline void ins(int x,int y) {e[++pin]=(edge){hr[x],y}; hr[x]=pin;}\n\nvoid bfs(int SS,int g)\n{\n//\tmemset(u,0,sizeof(dep));\n\tregister int i,x;\n\tfor (dep[g][q[hd=tl=1]=SS]=1;hd<=tl;++hd)\n\t\tfor (x=q[hd],i=hr[x];i;i=e[i].nex)\n\t\t\tif (!dep[g][e[i].to])\n\t\t\t\tdep[g][e[i].to]=dep[g][x]+1,q[++tl]=e[i].to;\n}\n\nint main()\n{\n\tregister int i,j,x,y;\n\tn=read(); m=read(); S=read(); T=read();\n\tfor (i=1;i<=m;++i)\n\t\tx=read(),y=read(),\n\t\tins(x,y),ins(y,x),\n\t\tmp[x][y]=mp[y][x]=true;\n\tbfs(S,0); bfs(T,1);\n\tfor (i=1;i<=n;++i) --dep[0][i],--dep[1][i];\n\tfor (i=1;i<n;++i)\n\t\tfor (j=i+1;j<=n;++j)\n\t\t\tif (!mp[i][j])\n\t\t\t\tif (min(dep[0][i]+dep[1][j]+1,dep[1][i]+dep[0][j]+1)>=dep[0][T]) ++ans;\n\tprintf(\"%d\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Fight Against Traffic.json",
    "editorial_link": "https://codeforces.com//blog/entry/58519",
    "editorial": "Let\u00e2\u0080\u0099s use bfs to calculate the smallest distances to all vertices from\r\nthe vertex and from the vertex . These will be and for all . is the the\r\ncurrent smallest distance between and . What you need is to iterate over\r\nall pairs and check if the edge between them doesn\u00e2\u0080\u0099t exist and neither\r\nnor is smaller than .Overall complexity: .\r\n"
}