{
    "link": "https://codeforces.com//contest/818/problem/C",
    "problemId": "112247",
    "problem_idx": "C",
    "shortId": "818C",
    "contest_number": "818",
    "problem_submissions": {
        "G": [
            30023806,
            28149762,
            28149727,
            28149674,
            28150840,
            28150782,
            28150772,
            28150751,
            28150583,
            36665796,
            28151676,
            28150077,
            28257233,
            28153699,
            28148603,
            28155021,
            28156689,
            28156349,
            28183779
        ],
        "F": [
            28147295,
            28150245,
            28148357,
            28147147,
            28148601,
            28147618,
            28149338,
            28148822,
            28148432,
            28150045,
            28149715,
            28149799,
            28150664,
            28150399,
            28265989,
            28152841,
            28152214,
            28151371,
            28150016,
            28150927,
            28150947,
            28149764
        ],
        "E": [
            28145911,
            28145866,
            28146912,
            28146350,
            28146816,
            28150531,
            28146712,
            28147272,
            28147609,
            28147038,
            28148502,
            28147986,
            28147358,
            28149016,
            28148737,
            28150693,
            28148409,
            28146623,
            28149530,
            28149268,
            28147603
        ],
        "D": [
            28144801,
            28145060,
            28145928,
            28145417,
            28145327,
            28143658,
            28146282,
            28144973,
            28145879,
            28146889,
            28146309,
            28145676,
            28146984,
            28146985,
            28145000,
            28147304,
            28145917,
            28147015,
            28147874,
            28146172
        ],
        "C": [
            28144306,
            28147073,
            28145409,
            28144547,
            28144448,
            28144425,
            28145368,
            28146425,
            28145275,
            28145837,
            28145300,
            28145004,
            28145976,
            28145637,
            28147975,
            28146492,
            28148332,
            28146298,
            28146819,
            28144965
        ],
        "B": [
            28143095,
            28143560,
            28143556,
            28143415,
            28143669,
            28144503,
            28144240,
            28143720,
            28144083,
            28143468,
            28143875,
            28143599,
            28143355,
            28143995,
            28143629,
            28143924,
            28143708,
            28142954,
            28143812,
            28144185
        ],
        "A": [
            28142461,
            28142521,
            28142540,
            28142460,
            28142740,
            28142644,
            28142466,
            28142416,
            28142519,
            28142508,
            28142479,
            28142800,
            28142422,
            28142542,
            28142573,
            28142463,
            28142490,
            28142485
        ]
    },
    "name": "C. Sofa Thief",
    "statement": "Yet another round on DecoForces is coming! Grandpa Maks wanted to\r\nparticipate in it but someone has stolen his precious sofa! And how can\r\none perform well with such a major loss?Fortunately, the thief had left\r\na note for Grandpa Maks. This note got Maks to the sofa storehouse.\r\nStill he had no idea which sofa belongs to him as they all looked the\r\nsame!The storehouse is represented as matrix . Every sofa takes two\r\nneighbouring by some side cells. No cell is covered by more than one\r\nsofa. There can be empty cells.Sofa is standing to the left of sofa if\r\nthere exist two such cells and that , is covered by and is covered by .\r\nSofa is standing to the top of sofa if there exist two such cells and\r\nthat , is covered by and is covered by . Right and bottom conditions are\r\ndeclared the same way. Also some sofa can be both to the top of another\r\nsofa and to the bottom of it. The same is for left and right\r\nconditions.The note also stated that there are sofas to the left of\r\nGrandpa Maks\u2019s sofa, to the right, to the top and to the bottom.Grandpa\r\nMaks asks you to help him to identify his sofa. It is guaranteed that\r\nthere is no more than one sofa of given conditions.Output the number of\r\nGrandpa Maks\u2019s sofa. If there is no such sofa that all the conditions\r\nare met for it then output .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\n#define x1 fjkljklx1\n#define y1 fjkljkly1\n#define x2 fjkljklx2\n#define y2 fjkljkly2\nint d , n , m;\nint x1[ N ] , x2[ N ] , y1[ N ] , y2[ N ];\nint cntl , cntr , cntt , cntb;\nvoid init(){\n  cin >> d >> n >> m;\n  for( int i = 0 ; i < d ; i ++ )\n    cin >> x1[ i ] >> y1[ i ] >> x2[ i ] >> y2[ i ];\n  cin >> cntl;\n  cin >> cntr;\n  cin >> cntt;\n  cin >> cntb;\n}\nint cl[ N ] , cr[ N ] , ct[ N ] , cb[ N ];\nvoid solve(){\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { x1[ i ] , i } );\n      v.push_back( { x2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // left xa < xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cl[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cl[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cr[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cr[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  {\n    vector< pair<int,int> > v;\n    for( int i = 0 ; i < d ; i ++ ){\n      v.push_back( { y1[ i ] , i } );\n      v.push_back( { y2[ i ] , i } );\n    }\n    {\n      sort( v.begin() , v.end() );\n      // top ya < yb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          ct[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            ct[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n    {\n      reverse( v.begin() , v.end() );\n      // right xa > xb\n      set<int> S;\n      for( size_t l = 0 , r = 0 ; l < v.size() ; l = r ){\n        while( r < v.size() and v[ l ].first == v[ r ].first ) r ++;\n        for( size_t i = l ; i < r ; i ++ ){\n          cb[ v[ i ].second ] = S.size();\n          if( S.count( v[ i ].second ) )\n            cb[ v[ i ].second ] --;\n        }\n        for( size_t i = l ; i < r ; i ++ )\n          S.insert( v[ i ].second );\n      }\n    }\n  }\n  for( int i = 0 ; i < d ; i ++ )\n    if( cl[ i ] == cntl and\n        cr[ i ] == cntr and\n        ct[ i ] == cntt and\n        cb[ i ] == cntb ){\n      cout << i + 1 << endl;\n      return;\n    }\n  cout << -1 << endl;\n}\nint main(){\n  init();\n  solve();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Sofa Thief.json",
    "editorial_link": "https://codeforces.com/blog/entry/52991",
    "editorial": "Coordinates don\u00e2\u0080\u0099t exceed so it\u00e2\u0080\u0099s possible to use sweep line method to\r\nsolve the problem.Let\u00e2\u0080\u0099s calculate value separately for each side. I will\r\nshow the algorithm for left side and all the others will be done\r\nsimilarly.Let be the number of sofas which has smaller of their\r\ncoordinates less than or equal to . To count that let\u00e2\u0080\u0099s firstly\r\nincrement by one for all sofas and then proceed from left to right and\r\ndo .Now will represent number of sofas to the left of the current one\r\nbut the sofa itself can also be counted. You need to decrement the\r\nresult by one if .The same is for top value but with coordinates insted\r\nof .For the right and bottom values you should calculate and . Then take\r\nand .The only thing left is to compare values of each sofa with given\r\nones and find the suitable sofa.Overall complexity: .\r\n"
}