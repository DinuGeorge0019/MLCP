{
    "link": "https://codeforces.com//contest/1886/problem/E",
    "problemId": "2254333",
    "problem_idx": "E",
    "shortId": "1886E",
    "contest_number": "1886",
    "problem_submissions": {
        "F": [
            227397695,
            227398300,
            228261037,
            228260268,
            228197178
        ],
        "E": [
            227362679,
            227384483,
            227364120,
            227375327,
            227373174,
            227378169,
            227374021,
            227374447,
            227379620,
            227374460,
            227376543,
            227384694,
            227379424,
            227380143,
            227385403,
            227378825,
            227381936,
            227382749,
            227399178,
            227387227
        ],
        "D": [
            227353655,
            227357179,
            227354694,
            227357584,
            227358464,
            227358468,
            227358349,
            227362290,
            227362059,
            227356663,
            227359799,
            227363314,
            227364815,
            227364540,
            227348253,
            227359972,
            227351995,
            227364703,
            227363479,
            227364505
        ],
        "C": [
            227350420,
            227354094,
            227350822,
            227351738,
            227353206,
            227352928,
            227352755,
            227358100,
            227355646,
            227353873,
            227356426,
            227357990,
            228289531,
            227359928,
            227359265,
            227363015,
            227354512,
            227347330,
            227360346,
            227356740,
            227359383
        ],
        "B": [
            227345467,
            227345695,
            227345097,
            227345886,
            227347778,
            227347034,
            227345776,
            227346855,
            227347299,
            227344500,
            227348328,
            227348902,
            227344888,
            227345167,
            227353779,
            227346134,
            227384569,
            227355313,
            227346381,
            227345209
        ],
        "A": [
            227342113,
            227340918,
            227341455,
            227340893,
            227341201,
            227341171,
            227340846,
            227340875,
            227341099,
            227340925,
            227340854,
            227342810,
            227341042,
            227341115,
            227341596,
            227341490,
            227340923,
            227349667,
            227341619,
            227341191
        ]
    },
    "name": "E. I Wanna be the Team Leader",
    "statement": "Monocarp is a team leader in a massive IT company.There are m projects\r\nhis team of programmers has to complete, numbered from 1 to m. The i-th\r\nproject has a difficulty level b_i.There are n programmers in the team,\r\nnumbered from 1 to n. The j-th programmer has a stress tolerance level\r\na_j.Monocarp wants to assign the programmers to the projects in such a\r\nway that: each programmer is assigned to no more than one project; each\r\nproject has at least one programmer assigned to it; let k programmers be\r\nassigned to the i-th project; then all the assigned programmers have to\r\nhave a stress tolerance level greater than or equal to\r\nfrac{b_i}{k}. Help Monocarp to find a valid assignment. If there are\r\nmultiple answers, print any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::array<int, 2>> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i][0];\n        a[i][1] = i;\n    }\n    std::sort(a.begin(), a.end(), std::greater());\n    \n    std::vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> b[i];\n    }\n    \n    std::vector f(m, std::vector<int>(n, n + 1));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int l = j + 1 - ((b[i] - 1) / a[j][0] + 1);\n            if (l >= 0) {\n                f[i][l] = std::min(f[i][l], j + 1);\n            }\n        }\n        for (int j = n - 2; j >= 0; j--) {\n            f[i][j] = std::min(f[i][j], f[i][j + 1]);\n        }\n    }\n    \n    std::vector<int> dp(1 << m, n + 1);\n    dp[0] = 0;\n    for (int s = 1; s < (1 << m); s++) {\n        for (int i = 0; i < m; i++) {\n            if (s >> i & 1) {\n                int t = s ^ (1 << i);\n                if (dp[t] < n) {\n                    dp[s] = std::min(dp[s], f[i][dp[t]]);\n                }\n            }\n        }\n    }\n    \n    if (dp.back() <= n) {\n        std::cout << \"YES\\n\";\n        std::vector<std::vector<int>> ans(m);\n        int s = (1 << m) - 1;\n        while (s > 0) {\n            for (int i = 0; i < m; i++) {\n                if (s >> i & 1) {\n                    int t = s ^ (1 << i);\n                    if (dp[t] < n && f[i][dp[t]] == dp[s]) {\n                        for (int j = dp[t]; j < dp[s]; j++) {\n                            ans[i].push_back(a[j][1] + 1);\n                        }\n                        s = t;\n                        break;\n                    }\n                }\n            }\n        }\n        for (auto x : ans) {\n            std::cout << x.size();\n            for (auto y : x) {\n                std::cout << \" \" << y;\n            }\n            std::cout << \"\\n\";\n        }\n    } else {\n        std::cout << \"NO\\n\";\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dp",
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. I Wanna be the Team Leader.json",
    "editorial_link": "https://codeforces.com//blog/entry/121255",
    "editorial": "Letâs start by arranging the programmers in the increasing order of\r\ntheir stress tolerance level. Not obvious what it achieves at first, but\r\nit always helps to sort, doesnât it?Now, consider some assignment of the\r\nprogrammers to the projects. Notice how itâs always optimal to take the\r\nsuffix of the programmers. If there is a valid answer which is not a\r\nsuffix, then you can always take drop the weakest programmer and replace\r\nhim with the strongest non-taken one, and the answer will still be\r\nvalid.We can actually propagate the argument further. Itâs also always\r\noptimal for each project to have assigned a segment of programmers. Look\r\nat the weakest taken programmer again and think about the project heâs\r\nassigned to. All that matters for the project is the number of other\r\nprogrammers assigned to it. So, you can safely replace the current\r\nassigned programmers with the same count of the next weakest ones. You\r\ncan do it by swapping the assigned projects of the adjacent programmers.\r\nThis way, every swap can only make any other projectâs weakest\r\nprogrammer stronger.Thus, we can actually build the answer the following\r\nway. Choose a project and assign the shortest possible suffix of\r\nnon-taken programmers to it. We just have to determine the order of the\r\nprojects to take.Well, letâs use dynamic programming for that. Let be\r\nthe shortest suffix of the programmers that can be assigned to the\r\nprojects from . For a transition, just choose one of the projects that\r\nisnât in and find the shortest segment of programmers starting from .How\r\nto find this shortest suffix fast enough? You can precompute it before\r\ncalculating the dynamic programming. For each project and each starting\r\nindex, you can calculate the shortest suffix with two pointers.Overall\r\ncomplexity: .\r\n",
    "hint": []
}