{"link": "https://codeforces.com//contest/1463/problem/C", "problemId": "836003", "problem_idx": "C", "shortId": "1463C", "contest_number": "1463", "problem_submissions": {"F": [101559554, 101581978, 101567286, 101577708, 101580696, 101680102, 101680098, 101605801, 101605564, 101602968, 101602931, 101594909, 101594099, 102434679, 101661639, 101713126, 101711433, 101812801], "E": [101543691, 101541624, 101550722, 101542275, 101561956, 101542640, 101551028, 101551947, 101553418, 101552115, 101553474, 101556641, 101557969, 101556648, 101554530, 101557890, 101556692, 101561428, 101553035], "D": [101533227, 101528710, 101537667, 101530458, 101531312, 101543635, 101536909, 101536759, 101540131, 101537456, 101542046, 101537094, 101540598, 101539288, 101544433, 101525965, 101526650, 101536306, 101544222], "C": [101526320, 101520150, 101529141, 101525986, 101523000, 101525367, 101530714, 101526273, 102544695, 101524853, 101531194, 101530250, 101529215, 101530504, 101529471, 101533604, 101540078, 101541782, 101523573, 101536896], "B": [101518923, 101515147, 101518366, 101516293, 101513263, 101522496, 101520454, 101515435, 101517061, 101515098, 101516483, 101522667, 101516542, 101515577, 101515224, 101517780, 101517682, 101515176, 101521789], "A": [101515277, 101512560, 101513602, 101512825, 101512593, 101512667, 101513802, 101512900, 101514221, 101512986, 101513229, 101513515, 101512759, 101512530, 101512877, 101514648, 101514992, 101512816, 101514556]}, "name": "C. Busy Robot", "statement": "You have a robot that can move along a number line. At time moment 0 it\r\nstands at point 0.You give n commands to the robot: at time t_i seconds\r\nyou command the robot to go to point x_i. Whenever the robot receives a\r\ncommand, it starts moving towards the point x_i with the speed of 1 unit\r\nper second, and he stops when he reaches that point. However, while the\r\nrobot is moving, it all the other commands that you give him.For\r\nexample, suppose you give three commands to the robot: at time 1 move to\r\npoint 5, at time 3 move to point 0 and at time 6 move to point 4. Then\r\nthe robot stands at 0 until time 1, then starts moving towards 5,\r\nignores the second command, reaches 5 at time 6 and immediately starts\r\nmoving to 4 to execute the third command. At time 7 it reaches 4 and\r\nstops there.You call the command i successful, if there is a time moment\r\nin the range [t_i, t_{i + 1}] (i. e. after you give this command and\r\nbefore you give another one, both bounds inclusive; we consider t_{n +\r\n1} = +\r\ninfty) when the robot is at point x_i. Count the number of successful\r\ncommands. Note that it is possible that an ignored command is\r\nsuccessful.\r\n", "solutions": ["#pragma GCC optimize(\"Ofast\")\n#pragma GCC target (\"sse4\")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tint cur = 0;\n\tvector<ll> t(n);\n\tvector<ll> x(n);\n\trep(i, n)cin >> t[i] >> x[i];\n\tint ans = 0;\n\trep(i, n) {\n\t\t//cur->x[i] at time t[i]\n\t\tll dif = abs(cur - x[i]);\n\t\tint nex = i + 1;\n\t\twhile (nex < n && t[nex] < t[i] + dif)nex++;\n\t\tll nexdif = INF;\n\t\tif (i + 1 < n)nexdif = t[i + 1] - t[i];\n\t\tif (dif <= nexdif)ans++;\n\t\tfor (int j = i + 1; j < nex; j++) {\n\t\t\tll tdif = t[j] - t[i];\n\t\t\tll tdif2 = INF;\n\t\t\tif (j + 1 < n)tdif2 = t[j + 1] - t[i];\n\t\t\tll le, ri;\n\t\t\tif (cur <= x[i]) {\n\t\t\t\tle = min(cur + tdif, x[i]);\n\t\t\t\tri = min(cur + tdif2, x[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tle = max(cur - tdif2, x[i]);\n\t\t\t\tri = max(cur - tdif, x[i]);\n\t\t\t}\n\t\t\tif (le <= x[j] && x[j] <= ri)ans++;\n\t\t}\n\t\tcur = x[i];\n\t\ti = nex - 1;\n\t}\n\t//cout << \"ans is \";\n\tcout << ans << \"\\n\";\n}\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1800", "interactive": false}