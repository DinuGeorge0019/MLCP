{
    "link": "https://codeforces.com//contest/1065/problem/E",
    "problemId": "235282",
    "problem_idx": "E",
    "shortId": "1065E",
    "contest_number": "1065",
    "problem_submissions": {
        "G": [
            44147383,
            44142689,
            64875649,
            44176191,
            44151224,
            44148655
        ],
        "F": [
            44140103,
            44135158,
            44149164,
            44170796,
            44144683,
            44147682,
            44150813,
            44148584,
            44232284,
            44149497,
            44149530,
            44147181,
            44142305,
            44150346,
            44135080,
            44139962,
            44154242,
            44143115,
            44173159
        ],
        "E": [
            44135655,
            44147876,
            44135777,
            44147851,
            44136930,
            44146829,
            44136198,
            44142963,
            44143566,
            44144277,
            44137199,
            44146967,
            44148616,
            44133656,
            44142278,
            44138211,
            44126340,
            44141084,
            44146795,
            44140823
        ],
        "D": [
            44131742,
            44145378,
            44140071,
            44135909,
            44143930,
            44133600,
            44143692,
            44140442,
            44140210,
            44138706,
            44143640,
            44144314,
            44158291,
            44137709,
            44163831,
            44137474,
            44135591,
            44136408
        ],
        "C": [
            44121602,
            44120175,
            44124781,
            44126011,
            44125676,
            44121365,
            44127681,
            44121729,
            44126925,
            44123439,
            44127185,
            44130687,
            44137712,
            44126326,
            44122320,
            44121809,
            44122322,
            44129853,
            44123901,
            44127061
        ],
        "B": [
            44119298,
            44120920,
            44120806,
            44122001,
            44121592,
            44118170,
            44120220,
            44123249,
            44122493,
            44127205,
            44122290,
            44123314,
            44136224,
            44122582,
            44118742,
            44120144,
            44119274,
            44120858,
            44120292,
            44127423
        ],
        "A": [
            44117312,
            44121828,
            44117393,
            44117877,
            44118469,
            44117250,
            44118091,
            44118967,
            44118166,
            44118757,
            44117346,
            44118839,
            44117870,
            44119633,
            44117273,
            44117291,
            44117281,
            44117657,
            44117462,
            44117869
        ]
    },
    "name": "E. Side Transmutations",
    "statement": "Consider some set of distinct characters A and some string S, consisting\r\nof exactly n characters, where each character is present in A.You are\r\ngiven an array of m integers b (b_1 < b_2 <\r\ndots < b_m). You are allowed to perform the following move on the string\r\nS: Choose some valid i and set k = b_i; Take the first k characters of S\r\n= Pr_k; Take the last k characters of S = Su_k; Substitute the first k\r\ncharacters of S with the reversed Su_k; Substitute the last k characters\r\nof S with the reversed Pr_k. For example, let’s take a look at S = \"\"\r\nand k = 2. Pr_2 = \"\", Su_2 = \"\". Reversed Pr_2 = \"\", Su_2 = \"\". Thus,\r\nthe resulting S is \"\".The move can be performed arbitrary number of\r\ntimes (possibly zero). Any i can be selected multiple times over these\r\nmoves.Let’s call some strings S and T equal if and only if there exists\r\nsuch a sequence of moves to transmute string S to string T. For the\r\nabove example strings \"\" and \"\" are equal. Also note that this implies S\r\n= S.The task is simple. Count the number of distinct strings.The answer\r\ncan be huge enough, so calculate it modulo 998244353.\r\n",
    "solutions": [
        "/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(\"%d\", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return ('a' <= x && x <= 'z'); }\ninline bool is_upper(char x) { return ('A' <= x && x <= 'Z'); }\ninline bool is_digit(char x) { return ('0' <= x && x <= '9'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 150;\n\nll power(ll a, ll k)\n{\n    if (k == 0) return 1;\n    ll t = power(a, k >> 1LL);\n    t = (t * t) % MOD;\n    if (k & 1LL) t = (t * a) % MOD;\n    return t;\n}\n\nll n, m, a, b[M];\nbool pr;\n\nint main()\n{\n    #ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> m >> a;\n    for (int i = 0; i < m; i++)\n        cin >> b[i];\n    pr = false;\n    if (n & 1)\n        pr = true;\n    n /= 2;\n    ll ans = power((a * a) % MOD, n - b[m - 1]);\n    for (int i = m - 1; i >= 1; i--) b[i] -= b[i - 1];\n    for (int i = 0; i < m; i++)\n    {\n        ll kol = power(a, b[i]);\n        kol = (kol * (kol + 1)) % MOD;\n        if (kol & 1LL)\n            kol = (kol + MOD) / 2LL;\n        else\n            kol = (kol / 2LL);\n        ans = (ans * kol) % MOD;\n    }\n    if (pr)\n        ans = (a * ans) % MOD;\n    cout << ans;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Side Transmutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/62411",
    "editorial": "Letâs take a look at any operation. You can notice that each letter can\r\nonly go from position to (-indexed). Then, doing some operation twice is\r\nthe same as doing that operation zero times.Now consider some set of\r\noperations , sorted in increasing order. Actually, they do the following\r\naltogether. Replace segment with the reversed segment and vice versa.\r\nThen replace segment with the reversed segment and vice versa. And\r\ncontinue until you reach the first pair. Segment might also be included\r\nin the answer when the parity is right.Moreover, every subset of\r\nsegments is achievable. So for each segment you can either swap it or\r\nnot. Letâs translate it to math language.Let be the number of such pairs\r\nof strings and that . Why is there such an order? You want to consider\r\nonly unique strings, thus, you need to pick exactly one of equal strings\r\nfrom each component. Let it be the smallest one.Then for each segment of\r\nthe set you have pairs to choose from, where is the length of that\r\nsegment.And that part of the formula is:.However, the part covered by\r\nzero segments is left. There are possible strings up there. is actually\r\na number of all pairs of strings of length plus the number of all pairs\r\nof equal strings of length divided by . .Overall complexity: .\r\n",
    "hint": []
}