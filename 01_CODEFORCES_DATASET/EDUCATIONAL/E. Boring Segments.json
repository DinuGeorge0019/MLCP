{
    "link": "https://codeforces.com//contest/1555/problem/E",
    "problemId": "1062144",
    "problem_idx": "E",
    "shortId": "1555E",
    "contest_number": "1555",
    "problem_submissions": {
        "F": [
            124306614,
            124343856,
            124312339,
            124307563,
            124318196,
            124319806,
            124318258,
            124337936,
            124326369,
            124312719,
            124312071,
            124325220,
            124322375,
            124337491,
            124327796,
            124313538,
            124320609,
            124319069,
            124334134
        ],
        "E": [
            124292614,
            124284546,
            124290978,
            124299668,
            124299626,
            124301534,
            124305345,
            124311168,
            124315291,
            124304878,
            124305598,
            124300363,
            124304344,
            124324832,
            124306310,
            124305064,
            124305374
        ],
        "C": [
            124284989,
            124280595,
            124283283,
            124284609,
            124285731,
            124291694,
            124283589,
            124282860,
            124292981,
            124286855,
            124287174,
            124284102,
            124289820,
            124283315,
            124290207,
            124292792,
            124290345
        ],
        "D": [
            124282896,
            124281706,
            124287585,
            124287694,
            124291470,
            124295363,
            124329814,
            124293642,
            124293299,
            124285216,
            124284331,
            124294215,
            124292885,
            124291338,
            124294163,
            124296113,
            124299446,
            124297892,
            124294376
        ],
        "B": [
            124280802,
            124279957,
            124281993,
            124281520,
            124282708,
            124281869,
            124281852,
            124283175,
            124289412,
            124282989,
            124282919,
            124281809,
            124286550,
            124291562,
            124286726,
            124289852,
            124285340
        ],
        "A": [
            124279594,
            124279557,
            124279608,
            124279611,
            124279723,
            124279607,
            124279587,
            124279711,
            124282014,
            124280166,
            124279749,
            124279696,
            124279824,
            124279602,
            124281131,
            124280445,
            124279990
        ]
    },
    "name": "E. Boring Segments",
    "statement": "You are given n segments on a number line, numbered from 1 to n. The\r\ni-th segments covers all integer points from l_i to r_i and has a value\r\nw_i.You are asked to select a subset of these segments (possibly, all of\r\nthem). Once the subset is selected, it\u2019s possible to travel between two\r\ninteger points if there exists a selected segment that covers both of\r\nthem. A subset is good if it\u2019s possible to reach point m starting from\r\npoint 1 in arbitrary number of moves.The cost of the subset is the\r\ndifference between the maximum and the minimum values of segments in it.\r\nFind the minimum cost of a good subset.In every test there exists at\r\nleast one good subset.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\ntemplate <typename T>\nstruct lazy_segment_tree{\n\tint N;\n\tvector<T> ST;\n\tvector<T> lazy;\n\tlazy_segment_tree(int n){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, -INF);\n\t\tlazy = vector<T>(N * 2 - 1, -1);\n\t}\n\tvoid eval(int i){\n\t\tif (lazy[i] != -1){\n\t\t\tif (i < N - 1){\n\t\t\t\tlazy[i * 2 + 1] = lazy[i];\n\t\t\t\tlazy[i * 2 + 2] = lazy[i];\n\t\t\t}\n\t\t\tST[i] = lazy[i];\n\t\t\tlazy[i] = -1;\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x, int i, int l, int r){\n\t\teval(i);\n\t\tif (R <= l || r <= L){\n\t\t\treturn;\n\t\t} else if (L <= l && r <= R){\n\t\t\tlazy[i] = x;\n\t\t\teval(i);\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\trange_update(L, R, x, i * 2 + 1, l, m);\n\t\t\trange_update(L, R, x, i * 2 + 2, m, r);\n\t\t\tST[i] = min(ST[i * 2 + 1], ST[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x){\n\t\treturn range_update(L, R, x, 0, 0, N);\n\t}\n\tT range_min(int L, int R, int i, int l, int r){\n\t\teval(i);\n\t\tif (R <= l || r <= L){\n\t\t\treturn INF;\n\t\t} else if (L <= l && r <= R){\n\t\t\treturn ST[i];\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn min(range_min(L, R, i * 2 + 1, l, m), range_min(L, R, i * 2 + 2, m, r));\n\t\t}\n\t}\n\tT range_min(int L, int R){\n\t\treturn range_min(L, R, 0, 0, N);\n\t}\n};\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  vector<tuple<int, int, int>> S(n);\n  for (int i = 0; i < n; i++){\n    int l, r, w;\n    cin >> l >> r >> w;\n    S[i] = make_tuple(w, l, r);\n  }\n  sort(S.begin(), S.end());\n  lazy_segment_tree<int> ST(m);\n  int ans = INF;\n  for (int i = 0; i < n; i++){\n    int w = get<0>(S[i]);\n    int l = get<1>(S[i]);\n    int r = get<2>(S[i]);\n    ST.range_update(l, r, w);\n    ans = min(ans, w - ST.range_min(1, m));\n  }\n  cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings",
        "trees",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Boring Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/93389",
    "editorial": "Take a look at the condition for a good subset.The major implication it\r\nmakes is that every point (even non-integer) of the segment should be\r\ncovered by at least one segment. If some point isn\u00e2\u0080\u0099t, then there is no\r\nway to jump across the gap it produces.At the same time, this condition\r\nis enough to have a path, since for every half-integer point (, and so\r\non) there exists a segment that covers it. So you can take that segment\r\nto go from to , then from to and so on.Thus, we are asked to select a\r\nsubset of segments that covers the entire segment in its union.The main\r\nprerequisite to the following solution is knowing the way to maintain\r\nthe union of segments. For now, I can tell you that there is a data\r\nstructure that allows you to add a segment, remove a segment and query\r\nthe length of the current union.Let\u00e2\u0080\u0099s continue with making some\r\nobservations on the cost function. If you fix the minimum and the\r\nmaximum value, you are free to select all segments that have their value\r\nin-between.That allows us to transition from selecting a subset of\r\nsegment to an interval, if you sort the segments by their weight.If you\r\nfix only minimum, then the required maximum should be as small as\r\npossible. However, if some value suffices as a maximum, then any value\r\ngreater than it also suffices (since it only adds extra segments to the\r\nsubset). This makes the function on the maximum monotonous.So the binary\r\nsearch applicable. You could iterate over the minimum and binary search\r\nthe maximum. However, it\u00e2\u0080\u0099s not too clear how to make a check function.\r\nYou would need to find a union of some interval of segments quickly. I\r\ndon\u00e2\u0080\u0099t really know a way to do that, so let\u00e2\u0080\u0099s try something\r\ndifferent.Instead, let\u00e2\u0080\u0099s forget about binary search and try to reach a\r\ntwo pointers solution. Let be the smallest possible maximum, given the\r\nfixed minimum is . We want to be greater than or equal than for two\r\npointers to be applicable.That condition indeed holds. Imagine if is\r\nsmaller than . So there exists some optimal subset for . Add all\r\nsegments with weight to that subset. That brings the minimum to .\r\nHowever, it doesn\u00e2\u0080\u0099t change the maximum, so is at least equal to , what\r\ncontradicts the assumption.Finally, the solution comes up to the\r\nfollowing. Iterate over the minimum value , while maintaining . When\r\ngoing from to , keep increasing the value of until the union of the\r\nsegments is exactly .Going from to and increasing the value of is\r\nactually removing some segments and adding some segments to the data\r\nstructure.The data structure that helps us with that is a segment tree.\r\nThe -th leaf of the tree holds the number of segments that cover the\r\ninterval . Add/remove segment makes it add/subtract on a range. The\r\nunion is full if the there are no intervals that are covered by zero\r\nsegments. Thus, let\u00e2\u0080\u0099s store the minimum of the subtree in every\r\nintermediate node. If the minimum on the tree is above zero, then the\r\ncurrent subset is good.Instead of applying two pointers on the values of\r\nthe segments, let\u00e2\u0080\u0099s apply them on the sorted segments themselves. That\r\nmakes moving the pointer exactly one update to the segtree.Overall\r\ncomplexity: .\r\n"
}