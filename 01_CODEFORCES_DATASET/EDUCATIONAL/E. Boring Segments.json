{"link": "https://codeforces.com//contest/1555/problem/E", "problemId": "1062144", "problem_idx": "E", "shortId": "1555E", "contest_number": "1555", "problem_submissions": {"F": [124306614, 124343856, 124312339, 124307563, 124318196, 124319806, 124318258, 124337936, 124326369, 124312719, 124312071, 124325220, 124322375, 124337491, 124327796, 124313538, 124320609, 124319069, 124334134], "E": [124292614, 124284546, 124290978, 124299668, 124299626, 124301534, 124305345, 124311168, 124315291, 124304878, 124305598, 124300363, 124304344, 124324832, 124306310, 124305064, 124305374], "C": [124284989, 124280595, 124283283, 124284609, 124285731, 124291694, 124283589, 124282860, 124292981, 124286855, 124287174, 124284102, 124289820, 124283315, 124290207, 124292792, 124290345], "D": [124282896, 124281706, 124287585, 124287694, 124291470, 124295363, 124329814, 124293642, 124293299, 124285216, 124284331, 124294215, 124292885, 124291338, 124294163, 124296113, 124299446, 124297892, 124294376], "B": [124280802, 124279957, 124281993, 124281520, 124282708, 124281869, 124281852, 124283175, 124289412, 124282989, 124282919, 124281809, 124286550, 124291562, 124286726, 124289852, 124285340], "A": [124279594, 124279557, 124279608, 124279611, 124279723, 124279607, 124279587, 124279711, 124282014, 124280166, 124279749, 124279696, 124279824, 124279602, 124281131, 124280445, 124279990]}, "name": "E. Boring Segments", "statement": "You are given n segments on a number line, numbered from 1 to n. The\r\ni-th segments covers all integer points from l_i to r_i and has a value\r\nw_i.You are asked to select a subset of these segments (possibly, all of\r\nthem). Once the subset is selected, it\u2019s possible to travel between two\r\ninteger points if there exists a selected segment that covers both of\r\nthem. A subset is good if it\u2019s possible to reach point m starting from\r\npoint 1 in arbitrary number of moves.The cost of the subset is the\r\ndifference between the maximum and the minimum values of segments in it.\r\nFind the minimum cost of a good subset.In every test there exists at\r\nleast one good subset.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\ntemplate <typename T>\nstruct lazy_segment_tree{\n\tint N;\n\tvector<T> ST;\n\tvector<T> lazy;\n\tlazy_segment_tree(int n){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, -INF);\n\t\tlazy = vector<T>(N * 2 - 1, -1);\n\t}\n\tvoid eval(int i){\n\t\tif (lazy[i] != -1){\n\t\t\tif (i < N - 1){\n\t\t\t\tlazy[i * 2 + 1] = lazy[i];\n\t\t\t\tlazy[i * 2 + 2] = lazy[i];\n\t\t\t}\n\t\t\tST[i] = lazy[i];\n\t\t\tlazy[i] = -1;\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x, int i, int l, int r){\n\t\teval(i);\n\t\tif (R <= l || r <= L){\n\t\t\treturn;\n\t\t} else if (L <= l && r <= R){\n\t\t\tlazy[i] = x;\n\t\t\teval(i);\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\trange_update(L, R, x, i * 2 + 1, l, m);\n\t\t\trange_update(L, R, x, i * 2 + 2, m, r);\n\t\t\tST[i] = min(ST[i * 2 + 1], ST[i * 2 + 2]);\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x){\n\t\treturn range_update(L, R, x, 0, 0, N);\n\t}\n\tT range_min(int L, int R, int i, int l, int r){\n\t\teval(i);\n\t\tif (R <= l || r <= L){\n\t\t\treturn INF;\n\t\t} else if (L <= l && r <= R){\n\t\t\treturn ST[i];\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn min(range_min(L, R, i * 2 + 1, l, m), range_min(L, R, i * 2 + 2, m, r));\n\t\t}\n\t}\n\tT range_min(int L, int R){\n\t\treturn range_min(L, R, 0, 0, N);\n\t}\n};\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m;\n  cin >> n >> m;\n  vector<tuple<int, int, int>> S(n);\n  for (int i = 0; i < n; i++){\n    int l, r, w;\n    cin >> l >> r >> w;\n    S[i] = make_tuple(w, l, r);\n  }\n  sort(S.begin(), S.end());\n  lazy_segment_tree<int> ST(m);\n  int ans = INF;\n  for (int i = 0; i < n; i++){\n    int w = get<0>(S[i]);\n    int l = get<1>(S[i]);\n    int r = get<2>(S[i]);\n    ST.range_update(l, r, w);\n    ans = min(ans, w - ST.range_min(1, m));\n  }\n  cout << ans << endl;\n}"], "input": "", "output": "", "tags": ["data structures", "sortings", "trees", "two pointers"], "dificulty": "2100", "interactive": false}