{
    "link": "https://codeforces.com//contest/1832/problem/D2",
    "problemId": "1919535",
    "problem_idx": "D2",
    "shortId": "1832D2",
    "contest_number": "1832",
    "problem_submissions": {
        "F": [
            205612816,
            205618187,
            205616065,
            205615360,
            205612997,
            205612699,
            205616615,
            205704621,
            205757584,
            205930525,
            205621852,
            205621757
        ],
        "E": [
            205588370,
            205576685,
            205587590,
            205562791,
            205578695,
            205581418,
            205576017,
            205588938,
            205587310,
            205585791,
            205594909,
            205587637,
            205568079,
            205590489,
            205592123,
            205595293,
            205581468,
            205598039,
            205585624
        ],
        "D1": [
            205582572,
            205571409,
            205573052,
            205565935,
            205571345,
            205569679,
            205567398,
            205577948,
            205578327,
            205578690,
            205578885,
            205573631,
            205580478,
            205584975,
            205584642,
            205576123,
            205577262,
            205587661,
            205590424,
            205578991,
            205594286
        ],
        "D2": [
            205582469,
            205571220,
            205573149,
            205573248,
            205571140,
            205587711,
            205587841,
            205578108,
            205578462,
            205578510,
            205604647,
            205579021,
            205580354,
            205589204,
            205584769,
            205584072,
            205587751,
            205599151,
            205586621,
            205599536
        ],
        "C": [
            205557102,
            205556400,
            205556488,
            205552484,
            205557070,
            205556143,
            205558460,
            205557880,
            205559387,
            205559279,
            205557942,
            205559043,
            205556434,
            205554797,
            205556994,
            205564356,
            205564037,
            205562522,
            205562917
        ],
        "B": [
            205552451,
            205550855,
            205551794,
            205549640,
            205552032,
            205552318,
            205551056,
            205550768,
            205554849,
            205551853,
            205553247,
            205555210,
            205553102,
            205550776,
            205552302,
            205556686,
            205557181,
            205553564,
            205556320
        ],
        "A": [
            205549496,
            205548656,
            205548697,
            205548635,
            205548771,
            205548615,
            205548617,
            205548590,
            205549420,
            205548691,
            205549006,
            205548793,
            205548840,
            205548603,
            205548831,
            205550263,
            205548997,
            205555130,
            205552258
        ]
    },
    "name": "D2. Red-Blue Operations  Hard Version ",
    "statement": ".You are given an array, consisting of n integers. Initially, all\r\nelements are red.You can apply the following operation to the array\r\nmultiple times. During the i-th operation, you select an element of the\r\narray; then: if the element is red, it increases by i and becomes blue;\r\nif the element is blue, it decreases by i and becomes red. The\r\noperations are numbered from 1, i. e. during the first operation some\r\nelement is changed by 1 and so on.You are asked q queries of the\r\nfollowing form: given an integer k, what can the largest minimum in the\r\narray be if you apply k operations to it? Note that the operations don’t\r\naffect the array between queries, all queries are asked on the initial\r\narray a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 1E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector<i64> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::sort(a.begin(), a.end());\n    \n    std::vector<i64> f(n + 1, inf);\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = std::min(f[i] + 1, a[i] + 1);\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    while (q--) {\n        i64 k;\n        std::cin >> k;\n        \n        if (k < n) {\n            std::cout << std::min(f[k], a[k]) << \" \";\n        } else {\n            i64 ans;\n            i64 s = sum;\n            if ((k - n) % 2 == 0) {\n                ans = f[n] + k - n;\n                s += 1LL * n * (k + k - n + 1) / 2 - (k - n) / 2;\n            } else {\n                ans = std::min(a[n - 1], f[n - 1] + k - (n - 1));\n                s += 1LL * (n - 1) * (k + k - n + 2) / 2 - (k - n + 1) / 2;\n            }\n            ans = std::min(1LL * ans, s >= 0 ? s / n : (s - n + 1) / n);\n            std::cout << ans << \" \";\n        }\n    }\n    std::cout << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D2. Red-Blue Operations  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116454",
    "editorial": "Read the editorial to the easy version to get the general idea of the\r\nsolution.Now, we should only optimize the calculations.First, the\r\nsorting can obviously be done beforehand. Now we want to get the minimum\r\nand the sum after applying the last increase operations. Consider and ,\r\nthe other cases are similar. The minimum is that: . Notice how the\r\nsecond part doesnât depend on and precalculate it.You can calculate\r\nprefix minimum array over .This surely helps with the case of . The\r\nresulting minimum is (since is sorted, the first element after the\r\nchanged prefix is the smallest).For , the minimum is .For , the minimum\r\nis .The sum is similar: . As easy to precalculate.The rest is the\r\nsame.Overall complexity: .\r\n",
    "hint": []
}