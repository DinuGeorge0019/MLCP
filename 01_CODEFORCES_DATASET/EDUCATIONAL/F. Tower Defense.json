{"link": "https://codeforces.com//contest/1651/problem/F", "problemId": "1324101", "problem_idx": "F", "shortId": "1651F", "contest_number": "1651", "problem_submissions": {"C": [149173723, 149105792, 149117381, 149152549, 149106514, 149108421, 149108464, 149108635, 149109429, 149110791, 149109777, 149108515, 149109773, 149111699, 149114619, 149106949, 149113559, 149129766], "F": [149161364, 149158834, 149161121, 149123303, 149175934, 149179491, 191725924, 149575413], "E": [149139170, 149130164, 149147455, 149137360, 149140976, 149145909, 149141908, 149139460, 149147248, 149148678, 149156290, 149148881, 149154274, 149143485, 149163314, 149138047, 149159145], "D": [149127559, 149163309, 149150118, 149115060, 149119439, 149116468, 149116651, 149118386, 149120734, 149121740, 149119776, 149192081, 149191968, 149191879, 149191841, 149191815, 149191600, 149191163, 149191124, 149128435, 149129157, 149129578, 149116059, 149145989, 149116064], "B": [149098208, 149096317, 149154308, 149094973, 149099387, 149095439, 149099190, 149096388, 149097486, 149098725, 149098039, 149097903, 149102336, 149093030, 149096020, 149099865, 149101390], "A": [149092351, 149091868, 149155144, 149091621, 149091628, 149091655, 149091686, 149091765, 149091751, 149092326, 149091819, 149092231, 149094932, 149091603, 149091630, 149091669, 149092684]}, "name": "F. Tower Defense", "statement": "Monocarp is playing a tower defense game. A level in the game can be\r\nrepresented as an OX axis, where each lattice point from 1 to n contains\r\na tower in it.The tower in the i-th point has c_i mana capacity and r_i\r\nmana regeneration rate. In the beginning, before the 0-th second, each\r\ntower has full mana. If, at the end of some second, the i-th tower has x\r\nmana, then it becomes\r\nmathit{min}(x + r_i, c_i) mana for the next second.There are q monsters\r\nspawning on a level. The j-th monster spawns at point 1 at the beginning\r\nof t_j-th second, and it has h_j health. Every monster is moving 1 point\r\nper second in the direction of increasing coordinate.When a monster\r\npasses the tower, the tower deals\r\nmathit{min}(H, M) damage to it, where H is the current health of the\r\nmonster and M is the current mana amount of the tower. This amount gets\r\nsubtracted from both monster\u2019s health and tower\u2019s mana.Unfortunately,\r\nsometimes some monsters can pass all n towers and remain alive. Monocarp\r\nwants to know what will be the total health of the monsters after they\r\npass all towers.\r\n", "solutions": ["#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 200001; \nconst int K = 100;\nconst int SZ = 262144;\n\nll sum[2*SZ][K];\n\nll qsum(int l, int r, int T) {\n    ll resL = 0, resR = 0; r++;\n    for (l += SZ, r += SZ; l < r; l >>= 1, r >>= 1) {\n        if (l&1) resL = resL+sum[l++][T];\n        if (r&1) resR = sum[--r][T]+resR;\n    }\n    return resL + resR;\n}\n\n\nint flar(int l, int r, int T, ll H, int L = 0, int R = SZ-1, int ind = 1) {\n    //dbg(l, r, T, H, L, R, ind, sum[ind][T]);\n    if (L > r || l > R) return -1;\n    if (L == R) {\n        return H <= sum[ind][T] ? L : -1;\n    }\n    int M = (L+R)/2;\n    if (sum[ind*2][T] >= H) {\n        int val = flar(l, r, T, H, L, M, ind*2);\n        if (val != -1) return val;\n    } \n    return flar(l, r, T, H - sum[ind*2][T], M+1, R, ind*2+1);\n}\n\nvoid solve() {\n    int N; cin >> N;\n    ll C[N], R[N];\n    F0R(i, N) cin >> C[i] >> R[i];\n    F0R(i, N) {\n        F0R(j, K) {\n            sum[i+SZ][j] = min(C[i], R[i] * j);\n        }\n    }\n    FORd(i, 1, SZ) {\n        F0R(j, K) {\n            sum[i][j] = sum[2*i][j] + sum[2*i+1][j];\n        }\n    }\n\n    set<pair<int, pl>> ev;\n    F0R(i, N) {\n        ev.ins({i, {-MX, C[i]}});\n    }\n\n    ll H[MX];\n    F0R(i, MX) H[i] = 0;\n    int Q; cin >> Q;\n    while(Q--) {\n        int T; cin >> T;\n        cin >> H[T];\n    }\n\n    ll ans = 0;\n    F0R(t, MX) {\n        int p = 0;\n        while (!ev.empty()) {\n            pair<int, pl> cur = *ev.begin();\n            if (t - cur.s.f >= K) {\n                ll gap = t - cur.s.f;\n                FOR(i, p, cur.f) {\n                    ll V = min(R[i] * gap, C[i]);\n                    if (V >= H[t]) {\n                        ev.ins({i, {t, V - H[t]}});\n                        goto done;\n                    }\n                    H[t] -= V;\n                }\n            } else if (p < cur.f) {\n                ll S = qsum(p, cur.f - 1, t - cur.s.f);\n                if (S < H[t]) {\n                    H[t] -= S;\n                } else {\n                    int pos = flar(p, cur.f - 1, t - cur.s.f, H[t] + qsum(0, p-1, t - cur.s.f));\n                    if (p < pos) H[t] -= qsum(p, pos - 1, t - cur.s.f);\n                    ll V = min(R[pos] * (t - cur.s.f), C[pos]);\n                    ev.ins({pos, {t, V - H[t]}});\n                    goto done;\n                }\n\n            }\n            ll V = min(cur.s.s + R[cur.f] * (t - cur.s.f), C[cur.f]);\n            if (V >= H[t]) {\n                ev.erase(ev.begin());\n                cur.s.s = V - H[t];\n                cur.s.f = t;\n                ev.ins(cur);\n                goto done;\n            }\n            H[t] -= V;\n            p = cur.f + 1;\n            ev.erase(ev.begin());\n\n        }\n        ans += H[t];\n        //dbg(t, H[t]);\n        ev.ins({N-1, {t, 0}});\n        done:\n        ;\n        /*if (t < 11) {\n            dbg(t, ev);\n        }*/\n    }\n\n    cout << ans << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures"], "dificulty": "3000", "interactive": false}