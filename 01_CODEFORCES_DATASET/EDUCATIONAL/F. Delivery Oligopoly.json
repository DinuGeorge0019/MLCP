{"link": "https://codeforces.com//contest/1155/problem/F", "problemId": "334466", "problem_idx": "F", "shortId": "1155F", "contest_number": "1155", "problem_submissions": {"F": [53147227, 53157176, 53156900, 53156084, 53154052, 53160034, 53156325, 53151832, 53154755, 53148688, 53161959, 53262750, 53737446, 53737379, 53175185], "E": [53135994, 53143627, 53147598, 53158466, 53136989, 53158165, 53136136, 53151523, 53138725, 53138756, 53143870, 53141750, 53144225, 53141600, 53144263, 53142970, 53144678, 53143027, 53146492, 53139061], "D": [53132284, 53136375, 53137845, 53140433, 53131955, 53144376, 53152771, 53133770, 53130242, 53133856, 53135466, 53137404, 53132457, 53137383, 53135331, 53136120, 53161942, 53136545, 53137490, 53137142], "C": [53130521, 53133027, 53132212, 53133949, 53152978, 53158707, 53154112, 53130838, 53134553, 53131325, 53130045, 53131332, 53135487, 53132186, 53132107, 53133338, 53132645, 53132555, 53132260], "B": [53127872, 53130197, 53129680, 53129662, 53128390, 53156310, 53155054, 53129416, 53131929, 53128726, 53127750, 53128694, 53130002, 53129606, 53130017, 53128669, 53130637, 53130008, 53131121], "A": [53127037, 53127563, 53127047, 53127010, 53127272, 53156874, 53155461, 53127028, 53127341, 53127201, 53128346, 53127115, 53128140, 53127708, 53127365, 53130750, 53128472, 53127451, 53127014]}, "name": "F. Delivery Oligopoly", "statement": "The whole delivery market of Berland is controlled by two rival\r\ncompanies: BerEx and BerPS. They both provide fast and reliable delivery\r\nservices across all the cities of Berland.The map of Berland can be\r\nrepresented as an graph. The cities are vertices and the roads are edges\r\nbetween them. Each pair of cities has no more than one road between\r\nthem. Each road connects different cities.BerEx and BerPS are so\r\ncompetitive that for each pair of cities (v, u) they have set up their\r\npaths from v to u in such a way that . It is guaranteed that it was\r\npossible.Now Berland government decided to cut down the road maintenance\r\ncost by abandoning some roads. Obviously, they want to maintain as\r\nlittle roads as possible. However, they don\u2019t want to break the entire\r\ndelivery system. So BerEx and BerPS should still be able to have their\r\npaths between every pair of cities non-intersecting.What is the minimal\r\nnumber of roads Berland government can maintain?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = 100100;\nconst int N = 15;\nconst int M = (1 << 14) + 7;\nbool g[N][N];\nint n, m;\nint edgesToMask[N][M];\nvector<int> pathInMask[M][N][N];\nint dp[M];\nint par[M][3];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v][u] = g[u][v] = 1;\n\t}\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int mask = 0; mask < (1 << n); mask++)\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (((mask >> u) & 1) == 0) continue;\n\t\t\t\tif (g[v][u])\n\t\t\t\t\tedgesToMask[v][mask]++;\n\t\t\t}\n\tfor (int v = 0; v < n; v++)\n\t\tpathInMask[1 << v][v][v].push_back(v);\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t//cerr << mask << endl;\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (pathInMask[mask][v][u].empty()) continue;\n\t\t\t\tfor (int w = 0; w < n; w++) {\n\t\t\t\t\tif ((mask >> w) & 1) continue;\n\t\t\t\t\tif (!g[u][w]) continue;\n\t\t\t\t\tint nmask = mask | (1 << w);\n\t\t\t\t\tif (!pathInMask[nmask][v][w].empty()) continue;\n\t\t\t\t\tpathInMask[nmask][v][w] = pathInMask[mask][v][u];\n\t\t\t\t\tpathInMask[nmask][v][w].push_back(w);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfor (int mask = 0; mask < (1 << n); mask++)\n\t\tdp[mask] = INF;\n\tdp[1] = 0;\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t//cerr << mask << endl;\n\t\tif (dp[mask] == INF) continue;\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif ((mask >> v) & 1) continue;\n\t\t\tif (edgesToMask[v][mask] >= 2) {\n\t\t\t\tint nmask = mask | (1 << v);\n\t\t\t\tif (dp[nmask] > dp[mask] + 2) {\n\t\t\t\t\tdp[nmask] = dp[mask] + 2;\n\t\t\t\t\tpar[nmask][0] = mask;\n\t\t\t\t\tpar[nmask][1] = par[nmask][2] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (edgesToMask[v][mask] == 0) continue;\n\t\t\tfor (int u = v + 1; u < n; u++) {\n\t\t\t\tif ((mask >> u) & 1) continue;\n\t\t\t\tif (edgesToMask[u][mask] == 0) continue;\n\t\t\t\tint all = ((1 << n) - 1) ^ mask ^ (1 << v) ^ (1 << u);\n\t\t\t\tfor (int smask = all;; smask = (smask - 1) & all) {\n\t\t\t\t\tint nmask = smask | (1 << v) | (1 << u);\n\t\t\t\t\tif (!pathInMask[nmask][v][u].empty()) {\n\t\t\t\t\t\tint w = dp[mask] + (int)pathInMask[nmask][v][u].size() + 1;\n\t\t\t\t\t\tif (w < dp[mask | nmask]) {\n\t\t\t\t\t\t\tdp[mask | nmask] = w;\n\t\t\t\t\t\t\tpar[mask | nmask][0] = mask;\n\t\t\t\t\t\t\tpar[mask | nmask][1] = v;\n\t\t\t\t\t\t\tpar[mask | nmask][2] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (smask == 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", dp[(1 << n) - 1]);\n//\tfflush(stdout);\n\tint mask = (1 << n) - 1;\n\twhile(mask > 1) {\n\t\t//cerr << mask << endl;\n\t\t//return 0;\n\t\tint nmask = par[mask][0];\n\t\tint v = par[mask][1];\n\t\tint u = par[mask][2];\n\t\tif (v == u) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int z = 0; cnt < 2 && z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[v][z]) continue;\n\t\t\t\tcnt++;\n\t\t\t\tprintf(\"%d %d\\n\", v + 1, z + 1);\n\t\t\t}\n\t\t\tif (cnt != 2) throw;\n\t\t} else {\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[v][z]) continue;\n\t\t\t\tprintf(\"%d %d\\n\", v + 1, z + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[u][z]) continue;\n\t\t\t\tprintf(\"%d %d\\n\", u + 1, z + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int> z = pathInMask[mask ^ nmask][v][u];\n\t\t\tfor (int i = 0; i < (int)z.size() - 1; i++) {\n\t\t\t\tprintf(\"%d %d\\n\", z[i] + 1, z[i + 1] + 1);\n\t\t\t}\n\t\t}\n\t\tmask = nmask;\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "graphs"], "dificulty": "2800", "interactive": false}