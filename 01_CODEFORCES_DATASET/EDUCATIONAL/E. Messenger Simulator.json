{"link": "https://codeforces.com//contest/1288/problem/E", "problemId": "516091", "problem_idx": "E", "shortId": "1288E", "contest_number": "1288", "problem_submissions": {"F": [68819552, 68808531, 68807458, 70134760, 68807017, 68813769, 68812618, 102301682, 68810583, 68807992, 68818667, 68814476, 68814904, 148920535, 69079454, 69075918, 69087920, 68817577, 68867890, 68867024], "E": [68789304, 68799414, 70134713, 68794162, 68793417, 68796419, 68796122, 68798077, 68796394, 68805226, 68789819, 68793916, 68792563, 68828678, 68828570, 68828548, 68828508, 68828405, 68825187, 68824325, 68795790, 68796556, 68795660, 68795978, 68794855, 68795573, 68798172, 68797193], "D": [68783658, 68790087, 70134685, 68790433, 68784769, 68786894, 68787811, 68794372, 68789589, 68795124, 68786983, 68787137, 68787922, 68782622, 68788267, 68791758, 68788474, 68787396, 68786555, 69711971, 69711762, 68788055, 68792205], "C": [68780932, 68782036, 70134661, 68786063, 68780437, 68783287, 68784254, 68819757, 68791290, 86478943, 68783597, 68785836, 68782781, 68782659, 68783955, 68780494, 68784922, 68782777, 68784716, 68784512, 68784035, 68782534, 68783571], "B": [68779970, 68780416, 70134627, 68782676, 68781485, 68781383, 68781464, 68781107, 68781318, 68782464, 68780637, 68781282, 68782023, 68779901, 68781253, 68780876, 68782711, 68780458, 68781060, 68780498, 68781762], "A": [68779722, 68779812, 70134580, 68780111, 68782502, 68779822, 68779930, 68779750, 68780171, 68781059, 68779815, 68780062, 68780122, 68779758, 68779835, 68779859, 68779825, 68779886, 68780036, 68779829, 68780004]}, "name": "E. Messenger Simulator", "statement": "Polycarp is a frequent user of the very popular messenger. He\u2019s chatting\r\nwith his friends all the time. He has n friends, numbered from 1 to\r\nn.Recall that a permutation of size n is an array of size n such that\r\neach integer from 1 to n occurs exactly once in this array.So his recent\r\nchat list can be represented with a permutation p of size n. p_1 is the\r\nmost recent friend Polycarp talked to, p_2 is the second most recent and\r\nso on.Initially, Polycarp\u2019s recent chat list p looks like 1, 2,\r\ndots, n (in other words, it is an identity permutation).After that he\r\nreceives m messages, the j-th message comes from the friend a_j. And\r\nthat causes friend a_j to move to the first position in a permutation,\r\nshifting everyone between the first position and the current position of\r\na_j by 1. Note that if the friend a_j is in the first position already\r\nthen nothing happens.For example, let the recent chat list be p = [4, 1,\r\n5, 3, 2]: if he gets messaged by friend 3, then p becomes [3, 4, 1, 5,\r\n2]; if he gets messaged by friend 4, then p doesn\u2019t change [4, 1, 5, 3,\r\n2]; if he gets messaged by friend 2, then p becomes [2, 4, 1, 5, 3]. For\r\neach friend consider all position he has been at in the beginning and\r\nafter receiving each message. Polycarp wants to know what were the\r\nminimum and the maximum positions.\r\n", "solutions": ["//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 _y0\n#define kill _kill\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll btc = 30;\nconst ld eps = 1e-10;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 1e9 + 7; //(int)(1e9 + 7); //998244353;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n//constants\nconst int M = (int)(6e5 + 239);\nconst int N = (int)(1e3 + 239);\nconst int L = 20;\nconst int T = (1 << 20) + 239;\nconst int B = 500;\nconst int X = 8;\n\nint ans1[M], ans2[M], n, m, a[M], pos[M];\n\nint tree[M];\n\nvoid add(int i, int x)\n{\n    for (; i < n + m; i |= i + 1)\n        tree[i] += x;\n}\n\nint gett(int i)\n{\n    int ans = 0;\n    for (; i >= 0; i = (i & (i + 1)) - 1)\n        ans += tree[i];\n    return ans;\n}\n\nint32_t main()\n{\n#ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        ans1[i] = i;\n        ans2[i] = i;\n        pos[i] = i + m;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        cin >> a[i];\n        a[i]--;\n        ans1[a[i]] = 0;\n    }\n    for (int i = 0; i < n; i++)\n        add(pos[i], 1);\n    for (int i = 0; i < m; i++)\n    {\n        int p = a[i];\n        ans2[p] = max(ans2[p], gett(pos[p]) - 1);\n        add(pos[p], -1);\n        pos[p] = m - i - 1;\n        add(pos[p], 1);\n    }\n    for (int i = 0; i < n; i++)\n        ans2[i] = max(ans2[i], gett(pos[i]) - 1);\n    for (int i = 0; i < n; i++)\n        cout << ans1[i] + 1 << \" \" << ans2[i] + 1 << \"\\n\";\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2000", "interactive": false}