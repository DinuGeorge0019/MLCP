{"link": "https://codeforces.com//contest/1221/problem/G", "problemId": "415613", "problem_idx": "G", "shortId": "1221G", "contest_number": "1221", "problem_submissions": {"G": [60878901, 60954325, 60892510, 60889777, 60939440, 60957169, 60954037, 60954018, 60887759, 60892512, 61066187, 60888304, 60953665, 60884074], "F": [60872429, 60906430, 60877026, 60879328, 60873795, 60880496, 60880041, 60882317, 60876205, 60881638, 60879016, 60884701, 60883109, 60876230, 60885368, 60884882, 60888631, 60877275], "E": [60865427, 60906424, 60870455, 60872355, 60881944, 60867813, 60873346, 60871774, 60882236, 60957159, 60869840, 60865430, 60870324, 60874697, 60871945, 60886034, 60875073, 60873664, 60883200, 60875153, 60886105, 60887173], "D": [60858978, 60906413, 60858963, 60862133, 60857697, 60858483, 60858390, 60860167, 60862000, 60957149, 60859058, 60857548, 60865511, 60860504, 60857388, 60865183, 60887076, 60866989, 60863673, 60861492, 60857971, 60867806, 60885376], "C": [60854799, 60906405, 60854087, 60858148, 60855694, 60855339, 60856078, 60857408, 60859538, 60957138, 60855511, 60854166, 60860646, 60858018, 60854647, 60856215, 60857135, 60857947, 60855000, 60855230, 60864597, 60884317], "B": [60853702, 60906395, 60853284, 60856858, 60853405, 60869020, 60854977, 60855791, 60854474, 60957129, 60854297, 60853117, 60859658, 60856090, 60853528, 60854286, 60855985, 60856982, 60854601, 60853843, 60862970, 60883738], "A": [60853175, 60906382, 60852746, 60855419, 60852846, 60852969, 60852978, 60853994, 60853299, 60957119, 60852836, 60852764, 60858768, 60853799, 60852813, 60853187, 60854280, 60853549, 60853275, 60852850, 60861325, 60883303]}, "name": "G. Graph And Numbers", "statement": "You are given an undirected graph with n vertices and m edges. You have\r\nto write a number on each vertex of this graph, each number should be\r\neither 0 or 1. After that, you write a number on each edge equal to the\r\nsum of numbers on vertices incident to that edge.You have to choose the\r\nnumbers you will write on the vertices so that there is at least one\r\nedge with 0 written on it, at least one edge with 1 and at least one\r\nedge with 2. How many ways are there to do it? Two ways to choose\r\nnumbers are different if there exists at least one vertex which has\r\ndifferent numbers written on it in these two ways.\r\n", "solutions": ["#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, m;\nconst int maxN = 42;\nvector < int > g[maxN];\nint deg[maxN];\nbool ed[maxN][maxN];\nll f() {\n    return (1LL << n);\n}\nconst int maxK = 20;\nbool bad[(1 << maxK) + 10];\nint from[(1 << maxK) + 10];\nbool other_bad[(1 << maxK) + 10];\nint cnt[(1 << maxK) + 10];\nll indep() {\n    int half = n / 2;\n    for (int i = 0; i < half; i++) {\n        for (int j = i + 1; j < half; j++) {\n            if (ed[i][j]) {\n                bad[(1 << i) + (1 << j)] = true;\n            }\n        }\n        for (int j = half; j < n; j++) {\n            if (ed[i][j]) {\n                from[(1 << i)] |= (1 << (j - half));\n            }\n        }\n    }\n    for (int bit = 0; bit < half; bit++) {\n        for (int mask = 0; mask < (1 << half); mask++) {\n            if (mask & (1 << bit)) {\n                bad[mask] |= bad[mask ^ (1 << bit)];\n                from[mask] |= from[mask ^ (1 << bit)];\n            }\n        }\n    }\n    int other_half = n - half;\n    for (int i = half; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (ed[i][j]) {\n                other_bad[(1 << (i - half)) + (1 << (j - half))] = true;\n            }\n        }\n    }\n    for (int bit = 0; bit < other_half; bit++) {\n        for (int mask = 0; mask < (1 << other_half); mask++) {\n            if (mask & (1 << bit)) {\n                other_bad[mask] |= other_bad[mask ^ (1 << bit)];\n            }\n        }\n    }\n    for (int mask = 0; mask < (1 << other_half); mask++) {\n        if (!other_bad[mask]) cnt[mask] = 1;\n    }\n    for (int bit = 0; bit < other_half; bit++) {\n        for (int mask = 0; mask < (1 << other_half); mask++) {\n            if (mask & (1 << bit)) {\n                cnt[mask] += cnt[mask ^ (1 << bit)];\n            }\n        }\n    }\n    int all = (1 << other_half) - 1;\n    ll tot = 0;\n    for (int my_mask = 0; my_mask < (1 << half); my_mask++) {\n        if (bad[my_mask]) continue;\n        int bad_guys = from[my_mask];\n        int good_guys = all ^ bad_guys;\n        tot += cnt[good_guys];\n    }\n    return tot;\n}\nbool used[maxN];\nvoid dfs(int v) {\n    used[v] = true;\n    for (int to : g[v]) {\n        if (used[to]) continue;\n        dfs(to);\n    }\n}\nll ones() {\n    // just number of conn\n    int tot = 0;\n    memset(used, 0, sizeof used);\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            dfs(i);\n            tot++;\n        }\n    }\n    return (1LL << tot);\n}\nll f01() {\n    int tot = 0;\n    for (int i = 0; i < n; i++) if (deg[i] == 0) tot++;\n    return (1LL << tot);\n}\nint clr[maxN];\nbool ALL_OK = true;\nvoid other_dfs(int v) {\n    used[v] = true;\n    for (int to : g[v]) {\n        if (used[to]) {\n            if (clr[to] != clr[v] ^ 1) {\n                ALL_OK = false;\n                return;\n            }\n        }\n        else {\n            clr[to] = clr[v] ^ 1;\n            other_dfs(to);\n        }\n    }\n}\nll f02() {\n    int tot = 0;\n    memset(used, 0, sizeof used);\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            tot++;\n            other_dfs(i);\n        }\n    }\n    if (!ALL_OK) return 0;\n    return (1LL << tot);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    if (m == 0) {\n        cout << 0;\n        return 0;\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        deg[a]++;\n        deg[b]++;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        ed[a][b] = ed[b][a] = true;\n    }\n    ll x = f();\n    ll y = indep();\n    ll z = ones();\n    ll t = f01();\n    ll q = f02();\n    cout << x - 2 * y - z + 2 * t + q;\n\n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "combinatorics", "dp", "meet-in-the-middle"], "dificulty": "2900", "interactive": false}