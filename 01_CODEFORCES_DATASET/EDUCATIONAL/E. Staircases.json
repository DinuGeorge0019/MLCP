{
    "link": "https://codeforces.com//contest/1598/problem/E",
    "problemId": "1138074",
    "problem_idx": "E",
    "shortId": "1598E",
    "contest_number": "1598",
    "problem_submissions": {
        "G": [
            131442050,
            131445550,
            131474021,
            131733851,
            189236477,
            131533150,
            131521436,
            131521173,
            131520806,
            131458159
        ],
        "F": [
            131413919,
            131426175,
            131419948,
            131424974,
            131423465,
            131425512,
            131426044,
            131429617,
            131434101,
            131424856,
            131429061,
            135925566,
            131432789,
            131436462,
            131426160,
            131433379,
            131432739,
            131442015,
            131426352,
            131438575
        ],
        "E": [
            131409216,
            131417508,
            131411965,
            131416590,
            131414689,
            131417539,
            131419673,
            131417908,
            131417850,
            131413609,
            131419666,
            131418620,
            131426224,
            131434401,
            131422338,
            131425095,
            131423673,
            131432059,
            131428300
        ],
        "D": [
            131405446,
            131408232,
            131403803,
            131406730,
            131406693,
            131408831,
            131409679,
            131411498,
            131409766,
            131431099,
            131412818,
            131410917,
            131408763,
            131411240,
            131414979,
            131418536,
            131414491,
            131405913,
            131414013,
            131411546
        ],
        "C": [
            131402318,
            131402805,
            131401746,
            131403276,
            131404307,
            131403297,
            131407011,
            131405600,
            131402882,
            131404574,
            131406244,
            131405518,
            131403235,
            131406335,
            131403809,
            131404263,
            131402426,
            131410937,
            131406878
        ],
        "B": [
            131399659,
            131401435,
            131400062,
            131400441,
            131401570,
            131401020,
            131401164,
            131404218,
            131400433,
            131402267,
            131404703,
            131402822,
            131405775,
            131403060,
            131401809,
            131401389,
            131400640,
            131406015,
            131403932
        ],
        "A": [
            131398034,
            131398273,
            131398102,
            131398196,
            131398135,
            131398297,
            131398147,
            131400227,
            131399230,
            131398720,
            131400611,
            131612251,
            131398353,
            131399540,
            131399744,
            131398269,
            131398178,
            131398070,
            131401090,
            131399096
        ]
    },
    "name": "E. Staircases",
    "statement": "You are given a matrix, consisting of n rows and m columns. The rows are\r\nnumbered top to bottom, the columns are numbered left to right.Each cell\r\nof the matrix can be either free or locked.Let’s call a path in the\r\nmatrix if it: starts and ends in the free cell; visits only free cells;\r\nhas one of the two following structures: the second cell is 1 to the\r\nright from the first one, the third cell is 1 to the bottom from the\r\nsecond one, the fourth cell is 1 to the right from the third one, and so\r\non; the second cell is 1 to the bottom from the first one, the third\r\ncell is 1 to the right from the second one, the fourth cell is 1 to the\r\nbottom from the third one, and so on. In particular, a path, consisting\r\nof a single cell, is considered to be a staircase.Here are some examples\r\nof staircases: Initially all the cells of the matrix are .You have to\r\nprocess q queries, each of them flips the state of a single cell. So, if\r\na cell is currently free, it makes it locked, and if a cell is currently\r\nlocked, it makes it free.Print the number of different staircases after\r\neach query. Two staircases are considered different if there exists such\r\na cell that appears in one path and doesn’t appear in the other path.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 10.10.2021 12:18:01       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      ans += 1;\n      { // right\n        int nr = m - 1 - j;\n        int nd = n - 1 - i;\n        nr = min(nr, nd + 1);\n        nd = min(nd, nr);\n        ans += nr + nd;\n      }\n      { // down\n        int nr = m - 1 - j;\n        int nd = n - 1 - i;\n        nd = min(nd, nr + 1);\n        nr = min(nr, nd);\n        ans += nr + nd;\n      }\n    }\n  }\n  vector<vector<int>> a(n, vector<int>(m));\n  auto Go = [&](int i, int j, int di, int dj) {\n    int cc = 0;\n    while (true) {\n      i += di;\n      j += dj;\n      if (i < 0 || j < 0 || i >= n || j >= m || a[i][j] == 1) {\n        break;\n      }\n      cc += 1;\n      swap(di, dj);\n    }\n    return cc;\n  };\n  while (q--) {\n    int i, j;\n    cin >> i >> j;\n    --i; --j;\n    {\n      int x = Go(i, j, -1, 0);\n      int y = Go(i, j, 0, 1);\n      ans += (a[i][j] == 1 ? 1 : -1) * ((x + 1) * (y + 1) - 1);\n    }\n    {\n      int x = Go(i, j, 0, -1);\n      int y = Go(i, j, 1, 0);\n      ans += (a[i][j] == 1 ? 1 : -1) * ((x + 1) * (y + 1) - 1);\n    }\n    ans += (a[i][j] == 1 ? 1 : -1);\n    a[i][j] ^= 1;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "data structures",
        "dfs and similar",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Staircases.json",
    "editorial_link": "https://codeforces.com//blog/entry/95890",
    "editorial": "The solution consist of two main parts: calculate the initial number of\r\nstaircases and recalculate the number of staircases on query.The\r\nconstraints were pretty loose, so weâll do the first part in and the\r\nsecond part in per query.However, itâs worth mentioning that faster is\r\npossible. The first part can surely be done in and can probably be done\r\nin . The second part can be done in per query.Itâs important to notice\r\nis that the only staircase that satisfy the requirements for both types\r\nis the staircase that consists of a single cell. Thus, staircases of\r\nboth types can be calculated almost separately.Letâs define \"base\"\r\nstaircases as the staircases that canât be prolonged further in any\r\ndirection. There are of them on the grid.If a staircase consists of at\r\nleast two cells, itâs a part of exactly one staircase. At the same time,\r\nevery segment of a staircase is a valid staircase by itself.Thus, the\r\nmain idea of calculating the initial answer is the following. Isolate\r\neach staircase and determine its length (possibly, in ). Add (the number\r\nof segments of length at least ) to the answer. Add extra one cell\r\nstaircases afterwards.If you draw the staircases on the grid, you can\r\neasily determine their starting cell. The staircases, that start by\r\ngoing one cell to the right, start from the first row. The staircases,\r\nthat start by going one cell to the bottom, start from the first column.\r\nNotice that both types can start from cell .The updates can be handled\r\nthe following way. The answer always changes by the number of staircases\r\nthat pass through cell (if you ignore its state). If the cell becomes\r\nfree, then these staircases are added to the answer. Otherwise, they are\r\nsubtracted from it.That can be calculated for two cases as well. Go\r\nfirst down, then right, as far as possible. Let it be steps. Go first\r\nleft, then up, as far as possible. Let it be steps. Then staircases are\r\nadded to the answer. Then change the order of steps in both directions\r\nto calculate the other type of staircases. Beware of one cell staircases\r\nagain.To achieve for precalc, you can calculate the length of each\r\nstaircase with a formula. To achieve per query, you can first enumerate\r\ncells in each staircase separately, then maintain the set of segments of\r\nadjacent free cells in it.\r\n",
    "hint": []
}