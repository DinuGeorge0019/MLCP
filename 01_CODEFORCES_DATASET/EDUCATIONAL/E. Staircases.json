{"link": "https://codeforces.com//contest/1598/problem/E", "problemId": "1138074", "problem_idx": "E", "shortId": "1598E", "contest_number": "1598", "problem_submissions": {"G": [131442050, 131445550, 131474021, 131733851, 189236477, 131533150, 131521436, 131521173, 131520806, 131458159], "F": [131413919, 131426175, 131419948, 131424974, 131423465, 131425512, 131426044, 131429617, 131434101, 131424856, 131429061, 135925566, 131432789, 131436462, 131426160, 131433379, 131432739, 131442015, 131426352, 131438575], "E": [131409216, 131417508, 131411965, 131416590, 131414689, 131417539, 131419673, 131417908, 131417850, 131413609, 131419666, 131418620, 131426224, 131434401, 131422338, 131425095, 131423673, 131432059, 131428300], "D": [131405446, 131408232, 131403803, 131406730, 131406693, 131408831, 131409679, 131411498, 131409766, 131431099, 131412818, 131410917, 131408763, 131411240, 131414979, 131418536, 131414491, 131405913, 131414013, 131411546], "C": [131402318, 131402805, 131401746, 131403276, 131404307, 131403297, 131407011, 131405600, 131402882, 131404574, 131406244, 131405518, 131403235, 131406335, 131403809, 131404263, 131402426, 131410937, 131406878], "B": [131399659, 131401435, 131400062, 131400441, 131401570, 131401020, 131401164, 131404218, 131400433, 131402267, 131404703, 131402822, 131405775, 131403060, 131401809, 131401389, 131400640, 131406015, 131403932], "A": [131398034, 131398273, 131398102, 131398196, 131398135, 131398297, 131398147, 131400227, 131399230, 131398720, 131400611, 131612251, 131398353, 131399540, 131399744, 131398269, 131398178, 131398070, 131401090, 131399096]}, "name": "E. Staircases", "statement": "You are given a matrix, consisting of n rows and m columns. The rows are\r\nnumbered top to bottom, the columns are numbered left to right.Each cell\r\nof the matrix can be either free or locked.Let\u2019s call a path in the\r\nmatrix if it: starts and ends in the free cell; visits only free cells;\r\nhas one of the two following structures: the second cell is 1 to the\r\nright from the first one, the third cell is 1 to the bottom from the\r\nsecond one, the fourth cell is 1 to the right from the third one, and so\r\non; the second cell is 1 to the bottom from the first one, the third\r\ncell is 1 to the right from the second one, the fourth cell is 1 to the\r\nbottom from the third one, and so on. In particular, a path, consisting\r\nof a single cell, is considered to be a staircase.Here are some examples\r\nof staircases: Initially all the cells of the matrix are .You have to\r\nprocess q queries, each of them flips the state of a single cell. So, if\r\na cell is currently free, it makes it locked, and if a cell is currently\r\nlocked, it makes it free.Print the number of different staircases after\r\neach query. Two staircases are considered different if there exists such\r\na cell that appears in one path and doesn\u2019t appear in the other path.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 10.10.2021 12:18:01       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      ans += 1;\n      { // right\n        int nr = m - 1 - j;\n        int nd = n - 1 - i;\n        nr = min(nr, nd + 1);\n        nd = min(nd, nr);\n        ans += nr + nd;\n      }\n      { // down\n        int nr = m - 1 - j;\n        int nd = n - 1 - i;\n        nd = min(nd, nr + 1);\n        nr = min(nr, nd);\n        ans += nr + nd;\n      }\n    }\n  }\n  vector<vector<int>> a(n, vector<int>(m));\n  auto Go = [&](int i, int j, int di, int dj) {\n    int cc = 0;\n    while (true) {\n      i += di;\n      j += dj;\n      if (i < 0 || j < 0 || i >= n || j >= m || a[i][j] == 1) {\n        break;\n      }\n      cc += 1;\n      swap(di, dj);\n    }\n    return cc;\n  };\n  while (q--) {\n    int i, j;\n    cin >> i >> j;\n    --i; --j;\n    {\n      int x = Go(i, j, -1, 0);\n      int y = Go(i, j, 0, 1);\n      ans += (a[i][j] == 1 ? 1 : -1) * ((x + 1) * (y + 1) - 1);\n    }\n    {\n      int x = Go(i, j, 0, -1);\n      int y = Go(i, j, 1, 0);\n      ans += (a[i][j] == 1 ? 1 : -1) * ((x + 1) * (y + 1) - 1);\n    }\n    ans += (a[i][j] == 1 ? 1 : -1);\n    a[i][j] ^= 1;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "data structures", "dfs and similar", "dp", "implementation", "math"], "dificulty": "2100", "interactive": false}