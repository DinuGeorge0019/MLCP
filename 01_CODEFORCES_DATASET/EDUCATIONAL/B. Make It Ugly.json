{
    "link": "https://codeforces.com//contest/1954/problem/B",
    "problemId": "2586692",
    "problem_idx": "B",
    "shortId": "1954B",
    "contest_number": "1954",
    "problem_submissions": {
        "F": [
            256316895,
            256329295,
            256334035,
            256332306,
            256344392,
            256332853,
            256328005,
            256347592,
            256335011,
            256352109,
            256350995,
            258635003,
            256340118,
            256372395,
            256325447,
            256325322,
            256346283,
            256316023,
            256323588,
            256320924
        ],
        "E": [
            256282413,
            256358889,
            256358516,
            256282751,
            256340120,
            256301294,
            256294589,
            256283411,
            256294052,
            256306491,
            256303451,
            256299550,
            256302258,
            256354417,
            256293685,
            256303935,
            256308643,
            256372754,
            256335764,
            256333289,
            256297901,
            256327707,
            256340547,
            256345064,
            256288665
        ],
        "D": [
            256268895,
            256269992,
            256269812,
            256286958,
            256273436,
            256278229,
            256282928,
            256272144,
            256284841,
            256280990,
            256279861,
            256284063,
            256273990,
            256301346,
            256280827,
            256332605,
            256335916,
            256339422,
            256279104
        ],
        "C": [
            256263031,
            256263009,
            256264769,
            256265286,
            256267161,
            256271687,
            256272827,
            256264797,
            256276178,
            256267220,
            256271392,
            256275794,
            256262221,
            256288253,
            256273238,
            256334487,
            256333463,
            256330248,
            256269277
        ],
        "B": [
            256260210,
            256260093,
            256260556,
            256262624,
            256263445,
            256260047,
            256260173,
            256261053,
            256267415,
            256261634,
            256268733,
            256270204,
            256275934,
            256283332,
            256344932,
            256336999,
            256331860,
            256328039,
            256266244
        ],
        "A": [
            256256940,
            256256909,
            256256942,
            256256970,
            256256990,
            256256907,
            256256875,
            256257032,
            256259999,
            256257112,
            256257788,
            256257203,
            256259580,
            256256932,
            256338388,
            256326736,
            256328175,
            256257406
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128421",
    "editorial": "As given in the problem statement, the definition of a beautiful array\r\nis not very interesting to us, since checking the beauty of an array is\r\nquite complex. Letâs try to simplify it.First of all, the first and last\r\nelements will never be changed, as it is impossible to choose such for\r\noperations. If they are different, then the array is definitely not\r\nbeautiful. Moreover, if the array is beautiful, then all its elements at\r\nthe end will be equal to the first and the last elements.The second idea\r\nis a bit more complicated. Notice that each element can be changed at\r\nmost once. Consider an arbitrary operation. We choose some for which ,\r\nand change to . Now both and will always remain equal to their current\r\nvalues, because in any operation involving them, will also be involved.\r\nThis means that will also remain equal to the new value.The next idea is\r\nas follows. We know what all the elements should be equal to in the end.\r\nThis means that we need to apply operations to all elements that are not\r\nequal to this value. According to the previous idea, this is possible if\r\nand only if there are no two consecutive numbers in the array that are\r\nnot equal to this value. The sufficiency of this condition is obvious,\r\nand the necessity is left as an exercise to the reader.In other words,\r\nthe check looks like this: , and or (or both are equal) for all .What\r\nelements should be removed so that the check does not pass? There are\r\ntwo options: break the first or second condition. So, you can do the\r\nfollowing: remove the entire prefix of numbers equal to ; remove the\r\nentire suffix of numbers equal to (or they are equal to each other,\r\nsince the given array is beautiful); choose two numbers that are not\r\nequal to , and remove all the numbers between them, so that these two\r\nnumbers become adjacent. The third condition can be simplified. If other\r\nnumbers not equal to are encountered between the selected numbers, then\r\nanother pair can be chosen, for which fewer numbers have to be removed.\r\nTherefore, it is only optimal to choose a pair for which all the numbers\r\nbetween them are equal to .Then the solution is as follows. Find the\r\nshortest block of numbers equal to . Remove it from the array. It can be\r\nat the prefix or at the suffix then the first condition will be broken.\r\nOr it can be somewhere in the middle then the second condition will be\r\nbroken.To find such a block, you can go through the array from left to\r\nright, maintaining the position of the previous element not equal to .\r\nIf the current element is not equal to , update the answer with the\r\ndifference between the saved and current positions, and update the saved\r\nposition.The only case when the answer is is when all the elements of\r\nthe array are the same. Otherwise, it is always possible to make the\r\narray not beautiful.Overall complexity: for each testcase.\r\n",
    "name": "B. Make It Ugly",
    "statement": "Let’s call an array a if you can make all its elements the same by using\r\nthe following operation an arbitrary number of times (possibly, zero):\r\nchoose an index i (2\r\nle i\r\nle |a| - 1) such that a_{i - 1} = a_{i + 1}, and replace a_i with a_{i -\r\n1}. You are given a beautiful array a_1, a_2,\r\ndots, a_n. What is the minimum number of elements you have to remove\r\nfrom it in order for it to stop being beautiful? Swapping elements is\r\nprohibited. If it is impossible to do so, then output .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std; #define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size()) using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128; using pii=pair<int,int>;using pll=pair<ll,ll>; template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>; using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>; #define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__))) template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>; // https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s))) template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);} template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());} template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;} template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;} #ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);} template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;} vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;} vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);} template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};} template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f; template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;} template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;} #define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) //#include<atcoder/all>//using namespace atcoder; //using mint=modint998244353;//using mint=modint1000000007; void ahcorz(){    int n; cin >> n;    vi a(n); cin >> a;    if(a[0]!=a[n-1]){        print(0);        return;    }    vi vec;    vec.pb(-1);    rep(n) if(a[i]!=a[0]) vec.pb(i);    vec.pb(n);    if(sz(vec)<=2){        print(-1);        return;    }    int mn=1e9;    rep(sz(vec)-1) chmin(mn,vec[i+1]-vec[i]-1);    print(mn);} signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Make It Ugly.json",
    "hint": []
}