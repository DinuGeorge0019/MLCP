{
    "link": "https://codeforces.com//contest/1886/problem/B",
    "problemId": "2254330",
    "problem_idx": "B",
    "shortId": "1886B",
    "contest_number": "1886",
    "problem_submissions": {
        "F": [
            227397695,
            227398300,
            228261037,
            228260268,
            228197178
        ],
        "E": [
            227362679,
            227384483,
            227364120,
            227375327,
            227373174,
            227378169,
            227374021,
            227374447,
            227379620,
            227374460,
            227376543,
            227384694,
            227379424,
            227380143,
            227385403,
            227378825,
            227381936,
            227382749,
            227399178,
            227387227
        ],
        "D": [
            227353655,
            227357179,
            227354694,
            227357584,
            227358464,
            227358468,
            227358349,
            227362290,
            227362059,
            227356663,
            227359799,
            227363314,
            227364815,
            227364540,
            227348253,
            227359972,
            227351995,
            227364703,
            227363479,
            227364505
        ],
        "C": [
            227350420,
            227354094,
            227350822,
            227351738,
            227353206,
            227352928,
            227352755,
            227358100,
            227355646,
            227353873,
            227356426,
            227357990,
            228289531,
            227359928,
            227359265,
            227363015,
            227354512,
            227347330,
            227360346,
            227356740,
            227359383
        ],
        "B": [
            227345467,
            227345695,
            227345097,
            227345886,
            227347778,
            227347034,
            227345776,
            227346855,
            227347299,
            227344500,
            227348328,
            227348902,
            227344888,
            227345167,
            227353779,
            227346134,
            227384569,
            227355313,
            227346381,
            227345209
        ],
        "A": [
            227342113,
            227340918,
            227341455,
            227340893,
            227341201,
            227341171,
            227340846,
            227340875,
            227341099,
            227340925,
            227340854,
            227342810,
            227341042,
            227341115,
            227341596,
            227341490,
            227340923,
            227349667,
            227341619,
            227341191
        ]
    },
    "name": "B. Fear of the Dark",
    "statement": "Monocarp tries to get home from work. He is currently at the point O =\r\n(0, 0) of a two-dimensional plane; his house is at the point P = (P_x,\r\nP_y).Unfortunately, it is late in the evening, so it is very dark.\r\nMonocarp is afraid of the darkness. He would like to go home along a\r\npath illuminated by something.Thankfully, there are two lanterns,\r\nlocated in the points A = (A_x, A_y) and B = (B_x, B_y). You can choose\r\nany non-negative number w and set the power of lanterns to w. If a\r\nlantern’s power is set to w, it illuminates a circle of radius w\r\ncentered at the lantern location (including the borders of the\r\ncircle).You have to choose the minimum non-negative value w for the\r\npower of the lanterns in such a way that . You may assume that the\r\nlanterns don’t interfere with Monocarp’s movement.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Point {\n    int x = 0;\n    int y = 0;\n};\n\ndouble dist(const Point &a, const Point &b) {\n    return std::hypot(a.x - b.x, a.y - b.y);\n}\n\nvoid solve() {\n    Point O, P, A, B;\n    std::cin >> P.x >> P.y >> A.x >> A.y >> B.x >> B.y;\n    \n    double ans = std::min({\n        std::max(dist(O, A), dist(A, P)),\n        std::max(dist(O, B), dist(B, P)),\n        std::max({dist(O, A), dist(A, B) / 2, dist(B, P)}),\n        std::max({dist(O, B), dist(B, A) / 2, dist(A, P)}),\n    });\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::cout << std::fixed << std::setprecision(10);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Fear of the Dark.json",
    "editorial_link": "https://codeforces.com//blog/entry/121255",
    "editorial": "There are only two major cases: both points and lie inside the same\r\ncircle, or the point lies inside one of the circles and lies inside the\r\nother circle.Letâs denote the distance between the points and as .Letâs\r\nlook at the first case, when the points and lie inside the circle\r\ncentered at . In that case, inequalities and must be satisfied.\r\nTherefore, the minimum possible radius for that case is equal to .\r\nSimilarly, for the circle centered at , the minimum possible radius for\r\nthat case is equal to .Letâs look at the second case, when the point\r\nlies inside the circle centered at and the point lies inside the circle\r\ncentered at . In that case, inequalities and must be satisfied. But\r\nthere is one extra constraint: the circles must intersect, because there\r\nis should an illuminated path from one circle to another. This adds one\r\nmore inequality . Therefore, the minimum possible radius for that case\r\nis equal to . Similarly, when lies inside the circle centered at and\r\nlies inside the circle centered at , the minimum possible radius for\r\nthat case is equal to .So the answer to the problem is the minimum among\r\naforementioned cases.\r\n",
    "hint": []
}