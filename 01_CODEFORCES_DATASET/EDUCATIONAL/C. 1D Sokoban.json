{"link": "https://codeforces.com//contest/1494/problem/C", "problemId": "913252", "problem_idx": "C", "shortId": "1494C", "contest_number": "1494", "problem_submissions": {"F": [108939157, 108939159, 108941615, 108940380, 108936690, 108949404, 108939049, 108976002, 109259098, 114355817, 114300723, 109105687, 108952860], "E": [108917863, 108917179, 108917875, 108920789, 108924713, 108911681, 108911479, 108897566, 108915498, 108912071, 108919266, 108916392, 108921553, 108913575, 108918608, 108932427, 108930755, 108916943], "D": [108912126, 108910016, 108906106, 108913150, 108917394, 108924483, 108905862, 108906091, 108907069, 108901150, 108912737, 108909289, 108909997, 108901829, 108912218, 108906405, 108912083], "C": [108899963, 108897106, 108898254, 108894965, 108905337, 108946028, 108904267, 108903529, 108894912, 108900440, 108893773, 108903235, 108896270, 108897186, 108897145, 108895547, 108897140, 108897478, 108896885], "B": [108887573, 108887648, 108887088, 108887791, 108891184, 108886492, 108887122, 108892723, 108887267, 108886341, 108887638, 108889178, 108889629, 108886479, 108887946, 108888463, 108886261], "A": [108886097, 108886134, 108886049, 108886041, 108887001, 108886021, 108886051, 108886176, 108886040, 108887099, 108886184, 108886195, 108886220, 108886015, 108886138, 108886325, 108885985]}, "name": "C. 1D Sokoban", "statement": "You are playing a game similar to Sokoban on an infinite number line.\r\nThe game is discrete, so you only consider integer positions on the\r\nline.You start on a position 0. There are n boxes, the i-th box is on a\r\nposition a_i. All positions of the boxes are distinct. There are also m\r\nspecial positions, the j-th position is b_j. All the special positions\r\nare also distinct.In one move you can go one position to the left or to\r\nthe right. If there is a box in the direction of your move, then you\r\npush the box to the next position in that direction. If the next\r\nposition is taken by another box, then that box is also pushed to the\r\nnext position, and so on. . .You are allowed to perform any number of\r\nmoves (possibly, zero). Your goal is to place as many boxes on special\r\npositions as possible. Note that some boxes can be initially placed on\r\nspecial positions.\r\n", "solutions": ["#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nint calc(vector<int> a, vector<int> b)\n{\n    int n = a.size(); int m = b.size();\n    set<int> pos(b.begin(), b.end());\n\n    vector<int> suf(n+1);\n    suf[n] = 0;\n    for (int i = n-1; i>=0; i--)\n    {\n        suf[i] = suf[i+1];\n        if (pos.count(a[i])) suf[i]++;\n    }\n\n    int ans = suf[0];\n\n\n    for (int take = 1; take<=n; take++)\n    {\n        //we take suf[take], and have take consecutive ending in a[take-1], a[take] - 1\n\n        auto it = lower_bound(b.begin(), b.end(), a[take-1]);\n        if (it==b.end()) continue;\n\n        int idx = it - b.begin();\n\n        int LIM = 1e9 + 5;\n        if (take<n) LIM = a[take]-1;\n\n        while (idx<m && b[idx] <= LIM)\n        {\n            int idx1 = lower_bound(b.begin(), b.end(), b[idx] - take + 1) - b.begin();\n\n            ans = max(ans, suf[take] + (idx - idx1 + 1));\n\n            idx++;\n        }\n    }\n    return ans;\n}\n\nvoid solve()\n{\n    int n, m;\n    cin>>n>>m;\n    vector<int> a(n); for (int i = 0; i<n; i++) cin>>a[i];\n    vector<int> b(m); for (int i = 0; i<m; i++) cin>>b[i];\n\n    int answer = 0;\n\n    vector<int> a1, b1;\n    for (auto it: a) if (it>0) a1.push_back(it);\n    for (auto it: b) if (it>0) b1.push_back(it);\n\n    answer+=calc(a1, b1);\n\n    a1.clear(); b1.clear();\n\n    for (auto it: a) if (it<0) a1.push_back(-it);\n    for (auto it: b) if (it<0) b1.push_back(-it);\n\n    reverse(a1.begin(), a1.end());\n    reverse(b1.begin(), b1.end());\n    answer+=calc(a1, b1);\n    cout<<answer<<endl;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}"], "input": "", "output": "", "tags": ["binary search", "dp", "greedy", "implementation", "two pointers"], "dificulty": "1900", "interactive": false}