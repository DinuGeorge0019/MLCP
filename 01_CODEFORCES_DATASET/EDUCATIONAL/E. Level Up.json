{
    "link": "https://codeforces.com//contest/1997/problem/E",
    "problemId": "2784498",
    "problem_idx": "E",
    "shortId": "1997E",
    "contest_number": "1997",
    "problem_submissions": {
        "F": [
            273554813,
            273562336,
            273555588,
            273558521,
            273558184,
            273555359,
            273562297,
            273565830,
            273546283,
            273544285,
            273566836,
            273566119,
            273585907,
            273568802,
            273555309,
            273574760,
            273588700,
            273578615,
            273575242,
            273588906
        ],
        "E": [
            273537014,
            273527320,
            273531772,
            273535164,
            273526322,
            273540324,
            273541553,
            273544138,
            273572699,
            273564384,
            273777832,
            273550008,
            273548972,
            273536881,
            273554636,
            273544552,
            273556209,
            273544842,
            273546282,
            273666737,
            273666189,
            273553954,
            273545375
        ],
        "D": [
            273513568,
            273513144,
            273513742,
            273512836,
            273510170,
            273516169,
            273515679,
            273515838,
            273510617,
            273513446,
            273517815,
            273525464,
            273518352,
            273521955,
            273529234,
            273520142,
            273512102,
            273520565,
            273515266,
            273520749
        ],
        "C": [
            273496813,
            273497815,
            273498571,
            273503315,
            273497876,
            273499195,
            273500860,
            273502791,
            273499347,
            273496485,
            273508798,
            273507268,
            273509198,
            273511156,
            273522873,
            273509562,
            273503505,
            273507797,
            273508832,
            273510628
        ],
        "B": [
            273490300,
            273489109,
            273490092,
            273494428,
            273492341,
            273491848,
            273492911,
            273494262,
            273492523,
            273491731,
            273501850,
            273497360,
            273496735,
            273504535,
            273502692,
            273496964,
            273493065,
            273497766,
            273504790,
            273497879
        ],
        "A": [
            273486630,
            273485994,
            273491236,
            273487968,
            273486132,
            273486581,
            273486579,
            273487757,
            273487599,
            273486090,
            273488578,
            273489964,
            273488719,
            273489029,
            273504662,
            273489452,
            273486034,
            273487994,
            273500770,
            273488432
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132154",
    "editorial": "I would like to describe two different intended solutions to this\r\nproblem.Solution One.Letâs start with the following idea. How many times\r\ncan the characterâs level increase for a fixed ? Given that there are\r\nmonsters, even if we fight all of them, the level will not exceed . That\r\nis, if we sum over all , the level will change no more than times\r\n(harmonic series).Letâs simulate the process for each and find out when\r\nthe level changed. Suppose the characterâs level became after fighting\r\nmonster . Then the level will become after fighting the -th monster with\r\na level greater than or equal to after position . That is, if we had an\r\narray of positions of monsters with a level greater than or equal to ,\r\nwe could find the position of the level change from it. Unfortunately,\r\nit is not possible to keep all such arrays in memory.Instead, letâs try\r\nto use a more powerful data structure. Now, suppose we want to add or\r\nremove positions from the structure and be able to query the -th\r\nposition greater than . Such structures exist. We can use a segment\r\ntree, a BIT, or an ordered_set from pbds.How can we reduce the problem\r\nto using this structure? The idea is as follows. Previously, we had the\r\nidea to iterate over and inside that iterate over the current character\r\nlevel. Letâs do the opposite. We will iterate over the character level\r\non the outside. And inside, we will update the level for all such for\r\nwhich the character has not reached the end of the monsters yet.It turns\r\nout that this will be a prefix of the . Why is that? For each , the\r\ncharacter reaches level at some no later than at . Suppose this is not\r\nthe case. Consider the first such where the character reached level at\r\nlater than at . That is, he reached level earlier or at the same time.\r\nThis means that he will encounter at least all the same monsters at as\r\nat (since the segment of monsters will start no later and end no\r\nearlier). Since at , the character must have encountered at least\r\nmonsters of level at least , at he will definitely encounter at least .\r\nThus, this cannot happen.Then the implementation is as follows. For each\r\n, we will maintain the position at which the character reached the\r\ncurrent level . Then, for the prefix of , for which this position is\r\nwithin the array, we will update it with the new position for level .\r\nFor this, we will store the positions of all monsters of level at least\r\nin the data structure. After processing level , we will remove all\r\nmonsters of this level from the structure. To find the new position, we\r\nneed to make such queries to the structure: either find the -th position\r\nafter the current saved one (in the segment tree or Fenwick tree), or\r\nfind the first (using order_of_key) and move positions from it (using\r\nfind_by_order) (in ordered_set).We can answer the queries within the\r\nsimulation. For each , we will store all queries related to it and sort\r\nthem in ascending order of . Since within each we move in the order of\r\nincreasing level, and thus position, we can answer the queries in that\r\norder. While the position of the query is less than or equal to the\r\nposition where the level will become , we answer the queries by checking\r\nthat the monsterâs level at that position is not less than .Overall\r\ncomplexity: .Solution Two.Letâs still simulate level increases\r\ndirectly.We will use the square root heuristics. If is greater than or\r\nequal to some constant , then the character will definitely fight all\r\nmonsters of level at least , simply because he cannot become greater\r\nthan this level himself. That is, if we choose on the order of , for\r\nexample, we only need to know whether the character is fighting a\r\nmonster, only for monsters of level no higher than .We will solve the\r\nproblem for all less than in . That is, we will honestly go through the\r\nmonsters, maintaining the characterâs level and a counter of fights\r\nuntil the level increases.For larger , we will solve the problem as\r\nfollows. We will sum the indices of all characters of each level from to\r\ninto separate arrays. We will consider whom the character fought at the\r\nend of the game for each level separately. It is obvious that for each\r\nlevel of monsters , the character fought a prefix of these monsters.\r\nSince the characterâs level increases monotonically, at some point the\r\ncharacterâs level will exceed , and all monsters of level will\r\nflee.Moreover, if the character fought a monster for some , he will also\r\nfight it for (by the proof from the previous solution).Thus, to find out\r\nwhich new monsters the character will fight at level , we can do the\r\nfollowing. We will iterate over monster levels up to and for the first\r\nfleeing monster of this level, we will check whether the character will\r\nfight it now. For this, we need to find out how many monsters the\r\ncharacter fought before this monster. If his level is not less than this\r\nnumber divided by (rounded down), then he will fight it. Among all the\r\nfirst monsters the character will fight, we will find the minimum. For\r\nit, our solution is definitely correct. For the others, this is not\r\nnecessarily true, because the characterâs level may increase due to\r\nfights to the left of this position.If no such monsters are found, then\r\nfor this we have found all. Otherwise, in some data structure, we will\r\nmark that the character is fighting with the leftmost found\r\nmonster.Thus, we need a data structure that can answer prefix sum\r\nqueries and update an element at a certain position. There are quite a\r\nfew such structures. However, we have a large number of queries: for\r\neach fight, we need to make queries, that is, a total of queries.\r\nHowever, there are not so many updates: each position will be updated in\r\nthe structure no more than once, that is, no more than updates.\r\nTherefore, we would like to have a structure that balances these\r\noperations. For example, let the query be , and the update be .We will\r\ndivide the array into blocks of size . For each block, we will store the\r\nsum of elements up to its left boundary. And for each position within\r\neach block, we will store the sum up to the left boundary of the block.\r\nThen, to query the prefix sum up to , we need to add the sum up to the\r\nleft position of the block and the sum from to the start of this block.\r\nTo update at position , we need to add one to the first sum for each\r\nblock from to the end. And also for each position from to the end of its\r\nblock.Queries can be answered as follows. For each monster, we will keep\r\ntrack of the first at which we will fight it. Then it is sufficient to\r\ncheck that the from the query is not less than this value.Overall\r\ncomplexity: .\r\n",
    "name": "E. Level Up",
    "statement": "Monocarp is playing a computer game. He starts the game being level 1.\r\nHe is about to fight n monsters, in order from 1 to n. The level of the\r\ni-th monster is a_i.For each monster in the given order, Monocarp’s\r\nencounter goes as follows: if Monocarp’s level is strictly higher than\r\nthe monster’s level, the monster flees (runs away); otherwise, Monocarp\r\nfights the monster. After every k-th fight with a monster (), Monocarp’s\r\nlevel increases by 1. So, his level becomes 2 after k monsters he\r\nfights, 3 after 2k monsters, 4 after 3k monsters, and so on.You need to\r\nprocess q queries of the following form: i x: will Monocarp fight the\r\ni-th monster (or will this monster flee) if the parameter k is equal to\r\nx?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>//#define int li#define f first#define s second using namespace std;using li = long long;using ld = long double;const int N = 2e5 + 5; int t[N]; int sum(int r){    int ans = 0;     for(; r >= 0; r = (r & r + 1) - 1)        ans += t[r];     return ans;} void inc(int i, int d){    for(; i < N; i |= i + 1)        t[i] += d;} int Lower_bound(int x){    int r = -1;    int s = 0;     for(int j = 20; j >= 0; j--)    {        int nr = r + (1 << j);         if(nr < N && s + t[nr] < x)        {            s += t[nr];            r = nr;        }    }     return r + 1;} int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);     int n, q;    cin >> n >> q;     vector <int> a(n);     for(int i = 0; i < n; i++)        cin >> a[i];     vector <int> up[n + 1];     for(int i = 0; i < n; i++)        inc(i, 1);     vector <pair <int, int> > v;     for(int i = 0; i < n; i++)    {        v.push_back({a[i], i});    }     sort(v.begin(), v.end());    int ind = 0;     for(int k = 1; k <= n; k++)        up[k].push_back(-1);     for(int i = 1; i <= n; i++)    {        for(int k = 1; k * i <= n; k++)        {            if(up[k].size() == i)            {                int j = Lower_bound(sum(up[k].back()) + k);                 if(j < n)                    up[k].push_back(j);            }        }         while(ind < n && v[ind].f == i)        {            inc(v[ind].s, -1);            ind++;        }    }     while(q--)    {        int i, k;        cin >> i >> k;        i--;         if(up[k].size() <= a[i] || up[k][a[i]] >= i)            cout << \"YES\\n\";        else cout << \"NO\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Level Up.json",
    "hint": []
}