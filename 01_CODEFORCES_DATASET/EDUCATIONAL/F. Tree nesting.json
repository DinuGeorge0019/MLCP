{
    "link": "https://codeforces.com//contest/762/problem/F",
    "problemId": "90127",
    "problem_idx": "F",
    "shortId": "762F",
    "contest_number": "762",
    "problem_submissions": {
        "F": [
            24128800,
            24127287,
            24131448,
            24128833,
            24128590
        ],
        "E": [
            24122771,
            24123546,
            24117007,
            24124444,
            24127665,
            24127353,
            24122694,
            24124867,
            24128194,
            24130174,
            24129986,
            24129967,
            24127255,
            24123944,
            24123747,
            24128463,
            24126253,
            24117536,
            24126607
        ],
        "D": [
            24120216,
            24117937,
            24120594,
            24123699,
            24120899,
            24122923,
            24125654,
            24122077,
            24124440,
            24123437,
            24124479,
            24129845,
            64773611,
            24129570,
            24127415,
            24125478,
            24129569,
            24125183,
            24124387,
            24117686
        ],
        "C": [
            24117649,
            24115665,
            24118684,
            24120038,
            24118048,
            24119412,
            24117040,
            24153774,
            24117580,
            24118699,
            24120548,
            24119249,
            24120443,
            24120966,
            24122719,
            24122392,
            24134825,
            24118679
        ],
        "B": [
            24115242,
            24114275,
            24114874,
            24121323,
            24115338,
            24115218,
            24114366,
            24115078,
            24114616,
            24115065,
            24117965,
            24115815,
            24115613,
            24116743,
            24116439,
            24116970,
            24124581,
            24115154,
            24114842
        ],
        "A": [
            24113787,
            24113769,
            24113819,
            24114373,
            24113802,
            24113840,
            24113765,
            24113864,
            24113822,
            24115779,
            24114962,
            24114446,
            24113882,
            24114350,
            24114566,
            24114001,
            24114912,
            24113931,
            24113786
        ]
    },
    "name": "F. Tree nesting",
    "statement": "You are given two trees (connected undirected acyclic graphs) and .Count\r\nthe number of subtrees (connected subgraphs) of that are isomorphic to\r\ntree . Since this number can get quite large, output it modulo .Two\r\nsubtrees of tree are considered different, if there exists a vertex in\r\nthat belongs to exactly one of them.Tree is called isomorphic to tree if\r\nthere exists a bijection from the set of vertices of to the set of\r\nvertices of that has the following property: if there is an edge between\r\nvertices and in tree , then there must be an edge between vertices and\r\nin tree . And vice versa if there is an edge between vertices and in\r\ntree , there must be an edge between and in tree .\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 1021\nvoid build(){\n}\nstruct Tree{\n  int n;\n  vector<int> v[ N ];\n  void init(){\n    n = getint();\n    for( int i = 1 ; i <= n ; i ++ )\n      v[ i ].clear();\n    for( int i = 1 ; i < n ; i ++ ){\n      int ai = getint();\n      int bi = getint();\n      v[ ai ].push_back( bi );\n      v[ bi ].push_back( ai );\n    }\n  }\n} s , t;\nint hsvl[ N ] , mid , con;\nvector<int> v;\nmap< vector<int> , int > M;\nint Hash( int x , int prt = -1 ){\n  vector<int> tv;\n  for( int son : t.v[ x ] ){\n    if( son == prt ) continue;\n    tv.push_back( Hash( son , x ) );\n  }\n  sort( tv.begin() , tv.end() );\n  if( M.count( tv ) == 0 ){\n    M[ tv ] = ++ mid;\n    if( tv.empty() )\n      con = mid;\n  }\n  return M[ tv ];\n}\nvoid init(){\n  s.init();\n  t.init();\n}\nvector<int> son[ N ] , vs[ N ];\nvoid pre_go( int now , int prt ){\n  for( int x : s.v[ now ] ){\n    if( x == prt ) continue;\n    vs[ now ].push_back( x );\n    pre_go( x , now );\n  }\n}\nvector<int> useful;\nunordered_map<int,int> who;\nint go( int now , int prt ){\n  for( int tson : t.v[ now ] ){\n    if( tson == prt ) continue;\n    son[ now ].push_back( go( tson , now ) );\n  }\n  sort( son[ now ].begin() , son[ now ].end() );\n  int ret = M[ son[ now ] ];\n  useful.push_back( ret );\n  who[ ret ] = now;\n  return ret;\n}\nint target , ans , tdp[ 1 << 12 ] , rdp[ 1 << 12 ];\nint q[ 1 << 12 ] , qt;\nint iq[ 1 << 12 ] , stmp;\nunordered_map<int,int> dp[ N ];\nvoid go_cal( int now ){\n  for( int sn : vs[ now ] )\n    go_cal( sn );\n  for( auto cv : useful ){\n    if( cv == con ){\n      dp[ now ][ cv ] = 1;\n    }else{\n      int he = who[ cv ];\n      int csz = son[ he ].size();\n      for( int j = 0 ; j < ( 1 << csz ) ; j ++ )\n        tdp[ j ] = 0;\n      tdp[ 0 ] = 1;\n      iq[ 0 ] = ++ stmp;\n      q[ 0 ] = 0; qt = 1;\n      for( int sn : vs[ now ] ){\n        for( int _ = 0 ; _ < qt ; _ ++ )\n          rdp[ q[ _ ] ] = tdp[ q[ _ ] ];\n        int cqt = qt;\n        for( int _ = 0 ; _ < cqt ; _ ++ ){\n          int inow = q[ _ ];\n          for( int j = 0 ; j < csz ; j ++ ){\n            if( ( inow >> j ) & 1 ) continue;\n            if( j && son[ he ][ j ] == son[ he ][ j - 1 ] &&\n                ( ( inow >> ( j - 1 ) ) & 1 ) == 0 ) continue;\n            tdp[ inow | ( 1 << j ) ] = add(\n                tdp[ inow | ( 1 << j ) ],\n                mul( rdp[ inow ] , dp[ sn ][ son[ he ][ j ] ] ) );\n            if( iq[ inow | ( 1 << j ) ] != stmp ){\n              iq[ inow | ( 1 << j ) ] = stmp;\n              q[ qt ++ ] = inow | ( 1 << j );\n            }\n          }\n        }\n      }\n      dp[ now ][ cv ] = tdp[ ( 1 << csz ) - 1 ];\n    }\n    if( cv == target )\n      ans = add( ans , dp[ now ][ cv ] );\n  }\n}\nvoid cal( int i ){\n  for( int j = 1 ; j <= t.n ; j ++ )\n    son[ j ].clear();\n  who.clear();\n  useful.clear();\n  target = go( i , i );\n  sort( useful.begin() , useful.end() );\n  useful.resize( unique( useful.begin() , useful.end() ) - useful.begin() );\n  for( int j = 1 ; j <= s.n ; j ++ )\n    dp[ j ].clear();\n  go_cal( 1 );\n}\nvoid solve(){\n  pre_go( 1 , 1 );\n  for( int i = 1 ; i <= t.n ; i ++ ){\n    hsvl[ i ] = Hash( i );\n    bool bye = false;\n    for( int j = 1 ; j < i ; j ++ )\n      if( hsvl[ i ] == hsvl[ j ] ){\n        bye = true;\n        break;\n      }\n    if( bye ) continue;\n    cal( i );\n  }\n  printf( \"%d\\n\" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "graphs",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Tree nesting.json",
    "editorial_link": "https://codeforces.com//blog/entry/50010",
    "editorial": "No nested spoilers. It's serious business here!\n\nOne of the possible ways to make your life easier is to count the number of automorphisms of tree T. This way you will be able to first calculate the number of labeled matchings of vertices of tree T to the vertices of tree S, and then divide this number by the number of automorphisms.\n\nAlthough solution that I will describe does not use this! :D\n\nFirst, remember that every automorphism has a fixed point. Either a vertex or an edge. This is called center of the tree, and you can find it by first finding the diameter of the tree. It's middle vertex (or an edge, if there are two middle vertices) is the center of the tree.\n\nLet's root T at it's center. Now let's enumerate subtrees (rooted ones!) of T in such a way that if two subtress are isomorphic they will receive the same number and vice versa. You can do it in a single dfs processing subtrees bottom-up. These numbers will correspond to different isomorphisms.\n\nNow you can do a dp with memoization to calculate for each subtree of S rooted at some directed edge the number of ways to \"attach\" each of the isomorphisms from above to this subtree. This can be done by going through all immediate children of the currently processed vertex of S and doing a bitmask DP, where bits are immediate children of the root of currently processed isomophism of T. 1 means it is \"attached\" to some children in S, 0 means not.\n\nOne of the problems here is that root of current isomorphism of T can have isomorphic children, and if we shuffle how they are attached to children in S we will still receive the same way to cover S with T, so we will calculate some ways twice or more. The solution is to sort children by their isomorphism number and when processing a bitmask, never put 1 to the bit that has a 0 bit to the left that corresponds to the child with the same isomorphism number. This way you will match such children in a fixed order and won't calculate anything unnecessary.",
    "hint": []
}