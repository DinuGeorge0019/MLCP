{"link": "https://codeforces.com//contest/946/problem/G", "problemId": "162812", "problem_idx": "G", "shortId": "946G", "contest_number": "946", "problem_submissions": {"G": [36021661, 36026384, 36022849, 36018588, 36030003, 36031880, 36023496, 36141030, 36023713, 36019743, 36021921], "F": [36016439, 36010306, 36011759, 36017801, 36015918, 36015627, 36017713, 36012422, 36018592, 36017729, 36020768, 36016813, 36019907, 36021177, 36017821, 36021462], "E": [36007161, 36005953, 36006973, 36007671, 36003744, 36009603, 36013999, 36014555, 36006191, 36012983, 36013994, 36013308, 36012827, 36016281, 36012410, 36015253, 36015878, 36009347, 36016909], "D": [36001071, 36002106, 35999863, 36001996, 36001455, 36003959, 36005490, 36004597, 36014071, 36007176, 36006435, 36007071, 36005693, 36006922, 36007333, 36006139, 36006839, 36019644, 36007254], "C": [35997922, 35999476, 35998023, 35998548, 35998939, 35999238, 36000359, 35999969, 35998896, 36000616, 36003485, 36001243, 36000192, 36002608, 35999675, 36001749, 36003789, 35999684, 36002661], "B": [35996866, 35998672, 35996504, 35997493, 35996253, 35997312, 35998806, 35998462, 35998652, 35999416, 35998242, 35998547, 35997873, 35998443, 36000126, 35998309, 35998592, 35998542], "A": [35995800, 35997505, 35995802, 35996074, 35995799, 35995844, 35997767, 35996078, 35996606, 35997456, 35995903, 35995883, 35995904, 35996096, 35995831, 35996261, 35997282, 35997134]}, "name": "G. Almost Increasing Array", "statement": "We call an array if we can erase not more than one element from it so\r\nthat the array becomes strictly increasing (that is, every element is\r\nstriclty greater than every element before it).You are given an array\r\nconsisting of elements. You are allowed to replace any element with any\r\ninteger number (and you may do so any number of times you need). What is\r\nthe minimum number of replacements you have to perform in order to make\r\nthe array ?\r\n", "solutions": ["// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=2e5+10;\nint n,a[N];\n\nint al[N],ar[N];\nPII hl[N];\nint solve() {\n    REP1(i,1,n) a[i]+=n-i+1;\n    dump(VI(a+1,a+n+1));\n    REP1(i,0,n) al[i]=INT_MAX;\n    REP1(i,1,n) {\n        int p=upper_bound(al,al+n+1,a[i])-al;\n        hl[i]={p,al[p]};\n        al[p]=a[i];\n    }\n    int mx=lower_bound(al,al+n+1,INT_MAX)-al;\n    for ( int i=n; i>=1; i-- ) {\n        int p=hl[i].first,v=hl[i].second;\n        al[p]=v;\n        int pr=upper_bound(ar,ar+n+1,v-1,greater<int>())-ar;\n        dump(i,p,v,VI(al,al+n+1),VI(ar,ar+n+1),pr);\n        chkmax(mx,p+pr);\n\n        if ( i>1 ) {\n            int z=hl[i-1].first;\n            int zr=upper_bound(ar,ar+n+1,a[i-1]-1,greater<int>())-ar;\n            dump(z,zr,a[i-1]-1);\n            chkmax(mx,z+1+zr);\n        }\n\n        int q=upper_bound(ar,ar+n+1,a[i],greater<int>())-ar;\n        int ql=upper_bound(al,al+n+1,a[i]+1)-al;\n        chkmax(mx,q+ql);\n        ar[q]=a[i];\n    }\n    return max(0,n-1-mx);\n}\n\nvoid main() {\n    R(n);\n    REP1(i,1,n) R(a[i]);\n    // int slow_ans=slow();\n    int ans=solve();\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"], "input": "", "output": "", "tags": ["data structures", "dp"], "dificulty": "2500", "interactive": false}