{
    "link": "https://codeforces.com//contest/1380/problem/D",
    "problemId": "670986",
    "problem_idx": "D",
    "shortId": "1380D",
    "contest_number": "1380",
    "problem_submissions": {
        "F": [
            86713166,
            86683254,
            86680631,
            86680966,
            86687165,
            86684140,
            86669350,
            86688621,
            86687283,
            86673002,
            86689951,
            86691835,
            86685205,
            86710315,
            86689156,
            86687400,
            86687045,
            86687896,
            86690019
        ],
        "G": [
            86677566,
            86685201,
            86688237,
            86689481,
            86686718,
            86691383,
            86690954,
            86692142,
            86694360,
            86693986,
            86693332,
            86693299,
            86700820,
            86693764,
            86685196,
            86684314
        ],
        "E": [
            86675522,
            86675407,
            86673302,
            86676691,
            86680473,
            86684037,
            86681297,
            86679620,
            86685647,
            86685220,
            86686544,
            86674567,
            86678512,
            86684412,
            86683830,
            86676323,
            86680714,
            86681696,
            86690990
        ],
        "D": [
            86667662,
            86670333,
            86669219,
            86673424,
            86678569,
            86680592,
            86676914,
            86676735,
            86681998,
            86680522,
            86687871,
            86670447,
            86672345,
            86680156,
            86679073,
            86689461,
            86721905,
            86687223
        ],
        "C": [
            86667582,
            86670259,
            86669101,
            86667895,
            86670203,
            86672224,
            86667959,
            86672685,
            86676101,
            86675384,
            86675814,
            86668973,
            86672498,
            86672045,
            86670655,
            86667252,
            86668731,
            86674537,
            86668780
        ],
        "B": [
            86667335,
            86670187,
            86671042,
            86667790,
            86672794,
            86670893,
            86667752,
            86671215,
            86673431,
            86671665,
            86674484,
            86670341,
            86660822,
            86669327,
            86673817,
            86667069,
            86673326,
            86672657,
            86668683
        ],
        "A": [
            86667075,
            86670143,
            86668605,
            86667568,
            86667937,
            86657614,
            86657741,
            86669480,
            86673357,
            86672922,
            86672973,
            86668720,
            86672438,
            86659787,
            86671597,
            86666992,
            86671323,
            86669608,
            86668545
        ]
    },
    "name": "D. Berserk And Fireball",
    "statement": "There are n warriors in a row. The power of the i-th warrior is a_i. All\r\npowers are pairwise distinct.You have two types of spells which you may\r\ncast: Fireball: you spend x mana and destroy k consecutive warriors;\r\nBerserk: you spend y mana, choose two consecutive warriors, and the\r\nwarrior with greater power destroys the warrior with smaller power. For\r\nexample, let the powers of warriors be [2, 3, 7, 8, 11, 5, 4], and k =\r\n3. If you cast Berserk on warriors with powers 8 and 11, the resulting\r\nsequence of powers becomes [2, 3, 7, 11, 5, 4]. Then, for example, if\r\nyou cast Fireball on consecutive warriors with powers [7, 11, 5], the\r\nresulting sequence of powers becomes [2, 3, 4].You want to turn the\r\ncurrent sequence of warriors powers a_1, a_2,\r\ndots, a_n into b_1, b_2,\r\ndots, b_m. Calculate the minimum amount of mana you need to spend on it.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N, M; cin >> N >> M;\n    ll X, K, Y; cin >> X >> K >> Y;\n    int A[N+1], B[M+1]; F0R(i, N) cin >> A[i];\n    F0R(i, M) cin >> B[i];\n    \n    int bp = 0;\n    int lv = -1;\n    int mx = 0;\n    int cnt = 0;\n    ll ans = 0;\n    A[N] = 0; B[M] = 0;\n    F0R(i, N+1) {\n        if (bp < M+1 && A[i] == B[bp]) {\n            ll res = 1e18;\n            if (mx < lv || mx < A[i]) {\n                res = Y * cnt;\n            }\n            for (int j = K; j <= cnt; j += K) {\n                ckmin(res, X * (j / K) + Y * (cnt - j));\n            }\n\n            if (res > 1e17) {\n                cout << -1 << nl; return 0;\n            }\n            ans += res;\n\n            bp++;\n            lv = A[i];\n            mx = 0;\n            cnt = 0;\n        } else {\n            ckmax(mx, A[i]);\n            cnt++;\n        }\n    }\n    if (bp != M+1) {\n        cout << -1 << nl; return 0;\n    }\n    cout << ans << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Berserk And Fireball.json",
    "editorial_link": "https://codeforces.com//blog/entry/80054",
    "editorial": "The first thing we need to do is to find the occurrences of in the\r\nsequence these are the monsters that have to remain. Since both spells\r\n(Fireball and Berserk) affect consecutive monsters, we should treat each\r\nsubsegment of monsters we have to delete separately.Consider a segment\r\nwith monsters we have to delete such that the last monster before it has\r\npower , the first monster after the segment has power , and the\r\nstrongest monster on the segment has power .If , then we have to use\r\nBerserk at least times. Letâs make the strongest monster on segment kill\r\nsome other monster. If , then the strongest monster should also be\r\nkilled by one of the monsters bounding the segment, so if and , there is\r\nno solution.Okay, now the number of monsters is divisible by . If it is\r\nmore profitable to use Fireball, we use the required number of Fireballs\r\nto kill all of them. Otherwise, we have to kill the maximum possible\r\nnumber of monsters with Berserk and finish the remaining ones with\r\nFireball. If or , then one of the monsters just outside the segment can\r\nkill all the monsters inside the segment; otherwise, the strongest\r\nmonster should kill adjacent monsters until exactly remain, and those\r\nmonsters are finished with a single Fireball.Now we know what we need to\r\nconsider when processing a single segment; all thatâs left is to sum the\r\nminimum required mana over all such segments. Since the total length of\r\nthese segments is at most and we can process each segment in linear\r\ntime, we have a solution with complexity .\r\n",
    "hint": []
}