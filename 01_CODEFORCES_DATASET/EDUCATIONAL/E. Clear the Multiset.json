{
    "link": "https://codeforces.com//contest/1400/problem/E",
    "problemId": "709187",
    "problem_idx": "E",
    "shortId": "1400E",
    "contest_number": "1400",
    "problem_submissions": {
        "D": [
            91063958,
            91019003,
            90921157,
            90924583,
            91129094,
            90921742,
            90924518,
            90925405,
            90924228,
            90928527,
            90927053,
            90928008,
            90921390,
            90926754,
            90926098,
            90923479,
            90932560,
            90927207,
            90928111,
            90927601,
            90927240
        ],
        "E": [
            91063322,
            90999997,
            90927958,
            90932635,
            91129112,
            90933891,
            90932788,
            90935094,
            90929091,
            90933541,
            90984689,
            90938941,
            90934180,
            90924023,
            90933282,
            90933092,
            92294796,
            92121423,
            90928722,
            90927143,
            91007103,
            90937273,
            90935595,
            90936018,
            90937203,
            90931579
        ],
        "A": [
            90999219,
            90908018,
            90908383,
            91129044,
            90908056,
            90908072,
            90909135,
            90908276,
            90908322,
            90909230,
            90908179,
            90908024,
            90908751,
            90908160,
            90908096,
            90908554,
            90910364,
            90910969,
            90908122,
            90909588
        ],
        "G": [
            90977154,
            90944389,
            90958977,
            91129247,
            90953059,
            90965280,
            90969288,
            90980892,
            90974551,
            90962476,
            90980693,
            90948619,
            90945807,
            90946996,
            90945319,
            90958148,
            90949510,
            90964852,
            90966663
        ],
        "F": [
            90977148,
            90956838,
            90944290,
            91129137,
            90963414,
            90954565,
            90943343,
            90954552,
            90955511,
            90976453,
            90961680,
            90961250,
            91019872,
            91482375,
            91348176,
            90960811,
            91338009,
            90994292
        ],
        "B": [
            90918673,
            90916748,
            91129051,
            90911853,
            90914978,
            90917579,
            90917952,
            90918236,
            90916691,
            90916458,
            90913884,
            90919126,
            90919862,
            90914960,
            90914966,
            90919061,
            90921310,
            90914836,
            90917699
        ],
        "C": [
            90915688,
            90920946,
            91129078,
            90918859,
            90921028,
            90921919,
            90921370,
            90923530,
            90922399,
            90921710,
            90918731,
            90923624,
            90923408,
            90918967,
            90930451,
            90922773,
            90925808,
            90920451,
            90924212
        ]
    },
    "name": "E. Clear the Multiset",
    "statement": "You have a multiset containing several integers. Initially, it contains\r\na_1 elements equal to 1, a_2 elements equal to 2, ..., a_n elements\r\nequal to n.You may apply two types of operations: choose two integers l\r\nand r (l\r\nle r), then remove one occurrence of l, one occurrence of l + 1, ...,\r\none occurrence of r from the multiset. This operation can be applied\r\nonly if each number from l to r occurs at least once in the multiset;\r\nchoose two integers i and x (x\r\nge 1), then remove x occurrences of i from the multiset. This operation\r\ncan be applied only if the multiset contains at least x occurrences of\r\ni. What is the minimum number of operations required to delete all\r\nelements from the multiset?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nint N;\nvector<int> A;\n\nint solve(int start, int end, int outside) {\n    if (start >= end)\n        return 0;\n\n    int min_index = int(min_element(A.begin() + start, A.begin() + end) - A.begin());\n    int minimum = A[min_index];\n    return min(end - start, solve(start, min_index, minimum) + solve(min_index + 1, end, minimum) + minimum - outside);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N;\n    A.resize(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    cout << solve(0, N, 0) << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Clear the Multiset.json",
    "editorial_link": "https://codeforces.com//blog/entry/81916",
    "editorial": "Notice that we can reorder the operations in any way we want without\r\naffecting the result. So let\u00e2\u0080\u0099s do all of the first-type operations\r\nbefore the second-type operations. Then it\u00e2\u0080\u0099s clear that the number of\r\nsecond-type operations we\u00e2\u0080\u0099ll need is the number of nonzero elements left\r\nover after the first-type operations. So we just want to choose\r\nfirst-type operations to minimize the number of first-type operations\r\nplus the number of nonzero elements left after we\u00e2\u0080\u0099re done. Let\u00e2\u0080\u0099s say we\r\nhave an array where is the minimum value (if there is a tie, you can\r\npick any tied index). I only have a messy proof for this at the moment,\r\nbut it turns out we only need to consider two options: either take all\r\nsecond-type operations, or use first-type operations on the entire array\r\nand then recursively solve and separately. This leads to a simple\r\nsolution: 90999997. Note that by using RMQ we can improve this to or\r\neven . The idea is very similar to the solution to problem G here.\r\n"
}