{
    "link": "https://codeforces.com//contest/1469/problem/A",
    "problemId": "847526",
    "problem_idx": "A",
    "shortId": "1469A",
    "contest_number": "1469",
    "problem_submissions": {
        "F": [
            102583473,
            102644474,
            102589987,
            102594210,
            102598891,
            102606787,
            102602998,
            102604144,
            102603740,
            102665234,
            102604943,
            102600529,
            102596981,
            102695061,
            102694126,
            102693059,
            102692990,
            102691774,
            102691554,
            102634847,
            102593976,
            102601060,
            102611713,
            102611193,
            102613178,
            102615015,
            102610571,
            133243413,
            102609965,
            102615327
        ],
        "E": [
            102573843,
            102644473,
            102578949,
            102577732,
            102585110,
            102591945,
            102586477,
            102582817,
            102595462,
            102579611,
            102664687,
            102648095,
            102648064,
            102594234,
            102584569,
            102634471,
            102624399,
            102623518,
            102608733,
            155214938,
            102768106,
            102593726,
            102593694,
            102597495,
            102592373,
            102595193,
            102588652,
            102589423,
            102593264
        ],
        "D": [
            102562850,
            102644472,
            102568881,
            102566821,
            102569601,
            102570954,
            102563048,
            102571352,
            102588415,
            102664675,
            102570617,
            102572568,
            102569075,
            102580450,
            102569951,
            102575804,
            102575811,
            102574711,
            102577038,
            102579322,
            102570202
        ],
        "C": [
            102552805,
            102644471,
            102555513,
            102554730,
            102555597,
            102558406,
            102554980,
            102553952,
            102556321,
            102664664,
            102560782,
            102559861,
            102555651,
            102570770,
            102554929,
            102563292,
            102558262,
            102561567,
            102566610,
            102569771,
            102557739
        ],
        "B": [
            102548072,
            102644469,
            102548784,
            102547413,
            102549611,
            102549952,
            102549039,
            102547745,
            102550684,
            102664647,
            102553929,
            102550781,
            102634199,
            102551181,
            102557688,
            102550308,
            102552089,
            102551269,
            102550296,
            102555698,
            102550742,
            102551593
        ],
        "A": [
            102546848,
            102644467,
            102547134,
            102546803,
            102547541,
            102546863,
            102546919,
            102546821,
            102547947,
            102664636,
            102549491,
            102548928,
            102547577,
            102555388,
            102547472,
            102548992,
            102546835,
            102546964,
            102551041,
            102547957,
            102549438
        ]
    },
    "name": "A. Regular Bracket Sequence",
    "statement": "A bracket sequence is called regular if it is possible to obtain correct\r\narithmetic expression by inserting characters and into this sequence.\r\nFor example, sequences , and are regular, while , and are not. Let\u2019s\r\ncall a regular bracket sequence \"RBS\".You are given a sequence s of n\r\ncharacters , , and/or . in this sequence.You have to replace every\r\ncharacter with either or (different characters can be replaced with\r\ndifferent brackets). .Determine if it is possible to obtain an RBS after\r\nthese replacements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        std::string s;\n        std::cin >> s;\n        if (s.length() % 2 == 0 && s[0] != ')' && s.back() != '(') {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Regular Bracket Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/86082",
    "editorial": "There are two solutions to this problem: casework and greedy.The greedy\r\nsolution goes as follows: the number of opening brackets in an RBS\r\nshould be exactly , and if there is a closing bracket before an opening\r\nbracket, it\u00e2\u0080\u0099s optimal to swap them, if possible. So, we should replace\r\nthe first question marks with opening brackets, other question marks\r\nwith closing brackets, and if the answer exists, this method will find\r\nit. All that\u00e2\u0080\u0099s left is to check that the resulting sequence is an\r\nRBS.The casework solution goes as follows: first of all, each RBS should\r\nhave an even length, so if is odd, there is no answer. Furthermore, an\r\nRBS always begins with an opening bracket and always ends with a closing\r\nbracket, so if the first character is a closing bracket or the last\r\ncharacter is an opening bracket, there is no answer. Since there is at\r\nmost one opening bracket and at most one closing bracket in the original\r\nsequence, these three constraints are enough: if the opening bracket is\r\nbefore the closing bracket, then they balance out, and all other\r\ncharacters can be replaced in such a way that they form an RBS of length\r\n. If the opening bracket is after the closing bracket, then the first\r\nand the last characters are question marks (since the first character is\r\nnot a closing bracket, and the last one is not an opening bracket). We\r\nshould replace the first character with an opening bracket, the last\r\ncharacter with a closing bracket, so we get four characters (two opening\r\nand two closing brackets) which balance themselves out. All other\r\nquestion marks can be replaced in such a way that they form an RBS of\r\nlength . So, all we have to check is that is even, the first character\r\nis not a closing bracket, and the last character is not an opening\r\nbracket.\r\n"
}