{"link": "https://codeforces.com//contest/1841/problem/C", "problemId": "1962592", "problem_idx": "C", "shortId": "1841C", "contest_number": "1841", "problem_submissions": {"F": [209441446, 209449956, 209447296, 209453943, 209449863, 209446444, 209454347, 209678776, 209452092, 209454468, 209458945, 209453449, 209451716, 209465466, 209464638, 209461720, 209460276, 209459819, 209458504, 209458152, 209453975, 209486469, 209486319, 209486054, 209459375, 209456147, 209463444, 209466329, 209466771, 209609259, 209462972, 209467839, 209463203], "E": [209420520, 209430600, 209434973, 209427885, 209438551, 209434946, 209433065, 209431302, 209443745, 209434541, 209438545, 209438034, 209444420, 209422689, 209420477, 209458913, 209440856, 209447420, 209460885, 209429843], "D": [209412776, 209418240, 209420286, 209421079, 209475842, 209428591, 209423202, 209420942, 209417076, 209424719, 209423326, 209425276, 209464164, 209425284, 209430127, 209413537, 209411059, 209426861, 209442988, 209439319, 209441486, 209421279], "C": [209400973, 209405174, 209401188, 209410862, 209415662, 209408968, 209409562, 209408253, 209414636, 209413637, 209410942, 209421138, 209419542, 209405503, 209431667, 209409468, 209421971, 209433784, 209431914, 209416091], "B": [209395303, 209394968, 209391532, 209391351, 209395229, 209393535, 209397133, 209392667, 209405342, 209396380, 209399455, 209465838, 209465126, 209398959, 209401067, 209395449, 209398643, 209399436, 209394778, 209404496, 209407644, 209470007], "A": [209388179, 209388192, 209387876, 209387947, 209389004, 209388221, 209388559, 209388171, 209393927, 209405420, 209388257, 209389054, 209391461, 209401864, 209387894, 209390233, 209387972, 209392823, 209407382, 209389297]}, "name": "C. Ranom Numbers", "statement": "Ranom digits are denoted by uppercase Latin letters from to . Moreover,\r\nthe value of the letter is 1, is 10, is 100, is 1000, is 10000.A Ranom\r\nnumber is a sequence of Ranom digits. The value of the Ranom number is\r\ncalculated as follows: the values of all digits are summed up, but some\r\ndigits are taken with negative signs: a digit is taken with negative\r\nsign if there is a digit with a value to the right of it (not\r\nnecessarily immediately after it); otherwise, that digit is taken with a\r\npositive sign.For example, the value of the Ranom number is 1000 - 1 -\r\n1 - 1 - 10 + 1000 + 100 + 1 = 2088.You are given a Ranom number. You can\r\nchange no more than one digit in it. Calculate the maximum possible\r\nvalue of the resulting number.\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << \" \"; cout << v[i];\n    }\n    cout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\n\nvector<int> v = { 1,10,100,1000,10000 };\n\nll dp[1 << 18][5][2];\nvoid solve() {\n    string s; cin >> s;\n    reverse(all(s));\n    rep(i, s.size() + 1) {\n        rep(j, 5)rep(k, 2)dp[i][j][k] = -INF;\n    }\n    dp[0][0][0] = 0;\n    rep(i, s.size()) {\n        int c = s[i] - 'A';\n        rep(j, 5)rep(k, 2) {\n            if (dp[i][j][k]==-INF)continue;\n            rep(ad, 5) {\n                int nj = max(j, ad);\n                int nk = k; if (ad != c)nk++;\n                if (nk > 1)continue;\n                ll val = dp[i][j][k];\n                if (j > ad)val -= v[ad];\n                else val += v[ad];\n                chmax(dp[i + 1][nj][nk], val);\n            }\n        }\n    }\n    ll ans = -INF;\n    rep(j, 5)rep(k, 2)chmax(ans, dp[s.size()][j][k]);\n    cout << ans << \"\\n\";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dp", "greedy", "math", "strings"], "dificulty": "1800", "interactive": false}