{
    "link": "https://codeforces.com//contest/1841/problem/C",
    "problemId": "1962592",
    "problem_idx": "C",
    "shortId": "1841C",
    "contest_number": "1841",
    "problem_submissions": {
        "F": [
            209441446,
            209449956,
            209447296,
            209453943,
            209449863,
            209446444,
            209454347,
            209678776,
            209452092,
            209454468,
            209458945,
            209453449,
            209451716,
            209465466,
            209464638,
            209461720,
            209460276,
            209459819,
            209458504,
            209458152,
            209453975,
            209486469,
            209486319,
            209486054,
            209459375,
            209456147,
            209463444,
            209466329,
            209466771,
            209609259,
            209462972,
            209467839,
            209463203
        ],
        "E": [
            209420520,
            209430600,
            209434973,
            209427885,
            209438551,
            209434946,
            209433065,
            209431302,
            209443745,
            209434541,
            209438545,
            209438034,
            209444420,
            209422689,
            209420477,
            209458913,
            209440856,
            209447420,
            209460885,
            209429843
        ],
        "D": [
            209412776,
            209418240,
            209420286,
            209421079,
            209475842,
            209428591,
            209423202,
            209420942,
            209417076,
            209424719,
            209423326,
            209425276,
            209464164,
            209425284,
            209430127,
            209413537,
            209411059,
            209426861,
            209442988,
            209439319,
            209441486,
            209421279
        ],
        "C": [
            209400973,
            209405174,
            209401188,
            209410862,
            209415662,
            209408968,
            209409562,
            209408253,
            209414636,
            209413637,
            209410942,
            209421138,
            209419542,
            209405503,
            209431667,
            209409468,
            209421971,
            209433784,
            209431914,
            209416091
        ],
        "B": [
            209395303,
            209394968,
            209391532,
            209391351,
            209395229,
            209393535,
            209397133,
            209392667,
            209405342,
            209396380,
            209399455,
            209465838,
            209465126,
            209398959,
            209401067,
            209395449,
            209398643,
            209399436,
            209394778,
            209404496,
            209407644,
            209470007
        ],
        "A": [
            209388179,
            209388192,
            209387876,
            209387947,
            209389004,
            209388221,
            209388559,
            209388171,
            209393927,
            209405420,
            209388257,
            209389054,
            209391461,
            209401864,
            209387894,
            209390233,
            209387972,
            209392823,
            209407382,
            209389297
        ]
    },
    "name": "C. Ranom Numbers",
    "statement": "Ranom digits are denoted by uppercase Latin letters from to . Moreover,\r\nthe value of the letter is 1, is 10, is 100, is 1000, is 10000.A Ranom\r\nnumber is a sequence of Ranom digits. The value of the Ranom number is\r\ncalculated as follows: the values of all digits are summed up, but some\r\ndigits are taken with negative signs: a digit is taken with negative\r\nsign if there is a digit with a value to the right of it (not\r\nnecessarily immediately after it); otherwise, that digit is taken with a\r\npositive sign.For example, the value of the Ranom number is 1000 - 1 -\r\n1 - 1 - 10 + 1000 + 100 + 1 = 2088.You are given a Ranom number. You can\r\nchange no more than one digit in it. Calculate the maximum possible\r\nvalue of the resulting number.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << \" \"; cout << v[i];\n    }\n    cout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\n\nvector<int> v = { 1,10,100,1000,10000 };\n\nll dp[1 << 18][5][2];\nvoid solve() {\n    string s; cin >> s;\n    reverse(all(s));\n    rep(i, s.size() + 1) {\n        rep(j, 5)rep(k, 2)dp[i][j][k] = -INF;\n    }\n    dp[0][0][0] = 0;\n    rep(i, s.size()) {\n        int c = s[i] - 'A';\n        rep(j, 5)rep(k, 2) {\n            if (dp[i][j][k]==-INF)continue;\n            rep(ad, 5) {\n                int nj = max(j, ad);\n                int nk = k; if (ad != c)nk++;\n                if (nk > 1)continue;\n                ll val = dp[i][j][k];\n                if (j > ad)val -= v[ad];\n                else val += v[ad];\n                chmax(dp[i + 1][nj][nk], val);\n            }\n        }\n    }\n    ll ans = -INF;\n    rep(j, 5)rep(k, 2)chmax(ans, dp[s.size()][j][k]);\n    cout << ans << \"\\n\";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Ranom Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/117262",
    "editorial": "There are two main solutions to this problem: dynamic programming and\r\ngreedy.Reverse the string we were given, so that the sign of each digit\r\ndepends on the maximum digit to the left of it (not to the right). Then,\r\nrun the following dynamic programming: is the maximum value of the\r\nnumber if we considered first characters, applied changes to them ( is\r\neither or ), and the maximum character we encountered so far was ( can\r\nhave possible values). The transitions are fairly simple: when we\r\nconsider the state , we can either leave the current character as it is,\r\nor, if , iterate on the replacement for the current character and use\r\nthe replacement instead (then we go to the state with ). Note that this\r\nsolution can also work if we can make more than one operation. This\r\ndynamic programming has states (where is the number of different\r\ncharacters, and is the maximum number of changes we can make), and each\r\nstate has no more than outgoing transitions. In this problem, and , so\r\nthis solution easily passes.Of course, we can try to iterate on every\r\ncharacter and check all possible replacements for it, but quickly\r\ncalculating the answer after replacement can be a bit difficult.\r\nInstead, we claim the following: it is optimal to consider at most\r\npositions to replace the first and the last position of , the first and\r\nthe last position of , and so on. That way, we have only different\r\ncandidates for the answer, and we can check each of them in .How to\r\nprove that this is enough? When we replace a character, we either\r\nincrease or decrease it. If we increase a character, it\u00e2\u0080\u0099s easy to see\r\nwhy it\u00e2\u0080\u0099s optimal to try only the first occurrence of each character\r\nincreasing a character may affect some characters to the left of it\r\n(turn them from positive to negative), and by picking the first\r\noccurrence of a character, we make sure that the number of characters\r\ntransformed from positive to negative is as small as possible. Note that\r\nif the string has at least one character different from , we can replace\r\nthe first such character with and increase the answer by at least (this\r\nwill be useful in the second part of the proof).Now suppose it\u00e2\u0080\u0099s optimal\r\nto decrease a character, let\u00e2\u0080\u0099s show that it\u00e2\u0080\u0099s always optimal to choose\r\nthe last occurrence of a character to decrease. Suppose we decreased a\r\ncharacter, and it was not the last occurrence. This means that this\r\ncharacter will be negative after replacement, so it should be negative\r\nbefore the replacement. The maximum value we can add to the answer by\r\nreplacing a negative character with another negative character is\r\n(changing negative to negative ), and we have already shown that we can\r\nadd at least by replacing the first non- character in the string with .\r\nSo, if we decrease a character and it was not the last occurrence of\r\nthat character, it\u00e2\u0080\u0099s suboptimal.\r\n"
}