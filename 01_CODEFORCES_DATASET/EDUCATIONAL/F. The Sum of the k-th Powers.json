{
    "link": "https://codeforces.com//contest/622/problem/F",
    "problemId": "47920",
    "problem_idx": "F",
    "shortId": "622F",
    "contest_number": "622",
    "problem_submissions": {
        "F": [
            27693832,
            15938161,
            15938350,
            15937525,
            15940871,
            15940468,
            15941715,
            15935758,
            15942132,
            15939672,
            15962566,
            15966525,
            15955821,
            16477461,
            16135097
        ],
        "E": [
            15936192,
            15935128,
            15935464,
            15935136,
            15937412,
            15942338,
            15942779,
            15939453,
            15935850,
            15933034,
            15937053,
            15935414,
            15937343,
            15937472,
            15938233,
            15935244,
            15936698,
            15939486,
            15936424
        ],
        "D": [
            15933494,
            15933221,
            15933776,
            15937480,
            15935164,
            15939366,
            15936035,
            15940787,
            15933859,
            15935298,
            15934473,
            15934644,
            15933986,
            15934369,
            15934813,
            15934580,
            15935083,
            15935405,
            15937710
        ],
        "C": [
            15932039,
            15931591,
            15932212,
            15932351,
            15933060,
            15933265,
            15932091,
            15936323,
            15932756,
            15931784,
            15931982,
            15933549,
            15932246,
            15932409,
            15933086,
            15932288,
            15932372,
            15932233,
            15932181
        ],
        "B": [
            15931075,
            15931135,
            15931295,
            15931505,
            15932084,
            15932002,
            15931182,
            15931089,
            15931279,
            15931134,
            15931176,
            15931455,
            15931488,
            15931348,
            15931223,
            15931203,
            15931572,
            15931376,
            15931416
        ],
        "A": [
            15930972,
            15930991,
            15931097,
            15931150,
            15931799,
            15931265,
            15930996,
            15931213,
            15930997,
            15930976,
            15930999,
            15931143,
            15931011,
            15931015,
            15931009,
            15931021,
            15931298,
            15931086,
            15931092
        ]
    },
    "name": "F. The Sum of the k-th Powers",
    "statement": "There are well-known formulas: , , . Also mathematicians found similar\r\nformulas for higher degrees.Find the value of the sum modulo (so you\r\nshould find the remainder after dividing the answer by the value ).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nLL fac[SIZE];\nvoid ADD(LL &x,LL v){x=(x+v)%MOD;}\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL a=1%MOD;\n    while(y){\n        if(y&1)a=a*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return a;\n}\n//1-base\nstruct Difference{\n    LL a[SIZE],cc[SIZE];\n    int n;\n    void build(LL _a[],int _n){\n        fac[0]=1;\n        REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;\n        n=_n;\n        REPP(i,1,n+1)a[i]=_a[i];\n        REPP(i,1,n+1){\n            cc[i]=mypow(fac[i-1]*fac[n-i],MOD-2)*a[i]%MOD;\n            if((n-i)%2==1)cc[i]=(MOD-cc[i])%MOD;\n        }\n    }\n    LL get(LL x){\n        x%=MOD;\n        if(x<=n)return a[x];\n        LL an=0;\n        LL tmp=1;\n        REPP(i,1,n+1)tmp=tmp*(x-i)%MOD;\n        REPP(i,1,n+1){\n            ADD(an,tmp*mypow(x-i,MOD-2)%MOD*cc[i]);\n        }\n        return an;\n    }\n}D;\nLL a[SIZE];\nint main(){\n    DRII(n,k);\n    REPP(i,1,k+5){\n        a[i]=(a[i-1]+mypow(i,k))%MOD;\n    }\n    D.build(a,k+4);\n    cout<<D.get(n);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. The Sum of the k-th Powers.json",
    "editorial_link": "https://codeforces.com//blog/entry/23442",
    "editorial": "This problem was suggested by Ivan Popovich NVAL. Statement: the\r\nfunction of the sum is a polynomial of degree over variable . This\r\nstatement can be proved by induction (to make step you should take the\r\nderivative). Denote the value of the sum for . We can easily calculate\r\nthe values of for from to in time. If then we already have the answer.\r\nOtherwise let\u00e2\u0080\u0099s use Lagrange polynomial to get the value of the sum for\r\nthe given value . The Largange polynomial have the following form: . In\r\nour case and . To calculate in a linear time we should use that for all\r\n. It\u00e2\u0080\u0099s help us because with that property we can recalculate the inner\r\nproduct for from the inner product for simply by multiplying by two\r\nvalues and dividing by two values. So we can calculate the sum in linear\r\ntime over . ++ solution Complexity: ( appeared because we should find\r\nthe inverse element in the field modulo ).\r\n"
}