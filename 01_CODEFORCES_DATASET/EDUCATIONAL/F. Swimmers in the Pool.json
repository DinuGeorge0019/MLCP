{"link": "https://codeforces.com//contest/1845/problem/F", "problemId": "1986293", "problem_idx": "F", "shortId": "1845F", "contest_number": "1845", "problem_submissions": {"F": [211475859, 211492939, 211497555, 211490825, 211491595, 211499186, 211501170, 211510297, 211505215, 211508507, 211523706, 211508142, 211526813, 211526845, 211523227, 211522513, 211521610, 211527973], "E": [211462563, 211461492, 211471272, 211472249, 211480189, 211485085, 211477384, 211480631, 211479180, 211479798, 211487222, 211476273, 211646872, 211490174, 211488484, 211525957, 211524499, 211523817, 211482860, 211491352, 211488220, 211483247, 211483585, 211488962, 211482756, 211497978], "B": [211453598, 211442082, 211444910, 211443511, 211441772, 211442686, 211445493, 211443115, 211444001, 211449977, 211446525, 211444666, 211443749, 211447761, 211449897, 211443106, 211444760, 211445575, 211449630, 211442921], "D": [211450415, 211448543, 211458729, 211462418, 211460113, 211454656, 211463763, 211469130, 211470306, 211471906, 211459492, 211645284, 211472007, 211475281, 211467877, 211468462, 211468425, 211461450, 211463088, 211470068, 211462856], "C": [211443935, 211445016, 211453965, 211452711, 211452512, 211450213, 211454682, 211448771, 211452473, 211462596, 211453195, 211455269, 211452431, 211458111, 211462223, 211458912, 211452900, 211451834, 211462935, 211452522], "A": [211441020, 211441082, 211441390, 211441217, 211441011, 211441288, 211441347, 211441228, 211442540, 211441983, 211441400, 211441604, 211441498, 211442268, 211443714, 211441364, 211441612, 211441912, 211442694, 211441281]}, "name": "F. Swimmers in the Pool", "statement": "There is a pool of length l where n swimmers plan to swim. People start\r\nswimming at the same time (at the time moment 0), but you can assume\r\nthat they take different lanes, so they don\u2019t interfere with each\r\nother.Each person swims along the following route: they start at point 0\r\nand swim to point l with constant speed (which is equal to v_i units per\r\nsecond for the i-th swimmer). After reaching the point l, the swimmer\r\ninstantly (in negligible time) turns back and starts swimming to the\r\npoint 0 with the same constant speed. After returning to the point 0,\r\nthe swimmer starts swimming to the point l, and so on.Let\u2019s say that\r\nsome moment of time is a if there are swimmers that are in the same\r\npoint of the pool at that moment of time (that point may be 0 or l as\r\nwell as any other real point inside the pool).The pool will be open for\r\nt seconds. You have to calculate the number of meeting moments while the\r\npool is open. Since the answer may be very large, print it modulo 10^9 +\r\n7.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\ntypedef long long ll;\nconst int p=998244353;\nint po(int a,int b) {if(b==0) return 1; if(b==1) return a; if(b%2==0) {int u=po(a,b/2);return (u*1LL*u)%p;} else {int u=po(a,b-1);return (a*1LL*u)%p;}}\nint inv(int x) {return po(x,p-2);}\ntemplate<int M, int K, int G> struct Fft {\n  // 1, 1/4, 1/8, 3/8, 1/16, 5/16, 3/16, 7/16, ...\n  int g[1 << (K - 1)];\n  Fft() : g() { //if tl constexpr...\n    static_assert(K >= 2, \"Fft: K >= 2 must hold\");\n    g[0] = 1;\n    g[1 << (K - 2)] = G;\n    for (int l = 1 << (K - 2); l >= 2; l >>= 1) {\n      g[l >> 1] = (static_cast<long long>(g[l]) * g[l]) % M;\n    }\n    assert((static_cast<long long>(g[1]) * g[1]) % M == M - 1);\n    for (int l = 2; l <= 1 << (K - 2); l <<= 1) {\n      for (int i = 1; i < l; ++i) {\n        g[l + i] = (static_cast<long long>(g[l]) * g[i]) % M;\n      }\n    }\n  }\n  void fft(vector<int> &x) const {\n    const int n = x.size();\n    assert(!(n & (n - 1)) && n <= 1 << K);\n    for (int h = __builtin_ctz(n); h--; ) {\n      const int l = 1 << h;\n      for (int i = 0; i < n >> 1 >> h; ++i) {\n        for (int j = i << 1 << h; j < ((i << 1) + 1) << h; ++j) {\n          const int t = (static_cast<long long>(g[i]) * x[j | l]) % M;\n          if ((x[j | l] = x[j] - t) < 0) x[j | l] += M;\n          if ((x[j] += t) >= M) x[j] -= M;\n        }\n      }\n    }\n    for (int i = 0, j = 0; i < n; ++i) {\n      if (i < j) std::swap(x[i], x[j]);\n      for (int l = n; (l >>= 1) && !((j ^= l) & l); ) {}\n    }\n  }\n  vector<int> convolution(const vector<int> &a, const vector<int> &b) const {\n    if(a.empty() || b.empty()) return {};\n    const int na = a.size(), nb = b.size();\n    int n, invN = 1;\n    for (n = 1; n < na + nb - 1; n <<= 1) invN = ((invN & 1) ? (invN + M) : invN) >> 1;\n    vector<int> x(n, 0), y(n, 0);\n    std::copy(a.begin(), a.end(), x.begin());\n    std::copy(b.begin(), b.end(), y.begin());\n    fft(x);\n    fft(y);\n    for (int i = 0; i < n; ++i) x[i] = (((static_cast<long long>(x[i]) * y[i]) % M) * invN) % M;\n    std::reverse(x.begin() + 1, x.end());\n    fft(x);\n    x.resize(na + nb - 1);\n    return x;\n  }\n};\nFft<998244353,23,31> muls;\nvector<int> form(vector<int> v,int n)\n{\n    while(v.size()<n) v.push_back(0);\n    while(v.size()>n) v.pop_back();\n    return v;\n}\nvector<int> operator *(vector<int> v1,vector<int> v2)\n{\n    return muls.convolution(v1,v2);\n}\nvector<int> operator +(vector<int> v1,vector<int> v2)\n{\n    while(v2.size()<v1.size()) v2.push_back(0); while(v1.size()<v2.size()) v1.push_back(0);\n    for(int i=0;i<v1.size();++i) {v1[i]+=v2[i];if(v1[i]>=p) v1[i]-=p; else if(v1[i]<0) v1[i]+=p;}\n    return v1;\n}\nvector<int> operator -(vector<int> v1,vector<int> v2)\n{\n    int sz=max(v1.size(),v2.size());while(v1.size()<sz) v1.push_back(0); while(v2.size()<sz) v2.push_back(0);\n    for(int i=0;i<sz;++i) {v1[i]-=v2[i];if(v1[i]<0) v1[i]+=p; else if(v1[i]>=p) v1[i]-=p;} return v1;\n}\nvector<int> trmi(vector<int> v)\n{\n    for(int i=1;i<v.size();i+=2) {if(v[i]>0) v[i]=p-v[i]; else v[i]=(-v[i]);}\n    return v;\n}\nvector<int> deriv(vector<int> v)\n{\n    if(v.empty()) return{};\n    vector<int> ans(v.size()-1);\n    for(int i=1;i<v.size();++i) ans[i-1]=(v[i]*1LL*i)%p;\n    return ans;\n}\nvector<int> integ(vector<int> v)\n{\n    vector<int> ans(v.size()+1);ans[0]=0;\n    for(int i=1;i<v.size();++i) ans[i-1]=(v[i]*1LL*i)%p;\n    return ans;\n}\nvector<int> mul(vector<vector<int> > v)\n{\n    if(v.size()==1) return v[0];\n    vector<vector<int> > v1,v2;for(int i=0;i<v.size()/2;++i) v1.push_back(v[i]); for(int i=v.size()/2;i<v.size();++i) v2.push_back(v[i]);\n    return muls.convolution(mul(v1),mul(v2));\n}\nvector<int> inv1(vector<int> v,int n)\n{\n    assert(v[0]!=0);\n    int sz=1;v=form(v,n);vector<int> a={inv(v[0])};\n    while(sz<n)\n    {\n        vector<int> vsz;for(int i=0;i<min(n,2*sz);++i) vsz.push_back(v[i]);\n        vector<int> b=((vector<int>) {1})-muls.convolution(a,vsz);\n        for(int i=0;i<sz;++i) assert(b[i]==0);\n        b.erase(b.begin(),b.begin()+sz);\n        vector<int> c=muls.convolution(b,a);\n        for(int i=0;i<sz;++i) a.push_back(c[i]);\n        sz*=2;\n    }\n    return form(a,n);\n}\nvector<int> inv(vector<int> v,int n)\n{\n    v=form(v,n);assert(v[0]!=0);if(v.size()==1) {return {inv(v[0])};} vector<int> v1=trmi(v);\n    vector<int> a=v1*v;a=form(a,2*n);\n    vector<int> b((n+1)/2);for(int i=0;i<b.size();++i) b[i]=a[2*i];\n    vector<int> ans1=inv(b,b.size());vector<int> ans2(n);for(int i=0;i<n;++i) {if(i%2==0) ans2[i]=ans1[i/2]; else ans2[i]=0;}\n    return form(v1*ans2,n);\n}\nvector<int> operator/(vector<int> a,vector<int> b)\n{\n    while(!a.empty() && a.back()==0) a.pop_back(); while(!b.empty() && b.back()==0) b.pop_back();\n    int n=a.size();int m=b.size();if(n<m) return {};\n    reverse(a.begin(),a.end());reverse(b.begin(),b.end());vector<int> ans=a*inv(b,n-m+1);while(ans.size()>n-m+1) ans.pop_back();\n    reverse(ans.begin(),ans.end());while(!ans.empty() && ans.back()==0) ans.pop_back();return ans;\n}\nvector<int> operator%(vector<int> a,vector <int> b)\n{\n    vector<int> ans=a-b*(a/b);while(!ans.empty() && ans.back()==0) ans.pop_back(); return ans;\n}\nconst int mod=1e9+7;\nconst int maxn=4e5+5;\nint o=maxn/2;\nbool ok[maxn];\nint answ[maxn];\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int l,t1;cin>>l>>t1;\n    int n;\n    cin>>n;\n    vector<int> a(maxn);\n    for(int i=0;i<n;++i)\n    {\n        int v;cin>>v;a[v]=1;\n    }\n    vector<int> a1=a*a;\n    for(int i=0;i<maxn;++i)\n    {\n        int h=a1[i];if(i%2==0 && a[i/2]) h--;\n        if(h) {ok[i]=true;}\n    }\n    vector<int> b=a;\n    reverse(b.begin(),b.begin()+o);\n    vector<int> a2=a*b;\n    for(int i=0;i<o;++i)\n    {\n        if(a2[i])\n        {\n            ok[o-i-1]=true;\n        }\n    }\n    //for(int j=0;j<10;++j) cout<<ok[j]<<' '; cout<<endl;\n    for(int g=1;g<maxn;++g)\n    {\n        answ[g]=(t1*g)/(2*l);\n    }\n    int res=0;\n    for(int g=1;g<maxn;++g)\n    {\n        bool ok1=false;\n        for(int k=g;k<maxn;k+=g)\n        {\n            if(ok[k]) ok1=true;\n            if(k!=g) answ[k]-=answ[g];\n        }\n        //if(ok1) cout<<g<<\" g \"<<answ[g]<<\" answ[g] \"<<endl;\n        if(ok1) {res+=answ[g];res%=mod;}\n    }\n    cout<<(res%mod+mod)%mod;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "fft", "math", "number theory"], "dificulty": "2800", "interactive": false}