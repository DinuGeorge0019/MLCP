{"link": "https://codeforces.com//contest/1879/problem/E", "problemId": "2226289", "problem_idx": "E", "shortId": "1879E", "contest_number": "1879", "problem_submissions": {"F": [224937536, 224935202, 224950610, 224926179, 224962842, 224969051, 224930929, 224967422, 224963265, 224966461, 224940572, 224966841, 224954569, 225047271, 224982141, 224973229, 225020484, 225376642, 224974176, 225441069], "E": [224915766, 224914283, 224947954, 224935300, 224927963, 224966463, 224932997, 224929889, 224950618, 224966233, 224954318, 224969484, 224930880, 224920140, 224922897, 224920584, 224928749, 224925724, 224924188, 224933925], "D": [224888044, 224890483, 224896670, 224904072, 224896642, 224898559, 224895640, 224898718, 224909765, 224890763, 224903520, 224917804, 224935485, 224900120, 224899388, 224897270, 224896991, 224895504, 224897180, 224904052], "C": [224883111, 224886635, 224905698, 224893770, 224888377, 224894906, 224886723, 224893779, 224902835, 224885562, 224895691, 224922809, 224940882, 224893191, 224888785, 224888462, 224890469, 224889684, 224903420, 224892974], "B": [224880512, 224883808, 224889537, 224888023, 224883379, 224885924, 224899117, 224885706, 224885740, 224883031, 224886861, 224914364, 224945905, 224884557, 224881988, 224884765, 224884529, 224883777, 224884553, 224888797], "A": [224880000, 224880258, 224880343, 224880667, 224881398, 224880389, 224901703, 224881377, 224880233, 224880172, 224880548, 224906481, 224947822, 224880196, 224880217, 225049284, 224880515, 224880208, 224880388, 224880513, 224881480]}, "name": "E. Interactive Game with Coloring", "statement": "You may use in C++, in Java, in Python or in Pascal to flush the output.\r\nIf you use some other programming language, consult its documentation.\r\nYou may also refer to the guide on interactive problems:\r\nhttps://codeforces.com/blog/entry/45307.You are given a tree on n\r\nvertices; vertex 1 is the root of the tree. For every i\r\nin [2, n], the parent of the i-th vertex is p_i, and p_i < i.You have to\r\ncolor all edges of the tree using the such that you can win the game on\r\nthat tree (every edge should be painted into exactly one color).The game\r\nwe\u2019re going to play will be conducted as follows. After you paint the\r\nedges and print their colors, the jury will place a chip into one of the\r\nvertices of the tree (except for the root). Your goal is to move this\r\nchip to the root in exactly d moves, where d is the distance from the\r\nroot to that vertex (the distance is equal to the number of edges on the\r\npath). If the chip reaches the root in d moves, you win. Otherwise, you\r\nlose.The jury won\u2019t tell you where the chip is located. You won\u2019t even\r\nknow the value of d in advance. However, at the start of each move, you\r\nwill be told how many edges of each color are incident to the current\r\nvertex (this includes both the edge leading up the tree and the edges\r\nleading away from the root). You have to choose one of these colors, and\r\nthe chip will be moved along the edge of the chosen color (if there are\r\nmultiple edges with that color incident to the current vertex, the jury\r\ngets to choose one of them). After the chip is moved, you will be told\r\nthe same information about the current vertex again, and the game\r\ncontinues, until you either reach the root, or you make d moves without\r\nreaching the root.. It means that both the starting vertex and the\r\ncurrent vertex are and may change \"on the run\" depending on the output\r\nof your program. However, the state of the game will always be\r\nconsistent with the information you are given: .\r\n", "solutions": ["#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    int dep[N]; F0R(i, N) dep[i] = 0;\n    int deg[N]; F0R(i, N) deg[i] = 0;\n    int rt[N]; F0R(i, N) rt[i] = 0;\n    int cap = 0;\n    FOR(i, 1, N) {\n        int X; cin >> X; X--;\n        dep[i] = dep[X] + 1;\n        deg[i]++; deg[X]++;\n        ckmax(cap, dep[i]);\n        if (X == 0) {\n            rt[i] = i;\n        } else rt[i] = rt[X];\n    }\n    if (cap == 1) {\n        cout << 1 << endl;\n        FOR(i, 1, N) {\n            cout << 1 << \" \";\n        }\n        cout << endl;\n        while (true) {\n            int X; cin >> X;\n            if (X != 0) return;\n            cin >> X;\n            cout << 1 << endl;\n        }\n    }\n    map<int, int> pa;\n    bool ok = true;\n    FOR(i, 1, N) {\n        if (deg[i] == 2) {\n            if (!pa.count(rt[i])) pa[rt[i]] = dep[i]%2;\n            if (pa[rt[i]] != dep[i]%2) ok = false;\n        }\n    }\n    if (ok) {\n        cout << 2 << endl;\n        FOR(i, 1, N) {\n            int val = dep[i] % 2;\n            if (val == 0) val = 2;\n            if (pa[rt[i]] == 0) val = 3 - val;\n            cout << val << \" \";\n        }\n        cout << endl;\n        while (true) {\n            int X; cin >> X;\n            if (X != 0) return;\n            int A, B; cin >> A >> B;\n            if (A == 1) {\n                cout << 1 << endl;\n            } else {\n                cout << 2 << endl;\n            }\n        }\n    }\n    cout << 3 << endl;\n    FOR(i, 1, N) {\n        int val = dep[i] % 3;\n        if (val == 0) val = 3;\n        cout << val << \" \";\n    }\n    cout << endl;\n    assert(cap >= 3);\n    while (true) {\n        int X; cin >> X;\n        if (X != 0) return;\n        int A[3]; F0R(i, 3) A[i] = 0;\n        F0R(i, min(cap, 3)) cin >> A[i];\n        int cnt = 0;\n        F0R(i, min(cap, 3)) cnt += A[i];\n        F0R(i, 3) {\n            if (A[i] == cnt) {\n                cout << i+1 << endl;\n                goto done;\n            }\n        }\n        F0R(i, 3) {\n            if (A[i] == 0) {\n                cout << (i+1)%3 + 1 << endl;\n                goto done;\n            }\n        }\n        done:\n        ;\n    }\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "dfs and similar", "graphs", "implementation", "interactive", "trees"], "dificulty": "2400", "interactive": false}