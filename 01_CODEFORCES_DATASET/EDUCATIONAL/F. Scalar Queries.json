{"link": "https://codeforces.com//contest/1167/problem/F", "problemId": "344635", "problem_idx": "F", "shortId": "1167F", "contest_number": "1167", "problem_submissions": {"G": [54199521, 54201009, 54517594, 54222661, 54364012, 54215552, 54224700, 54210170, 54210125, 54210060, 54209496, 54208961, 54219271, 58247930], "F": [54189763, 54191560, 54188017, 54193815, 54198047, 54197721, 54195395, 54190513, 54198962, 54198980, 54197783, 54198116, 54209016, 54200221, 54197337, 54195561, 54196921, 54190680, 54201016, 54197503, 54199324], "E": [54187099, 54187335, 54196048, 54186318, 54187789, 54191563, 54192086, 54195810, 54191131, 54191667, 54192242, 54194803, 54192777, 54191266, 54189610, 54192694, 54196385, 54241812, 54208508, 54196237, 54192975, 54196282], "D": [54184655, 54183868, 54182601, 54254072, 54187816, 54183265, 54184958, 54187415, 54186508, 54185650, 54184214, 54187917, 54185330, 54215169, 54214062, 54213957, 54213940, 54212912, 54212894, 54186804, 54192578, 54182335, 54185963, 54184762, 54186406, 54188164, 54188808], "C": [54183325, 54182652, 54179797, 54181639, 54180270, 54183029, 54186018, 54184791, 54184638, 54183698, 54183060, 54181938, 54183556, 54183141, 54183089, 54180288, 54184423, 54183220, 54184555, 54185863, 54182921], "B": [54182048, 54181521, 54184836, 54179971, 54182085, 54181491, 54183487, 54185276, 54182631, 54181677, 54186071, 54182415, 54181445, 54182146, 54198453, 54183319, 54181503, 54182555, 54184235, 54186573], "A": [54178078, 54178458, 54177903, 54177871, 54177876, 54178109, 54178374, 54178382, 54178054, 54178274, 54179924, 54177952, 54177881, 54177926, 54178075, 54177978, 54177900, 54179121, 54179411, 54179558]}, "name": "F. Scalar Queries", "statement": "You are given an array a_1, a_2,\r\ndots, a_n. All a_i are pairwise distinct.Let\u2019s define function f(l, r)\r\nas follows: let\u2019s define array b_1, b_2,\r\ndots, b_{r - l + 1}, where b_i = a_{l - 1 + i}; sort array b in\r\nincreasing order; result of the function f(l, r) is\r\nsum\r\nlimits_{i = 1}^{r - l + 1}{b_i\r\ncdot i}. Calculate\r\nleft(\r\nsum\r\nlimits_{1\r\nle l\r\nle r\r\nle n}{f(l, r)}\r\nright)\r\nmod (10^9+7), i.e. total sum of f for all subsegments of a modulo\r\n10^9+7.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\n\nll tab[nax];\n\nll wyn;\n\nll drz[nax][2];//0 to z lewej\n\nvoid pisz(int v, ll w, int p)\n{\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tdrz[i][p]=(drz[i][p]+w)%mod;\n}\n\nll czyt(int a, int b, int p)\n{\n\tll ret=0;\n\tfor (int i=b; i; i-=(i&(-i)))\n\t\tret+=drz[i][p];\n\tfor (int i=a-1; i; i-=(i&(-i)))\n\t\tret-=drz[i][p];\n\tret%=mod;\n\tif (ret<0)\n\t\tret+=mod;\n\treturn ret;\n}\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tdod(wyn, tab[i]*i%mod*(n-i+1));\n\tvector <pll> wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back({tab[i], i});\n\tsort(wek.begin(), wek.end());\n\tdebug() << imie(wyn);\n\tfor (pll h : wek)\n\t{\n\t\tint i=h.second;\n\t\tll lew=czyt(1, i-1, 0);\n\t\tll pra=czyt(i+1, n, 1);\n\t\tdod(wyn, lew*(n+1-i)%mod*tab[i]+pra*i%mod*tab[i]);\n\t\tpisz(i, i, 0);\n\t\tpisz(i, n-i+1, 1);\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "data structures", "math", "sortings"], "dificulty": "2300", "interactive": false}