{"link": "https://codeforces.com//contest/818/problem/G", "problemId": "112251", "problem_idx": "G", "shortId": "818G", "contest_number": "818", "problem_submissions": {"G": [30023806, 28149762, 28149727, 28149674, 28150840, 28150782, 28150772, 28150751, 28150583, 36665796, 28151676, 28150077, 28257233, 28153699, 28148603, 28155021, 28156689, 28156349, 28183779], "F": [28147295, 28150245, 28148357, 28147147, 28148601, 28147618, 28149338, 28148822, 28148432, 28150045, 28149715, 28149799, 28150664, 28150399, 28265989, 28152841, 28152214, 28151371, 28150016, 28150927, 28150947, 28149764], "E": [28145911, 28145866, 28146912, 28146350, 28146816, 28150531, 28146712, 28147272, 28147609, 28147038, 28148502, 28147986, 28147358, 28149016, 28148737, 28150693, 28148409, 28146623, 28149530, 28149268, 28147603], "D": [28144801, 28145060, 28145928, 28145417, 28145327, 28143658, 28146282, 28144973, 28145879, 28146889, 28146309, 28145676, 28146984, 28146985, 28145000, 28147304, 28145917, 28147015, 28147874, 28146172], "C": [28144306, 28147073, 28145409, 28144547, 28144448, 28144425, 28145368, 28146425, 28145275, 28145837, 28145300, 28145004, 28145976, 28145637, 28147975, 28146492, 28148332, 28146298, 28146819, 28144965], "B": [28143095, 28143560, 28143556, 28143415, 28143669, 28144503, 28144240, 28143720, 28144083, 28143468, 28143875, 28143599, 28143355, 28143995, 28143629, 28143924, 28143708, 28142954, 28143812, 28144185], "A": [28142461, 28142521, 28142540, 28142460, 28142740, 28142644, 28142466, 28142416, 28142519, 28142508, 28142479, 28142800, 28142422, 28142542, 28142573, 28142463, 28142490, 28142485]}, "name": "G. Four Melodies", "statement": "Alice is a composer, and recently she had recorded two tracks that\r\nbecame very popular. Now she has got a lot of fans who are waiting for\r\nnew tracks. This time Alice wants to form four melodies for her\r\ntracks.Alice has a sheet with notes written on it. She wants to take\r\nfour such non-empty non-intersecting subsequences that all of them form\r\na and sum of their lengths is maximal.Subsequence forms a melody when\r\neach two adjacent notes either differ by or are congruent modulo .You\r\nshould write a program which will calculate maximum sum of lengths of\r\nsuch four non-empty non-intersecting subsequences that all of them form\r\na melody.\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ninline int getint(){\n  int _x=0; char _tc=getchar();    \n  while(_tc<'0'||_tc>'9') _tc=getchar();\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x;\n}\n/*\n  A template for Min Cost Max Flow\n  tested with TIOJ 1724\n*/\nstruct MinCostMaxFlow{\ntypedef int Tcost;\n  static const int MAXV = 100010;\n  static const int INFf = 1e6;\n  static const Tcost INFc  = 1e6;\n  struct Edge{\n    int v, cap;\n    Tcost w;\n    int rev;\n    Edge(){}\n    Edge(int t2, int t3, Tcost t4, int t5)\n    : v(t2), cap(t3), w(t4), rev(t5) {}\n  };\n  int V, s, t;\n  vector<Edge> g[MAXV];\n  void init(int n){\n    V = n+2;\n    s = n+1, t = n+2;\n    for(int i = 0; i <= V; i++) g[i].clear();\n  }\n  void addEdge(int a, int b, int cap, Tcost w){\n    g[a].push_back(Edge(b, cap, w, (int)g[b].size()));\n    g[b].push_back(Edge(a, 0, -w, (int)g[a].size()-1));\n  }\n  Tcost d[MAXV];\n  int id[MAXV], mom[MAXV];\n  bool inqu[MAXV];\n  queue<int> q;\n  Tcost solve(){\n    int mxf = 0; Tcost mnc = 0;\n    while(1){\n      fill(d, d+1+V, INFc);\n      fill(inqu, inqu+1+V, 0);\n      fill(mom, mom+1+V, -1);\n      mom[s] = s;\n      d[s] = 0;\n      q.push(s); inqu[s] = 1;\n      while(q.size()){\n        int u = q.front(); q.pop();\n        inqu[u] = 0;\n        for(int i = 0; i < (int) g[u].size(); i++){\n          Edge &e = g[u][i];\n          int v = e.v;\n          if(e.cap > 0 && d[v] > d[u]+e.w){\n            d[v] = d[u]+e.w;\n            mom[v] = u;\n            id[v] = i;\n            if(!inqu[v]) q.push(v), inqu[v] = 1;\n          }\n        }\n      }\n      if(mom[t] == -1) break ;\n      int df = INFf;\n      for(int u = t; u != s; u = mom[u])\n        df = min(df, g[mom[u]][id[u]].cap);\n      for(int u = t; u != s; u = mom[u]){\n        Edge &e = g[mom[u]][id[u]];\n        e.cap             -= df;\n        g[e.v][e.rev].cap += df;\n      }\n      mxf += df;\n      mnc += df*d[t];\n    }\n    return mnc;\n  }\n} flow;\n#define N 3030\nint n , a[ N ];\nvoid init(){\n  n = getint();\n  //n = 3000;\n  for( int i = 1 ; i <= n ; i ++ ){\n    a[ i ] = getint();\n    //a[ i ] = 2 - (i % 2);\n  }\n}\nvoid solve(){\n  flow.init( n + n + 1 );\n  int s = n + n + 1;\n  flow.addEdge( flow.s , s , 4 , 0 );\n// void addEdge(int a, int b, int cap, int w){\n  for( int i = 1 ; i <= n ; i ++ ){\n    flow.addEdge( s , i , 1 , 0 );\n    flow.addEdge( i , i + n , 1 , -1 );\n    flow.addEdge( i + n , flow.t , 1 , 0 );\n    //for( int j = i + 1 ; j <= n ; j ++ )\n      //if( abs( a[ i ] - a[ j ] ) == 1 or a[ i ] % 7 == a[ j ] % 7 )\n        //flow.addEdge( i + n , j , 1 , 0 );\n    int con = 0;\n    int neg = 0;\n    int pos = 0;\n#define MAGIC 10\n    for( int j = i + 1 ; j <= n ; j ++ ){\n      if( a[ j ] - a[ i ] == -1 and neg < MAGIC ){\n        neg ++;\n        flow.addEdge( i + n , j , 1 , 0 );\n      }\n      if( a[ j ] - a[ i ] == +1 and pos < MAGIC ){\n        pos ++;\n        flow.addEdge( i + n , j , 1 , 0 );\n      }\n      if( a[ j ] % 7 == a[ i ] % 7 and con < MAGIC ){\n        con ++;\n        flow.addEdge( i + n , j , 1 , 0 );\n      }\n    }\n  }\n  cout << -flow.solve() << endl;\n}\nint main(){\n  init();\n  solve();\n}\n"], "input": "", "output": "", "tags": ["flows", "graphs"], "dificulty": "2600", "interactive": false}