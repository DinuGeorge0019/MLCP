{
    "link": "https://codeforces.com//contest/990/problem/E",
    "problemId": "188994",
    "problem_idx": "E",
    "shortId": "990E",
    "contest_number": "990",
    "problem_submissions": {
        "F": [
            39110066,
            39104822,
            39113275,
            39114587,
            39116563,
            39116347,
            39108471,
            39110743,
            39112419,
            39112294,
            39108515,
            39111997,
            39116686,
            39101868,
            39116200,
            39118004,
            39116805
        ],
        "G": [
            39103567,
            39107402,
            39106809,
            39106218,
            39109082,
            39109620,
            39112690,
            39099088,
            39107571,
            39107687,
            39101902,
            39093184,
            39110367,
            39109522,
            39104630,
            39111664,
            39109028,
            39108412,
            39110999,
            39098996,
            39104033,
            39110989
        ],
        "E": [
            39100436,
            39099837,
            39102349,
            39105427,
            39103107,
            39102633,
            39102885,
            39108880,
            39105761,
            39109203,
            39112620,
            39094389,
            39105905,
            39112883,
            39105943,
            39113374,
            39104376,
            39107310,
            39113606,
            39104223
        ],
        "D": [
            39097266,
            39096033,
            39098379,
            39099218,
            39098520,
            39098083,
            39096052,
            39105736,
            39099850,
            39105515,
            39109276,
            39104646,
            39099923,
            39115103,
            39100668,
            39103321,
            39099280,
            39102959,
            39097613,
            39097717
        ],
        "C": [
            39093177,
            39093378,
            39093798,
            39094808,
            39094793,
            39094824,
            39092448,
            39093937,
            39096177,
            39100038,
            39095064,
            39091685,
            39095797,
            39094884,
            39094704,
            39096565,
            39094721,
            39095152,
            39094603,
            39094594
        ],
        "B": [
            39090464,
            39091292,
            39090459,
            39091170,
            39091740,
            39091855,
            39090681,
            39099050,
            39093555,
            39099346,
            39098193,
            39090407,
            39092627,
            39091505,
            39092737,
            39092039,
            39090632,
            39091613,
            39090743,
            39091072
        ],
        "A": [
            39088999,
            39088905,
            39088870,
            39088899,
            39089924,
            39089350,
            39089008,
            39089597,
            39089600,
            39090391,
            39090409,
            39089125,
            39089740,
            39090714,
            39089522,
            39088868,
            39088892,
            39089011,
            39089148
        ]
    },
    "name": "E. Post Lamps",
    "statement": "Adilbek\u2019s house is located on a street which can be represented as the\r\nOX axis. This street is really dark, so Adilbek wants to install some\r\npost lamps to illuminate it. Street has n positions to install lamps,\r\nthey correspond to the integer numbers from 0 to n - 1 on the OX axis.\r\nHowever, some positions are blocked and no post lamp can be placed\r\nthere.There are post lamps of different types which differ only by their\r\npower. When placed in position x, post lamp of power l illuminates the\r\nsegment [x; x + l]. The power of each post lamp is always a positive\r\ninteger number.The post lamp shop provides an infinite amount of lamps\r\nof each type from power 1 to power k. Though each customer is only\r\nallowed to order post lamps of type. Post lamps of power l cost a_l\r\neach.What is the minimal total cost of the post lamps of type Adilbek\r\ncan buy to illuminate the entire segment [0; n] of the street? If some\r\nlamps illuminate any other segment of the street, Adilbek does not care,\r\nso, for example, he may place a lamp of power 3 in position n - 1 (even\r\nthough its illumination zone doesn\u2019t completely belong to segment [0;\r\nn]).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxm = 1000005;\nconst ll Inf = 9000000000000000000ll;\n\nint n, m, k;\nbool block[Maxm];\nint cnt[Maxm];\nint a[Maxm];\nll res = Inf;\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a; scanf(\"%d\", &a);\n\t\tblock[a] = true;\n\t}\n\tint mx = 0;\n\tfor (int i = 0; i < Maxm; i++)\n\t\tif (block[i]) {\n\t\t\tcnt[i] = 1;\n\t\t\tif (i) cnt[i] += cnt[i - 1];\n\t\t\tmx = max(mx, cnt[i]);\n\t\t}\n\tif (block[0]) { printf(\"-1\\n\"); return 0; }\n\tfor (int i = 1; i <= k; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = mx + 1; i <= k; i++) {\n\t\tint cur = 0;\n\t\tll cand = 0;\n\t\twhile (cur < n)\n\t\t\tif (block[cur]) cur -= cnt[cur];\n\t\t\telse { cand += a[i]; cur += i; }\n\t\tres = min(res, cand);\n\t}\n\tif (res >= Inf) printf(\"-1\\n\");\n\telse cout << res << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Post Lamps.json",
    "editorial_link": "https://codeforces.com//blog/entry/59962",
    "editorial": "Let\u00e2\u0080\u0099s start with learning how to place lamps of fixed power to cover the\r\nsegment with the minimal number of them. The following greedy strategy\r\nworks: find the rightmost non-blocked position that is covered by lamps\r\nand place lamp there until either everything is covered or rightmost\r\nfree position is to the left of the last placed lamp. Initially you only\r\nconsider to be covered. Function the minimal number of post lamps to\r\ncover segment is clearly monotonous, thus you want to update states as\r\nearly as possible.Okay, now you iterate over all and update the answer\r\nwith the results multiplied by cost.Now, why will this work fast? You\r\nobviously precalculate the rightmost free position for each prefix\r\nsegment. If there are any free positions to the right of last placed\r\nlamp then the rightmost of them will always be the rightmost for the\r\nentire prefix segment. Finally, any two consecutive iterations of the\r\nalgorithm will either move you by positions or return . This can be\r\neasily proven by contradiction.Overall complexity: , as you do about\r\nsteps for each and that is a common series sum.\r\n"
}