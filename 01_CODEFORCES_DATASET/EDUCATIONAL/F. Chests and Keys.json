{"link": "https://codeforces.com//contest/1519/problem/F", "problemId": "971591", "problem_idx": "F", "shortId": "1519F", "contest_number": "1519", "problem_submissions": {"C": [114616470, 114551329, 114551180, 114564495, 114550309, 114552694, 114547702, 114548020, 114553618, 114563241, 114559641, 114555665, 114557042, 114556787, 114554939, 114556558, 114555376, 114549327, 114552625, 114552238, 114554684, 114559315], "F": [114613463, 114611288, 114604337, 114598897, 114611467, 114680142, 114636104, 114635840], "E": [114607966, 114580590, 114575288, 114583294, 114570654, 114566689, 114580490, 114581344, 114581275, 114584747, 114587745, 114586133, 114587347, 114590609, 114592573, 114589054, 114601871, 114596259, 114594317, 114625207, 114625166, 114600206, 114595857], "D": [114555495, 114555902, 114567847, 114556972, 114556567, 114552424, 114552771, 114561234, 114544188, 114558776, 114560835, 114564971, 114561515, 114561300, 114565333, 114554107, 114558569, 114558286, 114563876, 114568526], "B": [114542697, 114545137, 114558022, 114545565, 114550455, 114542163, 114542842, 114545295, 114550992, 114551627, 114546744, 114549467, 114548090, 114544402, 114547969, 114543205, 114546111, 114545907, 114546890, 114546969], "A": [114541604, 114541862, 114551019, 114541996, 114541593, 114541608, 114541607, 114541640, 114546683, 114543589, 114543013, 114543817, 114542361, 114541678, 114541836, 114541598, 114541959, 114541646, 114541768, 114542287]}, "name": "F. Chests and Keys", "statement": "Alice and Bob play a game. Alice has got n treasure chests (the i-th of\r\nwhich contains a_i coins) and m keys (the j-th of which she can sell Bob\r\nfor b_j coins).Firstly, Alice puts some locks on the chests. There are m\r\ntypes of locks, the locks of the j-th type can only be opened with the\r\nj-th key. To put a lock of type j on the i-th chest, Alice has to pay\r\nc_{i,j} dollars. Alice can put any number of different types of locks on\r\neach chest (possibly, zero).Then, Bob buys some of the keys from Alice\r\n(possibly none, possibly all of them) and opens each chest he can (he\r\ncan open a chest if he has the keys for all of the locks on this chest).\r\nBob\u2019s profit is the difference between the total number of coins in the\r\nopened chests and the total number of coins he spends buying keys from\r\nAlice. If Bob\u2019s profit is (greater than zero), he wins the game.\r\nOtherwise, Alice wins the game.Alice wants to put some locks on some\r\nchests so no matter which keys Bob buys, she always wins (Bob cannot get\r\npositive profit). Of course, she wants to spend the minimum possible\r\nnumber of dollars on buying the locks. Help her to determine whether she\r\ncan win the game at all, and if she can, how many dollars she has to\r\nspend on the locks.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int INF = int(1e9) + 5;\nconst int COINS = 4;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N), B(M);\n\n    for (auto &a : A)\n        cin >> a;\n\n    for (auto &b : B)\n        cin >> b;\n\n    int a_total = accumulate(A.begin(), A.end(), 0);\n    int b_total = accumulate(B.begin(), B.end(), 0);\n\n    if (a_total > b_total) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n\n    vector<vector<int>> C(N, vector<int>(M));\n\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            cin >> C[i][j];\n\n    vector<int> PC(M + 1, 1);\n\n    for (int i = 0; i < M; i++)\n        PC[i + 1] = (COINS + 1) * PC[i];\n\n    auto encode = [&](const vector<int> &remain) -> int {\n        assert(int(remain.size()) == M);\n        int encoded = 0;\n\n        for (int i = 0; i < M; i++)\n            encoded += remain[i] * PC[i];\n\n        return encoded;\n    };\n\n    auto get = [&](int encoded, int index) -> int {\n        return encoded / PC[index] % (COINS + 1);\n    };\n\n    auto reduce = [&](int encoded, int index, int subtract) -> int {\n        assert(subtract <= get(encoded, index));\n        return encoded - subtract * PC[index];\n    };\n\n    int states = PC[M];\n    vector<int> dp(states, INF);\n    dp[encode(B)] = 0;\n\n    for (int i = 0; i < N; i++) {\n        vector<int> ndp(states, INF);\n\n        auto recurse = y_combinator([&](auto self, int encoded, int key, int cost, int still) -> void {\n            if (key >= M) {\n                if (still == 0)\n                    ndp[encoded] = min(ndp[encoded], cost);\n\n                return;\n            }\n\n            self(encoded, key + 1, cost, still);\n            cost += C[i][key];\n\n            for (int take = 1; take <= min(get(encoded, key), still); take++)\n                self(reduce(encoded, key, take), key + 1, cost, still - take);\n        });\n\n        for (int encoded = 0; encoded < states; encoded++)\n            if (dp[encoded] < INF)\n                recurse(encoded, 0, dp[encoded], A[i]);\n\n        dp.swap(ndp);\n    }\n\n    cout << *min_element(dp.begin(), dp.end()) << '\\n';\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "dfs and similar", "dp", "flows"], "dificulty": "3200", "interactive": false}