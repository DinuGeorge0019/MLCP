{
    "link": "https://codeforces.com//contest/1519/problem/F",
    "problemId": "971591",
    "problem_idx": "F",
    "shortId": "1519F",
    "contest_number": "1519",
    "problem_submissions": {
        "C": [
            114616470,
            114551329,
            114551180,
            114564495,
            114550309,
            114552694,
            114547702,
            114548020,
            114553618,
            114563241,
            114559641,
            114555665,
            114557042,
            114556787,
            114554939,
            114556558,
            114555376,
            114549327,
            114552625,
            114552238,
            114554684,
            114559315
        ],
        "F": [
            114613463,
            114611288,
            114604337,
            114598897,
            114611467,
            114680142,
            114636104,
            114635840
        ],
        "E": [
            114607966,
            114580590,
            114575288,
            114583294,
            114570654,
            114566689,
            114580490,
            114581344,
            114581275,
            114584747,
            114587745,
            114586133,
            114587347,
            114590609,
            114592573,
            114589054,
            114601871,
            114596259,
            114594317,
            114625207,
            114625166,
            114600206,
            114595857
        ],
        "D": [
            114555495,
            114555902,
            114567847,
            114556972,
            114556567,
            114552424,
            114552771,
            114561234,
            114544188,
            114558776,
            114560835,
            114564971,
            114561515,
            114561300,
            114565333,
            114554107,
            114558569,
            114558286,
            114563876,
            114568526
        ],
        "B": [
            114542697,
            114545137,
            114558022,
            114545565,
            114550455,
            114542163,
            114542842,
            114545295,
            114550992,
            114551627,
            114546744,
            114549467,
            114548090,
            114544402,
            114547969,
            114543205,
            114546111,
            114545907,
            114546890,
            114546969
        ],
        "A": [
            114541604,
            114541862,
            114551019,
            114541996,
            114541593,
            114541608,
            114541607,
            114541640,
            114546683,
            114543589,
            114543013,
            114543817,
            114542361,
            114541678,
            114541836,
            114541598,
            114541959,
            114541646,
            114541768,
            114542287
        ]
    },
    "name": "F. Chests and Keys",
    "statement": "Alice and Bob play a game. Alice has got n treasure chests (the i-th of\r\nwhich contains a_i coins) and m keys (the j-th of which she can sell Bob\r\nfor b_j coins).Firstly, Alice puts some locks on the chests. There are m\r\ntypes of locks, the locks of the j-th type can only be opened with the\r\nj-th key. To put a lock of type j on the i-th chest, Alice has to pay\r\nc_{i,j} dollars. Alice can put any number of different types of locks on\r\neach chest (possibly, zero).Then, Bob buys some of the keys from Alice\r\n(possibly none, possibly all of them) and opens each chest he can (he\r\ncan open a chest if he has the keys for all of the locks on this chest).\r\nBob’s profit is the difference between the total number of coins in the\r\nopened chests and the total number of coins he spends buying keys from\r\nAlice. If Bob’s profit is (greater than zero), he wins the game.\r\nOtherwise, Alice wins the game.Alice wants to put some locks on some\r\nchests so no matter which keys Bob buys, she always wins (Bob cannot get\r\npositive profit). Of course, she wants to spend the minimum possible\r\nnumber of dollars on buying the locks. Help her to determine whether she\r\ncan win the game at all, and if she can, how many dollars she has to\r\nspend on the locks.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int INF = int(1e9) + 5;\nconst int COINS = 4;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N), B(M);\n\n    for (auto &a : A)\n        cin >> a;\n\n    for (auto &b : B)\n        cin >> b;\n\n    int a_total = accumulate(A.begin(), A.end(), 0);\n    int b_total = accumulate(B.begin(), B.end(), 0);\n\n    if (a_total > b_total) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n\n    vector<vector<int>> C(N, vector<int>(M));\n\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            cin >> C[i][j];\n\n    vector<int> PC(M + 1, 1);\n\n    for (int i = 0; i < M; i++)\n        PC[i + 1] = (COINS + 1) * PC[i];\n\n    auto encode = [&](const vector<int> &remain) -> int {\n        assert(int(remain.size()) == M);\n        int encoded = 0;\n\n        for (int i = 0; i < M; i++)\n            encoded += remain[i] * PC[i];\n\n        return encoded;\n    };\n\n    auto get = [&](int encoded, int index) -> int {\n        return encoded / PC[index] % (COINS + 1);\n    };\n\n    auto reduce = [&](int encoded, int index, int subtract) -> int {\n        assert(subtract <= get(encoded, index));\n        return encoded - subtract * PC[index];\n    };\n\n    int states = PC[M];\n    vector<int> dp(states, INF);\n    dp[encode(B)] = 0;\n\n    for (int i = 0; i < N; i++) {\n        vector<int> ndp(states, INF);\n\n        auto recurse = y_combinator([&](auto self, int encoded, int key, int cost, int still) -> void {\n            if (key >= M) {\n                if (still == 0)\n                    ndp[encoded] = min(ndp[encoded], cost);\n\n                return;\n            }\n\n            self(encoded, key + 1, cost, still);\n            cost += C[i][key];\n\n            for (int take = 1; take <= min(get(encoded, key), still); take++)\n                self(reduce(encoded, key, take), key + 1, cost, still - take);\n        });\n\n        for (int encoded = 0; encoded < states; encoded++)\n            if (dp[encoded] < INF)\n                recurse(encoded, 0, dp[encoded], A[i]);\n\n        dp.swap(ndp);\n    }\n\n    cout << *min_element(dp.begin(), dp.end()) << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar",
        "dp",
        "flows"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Chests and Keys.json",
    "editorial_link": "https://codeforces.com//blog/entry/90212",
    "editorial": "Firstly, letâs try to find some naive solution for this problem. Letâs\r\niterate on the subset of locks Alice puts on the chests. After choosing\r\nthe subset of locks, how to check whether Bob can gain positive profit?\r\nWe can iterate on the subset of keys he can buy as well, but in fact,\r\nthis problem has a polynomial solution. Construct a flow network as\r\nfollows: each chest and each key represents a vertex; there are arcs\r\nfrom the source to the vertices representing the chests (each having\r\ncapacity ), arcs from the vertices representing the keys to the sink\r\n(each having capacity ), and for each chosen lock, an arc from the\r\nrespective chest-vertex to the respective key-vertex with infinite\r\ncapacity. If we find the minimum cut from the source to the sink, then\r\nBobâs profit is . The reasoning behind this solution is the following\r\none: if Bob takes all the chests and all the keys belonging to the first\r\npart of the cut, his profit is equal to the total cost of all chests he\r\nhas taken, minus the total cost of all keys he has taken, minus infinity\r\nif he takes a chest he canât open. And the value of the cut is equal to\r\nthe total cost of chests he doesnât take, plus the total cost of keys he\r\ntakes, plus infinity if he canât open some chest he takes (since the arc\r\nfrom this chest-vertex to one of the key-vertices belongs to the cut).\r\nSo, Bobâs profit is , and by minimizing the cut value, we maximize his\r\nprofit. A minimum cut can be easily found using any maxflow\r\nalgorithm.Unfortunately, even iterating through all subsets of locks is\r\ntoo slow. To improve this solution, we should look at the minimum cut\r\nand its usage a bit more in detail. Notice that Bob can always take no\r\nkeys and open no chests to get a profit of zero, so Aliceâs goal is to\r\nensure that it is the best Bobâs option. If Bob takes no chests and no\r\nkeys, it means that the cut divides the network into two parts: the\r\nsource and all other vertices. And, in terms of flows, it means that the\r\nmaximum flow in this network (I highlighted it because it is the key\r\nidea of the solution).Here the constraints on , and come in handy. We\r\ncan use a dynamic programming with the flow over all arcs going from the\r\nsource as one of the states. One of the ways to implement it is to have\r\nas the state, where through are the values of the flow going from the\r\narcs from the source, is the current vertex in the left part we\r\nconsider, is the current vertex in the right part we consider, and is\r\nthe flow we already pushed through the arc connecting vertex of the\r\nright part to the sink (and the value we store for this state is the\r\nminimum cost Alice has pay to reach this state). There are two basic\r\ntypes of transitions in this dynamic programming: we either skip the arc\r\nfrom to , or pick it and transfer some flow through it; and no matter\r\nwhat weâve chosen, we move to the next vertex of the left part (or to\r\nand increase by if we are already considering the -th vertex of the left\r\npart). The constraints were loose enough to implement this dp basically\r\nin any form (there was no need to compress the states into single\r\nintegers, for example, which was what the most participants of the round\r\ndid).\r\n",
    "hint": []
}