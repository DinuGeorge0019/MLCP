{
    "link": "https://codeforces.com//contest/1923/problem/C",
    "problemId": "2492666",
    "problem_idx": "C",
    "shortId": "1923C",
    "contest_number": "1923",
    "problem_submissions": {
        "F": [
            247927445,
            247926735,
            247941699,
            247942342,
            247957925,
            247930359,
            247950515,
            247952641,
            247961910,
            247957616,
            247954803,
            247957462,
            247965318,
            247958101,
            247966724,
            247961269,
            247975649,
            247970780
        ],
        "E": [
            247910260,
            247907637,
            247944549,
            247918053,
            247922522,
            247916787,
            247955209,
            247923339,
            247906437,
            247924189,
            247923801,
            247924733,
            247919146,
            247919411,
            247915457,
            248010348,
            247930116,
            247913617,
            247921891,
            247928453
        ],
        "D": [
            247906663,
            247903362,
            247909256,
            247913572,
            247912411,
            247905740,
            247917150,
            247917832,
            247911096,
            247917233,
            247917212,
            247913338,
            247913589,
            247931525,
            247913875,
            247917151,
            247917274,
            247912599
        ],
        "C": [
            247899621,
            247896441,
            247899387,
            247904054,
            247903940,
            247899293,
            247903341,
            247912953,
            247900198,
            247901509,
            247906201,
            247902190,
            247904629,
            247901902,
            247905627,
            247901567,
            247905304,
            247903364
        ],
        "B": [
            247895420,
            247893401,
            247895016,
            247899339,
            247899002,
            247894634,
            247896319,
            247907358,
            247897312,
            247896352,
            247897008,
            247896401,
            247900980,
            247897119,
            247897848,
            247898814,
            247898339,
            247898930
        ],
        "A": [
            247893064,
            247892642,
            247892787,
            247894650,
            247893381,
            247892909,
            247892866,
            247905142,
            247893155,
            247893038,
            247892799,
            247892722,
            247896270,
            247892907,
            247893359,
            247893598,
            247893062,
            247896053
        ]
    },
    "name": "C. Find B",
    "statement": "An array a of length m is considered good if there exists an integer\r\narray b of length m such that the following conditions hold:\r\nsum\r\nlimits_{i=1}^{m} a_i =\r\nsum\r\nlimits_{i=1}^{m} b_i; a_i\r\nneq b_i for every index i from 1 to m; b_i > 0 for every index i from 1\r\nto m. You are given an array c of length n. Each element of this array\r\nis greater than 0.You have to answer q queries. During the i-th query,\r\nyou have to determine whether the subarray c_{l_{i}}, c_{l_{i}+1},\r\ndots, c_{r_{i}} is good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n    }\n    \n    std::vector<i64> s1(n + 1), s2(n + 1);\n    for (int i = 0; i < n; i++) {\n        s1[i + 1] = s1[i] + c[i];\n        s2[i + 1] = s2[i] + (c[i] == 1 ? 2 : 1);\n    }\n    \n    while (q--) {\n        int l, r;\n        std::cin >> l >> r;\n        l--;\n        \n        i64 a = s1[r] - s1[l];\n        i64 b = s2[r] - s2[l];\n        if (a >= b && r - l >= 2) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Find B.json",
    "editorial_link": "https://codeforces.com//blog/entry/126339",
    "editorial": "At first, let\u00e2\u0080\u0099s precalculate the array of prefix sum and the number of\r\nelements equal to one on prefix (let\u00e2\u0080\u0099s denote them as and ). More\r\nformally, and , where the function returns if equals and otherwise . For\r\nexample, if , then and .Now we can answer the query , . For this, let\u00e2\u0080\u0099s\r\ncalculate the sum on subarray and the number of elements equal to on\r\nsubarray (let\u00e2\u0080\u0099s denote it as and ). We can do it by precalculated arrays\r\nand : ; . To answer query , at first let\u00e2\u0080\u0099s try to find the array with\r\nthe minimum value of . For this, for indexes , where we have to set ,\r\nand for indexes , where we have to set . Thus, the sum of all elements\r\nin array equal to or . Now we have three cases: If this sum is greater\r\nthan then the answer is ; If this sum is equal to then the answer is ;\r\nIf this sum is greater than then we can add this excess to the maximal\r\nelement in array . In this case, the answer is .\r\n"
}