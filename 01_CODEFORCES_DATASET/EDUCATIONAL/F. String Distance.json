{
    "link": "https://codeforces.com//contest/1535/problem/F",
    "problemId": "1005287",
    "problem_idx": "F",
    "shortId": "1535F",
    "contest_number": "1535",
    "problem_submissions": {
        "F": [
            118419611,
            118426010,
            118430867,
            118426204,
            118431979,
            118430548,
            118427577,
            118427147,
            118426507,
            118434537,
            118439125,
            118438429,
            118430864,
            118436547,
            118434959,
            118453422,
            118456471,
            118456451,
            118456355,
            118456131,
            118456058,
            118456048,
            118455909,
            118455542,
            118455503,
            118455485
        ],
        "E": [
            118400147,
            118402299,
            118394572,
            118405499,
            118401297,
            118401883,
            118414866,
            118411914,
            118414294,
            118416129,
            118415333,
            118407183,
            118406610,
            118405332,
            118409528,
            118409895,
            118409924,
            118411325,
            118411281,
            118410495
        ],
        "D": [
            118386781,
            118389062,
            118387245,
            118390389,
            118390997,
            118394077,
            118396153,
            118398368,
            118392634,
            118407760,
            118505002,
            118402523,
            118396763,
            118398598,
            118397636,
            118397134,
            118395495,
            118396828,
            118399622,
            118398243,
            118400710,
            118402452
        ],
        "C": [
            118378877,
            118377465,
            118375938,
            118430752,
            118379578,
            118379282,
            118380197,
            118383333,
            118382719,
            118391368,
            118391117,
            118384601,
            118383707,
            118399476,
            118384199,
            118383290,
            118382649,
            118384396,
            118382126,
            118382935,
            118380453,
            118382432
        ],
        "B": [
            118372987,
            118446923,
            118371985,
            118371638,
            118369895,
            118374146,
            118373752,
            118371435,
            118372857,
            118372165,
            118379497,
            118375234,
            118373646,
            118372652,
            118378295,
            118372318,
            118372891,
            118372700,
            118376055,
            118373052,
            118370572
        ],
        "A": [
            118369280,
            118369165,
            118369096,
            118369133,
            118369295,
            118369220,
            118369112,
            118369384,
            118369143,
            118369677,
            118369872,
            118369144,
            118369236,
            118370094,
            118369134,
            118369278,
            118369451,
            118369228,
            118369772,
            118369174
        ]
    },
    "name": "F. String Distance",
    "statement": "Suppose you are given two strings a and b. You can apply the following\r\noperation any number of times: choose any substring of a or b, and sort\r\nthe characters in it in non-descending order. Let f(a, b) the minimum\r\nnumber of operations you have to apply in order to make them equal (or\r\nf(a, b) = 1337 if it is impossible to make a and b equal using these\r\noperations).For example: f(\r\ntext{ab},\r\ntext{ab}) = 0; f(\r\ntext{ba},\r\ntext{ab}) = 1 (in one operation, we can sort the whole first string); f(\r\ntext{ebcda},\r\ntext{ecdba}) = 1 (in one operation, we can sort the substring of the\r\nsecond string starting from the 2-nd character and ending with the 4-th\r\ncharacter); f(\r\ntext{a},\r\ntext{b}) = 1337. You are given n strings s_1, s_2,\r\ndots, s_k having equal length. Calculate\r\nsum\r\nlimits_{i = 1}^{n}\r\nsum\r\nlimits_{j = i + 1}^{n} f(s_i, s_j).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nstruct binary_indexed_tree{\n\tint N;\n\tvector<T> BIT;\n\tbinary_indexed_tree(int N): N(N), BIT(N + 1, 0){\n\t}\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile (i <= N){\n\t\t\tBIT[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tT sum(int i){\n\t\tT ans = 0;\n\t\twhile (i > 0){\n\t\t\tans += BIT[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn ans;\n\t}\n\tT sum(int L, int R){\n\t\treturn sum(R) - sum(L);\n\t}\n};\nint main(){\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  for (int i = 0; i < n; i++){\n    cin >> s[i];\n  }\n  int m = s[0].size();\n  map<array<int, 26>, vector<int>> mp;\n  for (int i = 0; i < n; i++){\n    array<int, 26> cnt;\n    for (int j = 0; j < 26; j++){\n      cnt[j] = 0;\n    }\n    for (int j = 0; j < m; j++){\n      cnt[s[i][j] - 'a']++;\n    }\n    mp[cnt].push_back(i);\n  }\n  long long ans = 0;\n  int cnt = 0;\n  for (auto P : mp){\n    int n2 = P.second.size();\n    vector<string> s2(n2);\n    for (int i = 0; i < n2; i++){\n      s2[i] = s[P.second[i]];\n    }\n    ans += (long long) cnt * n2 * 1337;\n    ans += (long long) n2 * (n2 - 1);\n    sort(s2.begin(), s2.end());\n    vector<pair<string, int>> P2(n2);\n    for (int i = 0; i < n2; i++){\n      P2[i] = make_pair(s2[i], i);\n      reverse(P2[i].first.begin(), P2[i].first.end());\n    }\n    sort(P2.begin(), P2.end());\n    vector<string> s3(n2);\n    for (int i = 0; i < n2; i++){\n      s3[i] = P2[i].first;\n    }\n    vector<int> spos(n2);\n    for (int i = 0; i < n2; i++){\n      spos[P2[i].second] = i;\n    }\n    vector<vector<int>> prel(m + 1, vector<int>(n2, -1));\n    vector<vector<int>> prer(m + 1, vector<int>(n2, -1));\n    for (int i = 0; i < n2; i++){\n      prel[0][i] = 0;\n      prer[0][i] = n2;\n    }\n    for (int i = 1; i <= m; i++){\n      for (int j = 0; j < n2; j++){\n        if (prel[i][j] == -1){\n          int t = j;\n          while (true){\n            t++;\n            if (t == prer[i - 1][j]){\n              break;\n            }\n            if (s2[j][i - 1] != s2[t][i - 1]){\n              break;\n            }\n          }\n          for (int k = j; k < t; k++){\n            prel[i][k] = j;\n            prer[i][k] = t;\n          }\n        }\n      }\n    }\n    vector<vector<int>> sufl(m + 1, vector<int>(n2, -1));\n    vector<vector<int>> sufr(m + 1, vector<int>(n2, -1));\n    for (int i = 0; i < n2; i++){\n      sufl[0][i] = 0;\n      sufr[0][i] = n2;\n    }\n    for (int i = 1; i <= m; i++){\n      for (int j = 0; j < n2; j++){\n        if (sufl[i][j] == -1){\n          int t = j;\n          while (true){\n            t++;\n            if (t == sufr[i - 1][j]){\n              break;\n            }\n            if (s3[j][i - 1] != s3[t][i - 1]){\n              break;\n            }\n          }\n          for (int k = j; k < t; k++){\n            sufl[i][k] = j;\n            sufr[i][k] = t;\n          }\n        }\n      }\n    }\n    vector<vector<pair<int, int>>> query_add(n2 + 1);\n    vector<vector<pair<int, int>>> query_sub(n2 + 1);\n    for (int i = 0; i < n2; i++){\n      vector<int> w;\n      w.push_back(0);\n      for (int j = 0; j < m - 1; j++){\n        if (s2[i][j] > s2[i][j + 1]){\n          w.push_back(j + 1);\n        }\n      }\n      w.push_back(m);\n      int k = w.size();\n      for (int j = 0; j < k - 1; j++){\n        int L = w[j];\n        int R = m - w[j + 1];\n        query_sub[sufl[R][spos[i]]].push_back(make_pair(prel[L][i], prer[L][i]));\n        query_add[sufr[R][spos[i]]].push_back(make_pair(prel[L][i], prer[L][i]));\n        ans++;\n      }\n    }\n    binary_indexed_tree<int> BIT(n2);\n    for (int i = 0; i <= n2; i++){\n      int cnt1 = query_add[i].size();\n      for (int j = 0; j < cnt1; j++){\n        int l = query_add[i][j].first;\n        int r = query_add[i][j].second;\n        ans -= BIT.sum(l, r);\n      }\n      int cnt2 = query_sub[i].size();\n      for (int j = 0; j < cnt2; j++){\n        int l = query_sub[i][j].first;\n        int r = query_sub[i][j].second;\n        ans += BIT.sum(l, r);\n      }\n      if (i < n2){\n        BIT.add(P2[i].second, 1);\n      }\n    }\n    cnt += n2;\n  }\n  cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "hashing",
        "implementation",
        "strings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. String Distance.json",
    "editorial_link": "https://codeforces.com//blog/entry/91481",
    "editorial": "Disclaimer: the model solution is very complicated compared to most\r\nparticipants\u00e2\u0080\u0099 solutions. Feel free to discuss your approaches in the\r\ncomments!First of all, it\u00e2\u0080\u0099s easy to determine when two strings cannot be\r\nmade equal using these operations: it\u00e2\u0080\u0099s when their multisets of\r\ncharacters differ. So, we divide the strings into different equivalence\r\nclasses, and for any pair of strings from different classes, the answer\r\nis . For any pair of strings from the same class, the answer is either\r\nor , since operations are always enough to make the strings from the\r\nsame equivalence class equal (we just sort both of them). Okay, now, for\r\neach class, we have to calculate the number of pairs of strings with the\r\ndistance equal to .Okay, suppose you have two strings and , and you want\r\nto make them equal using one operation. Suppose that lexicographically.\r\nSince applying an operation can\u00e2\u0080\u0099t result in getting a lexicographically\r\nlarger string, we should apply the operation on the string , not .\r\nSuppose we choose a substring of the string and sort it. All characters\r\nto the left of position and to the right of position are untouched, and\r\nall characters in are ordered in non-descending order; so, in order to\r\ntransform into , we should choose a subsegment such that all characters\r\noutside this segment are the same in both strings, and the substring of\r\nis sorted. So, the best way to choose a subsegment is to compute the\r\nlongest common prefix of and , the longest common suffix of and , and\r\ntry sorting everything in the middle in . This gives us a solution in :\r\nfor a pair of strings, we can check that one of them can be transformed\r\ninto the other in . To do so, we need to build some data structure\r\nallowing to query longest common prefixes/suffixes in (a trie with LCA\r\nor precalculating LCP and building a sparse table of them can do the\r\ntrick); furthermore, we want to be able to check if some subsegment of\r\nsome string is sorted in (but precalculating them is quite easy). So, we\r\nhave a solution that works if the strings are long (in the model\r\nsolution, this approach is used on classes having not more than\r\nstrings).The second approach can be used on classes having many strings.\r\nIf the number of strings is big, it means that they are short, so we can\r\ndo the following thing: for each string, iterate on the subsegment we\r\nwill sort and check if the resulting string exists. The model solution\r\nuses some very complicated data structures to implement this, but I\r\nbelieve that it\u00e2\u0080\u0099s quite easy to get this approach working using string\r\nhashes.The only dangerous thing in the second solution you have to\r\nconsider is that choosing different substrings to sort may result in\r\ngetting the same resulting string. One good way to deal with this is to\r\nignore some substrings if sorting them doesn\u00e2\u0080\u0099t change the leftmost or\r\nthe rightmost character in the substring; for example, if we sort the\r\nsubstring in the string , the character in the beginning of this\r\nsubstring is unchanged, so we can get the same result by sorting . So,\r\nwe consider sorting the substring only if it changes both the first and\r\nthe last characters of the substring.Okay, so we have two approaches:\r\none works well with a small number of long strings, and the other works\r\nwell with a big number of short strings. We can choose which of them to\r\nrun depending on the size of the equivalence class we are considering,\r\nand this idea gives us a working solution.\r\n"
}