{
    "link": "https://codeforces.com//contest/863/problem/F",
    "problemId": "123496",
    "problem_idx": "F",
    "shortId": "863F",
    "contest_number": "863",
    "problem_submissions": {
        "F": [
            30585747,
            30587406,
            30587581,
            30586987,
            30589318,
            30588386,
            30614835,
            30589226,
            30587748,
            30588069,
            30589138,
            30588637,
            30589602,
            30588953,
            30587113,
            30590006,
            30591128,
            30589525,
            30591328
        ],
        "E": [
            30584826,
            30584892,
            30586722,
            30586370,
            30585856,
            30586447,
            30586390,
            30586258,
            30587809,
            30586316,
            30587721,
            30587855,
            30587775,
            30588242,
            30587782,
            30587403,
            30589806
        ],
        "D": [
            30584161,
            30582889,
            30583896,
            30584983,
            30584514,
            30599512,
            30585431,
            30584907,
            30584911,
            30586408,
            30585496,
            30586610,
            30586374,
            30584958,
            30587183,
            30584596,
            30585231,
            30587520
        ],
        "C": [
            30583486,
            30584324,
            30585366,
            30584169,
            30583738,
            30584504,
            30584405,
            30584037,
            30585386,
            30584778,
            30585657,
            30585045,
            30584141,
            30586261,
            30586674,
            30591722,
            30586154
        ],
        "B": [
            30581979,
            30583463,
            30582674,
            30582188,
            30582199,
            30582158,
            30582064,
            30582238,
            30582609,
            30582456,
            30582868,
            30582784,
            30582689,
            30582852,
            30583217,
            30606326,
            30582212,
            30582335
        ],
        "A": [
            30581619,
            30581704,
            30581695,
            30581653,
            30581650,
            30786677,
            30581665,
            30581657,
            30581629,
            30581763,
            30581628,
            30581791,
            30581663,
            30581713,
            30581800,
            30581819,
            30581630,
            30581694
        ],
        "G": [
            57430904,
            30596090
        ]
    },
    "name": "F. Almost Permutation",
    "statement": "Recently Ivan noticed an array while debugging his code. Now Ivan can’t\r\nremember this array, but the bug he was trying to fix didn’t go away, so\r\nIvan thinks that the data from this array might help him to reproduce\r\nthe bug.Ivan clearly remembers that there were elements in the array,\r\nand each element was not less than and not greater than . Also he\r\nremembers facts about the array. There are two types of facts that Ivan\r\nremembers: for each such that ; for each such that . Also Ivan thinks\r\nthat this array was a permutation, but he is not so sure about it. He\r\nwants to restore some array that corresponds to the facts that he\r\nremembers and is very similar to permutation. Formally, Ivan has denoted\r\nthe of array as follows:, where is the number of occurences of in the\r\narray.Help Ivan to determine minimum possible of the array that\r\ncorresponds to the facts!\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nusing Weight = int;\nconst Weight InfWeight = INF;\nWeight hungarianMin(const vector<vector<Weight> > &A) {\n\tif (A.empty()) return 0;\n\tint h = A.size(), n = A[0].size();\n\tif (h > n) return InfWeight;\n\tvector<Weight> fx(h), fy(n);\n\tvector<int> x(h, -1), y(n, -1);\n\tvector<int> t(n), s(h + 1);\n\tfor (int i = 0; i < h; ) {\n\t\tfill(t.begin(), t.end(), -1);\n\t\ts[0] = i;\n\t\tint q = 0;\n\t\tfor (int p = 0; p <= q; ++ p) {\n\t\t\tfor (int k = s[p], j = 0; j < n; ++ j) {\n\t\t\t\tif (fx[k] + fy[j] == A[k][j] && t[j] < 0) {\n\t\t\t\t\ts[++ q] = y[j];\n\t\t\t\t\tt[j] = k;\n\t\t\t\t\tif (s[q] < 0) {\n\t\t\t\t\t\tfor (p = j; p >= 0; j = p) {\n\t\t\t\t\t\t\ty[j] = k = t[j];\n\t\t\t\t\t\t\tp = x[k];\n\t\t\t\t\t\t\tx[k] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++ i;\n\t\t\t\t\t\tgoto continue_;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (0) {\n\t\tcontinue_:;\n\t\t} else {\n\t\t\tWeight d = InfWeight;\n\t\t\tfor (int j = 0; j < n; j++) if (t[j] < 0) {\n\t\t\t\tfor (int k = 0; k <= q; ++ k) if (A[s[k]][j] != InfWeight)\n\t\t\t\t\td = min(d, A[s[k]][j] - fx[s[k]] - fy[j]);\n\t\t\t}\n\t\t\tif (d == InfWeight)\n\t\t\t\treturn InfWeight;\n\t\t\tfor (int j = 0; j < n; ++ j) {\n\t\t\t\tif (t[j] >= 0)\n\t\t\t\t\tfy[j] -= d;\n\t\t\t}\n\t\t\tfor (int k = 0; k <= q; ++ k)\n\t\t\t\tfx[s[k]] += d;\n\t\t}\n\t}\n\tWeight res = 0;\n\tfor (int i = 0; i < h; ++ i)\n\t\tres += A[i][x[i]];\n\treturn res;\n}\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(\"%d%d\", &n, &q)) {\n\t\tvector<int> lo(n, 1), up(n, n);\n\t\trep(qi, q) {\n\t\t\tint t; int l; int r; int v;\n\t\t\tscanf(\"%d%d%d%d\", &t, &l, &r, &v), -- l;\n\t\t\tif (t == 1) {\n\t\t\t\treu(i, l, r)\n\t\t\t\t\tamax(lo[i], v);\n\t\t\t} else {\n\t\t\t\treu(i, l, r)\n\t\t\t\t\tamin(up[i], v);\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\trep(i, n)\n\t\t\tok &= lo[i] <= up[i];\n\t\tif (!ok) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<int>> A(n, vector<int>(n * n, INF));\n\t\trep(i, n) {\n\t\t\trer(x, lo[i], up[i]) {\n\t\t\t\trep(k, n)\n\t\t\t\t\tA[i][(x - 1) * n + k] = 2 * k + 1;\n\t\t\t}\n\t\t}\n\t\tint ans = hungarianMin(A);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Almost Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/54708",
    "editorial": "This problem can be solved with mincost maxflow approach.Letâs construct\r\na following network: Construct a vertex for every number from to . For\r\neach of these vertices add directed edges from the source to this\r\nvertex, the capacity of each edge will be , and the costs will be (so\r\npushing flow from the source to the vertex will cost exactly ); Also\r\nconstruct a vertex for every index of the array. For each number make\r\nadd a directed edge with capacity and cost to every position in the\r\narray such that this number can be put into this position, and for every\r\nindex make a directed edge from the vertex constructed for this index to\r\nthe sink with capacity and cost . Minimum cost maximum flow in this\r\nnetwork will construct a suitable array with minimum cost, so the answer\r\nto the problem is minimum cost of maximum flow in the network.\r\n",
    "hint": []
}