{
    "link": "https://codeforces.com//contest/1814/problem/E",
    "problemId": "1867160",
    "problem_idx": "E",
    "shortId": "1814E",
    "contest_number": "1814",
    "problem_submissions": {
        "F": [
            201036702,
            201037659,
            201028227,
            201050534,
            201005326,
            201050567,
            201051354,
            201158503,
            202793506,
            201087367,
            202961596,
            202961442,
            202961147,
            201054424,
            201057597,
            201057439,
            201061539
        ],
        "E": [
            201020903,
            201018973,
            201013610,
            201039745,
            201017818,
            201033040,
            201037281,
            201034750,
            201024677,
            201030462,
            201026865,
            201030498,
            201034907,
            201040830,
            201037552,
            201041417,
            201042340,
            201036940,
            201015059,
            201040959
        ],
        "D": [
            201007638,
            201011987,
            201038257,
            201026423,
            201158753,
            201158000,
            201029908,
            201043932,
            201052993,
            201045921,
            201082509,
            201058213,
            201035019,
            201016854,
            201013631,
            201010624,
            201014339,
            201022685,
            201018472,
            201019148,
            201025982,
            201024394,
            201027376,
            201024423,
            201027368,
            201021262,
            201025020,
            201019825,
            201029085,
            201044637,
            201027275
        ],
        "C": [
            200997961,
            201000063,
            201003769,
            201024541,
            201036517,
            201006380,
            201034351,
            200999416,
            201001849,
            201000732,
            201005802,
            201004502,
            201004247,
            201004311,
            201006996,
            201002331,
            201000424,
            200997419,
            201005850,
            201004743
        ],
        "B": [
            200988415,
            200991922,
            200990827,
            200995877,
            201038223,
            200997671,
            201032023,
            200991419,
            200988849,
            200991883,
            200998660,
            200995028,
            200998040,
            200993967,
            200992160,
            200993164,
            200991747,
            200987467,
            201004511,
            200997597
        ],
        "A": [
            200985126,
            200985107,
            200985078,
            200985613,
            201039035,
            200990896,
            201030957,
            200985096,
            200985148,
            200986607,
            200985454,
            200988595,
            200985783,
            200985667,
            200986043,
            200985871,
            200988700,
            200985284,
            201001220,
            200986768
        ]
    },
    "name": "E. Chain Chips",
    "statement": "You are given an undirected graph consisting of n vertices and n-1\r\nedges. The i-th edge has weight a_i; it connects the vertices i and\r\ni+1.Initially, each vertex contains a chip. Each chip has an integer\r\nwritten on it; the integer written on the chip in the i-th vertex is\r\ni.In one operation, you can choose a chip (if there are multiple chips\r\nin a single vertex, you may choose any one of them) and move it along\r\none of the edges of the graph. The cost of this operation is equal to\r\nthe weight of the edge.The of the graph is the minimum cost of a\r\nsequence of such operations that meets the following condition: after\r\nall operations are performed, each vertex contains exactly one chip, and\r\nthe integer on each chip is to the index of the vertex where that chip\r\nis located. You are given q queries of the form: k x change the weight\r\nof the k-th edge (the one which connects the vertices k and k+1) to x.\r\nAfter each query, print the of the graph. Note that you don\u2019t actually\r\nmove any chips; when you compute the cost, the chips are on their\r\ninitial positions.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << \" \"; cout << v[i];\n\t}\n\tcout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\ntemplate<typename T>\nstruct SegT {\nprivate:\n\tint sz; vector<T> node;\n\tT init_c;\n\tfunction<T(T, T)> f;\npublic:\n\tSegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n\t\tinit_c = _init_c; f = _f;\n\t\tint n = v.size();\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t\trep(i, n) {\n\t\t\tnode[i + sz - 1] = v[i];\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tnode[i] = f(node[2 * i + 1], node[2 * i + 2]);\n\t\t}\n\t}\n\tSegT(int n, T _init_c, function<T(T, T)> _f) {\n\t\tinit_c = _init_c; f = _f;\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tvoid update(int k, T a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n\t//k\u4ee5\u4e0a\u3067f(x,node[y+sz-1])\u3092true\u306b\u3059\u308b\u3088\u3046\u306a\u6700\u5c0f\u306ey\n\tint searchloc(int le, T x, function<bool(T, T)> comp) {\n\t\tint  k = le + sz - 1;\n\t\tif (comp(x, node[k]))return le;\n\t\tx = f(x, node[k]);\n\t\twhile (k > 0) {\n\t\t\tint mem = k;\n\t\t\tk = (k - 1) / 2;\n\t\t\tif (2 * k + 1 == mem) {\n\t\t\t\tif (comp(x, node[2 * k + 2])) {\n\t\t\t\t\tk = 2 * k + 2; break;\n\t\t\t\t}\n\t\t\t\tx = f(x, node[2 * k + 2]);\n\t\t\t}\n\t\t}\n\t\tif (k == 0)return sz;\n\t\twhile (k < sz - 1) {\n\t\t\tif (comp(x, node[2 * k + 1])) {\n\t\t\t\tk = 2 * k + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = f(x, node[2 * k + 1]);\n\t\t\t\tk = 2 * k + 2;\n\t\t\t}\n\t\t}\n\t\treturn k - (sz - 1);\n\t}\n};\n\nusing ar = array<ll, 4>;\nvoid solve() {\n\tint n; cin >> n;\n\tvector<ll> a(n);\n\trep(i, n-1)cin >> a[i];\n\tvector<ar> ori(n - 1);\n\trep(i, n - 1) {\n\t\trep(j, 4)ori[i][j] = INF;\n\t\tori[i][0] = 0;\n\t\tori[i][3] = a[i];\n\t}\n\tar e = { -1,-1,-1,-1 };\n\tauto f = [&](ar a, ar b) {\n\t\tif (a == e)return b;\n\t\tif (b == e)return a;\n\t\tar res; rep(i, 4)res[i] = INF;\n\t\trep(i, 4)rep(j, 4) {\n\t\t\tint br = i & 2;\n\t\t\tint bl = j & 1;\n\t\t\tif (!br && !bl)continue;\n\t\t\tint ni = 0;\n\t\t\tif (i & 1)ni |= 1;\n\t\t\tif (j & 2)ni |= 2;\n\t\t\tchmin(res[ni], a[i] + b[j]);\n\t\t}\n\t\treturn res;\n\t};\n\tSegT<ar> st(ori, e, f);\n\tint q; cin >> q;\n\trep(i, q) {\n\t\tint id, x; cin >> id >> x; id--;\n\t\tar cur; rep(j, 4)cur[j] = INF;\n\t\tcur[0] = 0;\n\t\tcur[3] = x;\n\t\tst.update(id, cur);\n\t\tar z = st.query(0, n - 1);\n\t\tll ans = 2 * z[3];\n\t\tcout << ans << \"\\n\";\n\t}\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "matrices"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Chain Chips.json",
    "editorial_link": "https://codeforces.com//blog/entry/114854",
    "editorial": "Let\u00e2\u0080\u0099s try to analyze how many times we traverse each edge, in the style\r\nof \"Contribution to the Sum\" technique. For each edge, the number of\r\ntimes it is traversed must be even, since for every chip that goes from\r\nthe part of the graph to the part , there should be a chip that goes in\r\nthe opposite direction (the number of chips on vertices should be\r\nunchanged).For each vertex, at least one incident edge should be\r\ntraversed at least twice otherwise, the chip from this vertex cannot be\r\nmoved to any other vertex.We would also like to traverse the edges as\r\nrarely as possible. Is it possible to find an answer where, if we\r\ntraverse any edge, we traverse it only twice? It turns out it is\r\npossible. Let\u00e2\u0080\u0099s \"split\" the graph into several parts by removing the\r\nedges we don\u00e2\u0080\u0099t traverse. If we don\u00e2\u0080\u0099t break the constraint that each\r\nvertex has at least one incident edge which is traversed by some chip,\r\nthen each part of the graph will contain at least two vertices. And in\r\neach part, we can make sure that each edge is traversed only twice as\r\nfollows: let the part represent the segment of vertices; if we move the\r\nchip to the vertex , the chip to the vertex , the chip to the vertex ,\r\n..., the chip to the vertex , then every edge in that part will be\r\ntraversed exactly twice.So, we have shown that if we pick a subset of\r\nedges which we traverse that meets the constraint on each vertex having\r\nan incident traversed edge, then it is enough to traverse each chosen\r\nedge only twice. Now the problem becomes the following: choose a subset\r\nof edges in such a way that every vertex has at least one incident\r\nchosen edge, minimize the total weight of this subset, and print the\r\ninteger which is double that total weight.Since the structure of the\r\ngraph is specific, we can run dynamic programming of the form the\r\nminimum total weight of the subset, if we considered the first edges,\r\nand is if we haven\u00e2\u0080\u0099t taken the last edge, or if we have. Obviously, this\r\ndynamic programming works in , which is too slow because we have to\r\nprocess queries. We will employ a classical technique of storing the\r\ndynamic programming in segment tree: build a segment tree on leaves; in\r\nevery vertex of the segment tree, we store a matrix ; if the segment\r\nrepresented by the node of the segment tree is , then the value of is\r\nthe minimum total weight of the subset of edges between and such that\r\namong every pair of adjacent edges, at least one is chosen; and\r\nrepresent the status of the first/last edge on the segment,\r\nrespectively. And when some element changes, we need to recalculate only\r\nnodes of the segment tree, so this solution works in , albeit with a\r\nvery big constant factor.Implementation note: don\u00e2\u0080\u0099t use dynamic-size\r\narrays (like in C++) to store the values in the matrices, it might slow\r\nyour solution very seriously. Instead, use static-size arrays.\r\n"
}