{
    "link": "https://codeforces.com//contest/1620/problem/E",
    "problemId": "1233292",
    "problem_idx": "E",
    "shortId": "1620E",
    "contest_number": "1620",
    "problem_submissions": {
        "G": [
            139834723,
            139834630,
            139800025,
            139798720,
            139797780,
            139795833,
            139793177,
            139797195,
            139801753,
            139800125,
            139798252,
            139806590,
            139801965,
            139799470,
            139800885,
            139815133,
            139836989,
            139836961,
            139803234,
            139783937,
            139766371,
            139781791,
            198626640,
            139785516,
            139791910,
            139794593,
            139799506,
            139797098,
            139802371,
            139794714
        ],
        "E": [
            139834170,
            139768900,
            139778404,
            139777262,
            139781401,
            139780307,
            180264469,
            139772320,
            139783598,
            139787731,
            139788776,
            139795635,
            139801166,
            139803161,
            139771172,
            139772982,
            139775572,
            139777494,
            139781749,
            139783689,
            139782938,
            139773708
        ],
        "D": [
            139828795,
            139828599,
            139828445,
            139801175,
            139773916,
            139773661,
            139775200,
            139772309,
            139777532,
            139778435,
            139852816,
            139778132,
            139769927,
            139780286,
            139786796,
            139790402,
            139791529,
            139805624,
            139765400,
            139770581,
            139781836,
            139766109,
            139779076,
            139774566,
            139785166
        ],
        "F": [
            139826678,
            139786211,
            139791869,
            139787814,
            139791341,
            139788904,
            139814807,
            139811473,
            139818294,
            139801200,
            139837073,
            139811622,
            139810717,
            139801430,
            139908478,
            139834808,
            139830354
        ],
        "B": [
            139800559,
            139758636,
            139759221,
            139759228,
            139768929,
            139762743,
            139760389,
            139791856,
            139762557,
            139759423,
            139779986,
            139793644,
            139810932,
            139757813,
            139761675,
            139760955,
            139759416,
            139760977,
            139759368,
            139760377
        ],
        "C": [
            139765159,
            139765932,
            139765302,
            139774145,
            139773181,
            207683198,
            139765484,
            139764863,
            139771290,
            139772950,
            139784482,
            139796217,
            139807967,
            139762141,
            139766772,
            139767896,
            139775442,
            139767619,
            139767081,
            139780353
        ],
        "A": [
            139756564,
            139756597,
            139756503,
            139756739,
            139759409,
            139756692,
            139757881,
            139756729,
            139756611,
            139777143,
            139792512,
            139812388,
            139756396,
            139756654,
            139757129,
            139756551,
            139756903,
            139756439,
            139756571
        ]
    },
    "name": "E. Replace the Numbers",
    "statement": "You have an array of integers (initially empty).You have to perform q\r\nqueries. Each query is of one of two types: \"1 x\" add the element x to\r\nthe end of the array; \"2 x y\" replace all occurrences of x in the array\r\nwith y. Find the resulting array after performing all the queries.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T_vector>\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end = int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');\n}\n\n\nconst int X_MAX = int(5e5) + 5;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int Q;\n    cin >> Q;\n    vector<int> type(Q), X(Q), Y(Q);\n\n    for (int q = 0; q < Q; q++) {\n        cin >> type[q] >> X[q];\n\n        if (type[q] == 2)\n            cin >> Y[q];\n    }\n\n    vector<int> A;\n    vector<int> final(X_MAX);\n    iota(final.begin(), final.end(), 0);\n\n    for (int q = Q - 1; q >= 0; q--)\n        if (type[q] == 1)\n            A.push_back(final[X[q]]);\n        else\n            final[X[q]] = final[Y[q]];\n\n    reverse(A.begin(), A.end());\n    output_vector(A);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dsu",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Replace the Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/98061",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem from the end. Let\u00e2\u0080\u0099s maintain the array what\r\nnumber will become if we apply to it all the already considered queries\r\nof type . If the current query is of the first type, then we simply add\r\nto the resulting array. If the current query is of the second type, then\r\nwe have to change the value of . Since all occurrences of must be\r\nreplaced with , it is enough to assign .Since we process each query in ,\r\nthe final complexity is .There is also an alternative solution. Let\u00e2\u0080\u0099s\r\nprocess queries in the direct order. Let\u00e2\u0080\u0099s store all its positions in an\r\narray for each number. Then for the first query, it is enough to put the\r\nindex in the corresponding array of positions. And for a query of the\r\nsecond type, we have to move all the positions of the number into an\r\narray of positions of the number . The naive implementation is obviously\r\ntoo slow, but we can use the small to large method, then the complexity\r\nof the solution will be .\r\n"
}