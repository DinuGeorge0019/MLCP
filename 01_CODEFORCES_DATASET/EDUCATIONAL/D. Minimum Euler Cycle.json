{"link": "https://codeforces.com//contest/1334/problem/D", "problemId": "590684", "problem_idx": "D", "shortId": "1334D", "contest_number": "1334", "problem_submissions": {"G": [76150604, 76454180, 76191944, 76188027, 76167647, 76177375, 76173628, 76186408, 76177963, 76163688, 76192725, 76184456, 76199963, 76199932, 76182086, 76197235, 76196570, 76214003, 76498225, 76495336, 76260338], "F": [76137544, 76454142, 76145547, 76157286, 76163120, 76164905, 76178511, 76167121, 76165115, 77917392, 76145490, 76152253, 76160935, 76165553, 76165708, 76168968, 76174508, 76168274, 76170642, 76172386, 76176147], "E": [76125664, 76454103, 76130620, 76144771, 76144664, 76158374, 76133358, 76154175, 76146278, 77917431, 76130418, 76125237, 76138118, 76141034, 76142668, 76149616, 76144057, 76143238, 76146704, 76123897, 76133227], "D": [76117930, 76454057, 76121143, 76124195, 76129444, 76121217, 76145661, 76143168, 76138942, 76118871, 76134614, 76125142, 76129022, 76126912, 76131421, 76134529, 76131763, 76126502, 76140986, 76147818], "C": [76108518, 76454007, 76107934, 76107462, 76112664, 76110005, 76119790, 76108604, 76117844, 76213964, 76213679, 76105910, 76110649, 76113576, 76108183, 76111773, 76111557, 76110114, 76109227, 76109093, 76106723, 76112412], "B": [76102992, 76453951, 76102307, 76102229, 76104046, 76104090, 76113043, 76104228, 76113456, 76102698, 76104186, 76104760, 76102468, 76104601, 76103592, 76102759, 76103107, 76101604, 76101877, 76102615], "A": [76101170, 76453913, 76100742, 76100982, 76101188, 76101149, 76107978, 76101072, 76103065, 76100866, 76101471, 76100923, 76100719, 76101105, 76100817, 76100705, 76100882, 76100750, 76100773, 76100924]}, "name": "D. Minimum Euler Cycle", "statement": "You are given a graph K_n with n vertices: each pair of vertices u\r\nneq v in K_n have both directed edges (u, v) and (v, u); there are no\r\nself-loops.You should find such a cycle in K_n that visits every\r\ndirected edge exactly once (allowing for revisiting vertices).We can\r\nwrite such cycle as a list of n(n - 1) + 1 vertices v_1, v_2, v_3,\r\ndots, v_{n(n - 1) - 1}, v_{n(n - 1)}, v_{n(n - 1) + 1} = v_1 a visiting\r\norder, where each (v_i, v_{i + 1}) occurs exactly once.Find the such\r\ncycle. It\u2019s not hard to prove that the cycle always exists.Since the\r\nanswer can be too large print its [l, r] segment, in other words, v_l,\r\nv_{l + 1},\r\ndots, v_r.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint _,n;\nll l,r,s[N];\n\nint calc(ll x) {\n\tif (x>s[n-1]) return 1;\n\tauto a=lower_bound(s+1,s+n,x)-s;\n\tint b=x-s[a-1];\n\tif (b%2==1) return a;\n\telse return b/2+a;\n}\n\nint main() {\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tscanf(\"%d%lld%lld\",&n,&l,&r);\n\t\trep(i,1,n+1) s[i]=s[i-1]+2*(n-i);\n\t\tfor (ll i=l;i<=r;i++)\n\t\t \tprintf(\"%d \",calc(i));\n\t\tputs(\"\");\n\t}\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "greedy", "implementation"], "dificulty": "1800", "interactive": false}