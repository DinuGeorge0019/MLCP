{
    "link": "https://codeforces.com//contest/2111/problem/E",
    "problemId": "3419290",
    "problem_idx": "E",
    "shortId": "2111E",
    "contest_number": "2111",
    "problem_submissions": {
        "G": [
            322719568,
            322738251,
            322737232,
            322734882,
            322733848,
            322739705,
            322765348,
            322764688,
            322752005,
            322753587,
            322751319,
            322720568,
            322729631,
            322757116,
            322785461,
            322890645,
            323020347,
            322778439,
            322778419,
            322778201,
            322778119,
            322778020,
            322777882,
            322777223,
            322776997,
            322776001,
            322775936
        ],
        "E": [
            322697990,
            322695191,
            322705487,
            322705821,
            322705980,
            322713283,
            322724677,
            322738049,
            322690431,
            322700985,
            322700076,
            322704262,
            322702259,
            322707219,
            322704094,
            322705822,
            322703551
        ],
        "F": [
            322691387,
            322716243,
            322719103,
            322728613,
            322729993,
            322731051,
            322740913,
            322686943,
            322710192,
            322719720,
            322713672,
            322713636,
            322726013,
            322721562,
            322720556,
            322728230,
            322730210
        ],
        "D": [
            322678511,
            322686771,
            322684334,
            322692059,
            322689019,
            322692746,
            322686820,
            322741814,
            322683201,
            322689247,
            322687368,
            322686598,
            322691632,
            322687656,
            322691451,
            322694053,
            322684204
        ],
        "C": [
            322676707,
            322681404,
            322679043,
            322681662,
            322681314,
            322683752,
            322680197,
            322743070,
            322679811,
            322681807,
            322679034,
            322681517,
            322680587,
            322678741,
            322686213,
            322679235,
            322680369
        ],
        "B": [
            322676127,
            322679449,
            322677961,
            322679172,
            322678800,
            322680312,
            322678349,
            322745453,
            322678542,
            322679221,
            322677917,
            322679124,
            322677847,
            322677424,
            322681157,
            322677471,
            322677308
        ],
        "A": [
            322675651,
            322676474,
            322676120,
            322676736,
            322675861,
            322677535,
            322676082,
            322747128,
            322675974,
            322676468,
            322676128,
            322676492,
            322675977,
            322675843,
            322676405,
            322675792,
            322675708
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143528",
    "editorial": "First, let’s try to understand what operations and sequences of\r\noperations make sense to perform.Each letter can be transformed at most\r\ntwo times: if we change it more than twice, then at two moments in time\r\nit will be the same, and all operations between them can be\r\nomitted.Clearly, there is no point in transforming the letter at all, as\r\nit cannot be made lexicographically smaller. The letter can only be\r\ntransformed into the letter , either directly or indirectly through the\r\nletter . The letter can be transformed into both the letter (directly or\r\nindirectly through the letter ) or the letter (but only directly; there\r\nis no point in transforming it into to then transform it into ).This\r\nmeans that we are actually interested in the following sequences of\r\ntransformations: ; ; ; ; . Moreover, there is no point in combining\r\nsequences of types and (the only ones with two operations) because if\r\nthere are two sequences of types and , we can instead transform them\r\ninto two sequences of types and .Now let’s try to actually solve the\r\nproblem. We will go through the string from left to right and for each\r\ncharacter, we will try to transform it into the smallest possible\r\ncharacter (considering that we still need to transform characters in the\r\nprefix and that some operations may be unavailable).When we encounter\r\nthe character , let’s first try to build a sequence of type for it, and\r\nif that doesn’t work, a sequence of type . When we encounter the\r\ncharacter , we will first try to build a sequence of type , if that\r\ndoesn’t work, then type , and if that still doesn’t work, type . To\r\nbuild the sequences, we will keep a set of all queries for each possible\r\ntransformation of one character into another; if there is only one\r\ntransformation in the sequence, we will take the earliest one; if there\r\nare two, we will take the earliest of the first type and use to find the\r\nearliest of the second type that can be taken with it.Let’s prove that\r\nthis greedy approach works. To do this, we will analyze two \"dangerous\"\r\nmoments in our greedy approach: What if transforming characters into\r\ndirectly is not always beneficial? We try to transform them directly\r\nfirst and only then indirectly; what if this is incorrect? What if our\r\nchoice of the earliest operations for transformations is not correct\r\nbecause it may prohibit us from performing some sequence of operations\r\nlater? We will prove that point is not a problem. Suppose in the optimal\r\nsolution we transformed some character into indirectly, although at that\r\nmoment we could have done it directly. If we still have unused\r\noperations to transform into directly, we can use the direct\r\ntransformation instead of the indirect one, and the answer will not\r\nchange. Otherwise, suppose we used that direct transformation on\r\ncharacter (). If , we can \"swap\" them, and the answer will not change.\r\nIf , this means that we indirectly transformed the character into and\r\nthe character into and we previously proved that in the optimal\r\nsolution, we can ignore such cases.Now let’s prove that point is also\r\nnot a problem. If we use a single transformation of character or into ,\r\nit is always beneficial to take the earliest operation of that type:\r\nlater operations of that type may be needed for indirect transformations\r\n(sequences of transformations of types or ), and in such sequences, the\r\noperation of transforming into is the second one, so it is beneficial to\r\nleave later operations of transforming into for such sequences. We can\r\nalso use a single transformation from to , but we only use it when the\r\noperations for transforming into have either already ended or the last\r\nsuch operation occurs later than the first operation of transforming\r\ninto , so we definitely cannot use the transformation from to in a\r\nsequence of two operations, and we can take any such operation\r\n(including the earliest one).Therefore, the solution can be implemented\r\nas follows: For each type of operation, form a set of all queries in\r\nwhich such an operation can be performed. Go through the string from\r\nleft to right and greedily transform the current character into the\r\nsmallest possible character. First, we will try to transform it into\r\n(first directly, then indirectly); if that doesn’t work, then into . In\r\neach transformation, we will use the earliest operation (if two\r\noperations are needed, the earliest operation of the first type and the\r\nearliest operation of the second type that comes after the first). The\r\ncomplexity of the solution is .\r\n",
    "name": "E. Changing the String",
    "statement": "Given a string s that consists only of the first three letters of the\r\nLatin alphabet, meaning each character of the string is either , , or\r\n.Also given are q operations that need to be performed on the string. In\r\neach operation, two letters x and y from the set of the first three\r\nletters of the Latin alphabet are provided, and for each operation, one\r\nof the following two actions must be taken: change any (one) occurrence\r\nof the letter x in the string s to the letter y (if at least one\r\noccurrence of the letter x exists); do nothing. The goal is to perform\r\nall operations in the given order in such a way that the string s\r\nbecomes lexicographically minimal.Recall that a string a is\r\nlexicographically less than a string b if and only if one of the\r\nfollowing conditions holds: a is a prefix of b, but a\r\nneq b; at the first position where a and b differ, the string a has a\r\nletter that comes earlier in the alphabet than the corresponding letter\r\nin b.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "implementation",
        "sortings",
        "strings"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Changing the String.json"
}