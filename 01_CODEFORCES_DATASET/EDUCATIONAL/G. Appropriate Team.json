{
    "link": "https://codeforces.com//contest/1016/problem/G",
    "problemId": "204442",
    "problem_idx": "G",
    "shortId": "1016G",
    "contest_number": "1016",
    "problem_submissions": {
        "G": [
            41182699,
            41182152,
            41208590,
            41208565,
            41208533,
            41186176
        ],
        "E": [
            41176649,
            41174782,
            41175307,
            41175790,
            41176170,
            41175960,
            41179374,
            41176561,
            41175646,
            41175201,
            41179908,
            41184095,
            41179907,
            41172878,
            41174329,
            41178174,
            41177502,
            41177414,
            41176901,
            41187225,
            41186968,
            41177073,
            41179262,
            41178795,
            41177041
        ],
        "C": [
            41173342,
            41166585,
            41171261,
            41168340,
            41167894,
            41169421,
            41170385,
            41170240,
            41169071,
            41173849,
            41167601,
            41164969,
            41165695,
            41170115,
            41170716,
            41168026,
            41168718,
            41168530,
            41166879
        ],
        "F": [
            41171110,
            41181183,
            41180305,
            41183918,
            41185092,
            41183413,
            41183773,
            41181947,
            41183454,
            41180224,
            41185015,
            41178764,
            41188501,
            42098047,
            42098011,
            41192515,
            41197238,
            41187801
        ],
        "D": [
            41165638,
            41168213,
            41167884,
            41169638,
            41172158,
            41171342,
            41172221,
            41172202,
            41173341,
            41167097,
            41174977,
            41169216,
            41167575,
            41163502,
            41165286,
            41170742,
            41170760,
            41171944,
            41162657
        ],
        "B": [
            41161071,
            41162662,
            41164375,
            41162058,
            41164067,
            41164871,
            41164742,
            41161857,
            41162316,
            41161724,
            41169935,
            41161660,
            41162105,
            41161158,
            41162458,
            41162731,
            41163603,
            41163495,
            41169324
        ],
        "A": [
            41160184,
            41161181,
            41160522,
            41160409,
            41160935,
            41160830,
            41161646,
            41160641,
            41160349,
            41160611,
            41175572,
            41160281,
            41160461,
            41160190,
            41160493,
            41160416,
            41161519,
            41160623,
            41167976
        ]
    },
    "name": "G. Appropriate Team",
    "statement": "Since next season are coming, you’d like to form a team from two or\r\nthree participants. There are n candidates, the i-th candidate has rank\r\na_i. But you have weird requirements for your teammates: if you have\r\nrank v and have chosen the i-th and j-th candidate, then GCD(v, a_i) = X\r\nand LCM(v, a_j) = Y must be met.You are very experienced, so you can\r\nchange your rank to any non-negative integer but X and Y are tied with\r\nyour birthdate, so they are fixed.Now you want to know, how many are\r\nthere pairs (i, j) such that there exists an integer v meeting the\r\nfollowing constraints: GCD(v, a_i) = X and LCM(v, a_j) = Y. It’s\r\npossible that i = j and you form a team of two.GCD is the greatest\r\ncommon divisor of two number, LCM the least common multiple.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n// n < 4,759,123,141        3 :  2, 7, 61\n// n < 1,122,004,669,633    4 :  2, 13, 23, 1662803\n// n < 3,474,749,660,383          6 :  pirmes <= 13\n// n < 2^64                       7 :\n// 2, 325, 9375, 28178, 450775, 9780504, 1795265022\n// Make sure testing integer is in range [2, n−2] if\n// you want to use magic.\nLL add(LL a, LL b, LL mod){\n  a+=b;\n  return a>=mod?a-mod:a;\n}\nLL mul(LL a, LL b, LL mod){\n  LL ret=0;\n  while(b){\n    if(b&1LL) ret=(ret+a)%mod;\n    a=(a+a)%mod;\n    b>>=1;\n  }\n  return ret;\n}\nLL mypow(LL a, LL b, LL mod){\n  LL ret=1;\n  while(b){\n    if(b&1LL) ret=mul(ret, a, mod);\n    a=mul(a, a, mod);\n    b>>=1;\n  }\n  return ret;\n}\nbool witness(LL a,LL n,LL u,int t){\n\tLL x=mypow(a,u,n);\n\tfor(int i=0;i<t;i++) {\n\t\tLL nx=mul(x,x,n);\n\t\tif(nx==1&&x!=1&&x!=n-1) return 1;\n\t\tx=nx;\n\t}\n\treturn x!=1;\n}\nbool miller_rabin(LL n) {\n\t// iterate s times of witness on n\n\t// return 1 if prime, 0 otherwise\n\tif(n<2) return 0;\n\tif(!(n&1)) return n == 2;\n\tLL u=n-1; int t=0;\n\t// n-1 = u*2^t\n\twhile(!(u&1)) u>>=1, t++;\n  for(LL a: {2, 325, 9375, 28178, 450775, 9780504, 1795265022}){\n    if(a > n-2)\n      continue;\n\t\tif(witness(a,n,u,t))\n      return 0;\n\t}\n\treturn 1;\n}\n// does not work when n is prime\nLL f(LL x, LL mod){ return add(mul(x,x,mod),1,mod); }\nLL myrand(LL n){\n  LL ret=1;\n  for(int i=0; i<4; i++)\n    ret=(ret<<15)|(rand() & ((1LL<<15)-1));\n  return ret%n;\n}\nLL pollard_rho(LL n) {\n\tif(!(n&1)) return 2;\n  while(true){\n    LL y=2, x=myrand(n-1)+1, res=1;\n    for(int sz=2; res==1; sz*=2) {\n      for(int i=0; i<sz && res<=1; i++) {\n        x = f(x, n);\n        res = __gcd(abs(x-y), n);\n      }\n      y = x;\n    }\n    if (res!=0 && res!=n) return res;\n  }\n}\nconst int N=202020;\nLL n, x, y, a[N];\nvector<LL> pris;\nbool factor(LL val, vector<LL>& cc){\n  cc.resize(pris.size());\n  for(size_t i=0; i<pris.size(); i++){\n    cc[i]=0;\n    while(val % pris[i] == 0){\n      val/=pris[i];\n      cc[i]++;\n    }\n  }\n  return val==1;\n}\nvector<LL> cx, cy;\nvector<LL> coe[N];\nbool okay[N];\nLL cnt[1<<19];\nvoid go(){\n  assert(factor(x, cx));\n  assert(factor(y, cy));\n  for(int i=0; i<n; i++)\n    okay[i]=factor(a[i], coe[i]);\n  for(int i=0; i<n; i++){\n    { // as i\n      bool ok=true;\n      int msk=0;\n      for(size_t j=0; j<pris.size(); j++){\n        if(coe[i][j] < cx[j]){\n          ok=false;\n          break;\n        }\n        if(coe[i][j] == cx[j] or cx[j] == cy[j])\n          continue;\n        msk|=(1<<j);\n      }\n      if(not ok) continue;\n      cnt[msk]++;\n    }\n  }\n  for(size_t i=0; i<pris.size(); i++)\n    for(int j=0; j<(1<<(pris.size())); j++)\n      if((j >> i) & 1)\n        cnt[j]+=cnt[j^(1<<i)];\n  LL ans=0;\n  int ALL=(1<<pris.size())-1;\n  for(int i=0; i<n; i++){\n    { // as j\n      if(not okay[i]) continue;\n      bool ok=true;\n      int msk=0;\n      for(size_t j=0; j<pris.size(); j++){\n        if(coe[i][j] > cy[j]){\n          ok=false;\n          break;\n        }\n        if(coe[i][j] == cy[j] or cx[j] == cy[j])\n          continue;\n        msk|=(1<<j);\n      }\n      if(not ok) continue;\n      msk^=ALL;\n      ans+=cnt[msk];\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\nint main(){\n  scanf(\"%lld%lld%lld\", &n, &x, &y);\n  for(int i=0; i<n; i++) scanf(\"%lld\", &a[i]);\n  if(y%x){\n    puts(\"0\");\n    exit(0);\n  }\n  {\n    LL tmpy=y;\n    for(LL i=2; i<=1e6+10; i++){\n      if(tmpy % i) continue;\n      pris.push_back(i);\n      while(tmpy % i == 0) tmpy/=i;\n    }\n    if(tmpy > 1){\n      if(miller_rabin(tmpy))\n        pris.push_back(tmpy);\n      else{\n        LL aa=pollard_rho(tmpy);\n        LL bb=tmpy/aa;\n        pris.push_back(aa);\n        pris.push_back(bb);\n      }\n    }\n    sort(pris.begin(), pris.end());\n    pris.resize(unique(pris.begin(), pris.end())-pris.begin());\n  }\n  go();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "math",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Appropriate Team.json",
    "editorial_link": "https://codeforces.com/blog/entry/61015",
    "editorial": "At first, must be met (since and ). Now let and . From now on letâs\r\nconsider only such that .Now letâs look at : must be met. Let . Since ,\r\nif then must have to the power of in its factorization; otherwise power\r\nof can be any non-negative integer . It leads us to the bitmask of\r\nrestrictions () with size equal to the number of different prime\r\ndivisors of .In the same way letâs process . Of course, and if then must\r\nhave to the power of in its factorization. This is another restriction\r\nbitmask ().So, for any pair there exists if and only if . Since we look\r\nonly at where then canât have power of equal to and at the same time.\r\nFor any other it is enough to have power of in equal to the power of in\r\n(even if itâs equal to ).So, for each we need to know the number of such\r\nthat is a submask of . So we just need to calculate sum of submasks for\r\neach mask; it can be done with or .Finally, how to factorize number up\r\nto . Of course, Pollard algorithm helps, but there is another way, which\r\nworks sometimes. Letâs factorize with primes up to . So after that if\r\nthere is only three cases: , or . is easy to check ( helps). Otherwise,\r\njust check with all , and : if you have found and , then and you have\r\nfound . Otherwise you can assume that , because this probable mistake\r\ndoesnât break anything in this task.Result complexity is where is the\r\nnumber of prime divisors of .\r\n",
    "hint": []
}