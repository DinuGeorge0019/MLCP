{
    "link": "https://codeforces.com//contest/1016/problem/B",
    "problemId": "204437",
    "problem_idx": "B",
    "shortId": "1016B",
    "contest_number": "1016",
    "problem_submissions": {
        "G": [
            41182699,
            41182152,
            41208590,
            41208565,
            41208533,
            41186176
        ],
        "E": [
            41176649,
            41174782,
            41175307,
            41175790,
            41176170,
            41175960,
            41179374,
            41176561,
            41175646,
            41175201,
            41179908,
            41184095,
            41179907,
            41172878,
            41174329,
            41178174,
            41177502,
            41177414,
            41176901,
            41187225,
            41186968,
            41177073,
            41179262,
            41178795,
            41177041
        ],
        "C": [
            41173342,
            41166585,
            41171261,
            41168340,
            41167894,
            41169421,
            41170385,
            41170240,
            41169071,
            41173849,
            41167601,
            41164969,
            41165695,
            41170115,
            41170716,
            41168026,
            41168718,
            41168530,
            41166879
        ],
        "F": [
            41171110,
            41181183,
            41180305,
            41183918,
            41185092,
            41183413,
            41183773,
            41181947,
            41183454,
            41180224,
            41185015,
            41178764,
            41188501,
            42098047,
            42098011,
            41192515,
            41197238,
            41187801
        ],
        "D": [
            41165638,
            41168213,
            41167884,
            41169638,
            41172158,
            41171342,
            41172221,
            41172202,
            41173341,
            41167097,
            41174977,
            41169216,
            41167575,
            41163502,
            41165286,
            41170742,
            41170760,
            41171944,
            41162657
        ],
        "B": [
            41161071,
            41162662,
            41164375,
            41162058,
            41164067,
            41164871,
            41164742,
            41161857,
            41162316,
            41161724,
            41169935,
            41161660,
            41162105,
            41161158,
            41162458,
            41162731,
            41163603,
            41163495,
            41169324
        ],
        "A": [
            41160184,
            41161181,
            41160522,
            41160409,
            41160935,
            41160830,
            41161646,
            41160641,
            41160349,
            41160611,
            41175572,
            41160281,
            41160461,
            41160190,
            41160493,
            41160416,
            41161519,
            41160623,
            41167976
        ]
    },
    "name": "B. Segment Occurrences",
    "statement": "You are given two strings s and t, both consisting only of lowercase\r\nLatin letters.The substring s[l..r] is the string which is obtained by\r\ntaking characters s_l, s_{l + 1},\r\ndots, s_r without changing the order.Each of the occurrences of string a\r\nin a string b is a position i (1\r\nle i\r\nle |b| - |a| + 1) such that b[i..i + |a| - 1] = a (|a| is the length of\r\nstring a).You are asked q queries: for the i-th query you are required\r\nto calculate the number of occurrences of string t in a substring\r\ns[l_i..r_i].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=1021;\nint n, m, q, ans[N];\nstring s, t;\nint main(){\n  scanf(\"%d%d%d\", &n, &m, &q);\n  cin>>s>>t;\n  for(int i=0; i+m<=n; i++)\n    if(s.substr(i, m) == t)\n      ans[i+1]++;\n  for(int i=2; i<=n; i++)\n    ans[i]+=ans[i-1];\n  while(q--){\n    int li, ri;\n    scanf(\"%d%d\", &li, &ri);\n    ri=ri-m+1;\n    printf(\"%d\\n\", max(0, ans[max(0,ri)]-ans[li-1]));\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Segment Occurrences.json",
    "editorial_link": "https://codeforces.com/blog/entry/61015",
    "editorial": "Letâs take a look at a naive approach: for each query you iterate over\r\npositions and check if . Okay, this is obviously . Now we notice that\r\nthere are only positions for to start from, we can calculate if there is\r\nan occurrence of starting in this position beforehand in . Thus, we\r\ntransition to solution. Finally, we calculate a partial sum array over\r\nthis occurrence check array and answer each query in .Overall\r\ncomplexity: .\r\n",
    "hint": []
}