{
    "link": "https://codeforces.com//contest/609/problem/D",
    "problemId": "43547",
    "problem_idx": "D",
    "shortId": "609D",
    "contest_number": "609",
    "problem_submissions": {
        "F": [
            14886217,
            14887477,
            14888177,
            14886379,
            14885040,
            14885527,
            14887905,
            14886648,
            14888303,
            14895268,
            14888745,
            14917735,
            14898327,
            14893077,
            14892871
        ],
        "E": [
            14882063,
            14883627,
            14884067,
            14882265,
            14882405,
            14883303,
            14885623,
            14884355,
            14884989,
            14882411,
            14880931,
            14884153,
            14884117,
            14884965,
            14886043,
            14885211,
            14885825,
            14885599
        ],
        "D": [
            14879612,
            14881347,
            14882734,
            14880026,
            14880930,
            14881222,
            14881919,
            14978995,
            14882591,
            14880772,
            14880443,
            14883120,
            14881030,
            14880993,
            14882082,
            14883447,
            14882873,
            14884432,
            14883318
        ],
        "C": [
            14878082,
            14878799,
            14878664,
            14878553,
            14878302,
            14878492,
            14879132,
            14879063,
            14878272,
            14878604,
            14878442,
            14879174,
            14878439,
            14879071,
            14879422,
            14879561,
            14879189,
            14879663
        ],
        "B": [
            14877436,
            14877988,
            14877744,
            14877733,
            14877531,
            14877677,
            14878043,
            14878384,
            14877598,
            14877591,
            14877568,
            14877569,
            14877547,
            14877786,
            14877829,
            14878321,
            14878191,
            14879079
        ],
        "A": [
            14877245,
            14877406,
            14877341,
            14877385,
            14877254,
            14877304,
            14877500,
            14878068,
            14877300,
            14877250,
            14877283,
            14877265,
            14877281,
            14877315,
            14877259,
            14877505,
            14877351,
            14878481
        ]
    },
    "name": "D. Gadgets for dollars and pounds",
    "statement": "Nura wants to buy gadgets. She has only burles for that. She can buy\r\neach gadget for dollars or for pounds. So each gadget is selling only\r\nfor some type of currency. The type of currency and the cost in that\r\ncurrency are not changing.Nura can buy gadgets for days. For each day\r\nyou know the exchange rates of dollar and pound, so you know the cost of\r\nconversion burles to dollars or to pounds.Each day (from to ) Nura can\r\nbuy some gadgets by current exchange rate. Each day she can buy any\r\ngadgets she wants, but each gadget can be bought no more than once\r\nduring days.Help Nura to find the minimum day index when she will have\r\ngadgets. Nura always pays with burles, which are converted according to\r\nthe exchange rate of the purchase day. Nura can’t buy dollars or pounds,\r\nshe always stores only burles. Gadgets are numbered with integers from\r\nto in order of their appearing in input.\r\n",
    "solutions": [
        "/*\nThe basement incinerator\nIs where they'll put the head\nHose the floor and clean the room\nAnywhere they bled\n\nInto boxes go the bags\nFill the space with rocks\nIn the dark of night\nHe throws them off the docks\n\nRotting in the river\nNever to be found\nUnder tons of concrete\nDeep beneath the ground\n\nFrom behind, he grabs his mouth\nThe blade goes to his neck\nBulging veins pumping blood\nHe struggles to protect\n\nIf you don't cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nGrab the neck, slit the throat, take the life\nHang the corpse, prepare to drain the blood\nBone saw, meat cleaver, filleting knife\nCarve the corpse, dissect him in the tub\n\nSmash the teeth, slice off scars, crush the bones\nWith a crowbar scrape off all tattoos\n\nIf you don't cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nChunks of a skull\nSawn in half bones\nBody is found\nKiller unknown\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nvector < pair<long long, pair<int, int> > >v;\nint l, r;\nint cheap1, cheap2;\nint a[N], b[N];\nint tp[N];\nint c[N];\nint n, m, k, s;\n\nbool good(int l)\n{\n\tv.clear();\n\n\tcheap1 = 1;\n\tcheap2 = 1;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tif (a[i] < a[cheap1])\n\t\t\tcheap1 = i;\n\t\tif (b[i] < b[cheap2])\n\t\t\tcheap2 = i;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (tp[i] == 1)\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * a[cheap1] * c[i], make_pair(i, cheap1)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * b[cheap2] * c[i], make_pair(i, cheap2)));\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tlong long need = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tneed += v[i].first;\n\treturn (need <= s);\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m >> k >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> b[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> tp[i] >> c[i];\n\t}\n\n\tl = 1;\n\tr = n + 1;\n\twhile (l < r)\n\t{\n\t\tint mid = l + r;\n\t\tmid /= 2;\n\t\tif (good(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid+1;\n\t}\n\n\tif (l == n + 1)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tcout << l << endl;\n\n\tgood(l);\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tcout << v[i].second.first << \" \" << v[i].second.second << \"\\n\";\n\t}\n\n\tcin.get();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Gadgets for dollars and pounds.json",
    "editorial_link": "https://codeforces.com//blog/entry/22187",
    "editorial": "If Nura can buy gadgets in days then she can do that in days. So the\r\nfunction of answer is monotonic. So we can find the minimal day with\r\nbinary search. Denote the left bound of binary search and the right one.\r\nWe will maintain the invariant that in left bound we canât buy gadgets\r\nand in right bound we can do that. Denote function equals to if we can\r\nbuy gadgets in days and otherwise. As usual in binary search we will\r\nchoose . If then we should move the right bound and the left bound in\r\nother case. If binary search found the value then the answer is ,\r\notherwise the answer is . Before binary search we can create two arrays\r\nof gadgets which are selling for dollars and pounds, and sort them. Easy\r\nto see that we should buy gadgets for dollars on day when dollar costs\r\nas small as possible and when pounds costs as small as possible. Let now\r\nwe want to buy gadgets for dollars and gadgets for pounds. Of course we\r\nwill buy the least cheap of them (we already sort the arrays for that).\r\nLetâs iterate over from to and maintain the sum of gadgets for dollars\r\nand the sum of gadgets for pounds . For we can calculate the sums in .\r\nFor other xâs we can recalculate the sums in time from the sums for by\r\nadding gadget for dollars and removing gadget for pounds. Complexity: .\r\n",
    "hint": []
}