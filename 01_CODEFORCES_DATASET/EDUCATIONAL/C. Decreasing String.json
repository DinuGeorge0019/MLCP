{
    "link": "https://codeforces.com//contest/1886/problem/C",
    "problemId": "2254331",
    "problem_idx": "C",
    "shortId": "1886C",
    "contest_number": "1886",
    "problem_submissions": {
        "F": [
            227397695,
            227398300,
            228261037,
            228260268,
            228197178
        ],
        "E": [
            227362679,
            227384483,
            227364120,
            227375327,
            227373174,
            227378169,
            227374021,
            227374447,
            227379620,
            227374460,
            227376543,
            227384694,
            227379424,
            227380143,
            227385403,
            227378825,
            227381936,
            227382749,
            227399178,
            227387227
        ],
        "D": [
            227353655,
            227357179,
            227354694,
            227357584,
            227358464,
            227358468,
            227358349,
            227362290,
            227362059,
            227356663,
            227359799,
            227363314,
            227364815,
            227364540,
            227348253,
            227359972,
            227351995,
            227364703,
            227363479,
            227364505
        ],
        "C": [
            227350420,
            227354094,
            227350822,
            227351738,
            227353206,
            227352928,
            227352755,
            227358100,
            227355646,
            227353873,
            227356426,
            227357990,
            228289531,
            227359928,
            227359265,
            227363015,
            227354512,
            227347330,
            227360346,
            227356740,
            227359383
        ],
        "B": [
            227345467,
            227345695,
            227345097,
            227345886,
            227347778,
            227347034,
            227345776,
            227346855,
            227347299,
            227344500,
            227348328,
            227348902,
            227344888,
            227345167,
            227353779,
            227346134,
            227384569,
            227355313,
            227346381,
            227345209
        ],
        "A": [
            227342113,
            227340918,
            227341455,
            227340893,
            227341201,
            227341171,
            227340846,
            227340875,
            227341099,
            227340925,
            227340854,
            227342810,
            227341042,
            227341115,
            227341596,
            227341490,
            227340923,
            227349667,
            227341619,
            227341191
        ]
    },
    "name": "C. Decreasing String",
    "statement": "Recall that string a is lexicographically smaller than string b if a is\r\na prefix of b (and a\r\nne b), or there exists an index i (1\r\nle i\r\nle\r\nmin(|a|, |b|)) such that a_i < b_i, and for any index j (1\r\nle j < i) a_j = b_j.Consider a sequence of strings s_1, s_2,\r\ndots, s_n, each consisting of lowercase Latin letters. String s_1 is\r\ngiven explicitly, and all other strings are generated according to the\r\nfollowing rule: to obtain the string s_i, a character is removed from\r\nstring s_{i-1} in such a way that string s_i is lexicographically\r\nminimal.For example, if s_1 =\r\nmathrm{dacb}, then string s_2 =\r\nmathrm{acb}, string s_3 =\r\nmathrm{ab}, string s_4 =\r\nmathrm{a}.After that, we obtain the string S = s_1 + s_2 +\r\ndots + s_n (S is the concatenation of all strings s_1, s_2,\r\ndots, s_n).You need to output the character in position pos of the\r\nstring S (i. e. the character S_{pos}).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    i64 pos;\n    std::cin >> pos;\n    pos--;\n    int x, y;\n    for (int i = 0; i < n; i++) {\n        int len = n - i;\n        if (pos < len) {\n            x = i;\n            y = pos;\n            break;\n        }\n        pos -= len;\n    }\n    \n    std::string t;\n    for (auto c : s) {\n        while (x > 0 && !t.empty() && c < t.back()) {\n            t.pop_back();\n            x--;\n        }\n        t += c;\n    }\n    std::cout << t[y];\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::cout << std::fixed << std::setprecision(10);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    std::cout << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Decreasing String.json",
    "editorial_link": "https://codeforces.com//blog/entry/121255",
    "editorial": "Letâs analyze in which order the characters should be removed from the\r\ngiven string. Suppose we want to remove a character so that the\r\nresulting string is lexicographically smallest. We can show that the\r\nbest option is to find the leftmost pair of adjacent characters such\r\nthat : removing will decrease the character on that position; if you\r\nremove some character to the right of , the -th character wonât\r\ndecrease; and if you remove some character to the left of , you might\r\naccidentally increase some character before the -th position (we chose\r\nthe leftmost such pair, so the prefix until the -th character is\r\nnon-decreasing). If there is no such pair of adjacent characters, you\r\nshould remove the last character of the string. Unfortunately,\r\nimplementing it naively is too slow (the solution will work in ).\r\nThankfully, there is a way to determine in which all characters are\r\nremoved in .Maintain a stack of characters (initially empty) and iterate\r\nover the string from left to right. When you encounter a character, if\r\nthe stack is empty or the character on top of the stack is not greater\r\nthan the current one, you donât have to remove anything, just push the\r\nnew character into the stack. But if the character on top of the stack\r\nis greater than the new one, then we have found a pair of adjacent\r\ncharacters which meets the condition; so, the character on top of the\r\nstack is the next to remove. Pop the topmost element of the stack. Note\r\nthat we donât push the new character into the stack yet, because the\r\nnext element on top of the stack might still be greater in that case,\r\nthis is the next character to remove (and we pop it), and so on. In the\r\nend, the character in the stack will be non-descending from the bottom\r\nof the stack to the top, and we should remove them from top to bottom.\r\nThatâs how we can find in which order characters are removed.The rest is\r\nquite easy: locate in which of the strings the position occurs, remove\r\nthe required number of characters, and print the corresponding character\r\nof the resulting string.Minor detail which can make the implementation\r\neasier: if you append some character which is less than to the end of\r\nthe given string, you donât have to consider the case when thereâs no\r\npair of adjacent characters .\r\n",
    "hint": []
}