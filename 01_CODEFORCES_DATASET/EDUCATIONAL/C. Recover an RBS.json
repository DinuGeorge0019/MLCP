{
    "link": "https://codeforces.com//contest/1709/problem/C",
    "problemId": "1473246",
    "problem_idx": "C",
    "shortId": "1709C",
    "contest_number": "1709",
    "problem_submissions": {
        "F": [
            165168347,
            165171155,
            165167911,
            165174463,
            165176163,
            165160774,
            165168485,
            165153508,
            165190349,
            165187538,
            165182010,
            165187878,
            165188862,
            165199087,
            165192962,
            165196109,
            165191946,
            165144458,
            165186818,
            165193512,
            165203160
        ],
        "E": [
            165159365,
            165161441,
            165158406,
            165162017,
            165168742,
            165174634,
            165187067,
            165172843,
            165175285,
            165185776,
            165171787,
            165176500,
            165174638,
            165175948,
            165172273,
            165158835,
            165190131,
            165153154,
            165197774,
            165181829,
            165178900
        ],
        "D": [
            165150554,
            165148981,
            165152094,
            165156213,
            165151693,
            165153019,
            165151289,
            165162605,
            165149121,
            165155132,
            165160454,
            165159258,
            165152293,
            165165679,
            165219278,
            165218001,
            165217824,
            165217721,
            165217510,
            165217230,
            165156286,
            165159148,
            165160000,
            165161618,
            165152984
        ],
        "C": [
            165144629,
            165143580,
            165141216,
            165150836,
            165145746,
            165145999,
            165145473,
            165163144,
            165144208,
            165149116,
            165150518,
            165148291,
            165145172,
            165171500,
            165146230,
            165166415,
            165151667,
            165148193,
            165146642
        ],
        "B": [
            165139451,
            165137999,
            165136858,
            165138643,
            165140562,
            165138703,
            165137403,
            165156435,
            165139221,
            165142115,
            165142999,
            165139377,
            165138165,
            165141728,
            165137879,
            165168796,
            165142050,
            165141198,
            165138920
        ],
        "A": [
            165135387,
            165134436,
            165133952,
            165134310,
            165134821,
            165133959,
            165133957,
            165138163,
            165134268,
            165134365,
            165134868,
            165134280,
            165133923,
            165136754,
            165134369,
            165170607,
            165135087,
            165136295,
            165134364
        ]
    },
    "name": "C. Recover an RBS",
    "statement": "A bracket sequence is a string containing only characters \"\" and \"\". A\r\nregular bracket sequence (or, shortly, an RBS) is a bracket sequence\r\nthat can be transformed into a correct arithmetic expression by\r\ninserting characters \"\" and \"\" between the original characters of the\r\nsequence. For example: bracket sequences \"\" and \"\" are regular (the\r\nresulting expressions are: \"\" and \"\"); bracket sequences \"\", \"\" and \"\"\r\nare not. There was an RBS. Some brackets have been replaced with\r\nquestion marks. Is it true that there is a way to replace question marks\r\nwith brackets, so that the resulting sequence is an RBS?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 500500;\nint n;\nchar s[N];\n\nvoid solve() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tint cntQ = 0, bal = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '?') {\n\t\t\tcntQ++;\n\t\t} else if (s[i] == '(') {\n\t\t\tbal++;\n\t\t} else {\n\t\t\tbal--;\n\t\t}\n\t}\n\tif (cntQ == abs(bal)) {\n\t\tprintf(\"YES\\n\");\n\t\treturn;\n\t}\n\tint cntPos = (cntQ - bal) / 2;\n\tbool placeNeg = false;\n\tfor (int i = 0; i < n; i++) if (s[i] == '?') {\n\t\tif (cntPos > 1) {\n\t\t\ts[i] = '(';\n\t\t\tcntPos--;\n\t\t} else if (cntPos == 1) {\n\t\t\tif (placeNeg) {\n\t\t\t\ts[i] = '(';\n\t\t\t\tcntPos--;\n\t\t\t} else {\n\t\t\t\ts[i] = ')';\n\t\t\t\tplaceNeg = true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[i] = ')';\n\t\t}\n\t}\n\tbal = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '(')\n\t\t\tbal++;\n\t\telse\n\t\t\tbal--;\n\t\tif (bal < 0) {\n\t\t\tprintf(\"YES\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NO\\n\");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Recover an RBS.json",
    "editorial_link": "https://codeforces.com//blog/entry/105164",
    "editorial": "There are many different approaches to this problem, but I think the\r\nmodel solution has the most elegant one.First of all, let\u00e2\u0080\u0099s construct an\r\nRBS from the given string (it always exists, so it is always possible).\r\nBy calculating the number of opening brackets, closing brackets and\r\nquestions in the given string, we can compute the number of question\r\nmarks that should be replaced with opening brackets (it is easy since\r\nexactly half of the characters in each RBS are opening brackets). Then,\r\nlet\u00e2\u0080\u0099s form the RBS greedily: replace the first several question marks\r\nwith opening brackets, and all remaining ones with closed brackets.Okay,\r\nthen what about finding a second RBS? Recall that a bracket sequence is\r\nan RBS when for each of its positions, the number of closing brackets\r\nbefore it is not greater than the number of opening brackets before it\r\n(and these two values should be equal at the end of the sequence, but it\r\nis less important now). Consider the segment between the last question\r\nmark replaced with an opening bracket, and the first question mark\r\nreplaced by the closing bracket. If we try to change the order of\r\ncharacters corresponding to question marks, the balance on this segment\r\nwill decrease at least by (since at least one opening bracket to the\r\nleft of it will become a closing bracket). Is there a way to affect only\r\nthis segment, and change the balance on it only by ? Yes just swap the\r\nendpoints of this segment (i. e. the last opening bracket that was a\r\nquestion mark and the first closing bracket that was also a question\r\nmark). If it yields an RBS, then the answer is . Otherwise, the answer\r\nis since any other permutation of characters that were replacing\r\nquestion marks will also decrease the balance on this segment by at\r\nleast .\r\n"
}