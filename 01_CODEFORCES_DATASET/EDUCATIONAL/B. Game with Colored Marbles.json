{
    "link": "https://codeforces.com//contest/2042/problem/B",
    "problemId": "3063460",
    "problem_idx": "B",
    "shortId": "2042B",
    "contest_number": "2042",
    "problem_submissions": {
        "E": [
            294423774,
            294419934,
            294425145,
            294427314,
            294461391,
            294454616,
            294469820,
            294456785,
            294473828,
            294432050,
            294452832,
            294430074,
            294720157,
            294431481,
            294468510,
            294470387,
            294430159
        ],
        "F": [
            294412520,
            294425551,
            294432280,
            294452436,
            294434993,
            294433145,
            294446063,
            294428799,
            294413717,
            294412873,
            294411042,
            294425120,
            294428614,
            294424117,
            294468671,
            294445770,
            294425722,
            294433551,
            294468661,
            294431992,
            294436625
        ],
        "D": [
            294403997,
            294407353,
            294409781,
            294414370,
            294407554,
            294410319,
            294417815,
            294419253,
            294437550,
            294410412,
            294413967,
            294418349,
            294411907,
            294402733,
            294411823,
            294409744,
            294417262,
            294417181,
            294415900
        ],
        "C": [
            294397589,
            294400380,
            294403833,
            294401565,
            294414063,
            294405958,
            294407677,
            294415266,
            294453518,
            294402202,
            294397037,
            294403746,
            294403563,
            294397148,
            294404737,
            294399098,
            294402722,
            294400450,
            294396822
        ],
        "B": [
            294394491,
            294397696,
            294398701,
            294393052,
            294393883,
            294395178,
            294398939,
            294412364,
            294455866,
            294393748,
            294393435,
            294395970,
            294392768,
            294392321,
            294399650,
            294391444,
            294395529,
            294395407,
            294392933
        ],
        "A": [
            294390734,
            294395467,
            294390153,
            294389939,
            294390115,
            294390408,
            294402923,
            294412466,
            294454482,
            294389870,
            294390174,
            294391619,
            294390031,
            294390265,
            294390266,
            294389845,
            294389856,
            294390624,
            294389907
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136886",
    "editorial": "Itâs fairly intuitive that if there is at least one unique marble\r\navailable (a marble is unique if there are no other marbles with the\r\nsame color), taking it is optimal: if Alice takes that marble, she gets\r\npoints, and if Bob takes that marble, he denies points to Alice. So,\r\ninitially, both players take unique marbles one by one, until there is\r\nnone left. Letâs denote the number of unique marbles as ; then, Alice\r\ntakes unique marbles and gets points for each of them.After that, all\r\nremaining marbles are non-unique; for each remaining color, there are at\r\nleast two marbles. Letâs denote the number of remaining colors as . We\r\ncan show that Alice can get more points no matter how Bob plays, but she\r\ncanât get more points if Bob plays optimally.There exists a symmetric\r\nstrategy for each player: if during the previous turn, your opponent\r\ntook the first marble of some color, respond by taking a marble of the\r\nsame color; otherwise, play any legal move. This symmetric strategy\r\nensures that Alice gets exactly point for each remaining color, since\r\neach color will be shared between two players. So, Alice can always\r\nachieve points, and Bob can make sure she doesnât get more than .So, to\r\nsolve this problem, you need to calculate the number of marbles for each\r\ncolor. Then, let the number of colors with exactly one marble be , and\r\nthe number of colors with more than marble be . Aliceâs score will be .\r\n",
    "name": "B. Game with Colored Marbles",
    "statement": "Alice and Bob play a game. There are n marbles, the i-th of them has\r\ncolor c_i. The players take turns; Alice goes first, then Bob, then\r\nAlice again, then Bob again, and so on.During their turn, a player take\r\nof the remaining marbles and remove it from the game. If there are no\r\nmarbles left (all n marbles have been taken), the game ends.Alice’s\r\nscore at the end of the game is calculated as follows: she receives 1\r\npoint for every color x such that she has taken at least one marble of\r\nthat color; additionally, she receives 1 point for every color x such\r\nthat she has taken marbles of that color (of course, only colors present\r\nin the game are considered). For example, suppose there are 5 marbles,\r\ntheir colors are [1, 3, 1, 3, 4], and the game goes as follows: Alice\r\ntakes the 1-st marble, then Bob takes the 3-rd marble, then Alice takes\r\nthe 5-th marble, then Bob takes the 2-nd marble, and finally, Alice\r\ntakes the 4-th marble. Then, Alice receives 4 points: 3 points for\r\nhaving at least one marble for colors 1, 3 and 4, and 1 point for having\r\nall marbles of color 4. .Alice wants to maximize her score at the end of\r\nthe game. Bob wants to minimize it. Both players play optimally (i. e.\r\nAlice chooses a strategy which allows her to get as many points as\r\npossible, and Bob chooses a strategy which minimizes the amount of\r\npoints Alice can get).Calculate Alice’s score at the end of the game.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;#define all(x) x.begin(),x.end()template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << \" \" << p.second; }template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = \" \"; return os; }#ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#define ASSERT(...) 42#endiftypedef long long ll;typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> pi;const int oo = 1e9; void solve() {    int n; cin >> n;    vi c(n);    for(auto& i : c) cin >> i;    map<int,int> cnt;    for(auto x : c) cnt[x]++;    int os=0;    int ans=0;    for(auto [k,v] : cnt) {        if(v==1) {            os++;        } else ans++;    }    ans+=(os+1)/2*2;    cout << ans << '\\n';     } int main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int t; cin >> t;    while(t--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Game with Colored Marbles.json",
    "hint": []
}