{
    "link": "https://codeforces.com//contest/845/problem/F",
    "problemId": "119176",
    "problem_idx": "F",
    "shortId": "845F",
    "contest_number": "845",
    "problem_submissions": {
        "F": [
            29662191,
            29658691,
            29662577,
            29662557,
            29659271,
            29663949,
            29653306,
            29665823,
            29656869,
            29668298
        ],
        "E": [
            29659390,
            29664188,
            29664063,
            29663215,
            29663046,
            29661461,
            29660552,
            29653793,
            29658574,
            29655087,
            29668158,
            29670073,
            29664054,
            35903704,
            29673169,
            29656703
        ],
        "G": [
            29653058,
            29648925,
            29654997,
            29656636,
            29656923,
            29653301,
            29656155,
            29657485,
            29658552,
            29655006,
            29655066,
            29653896,
            29654510,
            29655977,
            29654363,
            29657005,
            29659307
        ],
        "D": [
            29651798,
            29653616,
            29652569,
            29653638,
            29650642,
            29655985,
            29652243,
            29654023,
            29657108,
            29650588,
            29651844,
            29650739,
            29653419,
            29656251,
            29652823,
            29652595,
            29655002,
            29652809,
            29650646
        ],
        "C": [
            29648829,
            29651383,
            29648358,
            29648061,
            29648669,
            29648794,
            29648303,
            29648671,
            29648937,
            29648455,
            29648984,
            29648127,
            29648921,
            29649045,
            29649074,
            29650613,
            29649296,
            29649747,
            29649146
        ],
        "B": [
            29648130,
            29650436,
            29648956,
            29647280,
            29647747,
            29647255,
            29647572,
            29647971,
            29647530,
            29648013,
            29647504,
            29647868,
            29647800,
            29648160,
            29648934,
            29648366,
            29648191,
            29646728
        ],
        "A": [
            29647342,
            29649692,
            29646643,
            29646523,
            29646782,
            29646497,
            29646493,
            29646476,
            29646501,
            29647201,
            29646463,
            29646669,
            29646500,
            29646893,
            29647910,
            29647098,
            29646857,
            29647624
        ]
    },
    "name": "F. Guards In The Storehouse",
    "statement": "Polycarp owns a shop in the capital of Berland. Recently the criminal\r\nactivity in the capital increased, so Polycarp is thinking about\r\nestablishing some better security in the storehouse of his shop.The\r\nstorehouse can be represented as a matrix with rows and columns. Each\r\nelement of the matrix is either (an empty space) or (a wall).Polycarp\r\nwants to hire some guards (possibly zero) to watch for the storehouse.\r\nEach guard will be in some cell of matrix and will protect every cell to\r\nthe right of his own cell and every cell to the bottom of his own cell,\r\nuntil the nearest wall. More formally, if the guard is standing in the\r\ncell , then he protects cell if all these conditions are met: is an\r\nempty cell; either and , or and ; there are no walls between cells and .\r\nGuards can be placed only in empty cells (and can protect only empty\r\ncells). The of placing the guards is some set of cells where guards will\r\nbe placed (of course, two plans are different if there exists at least\r\none cell that is included in the first plan, but not included in the\r\nsecond plan, or vice versa). Polycarp calls a plan if there is empty\r\ncell that is not protected.Polycarp wants to know the number of suitable\r\nplans. Since it can be very large, you have to output it modulo .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\ninline void add(int &x,int y)\n{\n    x+=y;\n    x=(x>=Mod ? x-Mod : x);\n}\nchar s[255][255],t[255][255];\nint dp[2][(1<<15)+5][2][2];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)\n        scanf(\"%s\",s[i]);\n    if(n<m)\n    {\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                t[j][i]=s[i][j];\n        memcpy(s,t,sizeof(t));\n        swap(n,m);\n    }\n    int now=0,la=1;\n    dp[now][0][0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        {\n            swap(now,la);\n            memset(dp[now],0,(1<<m)*sizeof(dp[now][0]));\n            for(int mask=0;mask<(1<<m);mask++)\n                for(int k=0;k<2;k++)\n                    for(int l=0;l<2;l++)\n                    {\n                        if(s[i][j]=='x')\n                            add(dp[now][mask&(~0^(1<<j))][0][l],dp[la][mask][k][l]);\n                        else\n                        {\n                            int gg=(~mask>>j&1) && (k==0 || j==0);\n                            if(gg+l<2)add(dp[now][mask][k&(j>0)][gg+l],dp[la][mask][k][l]);\n                            add(dp[now][mask|(1<<j)][1][l],dp[la][mask][k][l]);\n                        }\n                    }\n        }\n    int res=0;\n    for(int mask=0;mask<(1<<m);mask++)\n        for(int k=0;k<2;k++)\n            for(int l=0;l<2;l++)\n                add(res,dp[now][mask][k][l]);\n    return 0*printf(\"%d\\n\",res);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Guards In The Storehouse.json",
    "editorial_link": "https://codeforces.com//blog/entry/53986",
    "editorial": "This problem can be solved using dynamic programming with broken\r\nprofile. First of all, we have to make the number of rows not larger\r\nthan ; if it is larger, then we can just rotate the given matrix.Letâs\r\nfill the matrix from left to right, and in each column from top to\r\nbottom. Let be the number of ways to achieve the following situation: we\r\nnow want to fill cell with index , denotes the rows which are already\r\nprotected in this column (so there is a wall in this row or there is a\r\nguard to the left), is a flag that denotes if current cell is protected\r\nby some guard above, and is a flag that denotes if there was a cell that\r\nwas not protected.When advancing from one column to another, we have to\r\nchange the mask so we update the rows that are currently protected. The\r\nrows such that in the previous column there was a wall in this row\r\nbecome un-protected, and the rows such that there is a wall in current\r\ncolumn in this row become protected. And, of course, becomes zero.When\r\nwe place a guard, we set to one and make the corresponding row\r\nprotected. And when we are at the wall, we have to set to zero, so the\r\nguard from above doesnât protect next cell.The answer is the sum of all\r\nvalues.\r\n",
    "hint": []
}