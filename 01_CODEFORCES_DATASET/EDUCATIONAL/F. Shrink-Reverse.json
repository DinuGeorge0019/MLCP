{"link": "https://codeforces.com//contest/1923/problem/F", "problemId": "2492669", "problem_idx": "F", "shortId": "1923F", "contest_number": "1923", "problem_submissions": {"F": [247927445, 247926735, 247941699, 247942342, 247957925, 247930359, 247950515, 247952641, 247961910, 247957616, 247954803, 247957462, 247965318, 247958101, 247966724, 247961269, 247975649, 247970780], "E": [247910260, 247907637, 247944549, 247918053, 247922522, 247916787, 247955209, 247923339, 247906437, 247924189, 247923801, 247924733, 247919146, 247919411, 247915457, 248010348, 247930116, 247913617, 247921891, 247928453], "D": [247906663, 247903362, 247909256, 247913572, 247912411, 247905740, 247917150, 247917832, 247911096, 247917233, 247917212, 247913338, 247913589, 247931525, 247913875, 247917151, 247917274, 247912599], "C": [247899621, 247896441, 247899387, 247904054, 247903940, 247899293, 247903341, 247912953, 247900198, 247901509, 247906201, 247902190, 247904629, 247901902, 247905627, 247901567, 247905304, 247903364], "B": [247895420, 247893401, 247895016, 247899339, 247899002, 247894634, 247896319, 247907358, 247897312, 247896352, 247897008, 247896401, 247900980, 247897119, 247897848, 247898814, 247898339, 247898930], "A": [247893064, 247892642, 247892787, 247894650, 247893381, 247892909, 247892866, 247905142, 247893155, 247893038, 247892799, 247892722, 247896270, 247892907, 247893359, 247893598, 247893062, 247896053]}, "name": "F. Shrink-Reverse", "statement": "You are given a binary string s of length n (a string consisting of n\r\ncharacters, and each character is either or ).Let\u2019s look at s as at a\r\nbinary representation of some integer, and name that integer as the of\r\nstring s. For example, the value of is 0, the value of is 13, \"\" is 32\r\nand so on.You can perform at most k operations on s. Each operation\r\nshould have one of the two following types: : choose two indices i < j\r\nin s and swap s_i with s_j; : delete all leading zeroes from s and\r\nreverse s. For example, after you perform on , you\u2019ll get .What is the\r\nminimum value of s you can achieve by performing at most k operations on\r\ns?\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\nstruct SuffixArray {\n    int n;\n    std::vector<int> sa, rk, lc;\n    SuffixArray(const std::string &s) {\n        n = s.length();\n        sa.resize(n);\n        lc.resize(n - 1);\n        rk.resize(n);\n        std::iota(sa.begin(), sa.end(), 0);\n        std::sort(sa.begin(), sa.end(), [&](int a, int b) {return s[a] < s[b];});\n        rk[sa[0]] = 0;\n        for (int i = 1; i < n; ++i)\n            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);\n        int k = 1;\n        std::vector<int> tmp, cnt(n);\n        tmp.reserve(n);\n        while (rk[sa[n - 1]] < n - 1) {\n            tmp.clear();\n            for (int i = 0; i < k; ++i)\n                tmp.push_back(n - k + i);\n            for (auto i : sa)\n                if (i >= k)\n                    tmp.push_back(i - k);\n            std::fill(cnt.begin(), cnt.end(), 0);\n            for (int i = 0; i < n; ++i)\n                ++cnt[rk[i]];\n            for (int i = 1; i < n; ++i)\n                cnt[i] += cnt[i - 1];\n            for (int i = n - 1; i >= 0; --i)\n                sa[--cnt[rk[tmp[i]]]] = tmp[i];\n            std::swap(rk, tmp);\n            rk[sa[0]] = 0;\n            for (int i = 1; i < n; ++i)\n                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);\n            k *= 2;\n        }\n        for (int i = 0, j = 0; i < n; ++i) {\n            if (rk[i] == 0) {\n                j = 0;\n            } else {\n                for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j]; )\n                    ++j;\n                lc[rk[i] - 1] = j;\n            }\n        }\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::string t = s;\n    \n    int res = k;\n    int r = n;\n    for (int i = 0; i < n; i++) {\n        if (t[i] == '1') {\n            while (r > 0 && t[r - 1] == '1') {\n                r--;\n            }\n            if (res > 0 && i < r) {\n                std::swap(t[i], t[r - 1]);\n                res--;\n            }\n        }\n    }\n    \n    auto work = [&](int k) {\n        int cnt = std::count(s.begin(), s.end(), '1');\n        int need = std::max(1, cnt - k);\n        std::vector<int> p;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') {\n                p.push_back(i);\n            }\n        }\n        int len = n;\n        for (int i = need - 1; i < p.size(); i++) {\n            len = std::min(len, p[i] - p[i - (need - 1)] + 1);\n        }\n        if (len <= cnt) {\n            t = std::string(n - cnt, '0') + std::string(cnt, '1');\n            return;\n        }\n        std::vector<int> pre(n + 1);\n        SuffixArray sa(s);\n        for (int i = 0; i < n; i++) {\n            pre[i + 1] = pre[i] + s[i] - '0';\n        }\n        for (auto i : sa.sa) {\n            if (i + len <= n && pre[i + len] - pre[i] >= need) {\n                std::string ans = s.substr(i, len);\n                int res = k;\n                for (int i = ans.size() - 1; i >= 0; i--) {\n                    if (ans[i] == '0' && res > 0) {\n                        res--;\n                        ans[i] = '1';\n                    }\n                }\n                ans = std::string(n - len, '0') + ans;\n                t = std::min(t, ans);\n                return;\n            }\n        }\n        assert(false);\n    };\n    \n    if (k >= 2) {\n        work(k - 2);\n    }\n    if (k >= 1) {\n        std::reverse(s.begin(), s.end());\n        work(k - 1);\n    }\n    Z ans = 0;\n    for (auto c : t) {\n        ans = ans * 2 + (c - '0');\n    }\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "brute force", "greedy", "hashing", "implementation", "string suffix structures", "strings"], "dificulty": "2800", "interactive": false}