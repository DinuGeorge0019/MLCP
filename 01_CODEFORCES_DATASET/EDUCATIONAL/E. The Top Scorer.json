{
    "link": "https://codeforces.com//contest/1096/problem/E",
    "problemId": "275412",
    "problem_idx": "E",
    "shortId": "1096E",
    "contest_number": "1096",
    "problem_submissions": {
        "E": [
            47642254,
            47649536,
            47653679,
            47648526,
            47652142,
            47650532,
            47647313,
            47647929,
            47648225,
            47694278,
            47661678,
            47661672,
            47660722,
            47660711,
            47660680,
            47660618,
            47660582,
            47660120,
            47656494,
            47655953,
            47657647,
            47817653,
            47648933,
            47665496,
            47659752
        ],
        "F": [
            47639264,
            47644997,
            47642974,
            47644488,
            47645071,
            47645827,
            47642225,
            47651889,
            47635316,
            47632710,
            47640155,
            47703351,
            47703260,
            47636058,
            47646007,
            47639902,
            47642860,
            47639982,
            47644292,
            47643281,
            47642796
        ],
        "G": [
            47638289,
            47637580,
            47634875,
            47638768,
            47640048,
            47642247,
            47630999,
            47650309,
            47660389,
            47657262,
            47654048,
            47629119,
            47636649,
            47642830,
            47708729,
            47708522,
            47703016,
            47700940,
            47672367,
            47656352,
            47640712,
            47641093,
            47648435,
            47638969,
            47687049,
            47686924,
            47686825,
            47646867,
            47636051,
            47647716
        ],
        "D": [
            47635471,
            47633956,
            47638959,
            47636889,
            47629667,
            47638623,
            47639300,
            47633153,
            47649242,
            47638629,
            47633639,
            47630356,
            47634376,
            47631648,
            47636547,
            47634092,
            47638812,
            72047403,
            47632964,
            47638521
        ],
        "C": [
            47633317,
            47631680,
            47629418,
            47632179,
            47634755,
            47633350,
            47643997,
            47635493,
            47651183,
            47635153,
            47632143,
            47638363,
            47631171,
            47629984,
            47635983,
            47631947,
            47634094,
            47646109,
            47636660
        ],
        "B": [
            47631281,
            47629817,
            47632624,
            47628290,
            47637243,
            47631678,
            47637542,
            47630349,
            47652229,
            47629170,
            47629856,
            47637300,
            47629416,
            47628505,
            47627019,
            47628065,
            47630666,
            94912172,
            47637515,
            47631993
        ],
        "A": [
            47628887,
            47626041,
            47629759,
            47624992,
            47630193,
            47627541,
            47635962,
            47626700,
            47652441,
            47625024,
            47625341,
            47625412,
            47625492,
            47624882,
            47624919,
            47624912,
            47627405,
            47625425,
            47625087
        ]
    },
    "name": "E. The Top Scorer",
    "statement": "Hasan loves playing games and has recently discovered a game called\r\nTopScore. In this soccer-like game there are p players doing penalty\r\nshoot-outs. Winner is the one who scores the most. They have just\r\nfinished the game and now are waiting for the result. But there\u2019s a tiny\r\nproblem! The judges have lost the paper of scores! Fortunately they have\r\ncalculated sum of the scores before they get lost and also for some of\r\nthe players they have remembered a lower bound on how much they scored.\r\nHowever, the information about the bounds is private, so Hasan only got\r\nto know his bound.According to the available data, he knows that his\r\nscore is at least r and sum of the scores is s.Thus the final state of\r\nthe game can be represented in form of sequence of p integers a_1, a_2,\r\ndots, a_p (0\r\nle a_i) player\u2019s scores. Hasan is player number 1, so a_1\r\nge r. Also a_1 + a_2 +\r\ndots + a_p = s. Two states are considered different if there exists some\r\nposition i such that the value of a_i differs in these states. Help\r\nHasan find the probability of him winning.It can be shown that it is in\r\nthe form of\r\nfrac{P}{Q} where P and Q are non-negative integers and Q\r\nne 0, P\r\nle Q. Report the value of P\r\ncdot Q^{-1}\r\npmod {998244353}.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 1000005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\nconst ll inv2=(MOD+1)/2;\nll a[MAXN],d,b[MAXN],c[MAXN],ans;\nll f[MAXN],nf[MAXN],inv[MAXN];\nint n,r,s;\nll pow_(ll x,ll y)\n{\n    ll res=1;\n    while(y)\n    {\n        if(y&1) res=res*x%MOD;\n        x=x*x%MOD;\n        y>>=1;\n    }\n    return res;\n}\nll C(ll x,ll y)\n{\n    return f[x]*nf[y]%MOD*nf[x-y]%MOD;\n}\nll calc(ll n,ll b,ll sum)\n{\n    if(sum<0) return 0;\n    if(n==0) return (sum==0);\n    if(b==0) return 0;\n    ll res=0;\n    for(int i=0;i<=min(n,sum/b);i++)\n    {\n        if(i&1) (res-=C(n,i)*C(sum-i*b+n-1,n-1)%MOD)%=MOD;\n        else (res+=C(n,i)*C(sum-i*b+n-1,n-1))%=MOD;\n    }\n    return (res+MOD)%MOD;\n}\n\nint main()\n{\n    inv[1]=1; for(int i=2;i<MAXN;i++) inv[i]=MOD-(MOD/i)*inv[MOD%i]%MOD;\n    f[0]=nf[0]=1; for(int i=1;i<MAXN;i++) f[i]=f[i-1]*i%MOD,nf[i]=nf[i-1]*inv[i]%MOD;\n    scanf(\"%d%d%d\",&n,&s,&r);\n    if(s==0)\n    {\n        printf(\"%lld\\n\",inv[n]);\n        return 0;\n    }\n    for(int i=r;i<=s;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            ll ret=calc(n-j,i,s-j*i)*C(n-1,j-1)%MOD;\n            (ans+=ret*inv[j])%=MOD;\n        }\n    }\n    ans=ans*pow_(calc(n,s+1,s-r),MOD-2)%MOD;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. The Top Scorer.json",
    "editorial_link": "https://codeforces.com//blog/entry/64156",
    "editorial": "An straightforward dp solution is to calculate {number of states at the\r\nend of the game in which no one has scored more than goals} where is the\r\nnumber of total goals to be scored and is the number players in the\r\ngame. Fix the score of Hasan in the game and by using this dp the rest\r\nis easy (also described below). But as long as the time needed to\r\ncalculate is this solution won\u00e2\u0080\u0099t fit in the constraints.With a little\r\nhelp from combinatorics, we can calculate the value of mentioned dp\r\nfunction without using recursions.Define by inclusion-exclusion\r\nprinciple it can be easily seen that the value of equals to the above .\r\nAnd the complexity of calculation for is with a preprocess for\r\ncalculating binomial coefficients.This formula is a well-known\r\nmodification of \"Star and Bars\" problem but with the upper limit on\r\nterms.Now we can calculate the answer, firstly fix Hasan\u00e2\u0080\u0099s score and\r\nnumber of top-scorers, then use to calculate each state: By using\r\nmodulus arithmetic, the answer can be reported in the requested\r\nform.Overall complexity: .\r\n"
}