{
    "link": "https://codeforces.com//contest/1661/problem/C",
    "problemId": "1361829",
    "problem_idx": "C",
    "shortId": "1661C",
    "contest_number": "1661",
    "problem_submissions": {
        "F": [
            153187553,
            153195355,
            153198079,
            153192699,
            153208735,
            153197140,
            153204834,
            153209679,
            153216895,
            153192345,
            153209985,
            153215287,
            153214260,
            153206784,
            153181924,
            153187391,
            153499691
        ],
        "E": [
            153181602,
            153183458,
            153186252,
            153186023,
            153206034,
            153195940,
            153194023,
            153206147,
            153218775,
            153197839,
            153195670,
            153202578,
            153201319,
            153198707,
            153201518,
            153192938,
            153189205,
            153195957,
            153196511
        ],
        "D": [
            153174390,
            153174537,
            153175638,
            153174007,
            153176690,
            153176745,
            153185907,
            153182627,
            153178744,
            153172686,
            153190154,
            153190396,
            153190106,
            153210872,
            153207891,
            153175462,
            153176825,
            153177570,
            153175676
        ],
        "C": [
            153170138,
            153167530,
            153168248,
            153169048,
            153170259,
            153170541,
            153168119,
            153170774,
            153172726,
            153194437,
            153178130,
            153175287,
            153185061,
            153205419,
            153246548,
            153215381,
            153166182,
            153169099,
            153168642,
            153167758
        ],
        "B": [
            153162156,
            153162580,
            153161952,
            153162200,
            153164678,
            153162918,
            153163800,
            153162935,
            153167883,
            153164440,
            153162927,
            153168126,
            153181318,
            153200885,
            153216655,
            153161628,
            153165270,
            153163647,
            153161926
        ],
        "A": [
            153160994,
            153160951,
            153163491,
            153160922,
            153160942,
            153161262,
            153161508,
            153160985,
            153162410,
            153161094,
            153160862,
            153162511,
            153178823,
            153198439,
            153217630,
            153160910,
            153162727,
            153160959,
            153160858
        ]
    },
    "name": "C. Water the Trees",
    "statement": "There are n trees in a park, numbered from 1 to n. The initial height of\r\nthe i-th tree is h_i.You want to water these trees, so they all grow to\r\nthe height.The watering process goes as follows. You start watering\r\ntrees at day 1. During the j-th day you can: Choose a tree and water it.\r\nIf the day is odd (e.g. 1, 3, 5, 7,\r\ndots), then the height of the tree increases by 1. If the day is even\r\n(e.g. 2, 4, 6, 8,\r\ndots), then the height of the tree increases by 2. Or skip a day without\r\nwatering any tree. Note that you can\u2019t water more than one tree in a\r\nday. Your task is to determine the number of days required to water the\r\ntrees so they grow to the same height.You have to answer t independent\r\ntest cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1000000000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int j = 0; j < n; j++){\n      cin >> h[j];\n    }\n    int mx = 0;\n    for (int j = 0; j < n; j++){\n      mx = max(mx, h[j]);\n    }\n    long long ans = INF;\n    for (int j = 0; j < 3; j++){\n      long long sum = 0;\n      int cnt = 0;\n      for (int k = 0; k < n; k++){\n        sum += mx + j - h[k];\n        if ((mx + j - h[k]) % 2 == 1){\n          cnt++;\n        }\n      }\n      long long res = sum / 3 * 2;\n      if (sum % 3 == 1){\n        res++;\n      }\n      if (sum % 3 == 2){\n        res += 2;\n      }\n      res = max(res, (long long) cnt * 2 - 1);\n      ans = min(ans, res);\n    }\n    cout << ans << endl;\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Water the Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/101790",
    "editorial": "The first observation we need to solve this problem: the required height\r\nis either or , where is the maximum initial height of some tree. We\r\ndon\u00e2\u0080\u0099t need heights greater than , because, for example, if the height is\r\n, we can remove some moves and get the answer for the height . The same\r\nthing applies to all heights greater than . Why do we even need the\r\nheight ? In some cases (like ) the answer for the height is better than\r\nthe answer for the height (in this particular case, it is vs ).Now, we\r\nhave two ways to solve the problem: either use some gross formulas, or\r\njust write a binary search on the answer. I won\u00e2\u0080\u0099t consider the solution\r\nwith formulas (but we have one), so let\u00e2\u0080\u0099s assume we use binary search.\r\nLet the current answer be . Then let be the number of operations we can\r\ndo and be the number of operations we can do. We can use operations\r\ngreedily and then just check if the number of operations is sufficient\r\nto grow up the remaining heights.Time complexity: per test case.\r\n"
}