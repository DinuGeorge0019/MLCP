{
    "link": "https://codeforces.com//contest/1697/problem/F",
    "problemId": "1427645",
    "problem_idx": "F",
    "shortId": "1697F",
    "contest_number": "1697",
    "problem_submissions": {
        "F": [
            160316028,
            160335271,
            160331836,
            160345509,
            160346300,
            160344663,
            160340959,
            160455567,
            160365066,
            160450918
        ],
        "E": [
            160306724,
            160317216,
            160317720,
            160323985,
            160325271,
            160325964,
            160354419,
            160319599,
            160322353,
            160325146,
            160325548,
            160320808,
            160330194,
            160331332,
            160324375,
            160329677,
            160325210,
            160439973,
            160435649,
            160435501,
            160334542,
            160334158
        ],
        "D": [
            160297103,
            160308079,
            160308707,
            160309184,
            160311087,
            160315683,
            160304446,
            160307456,
            160306088,
            160309775,
            160310589,
            160312120,
            160309909,
            160314751,
            160306875,
            160306002,
            160313672,
            160319695,
            160308549
        ],
        "C": [
            160289797,
            160295599,
            160301341,
            160300167,
            160298909,
            160307057,
            160312096,
            160291233,
            160293256,
            160294510,
            160299611,
            160297247,
            160296258,
            160299415,
            160296418,
            160293099,
            160299382,
            160299241,
            160297402
        ],
        "B": [
            160279508,
            160282090,
            160301342,
            160292066,
            160285118,
            160283650,
            160284312,
            160283738,
            160281629,
            160287785,
            160284110,
            160279928,
            160285652,
            160285722,
            160282180,
            160283286,
            160288457,
            160284205,
            160285201
        ],
        "A": [
            160279237,
            160279338,
            160286569,
            160289515,
            160279504,
            160279374,
            160279443,
            160279381,
            160279282,
            160282067,
            160279274,
            160279241,
            160281284,
            160279454,
            160279294,
            160279242,
            160281815,
            160279598,
            160280937
        ]
    },
    "name": "F. Too Many Constraints",
    "statement": "You are asked to build an array a, consisting of n integers, each\r\nelement should be from 1 to k.The array should be non-decreasing (a_i\r\nle a_{i+1} for all i from 1 to n-1). You are also given additional\r\nconstraints on it. Each constraint is of one of three following types:\r\n1 i x: a_i be equal to x; 2 i j x: a_i + a_j should be less than or\r\nequal to x; 3 i j x: a_i + a_j should be greater than or equal to x.\r\nBuild any non-decreasing array that satisfies all constraints or report\r\nthat no such array exists.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.06.2022 19:00:43       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  vector<int> order;\n  vector<bool> was(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    was[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!was[to]) {\n        dfs1(to);\n      }\n    }\n    order.push_back(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  vector<int> c(g.n, -1);\n  function<void(int)> dfs2 = [&](int v) {\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (c[to] == -1) {\n        c[to] = c[v];\n        dfs2(to);\n      }\n    }\n  };\n  cnt = 0;\n  for (int id = g.n - 1; id >= 0; id--) {\n    int i = order[id];\n    if (c[i] != -1) {\n      continue;\n    }\n    c[i] = cnt++;\n    dfs2(i);\n  }\n  return c;\n}\n\nclass twosat {\n public:\n  digraph<int> g;\n  int n;\n\n  twosat(int _n) : g(digraph<int>(2 * _n)), n(_n) {\n  }\n\n  inline void add(int x, int value_x) {\n    assert(0 <= x && x < n);\n    assert(0 <= value_x && value_x <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * x + value_x);\n  }\n  \n  inline void add(int x, int value_x, int y, int value_y) {\n    assert(0 <= x && x < n && 0 <= y && y < n);\n    assert(0 <= value_x && value_x <= 1 && 0 <= value_y && value_y <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * y + value_y);\n    g.add(2 * y + (value_y ^ 1), 2 * x + value_x);\n  }\n\n  inline vector<int> solve() {\n    int cnt;\n    vector<int> c = find_scc(g, cnt);\n    vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n      if (c[2 * i] == c[2 * i + 1]) {\n        return vector<int>();\n      }\n      res[i] = (c[2 * i] < c[2 * i + 1]);\n    }\n    return res;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m, k;\n    cin >> n >> m >> k;\n    twosat ts(n * (k + 1));\n    for (int i = 0; i < n; i++) {\n      ts.add(i * (k + 1) + 0, 0);\n      ts.add(i * (k + 1) + k, 1);\n      for (int j = 0; j < k; j++) {\n        ts.add(i * (k + 1) + j, 0, i * (k + 1) + (j + 1), 1);\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      for (int j = 1; j < k; j++) {\n        ts.add(i * (k + 1) + j, 1, (i + 1) * (k + 1) + j, 0);\n      }\n    }\n    while (m--) {\n      int op;\n      cin >> op;\n      if (op == 1) {\n        int i, x;\n        cin >> i >> x;\n        --i;\n        ts.add(i * (k + 1) + x - 1, 1, i * (k + 1) + x, 0);\n      }\n      if (op == 2) {\n        int i, j, x;\n        cin >> i >> j >> x;\n        --i; --j;\n        for (int p = 0; p <= k; p++) {\n          int q = x - 1 - p;\n          if (q >= 0 && q <= k) {\n            ts.add(i * (k + 1) + p, 1, j * (k + 1) + q, 1);\n          }\n        }\n      }\n      if (op == 3) {\n        int i, j, x;\n        cin >> i >> j >> x;\n        --i; --j;\n        for (int p = 0; p <= k; p++) {\n          int q = x - 1 - p;\n          if (q >= 0 && q <= k) {\n            ts.add(i * (k + 1) + p, 0, j * (k + 1) + q, 0);\n          }\n        }\n      }\n    }\n    auto res = ts.solve();\n    if (res.empty()) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 1; j <= k; j++) {\n        if (res[i * (k + 1) + j]) {\n          a[i] = j;\n          break;\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << \" \\n\"[i == n - 1];\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "constructive algorithms",
        "graphs",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Too Many Constraints.json",
    "editorial_link": "https://codeforces.com//blog/entry/103835",
    "editorial": "Imagine there were no constraints of the second or the third types. Then\r\nit would be possible to solve the problem with some greedy algorithm.\r\nUnfortunately, when both these constraints are present, itâs not\r\nimmediately clear how to adapt the greedy.Dynamic programming is\r\nprobably also out of question, because you canât maintain all possible\r\ncuts between equal values on each prefix.Thus, letâs try to make a graph\r\nproblem out of this. Who knows, maybe a flow or something else could\r\nwork.Create nodes for each position. Let the -th of them on the -th\r\nposition represent the condition of kind \"is equal to ?\". Then all\r\nconstraints can be described as edges on this graph. Binary variables,\r\nrestrictive edges. Surely, this is 2-SAT.Connect the pairs of values\r\nthat satisfy each constraint. Add the edges between the adjacent\r\npositions to enforce the restriction on the non-decreasing order.\r\nProhibit each position to be assigned to multiple values. Force each\r\nposition to be assigned at least one value. Huh, itâs not that easy.\r\nThatâs where the 2-SAT idea fails. We want the conditions of form . But\r\nthat is not allowed, since 2-SAT has to have two variables in a\r\nclause.Thatâs where the main idea of the problem comes up. Instead of\r\nmaking our nodes represent , letâs make them and try building the graph\r\nagain.If , then all nodes for will be true, and the rest will be false.\r\nSo if is false, then is false. That will enforce the validity of the\r\nnodes themselves.First, the order. If is true, then is true.The first\r\ntype of constraints. is basically the same as ( or ). For our\r\nconditions, itâs rather ((not ) or ).The second type of constraints. .\r\nLet be greater than or equal to some . Then, for this constraint to\r\nhold, should be no greater than . Thus, if is true, then should be\r\nfalse. Same for and swapped.The third type of constraints is similar. .\r\nLet be less than or equal to some . Then, for this constraint to hold,\r\nshould be greater than or equal to . Thus, if is false, then should be\r\ntrue. Same for and swapped.And thatâs it. Solve the 2-SAT and restore\r\nthe answer. I can advise making not but actually nodes for and force the\r\nvalues to be between and . That will simplify the checks while adding\r\nthe constraints.Overall complexity: .\r\n",
    "hint": []
}