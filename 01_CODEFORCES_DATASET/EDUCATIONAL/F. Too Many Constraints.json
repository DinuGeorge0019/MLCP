{"link": "https://codeforces.com//contest/1697/problem/F", "problemId": "1427645", "problem_idx": "F", "shortId": "1697F", "contest_number": "1697", "problem_submissions": {"F": [160316028, 160335271, 160331836, 160345509, 160346300, 160344663, 160340959, 160455567, 160365066, 160450918], "E": [160306724, 160317216, 160317720, 160323985, 160325271, 160325964, 160354419, 160319599, 160322353, 160325146, 160325548, 160320808, 160330194, 160331332, 160324375, 160329677, 160325210, 160439973, 160435649, 160435501, 160334542, 160334158], "D": [160297103, 160308079, 160308707, 160309184, 160311087, 160315683, 160304446, 160307456, 160306088, 160309775, 160310589, 160312120, 160309909, 160314751, 160306875, 160306002, 160313672, 160319695, 160308549], "C": [160289797, 160295599, 160301341, 160300167, 160298909, 160307057, 160312096, 160291233, 160293256, 160294510, 160299611, 160297247, 160296258, 160299415, 160296418, 160293099, 160299382, 160299241, 160297402], "B": [160279508, 160282090, 160301342, 160292066, 160285118, 160283650, 160284312, 160283738, 160281629, 160287785, 160284110, 160279928, 160285652, 160285722, 160282180, 160283286, 160288457, 160284205, 160285201], "A": [160279237, 160279338, 160286569, 160289515, 160279504, 160279374, 160279443, 160279381, 160279282, 160282067, 160279274, 160279241, 160281284, 160279454, 160279294, 160279242, 160281815, 160279598, 160280937]}, "name": "F. Too Many Constraints", "statement": "You are asked to build an array a, consisting of n integers, each\r\nelement should be from 1 to k.The array should be non-decreasing (a_i\r\nle a_{i+1} for all i from 1 to n-1). You are also given additional\r\nconstraints on it. Each constraint is of one of three following types:\r\n1\u00a0i\u00a0x: a_i be equal to x; 2\u00a0i\u00a0j\u00a0x: a_i + a_j should be less than or\r\nequal to x; 3\u00a0i\u00a0j\u00a0x: a_i + a_j should be greater than or equal to x.\r\nBuild any non-decreasing array that satisfies all constraints or report\r\nthat no such array exists.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 12.06.2022 19:00:43       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  vector<int> order;\n  vector<bool> was(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    was[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!was[to]) {\n        dfs1(to);\n      }\n    }\n    order.push_back(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  vector<int> c(g.n, -1);\n  function<void(int)> dfs2 = [&](int v) {\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (c[to] == -1) {\n        c[to] = c[v];\n        dfs2(to);\n      }\n    }\n  };\n  cnt = 0;\n  for (int id = g.n - 1; id >= 0; id--) {\n    int i = order[id];\n    if (c[i] != -1) {\n      continue;\n    }\n    c[i] = cnt++;\n    dfs2(i);\n  }\n  return c;\n}\n\nclass twosat {\n public:\n  digraph<int> g;\n  int n;\n\n  twosat(int _n) : g(digraph<int>(2 * _n)), n(_n) {\n  }\n\n  inline void add(int x, int value_x) {\n    assert(0 <= x && x < n);\n    assert(0 <= value_x && value_x <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * x + value_x);\n  }\n  \n  inline void add(int x, int value_x, int y, int value_y) {\n    assert(0 <= x && x < n && 0 <= y && y < n);\n    assert(0 <= value_x && value_x <= 1 && 0 <= value_y && value_y <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * y + value_y);\n    g.add(2 * y + (value_y ^ 1), 2 * x + value_x);\n  }\n\n  inline vector<int> solve() {\n    int cnt;\n    vector<int> c = find_scc(g, cnt);\n    vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n      if (c[2 * i] == c[2 * i + 1]) {\n        return vector<int>();\n      }\n      res[i] = (c[2 * i] < c[2 * i + 1]);\n    }\n    return res;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m, k;\n    cin >> n >> m >> k;\n    twosat ts(n * (k + 1));\n    for (int i = 0; i < n; i++) {\n      ts.add(i * (k + 1) + 0, 0);\n      ts.add(i * (k + 1) + k, 1);\n      for (int j = 0; j < k; j++) {\n        ts.add(i * (k + 1) + j, 0, i * (k + 1) + (j + 1), 1);\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      for (int j = 1; j < k; j++) {\n        ts.add(i * (k + 1) + j, 1, (i + 1) * (k + 1) + j, 0);\n      }\n    }\n    while (m--) {\n      int op;\n      cin >> op;\n      if (op == 1) {\n        int i, x;\n        cin >> i >> x;\n        --i;\n        ts.add(i * (k + 1) + x - 1, 1, i * (k + 1) + x, 0);\n      }\n      if (op == 2) {\n        int i, j, x;\n        cin >> i >> j >> x;\n        --i; --j;\n        for (int p = 0; p <= k; p++) {\n          int q = x - 1 - p;\n          if (q >= 0 && q <= k) {\n            ts.add(i * (k + 1) + p, 1, j * (k + 1) + q, 1);\n          }\n        }\n      }\n      if (op == 3) {\n        int i, j, x;\n        cin >> i >> j >> x;\n        --i; --j;\n        for (int p = 0; p <= k; p++) {\n          int q = x - 1 - p;\n          if (q >= 0 && q <= k) {\n            ts.add(i * (k + 1) + p, 0, j * (k + 1) + q, 0);\n          }\n        }\n      }\n    }\n    auto res = ts.solve();\n    if (res.empty()) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 1; j <= k; j++) {\n        if (res[i * (k + 1) + j]) {\n          a[i] = j;\n          break;\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << \" \\n\"[i == n - 1];\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["2-sat", "constructive algorithms", "graphs", "implementation"], "dificulty": "2800", "interactive": false}