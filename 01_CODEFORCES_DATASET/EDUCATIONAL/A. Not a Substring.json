{
    "link": "https://codeforces.com//contest/1860/problem/A",
    "problemId": "2169697",
    "problem_idx": "A",
    "shortId": "1860A",
    "contest_number": "1860",
    "problem_submissions": {
        "F": [
            219298549,
            219320447,
            219349019,
            219323121,
            219334429,
            219337442,
            219335056,
            219339341,
            219339231,
            219349246,
            219345811,
            219439688,
            219439045,
            219356857,
            219353864,
            219402976,
            219353456,
            219351823
        ],
        "E": [
            219277150,
            219281408,
            219287269,
            219300383,
            219293770,
            219301781,
            219289069,
            219306188,
            219288291,
            219288789,
            219301050,
            219298191,
            219305638,
            219306388,
            219300992,
            219313680,
            219301529,
            219309490,
            219305863,
            219309540,
            219307800
        ],
        "D": [
            219271388,
            219273923,
            219270716,
            219286342,
            219405254,
            219345669,
            219344552,
            219277413,
            219284438,
            219280247,
            219290826,
            219278202,
            219277998,
            219274616,
            219275328,
            219282484,
            219281832,
            219279471,
            219288325,
            219282155,
            219284217,
            219287012,
            219287888
        ],
        "C": [
            219264168,
            219264568,
            219266116,
            219265339,
            219269044,
            219276912,
            219269876,
            219279690,
            219266598,
            219268637,
            219263040,
            219261658,
            219264629,
            219267625,
            219267964,
            219267177,
            219271968,
            219274243,
            219264405,
            219273316
        ],
        "B": [
            219260635,
            219258799,
            219260447,
            219259349,
            219260950,
            219267717,
            219262012,
            219271581,
            219260726,
            219261008,
            219259442,
            219257734,
            219259759,
            219262401,
            219260169,
            219259084,
            219263649,
            219264522,
            219272480,
            219264690
        ],
        "A": [
            219257237,
            219257029,
            219257674,
            219257720,
            219257171,
            219258923,
            219257078,
            219260398,
            219257258,
            219257446,
            219257236,
            219256961,
            219257126,
            219257819,
            219257229,
            219257120,
            219257449,
            219257142,
            219257016,
            219258968
        ]
    },
    "name": "A. Not a Substring",
    "statement": "A bracket sequence is a string consisting of characters ” and/or ”. A\r\nregular bracket sequence is a bracket sequence that can be transformed\r\ninto a correct arithmetic expression by inserting characters ” and ”\r\nbetween the original characters of the sequence. For example: bracket\r\nsequences \"\" and \"\" are regular (they can be transformed into \"\" and \"\",\r\nrespectively); bracket sequences \"\", \"\" and \"\" are not regular. You are\r\ngiven a bracket sequence s; let’s define its length as n. Your task is\r\nto find a regular bracket sequence t of length 2n such that s occur in t\r\nas a , or report that there is no such sequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    if (s == \"()\") {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    \n    std::cout << \"YES\\n\";\n    bool alt = true;\n    for (int i = 1; i < n; i++) {\n        if (s[i] == s[i - 1]) {\n            alt = false;\n        }\n    }\n    if (alt) {\n        std::cout << std::string(n, '(') + std::string(n, ')') << \"\\n\";\n    } else {\n        for (int i = 1; i <= n; i++) {\n            std::cout << \"()\";\n        }\n        std::cout << \"\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Not a Substring.json",
    "editorial_link": "https://codeforces.com//blog/entry/119504",
    "editorial": "Letâs consider the following two cases: the string contains two\r\nconsecutive equal characters, for example, \"\" or \"\". In this case, we\r\ncan choose a string of the form \"\", since it does not contain a\r\nsubstring of two equal characters, therefore is not a substring of ; in\r\nthe string , all adjacent characters are different, i.e., it is\r\nalternating. In this case, we can choose a string of the form \"\", since\r\nhere the length of the longest alternating substring is . The only\r\nalternating substring it contains is \"\", which is a part of regular\r\nbracket sequence. Thus, it is sufficient to consider the answer among\r\nonly two candidates \"\" and \"\" of length .\r\n",
    "hint": []
}