{
    "link": "https://codeforces.com//contest/1728/problem/C",
    "problemId": "1534224",
    "problem_idx": "C",
    "shortId": "1728C",
    "contest_number": "1728",
    "problem_submissions": {
        "F": [
            171415471,
            171408709,
            171477755,
            171477598,
            171800837,
            171602685,
            171508405,
            171615612,
            171428158,
            171416710,
            171516704
        ],
        "G": [
            171401437,
            171423625,
            171401320,
            171405459,
            171408910,
            171400855,
            171410753,
            171399735,
            171425286,
            171424973,
            171424864,
            171421363,
            171409384,
            171429440,
            171419291,
            171421745,
            171401911,
            171420331,
            171494040,
            171406232,
            171419649,
            171415822,
            171442989,
            171426124,
            171423998,
            171422898,
            171422786,
            171419842
        ],
        "E": [
            171378857,
            171391875,
            171380622,
            171383139,
            171380478,
            171390287,
            171381329,
            171385138,
            171384190,
            171396093,
            171392841,
            171388311,
            171403618,
            171390049,
            171393452,
            171494181,
            171455206,
            171419342,
            171391692,
            171398313,
            171393739,
            171428155,
            171396053,
            171400068
        ],
        "D": [
            171364431,
            171379034,
            171368807,
            171365018,
            171370163,
            171375547,
            171369467,
            171380229,
            171364084,
            171374772,
            171368217,
            171377453,
            171410355,
            171379812,
            171386430,
            171377364,
            171385449,
            171375075,
            171380828,
            171376969
        ],
        "C": [
            171356021,
            171355657,
            171354790,
            171355489,
            171357376,
            171364423,
            171358552,
            171371507,
            171356927,
            171358656,
            171358481,
            171361890,
            171364747,
            171361193,
            171494234,
            171359234,
            171364539,
            171370274,
            171358915,
            171369689,
            171370585
        ],
        "B": [
            171350944,
            171350546,
            171350225,
            171351747,
            171353484,
            171350234,
            171353700,
            171367743,
            171353076,
            171355275,
            171352643,
            171355734,
            171359875,
            171351546,
            171353658,
            171357176,
            171361933,
            171353420,
            171361436,
            171361759
        ],
        "A": [
            171346435,
            171346486,
            171346382,
            171346456,
            171348074,
            171346466,
            171346859,
            171352332,
            171346599,
            171349231,
            171346445,
            171346558,
            171348949,
            171346594,
            171346485,
            171349162,
            171347108,
            171346675,
            171346628,
            171349812
        ]
    },
    "name": "C. Digital Logarithm",
    "statement": "Let’s define f(x) for a positive integer x as the length of the base-10\r\nrepresentation of x without leading zeros. I like to call it a digital\r\nlogarithm. Similar to a digital root, if you are familiar with that.You\r\nare given two arrays a and b, each containing n positive integers. In\r\none operation, you do the following: pick some integer i from 1 to n;\r\nassign either f(a_i) to a_i or f(b_i) to b_i. Two arrays are considered\r\nsimilar to each other if you can rearrange the elements in both of them,\r\nso that they are equal (e. g. a_i = b_i for all i from 1 to n).What’s\r\nthe smallest number of operations required to make a and b similar to\r\neach other?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 2e5 + 5;\n\npriority_queue<int> A, B;\nint a[N], b[N];\nint T, n;\n\nint calc(int x) {\n\tint ans = 0;\n\twhile (x) {\n\t\t++ans;\n\t\tx /= 10;\n\t}\n\treturn ans;\n}\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tn = read();\n\t\tfor (int i = 1; i <= n; i++) a[i] = read(), A.push(a[i]);\n\t\tfor (int i = 1; i <= n; i++) b[i] = read(), B.push(b[i]);\n\t\tint ans = 0;\n\t\tfor (int _ = 1; _ <= n; _++) {\n\t\t\tint x = A.top(), y = B.top();\n\t\t\twhile (x != y) {\n\t\t\t\t++ans;\n\t\t\t\tif (x > y) {\n\t\t\t\t\tA.pop();\n\t\t\t\t\tA.push(calc(x));\n\t\t\t\t\tx = A.top();\n\t\t\t\t} else {\n\t\t\t\t\tB.pop();\n\t\t\t\t\tB.push(calc(y));\n\t\t\t\t\ty = B.top();\n\t\t\t\t}\n\t\t\t}\n\t\t\tA.pop();\n\t\t\tB.pop();\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Digital Logarithm.json",
    "editorial_link": "https://codeforces.com//blog/entry/106805",
    "editorial": "First, why can you always make the arrays similar? Applying a digital\r\nlogarithm to any number will eventually make it equal to . Thus, you can\r\nat least make all numbers into s in both arrays.Then notice the most\r\nimprotant thing applying the digital logarithm to a number greater than\r\nalways makes this number smaller.Thus, if a number appears in only one\r\nof the arrays, you will have to do one of the followings two things:\r\ndecrease some greater number to make it equal to this one; decrease this\r\nnumber. What if there is no greater number at all? This is the case for\r\nthe largest number in both arrays altogether. If it appears in only one\r\nof the arrays, you must always decrease. If it appears in both, though,\r\nwhy decrease it further? Worst case, you will decrease it in one array,\r\nthen youâll have to decrease it in the other array as well. This is\r\nnever more optimal than just matching one occurrence in both arrays to\r\neach other and removing them from the arrays.So, the proposed solution\r\nis the following. Consider the largest element in each array. If they\r\nare equal, remove both. If not, apply digital logarithm to the larger of\r\nthem. Continue until the arrays are empty.Whatâs the estimated\r\ncomplexity of this algorithm? Each number in the first array will be\r\nconsidered at most the number of times you can decrease it with a\r\ndigital logarithm operation plus one. That is at most a number greater\r\nthan always becomes a single digit and a single digit always becomes .\r\nSame goes for the second array. So the complexity is basically linear.To\r\nimplement it efficiently, you will have to use some data structure that\r\nprovides three operations: peek at the maximum; remove the maximum;\r\ninsert a new element. The perfect one is a heap priority_queue in\r\nC++.Overall complexity: per testcase.\r\n",
    "hint": []
}