{
    "link": "https://codeforces.com//contest/1895/problem/D",
    "problemId": "2305458",
    "problem_idx": "D",
    "shortId": "1895D",
    "contest_number": "1895",
    "problem_submissions": {
        "F": [
            231327821,
            231171975,
            231177341,
            231177139,
            231181247,
            231175451,
            231179505,
            231178754,
            231171033,
            231178007,
            231174701,
            231183326,
            231187269,
            231180010,
            231181283,
            231185538,
            231191457,
            231188914,
            231183055,
            231180065,
            231188744
        ],
        "E": [
            231166411,
            231162837,
            231168539,
            231171744,
            231170279,
            231169982,
            231169182,
            231183134,
            231173048,
            231168317,
            231174671,
            231173323,
            231173438,
            231175391,
            231175133,
            231176680,
            231179383,
            231171479,
            231175722,
            231195510
        ],
        "D": [
            231152062,
            231147559,
            231156462,
            231152946,
            231160742,
            231157174,
            231157872,
            231159102,
            231163758,
            231163699,
            231163345,
            231153744,
            231159964,
            231158155,
            231162193,
            231160798,
            231161526,
            231144729,
            231162242,
            231164715,
            231182588,
            231152194
        ],
        "C": [
            231148538,
            231143114,
            231150605,
            231147252,
            231154149,
            231154615,
            231153991,
            231151789,
            231144066,
            231169078,
            231151364,
            231154661,
            231154195,
            231153927,
            231153798,
            231162003,
            231153879,
            231145977,
            231148366,
            231148040
        ],
        "B": [
            231139170,
            231136290,
            231139512,
            231137580,
            231137719,
            231135569,
            231140209,
            231138699,
            231136948,
            231136771,
            231139306,
            231136791,
            231139010,
            231138206,
            231140302,
            231137608,
            231140161,
            231139339,
            231137240,
            231137323
        ],
        "A": [
            231135878,
            231135554,
            231135956,
            231135743,
            231135841,
            231137384,
            231140495,
            231135913,
            231135720,
            231135699,
            231136135,
            231135592,
            231135620,
            231135621,
            231136784,
            231135521,
            231136631,
            231135611,
            231135732,
            231135594
        ],
        "G": [
            231214354,
            231210500,
            231273875,
            231214703,
            231213900,
            231213313
        ]
    },
    "name": "D. XOR Construction",
    "statement": "You are given n-1 integers a_1, a_2,\r\ndots, a_{n-1}.Your task is to construct an array b_1, b_2,\r\ndots, b_n such that: every integer from 0 to n-1 appears in b exactly\r\nonce; for every i from 1 to n-1, b_i\r\noplus b_{i+1} = a_i (where\r\noplus denotes the bitwise XOR operator).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?\"YES\\n\":\"Yes\\n\"); else cout<<(upp?\"NO\\n\":\"No\\n\");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<'{';for(int i=0;i<(int)p.size();i++){if(i){cout<<\",\";}cout<<'\"'<<p[i]<<'\"';}cout<<\"}\\n\";}\nelse{if(ty==1){cout<<p.size()<<\"\\n\";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<\" \";cout<<p[i];}cout<<\"\\n\";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    //cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<int> A(N);\n\trep(i,0,N-1){\n\t\tcin>>A[i+1];\n\t\tA[i+1]^=A[i];\n\t}\n\tfor(int d=0;d<30;d++){\n\t\tint X=0;\n\t\trep(i,0,N){\n\t\t\tif(A[i]&(1<<d)) X++;\n\t\t\telse X--;\n\t\t}\n\t\tif(X>0) rep(i,0,N) A[i]^=(1<<d);\n\t}\n\tvec_out(A);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "data structures",
        "math",
        "string suffix structures",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. XOR Construction.json",
    "editorial_link": "https://codeforces.com//blog/entry/122034",
    "editorial": "We can see that the first element of the array determines all other\r\nvalues, .So letâs iterate over the value of . For every value of , we\r\nneed to check whether it produces correct permutation or not (i. e. all\r\n). To do it in a fast way, we can generate an array , where is the XOR\r\nof the first element of the array (i.e. and ). We can see that . Letâs\r\nstore all values of in a binary trie. To check that produces an array\r\nwhere all elements are less than , we can calculate the maximum value of\r\nusing descending on the trie. If the maximum is less than , then itâs a\r\nvalid first element of the permutation.Note that we donât actually need\r\nto check that the minimum is exactly and all elements are distinct: we\r\nare guaranteed that the answer exists, so all values are pairwise\r\ndistinct, and no matter which we choose, all will also be pairwise\r\ndistinct.\r\n",
    "hint": []
}