{
    "link": "https://codeforces.com//contest/915/problem/D",
    "problemId": "146471",
    "problem_idx": "D",
    "shortId": "915D",
    "contest_number": "915",
    "problem_submissions": {
        "G": [
            34149372,
            34145802,
            34144917,
            34149940,
            34145497,
            34145091,
            34146841,
            34133578,
            34140368,
            34156614,
            34136642,
            34149433,
            34141049,
            34151857,
            34143141,
            34142291,
            34153795,
            34152031,
            34149642
        ],
        "F": [
            34141740,
            34141911,
            34142659,
            34144461,
            34139648,
            34150037,
            34135451,
            34135325,
            34136765,
            34139507,
            34185912,
            34185895,
            34185884,
            34144212,
            34147801,
            34138374,
            34149691,
            34145676,
            34149957
        ],
        "E": [
            34139509,
            34136671,
            34139993,
            34142857,
            34141594,
            34143243,
            34138759,
            34150868,
            34131224,
            34145365,
            34144825,
            34146415,
            34139658,
            34148670,
            34147938,
            34144847,
            34142409,
            34147934,
            34152612
        ],
        "D": [
            34136912,
            34138946,
            34136834,
            34138837,
            34134917,
            34139148,
            34142081,
            34147574,
            34141584,
            34140548,
            34136477,
            34136703,
            34136486,
            34145522,
            34138909,
            34138016,
            34141644,
            34141385,
            34135263
        ],
        "C": [
            34133179,
            34132160,
            34132616,
            34134296,
            34131528,
            34132656,
            34145969,
            34144943,
            34139362,
            34131971,
            34135532,
            34132111,
            34166504,
            34134375,
            34134967,
            34134748,
            34132949,
            34134607,
            34133338
        ],
        "B": [
            34129725,
            34129567,
            34129784,
            34132321,
            34130243,
            34147501,
            34142325,
            34138326,
            34132523,
            34157084,
            34130697,
            34130455,
            34131022,
            34130794,
            34158518,
            34130482
        ],
        "A": [
            34127694,
            34127702,
            34127886,
            34130517,
            34127730,
            34147894,
            34141073,
            34137409,
            34128096,
            34127668,
            34127948,
            34127873,
            34127723,
            34128273,
            34128083,
            34127880
        ]
    },
    "name": "D. Almost Acyclic Graph",
    "statement": "You are given a directed graph consisting of vertices and edges (each\r\nedge is directed, so it can be traversed in only one direction). You are\r\nallowed to remove at most one edge from it.Can you make this graph\r\nacyclic by removing at most one edge from it? A directed graph is called\r\nacyclic iff it doesn’t contain any cycle (a non-empty path that starts\r\nand ends in the same vertex).\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\n\nvector<int>edges[510];\nint t1, t2;\n\nvector<int>curCycle;\nbool vis[510];\nbool tVis[510];\nint dfsC(int a) {\n\tif (tVis[a])return -1;\n\tif (vis[a]) {\n\t\tcurCycle.push_back(a);\n\t\treturn a;\n\t}\n\tvis[a] = true;\n\tint ret = -1;\n\tfor (auto x : edges[a]) {\n\t\tif (t1 == a && t2 == x)continue;\n\t\tint d = dfsC(x);\n\t\tif (d == -1)continue;\n\t\tif (d == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (d == a) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tret = d;\n\t\tcurCycle.push_back(a);\n\t\tbreak;\n\t}\n\ttVis[a] = true;\n\treturn ret;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint n, m; cin >> n >> m;\n\tfori(m) {\n\t\tint a, b; cin >> a >> b;\n\t\tedges[a].push_back(b);\n\t}\n\tfori1(n) {\n\t\tint x = dfsC(i);\n\t\tif (x == 0)break;\n\t}\n\tif (curCycle.empty()) {\n\t\tcout << \"YES\";\n\t\treturn 0;\n\t}\n\tvector<int>cycle = curCycle;\n\treverse(cycle.begin(), cycle.end());\n\tfori(cycle.size()) {\n\t\tt1 = cycle[i];\n\t\tt2 = cycle[(i + 1) % cycle.size()];\n\t\tforj1(n)vis[j] = tVis[j] = false;\n\t\tbool haveC = false;\n\t\tforj1(n) {\n\t\t\tint x = dfsC(j);\n\t\t\tif (x == 0) {\n\t\t\t\thaveC = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!haveC) {\n\t\t\tcout << \"YES\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"NO\";\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Almost Acyclic Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/57123",
    "editorial": "The constraits are set in such a way that naive solution wonât pass\r\n(unmark every edge one by one and check if graph of marked edges doesnât\r\ncontain cycles with dfs/bfs). Thus we should somehow limit the number of\r\nedges to check. Letâs take arbitrary cycle in graph. Do dfs, store the\r\nvertex you used to travel to any other vertex and restore edges with\r\nthis data if cycle is met. With this algo length of cycle will not\r\nexceed . Then do the naive algo but check only edges from this\r\ncycle.Overall complexity: .\r\n",
    "hint": []
}