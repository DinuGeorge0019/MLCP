{
    "link": "https://codeforces.com//contest/1167/problem/B",
    "problemId": "344631",
    "problem_idx": "B",
    "shortId": "1167B",
    "contest_number": "1167",
    "problem_submissions": {
        "G": [
            54199521,
            54201009,
            54517594,
            54222661,
            54364012,
            54215552,
            54224700,
            54210170,
            54210125,
            54210060,
            54209496,
            54208961,
            54219271,
            58247930
        ],
        "F": [
            54189763,
            54191560,
            54188017,
            54193815,
            54198047,
            54197721,
            54195395,
            54190513,
            54198962,
            54198980,
            54197783,
            54198116,
            54209016,
            54200221,
            54197337,
            54195561,
            54196921,
            54190680,
            54201016,
            54197503,
            54199324
        ],
        "E": [
            54187099,
            54187335,
            54196048,
            54186318,
            54187789,
            54191563,
            54192086,
            54195810,
            54191131,
            54191667,
            54192242,
            54194803,
            54192777,
            54191266,
            54189610,
            54192694,
            54196385,
            54241812,
            54208508,
            54196237,
            54192975,
            54196282
        ],
        "D": [
            54184655,
            54183868,
            54182601,
            54254072,
            54187816,
            54183265,
            54184958,
            54187415,
            54186508,
            54185650,
            54184214,
            54187917,
            54185330,
            54215169,
            54214062,
            54213957,
            54213940,
            54212912,
            54212894,
            54186804,
            54192578,
            54182335,
            54185963,
            54184762,
            54186406,
            54188164,
            54188808
        ],
        "C": [
            54183325,
            54182652,
            54179797,
            54181639,
            54180270,
            54183029,
            54186018,
            54184791,
            54184638,
            54183698,
            54183060,
            54181938,
            54183556,
            54183141,
            54183089,
            54180288,
            54184423,
            54183220,
            54184555,
            54185863,
            54182921
        ],
        "B": [
            54182048,
            54181521,
            54184836,
            54179971,
            54182085,
            54181491,
            54183487,
            54185276,
            54182631,
            54181677,
            54186071,
            54182415,
            54181445,
            54182146,
            54198453,
            54183319,
            54181503,
            54182555,
            54184235,
            54186573
        ],
        "A": [
            54178078,
            54178458,
            54177903,
            54177871,
            54177876,
            54178109,
            54178374,
            54178382,
            54178054,
            54178274,
            54179924,
            54177952,
            54177881,
            54177926,
            54178075,
            54177978,
            54177900,
            54179121,
            54179411,
            54179558
        ]
    },
    "name": "B. Lost Numbers",
    "statement": "You may use in C++, in Java, in Python or in Pascal to flush the output.\r\nIf you use some other programming language, consult its documentation.\r\nYou may also refer to the guide on interactive problems:\r\nhttps://codeforces.com/blog/entry/45307.The jury guessed some array a\r\nconsisting of 6 integers. There are 6 special numbers 4, 8, 15, 16, 23,\r\n42 and each of these numbers occurs in a exactly once (so, a is some\r\npermutation of these numbers).You donâ€™t know anything about their order,\r\nbut you are allowed to ask . In each query, you may choose two indices i\r\nand j (1\r\nle i, j\r\nle 6, i and j are not necessarily distinct), and you will get the value\r\nof a_i\r\ncdot a_j in return.Can you guess the array a?.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint pyt(int a, int b)\n{\n\tprintf(\"? %d %d\\n\", a, b);\n\tff();\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nvi wek{4, 8, 15, 16, 23, 42};\n\npii daj(int v)\n{\n\tfor (int i=0; i<6; i++)\n\t\tfor (int j=0; j<i; j++)\n\t\t\tif (wek[i]*wek[j]==v)\n\t\t\t\treturn {wek[i], wek[j]};\n\tassert(0);\n}\n\nint wyn;\n\nint main()\n{\n\tpii a=daj(pyt(1, 2));\n\tpii b=daj(pyt(3, 4));\n\tpii c=daj(pyt(1, 3));\n\tif (c.second==a.first || c.second==a.second)\n\t\tswap(c.first, c.second);\n\tif (a.second==c.first)\n\t\tswap(a.second, a.first);\n\tif (b.second==c.second)\n\t\tswap(b.second, b.first);\n\tint x=pyt(1, 5)/a.first;\n\tint y=1;\n\tfor (int i : wek)\n\t\ty*=i;\n\ty/=a.first;\n\ty/=a.second;\n\ty/=b.first;\n\ty/=b.second;\n\ty/=x;\n\tprintf(\"! %d %d %d %d %d %d\\n\", a.first, a.second, b.first, b.second, x, y);\n\tff();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "divide and conquer",
        "interactive",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Lost Numbers.json",
    "editorial_link": "https://codeforces.com/blog/entry/67058",
    "editorial": "The key fact that allows us to solve this problem is that if we analyze\r\nthe pairwise products of special numbers, we will see that all of them\r\n(considering that we always multiply two different numbers) are unique.\r\nSo, if we, for example, know that , then there are only two\r\npossibilities for the values of and : is uniquely expressed as the\r\nproduct of two distinct special numbers and , and either , , or , . This\r\nallows us to guess three numbers using two queries: we ask and , we\r\nuniquely determine as the only number that is suitable for the both\r\npairs, and then we express and .Of course, there are easier ways to\r\nsolve this problem, considering there are only special numbers. For\r\nexample, you could use four queries (for all ) and try all permutations,\r\nand the model solution uses exactly this approach.\r\n",
    "hint": []
}