{"link": "https://codeforces.com//contest/612/problem/F", "problemId": "43955", "problem_idx": "F", "shortId": "612F", "contest_number": "612", "problem_submissions": {"F": [15015795, 15017252, 15017564, 15018652, 15015599, 15019361, 15017340, 15018654, 15018390], "E": [15010777, 15013400, 15012462, 15011810, 15012679, 15013333, 15013462, 15013944, 15012201, 15013667, 15013024, 15014276, 15013859, 15015715, 15015116, 15015247, 15029017, 15014027], "D": [15009323, 15008963, 15010162, 15010758, 15010353, 15011058, 15011357, 15011634, 15014470, 15010446, 15011643, 15012291, 15011559, 15012012, 15012245, 15011608, 15011635, 15028872, 15012187], "C": [15008569, 15009102, 15009409, 15009193, 15010189, 15009546, 15011006, 15009509, 15009168, 115507184, 115502940, 15010264, 15009734, 15009610, 15009584, 15010138, 15009962, 15009608, 15009629], "B": [15008273, 15008554, 15008493, 15008437, 15009218, 15008849, 15010423, 15011364, 15008522, 15009393, 15008208, 15008534, 15008851, 15008467, 15008897, 15008961, 15010023], "A": [15008217, 15008351, 15008267, 15008284, 15008898, 15008420, 15010012, 15010693, 15008295, 15008665, 15008737, 15008297, 15008383, 15008260, 15008327, 15008392, 15008492]}, "name": "F. Simba on the Circle", "statement": "You are given a circular array with elements. The elements are numbered\r\nfrom some element with values from to in clockwise order. The -th cell\r\ncontains the value . The robot Simba is in cell .Each moment of time the\r\nrobot is in some of the cells (at the begin he is in ). In one turn the\r\nrobot can write out the number written in current cell or move to the\r\nadjacent cell in clockwise or counterclockwise direction. To write out\r\nthe number from the cell Simba doesn\u2019t spend any time, but to move to\r\nadjacent cell Simba spends one unit of time.Simba wants to write the\r\nnumber from each cell one time, so the numbers will be written in a non\r\ndecreasing order. Find the least number of time units to write out all\r\nnumbers.\r\n", "solutions": ["/*\nBearing the mark of a demon from hell the dragon is cast onto the earth\nSeeking revenge on the woman of man Satanus unleashes his wrath\nAngels of death are the allies of hate the jackals destroying the cross\n\n[Chorus:]\nFighting with fire the dragon attacks\nBurning the cross and unleashing the powers of hell\nCursed are the mortals who dare to fight with the beast\n\nDemons of hell bear the mark of the beast the sons of the dragon are born\nSummoned to earth armageddon is here to slaughter the christian hordes\nDestroying the temples Jehova has lost the nazarene will fester in hell\n\n[Chorus]\n\nA wrathful attack upon the christian faith the legions of Satan make war\nReplacing the cross with the mark of the beast the kingdoms of Jesu have fell\nDemons of hell armageddon is here preventing the coming of christ\nrelinquish your god now that satan is king the nazarene will never arise\n\nBearing the mark of a demon from hell the dragon is cast onto earth\nSeeking revenge on the woman of man Satanus unleashes his wrath\nAngels of death are the allies of hate the jackals destroying the cross\n\n[Chorus]\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define prev asdfasdgasdg\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 2200;\n\nusing namespace std;\n\nint n, s;\nint ar[N];\nvector<int> v;\nint need_val, need_cnt;\nvector<pair<int, int> > avec;\nvector<int> entries[N];\nint prev[N], nxt[N];\nmap<int, int> mapp;\nint dp[N][2];\npair<int, int> par[N][2];\nint cnt;\n\nvoid remap()\n{\n\tsort(v.begin(), v.end());\n\tcnt = 0;\n\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (i>0 && v[i] == v[i - 1])\n\t\t\tcontinue;\n\t\tmapp[v[i]] = cnt;\n\t\t++cnt;\n\t}\n}\n\nint get_dist(int a, int b)\n{\n\ta = abs(a - b);\n\tif (a > n - a)\n\t\ta = n - a;\n\treturn a;\n}\n\nvector<pair<int, int> > qmoves,vec1,vec2;\n\nint eval(int a, int b, int dir)\n{\n\tint have = 0;\n\tint moves = 0;\n\tqmoves.clear();\n\tint moves2 = 0;\n\n\twhile (true)\n\t{\n\t\tif (ar[a] == need_val||a==b)\n\t\t{\n\t\t\tif (ar[a]==need_val)\n\t\t\t\t++have;\n\t\t\tqmoves.push_back(make_pair(moves2, dir));\n\t\t\tmoves2 = 0;\n\t\t}\n\t\tif (a == b)\n\t\t\tbreak;\n\t\t++moves;\n\t\t++moves2;\n\t\ta += dir;\n\t\tif (a < 0)\n\t\t\ta += n;\n\t\tif (a >= n)\n\t\t\ta -= n;\n\t}\n\tif (have < need_cnt)\n\t\treturn 1e9;\n\treturn moves;\n}\n\nvoid show(vector<pair<int, int> > v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t\tcout << v[i].first << \" \" << v[i].second << endl;\n\tcout << endl;\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> s;\n\n\t--s;\n\n\tfor (int i = 0; i <n; i++)\n\t{\n\t\tcin >> ar[i];\n\t\tv.push_back(ar[i]);\n\t}\n\n\tremap();\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tar[i] = mapp[ar[i]];\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (entries[ar[i]].size())\n\t\t\tprev[i] = entries[ar[i]].back(),\n\t\t\tnxt[entries[ar[i]].back()] = i,\n\t\t\tprev[entries[ar[i]][0]] = i,\n\t\t\tnxt[i] = entries[ar[i]][0];\n\t\tentries[ar[i]].push_back(i);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (entries[ar[i]].size() == 1)\n\t\t{\n\t\t\tprev[i] = nxt[i] = i;\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << i << \" \" << prev[i] << \" \" << nxt[i] << \" \" << ar[i] << \" \" << cnt << endl;\n\t}\n\t*/\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdp[i][0] = dp[i][1] = 1e9;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] == 0)\n\t\t{\n\t\t\tdp[i][0] = get_dist(s, i);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < entries[i].size(); j++)// 0 moves\n\t\t{\n\t\t\tint ps = entries[i][j];\n\t\t\tint R = nxt[ps];\n\t\t\tint L = prev[ps];\n\t\t\tif (L == ps)\n\t\t\t{\n\t\t\t\tif (dp[ps][1]>dp[ps][0])\n\t\t\t\t{\n\t\t\t\t\tdp[ps][1] = dp[ps][0];\n\t\t\t\t\tpar[ps][1] = make_pair(ps, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dist_L;\n\t\t\tif (L < ps)\n\t\t\t\tdist_L = ps - L;\n\t\t\telse\n\t\t\t\tdist_L = ps + n - L;\n\t\t\tint dist_R;\n\t\t\tif (R>ps)\n\t\t\t\tdist_R = R - ps;\n\t\t\telse\n\t\t\t\tdist_R = R + n - ps;\n\n\t\t\tif (dp[L][1] > dp[ps][0] + (n - dist_L))\n\t\t\t{\n\t\t\t\tdp[L][1] = dp[ps][0] + (n - dist_L);\n\t\t\t\tpar[L][1] = make_pair(ps, 0);\n\t\t\t}\n\t\t\tif (dp[R][1] > dp[ps][0] + (n - dist_R))\n\t\t\t{\n\t\t\t\tdp[R][1] = dp[ps][0] + (n - dist_R);\n\t\t\t\tpar[R][1] = make_pair(ps, 0);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < entries[i].size(); j++)\n\t\t{\n\t\t\tint ps = entries[i][j];\n\t\t\tfor (int q = 0; q < entries[i + 1].size(); q++)\n\t\t\t{\n\t\t\t\tint ps2 = entries[i + 1][q];\n\t\t\t\tint D = get_dist(ps2, ps);\n\t\t\t\tif (dp[ps2][0]>dp[ps][1] + D)\n\t\t\t\t{\n\t\t\t\t\tdp[ps2][0] = dp[ps][1] + D;\n\t\t\t\t\tpar[ps2][0] = make_pair(ps, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n//\tcout << dp[0][0] << endl;\n\n\tint qi, qj;\n\n\tint ans = 1e9;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (ar[i] == cnt - 1)\n\t\t{\n\t\t\tif (dp[i][1] < ans)\n\t\t\t{\n\t\t\t\tans = dp[i][1];\n\t\t\t\tqi = i;\n\t\t\t\tqj = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\t//cout << ans << \" \"<<qi<<\" \"<<qj<<endl;\n\n\twhile (ar[qi] != 0 || qj != 0)\n\t{\n\t\tpair<int, int> p2 = par[qi][qj];\n\t\tif (qj == 0 && p2.second == 1)\n\t\t{\n\t\t\tneed_val = -1;\n\t\t\tneed_cnt = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tneed_val = ar[qi];\n\t\t\tneed_cnt = entries[ar[qi]].size();\n\t\t}\n\t\tint cost1 = eval(p2.first, qi,1);\n\t\tvec1 = qmoves;\n\t\tint cost2 = eval(p2.first, qi, -1);\n\t\tvec2 = qmoves;\n\n\t\treverse(vec1.begin(), vec1.end());\n\t\treverse(vec2.begin(), vec2.end());\n\t\t/*\n\t\tshow(vec1);\n\t\tshow(vec2);\n\t\tcout << cost1 << \"!\" << cost2 << endl;\n\t\t*/\n\t\tif (cost1 < cost2)\n\t\t{\n\t\t\tfor (int q = 0; q < vec1.size(); q++)\n\t\t\t{\n\t\t\t\tavec.push_back(vec1[q]);\n\t\t\t}\n\t//\t\tavec.push_back(make_pair(cost1, 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int q = 0; q < vec2.size(); q++)\n\t\t\t{\n\t\t\t\tavec.push_back(vec2[q]);\n\t\t\t}\n//\t\t\tavec.push_back(make_pair(cost2, -1));\n\t\t}\n\t\tqi = p2.first;\n\t\tqj = p2.second;\n\t}\n\t\n//\tcout << qi << \"%\" << qj << \" \"<<dp[qi][qj]<<endl;\n\n\t// 1 move\n\n\tneed_val = -1;\n\tneed_cnt = 0;\n\tint cost1 = eval(s, qi, 1);\n\tvec1 = qmoves;\n\tint cost2 = eval(s, qi, -1);\n\tvec2 = qmoves;\n\treverse(vec1.begin(), vec1.end());\n\treverse(vec2.begin(), vec2.end());\n\t/*\n\tshow(vec1);\n\tshow(vec2);\n\tcout << \"!\" << cost1 << \" \" << cost2 << endl;\n\t*/\n\tif (cost1 < cost2)\n\t{\n\n\t\tfor (int q = 0; q < vec1.size(); q++)\n\t\t{\n\t\t\tavec.push_back(vec1[q]);\n\t\t}\n//\t\tavec.push_back(make_pair(cost1, 1));\n\t}\n\telse\n\t{\n\n\t\tfor (int q = 0; q < vec2.size(); q++)\n\t\t{\n\t\t\tavec.push_back(vec2[q]);\n\t\t}\n//\t\tavec.push_back(make_pair(cost2, -1));\n\t}\n\treverse(avec.begin(), avec.end());\n\n\tfor (int i = 0; i < avec.size(); i++)\n\t{\n\t\tif (i != 0 && avec[i].first == 0)\n\t\t\tcontinue;\n\t\tif (avec[i].second == 1)\n\t\t\tcout << \"+\";\n\t\telse\n\t\t\tcout << \"-\";\n\t\tcout << avec[i].first;\n\t\tcout << endl;\n\t}\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2600", "interactive": false}