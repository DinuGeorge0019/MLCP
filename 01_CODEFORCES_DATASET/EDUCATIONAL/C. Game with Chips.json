{
    "link": "https://codeforces.com//contest/1327/problem/C",
    "problemId": "571326",
    "problem_idx": "C",
    "shortId": "1327C",
    "contest_number": "1327",
    "problem_submissions": {
        "F": [
            74109494,
            74096912,
            74114522,
            74102690,
            74088644,
            74096945,
            74118574,
            74105095,
            74095826,
            74113555,
            74098825,
            74097831,
            74105606,
            74109593,
            74101097,
            74708534,
            74098586
        ],
        "G": [
            74091723,
            74123968,
            74123925,
            74114197,
            76629927,
            74211867,
            74588194,
            74135043,
            143583395,
            74127397,
            74126425,
            74105678,
            74715507
        ],
        "B": [
            74068544,
            74058114,
            74057729,
            74055609,
            74062072,
            74057059,
            74054855,
            74056002,
            74059330,
            74057094,
            74057214,
            74063726,
            74054652,
            74058809,
            74054826,
            74057170,
            74057831,
            74708239,
            74069029
        ],
        "E": [
            74063712,
            74072104,
            74084153,
            74095848,
            74069496,
            74077697,
            74073149,
            74081984,
            74074950,
            74080019,
            74086353,
            74075499,
            74090079,
            74089858,
            74078241,
            74086260,
            74708411,
            74085708
        ],
        "C": [
            74060977,
            74064317,
            74075501,
            74070865,
            74062695,
            74059969,
            74061257,
            74063448,
            74063934,
            74060895,
            74069645,
            74078565,
            74065457,
            74072914,
            74062504,
            74072575,
            74708279,
            74073328
        ],
        "D": [
            74058988,
            74081137,
            74080575,
            74087567,
            74078030,
            74085278,
            74068392,
            74068497,
            74084912,
            74069773,
            74079760,
            74085394,
            74082419,
            74068982,
            74073656,
            74080794,
            74708339,
            74079780
        ],
        "A": [
            74048309,
            74098107,
            74049366,
            74047546,
            74050945,
            74048503,
            74046989,
            74047125,
            74048033,
            74048151,
            74049565,
            74047828,
            74047513,
            74049730,
            74046774,
            74049977,
            74047800,
            74708180,
            74063309
        ]
    },
    "name": "C. Game with Chips",
    "statement": "Petya has a rectangular Board of size n\r\ntimes m. Initially, k chips are placed on the board, i-th chip is\r\nlocated in the cell at the intersection of sx_i-th row and sy_i-th\r\ncolumn.In one action, Petya can move to the left, right, down or up by 1\r\ncell.If the chip was in the (x, y) cell, then after the operation: left,\r\nits coordinates will be (x, y - 1); right, its coordinates will be (x,\r\ny + 1); down, its coordinates will be (x + 1, y); up, its coordinates\r\nwill be (x - 1, y). If the chip is located by the wall of the board, and\r\nthe action chosen by Petya moves it towards the wall, then the chip\r\nremains in its current position.For each chip, Petya chose the position\r\nwhich it should visit. Note that it’s not necessary for a chip to end up\r\nin this position.Since Petya does not have a lot of free time, he is\r\nready to do no more than 2nm actions.You have to find out what actions\r\nPetya should do so that each chip visits the position that Petya\r\nselected for it at least once. Or determine that it is not possible to\r\ndo this in 2nm actions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,m;\nstring ans;\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m-1) ans.pb('L');\n\trep(i,0,n-1) ans.pb('U');\n\trep(i,0,n) {\n\t\tif (i%2==0) {\n\t\t\trep(j,0,m-1) ans.pb('R');\n\t\t} else {\n\t\t\trep(j,0,m-1) ans.pb('L');\n\t\t}\n\t\tif (i!=n-1) ans.pb('D');\n\t}\n\tprintf(\"%d\\n\",SZ(ans));\n\tprintf(\"%s\\n\",ans.c_str());\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Game with Chips.json",
    "editorial_link": "https://codeforces.com//blog/entry/75147",
    "editorial": "Note that 2nm is a fairly large number of operations. Therefore, we can\r\nfirst collect all the chips in one cell, and then go around the entire\r\nboard.Letâs calculate the required number of operations.First, letâs\r\ncollect all the chips in the (1, 1) cell. To do this, letâs do n-1\r\noperations U so that all the chips are in the first row, then do m-1\r\noperations L. After such operations, wherever the chip is initially\r\nlocated, it will end up in the (1, 1) cell.After that, we need to go\r\naround the entire board. Letâs do it in such a way that the rows with\r\nodd numbers are be bypassed from left to right, and the even ones from\r\nright to left. We also need n-1 operations D to move from one row to the\r\nnext one.In total, we got (n-1) + (m-1) + n * (m-1) + (n-1) = nm + n +\r\nm - 3 operations, which is completely suitable for us.\r\n",
    "hint": []
}