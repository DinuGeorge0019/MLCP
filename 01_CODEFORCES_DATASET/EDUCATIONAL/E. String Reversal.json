{
    "link": "https://codeforces.com//contest/1430/problem/E",
    "problemId": "755157",
    "problem_idx": "E",
    "shortId": "1430E",
    "contest_number": "1430",
    "problem_submissions": {
        "G": [
            95237045,
            95235075,
            95240737,
            97566243,
            95239114,
            95228241,
            95221926,
            95230929,
            95239632,
            95250364,
            95455283,
            95252471,
            95256236,
            95242546,
            95303013,
            98871928
        ],
        "F": [
            95220487,
            95228332,
            95223150,
            97566130,
            95216783,
            95250832,
            95242433,
            95256538,
            95247019,
            95248722,
            95240985,
            95228704,
            95232008,
            95232802,
            95230075,
            95232563,
            95238448,
            95465311,
            95234311,
            95232005
        ],
        "E": [
            95211511,
            95210553,
            95208920,
            97565966,
            95208366,
            95208320,
            95213012,
            95219246,
            95219352,
            95220042,
            95209230,
            95216025,
            95206937,
            95209011,
            95216031,
            95214609,
            95202690,
            95215844,
            95218385
        ],
        "D": [
            95208553,
            95206064,
            95205170,
            97565921,
            95205237,
            95202655,
            95224583,
            95213640,
            95216224,
            95211198,
            95204449,
            95212306,
            95215958,
            95200930,
            95207117,
            95208215,
            95216892,
            95212972,
            95215071
        ],
        "C": [
            95197013,
            95198163,
            95199698,
            97565869,
            95200959,
            95198168,
            95198409,
            95198669,
            95209890,
            95204911,
            95197315,
            95202373,
            95200953,
            95202547,
            95204796,
            95194169,
            95198706,
            95205881,
            95210665
        ],
        "B": [
            95195119,
            95195489,
            95196116,
            97565818,
            95196356,
            95194999,
            95195326,
            95195742,
            95196929,
            95195601,
            95195544,
            95196763,
            95197327,
            95194053,
            95194687,
            95199867,
            95195154,
            95196136,
            95196683
        ],
        "A": [
            95193928,
            95194100,
            95194842,
            97565779,
            95194326,
            95193977,
            95194039,
            95194134,
            95194416,
            95194244,
            95194071,
            95194430,
            95194685,
            95193941,
            95193947,
            95197083,
            95194045,
            95194254,
            95194714
        ]
    },
    "name": "E. String Reversal",
    "statement": "You are given a string s. You have to reverse it that is, the first\r\nletter should become equal to the last letter before the reversal, the\r\nsecond letter should become equal to the second-to-last letter before\r\nthe reversal and so on. For example, if your goal is to reverse the\r\nstring \"\", you should get the string \"\". To accomplish your goal, you\r\ncan swap the . Your task is to calculate the minimum number of swaps you\r\nhave to perform to reverse the given string.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=200005;\nchar s[N],ns[N];\nint n,t[N],mat[N];\nvector<int> v1[N];\nvoid change(int x,int v){\n\tfor (;x<=n;x+=x&(-x)) t[x]+=v;\n}\nint ask(int x){\n\tint s=0;\n\tfor (;x;x-=x&(-x)) s+=t[x];\n\treturn s;\n}\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\t//n=strlen(s+1);\n\tmemcpy(ns,s,sizeof(ns));\n\treverse(ns+1,ns+n+1);\n\tFor(i,1,n) v1[s[i]].PB(i);\n\tRep(i,n,1){\n\t\tmat[i]=v1[ns[i]].back();\n\t\tv1[ns[i]].pop_back();\n\t}\n\tll ans=0;\n\tFor(i,1,n){\n\t\tchange(mat[i],1);\n\t\tans+=i-ask(mat[i]);\n\t}\n\tcout<<ans<<endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. String Reversal.json",
    "editorial_link": "https://codeforces.com//blog/entry/83614",
    "editorial": "First of all, letâs find the resulting position for each character of\r\nthe string. Itâs easy to see that we donât need to swap equal adjacent\r\ncharacters (it changes nothing), so the first character in the original\r\nstring is the first character in the resulting string, the second\r\ncharacter in the original string is the second character in the\r\nresulting string, and so on.Now, letâs build a permutation of elements,\r\nwhere is the resulting position of the element that was on position in\r\nthe original string. For example, for the string this permutation will\r\nbe . In one operation, we may swap two elements in this permutation, and\r\nour goal is to sort it (since each character of the string has its own\r\nrequired position, and when for every the condition holds, each\r\ncharacter is on the position it should be). The required number of swaps\r\nof adjacent elements to sort a permutation is exactly the number of\r\ninversions in it (since each swap changes the number of inversions by ),\r\nand this number can be calculated using many different techniques, for\r\nexample, mergesort tree or Fenwick tree.\r\n",
    "hint": []
}