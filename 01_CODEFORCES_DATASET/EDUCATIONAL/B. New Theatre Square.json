{
    "link": "https://codeforces.com//contest/1359/problem/B",
    "problemId": "634673",
    "problem_idx": "B",
    "shortId": "1359B",
    "contest_number": "1359",
    "problem_submissions": {
        "C": [
            81997007,
            81727058,
            81734733,
            81730835,
            81740916,
            81747939,
            81729612,
            81737303,
            81737447,
            81741656,
            81752868,
            81776094,
            81761832,
            81724495,
            81746226,
            81738450,
            81730327,
            81729715,
            81731437,
            81744227,
            81733481
        ],
        "F": [
            81812419,
            81764295,
            81854273,
            81854109,
            81853958,
            81778328,
            81787414,
            81786228,
            81796920,
            81794151,
            81788283,
            81787937,
            81784721,
            81790808,
            81789636,
            81804129,
            81796060,
            81778353,
            81798275,
            105524321,
            105524094,
            105524008,
            81799361,
            81796754,
            81795964,
            81808154,
            81868467,
            205746151,
            205745147,
            140844519
        ],
        "D": [
            81739116,
            81744503,
            81735878,
            81749048,
            81740279,
            81749196,
            81744086,
            81743897,
            81754255,
            81762454,
            81758312,
            81744429,
            81728105,
            81726622,
            81721526,
            81737234,
            81738327,
            81737186,
            81731810,
            81739976
        ],
        "E": [
            81734306,
            81750721,
            81743059,
            81759597,
            81729601,
            81756849,
            81752573,
            81749938,
            81761248,
            81768636,
            81784969,
            81729272,
            81731972,
            81733967,
            81747782,
            81743404,
            81743235,
            81742828,
            81736556,
            81742484
        ],
        "B": [
            81716705,
            81725433,
            81718596,
            81720832,
            81719267,
            81716337,
            81719010,
            81727250,
            81721619,
            81746513,
            81720940,
            81767813,
            81716284,
            81717634,
            81717996,
            81719942,
            81719713,
            81719807,
            81718363,
            81718512
        ],
        "A": [
            81715063,
            81720474,
            81715122,
            81715707,
            81715255,
            81715098,
            81715727,
            81721547,
            81715498,
            81744191,
            81715755,
            81770964,
            81715068,
            81715226,
            81715093,
            81715532,
            81715578,
            81715424,
            81715396,
            81715264
        ]
    },
    "name": "B. New Theatre Square",
    "statement": "You might have remembered Theatre square from the problem 1A. Now it’s\r\nfinally getting repaved.The square still has a rectangular shape of n\r\ntimes m meters. However, the picture is about to get more complicated\r\nnow. Let a_{i,j} be the j-th square in the i-th row of the pavement.You\r\nare given the picture of the squares: if a_{i,j} = \"\", then the j-th\r\nsquare in the i-th row should be ; if a_{i,j} = \"\", then the j-th square\r\nin the i-th row should be . The black squares are paved already. You\r\nhave to pave the white squares. There are two options for pavement\r\ntiles: 1\r\ntimes 1 tiles each tile costs x burles and covers exactly 1 square; 1\r\ntimes 2 tiles each tile costs y burles and covers exactly 2 adjacent\r\nsquares of the . What is the smallest total price of the tiles needed to\r\ncover all the white squares?\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 1005;\nchar c[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n, m;\n        cin >> n >> m;\n        int x, y;\n        cin >> x >> y;\n        y = min(y, 2 * x);\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                cin >> c[i][j];\n                if (c[i][j] == '.') {\n                    if (j != 1 && c[i][j - 1] == '.' && c[i][j] == '.') {\n                        c[i][j] = '*';\n                        c[i][j - 1] = '*';\n                        ans += y;\n                    }\n                }\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (c[i][j] == '.') ans += x;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. New Theatre Square.json",
    "editorial_link": "https://codeforces.com//blog/entry/78116",
    "editorial": "Notice that rows can be solved completely separately of each other. Each\r\ntile takes either one or two squares but itâs always in the same row.So\r\nletâs take a look at a single row. There are sequences of dot characters\r\nseparated by some asterisks. Once again each of these sequences can be\r\nsolved independently of the others.Thus, we have these empty strips of\r\nempty squares which, when solved, can be summed up into the whole\r\nanswer.There are two cases, depending on if a is cheaper than two tiles.\r\nIf it is then we want to use of many tiles as possible. So given , we\r\ncan place tiles and cover the rest squares with tiles.If it isnât\r\ncheaper then we want to cover everything with tiles and never use ones.\r\nSo all should be .The easier way to implement this might be the\r\nfollowing. Letâs update the price of the tile with the minimum of and .\r\nThis way the first algorithm will produce exactly the same result of the\r\nsecond one in the case when a tile isnât cheaper than two ones.Overall\r\ncomplexity: per testcase.\r\n",
    "hint": []
}