{
    "link": "https://codeforces.com//contest/1821/problem/F",
    "problemId": "1887932",
    "problem_idx": "F",
    "shortId": "1821F",
    "contest_number": "1821",
    "problem_submissions": {
        "F": [
            202874134,
            202859904,
            202858229,
            202861559,
            202872887,
            202859974,
            202856919,
            202868327,
            202882475,
            202876779,
            202870359,
            202879197,
            202869342,
            202883580,
            202880852,
            203770664,
            202876913,
            202876748,
            202875057,
            202875004,
            202878771,
            202874220,
            202869665
        ],
        "E": [
            202851078,
            202851207,
            202852651,
            202845029,
            202854281,
            202869953,
            202852432,
            202850529,
            202858695,
            202849198,
            202862275,
            202850037,
            202856111,
            202863740,
            202868777,
            202865633,
            202858626,
            202863992,
            202876455
        ],
        "D": [
            202839910,
            202837788,
            202840967,
            202837261,
            202846749,
            202839594,
            202843601,
            202842780,
            202848113,
            202843851,
            202849914,
            202836012,
            202848152,
            202848821,
            202851217,
            202856400,
            202848668,
            202853904,
            202847149
        ],
        "C": [
            202829555,
            202830560,
            202832642,
            202830912,
            202836849,
            202832172,
            202834957,
            202827979,
            202831432,
            202832058,
            202834744,
            202833738,
            202834719,
            202831454,
            202838345,
            202836024,
            202839448,
            202842531,
            202836507
        ],
        "B": [
            202826167,
            202826238,
            202826386,
            202826297,
            202828596,
            202827059,
            202829521,
            202825674,
            202826732,
            202829400,
            202829530,
            202825769,
            202828359,
            202826421,
            202828754,
            202830182,
            202834397,
            202837813,
            202832744
        ],
        "A": [
            202824330,
            202824182,
            202824201,
            202824170,
            202825451,
            202824300,
            202825020,
            202824095,
            202824581,
            202824237,
            202824979,
            202824089,
            202824602,
            202824298,
            202824347,
            202824916,
            202826157,
            202824991,
            202825871
        ]
    },
    "name": "F. Timber",
    "statement": "There is a beautiful alley with trees in front of a shopping mall.\r\nUnfortunately, it has to go to make space for the parking lot.The trees\r\non the alley all grow in a single line. There are n spots for trees,\r\nindex 0 is the shopping mall, index n+1 is the road and indices from 1\r\nto n are the spots for trees. Some of them are taken there grow trees of\r\nthe same height k. No more than one tree grows in each spot.When you\r\nchop down a tree in the spot x, you can make it fall either left or\r\nright. If it falls to the left, it takes up spots from x-k to x,\r\ninclusive. If it falls to the right, it takes up spots from x to x+k,\r\ninclusive.Let m trees on the alley grow in some spots x_1, x_2,\r\ndots, x_m. Let an alley be called if all m trees can be chopped down in\r\nsuch a way that: no tree falls on the shopping mall or the road; each\r\nspot is taken up by no more than one fallen tree. Calculate the number\r\nof different alleys with m trees of height k. Two alleys are considered\r\ndifferent if there is a spot y such that a tree grows in y on the first\r\nalley and doesn’t grow in y on the second alley.Output the number modulo\r\n998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=600005;\nconst ll INF=1LL<<60;\n\n// FPS 全部載せ\n\n// from: https://gist.github.com/yosupo06/ddd51afb727600fd95d9d8ad6c3c80c9\n// (based on AtCoder STL)\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\nusing mint=atcoder::modint998244353;\n\nmint inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=-inv[mod%i]*(mod/i);\n        fac[i]=fac[i-1]*i;\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\n\nmint comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[b]*finv[a-b];\n}\n\nmint perm(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*finv[a-b];\n}\n\nvector<mint> bibun(vector<mint> F,int deg){\n    vector<mint> res(deg+1);\n    for(int i=1;i<si(F)&&i-1<=deg;i++){\n        res[i-1]=F[i]*i;\n    }\n    \n    return res;\n}\n\nvector<mint> sekibun(vector<mint> F,int deg){\n    vector<mint> res(deg+1);\n    for(int i=0;i<min(si(F),deg);i++){\n        res[i+1]=F[i]*inv[i+1];\n    }\n    \n    return res;\n}\n\nvector<mint> invv(vector<mint> F,int deg){\n    assert(F[0]!=0);\n    \n    mint kake=mint(F[0]).inv();\n    for(int i=0;i<si(F);i++){\n        F[i]*=kake;\n    }\n    vector<mint> G(1,1);\n    int len=1;\n    while(len<=deg){\n        vector<mint> f=F;f.resize(len*2);\n        vector<mint> g=G;g.resize(len*2);\n        \n        atcoder::internal::butterfly(f);\n        atcoder::internal::butterfly(g);\n        \n        for(int i=0;i<len*2;i++) f[i]*=g[i];\n        \n        atcoder::internal::butterfly_inv(f);\n        vector<mint> nf(len*2);\n        for(int i=len;i<2*len;i++) nf[i-len]=f[i];\n        \n        f=nf;\n        atcoder::internal::butterfly(f);\n        \n        for(int i=0;i<len*2;i++) f[i]*=g[i];\n        \n        atcoder::internal::butterfly_inv(f);\n        \n        mint iz=mint(len*2).inv();\n        mint coe=-iz*iz;\n        \n        G.resize(len*2);\n        \n        for(int i=0;i<len;i++) G[len+i]=f[i]*coe;\n        \n        len*=2;\n    }\n    \n    G.resize(deg+1);\n    for(int i=0;i<=deg;i++) G[i]*=kake;\n    \n    return G;\n}//1/Tのdeg次以下を返す\n\nvector<mint> logg(vector<mint> F,int deg){\n    assert(F[0]==1);\n    \n    vector<mint> FF=bibun(F,deg);\n    vector<mint> waru=invv(F,deg);\n    \n    vector<mint> G=atcoder::convolution(FF,waru);\n    \n    G=sekibun(G,deg);\n    \n    return G;\n}\n// F0 = 1\n\nvector<mint> expp(vector<mint> F,int deg){\n    if(si(F)){\n        assert(F[0]==0);\n    }\n    \n    vector<mint> G(1,1);\n    int len=1;\n    while(len<=deg){\n        vector<mint> nex=logg(G,len*2-1);\n        for(int i=0;i<si(nex);i++) nex[i]*=(-1);\n        for(int i=0;i<si(nex);i++){\n            if(i<si(F)) nex[i]+=F[i];\n        }\n        nex[0]++;\n        nex=atcoder::convolution(nex,G);\n        nex.resize(len*2);\n        \n        len*=2;\n        G=nex;\n    }\n    \n    G.resize(deg+1);\n    \n    return G;\n}\n// F0 = 0\n\nvector<mint> poww(vector<mint> F,int deg,ll K){\n    if(K==0){\n        vector<mint> res(deg+1);\n        res[0]=1;\n        return res;\n    }\n    if(si(F)==0){\n        vector<mint> res(deg+1);\n        return res;\n    }\n    \n    ll geta=-1;\n    mint kake=0;\n    for(int i=0;i<si(F);i++){\n        if(F[i]!=0){\n            geta=i;\n            kake=F[i].inv();\n            break;\n        }\n    }\n    \n    if(geta==-1){\n        vector<mint> res(deg+1);\n        return res;\n    }\n    \n    if(geta>1000000000LL/K){\n        vector<mint> res(deg+1);\n        return res;\n    }\n    if(geta*K>deg){\n        vector<mint> res(deg+1);\n        return res;\n    }\n    \n    vector<mint> nF(si(F)-geta);\n    for(int i=geta;i<si(F);i++){\n        nF[i-geta]=(F[i]*kake);\n    }\n    \n    F=nF;\n    \n    vector<mint> FF=logg(nF,deg-geta*K);\n    for(int i=0;i<si(FF);i++) FF[i]*=K;\n    \n    vector<mint> G=expp(FF,deg-geta*K);\n    \n    kake=kake.inv();\n    kake=kake.pow(K);\n    \n    vector<mint> res(deg+1);\n    for(int i=0;i<si(G);i++){\n        res[geta*K+i]=G[i]*kake;\n    }\n    \n    return res;\n}\n\n// make() を呼ばないとsekibun呼ぶやつで一部バグる\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    ll N,M,K;cin>>N>>M>>K;\n    if((K+1)*M>N){\n        cout<<0<<\"\\n\";\n        return 0;\n    }\n    \n    vector<mint> F(N+1);\n    for(int i=0;i<=N;i++){\n        if(K+1<=i&&i<=K+K) F[i]=2;\n        else if(K+K+1<=i) F[i]=1;\n    }\n    \n    auto res=poww(F,N,M);\n    \n    mint ans=0;\n    \n    for(int i=1;i<=N;i++) ans+=res[i];\n    \n    cout<<ans.val()<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Timber.json",
    "editorial_link": "https://codeforces.com//blog/entry/115296",
    "editorial": "People say that this problem can be bashed with generating functions.\r\nSadly, I know nothing about them, so Iâll explain the more adhoc\r\nsolution I managed to come up.Letâs investigate the general form of some\r\nplacement of trees. Imagine we fixed some position for them. How to\r\ncheck if itâs possible to cut them all down? Well, itâs a simple greedy\r\nproblem. Process trees left to right. If a tree can fall down to the\r\nleft, make it fall to the left. Otherwise, if it can fall down to the\r\nright, make it fall to the right. Otherwise, no answer.Try a harder\r\nproblem. Consider the spots the fallen trees take. How many\r\nconstructions can these spots be induced by after the greedy algorithm\r\nis performed? First, these taken spots are actually segments of length .\r\nEach tree can fall either from the left or the right side of the\r\nsegment. To determine the answer, one has to look at the number of free\r\nspots to the left of each fallen tree. If thereâre at least free spots,\r\nthen the tree can only fall from the left side of that segment.\r\nOtherwise, it can fall both ways. Thus, for trees that have less than\r\nfree spots to the left of them, the answer is .We canât really iterate\r\nover the constructions, so letâs try yet another related problem. Would\r\nbe cool if we could fix the exact number of trees that have more than\r\nfree cells to the left of them. I donât really know how to do that. But\r\nI know how to fix at least the amount. Let that be at least trees. For\r\ntrees, make their segments of length for the tree itself and extra cells\r\nto the left of it. For the rest trees, make their segments of length .\r\nThen we have to place them on the given spots. The path is as follows.\r\nRearrange the long and the short segments among each other . Then use\r\nstars and bars to choose the amount of space between the segments .\r\nFinally, multiply by to fix the side for the short segments.Initially,\r\nwe thought that we could just use PIE to calculate the exact answer from\r\nthat . And the results of this formula coincided with the naive\r\nsolution, so we thought that everything should be fine. But\r\nunfortunately, even though the formula is right, using PIE in the\r\ndescribed way is . Let us show you the correct way.Let be the number of\r\nways to choose the segments for the trees in such a way that fixed\r\nsegments are \"long\" (i. e. at least of length ). To calculate , we use\r\nthe familiar stars and bars concept: (we already had this formula\r\nearlier).Now, let be the number of ways to choose the segments for the\r\ntrees in such a way that fixed segments are \"long\", and all other\r\nsegments are \"short\". The formula for is a straightforward application\r\nof PIE: , where we iterate on the number of segments that should be\r\nshort, but are definitely long.The answer to the problem can be\r\ncalculated as we choose which segments are \"long\", and all others should\r\nbe \"short\". Expanding gives us the following formula:which, after\r\nexpanding binomial coefficients into factorials and getting rid of ,\r\nbecomesWe introduce the substitution variable , and the formula\r\nbecomesBy multiplying both the numerator and the denominator by , we\r\nthen getAnd is just . Thus, the answer is equal to .Overall complexity:\r\n.\r\n",
    "hint": []
}