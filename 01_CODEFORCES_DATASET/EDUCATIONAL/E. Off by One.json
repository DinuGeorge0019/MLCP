{"link": "https://codeforces.com//contest/1519/problem/E", "problemId": "971590", "problem_idx": "E", "shortId": "1519E", "contest_number": "1519", "problem_submissions": {"C": [114616470, 114551329, 114551180, 114564495, 114550309, 114552694, 114547702, 114548020, 114553618, 114563241, 114559641, 114555665, 114557042, 114556787, 114554939, 114556558, 114555376, 114549327, 114552625, 114552238, 114554684, 114559315], "F": [114613463, 114611288, 114604337, 114598897, 114611467, 114680142, 114636104, 114635840], "E": [114607966, 114580590, 114575288, 114583294, 114570654, 114566689, 114580490, 114581344, 114581275, 114584747, 114587745, 114586133, 114587347, 114590609, 114592573, 114589054, 114601871, 114596259, 114594317, 114625207, 114625166, 114600206, 114595857], "D": [114555495, 114555902, 114567847, 114556972, 114556567, 114552424, 114552771, 114561234, 114544188, 114558776, 114560835, 114564971, 114561515, 114561300, 114565333, 114554107, 114558569, 114558286, 114563876, 114568526], "B": [114542697, 114545137, 114558022, 114545565, 114550455, 114542163, 114542842, 114545295, 114550992, 114551627, 114546744, 114549467, 114548090, 114544402, 114547969, 114543205, 114546111, 114545907, 114546890, 114546969], "A": [114541604, 114541862, 114551019, 114541996, 114541593, 114541608, 114541607, 114541640, 114546683, 114543589, 114543013, 114543817, 114542361, 114541678, 114541836, 114541598, 114541959, 114541646, 114541768, 114542287]}, "name": "E. Off by One", "statement": "There are n points on an infinite plane. The i-th point has coordinates\r\n(x_i, y_i) such that x_i > 0 and y_i > 0. The coordinates are not\r\nnecessarily integer.In one move you perform the following operations:\r\nchoose two points a and b (a\r\nneq b); move point a from (x_a, y_a) to either (x_a + 1, y_a) or (x_a,\r\ny_a + 1); move point b from (x_b, y_b) to either (x_b + 1, y_b) or (x_b,\r\ny_b + 1); remove points a and b. Otherwise, the move can\u2019t be performed\r\nand the points stay at their original coordinates (x_a, y_a) and (x_b,\r\ny_b), respectively.The numeration of points after some points are\r\nremoved. Once the points are removed, they can\u2019t be chosen in any later\r\nmoves. Note that you have to move both points during the move, you can\u2019t\r\nleave them at their original coordinates.What is the maximum number of\r\nmoves you can perform? What are these moves?If there are multiple\r\nanswers, you can print any of them.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\narray<int64_t, 2> normalize(array<int64_t, 2> slope) {\n    int64_t g = __gcd(slope[0], slope[1]);\n    return {slope[0] / g, slope[1] / g};\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N;\n    cin >> N;\n    vector<int64_t> A(N), B(N), C(N), D(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> A[i] >> B[i] >> C[i] >> D[i];\n\n    vector<array<array<int64_t, 2>, 2>> slopes(N);\n    vector<array<int64_t, 2>> sorted;\n\n    for (int i = 0; i < N; i++) {\n        slopes[i][0] = normalize({B[i] * C[i], (A[i] + B[i]) * D[i]});\n        slopes[i][1] = normalize({B[i] * (C[i] + D[i]), A[i] * D[i]});\n        sorted.push_back(slopes[i][0]);\n        sorted.push_back(slopes[i][1]);\n    }\n\n    sort(sorted.begin(), sorted.end());\n    sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n    int S = int(sorted.size());\n    vector<vector<int>> adj(N + S);\n\n    auto get_index = [&](array<int64_t, 2> slope) -> int {\n        return int(lower_bound(sorted.begin(), sorted.end(), slope) - sorted.begin());\n    };\n\n    auto add_edge = [&](int a, int b) -> void {\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    };\n\n    for (int i = 0; i < N; i++) {\n        add_edge(i, N + get_index(slopes[i][0]));\n        add_edge(i, N + get_index(slopes[i][1]));\n    }\n\n    vector<array<int, 2>> matches;\n    vector<bool> visited(N + S, false);\n\n    auto solve = y_combinator([&](auto self, int node) -> int {\n        if (visited[node])\n            return -1;\n\n        visited[node] = true;\n        vector<int> choices;\n\n        for (int neigh : adj[node]) {\n            int child = self(neigh);\n\n            if (child >= 0)\n                choices.push_back(child);\n        }\n\n        while (choices.size() >= 2) {\n            matches.push_back({choices[choices.size() - 2], choices.back()});\n            choices.pop_back();\n            choices.pop_back();\n        }\n\n        int current = node < N ? node : -1;\n\n        if (!choices.empty() && current >= 0) {\n            matches.push_back({choices[0], current});\n            choices.pop_back();\n            current = -1;\n        }\n\n        if (node >= N && !choices.empty())\n            current = choices[0];\n\n        return current;\n    });\n\n    for (int i = N; i < N + S; i++)\n        solve(i);\n\n    cout << matches.size() << '\\n';\n\n    for (array<int, 2> match : matches)\n        cout << match[0] + 1 << ' ' << match[1] + 1 << '\\n';\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "geometry", "graphs", "sortings", "trees"], "dificulty": "2700", "interactive": false}