{
    "link": "https://codeforces.com//contest/1519/problem/E",
    "problemId": "971590",
    "problem_idx": "E",
    "shortId": "1519E",
    "contest_number": "1519",
    "problem_submissions": {
        "C": [
            114616470,
            114551329,
            114551180,
            114564495,
            114550309,
            114552694,
            114547702,
            114548020,
            114553618,
            114563241,
            114559641,
            114555665,
            114557042,
            114556787,
            114554939,
            114556558,
            114555376,
            114549327,
            114552625,
            114552238,
            114554684,
            114559315
        ],
        "F": [
            114613463,
            114611288,
            114604337,
            114598897,
            114611467,
            114680142,
            114636104,
            114635840
        ],
        "E": [
            114607966,
            114580590,
            114575288,
            114583294,
            114570654,
            114566689,
            114580490,
            114581344,
            114581275,
            114584747,
            114587745,
            114586133,
            114587347,
            114590609,
            114592573,
            114589054,
            114601871,
            114596259,
            114594317,
            114625207,
            114625166,
            114600206,
            114595857
        ],
        "D": [
            114555495,
            114555902,
            114567847,
            114556972,
            114556567,
            114552424,
            114552771,
            114561234,
            114544188,
            114558776,
            114560835,
            114564971,
            114561515,
            114561300,
            114565333,
            114554107,
            114558569,
            114558286,
            114563876,
            114568526
        ],
        "B": [
            114542697,
            114545137,
            114558022,
            114545565,
            114550455,
            114542163,
            114542842,
            114545295,
            114550992,
            114551627,
            114546744,
            114549467,
            114548090,
            114544402,
            114547969,
            114543205,
            114546111,
            114545907,
            114546890,
            114546969
        ],
        "A": [
            114541604,
            114541862,
            114551019,
            114541996,
            114541593,
            114541608,
            114541607,
            114541640,
            114546683,
            114543589,
            114543013,
            114543817,
            114542361,
            114541678,
            114541836,
            114541598,
            114541959,
            114541646,
            114541768,
            114542287
        ]
    },
    "name": "E. Off by One",
    "statement": "There are n points on an infinite plane. The i-th point has coordinates\r\n(x_i, y_i) such that x_i > 0 and y_i > 0. The coordinates are not\r\nnecessarily integer.In one move you perform the following operations:\r\nchoose two points a and b (a\r\nneq b); move point a from (x_a, y_a) to either (x_a + 1, y_a) or (x_a,\r\ny_a + 1); move point b from (x_b, y_b) to either (x_b + 1, y_b) or (x_b,\r\ny_b + 1); remove points a and b. Otherwise, the move can’t be performed\r\nand the points stay at their original coordinates (x_a, y_a) and (x_b,\r\ny_b), respectively.The numeration of points after some points are\r\nremoved. Once the points are removed, they can’t be chosen in any later\r\nmoves. Note that you have to move both points during the move, you can’t\r\nleave them at their original coordinates.What is the maximum number of\r\nmoves you can perform? What are these moves?If there are multiple\r\nanswers, you can print any of them.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\narray<int64_t, 2> normalize(array<int64_t, 2> slope) {\n    int64_t g = __gcd(slope[0], slope[1]);\n    return {slope[0] / g, slope[1] / g};\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N;\n    cin >> N;\n    vector<int64_t> A(N), B(N), C(N), D(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> A[i] >> B[i] >> C[i] >> D[i];\n\n    vector<array<array<int64_t, 2>, 2>> slopes(N);\n    vector<array<int64_t, 2>> sorted;\n\n    for (int i = 0; i < N; i++) {\n        slopes[i][0] = normalize({B[i] * C[i], (A[i] + B[i]) * D[i]});\n        slopes[i][1] = normalize({B[i] * (C[i] + D[i]), A[i] * D[i]});\n        sorted.push_back(slopes[i][0]);\n        sorted.push_back(slopes[i][1]);\n    }\n\n    sort(sorted.begin(), sorted.end());\n    sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n    int S = int(sorted.size());\n    vector<vector<int>> adj(N + S);\n\n    auto get_index = [&](array<int64_t, 2> slope) -> int {\n        return int(lower_bound(sorted.begin(), sorted.end(), slope) - sorted.begin());\n    };\n\n    auto add_edge = [&](int a, int b) -> void {\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    };\n\n    for (int i = 0; i < N; i++) {\n        add_edge(i, N + get_index(slopes[i][0]));\n        add_edge(i, N + get_index(slopes[i][1]));\n    }\n\n    vector<array<int, 2>> matches;\n    vector<bool> visited(N + S, false);\n\n    auto solve = y_combinator([&](auto self, int node) -> int {\n        if (visited[node])\n            return -1;\n\n        visited[node] = true;\n        vector<int> choices;\n\n        for (int neigh : adj[node]) {\n            int child = self(neigh);\n\n            if (child >= 0)\n                choices.push_back(child);\n        }\n\n        while (choices.size() >= 2) {\n            matches.push_back({choices[choices.size() - 2], choices.back()});\n            choices.pop_back();\n            choices.pop_back();\n        }\n\n        int current = node < N ? node : -1;\n\n        if (!choices.empty() && current >= 0) {\n            matches.push_back({choices[0], current});\n            choices.pop_back();\n            current = -1;\n        }\n\n        if (node >= N && !choices.empty())\n            current = choices[0];\n\n        return current;\n    });\n\n    for (int i = N; i < N + S; i++)\n        solve(i);\n\n    cout << matches.size() << '\\n';\n\n    for (array<int, 2> match : matches)\n        cout << match[0] + 1 << ' ' << match[1] + 1 << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "geometry",
        "graphs",
        "sortings",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Off by One.json",
    "editorial_link": "https://codeforces.com//blog/entry/90212",
    "editorial": "At first the problem sounds like some sort of matching. However, it\r\nseems like you first want to match each point with either of its moves\r\nand then some pairs of points to each other. That doesnât sound viable\r\nbut since the matchings are often connected with graphs, the graph idea\r\nmight come handy.Letâs first consider a pair of matched points. What\r\ndoes it actually mean that there exists a line through their new\r\ncoordinates and ? Itâs the same as: the angles of a line through the new\r\ncoordinates of and and a line through the new coordinates of and are the\r\nsame. Angles are the same means that their tangents are the same (and\r\nvice versa since we only consider the first quadrant of the plane). So\r\nwe can conclude that or of the first point should be equal to any of\r\nthese of the second point.Now consider the following graph. Various\r\nvalues of tangents of the lines are the nodes. Each point produces an\r\nedge between their and . What are the matched pairs of points in this\r\ngraph? Itâs such a pair of edges that they share at least one\r\nendpoint.Building a graph is the slowest part of the solution since you\r\nhave to use some data structure (or at least a sort and a binary\r\nsearch). is possible with some sort of hashmap but should be perfectly\r\nfine as well.So we reduced the problem to a more well-known one: given\r\nan arbitrary undirected graph, find the maximum number of pairs of edges\r\nsuch that each pair shares at least one endpoint and each edge is\r\nincluded in no more than one pair.The upper bound on the answer is the\r\nfollowing. Let be the number of edges in the -th connected component.\r\nBest case we can make pairs from it. Letâs come up with an algorithm to\r\nachieve this bound.Consider a dfs tree of a component. Itâs known that a\r\ndfs tree of an undirected graph contains no cross edges. So if we direct\r\nall the edges of a dfs tree downwards (convert all back edges to forward\r\nedges), each edge will connect some vertex to its descendant. Imagine we\r\ncame up with a dfs such that matches all the edges that have their upper\r\nnode in the subtree of to each other (except one edge in case there is\r\nan odd number of them). will solve the task exactly then.How should that\r\ndfs work exactly?What if there were no forward edges at all? That case\r\nis easy since all edges are tree edges. Weâll try to maintain an\r\ninvariant that the only unmatched edge is an edge that has as one of its\r\nendpoints. If is a leaf, then thereâs nothing to match. Otherwise, we go\r\ninto some child . If it canât match all its edges, then match its\r\nremaining edge to an edge . If it can then remember that we have an edge\r\nunmatched so far. Go into another child . Same, match our edge with its\r\nedge if it has one unmatched. However, if turned out to get unmatched\r\nand turned out to be unmatched, then you can match them to each other.\r\nThis way you will be left with at most one unmatched edge after you\r\nprocess all the children, and that edge has its endpoint at .Add the\r\nforward edges back. Did anything change? Look at the forward edge that\r\nhas its upper vertex the lowest. We can see that it points to a vertex\r\nthat has its subtree fully matches. So why donât we treat this forward\r\nedge the same as an edge to a leaf? Forget that has some subtree of its\r\nown and just believe that you canât match the edge so far. Proceed the\r\nsame as the easy case.Since we mark exactly which edges you pair up with\r\nwhich, itâs trivial to retrieve the answer.Overall complexity: .\r\n",
    "hint": []
}