{"link": "https://codeforces.com//contest/1795/problem/F", "problemId": "1785702", "problem_idx": "F", "shortId": "1795F", "contest_number": "1795", "problem_submissions": {"G": [193868249, 193922126, 193880640, 193880242, 193879883, 193877939, 193892319, 193909416, 193909281, 193909039, 193908855, 193907982, 193907256, 193907116, 193905885, 193905428, 193895936, 193894919, 193900585, 193900447, 193900331, 193900021, 193895212, 193901119, 193897399, 194065980, 193895350, 193897364, 193910352, 193909678, 193877594, 193901310, 193900708, 193909774, 193909664, 193908826, 193902609, 193895098, 193898582, 193887169, 193989778, 193903191, 193906575, 193901677], "E": [193858484, 193864061, 193860485, 193866472, 193870118, 193881494, 193869535, 193877440, 194065966, 193867450, 193873381, 193864290, 193872060, 193880762, 193876051, 193901176, 193882421, 193899122, 193881276, 193885055], "F": [193849592, 193871412, 193870619, 193880295, 193883585, 193866256, 193887756, 193901053, 193899102, 193887184, 194065972, 193879792, 193887970, 193889897, 193889600, 193879424, 193886027, 193888430, 193890811, 193880065, 193894847, 193891841], "D": [193842483, 193853701, 193849666, 193849500, 193854093, 193850355, 193858853, 193853243, 194065953, 193855818, 193855956, 193852941, 193856134, 193845600, 193859844, 193851729, 193849114, 193866588, 193860778, 193855517], "C": [193840570, 193847474, 193846113, 193844888, 193847932, 193844693, 193851549, 193846559, 194065943, 193849210, 193849704, 193847867, 193849903, 193858596, 193851945, 193847688, 193845368, 193860332, 193855373, 193849162], "B": [193839119, 193839637, 193839480, 193839407, 193839832, 193839202, 193842405, 193840503, 194065925, 193843321, 193841514, 193841857, 193840539, 193848293, 193839850, 193839356, 193839529, 193847088, 193842717, 193840388], "A": [193838910, 193838985, 193838946, 193838908, 193839007, 193838901, 193840204, 193839189, 194065914, 193839222, 193839386, 193882631, 193839087, 193843666, 193841139, 193839086, 193838960, 193838928, 193845036, 193840156, 193838911]}, "name": "F. Blocking Chips", "statement": "You are given a tree, consisting of n vertices. There are k chips,\r\nplaced in vertices a_1, a_2,\r\ndots, a_k. All a_i are distinct. Vertices a_1, a_2,\r\ndots, a_k are colored black initially. The remaining vertices are\r\nwhite.You are going to play a game where you perform some moves\r\n(possibly, zero). On the i-th move (1-indexed) you are going to move the\r\n((i - 1)\r\nbmod k + 1)-st chip from its current vertex to an adjacent vertex and\r\ncolor that vertex . So, if k=3, you move chip 1 on move 1, chip 2 on\r\nmove 2, chip 3 on move 3, chip 1 on move 4, chip 2 on move 5 and so on.\r\nIf there is no adjacent white vertex, then the game ends.What\u2019s the\r\nmaximum number of moves you can perform?\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 16.02.2023 18:44:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> que(1, 0);\n    vector<int> pv(n, -1);\n    pv[0] = -2;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (pv[u] == -1) {\n          que.push_back(u);\n          pv[u] = que[b];\n        }\n      }\n    }\n    int k;\n    cin >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    int low = 0, high = n;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      vector<int> val(n, -1);\n      for (int i = 0; i < k; i++) {\n        val[a[i]] = mid / k + (i < mid % k);\n      }\n      bool ok = true;\n      vector<int> down(n, 0);\n      for (int it = n - 1; it >= 0; it--) {\n        int i = que[it];\n        if (val[i] >= 0) {\n          if (down[i] < val[i]) {\n            if (pv[i] < 0) {\n              ok = false;\n              break;\n            }\n            if (val[pv[i]] >= 0) {\n              ok = false;\n              break;\n            }\n            val[pv[i]] = val[i] - 1;\n          }\n        } else {\n          if (pv[i] >= 0) {\n            down[pv[i]] = max(down[pv[i]], down[i] + 1);\n          }\n        }\n      }\n      if (ok) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "dfs and similar", "greedy", "trees"], "dificulty": "2400", "interactive": false}