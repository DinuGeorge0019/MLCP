{
    "link": "https://codeforces.com//contest/1795/problem/F",
    "problemId": "1785702",
    "problem_idx": "F",
    "shortId": "1795F",
    "contest_number": "1795",
    "problem_submissions": {
        "G": [
            193868249,
            193922126,
            193880640,
            193880242,
            193879883,
            193877939,
            193892319,
            193909416,
            193909281,
            193909039,
            193908855,
            193907982,
            193907256,
            193907116,
            193905885,
            193905428,
            193895936,
            193894919,
            193900585,
            193900447,
            193900331,
            193900021,
            193895212,
            193901119,
            193897399,
            194065980,
            193895350,
            193897364,
            193910352,
            193909678,
            193877594,
            193901310,
            193900708,
            193909774,
            193909664,
            193908826,
            193902609,
            193895098,
            193898582,
            193887169,
            193989778,
            193903191,
            193906575,
            193901677
        ],
        "E": [
            193858484,
            193864061,
            193860485,
            193866472,
            193870118,
            193881494,
            193869535,
            193877440,
            194065966,
            193867450,
            193873381,
            193864290,
            193872060,
            193880762,
            193876051,
            193901176,
            193882421,
            193899122,
            193881276,
            193885055
        ],
        "F": [
            193849592,
            193871412,
            193870619,
            193880295,
            193883585,
            193866256,
            193887756,
            193901053,
            193899102,
            193887184,
            194065972,
            193879792,
            193887970,
            193889897,
            193889600,
            193879424,
            193886027,
            193888430,
            193890811,
            193880065,
            193894847,
            193891841
        ],
        "D": [
            193842483,
            193853701,
            193849666,
            193849500,
            193854093,
            193850355,
            193858853,
            193853243,
            194065953,
            193855818,
            193855956,
            193852941,
            193856134,
            193845600,
            193859844,
            193851729,
            193849114,
            193866588,
            193860778,
            193855517
        ],
        "C": [
            193840570,
            193847474,
            193846113,
            193844888,
            193847932,
            193844693,
            193851549,
            193846559,
            194065943,
            193849210,
            193849704,
            193847867,
            193849903,
            193858596,
            193851945,
            193847688,
            193845368,
            193860332,
            193855373,
            193849162
        ],
        "B": [
            193839119,
            193839637,
            193839480,
            193839407,
            193839832,
            193839202,
            193842405,
            193840503,
            194065925,
            193843321,
            193841514,
            193841857,
            193840539,
            193848293,
            193839850,
            193839356,
            193839529,
            193847088,
            193842717,
            193840388
        ],
        "A": [
            193838910,
            193838985,
            193838946,
            193838908,
            193839007,
            193838901,
            193840204,
            193839189,
            194065914,
            193839222,
            193839386,
            193882631,
            193839087,
            193843666,
            193841139,
            193839086,
            193838960,
            193838928,
            193845036,
            193840156,
            193838911
        ]
    },
    "name": "F. Blocking Chips",
    "statement": "You are given a tree, consisting of n vertices. There are k chips,\r\nplaced in vertices a_1, a_2,\r\ndots, a_k. All a_i are distinct. Vertices a_1, a_2,\r\ndots, a_k are colored black initially. The remaining vertices are\r\nwhite.You are going to play a game where you perform some moves\r\n(possibly, zero). On the i-th move (1-indexed) you are going to move the\r\n((i - 1)\r\nbmod k + 1)-st chip from its current vertex to an adjacent vertex and\r\ncolor that vertex . So, if k=3, you move chip 1 on move 1, chip 2 on\r\nmove 2, chip 3 on move 3, chip 1 on move 4, chip 2 on move 5 and so on.\r\nIf there is no adjacent white vertex, then the game ends.What\u2019s the\r\nmaximum number of moves you can perform?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.02.2023 18:44:28       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n - 1; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> que(1, 0);\n    vector<int> pv(n, -1);\n    pv[0] = -2;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int u : g[que[b]]) {\n        if (pv[u] == -1) {\n          que.push_back(u);\n          pv[u] = que[b];\n        }\n      }\n    }\n    int k;\n    cin >> k;\n    vector<int> a(k);\n    for (int i = 0; i < k; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    int low = 0, high = n;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      vector<int> val(n, -1);\n      for (int i = 0; i < k; i++) {\n        val[a[i]] = mid / k + (i < mid % k);\n      }\n      bool ok = true;\n      vector<int> down(n, 0);\n      for (int it = n - 1; it >= 0; it--) {\n        int i = que[it];\n        if (val[i] >= 0) {\n          if (down[i] < val[i]) {\n            if (pv[i] < 0) {\n              ok = false;\n              break;\n            }\n            if (val[pv[i]] >= 0) {\n              ok = false;\n              break;\n            }\n            val[pv[i]] = val[i] - 1;\n          }\n        } else {\n          if (pv[i] >= 0) {\n            down[pv[i]] = max(down[pv[i]], down[i] + 1);\n          }\n        }\n      }\n      if (ok) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Blocking Chips.json",
    "editorial_link": "https://codeforces.com//blog/entry/112963",
    "editorial": "The constraints tell us that the solution should be linear or pretty\r\nclose to it. Well, in particular, that implies that the solution almost\r\ncertainly isn\u00e2\u0080\u0099t dynamic programming, since we have both and to care\r\nabout. Thus, we\u00e2\u0080\u0099ll think about something greedy.When we know the number\r\nof move the game will last, we can tell how many steps each chip should\r\nmake. Well, since the more moves the game last, the more steps each ship\r\nmakes, the answer is a monotonic function. Let\u00e2\u0080\u0099s apply binary search and\r\nthink if we can check if each chip can make some known number of steps.A\r\ncommon idea in the problems where you have to do something greedily on a\r\ntree is to root the tree arbitrarily and process everything bottom\r\nup.Consider the bottommost chip. If it can move its number of moves\r\ndownwards, it\u00e2\u0080\u0099s always optimal to do that. Since it\u00e2\u0080\u0099s the bottommost\r\nchip, it can only make things worse for chips above it. And any of them\r\ncan\u00e2\u0080\u0099t pass through the initial vertex of this chip anyway.If it can\u00e2\u0080\u0099t,\r\nit has to move to its parent vertex. Let\u00e2\u0080\u0099s move it there and deal with\r\nthis chip later when it becomes the bottommost again.If it can\u00e2\u0080\u0099t move to\r\nits parent, it can\u00e2\u0080\u0099t move at all. Thus, the game can\u00e2\u0080\u0099t last for this\r\nmany steps.Since we only apply either the move which is guaranteed to\r\nnot interrupt any other moves or the move which is forced, the greedy\r\nstrategy is correct.As for implementation details, it\u00e2\u0080\u0099s not too tricky.\r\nBasically, for each vertex, we should maintain these values: if this\r\nvertex has been visited; the number of steps the chip in this vertex\r\nstill has to make (if any chip is in this vertex); the longest path\r\ndownwards from this vertex via non-visited vertices. The second value\r\ncan be initialized beforehand and pushed to the parent when needed. The\r\nrest of them are easily maintained with a single dfs.Overall complexity:\r\nper testcase.\r\n"
}