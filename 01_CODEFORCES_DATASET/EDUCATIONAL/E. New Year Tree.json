{
    "link": "https://codeforces.com//contest/620/problem/E",
    "problemId": "45931",
    "problem_idx": "E",
    "shortId": "620E",
    "contest_number": "620",
    "problem_submissions": {
        "F": [
            15476784,
            15481381,
            15483385,
            15501760,
            15483713,
            15483332,
            15483269,
            15486457,
            110737274,
            15560294,
            15483002
        ],
        "D": [
            15476004,
            15475486,
            15475046,
            15475660,
            15478283,
            15474921,
            15479173,
            15478662,
            15478888,
            15480075,
            15479882,
            15476142,
            15479569,
            15476517,
            15477414,
            15476987,
            15477430,
            15481310
        ],
        "E": [
            15473382,
            15477169,
            15483815,
            15476430,
            15478101,
            15474547,
            15477143,
            15476019,
            15475341,
            15476219,
            15475959,
            15477453,
            15479247,
            15477250,
            15479114,
            15481223,
            15479051,
            15484874,
            15484860,
            15484177,
            15484110,
            15484033,
            15483969,
            15483912,
            15483838,
            15483788,
            15478778,
            15477351
        ],
        "C": [
            15470876,
            15472964,
            15471929,
            15471592,
            15471646,
            15471528,
            15473335,
            15473233,
            15472403,
            15472416,
            15473511,
            15471829,
            15473844,
            15472579,
            15473548,
            15472833,
            15472615,
            15472479,
            15473711
        ],
        "B": [
            15470277,
            15471380,
            15470857,
            15470699,
            15470633,
            15470596,
            15471005,
            15471139,
            15470850,
            15471115,
            15471308,
            15470718,
            15472406,
            15471044,
            15470836,
            15471243,
            15471685,
            15471223
        ],
        "A": [
            15470173,
            15470408,
            15470256,
            15470217,
            15470181,
            15470174,
            15470315,
            15470332,
            15470383,
            15470351,
            15470502,
            15470184,
            15471568,
            15470376,
            15470236,
            15470211,
            15470178,
            15470460
        ]
    },
    "name": "E. New Year Tree",
    "statement": "The New Year holidays are over, but Resha doesn’t want to throw away the\r\nNew Year tree. He invited his best friends Kerim and Gural to help him\r\nto redecorate the New Year tree.The New Year tree is an undirected tree\r\nwith vertices and root in the vertex .You should process the queries of\r\nthe two types: Change the colours of all vertices in the subtree of the\r\nvertex to the colour . Find the number of different colours in the\r\nsubtree of the vertex .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 400010;\n\nvector <int> g[N];\nint pos[N], to[N];\nint kw = 0, w[N];\n\nvoid dfs(int v, int pr) {\n  pos[v] = kw;\n  w[kw++] = v;\n  for (int j = 0; j < (int) g[v].size(); j++) {\n    int u = g[v][j];\n    if (u != pr) {\n      dfs(u, v);\n    }\n  }\n  to[v] = kw - 1;\n}\n\nlong long a[4 * N];\nbool put[4 * N];\nint color[N];\n\nvoid build(int x, int l, int r) {\n  if (l < r) {\n    int y = (l + r) >> 1;\n    build(x + x, l, y);\n    build(x + x + 1, y + 1, r);\n    a[x] = a[x + x] | a[x + x + 1];\n    put[x] = false;\n  } else {\n    a[x] = 1LL << color[w[l]];\n    put[x] = true;\n  }\n}\n\ninline void push(int x) {\n  if (put[x]) {\n    a[x + x] = a[x + x + 1] = a[x];\n    put[x + x] = put[x + x + 1] = true;\n    put[x] = false;\n  }\n}\n\ninline void gather(int x) {\n  a[x] = a[x + x] | a[x + x + 1];\n}\n\nvoid modify(int x, int l, int r, int ll, int rr, long long v) {\n  if (r < ll || rr < l) {\n    return;\n  }\n  if (ll <= l && r <= rr) {\n    a[x] = v;\n    put[x] = true;\n    return;\n  }\n  push(x);\n  int y = (l + r) >> 1;\n  modify(x + x, l, y, ll, rr, v);\n  modify(x + x + 1, y + 1, r, ll, rr, v);\n  gather(x);\n}\n\nlong long get(int x, int l, int r, int ll, int rr) {\n  if (r < ll || rr < l) {\n    return 0;\n  }\n  if (ll <= l && r <= rr) {\n    return a[x];\n  }\n  push(x);\n  int y = (l + r) >> 1;\n  long long res = get(x + x, l, y, ll, rr);\n  res |= get(x + x + 1, y + 1, r, ll, rr);\n  gather(x);\n  return res;\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", color + i);\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar;\n    scanf(\"%d %d\", &foo, &bar);\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  dfs(0, -1);\n  build(1, 0, n - 1);\n  while (m--) {\n    int type;\n    scanf(\"%d\", &type);\n    if (type == 1) {\n      int foo, bar;\n      scanf(\"%d %d\", &foo, &bar);\n      foo--;\n      modify(1, 0, n - 1, pos[foo], to[foo], 1LL << bar);\n    } else {\n      int foo;\n      scanf(\"%d\", &foo);\n      foo--;\n      long long value = get(1, 0, n - 1, pos[foo], to[foo]);\n      printf(\"%d\\n\", __builtin_popcountll(value));\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. New Year Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/22936",
    "editorial": "Letâs run dfs on the tree and write out the vertices in order of their\r\nvisisiting by dfs (that permutation is called Euler walk). Easy to see\r\nthat subtree of any vertex is a subsegment of that permutation. Note\r\nthat the number of different colours is , so we can store the set of\r\ncolours just as mask of binary bits in -bit type (*long long* in C++,\r\nlong in Java). Letâs build the segment tree over the permutation which\r\nsupports two operations: paint subsegment by some colour and find the\r\nmask of colours of some segment. ++ solution Complexity: .\r\n",
    "hint": []
}