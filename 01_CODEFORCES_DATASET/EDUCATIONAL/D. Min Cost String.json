{
    "link": "https://codeforces.com//contest/1511/problem/D",
    "problemId": "955215",
    "problem_idx": "D",
    "shortId": "1511D",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "D. Min Cost String",
    "statement": "Let’s define the of a string s as the number of index pairs i and j (1\r\nle i < j < |s|) such that s_i = s_j and s_{i+1} = s_{j+1}.You are given\r\ntwo positive integers n and k. Among all strings with length n that\r\ncontain only the first k characters of the Latin alphabet, find a string\r\nwith minimum possible . If there are multiple such strings with minimum\r\nfind any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int k = scan();\n  string s;\n  for (int i : Rep(k)) {\n    s += 'a' + i;\n    for (int j : Rep(i + 1, k)) {\n      s += 'a' + i;\n      s += 'a' + j;\n    }\n  }\n  while (int(size(s)) < n) s += s;\n  s.resize(n);\n  cout << s << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "greedy",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Min Cost String.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "Consider all possible strings of length on the alphabet of size (there\r\nare of them). Let be the number of occurrences of the -th of them in the\r\nstring . The cost of the string by definition is . Now, letâs suppose\r\nthere are two strings and such that . Then, if we somehow reduce the\r\nnumber of occurrences of the string by and increase the number of\r\noccurrences of the string by , the cost will decrease. So, in the\r\noptimal answer all the strings of length should appear the same number\r\nof times (and if itâs impossible, the difference in the number of\r\nappearances should not be greater than ).Letâs suppose that , then our\r\ngoal is to build a string where each string of length on the alphabet of\r\ncharacters appears exactly once. The construction of this string can be\r\nmodeled using Eulerian cycles: build a directed graph with vertices,\r\nwhere each vertex represents a character, each arc represents a string\r\nof length , and for every pair of vertices , there is an arc from to\r\n(itâs possible that !). Then, by finding the Eulerian cycle in this\r\ngraph (it always exists since the graph is strongly connected and, for\r\neach vertex, its in-degree is equal to its out-degree), we find a string\r\nof length such that all its substrings are different (so each string of\r\nlength appears there once as a substring).Okay, what about the cases and\r\n? Since the string we build for the case represents a cycle, we can make\r\nit \"cyclical\" and repeat the required number of times, then cut last\r\nseveral characters if itâs too big. For example, if , , then the string\r\nfor is (itâs not the only one, but we can use it). We can expand this\r\nstring to (by repeating the last characters), and delete the last\r\ncharacter so its length is .By the way, in this problem, you donât have\r\nto implement the algorithm that finds Eulerian cycles. The graph where\r\nwe want to find the Eulerian cycle has a very special structure, and\r\nthere are many different constructive ways to find the cycle in it. But\r\nif you canât use them, you always can rely on the straightforward\r\nsolution that explicitly searches for the Eulerian cycle.\r\n",
    "hint": []
}