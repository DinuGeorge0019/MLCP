{
    "link": "https://codeforces.com//contest/1923/problem/E",
    "problemId": "2492668",
    "problem_idx": "E",
    "shortId": "1923E",
    "contest_number": "1923",
    "problem_submissions": {
        "F": [
            247927445,
            247926735,
            247941699,
            247942342,
            247957925,
            247930359,
            247950515,
            247952641,
            247961910,
            247957616,
            247954803,
            247957462,
            247965318,
            247958101,
            247966724,
            247961269,
            247975649,
            247970780
        ],
        "E": [
            247910260,
            247907637,
            247944549,
            247918053,
            247922522,
            247916787,
            247955209,
            247923339,
            247906437,
            247924189,
            247923801,
            247924733,
            247919146,
            247919411,
            247915457,
            248010348,
            247930116,
            247913617,
            247921891,
            247928453
        ],
        "D": [
            247906663,
            247903362,
            247909256,
            247913572,
            247912411,
            247905740,
            247917150,
            247917832,
            247911096,
            247917233,
            247917212,
            247913338,
            247913589,
            247931525,
            247913875,
            247917151,
            247917274,
            247912599
        ],
        "C": [
            247899621,
            247896441,
            247899387,
            247904054,
            247903940,
            247899293,
            247903341,
            247912953,
            247900198,
            247901509,
            247906201,
            247902190,
            247904629,
            247901902,
            247905627,
            247901567,
            247905304,
            247903364
        ],
        "B": [
            247895420,
            247893401,
            247895016,
            247899339,
            247899002,
            247894634,
            247896319,
            247907358,
            247897312,
            247896352,
            247897008,
            247896401,
            247900980,
            247897119,
            247897848,
            247898814,
            247898339,
            247898930
        ],
        "A": [
            247893064,
            247892642,
            247892787,
            247894650,
            247893381,
            247892909,
            247892866,
            247905142,
            247893155,
            247893038,
            247892799,
            247892722,
            247896270,
            247892907,
            247893359,
            247893598,
            247893062,
            247896053
        ]
    },
    "name": "E. Count Paths",
    "statement": "You are given a tree, consisting of n vertices, numbered from 1 to n.\r\nEvery vertex is colored in some color, denoted by an integer from 1 to\r\nn.A simple path of the tree is called if: it consists of at least 2\r\nvertices; the first and the last vertices of the path have the same\r\ncolor; no other vertex on the path has the same color as the first\r\nvertex. Count the number of the simple paths of the tree. Note that\r\npaths are considered undirected (i. e. the path from x to y is the same\r\nas the path from y to x).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n        c[i]--;\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<std::map<int, int>> mp(n);\n    i64 ans = 0;\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            self(self, y, x);\n            if (mp[y].count(c[x])) {\n                ans += mp[y][c[x]];\n                mp[y].erase(c[x]);\n            }\n            if (mp[x].size() < mp[y].size()) {\n                std::swap(mp[x], mp[y]);\n            }\n            for (auto [a, b] : mp[y]) {\n                ans += 1LL * b * mp[x][a];\n                mp[x][a] += b;\n            }\n            mp[y].clear();\n        }\n        mp[x][c[x]] += 1;\n    };\n    dfs(dfs, 0, -1);\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Count Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/126339",
    "editorial": "Letâs consider what the paths passing through some vertex look like.\r\nFirst, root the tree arbitrarily. Let be the children of . Then, for\r\nsome color , there are top-level vertices in their subtrees. Top-level\r\nhere means that there are no vertices of color on the path from them to\r\n.If the color of is not , then you can combine all top-level vertices\r\nfrom every pair of children into paths. If the color is , then all\r\ntop-level vertices can only be paired with . Moreover, the top-level\r\nvertices of color in subtree of is only itself now.With these ideas,\r\nsome small-to-large can be implemented. Store for all colors such that\r\nthere exist top-level vertices of this color.In order to recalculate\r\nfrom the values of its children, you can first calculate the sum of for\r\neach , then replace with (regardless of if it appeared in children or\r\nnot). So that can be done by adding all values to the values of the\r\nlargest child of (largest by its size of , for example). During this\r\nprocess, you can calculate the number of paths as well.The complexity\r\nwill be for each testcase, and that should pass freely.Thereâs also an\r\nidea for a faster solution. Two words: virtual trees. Basically, you can\r\nbuild a virtual tree of all vertices of each color. Now, there are\r\nvertices colored in it and some auxiliary vertices. The answer for that\r\ncolor can be calculated with some sort of dynamic programming. Similar\r\nto the first solution, for each vertex, store the number of top-level\r\nvertices of color in its subtree. All the calculations are exactly the\r\nsame.You can build all virtual trees in in total.\r\n",
    "hint": []
}