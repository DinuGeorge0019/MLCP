{
    "link": "https://codeforces.com//contest/1036/problem/C",
    "problemId": "216419",
    "problem_idx": "C",
    "shortId": "1036C",
    "contest_number": "1036",
    "problem_submissions": {
        "G": [
            42635175,
            42627436,
            42635430,
            42626359,
            42737989,
            42717556,
            42717524,
            42717521,
            42651041,
            42700940,
            42700625,
            54263107,
            42638239,
            42625046,
            42815013
        ],
        "B": [
            42631894,
            42635568,
            42631049,
            42642897,
            42640457,
            42621960,
            42628162,
            42621741,
            42621550,
            42618797,
            42623868,
            42633347,
            42620322,
            42622448,
            42641969,
            42624721,
            42635114,
            42625827,
            42628122,
            42634984,
            42644768
        ],
        "F": [
            42629280,
            42634265,
            42627972,
            42642001,
            42641962,
            42630707,
            42634470,
            42717490,
            42631938,
            42631850,
            42631382,
            42631058,
            42629288,
            42629020,
            42633820,
            42633355,
            42631044,
            42636476,
            42635060,
            42629290,
            42636959,
            42643700,
            42637023,
            42633474,
            42641007
        ],
        "E": [
            42626026,
            42624301,
            42644046,
            42634366,
            42634335,
            42634205,
            42630482,
            42637851,
            42633450,
            42641281,
            42638561,
            42638638,
            42639628,
            42642761,
            42644666,
            42649447,
            42648312,
            42643498,
            42631013,
            42635443,
            42642733,
            42645034,
            42634920
        ],
        "D": [
            42623581,
            42621638,
            42636628,
            42635516,
            42624651,
            42622909,
            42625901,
            42624230,
            42627616,
            42623027,
            42622706,
            42628513,
            42629952,
            42622220,
            42628717,
            42631816,
            42630498,
            42632680,
            42629722,
            42643211
        ],
        "C": [
            42622041,
            42620587,
            42639507,
            42636945,
            42623531,
            42620800,
            42624388,
            42623206,
            42625364,
            42621712,
            81464229,
            42620946,
            42626482,
            42628744,
            42619137,
            42627629,
            42632962,
            42629275,
            42630870,
            42627504,
            42631469
        ],
        "A": [
            42617741,
            42628137,
            42620189,
            42640915,
            42619770,
            42617799,
            42621837,
            42618858,
            42617734,
            42618440,
            42617898,
            42617724,
            42617895,
            42631014,
            42618014,
            42635499,
            42624408,
            42620380,
            42619824
        ]
    },
    "name": "C. Classy Numbers",
    "statement": "Let’s call some positive integer if its decimal representation contains\r\nno more than 3 non-zero digits. For example, numbers 4, 200000, 10203\r\nare and numbers 4231, 102306, 7277420000 are not.You are given a segment\r\n[L; R]. Count the number of integers x such that L\r\nle x\r\nle R.Each testcase contains several segments, for each of them you are\r\nrequired to solve the problem separately.\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\nLL l, r;\nvoid init(){\n  l=getint();\n  r=getint();\n}\nLL b[20], h;\nLL C2(LL x){ return x*(x-1)/2; }\nLL C3(LL x){ return x*(x-1)*(x-2)/6; }\nLL ff(int bt, int g){\n  if(g == 0) return 1;\n  if(g == 1) return (bt+1)*9;\n  if(g == 2) return C2(bt+1)*9*9;\n  if(g == 3) return C3(bt+1)*9*9*9;\n  return -1;\n}\nLL go(int bt, int res, bool same){\n  if(res == 0 or bt < 0) return 1;\n  if(not same){\n    LL ret=0;\n    for(int g=0; g<=res; g++)\n      ret+=ff(bt, g);\n    return ret;\n  }\n  LL ret=0;\n  for(int i=0; i<=9; i++){\n    if(i and res==0) break;\n    if(same and i>b[bt]) break;\n    ret+=go(bt-1, res-(i>0), same and i==b[bt]);\n  }\n  return ret;\n}\nLL f(LL x){\n  if(x == 0) return 1;\n  h=0;\n  while(x){\n    b[h++]=x%10;\n    x/=10;\n  }\n  return go(h-1, 3, true);\n}\nvoid solve(){\n  printf(\"%lld\\n\", f(r)-f(l-1));\n}\nint main(){\n  build();\n  __ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Classy Numbers.json",
    "editorial_link": "https://codeforces.com/blog/entry/61727",
    "editorial": "There are quite a few approaches to the problem. Iâll describe the two\r\nof them which I actually implemented.First approach - combinatoric\r\none:Problems of the form \"count the number of beautiful numbers from to\r\n\" usually require counting the numbers on and (or not inclusively and )\r\nand subtracting one from another. Letâs try this thing here, counting\r\nnot inclusively.Letâs fix some prefix of the upper border number. We\r\nwant to calculate the amount of numbers having the same prefix but being\r\nsmaller in the next digit. If we count it for all prefixes (including\r\nthe empty one), we will get the answer. And that is pretty easy. Let the\r\nprefix include non-zero digits, the length of the suffix be and the\r\ndigit after the chosen prefix is . If is zero then there the result is\r\nobviously zero. Otherwise we can either put or any of the non-zero\r\ndigits. Then the formula is: + .We choose positions from the suffix to\r\nput non-zero digits in them (any digit from to ) and fill the rest with\r\nzeros.Overall complexity: .Second approach - precalc one:This is a bit\r\neasier to implement. Actually, there are just about 700000 valid\r\nnumbers, you can generate them all, put them into the array in sorted\r\norder and binary search for the given queries.Overall complexity: .\r\n",
    "hint": []
}