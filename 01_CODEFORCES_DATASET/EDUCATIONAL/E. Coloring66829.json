{
    "link": "https://codeforces.com//contest/1574/problem/E",
    "problemId": "1115678",
    "problem_idx": "E",
    "shortId": "1574E",
    "contest_number": "1574",
    "problem_submissions": {
        "F": [
            129371777,
            129390921,
            129389731,
            129403988,
            129393793,
            129405865,
            129397624,
            129402611,
            129407592,
            129402025,
            129406898,
            129404634,
            129404840,
            129396171,
            129404379,
            129428143,
            129709936
        ],
        "E": [
            129358674,
            129374904,
            129374765,
            129380449,
            129384709,
            129384504,
            129386221,
            129385268,
            129386371,
            129386001,
            129382985,
            129391466,
            129400354,
            129386981,
            129377485,
            129381385,
            129368975,
            129386322,
            131512763,
            129380209,
            129375216
        ],
        "D": [
            129351289,
            129361598,
            129356978,
            129361351,
            129369248,
            129359850,
            129368999,
            129364465,
            129359499,
            129374264,
            129364919,
            129372422,
            129366912,
            129361472,
            129361829,
            129360363,
            129358818,
            129366595,
            129366262,
            129357077
        ],
        "C": [
            129345085,
            129349632,
            129348099,
            129350669,
            129350365,
            129350502,
            129357353,
            129349080,
            129351966,
            129349226,
            129354359,
            129353753,
            129347195,
            129407614,
            129351570,
            129352219,
            129351381,
            129349196,
            129351680,
            129362666
        ],
        "B": [
            129342942,
            129343801,
            129344237,
            129345556,
            129343553,
            129345572,
            129345752,
            129344787,
            129345774,
            129343483,
            129344471,
            129343826,
            129343420,
            129410456,
            129346117,
            129346262,
            129343905,
            129345607,
            129345689,
            129346070
        ],
        "A": [
            129341973,
            129342397,
            129341943,
            129342408,
            129341991,
            129342232,
            129342087,
            129342285,
            129343124,
            129342143,
            129342078,
            129341990,
            129341904,
            129411806,
            129343011,
            129342282,
            129341912,
            129342040,
            129342183,
            129341989
        ]
    },
    "name": "E. Coloring",
    "statement": "A matrix of size n\r\ntimes m, such that each cell of it contains either 0 or 1, is considered\r\nif the sum in every contiguous submatrix of size 2\r\ntimes 2 is exactly 2, i. e. every \"square\" of size 2\r\ntimes 2 contains exactly two 1\u2019s and exactly two 0\u2019s.You are given a\r\nmatrix of size n\r\ntimes m. Initially each cell of this matrix is empty. Let\u2019s denote the\r\ncell on the intersection of the x-th row and the y-th column as (x, y).\r\nYou have to process the queries of three types: x y -1 clear the cell\r\n(x, y), if there was a number in it; x y 0 write the number 0 in the\r\ncell (x, y), ; x y 1 write the number 1 in the cell (x, y), . After each\r\nquery, print the number of ways to fill the empty cells of the matrix so\r\nthat the resulting matrix is . Since the answers can be large, print\r\nthem modulo 998244353.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 20.09.2021 17:49:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> row_has(n, vector<int>(2));\n  vector<vector<int>> col_has(m, vector<int>(2));\n  vector<int> mat_has(2);\n  int bad_rows = 0;\n  int bad_cols = 0;\n  int empty_rows = n;\n  int empty_cols = m;\n  map<pair<int, int>, int> mp;\n  auto CountRow = [&](int x, int coeff) {\n    if (row_has[x][0] + row_has[x][1] == 0) {\n      empty_rows += coeff;\n    }\n    if (row_has[x][0] > 0 && row_has[x][1] > 0) {\n      bad_rows += coeff;\n    }\n  };\n  auto CountCol = [&](int x, int coeff) {\n    if (col_has[x][0] + col_has[x][1] == 0) {\n      empty_cols += coeff;\n    }\n    if (col_has[x][0] > 0 && col_has[x][1] > 0) {\n      bad_cols += coeff;\n    }\n  };\n  auto Add = [&](int x, int y, int z) {\n    CountRow(x, -1);\n    CountCol(y, -1);\n    row_has[x][(y + z) % 2] += 1;\n    col_has[y][(x + z) % 2] += 1;\n    CountRow(x, +1);\n    CountCol(y, +1);\n    mat_has[(x + y + z) % 2] += 1;\n  };\n  auto Remove = [&](int x, int y, int z) {\n    CountRow(x, -1);\n    CountCol(y, -1);\n    row_has[x][(y + z) % 2] -= 1;\n    col_has[y][(x + z) % 2] -= 1;\n    CountRow(x, +1);\n    CountCol(y, +1);\n    mat_has[(x + y + z) % 2] -= 1;\n  };\n  while (k--) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    auto p = make_pair(x, y);\n    auto it = mp.find(p);\n    if (it != mp.end()) {\n      Remove(x, y, it->second);\n      mp.erase(it);\n    }\n    if (z != -1) {\n      Add(x, y, z);\n      mp[p] = z;\n    }\n    Mint ans = 0;\n    if (bad_rows == 0) {\n      ans += power(Mint(2), empty_rows);\n    }\n    if (bad_cols == 0) {\n      ans += power(Mint(2), empty_cols);\n    }\n    for (int v : mat_has) {\n      if (v == 0) {\n        ans -= 1;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "implementation",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Coloring66829.json",
    "editorial_link": "https://codeforces.com//blog/entry/95188",
    "editorial": "For best understanding we replace the matrix with and with the matrix\r\nwith black and white cells.At first let\u00e2\u0080\u0099s consider matrix if there are\r\ntwo adjacent horizontal cell with same color (for example cells and are\r\nblack). Then the cells , , and must have the opposite color (white); the\r\ncells , , and must have the same color (black) and so on. So, two\r\nadjacent horizontal cells generate the of width two. Reciprocally two\r\nadjacent vertical cells generate the of width two. And if simultaneously\r\nthere are and then the answer is (because they contradict each other).If\r\nthere are two cells of same color in the same row with even number of\r\ncells between them (for example and with four cells between them) then\r\nthere is the (because there are always two adjacent cells with same\r\ncolor between them). The same is correct for . Now let\u00e2\u0080\u0099s consider how\r\nthe matrix look if there are the . It look like a chess board of size ,\r\nbut colors of some verticals are inverted. The same is correct if there\r\nare the .How we can quickly understand that there are two cells of same\r\ncolor in the same row with even number of cells between them? For this\r\nmentally color the matrix in a checkerboard pattern. And then one of\r\nthis cells has the same color witch cells in chessboard, and the other\r\nhas the opposite color witch cells in chessboard.For calculating the\r\nanswer we have maintain to the following values: The color of each\r\ncolored cell; The row and columns containing the cells of same color\r\nwith even number of cells between them; And the number of row and\r\ncolumns containing at least one colored cell (for calculating the number\r\nof beautiful matrix).\r\n"
}