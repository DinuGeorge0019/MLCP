{
    "link": "https://codeforces.com//contest/817/problem/E",
    "problemId": "110091",
    "problem_idx": "E",
    "shortId": "817E",
    "contest_number": "817",
    "problem_submissions": {
        "F": [
            27802477,
            27802871,
            27803246,
            27803944,
            27802191,
            27802636,
            27804073,
            27805415,
            27804948,
            27806927,
            27806466,
            27805739,
            27813146,
            27797882,
            27806149,
            27806211,
            27805850,
            27805698,
            27804211,
            28257297,
            28257292,
            28257289,
            28257283,
            27833492,
            27833455,
            27833416,
            27833374,
            27832302,
            27812034,
            27812024,
            27812004,
            27811985,
            27811962,
            27811901,
            27811225,
            27805471,
            27800244,
            27803532
        ],
        "E": [
            27800445,
            27801366,
            27800267,
            27802020,
            27799789,
            27803533,
            27800764,
            27802558,
            27802198,
            27802473,
            27804063,
            27802765,
            27801098,
            27803095,
            27803349,
            27806700,
            27900799,
            27832089,
            27832073,
            27822028,
            27806592,
            27806456,
            27832416,
            27832402,
            27811118,
            27810762,
            27810658,
            27810610,
            27810602,
            27810544,
            27810479,
            27810444,
            27810393,
            27810363,
            27809667,
            27809595,
            27809575,
            27809510,
            27809462,
            27809387,
            27809304,
            27806448,
            27801453,
            27803200
        ],
        "D": [
            27799007,
            27800384,
            27798797,
            27800152,
            27798092,
            27799516,
            27799058,
            27800102,
            27800977,
            27800772,
            27801734,
            27801612,
            27802809,
            27801124,
            27803838,
            27801479,
            27798229,
            27800381,
            27803639,
            27803601
        ],
        "C": [
            27798258,
            27799047,
            27797583,
            27799266,
            27798759,
            27798490,
            27798461,
            27798153,
            27799421,
            27799975,
            27800118,
            27798874,
            27803217,
            27798996,
            27799073,
            27799736,
            27802337,
            27801320,
            27804182,
            27799514
        ],
        "B": [
            27797855,
            27797266,
            27797101,
            27797959,
            27796767,
            27796880,
            27796993,
            27797447,
            27798255,
            27798428,
            27798510,
            27797187,
            27803954,
            27798163,
            27797319,
            27798991,
            27796825,
            27797991,
            27805108,
            27797443,
            27797269,
            27797136,
            27797019,
            27796797
        ],
        "A": [
            27796617,
            27797382,
            27796336,
            27796710,
            27796341,
            27796727,
            27796292,
            27796290,
            27796506,
            27796662,
            27797209,
            27797129,
            27797386,
            27796400,
            27804277,
            27796496,
            27796390,
            27798422,
            27798806,
            27796261,
            27805446,
            27797485,
            27797449,
            27797050,
            27796752,
            27796611,
            27796441,
            27796311
        ]
    },
    "name": "E. Choosing The Commander",
    "statement": "As you might remember from the previous round, Vova is currently playing\r\na strategic game known as Rage of Empires.Vova managed to build a large\r\narmy, but forgot about the main person in the army - the commander. So\r\nhe tries to hire a commander, and he wants to choose the person who will\r\nbe respected by warriors.Each warrior is represented by his personality\r\nan integer number . Each commander has two characteristics his\r\npersonality and leadership (both are integer numbers). Warrior commander\r\nonly if ( is the bitwise excluding OR of and ).Initially Vova\u2019s army is\r\nempty. There are three different types of events that can happen with\r\nthe army: one warrior with personality joins Vova\u2019s army; one warrior\r\nwith personality leaves Vova\u2019s army; Vova tries to hire a commander with\r\npersonality and leadership . For each event of the third type Vova wants\r\nto know how many warriors (counting only those who joined the army and\r\nhaven\u2019t left yet) the commander he tries to hire.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << \" = \" << (x) << \", \";\n#define endln cerr << \"\\n\";\n\nconst int maxn = 1e5 + 5;\nconst int logn = 31;\n\nint ptr;\nint nxt[maxn * logn * 5][2];\nint val[maxn * logn * 5];\n\nvoid add(int k) {\n    int st = 0;\n    FORd(i, logn, 0) {\n        int x = bit(k, i);\n        if (!nxt[st][x]) nxt[st][x] = ++ptr;\n        st = nxt[st][x];\n        val[st]++;\n    }\n}\n\nvoid rem(int k) {\n    int st = 0;\n    FORd(i, logn, 0) {\n        int x = bit(k, i);\n        if (!nxt[st][x]) nxt[st][x] = ++ptr;\n        st = nxt[st][x];\n        val[st]--;\n    }\n}\n\nint query(int k, int l) {\n    int res = 0, st = 0;\n    FORd(i, logn, 0) {\n        int x = bit(k, i);\n        int y = bit(l, i);\n        if (y) {\n            if (nxt[st][x]) {\n                res += val[nxt[st][x]];\n            }\n            if (nxt[st][!x]) {\n                st = nxt[st][!x];\n            }\n            else {\n                return res;\n            }\n        }\n        else {\n            if (nxt[st][x]) {\n                st = nxt[st][x];\n            }\n            else {\n                return res;\n            }\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    int q; cin >> q;\n    while (q--) {\n        int op; cin >> op;\n        if (op == 1) {\n            int p; cin >> p;\n            add(p);\n        }\n        else if (op == 2) {\n            int p; cin >> p;\n            rem(p);\n        }\n        else {\n            int p, l; cin >> p >> l;;\n            cout << query(p, l) << \"\\n\";\n        }\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(\"in.txt\", \"r\")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(\"in.txt\", \"r\", stdin));\n        //assert(freopen(\"out.txt\", \"w\", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Choosing The Commander.json",
    "editorial_link": "https://codeforces.com//blog/entry/52638",
    "editorial": "Let\u00e2\u0080\u0099s use binary trie to store all personalities of warriors (that is,\r\njust use the trie data structure on binary representations of all ). For\r\neach subtree of this trie you have to maintain the number of \u00e2\u0080\u0099s\r\ncurrently present in this subtree when inserting a value of , we\r\nincrease the sizes of subtrees on the path from the node with to the\r\nroot by , and when removing , we decrease the sizes of subtrees on this\r\npath by .How can it help us with answering the events of third type? We\r\nwill descend the trie. When descending, we will try to find the number\r\nin the structure. When we go to some subtree, we determine whether we\r\nadd the quantity of numbers in the subtree we are not going into by\r\nchecking if the current bit in is equal to (if so, then for all numbers\r\nfrom this subtree their bitwise xor with the current commander\u00e2\u0080\u0099s\r\npersonality is less than ). The answer to the event is the sum of sizes\r\nof all subtrees we \"added\" while descending into the trie.\r\n"
}