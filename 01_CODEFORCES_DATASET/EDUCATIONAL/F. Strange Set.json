{
    "link": "https://codeforces.com//contest/1473/problem/F",
    "problemId": "864974",
    "problem_idx": "F",
    "shortId": "1473F",
    "contest_number": "1473",
    "problem_submissions": {
        "G": [
            104324184,
            104387693,
            104338182,
            104349212,
            104348798,
            104346480,
            104390780,
            104390610,
            104390495,
            104389764,
            104383982,
            104383801,
            104346655,
            104341001,
            104315264,
            104352224,
            104352185,
            104375589,
            104397435,
            104397194,
            104376606,
            104352690,
            104352754,
            104352534,
            104398919,
            104398235,
            104330024
        ],
        "F": [
            104316672,
            104314197,
            104321921,
            104322437,
            104324528,
            104322986,
            104314395,
            104317108,
            104322022,
            104311306,
            136810058,
            104327481,
            104330457,
            104324027,
            104334280,
            104334405,
            104340043,
            104329360,
            104332558
        ],
        "E": [
            104307026,
            104303673,
            104306129,
            104311187,
            104320601,
            104327879,
            104304639,
            104302012,
            104310767,
            104318435,
            104314089,
            104313021,
            104316783,
            104313523,
            104318767,
            104312111,
            104314876,
            104327257,
            104303395
        ],
        "D": [
            104300616,
            104298125,
            104298419,
            104305187,
            104310558,
            104332950,
            104295784,
            104297395,
            104304904,
            104298645,
            104306694,
            104301645,
            104305953,
            104307851,
            104307522,
            104307146,
            104309694,
            104303434,
            104321617
        ],
        "C": [
            104297127,
            104291328,
            104310275,
            104297010,
            104300137,
            104335806,
            104289962,
            104291239,
            104299846,
            104320575,
            104299422,
            104297141,
            104307584,
            104296827,
            104299646,
            104301166,
            104302797,
            104297015,
            104316440
        ],
        "B": [
            104289189,
            104283439,
            104284166,
            104288050,
            104287625,
            104337404,
            104283726,
            104283807,
            104286751,
            104285766,
            104285844,
            104292438,
            104285398,
            104287974,
            104288404,
            104287047,
            104293072,
            104288614,
            104287425
        ],
        "A": [
            104282920,
            104280323,
            104280823,
            104280333,
            104281130,
            104338367,
            104280298,
            104280342,
            104281217,
            104281168,
            104280838,
            104286833,
            104280557,
            104280439,
            104281300,
            104280646,
            104289104,
            104281489,
            104280913
        ]
    },
    "name": "F. Strange Set",
    "statement": "You are given an integer n and two sequences a_1, a_2,\r\ndots, a_n and b_1, b_2,\r\ndots, b_n.Let\u2019s call a set of integers S such that S\r\nsubseteq\r\n{1, 2, 3,\r\ndots, n\r\n} , if, for every element i of S, the following condition is met: for\r\nevery j\r\nin [1, i - 1], if a_j divides a_i, then j is also included in S. An\r\nempty set is always .The of the set S is\r\nsum\r\nlimits_{i\r\nin S} b_i. You have to calculate the maximum possible of a set.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nconstexpr int inf = 1e9;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::mt19937 gen;\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    std::vector<int> last(101, -1);\n    Flow g(n + 2);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (b[i] > 0) {\n            ans += b[i];\n            g.addEdge(n, i, b[i]);\n        } else {\n            g.addEdge(i, n + 1, -b[i]);\n        }\n        for (int j = 1; j <= a[i]; j++) {\n            if (a[i] % j == 0 && last[j] != -1) {\n                g.addEdge(i, last[j], inf);\n            }\n        }\n        last[a[i]] = i;\n    }\n    ans -= g.maxFlow(n, n + 1);\n    std::cout << ans << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Strange Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/86827",
    "editorial": "We will model the problem as the minimum cut in a flow network.Build a\r\nnetwork as follows: create a source node , a sink node , and a vertex\r\nfor every number from to . Let\u00e2\u0080\u0099s say that we are going to find the\r\nminimum - cut in this network, and the vertices belonging to the same\r\ncut part with represent the numbers that are taken into the answer.Using\r\nthe edges of the network, we should model these constraints: taking an\r\nelement that depends on another element should force us to take as well;\r\ntaking an element with should add to our score; taking an element with\r\nshould subtract from our score. Constraint can be modeled in the\r\nfollowing way: for every pair such that element depends on element ( and\r\n), add a directed edge with infinite capacity from to . That way, if is\r\ntaken and is not, the value of the cut will be infinite because of this\r\nedge, and this cut cannot be minimum.Constraint is modeled in the\r\nfollowing way: for every such that , add a directed edge with capacity\r\nfrom to . That way, if we take some element with into the answer, is\r\nadded to the value of the cut.And for constraint , for every such that ,\r\nadd a directed edge with capacity from to . That way, if we take some\r\nelement with , is added to the value of the cut.It\u00e2\u0080\u0099s now easy to see\r\nthat the answer is , since it is exactly the sum of elements that were\r\ntaken (for positive elements, we add them all up and then subtract the\r\nones that don\u00e2\u0080\u0099t belong to the answer; for negative ones, we just\r\nsubtract those which belong to the answer). To find a minimum cut, just\r\nrun maximum flow in this network.There\u00e2\u0080\u0099s one caveat though. If, for\r\nexample, all are equal (or many are divisible by many other values in ),\r\nthis network can contain edges. To reduce the number of edges, let\u00e2\u0080\u0099s see\r\nthat if for some index there exist two equal divisors of to the left of\r\nit (let\u00e2\u0080\u0099s say that these divisors are and : ; ; ), then we only need to\r\nadd an edge from to , because taking also should force taking into the\r\nanswer. So, for every divisor of , we are interested in only one closest\r\noccurrence of this divisor to the left, and we need to add a directed\r\nedge only to this occurrence, and ignore all other occurrences. That\r\nway, for every vertex , we add at most edges to other vertices (where is\r\nthe number of divisors of ).It can be proven that any maximum flow\r\nalgorithm that relies on augmenting paths will finish after iterations\r\nin this network, so it won\u00e2\u0080\u0099t work longer than , and both and are\r\nproportional to , so any maximum flow solution will run in .\r\n"
}