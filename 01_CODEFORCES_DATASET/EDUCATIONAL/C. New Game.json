{
    "link": "https://codeforces.com//contest/2025/problem/C",
    "problemId": "2948773",
    "problem_idx": "C",
    "shortId": "2025C",
    "contest_number": "2025",
    "problem_submissions": {
        "G": [
            285888128,
            285968165,
            285968156,
            285968149,
            285968144,
            285897832,
            285920810,
            285910851,
            285909011,
            285930826,
            285929850,
            285925790,
            285926690,
            285922742,
            285921341,
            285927635,
            285927533,
            285927378,
            285927290,
            285927201,
            285926718,
            285927241,
            285924989,
            299831833,
            286121442
        ],
        "F": [
            285868426,
            285875834,
            285881666,
            285895954,
            285888111,
            285886401,
            285885303,
            285891958,
            285893731,
            285892263,
            285879653,
            285886660,
            285891778,
            285886231,
            285896708,
            285895437,
            285887128,
            285901645,
            285898009,
            285911413,
            285909168
        ],
        "E": [
            285859957,
            285867757,
            285870223,
            285876387,
            285873807,
            285876494,
            285872556,
            285873708,
            285881956,
            285870423,
            285874469,
            285878077,
            285869033,
            285872685,
            285876656,
            285892958,
            285888168,
            285880850,
            285877703,
            285879472
        ],
        "C": [
            285855265,
            285848963,
            285851041,
            285855836,
            285849335,
            285851254,
            285854960,
            285854181,
            285864164,
            285852009,
            285850624,
            285853432,
            285850248,
            285850107,
            285852412,
            285937663,
            285937269,
            285852480,
            285853757,
            285856229,
            285852397,
            285853481
        ],
        "D": [
            285854273,
            285858071,
            285858183,
            285867921,
            285860641,
            285863810,
            285864716,
            285864881,
            285873876,
            285863514,
            285859817,
            285865001,
            285869981,
            285860140,
            285866304,
            285941352,
            285868260,
            285864450,
            285868121,
            285865847,
            285869499
        ],
        "B": [
            285844312,
            285844368,
            285843910,
            285848590,
            285844872,
            285845275,
            285846752,
            285845703,
            285858394,
            285844772,
            285844563,
            285847140,
            285845401,
            285845320,
            285848121,
            285848201,
            285847162,
            285850578,
            285846812,
            285847900
        ],
        "A": [
            285841954,
            285841960,
            285842031,
            285842286,
            285842224,
            285842066,
            285842261,
            285842191,
            285843710,
            285842044,
            285842146,
            285842134,
            285841991,
            285842021,
            285846906,
            285842091,
            285842126,
            285842764,
            285842102,
            285842266
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135173",
    "editorial": "Letâs fix the value of the first selected card . Then it is optimal to\r\ntake the cards as follows: take all cards with the number , then all\r\ncards with the number , ..., all cards with the number . If any of the\r\nintermediate numbers are not present in the deck, we stop\r\nimmediately.Letâs sort the array . Then the answer can be found as\r\nfollows. Start at some position and move to the right from it as long as\r\nthe following conditions are met: the difference between the next number\r\nand the current one does not exceed (otherwise, some number between them\r\noccurs times) and the difference between the next number and is strictly\r\nless than (otherwise, we will take more than different numbers).It is\r\neasy to notice that as increases, the position we reach through this\r\nprocess also increases. Therefore, we can use two pointers to solve the\r\nproblem. We will maintain a pointer to this position and update the\r\nanswer at each with the distance between and the pointer.Overall\r\ncomplexity: for each test case.\r\n",
    "name": "C. New Game",
    "statement": "There’s a new game Monocarp wants to play. The game uses a deck of n\r\ncards, where the i-th card has exactly one integer a_i written on it.At\r\nthe beginning of the game, on the first turn, Monocarp can take any card\r\nfrom the deck. During each subsequent turn, Monocarp can take exactly\r\none card that has either the same number as on the card taken on the\r\nprevious turn or a number that is one greater than the number on the\r\ncard taken on the previous turn.In other words, if on the previous turn\r\nMonocarp took a card with the number x, then on the current turn he can\r\ntake either a card with the number x or a card with the number x + 1.\r\nMonocarp can take any card which meets that condition, regardless of its\r\nposition in the deck.After Monocarp takes a card on the current turn, it\r\nis removed from the deck.According to the rules of the game, the number\r\nof distinct numbers written on the cards that Monocarp has taken must\r\nnot exceed k.If, after a turn, Monocarp cannot take a card without\r\nviolating the described rules, the game ends.Your task is to determine\r\nthe maximum number of cards that Monocarp can take from the deck during\r\nthe game, given that on the first turn he can take any card from the\r\ndeck.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; void solve() {    int n, k;    std::cin >> n >> k;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    std::sort(a.begin(), a.end());        int ans = 0;        for (int i = 0, j = 0; i < n; i++) {        j = std::max(j, i);        while (j + 1 < n && a[j + 1] <= a[j] + 1 && a[j + 1] < a[i] + k) {            j++;        }        ans = std::max(ans, j - i + 1);    }    std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. New Game.json",
    "hint": []
}