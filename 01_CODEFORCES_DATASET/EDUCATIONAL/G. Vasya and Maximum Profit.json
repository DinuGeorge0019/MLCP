{
    "link": "https://codeforces.com//contest/1107/problem/G",
    "problemId": "288740",
    "problem_idx": "G",
    "shortId": "1107G",
    "contest_number": "1107",
    "problem_submissions": {
        "E": [
            49013467,
            49008460,
            49012396,
            49006242,
            49008619,
            49017766,
            49019000,
            49012372,
            49011583,
            176420718,
            49013181,
            49015268,
            49018364,
            49014306,
            49015741,
            49004388,
            48997380,
            49015240,
            49002659,
            49009546,
            49008550
        ],
        "G": [
            49011365,
            49010194,
            49016397,
            49014169,
            49016073,
            49011313,
            49010209,
            49025351,
            49022889,
            49019588,
            49010516,
            49020197,
            49021008,
            49020053,
            49017813,
            49036704,
            49020211,
            49015481,
            49030126
        ],
        "F": [
            49008073,
            49012089,
            49021192,
            49015026,
            49017918,
            49019060,
            49366532,
            49825656,
            49825549,
            49021809
        ],
        "D": [
            48997651,
            49010674,
            49008906,
            49001237,
            49051114,
            49002152,
            49005979,
            49003643,
            49005670,
            49006757,
            49005502,
            49007559,
            49006488,
            49007684,
            49005318,
            49010907,
            49009162,
            49010914,
            49006671,
            49005756,
            49006449
        ],
        "C": [
            48994637,
            48998923,
            49003509,
            48997020,
            48998710,
            48997908,
            49002063,
            48998329,
            49002178,
            48999947,
            49000421,
            49004011,
            49003004,
            48998353,
            49007207,
            49005313,
            48999254,
            49018676,
            49000412,
            49000294
        ],
        "B": [
            48993730,
            48996062,
            48998013,
            48994172,
            48995232,
            48997773,
            48995013,
            48998484,
            48995876,
            48996083,
            48994456,
            48998645,
            48994729,
            48997378,
            49001444,
            48995542,
            49016049,
            48995486,
            48997049
        ],
        "A": [
            48993686,
            48993925,
            48994361,
            48993741,
            48994038,
            48994065,
            48994006,
            48996736,
            48994321,
            48994290,
            48993884,
            48994319,
            48994054,
            48994165,
            49000099,
            48993805,
            49017652,
            48993935,
            48993923
        ]
    },
    "name": "G. Vasya and Maximum Profit",
    "statement": "Vasya got really tired of these credits (from problem F) and now wants\r\nto earn the money himself! He decided to make a contest to gain a\r\nprofit.Vasya has n problems to choose from. They are numbered from 1 to\r\nn. The difficulty of the i-th problem is d_i. Moreover, the problems are\r\ngiven in the increasing order by their difficulties. . In order to add\r\nthe i-th problem to the contest you need to pay c_i burles to its\r\nauthor. For each problem in the contest Vasya gets a burles..So the\r\ntotal earnings for the contest are calculated as follows: if Vasya takes\r\nproblem i to the contest, he needs to pay c_i to its author; for each\r\nproblem in the contest Vasya gets a burles; let gap(l, r) =\r\nmax\r\nlimits_{l\r\nle i < r} (d_{i + 1} - d_i)^2. If Vasya takes all the tasks with indices\r\nfrom l to r to the contest, he also needs to pay gap(l, r). If l = r\r\nthen gap(l, r) = 0. Calculate the maximum profit that Vasya can earn by\r\ntaking a consecutive segment of tasks.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nstruct Data {\n    ll mp, ms;\n    ll sm;\n    ll ans;\n\n    Data(ll x = 0)\n        : mp(max(0ll, x))\n        , ms(max(0ll, x))\n        , sm(x)\n        , ans(max(0ll, x))\n    {\n    }\n};\n\nData mrg(Data l, Data r) {\n    Data res;\n    res.sm = l.sm + r.sm;\n    res.mp = max(l.mp, l.sm + r.mp);\n    res.ms = max(r.ms, l.ms + r.sm);\n    res.ans = max(max(l.ans, r.ans), l.ms + r.mp);\n    return res;\n}\n\nconst int MX = 300 * 1000 + 7;\nint p[MX], w[MX];\nData d[MX];\n\nll a[MX];\n\nint getp(int v) {\n    if (p[v] == -1) {\n        return v;\n    }\n    p[v] = getp(p[v]);\n    return p[v];\n}\n\nvoid join(int u, int v) {\n    u = getp(u);\n    v = getp(v);\n    assert(u != v);\n/*    if (w[u] < w[v]) {\n        swap(u, v);\n    } */\n    w[u] += w[v];\n    p[v] = u;\n    d[u] = mrg(d[u], d[v]);\n}\n\nll D[MX];\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n;\n    ll A;\n    cin >> n >> A;\n    ll ans = 0;\n    vector<pair<ll, int> > go;\n\n    for (int i = 0; i < n; i++) {\n        cin >> D[i];\n        cin >> a[i];\n        a[i] = A - a[i];\n        d[i] = Data(a[i]);\n        p[i] = -1;\n        ans = max(ans, a[i]);\n        if (i > 0) {\n            ll gap = (D[i] - D[i - 1]) * (D[i] - D[i - 1]);\n            go.emplace_back(gap, i);\n        }\n    }\n\n    sort(go.begin(), go.end());\n    for (const auto& [val, pos] : go) {\n        join(pos - 1, pos);\n        int v = getp(pos);\n        ans = max(ans, d[v].ans - val);\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "dp",
        "dsu"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Vasya and Maximum Profit.json",
    "editorial_link": "https://codeforces.com//blog/entry/64833",
    "editorial": "We can first compute all values of . Since we only care about the\r\nmaximum such value within our segment, we can use div-conquer to solve\r\nevery segment. In particular, if we know the index of the maximum value\r\nin , we know that any segment crossing this index has this value as its\r\nmaximum. We can thus solve all segments crossing this maximum and\r\nrecurse on the left and right sides. To find the best crossing segment,\r\nnote that each problem contributes a value of . We can independently\r\nfind the largest sum starting from our crossing index going left and the\r\nlargest sum going right, and add these two together for the best overall\r\ncrossing segment. Unfortunately, since we canât guarantee that the\r\nmaximum indices will divide our interval nicely in half, this does not\r\nlead to the usual runtime of div-conquer but is instead in the worst\r\ncase. To improve on this, we can precompute partial sums of and use RMQ\r\nto find the minimum sum left of the crossing index and the maximum sum\r\nright of the crossing index. This reduces the crossing computation from\r\nper index to or , giving an overall runtime of . Code: 49036431\r\n",
    "hint": [
        "Hint Just take care of 4 factors in a Node of the segment tree managing [l,r]: MAX, MAXSUMLEFT, MAXSUMRIGHT, SUM."
    ]
}