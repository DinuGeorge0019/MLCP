{
    "link": "https://codeforces.com//contest/1418/problem/G",
    "problemId": "727429",
    "problem_idx": "G",
    "shortId": "1418G",
    "contest_number": "1418",
    "problem_submissions": {
        "F": [
            92827621,
            92992766,
            92847130,
            92847007,
            92846498,
            92840659,
            92838710,
            92837329,
            92835778,
            92821703,
            92839298,
            92833921,
            92885700,
            92870799,
            92830172,
            92989347,
            92845726
        ],
        "G": [
            92817256,
            93890104,
            93890054,
            93890004,
            93889956,
            93889783,
            93889650,
            93889392,
            93889084,
            93888189,
            93888010,
            93887834,
            93887831,
            93887519,
            93887334,
            93887004,
            93839244,
            93839240,
            93839237,
            93835786,
            93835763,
            93835704,
            93828053,
            93828000,
            92855419,
            92854972,
            92815447,
            92815164,
            92824652,
            92823576,
            92837977,
            92824758,
            92885721,
            92823789,
            92823462,
            92820493,
            92830232,
            93485501,
            92866692,
            92833116,
            92832754,
            92824217,
            92833610,
            92830510,
            92833625,
            92828988,
            92837204,
            92830405,
            92834428
        ],
        "A": [
            92809737,
            92851684,
            92804370,
            92802575,
            92799307,
            92799729,
            92800647,
            92885635,
            92800218,
            92800425,
            92802031,
            92799884,
            92800952,
            92799036,
            92800270,
            92799895,
            92801328,
            92799861,
            92800242,
            92800050,
            92800040,
            92801512
        ],
        "D": [
            92806930,
            92847621,
            92803255,
            92806570,
            92812108,
            92817724,
            92809504,
            92885678,
            92808863,
            92812638,
            92810774,
            92842221,
            92815078,
            92815207,
            92817058,
            92813567,
            92813334,
            92817631,
            92827883,
            92813906,
            92816619,
            92816135,
            92820186
        ],
        "E": [
            92805758,
            92809090,
            92809687,
            92815513,
            92824046,
            92816662,
            92885694,
            92814615,
            92816908,
            92930467,
            92820677,
            92822734,
            92822919,
            92819310,
            92822831,
            92824275,
            92815296,
            92836469,
            92823732,
            92819866,
            92826009
        ],
        "C": [
            92798839,
            92798564,
            92801110,
            92802769,
            92810140,
            92803375,
            92885666,
            92803075,
            92805736,
            92801242,
            92805901,
            92804239,
            92807896,
            92805622,
            92804878,
            92809071,
            92805265,
            92806697,
            92803772,
            92811897,
            92812555
        ],
        "B": [
            92797501,
            92797816,
            92799405,
            92798968,
            92805443,
            92800263,
            92885648,
            92799516,
            92803590,
            92799029,
            92802282,
            92800352,
            92804945,
            92826085,
            92800306,
            92804932,
            92801700,
            92803543,
            92799506,
            92808871,
            92806614
        ]
    },
    "name": "G. Three Occurrences",
    "statement": "You are given an array a consisting of n integers. We denote the\r\nsubarray a[l..r] as the array [a_l, a_{l + 1},\r\ndots, a_r] (1\r\nle l\r\nle r\r\nle n).A subarray is considered if every integer that occurs in this\r\nsubarray occurs there . For example, the array [1, 2, 2, 2, 1, 1, 2, 2,\r\n2] has three good subarrays: a[1..6] = [1, 2, 2, 2, 1, 1]; a[2..4] = [2,\r\n2, 2]; a[7..9] = [2, 2, 2]. Calculate the number of good subarrays of\r\nthe given array a.\r\n",
    "solutions": [
        "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n//#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nconst int N=500005;\nint n,a[N],pre[N],lst[N];\nLL ans;\nint mn[N*4],cnt[N*4],tg[N*4];\nvoid upd(int k1){\n\tmn[k1]=min(mn[k1*2],mn[k1*2+1]);\n\tcnt[k1]=0;\n\tif(mn[k1]==mn[k1*2])cnt[k1]+=cnt[k1*2];\n\tif(mn[k1]==mn[k1*2+1])cnt[k1]+=cnt[k1*2+1];\n}\nvoid pst(int k1,int k2){\n\ttg[k1]+=k2,mn[k1]+=k2;\n}\nvoid psd(int k1){\n\tif(tg[k1]){\n\t\tpst(k1*2,tg[k1]);\n\t\tpst(k1*2+1,tg[k1]);\n\t\ttg[k1]=0;\n\t}\n}\nvoid bud(int k1,int k2,int k3){\n\tif(k2==k3){\n\t\tmn[k1]=N;\n\t\tcnt[k1]=1;\n\t\treturn;\n\t}\n\tint mid=(k2+k3)>>1;\n\tbud(k1*2,k2,mid),bud(k1*2+1,mid+1,k3);\n\tupd(k1);\n}\nvoid mdf(int k1,int k2,int k3,int k4,int k5,int k6){\n\tif(k2>k5||k3<k4)return;\n\tif(k4<=k2&&k3<=k5){\n\t\tpst(k1,k6);\n\t\treturn;\n\t}\n\tpsd(k1);\n\tint mid=(k2+k3)>>1;\n\tmdf(k1*2,k2,mid,k4,k5,k6),mdf(k1*2+1,mid+1,k3,k4,k5,k6);\n\tupd(k1);\n}\nsigned main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\trd(n);\n\trep(i,1,n){\n\t\trd(a[i]);\n\t\tpre[i]=lst[a[i]];\n\t\tlst[a[i]]=i;\n\t}\n\tbud(1,1,n);\n\trep(i,1,n){\n\t\tmdf(1,1,n,i,i,-N);\n\t\tint k1=pre[i];\n\t\tint k2=pre[k1];\n\t\tint k3=pre[k2];\n\t\tint k4=pre[k3];\n\t\tif(k1){\n\t\t\tmdf(1,1,n,1,k1,-1);\n\t\t}\n\t\tif(k3){\n\t\t\tmdf(1,1,n,k4+1,k3,1);\n\t\t}\n\t\tif(k2){\n\t\t\tmdf(1,1,n,k3+1,k2,-1);\n\t\t}\n\t\tmdf(1,1,n,1,i,1);\n\t\tif(mn[1]==0){\n\t\t\tans+=cnt[1];\n\t\t\tD(\"%d %d\\n\",i,cnt[1]);\n\t\t}\n\t}\n\tpt(ans,'\\n');\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "hashing",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Three Occurrences.json",
    "editorial_link": "https://codeforces.com//blog/entry/82673",
    "editorial": "Letâs consider two solutions: a non-deterministic and a deterministic\r\none.The random solution goes like that.Letâs assign a random integer to\r\neach value from to (to value, not to a position). Let the value of the\r\nsubarray be the trit-wise sum of the assigned integers of all values on\r\nit. Trit-wise is the analogue of bit-wise sum (xor) but in ternary\r\nsystem. So adding up the same integer three times trit-wise is always\r\nequal to zero. Thus, if the value on a subarray is zero then each value\r\nappears on it a multiple of three times. How to count the number of such\r\nsubarrays? Process the array from left to right and store the prefix\r\ntrit-wise sums in a map. The number of the valid subarrays that end in\r\nthe current position is the number of occurrences of the current prefix\r\ntrit-wise sum in a map. The current sum should be added to the map\r\nafterwards.However, thatâs not what the problem asks us to find. Letâs\r\nconsider another problem: count the number of subarray such that each\r\nnumber appears no more than three times. This can be done with two\r\npointers. Process the array from left to right and for each number store\r\nthe positions it occurred on. If some number appears at least four times\r\nthan the left pointer should be moved to the next position after the\r\nfourth-to-last position. The number of valid subarrays the end in the\r\ncurrent position is the distance to the left pointer.Letâs combine these\r\nproblems: maintain the pointer to only the valid positions and remove\r\nthe prefix trit-wise sums from the map as you increase the pointer. That\r\nway the map will only store the valid sums, and they can be added to\r\nanswer as they are.Assume you use trits. I guess the probability of the\r\ncollision is the same as two vectors (out of ) colliding in a\r\n-dimensional space with their coordinates being from to . That will be\r\nabout when (according to birthday paradox) and way less if we increase\r\n.Overall complexity: .The deterministic solution (a.k.a. the boring one)\r\ngoes like that.Letâs again process the array from left to right. Let the\r\ncurrent position be the right border of the segment. Each number makes\r\nsome constraints on where the left border might be. More specifically,\r\nitâs two possible segments: between its last occurrence and the current\r\nposition and between its fourth-to-last occurrence and its third-to-last\r\none. Letâs actually invert these segments. Bad segments are from the\r\nbeginning of the array to the fourth-to-last occurrence, then from the\r\nsecond-to-last occurrence to the last one. So the valid left borders are\r\nin such positions that are covered by zero bad segments.Letâs keep track\r\nof them in a segment tree. Add on the bad subarrays. Now you have to\r\ncount the number of values in a segtree. Thatâs a pretty common problem.\r\nAs we know that no values can go below , should be a minimum element on\r\nthe segment. So we can store a pair of (minimum on segment, number of\r\nminimums on segment). At the end the second value is the number of zeros\r\nif the first value is zero.Overall complexity: .\r\n",
    "hint": []
}