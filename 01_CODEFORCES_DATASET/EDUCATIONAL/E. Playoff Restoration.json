{
    "link": "https://codeforces.com//contest/1569/problem/E",
    "problemId": "1103183",
    "problem_idx": "E",
    "shortId": "1569E",
    "contest_number": "1569",
    "problem_submissions": {
        "F": [
            128266355,
            128271363,
            128276594,
            128274140,
            128277636,
            128276419,
            128239230,
            128386349,
            128320123
        ],
        "E": [
            128250268,
            128256767,
            128246439,
            128253452,
            128257933,
            128258504,
            128255293,
            128254536,
            128252116,
            128261192,
            128578023,
            128259291,
            128263798,
            128266969,
            128259594,
            128258410,
            128275140,
            128271709,
            128263862,
            128264259
        ],
        "D": [
            128235337,
            128235527,
            128231804,
            128235402,
            128242825,
            128262573,
            128235767,
            128236235,
            128236769,
            128233977,
            128578016,
            128240282,
            128241897,
            128232635,
            128238819,
            128243586,
            128233606,
            128230968,
            128243956,
            128245831
        ],
        "C": [
            128220989,
            128228983,
            128226656,
            128226748,
            128234279,
            128264995,
            128226270,
            128225854,
            128229844,
            128225694,
            128578004,
            128230030,
            128228479,
            128225884,
            128230468,
            128226610,
            128225551,
            128233122,
            128232240,
            128234418
        ],
        "B": [
            128217208,
            128223439,
            128220536,
            128221217,
            128228682,
            128267165,
            128220994,
            128220572,
            128221551,
            128221442,
            128577996,
            128221801,
            128220084,
            128221194,
            128224466,
            128232979,
            128220020,
            128224325,
            128224652,
            128224175
        ],
        "A": [
            128212769,
            128212941,
            128213029,
            128212974,
            128213857,
            128267874,
            128212779,
            128212821,
            128212915,
            128213233,
            128577977,
            128213929,
            128212944,
            128212794,
            128212959,
            128213921,
            128212839,
            128214062,
            128216496,
            128214843
        ]
    },
    "name": "E. Playoff Restoration",
    "statement": "2^k teams participate in a playoff tournament. The tournament consists\r\nof 2^k - 1 games. They are held as follows: first of all, the teams are\r\nsplit into pairs: team 1 plays against team 2, team 3 plays against team\r\n4 (exactly in this order), and so on (so, 2^{k-1} games are played in\r\nthat phase). When a team loses a game, it is eliminated, and each game\r\nresults in elimination of one team (there are no ties). After that, only\r\n2^{k-1} teams remain. If only one team remains, it is declared the\r\nchampion; otherwise, 2^{k-2} games are played: in the first one of them,\r\nthe winner of the game \"1 vs 2\" plays against the winner of the game \"3\r\nvs 4\", then the winner of the game \"5 vs 6\" plays against the winner of\r\nthe game \"7 vs 8\", and so on. This process repeats until only one team\r\nremains.After the tournament ends, the teams are assigned places\r\naccording to the tournament phase when they were eliminated. In\r\nparticular: the winner of the tournament gets place 1; the team\r\neliminated in the finals gets place 2; both teams eliminated in the\r\nsemifinals get place 3; all teams eliminated in the quarterfinals get\r\nplace 5; all teams eliminated in the 1/8 finals get place 9, and so on.\r\nFor example, this picture describes one of the possible ways the\r\ntournament can go with k = 3, and the resulting places of the teams:\r\nAfter a tournament which was conducted by the aforementioned rules\r\nended, its results were encoded in the following way. Let p_i be the\r\nplace of the i-th team in the tournament. The hash value of the\r\ntournament h is calculated as h = (\r\nsum\r\nlimits_{i=1}^{2^k} i\r\ncdot A^{p_i})\r\nbmod 998244353, where A is some given integer.Unfortunately, due to a\r\nsystem crash, almost all tournament-related data was lost. The only\r\npieces of data that remain are the values of k, A and h. You are asked\r\nto restore the resulting placing of the teams in the tournament, if it\r\nis possible at all.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 100001; \n\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid __print(mi X) {\n    cout << X.v;\n}\nint K;\nmi A, H;\nmi vals[6];\nint places[6];\n\n\nmap<int, map<mi, vi>> get(vi B) {\n    int nm = (1 << (K-1)) - 1;\n    map<int, map<mi, vi>> res;\n    F0R(m, 1 << nm) {\n        int p = 0;\n        int v = K;\n        vi cur; F0R(i, sz(B)) cur.pb(i);\n        vi place(sz(B));\n        mi value = 0;\n        while (sz(cur) > 1) {\n            vi nxt;\n            F0R(i, sz(cur) / 2) {\n                if (m & (1 << p)) {\n                    nxt.pb(cur[i*2]);\n                    place[cur[i*2+1]] = places[v];\n                    value += B[cur[i*2+1]] * vals[v];\n                } else {\n                    nxt.pb(cur[i*2+1]);\n                    place[cur[i*2]] = places[v];\n                    value += B[cur[i*2]] * vals[v];\n                }\n                p++;\n            }\n            cur = nxt;\n            v--;\n        }\n        place[cur[0]] = 2;\n        value += B[cur[0]] * vals[1];\n       /* vi tst = {5, 3, 5, 2};\n        if (place == tst) {\n            dbg(cur[0],value);\n        }*/\n        res[B[cur[0]]][value] = (place);\n    }\n    return res;\n}\n\nvoid solve() {\n    cin >> K >> A >> H;\n    vals[0] = A;\n    FOR(i, 1, 6) {\n        vals[i] = pow(mi(A), (pow(mi(2), i-1) +1).v);\n    }\n    places[0] = 1; places[1] = 2; places[2] = 3; places[3] = 5; places[4] = 9;\n    places[5] = 17;\n    vi A1, A2;\n    F0R(i, 1 << (K-1)) {\n        A1.pb(i+1);\n        A2.pb(i+1+(1<<(K-1)));\n    }\n\n    map<int, map<mi, vi>> res1 = get(A1), res2 = get(A2);\n    trav(a, res1) {\n        trav(b, res2) {\n            trav(x, a.s) {\n\n                mi cur1 = x.f + a.f * vals[0] - a.f * vals[1];\n                if (b.s.count(H-cur1)) {\n                    vi ans1 = x.s, ans2 = b.s[H-cur1];\n                    ans1[a.f-1] = 1;\n                    trav(c, ans1) cout << c << \" \";\n                    trav(c, ans2) cout << c << \" \";\n                    return;\n                }\n                mi cur2 = x.f + b.f * vals[0] - b.f * vals[1];\n                /*if (x.f.v == 706382488) {\n                    dbg(cur2);\n                }*/\n               if (b.s.count(H-cur2)) {\n                    vi ans1 = x.s, ans2 = b.s[H-cur2];\n                    ans2[b.f-(1 << (K-1))-1] = 1;\n                    trav(c, ans1) cout << c << \" \";\n                    trav(c, ans2) cout << c << \" \";\n                    return;\n                }\n            }\n        }\n    }\n\n    cout << -1 << nl;\n\n\n\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "hashing",
        "implementation",
        "meet-in-the-middle"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Playoff Restoration.json",
    "editorial_link": "https://codeforces.com//blog/entry/94721",
    "editorial": "There are exactly games in the tournament, each game has only two\r\npossible outcomes. So it\u00e2\u0080\u0099s possible to bruteforce all possible ways the\r\ntournament could go if is not large. In fact, this solution is fast\r\nenough when , so if we somehow can handle the case , we will have a\r\nworking solution.To handle , let\u00e2\u0080\u0099s divide the teams into two groups:\r\nteams from to and teams from to . There will be exactly matches in each\r\ngroup, and the winners of these two groups will play in the finals. The\r\nnumber of possible ways the games in a group can go is just , so let\u00e2\u0080\u0099s\r\ntry to bruteforce all possible results in each group and somehow \"merge\"\r\nthem into the results of the whole tournament.The main idea is to\r\nrewrite as , where , and , find all possible values for and , and choose\r\na pair of values that yields exactly the given value of .We will handle\r\ntwo separate cases: the winner of the first group wins the whole\r\ntournament, or the winner of the second group wins the whole tournament.\r\nSuppose we are handling the first case (the second is symmetrical). By\r\nchoosing the results of matches in the first group, we determine the\r\nplaces of the teams from the first group : the winner of the first group\r\ngets place , the team eliminated in the last match of the first group\r\ngets place , and so on. It means that by choosing one of the possible\r\nresults in the first group, we can calculate . Let\u00e2\u0080\u0099s bruteforce these\r\ncombinations of results in the first group and store them in some data\r\nstructure that allows to check whether some value of is achievable (in\r\nthe model solution, it\u00e2\u0080\u0099s a which maps reachable values of to\r\ncombinations of results that yield these values). Then, by choosing the\r\nresults of matches in the second group, we can calculate ; so the\r\nremaining part of the solution is to bruteforce all possible results in\r\nthe second group, calculate for them, and check that such that can be\r\nachieved by choosing the results in the first group. Don\u00e2\u0080\u0099t forget to\r\nalso handle the case when the team which wins in the first group loses\r\nin the finals (it is almost the same, but the winner in the first group\r\ngets place and the winner in the second group gets place ).The technique\r\nI\u00e2\u0080\u0099ve described here (instead of bruteforcing all possible variants,\r\nsplit the thing we try to bruteforce into two parts, bruteforce them\r\nseparatedly, and then try to \"merge\" the parts) is called and can be\r\nused to solve a large variety of problems.\r\n"
}