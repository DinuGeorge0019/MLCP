{
    "link": "https://codeforces.com//contest/1202/problem/B",
    "problemId": "385663",
    "problem_idx": "B",
    "shortId": "1202B",
    "contest_number": "1202",
    "problem_submissions": {
        "F": [
            58450924,
            58449423,
            58454352,
            58459803,
            58448615,
            58683759,
            58544660,
            58632018,
            58460608,
            58677253,
            59095272
        ],
        "E": [
            58446577,
            59548224,
            58440455,
            58449286,
            58475576,
            58455191,
            58455332,
            58449043,
            58451450,
            58448860,
            58450378,
            58451427,
            58451624,
            58451536,
            58451835,
            58443909,
            58451432,
            58452032,
            58454174,
            58451009,
            58452592,
            58451940
        ],
        "D": [
            58444092,
            58442549,
            58443962,
            58475546,
            58444450,
            58440999,
            58440440,
            58443368,
            58445508,
            58445716,
            58445057,
            58441174,
            58445333,
            58445907,
            58446487,
            58445052,
            58442732,
            58442650,
            58444867,
            58447384,
            58446089
        ],
        "C": [
            58441598,
            58452310,
            58442367,
            58475556,
            58442473,
            58439618,
            58446484,
            58442135,
            58443668,
            58443427,
            58442755,
            58446380,
            58443036,
            58443982,
            58455139,
            58441929,
            58447606,
            58446719,
            58443811,
            58445636,
            58448227
        ],
        "B": [
            58439444,
            58444513,
            58438813,
            58475511,
            58439503,
            58438262,
            58439422,
            58439559,
            58440663,
            58440425,
            58439072,
            58440288,
            58439823,
            58440365,
            58439836,
            58438293,
            58440655,
            58440555,
            58440058,
            58442143,
            58438995
        ],
        "A": [
            58438253,
            58437660,
            58437723,
            58475481,
            58437816,
            58437640,
            58437730,
            58437581,
            58437903,
            58437729,
            58437803,
            58437783,
            58437814,
            58438010,
            58438207,
            58437638,
            58439242,
            58437860,
            58437712,
            58437966,
            58440352
        ]
    },
    "name": "B. You Are Given a Decimal String...",
    "statement": "Suppose you have a special x-y-counter. This counter can store some\r\nvalue as a decimal number; at first, the counter has value 0. The\r\ncounter performs the following algorithm: it prints its lowest digit\r\nand, after that, adds either x or y to its value. So all sequences this\r\ncounter generates are starting from 0. For example, a 4-2-counter can\r\nact as follows: it prints 0, and adds 4 to its value, so the current\r\nvalue is 4, and the output is 0; it prints 4, and adds 4 to its value,\r\nso the current value is 8, and the output is 04; it prints 8, and adds 4\r\nto its value, so the current value is 12, and the output is 048; it\r\nprints 2, and adds 2 to its value, so the current value is 14, and the\r\noutput is 0482; it prints 4, and adds 4 to its value, so the current\r\nvalue is 18, and the output is 04824. This is only one of the possible\r\noutputs; for example, the same counter could generate 0246802468024 as\r\nthe output, if we chose to add 2 during each step.You wrote down a\r\nprinted sequence from one of such x-y-counters. But the sequence was\r\ncorrupted and several elements from the sequence could be erased.Now\r\nyou\u2019d like to recover data you\u2019ve lost, but you don\u2019t even know the type\r\nof the counter you used. You have a decimal string s the remaining data\r\nof the sequence. For all 0\r\nle x, y < 10, calculate the minimum number of digits you have to insert\r\nin the string s to make it a possible output of the x-y-counter. Note\r\nthat you can\u2019t change the order of digits in string s or erase any of\r\nthem; only insertions are allowed.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=2012345678;\nlong long dist[10][10];\nchar b[2010101];\nint main(){\n\tscanf(\"%s\",b);\n\tint n=strlen(b);\n\tfor(int x=0;x<10;x++)for(int y=0;y<10;y++){\n\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)dist[i][j]=inf;\n\t\tfor(int i=0;i<10;i++)dist[i][(i+x)%10]=dist[i][(i+y)%10]=1;\n\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)for(int k=0;k<10;k++){\n\t\t\tdist[j][k]=min(dist[j][k],dist[j][i]+dist[i][k]);\n\t\t}\n\t\t//for(int i=0;i<10;i++)for(int j=0;j<10;j++)printf(\"%d %d %d %d %d\\n\",x,y,i,j,dist[i][j]);\n\t\tbool bad=false;\n\t\tlong long ans=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint s=b[i]-'0',e=b[i+1]-'0';\n\t\t\tif(dist[s][e]==inf){\n\t\t\t\tbad=true;break;\n\t\t\t}\n\t\t\tans+=dist[s][e]-1;\n\t\t}\n\t\tprintf(\"%lld \",bad?-1LL:ans);\n\t\tif(y==9)puts(\"\");\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. You Are Given a Decimal String....json",
    "editorial_link": "https://codeforces.com/blog/entry/68972",
    "editorial": "All you need to know to solve this task is the minimal number of steps\r\nto move from any digit to any digit for fixed and (let\u00e2\u0080\u0099s denote it as ).\r\nShortest path? BFS? Floyd? Of course, you can use it, but you can think\r\na little harder and save nerves and time.Since order of choosing\r\noperations and doesn\u00e2\u0080\u0099t matter for transferring from to , so only number\r\nof -s and -s are matter. Let\u00e2\u0080\u0099s denote them as and . Since adding any\r\nfixed value times are meaningless, so .Now you can, for each , for each\r\n, for each iterate over all possible and . Digit you\u00e2\u0080\u0099d move to is equal\r\nto . Just relax value of by .Now you can, for each and , calculate the\r\nanswer by iterating over string by summing (number of inserted values is\r\nless by one than number of steps).But, it will work only in C++, since\r\nthe language is fast and basic operations are executed in less than 0.5\r\nsecond. But the model solution is written in Kotlin. How is it? The\r\nstring can be long, but there are only different neighbouring digits, so\r\nyou can just one time precalculate the number of such that and . And\r\ncalculate the answer not by iterating over but by multiplying by .The\r\nresult complexity is , where . But will pass on fast languages like\r\nC++.P.S.: There are no real problem with I/O both Python and Kotlin read\r\none string up to in less than 0.5 seconds.\r\n"
}