{
    "link": "https://codeforces.com//contest/2025/problem/G",
    "problemId": "2948777",
    "problem_idx": "G",
    "shortId": "2025G",
    "contest_number": "2025",
    "problem_submissions": {
        "G": [
            285888128,
            285968165,
            285968156,
            285968149,
            285968144,
            285897832,
            285920810,
            285910851,
            285909011,
            285930826,
            285929850,
            285925790,
            285926690,
            285922742,
            285921341,
            285927635,
            285927533,
            285927378,
            285927290,
            285927201,
            285926718,
            285927241,
            285924989,
            299831833,
            286121442
        ],
        "F": [
            285868426,
            285875834,
            285881666,
            285895954,
            285888111,
            285886401,
            285885303,
            285891958,
            285893731,
            285892263,
            285879653,
            285886660,
            285891778,
            285886231,
            285896708,
            285895437,
            285887128,
            285901645,
            285898009,
            285911413,
            285909168
        ],
        "E": [
            285859957,
            285867757,
            285870223,
            285876387,
            285873807,
            285876494,
            285872556,
            285873708,
            285881956,
            285870423,
            285874469,
            285878077,
            285869033,
            285872685,
            285876656,
            285892958,
            285888168,
            285880850,
            285877703,
            285879472
        ],
        "C": [
            285855265,
            285848963,
            285851041,
            285855836,
            285849335,
            285851254,
            285854960,
            285854181,
            285864164,
            285852009,
            285850624,
            285853432,
            285850248,
            285850107,
            285852412,
            285937663,
            285937269,
            285852480,
            285853757,
            285856229,
            285852397,
            285853481
        ],
        "D": [
            285854273,
            285858071,
            285858183,
            285867921,
            285860641,
            285863810,
            285864716,
            285864881,
            285873876,
            285863514,
            285859817,
            285865001,
            285869981,
            285860140,
            285866304,
            285941352,
            285868260,
            285864450,
            285868121,
            285865847,
            285869499
        ],
        "B": [
            285844312,
            285844368,
            285843910,
            285848590,
            285844872,
            285845275,
            285846752,
            285845703,
            285858394,
            285844772,
            285844563,
            285847140,
            285845401,
            285845320,
            285848121,
            285848201,
            285847162,
            285850578,
            285846812,
            285847900
        ],
        "A": [
            285841954,
            285841960,
            285842031,
            285842286,
            285842224,
            285842066,
            285842261,
            285842191,
            285843710,
            285842044,
            285842146,
            285842134,
            285841991,
            285842021,
            285846906,
            285842091,
            285842126,
            285842764,
            285842102,
            285842266
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135173",
    "editorial": "Let\u00e2\u0080\u0099s start unraveling the solution from the end. Suppose we currently\r\nhave heroes with health and artifacts with durability . Let\u00e2\u0080\u0099s assume we\r\nhave already distributed the artifacts to the heroes, forming pairs . If\r\n, we will discard the excess artifacts with the lowest durability. If ,\r\nwe will add the artifacts with durability (that will deactivate at the\r\nstart).How many rounds will the battle last? Notice the following: a\r\nhero with health and an artifact with durability can be replaced with\r\ntwo heroes with health and , respectively, and the answer will not\r\nchange.Thus, it is sufficient to analyze the case when there are no\r\nartifacts, and there are only heroes with health . The idea is as\r\nfollows: in each round, the heroes take exactly point of damage in\r\ntotal. Therefore, the battle will last rounds. The first sum is easy to\r\nmaintain let\u00e2\u0080\u0099s focus on the second one.Next, we need to learn how to\r\ndistribute the artifacts in such a way that maximizes this sum.\r\nIntuitively, it seems that the healthiest heroes should receive the most\r\ndurable artifacts. That is, we should sort the heroes in descending\r\norder of health and the artifacts in descending order of durability.We\r\nwill show that this is indeed the case. Suppose there are two heroes\r\nwith health and (). They receive artifacts with durability and (). We\r\nwill show that it is optimal to give the first artifact to the first\r\nhero and the second one to the second hero. If there is at least one\r\nartifact with durability not greater than (that is, the minimum will\r\nalways be equal to this artifact), it is always optimal to give it to\r\nthe second hero and the other artifact to the first hero. If there is at\r\nleast one artifact with durability not less than (that is, the minimum\r\nwill always be equal to the hero), it is always optimal to give it to\r\nthe first hero. Otherwise, the durabilities of the artifacts lie between\r\nthe health values of the heroes, meaning that the minimum for the first\r\nhero will always be equal to his artifact, and the minimum for the\r\nsecond hero will be his health. Therefore, it is again optimal to give\r\nthe larger artifact to the first hero. It follows that if for a pair of\r\nheroes the condition that the larger hero has the larger artifact is not\r\nmet, we can swap their artifacts, and the answer will not decrease.Thus,\r\nthe task is as follows. After each query, we need to maintain a sorted\r\nsequence of heroes, artifacts, and the sum . This sounds quite\r\ncomplicated because there are a lot of changes with each query. Some\r\nsuffix of one of the arrays shifts one position to the right after\r\ninserting a new element, affecting many terms.Let\u00e2\u0080\u0099s consider an idea of\r\na sweep line instead. We will combine the heroes and artifacts into one\r\narray and sort it in descending order. For simplicity, let\u00e2\u0080\u0099s assume all\r\ndurability and health values are distinct integers. Then we will iterate\r\nover this array while maintaining the number of heroes who have not yet\r\nreceived an artifact and the number of artifacts that have not been\r\nassigned to a hero. If we encounter an artifact and there are previously\r\nencountered heroes who have not received an artifact, we will give this\r\nartifact to any of them. Since all these heroes have health greater than\r\nthe durability of this artifact, the minimum will always be equal to the\r\ndurability of the artifact. Thus, the sum will increase by the\r\ndurability of the artifact. Otherwise, we will remember that there is\r\none more free artifact. The same goes for a hero. If we encounter a hero\r\nand there are previously encountered artifacts that have not been\r\nassigned to a hero, we will give any of these artifacts to the hero. The\r\nsum will then increase by the hero\u00e2\u0080\u0099s health.It can be shown that this\r\nprocess of assigning artifacts yields the same result as sorting.Note\r\nthat at any moment of time, there are either no free heroes or no free\r\nartifacts. Thus, it is sufficient to maintain a \"balance\" the difference\r\nbetween the number of heroes and artifacts on the prefix. If the balance\r\nis positive, and we encounter an artifact, we add its durability to the\r\nanswer. If the balance is negative, and we encounter a hero, we add his\r\nhealth to the answer.Note that equal elements do not break this\r\nalgorithm. For simplicity, I suggest sorting not just the values but\r\npairs of values and query indices to maintain a strict order.How does\r\nthis reduction help? It turns out that it is now possible to use square\r\nroot decomposition to solve the problem.Read all queries in advance and\r\nsort them by the value in descending order. We will divide all queries\r\ninto blocks of size . Initially, all queries are deactivated. When\r\nprocessing the next query in the input order, we will activate it within\r\nthe block and recalculate the entire block.What should we store for each\r\nblock? Notice that all balance checks for the terms depend on two\r\nvalues: the balance at the start of the block and the balance before\r\nthis term within the block. Therefore, for the block, we can maintain\r\nthe following values: the total balance in the block, as well as the\r\ntotal contribution of the terms from this block for each balance at the\r\nstart of the block. Obviously, the balance at the start of the block can\r\nrange from to . However, if the absolute value of the balance exceeds ,\r\nthe contribution of the block will be the same as if this balance was\r\nlimited by or , respectively (since within the block it will either\r\nalways be positive or always negative). Thus, it is sufficient to\r\ncalculate the answer only for balances from to .Knowing these values for\r\neach block, the answer can be calculated in . We will go through the\r\nblocks while maintaining the current balance. We will add the block\u00e2\u0080\u0099s\r\ncontribution for the current balance to the answer and add the total\r\nbalance of the block to the current balance.We still need to learn how\r\nto quickly recalculate the answers for all balances within the block. We\r\nwill iterate over the elements within the block while maintaining the\r\ncurrent balance inside the block. Let the balance be . Then if the\r\ncurrent element is an artifact, its durability will be added to the sum\r\nif the balance at the start of the block is at least . Similarly, if the\r\ncurrent element is a hero, his health will be added if the balance at\r\nthe start of the block is at most . Thus, we need to add a value over\r\nsome range of balances either from to , or from to . This can be done\r\nusing a difference array. That is, we can make two updates in for each\r\nelement of the block, and then compute the prefix sum once in\r\n.Therefore, for each query, we can update the structure in , and\r\nrecalculate the sum in . Hence, it is optimal to choose .Overall\r\ncomplexity: .\r\n",
    "name": "G. Variable Damage",
    "statement": "Monocarp is gathering an army to fight a dragon in a videogame.The army\r\nconsists of two parts: the heroes and the defensive artifacts. Each hero\r\nhas one parameter his health. Each defensive artifact also has one\r\nparameter its durability.Before the battle begins, Monocarp distributes\r\nartifacts to the heroes so that each hero receives at most one\r\nartifact.The battle consists of rounds that proceed as follows: first,\r\nthe dragon deals damage equal to\r\nfrac{1}{a + b} () to each hero, where a is the number of heroes alive\r\nand b is the number of active artifacts; after that, all heroes with\r\nhealth 0 or less die; finally, some artifacts are deactivated. An\r\nartifact with durability x is deactivated when one of the following\r\noccurs: the hero holding the artifact either dies or receives x total\r\ndamage (from the start of the battle). If an artifact is not held by any\r\nhero, it is inactive from the beginning of the battle. The battle ends\r\nwhen there are no heroes left alive.Initially, the army is empty. There\r\nare q queries: add a hero with health x or an artifact with durability y\r\nto the army. After each query, determine the maximum number of rounds\r\nthat Monocarp can survive if he distributes the artifacts optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int q;    std::cin >> q;        const int B = std::sqrt(q);        std::vector<int> t(q), v(q);    for (int i = 0; i < q; i++) {        std::cin >> t[i] >> v[i];    }        auto vs = v;    std::sort(vs.begin(), vs.end());    std::vector<int> ord(q);    std::iota(ord.begin(), ord.end(), 0);    std::sort(ord.begin(), ord.end(),        [&](int i, int j) {            return v[i] < v[j];        });        std::vector<int> d(q);    d[0] = vs[0];    for (int i = 1; i < q; i++) {        d[i] = vs[i] - vs[i - 1];    }        i64 sum = 0;        for (int i = 0; i < q; i++) {        v[ord[i]] = i;    }        std::vector<int> u(q);        int nb = (q + B - 1) / B;    std::vector<int> ad(nb);    std::vector<int> mx(nb), len(nb);    for (int i = 0; i < q; i++) {        len[i / B] += d[i];    }    std::vector f(nb, std::vector<i64>(B));    for (int b = 0; b < nb; b++) {        for (int i = 0; i < B; i++) {            f[b][i] = 1LL * i * len[b];        }    }        auto build = [&](int b) {        int l = b * B, r = std::min(q, l + B);        mx[b] = -1E9;        for (int i = l; i < r; i++) {            u[i] += ad[b];            mx[b] = std::max(mx[b], u[i]);        }        ad[b] = 0;        std::fill(f[b].begin(), f[b].end(), 0);        for (int i = l; i < r; i++) {            int v = mx[b] - u[i];            if (v + 1 < B) {                f[b][v + 1] += d[i];            }        }        for (int i = 1; i < B; i++) {            f[b][i] += f[b][i - 1];        }        for (int i = 1; i < B; i++) {            f[b][i] += f[b][i - 1];        }    };        i64 res = 0;    auto calc = [&](int b, int c) {        if (mx[b] > 0) {            if (mx[b] < B) {                res += c * f[b][mx[b]];            } else {                res += c * (f[b][B - 1] + 1LL * len[b] * (mx[b] - B + 1));            }        }    };    auto add = [&](int b, int c) {        ad[b] += c;        mx[b] += c;    };        for (int i = 0; i < q; i++) {        if (t[i] == 1) {            sum += vs[v[i]];        }        int b = v[i] / B;        int c = t[i] == 1 ? 1 : -1;        for (int j = 0; j < b; j++) {            calc(j, -1);            add(j, c);            calc(j, 1);        }        calc(b, -1);        for (int j = b * B; j <= v[i]; j++) {            u[j] += c;        }        build(b);        calc(b, 1);                std::cout << 2 * sum - res << \"\\n\";    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "flows"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Variable Damage.json"
}