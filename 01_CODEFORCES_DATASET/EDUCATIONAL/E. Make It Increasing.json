{
    "link": "https://codeforces.com//contest/1437/problem/E",
    "problemId": "775843",
    "problem_idx": "E",
    "shortId": "1437E",
    "contest_number": "1437",
    "problem_submissions": {
        "G": [
            96904215,
            96908358,
            96911556,
            96933769,
            96933754,
            96933518,
            96933473,
            96933445,
            96933414,
            96933394,
            96933374,
            96932455,
            96904310,
            96918769,
            96918726,
            96918674,
            96918569,
            96915736,
            96908201,
            96875131,
            106175814,
            96910852,
            96987761,
            96907141,
            96934887
        ],
        "F": [
            96888983,
            96900781,
            96907021,
            96914548,
            96914009,
            96904550,
            96923575,
            96889382,
            96917076,
            96892031,
            96900189,
            96901851,
            96912014,
            96916841,
            96913488,
            97559818,
            96910656
        ],
        "E": [
            96880914,
            96882404,
            96885840,
            96932444,
            96885328,
            96892490,
            96890860,
            96896271,
            96896163,
            96888156,
            96885346,
            96887072,
            96892577,
            96896957,
            96895240,
            96898636,
            97559735,
            96897006
        ],
        "D": [
            96875179,
            96877608,
            96875178,
            96880944,
            96885771,
            96877805,
            96898190,
            96885975,
            96876295,
            96879122,
            96877985,
            96883085,
            96879709,
            96879615,
            96881903,
            97558972,
            96886384
        ],
        "C": [
            96871849,
            96873242,
            96871401,
            96937777,
            96917473,
            96874581,
            96876847,
            96873952,
            96902915,
            96882435,
            96874057,
            96876339,
            96874008,
            96878071,
            96874148,
            96873187,
            96875974,
            97558809,
            96872333
        ],
        "B": [
            96868094,
            96870116,
            96868044,
            96871520,
            96869439,
            96870069,
            96905187,
            96921093,
            96871936,
            96870828,
            96870841,
            96868971,
            96868275,
            96868652,
            96869849,
            97558720,
            96868938
        ],
        "A": [
            96867417,
            96867598,
            96867496,
            96867654,
            96867506,
            96867568,
            96906923,
            96868396,
            96867566,
            96869874,
            96869082,
            96867617,
            96867510,
            96867621,
            96867703,
            97558428,
            96867545
        ]
    },
    "name": "E. Make It Increasing",
    "statement": "You are given an array of n integers a_1, a_2, ..., a_n, and a set b of\r\nk distinct integers from 1 to n.In one operation, you may choose two\r\nintegers i and x (1\r\nle i\r\nle n, x can be any integer) and assign a_i := x. This operation can be\r\ndone only if i does not belong to the set b.Calculate the minimum number\r\nof operations you should perform so the array a is increasing (that is,\r\na_1 < a_2 < a_3 <\r\ndots < a_n), or report that it is impossible.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int INF = (int)1e9 + (int)1e8;\nconst int N = 500500;\nint a[N];\nint c[N];\nint n;\n\nint solve(int L, int R) {\n\t/*\n\teprintf(\"solve\\n\");\n\tfor (int i = L; i <= R; i++)\n\t\teprintf(\"%d \", a[i]);\n\teprintf(\"\\n\");\n\t*/\n\tif (a[L] > a[R]) return N;\n\tint len = R - L;\n\tfor (int i = 0; i < len; i++)\n\t\tc[i] = INF;\n\tc[0] = 0;\n\tfor (int i = L + 1; i < R; i++) {\n\t\tif (a[i] < a[L] || a[i] > a[R]) continue;\n\t\tint p = upper_bound(c, c + len, a[i]) - c;\n\t\tc[p] = a[i];\n\t}\n\tint ans = len - 1;\n\twhile(c[ans] == INF) ans--;\n\treturn len - 1 - ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i] += n - i;\n\t}\n\ta[0] = 0;\n\ta[n + 1] = INF - 2;\n\tn += 2;\n\tint ans = 0;\n\tint lst = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tans += solve(lst, x);\n\t\tif (ans >= N) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlst = x;\n\t}\n\tans += solve(lst, n - 1);\n\tif (ans >= N) {\n\t\tprintf(\"-1\\n\");\n\t} else {\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "dp",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Make It Increasing.json",
    "editorial_link": "https://codeforces.com//blog/entry/84149",
    "editorial": "First, letâs solve the problem without blocked positions.Letâs look at\r\nthe array . Obviously, if strictly increases, then does not decrease,\r\nand vice versa. Now we have to find the maximum number of positions in\r\nthe array that can be left unchanged. And you can always choose an\r\ninteger that will not break the non-decreasing array for the rest of\r\npositions. This problem can be solved in by analogy with the largest\r\nincreasing subsequence, but now you can take equal elements.Now you can\r\nrealize that the segments between two blocked positions do not depend on\r\neach other, and the initial problem can be solved as the problem\r\ndescribed above. All that remains is to check that all blocked positions\r\ndo not break the strict array increment.\r\n",
    "hint": []
}