{
    "link": "https://codeforces.com//contest/1976/problem/E",
    "problemId": "2672921",
    "problem_idx": "E",
    "shortId": "1976E",
    "contest_number": "1976",
    "problem_submissions": {
        "F": [
            263314410,
            263323534,
            263323690,
            263325512,
            263334653,
            263331007,
            263325411,
            263343899,
            263340351,
            263335929,
            263326828,
            263332991,
            263341073,
            263348258,
            263349127,
            263349457,
            263346381,
            263355969,
            263347175,
            263342030
        ],
        "E": [
            263305882,
            263313991,
            263310881,
            263312246,
            263315063,
            263311135,
            263313445,
            263315175,
            263343942,
            263328216,
            263320417,
            263320641,
            263323277,
            263324951,
            263331673,
            263329104,
            263324699,
            263325555,
            263316314,
            263328040,
            263331822
        ],
        "C": [
            263292519,
            263287752,
            263288751,
            263286876,
            263284054,
            263285532,
            263285507,
            263293215,
            263285305,
            263285884,
            263286170,
            263285744,
            263298002,
            263303206,
            263289650,
            263291396,
            263291844,
            263302664,
            263303154,
            263303039,
            263301515
        ],
        "D": [
            263292311,
            263298587,
            263366307,
            263299064,
            263295271,
            263295241,
            263295262,
            263303840,
            263298130,
            263292787,
            263298290,
            263306115,
            263312088,
            263291555,
            263300847,
            263305912,
            263364926,
            263302707,
            263310976,
            263298729,
            263311543,
            263313366
        ],
        "B": [
            263272017,
            263272271,
            263275878,
            263272612,
            263272889,
            263274173,
            263277739,
            263274170,
            263273861,
            263276359,
            263274099,
            263279892,
            263280435,
            263273730,
            263275861,
            263277331,
            263275586,
            263274544,
            263272648,
            263279232
        ],
        "A": [
            263268782,
            263268834,
            263269741,
            263268999,
            263269168,
            263269203,
            263269867,
            263269889,
            263269156,
            263268775,
            263269596,
            263270510,
            263268758,
            263268826,
            263268756,
            263270814,
            263269912,
            263269509,
            263268983,
            263270469
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129992",
    "editorial": "First, let\u00e2\u0080\u0099s deal with the case . In this case, after all operations are\r\nperformed, all arrays have only one element each, and can no longer be\r\nsplit. We can show that the initial order of elements can be restored\r\nuniquely in this case. For example, we can start with arrays consisting\r\nof single elements (one array for each integer from to ), and \"undo\" the\r\noperations to restore the initial order. \"Undoing\" the operations means\r\nlinking two arrays together, and we don\u00e2\u0080\u0099t have any choice which arrays\r\nand in which order we link, so the result of each operation is uniquely\r\ndetermined. So, in the case , the answer is .What about the case ? Let\u00e2\u0080\u0099s\r\ndivide all integers from to into two groups: the integers from the\r\nsequences and/or , and all other integers. We can use the same process\r\nto show that the order of elements from the first group (the ones which\r\nwere present in at least one of the given sequences) is unique, and we\r\ncan restore their order using something like DSU (performing operations\r\nfrom the last to the first) or a double-linked list (performing\r\noperations from the first to the last).So, suppose we restored the order\r\nof elements which are present in the input; we need to insert all of the\r\nremaining integers and don\u00e2\u0080\u0099t make the sequence of operations invalid. We\r\nhave an array of elements, the order of which is fixed; and there are\r\n\"buckets\" where we can insert the remaining elements (before the first\r\nelement, between the first and the second, and so on).For each of these\r\n\"buckets\", let\u00e2\u0080\u0099s consider the maximum between the elements on the\r\nborders of the bucket (the fixed elements between which we insert the\r\nremaining elements). It\u00e2\u0080\u0099s quite easy to see that each element we insert\r\nin a \"bucket\" should be less than this maximum: suppose the fixed\r\nelement on the left border is , the fixed element on the right border is\r\n, and there was an element between them. After we performed all\r\noperations, is either in the same array as or in the same array as ; so\r\nwhen we \"made\" that array during an operation, we would have written the\r\ninteger (or some even greater integer) instead of or .And we can also\r\nshow the opposite: if each element in each \"bucket\" is less than the\r\nmaximum of the two elements bordering the bucket, the operation sequence\r\nis valid. To prove it, let\u00e2\u0080\u0099s merge every bucket with the greater of the\r\nelements on its borders, and then again \"undo\" all operations to restore\r\nthe original order of elements.So, for each remaining element, there are\r\nsome buckets where we can put it, and some buckets where we can\u00e2\u0080\u0099t.\r\nHowever, we also have to consider the relative order of the elements we\r\ninsert in the same bucket.Let\u00e2\u0080\u0099s start with the sequence of \"fixed\"\r\nelements, and insert the remaining elements one by one from the greatest\r\ninteger to the smallest integer. We can show that every time we insert\r\nan element in this order, the number of places where it can go does not\r\ndepend on where we inserted the previous elements. Suppose we insert an\r\nelement which \"fits\" into buckets, and before inserting it, we also\r\ninserted other elements. Then there are exactly places where this\r\nelement can fit, because every element we inserted earlier went into one\r\nof those same buckets and split that bucket into two. So, maintaining\r\nthese two numbers (the number of available buckets and the number of\r\nelements we already inserted) is enough, and the positions of elements\r\nwe inserted does not matter.This allows us to count the number of\r\npossible permutations in .\r\n",
    "name": "E. Splittable Permutations",
    "statement": "Initially, we had one array, which was a permutation of size n (an array\r\nof size n where each integer from 1 to n appears exactly once).We\r\nperformed q operations. During the i-th operation, we did the following:\r\nchoose any array we have with at least 2 elements; split it into two\r\nnon-empty arrays (prefix and suffix); write two integers l_i and r_i,\r\nwhere l_i is the maximum element in the left part which we get after the\r\nsplit, and r_i is the maximum element in the right part; remove the\r\narray we\u2019ve chosen from the pool of arrays we can use, and add the two\r\nresulting parts into the pool. For example, suppose the initial array\r\nwas [6, 3, 4, 1, 2, 5], and we performed the following operations:\r\nchoose the array [6, 3, 4, 1, 2, 5] and split it into [6, 3] and [4, 1,\r\n2, 5]. Then we write l_1 = 6 and r_1 = 5, and the arrays we have are [6,\r\n3] and [4, 1, 2, 5]; choose the array [4, 1, 2, 5] and split it into [4,\r\n1, 2] and [5]. Then we write l_2 = 4 and r_2 = 5, and the arrays we have\r\nare [6, 3], [4, 1, 2] and [5]; choose the array [4, 1, 2] and split it\r\ninto [4] and [1, 2]. Then we write l_3 = 4 and r_3 = 2, and the arrays\r\nwe have are [6, 3], [4], [1, 2] and [5]. You are given two integers n\r\nand q, and two sequences [l_1, l_2,\r\ndots, l_q] and [r_1, r_2,\r\ndots, r_q]. A permutation of size n is called if we can perform q\r\noperations and produce the given sequences [l_1, l_2,\r\ndots, l_q] and [r_1, r_2,\r\ndots, r_q].Calculate the number of valid permutations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;template<class T>constexpr T power(T a, i64 b) {    T res {1};    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;}\u00a0constexpr i64 mul(i64 a, i64 b, i64 p) {    i64 res = a * b - i64(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;}\u00a0template<i64 P>struct MInt {    i64 x;    constexpr MInt() : x {0} {}    constexpr MInt(i64 x) : x {norm(x % getMod())} {}        static i64 Mod;    constexpr static i64 getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(i64 Mod_) {        Mod = Mod_;    }    constexpr i64 norm(i64 x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr i64 val() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        if (getMod() < (1ULL << 31)) {            x = x * rhs.x % int(getMod());        } else {            x = mul(x, rhs.x, getMod());        }        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        i64 v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }    friend constexpr bool operator<(MInt lhs, MInt rhs) {        return lhs.val() < rhs.val();    }};\u00a0template<>i64 MInt<0>::Mod = 998244353;\u00a0constexpr int P = 998244353;using Z = MInt<P>;\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, q;    std::cin >> n >> q;        std::vector<int> l(q), r(q);    for (int i = 0; i < q; i++) {        std::cin >> l[i];    }    for (int i = 0; i < q; i++) {        std::cin >> r[i];    }        std::vector<int> L(n + 2), R(n + 2);    R[0] = n;    L[n] = 0;    R[n] = n + 1;    L[n + 1] = n;        for (int i = 0; i < q; i++) {        int a = l[i], b = r[i];        if (a > b) {            R[b] = R[a];            L[R[b]] = b;            R[a] = b;            L[b] = a;        } else {            L[a] = L[b];            R[L[a]] = a;            L[b] = a;            R[a] = b;        }    }        std::vector<int> a;    for (int i = R[0]; i != n + 1; i = R[i]) {        a.push_back(i);    }        std::vector<int> cnt(n + 1), v(n + 1);    for (auto x : a) {        v[x] = 1;    }    cnt[a[0]]++;    for (int i = 1; i < a.size(); i++) {        cnt[std::max(a[i - 1], a[i])]++;    }    cnt[a.back()]++;        Z ans = 1;    Z cur = 0;    for (int i = n; i >= 1; i--) {        if (!v[i]) {            ans *= cur;            cur += 1;        }        cur += cnt[i];    }    std::cout << ans << \"\\n\";        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dfs and similar",
        "greedy",
        "math",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Splittable Permutations.json"
}