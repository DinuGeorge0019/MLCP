{
    "link": "https://codeforces.com//contest/2026/problem/E",
    "problemId": "2985132",
    "problem_idx": "E",
    "shortId": "2026E",
    "contest_number": "2026",
    "problem_submissions": {
        "F": [
            288561266,
            289460762,
            288610204,
            288597833,
            288597166,
            288569834,
            288622486,
            288654341,
            288862318,
            289435066
        ],
        "E": [
            288532750,
            288648436,
            289460758,
            288538098,
            288522785,
            288536060,
            288547433,
            288544648,
            288565205,
            288561153,
            288562514,
            288560885,
            288560234,
            288562220,
            288569450,
            288563732,
            288565049,
            288562236,
            288561108,
            288565165,
            288569967
        ],
        "C": [
            288529378,
            288523247,
            288587507,
            288523790,
            288525729,
            288530332,
            288531829,
            288528175,
            288530132,
            288533395,
            288532265,
            288535389,
            288532312,
            288535104,
            288538148,
            288539384,
            288557011,
            288540483,
            288538281
        ],
        "D": [
            288525443,
            288532543,
            288578032,
            288532129,
            288536966,
            288541005,
            288544765,
            288551300,
            288551604,
            288547887,
            288547345,
            288554913,
            288553450,
            288546930,
            288552551,
            288553665,
            288542913,
            288552909,
            288551588
        ],
        "B": [
            288512906,
            288512626,
            288591954,
            288514323,
            288515612,
            288518687,
            288518565,
            288516062,
            288516991,
            288516923,
            288523730,
            288523890,
            288520786,
            288521682,
            288521503,
            288524297,
            288520697,
            288521668,
            288521796
        ],
        "A": [
            288510200,
            288515667,
            288594432,
            288510659,
            288510501,
            288510904,
            288511010,
            288517929,
            288511642,
            288510491,
            288516233,
            288511665,
            288510831,
            288512187,
            288514794,
            288512225,
            288511936,
            288512066,
            288512165
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135680",
    "editorial": "Let the number of chosen elements be , and their bitwise OR be . The\r\nanswer is equal to , where is the number of bits equal to in .However,\r\nwe can rewrite as , where is equal to the number of bits equal to among\r\nthe first bits in . So, we have to maximize the value of .Consider the\r\nfollowing bipartite graph: the left part consists of elements of the\r\ngiven array, the right part consists of bits. An edge between vertex\r\nfrom the left part and vertex from the right part means that the -th bit\r\nin is set to .Suppose weâve chosen a set of vertices in the left part\r\n(the elements of our subsequence). The bits which are equal to in the\r\nbitwise OR are represented by such vertices such that no chosen vertex\r\nfrom the left part is connected to . So, if we unite the chosen vertices\r\nfrom the left part with the vertices in the right part representing bits\r\nequal to , this will be an independent subset of vertices.Thus, our\r\nproblem is reduced to finding the maximum size of the independent subset\r\nof vertices. Usually, this problem is NP-complete. However, our graph is\r\nbipartite. So, we can use the following: by Konigâs theorem, in a\r\nbipartite graph, the size of the minimum vertex cover is equal to the\r\nsize of the maximum matching; and in every graph, independent subsets\r\nand vertex covers are complements of each other (if is a vertex cover,\r\nthen the set of all vertices not belonging to is an independent subset,\r\nand vice versa). So, the maximum independent subset is the complement of\r\nthe minimum vertex cover. It means that we can calculate the size of the\r\nmaximum independent subset as , where is the number of vertices in the\r\ngraph, and is the size of the maximum matching. We can compute using any\r\nmaximum matching algorithm or network flow.\r\n",
    "name": "E. Best Subsequence",
    "statement": "Given an integer array a of size n.Let’s define the of the array as its\r\nsize minus the number of set bits in the bitwise OR of all elements of\r\nthe array.For example, for the array [1, 0, 1, 2], the bitwise OR is 3\r\n(which contains 2 set bits), and the value of the array is 4-2=2.Your\r\ntask is to calculate the maximum possible value of some subsequence of\r\nthe given array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; #define rep(i, a, b) for(int i = a; i < (b); ++i)#define trav(a, x) for(auto& a : x)#define all(x) x.begin(), x.end()#define sz(x) (int)(x).size()typedef long long ll;typedef pair<int, int> pii;typedef vector<int> vi;  bool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {\tif (A[a] != L) return 0;\tA[a] = -1;\tfor (int b : g[a]) if (B[b] == L + 1) {\t\tB[b] = 0;\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\t\t\treturn btoa[b] = a, 1;\t}\treturn 0;} int hopcroftKarp(vector<vi>& g, vi& btoa) {\tint res = 0;\tvi A(g.size()), B(btoa.size()), cur, next;\tfor (;;) {\t\tfill(all(A), 0);\t\tfill(all(B), 0);\t\t/// Find the starting nodes for BFS (i.e. layer 0).\t\tcur.clear();\t\tfor (int a : btoa) if(a != -1) A[a] = -1;\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\t\t/// Find all layers using bfs.\t\tfor (int lay = 1;; lay++) {\t\t\tbool islast = 0;\t\t\tnext.clear();\t\t\tfor (int a : cur) for (int b : g[a]) {\t\t\t\tif (btoa[b] == -1) {\t\t\t\t\tB[b] = lay;\t\t\t\t\tislast = 1;\t\t\t\t}\t\t\t\telse if (btoa[b] != a && !B[b]) {\t\t\t\t\tB[b] = lay;\t\t\t\t\tnext.push_back(btoa[b]);\t\t\t\t}\t\t\t}\t\t\tif (islast) break;\t\t\tif (next.empty()) return res;\t\t\tfor (int a : next) A[a] = lay;\t\t\tcur.swap(next);\t\t}\t\t/// Use DFS to scan for augmenting paths.\t\trep(a,0,sz(g))\t\t\tres += dfs(a, 0, g, btoa, A, B);\t}} void solve(){\tint N;\tcin >> N;\tvector<vector<int> > g(N);\tvector<int> btoa(60, -1);\tfor(int i = 0; i < N; i++){\t\tll A;\t\tcin >> A;\t\tfor(int j = 0; j < 60; j++){\t\t\tif(A & (ll(1) << j)){\t\t\t\tg[i].push_back(j);\t\t\t}\t\t}\t}\tint ans = hopcroftKarp(g, btoa);\tcout << (N - ans) << '\\n';} int main(){\tios_base::sync_with_stdio(false), cin.tie(nullptr);\tint T;\tcin >> T;\twhile(T--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "flows",
        "graph matchings",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Best Subsequence.json",
    "hint": []
}