{"link": "https://codeforces.com//contest/1680/problem/F", "problemId": "1398260", "problem_idx": "F", "shortId": "1680F", "contest_number": "1680", "problem_submissions": {"F": [157047850, 157060684, 157042836, 157059615, 157060798, 158084238, 157065404, 157062967, 157061917, 157070522, 157068911, 157063520, 157068892, 157055321, 157070359, 157059828, 157067724, 157073079, 157081810, 157079385, 157105181], "E": [157041040, 157049624, 157047687, 157040462, 157036732, 157047646, 157052435, 157048797, 157052165, 157051933, 157052874, 157059209, 157046788, 157045330, 157056328, 157052190, 157048507, 157050045, 157051601, 157048385], "D": [157034306, 157035182, 157038681, 157048294, 158084226, 157074494, 157044699, 157036339, 157047488, 157040348, 157044725, 157050170, 157047151, 157062708, 157050690, 157073571, 157048489, 157064425, 157042063, 157043656, 157043396, 157043910], "C": [157027102, 157026046, 157029273, 157029023, 158084216, 157023897, 157025338, 157028892, 157029198, 157031553, 157033288, 157030228, 157028759, 157029727, 157032895, 157036498, 157043784, 157026230, 157030697, 157031960, 157038763], "B": [157018674, 157018124, 157022874, 157018932, 157018732, 157019545, 157018987, 157019892, 157025559, 157018220, 157022589, 157021909, 157021994, 157021310, 157023912, 157020972, 157018915, 157021224, 157020613, 157022918], "A": [157018002, 157017909, 157018617, 157017994, 157017953, 157018014, 157018037, 157018035, 157019519, 157017930, 157031859, 157018590, 157019204, 157018082, 157018046, 157018257, 157017944, 157018274, 157018303, 157018968]}, "name": "F. Lenient Vertex Cover", "statement": "You are given a simple connected undirected graph, consisting of n\r\nvertices and m edges. The vertices are numbered from 1 to n.A vertex\r\ncover of a graph is a set of vertices such that each edge has at least\r\none of its endpoints in the set.Let\u2019s call a vertex cover such a vertex\r\ncover that edge in it has both endpoints in the set.Find a vertex cover\r\nof a graph or report that there is none. If there are multiple answers,\r\nthen print any of them.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nnamespace ecnerwala {\n\nusing std::swap;\n\nstruct level_ancestor {\n\tint N;\n\tstd::vector<int> preorder;\n\tstd::vector<int> idx;\n\tstd::vector<std::pair<int, int>> heavyPar; // heavy parent, distance\n\tlevel_ancestor() : N(0) {}\n\n\tlevel_ancestor(const std::vector<int>& par) : N(int(par.size())), preorder(N), idx(N), heavyPar(N) {\n\t\tstd::vector<std::vector<int>> ch(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] != -1) ch[par[i]].push_back(i);\n\t\t}\n\t\tstd::vector<int> sz(N);\n\t\tint nxt_idx = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] == -1) {\n\t\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\t\t\tsz[cur] = 1;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt);\n\t\t\t\t\t\tsz[cur] += sz[nxt];\n\t\t\t\t\t}\n\t\t\t\t\tif (!ch[cur].empty()) {\n\t\t\t\t\t\tauto mit = max_element(ch[cur].begin(), ch[cur].end(), [&](int a, int b) { return sz[a] < sz[b]; });\n\t\t\t\t\t\tswap(*ch[cur].begin(), *mit);\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t\tstd::y_combinator([&](auto self, int cur, int isRoot = true) -> void {\n\t\t\t\t\tpreorder[idx[cur] = nxt_idx++] = cur;\n\t\t\t\t\tif (isRoot) {\n\t\t\t\t\t\theavyPar[idx[cur]] = {par[cur] == -1 ? -1 : idx[par[cur]], 1};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(idx[par[cur]] == idx[cur]-1);\n\t\t\t\t\t\theavyPar[idx[cur]] = heavyPar[idx[cur]-1];\n\t\t\t\t\t\theavyPar[idx[cur]].second++;\n\t\t\t\t\t}\n\t\t\t\t\tbool chRoot = false;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt, chRoot);\n\t\t\t\t\t\tchRoot = true;\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint get_ancestor(int a, int k) const {\n\t\tassert(k >= 0);\n\t\ta = idx[a];\n\t\twhile (a != -1 && k) {\n\t\t\tif (k >= heavyPar[a].second) {\n\t\t\t\tk -= heavyPar[a].second;\n\t\t\t\tassert(heavyPar[a].first <= a - heavyPar[a].second);\n\t\t\t\ta = heavyPar[a].first;\n\t\t\t} else {\n\t\t\t\ta -= k;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tif (a == -1) return -1;\n\t\telse return preorder[a];\n\t}\n\n\tint lca(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\treturn preorder[a];\n\t\t\t}\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t}\n\n\tint dist(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\tres += b - a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres += heavyPar[b].second;\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n} // namespace ecnerwala\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<int> > edges(n);\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tvector<int> par(n, -1);\n\tvector<int> vis(n, 0);\n\tint root = 0;\n\tvector<int> e;\n\ty_combinator(\n\t\t[&](auto self, int v, int p) -> void {\n\t\t\tpar[v] = p;\n\t\t\tvis[v] = 1;\n\t\t\tfor(int w : edges[v]){\n\t\t\t\tif(vis[w]) continue;\n\t\t\t\te.push_back(w);\n\t\t\t\tself(w, v);\n\t\t\t}\n\t\t}\n\t)(root, -1);\n\tecnerwala::level_ancestor la(par);\n\tint nbad = 0;\n\tvector<int> upd(n, 0);\n\tvector<int> upd2(n, 0);\n\tfor(int u = 0; u < n; u++){\n\t\tfor(int v : edges[u]){\n\t\t\tint clen = la.dist(u, v) + 1;\n\t\t\tif(clen & 1){\n\t\t\t\tnbad++;\n\t\t\t\tupd[u]++;\n\t\t\t\tupd[v]++;\n\t\t\t\tupd[la.lca(u, v)] -= 2;\n\t\t\t} else if(clen > 2){\n\t\t\t\tupd2[u]++;\n\t\t\t\tupd2[v]++;\n\t\t\t\tupd2[la.lca(u, v)] -= 2;\n\t\t\t}\n\t\t}\n\t}\n\treverse(e.begin(), e.end());\n\tfor(int v : e){\n\t\tupd[par[v]] += upd[v];\n\t\tupd2[par[v]] += upd2[v];\n\t}\n\tint bu = -1, bv = -1;\n\tif(nbad == 0){\n\t\tbu = 0;\n\t\tbv = 0;\n\t} else if(nbad == 2){\n\t\tfor(int u = 0; u < n; u++){\n\t\t\tfor(int v : edges[u]){\n\t\t\t\tint parity = la.dist(u, v) + 1;\n\t\t\t\tif(parity & 1){\n\t\t\t\t\tbu = u;\n\t\t\t\t\tbv = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(int x = 0; x < n; x++){\n\t\t\tif(upd[x] == nbad && upd2[x] == 0){\n\t\t\t\tbu = x;\n\t\t\t\tbv = par[x];\n\t\t\t}\n\t\t}\n\t}\n\tif(bu == -1){\n\t\tcout << \"NO\" << '\\n';\n\t\treturn;\n\t}\n\tvector<int> color(n, -1);\n\tvis = vector<int>(n, 0);\n\ty_combinator([&](auto self, int v, int c) -> void {\n\t\tcolor[v] = c;\n\t\tvis[v] = 1;\n\t\tfor(int w : edges[v]){\n\t\t\tif(v == bu && w == bv) continue;\n\t\t\tif(v == bv && w == bu) continue;\n\t\t\tif(vis[w]) continue;\n\t\t\tself(w, c ^ 1);\n\t\t}\n\t})(bu, 1);\n\tcout << \"YES\" << '\\n';\n\tfor(int i = 0; i < n; i++) cout << color[i];\n\tcout << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["dfs and similar", "divide and conquer", "dsu", "graphs", "trees"], "dificulty": "2600", "interactive": false}