{
    "link": "https://codeforces.com//contest/863/problem/B",
    "problemId": "123492",
    "problem_idx": "B",
    "shortId": "863B",
    "contest_number": "863",
    "problem_submissions": {
        "F": [
            30585747,
            30587406,
            30587581,
            30586987,
            30589318,
            30588386,
            30614835,
            30589226,
            30587748,
            30588069,
            30589138,
            30588637,
            30589602,
            30588953,
            30587113,
            30590006,
            30591128,
            30589525,
            30591328
        ],
        "E": [
            30584826,
            30584892,
            30586722,
            30586370,
            30585856,
            30586447,
            30586390,
            30586258,
            30587809,
            30586316,
            30587721,
            30587855,
            30587775,
            30588242,
            30587782,
            30587403,
            30589806
        ],
        "D": [
            30584161,
            30582889,
            30583896,
            30584983,
            30584514,
            30599512,
            30585431,
            30584907,
            30584911,
            30586408,
            30585496,
            30586610,
            30586374,
            30584958,
            30587183,
            30584596,
            30585231,
            30587520
        ],
        "C": [
            30583486,
            30584324,
            30585366,
            30584169,
            30583738,
            30584504,
            30584405,
            30584037,
            30585386,
            30584778,
            30585657,
            30585045,
            30584141,
            30586261,
            30586674,
            30591722,
            30586154
        ],
        "B": [
            30581979,
            30583463,
            30582674,
            30582188,
            30582199,
            30582158,
            30582064,
            30582238,
            30582609,
            30582456,
            30582868,
            30582784,
            30582689,
            30582852,
            30583217,
            30606326,
            30582212,
            30582335
        ],
        "A": [
            30581619,
            30581704,
            30581695,
            30581653,
            30581650,
            30786677,
            30581665,
            30581657,
            30581629,
            30581763,
            30581628,
            30581791,
            30581663,
            30581713,
            30581800,
            30581819,
            30581630,
            30581694
        ],
        "G": [
            57430904,
            30596090
        ]
    },
    "name": "B. Kayaking",
    "statement": "Vadim is really keen on travelling. Recently he heard about kayaking\r\nactivity near his town and became very excited about it, so he joined a\r\nparty of kayakers.Now the party is ready to start its journey, but\r\nfirstly they have to choose kayaks. There are people in the group\r\n(including Vadim), and they have exactly tandem kayaks (each of which,\r\nobviously, can carry two people) and single kayaks. -th person’s weight\r\nis , and weight is an important matter in kayaking if the difference\r\nbetween the weights of two people that sit in the same tandem kayak is\r\ntoo large, then it can crash. And, of course, people want to distribute\r\ntheir seats in kayaks in order to minimize the chances that kayaks will\r\ncrash.Formally, the instability of a single kayak is always , and the\r\ninstability of a tandem kayak is the absolute difference between weights\r\nof the people that are in this kayak. Instability of the whole journey\r\nis the total instability of all kayaks.Help the party to determine\r\nminimum possible total instability!\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tvector<int> w(n * 2);\n\t\tfor (int i = 0; i < n * 2; ++ i)\n\t\t\tscanf(\"%d\", &w[i]);\n\t\tsort(w.begin(), w.end());\n\t\tvector<vi> dp(n * 2 + 1, vi(3, INF));\n\t\tdp[0][0] = 0;\n\t\trep(i, n * 2) rep(j, 3) {\n\t\t\tint x = dp[i][j];\n\t\t\tif (x == INF) continue;\n\t\t\tif (i + 2 <= n * 2)\n\t\t\t\tamin(dp[i + 2][j], x + (w[i + 1] - w[i]));\n\t\t\tif (j < 2)\n\t\t\t\tamin(dp[i + 1][j + 1], x);\n\t\t}\n\t\tint ans = dp.back()[2];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Kayaking.json",
    "editorial_link": "https://codeforces.com//blog/entry/54708",
    "editorial": "Firstly letâs learn how to split persons in pairs as if there are no\r\nsingle kayaks. Let there be people with weights , , and (). Obviously,\r\nthe lowest instability you can achieve is . Swapping any two elements\r\nwill only make the result greater. This greedy strategy can be used to\r\ndistribute all the seats.Now you need to check every pair of persons to\r\nseat in single kayaks and calculate total instability for the rest. The\r\nanswer will be the minimun instabily over all pairs.Overall complexity:\r\n.\r\n",
    "hint": []
}