{
    "link": "https://codeforces.com//contest/1140/problem/F",
    "problemId": "317589",
    "problem_idx": "F",
    "shortId": "1140F",
    "contest_number": "1140",
    "problem_submissions": {
        "G": [
            51711380,
            51715425,
            51701961,
            51723677,
            51713161,
            51826208,
            51725702,
            51751383,
            51751094,
            51871694
        ],
        "E": [
            51707475,
            51698157,
            51710451,
            51699057,
            51698619,
            51700718,
            51698345,
            51703686,
            51826592,
            51711304,
            51706757,
            51709505,
            51702992,
            51711975,
            51716308,
            51694918,
            51707265,
            51699848,
            51701075,
            51700169,
            51701450
        ],
        "F": [
            51700190,
            51704937,
            51708125,
            51707572,
            51715636,
            51713154,
            51709309,
            51745229,
            51724116,
            51717194,
            51826549,
            51704389,
            51714714,
            51719425,
            51719809,
            51889038,
            51888545,
            51716543,
            51712779,
            51717719,
            51719576,
            51772442,
            51734097,
            51801995,
            52594541,
            52594485
        ],
        "D": [
            51692897,
            51692552,
            51711200,
            51692355,
            51691890,
            51695018,
            51693289,
            51690531,
            51826633,
            51691126,
            51688766,
            51694582,
            51696697,
            51687330,
            51696460,
            51700363,
            51702095,
            51691157,
            51691573,
            51691854,
            51693356
        ],
        "C": [
            51691812,
            51690406,
            51711880,
            51691405,
            51690720,
            51691755,
            51691383,
            51689446,
            51826659,
            51690305,
            51696638,
            51692263,
            51691635,
            51692542,
            51695004,
            51699456,
            51696505,
            51690289,
            51689951,
            51689550,
            51688775
        ],
        "B": [
            51689841,
            51689192,
            51712746,
            51689822,
            51689241,
            51688933,
            51689569,
            51688189,
            51826766,
            51688939,
            51690552,
            51689048,
            51689939,
            51691885,
            51692884,
            51696524,
            51689978,
            51688514,
            51688185,
            51688344,
            51690712
        ],
        "A": [
            51687668,
            51687221,
            51713210,
            51688333,
            51687348,
            51687390,
            51687760,
            51687210,
            51826788,
            51687239,
            51687778,
            51687499,
            51688125,
            51688099,
            51687757,
            51687342,
            51688091,
            51687317,
            51687203,
            51687474,
            51687413
        ]
    },
    "name": "F. Extending Set of Points",
    "statement": "For a given set of two-dimensional points S, let\u2019s denote its extension\r\nE(S) as the result of the following algorithm:Create another set of\r\ntwo-dimensional points R, which is initially equal to S. Then, while\r\nthere exist four numbers x_1, y_1, x_2 and y_2 such that (x_1, y_1)\r\nin R, (x_1, y_2)\r\nin R, (x_2, y_1)\r\nin R and (x_2, y_2)\r\nnotin R, add (x_2, y_2) to R. When it is impossible to find such four\r\nintegers, let R be the result of the algorithm.Now for the problem\r\nitself. You are given a set of two-dimensional points S, which is\r\ninitially empty. You have to process two types of queries: add some\r\npoint to S, or remove some point from it. After each query you have to\r\ncompute the size of E(S).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define li long long\n#define gc getchar()\n#define pc putchar\n//char buf[100000],*buff = buf + 100000;\n//#define gc (buff == buf + 100000 ? (fread(buf,1,100000,stdin),buff = buf) : 0,*buff++)\ninline li read(){\n\tli x = 0,y = 0,c = gc;\n\twhile(!isdigit(c)) y = c,c = gc;\n\twhile(isdigit(c)) x = x * 10 + (c ^ '0'),c = gc;\n\treturn y == '-' ? -x : x;\n}\ninline void print(li x){\n\tif(x < 0) pc('-'),x = -x;\n\tif(x >= 10) print(x / 10);\n\tpc(x % 10 + '0');\n}\nli s1 = 19260817,s2 = 23333333,s3 = 998244853,srd;\ninline li rd(){\n\treturn srd = (srd * s1 + s2 + rand()) % s3;\n}\nvoid file(){\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n}\nint n,cnt;\nstruct node{\n\tint x,y,l,r;\n}a[300010];\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\nmap<pii,int> m;\nli as[300010],nwas;\nint f[600010],sz1[600010],sz2[600010];\ninline int getf(int q){\n\treturn f[q] == q ? q : getf(f[q]);\n}\n#define ls q << 1\n#define rs q << 1 | 1\n#define ln ls,l,mid\n#define rn rs,mid + 1,r\n#define md int mid = l + r >> 1\nvector<pii > t[1200010];\ninline void ins(int q,int l,int r,node x){\n\tif(l >= x.l && r <= x.r){\n\t\tt[q].push_back(mp(x.x,x.y));\n\t\treturn;\n\t}\n\tmd;\n\tif(mid >= x.l) ins(ln,x);\n\tif(mid < x.r) ins(rn,x); \n} \nint st[10000010][4],ft;\ninline void wk(int q,int l,int r){\n\tint ff = ft;\n\tfor(int i = 0;i < t[q].size();++i){\n\t\tint x = t[q][i].fi,y = t[q][i].se + 300000;\n\t\tx = getf(x);y = getf(y);\n\t\tif(x == y) continue; \n\t\tif(sz1[x] + sz2[x] < sz1[y] + sz2[y]) swap(x,y);\n\t\tnwas += 1ll * sz1[x] * sz2[y] + 1ll * sz1[y] * sz2[x];\n\t\tst[++ft][0] = x;st[ft][1] = y;st[ft][2] = sz1[x];st[ft][3] = sz2[x];\n\t\tf[y] = x;sz1[x] += sz1[y];sz2[x] += sz2[y];\n\t}\n\tif(l == r) as[l] = nwas;\n\telse{\n\t\tmd;wk(ln);wk(rn);\n\t}\n\twhile(ft != ff){\n\t\tint x = st[ft][0],y = st[ft][1];\n\t\tsz1[x] = st[ft][2];sz2[x] = st[ft][3];f[y] = y;\n\t\tnwas -= 1ll * sz1[x] * sz2[y] + 1ll * sz1[y] * sz2[x];\n\t\t--ft;\n\t}\n}\nint main(){\n\tsrand(time(0));rd();\n\t//file();\n\tint i,j,x,y;\n\tn = read();\n\tfor(i = 1;i <= n;++i){\n\t\tx = read();y = read();\n\t\tif(m.find(mp(x,y)) != m.end()){\n\t\t\ta[m[mp(x,y)]].r = i - 1;\n\t\t\tm.erase(mp(x,y));\n\t\t}\n\t\telse{\n\t\t\tm[mp(x,y)] = ++cnt;\n\t\t\ta[cnt].x = x;a[cnt].y = y;a[cnt].l = i;\n\t\t}\n\t}\n\tfor(i = 1;i <= cnt;++i) if(!a[i].r) a[i].r = n;\n\tfor(i = 1;i <= 600000;++i) f[i] = i;\n\tfor(i = 1;i <= 300000;++i) sz1[i] = 1,sz2[i +  300000] = 1;\n\t//for(i = 1;i <= cnt;++i) cerr<<a[i].x<<\" \"<<a[i].y<<\" \"<<a[i].l<<\" \"<<a[i].r<<endl;\n\tfor(i = 1;i <= cnt;++i) ins(1,1,n,a[i]);\n\twk(1,1,n);\n\tfor(i = 1;i <= n;++i) print(as[i]),pc(' ');\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dsu"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Extending Set of Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/66147",
    "editorial": "Let\u00e2\u0080\u0099s try to analyze how the size of can be calculated. Let\u00e2\u0080\u0099s connect\r\npoints having same -coordinates to each other, and do the same for\r\npoints having same -coordinates. Then we can solve the problem for each\r\ncomponent separatedly: after the algorithm is run, the component will\r\ncontain the points such that at least one point in the component has\r\n-coordinate equal to , and at least one point in the component (maybe\r\nsame, maybe another one) has -coordinate equal to . So the answer for\r\neach component is the product of the number of distinct -coordinates and\r\nthe number of distinct -coordinates in the component. Now we can process\r\ninsertion queries: there are many ways to do it, but, in my opinion, the\r\neasiest way to handle them is to create a separate vertex for every\r\n-coordinate and -coordinate, and process each point as an edge\r\nconnecting vertices corresponding to its coordinates (edges can be\r\neasily added by using DSU with rank heuristics).To handle removals, we\r\nwill get rid of them completely. Transform the input into a set of\r\nevents \"some point exists from query to query \". Then build a segment\r\ntree over queries, and break each event into segments with this segment\r\ntree. Then we can initialize a DSU, and run DFS on the vertices of the\r\nsegment tree to get answers for all queries. When we enter some node, we\r\nadd all edges that exist on the corresponding segment into DSU. If we\r\nare in a leaf node, we may compute the for the corresponding query. And\r\nwhen we leave a vertex, we can rollback all changes we made when we\r\nentered it. One important moment is that using path compression in DSU\r\nhere is meaningless since it doesn\u00e2\u0080\u0099t work with rollbacks well.This\r\nsolution works in .\r\n"
}