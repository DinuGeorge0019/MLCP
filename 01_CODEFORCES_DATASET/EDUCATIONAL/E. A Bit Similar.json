{
    "link": "https://codeforces.com//contest/1469/problem/E",
    "problemId": "847530",
    "problem_idx": "E",
    "shortId": "1469E",
    "contest_number": "1469",
    "problem_submissions": {
        "F": [
            102583473,
            102644474,
            102589987,
            102594210,
            102598891,
            102606787,
            102602998,
            102604144,
            102603740,
            102665234,
            102604943,
            102600529,
            102596981,
            102695061,
            102694126,
            102693059,
            102692990,
            102691774,
            102691554,
            102634847,
            102593976,
            102601060,
            102611713,
            102611193,
            102613178,
            102615015,
            102610571,
            133243413,
            102609965,
            102615327
        ],
        "E": [
            102573843,
            102644473,
            102578949,
            102577732,
            102585110,
            102591945,
            102586477,
            102582817,
            102595462,
            102579611,
            102664687,
            102648095,
            102648064,
            102594234,
            102584569,
            102634471,
            102624399,
            102623518,
            102608733,
            155214938,
            102768106,
            102593726,
            102593694,
            102597495,
            102592373,
            102595193,
            102588652,
            102589423,
            102593264
        ],
        "D": [
            102562850,
            102644472,
            102568881,
            102566821,
            102569601,
            102570954,
            102563048,
            102571352,
            102588415,
            102664675,
            102570617,
            102572568,
            102569075,
            102580450,
            102569951,
            102575804,
            102575811,
            102574711,
            102577038,
            102579322,
            102570202
        ],
        "C": [
            102552805,
            102644471,
            102555513,
            102554730,
            102555597,
            102558406,
            102554980,
            102553952,
            102556321,
            102664664,
            102560782,
            102559861,
            102555651,
            102570770,
            102554929,
            102563292,
            102558262,
            102561567,
            102566610,
            102569771,
            102557739
        ],
        "B": [
            102548072,
            102644469,
            102548784,
            102547413,
            102549611,
            102549952,
            102549039,
            102547745,
            102550684,
            102664647,
            102553929,
            102550781,
            102634199,
            102551181,
            102557688,
            102550308,
            102552089,
            102551269,
            102550296,
            102555698,
            102550742,
            102551593
        ],
        "A": [
            102546848,
            102644467,
            102547134,
            102546803,
            102547541,
            102546863,
            102546919,
            102546821,
            102547947,
            102664636,
            102549491,
            102548928,
            102547577,
            102555388,
            102547472,
            102548992,
            102546835,
            102546964,
            102551041,
            102547957,
            102549438
        ]
    },
    "name": "E. A Bit Similar",
    "statement": "Let\u2019s call two strings a and b (both of length k) if they have the same\r\ncharacter in some position, i. e. there exists at least one i\r\nin [1, k] such that a_i = b_i.You are given a binary string s of length\r\nn (a string of n characters and/or ) and an integer k. Let\u2019s denote the\r\nstring s[i..j] as the substring of s starting from the i-th character\r\nand ending with the j-th character (that is, s[i..j] = s_i s_{i + 1}\r\ns_{i + 2}\r\ndots s_{j - 1} s_j).Let\u2019s call a binary string t of length k if it is to\r\nall substrings of s having length exactly k; that is, it is to s[1..k],\r\ns[2..k+1],\r\ndots, s[n-k+1..n].Your goal is to find the smallest string t that is ,\r\nor report that no such string exists. String x is lexicographically less\r\nthan string y if either x is a prefix of y (and x\r\nne y), or there exists such i (1\r\nle i\r\nle\r\nmin(|x|, |y|)), that x_i < y_i, and for any j (1\r\nle j < i) x_j = y_j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, k;\n        std::string s;\n        std::cin >> n >> k >> s;\n        int lg = std::__lg(n) + 1;\n        std::string t(std::max(0, k - lg), '0');\n        int l = k - t.length();\n        int mask = 0, cnt = 0;\n        for (int i = 0; i < k - l; ++i) {\n            cnt += s[i] - '0';\n        }\n        for (int i = k - l; i < k - 1; ++i) {\n            mask = (mask << 1) | (s[i] - '0');\n        }\n        std::vector<bool> bad(1 << l);\n        for (int i = k - 1; i < n; ++i) {\n            mask = ((mask << 1) | (s[i] - '0')) & ((1 << l) - 1);\n            if (cnt == k - l) {\n                bad[((1 << l) - 1) ^ mask] = true;\n            }\n            cnt = cnt - (s[i - k + 1] - '0') + (s[i - l + 1] - '0');\n        }\n        int ans = 0;\n        while (ans < (1 << l) && bad[ans]) {\n            ++ans;\n        }\n        if (ans == (1 << l)) {\n            std::cout << \"NO\\n\";\n            continue;\n        }\n        for (int i = l - 1; i >= 0; --i) {\n            t += '0' + (ans >> i & 1);\n        }\n        std::cout << \"YES\\n\";\n        std::cout << t << \"\\n\";\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "hashing",
        "string suffix structures",
        "strings",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. A Bit Similar.json",
    "editorial_link": "https://codeforces.com//blog/entry/86082",
    "editorial": "Let\u00e2\u0080\u0099s denote as the number of substrings of having length exactly (so,\r\n).The first and crucial observation is that if , then the answer always\r\nexists. Each of substrings forbids one of the strings from being the\r\nanswer (a string is forbidden if every each character differs from the\r\ncorresponding character in one of the substrings); we can forbid at most\r\nstrings from being the answer, and the number of possible candidates for\r\nthe answer is . This observation leads us to a more strong fact that\r\nactually allows us to find a solution: we can set the first characters\r\nin the answer to ; all the remaining characters are enough to find the\r\nanswer.There are at most possible combinations of the last characters,\r\nand this number is not greater than . Let\u00e2\u0080\u0099s iterate on each substring of\r\nof length and check which combination it forbids by inverting the last\r\ncharacters of the substring. After that, find the minimum unforbidden\r\ncombination. Note that there may be a case when a substring doesn\u00e2\u0080\u0099t\r\nactually forbid any combination if there are zeroes in the first\r\ncharacters of the substring, it is to the answer no matter which\r\ncombination we choose. This can be checked by precalculating the closest\r\nposition of zero to the left/right of each index.The whole solution\r\nworks in per test case the hardest part is inverting the suffix of each\r\nsubstring we are interested in.\r\n"
}