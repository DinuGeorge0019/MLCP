{
    "link": "https://codeforces.com//contest/1288/problem/F",
    "problemId": "516092",
    "problem_idx": "F",
    "shortId": "1288F",
    "contest_number": "1288",
    "problem_submissions": {
        "F": [
            68819552,
            68808531,
            68807458,
            70134760,
            68807017,
            68813769,
            68812618,
            102301682,
            68810583,
            68807992,
            68818667,
            68814476,
            68814904,
            148920535,
            69079454,
            69075918,
            69087920,
            68817577,
            68867890,
            68867024
        ],
        "E": [
            68789304,
            68799414,
            70134713,
            68794162,
            68793417,
            68796419,
            68796122,
            68798077,
            68796394,
            68805226,
            68789819,
            68793916,
            68792563,
            68828678,
            68828570,
            68828548,
            68828508,
            68828405,
            68825187,
            68824325,
            68795790,
            68796556,
            68795660,
            68795978,
            68794855,
            68795573,
            68798172,
            68797193
        ],
        "D": [
            68783658,
            68790087,
            70134685,
            68790433,
            68784769,
            68786894,
            68787811,
            68794372,
            68789589,
            68795124,
            68786983,
            68787137,
            68787922,
            68782622,
            68788267,
            68791758,
            68788474,
            68787396,
            68786555,
            69711971,
            69711762,
            68788055,
            68792205
        ],
        "C": [
            68780932,
            68782036,
            70134661,
            68786063,
            68780437,
            68783287,
            68784254,
            68819757,
            68791290,
            86478943,
            68783597,
            68785836,
            68782781,
            68782659,
            68783955,
            68780494,
            68784922,
            68782777,
            68784716,
            68784512,
            68784035,
            68782534,
            68783571
        ],
        "B": [
            68779970,
            68780416,
            70134627,
            68782676,
            68781485,
            68781383,
            68781464,
            68781107,
            68781318,
            68782464,
            68780637,
            68781282,
            68782023,
            68779901,
            68781253,
            68780876,
            68782711,
            68780458,
            68781060,
            68780498,
            68781762
        ],
        "A": [
            68779722,
            68779812,
            70134580,
            68780111,
            68782502,
            68779822,
            68779930,
            68779750,
            68780171,
            68781059,
            68779815,
            68780062,
            68780122,
            68779758,
            68779835,
            68779859,
            68779825,
            68779886,
            68780036,
            68779829,
            68780004
        ]
    },
    "name": "F. Red-Blue Graph",
    "statement": "You are given a bipartite graph: the first part of this graph contains\r\nn_1 vertices, the second part contains n_2 vertices, and there are m\r\nedges. .Initially, each edge is colorless. For each edge, you may either\r\nleave it uncolored (it is free), paint it red (it costs r coins) or\r\npaint it blue (it costs b coins). No edge can be painted red and blue\r\nsimultaneously.There are three types of vertices in this graph\r\ncolorless, red and blue. Colored vertices impose additional constraints\r\non edgesâ€™ colours: for each red vertex, the number of red edges indicent\r\nto it should be than the number of blue edges incident to it; for each\r\nblue vertex, the number of blue edges indicent to it should be than the\r\nnumber of red edges incident to it. Colorless vertices impose no\r\nadditional constraints.Your goal is to paint some (possibly none) edges\r\nso that all constraints are met, and among all ways to do so, you should\r\nchoose the one with minimum total cost.\r\n",
    "solutions": [
        "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 _y0\n#define kill _kill\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll btc = 30;\nconst ld eps = 1e-10;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 1e9 + 7; //(int)(1e9 + 7); //998244353;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n\n//random\nmt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n//constants\nconst int M = (int)(2e5 + 239);\nconst int N = (int)(2e3 + 239);\nconst int L = 20;\nconst int T = (1 << 20) + 239;\nconst int B = 500;\nconst int X = 210;\n\nstruct MCMF\n{\n    struct Edge\n    {\n        int to, fr;\n        ll c, f, p;\n\n        Edge()\n        {\n            fr = to = c = f = p = 0;\n        }\n\n        Edge(int fr1, int to1, ll c1, ll p1)\n        {\n            fr = fr1;\n            to = to1;\n            c = c1;\n            f = 0;\n            p = p1;\n        }\n    };\n\n    int n;\n    vector<Edge> e;\n    vector<vector<int> > v;\n    int s, f;\n    vector<int> pr;\n    vector<ll> dist;\n    vector<ll> pot;\n\n    MCMF()\n    {\n\n    }\n\n    MCMF(int nn, int ss, int ff)\n    {\n        n = nn;\n        dist.resize(n);\n        v.resize(n);\n        pot.resize(n);\n        pr.resize(n);\n        for (int i = 0; i < n; i++)\n            pot[i] = 0;\n        s = ss, f = ff;\n    }\n\n    inline int connect(int a, int b, ll c, ll p)\n    {\n        int i = e.size();\n        e.push_back(Edge(a, b, c, p));\n        v[a].push_back(i);\n        e.push_back(Edge(b, a, 0, -p));\n        v[b].push_back(i + 1);\n        return i;\n    }\n\n    inline ll cost(int i)\n    {\n        return e[i].p + pot[e[i].fr] - pot[e[i].to];\n    }\n\n    inline void phase()\n    {\n        for (int i = 0; i < n; i++)\n            dist[i] = INF, pr[i] = -1;\n        dist[s] = 0;\n        set<pair<ll, int> > q;\n        for (int i = 0; i < n; i++)\n            q.insert(make_pair(dist[i], i));\n        while (!q.empty())\n        {\n            int x = q.begin()->second;\n            q.erase(q.begin());\n            for (int i : v[x])\n                if (e[i].c > e[i].f && dist[e[i].to] > dist[x] + cost(i))\n                {\n                    q.erase(make_pair(dist[e[i].to], e[i].to));\n                    pr[e[i].to] = i;\n                    dist[e[i].to] = dist[x] + cost(i);\n                    q.insert(make_pair(dist[e[i].to], e[i].to));\n                }\n        }\n        if (dist[f] >= BIG)\n            return;\n        int t = f;\n        ll w = INF;\n        vector<int> way;\n        while (t != s)\n        {\n            way.push_back(t);\n            w = min(w, e[pr[t]].c - e[pr[t]].f);\n            t = e[pr[t]].fr;\n        }\n        way.push_back(s);\n        reverse(way.begin(), way.end());\n        t = f;\n        while (t != s)\n        {\n            e[pr[t]].f += w;\n            e[pr[t] ^ 1].f -= w;\n            t = e[pr[t]].fr;\n        }\n        for (int i = 0; i < n; i++)\n            pot[i] = dist[i];\n        phase();\n    }\n\n    inline void compute_fb()\n    {\n        for (int i = 0; i < n; i++)\n            pot[i] = 0;\n        for (int z = 0; z < n; z++)\n            for (Edge ee : e)\n                if (ee.c > 0)\n                    pot[ee.to] = min(pot[ee.to], pot[ee.fr] + ee.p);\n        //for (int i = 0; i < (int)e.size(); i++)\n        //    if (cost(i) < 0 && e[i].c > 0)\n        //        cerr << \"bad!\\n\";\n    }\n\n    inline void run()\n    {\n        compute_fb();\n        phase();\n    }\n\n    inline ll gett()\n    {\n        ll ans = 0;\n        for (Edge ee : e)\n            if (ee.c > 0)\n                ans += ee.f * ee.p;\n        return ans;\n    }\n\n    inline int getsize()\n    {\n        ll ans = 0;\n        for (int i : v[s])\n            if (e[i].c > 0)\n                ans += e[i].f;\n        return ans;\n    }\n};\n\nint n1, n2, m, r, b;\nstring s1, s2;\nint ri[X], bi[X];\n\nint32_t main()\n{\n#ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n1 >> n2 >> m >> r >> b >> s1 >> s2;\n    MCMF gr = MCMF(n1 + n2 + 4, n1 + n2 + 2, n1 + n2 + 3);\n    int L = n1 + n2;\n    int R = n1 + n2 + 1;\n    int S = n1 + n2 + 2;\n    int F = n1 + n2 + 3;\n    for (int i = 0; i < m; i++)\n    {\n        int s, f;\n        cin >> s >> f;\n        s--, f--;\n        ri[i] = gr.connect(s, f + n1, 1, r);\n        bi[i] = gr.connect(f + n1, s, 1, b);\n    }\n    int big = 2 * m + 10;\n    gr.connect(R, L, big, 0);\n    int need = 0;\n    for (int i = 0; i < n1; i++)\n    {\n        if (s1[i] == 'U')\n        {\n            gr.connect(i, R, big, 0);\n            gr.connect(L, i, big, 0);\n            continue;\n        }\n        need++;\n        if (s1[i] == 'B')\n        {\n            gr.connect(i, R, big, 0);\n            gr.connect(i, F, 1, 0);\n            gr.connect(S, R, 1, 0);\n        }\n        else\n        {\n            gr.connect(L, i, big, 0);\n            gr.connect(L, F, 1, 0);\n            gr.connect(S, i, 1, 0);\n        }\n    }\n    for (int ii = 0; ii < n2; ii++)\n    {\n        int i = ii + n1;\n        if (s2[ii] == 'U')\n        {\n            gr.connect(i, R, big, 0);\n            gr.connect(L, i, big, 0);\n            continue;\n        }\n        need++;\n        if (s2[ii] == 'R')\n        {\n            gr.connect(i, R, big, 0);\n            gr.connect(i, F, 1, 0);\n            gr.connect(S, R, 1, 0);\n        }\n        else\n        {\n            gr.connect(L, i, big, 0);\n            gr.connect(L, F, 1, 0);\n            gr.connect(S, i, 1, 0);\n        }\n    }\n    gr.run();\n    if (gr.getsize() != need)\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    cout << gr.gett() << \"\\n\";\n    string ans = \"\";\n    for (int i = 0; i < m; i++)\n    {\n        if (gr.e[ri[i]].f == 1)\n            ans += \"R\";\n        else if (gr.e[bi[i]].f == 1)\n            ans += \"B\";\n        else\n            ans += \"U\";\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "flows"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Red-Blue Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/73105",
    "editorial": "A lot of things in this problem may tell us that we should try thinking\r\nabout a flow solution. Okay, letÃ¢Â€Â™s try to model the problem as a flow\r\nnetwork.First of all, our network will consist of vertices and edges of\r\nthe original graph. We somehow have to denote \"red\", \"blue\" and\r\n\"colorless\" edges; we will do it as follows: each edge of the original\r\ngraph corresponds to a bidirectional edge with capacity in the network;\r\nif the flow goes from the left part to the right part along the edge, it\r\nis red; if the flow goes from right to left, it is a blue edge; and if\r\nthere is no flow along the edge, it is colorless.Okay, we need to impose\r\nsome constraints on the vertices. Consider some vertex from the left\r\npart. Each red edge incident to it transfers one unit of flow from it to\r\nsome other vertex, and each blue edge incident to it does the opposite.\r\nSo, the difference between the number of blue and red edges incident to\r\nis the amount of excess flow that has to be transfered somewhere else.\r\nIf is colorless, there are no constraints on the colors of edges, so\r\nthis amount of excess flow does not matter to model it, we can add a\r\ndirected edge from source to with infinite capacity, and a directed edge\r\nfrom to sink with infinite capacity. What if is red? At least one unit\r\nof flow should be transfered to it; so we add a directed edge from the\r\nsource to with infinite capacity . And if is blue, we need to transfer\r\nat least one unit of excess flow from it so we add a directed edge from\r\nto the sink with infinite capacity such that there is at least one unit\r\nof flow along it. The colors of the vertices in the right part can be\r\nmodeled symmetrically.How to deal with edges such that there should be\r\nsome flow along them? You may use classic \"flows with demands\" approach\r\nfrom here: https://cp-algorithms.com/graph/flow_with_demands.html. Or\r\nyou can model it with the help of the costs: if the flow along the edge\r\nshould be between and , we can add two edges: one with capacity and cost\r\n(where is a negative number with sufficiently large absolute value, for\r\nexample, ), and another with capacity and cost .Okay, now we know how to\r\nfind at least one painting. How about finding the cheapest painting that\r\nmeets all the constraints? One of the simplest ways to do it is to\r\nimpose costs on the edges of the original graph: we can treat each edge\r\nof the original graph as a pair of directed edges, one going from left\r\nto right with capacity and cost , and another going from right to left\r\nwith capacity and cost .\r\n",
    "hint": []
}