{
    "link": "https://codeforces.com//contest/2086/problem/B",
    "problemId": "3306521",
    "problem_idx": "B",
    "shortId": "2086B",
    "contest_number": "2086",
    "problem_submissions": {
        "F": [
            313800473,
            313815107,
            313814871,
            313816809,
            313824037,
            313823800,
            313823595,
            313823290,
            313831013,
            313847963
        ],
        "E": [
            313778103,
            313768063,
            313796531,
            313772368,
            313776096,
            313773540,
            313775500,
            313777349,
            313773743,
            313773212,
            313777394,
            313774460,
            313780281,
            313777023,
            313779749,
            313779985,
            313789675,
            313782783,
            313780927
        ],
        "D": [
            313765839,
            313760163,
            313763413,
            313762506,
            313761667,
            313764480,
            313761919,
            313762403,
            313764311,
            313768000,
            313764673,
            313765244,
            313767408,
            313766701,
            313767208,
            313767620,
            313765113,
            313765919,
            313769446
        ],
        "C": [
            313762408,
            313757321,
            313759589,
            313757952,
            313757592,
            313758776,
            313758447,
            313758249,
            313761365,
            313762216,
            313760196,
            313762012,
            313758933,
            313763649,
            313761491,
            313762919,
            313757921,
            313761818
        ],
        "B": [
            313759878,
            313752573,
            313755779,
            313754646,
            313754713,
            313753530,
            313755287,
            313755649,
            313756220,
            313750845,
            313757002,
            313758471,
            313753446,
            313758811,
            313757915,
            313759796,
            313754670,
            313758593
        ],
        "A": [
            313747124,
            313744880,
            313745589,
            313744964,
            313745790,
            313744642,
            313747626,
            313744833,
            313745066,
            313744593,
            313747501,
            313747195,
            313744587,
            313748494,
            313746594,
            313746261,
            313746218,
            313744938
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141425",
    "editorial": "In this problem, the array is obtained by copying the array exactly\r\ntimes.Notice that all elements of the array are positive; therefore, the\r\nelements of the array are also positive. From this, we can conclude that\r\nthe optimal for any that maximizes the sum over the segment [] is always\r\nequal to . It also follows that the maximum sum for is less than the\r\nmaximum sum for . The condition of monotonicity holds, so we can perform\r\na binary search to find the first such for which the maximum sum is .How\r\ndo we write a check for such a binary search? Given a position , we need\r\nto calculate the maximum sum for it. To do this, we find how many \"full\r\narrays \" fit into the suffix : there are of them. In addition to this,\r\nthere are elements from the suffix of the array on this segment, so the\r\ntotal sum of the elements of the array over the segment [] can be found\r\nusing the formula:At this point, we can write a solution that works in .\r\nIf we pre-calculate all suffix sums for the array , then the formula\r\nabove can be calculated in , so the solution can be optimized to .There\r\nare also other solutions with complexity that also get .\r\n",
    "name": "B. Large Array and Segments",
    "statement": "There is an array a consisting of n integers, and a positive integer k.\r\nAn array b is created from array a according to the following rules: b\r\ncontains n\r\ncdot k numbers; the first n numbers of array b are the same as the\r\nnumbers of array a, that is, b_{i} = a_{i} for i\r\nle n; for any i > n, it holds that b_{i} = b_{i - n}. For example, if a\r\n= [2, 3, 1, 4] and k = 3, then b = [2, 3, 1, 4, 2, 3, 1, 4, 2, 3, 1, 4].\r\nGiven a number x, it is required to count the number of such positions l\r\n(1\r\nle l\r\nle n\r\ncdot k), for which there exists a position r\r\nge l, such that the sum of the elements of array b on the segment [l, r]\r\nis x (in other words, b_{l} + b_{l+1} +\r\ndots + b_{r}\r\nge x).\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Large Array and Segments.json"
}