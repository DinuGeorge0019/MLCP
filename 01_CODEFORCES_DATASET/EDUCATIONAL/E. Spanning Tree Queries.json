{"link": "https://codeforces.com//contest/1633/problem/E", "problemId": "1280037", "problem_idx": "E", "shortId": "1633E", "contest_number": "1633", "problem_submissions": {"F": [144728014, 144732663, 144725299, 144734135, 144755385, 144746200, 144750180, 144784169, 144784123, 144784071, 144756558, 144756413, 144744162, 144773832, 144760627, 144857379, 144846906, 144860452], "E": [144697422, 144697254, 144700273, 144711600, 144710139, 144705030, 144759258, 144758605, 144753117, 144751374, 144692794, 144693937, 144709093, 144688303, 144718728, 144712277, 144711222, 144703097, 144703533, 144701413, 144708247, 144730413, 144725248, 144709092, 144706985, 144707076, 144709192, 144715254, 144713175, 144701813, 144716988, 144713208, 144710969], "D": [144679861, 144680032, 144672273, 144677313, 144750526, 144750179, 144673134, 144665105, 144722610, 144673318, 144676038, 144675084, 144682415, 144685094, 144675142, 144684537, 144675967, 144689440, 144678803, 144684839], "C": [144667366, 144667779, 144684242, 144665775, 144661471, 144672346, 144750549, 144664792, 144665309, 144663855, 144664551, 144665641, 144665205, 144669565, 144668090, 144672866, 144664710, 144674840, 144672003], "B": [144661250, 144661582, 144668540, 144659176, 144657404, 144657564, 144747880, 144657576, 144658942, 144658191, 144658845, 144734517, 144658134, 144658621, 144660270, 144659944, 144661387, 144659383, 144660032], "A": [144658378, 144658299, 144661328, 144657617, 144657004, 144657002, 144746540, 144657039, 144657209, 144657101, 144657184, 144734357, 144657068, 144657075, 144657309, 144657719, 144657565, 144657507, 144658267]}, "name": "E. Spanning Tree Queries", "statement": "You are given a connected weighted undirected graph, consisting of n\r\nvertices and m edges.You are asked k queries about it. Each query\r\nconsists of a single integer x. For each query, you select a spanning\r\ntree in the graph. Let the weights of its edges be w_1, w_2,\r\ndots, w_{n-1}. The cost of a spanning tree is\r\nsum\r\nlimits_{i=1}^{n-1} |w_i - x| (the sum of absolute differences between\r\nthe weights and x). The answer to a query is the lowest cost of a\r\nspanning tree.The queries are given in a compressed format. The first p\r\n(1\r\nle p\r\nle k) queries q_1, q_2,\r\ndots, q_p are provided explicitly. For queries from p+1 to k, q_j =\r\n(q_{j-1}\r\ncdot a + b)\r\nmod c.Print the xor of answers to all queries.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::array<int, 3>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        std::cin >> u >> v >> w;\n        u--;\n        v--;\n        edges[i] = {w, u, v};\n    }\n    \n    int p, k, a, b, c;\n    std::cin >> p >> k >> a >> b >> c;\n    \n    std::vector<int> q(k);\n    for (int i = 0; i < p; i++) {\n        std::cin >> q[i];\n    }\n    for (int i = p; i < k; i++) {\n        q[i] = (1LL * a * q[i - 1] + b) % c;\n    }\n    \n    std::sort(q.begin(), q.end());\n    \n    std::vector<int> e{0};\n    std::sort(edges.begin(), edges.end());\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = i; j < m; j++) {\n            e.push_back((edges[i][0] + edges[j][0] + 1) / 2);\n        }\n    }\n    \n    std::sort(e.begin(), e.end());\n    \n    i64 coef = 0, cons = 0;\n    \n    i64 ans = 0;\n    \n    for (int i = 0, j = 0; i < k; i++) {\n        int oj = j;\n        while (j < int(e.size()) && q[i] >= e[j]) {\n            j++;\n        }\n        \n        if (oj != j) {\n            std::sort(edges.begin(), edges.end(), [&](auto a, auto b) {\n                int x = std::abs(a[0] - e[j - 1]);\n                int y = std::abs(b[0] - e[j - 1]);\n                if (x != y) {\n                    return x < y;\n                } else {\n                    return a[0] > b[0];\n                }\n            });\n            \n            coef = cons = 0;\n            \n            DSU g(n);\n            for (auto [w, u, v] : edges) {\n                if (g.merge(u, v)) {\n                    if (w > e[j - 1]) {\n                        coef--;\n                        cons += w;\n                    } else {\n                        coef++;\n                        cons -= w;\n                    }\n                }\n            }\n        }\n        \n        ans ^= coef * q[i] + cons;\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "dsu", "graphs", "greedy", "math", "sortings", "trees"], "dificulty": "2400", "interactive": false}