{
    "link": "https://codeforces.com//contest/1633/problem/F",
    "problemId": "1280038",
    "problem_idx": "F",
    "shortId": "1633F",
    "contest_number": "1633",
    "problem_submissions": {
        "F": [
            144728014,
            144732663,
            144725299,
            144734135,
            144755385,
            144746200,
            144750180,
            144784169,
            144784123,
            144784071,
            144756558,
            144756413,
            144744162,
            144773832,
            144760627,
            144857379,
            144846906,
            144860452
        ],
        "E": [
            144697422,
            144697254,
            144700273,
            144711600,
            144710139,
            144705030,
            144759258,
            144758605,
            144753117,
            144751374,
            144692794,
            144693937,
            144709093,
            144688303,
            144718728,
            144712277,
            144711222,
            144703097,
            144703533,
            144701413,
            144708247,
            144730413,
            144725248,
            144709092,
            144706985,
            144707076,
            144709192,
            144715254,
            144713175,
            144701813,
            144716988,
            144713208,
            144710969
        ],
        "D": [
            144679861,
            144680032,
            144672273,
            144677313,
            144750526,
            144750179,
            144673134,
            144665105,
            144722610,
            144673318,
            144676038,
            144675084,
            144682415,
            144685094,
            144675142,
            144684537,
            144675967,
            144689440,
            144678803,
            144684839
        ],
        "C": [
            144667366,
            144667779,
            144684242,
            144665775,
            144661471,
            144672346,
            144750549,
            144664792,
            144665309,
            144663855,
            144664551,
            144665641,
            144665205,
            144669565,
            144668090,
            144672866,
            144664710,
            144674840,
            144672003
        ],
        "B": [
            144661250,
            144661582,
            144668540,
            144659176,
            144657404,
            144657564,
            144747880,
            144657576,
            144658942,
            144658191,
            144658845,
            144734517,
            144658134,
            144658621,
            144660270,
            144659944,
            144661387,
            144659383,
            144660032
        ],
        "A": [
            144658378,
            144658299,
            144661328,
            144657617,
            144657004,
            144657002,
            144746540,
            144657039,
            144657209,
            144657101,
            144657184,
            144734357,
            144657068,
            144657075,
            144657309,
            144657719,
            144657565,
            144657507,
            144658267
        ]
    },
    "name": "F. Perfect Matching",
    "statement": "You are given a tree consisting of n vertices (numbered from 1 to n) and\r\nn-1 edges (numbered from 1 to n-1). Initially, all vertices except\r\nvertex 1 are inactive.You have to process queries of three types: 1 v\r\nactivate the vertex v. It is guaranteed that the vertex v is inactive\r\nbefore this query, and one of its neighbors is active. After activating\r\nthe vertex, you have to choose a subset of edges of the tree such that\r\neach vertex is incident to chosen edge, and each vertex is not incident\r\nto any of the chosen edges in other words, this subset should represent\r\na perfect matching on the active part of the tree. If any such subset of\r\nedges exists, print the sum of indices of edges in it; otherwise, print\r\n0. 2 queries of this type will be asked only right after a query of type\r\n1, and there will be such queries. If your answer to the previous query\r\nwas 0, simply print 0; otherwise, print the subset of edges for the\r\nprevious query as follows: first, print the number of edges in the\r\nsubset, then print the indices of the chosen edges . The sum of indices\r\nshould be equal to your answer to the previous query. 3 terminate the\r\nprogram. Note that you should solve the problem in mode. It means that\r\nyou can\u2019t read the whole input at once. You can read each query only\r\nafter writing the answer for the last query. Use functions in and in\r\nlanguages after each writing in your program.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Info {\n    int c[2];\n    i64 s[2];\n    Info() : c{}, s{} {}\n    Info(int x, int v) : Info() {\n        c[x] = 1;\n        s[x] = v;\n    }\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.c[0] = a.c[0] + b.c[0];\n    c.c[1] = a.c[1] + b.c[1];\n    c.s[0] = a.s[0] + b.s[0];\n    c.s[1] = a.s[1] + b.s[1];\n    return c;\n}\n\nvoid apply(Info &a, int b) {\n    if (b) {\n        std::swap(a.c[0], a.c[1]);\n        std::swap(a.s[0], a.s[1]);\n    }\n}\n\nvoid apply(int &a, int b) {\n    a ^= b;\n}\n\ntemplate<class Info, class Tag,\n    class Merge = std::plus<Info>>\nstruct LazySegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void apply(int p, const Tag &v) {\n        ::apply(info[p], v);\n        ::apply(tag[p], v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    bool rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return true;\n        }\n        if (l >= x && r <= y && info[p].c[0] + info[p].c[1] == r - l) {\n            apply(p, v);\n            return true;\n        }\n        if (l >= x && r <= y && info[p].c[0] + info[p].c[1] == 0) {\n            return false;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        bool res;\n        if (rangeApply(2 * p + 1, m, r, x, y, v)) {\n            res = rangeApply(2 * p, l, m, x, y, v);\n        } else {\n            res = false;\n        }\n        pull(p);\n        return res;\n    }\n    bool rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--;\n        v--;\n        \n        adj[u].emplace_back(v, i + 1);\n        adj[v].emplace_back(u, i + 1);\n    }\n    \n    std::vector<int> id(n), parent(n, -1), dep(n), top(n), in(n), out(n), siz(n);\n    int clk = 0;\n    \n    std::function<void(int)> dfs1 = [&](int u) {\n        if (u > 0) {\n            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), std::pair(parent[u], id[u])));\n        }\n        siz[u] = 1;\n        for (auto &e : adj[u]) {\n            auto [v, i] = e;\n            id[v] = i;\n            parent[v] = u;\n            dep[v] = dep[u] + 1;\n            dfs1(v);\n            siz[u] += siz[v];\n            if (siz[v] > siz[adj[u][0].first]) {\n                std::swap(adj[u][0], e);\n            }\n        }\n    };\n    dfs1(0);\n    \n    std::function<void(int)> dfs2 = [&](int u) {\n        in[u] = clk++;\n        for (auto [v, i] : adj[u]) {\n            top[v] = v == adj[u][0].first ? top[u] : v;\n            dfs2(v);\n        }\n        out[u] = clk;\n    };\n    dfs2(0);\n    \n    LazySegmentTree<Info, int> seg(n);\n    seg.modify(0, Info(1, 0));\n    \n    while (true) {\n        int op;\n        std::cin >> op;\n        \n        if (op == 3) {\n            break;\n        }\n        \n        if (op == 1) {\n            int x;\n            std::cin >> x;\n            x--;\n            int s = 1;\n            for (auto [v, i] : adj[x]) {\n                s ^= seg.rangeQuery(in[v], in[v] + 1).c[1];\n            }\n            \n            seg.modify(in[x], Info(s, id[x]));\n            if (s == 1) {\n                x = parent[x];\n                while (x != -1) {\n                    if (!seg.rangeApply(in[top[x]], in[x] + 1, 1)) {\n                        break;\n                    }\n                    x = parent[top[x]];\n                }\n            }\n        }\n        \n        auto info = seg.info[1];\n        if (info.c[0] != info.c[1]) {\n            std::cout << 0 << std::endl;\n        } else if (op == 1) {\n            std::cout << info.s[1] << std::endl;\n        } else {\n            std::vector<int> ans;\n            for (int i = 0; i < n; i++) {\n                if (seg.rangeQuery(in[i], in[i] + 1).c[1] == 1) {\n                    ans.push_back(id[i]);\n                }\n            }\n            std::sort(ans.begin(), ans.end());\n            \n            std::cout << ans.size();\n            for (auto x : ans) {\n                std::cout << \" \" << x;\n            }\n            std::cout << std::endl;\n        }\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "interactive",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Perfect Matching.json",
    "editorial_link": "https://codeforces.com//blog/entry/99539",
    "editorial": "Let\u00e2\u0080\u0099s root the tree at vertex and try to analyze when a tree contains a\r\nperfect matching. If we want to find the maximum matching in a tree, we\r\ncan use some greedy approaches like \"take a leaf of the tree, match it\r\nwith its parent and remove both vertices, repeat this process until only\r\nisolated vertices remain\". If we are interested in a perfect matching,\r\nthen this process should eliminate all of the vertices.Let\u00e2\u0080\u0099s modify this\r\nprocess a bit by always picking the deepest leaf. If there exists a\r\nperfect matching, picking the deepest leaf will ensure that the tree\r\nalways remains a tree and doesn\u00e2\u0080\u0099t fall apart, i. e. there will always be\r\none connected component. It means that when we remove the leaf with its\r\nparent, this leaf is the only descendant of its parent.It\u00e2\u0080\u0099s easy to see\r\nthat whenever we remove a pair of vertices in this process, for each\r\nremaining vertex, the number of its descendants is either left unchanged\r\nor decreased by . It means that if a vertex has an even number of\r\ndescendants, it will have an even number of descendants until it is\r\nremoved, and the same for odd number of descendants.Let\u00e2\u0080\u0099s call the\r\nvertices with even number of descendants (including the vertex itself) ,\r\nand all the other vertices . A vertex cannot change its status in the\r\nprocess of building the perfect matching. Each leaf is and odd vertex,\r\nand if its parent has only one child, this parent is an even vertex. So,\r\nwhen we remove a pair of vertices, one of them (the child) is odd, and\r\nthe other of them (the parent) is even.This leads us to another way of\r\nbuilding the perfect matching: match each odd vertex with its parent,\r\nand make sure that everything is correct. Unfortunately, implementing it\r\nis per query, so we need something faster. We can see that each even\r\nvertex has at least one odd child (because if all children of a vertex\r\nare even, then the number of its descendants, including the vertex\r\nitself is odd). In order to find a perfect matching, we have to make\r\nsure that: each even vertex has one odd child; each odd vertex has an\r\neven vertex as its parent. All this means is that : it cannot be greater\r\nsince each even vertex has at least one odd child, and if it is smaller,\r\nit\u00e2\u0080\u0099s impossible to match the vertices. The perfect matching itself\r\nconsists of edges that connect odd vertices with their parents.Okay, now\r\nwe need some sort of data structure to maintain the status of each\r\nvertex (and the sum of edges that lead to an odd vertex if directed from\r\ntop to bottom). In our problem, we have to add new leaves to the tree\r\n(it happens when a vertex is activated), and this increases the number\r\nof descendants for every vertex on the path from the root to this new\r\nleaf. So, we need some sort of data structure that supports the\r\noperations \"add a new leaf\" and \"flip the status of all vertices on a\r\npath\". One of the structures that allow this is the Link/Cut Tree, but\r\nwe can use the fact that the whole tree is given in advance to build a\r\nHeavy-Light Decomposition on it, which is much easier to code.\r\nOperations on segments of paths can be done with a lazy segment tree,\r\nand each vertex then will be added in .\r\n"
}