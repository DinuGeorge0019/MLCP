{
    "link": "https://codeforces.com//contest/1766/problem/C",
    "problemId": "1690148",
    "problem_idx": "C",
    "shortId": "1766C",
    "contest_number": "1766",
    "problem_submissions": {
        "E": [
            184982392,
            184982173,
            184938042,
            184950686,
            184932260,
            184939673,
            184936898,
            184934396,
            184948204,
            184935811,
            184943315,
            184989151,
            184947057,
            184952057,
            184938439,
            184967483,
            187916344,
            184948513,
            184933180,
            184935854,
            184939624,
            184943840,
            184943132,
            184940980
        ],
        "F": [
            184949728,
            184939667,
            184976950,
            184964579,
            184958474,
            184962483,
            184966185,
            184957638,
            184969067,
            185089664,
            185089530,
            184977947,
            184997639,
            184973757,
            184966070,
            184960435,
            184974697,
            184966631,
            184990205,
            184997420
        ],
        "D": [
            184914984,
            184986868,
            184986781,
            184917638,
            184915781,
            184923898,
            184923871,
            184918405,
            184919375,
            184923813,
            184918585,
            184915933,
            184925192,
            184969262,
            184952734,
            184970967,
            184919304,
            184918923,
            184922752,
            184918317,
            184920694,
            184924980
        ],
        "C": [
            184909482,
            184913973,
            184911632,
            184918401,
            184916364,
            185395845,
            184914719,
            184914076,
            184920058,
            184913612,
            184913225,
            184921601,
            184918048,
            184950984,
            184973944,
            184914889,
            184913008,
            184914015,
            184915845,
            184914942,
            184915187
        ],
        "B": [
            184907198,
            184909422,
            184907991,
            184909353,
            184910422,
            184907995,
            184908723,
            184907965,
            184908129,
            184908832,
            184911921,
            184911885,
            184949263,
            184977162,
            184909079,
            184908305,
            184909027,
            184908934,
            184911337,
            184910448
        ],
        "A": [
            184906447,
            184906808,
            184906511,
            184906536,
            184906567,
            184906521,
            184906485,
            184906494,
            184906490,
            184992052,
            184907067,
            184906532,
            184906851,
            184947991,
            184978729,
            184906583,
            184906564,
            184906598,
            184906512,
            184906683,
            184906543
        ]
    },
    "name": "C. Hamiltonian Wall",
    "statement": "Sir Monocarp Hamilton is planning to paint his wall. The wall can be\r\nrepresented as a grid, consisting of 2 rows and m columns. Initially,\r\nthe wall is completely white.Monocarp wants to paint a black picture on\r\nthe wall. In particular, he wants cell (i, j) (the j-th cell in the i-th\r\nrow) to be colored black, if c_{i, j} = ”, and to be left white, if\r\nc_{i, j} = ”. Additionally, he wants each column to have at least one\r\nblack cell, so, for each j, the following constraint is satisfied: c_{1,\r\nj}, c_{2, j} or both of them will be equal to ”.In order for the picture\r\nto turn out smooth, Monocarp wants to place down a paint brush in some\r\ncell (x_1, y_1) and move it along the path (x_1, y_1), (x_2, y_2),\r\ndots, (x_k, y_k) so that: for each i, (x_i, y_i) and (x_{i+1}, y_{i+1})\r\nshare a common side; all black cells appear in the path ; white cells\r\ndon’t appear in the path. Determine if Monocarp can paint the wall.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<char>> c(2, vector<char>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> c[j][k];\n      }\n    }\n    vector<bool> ok(2, true);\n    int cnt = 0;\n    for (int j = 0; j < m; j++){\n      if (c[0][j] == 'B' && c[1][j] == 'B'){\n        cnt++;\n      }\n      if (c[0][j] == 'W'){\n        ok[cnt % 2] = false;\n      }\n      if (c[1][j] == 'W'){\n        ok[1 - cnt % 2] = false;\n      }\n    }\n    if (ok[0] || ok[1]){\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Hamiltonian Wall.json",
    "editorial_link": "https://codeforces.com//blog/entry/110066",
    "editorial": "Why is there a constraint of each column having at least one black cell?\r\nDoes the problem change a lot if there were white columns? Well, if such\r\na column was inbetween some black cells, then the answer would be \"\". If\r\nit was on the side of the grid, you could remove it and proceed to solve\r\nwithout it. So, that doesnât really change the problem other than\r\nremoving some casework.Letâs try to fix a start. Find a column that has\r\nonly one black cell in it. If there are no such columns, the answer is\r\nimmediately \"\". Otherwise, the path will always go through it in known\r\ndirections: to the left and to the right (if both of them exist). Letâs\r\nsolve the problem separately for the left part of the path and for the\r\nright one find a path that starts to the left of it and covers\r\neverything to the left and the same for the right part.Consider the\r\nright part.If the next column also has one black cell, then we can\r\ndetermine where to go uniquely. If this cell is on the opposite row,\r\nthen the answer is \"\". Otherwise, go there and proceed further.Let it\r\nhave two black cells now. Find the entire two black row rectangle of\r\nmaximum size that starts there. If thereâs nothing after it, you can\r\neasily traverse it any way you like. Otherwise, you have to traverse it\r\nin such a way that you end up in its last column, then go to the right\r\nfrom there. Turns out, thereâs only one way to achieve that. Go up/down\r\nto another row, go right, up/down to another row, right and so on. Now\r\nyou just have to check if you end up in the correct row.Thus, you can\r\nsimulate the path to the left and to the right and check if you never\r\nget stuck.Overall comlexity: per testcase.\r\n",
    "hint": []
}