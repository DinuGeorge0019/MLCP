{
    "link": "https://codeforces.com//contest/2043/problem/A",
    "problemId": "3103846",
    "problem_idx": "A",
    "shortId": "2043A",
    "contest_number": "2043",
    "problem_submissions": {
        "G": [
            298276621,
            298458376,
            298455954,
            298459741,
            298498128,
            298494225,
            298493989,
            298368643,
            298368617
        ],
        "F": [
            298243973,
            298258053,
            298242817,
            298260253,
            298257085,
            298250612,
            298241233,
            298252743,
            298266622,
            298254223,
            298258269,
            298270540,
            298270292,
            298270970,
            298272964,
            298350526,
            298284182,
            298276985,
            298272819,
            298283274,
            298421391,
            298417038,
            298257904
        ],
        "E": [
            298230325,
            298236565,
            298229495,
            298226934,
            298227308,
            298237122,
            298220698,
            298238215,
            298226770,
            298234499,
            298239196,
            298230091,
            298228297,
            298244169,
            298310355,
            298234798,
            298238168,
            298247710,
            298242187,
            298286367
        ],
        "D": [
            298219869,
            298216982,
            298222571,
            298218218,
            298213410,
            298224781,
            298213619,
            298219577,
            298216318,
            298221470,
            298226089,
            298219311,
            298219518,
            298230143,
            298226137,
            298226579,
            298229601,
            298224236,
            298231826
        ],
        "C": [
            298215825,
            298213305,
            298214855,
            298212674,
            298210052,
            298218770,
            298246686,
            298216835,
            298211668,
            298217178,
            298218473,
            298215699,
            298214498,
            298219482,
            298220559,
            298222653,
            298215672,
            298216539,
            298220531
        ],
        "B": [
            298205974,
            298203999,
            298204560,
            298204165,
            298201534,
            298206623,
            298209665,
            298205595,
            298204637,
            298205310,
            298207112,
            298207961,
            298204179,
            298210111,
            298210081,
            298211372,
            298204136,
            298203902,
            298209938
        ],
        "A": [
            298200061,
            298199218,
            298199258,
            298199378,
            298199175,
            298200132,
            298199984,
            298200407,
            298199812,
            298205860,
            298199259,
            298199630,
            298199502,
            298199251,
            298211149,
            298199244,
            298199260,
            298199390,
            298200087
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137801",
    "editorial": "Let\u00e2\u0080\u0099s try to solve this problem \"naively\": obviously, while we have at\r\nleast one coin with value , we should transform it, since it increases\r\nthe number of coins we get. We can simulate this process, but the number\r\nof transformations we get might be really large, so we need to speed\r\nthis up.Let\u00e2\u0080\u0099s make it faster the following way: instead of transforming\r\njust one coin, we will transform all coins at once. So, after one\r\noperation, we will have coins with value ; after two operations, we will\r\nhave coins with value each, and so on. This can be implemented using a\r\nsimple while-loop: while the value of our coins is greater than , we\r\ndivide it by and double the number of coins. This solution works in .It\r\nis also possible to derive a formula for the answer: the number of times\r\nwe need to divide a number by so it becomes less than is , and the\r\nnumber of coins we will get is to the power of that expression. However,\r\nyou must be very careful with this approach, because it can have severe\r\nprecision issues due to the fact that standard logarithm functions work\r\nwith floating-point numbers, so they are imprecise. You should use some\r\nway to calculate without floating-point calculations; for example,\r\niterating (or binary searching) on the power of you need to divide the\r\nnumber by so that it becomes less than .\r\n",
    "name": "A. Coin Transformation",
    "statement": "Initially, you have a coin with value n. You can perform the following\r\noperation any number of times (possibly zero): transform one coin with\r\nvalue x, where x is (x>3), into two coins with value\r\nlfloor\r\nfrac{x}{4}\r\nrfloor. What is the maximum number of coins you can have after\r\nperforming this operation any number of times?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(\"1.in\", \"r\", stdin);  freopen(\"1.out\", \"w\", stdout);}using ll = long long;\u00a0map<ll, ll> mp;\u00a0ll Dfs(ll x) {  if(x <= 3) return 1;  if(mp.count(x)) return mp[x];  return mp[x] = 2 * Dfs(x / 4);}\u00a0void Solve() {  ll n;  cin >> n;  cout << Dfs(n) << \"\\n\";}\u00a0int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T;  cin >> T;  while(T--) Solve();  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Coin Transformation.json"
}