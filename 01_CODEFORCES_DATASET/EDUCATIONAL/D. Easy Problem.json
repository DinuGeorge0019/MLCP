{
    "link": "https://codeforces.com//contest/1096/problem/D",
    "problemId": "275411",
    "problem_idx": "D",
    "shortId": "1096D",
    "contest_number": "1096",
    "problem_submissions": {
        "E": [
            47642254,
            47649536,
            47653679,
            47648526,
            47652142,
            47650532,
            47647313,
            47647929,
            47648225,
            47694278,
            47661678,
            47661672,
            47660722,
            47660711,
            47660680,
            47660618,
            47660582,
            47660120,
            47656494,
            47655953,
            47657647,
            47817653,
            47648933,
            47665496,
            47659752
        ],
        "F": [
            47639264,
            47644997,
            47642974,
            47644488,
            47645071,
            47645827,
            47642225,
            47651889,
            47635316,
            47632710,
            47640155,
            47703351,
            47703260,
            47636058,
            47646007,
            47639902,
            47642860,
            47639982,
            47644292,
            47643281,
            47642796
        ],
        "G": [
            47638289,
            47637580,
            47634875,
            47638768,
            47640048,
            47642247,
            47630999,
            47650309,
            47660389,
            47657262,
            47654048,
            47629119,
            47636649,
            47642830,
            47708729,
            47708522,
            47703016,
            47700940,
            47672367,
            47656352,
            47640712,
            47641093,
            47648435,
            47638969,
            47687049,
            47686924,
            47686825,
            47646867,
            47636051,
            47647716
        ],
        "D": [
            47635471,
            47633956,
            47638959,
            47636889,
            47629667,
            47638623,
            47639300,
            47633153,
            47649242,
            47638629,
            47633639,
            47630356,
            47634376,
            47631648,
            47636547,
            47634092,
            47638812,
            72047403,
            47632964,
            47638521
        ],
        "C": [
            47633317,
            47631680,
            47629418,
            47632179,
            47634755,
            47633350,
            47643997,
            47635493,
            47651183,
            47635153,
            47632143,
            47638363,
            47631171,
            47629984,
            47635983,
            47631947,
            47634094,
            47646109,
            47636660
        ],
        "B": [
            47631281,
            47629817,
            47632624,
            47628290,
            47637243,
            47631678,
            47637542,
            47630349,
            47652229,
            47629170,
            47629856,
            47637300,
            47629416,
            47628505,
            47627019,
            47628065,
            47630666,
            94912172,
            47637515,
            47631993
        ],
        "A": [
            47628887,
            47626041,
            47629759,
            47624992,
            47630193,
            47627541,
            47635962,
            47626700,
            47652441,
            47625024,
            47625341,
            47625412,
            47625492,
            47624882,
            47624919,
            47624912,
            47627405,
            47625425,
            47625087
        ]
    },
    "name": "D. Easy Problem",
    "statement": "Vasya is preparing a contest, and now he has written a statement for an\r\neasy problem. The statement is a string of length n consisting of\r\nlowercase Latin latters. Vasya thinks that the statement can be\r\nconsidered hard if it contains a subsequence ; otherwise the statement\r\nis easy. For example, , , can be considered hard statements, while , and\r\nare easy statements. Vasya doesn’t want the statement to be hard. He may\r\nremove some characters from the statement in order to make it easy. But,\r\nof course, some parts of the statement can be crucial to understanding.\r\nInitially the of the statement is 0, and removing i-th character\r\nincreases the by a_i (the index of each character is considered as it\r\nwas in the original statement, so, for example, if you delete character\r\nfrom , and then character , the index of is still 4 even though you\r\ndelete it from the string ).Vasya wants to calculate the minimum of the\r\nstatement, if he removes some characters (possibly zero) so that the\r\nstatement is easy. Help him to do it!Recall that subsequence is a\r\nsequence that can be derived from another sequence by deleting some\r\nelements without changing the order of the remaining elements.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000000000000LL\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nll n,k,a[MAXN];\nll dp[MAXN][4];\n//0: no\n//1: h\n//2: ha\n//3: har\nchar str[MAXN];\nvoid relax(ll &a,ll b) {a=min(a,b);}\nint main()\n{\n    scanf(\"%lld\",&n);\n    scanf(\"%s\",str+1);\n    for(ll i=1;i<=n;i++) scanf(\"%lld\",&a[i]);\n    for(ll i=0;i<=n;i++) dp[i][0]=dp[i][1]=dp[i][2]=dp[i][3]=INF;\n    dp[0][0]=0;\n    for(ll i=0;i<n;i++)\n    {\n        for(ll j=0;j<4;j++)\n        {\n            if(dp[i][j]==INF) continue;\n            relax(dp[i+1][j],dp[i][j]+a[i+1]);\n            if(j==0)\n            {\n                if(str[i+1]=='h') relax(dp[i+1][j+1],dp[i][j]);\n                else relax(dp[i+1][j],dp[i][j]);\n            }\n            else if(j==1)\n            {\n                if(str[i+1]=='a') relax(dp[i+1][j+1],dp[i][j]);\n                else relax(dp[i+1][j],dp[i][j]);\n            }\n            else if(j==2)\n            {\n                if(str[i+1]=='r') relax(dp[i+1][j+1],dp[i][j]);\n                else relax(dp[i+1][j],dp[i][j]);\n            }\n            else\n            {\n                if(str[i+1]!='d') relax(dp[i+1][j],dp[i][j]);\n            }\n        }\n    }\n    printf(\"%lld\\n\",min(min(dp[n][0],dp[n][1]),min(dp[n][2],dp[n][3])));\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Easy Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/64156",
    "editorial": "Denote string as .We will solve this problem with dynamic programming.\r\nDenote the minimum possible ambiguity if we considered first letters of\r\nstatement and got prefix having length as a subsequence of the string.If\r\n-th letter of the statement is not equal to , then we donât have to\r\nchange it.Otherwise we either change the letter, or let it stay as it is\r\n(and the length of the prefix we found so far increases): .\r\n",
    "hint": []
}