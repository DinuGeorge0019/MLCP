{
    "link": "https://codeforces.com//contest/1257/problem/F",
    "problemId": "470641",
    "problem_idx": "F",
    "shortId": "1257F",
    "contest_number": "1257",
    "problem_submissions": {
        "D": [
            65057118,
            65056815,
            64811909,
            64812228,
            64902701,
            64852999,
            64814000,
            64812775,
            64810546,
            64816528,
            64811860,
            64815149,
            64813583,
            64859190,
            64812263,
            64833625,
            64835681,
            64837730,
            64812160,
            64814684,
            64816849,
            64813089,
            64816979,
            64819402,
            64816732
        ],
        "C": [
            65056409,
            64806576,
            64805235,
            64806785,
            64807190,
            64804696,
            64807450,
            64806032,
            64809153,
            64805479,
            64859181,
            64806083,
            64833699,
            64837249,
            64838553,
            64806562,
            64809106,
            64808660,
            64805745,
            64806256,
            64807560,
            64807194
        ],
        "G": [
            64897847,
            64897831,
            64897799,
            64897485,
            64897435,
            64897360,
            64897323,
            64897206,
            64897135,
            64897132,
            64832008,
            64834753,
            64834055,
            65121895,
            65107512,
            65106890,
            64896695,
            64896568,
            64824847,
            64838006,
            64831302,
            64827437,
            64838916,
            64835759,
            64897295,
            64843586,
            64835359,
            64859234,
            64838704,
            65758026,
            65701826,
            64838221,
            64811892,
            64819153,
            64825152,
            64845699,
            211233713
        ],
        "E": [
            64865638,
            64865598,
            64816641,
            64819423,
            64857985,
            64831912,
            64817543,
            64814313,
            64819647,
            64817584,
            64819210,
            64817767,
            64859197,
            64814324,
            64824835,
            64832464,
            64832777,
            64820509,
            64818561,
            64820860,
            64817451,
            64823687,
            64821709,
            64824423
        ],
        "F": [
            64821055,
            64823926,
            64819069,
            64824118,
            64836060,
            64833509,
            64822156,
            64828427,
            64823151,
            64859227,
            64836114,
            64824755,
            64828355,
            64829448,
            64829060,
            64827403,
            64826552,
            64828456,
            64828341,
            64826098,
            64830812
        ],
        "B": [
            64802390,
            64803311,
            64804526,
            64804462,
            64802487,
            64804783,
            64803616,
            64806366,
            64802273,
            64859169,
            64803153,
            64833735,
            64838243,
            64839005,
            64803686,
            64806451,
            64806108,
            64802622,
            64803655,
            64803331,
            64803958
        ],
        "A": [
            64800956,
            64800953,
            64801859,
            64801038,
            64800918,
            64800975,
            64800962,
            64803138,
            64800908,
            64859160,
            64801089,
            64833779,
            64838753,
            64839327,
            64800961,
            64801572,
            64801191,
            64800917,
            64801440,
            64800919,
            64801087
        ]
    },
    "name": "F. Make Them Similar",
    "statement": "Let\u2019s call two numbers if their binary representations contain the same\r\nnumber of digits equal to 1. For example: 2 and 4 are similar (binary\r\nrepresentations are 10 and 100); 1337 and 4213 are similar (binary\r\nrepresentations are 10100111001 and 1000001110101); 3 and 2 are not\r\nsimilar (binary representations are 11 and 10); 42 and 13 are similar\r\n(binary representations are 101010 and 1101). You are given an array of\r\nn integers a_1, a_2, ..., a_n. You may choose a non-negative integer x,\r\nand then get another array of n integers b_1, b_2, ..., b_n, where b_i =\r\na_i\r\noplus x (\r\noplus denotes bitwise XOR).Is it possible to obtain an array b where all\r\nnumbers are similar to each other?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int BITS = 30;\nconst int HALF = BITS / 2;\n\nint N;\nvector<int> A;\n\nvoid normalize(vector<int> &counts) {\n    assert((int) counts.size() == N);\n\n    for (int i = N - 1; i >= 0; i--)\n        counts[i] -= counts[0];\n}\n\nint main() {\n    cin >> N;\n    A.resize(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    map<vector<int>, int> possible;\n\n    for (int mask = 0; mask < 1 << HALF; mask++) {\n        vector<int> counts(N, 0);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = __builtin_popcount((A[i] & ((1 << HALF) - 1)) ^ mask);\n\n        normalize(counts);\n\n        if (possible.find(counts) == possible.end())\n            possible[counts] = mask;\n    }\n\n    for (int mask = 0; mask < 1 << HALF; mask++) {\n        vector<int> counts(N, 0);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = __builtin_popcount(A[i] >> HALF ^ mask);\n\n        normalize(counts);\n\n        for (int i = 0; i < N; i++)\n            counts[i] = -counts[i];\n\n        if (possible.find(counts) != possible.end()) {\n            int other = possible[counts];\n            cout << (mask << HALF) + other << '\\n';\n            return 0;\n        }\n    }\n\n    cout << -1 << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "hashing",
        "meet-in-the-middle"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Make Them Similar.json",
    "editorial_link": "https://codeforces.com//blog/entry/71434",
    "editorial": "Iterating over all possible values of and checking them may be too slow\r\n(though heavily optimized brute force is difficult to eliminate in this\r\nproblem), so we need to speed this approach up.The resulting number\r\nconsists of bits. Let\u00e2\u0080\u0099s use the classical meet-in-the-middle trick: try\r\nall combinations of lowest bits, try all combinations of highest bits,\r\nand somehow \"merge\" the results.When we fix a combination of lowest\r\nbits, we fix lowest bits in every . Suppose that there are ones among\r\nlowest bits of .Analogically, when we fix a combination of highest bits,\r\nwe fix highest bits in every . Suppose that there are ones among highest\r\nbits of .We want to find a combination of lowest and highest bits such\r\nthat is the same for each . Let\u00e2\u0080\u0099s represent each combination of lowest\r\nbits with an -dimensional vector with coordinates . Let\u00e2\u0080\u0099s also represent\r\neach combination of highest bits with an -dimensional vector with\r\ncoordinates . We want to find a combination of lowest bits and a\r\ncombination of highest bits such that their vectors are opposite. We can\r\ndo so, for example, by precalculating all vectors for all combinations\r\nof lowest bits, storing them in a map or a trie, iterating on a\r\ncombination of highest bits and searching for the opposite vector in the\r\nmap/trie.\r\n"
}