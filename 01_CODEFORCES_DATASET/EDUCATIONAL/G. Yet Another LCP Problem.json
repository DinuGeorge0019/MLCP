{
    "link": "https://codeforces.com//contest/1073/problem/G",
    "problemId": "243302",
    "problem_idx": "G",
    "shortId": "1073G",
    "contest_number": "1073",
    "problem_submissions": {
        "G": [
            44873257,
            44854949,
            44872747,
            44857777,
            44904113,
            44992378,
            44992266,
            44905426,
            44884903,
            44945894,
            44917741
        ],
        "F": [
            44867029,
            44865010,
            44864483,
            44871287,
            44872814,
            44868847,
            44879071,
            44874774,
            44882300,
            44882274,
            44882259,
            44904164,
            45084744,
            45695799,
            44888299
        ],
        "E": [
            44859477,
            44871290,
            44861403,
            44863217,
            44864294,
            44859185,
            44863995,
            44861353,
            44862909,
            44862761,
            44864156,
            44861997,
            44866321,
            44865560,
            44864610,
            44864622,
            44866506,
            44866536,
            44864718,
            44867428
        ],
        "D": [
            44857129,
            44872779,
            44856075,
            44857988,
            44858337,
            44861164,
            44866799,
            44854399,
            44858649,
            44887677,
            44857825,
            44863255,
            44857894,
            44856716,
            44859464,
            44857349,
            44858547,
            44860520,
            44859062,
            44858058
        ],
        "C": [
            44852935,
            44867793,
            44850047,
            44853493,
            44853830,
            44872109,
            44870370,
            44851223,
            44852821,
            44887759,
            44853381,
            44855264,
            44855099,
            44853761,
            44855656,
            44859785,
            44852765,
            44856270,
            44855283,
            44855046
        ],
        "B": [
            44847780,
            44861886,
            44847247,
            44849026,
            44846682,
            44849066,
            44868560,
            44847702,
            44847526,
            44848456,
            44847355,
            44849516,
            44847583,
            44849338,
            44847283,
            44847620,
            44847641,
            44850429,
            44848272
        ],
        "A": [
            44846309,
            44861253,
            44846364,
            44847286,
            44846147,
            44847332,
            44867659,
            44846213,
            44846204,
            44846510,
            44846224,
            44846724,
            44846207,
            44847114,
            44846296,
            44846271,
            44846181,
            44848595,
            44846401
        ]
    },
    "name": "G. Yet Another LCP Problem",
    "statement": "Let\r\ntext{LCP}(s, t) be the length of the longest common prefix of strings s\r\nand t. Also let s[x\r\ndots y] be the substring of s from index x to index y (inclusive). For\r\nexample, if s = \"\", then s[1\r\ndots 3] = \"\", s[2\r\ndots 5] = \"\".You are given a string s of length n and q queries. Each\r\nquery is a pair of integer sets a_1, a_2,\r\ndots, a_k and b_1, b_2,\r\ndots, b_l. Calculate\r\nsum\r\nlimits_{i = 1}^{i = k}\r\nsum\r\nlimits_{j = 1}^{j = l}{\r\ntext{LCP}(s[a_i\r\ndots n], s[b_j\r\ndots n])} for each query.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <string>\n\nusing namespace std;\n\nstruct SuffixDataStructure {\n  const std::vector<int> &a;\n  std::vector<int> sa;\n  std::vector<int> isa;\n  std::vector<int> lcp;\n  std::vector<int> lg;\n  std::vector<std::vector<int>> rmq;\n\n  // a[i]>=0\n  SuffixDataStructure(const std::vector<int> &a) : a(a) {\n    sa = suffix_array(a);\n    sa.insert(sa.begin(), a.size());\n    build_lcp();\n    build_rmq();\n  }\n\n  int get_lcp(int i, int j) {\n    if (i == j) {\n      return a.size() - std::max(i, j);\n    }\n    i = isa[i];\n    j = isa[j];\n    if (i > j) {\n      std::swap(i, j);\n    }\n    int k = __lg(j - i);\n    return std::min(rmq[k][i], rmq[k][j - (1 << k)]);\n  }\n\n  vector<int> suffix_array(vector<int> a) {\n    const int n = a.size();\n    if (n == 0) return {};\n    const int H = *max_element(begin(a), end(a)) + 1;\n    vector<bool> s(n);\n    vector<int> next(n), ss;\n    for (int i = n - 2; i >= 0; i--) {\n      s[i] = a[i] == a[i + 1] ? s[i + 1] : a[i] < a[i + 1];\n      if (!s[i] && s[i + 1]) ss.push_back(i + 1);\n    }\n    reverse(ss.begin(), ss.end());\n    for (int i = 0; i < ss.size(); i++) {\n      next[ss[i]] = i + 1 < ss.size() ? ss[i + 1] : n;\n    }\n    auto induced_sort = [&]() {\n      vector<int> sa(n, -1), L(H + 1);\n      for (int i = 0; i < n; i++) L[a[i] + 1]++;\n      for (int i = 0; i < H; i++) L[i + 1] += L[i];\n      auto S = L;\n      for (int i = (int)ss.size() - 1; i >= 0; i--) {\n        int j = ss[i];\n        sa[--S[a[j] + 1]] = j;\n      }\n      S = L;\n      sa[L[a[n - 1]]++] = n - 1;\n      for (int i = 0; i < n; i++) {\n        int j = sa[i] - 1;\n        if (j >= 0 && !s[j]) sa[L[a[j]]++] = j;\n      }\n      for (int i = n - 1; i >= 0; i--) {\n        int j = sa[i] - 1;\n        if (j >= 0 && s[j]) sa[--S[a[j] + 1]] = j;\n      }\n      return sa;\n    };\n    vector<int> rank(n);\n    int j = -1;\n    for (int i : induced_sort()) {\n      if (0 < i && s[i] && !s[i - 1]) {\n        if (j != -1) rank[i] = rank[j] + (next[i] - i != next[j] - j || !equal(a.begin() + i, a.begin() + next[i], a.begin() + j));\n        j = i;\n      }\n    }\n    vector<int> b;\n    for (int i : ss) b.push_back(rank[i]);\n    vector<int> tmp(ss);\n    ss.clear();\n    for (int i : suffix_array(b)) ss.push_back(tmp[i]);\n    return induced_sort();\n  }\n\n  void build_lcp() {\n    const int n = a.size();\n    isa.resize(n + 1);\n    lcp.assign(n + 1, 0);\n    for (int i = 0; i <= n; i++) {\n      isa[sa[i]] = i;\n    }\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n      int j = sa[isa[i] - 1];\n      k = std::max(0, k - 1);\n      while (i + k < n && j + k < n && a[i + k] == a[j + k]) {\n        k++;\n      }\n      lcp[isa[i] - 1] = k;\n    }\n  }\n\n  void build_rmq() {\n    const int n = lcp.size();\n    lg.resize(n + 1);\n    for (int i = 2; i <= n; i++) {\n      lg[i] = lg[i / 2] + 1;\n    }\n    const int m = lg[n];\n    rmq.assign(m + 1, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      rmq[0][i] = lcp[i];\n    }\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j + (1 << i) < n; j++) {\n        rmq[i + 1][j] = std::min(rmq[i][j], rmq[i][j + (1 << i)]);\n      }\n    }\n  }\n};\n\nconst long long inf = 1e9;\n\nstruct Stack {\n  vector<pair<int, long long>> a;\n  long long sum = 0;\n\n  void push() {\n    sum += inf;\n    a.emplace_back(inf, 1);\n  }\n\n  void cut(int k) {\n    long long s = 0;\n    while (!a.empty() && a.back().first >= k) {\n      s += a.back().second;\n      sum -= a.back().first * a.back().second;\n      a.pop_back();\n    }\n    sum += s * k;\n    a.emplace_back(k, s);\n  }\n\n  int total() {\n    int s = 0;\n    for (auto p : a) s += p.second;\n    return s;\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n  vector<int> a;\n  for (int i = 0; i < n; i++) {\n    a.push_back(s[i] - 'a');\n  }\n  SuffixDataStructure sa(a);\n\n  while (q--) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    vector<int> a(u);\n    vector<int> b(v);\n    for (int i = 0; i < u; i++) scanf(\"%d\", &a[i]), a[i]--, a[i] = sa.isa[a[i]];\n    for (int i = 0; i < v; i++) scanf(\"%d\", &b[i]), b[i]--, b[i] = sa.isa[b[i]];\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    int i = 0;\n    int j = 0;\n    Stack A, B;\n    int p = -1;\n    long long ans = 0;\n    while (i < u || j < v) {\n      if (j == v || (i < u && a[i] < b[j])) {\n        int h = p == -1 ? 0 : sa.get_lcp(sa.sa[p], sa.sa[a[i]]);\n        p = a[i];\n        A.cut(h);\n        B.cut(h);\n        ans += B.sum;\n        A.push();\n        i++;\n      } else {\n        int h = p == -1 ? 0 : sa.get_lcp(sa.sa[p], sa.sa[b[j]]);\n        p = b[j];\n        A.cut(h);\n        B.cut(h);\n        ans += A.sum;\n        B.push();\n        j++;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "string suffix structures"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Yet Another LCP Problem.json",
    "editorial_link": "https://codeforces.com/blog/entry/62742",
    "editorial": "At first, implement your favourite string suffix structure for comparing\r\npair of suffixes lexicographically fast enough. For example, it\u00e2\u0080\u0099s a\r\nSuffix Array + linear LCP + Sparse Table. Now we can compare two\r\nsuffixes and by finding and comparing with .We will process queries\r\nonline. Let current query be a pair of arrays () and (). We will\r\ncalculate answer in two parts: To calculate the first sum we can sort\r\nall suffixes in lexicographical order and maintain some information for\r\nprefixes of . What information we need to maintain? We need some Data\r\nStructure which will hold of suffixes from . When we process some we\r\nneed just a total sum of all in the DS. If , we should add to the DS\r\nlength of -th suffix. And when we move from to we must recalculate some\r\n. Since is sorted, all we need is to set .In fact, this Data Structure\r\nis just a . In this we will hold for each length number of suffixes with\r\n(we will hold only non-zero values). When we should add some suffix , we\r\nmanually increase some value by one. Setting with can be done with\r\ndecreasing maximum in while its more than . It can be proven, that there\r\nwill be operations with for one query. The total sum can be maintained\r\nin some global variable, which will be recalculated each time changes.To\r\ncalculate the second sum we can just reverse and run the same algorithm.\r\nSo total complexity is .\r\n"
}