{
    "link": "https://codeforces.com//contest/1175/problem/C",
    "problemId": "354215",
    "problem_idx": "C",
    "shortId": "1175C",
    "contest_number": "1175",
    "problem_submissions": {
        "E": [
            55152697,
            55143297,
            55144842,
            55149453,
            55145090,
            55152529,
            55156277,
            55145238,
            55141766,
            55151809,
            55150612,
            55150119,
            55150752,
            55156812,
            55152738,
            55154944,
            55150125,
            55154652,
            55158266,
            55163765
        ],
        "F": [
            55143004,
            55151795,
            55152215,
            55142312,
            55154601,
            55143715,
            55151506,
            55166103,
            55151247,
            55162817,
            55160160,
            55154302,
            55159983,
            55153216,
            55161466,
            55160616,
            55159270,
            55167756,
            76726554,
            55159045
        ],
        "D": [
            55137941,
            55140293,
            55140750,
            55145972,
            55139564,
            55144646,
            55138002,
            55141894,
            55136780,
            55138695,
            55141164,
            55144507,
            55139116,
            55139569,
            55142712,
            55138367,
            55143330,
            55142605,
            55147375,
            55147140
        ],
        "C": [
            55134609,
            55137594,
            55139019,
            55137598,
            55135791,
            55137314,
            55136601,
            55136692,
            55135046,
            55136312,
            55137446,
            55142893,
            55137610,
            55138266,
            55140998,
            55137003,
            55146366,
            55138295,
            55140586,
            55141407
        ],
        "B": [
            55132016,
            55133684,
            55136306,
            55134307,
            55133707,
            55134207,
            55135033,
            55133685,
            55171853,
            55133665,
            55137967,
            55138315,
            55133858,
            55138192,
            55135842,
            55133934,
            55137057,
            55134510,
            55135402,
            55137596
        ],
        "A": [
            55129715,
            55129741,
            55129684,
            55129658,
            55129917,
            55129679,
            55130628,
            55129791,
            55130186,
            55130042,
            55129731,
            55135937,
            55130056,
            55130398,
            55129926,
            55129655,
            55132057,
            55130203,
            55131132,
            55132516
        ],
        "G": [
            55169838,
            55219359,
            58237199,
            55161904,
            55163020
        ]
    },
    "name": "C. Electrification",
    "statement": "At first, there was a legend related to the name of the problem, but now\r\nit’s just a formal statement.You are given n points a_1, a_2,\r\ndots, a_n on the OX axis. Now you are asked to find such an integer\r\npoint x on OX axis that f_k(x) is minimal possible.The function f_k(x)\r\ncan be described in the following way: form a list of distances d_1,\r\nd_2,\r\ndots, d_n where d_i = |a_i - x| (distance between a_i and x); sort list\r\nd in non-descending order; take d_{k + 1} as a result. If there are\r\nmultiple optimal answers you can print any of them.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e18;\n\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\n\tvector<ll> points(n);\n\tfor (int i = 0; i < n; ++i) cin >> points[i];\n\tsort(points.begin(), points.end());\n\n\tll res = INF;\n\tll x = -1;\n\tfor (int i = 0; i+k < n; ++i) {\n\t\tll offer = (points[i+k] - points[i] + 1) / 2;\n\t\tif (offer < res) {\n\t\t\tres = offer;\n\t\t\tx = (points[i+k] + points[i]) / 2;\n\t\t}\n\t}\n\tcout << x << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint t;\n\tcin >> t;\n\tfor (int ti = 0; ti < t; ++ti) {\n\t\tsolve();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Electrification.json",
    "editorial_link": "https://codeforces.com/blog/entry/67484",
    "editorial": "First observation: closest points to any point form a contiguous\r\nsubsegment , so .Second observation: for any contiguous subsegment all\r\npoints this subsegment closest to, also form a contiguous segment . And,\r\nbecause of the nature of , value of is minimal in borders and .So, all\r\nwe need is to check all and . But what is a value of ? Itâs such point,\r\nthat , but . So, itâs just in the middle of segment . Note, that and ,\r\nso itâs enough to check only -s.In result, all we need is to find\r\nminimal possible value and resulting .\r\n",
    "hint": []
}