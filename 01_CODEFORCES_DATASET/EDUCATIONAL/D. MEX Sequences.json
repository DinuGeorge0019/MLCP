{
    "link": "https://codeforces.com//contest/1613/problem/D",
    "problemId": "1209364",
    "problem_idx": "D",
    "shortId": "1613D",
    "contest_number": "1613",
    "problem_submissions": {
        "F": [
            137662460,
            137680102,
            137669930,
            137680388,
            137676481,
            137689054,
            137677544,
            137670783,
            137684225,
            137683109,
            137695659,
            137689822,
            137678272,
            137672898,
            137688331,
            137700851,
            137691450,
            137776678,
            137775393,
            137689226,
            137689675,
            137703031
        ],
        "E": [
            137655072,
            137656585,
            137663380,
            137661012,
            137661380,
            137660230,
            137663524,
            137662766,
            137664563,
            137669185,
            137669422,
            137670709,
            137669302,
            137681566,
            137674305,
            137665393,
            137678462,
            137670584,
            137679435,
            137664635
        ],
        "D": [
            137646881,
            137645109,
            137652424,
            137648321,
            137652518,
            137652740,
            137657211,
            137653818,
            137651858,
            137656413,
            137653916,
            137656694,
            137657143,
            137657455,
            137659528,
            137655936,
            137665693,
            137656041,
            137646478,
            137655272
        ],
        "C": [
            137634971,
            137635045,
            137641150,
            137632004,
            137642031,
            137634798,
            137639433,
            137636954,
            137638798,
            137636121,
            137638972,
            137644414,
            137635322,
            137642182,
            137647281,
            137639264,
            137643162,
            137637445,
            137634607,
            137639818
        ],
        "B": [
            137631052,
            137629986,
            137635688,
            137629262,
            137630431,
            137630193,
            137632384,
            137630955,
            137634981,
            137632132,
            137632097,
            137637773,
            137629234,
            137636896,
            137636754,
            137634314,
            137635536,
            137633727,
            137630130,
            137635595
        ],
        "A": [
            137628660,
            137628698,
            137630882,
            137628467,
            137628655,
            137628608,
            137630089,
            137628835,
            137631891,
            137629156,
            137628914,
            137629328,
            137628519,
            137632470,
            137630776,
            137629772,
            137629039,
            137628924,
            137628505,
            137630736
        ]
    },
    "name": "D. MEX Sequences",
    "statement": "Let’s call a sequence of integers x_1, x_2,\r\ndots, x_k if for all i (1\r\nle i\r\nle k) |x_i -\r\noperatorname{MEX}(x_1, x_2,\r\ndots, x_i)|\r\nle 1 holds. Where\r\noperatorname{MEX}(x_1,\r\ndots, x_k) is the minimum non-negative integer that doesn’t belong to\r\nthe set x_1,\r\ndots, x_k. For example,\r\noperatorname{MEX}(1, 0, 1, 3) = 2 and\r\noperatorname{MEX}(2, 1, 5) = 0.You are given an array a consisting of n\r\nnon-negative integers. Calculate the number of non-empty subsequences of\r\na given array. The number of subsequences can be very large, so print it\r\nmodulo 998244353. Note: a subsequence of an array a is a sequence\r\n[a_{i_1}, a_{i_2},\r\ndots, a_{i_m}] meeting the constraints 1\r\nle i_1 < i_2 <\r\ndots < i_m\r\nle n. If two different ways to choose the sequence of indices [i_1, i_2,\r\ndots, i_m] yield the same subsequence, the resulting subsequence should\r\nbe counted twice (i. e. two subsequences are different if their\r\nsequences of indices [i_1, i_2,\r\ndots, i_m] are not the same).\r\n",
    "solutions": [
        "\n#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define imie(x) #x << \": \" << x\n\nusing namespace std;\n\ntemplate <uint32_t base>\nstruct Montgomery {\n\tusing i32 = int32_t;\n\tusing u32 = uint32_t;\n\tusing u64 = uint64_t;\n\n\tstatic constexpr u32 mod() {\n\t\treturn base;\n\t}\n\n\tstatic constexpr u32 np = []() {\n\t\tu32 x = base;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tx *= 2u - base * x;\n\t\t}\n\t\treturn -x;\n\t}();\n\tstatic constexpr u32 r2 = -(u64)(base) % base;\n\n\tstatic_assert(base < (1u << 30));\n\tstatic_assert(base * np + 1 == 0);\n\n\tstatic u32 reduce(u64 x) {\n\t\treturn (x + (u64)((u32)x * np) * base) >> 32;\n\t}\n\n\tu32 x;\n\tMontgomery(): x(0) {}\n\tconstexpr Montgomery(long long y): x(y ? reduce((u64)(y % base + base) * r2) : 0) {}\n\n\tMontgomery& operator +=(const Montgomery& ot) {\n\t\tif ((i32)(x += ot.x - 2 * base) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator -=(const Montgomery& ot) {\n\t\tif ((i32)(x -= ot.x) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator *=(const Montgomery& ot) {\n\t\tx = reduce((u64)x * ot.x);\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator /=(const Montgomery& ot) {\n\t\treturn *this *= ot.inverse();\n\t}\n\n\tfriend Montgomery operator +(Montgomery a, const Montgomery& b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator -(Montgomery a, const Montgomery& b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator *(Montgomery a, const Montgomery& b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator /(Montgomery a, const Montgomery& b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\n\tMontgomery operator -() const {\n\t\treturn Montgomery() - *this;\n\t}\n\n\tu32 get() const {\n\t\tu32 res = reduce(x);\n\t\treturn res < base ? res : res - base;\n\t}\n\n\tu32 operator ()() const {\n\t\treturn get();\n\t}\n\n\tMontgomery inverse() const {\n\t\treturn pow(base - 2);\n\t}\n\n\tMontgomery pow(int64_t p) const {\n\t\tif (p < 0) {\n\t\t\treturn pow(-p).inverse();\n\t\t}\n\t\tMontgomery res = 1;\n\t\tMontgomery a = *this;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\ta *= a;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend istream& operator >>(istream& istr, Montgomery& m) {\n\t\tlong long x;\n\t\tistr >> x;\n\t\tm = Montgomery(x);\n\t\treturn istr;\n\t}\n\n\tfriend ostream& operator <<(ostream& ostr, const Montgomery& m) {\n\t\treturn ostr << m.get();\n\t}\n\n\tbool operator ==(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) == (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\tbool operator !=(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) != (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\texplicit operator int64_t() const {\n\t\treturn x;\n\t}\n\n\texplicit operator bool() const {\n\t\treturn x;\n\t}\n};\n\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nconst int mod = 998'244'353;\nusing Mint = Montgomery<mod>;\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tvector<Mint> f(n + 1);\n\tvector<Mint> g(n + 1);\n\tMint ans = 0;\n\tfor (int x : a) {\n\t\tMint good = f[x];\n\t\tif (x) {\n\t\t\tgood += f[x - 1];\n\t\t} else {\n\t\t\tgood += 1;\n\t\t}\n\n\t\tMint around_smaller = 0, around_larger = 0;\n\t\taround_smaller += x >= 2 ? f[x - 2] : 0;\n\t\taround_smaller += x >= 1 ? g[x - 1] : 0;\n\t\tif (x == 1) {\n\t\t\taround_smaller += 1;\n\t\t}\n\t\taround_larger += x < n ? g[x + 1] : 0;\n\t\t// cerr << x << \": \" << good << \" \" << around_smaller << \" \" << around_larger << \"\\n\";\n\n\t\tans += good + around_larger + around_smaller;\n\n\t\tf[x] += good;\n\t\tif (x > 0) {\n\t\t\tg[x - 1] += around_smaller;\n\t\t}\n\t\tif (x < n) {\n\t\t\tg[x + 1] += around_larger;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. MEX Sequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/97467",
    "editorial": "Letâs understand what MEX-correct sequences look like. It turns out\r\nthere are only two types: and . For example, the sequences and the empty\r\nsequence are MEX-correct sequences of the first type, and and of the\r\nsecond one.Letâs calculate the dynamic programming the number of\r\nMEX-correct subsequences of the first type on the prefix of length with\r\nequal to and similarly the number of MEX-correct subsequences of the\r\nsecond type on the prefix of length with equal to .Letâs look at the\r\ntransitions in these dps, and show that there are no other MEX-correct\r\nsequences at the same time.Let the current state be , and we are trying\r\nto add an element equal to : if , then such an element cannot be added;\r\nif , then the value of will not change and the sequence is still of the\r\nfirst type, which means we have a transition to ; if , then the value of\r\nwill increase by , but it will still be of the first type, which means\r\nwe have a transition to if , then the value of will not change, but the\r\nsequence will become of the second type, which means we have a\r\ntransition to ; if , then such an element cannot be added. Let the\r\ncurrent state be , and we are trying to add an element equal to : if ,\r\nthen such an element cannot be added; if , then the value of will not\r\nchange and the sequence is still of the second type, which means we have\r\na transition to ; if , then such an element cannot be added, because\r\nwill increase by , which means the absolute difference between and is\r\ngreater than ; if , then the value of will not change and the sequence\r\nis still of the second type, which means we have a transition to ; if ,\r\nthen such an element cannot be added. Thus, we considered all possible\r\ntransitions (adding a new element to the already MEX-correct sequences)\r\nand made sure that there are only two types.While the solution itself\r\nworks in time (because each element has possible transitions in the\r\ndps), it uses memory, which does not allow us to write that solution as\r\nis. However, note that and (similarly for ) differ in only a few\r\npositions (in those that the element allowed us to make), which means we\r\ncan store only one-dimensional arrays, and . Thus, the final complexity\r\nof the solution is .\r\n",
    "hint": []
}