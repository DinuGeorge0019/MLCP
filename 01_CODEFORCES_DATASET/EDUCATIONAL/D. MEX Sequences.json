{"link": "https://codeforces.com//contest/1613/problem/D", "problemId": "1209364", "problem_idx": "D", "shortId": "1613D", "contest_number": "1613", "problem_submissions": {"F": [137662460, 137680102, 137669930, 137680388, 137676481, 137689054, 137677544, 137670783, 137684225, 137683109, 137695659, 137689822, 137678272, 137672898, 137688331, 137700851, 137691450, 137776678, 137775393, 137689226, 137689675, 137703031], "E": [137655072, 137656585, 137663380, 137661012, 137661380, 137660230, 137663524, 137662766, 137664563, 137669185, 137669422, 137670709, 137669302, 137681566, 137674305, 137665393, 137678462, 137670584, 137679435, 137664635], "D": [137646881, 137645109, 137652424, 137648321, 137652518, 137652740, 137657211, 137653818, 137651858, 137656413, 137653916, 137656694, 137657143, 137657455, 137659528, 137655936, 137665693, 137656041, 137646478, 137655272], "C": [137634971, 137635045, 137641150, 137632004, 137642031, 137634798, 137639433, 137636954, 137638798, 137636121, 137638972, 137644414, 137635322, 137642182, 137647281, 137639264, 137643162, 137637445, 137634607, 137639818], "B": [137631052, 137629986, 137635688, 137629262, 137630431, 137630193, 137632384, 137630955, 137634981, 137632132, 137632097, 137637773, 137629234, 137636896, 137636754, 137634314, 137635536, 137633727, 137630130, 137635595], "A": [137628660, 137628698, 137630882, 137628467, 137628655, 137628608, 137630089, 137628835, 137631891, 137629156, 137628914, 137629328, 137628519, 137632470, 137630776, 137629772, 137629039, 137628924, 137628505, 137630736]}, "name": "D. MEX Sequences", "statement": "Let\u2019s call a sequence of integers x_1, x_2,\r\ndots, x_k if for all i (1\r\nle i\r\nle k) |x_i -\r\noperatorname{MEX}(x_1, x_2,\r\ndots, x_i)|\r\nle 1 holds. Where\r\noperatorname{MEX}(x_1,\r\ndots, x_k) is the minimum non-negative integer that doesn\u2019t belong to\r\nthe set x_1,\r\ndots, x_k. For example,\r\noperatorname{MEX}(1, 0, 1, 3) = 2 and\r\noperatorname{MEX}(2, 1, 5) = 0.You are given an array a consisting of n\r\nnon-negative integers. Calculate the number of non-empty subsequences of\r\na given array. The number of subsequences can be very large, so print it\r\nmodulo 998244353. Note: a subsequence of an array a is a sequence\r\n[a_{i_1}, a_{i_2},\r\ndots, a_{i_m}] meeting the constraints 1\r\nle i_1 < i_2 <\r\ndots < i_m\r\nle n. If two different ways to choose the sequence of indices [i_1, i_2,\r\ndots, i_m] yield the same subsequence, the resulting subsequence should\r\nbe counted twice (i. e. two subsequences are different if their\r\nsequences of indices [i_1, i_2,\r\ndots, i_m] are not the same).\r\n", "solutions": ["\n#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define imie(x) #x << \": \" << x\n\nusing namespace std;\n\ntemplate <uint32_t base>\nstruct Montgomery {\n\tusing i32 = int32_t;\n\tusing u32 = uint32_t;\n\tusing u64 = uint64_t;\n\n\tstatic constexpr u32 mod() {\n\t\treturn base;\n\t}\n\n\tstatic constexpr u32 np = []() {\n\t\tu32 x = base;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tx *= 2u - base * x;\n\t\t}\n\t\treturn -x;\n\t}();\n\tstatic constexpr u32 r2 = -(u64)(base) % base;\n\n\tstatic_assert(base < (1u << 30));\n\tstatic_assert(base * np + 1 == 0);\n\n\tstatic u32 reduce(u64 x) {\n\t\treturn (x + (u64)((u32)x * np) * base) >> 32;\n\t}\n\n\tu32 x;\n\tMontgomery(): x(0) {}\n\tconstexpr Montgomery(long long y): x(y ? reduce((u64)(y % base + base) * r2) : 0) {}\n\n\tMontgomery& operator +=(const Montgomery& ot) {\n\t\tif ((i32)(x += ot.x - 2 * base) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator -=(const Montgomery& ot) {\n\t\tif ((i32)(x -= ot.x) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator *=(const Montgomery& ot) {\n\t\tx = reduce((u64)x * ot.x);\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator /=(const Montgomery& ot) {\n\t\treturn *this *= ot.inverse();\n\t}\n\n\tfriend Montgomery operator +(Montgomery a, const Montgomery& b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator -(Montgomery a, const Montgomery& b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator *(Montgomery a, const Montgomery& b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator /(Montgomery a, const Montgomery& b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\n\tMontgomery operator -() const {\n\t\treturn Montgomery() - *this;\n\t}\n\n\tu32 get() const {\n\t\tu32 res = reduce(x);\n\t\treturn res < base ? res : res - base;\n\t}\n\n\tu32 operator ()() const {\n\t\treturn get();\n\t}\n\n\tMontgomery inverse() const {\n\t\treturn pow(base - 2);\n\t}\n\n\tMontgomery pow(int64_t p) const {\n\t\tif (p < 0) {\n\t\t\treturn pow(-p).inverse();\n\t\t}\n\t\tMontgomery res = 1;\n\t\tMontgomery a = *this;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\ta *= a;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend istream& operator >>(istream& istr, Montgomery& m) {\n\t\tlong long x;\n\t\tistr >> x;\n\t\tm = Montgomery(x);\n\t\treturn istr;\n\t}\n\n\tfriend ostream& operator <<(ostream& ostr, const Montgomery& m) {\n\t\treturn ostr << m.get();\n\t}\n\n\tbool operator ==(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) == (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\tbool operator !=(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) != (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\texplicit operator int64_t() const {\n\t\treturn x;\n\t}\n\n\texplicit operator bool() const {\n\t\treturn x;\n\t}\n};\n\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nconst int mod = 998'244'353;\nusing Mint = Montgomery<mod>;\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tvector<Mint> f(n + 1);\n\tvector<Mint> g(n + 1);\n\tMint ans = 0;\n\tfor (int x : a) {\n\t\tMint good = f[x];\n\t\tif (x) {\n\t\t\tgood += f[x - 1];\n\t\t} else {\n\t\t\tgood += 1;\n\t\t}\n\n\t\tMint around_smaller = 0, around_larger = 0;\n\t\taround_smaller += x >= 2 ? f[x - 2] : 0;\n\t\taround_smaller += x >= 1 ? g[x - 1] : 0;\n\t\tif (x == 1) {\n\t\t\taround_smaller += 1;\n\t\t}\n\t\taround_larger += x < n ? g[x + 1] : 0;\n\t\t// cerr << x << \": \" << good << \" \" << around_smaller << \" \" << around_larger << \"\\n\";\n\n\t\tans += good + around_larger + around_smaller;\n\n\t\tf[x] += good;\n\t\tif (x > 0) {\n\t\t\tg[x - 1] += around_smaller;\n\t\t}\n\t\tif (x < n) {\n\t\t\tg[x + 1] += around_larger;\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["dp", "math"], "dificulty": "1900", "interactive": false}