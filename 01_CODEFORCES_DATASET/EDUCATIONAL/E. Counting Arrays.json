{
    "link": "https://codeforces.com//contest/893/problem/E",
    "problemId": "135515",
    "problem_idx": "E",
    "shortId": "893E",
    "contest_number": "893",
    "problem_submissions": {
        "D": [
            32587846,
            32584166,
            32584580,
            32587450,
            32584069,
            32583060,
            32588853,
            32589858,
            32585182,
            32590659,
            32586485,
            32589315,
            32591783,
            32597332,
            32598552,
            32591926,
            32591314,
            32591378,
            32595633,
            32593677
        ],
        "F": [
            32587029,
            32588564,
            32633440,
            32633411,
            32600577,
            32591730,
            32591080,
            32593455,
            32595872,
            32596856,
            32595308,
            32598298,
            32597321,
            32596161,
            32595895,
            32587274,
            32617128,
            32590562,
            32596152,
            32592069,
            32595471,
            32597133,
            32631856,
            32597548,
            32597501,
            32596510,
            32594100,
            32588288
        ],
        "E": [
            32582663,
            32585881,
            32587039,
            32583891,
            32589038,
            32590654,
            32590403,
            32589458,
            32590147,
            32585649,
            32586443,
            32598380,
            32591576,
            32589935,
            32595163,
            32587306,
            32598292,
            32632299,
            32631834,
            32597903,
            32592050,
            32595887
        ],
        "C": [
            32580222,
            32581731,
            32579674,
            32581061,
            32582009,
            32580473,
            32581974,
            32581755,
            32582911,
            32582779,
            32581570,
            32581398,
            32580526,
            32582157,
            32582935,
            32581251,
            32583782,
            32581776,
            32581603,
            32588827
        ],
        "B": [
            32579038,
            32579297,
            32579032,
            32580119,
            32580362,
            32579253,
            32579828,
            32580254,
            32581551,
            32581638,
            32580169,
            32580423,
            32579209,
            32580529,
            32581182,
            32578812,
            32582642,
            32580448,
            32580061,
            32587514
        ],
        "A": [
            32578761,
            32578814,
            32578771,
            32578835,
            32579027,
            32578799,
            32578920,
            32578996,
            32579962,
            32580679,
            32579419,
            32579406,
            32579609,
            32579237,
            32580280,
            32579180,
            32578788,
            32579540,
            32578923,
            32586994
        ]
    },
    "name": "E. Counting Arrays",
    "statement": "You are given two positive integer numbers and . An array is called an\r\nof iff the following conditions are met: There are elements in , and all\r\nof them are integer numbers; . You have to count the number of pairwise\r\ndistinct arrays that are -factorizations of . Two arrays and are\r\nconsidered different iff there exists at least one index () such that .\r\nSince the answer can be very large, print it modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 1111111;\nint erat[N];\n\nconst int mod = 1000000007;\nint fact[N];\nint invfact[N];\n\nlong long pw(long long a, long long b) {\n\tlong long res = 1;\n\twhile (b) {\n\t\tif (b & 1ll) {\n\t\t\tres = res * a % mod;\n\t\t}\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn res;\n}\n\nlong long C(int n, int k) {\n\treturn fact[n] * 1ll * invfact[n - k] % mod * invfact[k] % mod;\n}\n\nint main() {\n\tfor (int i = 2; i < N; ++i) {\n\t\tif (erat[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\terat[i] = i;\n\t\tif (1.0 * i * i < N + N) {\n\t\t\tfor (int j = i * i; j < N; j += i) {\n\t\t\t\tif (erat[j] == 0) {\n\t\t\t\t\terat[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfact[i] = 1ll * i * fact[i - 1] % mod;\n\t}\n\tinvfact[N - 1] = pw(fact[N - 1], mod - 2);\n\tfor (int i = N - 2; i >= 0; --i) {\n\t\tinvfact[i] = 1ll * invfact[i + 1] * (i + 1) % mod;\n\t}\n\n\tint q = nxt();\n\twhile (q--) {\n\t\tint x = nxt(), y = nxt();\n\t\tlong long ans = 1;\n\t\tint last = 0;\n\t\tint cnt = 0;\n\t\twhile (x > 1) {\n\t\t\tint p = erat[x];\n\t\t\tif (p == last) {\n\t\t\t\t++cnt;\n\t\t\t} else {\n\t\t\t\tans = ans * C(cnt + y - 1, cnt) % mod;\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t\tlast = p;\n\t\t\tx /= p;\n\t\t}\n\t\tans = ans * C(cnt + y - 1, cnt) % mod;\n\t\tans = ans * pw(2, y - 1) % mod;\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Counting Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/55989",
    "editorial": "Fill the array with ones. Now we should take every prime divisor of and\r\ndistribute (maximum power of this prime to appear in ) of it into some\r\ncells of the array. It is pretty well-known problem, it\u00e2\u0080\u0099s equal to .\r\nTake product of this values for every prime . This will be the answer if\r\nthere were no negative numbers. But we should also multiply it by number\r\nof ways to select even number of position to put unary minuses (like you\r\ncan fill in position anyhow and the final one will be determined by\r\nparity of current count).To process many queries you should factorize\r\nnumbers in (by precalcing the smallest prime divisor of every number up\r\nto with sieve of Eratosthenes), get in (by precalcing factorials and\r\ninverse factorials) and get in (binary exponentiation).Overall\r\ncomplexity: .\r\n"
}