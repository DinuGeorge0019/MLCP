{"link": "https://codeforces.com//contest/1366/problem/F", "problemId": "646804", "problem_idx": "F", "shortId": "1366F", "contest_number": "1366", "problem_submissions": {"F": [83447668, 83448434, 83444622, 83426763, 83441574, 83428280, 83460965, 83423891, 83442353, 83757770, 83445090, 83429919, 83438895, 83437207, 83492622, 83492442, 83474062, 83453556, 83447806], "G": [83429184, 83428882, 83457684, 83412158, 83433864, 83437984, 83494857, 83757790, 83510645, 83444271, 83455262, 83440823, 83444943, 83578671, 83450093], "E": [83398532, 83418602, 83409360, 83402434, 83412489, 83410962, 83757722, 83418361, 83408316, 83407997, 83427080, 83413277, 83416924, 83424580, 83418188, 83406625, 83420403, 83421638], "D": [83393167, 83406995, 83402251, 83397827, 83397479, 83404641, 83397199, 83402779, 83757690, 83407778, 83401287, 83402226, 83406676, 83407995, 83406280, 83407838, 83409402, 83421660, 83414839, 83414935], "C": [83390782, 83401605, 83394916, 83391593, 83392337, 83394149, 83393867, 83397548, 83757664, 83394207, 83391231, 83395559, 83398133, 83401855, 83400985, 83402206, 83402544, 83397821, 83396193, 83400630], "B": [83389935, 83490415, 83397273, 83390226, 83389902, 83389999, 83390997, 83390624, 83757653, 83390343, 83389925, 83392810, 83391891, 83392040, 83392753, 83394886, 83392865, 83391554, 83391226, 83391686], "A": [83389637, 83390640, 83389645, 83389626, 83389634, 83389655, 83389755, 83757620, 83389748, 83389663, 83390083, 83389875, 83389821, 83390216, 83392108, 83390187, 83390121, 83389679, 83389858]}, "name": "F. Jog Around The Graph", "statement": "You are given a simple weighted connected undirected graph, consisting\r\nof n vertices and m edges.A path in the graph of length k is a sequence\r\nof k+1 vertices v_1, v_2,\r\ndots, v_{k+1} such that for each i (1\r\nle i\r\nle k) the edge (v_i, v_{i+1}) is present in the graph. A path from some\r\nvertex v also has vertex v_1=v. Note that edges and vertices are allowed\r\nto be included in the path multiple times.The weight of the path is the\r\ntotal weight of edges in it.For each i from 1 to q consider a path from\r\nvertex 1 of length i of the maximum weight. What is the sum of weights\r\nof these q paths?Answer can be quite large, so print it modulo 10^9+7.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9)+7>;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tusing ll = long long;\n\tint n, m;\n\tll q;\n\tcin >> n >> m >> q;\n\tvector<int> u(m), v(m), w(m);\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u[i] >> v[i] >> w[i];\n\t\tu[i]--; v[i]--;\n\t}\n\tvector<ll> len(n, -1e18);\n\tlen[0] = 0;\n\tvector<ll> best_path(m, -1e18);\n\tvector<ll> ans(n+1, -1e18);\n\tfor(int d = 0; d <= n; d++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans[d] = max(ans[d], len[i]);\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tbest_path[i] = max(best_path[i], max(len[u[i]], len[v[i]]) - w[i] * d);\n\t\t}\n\t\tvector<ll> newlen(n, -1e18);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tnewlen[u[i]] = max(newlen[u[i]], len[v[i]] + w[i]);\n\t\t\tnewlen[v[i]] = max(newlen[v[i]], len[u[i]] + w[i]);\n\t\t}\n\t\tlen = newlen;\n\t}\n\tnum total = 0;\n\tfor(int d = 0; d <= q && d <= n; d++){\n\t\ttotal += ans[d];\n\t}\n\tauto get_best = [&](ll d) -> ll {\n\t\tll best = -1;\n\t\tll id = -1;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tll clen = best_path[j] + w[j] * d;\n\t\t\tif(clen > best){\n\t\t\t\tbest = clen;\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\treturn id;\n\t};\n\tif(n+1 <= q){\n\t\ty_combinator([&](auto self, ll l, ll lv, ll r, ll rv) -> void {\n\t\t\tif(l > r) return;\n\t\t\tif(lv == rv){\n\t\t\t\ttotal += num(r - l + 1) * best_path[lv];\n\t\t\t\ttotal += num(r - l + 1) * num(r + l) / 2 * w[lv];\n\t\t\t} else {\n\t\t\t\tll m1 = (l + r) / 2;\n\t\t\t\tll m2 = m1 + 1;\n\t\t\t\tll m1v = get_best(m1);\n\t\t\t\tll m2v = get_best(m2);\n\t\t\t\tself(l, lv, m1, m1v);\n\t\t\t\tself(m2, m2v, r, rv);\n\t\t\t}\n\t\t})(n+1, get_best(n+1), q, get_best(q));\t\t\n\t}\n\tcout << total << '\\n';\n}"], "input": "", "output": "", "tags": ["binary search", "dp", "geometry", "graphs"], "dificulty": "2700", "interactive": false}