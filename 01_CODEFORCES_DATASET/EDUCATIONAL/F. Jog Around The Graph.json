{
    "link": "https://codeforces.com//contest/1366/problem/F",
    "problemId": "646804",
    "problem_idx": "F",
    "shortId": "1366F",
    "contest_number": "1366",
    "problem_submissions": {
        "F": [
            83447668,
            83448434,
            83444622,
            83426763,
            83441574,
            83428280,
            83460965,
            83423891,
            83442353,
            83757770,
            83445090,
            83429919,
            83438895,
            83437207,
            83492622,
            83492442,
            83474062,
            83453556,
            83447806
        ],
        "G": [
            83429184,
            83428882,
            83457684,
            83412158,
            83433864,
            83437984,
            83494857,
            83757790,
            83510645,
            83444271,
            83455262,
            83440823,
            83444943,
            83578671,
            83450093
        ],
        "E": [
            83398532,
            83418602,
            83409360,
            83402434,
            83412489,
            83410962,
            83757722,
            83418361,
            83408316,
            83407997,
            83427080,
            83413277,
            83416924,
            83424580,
            83418188,
            83406625,
            83420403,
            83421638
        ],
        "D": [
            83393167,
            83406995,
            83402251,
            83397827,
            83397479,
            83404641,
            83397199,
            83402779,
            83757690,
            83407778,
            83401287,
            83402226,
            83406676,
            83407995,
            83406280,
            83407838,
            83409402,
            83421660,
            83414839,
            83414935
        ],
        "C": [
            83390782,
            83401605,
            83394916,
            83391593,
            83392337,
            83394149,
            83393867,
            83397548,
            83757664,
            83394207,
            83391231,
            83395559,
            83398133,
            83401855,
            83400985,
            83402206,
            83402544,
            83397821,
            83396193,
            83400630
        ],
        "B": [
            83389935,
            83490415,
            83397273,
            83390226,
            83389902,
            83389999,
            83390997,
            83390624,
            83757653,
            83390343,
            83389925,
            83392810,
            83391891,
            83392040,
            83392753,
            83394886,
            83392865,
            83391554,
            83391226,
            83391686
        ],
        "A": [
            83389637,
            83390640,
            83389645,
            83389626,
            83389634,
            83389655,
            83389755,
            83757620,
            83389748,
            83389663,
            83390083,
            83389875,
            83389821,
            83390216,
            83392108,
            83390187,
            83390121,
            83389679,
            83389858
        ]
    },
    "name": "F. Jog Around The Graph",
    "statement": "You are given a simple weighted connected undirected graph, consisting\r\nof n vertices and m edges.A path in the graph of length k is a sequence\r\nof k+1 vertices v_1, v_2,\r\ndots, v_{k+1} such that for each i (1\r\nle i\r\nle k) the edge (v_i, v_{i+1}) is present in the graph. A path from some\r\nvertex v also has vertex v_1=v. Note that edges and vertices are allowed\r\nto be included in the path multiple times.The weight of the path is the\r\ntotal weight of edges in it.For each i from 1 to q consider a path from\r\nvertex 1 of length i of the maximum weight. What is the sum of weights\r\nof these q paths?Answer can be quite large, so print it modulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9)+7>;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tusing ll = long long;\n\tint n, m;\n\tll q;\n\tcin >> n >> m >> q;\n\tvector<int> u(m), v(m), w(m);\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u[i] >> v[i] >> w[i];\n\t\tu[i]--; v[i]--;\n\t}\n\tvector<ll> len(n, -1e18);\n\tlen[0] = 0;\n\tvector<ll> best_path(m, -1e18);\n\tvector<ll> ans(n+1, -1e18);\n\tfor(int d = 0; d <= n; d++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans[d] = max(ans[d], len[i]);\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tbest_path[i] = max(best_path[i], max(len[u[i]], len[v[i]]) - w[i] * d);\n\t\t}\n\t\tvector<ll> newlen(n, -1e18);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tnewlen[u[i]] = max(newlen[u[i]], len[v[i]] + w[i]);\n\t\t\tnewlen[v[i]] = max(newlen[v[i]], len[u[i]] + w[i]);\n\t\t}\n\t\tlen = newlen;\n\t}\n\tnum total = 0;\n\tfor(int d = 0; d <= q && d <= n; d++){\n\t\ttotal += ans[d];\n\t}\n\tauto get_best = [&](ll d) -> ll {\n\t\tll best = -1;\n\t\tll id = -1;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tll clen = best_path[j] + w[j] * d;\n\t\t\tif(clen > best){\n\t\t\t\tbest = clen;\n\t\t\t\tid = j;\n\t\t\t}\n\t\t}\n\t\treturn id;\n\t};\n\tif(n+1 <= q){\n\t\ty_combinator([&](auto self, ll l, ll lv, ll r, ll rv) -> void {\n\t\t\tif(l > r) return;\n\t\t\tif(lv == rv){\n\t\t\t\ttotal += num(r - l + 1) * best_path[lv];\n\t\t\t\ttotal += num(r - l + 1) * num(r + l) / 2 * w[lv];\n\t\t\t} else {\n\t\t\t\tll m1 = (l + r) / 2;\n\t\t\t\tll m2 = m1 + 1;\n\t\t\t\tll m1v = get_best(m1);\n\t\t\t\tll m2v = get_best(m2);\n\t\t\t\tself(l, lv, m1, m1v);\n\t\t\t\tself(m2, m2v, r, rv);\n\t\t\t}\n\t\t})(n+1, get_best(n+1), q, get_best(q));\t\t\n\t}\n\tcout << total << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "geometry",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Jog Around The Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/78735",
    "editorial": "Letâs observe what does the maximum weight of some fixed length path\r\nlook like. Among the edges on that path the last one has the maximum\r\nweight. If it wasnât then the better total weight could be achieved by\r\nchoosing a bigger weight edge earlier and going back and forth on it for\r\nthe same number of steps. It actually helps us arrive to a conclusion\r\nthat all optimal paths look like that: some simple path to an edge and\r\nthen back and forth movement on it.Any simple path in the graph has its\r\nlength at most . Letâs separate the queries into two parts. will be\r\nhandled in a straightforward manner. Let be the maximum weight of a path\r\nthat ends in and has exactly edges in it. Thatâs pretty easy to\r\ncalculate in .You can also think of this as some kind of Ford-Bellman\r\nalgorithm let on the -th step be the maximum weight of the path to of\r\nlength . Iterate over all edges and try to update and for each edge\r\n(thatâs what I do in my solution if you refer to it).Now for . There was\r\na very common assumption that after a bit more steps some edge will\r\nbecome the most optimal and will stay the most optimal until the end of\r\ntime. However, that \"a bit\" cut-off is in fact too high to rely on (it\r\nmust be somewhere around ).So the best path of length exactly ending in\r\neach vertex is . Let the maximum weight adjacent edge to vertex be . So\r\nthe path of length will have weight . Treat it like a line with\r\ncoefficients and .How do determine which line is the best for some ?\r\nSure, experienced participants will immediately answer \"convex hull\".\r\nBuild a lower envelope of the convex hull of these lines. If was a\r\nlittle smaller than we could query with binary search for each , the\r\nsame how convex hull is usually used. We have to examine the hull\r\nfurther. Each line in it becomes the best in some point, then stays the\r\nbest for some interval and then never appears the best again. What are\r\nthese line changing points? Well, itâs just the intersection point of\r\nthe adjacent lines in the hull. So having these points and the\r\nparameters of the line we can calculate its contribution to the answer\r\nwith a sum of arithmetic progression formula.There were just lines in\r\nthe hull so you can build the hull in any complexity, I think I saw up\r\nto performances in the participants codes.There is a cool solution that\r\ninvolves some kind of Divide&Conquer on these lines. I personally\r\nthought of it in a sense of traversing a Li-Chao tree without actually\r\nbuilding it. If anyone wants to explain this solution, feel free to do\r\nit in comments.Overall complexity: .\r\n",
    "hint": []
}