{
    "link": "https://codeforces.com//contest/1238/problem/D",
    "problemId": "434108",
    "problem_idx": "D",
    "shortId": "1238D",
    "contest_number": "1238",
    "problem_submissions": {
        "G": [
            62148377,
            62150345,
            62148994,
            62146428,
            62171195,
            62152430,
            62150450,
            62151715,
            63077598,
            62153399,
            62153961,
            62326923,
            62163873,
            62157710,
            63252631
        ],
        "C": [
            62139579,
            62128875,
            62134212,
            62149084,
            62171152,
            62131518,
            62131617,
            62138927,
            62130356,
            62145335,
            62127646,
            62128518,
            62127470,
            62128489,
            62132928,
            62130729,
            62130656,
            62131114,
            62129400,
            62129293,
            62129389,
            62141737
        ],
        "F": [
            62135057,
            62143199,
            62146057,
            62137636,
            62171175,
            62141888,
            62144431,
            62147441,
            62144667,
            62133761,
            62136545,
            62139411,
            62133600,
            62138749,
            62143755,
            62143321,
            62145892,
            62144865,
            62148327,
            62148901,
            62145390
        ],
        "E": [
            62130371,
            62135558,
            62133197,
            62133178,
            62171181,
            62138707,
            62138998,
            71444053,
            62143394,
            62142446,
            62126207,
            62132191,
            62134744,
            62139465,
            62131237,
            62138771,
            62335532,
            62136799,
            62138459,
            62139760,
            62138816,
            62133466,
            62139306,
            62136690
        ],
        "D": [
            62130325,
            62130011,
            62129721,
            62133154,
            62171155,
            62134587,
            62136980,
            62133511,
            62142844,
            62150513,
            62130499,
            62130138,
            62131294,
            62128520,
            62132339,
            62134000,
            62132013,
            62132252,
            62131248,
            62131658,
            62131164
        ],
        "B": [
            62124194,
            62124712,
            62125813,
            62133117,
            62171147,
            62134676,
            62126226,
            62125252,
            62142403,
            62146274,
            62123866,
            62124453,
            62125991,
            62125432,
            62124476,
            62123794,
            62126146,
            62127228,
            62126305,
            62123963,
            62127931,
            62125892
        ],
        "A": [
            62120855,
            62121082,
            62121998,
            62121600,
            62171137,
            62121874,
            62120946,
            62121255,
            62120923,
            62120856,
            62121293,
            62121013,
            62121176,
            62120783,
            62120942,
            62121012,
            62121072,
            62121136,
            62121767,
            62121527
        ]
    },
    "name": "D. AB-string",
    "statement": "The string t_1t_2\r\ndots t_k is good if each letter of this string belongs to at least one\r\npalindrome of length than .A palindrome is a string that reads the same\r\nbackward as forward. For example, the strings , , , are palindromes, but\r\nthe strings , , are not.Here are some examples of good strings: t =\r\n(letters t_1, t_2 belong to palindrome t_1\r\ndots t_2 and letters t_3, t_4, t_5 belong to palindrome t_3\r\ndots t_5); t = (letters t_1, t_2, t_3 belong to palindrome t_1\r\ndots t_3 and letter t_4 belongs to palindrome t_3\r\ndots t_4); t = (all letters belong to palindrome t_1\r\ndots t_5); You are given a string s of length n, consisting of letters\r\nand .You have to calculate the number of good substrings of string s.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nstring s;\nvector<int>pos[2];\nint main(){\n\tcin >> n >> s;\n\trep(i,n) pos[s[i]-'A'].pb(i);\n\tll ans = n;\n\trep(i,n){\n\t\tint id = s[i]-'A';\n\t\tint x = POSU(pos[id],i);\n\t\tif(x == pos[id].size()) x = n;\n\t\telse x = pos[id][x];\n\t\tans += x-i-1;\n\t\t\n\t\tif(i != n-1 && s[i] == s[i+1]){\n\t\t\tid = 1-id;\n\t\t\tx = POSU(pos[id],i);\n\t\t\tif(x == pos[id].size()) continue;\n\t\t\telse ans++;\n\t\t}\n\t}\n\tcout << 1LL*n*(n+1)/2 - ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "dp",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. AB-string.json",
    "editorial_link": "https://codeforces.com//blog/entry/70450",
    "editorial": "Instead of counting the number of good substrings, let\u00e2\u0080\u0099s count the\r\nnumber of bad substrings , then number of good substrings is equal to\r\n.Let\u00e2\u0080\u0099s call a character in string is bad if there is no such palindrome\r\nthat . Any character in substring is good. It can be proven as follows.\r\nIf or then belong to a palindrome of length . If and then belong to a\r\npalindrome .So only characters and can be bad. But at the same time\r\ncharacter is bad if there is no character such that and . It is true\r\nbecause substring is palindrome (index is minimum index such that ).So,\r\nthere are only patterns of bad strings: ; ; ; ; All that remains is to\r\ncount the number of substrings of this kind.\r\n"
}