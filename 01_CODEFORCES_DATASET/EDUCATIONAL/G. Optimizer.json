{
    "link": "https://codeforces.com//contest/1156/problem/G",
    "problemId": "338454",
    "problem_idx": "G",
    "shortId": "1156G",
    "contest_number": "1156",
    "problem_submissions": {
        "A": [
            53639029,
            53626152,
            53625678,
            53630793,
            53625404,
            53614352,
            53623128,
            53628986,
            53624721,
            53623695,
            53625017,
            53634723,
            53624542,
            53628079,
            53633627,
            53624437,
            53623236,
            53629488,
            53623966,
            53615060
        ],
        "B": [
            53637891,
            53617977,
            53617293,
            53625525,
            53620909,
            53621377,
            53618385,
            53633927,
            53620068,
            53619804,
            53621825,
            53614635,
            53623085,
            53633560,
            53636498,
            53618667,
            53619022,
            53619496,
            53620680,
            53624386
        ],
        "C": [
            53636621,
            53619670,
            53619150,
            53614135,
            53617663,
            53625504,
            53624957,
            53661619,
            53635201,
            53626601,
            53622201,
            53615675,
            53635681,
            53619089,
            53620360,
            53614001,
            53620016,
            53634903,
            53620881,
            53615566,
            53626189
        ],
        "G": [
            53635130,
            53641842,
            53954352,
            53641770,
            203176755,
            53643379
        ],
        "D": [
            53620605,
            53623897,
            53623535,
            53629070,
            53631245,
            53633026,
            53629459,
            53616004,
            53628435,
            53632954,
            53632904,
            53620339,
            53632312,
            53623609,
            53618157,
            53629146,
            53629263,
            53627644,
            53629790,
            53630995
        ],
        "F": [
            53617719,
            53632417,
            53636572,
            53634637,
            53627300,
            53636941,
            53634698,
            53625519,
            53635307,
            53636482,
            53636370,
            53630747,
            53636740,
            53635472,
            53633389,
            53637182,
            53632117,
            53637419,
            53635743,
            53636158
        ],
        "E": [
            53614077,
            53629771,
            53629915,
            53618247,
            53637367,
            53630569,
            53631126,
            53661599,
            53620934,
            53631115,
            53629004,
            53629934,
            53625980,
            53630101,
            53619260,
            53627891,
            53632780,
            53621624,
            53634838,
            53638304,
            53634716
        ]
    },
    "name": "G. Optimizer",
    "statement": "Let’s analyze a program written on some strange programming language.\r\nThe variables in this language have names consisting of 1 to 4\r\ncharacters, and each character is a lowercase or an uppercase Latin\r\nletter, or a digit. There is an extra constraint that the first\r\ncharacter should not be a digit.There are four types of operations in\r\nthe program, each denoted by one of the characters: , , or .Each line of\r\nthe program has one of the following formats: , where and are valid\r\nvariable names; , where , and are valid variable names, and <op> is an\r\noperation character. The program is executed line-by-line, and the\r\nresult of execution is stored in a variable having the name . If is\r\nnever assigned in the program, then the result will be equal to the\r\nvalue of before running the program.Two programs are called equivalent\r\nif no matter which operations do characters , , and denote (but,\r\nobviously, performing the same operation on the same arguments gives the\r\nsame result) and which values do variables have before execution of\r\nprogram, the value of after running the first program is equal to the\r\nvalue of after running the second program (the programs are executed\r\nindependently).You are given a program consisting of n lines. Your task\r\nis to write a program consisting of minimum possible number of lines\r\nthat is equivalent to the program you are given.\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nstruct var {\n    int a1, a2;\n    char op;\n    var(int a1, int a2, char op) : a1(a1), a2(a2), op(op) {}\n};\n\nvector<var> V;\nmap<string, int> mapa;\nset<string> used;\nmap<int, string> init;\nmap<pair<pair<int, int>, char>, int> MAPA;\n\nmap<int, string> toSTR;\n\nstring f(int x) {\n    string res;\n    rep(i, 0, 4) {\n        res += char('a' + x % 26);\n        x /= 26;\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nstring getStr(int x) {\n    int xxx = x;\n    if (x == mapa[\"res\"]) {\n        return \"res\";\n    }\n    if (init.count(x)) {\n        return init[x];\n    }\n    if (toSTR.count(x)) {\n        return toSTR[x];\n    }\n    while (used.count(f(x))) {\n        x++;\n    }\n    used.insert(f(x));\n    return toSTR[xxx] = f(x);\n}\n\nvector<string> out;\nset<int> was;\n\nvoid restore(int id) {\n    if (V[id].op == '.') {\n        return;\n    }\n    if (!was.count(V[id].a1)) {\n        restore(V[id].a1);\n    }\n    if (!was.count(V[id].a2)) {\n        restore(V[id].a2);\n    }\n    out.push_back(getStr(id) + \"=\" + getStr(V[id].a1) + V[id].op + getStr(V[id].a2));\n    was.insert(id);\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int curID = 0;\n    int ANS_ID = -1;\n    string ANS_STR = \"\";\n    rep(t, 0, n) {\n        string s;\n        cin >> s;\n        int p1 = -1, p2 = -1;\n        rep(i, 0, sz(s)) {\n            if (s[i] == '=') {\n                p1 = i;\n            }\n            if (s[i] == '$' || s[i] == '^' || s[i] == '#' || s[i] == '&') {\n                p2 = i;\n            }\n        }\n        if (p2 == -1) {\n            string a = s.substr(0, p1), b = s.substr(p1 + 1, sz(s) - p1 - 1);\n            if (a == b) {\n                continue;\n            }\n            if (mapa.find(b) == mapa.end()) {\n                mapa[b] = curID++;\n                init[mapa[b]] = b;\n                used.insert(b);\n                V.push_back(var(-1, -1, '.'));\n            }\n            if (a == \"res\") {\n                if (V[mapa[b]].op == '.') {\n                    ANS_ID = mapa[b];\n                    ANS_STR = init[mapa[b]];\n                }\n            }\n            mapa[a] = mapa[b];\n        } else {\n            string a = s.substr(0, p1), b = s.substr(p1 + 1, p2 - p1 - 1), c = s.substr(p2 + 1, sz(s) - p2 - 1);\n            if (mapa.find(b) == mapa.end()) {\n                mapa[b] = curID++;\n                init[mapa[b]] = b;\n                used.insert(b);\n                V.push_back(var(-1, -1, '.'));\n            }\n            if (mapa.find(c) == mapa.end()) {\n                mapa[c] = curID++;\n                init[mapa[c]] = c;\n                used.insert(c);\n                V.push_back(var(-1, -1, '.'));\n            }\n            int idB = mapa[b], idC = mapa[c];\n            auto it = MAPA.find({{idB, idC}, s[p2]});\n            if (it == MAPA.end()) {\n                V.push_back(var(idB, idC, s[p2]));\n                mapa[a] = curID++;\n                MAPA[{{idB, idC}, s[p2]}] = mapa[a];\n            } else {\n                mapa[a] = it->se;\n            }\n        }\n    }\n    if (mapa.find(\"res\") == mapa.end()) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    if (mapa[\"res\"] == ANS_ID) {\n        if (ANS_STR == \"res\") {\n            cout << 0 << \"\\n\";\n            return 0;\n        }\n        cout << 1 << \"\\n\";\n        cout << \"res=\" << ANS_STR << \"\\n\";\n        return 0;\n    }\n    restore(mapa[\"res\"]);\n    cout << sz(out) << \"\\n\";\n    for (auto it : out) {\n        cout << it << \"\\n\";\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "hashing",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Optimizer.json",
    "editorial_link": "https://codeforces.com/blog/entry/66827",
    "editorial": "I couldâve explained the jury solution, however, after the contest I\r\nfound a much easier and more understandable solution by one of the\r\nparticipants. I put one of juryâs solutions under the spoiler along with\r\na link to the solution Iâm explaining.Letâs restate the problem in a\r\nmore convinient way. Initially we are given some directed acyclic graph.\r\nLet there be nodes of two kinds: For a direct set operation. These will\r\nhave a single outgoing edge to another node. For a binary operation.\r\nThese will have two outgoing edges to other nodes. However, itâs\r\nimportant which edge is the \"left\" one and which is the \"right\" one. We\r\nalso have to make dummy vertices for the variables which only appeared\r\nat the right side of some operation.We are allowed to remove any direct\r\nset operations, we will simulate this by compressing the edges of the\r\ngraph. Instead of doing (), weâll do (). Value-wise this is the same but\r\nvariable donât rely on anymore, so might be deleted.Weâll build the\r\nentire graph line by line. Letâs maintain array which will keep the\r\ncurrent value of each variable. It will store the node itself. Itâs\r\nprobably better to store both kinds of nodes in a separate array so that\r\nand the pointers to the ends of the edges could be integers.If we\r\nencountered no \"\" variable getting set, then the answer is 0.Otherwise\r\nletâs traverse from the node representing the current value of \"\" to\r\nevery reachable node. While building the graph we were compressing every\r\nunoptimal operation, thus all reachable nodes matter.Finally, the last\r\noperation on \"\" might have been just a direct set. Thatâs unoptimal, so\r\nweâll handle that case separately.\r\n",
    "hint": []
}