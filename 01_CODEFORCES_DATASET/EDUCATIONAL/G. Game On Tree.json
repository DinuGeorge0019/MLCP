{
    "link": "https://codeforces.com//contest/1452/problem/G",
    "problemId": "802110",
    "problem_idx": "G",
    "shortId": "1452G",
    "contest_number": "1452",
    "problem_submissions": {
        "F": [
            98942480,
            98939437,
            98940434,
            106494164,
            106494140,
            98942341,
            98945383,
            98935697,
            98927001,
            98944945,
            98934044,
            98976764,
            99270253
        ],
        "E": [
            98926708,
            98926305,
            98923150,
            98930994,
            98926114,
            98927253,
            98926662,
            99001021,
            98943947,
            99042260,
            98926234,
            98930834,
            98943700,
            98921374,
            98925742,
            98930269,
            98929950,
            98918489,
            98928745,
            98929548
        ],
        "D": [
            98906301,
            98909937,
            98915472,
            98909763,
            98919427,
            98912085,
            99000804,
            98903628,
            98909739,
            98911723,
            98911927,
            98913556,
            98901042,
            98908884,
            98907045,
            98910263,
            98910231,
            98913804,
            98909129
        ],
        "C": [
            98899318,
            98901635,
            98905651,
            98903381,
            98906519,
            98900085,
            98896987,
            98906559,
            98901684,
            98905788,
            98906611,
            98898047,
            98901391,
            98899348,
            98900377,
            98902439,
            98902965,
            98898261
        ],
        "B": [
            98897777,
            98898220,
            98901029,
            98900303,
            98904013,
            98898005,
            99000726,
            99000688,
            98978607,
            98898951,
            98904401,
            98905057,
            98908639,
            98904166,
            98896699,
            98898174,
            98897853,
            98902989,
            98899546,
            98900510,
            98903751
        ],
        "A": [
            98895449,
            98895686,
            98896660,
            98896462,
            98897246,
            98895467,
            98895360,
            98896351,
            100779606,
            98895507,
            98904547,
            98896942,
            98895363,
            98895604,
            98895575,
            98895460,
            98903659,
            98895637,
            98896531
        ],
        "G": [
            99251139,
            98943421,
            99550385,
            99358496,
            99358463,
            99358399,
            99296629,
            99296419,
            99053359,
            99052180,
            98944458,
            98945555,
            99287849
        ]
    },
    "name": "G. Game On Tree",
    "statement": "Alice and Bob are playing a game. They have a tree consisting of n\r\nvertices. Initially, Bob has k chips, the i-th chip is located in the\r\nvertex a_i (all these vertices are unique). Before the game starts,\r\nAlice will place a chip into one of the vertices of the tree.The game\r\nconsists of turns. Each turn, the following events happen (sequentially,\r\nexactly in the following order): Alice either moves her chip to an\r\nadjacent vertex or doesn’t move it; for each Bob’s chip, he either moves\r\nit to an adjacent vertex or doesn’t move it. Note that this choice is\r\ndone independently for each chip. The game ends when Alice’s chip shares\r\nthe same vertex with one (or multiple) of Bob’s chips. Note that Bob’s\r\nchips may share the same vertex, even though they are in different\r\nvertices at the beginning of the game.Alice wants to maximize the number\r\nof turns, Bob wants to minimize it. If the game ends in the middle of\r\nsome turn (Alice moves her chip to a vertex that contains one or\r\nmultiple Bob’s chips), this turn is counted.For each vertex, calculate\r\nthe number of turns the game will last if Alice places her chip in that\r\nvertex.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\nstruct tree{\n\tint n;\n\tvector<vector<int>> G;\n\ttree(){}\n\ttree(int n_){\n\t\tn=n_;\n\t\tG=vector<vector<int>>(n);\n\t}\n\t\n\tvoid add_edge(int a,int b){\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tvoid input(int ind){\n\t\tscanf(\"%d\",&n);\n\t\tG=vector<vector<int>>(n);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\ta-=ind; b-=ind;\n\t\t\tadd_edge(a,b);\n\t\t}\n\t}\n\t\n\tvoid dfs_dist(int v,int p,int d,vector<int> &dist){\n\t\tdist[v]=d;\n\t\tfor(int u: G[v]){\n\t\t\tif(u==p)continue;\n\t\t\tdfs_dist(u,v,d+1,dist);\n\t\t}\n\t}\n\t\n\t//centroids\n\tint cent;\n\tvector<tree*> subtree;\n\tvector<pair<int,int>> id;\n\tint dfs_sz(int v,int p,vector<int> &par,vector<int> &sz){\n\t\tpar[v]=p;\n\t\tsz[v]=1;\n\t\tfor(int u: G[v]){\n\t\t\tif(u==p)continue;\n\t\t\tsz[v]+=dfs_sz(u,v,par,sz);\n\t\t}\n\t\treturn sz[v];\n\t}\n\tint dfs_id(int v,int p,pair<int,int> id_){\n\t\tid[v]=id_; id_.sc++;\n\t\tfor(int u: G[v]){\n\t\t\tif(u==p)continue;\n\t\t\tid_.sc=dfs_id(u,v,id_);\n\t\t\tsubtree[id_.fr]->add_edge(id[v].sc,id[u].sc);\n\t\t}\n\t\treturn id_.sc;\n\t}\n\tvoid cent_div(){\n\t\tvector<int> sz(n),par(n);\n\t\tdfs_sz(0,-1,par,sz);\n\t\tcent=0;\n\t\twhile(1){\n\t\t\tif(sz[cent]<=n/2){\n\t\t\t\tcent=par[cent];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool upd=false;\n\t\t\tfor(int u: G[cent]){\n\t\t\t\tif(u==par[cent])continue;\n\t\t\t\tif(sz[u]>n/2){\n\t\t\t\t\tcent=u;\n\t\t\t\t\tupd=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!upd)break;\n\t\t}\n\t\tid=vector<pair<int,int>>(n);\n\t\tfor(int u: G[cent]){\n\t\t\tsubtree.push_back(new tree(u==par[cent]?(n-sz[cent]):sz[u]));\n\t\t\tdfs_id(u,cent,mp(subtree.size()-1,0));\n\t\t}\n\t\tfor(auto t: subtree)t->cent_div();\n\t}\n\t\n\tvector<int> dist;\n\tvector<int> val;\n\tvoid f(vector<int> &d){\n\t\tdist=vector<int>(n);\n\t\tdfs_dist(cent,-1,0,dist);\n\t\tval=vector<int>(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tval[dist[i]]=max(val[dist[i]],d[i]);\n\t\t}\n\t\tfor(int i=0;i+1<n;i++){\n\t\t\tval[i+1]=max(val[i+1],val[i]);\n\t\t}\n\t\tvector<vector<int>> d_(subtree.size());\n\t\tfor(int i=0;i<subtree.size();i++)d_[i]=vector<int>(subtree[i]->n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==cent)continue;\n\t\t\td_[id[i].fr][id[i].sc]=d[i];\n\t\t}\n\t\tfor(int i=0;i<subtree.size();i++){\n\t\t\tsubtree[i]->f(d_[i]);\n\t\t}\n\t}\n\tbool solve(int v,int d){\n\t\tif(d-1-dist[v]>=0&&val[min(n-1,d-1-dist[v])]>=d)return true;\n\t\tif(v==cent)return false;\n\t\treturn subtree[id[v].fr]->solve(id[v].sc,d);\n\t}\n\t\n\t//debug\n\tvoid output(){\n\t\tcerr<<n<<endl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcerr<<i<<\"-\";\n\t\t\tfor(int j: G[i]){\n\t\t\t\tcerr<<j<<\",\";\n\t\t\t}\n\t\t\tcerr<<endl;\n\t\t}\n\t}\n\tvoid debug_centroids(){\n\t\toutput();\n\t\tfor(auto t: subtree)t->debug_centroids();\n\t}\n};\n\ntree T;\nint k;\nint a[200010];\n\nint main(){\n\tT.input(1);\n\tscanf(\"%d\",&k);\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\t\n\tT.cent_div();\n\t\n\tif(1){\n\t\tvector<int> d(T.n,INF);\n\t\tqueue<int> que;\n\t\tfor(int i=0;i<k;i++){\n\t\t\td[a[i]]=0;\n\t\t\tque.push(a[i]);\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front(); que.pop();\n\t\t\tfor(int u: T.G[v]){\n\t\t\t\tif(d[u]>d[v]+1){\n\t\t\t\t\td[u]=d[v]+1;\n\t\t\t\t\tque.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tT.f(d);\n\t}\n\tfor(int i=0;i<T.n;i++){\n\t\tint l=0,r=T.n-1;\n\t\twhile(l<r){\n\t\t\tint mid=(l+r+1)/2;\n\t\t\tif(T.solve(i,mid))l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tprintf(\"%d%c\",l,(i+1==T.n)?'\\n':' ');\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Game On Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/84847",
    "editorial": "This task was inspired by an older edu task and another task proposed by\r\nRockyB.Letâs learn to solve the problem for at least one starting vertex\r\nfor Alice. Let this vertex be . In general, Aliceâs strategy is\r\nbasically this: run to some vertex as fast as possible and stay in it\r\nuntil Bob reaches . Hesitation on a way to this vertex wonât be optimal.\r\nVisiting the same vertex multiple times wonât as well. I guess that can\r\nbe proven more formally by analyzing the set of possible solutions after\r\neach move.What properties should vertex have for Alice to be able to\r\nescape to it? There shouldnât be a way for Bob to catch her midway.\r\nHowever, itâs not necessary to check any midway intersections. If Bob\r\ncan catch her anywhere on a path, she can also follow her to the end (by\r\nmoving the same path) and catch her at the destination. Thus, this\r\nvertex should be further from any Bobâs chips than from .So you can\r\nprecalculate the distance to the closest Bobâs chip to each vertex .\r\nJust push all chips to a queue and run a bfs.Weâve learned to solve the\r\nproblem in for each vertex . Just iterate over all vertices and take the\r\nmaximum of over such of them that have greater than the distance from to\r\n.Now the solution can go two ways. You can stop thinking here and obtain\r\nan one or think more and get an .The first one goes like that. Notice\r\nthat the function if the Alice can make at least moves from vertex is\r\nmonotonous in regard to . So we can binary search the answer. The check\r\nquery transforms to the following. Consider all vertices with distance\r\nless or equal to from . There should exist at least one vertex with\r\nvalue for the check to return true. So at least the maximum value of\r\nthem should be greater than .That is basically a centroid exercise. Let\r\neach centroid store such an array that is the maximum value of over all\r\nsuch that belong to this centroidâs subgraph and are no further than\r\ndistance from the centroid. That array can be constructed in for all\r\ncentroids in total. You can easily see that the length of this array\r\ndoesnât exceed the number of vertices in the subgraph of the\r\ncorresponding centroid that is be definition.For the query iterate over\r\nall centroids belongs to and check the value from some cell of each\r\noneâs array.For the second solution letâs reverse the problem. Consider\r\nthe vertex Alice escapes to. If there is a starting vertex no further\r\nthan from it, then the answer for can be updated with . So we can update\r\nthe subgraph of vertices with distance no more than with the maximum of\r\ntheir current answer and .The solution will be almost the same centroid.\r\nIterate over all centroids belongs to and write into the cell of each\r\noneâs array , where is the distance from to this centroid. Then build an\r\narray of prefix maximums over this array. Finally, for each collect the\r\nbest answer over all centroids belongs to.Overall complexity: or .\r\n",
    "hint": []
}