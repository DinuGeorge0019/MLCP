{
    "link": "https://codeforces.com//contest/884/problem/B",
    "problemId": "130888",
    "problem_idx": "B",
    "shortId": "884B",
    "contest_number": "884",
    "problem_submissions": {
        "F": [
            31808128,
            31809259,
            31810428,
            31811126,
            31807028,
            31810125,
            31808407,
            31808014,
            31873745,
            31808068,
            31810481,
            70767801,
            36469296,
            36469289,
            31909919,
            31809387,
            31822510,
            31808175,
            31811034
        ],
        "E": [
            31805401,
            31807388,
            31807565,
            31808478,
            31804019,
            31805975,
            31805687,
            31805755,
            31841462,
            31810079,
            31810699,
            31810217,
            31811063,
            31809732,
            31810149
        ],
        "D": [
            31802703,
            31804699,
            31804124,
            31804641,
            31808138,
            31803343,
            31802113,
            31801774,
            31802510,
            31803536,
            31804976,
            31801949,
            31805944,
            31805607,
            31803821,
            31809103,
            31803969,
            31818412,
            31806095
        ],
        "C": [
            31800883,
            31800607,
            31802838,
            31802069,
            31799616,
            31802362,
            31800429,
            31800236,
            31800839,
            31801291,
            31801670,
            31800496,
            31801796,
            31802338,
            31801055,
            31801861,
            31801455,
            31800685,
            31802138
        ],
        "B": [
            31799211,
            31799036,
            31801939,
            31801321,
            31801497,
            31798756,
            31799168,
            31799265,
            31799895,
            31799341,
            31799382,
            31800133,
            31800205,
            31799009,
            31800238,
            31799378,
            31799257,
            31800274
        ],
        "A": [
            31798352,
            31798382,
            31801358,
            31800677,
            31801116,
            31798306,
            31798460,
            31798672,
            31798979,
            31798397,
            31798744,
            31798807,
            31798611,
            31798307,
            31798790,
            31798478,
            31798275,
            31799367
        ]
    },
    "name": "B. Japanese Crosswords Strike Back",
    "statement": "A one-dimensional Japanese crossword can be represented as a binary\r\nstring of length . An encoding of this crossword is an array of size ,\r\nwhere is the number of segments formed completely of â€™s, and is the\r\nlength of -th segment. No two segments touch or intersect.For example:\r\nIf and the crossword is , then its encoding is an array ; If and the\r\ncrossword is , then its encoding is an array ; If and the crossword is ,\r\nthen its encoding is an array ; If and the crossword is , then its\r\nencoding is an empty array. Mishka wants to create a new one-dimensional\r\nJapanese crossword. He has already picked the length and the encoding\r\nfor this crossword. And now he needs to check if there is crossword such\r\nthat its length and encoding are equal to the length and encoding he\r\npicked. Help him to check it!\r\n",
    "solutions": [
        "#include <utility>\n#include <functional>\n#include <map>\n#include <iterator>\n#include <vector>\n#include <array>\n#include <cstdio>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main()\n{\n    int N;\n    ll X;\n    RD(N, X);\n\n    ll sum = 0;\n    for(int i: RG(N))\n    {\n        int l;\n        RD(l);\n        sum += l;\n    }\n\n    if(sum + N - 1 == X)\n        WTL(\"YES\");\n    else\n        WTL(\"NO\");\n\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Japanese Crosswords Strike Back.json",
    "editorial_link": "https://codeforces.com//blog/entry/55470",
    "editorial": "The only answer is when no segment can be moved one cell either to the\r\nleft or to the right. So there should be exactly one cell between two\r\nconsecutive segments and the first and the last segments should touch\r\nthe borders.Thus total count of cells needed is .Overall complexity; .\r\n",
    "hint": []
}