{
    "link": "https://codeforces.com//contest/1651/problem/B",
    "problemId": "1324097",
    "problem_idx": "B",
    "shortId": "1651B",
    "contest_number": "1651",
    "problem_submissions": {
        "C": [
            149173723,
            149105792,
            149117381,
            149152549,
            149106514,
            149108421,
            149108464,
            149108635,
            149109429,
            149110791,
            149109777,
            149108515,
            149109773,
            149111699,
            149114619,
            149106949,
            149113559,
            149129766
        ],
        "F": [
            149161364,
            149158834,
            149161121,
            149123303,
            149175934,
            149179491,
            191725924,
            149575413
        ],
        "E": [
            149139170,
            149130164,
            149147455,
            149137360,
            149140976,
            149145909,
            149141908,
            149139460,
            149147248,
            149148678,
            149156290,
            149148881,
            149154274,
            149143485,
            149163314,
            149138047,
            149159145
        ],
        "D": [
            149127559,
            149163309,
            149150118,
            149115060,
            149119439,
            149116468,
            149116651,
            149118386,
            149120734,
            149121740,
            149119776,
            149192081,
            149191968,
            149191879,
            149191841,
            149191815,
            149191600,
            149191163,
            149191124,
            149128435,
            149129157,
            149129578,
            149116059,
            149145989,
            149116064
        ],
        "B": [
            149098208,
            149096317,
            149154308,
            149094973,
            149099387,
            149095439,
            149099190,
            149096388,
            149097486,
            149098725,
            149098039,
            149097903,
            149102336,
            149093030,
            149096020,
            149099865,
            149101390
        ],
        "A": [
            149092351,
            149091868,
            149155144,
            149091621,
            149091628,
            149091655,
            149091686,
            149091765,
            149091751,
            149092326,
            149091819,
            149092231,
            149094932,
            149091603,
            149091630,
            149091669,
            149092684
        ]
    },
    "name": "B. Prove Him Wrong",
    "statement": "Recently, your friend discovered one special operation on an integer\r\narray a: Choose two indices i and j (i\r\nneq j); Set a_i = a_j = |a_i - a_j|. After playing with this operation\r\nfor a while, he came to the next conclusion: For every array a of n\r\nintegers, where 1\r\nle a_i\r\nle 10^9, you can find a pair of indices (i, j) such that the total sum\r\nof a will after performing the operation. This statement sounds fishy to\r\nyou, so you want to find a counterexample for a given integer n. Can you\r\nfind such counterexample and prove him wrong?In other words, find an\r\narray a consisting of n integers a_1, a_2,\r\ndots, a_n (1\r\nle a_i\r\nle 10^9) such that for all pairs of indices (i, j) performing the\r\noperation won’t decrease the total sum (it will increase or not change\r\nthe sum).\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    ll ans[N];\n    ans[0] = 1;\n    FOR(i, 1, N) {\n        ans[i] = ans[i-1] * 3;\n        if (ans[i] > MOD-7) {\n            cout << \"NO\" << nl; return;\n        }\n    }\n    cout << \"YES\" << nl;\n    F0R(i, N) cout << ans[i] << \" \";\n    cout << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Prove Him Wrong.json",
    "editorial_link": "https://codeforces.com//blog/entry/100796",
    "editorial": "Suppose the initial sum of is equal to . If we perform the operation,\r\nthe new sum will be equal to . We want the sum not to decrease, or . If\r\n, we will get: If weâll get analogically.In other words, array you need\r\n(if sorted) will have , and so on. And one of the variants (and,\r\nobviously, an optimal one) is just .As a result, since , we just need to\r\ncheck: if then we found an answer, otherwise there is no counterexample.\r\n",
    "hint": []
}