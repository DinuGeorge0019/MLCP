{
    "link": "https://codeforces.com//contest/1783/problem/D",
    "problemId": "1728813",
    "problem_idx": "D",
    "shortId": "1783D",
    "contest_number": "1783",
    "problem_submissions": {
        "G": [
            188483896,
            188470188,
            188490778,
            188491718,
            188493113,
            188527457,
            188526933,
            188518837,
            188481313
        ],
        "F": [
            188457991,
            188459741,
            188468922,
            188473664,
            188468205,
            188471208,
            188461540,
            188473366,
            188477664,
            188473046,
            188489629,
            188473873,
            188484171,
            188480546,
            188485471,
            188484623,
            188483301,
            188466307,
            188469985,
            188485060
        ],
        "E": [
            188452364,
            188453897,
            188463917,
            188466624,
            188459377,
            188459968,
            188455446,
            188466225,
            188471180,
            188466814,
            188462880,
            188467584,
            188467423,
            188462700,
            188463311,
            188503353,
            188474118,
            188475092,
            188461623,
            188502886,
            188463602,
            188475668
        ],
        "D": [
            188448529,
            188449082,
            188455318,
            188454045,
            188455437,
            188454808,
            188471673,
            188459878,
            188455664,
            188459984,
            188457996,
            188455008,
            188460084,
            188450967,
            188459128,
            188456144,
            188459103,
            188459237,
            188463185
        ],
        "C": [
            188443311,
            188439911,
            188447553,
            188445874,
            188449689,
            188446252,
            188448135,
            188452418,
            188447924,
            188450344,
            188449627,
            188448578,
            188449959,
            188467122,
            188452277,
            188450824,
            188449810,
            188450396,
            188451763,
            188456895
        ],
        "B": [
            188434637,
            188433902,
            188440591,
            188436845,
            188440180,
            188437731,
            188434593,
            188440675,
            188439917,
            188436694,
            188436264,
            188437707,
            188438645,
            188437659,
            188440538,
            188439980,
            188442461,
            188440519,
            188465336,
            188436451
        ],
        "A": [
            188432373,
            188432255,
            188432618,
            188432523,
            188433063,
            188432771,
            188432273,
            188433871,
            188432631,
            188433273,
            188432881,
            188432854,
            188433005,
            188432822,
            188435678,
            188432922,
            188432552,
            188432977,
            188432291,
            188432577
        ]
    },
    "name": "D. Different Arrays",
    "statement": "You are given an array a consisting of n integers.You perform the\r\nsequence of n-2 operations on this array: during the first operation,\r\nyou either add a_2 to a_1 and subtract a_2 from a_3, or add a_2 to a_3\r\nand subtract a_2 from a_1; during the second operation, you either add\r\na_3 to a_2 and subtract a_3 from a_4, or add a_3 to a_4 and subtract a_3\r\nfrom a_2; ... during the last operation, you either add a_{n-1} to\r\na_{n-2} and subtract a_{n-1} from a_n, or add a_{n-1} to a_n and\r\nsubtract a_{n-1} from a_{n-2}. So, during the i-th operation, you add\r\nthe value of a_{i+1} to one of its neighbors, and subtract it from the\r\nother neighbor.For example, if you have the array [1, 2, 3, 4, 5], one\r\nof the possible sequences of operations is: subtract 2 from a_3 and add\r\nit to a_1, so the array becomes [3, 2, 1, 4, 5]; subtract 1 from a_2 and\r\nadd it to a_4, so the array becomes [3, 1, 1, 5, 5]; subtract 5 from a_3\r\nand add it to a_5, so the array becomes [3, 1, -4, 5, 10]. So, the\r\nresulting array is [3, 1, -4, 5, 10].An array is if it can be obtained\r\nby performing the aforementioned sequence of operations on a. You have\r\nto calculate the number of reachable arrays, and print it modulo\r\n998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int sum = std::accumulate(a.begin(), a.end(), 0);\n    std::vector<Z> dp(2 * sum + 1);\n    dp[a[1] + sum] = 1;\n    \n    for (int i = 2; i < n; i++) {\n        std::vector<Z> g(2 * sum + 1);\n        for (int j = 0; j <= 2 * sum; j++) {\n            if (!dp[j].val()) continue;\n            g[sum + a[i] - (j - sum)] += dp[j];\n            if (j != sum) g[sum + a[i] + (j - sum)] += dp[j];\n        }\n        std::swap(dp, g);\n    }\n    \n    auto ans = std::accumulate(dp.begin(), dp.end(), Z(0));\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Different Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/111194",
    "editorial": "One of the key observations to this problem is that, after the first\r\noperations, the first elements of the array are fixed and cannot be\r\nchanged afterwards. Also, after the -th operation, the elements on\r\npositions from to are the same as they were before applying the\r\noperations.This allows us to write the following dynamic programming:\r\nthe number of different prefixes our array can have, if we have\r\nperformed operations, the -th element is , and the -th element is . The\r\nelements after are the same as in the original array, and the elements\r\nbefore wonât be changed anymore, so we are interested only in these two\r\nelements.Letâs analyze the transitions in this dynamic programming. We\r\napply the operation to the elements , and . If we add to , then we\r\nsubtract it from , so we transition into state . Otherwise, we\r\ntransition into state . The element we leave behind is either or , and\r\nif , these two transitions give us different prefixes. But if , we need\r\nto make only one of these transitions, because adding or subtracting\r\nactually makes no difference.Okay, now weâve got a solution with dynamic\r\nprogramming in , where is up to and is up to . This is too slow. But we\r\ncan notice that the value of actually does not affect our transitions at\r\nall; we can just discard it, so our dynamic programming becomes , which\r\neasily fits into TL.Small implementation note: elements can become\r\nnegative, and in order to store dynamic programming with negative states\r\nin an array, we need to do something about that. I donât recommend using\r\nmaps (neither ordered nor unordered): you either get an extra log\r\nfactor, or make your solution susceptible to hacking. Instead, letâs say\r\nthat the value of , where can be a negative number, will be stored as in\r\nthe array, where is some constant which is greater than the maximum\r\npossible (for example, in this problem). That way, all array indices\r\nwill be non-negative.Solution complexity: .\r\n",
    "hint": []
}