{
    "link": "https://codeforces.com//contest/609/problem/E",
    "problemId": "43548",
    "problem_idx": "E",
    "shortId": "609E",
    "contest_number": "609",
    "problem_submissions": {
        "F": [
            14886217,
            14887477,
            14888177,
            14886379,
            14885040,
            14885527,
            14887905,
            14886648,
            14888303,
            14895268,
            14888745,
            14917735,
            14898327,
            14893077,
            14892871
        ],
        "E": [
            14882063,
            14883627,
            14884067,
            14882265,
            14882405,
            14883303,
            14885623,
            14884355,
            14884989,
            14882411,
            14880931,
            14884153,
            14884117,
            14884965,
            14886043,
            14885211,
            14885825,
            14885599
        ],
        "D": [
            14879612,
            14881347,
            14882734,
            14880026,
            14880930,
            14881222,
            14881919,
            14978995,
            14882591,
            14880772,
            14880443,
            14883120,
            14881030,
            14880993,
            14882082,
            14883447,
            14882873,
            14884432,
            14883318
        ],
        "C": [
            14878082,
            14878799,
            14878664,
            14878553,
            14878302,
            14878492,
            14879132,
            14879063,
            14878272,
            14878604,
            14878442,
            14879174,
            14878439,
            14879071,
            14879422,
            14879561,
            14879189,
            14879663
        ],
        "B": [
            14877436,
            14877988,
            14877744,
            14877733,
            14877531,
            14877677,
            14878043,
            14878384,
            14877598,
            14877591,
            14877568,
            14877569,
            14877547,
            14877786,
            14877829,
            14878321,
            14878191,
            14879079
        ],
        "A": [
            14877245,
            14877406,
            14877341,
            14877385,
            14877254,
            14877304,
            14877500,
            14878068,
            14877300,
            14877250,
            14877283,
            14877265,
            14877281,
            14877315,
            14877259,
            14877505,
            14877351,
            14878481
        ]
    },
    "name": "E. Minimum spanning tree for each edge",
    "statement": "Connected undirected weighted graph without self-loops and multiple\r\nedges is given. Graph contains vertices and edges.For each edge find the\r\nminimal possible weight of the spanning tree that contains the edge .The\r\nweight of the spanning tree is the sum of weights of all edges included\r\nin spanning tree.\r\n",
    "solutions": [
        "/*\nTake me back\nBack to the scene\nIt's coming back\nI remember her screams\n\nThe fear in her eye\nThe night she died\nIt left me empty\nHollow inside\n\nDead to the world\nI see only black\nThere's blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n\nFeelings deep inside\nI don't understand\nCan't fall asleep at night\nI try and wake in fright\n\nTouch of her skin\nNext to mine\nWarm and wet\nDeep inside\n\nDead to the world\nI see only black\nThere's blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n\nI wrapped my hands around her neck\nSqueezing out her breath\nEyes rolled back in her head\nClawing at my skin\nI know now it's not my fault\nShe was asking for it\n\nMemories\nCame back to me\nIn the night\n\nI hear her screams\nWaiting\nIn the grave\nCalling out\n\nCome to me\nI hear her screaming\nWaiting in the grave\nCalling out but she's buried\n\nWaiting in the grave\nCome to me\nI hear her screaming\nWaiting\n\nI wrapped my hands around her neck\nSqueezing out her breath\nEyes rolled back in her head\nClawing at my skin\nI know now it's not my fault\nShe was asking for it\n\nMemories\nCame back to me\nIn the night\n\nI hear her screams\nWaiting\nIn the grave\nCalling out\n\nI remember her screams\nThe night she died\nI left her empty\nHollow inside\n\nDead to the world\nI see only black\nThere's blood on my hands\n\nDead to the world\nI see only black\nThe blood of the dead\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nconst int l = 17;\n\nusing namespace std;\n\nint n, m;\nvector<pair<int, int> > g[N];\nvector<pair<int, pair<int, int> > > edges, edges2,mst;\nint w[N];\nlong long COST;\nint timer;\nint up[N][l + 1];\nint bedge[N][l + 1];\nint tin[N];\nint tout[N];\nint dep[N];\n\nvoid dfs(int v, int p = 1,int pcost=0)\n{\n\ttin[v] = timer;\n\t++timer;\n\tup[v][0] = p;\n\tbedge[v][0] = pcost;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tup[v][i] = up[up[v][i - 1]][i - 1];\n\t\tbedge[v][i] = max(bedge[v][i - 1], bedge[up[v][i-1]][i - 1]);\n\t}\n\tfor (int i = 0; i < g[v].size(); i++)\n\t{\n\t\tint to = g[v][i].first;\n\t\tint cost = g[v][i].second;\n\t\tif (to == p)\n\t\t\tcontinue;\n\t\tdep[to] = dep[v] + 1;\n\t\tdfs(to, v, cost);\n\t}\n\ttout[v] = timer;\n\t++timer;\n}\n\nbool upper(int a, int b)\n{\n\treturn (tin[a] <= tin[b] && tout[a] >= tout[b]);\n}\n\nint lca(int a, int b)\n{\n\tif (upper(a, b))\n\t\treturn a;\n\tif (upper(b, a))\n\t\treturn b;\n\tfor (int i = l; i >= 0; --i)\n\t{\n\t\tif (!upper(up[a][i], b))\n\t\t\ta = up[a][i];\n\t}\n\treturn up[a][0];\n}\n\nint get(int x)\n{\n\tif (x == w[x])\n\t\treturn x;\n\treturn w[x] = get(w[x]);\n}\n\nvoid merge(int a, int b)\n{\n\tif (rand() % 2)\n\t\tswap(a, b);\n\ta = get(a);\n\tb = get(b);\n\tw[a] = b;\n}\n\nint get_best(int v, int span)\n{\n\tint ret = 0;\n\tfor (int i = l; i >= 0; --i)\n\t{\n\t\tif (span&(1 << i))\n\t\t{\n\t\t\tret = max(ret, bedge[v][i]);\n\t\t\tv = up[v][i];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tedges.push_back(make_pair(c, make_pair(a, b)));\n\t\tedges2.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(edges.begin(), edges.end());\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tw[i] = i;\n\t}\n\n\tfor (int i = 0; i < edges.size(); i++)\n\t{\n\t\tint a, b, c;\n\t\ta = edges[i].second.first;\n\t\tb = edges[i].second.second;\n\t\tint ta, tb;\n\t\tc = edges[i].first;\n\t\tta = get(a);\n\t\ttb = get(b);\n\t\tif (ta == tb)\n\t\t\tcontinue;\n\t\tmerge(ta, tb);\n\t\tmst.push_back(make_pair(c, make_pair(a, b)));\n\t\tCOST += c;\n\t}\n\n\tfor (int i = 0; i < mst.size(); i++)\n\t{\n\t\tint v1 = mst[i].second.first;\n\t\tint v2 = mst[i].second.second;\n\t\tint cost = mst[i].first;\n\t\tg[v1].push_back(make_pair(v2, cost));\n\t\tg[v2].push_back(make_pair(v1, cost));\n\t}\n\t\n\tdfs(1);\n\n\tfor (int i = 0; i < edges2.size(); i++)\n\t{\n\t\tint v1 = edges2[i].second.first;\n\t\tint v2 = edges2[i].second.second;\n\t\tint L = lca(v1, v2);\n\t\tint bst = 0;\n\t\tbst = max(bst, get_best(v1, dep[v1] - dep[L]));\n\t\tbst = max(bst, get_best(v2, dep[v2] - dep[L]));\n\t\tcout << COST + edges2[i].first - bst << \"\\n\";\n\t}\n\n\tcin.get();cin.get();\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Minimum spanning tree for each edge.json",
    "editorial_link": "https://codeforces.com//blog/entry/22187",
    "editorial": "This problem was prepared by dalex. Letâs build any MST with any fast\r\nalgorithm (for example with Kruskalâs algorithm). For all edges in MST\r\nthe answer is the weight of the MST. Letâs consider any other edge .\r\nThere is exactly one path between and in the MST. Letâs remove mostly\r\nheavy edge on this path and add edge . Resulting tree is the MST\r\ncontaning edge (this can be proven by Tarjan criterion). Letâs fix some\r\nroot in the MST (for example the vertex ). To find the most heavy edge\r\non the path from to we can firstly find the heaviest edge on the path\r\nfrom to and then on the path from to , where is the lowest common\r\nancestor of vertices and . To find we can use binary lifting method.\r\nDuring calculation of we also can maintain the weight of the heaviest\r\nedge. Of course this problem also can be solved with difficult data\r\nstructures, for example with Heavy-light decomposition method or with\r\nLinkcut trees. Complexity: . Itâs very strange but I canât find any\r\narticles with Tarjan criterion on English (although there are articles\r\non Russian), so here it is: Some spanning tree is minimal if and only if\r\nthe weight of any other edge (not from spanning tree) is not less than\r\nthe weight of the heaviest edge on the path from to in spanning tree.\r\n",
    "hint": []
}