{
    "link": "https://codeforces.com//contest/1155/problem/D",
    "problemId": "334464",
    "problem_idx": "D",
    "shortId": "1155D",
    "contest_number": "1155",
    "problem_submissions": {
        "F": [
            53147227,
            53157176,
            53156900,
            53156084,
            53154052,
            53160034,
            53156325,
            53151832,
            53154755,
            53148688,
            53161959,
            53262750,
            53737446,
            53737379,
            53175185
        ],
        "E": [
            53135994,
            53143627,
            53147598,
            53158466,
            53136989,
            53158165,
            53136136,
            53151523,
            53138725,
            53138756,
            53143870,
            53141750,
            53144225,
            53141600,
            53144263,
            53142970,
            53144678,
            53143027,
            53146492,
            53139061
        ],
        "D": [
            53132284,
            53136375,
            53137845,
            53140433,
            53131955,
            53144376,
            53152771,
            53133770,
            53130242,
            53133856,
            53135466,
            53137404,
            53132457,
            53137383,
            53135331,
            53136120,
            53161942,
            53136545,
            53137490,
            53137142
        ],
        "C": [
            53130521,
            53133027,
            53132212,
            53133949,
            53152978,
            53158707,
            53154112,
            53130838,
            53134553,
            53131325,
            53130045,
            53131332,
            53135487,
            53132186,
            53132107,
            53133338,
            53132645,
            53132555,
            53132260
        ],
        "B": [
            53127872,
            53130197,
            53129680,
            53129662,
            53128390,
            53156310,
            53155054,
            53129416,
            53131929,
            53128726,
            53127750,
            53128694,
            53130002,
            53129606,
            53130017,
            53128669,
            53130637,
            53130008,
            53131121
        ],
        "A": [
            53127037,
            53127563,
            53127047,
            53127010,
            53127272,
            53156874,
            53155461,
            53127028,
            53127341,
            53127201,
            53128346,
            53127115,
            53128140,
            53127708,
            53127365,
            53130750,
            53128472,
            53127451,
            53127014
        ]
    },
    "name": "D. Beautiful Array",
    "statement": "You are given an array a consisting of n integers. Beauty of array is\r\nthe maximum sum of some of this array (this subarray may be empty). For\r\nexample, the beauty of the array is , and the beauty of the array is\r\n.You may choose of a and multiply all values contained in this subarray\r\nby x. You want to maximize the beauty of array after applying at most\r\none such operation.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll INF = (ll)1e18;\nconst int N = 300300;\nll dp[N][3][3];\nll a[N];\nint n;\nll X;\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%lld\", &n, &X);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tfor (int h = 0; h < 3; h++)\n\t\t\t\tdp[i][j][h] = -INF;\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tfor (int h = 0; h < 3; h++) {\n\t\t\t\tif (dp[i][j][h] == -INF) continue;\n\t\t\t\tif (j < 2) dp[i][j + 1][h] = max(dp[i][j + 1][h], dp[i][j][h]);\n\t\t\t\tif (h < 2) dp[i][j][h + 1] = max(dp[i][j][h + 1], dp[i][j][h]);\n\t\t\t\tif (i < n) {\n\t\t\t\t\tll w = dp[i][j][h];\n\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\tif (h == 1)\n\t\t\t\t\t\t\tw += a[i] * X;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tw += a[i];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j][h] = max(dp[i + 1][j][h], w);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n][2][2]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Beautiful Array.json",
    "editorial_link": "https://codeforces.com/blog/entry/66687",
    "editorial": "The first intuitive guess one\u00e2\u0080\u0099s probably made is multiplying the segment\r\nof maximum sum for positive . That thing is correct. Unfortunately,\r\nthere is no similar strategy for non-positive , simple greedy won\u00e2\u0080\u0099t work\r\nthere.Thus, dynamic programming is our new friend. Let\u00e2\u0080\u0099s introduce the\r\nfollowing state: , where is the length of the currently processed\r\nprefix, is the state of maximum sum segment ( is not reached, it\u00e2\u0080\u0099ll\r\nappear later, is open, current elements are added to it, is passed, the\r\nsegment appeared earlier) and is the state of segment multiplied by with\r\nthe same values. This will store the maximum segment sum we can\r\nachieve.The only base state is the prefix of length is processed and\r\nboth segments are not open yet. The rest of values in are .There are two\r\nmain transitions. At any moment we can change the state of each segment\r\nto the next one without moving to the next position. From state (not\r\nreached) we can go to state (opened) and from state we can go to state\r\n(passed). Note that this easily covers the case where optimal segment is\r\nempty. We can also move to the next position updating the value of with\r\ncorrespondance to the current states of segments.The answer will be\r\nstored in the state where all the array is processed and both segments\r\nare closed.Overall complexity: .\r\n"
}