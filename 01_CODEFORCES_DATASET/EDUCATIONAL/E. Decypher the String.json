{"link": "https://codeforces.com//contest/1117/problem/E", "problemId": "300045", "problem_idx": "E", "shortId": "1117E", "contest_number": "1117", "problem_submissions": {"G": [50133387, 50123254, 50123975, 50124239, 50123132, 50123974, 50123215, 50127013, 50125132, 50130140, 50133285, 50124682, 50142168, 50142000, 50128625, 50127307, 50133494, 50129719, 50134469, 50129830], "F": [50129894, 50129949, 50128458, 50125468, 50258283, 50124925, 50127988, 50122434, 50127178, 50132498, 50126909, 50125577], "E": [50113506, 50115627, 50118164, 50107209, 50118889, 50116932, 50118288, 50119948, 50118689, 50116057, 50116780, 50120258, 50120803, 50119739, 50121927, 50120709, 50116907, 50127759, 50122643], "D": [50110620, 50112367, 50131628, 50126652, 50113412, 50109860, 50115490, 50114987, 50116012, 50113616, 50125192, 50118574, 50115262, 50116431, 50116297, 50116049, 50110665, 50113350, 50117624], "C": [50108198, 50108891, 50111125, 50127915, 50107557, 50112815, 50111363, 50117842, 50111074, 50110415, 50111200, 50113692, 50111129, 50113480, 50108576, 50111462, 50115486, 50110963, 50119614], "B": [50104160, 50104529, 50104672, 50128597, 50104068, 50103950, 50111786, 50105649, 50106152, 50105125, 50105851, 50105634, 50104517, 50104965, 50103901, 50105704, 50105385, 50105318, 50104942], "A": [50102635, 50102746, 50102713, 50128246, 50102816, 50102612, 50103360, 50104051, 50103578, 50102668, 50103665, 50103717, 50102845, 50102752, 50102665, 50102783, 50102642, 50102966, 50102721]}, "name": "E. Decypher the String", "statement": "You may use in C++, in Java, in Python or in Pascal to flush the output.\r\nIf you use some other programming language, consult its documentation.\r\nYou may also refer to the guide on interactive problems:\r\nhttps://codeforces.com/blog/entry/45307.You are given a string t\r\nconsisting of n lowercase Latin letters. This string was cyphered as\r\nfollows: initially, the jury had a string s consisting of n lowercase\r\nLatin letters. Then they applied a sequence of no more than n (possibly\r\nzero) operations. i-th operation is denoted by two integers a_i and b_i\r\n(1\r\nle a_i, b_i\r\nle n), and means swapping two elements of the string with indices a_i\r\nand b_i. All operations were done in the order they were placed in the\r\nsequence. For example, if s is and 2 following operations are performed:\r\na_1 = 1, b_1 = 2; a_2 = 2, b_2 = 3, then after the first operation the\r\ncurrent string is , and after the second operation the current string is\r\n, so t is .You are asked to restore the original string s.\r\nUnfortunately, you have no information about the operations used in the\r\nalgorithm (you don\u2019t even know if there were any operations in the\r\nsequence). But you may run the same sequence of operations on any string\r\nyou want, provided that it contains only lowercase Latin letters and its\r\nlength is n, and get the resulting string after those operations.Can you\r\nguess the original string s asking the testing system to run the\r\nsequence of swaps no more than 3 times?.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\nstring T;\n\nint hoge[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\t\n\tFOR(i,3) {\n\t\tT.clear();\n\t\tFOR(j,N) {\n\t\t\tif(i==0) T.push_back('a'+(j%26));\n\t\t\tif(i==1) T.push_back('a'+(j/26%26));\n\t\t\tif(i==2) T.push_back('a'+(j/26/26%26));\n\t\t}\n\t\tcout<<(\"? \"+T)<<endl;\n\t\tcin>>T;\n\t\tFOR(j,N) {\n\t\t\tx=(T[j]-'a')%26;\n\t\t\tif(i==0) hoge[j]+=x;\n\t\t\tif(i==1) hoge[j]+=26*x;\n\t\t\tif(i==2) hoge[j]+=26*26*x;\n\t\t}\n\t}\n\t\n\tFOR(i,N) T[hoge[i]]=S[i];\n\tcout<<\"! \"+T<<endl;\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "chinese remainder theorem", "constructive algorithms", "interactive", "math"], "dificulty": "2200", "interactive": false}