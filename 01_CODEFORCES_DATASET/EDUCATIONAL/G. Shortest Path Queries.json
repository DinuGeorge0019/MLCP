{
    "link": "https://codeforces.com//contest/938/problem/G",
    "problemId": "157309",
    "problem_idx": "G",
    "shortId": "938G",
    "contest_number": "938",
    "problem_submissions": {
        "G": [
            35382589,
            142741934,
            35374754,
            35374730,
            35374710,
            35374477,
            46133767,
            35440047
        ],
        "F": [
            35355120,
            35364585,
            35363394,
            35363174,
            35367302,
            35374806,
            35369385,
            35368951,
            35367527,
            35361321,
            35357853,
            35375040,
            35422822
        ],
        "E": [
            35352538,
            35354313,
            35352415,
            35358415,
            35352081,
            35358431,
            35356947,
            35369123,
            35351851,
            35352768,
            35353204,
            35355446,
            35355331,
            35364623,
            35352359,
            35354851,
            35364184,
            35361370,
            35349789
        ],
        "D": [
            35346635,
            35346136,
            35347680,
            35354109,
            35356864,
            35352477,
            35380385,
            35375255,
            35364649,
            35366010,
            35347274,
            35349910,
            35350445,
            35351420,
            35351959,
            35348864,
            35350459,
            35349429,
            35350797,
            35351471,
            35353004
        ],
        "C": [
            35345282,
            35350127,
            35345829,
            35352431,
            35355200,
            35349840,
            35349239,
            35363657,
            35345361,
            35347976,
            35348608,
            35349044,
            35347701,
            35346898,
            35346389,
            35351193,
            35383156,
            35355323,
            35348814,
            35348388,
            35350097,
            35356762
        ],
        "B": [
            35342225,
            35343255,
            35342194,
            35342912,
            35343411,
            35345634,
            35362645,
            35360273,
            35342183,
            35342830,
            35342648,
            35343913,
            35343057,
            35342574,
            35342930,
            35343254,
            35345517,
            35342996,
            35357602
        ],
        "A": [
            35341839,
            35341862,
            35342757,
            35341910,
            35341845,
            35344578,
            35362076,
            35359775,
            35341793,
            35341960,
            35341885,
            35342136,
            35341987,
            35341868,
            35342317,
            35344022,
            35341914,
            35342769
        ]
    },
    "name": "G. Shortest Path Queries",
    "statement": "You are given an undirected connected graph with weighted edges. The\r\nlength of some path between two vertices is the bitwise xor of weights\r\nof all edges belonging to this path (if some edge is traversed more than\r\nonce, then it is included in bitwise xor the same number of times).\r\nThere are three types of queries you have to process: add an edge\r\nconnecting vertex to vertex with weight . It is guaranteed that there is\r\nno edge connecting to before this query; remove an edge connecting\r\nvertex to vertex . It is guaranteed that there was such edge in the\r\ngraph, and the graph stays connected after this query; calculate the\r\nlength of the shortest path (possibly non-simple) from vertex to vertex\r\n. Print the answers for all queries of type .\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <pair<int, pii>> Vx[600000];\nvoid initupdate(int st, int en, int S, int E, int n, pair<int, pii> v) {\n\tif (en < S || E < st) return;\n\tif (st <= S && E <= en) {\n\t\tVx[n].push_back(v);\n\t\treturn;\n\t}\n\n\tint M = (S + E) / 2;\n\tinitupdate(st, en, S, M, 2 * n, v);\n\tinitupdate(st, en, M + 1, E, 2 * n + 1, v);\n}\n\n\nmap <pii, int> Mp;\nmap <pii, int> Mv;\nint Qu[200050][2];\n\nint val[30];\nint r[200050][2];\nint sz[200050];\n\nint cur = 0;\nvector <pair<pii, int>> Vr[600050];\nvector <pair<int, int>> Vsz[600050];\nvector <pair<int, int>> Vval[600050];\n\nvoid updateval(int x) {\n\tint i;\n\tfor (i = 29; i >= 0; i--) {\n\t\tif (x & (1 << i));\n\t\telse continue;\n\n\t\tif (val[i]) x ^= val[i];\n\t\telse {\n\t\t\tVval[cur].emplace_back(i, val[i]);\n\t\t\tval[i] = x;\n\t\t\treturn;\n\t\t}\n\t}\n}\npii root(int x) {\n\tint ro = x, v = 0;\n\twhile (ro != r[ro][0]) {\n\t\tv ^= r[ro][1];\n\t\tro = r[ro][0];\n\t}\n\treturn pii(ro, v);\n}\nvoid mymerge(int a, int b, int c) {\n\tpii u1 = root(a);\n\tpii u2 = root(b);\n\n\tint r1 = u1.first, r2 = u2.first;\n\tc ^= u1.second ^ u2.second;\n\tif (r1 != r2) {\n\t\tif (sz[r1] > sz[r2]) swap(r1, r2);\n\t\tVr[cur].emplace_back(pii(r1, 0), r[r1][0]);\n\t\tVr[cur].emplace_back(pii(r1, 1), r[r1][1]);\n\t\tVsz[cur].emplace_back(r2, sz[r2]);\n\t\tr[r1][0] = r2;\n\t\tr[r1][1] = c;\n\t\tsz[r2] += sz[r1];\n\t}\n\telse updateval(c);\n}\nvoid getans(int st, int en, int S, int E, int n) {\n\tif (en < S || E < st) return;\n\t\n\tcur = n;\n\tfor (auto it : Vx[n]) {\n\t\tint c = it.first, x = it.second.first, y = it.second.second;\n\t\tmymerge(x, y, c);\n\t}\n\tif (S == E) {\n\t\tint x = Qu[S][0], y = Qu[S][1];\n\t\tpii u1 = root(x), u2 = root(y);\n\t\t\n\t\tint c = u1.second ^ u2.second;\n\t\tfor (int i = 29; i >= 0; i--) {\n\t\t\tif (!(c & (1 << i))) continue;\n\t\t\tif (!val[i]) continue;\n\t\t\tc ^= val[i];\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\telse {\n\t\tint M = (S + E) / 2;\n\t\tgetans(st, en, S, M, 2 * n);\n\t\tgetans(st, en, M + 1, E, 2 * n + 1);\n\t}\n\treverse(all(Vr[n]));\n\treverse(all(Vsz[n]));\n\treverse(all(Vval[n]));\n\tfor (auto it : Vr[n]) r[it.first.first][it.first.second] = it.second;\n\tfor (auto it : Vsz[n]) sz[it.first] = it.second;\n\tfor (auto it : Vval[n]) val[it.first] = it.second;\n\tVr[n].clear();\n\tVsz[n].clear();\n\tVval[n].clear();\n}\n\nint ux[200050][4];\nint main() {\n\tint N, M, Q, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2, t3;\n\t\tscanf(\"%d %d %d\", &t1, &t2, &t3);\n\t\tif (t1 > t2) swap(t1, t2);\n\t\tMp[pii(t1, t2)] = 1;\n\t\tMv[pii(t1, t2)] = t3;\n\t}\n\t\n\tint qc = 0, cc = 0;\n\tscanf(\"%d\", &Q);\n\tfor (i = 1; i <= Q; i++) {\n\t\tscanf(\"%d %d %d\", &ux[i][0], &ux[i][1], &ux[i][2]);\n\t\tif (ux[i][0] == 1) scanf(\"%d\", &ux[i][3]);\n\t\tif (ux[i][0] == 3) cc++;\n\t}\n\tfor (IT_MAX = 2; IT_MAX <= cc; IT_MAX *= 2);\n\tfor(i = 1; i <= Q; i++) {\n\t\tint t1 = ux[i][0], t2 = ux[i][1], t3 = ux[i][2], t4 = ux[i][3];\n\t\tif (t2 > t3) swap(t2, t3);\n\t\tif (t1 == 1) {\n\t\t\tMp[pii(t2, t3)] = qc + 1;\n\t\t\tMv[pii(t2, t3)] = t4;\n\t\t}\n\t\telse if (t1 == 2) {\n\t\t\tint st = Mp[pii(t2, t3)], en = qc;\n\t\t\tinitupdate(st, en, 1, IT_MAX, 1, mp(Mv[pii(t2, t3)], pii(t2, t3)));\n\t\t\tMp.erase(pii(t2, t3));\n\t\t\tMv.erase(pii(t2, t3));\n\t\t}\n\t\telse if (t1 == 3) {\n\t\t\tqc++;\n\t\t\tQu[qc][0] = t2, Qu[qc][1] = t3;\n\t\t}\n\t}\n\tfor (auto it : Mp) initupdate(it.second, qc, 1, IT_MAX, 1, mp(Mv[it.first], it.first));\n\n\tfor (i = 1; i <= N; i++) r[i][0] = i, r[i][1] = 0, sz[i] = 1;\n\tgetans(1, qc, 1, IT_MAX, 1);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dsu",
        "graphs"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Shortest Path Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/57840",
    "editorial": "This is a more complex version of problem G from Educational Round 27. You can find its editorial here.\n\nTo solve the problem we consider now, you have to use a technique known as dynamic connectivity. Let's build a segment tree over queries: each vertex of the segment tree will contain a list of all edges existing in the graph on the corresponding segment of queries. If some edge exists from query l to query r, then it's like an addition operation on segment [l,?r] in segment tree (but instead of addition, we insert this edge into the list of edges on a segment, and we make no pushes). Then if we write some data structure that will allow to add an edge and rollback operations we applied to the structure, then we will be able to solve the problem by DFS on segment tree: when we enter a vertex, we add all edges in the list of this vertex; when we are in a leaf, we calculate the required answer for the corresponding moment of time; and when we leave a vertex, we rollback all changes we made there.\n\nWhat data structure do we need? Firstly, we will have to use DSU maintaining the distance to the leader (to maintain the length of some path between two vertices). Don't use path compression, this won't work well since we have to do rollbacks.\n\nSecondly, we have to maintain the base of all cycles in the graph (since the graph is always connected, it doesn't matter that some cycles may be unreachable: by the time we get to leaves of the segment tree, these cycles will become reachable, so there's no need to store a separate base for each component). A convenient way to store the base is to make an array of 30 elements, initially filled with zeroes (we denote this array as a). i-th element of the array will denote some number in a base such that i-th bit is largest in the number. Adding some number x to this base is really easy: we iterate on bits from 29-th to 0-th, and if some bit j is equal to 1 in x, and a[j]???0, then we just set  (let's call this process reduction, we will need it later). If we get 0 after doing these operations, then the number we tried to add won't affect the base, and we don't need to do anything; otherwise, let k be the highmost bit equal to 1 in x, and then we set a[k]:??=?x.\n\nThis method of handling the base of cycles also allows us to answer queries of type 3 easily: firstly, we pick the length of some path from DSU (let it be p), and secondly, we just apply reduction to p, and this will be our answer.",
    "hint": []
}