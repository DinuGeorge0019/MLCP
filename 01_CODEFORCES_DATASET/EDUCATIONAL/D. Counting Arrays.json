{
    "link": "https://codeforces.com//contest/1749/problem/D",
    "problemId": "1596425",
    "problem_idx": "D",
    "shortId": "1749D",
    "contest_number": "1749",
    "problem_submissions": {
        "F": [
            177196926,
            177193969,
            177197845,
            177198119,
            177206430,
            177210873,
            177199785,
            177210774,
            177202230,
            177192913,
            177192213,
            177200070,
            177205944,
            177170394,
            177182862,
            177215270,
            177215844,
            177215523,
            177215051
        ],
        "E": [
            177175453,
            177181859,
            177173202,
            177167666,
            177181787,
            177187486,
            177182981,
            177191658,
            177182011,
            177191907,
            177180248,
            177184144,
            177194645,
            177180352,
            177179743,
            177190262,
            177179802,
            177185905,
            177189289,
            177181499
        ],
        "D": [
            177160734,
            177165684,
            177163670,
            177160708,
            177168035,
            177167597,
            177159805,
            177163272,
            177173571,
            177176783,
            177165402,
            177190745,
            177201885,
            177169012,
            177171922,
            177163620,
            177167442,
            177171641,
            177173186,
            177176099
        ],
        "C": [
            177153350,
            177154933,
            177150750,
            177151409,
            177156559,
            177158501,
            177150569,
            177150769,
            177164991,
            177159801,
            177155722,
            177194758,
            177205203,
            177156409,
            177150026,
            177153467,
            177161017,
            177156613,
            177158578,
            177157179
        ],
        "B": [
            177148010,
            177147226,
            177145824,
            177144459,
            177148401,
            177151190,
            177144790,
            177144751,
            177149472,
            177152803,
            177150420,
            177196545,
            177209340,
            177148820,
            177144521,
            177146740,
            177154433,
            177150579,
            177148916,
            177150562
        ],
        "A": [
            177143584,
            177143989,
            177143613,
            177143436,
            177144016,
            177147398,
            177143479,
            177143419,
            177143476,
            177149821,
            177206375,
            177197200,
            177210312,
            177145598,
            177143407,
            177143819,
            177150081,
            177145044,
            177144026,
            177143706
        ]
    },
    "name": "D. Counting Arrays",
    "statement": "Consider an array a of length n with elements numbered from 1 to n. It\r\nis possible to remove the i-th element of a if gcd(a_i, i) = 1, where\r\ngcd denotes the greatest common divisor. After an element is removed,\r\nthe elements to the right are shifted to the left by one position.An\r\narray b with n integers such that 1\r\nle b_i\r\nle n - i + 1 is a if it is possible to remove all elements of a, if you\r\nremove the b_1-th element, then the b_2-th, ..., then the b_n-th\r\nelement. For example, let a = [42, 314]: [1, 1] is a removal sequence:\r\nwhen you remove the 1-st element of the array, the condition gcd(42, 1)\r\n= 1 holds, and the array becomes [314]; when you remove the 1-st element\r\nagain, the condition gcd(314, 1) = 1 holds, and the array becomes empty.\r\n[2, 1] is not a removal sequence: when you try to remove the 2-nd\r\nelement, the condition gcd(314, 2) = 1 is false. An array is if it has\r\nremoval sequences. For example, the array [1, 2, 5] is ambiguous: it has\r\nremoval sequences [3, 1, 1] and [1, 2, 1]. The array [42, 314] is not\r\nambiguous: the only removal sequence it has is [1, 1].You are given two\r\nintegers n and m. You have to calculate the number of arrays a such that\r\nthe length of a is from 1 to n and each a_i is an integer from 1 to m.\r\n",
    "solutions": [
        "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv=\" \"){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv=\" \"){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<\" \";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<\"[\"<<z.first<<\"]=\"<<z.second<<\",\";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  friend ModInt operator+(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) += rhs;\n  }\n  friend ModInt operator-(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) -= rhs;\n  }\n  friend ModInt operator*(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) *= rhs;\n  }\n  friend ModInt operator/(const ModInt& lhs, const ModInt& rhs) {\n        return ModInt(lhs) /= rhs;\n  }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  \n  T RC(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return rfact(p) * fact(q) * fact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n  //+1\u304cn\u500b\u3001-1\u304cm\u500b\u3067 prefix sum\u304c\u5e38\u306bk\u4ee5\u4e0a\n  T catalan(ll n,ll m,ll k){\n    if(n>m-k)return 0;\n    else return C(n+m,m)-C(n+m,n+k-1);\n  }\n};\nusing modint = ModInt< MOD9 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\nvector< bool > prime_table(ll n) {\n  vector< bool > prime(n + 1, true);\n  if(n >= 0) prime[0] = false;\n  if(n >= 1) prime[1] = false;\n  for(ll i = 2; i * i <= n; i++) {\n    if(!prime[i]) continue;\n    for(ll j = i + i; j <= n; j += i) {\n      prime[j] = false;\n    }\n  }\n  return prime;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  modint dec=1;\n  ll g=1;\n  modint ret=0;\n  auto pt=prime_table(n+5);\n  rep(i,1,n+1){\n    if(pt[i])g*=i;\n    chmin(g,m+1);\n    dec*=m/g;\n    //cout<<i spa g spa dec<<endl;\n    ret+=pow(m,i)-dec;\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Counting Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/108269",
    "editorial": "We will calculate the answer by subtracting the number of arrays which\r\nhave only one removal sequence from the total number of arrays. The\r\nlatter is very simple it\u00e2\u0080\u0099s just .How do we calculate the number of\r\nunambiguous arrays? We can always delete the -st element of an array;\r\nso, is a removal sequence for each array. So, we have to calculate the\r\nnumber of arrays which have no other removal sequences.How do we check\r\nif the array has no removal sequences other than ? If, at any time, it\u00e2\u0080\u0099s\r\npossible to remove some element other than the -st from the array, it\r\ncreates another removal sequence since we can always complete that\r\nsequence.Let\u00e2\u0080\u0099s analyze the constraints on each element of the array. can\r\nbe any integer from to . should be divisible by (otherwise, we can\r\nremove it on the first step). should be divisible by (otherwise, we can\r\nremove it on the first step) and by (otherwise, we can remove it on the\r\nsecond step). should be divisible by and , but not necessarily by since\r\nan element which is divisible by already has a common divisor with . And\r\nso on using induction, we can show that the -th element should be\r\ndivisible by , where are all of the primes in . Obviously, the number of\r\nsuch elements is .So, we can easily calculate the number of possible\r\nelements for each index of the array, and that allows us to count all\r\nunambiguous arrays.\r\n"
}