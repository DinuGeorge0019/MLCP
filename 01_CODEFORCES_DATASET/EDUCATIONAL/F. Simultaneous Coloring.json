{
    "link": "https://codeforces.com//contest/1989/problem/F",
    "problemId": "2721699",
    "problem_idx": "F",
    "shortId": "1989F",
    "contest_number": "1989",
    "problem_submissions": {
        "F": [
            267852420,
            267715974,
            267712917,
            267719491,
            267734751,
            267735803,
            267741899,
            267747574,
            267768221,
            267767174,
            267766869,
            267748546,
            267750041,
            267754842,
            267760865,
            267768505,
            267763937,
            267766037,
            267765066,
            267764999,
            267764810
        ],
        "E": [
            267696430,
            267693533,
            267711891,
            267704153,
            267703845,
            267698823,
            267707139,
            267719026,
            267719849,
            267686019,
            267704171,
            267710707,
            267716623,
            267703403,
            267709172,
            267705649,
            267704995,
            267702509,
            267709118
        ],
        "D": [
            267685825,
            267682182,
            267696815,
            267692972,
            267693652,
            267703361,
            267692957,
            267722874,
            267708867,
            267680276,
            267687696,
            267691183,
            267686958,
            267692334,
            267690676,
            267692758,
            267695564,
            267692452,
            267700297
        ],
        "C": [
            267675529,
            267714300,
            267687642,
            267680264,
            267681105,
            267674205,
            267682216,
            267688126,
            267695068,
            267674713,
            267675536,
            267677226,
            267678584,
            267680860,
            267675171,
            267685177,
            267682170,
            267678912,
            267679841
        ],
        "B": [
            267671283,
            267671757,
            267674622,
            267674567,
            267676014,
            267669993,
            267681783,
            267674853,
            267678346,
            267669871,
            267670383,
            267672053,
            267670683,
            267671626,
            267671697,
            267673455,
            267674468,
            267674321,
            267671951
        ],
        "A": [
            267669443,
            267669849,
            267669717,
            267672060,
            267669107,
            267669168,
            267670166,
            267670012,
            267669413,
            267669118,
            267669169,
            267669489,
            267669101,
            267669245,
            267670092,
            267671181,
            267671315,
            267669875,
            267669241
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130937",
    "editorial": "\nThe main idea is as follows. Consider any constraint on a cell. If the cell must be red, then the last action on this cell must be coloring the row; otherwise, it should be the column. That is, if the operation is applied to both the row and the column of this cell, then there is a certain order of performing these operations. It is also worth noting that it does not make sense to apply the same operation twice, because the second application of the operation will recolor all the cells.\n\nThe word \"order\" should immediately bring to mind thoughts of directed graphs and topological sorting. Let's try to build a graph of operation execution. Create a graph with n+m\n vertices \u0097 one vertex for each row and column. If the cell must be red, then draw a directed edge from its column to its row. Otherwise, draw an edge from its row to its column.\n\nNow we would like to perform operations simply in the order of topological sorting. If this is possible (i.e., there are no cycles in the graph), then the answer is just 0\n. This means that operations can always be applied one by one. It is also worth noting that we apply the operations that do not color any cells with constraints. Their cost is always 0\n, so they do not change the answer.\n\nOtherwise, there are some strongly connected components in the graph with size greater than 1\n. In these components, we will always have to perform some operations at the same time. Of course, operations can be applied to the entire component at once. The cost will then be equal to the square of the component's size. Doesn't sound optimal but that's one way to satisfy the constraints.\n\nLet's show that it is not possible to do it cheaper. Consider the last set of actions on this component. If they do not affect the entire component, then within the affected subset, there will be a vertex with an outgoing edge outside the subset, but inside the component (otherwise it would be two different components). This means that there must be at least one more operation performed on the vertex to which this edge leads. Therefore, the set of actions considered will not be the last one.\n\nThen the solution is as follows. After adding each constraint, add the previously described edges and find the condensation of the graph. The answer will be the sum of the squares of the sizes of strongly connected components with size greater than 1\n. This solution works in O(q?(n+m+q))\n.\n\nTo optimize this solution, you can use the technique of incremental condensation. You can read about it in the blog by Radewoosh. Since DSU is used in it, you can maintain the sum of the squares of the component sizes on the fly.\n\nThe blog describes a solution with a logarithmic time complexity, but the problem did not require an implementation faster than log2\n. Solutions with a logarithmic memory complexity with a large constant might not pass (the author's solution consumes O(qlogq)\n memory and fits into 50\n megabytes).",
    "name": "F. Simultaneous Coloring",
    "statement": "You are given a matrix, consisting of n rows and m columns.You can\r\nperform two types of actions on it: paint the entire column in blue;\r\npaint the entire row in red. In one second, you can perform either one\r\naction or multiple actions at the same time. If you perform one action,\r\nit will be free. If you perform k > 1 actions at the same time, it will\r\ncost k^2 coins. When multiple actions are performed at the same time,\r\nfor each cell affected by actions of both types, the color can be chosen\r\nindependently.You are asked to process q queries. Before each query, all\r\ncells become colorless. Initially, there are no restrictions on the\r\ncolor of any cells. In the i-th query, a restriction of the following\r\nform is added: x_i\u00a0y_i\u00a0c_i the cell in row x_i in column y_i should be\r\npainted in color c_i. Thus, after i queries, there are i restrictions on\r\nthe required colors of the matrix cells. After each query, output the\r\nminimum cost of painting the matrix according to the restrictions.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;\u00a0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\u00a0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\u00a0using pii=pair<int,int>;using pll=pair<ll,ll>;\u00a0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\u00a0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\u00a0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\u00a0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\u00a0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\u00a0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\u00a0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\u00a0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\u00a0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;}\u00a0#ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif\u00a0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\u00a0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\u00a0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\u00a0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\u00a0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\u00a0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\u00a0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\u00a0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\u00a0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\u00a0//#include<atcoder/all>//using namespace atcoder;\u00a0//using mint=modint998244353;//using mint=modint1000000007;\u00a0ll get_val(ll x){    if(x<=1) return 0;    return x*x;}\u00a0const int maxn=400005;int par[maxn],siz[maxn];ll tot;int Find(int x){return par[x]==x?x:par[x]=Find(par[x]);}void Union(int x, int y){    x=Find(x),y=Find(y);    if(x==y) return;    if(siz[x]<siz[y]) swap(x,y);    tot-=get_val(siz[x])+get_val(siz[y]);    siz[x]+=siz[y],par[y]=x;    tot+=get_val(siz[x]);}\u00a0int n,m,q,scc[maxn];ll res[maxn];vector<int> V,adj[maxn],radj[maxn],ord;bool vis[maxn];\u00a0void rdfs(int u){    vis[u]=1;    for(auto v: radj[u]) if(!vis[v]) rdfs(v);    ord.pb(u);}\u00a0vector<int> de;\u00a0void dfs(int u, int rt){    vis[u]=1,de.pb(u),scc[u]=rt;    for(auto v: adj[u]) if(!vis[v]) dfs(v,rt);}\u00a0void solve(int l, int r, vector<array<int,3>> edges){    int mid=l+r>>1;    V.clear();    vector<array<int,3>> L,R;    for(auto& [u,v,i]: edges){        u=Find(u),v=Find(v);        V.pb(u),V.pb(v);    }    sort(all(V)),V.resize(unique(all(V))-V.begin());    for(auto u: V) vis[u]=0,adj[u].clear(),radj[u].clear();    for(auto& [u,v,i]: edges) if(i<=mid) adj[u].pb(v),radj[v].pb(u);    ord.clear();    for(auto u: V) if(!vis[u]) rdfs(u);    for(auto u: V) vis[u]=0;    reverse(all(ord));    vector<pii> tmp;    for(auto u: ord) if(!vis[u]){        de.clear();        dfs(u,u);        if(l==r) for(int i=0; i+1<de.size(); ++i) tmp.pb({de[i],de[i+1]});    }    if(l==r){        for(auto [u,v]: tmp) Union(u,v);        res[l]=tot;        return;    }    for(auto& [u,v,i]: edges){        if(scc[u]==scc[v]){            if(i<=mid) L.pb({u,v,i});        }        else R.pb({u,v,i});    }    solve(l,mid,L),solve(mid+1,r,R);}\u00a0void ahcorz(){    cin >> n >> m >> q;    for(int i=0; i<n+m; ++i) par[i]=i,siz[i]=1;    vector<array<int,3>> edges(q);    for(int i=0; i<q; ++i){        //int u,v; cin >> u >> v; u--,v--;        int x,y; char c; cin >> x >> y >> c; x--,y--;        if(c=='R'){            edges[i]={x,n+y,i};        }        else{            edges[i]={n+y,x,i};        }        //edges[i]={u,v,i};    }    solve(0,q-1,edges);    for(int i=0; i<q; ++i) cout << res[i] << \"\\n\";}\u00a0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "divide and conquer",
        "graphs"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Simultaneous Coloring.json"
}