{
    "link": "https://codeforces.com//contest/1469/problem/F",
    "problemId": "847531",
    "problem_idx": "F",
    "shortId": "1469F",
    "contest_number": "1469",
    "problem_submissions": {
        "F": [
            102583473,
            102644474,
            102589987,
            102594210,
            102598891,
            102606787,
            102602998,
            102604144,
            102603740,
            102665234,
            102604943,
            102600529,
            102596981,
            102695061,
            102694126,
            102693059,
            102692990,
            102691774,
            102691554,
            102634847,
            102593976,
            102601060,
            102611713,
            102611193,
            102613178,
            102615015,
            102610571,
            133243413,
            102609965,
            102615327
        ],
        "E": [
            102573843,
            102644473,
            102578949,
            102577732,
            102585110,
            102591945,
            102586477,
            102582817,
            102595462,
            102579611,
            102664687,
            102648095,
            102648064,
            102594234,
            102584569,
            102634471,
            102624399,
            102623518,
            102608733,
            155214938,
            102768106,
            102593726,
            102593694,
            102597495,
            102592373,
            102595193,
            102588652,
            102589423,
            102593264
        ],
        "D": [
            102562850,
            102644472,
            102568881,
            102566821,
            102569601,
            102570954,
            102563048,
            102571352,
            102588415,
            102664675,
            102570617,
            102572568,
            102569075,
            102580450,
            102569951,
            102575804,
            102575811,
            102574711,
            102577038,
            102579322,
            102570202
        ],
        "C": [
            102552805,
            102644471,
            102555513,
            102554730,
            102555597,
            102558406,
            102554980,
            102553952,
            102556321,
            102664664,
            102560782,
            102559861,
            102555651,
            102570770,
            102554929,
            102563292,
            102558262,
            102561567,
            102566610,
            102569771,
            102557739
        ],
        "B": [
            102548072,
            102644469,
            102548784,
            102547413,
            102549611,
            102549952,
            102549039,
            102547745,
            102550684,
            102664647,
            102553929,
            102550781,
            102634199,
            102551181,
            102557688,
            102550308,
            102552089,
            102551269,
            102550296,
            102555698,
            102550742,
            102551593
        ],
        "A": [
            102546848,
            102644467,
            102547134,
            102546803,
            102547541,
            102546863,
            102546919,
            102546821,
            102547947,
            102664636,
            102549491,
            102548928,
            102547577,
            102555388,
            102547472,
            102548992,
            102546835,
            102546964,
            102551041,
            102547957,
            102549438
        ]
    },
    "name": "F. Power Sockets",
    "statement": "// Define a chain: a chain of length 1 is a single vertex; a chain of\r\nlength x is a chain of length x-1 with a new vertex connected to the end\r\nof it with a single edge. You are given n chains of lengths l_1, l_2,\r\ndots, l_n. You plan to build a tree using some of them. Each vertex of\r\nthe tree is either white or black. The tree initially only has a white\r\nroot vertex. All chains initially consist only of white vertices. You\r\ncan take one of the chains and connect any of its vertices to any white\r\nvertex of the tree with an edge. The chain becomes part of the tree.\r\nBoth endpoints of this edge become black. Each chain can be used no more\r\nthan once. Some chains can be left unused. The distance between two\r\nvertices of the tree is the number of edges on the shortest path between\r\nthem.If there is at least k white vertices in the resulting tree, then\r\nthe value of the tree is the distance between the root and the k-th\r\nclosest white vertex.What’s the minimum value of the tree you can\r\nobtain? If there is no way to build a tree with at least k white\r\nvertices, then print .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nconstexpr int inf = 1e9, N = 5e5;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n, k;\n    std::cin >> n >> k;\n    std::vector<int> l(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> l[i];\n    }\n    std::sort(l.begin(), l.end(), std::greater<>());\n    int a[N]{};\n    a[0] = 1;\n    a[1] = -1;\n    int ans = inf;\n    int total = 0;\n    for (int i = 0, j = 0; i < N - 1; ++i) {\n        total += a[i];\n        a[i + 1] += a[i];\n        if (total + a[i + 1] >= k) {\n            ans = std::min(ans, i + 1);\n        }\n        while (a[i] > 0 && j < n) {\n            int u = (l[j] - 1) / 2;\n            int v = l[j] - 1 - u;\n            a[i + 2]++;\n            a[i + 2 + u]--;\n            a[i + 2]++;\n            a[i + 2 + v]--;\n            a[i]--;\n            total--;\n            j++;\n        }\n    }\n    if (ans == inf) {\n        ans = -1;\n    }\n    std::cout << ans << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Power Sockets.json",
    "editorial_link": "https://codeforces.com//blog/entry/86082",
    "editorial": "At first, letâs realize that the tree structure doesnât matter that\r\nmuch. What we actually need is the array such that it stores the number\r\nof white vertices on depth .Initially, and all other are zero. If you\r\ntake a chain and attach it to some vertex on depth , then the number of\r\nvertices on depth decreases by . Also, the added vertices update some\r\nother counts.So far, itâs extremely unclear what to begin with. Letâs\r\nstart by introducing some greedy ideas.For each letâs find the most\r\noptimal tree using exactly chains and update the answer with each of\r\nthem.First, itâs always optimal to attach a chain with its middle\r\nvertex. Just consider the changes in the white vertices counts.Second,\r\nfor each itâs always optimal to take the longest chains to use. If not\r\nthe longest are used, then you can replace any of them and there will be\r\nmore white vertices.It would be nice if we were able to just add another\r\nchain to the tree for to get the tree for . However, thatâs not always\r\nthe case. But we can still attempt it and show that the optimal answer\r\nwas achieved somewhere in the process.Letâs show that itâs always\r\noptimal to attach a new chain to the closest white vertex.So there are\r\nbasically two cases: there is not enough white vertices yet and there is\r\nenough. What happens if there is not enough vertices, and we pick the\r\nclosest one to attach a chain to? If there are still not enough\r\nvertices, then weâll just continue. Otherwise, weâll have to show that\r\nthe answer canât get any smaller by rearranging something.Consider what\r\nthe answer actually is. Build a prefix sum array over , then the answer\r\nis the shortest prefix such that its prefix sum is greater or equal to\r\n.So we put the -th chain to the closest white vertex at depth . It\r\ndecreases by and increases and further by or . Every chain we have put\r\nto this point was attached to a vertex at depth less or equal to the\r\nanswer (otherwise, we couldâve rearranged it and obtain the answer\r\nbefore). The optimal answer can be neither , nor (also because we\r\ncouldâve rearranged). Thus, the answer is at least and every single\r\nchain we have put was packed as tightly as possible below that depth.The\r\nsecond case works similarly. We couldâve obtained the optimal answer\r\nbefore . So the answer is below and we can do nothing about that. Or the\r\noptimal answer is ahead of us, so putting the chain at can decrease it\r\nas much or stronger as any other choice.Thus, updating the answer on\r\nevery iteration will give us the optimal result.Now we are done with the\r\ngreedy, time to implement it. I chose the most straightforward way. We\r\nbasically have to maintain a data structure that can add on range, get\r\nthe value of a cell and find the shortest prefix with sum at least .\r\nThat can be easily done with segtree.Overall complexity: .\r\n",
    "hint": []
}