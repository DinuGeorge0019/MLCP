{
    "link": "https://codeforces.com//contest/915/problem/E",
    "problemId": "146472",
    "problem_idx": "E",
    "shortId": "915E",
    "contest_number": "915",
    "problem_submissions": {
        "G": [
            34149372,
            34145802,
            34144917,
            34149940,
            34145497,
            34145091,
            34146841,
            34133578,
            34140368,
            34156614,
            34136642,
            34149433,
            34141049,
            34151857,
            34143141,
            34142291,
            34153795,
            34152031,
            34149642
        ],
        "F": [
            34141740,
            34141911,
            34142659,
            34144461,
            34139648,
            34150037,
            34135451,
            34135325,
            34136765,
            34139507,
            34185912,
            34185895,
            34185884,
            34144212,
            34147801,
            34138374,
            34149691,
            34145676,
            34149957
        ],
        "E": [
            34139509,
            34136671,
            34139993,
            34142857,
            34141594,
            34143243,
            34138759,
            34150868,
            34131224,
            34145365,
            34144825,
            34146415,
            34139658,
            34148670,
            34147938,
            34144847,
            34142409,
            34147934,
            34152612
        ],
        "D": [
            34136912,
            34138946,
            34136834,
            34138837,
            34134917,
            34139148,
            34142081,
            34147574,
            34141584,
            34140548,
            34136477,
            34136703,
            34136486,
            34145522,
            34138909,
            34138016,
            34141644,
            34141385,
            34135263
        ],
        "C": [
            34133179,
            34132160,
            34132616,
            34134296,
            34131528,
            34132656,
            34145969,
            34144943,
            34139362,
            34131971,
            34135532,
            34132111,
            34166504,
            34134375,
            34134967,
            34134748,
            34132949,
            34134607,
            34133338
        ],
        "B": [
            34129725,
            34129567,
            34129784,
            34132321,
            34130243,
            34147501,
            34142325,
            34138326,
            34132523,
            34157084,
            34130697,
            34130455,
            34131022,
            34130794,
            34158518,
            34130482
        ],
        "A": [
            34127694,
            34127702,
            34127886,
            34130517,
            34127730,
            34147894,
            34141073,
            34137409,
            34128096,
            34127668,
            34127948,
            34127873,
            34127723,
            34128273,
            34128083,
            34127880
        ]
    },
    "name": "E. Physical Education Lessons",
    "statement": "This year Alex has finished school, and now he is a first-year student\r\nof Berland State University. For him it was a total surprise that even\r\nthough he studies programming, he still has to attend physical education\r\nlessons. The end of the term is very soon, but, unfortunately, Alex\r\nstill hasn’t attended a single lesson!Since Alex doesn’t want to get\r\nexpelled, he wants to know the number of working days left until the end\r\nof the term, so he can attend physical education lessons during these\r\ndays. But in BSU calculating the number of working days is a complicated\r\nmatter:There are days left before the end of the term (numbered from to\r\n), and initially all of them are working days. Then the university staff\r\nsequentially publishes orders, one after another. Each order is\r\ncharacterised by three numbers , and : If , then all days from to\r\n(inclusive) become non-working days. If some of these days are made\r\nworking days by some previous order, then these days still become\r\nnon-working days; If , then all days from to (inclusive) become working\r\ndays. If some of these days are made non-working days by some previous\r\norder, then these days still become working days. Help Alex to determine\r\nthe number of working days left after each order!\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\n\nmap<int, int>working;\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint n, q; cin >> n >> q;\n\tworking[-1] = -1;\n\tworking[2E9] = 2E9;\n\tworking[1] = n;\n\tint answer = n;\n\twhile (q--) {\n\t\tint l, r, k; cin >> l >> r >> k;\n\t\tint haveNow = 0;\n\t\tmap<int, int>::iterator it = working.lower_bound(l);\n\t\tit--;\n\t\tif (it->second >= l) {\n\t\t\tworking[l] = it->second;\n\t\t\tit->second = l-1;\n\t\t}\n\t\tit++;\n\t\twhile (it->first <= r) {\n\t\t\tif (it->second > r) {\n\t\t\t\thaveNow += r + 1 - it->first;\n\t\t\t\tworking[r + 1] = it->second;\n\n\t\t\t}\n\t\t\telse\n\t\t\t\thaveNow += it->second - it->first + 1;\n\t\t\tmap<int, int>::iterator it2 = it;\n\t\t\tit++;\n\t\t\tworking.erase(it2);\n\t\t}\n\t\tif (k == 1) {\n\t\t\tanswer -= haveNow;\n\t\t}\n\t\telse {\n\t\t\tanswer -= haveNow;\n\t\t\tworking[l] = r;\n\t\t\tanswer += r - l + 1;\n\t\t}\n\t\tcout << answer << \"\\n\";\n\t}\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Physical Education Lessons.json",
    "editorial_link": "https://codeforces.com//blog/entry/57123",
    "editorial": "Letâs store current intervals with non-working days in set sorted by the\r\nright border. When new query comes you search for the first interval to\r\nhave its right border greater or equal than the currect left border and\r\nupdate all intervals to intersect the query (either fully delete or\r\ninsert back its part which doesnât intersect query). Finally, if then\r\ninsert the query into current set. Updates on the number of working days\r\ncan be done while deleting segments on the fly.Overall complexity: .\r\n",
    "hint": []
}