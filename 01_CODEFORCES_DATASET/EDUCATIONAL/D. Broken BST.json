{
    "link": "https://codeforces.com//contest/797/problem/D",
    "problemId": "103031",
    "problem_idx": "D",
    "shortId": "797D",
    "contest_number": "797",
    "problem_submissions": {
        "F": [
            26392422,
            26393656,
            26389980,
            26393053,
            26392770,
            26393200,
            26401058,
            26400600,
            26393845,
            26538858,
            26399564,
            26404933
        ],
        "E": [
            26384593,
            26386641,
            26387413,
            26384179,
            26390646,
            26385085,
            26384145,
            26385218,
            26385422,
            26383237,
            26385301,
            26385048,
            26387123,
            26383986,
            26385186,
            26383971,
            26385690,
            26386757,
            26387505
        ],
        "D": [
            26383853,
            26385506,
            26386518,
            26386869,
            26388006,
            26386076,
            26386759,
            26387198,
            26384655,
            26384909,
            26400699,
            26386910,
            26386839,
            26385859,
            26386865,
            26387340,
            26385970,
            26387551,
            26388539,
            26386426
        ],
        "C": [
            26382881,
            26383936,
            26385046,
            26385741,
            26385840,
            26383373,
            26384974,
            26383476,
            26383055,
            26382583,
            26383371,
            26383953,
            26383269,
            26383187,
            26384315,
            26382972,
            26384647,
            26385000,
            26382428
        ],
        "B": [
            26382061,
            26382225,
            26383108,
            26384548,
            26383123,
            26382179,
            26382430,
            26382528,
            26381992,
            26382016,
            26382484,
            26382716,
            26382235,
            26382138,
            26382837,
            26382347,
            26382410,
            26382477,
            26381988
        ],
        "A": [
            26381703,
            26381847,
            26382576,
            26383357,
            26382358,
            26381775,
            26381835,
            26381732,
            26381711,
            26381736,
            26381944,
            26381723,
            26381696,
            26381784,
            26381802,
            26381687,
            26381777,
            26381801,
            26381706
        ]
    },
    "name": "D. Broken BST",
    "statement": "Let be arbitrary binary tree tree, every vertex of which has no more\r\nthan two children. Given tree is rooted, so there exists only one vertex\r\nwhich doesn\u2019t have a parent it\u2019s the root of a tree. Every vertex has an\r\ninteger number written on it. Following algorithm is run on every value\r\nfrom the tree : Set pointer to the root of a tree. Return success if the\r\nvalue in the current vertex is equal to the number you are looking for\r\nGo to the left child of the vertex if the value in the current vertex is\r\ngreater than the number you are looking for Go to the right child of the\r\nvertex if the value in the current vertex is less than the number you\r\nare looking for Return fail if you try to go to the vertex that doesn\u2019t\r\nexist Here is the pseudo-code of the described algorithm: bool\r\nfind(TreeNode t, int x) { if (t == null) return false; if (t.value == x)\r\nreturn true; if (x < t.value) return find(t.left, x); else return\r\nfind(t.right, x);}find(root, x);The described algorithm works correctly\r\nif the tree is binary search tree (i.e. for each node the values of left\r\nsubtree are less than the value in the node, the values of right subtree\r\nare greater than the value in the node). But it can return invalid\r\nresult if tree is not a binary search tree.Since the given tree is not\r\nnecessarily a binary search tree, not all numbers can be found this way.\r\nYour task is to calculate, how many times the search will fail being\r\nrunning on every value from the tree.If the tree has multiple vertices\r\nwith the same values on them then you should run algorithm on every one\r\nof them separately.\r\n",
    "solutions": [
        "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\n\nconst int N = (int) 1e6 + 6, mod = (int) 0;\nint n, mark[N], val[N], cl[N], cr[N], root, sr[N];\nint solve(int v, int b, int e) {\n\tif (e - b <= 0) return 0;\n\tif (v == -1) return e - b;\n\tint ml = lower_bound(sr + b, sr + e, val[v]) - sr;\n\tint mr = upper_bound(sr + b, sr + e, val[v]) - sr;\n\treturn solve(cl[v], b, ml) + solve(cr[v], mr, e);\n}\nint main() {\n\tcin >> n;\n\tfor (int j = 0; j < n; ++j) {\n\t\tcin >> val[j] >> cl[j] >> cr[j];\n\t\tif (cl[j] >= 0) cl[j]--, mark[cl[j]] = 1;\n\t\tif (cr[j] >= 0) cr[j]--, mark[cr[j]] = 1;\n\t\tsr[j] = val[j];\n\t}\n\tsort(sr, sr + n);\n\tfor (int j = 0; j < n; ++j)\n\t\tif (!mark[j])\n\t\t\troot = j;\n\tcout << solve(root, 0, n) << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Broken BST.json",
    "editorial_link": "https://codeforces.com//blog/entry/51588",
    "editorial": "Let\u00e2\u0080\u0099s firstly consider tree with only distinct values in its nodes. Then\r\nvalue will be reached if and only if all the jumps to the left children\r\non the path from the root were done from the vertices with values\r\ngreater than the current one and all the jumps to the right children on\r\nthe path from the root were done from the vertices with values less than\r\nthe current one. Thus let\u00e2\u0080\u0099s run dfs from the root and maintain maximal\r\ntransition to the left child on current path and minimal transition to\r\nthe right child on current path. If the value of current node is greater\r\nthan left bound and less than right bound then it will be found.Now\r\nlet\u00e2\u0080\u0099s return to the original problem. Notice that transitions and\r\ncomparations won\u00e2\u0080\u0099t change. Store every found value in set and just\r\ncalculate how many values of vertices isn\u00e2\u0080\u0099t present there.Overall\r\ncomplexity: .\r\n"
}