{
    "link": "https://codeforces.com//contest/893/problem/D",
    "problemId": "135514",
    "problem_idx": "D",
    "shortId": "893D",
    "contest_number": "893",
    "problem_submissions": {
        "D": [
            32587846,
            32584166,
            32584580,
            32587450,
            32584069,
            32583060,
            32588853,
            32589858,
            32585182,
            32590659,
            32586485,
            32589315,
            32591783,
            32597332,
            32598552,
            32591926,
            32591314,
            32591378,
            32595633,
            32593677
        ],
        "F": [
            32587029,
            32588564,
            32633440,
            32633411,
            32600577,
            32591730,
            32591080,
            32593455,
            32595872,
            32596856,
            32595308,
            32598298,
            32597321,
            32596161,
            32595895,
            32587274,
            32617128,
            32590562,
            32596152,
            32592069,
            32595471,
            32597133,
            32631856,
            32597548,
            32597501,
            32596510,
            32594100,
            32588288
        ],
        "E": [
            32582663,
            32585881,
            32587039,
            32583891,
            32589038,
            32590654,
            32590403,
            32589458,
            32590147,
            32585649,
            32586443,
            32598380,
            32591576,
            32589935,
            32595163,
            32587306,
            32598292,
            32632299,
            32631834,
            32597903,
            32592050,
            32595887
        ],
        "C": [
            32580222,
            32581731,
            32579674,
            32581061,
            32582009,
            32580473,
            32581974,
            32581755,
            32582911,
            32582779,
            32581570,
            32581398,
            32580526,
            32582157,
            32582935,
            32581251,
            32583782,
            32581776,
            32581603,
            32588827
        ],
        "B": [
            32579038,
            32579297,
            32579032,
            32580119,
            32580362,
            32579253,
            32579828,
            32580254,
            32581551,
            32581638,
            32580169,
            32580423,
            32579209,
            32580529,
            32581182,
            32578812,
            32582642,
            32580448,
            32580061,
            32587514
        ],
        "A": [
            32578761,
            32578814,
            32578771,
            32578835,
            32579027,
            32578799,
            32578920,
            32578996,
            32579962,
            32580679,
            32579419,
            32579406,
            32579609,
            32579237,
            32580280,
            32579180,
            32578788,
            32579540,
            32578923,
            32586994
        ]
    },
    "name": "D. Credit Card",
    "statement": "Recenlty Luba got a credit card and started to use it. Let\u2019s consider\r\nconsecutive days Luba uses the card.In the of -th day a transaction\r\noccurs. If , then bourles are deposited to Luba\u2019s account. If , then\r\nbourles are withdrawn. And if , then the amount of money on Luba\u2019s\r\naccount is checked.In the of any of days Luba can go to the bank and\r\ndeposit any integer amount of burles to her account. But there is a\r\nlimitation: the amount of money on the account can never exceed .Luba\r\nmust not exceed this limit, and also she wants that (the days when ) the\r\namount of money on her account is non-negative. It takes a lot of time\r\nto go to the bank, so Luba wants to know the minimum number of days she\r\nneeds to deposit some money to her account (if it is possible to meet\r\nall the requirements). Help her!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt(), d = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tint ans = 0;\n\tint cur = 0;\n\tint balance = 0;\n\tvector<int> lows(n), rigs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tbalance += a[i];\n\t\tif (a[i] == 0) {\n\t\t\tlows[i] = -balance;\n\t\t}\n\t\trigs[i] = d - balance;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tlows[i] = max(lows[i], lows[i - 1]);\n\t}\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\trigs[i] = min(rigs[i], rigs[i + 1]);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (lows[i] > rigs[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (cur < lows[i]) {\n\t\t\tcur = rigs[i];\n\t\t\t++ans;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Credit Card.json",
    "editorial_link": "https://codeforces.com//blog/entry/55989",
    "editorial": "The following greedy solution works. Firstly, deposite money only on\r\ndays with . Secondly, every time the balance is negative to the day with\r\n, refill it to maximal possible value such that it won\u00e2\u0080\u0099t go over later.\r\nDays with can only lead to invalid state by going over card limit. We\r\ncan only add money to the balance. Adding zero money in those days won\u00e2\u0080\u0099t\r\nmake invalid states if all were valid previously. Finally, if it\u00e2\u0080\u0099s\r\npossible to get valid state in every day then it\u00e2\u0080\u0099s possible to get it by\r\nrefilling the same day the check happens. For example, you can make\r\nbalance in those days. Then you will never have negative balance there.\r\nThough it\u00e2\u0080\u0099s not the most optimal way. Let be some value you deposite in\r\nsome day with to pass all conditions till the next day with . I state\r\nthat function of number of game\u00e2\u0080\u0099s moves dependancy on is monotonious.\r\nLet\u00e2\u0080\u0099s check it for some fixed . Define minimum balance you will get on\r\nany suffix from now as . Obviously, taking will make it . If it goes\r\nnegative then you will need an extra move to finish the game. Thus\r\ntaking maximal will lead to the lowest score possible. And last but not\r\nleast realization part. What will be the maximum possible value to\r\ndeposite? Actually, it\u00e2\u0080\u0099s such a value that optimal game after this will\r\nlead to maximum balance of in some day. Thus, you want to check what\r\nwill be the maximum balance if you add zero money and take as .\r\nObviously, if it\u00e2\u0080\u0099s negative then output . Naively this still works on\r\nper day and lead to overall. Notice that by depositing you increase\r\nmaximums on each suffix for now by . So, you can calculate it as you\r\nwill do nothing and add sum of your \u00e2\u0080\u0099s to get actual value. You store\r\nprefix sum of up to in . Then take maximum on suffix for every ( is the\r\nmaxumum for from to ). .I hope I made it clear enough. :DOverall\r\ncomlpexity: .\r\n"
}