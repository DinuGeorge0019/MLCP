{
    "link": "https://codeforces.com//contest/1861/problem/C",
    "problemId": "2187863",
    "problem_idx": "C",
    "shortId": "1861C",
    "contest_number": "1861",
    "problem_submissions": {
        "F": [
            221319232,
            221334797,
            221343700,
            221334746,
            221435327
        ],
        "E": [
            221294949,
            221294627,
            221307083,
            221304545,
            221289987,
            221293214,
            221302482,
            221312615,
            221307967,
            221303480,
            221309861,
            221307296,
            221307859,
            221320123,
            221304501,
            221805824,
            221308535,
            221309691,
            221307994,
            221314449,
            221316461
        ],
        "D": [
            221289547,
            221296942,
            221291864,
            221307784,
            221293468,
            221297421,
            221296816,
            221288510,
            221291806,
            221295562,
            221296430,
            221296186,
            221290647,
            221296713,
            221298445,
            221297975,
            221298865,
            221297626,
            221298343
        ],
        "C": [
            221285558,
            221285843,
            221287563,
            221293257,
            221282816,
            221283475,
            221287126,
            221284366,
            221286970,
            221291172,
            221290155,
            221290726,
            221290133,
            221287629,
            221289108,
            221291690,
            221291845,
            221290307,
            221291196,
            221291877
        ],
        "B": [
            221280891,
            221279490,
            221280612,
            221282637,
            221278148,
            221277443,
            221280003,
            221278598,
            221281862,
            221281453,
            221282384,
            221284462,
            221279905,
            221283500,
            221283423,
            221284241,
            221280164,
            221284009,
            221283159
        ],
        "A": [
            221277133,
            221276828,
            221277503,
            221276971,
            221276729,
            221276717,
            221276917,
            221276888,
            221277198,
            221278164,
            221278677,
            221280809,
            221276797,
            221278399,
            221277159,
            221277434,
            221276991,
            221278067,
            221276850
        ]
    },
    "name": "C. Queries for the Array",
    "statement": "Monocarp had an array a consisting of integers. Initially, .Monocarp\r\nperformed three types of queries to this array: choose an integer and\r\nappend it . Each time Monocarp performed a query of this type, he wrote\r\nout a character ; remove from the array. Each time Monocarp performed a\r\nquery of this type, he wrote out a character . Monocarp never performed\r\nthis query on an empty array; check if the array is sorted in\r\nnon-descending order, i.,e. a_1\r\nle a_2\r\nle\r\ndots\r\nle a_k, where k is the number of elements in the array currently. . If\r\nthe array was sorted by the time Monocarp was performing that query, he\r\nwrote out a character . Otherwise, he wrote out a character . You are\r\ngiven a sequence s of q characters , , and/or . These are the characters\r\nthat were written out by Monocarp, given in the exact order he wrote\r\nthem out.You have to check if this sequence is consistent, i. e. it was\r\npossible for Monocarp to perform the queries so that the sequence of\r\ncharacters he wrote out is exactly s.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n}\n\nint n;\nint g;\nchar wcz[nax];\n\nint ok;\n\nint dfs(int v)//czy dluzsza byla posortowana\n{\n\tint ret=(v<=1);\n\tint nope=0;\n\twhile(1)\n\t{\n\t\tif (g>n)\n\t\t{\n\t\t\tif (ret && nope)\n\t\t\t\tok=0;\n\t\t\treturn ret;\n\t\t}\n\t\tchar c=wcz[g];\n\t\tg++;\n\t\tif (c=='+')\n\t\t{\n\t\t\tint wez=dfs(v+1);\n\t\t\tif (wez)\n\t\t\t\tret|=wez;\n\t\t}\n\t\tif (c=='-')\n\t\t{\n\t\t\tif (ret && nope)\n\t\t\t\tok=0;\n\t\t\treturn ret;\n\t\t}\n\t\tif (c=='1')\n\t\t{\n\t\t\tret=1;\n\t\t}\n\t\tif (c=='0')\n\t\t{\n\t\t\tnope=1;\n\t\t}\n\t}\n}\n\nvoid test()\n{\n\tscanf(\"%s\", wcz+1);\n\tn=strlen(wcz+1);\n\tok=1;\n\tg=1;\n\tdfs(0);\n\tans(ok);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "implementation",
        "strings",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Queries for the Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/119964",
    "editorial": "First of all, letâs analyze which situations cause the answer to be .\r\nThere are two types: if the number of elements in the array is currently\r\nless than , the array is definitely sorted. So, if we get a and the\r\nnumber of elements is or , the answer is ; if the array is sorted, but\r\nsome prefix of it (maybe coinciding with the whole array) is not sorted,\r\nthis is also a . These are the only two situations that cause a . We can\r\nprove that if none of this occurs, the answer is , using the following\r\nconstruction: every time there is a query, we will add to the array;\r\nevery time there is a query, and the current array is sorted, we will\r\nchange the last element of the array to (and assume we added instead of\r\nin the query it was added). That way, we can ensure that the array stays\r\nsorted as long as possible. The only cases when this construction\r\ndoesnât work are: we try to change an element to , but there is no such\r\nelement (the array is empty), or the array stays sorted after the change\r\n(we change the first element). This is exactly when a query appears and\r\nthe current number of elements is less than ; we change an element to ,\r\nand it makes the current array non-sorted, but it has to be sorted due\r\nto a query of type affecting it. This is exactly when we have a sorted\r\narray with a non-sorted prefix. Okay, now we have to check these two\r\nconditions somehow. The first one is quite easy: just keep track of the\r\nnumber of elements in the array; every time you process , increase it;\r\nevery time you process , decrease it; every time you process , check the\r\nnumber of elements.The second condition is tricky. There are many\r\napproaches on how to handle it; I will describe two of them.We are\r\ninterested in a situation when a sorted array has an unsorted prefix.\r\nSuppose there is a state of our array when this happens. In case when\r\nthis array has multiple prefixes for which we know that they are sorted,\r\nwhich one should we choose? It should be the longest sorted prefix,\r\nbecause we want an unsorted prefix to be shorter (or have the same\r\nlength). And among all non-sorted prefixes, we are interested in the\r\nshortest one, for the same reason.So, letâs go over the queries and keep\r\ntrack of the shortest non-sorted prefix and the longest sorted prefix of\r\nour array. Letâs analyze how our queries affect these two values. when\r\nwe append a new element (query of type ), we no longer know that the\r\ncurrent array is sorted, but its longest sorted prefix stays the same,\r\nand its shortest non-sorted prefix also stays the same. So, we donât\r\nneed to update these values; when we delete the last element (query of\r\ntype ), the length of the sorted prefix might change. If it was equal to\r\nthe number of elements before the query, it should decrease by , because\r\nthe last element on that prefix was deleted, and the prefix no longer\r\nexists. As for the length of the shortest unsorted prefix, if it was\r\nequal to the number of elements in the array before the query, it should\r\nbe set to because maybe the last element of the array made the array\r\nunsorted, and we donât know anything about the prefixes before it. when\r\nwe process a query of type or , we should update the shortest non-sorted\r\nprefix or the longest sorted prefix accordingly. After each query, we\r\ncan just check that the longest sorted prefix is shorter than the\r\nshortest non-sorted prefix (or one of them doesnât exist)..Letâs\r\nvisualize all states of the array using a rooted tree. Every moment of\r\ntime after a query corresponds to some vertex in this tree, and one\r\nvertex is a parent of another vertex if the array in the state\r\nrepresented by is the same as the array represented by , but without the\r\nlast element. For example, if the string of queries is , the tree looks\r\nlike this (the labels on the vertices correspond to the number of\r\nqueries after which the array is in that state): This tree can be\r\nconstructed from the query string as follows. Start with the root\r\nvertex, which represents the state when the array is empty. Every time\r\nyou get a query , you need to go down the tree. , because if you go down\r\nthe tree to an existing vertex, it means that the states will coincide\r\nand the arrays in these two states are not necessarily similar. If you\r\nget a query , you go up the tree so you either maintain the current path\r\nin the tree in a stack, or store a parent for each vertex, to know where\r\nto go when you go up.Okay, now what about queries of type and ? Every\r\ntime we process such a query, we mark the current vertex to remember\r\nthat it has a or a in it. For example, you can store two boolean arrays\r\nthat give you the information whether a vertex is marked with and\r\nwhether a vertex is marked with .So, how does this tree help us in\r\nsolving the problem? Recall what weâre trying to check: we want to find\r\nout if a sorted array has a non-sorted prefix. In terms of our tree, it\r\nmeans that . To check that in , you can, for example, run a series of\r\nDFS traversals from all vertices marked with and make sure that you\r\ndonât visit any vertices marked with . Or you could do it in a single\r\nDFS (as the model solution does) which, for each vertex in the tree,\r\ncomputes if it has a vertex marked with in its subtree.\r\n",
    "hint": []
}