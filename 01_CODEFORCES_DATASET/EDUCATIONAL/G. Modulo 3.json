{
    "link": "https://codeforces.com//contest/2104/problem/G",
    "problemId": "3357543",
    "problem_idx": "G",
    "shortId": "2104G",
    "contest_number": "2104",
    "problem_submissions": {
        "G": [
            317634002,
            317631743,
            320673214,
            317636349,
            317639303,
            317631308,
            317640372,
            317641490,
            317634993,
            317623920,
            317623580,
            317647581,
            317646744,
            317640479,
            317649324,
            317648614,
            317603575,
            317625986,
            317658338,
            317654956,
            317656090
        ],
        "F": [
            317618453,
            317615339,
            317611576,
            317619502,
            317642933,
            317616740,
            317626825,
            317624444,
            317635700,
            317630227,
            317652195,
            317651366,
            317632460,
            317639846,
            317622626,
            317627252,
            317618955,
            317629645,
            317633465
        ],
        "E": [
            317600678,
            317604770,
            317604225,
            317601494,
            317605089,
            317605713,
            317610349,
            317606588,
            317606228,
            317611391,
            317609737,
            317616567,
            317624447,
            317604365,
            317605239,
            317606517,
            317605527,
            317603967
        ],
        "D": [
            317596832,
            317600994,
            317595577,
            317597224,
            317599585,
            317599131,
            317603322,
            317601392,
            317602519,
            317606339,
            317605002,
            317608223,
            317625926,
            317598715,
            317596708,
            317599445,
            317601363,
            317598919
        ],
        "C": [
            317592206,
            317594503,
            317591740,
            317592536,
            317595007,
            317592453,
            317599440,
            317596483,
            317666768,
            317597634,
            317597533,
            317596118,
            317603421,
            317628135,
            317593822,
            317592818,
            317594552,
            317594062,
            317592586
        ],
        "B": [
            317586512,
            317588149,
            317586474,
            317586748,
            317587897,
            317586575,
            317590393,
            317589124,
            317590519,
            317590566,
            317590505,
            317595035,
            317629001,
            317588704,
            317587930,
            317589549,
            317586793,
            317587862
        ],
        "A": [
            317583850,
            317584199,
            317583696,
            317583966,
            317584221,
            317583906,
            317584707,
            317583779,
            317583664,
            317586307,
            317586411,
            317589674,
            317629578,
            317583905,
            317584152,
            317583791,
            317583699,
            317583693
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142472",
    "editorial": "First, let’s find out how to solve the following problem: you are given\r\na directed graph where all vertices have color . You can choose a vertex\r\nand a color from to , then color it and all vertices reachable from it\r\nwith that color. How many different colorings are there?Clearly, if a\r\npair of vertices is in the same strongly connected component, they will\r\nalways have the same color. Furthermore, if we fix a color for each\r\nstrongly connected component, there is always a way to color the graph\r\nsuch that the colors for all components match the chosen ones. To do\r\nthis, we can condense the graph and color it in topological order of the\r\ncondensation. Therefore, the answer for an arbitrary directed graph is ,\r\nwhere is the number of strongly connected components.Now let’s return to\r\nthe original problem and try to utilize the fact that the answer is\r\nrequired modulo (this is probably an important constraint). If or , then\r\nany power of is equal to itself. Therefore, the only complex case is\r\nwhen . For , even powers are equal to modulo , while odd powers are\r\nequal to . Thus, we are actually interested in the of the number of\r\nstrongly connected components.Let’s try to understand how to\r\nconveniently count the parity of the number of SCCs for a functional\r\ngraph. Vertices that are not on cycles represent separate components,\r\nand each cycle is a separate component. If a cycle has even length, it\r\nchanges the parity of the number of SCCs, while if it has odd length, it\r\nleaves it unchanged. Therefore, we are actually interested in the number\r\nof cycles of even length in the functional graph.If instead of a\r\ndirected graph, we treat it as an undirected one (making each edge\r\nbidirectional), the cycles will not change. We are interested in the\r\nnumber of even cycles, and since there will be a cycle in each connected\r\ncomponent, we are interested in the number of connected components . In\r\nother words, we need to maintain the number of in the undirected\r\ngraph.The further part of the solution is purely technical. Let’s use\r\nthe Dynamic Connectivity Offline method: For each edge, find all time\r\nsegments during which it exists. Build a segment tree, where each leaf\r\nrepresents a moment in time (the -st leaf is the -st query, the -nd leaf\r\nis the -nd query, and so on). For each existence segment of an edge, do\r\nthe following: break it into vertices of the segment tree (as in any\r\nsegment query) and add information to each corresponding vertex that\r\nthis edge exists throughout this segment. Implement a Disjoint Set Union\r\nwith the ability to roll back the last operations (we will need to use\r\nrank heuristics, but not path compression heuristics). Since we need to\r\nmaintain bipartiteness, for each vertex in the DSU we will store the\r\nparity of the distance to the parent. To perform rollbacks, we can store\r\ntwo arrays that will show for each operation which cell’s value changed\r\n(the address of the modified variable) and what it was before. We will\r\ntraverse the segment tree using depth-first search. Each time we enter a\r\nvertex of the segment tree, we will add all edges that exist throughout\r\nthis segment to the DSU and recalculate the number of bipartite\r\ncomponents. Upon exiting a vertex, we will roll back the DSU to the\r\nversion that was present when we entered the vertex. When processing a\r\nleaf of the segment tree, we will know how many bipartite components are\r\nin the graph at that moment, and thus we will count the number of\r\ncolorings modulo . Complexity of the solution: .\r\n",
    "name": "G. Modulo 3",
    "statement": "Surely, you have seen problems which require you to output the answer\r\nmodulo 10^9+7, 10^9+9, or 998244353. But have you ever seen a problem\r\nwhere you have to print the answer modulo 3?You are given a functional\r\ngraph consisting of n vertices, numbered from 1 to n. It is a directed\r\ngraph, in which each vertex has exactly one outgoing arc. The graph is\r\ngiven as the array g_1, g_2,\r\ndots, g_n, where g_i means that there is an arc that goes from i to g_i.\r\nFor some vertices, the outgoing arcs might be self-loops.Initially, all\r\nvertices of the graph are colored in color 1. You can perform the\r\nfollowing operation: select a vertex and a color from 1 to k, and then\r\ncolor this vertex and all vertices that are reachable from it. You can\r\nperform this operation any number of times (even zero).You should\r\nprocess q queries. The query is described by three integers x, y and k.\r\nFor each query, you should: assign g_x := y; then calculate the number\r\nof different graph colorings for the given value of k (two colorings are\r\ndifferent if there exists at least one vertex that is colored in\r\ndifferent colors in these two colorings); since the answer can be very\r\nlarge, print it . Note that in every query, the initial coloring of the\r\ngraph is reset (all vertices initially have color 1 in each query).\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Modulo 3.json",
    "hint": []
}