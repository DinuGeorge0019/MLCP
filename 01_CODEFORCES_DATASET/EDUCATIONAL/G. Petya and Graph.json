{"link": "https://codeforces.com//contest/1082/problem/G", "problemId": "64169", "problem_idx": "G", "shortId": "1082G", "contest_number": "1082", "problem_submissions": {"F": [46328946, 46337799, 46339884, 46346150, 46445422, 46359069, 46431759, 46637242, 46637151, 46325175, 46338896, 46409182], "G": [46323996, 46323275, 46334802, 46323141, 46326108, 46329586, 46321808, 163694400, 163693799, 46332091, 46330084, 46336228, 46329478, 46334035, 46334852, 46340605, 46341989, 46332446, 46341097, 46318296, 46328921, 46335428], "E": [46318513, 46330600, 46328796, 46321883, 46324879, 46325643, 46324793, 46322771, 46328316, 46332015, 46327943, 46323542, 46327890, 46325362, 46330431, 46320019, 46338363, 46322189, 46331138], "D": [46316454, 46320831, 46325078, 46317954, 46322179, 46323264, 46336380, 46328840, 46322602, 46323491, 46324308, 46330072, 46325620, 46329576, 46325051, 46330163, 46325538, 46319965, 46324331], "C": [46314364, 46317118, 46317698, 46315803, 46318057, 46319400, 46316833, 46317944, 46317349, 46317946, 46320711, 46318098, 46319780, 46320328, 46319548, 46328045, 46319609, 46315734, 46318281], "B": [46313723, 46315264, 46315248, 46314114, 46315542, 46315654, 46315306, 46315753, 46315155, 46315310, 46317088, 46316030, 46316402, 46316343, 46315252, 46358458, 46314954, 46314579, 46315821], "A": [46313553, 46313861, 46313655, 46313685, 46313732, 46313657, 46313638, 46313650, 46313676, 46313977, 46315097, 46313735, 46314264, 46315003, 46313777, 46326534, 46313605, 46313586, 46314557]}, "name": "G. Petya and Graph", "statement": "Petya has a simple graph (that is, a graph without loops or multiple\r\nedges) consisting of n vertices and m edges.The weight of the i-th\r\nvertex is a_i.The weight of the i-th edge is w_i.A subgraph of a graph\r\nis some set of the graph vertices and some set of the graph edges. The\r\nset of edges must meet the condition: both ends of each edge from the\r\nset must belong to the chosen set of vertices. The weight of a subgraph\r\nis the sum of the weights of its edges, minus the sum of the weights of\r\nits vertices. You need to find the maximum weight of subgraph of given\r\ngraph. .\r\n", "solutions": ["/*\nI'm just a man and I am what I am, yeah\nNobody will ever change my ways\nI don't need money and I don't need no lies, yeah\nI only need to live for today\nBut I'd like to talk things over with you\nI want to hear the things you say, today\nAlthough you won't change me anyway, oh no way\n\nI wish you'd come and see me, I'd like to hold you\nI want to set my mind all free\nYou understand me woman, you give me time, yeah\nBut I don't need no sympathy\nStill I wonder what it's like to be loved\nInstead of hiding in myself\nNobody will change me anyway, no no way\n\nNobody's gonna change my world\nThat's something too unreal\nNobody will change the way I feel\n\nSo listen to me now, hear what I say, yeah\nPlease give me time and maybe love\nIf there's a God up there, well I hope he helps me\nI need him now to set me free\n'Cause it may be that it's over for me\nIf you don't hear the things that I say, today\nNobody will change me anyway, no no way\n\nNobody's gonna change my world\nThat's something too unreal\nNobody will change the way I feel\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nlong long n,m,s,t;\n\nstruct edge {\n\tint a, b;\n\tlong long cap, flow;\n};\n\nconst int MAXN = N;\n\nlong long d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n\nvoid add_edge (int a, int b, long long cap) {\n\tedge e1 = { a, b, cap, 0 };\n\tedge e2 = { b, a, 0, 0 };\n\tg[a].push_back ((int) e.size());\n\te.push_back (e1);\n\tg[b].push_back ((int) e.size());\n\te.push_back (e2);\n}\n\nbool bfs() {\n\tint qh=0, qt=0;\n\tq[qt++] = s;\n\tmemset (d, -1, n * sizeof d[0]);\n\td[s] = 0;\n\twhile (qh < qt && d[t] == -1) {\n\t\tint v = q[qh++];\n\t\tfor (size_t i=0; i<g[v].size(); ++i) {\n\t\t\tint id = g[v][i],\n\t\t\t\tto = e[id].b;\n\t\t\tif (d[to] == -1 && e[id].flow < e[id].cap) {\n\t\t\t\tq[qt++] = to;\n\t\t\t\td[to] = d[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t] != -1;\n}\n\nlong long dfs (int v, long long flow) {\n\tif (!flow)  return 0;\n\tif (v == t)  return flow;\n\tfor (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n\t\tint id = g[v][ptr[v]],\n\t\t\tto = e[id].b;\n\t\tif (d[to] != d[v] + 1)  continue;\n\t\tint pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n\t\tif (pushed) {\n\t\t\te[id].flow += pushed;\n\t\t\te[id^1].flow -= pushed;\n\t\t\treturn pushed;\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long dinic() {\n\tlong long flow = 0;\n\tfor (;;) {\n\t\tif (!bfs())  break;\n\t\tfor (int i=0;i<=n;i++)\n\t\t\tptr[i]=0;\n\t\twhile (true){\n\t\t\tlong long pushed = dfs (s, 1000000000000000ll);\n\t\t\tif (pushed==0)\n\t\t\t\tbreak;\n\t\t\tflow += pushed;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>m;\n\ts=0;\n\tt=n+m+1;\n\tfor (int i=1;i<=n;i++){\n\t\tint val;\n\t\tcin>>val;\n\t\tadd_edge(s,i,val);\n\t}\n\n\tlong long ttl=0;\n\n\tfor (int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tint val;\n\t\tcin>>a>>b>>val;\n\t\tadd_edge(a,i+n,1e15);\n\t\tadd_edge(b,i+n,1e15);\n\t\tadd_edge(i+n,t,val);\n\t\tttl+=val;\n\t}\n\n\t// some magic shit happens.\n\tn=t+1;\n\tlong long here=dinic();\n\n\tcout<<ttl-here<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graphs"], "dificulty": "2400", "interactive": false}