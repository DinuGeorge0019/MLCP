{
    "link": "https://codeforces.com//contest/1221/problem/E",
    "problemId": "415611",
    "problem_idx": "E",
    "shortId": "1221E",
    "contest_number": "1221",
    "problem_submissions": {
        "G": [
            60878901,
            60954325,
            60892510,
            60889777,
            60939440,
            60957169,
            60954037,
            60954018,
            60887759,
            60892512,
            61066187,
            60888304,
            60953665,
            60884074
        ],
        "F": [
            60872429,
            60906430,
            60877026,
            60879328,
            60873795,
            60880496,
            60880041,
            60882317,
            60876205,
            60881638,
            60879016,
            60884701,
            60883109,
            60876230,
            60885368,
            60884882,
            60888631,
            60877275
        ],
        "E": [
            60865427,
            60906424,
            60870455,
            60872355,
            60881944,
            60867813,
            60873346,
            60871774,
            60882236,
            60957159,
            60869840,
            60865430,
            60870324,
            60874697,
            60871945,
            60886034,
            60875073,
            60873664,
            60883200,
            60875153,
            60886105,
            60887173
        ],
        "D": [
            60858978,
            60906413,
            60858963,
            60862133,
            60857697,
            60858483,
            60858390,
            60860167,
            60862000,
            60957149,
            60859058,
            60857548,
            60865511,
            60860504,
            60857388,
            60865183,
            60887076,
            60866989,
            60863673,
            60861492,
            60857971,
            60867806,
            60885376
        ],
        "C": [
            60854799,
            60906405,
            60854087,
            60858148,
            60855694,
            60855339,
            60856078,
            60857408,
            60859538,
            60957138,
            60855511,
            60854166,
            60860646,
            60858018,
            60854647,
            60856215,
            60857135,
            60857947,
            60855000,
            60855230,
            60864597,
            60884317
        ],
        "B": [
            60853702,
            60906395,
            60853284,
            60856858,
            60853405,
            60869020,
            60854977,
            60855791,
            60854474,
            60957129,
            60854297,
            60853117,
            60859658,
            60856090,
            60853528,
            60854286,
            60855985,
            60856982,
            60854601,
            60853843,
            60862970,
            60883738
        ],
        "A": [
            60853175,
            60906382,
            60852746,
            60855419,
            60852846,
            60852969,
            60852978,
            60853994,
            60853299,
            60957119,
            60852836,
            60852764,
            60858768,
            60853799,
            60852813,
            60853187,
            60854280,
            60853549,
            60853275,
            60852850,
            60861325,
            60883303
        ]
    },
    "name": "E. Game With String",
    "statement": "Alice and Bob play a game. Initially they have a string s_1, s_2,\r\ndots, s_n, consisting of only characters and . They take alternating\r\nturns, and Alice is moving first. During each turn, the player has to\r\nselect a contiguous substring consisting only of characters and replaces\r\neach of them with . Alice must select a substing of length a, and Bob\r\nmust select a substring of length b. It is guaranteed that a > b.For\r\nexample, if s = and a = 3, b = 2, then after Alice\u2019s move string can\r\nturn only into . And if it\u2019s Bob\u2019s turn and the string s = , then after\r\nBob\u2019s move the string can turn into , or .Whoever is unable to make a\r\nmove, loses. You have to determine who wins if they both play\r\noptimally.You have to answer q independent queries.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 3 * (int)1e5 + 100;\nvoid alice() {\n    cout << \"YES\" << '\\n';\n}\nvoid bob() {\n    cout << \"NO\" << '\\n';\n}\nint a, b;\nstring s;\nbool bad(int x) {\n    if (x >= 2 * b || (b <= x && x < a)) return true;\n    else return false;\n}\nvoid solve() {\n    cin >> a >> b;\n    cin >> s;\n    s = 'X' + s;\n    s += 'X';\n    vector < int > lens;\n    int i = 0;\n    while (i < s.size()) {\n        int j = i + 1;\n        while (j < s.size() && s[j] != 'X') j++; j--;\n        lens.emplace_back(j - i);\n        i = j + 1;\n    }\n    vector < int > nlens;\n    for (int v : lens) {\n        if (v < b) continue;\n        nlens.emplace_back(v);\n    }\n    lens = nlens;\n    for (int v : lens) {\n        if (b <= v && v < a) {\n            bob();\n            return ;\n        }\n    }\n    int cnt = 0;\n    vector < int > big;\n    for (int v : lens) {\n        if (v >= 2 * b) {\n            cnt++;\n            big.push_back(v);\n        }\n    }\n    if (cnt >= 2) {\n        bob();\n        return;\n    }\n    if (cnt == 0) {\n        if (lens.size() % 2) alice();\n        else bob();\n        return;\n    }\n    assert(big.size() == 1);\n    int p = big[0];\n    for (int len1 = 0; len1 + a <= p; len1++) {\n        int len2 = p - a - len1;\n        if (bad(len1) || bad(len2)) continue;\n        int cnt2 = (int)(lens.size() - 1) + (len1 >= a) + (len2 >= a);\n        if (cnt2 % 2 == 0) {\n            alice();\n            return;\n        }\n    }\n    bob();\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int q;\n    cin >> q;\n    while (q--) {\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Game With String.json",
    "editorial_link": "https://codeforces.com//blog/entry/69925",
    "editorial": "At first, let\u00e2\u0080\u0099s transform input to a more convenient form. We consider\r\nonly such subsegments that consist of the symbols and which cannot be\r\nexpanded to the right or left. For example, for we consider segments of\r\nlength , , , and .Let\u00e2\u0080\u0099s divide all such segments into four groups by\r\ntheir length : ; ; ; . In such a division, each segment belongs to\r\nexactly one type.Suppose that the Bob takes the first turn. If there is\r\na segment of second type, then Bob wins, because he always have a spare\r\nturn that Alice cannot make. If there is a segment of fourth type then\r\nthe Bob also wins because he can make the segment of second type by\r\ntaking turn in this segment of four type. If there are no segments of\r\nsecond and four types, then victory depends on the parity of the number\r\nof segments of the third type.But it is true if the Bob takes first\r\nturn. If Alice takes first turn then she doesn\u00e2\u0080\u0099t want, after her move,\r\nthere are segments of the second and fourth types. So if initially there\r\nis a segment of second type then Alice loses because she can\u00e2\u0080\u0099t take\r\nturns into segment of second type. If there are two or more segments of\r\nfour type then Alice also loses, because after her turn at least one\r\nsuch segments remains. If there are only one segment of four type then\r\nAlice have to take turn into this segment. Since the length of this\r\nsegment doesn\u00e2\u0080\u0099t exceed , we can iterate over all possible Alice moves.\r\nAfter Alice\u00e2\u0080\u0099s move segment of fourth type can be divided into no more\r\nthan two new segments, let\u00e2\u0080\u0099s denote their types as and . If at least one\r\nof these segments of second or fourth type, then it\u00e2\u0080\u0099s bad turn for\r\nAlice. Otherwise Alice win if remaining number of segment of third type\r\nis even (note that or also can be the third type). And finally, if\r\ninitially there are only segments of first or third type, then victory\r\ndepends on the parity of the number of segments of the third type.\r\n"
}