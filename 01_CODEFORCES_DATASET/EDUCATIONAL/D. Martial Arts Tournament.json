{
    "link": "https://codeforces.com//contest/1626/problem/D",
    "problemId": "1263150",
    "problem_idx": "D",
    "shortId": "1626D",
    "contest_number": "1626",
    "problem_submissions": {
        "F": [
            143582629,
            143582389,
            143582261,
            143030095,
            143019770,
            143017980,
            143015927,
            143006584,
            143023462,
            143045218,
            143026061,
            143072563,
            143021001,
            143025294,
            143015197,
            143148041,
            143279801,
            143279754,
            143024492,
            143100204,
            143021824,
            143021213,
            143026062,
            143139699,
            143154043
        ],
        "E": [
            143010407,
            142989954,
            143008363,
            143007466,
            143004225,
            143013367,
            143007933,
            143008509,
            143004621,
            143020671,
            143009993,
            143010097,
            143019395,
            143017128,
            143017699,
            143016277,
            143019421,
            143018155,
            143017417,
            143018743
        ],
        "D": [
            142998685,
            143013473,
            142988837,
            142997007,
            142994432,
            142986599,
            142991567,
            142995751,
            142993422,
            142993529,
            142995186,
            142999199,
            142996240,
            142996592,
            143000338,
            142993884,
            142998691,
            142998238,
            142999391,
            143006779
        ],
        "C": [
            142980226,
            142979015,
            142977662,
            142982232,
            142982146,
            142978115,
            142981893,
            142985454,
            142982343,
            142973197,
            142987870,
            142983951,
            142981935,
            142983145,
            142987103,
            142984609,
            142987630,
            142988530,
            142988589,
            142986757
        ],
        "B": [
            142966509,
            142971358,
            142971311,
            142969795,
            142977281,
            142971069,
            142970463,
            142974139,
            142973968,
            142967452,
            142975316,
            142974511,
            142969981,
            142973410,
            142975897,
            142971054,
            142977505,
            142974933,
            142973959,
            142976717
        ],
        "A": [
            142962825,
            142965501,
            142963716,
            142963362,
            142962925,
            142962831,
            142962961,
            142963214,
            142962815,
            142962827,
            142965526,
            142964440,
            142963478,
            142962969,
            142963307,
            142963256,
            142966097,
            142963562,
            142966185,
            142966137
        ]
    },
    "name": "D. Martial Arts Tournament",
    "statement": "Monocarp is planning to host a martial arts tournament. There will be\r\nthree divisions based on weight: lightweight, middleweight and\r\nheavyweight. The winner of each division will be determined by a single\r\nelimination system.In particular, that implies that the number of\r\nparticipants in each division should be a power of two. Additionally,\r\neach division should have a non-zero amount of participants.n\r\nparticipants have registered for the tournament so far, the i-th of them\r\nweighs a_i. To split participants into divisions, Monocarp is going to\r\nestablish two integer weight boundaries x and y (x < y). All\r\nparticipants who weigh strictly less than x will be considered\r\nlightweight. All participants who weigh greater or equal to y will be\r\nconsidered heavyweight. The remaining participants will be considered\r\nmiddleweight.It’s possible that the distribution doesn’t make the number\r\nof participants in each division a power of two. It can also lead to\r\nempty divisions. To fix the issues, Monocarp can invite an arbitrary\r\nnumber of participants to each division.Note that Monocarp can’t kick\r\nout any of the n participants who have already registered for the\r\ntournament.However, he wants to invite as little extra participants as\r\npossible. Help Monocarp to choose x and y in such a way that the total\r\namount of extra participants required is as small as possible. Output\r\nthat amount.\r\n",
    "solutions": [
        "#pragma region Macros\n//#pragma GCC target(\"avx2\")\n// #pragma GCC optimize(\"O3\")\n// #pragma comment(linker, \"/stack:200000000\")\n#ifdef ONLINE_JUDGE\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2\")\n// #pragma GCC target(\"avx2\")\n#endif\n#pragma GCC optimize(\"Ofast\")\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl '\\n'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= b; i -= c)\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define rng(v, l, r) v.begin() + l, v.begin() + r\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {\"NO\", \"YES\"};\nconst string YesNo[2] = {\"No\", \"Yes\"};\nconst string yesno[2] = {\"no\", \"yes\"};\nconst string firstsecond[2] = {\"second\", \"first\"};\nconst string FirstSecond[2] = {\"Second\", \"First\"};\nconst string possiblestr[2] = {\"impossible\", \"possible\"};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\n\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\n// bit 演算系\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - '0'; }\n    }\n    if(s[0] == '-') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << \"0\"); }\n    i128 num = v;\n    if(v < 0) {\n        os << '-';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + '0'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? \", \" : \" \");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << '('; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << ')'; }\n    return os;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\n    return os << p.first << \" \" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << \"[\";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? \"\" : \", \") << y;\n        else\n            os << (f ? \"\" : \" \") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << \"]\";\n    return os;\n}\n\n#ifdef noimi\n#undef endl\nvoid debug() { cerr << endl; }\nvoid debug(bool) { cerr << endl; }\ntemplate <class Head, class... Tail> void debug(bool is_front, Head head, Tail... tail) {\n    if(!is_front) cerr << \", \";\n    cerr << head;\n    debug(false, tail...);\n}\n\n#define dump(args...)                                                                                                                                          \\\n    {                                                                                                                                                          \\\n        vector<string> _debug = _split(#args, ',');                                                                                                            \\\n        err(true, begin(_debug), args);                                                                                                                        \\\n    }\n\nvector<string> _split(const string &s, char c) {\n    vector<string> v;\n    stringstream ss(s);\n    string x;\n    while(getline(ss, x, c)) {\n        if(empty(v))\n            v.eb(x);\n        else {\n            bool flag = false;\n            for(auto [c, d] : {pair('(', ')'), pair('[', ']'), pair('{', '}')}) {\n                if(count(all(v.back()), c) != count(all(v.back()), d)) flag = true;\n            }\n            if(flag)\n                v.back() += \",\" + x;\n            else\n                v.eb(x);\n        }\n    }\n    return move(v);\n}\n\nvoid err(bool, vector<string>::iterator) { cerr << endl; }\ntemplate <typename T, typename... Args> void err(bool is_front, vector<string>::iterator it, T a, Args... args) {\n    if(!is_front) cerr << \", \";\n    cerr << it->substr((*it)[0] == ' ', (*it).size()) << \" = \" << a, err(false, ++it, args...);\n}\n\n// #define dump(...) cerr << #__VA_ARGS__ << \" : \", debug(true, __VA_ARGS__)\n#else\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n#endif\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << ' ';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(std::forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, std::forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nint toint(const char &c, const char start = 'a') { return c - start; }\nint toint(const char &c, const string &chars) { return find(all(chars), c) - begin(chars); }\nint alphabets_to_int(const char &c) { return (islower(c) ? c - 'a' : c - 'A' + 26); }\ntemplate <typename T> auto toint(const T &v, const char &start = 'a') {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\ntemplate <typename T> auto toint(const T &v, const string &start) {\n    vector<decltype(toint(v[0]))> ret;\n    ret.reserve(v.size());\n    for(auto &&e : v) ret.emplace_back(toint(e, start));\n    return ret;\n}\n// a -> 0, A -> 26\ntemplate <typename T> auto alphabets_to_int(const T &s) {\n    vector<decltype(alphabets_to_int(s[0]))> res;\n    res.reserve(s.size());\n    for(auto &&e : s) { res.emplace_back(alphabets_to_int(e)); }\n    return res;\n}\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        T mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#pragma endregion\n\nnamespace modular {\nconstexpr ll MOD = 998244353;\nconst int MAXN = 11000000;\ntemplate <ll Modulus> class modint;\nusing mint = modint<MOD>;\nusing vmint = vector<mint>;\nvector<mint> Inv;\nmint inv(int x);\ntemplate <ll Modulus> class modint {\n\n  public:\n    static constexpr int mod() { return Modulus; }\n    ll a;\n\n    constexpr modint(const ll x = 0) noexcept : a(((x % Modulus) + Modulus) % Modulus) {}\n    constexpr ll &val() noexcept { return a; }\n    constexpr const ll &val() const noexcept { return a; }\n    constexpr modint operator-() const noexcept { return modint() - *this; }\n    constexpr modint operator+() const noexcept { return *this; }\n    constexpr modint &operator++() noexcept {\n        if(++a == MOD) a = 0;\n        return *this;\n    }\n    constexpr modint &operator--() noexcept {\n        if(!a) a = MOD;\n        a--;\n        return *this;\n    }\n    constexpr modint operator++(int) {\n        modint res = *this;\n        ++*this;\n        return res;\n    }\n    constexpr modint operator--(int) {\n        mint res = *this;\n        --*this;\n        return res;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if(a >= Modulus) { a -= Modulus; }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if(a < rhs.a) { a += Modulus; }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(const modint rhs) noexcept {\n        a = a * (modular::inv(rhs.a)).a % Modulus;\n        return *this;\n    }\n    constexpr modint pow(long long n) const noexcept {\n        if(n < 0) {\n            n %= Modulus - 1;\n            n = (Modulus - 1) + n;\n        }\n        modint x = *this, r = 1;\n        while(n) {\n            if(n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    constexpr modint inv() const noexcept { return pow(Modulus - 2); }\n    constexpr friend modint operator+(const modint &lhs, const modint &rhs) { return modint(lhs) += modint(rhs); }\n    constexpr friend modint operator-(const modint &lhs, const modint &rhs) { return modint(lhs) -= modint(rhs); }\n    constexpr friend modint operator*(const modint &lhs, const modint &rhs) { return modint(lhs) *= modint(rhs); }\n    constexpr friend modint operator/(const modint &lhs, const modint &rhs) { return modint(lhs) /= modint(rhs); }\n    constexpr friend bool operator==(const modint &lhs, const modint &rhs) { return lhs.a == rhs.a; }\n    constexpr friend bool operator!=(const modint &lhs, const modint &rhs) { return lhs.a != rhs.a; }\n    // constexpr friend modint operator^=(const modint &lhs, const modint &rhs) { return modint(lhs) ^= modint(rhs); }\n};\nvmint Fact{1, 1}, Ifact{1, 1};\nmint inv(int n) {\n    if(n > MAXN) return (mint(n)).pow(MOD - 2);\n    if(Inv.empty()) Inv.emplace_back(0), Inv.emplace_back(1);\n    if(Inv.size() > n)\n        return Inv[n];\n    else {\n        for(int i = Inv.size(); i <= n; ++i) {\n            auto [y, x] = div(int(MOD), i);\n            Inv.emplace_back(Inv[x] * (-y));\n        }\n        return Inv[n];\n    }\n}\nmint fact(int n) {\n    if(Fact.size() > n)\n        return Fact[n];\n    else\n        for(int i = Fact.size(); i <= n; ++i) Fact.emplace_back(Fact[i - 1] * i);\n    return Fact[n];\n}\nmint ifact(int n) {\n    if(Ifact.size() > n)\n        return Ifact[n];\n    else\n        for(int i = Ifact.size(); i <= n; ++i) Ifact.emplace_back(Ifact[i - 1] * inv(i));\n    return Ifact[n];\n}\nmint modpow(ll a, ll n) { return mint(a).pow(n); }\nmint inv(mint a) { return inv(a.a); }\nmint ifact(mint a) { return ifact(a.a); }\nmint fact(mint a) { return fact(a.a); }\nmint modpow(mint a, ll n) { return modpow(a.a, n); }\nmint C(int a, int b) {\n    if(a < 0 || b < 0) return 0;\n    if(a < b) return 0;\n    if(a > MAXN) {\n        mint res = 1;\n        rep(i, b) res *= a - i, res /= i + 1;\n        return res;\n    }\n    return fact(a) * ifact(b) * ifact(a - b);\n}\nmint P(int a, int b) {\n    if(a < 0 || b < 0) return 0;\n    if(a < b) return 0;\n    if(a > MAXN) {\n        mint res = 1;\n        rep(i, b) res *= a - i;\n        return res;\n    }\n    return fact(a) * ifact(a - b);\n}\nostream &operator<<(ostream &os, mint a) {\n    os << a.a;\n    return os;\n}\nistream &operator>>(istream &is, mint &a) {\n    ll x;\n    is >> x;\n    a = x;\n    return is;\n}\nostream &operator<<(ostream &os, const vmint &a) {\n    if(!a.empty()) {\n        os << a[0];\n        for(int i = 1; i < si(a); i++) os << \" \" << a[i];\n    }\n    return os;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace convolution {\n\nnamespace internal {\nint ceil_pow2(int n) {\n    int x = 0;\n    while((1U << x) < (unsigned int)(n)) x++;\n    return x;\n}\nint bsf(unsigned int n) {\n#ifdef _MSC_VER\n    unsigned long index;\n    _BitScanForward(&index, n);\n    return index;\n#else\n    return __builtin_ctz(n);\n#endif\n}\nconstexpr long long safe_mod(long long x, long long m) {\n    x %= m;\n    if(x < 0) x += m;\n    return x;\n}\nstruct barrett {\n    unsigned int _m;\n    unsigned long long im;\n    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n    unsigned int umod() const { return _m; }\n    unsigned int mul(unsigned int a, unsigned int b) const {\n        unsigned long long z = a;\n        z *= b;\n#ifdef _MSC_VER\n        unsigned long long x;\n        _umul128(z, im, &x);\n#else\n        unsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n        unsigned int v = (unsigned int)(z - x * _m);\n        if(_m <= v) v += _m;\n        return v;\n    }\n};\nconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n    if(m == 1) return 0;\n    unsigned int _m = (unsigned int)(m);\n    unsigned long long r = 1;\n    unsigned long long y = safe_mod(x, m);\n    while(n) {\n        if(n & 1) r = (r * y) % _m;\n        y = (y * y) % _m;\n        n >>= 1;\n    }\n    return r;\n}\nconstexpr bool is_prime_constexpr(int n) {\n    if(n <= 1) return false;\n    if(n == 2 || n == 7 || n == 61) return true;\n    if(n % 2 == 0) return false;\n    long long d = n - 1;\n    while(d % 2 == 0) d /= 2;\n    for(long long a : {2, 7, 61}) {\n        long long t = d;\n        long long y = pow_mod_constexpr(a, t, n);\n        while(t != n - 1 && y != 1 && y != n - 1) {\n            y = y * y % n;\n            t <<= 1;\n        }\n        if(y != n - 1 && t % 2 == 0) { return false; }\n    }\n    return true;\n}\ntemplate <int n> constexpr bool is_prime = is_prime_constexpr(n);\n\nconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n    a = safe_mod(a, b);\n    if(a == 0) return {b, 0};\n    long long s = b, t = a;\n    long long m0 = 0, m1 = 1;\n\n    while(t) {\n        long long u = s / t;\n        s -= t * u;\n        m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b\n        auto tmp = s;\n        s = t;\n        t = tmp;\n        tmp = m0;\n        m0 = m1;\n        m1 = tmp;\n    }\n    if(m0 < 0) m0 += b / s;\n    return {s, m0};\n}\n\n// Compile time primitive root\n// @param m must be prime\n// @return primitive root (and minimum in now)\nconstexpr int primitive_root_constexpr(int m) {\n    if(m == 2) return 1;\n    if(m == 167772161) return 3;\n    if(m == 469762049) return 3;\n    if(m == 754974721) return 11;\n    if(m == 998244353) return 3;\n    int divs[20] = {};\n    divs[0] = 2;\n    int cnt = 1;\n    int x = (m - 1) / 2;\n    while(x % 2 == 0) x /= 2;\n    for(int i = 3; (long long)(i)*i <= x; i += 2) {\n        if(x % i == 0) {\n            divs[cnt++] = i;\n            while(x % i == 0) { x /= i; }\n        }\n    }\n    if(x > 1) { divs[cnt++] = x; }\n    for(int g = 2;; g++) {\n        bool ok = true;\n        for(int i = 0; i < cnt; i++) {\n            if(pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                ok = false;\n                break;\n            }\n        }\n        if(ok) return g;\n    }\n}\ntemplate <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n\nvoid butterfly(std::vector<mint> &a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_e[30]; // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n    if(first) {\n        first = false;\n        mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for(int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for(int i = 0; i < cnt2 - 2; i++) {\n            sum_e[i] = es[i] * now;\n            now *= ies[i];\n        }\n    }\n    for(int ph = 1; ph <= h; ph++) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint now = 1;\n        for(int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for(int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p] * now;\n                a[i + offset] = l + r;\n                a[i + offset + p] = l - r;\n            }\n            now *= sum_e[bsf(~(unsigned int)(s))];\n        }\n    }\n}\n\nvoid butterfly_inv(std::vector<mint> &a) {\n    static constexpr int g = internal::primitive_root<mint::mod()>;\n    int n = int(a.size());\n    int h = internal::ceil_pow2(n);\n\n    static bool first = true;\n    static mint sum_ie[30]; // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n    if(first) {\n        first = false;\n        mint es[30], ies[30]; // es[i]^(2^(2+i)) == 1\n        int cnt2 = bsf(mint::mod() - 1);\n        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n        for(int i = cnt2; i >= 2; i--) {\n            // e^(2^i) == 1\n            es[i - 2] = e;\n            ies[i - 2] = ie;\n            e *= e;\n            ie *= ie;\n        }\n        mint now = 1;\n        for(int i = 0; i < cnt2 - 2; i++) {\n            sum_ie[i] = ies[i] * now;\n            now *= es[i];\n        }\n    }\n\n    for(int ph = h; ph >= 1; ph--) {\n        int w = 1 << (ph - 1), p = 1 << (h - ph);\n        mint inow = 1;\n        for(int s = 0; s < w; s++) {\n            int offset = s << (h - ph + 1);\n            for(int i = 0; i < p; i++) {\n                auto l = a[i + offset];\n                auto r = a[i + offset + p];\n                a[i + offset] = l + r;\n                a[i + offset + p] = (unsigned long long)(mint::mod() + l.val() - r.val()) * inow.val();\n            }\n            inow *= sum_ie[bsf(~(unsigned int)(s))];\n        }\n    }\n    mint z = mint(n).inv();\n    for(int i = 0; i < n; i++) a[i] *= z;\n}\n\n} // namespace internal\n\nstd::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n    int n = int(a.size()), m = int(b.size());\n    if(!n || !m) return {};\n    if(std::min(n, m) <= 60) {\n        if(n < m) {\n            std::swap(n, m);\n            std::swap(a, b);\n        }\n        std::vector<mint> ans(n + m - 1);\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) { ans[i + j] += a[i] * b[j]; }\n        }\n        return ans;\n    }\n    int z = 1 << internal::ceil_pow2(n + m - 1);\n    a.resize(z);\n    internal::butterfly(a);\n    b.resize(z);\n    internal::butterfly(b);\n    for(int i = 0; i < z; i++) { a[i] *= b[i]; }\n    internal::butterfly_inv(a);\n    a.resize(n + m - 1);\n    // mint iz = mint(z).inv();\n    // for(int i = 0; i < n + m - 1; i++) a[i] *= iz;\n    return a;\n}\n\n} // namespace convolution\n\nusing Poly = vmint;\nPoly low(const Poly &f, int s) { return Poly(f.begin(), f.begin() + min<int>(max(s, 1), f.size())); }\nPoly operator-(Poly f) {\n    for(auto &&e : f) e = -e;\n    return f;\n}\nPoly &operator+=(Poly &l, const Poly &r) {\n    l.resize(max(l.size(), r.size()));\n    rep(i, r.size()) l[i] += r[i];\n    return l;\n}\nPoly operator+(Poly l, const Poly &r) { return l += r; }\nPoly &operator-=(Poly &l, const Poly &r) {\n    l.resize(max(l.size(), r.size()));\n    rep(i, r.size()) l[i] -= r[i];\n    return l;\n}\nPoly operator-(Poly l, const Poly &r) { return l -= r; }\nPoly &operator<<=(Poly &f, size_t n) { return f.insert(f.begin(), n, 0), f; }\nPoly operator<<(Poly f, size_t n) { return f <<= n; }\nPoly &operator>>=(Poly &f, size_t n) { return f.erase(f.begin(), f.begin() + min(f.size(), n)), f; }\nPoly operator>>(Poly f, size_t n) { return f >>= n; }\nPoly operator*(const Poly &l, const Poly &r) { return convolution::convolution(l, r); }\nPoly &operator*=(Poly &l, const Poly &r) { return l = l * r; }\nPoly &operator*=(Poly &l, const mint &x) {\n    for(auto &e : l) e *= x;\n    return l;\n}\nPoly operator*(const Poly &l, const mint &x) {\n    auto res = l;\n    return res *= x;\n}\n\nPoly inv(const Poly &f, int s = -1) {\n    if(s == -1) s = f.size();\n    Poly r(s);\n    r[0] = mint(1) / f[0];\n    for(int n = 1; n < s; n *= 2) {\n        auto F = low(f, 2 * n);\n        F.resize(2 * n);\n        convolution::internal::butterfly(F);\n        auto g = low(r, 2 * n);\n        g.resize(2 * n);\n        convolution::internal::butterfly(g);\n        rep(i, 2 * n) F[i] *= g[i];\n        convolution::internal::butterfly_inv(F);\n        rep(i, n) F[i] = 0;\n        convolution::internal::butterfly(F);\n        rep(i, 2 * n) F[i] *= g[i];\n        convolution::internal::butterfly_inv(F);\n        rep(i, n, min(2 * n, s)) r[i] -= F[i];\n    }\n    return r;\n}\nPoly integ(const Poly &f) {\n    Poly res(f.size() + 1);\n    for(int i = 1; i < (int)res.size(); ++i) res[i] = f[i - 1] / i;\n    return res;\n}\nPoly deriv(const Poly &f) {\n    if(f.size() == 0) return Poly();\n    Poly res(f.size() - 1);\n    rep(i, res.size()) res[i] = f[i + 1] * (i + 1);\n    return res;\n}\nPoly log(const Poly &f) {\n    Poly g = integ(inv(f) * deriv(f));\n    return Poly{g.begin(), g.begin() + f.size()};\n}\nPoly exp(const Poly &f) {\n    Poly g{1};\n    while(g.size() < f.size()) {\n        Poly x(f.begin(), f.begin() + min(f.size(), g.size() * 2));\n        x[0] += 1;\n        g.resize(2 * g.size());\n        x -= log(g);\n        x *= {g.begin(), g.begin() + g.size() / 2};\n        rep(i, g.size() / 2, min<int>(x.size(), g.size())) g[i] = x[i];\n    }\n    return {g.begin(), g.begin() + f.size()};\n}\nPoly pow(const Poly &f, ll k, int need = -1) {\n    const int n = (int)f.size();\n    if(need == -1) need = n;\n    int z = 0;\n    rep(i, n) {\n        if(f[i].a) break;\n        z++;\n    }\n    if(z * k >= need) return Poly(n);\n    mint rev = f[z].inv();\n    Poly res = exp(log((f >> z) * rev) * k) * f[z].pow(k);\n    res.resize(need - z * k);\n    return res << z * k;\n}\n\nstruct Prd {\n    deque<Poly> deq;\n    Prd() = default;\n    void emplace(const Poly &f) { deq.emplace_back(f); }\n    Poly calc() {\n        if(deq.empty()) return {1};\n        sort(all(deq), [&](const Poly &f, const Poly &g) { return si(f) < si(g); });\n        while(deq.size() > 1) {\n            deq.emplace_back(deq[0] * deq[1]);\n            for(int i = 0; i < 2; ++i) deq.pop_front();\n        }\n        return deq.front();\n    }\n};\nPoly prd(vector<Poly> &v) {\n    Prd p;\n    for(auto &e : v) p.emplace(e);\n    return p.calc();\n}\n\nvmint power_table(mint x, int len) {\n    vmint res(len + 1);\n    res[0] = 1;\n    rep(i, len) res[i + 1] = res[i] * x;\n    return res;\n}\n\n} // namespace modular\nusing namespace modular;\n\nint main() {\n    TEST {\n        INT(n);\n        // [x, y)\n        vi ok(n + 1);\n        map<int, int> mp;\n        rep(n) {\n            INT(x);\n            mp[x]++;\n        }\n        int cnt = 0;\n        ok[0] = 1;\n        fore(a, b, mp) { ok[cnt += b] = 1; }\n        vi ok2(n + 1);\n        rep(i, n + 1) if(ok[i]) ok2[n - i] = true;\n        vi l, r;\n        rep(i, n + 1) {\n            if(ok[i]) l.eb(i);\n            if(ok2[i]) r.eb(i);\n        }\n\n        rep(t, inf<int>) {\n            int N = n + t;\n            if(popcount(N) > 3) continue;\n            vi v;\n            while(N) {\n                v.eb(1 << lowbit(N));\n                N -= 1 << lowbit(N);\n            }\n            bool flag = false;\n\n            vvc<int> cand;\n            if(si(v) == 3)\n                cand.eb(v);\n            else if(si(v) == 2) {\n                if(v[0] > 1) cand.eb(vi{v[0] / 2, v[0] / 2, v[1]});\n                cand.eb(vi{v[0], v[1] / 2, v[1] / 2});\n            } else if(si(v) == 1) {\n                if(v[0] >= 4) { cand.eb(vi{v[0] / 4, v[0] / 4, v[0] / 2}); }\n            }\n            fore(v, cand) {\n                rep(6) {\n                    int L = l[ub(l, v[0]) - 1];\n                    int R = r[ub(r, v[2]) - 1];\n                    int p = v[0] + v[2] - L - R;\n                    if(p <= t) {\n                        dump(v, l, r, L, R);\n                        flag = true;\n                        break;\n                    }\n                    next_permutation(all(v));\n                }\n                if(flag) break;\n            }\n            if(flag) {\n                OUT(t);\n                break;\n            }\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Martial Arts Tournament.json",
    "editorial_link": "https://codeforces.com//blog/entry/99136",
    "editorial": "Sort the weights, now choosing and will split the array into three\r\nconsecutive segments.Consider a naive solution to the problem. You can\r\niterate over the length of the first segment and the second segment. The\r\nthird segment will include everyone remaining.Now you have to check if\r\nthere exist some and that produce such segment. can be equal to the\r\nfirst element of the second segment (since only all elements of the\r\nfirst segment are smaller than it). Similarly, can be equal to the first\r\nelement of the third segment.However, if the last element of some\r\nsegment is equal to the first element of the next segment, no or can\r\nsplit the array like that.Otherwise, you can split an array like that.\r\nSo you can iterate over the lengths, check the correctness and choose\r\nthe best answer.Now let’s optimize it using the condition about powers\r\nof two.First, iterate over the size of the middle division (which is a\r\npower of two). Then over the length of the first segment (which can be\r\nnot a power of two). Check if the first segment is valid.So we fixed the\r\nlength of the first segment and some value which is greater or equal\r\nthan the length of the second segment. That value isn’t necessarily\r\nequal to the length of the second segment because the produced segment\r\nmight be invalid.So there is a greedy idea that the second segment\r\nshould be as long as possible under the constraint that it doesn’t\r\nexceed the fixed value. The intuition is the following. Consider the\r\nlongest possible valid segment. Now take the last element away from it.\r\nWe will have to invite one more participant to the middle division. And\r\nthat element will also get added to the third segment, increasing its\r\nlength. So potentially, you can only increase the required number of\r\nparticipants to invite.This can be implemented in the following fashion.\r\nFor each position precalculate the closest possible segment border from\r\nthe left. Iterate over the size of the middle division as a power of\r\ntwo. Iterate over the length of the first segment . Find the closest\r\nborder to the left of . Get the lengths of the second and the third\r\nsegments. Find the closest powers of two to each length and update the\r\nanswer.Overall complexity: per testcase.\r\n",
    "hint": []
}