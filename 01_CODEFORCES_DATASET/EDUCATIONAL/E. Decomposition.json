{
    "link": "https://codeforces.com//contest/1766/problem/E",
    "problemId": "1690150",
    "problem_idx": "E",
    "shortId": "1766E",
    "contest_number": "1766",
    "problem_submissions": {
        "E": [
            184982392,
            184982173,
            184938042,
            184950686,
            184932260,
            184939673,
            184936898,
            184934396,
            184948204,
            184935811,
            184943315,
            184989151,
            184947057,
            184952057,
            184938439,
            184967483,
            187916344,
            184948513,
            184933180,
            184935854,
            184939624,
            184943840,
            184943132,
            184940980
        ],
        "F": [
            184949728,
            184939667,
            184976950,
            184964579,
            184958474,
            184962483,
            184966185,
            184957638,
            184969067,
            185089664,
            185089530,
            184977947,
            184997639,
            184973757,
            184966070,
            184960435,
            184974697,
            184966631,
            184990205,
            184997420
        ],
        "D": [
            184914984,
            184986868,
            184986781,
            184917638,
            184915781,
            184923898,
            184923871,
            184918405,
            184919375,
            184923813,
            184918585,
            184915933,
            184925192,
            184969262,
            184952734,
            184970967,
            184919304,
            184918923,
            184922752,
            184918317,
            184920694,
            184924980
        ],
        "C": [
            184909482,
            184913973,
            184911632,
            184918401,
            184916364,
            185395845,
            184914719,
            184914076,
            184920058,
            184913612,
            184913225,
            184921601,
            184918048,
            184950984,
            184973944,
            184914889,
            184913008,
            184914015,
            184915845,
            184914942,
            184915187
        ],
        "B": [
            184907198,
            184909422,
            184907991,
            184909353,
            184910422,
            184907995,
            184908723,
            184907965,
            184908129,
            184908832,
            184911921,
            184911885,
            184949263,
            184977162,
            184909079,
            184908305,
            184909027,
            184908934,
            184911337,
            184910448
        ],
        "A": [
            184906447,
            184906808,
            184906511,
            184906536,
            184906567,
            184906521,
            184906485,
            184906494,
            184906490,
            184992052,
            184907067,
            184906532,
            184906851,
            184947991,
            184978729,
            184906583,
            184906564,
            184906598,
            184906512,
            184906683,
            184906543
        ]
    },
    "name": "E. Decomposition",
    "statement": "For a sequence of integers [x_1, x_2,\r\ndots, x_k], let\u2019s define its as follows:Process the sequence from the\r\nfirst element to the last one, maintaining the list of its subsequences.\r\nWhen you process the element x_i, append it to the end of the\r\nsubsequence in the list such that the bitwise AND of its last element\r\nand x_i is greater than 0. If there is no such subsequence in the list,\r\ncreate a new subsequence with only one element x_i and append it to the\r\nend of the list of subsequences.For example, let\u2019s analyze the\r\ndecomposition of the sequence [1, 3, 2, 0, 1, 3, 2, 1]: processing\r\nelement 1, the list of subsequences is empty. There is no subsequence to\r\nappend 1 to, so we create a new subsequence [1]; processing element 3,\r\nthe list of subsequences is [[1]]. Since the bitwise AND of 3 and 1 is\r\n1, the element is appended to the first subsequence; processing element\r\n2, the list of subsequences is [[1, 3]]. Since the bitwise AND of 2 and\r\n3 is 2, the element is appended to the first subsequence; processing\r\nelement 0, the list of subsequences is [[1, 3, 2]]. There is no\r\nsubsequence to append 0 to, so we create a new subsequence [0];\r\nprocessing element 1, the list of subsequences is [[1, 3, 2], [0]].\r\nThere is no subsequence to append 1 to, so we create a new subsequence\r\n[1]; processing element 3, the list of subsequences is [[1, 3, 2], [0],\r\n[1]]. Since the bitwise AND of 3 and 2 is 2, the element is appended to\r\nthe first subsequence; processing element 2, the list of subsequences is\r\n[[1, 3, 2, 3], [0], [1]]. Since the bitwise AND of 2 and 3 is 2, the\r\nelement is appended to the first subsequence; processing element 1, the\r\nlist of subsequences is [[1, 3, 2, 3, 2], [0], [1]]. The element 1\r\ncannot be appended to any of the first two subsequences, but can be\r\nappended to the third one. The resulting list of subsequences is [[1, 3,\r\n2, 3, 2], [0], [1, 1]].Let f([x_1, x_2,\r\ndots, x_k]) be the number of subsequences the sequence [x_1, x_2,\r\ndots, x_k] is decomposed into..You are given a sequence [a_1, a_2,\r\ndots, a_n], where each element is an integer from 0 to 3. Let a[i..j] be\r\nthe sequence [a_i, a_{i+1},\r\ndots, a_j]. You have to calculate\r\nsum\r\nlimits_{i=1}^n\r\nsum\r\nlimits_{j=i}^n f(a[i..j]).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++){\n    cin >> a[i];\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; i++){\n    if (a[i] == 0){\n      ans += (long long) (i + 1) * (n - i);\n    }\n  }\n  vector<array<int, 11>> P(4);\n  P[0] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n  P[1] = {1, 1, 7, 1, 4, 4, 10, 7, 9, 9, 10};\n  P[2] = {2, 4, 2, 2, 4, 6, 6, 7, 7, 10, 10};\n  P[3] = {3, 3, 3, 3, 5, 5, 5, 8, 8, 8, 10};\n  vector<int> L = {0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3};\n  vector<vector<long long>> dp(n + 1, vector<long long>(11, 0));\n  for (int i = 0; i < n; i++){\n    dp[i][0]++;\n    for (int j = 0; j < 11; j++){\n      dp[i + 1][P[a[i]][j]] += dp[i][j];\n    }\n  }\n  for (int i = 1; i <= n; i++){\n    for (int j = 0; j < 11; j++){\n      ans += dp[i][j] * L[j];\n    }\n  }\n  cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "dp",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Decomposition.json",
    "editorial_link": "https://codeforces.com//blog/entry/110066",
    "editorial": "Let\u00e2\u0080\u0099s assume that we don\u00e2\u0080\u0099t have any zeroes in our array. We\u00e2\u0080\u0099ll deal with\r\nthem later.The key observation is that the number of sequences in the\r\ndecomposition is not more than . To prove this, we can use the fact that\r\neach element will be appended to the first subsequence in the\r\ndecomposition; so, if the second/third subsequence in the decomposition\r\nends with the number or , all such numbers can be appended to that\r\nsubsequence, thus they won\u00e2\u0080\u0099t create any new subsequences. So, if we\r\nconsider the combination of the last elements in the subsequences of the\r\ndecomposition, there are only such combinations (even less in\r\npractice).Okay, now let\u00e2\u0080\u0099s try to use the fact that the number of such\r\ncombinations is small. There are many ways to abuse it, but, in my\r\nopinion, the most straightforward one (and also a bit slow, but fast\r\nenough to easily pass the time limit) is to run the following dynamic\r\nprogramming: , where is the index of the element we are processing, and\r\nis the vector representing the combination of last elements of\r\nsubsequences in the decomposition.But it\u00e2\u0080\u0099s not clear what do we store in\r\nthis dynamic programming. The model solution stores (i. e. we will\r\nconsider the number of subsequences added while processing the elements\r\n). So, our dynamic programming automatically sums up the answers for all\r\npossible right borders of the segment we decompose. Transitions in this\r\ndynamic programming is easy: we need to see how does the element alter\r\nthe state of decomposition (let it change it to ), take the value of ,\r\nand if the element forms a new subsequence, let\u00e2\u0080\u0099s account for it by\r\nincreasing by , because this increase will affect different right\r\nendpoints of the segment we decompose.And now it\u00e2\u0080\u0099s easy to see how to\r\nadd zeroes to our solution. We can just assume they don\u00e2\u0080\u0099t change the\r\nstate of decomposition, they simply add a new subsequence which won\u00e2\u0080\u0099t\r\ntake any other elements. So, in our transitions, processing means that ,\r\nbut the size of decomposition increases.To actually get the answer to\r\nthe problem, we need to consider all possible starting points of the\r\nsegment, so we sum up (where is the empty vector) for all .\r\n"
}