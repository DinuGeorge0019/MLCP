{"link": "https://codeforces.com//contest/1766/problem/E", "problemId": "1690150", "problem_idx": "E", "shortId": "1766E", "contest_number": "1766", "problem_submissions": {"E": [184982392, 184982173, 184938042, 184950686, 184932260, 184939673, 184936898, 184934396, 184948204, 184935811, 184943315, 184989151, 184947057, 184952057, 184938439, 184967483, 187916344, 184948513, 184933180, 184935854, 184939624, 184943840, 184943132, 184940980], "F": [184949728, 184939667, 184976950, 184964579, 184958474, 184962483, 184966185, 184957638, 184969067, 185089664, 185089530, 184977947, 184997639, 184973757, 184966070, 184960435, 184974697, 184966631, 184990205, 184997420], "D": [184914984, 184986868, 184986781, 184917638, 184915781, 184923898, 184923871, 184918405, 184919375, 184923813, 184918585, 184915933, 184925192, 184969262, 184952734, 184970967, 184919304, 184918923, 184922752, 184918317, 184920694, 184924980], "C": [184909482, 184913973, 184911632, 184918401, 184916364, 185395845, 184914719, 184914076, 184920058, 184913612, 184913225, 184921601, 184918048, 184950984, 184973944, 184914889, 184913008, 184914015, 184915845, 184914942, 184915187], "B": [184907198, 184909422, 184907991, 184909353, 184910422, 184907995, 184908723, 184907965, 184908129, 184908832, 184911921, 184911885, 184949263, 184977162, 184909079, 184908305, 184909027, 184908934, 184911337, 184910448], "A": [184906447, 184906808, 184906511, 184906536, 184906567, 184906521, 184906485, 184906494, 184906490, 184992052, 184907067, 184906532, 184906851, 184947991, 184978729, 184906583, 184906564, 184906598, 184906512, 184906683, 184906543]}, "name": "E. Decomposition", "statement": "For a sequence of integers [x_1, x_2,\r\ndots, x_k], let\u2019s define its as follows:Process the sequence from the\r\nfirst element to the last one, maintaining the list of its subsequences.\r\nWhen you process the element x_i, append it to the end of the\r\nsubsequence in the list such that the bitwise AND of its last element\r\nand x_i is greater than 0. If there is no such subsequence in the list,\r\ncreate a new subsequence with only one element x_i and append it to the\r\nend of the list of subsequences.For example, let\u2019s analyze the\r\ndecomposition of the sequence [1, 3, 2, 0, 1, 3, 2, 1]: processing\r\nelement 1, the list of subsequences is empty. There is no subsequence to\r\nappend 1 to, so we create a new subsequence [1]; processing element 3,\r\nthe list of subsequences is [[1]]. Since the bitwise AND of 3 and 1 is\r\n1, the element is appended to the first subsequence; processing element\r\n2, the list of subsequences is [[1, 3]]. Since the bitwise AND of 2 and\r\n3 is 2, the element is appended to the first subsequence; processing\r\nelement 0, the list of subsequences is [[1, 3, 2]]. There is no\r\nsubsequence to append 0 to, so we create a new subsequence [0];\r\nprocessing element 1, the list of subsequences is [[1, 3, 2], [0]].\r\nThere is no subsequence to append 1 to, so we create a new subsequence\r\n[1]; processing element 3, the list of subsequences is [[1, 3, 2], [0],\r\n[1]]. Since the bitwise AND of 3 and 2 is 2, the element is appended to\r\nthe first subsequence; processing element 2, the list of subsequences is\r\n[[1, 3, 2, 3], [0], [1]]. Since the bitwise AND of 2 and 3 is 2, the\r\nelement is appended to the first subsequence; processing element 1, the\r\nlist of subsequences is [[1, 3, 2, 3, 2], [0], [1]]. The element 1\r\ncannot be appended to any of the first two subsequences, but can be\r\nappended to the third one. The resulting list of subsequences is [[1, 3,\r\n2, 3, 2], [0], [1, 1]].Let f([x_1, x_2,\r\ndots, x_k]) be the number of subsequences the sequence [x_1, x_2,\r\ndots, x_k] is decomposed into..You are given a sequence [a_1, a_2,\r\ndots, a_n], where each element is an integer from 0 to 3. Let a[i..j] be\r\nthe sequence [a_i, a_{i+1},\r\ndots, a_j]. You have to calculate\r\nsum\r\nlimits_{i=1}^n\r\nsum\r\nlimits_{j=i}^n f(a[i..j]).\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++){\n    cin >> a[i];\n  }\n  long long ans = 0;\n  for (int i = 0; i < n; i++){\n    if (a[i] == 0){\n      ans += (long long) (i + 1) * (n - i);\n    }\n  }\n  vector<array<int, 11>> P(4);\n  P[0] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n  P[1] = {1, 1, 7, 1, 4, 4, 10, 7, 9, 9, 10};\n  P[2] = {2, 4, 2, 2, 4, 6, 6, 7, 7, 10, 10};\n  P[3] = {3, 3, 3, 3, 5, 5, 5, 8, 8, 8, 10};\n  vector<int> L = {0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3};\n  vector<vector<long long>> dp(n + 1, vector<long long>(11, 0));\n  for (int i = 0; i < n; i++){\n    dp[i][0]++;\n    for (int j = 0; j < 11; j++){\n      dp[i + 1][P[a[i]][j]] += dp[i][j];\n    }\n  }\n  for (int i = 1; i <= n; i++){\n    for (int j = 0; j < 11; j++){\n      ans += dp[i][j] * L[j];\n    }\n  }\n  cout << ans << endl;\n}"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures", "divide and conquer", "dp", "two pointers"], "dificulty": "2300", "interactive": false}