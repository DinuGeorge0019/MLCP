{
    "link": "https://codeforces.com//contest/1418/problem/F",
    "problemId": "727428",
    "problem_idx": "F",
    "shortId": "1418F",
    "contest_number": "1418",
    "problem_submissions": {
        "F": [
            92827621,
            92992766,
            92847130,
            92847007,
            92846498,
            92840659,
            92838710,
            92837329,
            92835778,
            92821703,
            92839298,
            92833921,
            92885700,
            92870799,
            92830172,
            92989347,
            92845726
        ],
        "G": [
            92817256,
            93890104,
            93890054,
            93890004,
            93889956,
            93889783,
            93889650,
            93889392,
            93889084,
            93888189,
            93888010,
            93887834,
            93887831,
            93887519,
            93887334,
            93887004,
            93839244,
            93839240,
            93839237,
            93835786,
            93835763,
            93835704,
            93828053,
            93828000,
            92855419,
            92854972,
            92815447,
            92815164,
            92824652,
            92823576,
            92837977,
            92824758,
            92885721,
            92823789,
            92823462,
            92820493,
            92830232,
            93485501,
            92866692,
            92833116,
            92832754,
            92824217,
            92833610,
            92830510,
            92833625,
            92828988,
            92837204,
            92830405,
            92834428
        ],
        "A": [
            92809737,
            92851684,
            92804370,
            92802575,
            92799307,
            92799729,
            92800647,
            92885635,
            92800218,
            92800425,
            92802031,
            92799884,
            92800952,
            92799036,
            92800270,
            92799895,
            92801328,
            92799861,
            92800242,
            92800050,
            92800040,
            92801512
        ],
        "D": [
            92806930,
            92847621,
            92803255,
            92806570,
            92812108,
            92817724,
            92809504,
            92885678,
            92808863,
            92812638,
            92810774,
            92842221,
            92815078,
            92815207,
            92817058,
            92813567,
            92813334,
            92817631,
            92827883,
            92813906,
            92816619,
            92816135,
            92820186
        ],
        "E": [
            92805758,
            92809090,
            92809687,
            92815513,
            92824046,
            92816662,
            92885694,
            92814615,
            92816908,
            92930467,
            92820677,
            92822734,
            92822919,
            92819310,
            92822831,
            92824275,
            92815296,
            92836469,
            92823732,
            92819866,
            92826009
        ],
        "C": [
            92798839,
            92798564,
            92801110,
            92802769,
            92810140,
            92803375,
            92885666,
            92803075,
            92805736,
            92801242,
            92805901,
            92804239,
            92807896,
            92805622,
            92804878,
            92809071,
            92805265,
            92806697,
            92803772,
            92811897,
            92812555
        ],
        "B": [
            92797501,
            92797816,
            92799405,
            92798968,
            92805443,
            92800263,
            92885648,
            92799516,
            92803590,
            92799029,
            92802282,
            92800352,
            92804945,
            92826085,
            92800306,
            92804932,
            92801700,
            92803543,
            92799506,
            92808871,
            92806614
        ]
    },
    "name": "F. Equal Product",
    "statement": "You are given four integers n, m, l and r.Let\u2019s name a tuple (x_1, y_1,\r\nx_2, y_2) as if: 1\r\nle x_1 < x_2\r\nle n; 1\r\nle y_2 < y_1\r\nle m; x_1\r\ncdot y_1 = x_2\r\ncdot y_2; l\r\nle x_1\r\ncdot y_1\r\nle r. Find any good tuple .\r\n",
    "solutions": [
        "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\n\nconst int N=200005;\n\nset<int>now;\nset<int>::iterator it;\nVI g[N];\nint cnt[N];\nint n,m,lasL,lasR;LL l,r;\n\nsigned main(){\n\trd(n);rd(m);rd(l);rd(r);\n\trep(i,1,200000)for(int j=i;j<=200000;j+=i)g[j].PB(i);\n\tlasL=m+1;lasR=m;\n\trep(i,1,n){\n\t\tLL L=(l-1)/i+1,R=r/i;\n\t\twhile(lasL>L){\n\t\t\t--lasL;\n\t\t\trep(j,0,SZ(g[lasL])-1){\n\t\t\t\tint d=g[lasL][j];\n\t\t\t\tif(cnt[d]==0)now.insert(d);\n\t\t\t\t++cnt[d];\n\t\t\t}\n\t\t}\n\t\twhile(lasR>R){\n\t\t\trep(j,0,SZ(g[lasR])-1){\n\t\t\t\tint d=g[lasR][j];\n\t\t\t\t--cnt[d];\n\t\t\t\tif(cnt[d]==0)now.erase(d);\n\t\t\t}\n\t\t\t--lasR;\n\t\t}\n\t\tbool ok=0;\n\t\trep(j,0,SZ(g[i])-1){\n\t\t\tint d=g[i][j],t1=i/d;\n\t\t\tit=now.upper_bound(t1);\n\t\t\tif(it!=now.end()&&*it<=n/d){\n\t\t\t\tok=1;\n\t\t\t\tint tmp=((L-1)/(*it)+1)*(*it);\n\t\t\t\tpt(i,' ');pt(tmp,' ');pt(d*(*it),' ');pt(1ll*i*tmp/d/(*it),'\\n');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)pt(-1,'\\n');\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "number theory",
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Equal Product.json",
    "editorial_link": "https://codeforces.com//blog/entry/82673",
    "editorial": "Let\u00e2\u0080\u0099s look at where . It can be proven that there always exists such\r\npair (, and ) that and .Brief proof is following: calculate , then let\r\nand . Obviously, such will make from and from (if ). And since and since\r\n.As we can see divides , so if we will iterate over all pairs where\r\nthere will be pairs in total.Let\u00e2\u0080\u0099s fix value of . Then, from one side,\r\nbut, from the other side, since , then . Anyway, all valid form a\r\nsegment (possibly, empty segment). And we need to find any that divides\r\nany from the segment and doesn\u00e2\u0080\u0099t exceed . Obviously, it\u00e2\u0080\u0099s optimally to\r\nfind the minimum possible such and just check inequality .We can find\r\nsuch for a fixed using, for example, built-in in a set with all divisors\r\nfor all valid . To maintain this set we can note that (simillary, ). So\r\nwe can move valid segment\u00e2\u0080\u0099s ends as two pointers.Each pair will be added\r\nand erased from the segment exactly once. That\u00e2\u0080\u0099s why the total\r\ncomplexity of maintaining the set of divisors (as well as the total\r\ncomplexity of queries for each ) will be equal to .All pairs (and ) can\r\nbe precalculated in using the sieve-like algorithm.\r\n"
}