{
    "link": "https://codeforces.com//contest/985/problem/D",
    "problemId": "184585",
    "problem_idx": "D",
    "shortId": "985D",
    "contest_number": "985",
    "problem_submissions": {
        "G": [
            38542149,
            38512186,
            38512236,
            38513581,
            38508155,
            38634852,
            38634344,
            38634277,
            38515048
        ],
        "F": [
            38499146,
            38499001,
            38501533,
            38502149,
            44969812,
            38501168,
            38505525,
            38502880,
            38530512,
            38499950,
            38499753,
            38505154,
            38503491,
            38504126,
            38510981,
            38505877,
            38504312,
            38507584,
            38509250,
            38506993,
            38507253
        ],
        "E": [
            38493702,
            38497357,
            38497944,
            38499266,
            38496305,
            38496738,
            38500977,
            38502378,
            38496622,
            38497691,
            38498718,
            38497100,
            38498488,
            38496555,
            38502188,
            38501286,
            38496578,
            38488837,
            38503513,
            38500067,
            38501389
        ],
        "D": [
            38491674,
            38495666,
            38493742,
            38495486,
            38495900,
            38495531,
            38494634,
            38495573,
            38493765,
            38502434,
            38497951,
            38500032,
            38496113,
            38498092
        ],
        "C": [
            38489266,
            38490508,
            38491062,
            38490764,
            38489327,
            38492089,
            38489607,
            38491317,
            38489050,
            38492258,
            38493205,
            38490810,
            38490379,
            38491131,
            38492401,
            38495949,
            38492200,
            38493338,
            38495062
        ],
        "B": [
            38486666,
            38488118,
            38487524,
            38488045,
            38487258,
            38487260,
            38487379,
            38487785,
            38486818,
            38488660,
            38487046,
            38487281,
            38487622,
            38487410,
            38487870,
            38578001,
            38491648,
            38488972,
            38488613,
            38488764
        ],
        "A": [
            38486349,
            38486599,
            38486409,
            38487064,
            38486426,
            38486427,
            38486493,
            38486415,
            38486362,
            38487242,
            38486378,
            38489634,
            38486554,
            38486364,
            38486402,
            38577942,
            38487704,
            38486613,
            38486447,
            38487421
        ]
    },
    "name": "D. Sand Fortress",
    "statement": "You are going to the beach with the idea to build the greatest sand\r\ncastle ever in your head! The beach is not as three-dimensional as you\r\ncould have imagined, it can be decribed as a line of spots to pile up\r\nsand pillars. Spots are numbered through infinity from left to right.\r\nObviously, there is not enough sand on the beach, so you brought packs\r\nof sand with you. Let height of the sand pillar on some spot be the\r\nnumber of sand packs you spent on it. There is a fence of height equal\r\nto the height of pillar with sand packs to the left of the first spot\r\nand you should prevent sand from going over it. Finally you ended up\r\nwith the following conditions to building the castle: : no sand from the\r\nleftmost spot should go over the fence; For any : large difference in\r\nheights of two neighboring pillars can lead sand to fall down from the\r\nhigher one to the lower, you really don\u2019t want this to happen; : you\r\nwant to spend all the sand you brought with you. As you have infinite\r\nspots to build, it is always possible to come up with some valid castle\r\nstructure. Though you want the castle to be as compact as possible. Your\r\ntask is to calculate the minimum number of spots you can occupy so that\r\nall the aforementioned conditions hold.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nll n,H;\n\nld mx(ll mid) {\n    // 1 to mid \n    // H-1+x \n    // mid+1-x\n    // 2x = H+mid+2 \n    ll x = max((mid-H+2)/2,0LL);\n    // mid-x to 1 \n    return (ld)x*(H+H-1+x)/2+(ld)(mid-x)*(mid-x+1)/2;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> H;\n    ll lo = 1, hi = 10LL*MOD;\n    while (lo < hi) {\n        ll mid = (lo+hi)/2;\n        if (mx(mid) >= n) hi = mid;\n        else lo = mid+1;\n    }\n    cout << lo;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Sand Fortress.json",
    "editorial_link": "https://codeforces.com//blog/entry/59623",
    "editorial": "Let\u00e2\u0080\u0099s consider the optimal answer to always look like will be the\r\nleftmost position of a pillar with maximum height. We will heavily use\r\nthe fact that all integers from to appear in this sequence to the right\r\nof .If you are able to construct any answer, it is easy to rearrange it\r\nto this pattern: select the leftmost maximum , sort in non-decreasing\r\norder and in non-increasing order. Sorted sequence will also be\r\nvalid.Let a pyramid of height be such a valid castle that it occupies\r\nexactly consecutive spots and . Exactly sand packs are required to build\r\nit.At first let\u00e2\u0080\u0099s solve the problem without even touching the fence.\r\nThis won\u00e2\u0080\u0099t always give the minimal answer but it\u00e2\u0080\u0099ll help us further.\r\nGiven some you can build the pyramid of height and get sand packs left\r\nover. This can fit in exactly pillars (you can place any pillar of\r\nheight next to some pillar of the same height). That way we see that .\r\nThis function is non-increasing, let\u00e2\u0080\u0099s show that for any from to is\r\nnon-positive. = = = = = = . .Now we can show that it is always optimal\r\nto push the initial pyramid to the left as far as possible, probably\r\nremoving some pillars on positions less than . That way the leftmost\r\npillar will have height . The total number of sand packs required to\r\nbuild it is . This pattern will also include all the integers from to\r\nand will have the minimal width you can achieve. Monotonicity of this\r\nfunction can be proven in the similar manner.Finally, the answer can be\r\ncalculated using the following algorithm: Find the maximum such that ,\r\nwhere . Solve the equation or just do the binary search; Output the\r\nwidth of resulting truncated pyramid plus the minimal number of\r\nadditional pillars it will take to distribute leftover sand packs. You\r\nshould also take into consideration the upper bound on to avoid\r\nmultiplying huge numbers. It\u00e2\u0080\u0099s about , so -bit integer type will be\r\nenough for all the calculations.Overall complexity: or .\r\n"
}