{
    "link": "https://codeforces.com//contest/1821/problem/B",
    "problemId": "1887928",
    "problem_idx": "B",
    "shortId": "1821B",
    "contest_number": "1821",
    "problem_submissions": {
        "F": [
            202874134,
            202859904,
            202858229,
            202861559,
            202872887,
            202859974,
            202856919,
            202868327,
            202882475,
            202876779,
            202870359,
            202879197,
            202869342,
            202883580,
            202880852,
            203770664,
            202876913,
            202876748,
            202875057,
            202875004,
            202878771,
            202874220,
            202869665
        ],
        "E": [
            202851078,
            202851207,
            202852651,
            202845029,
            202854281,
            202869953,
            202852432,
            202850529,
            202858695,
            202849198,
            202862275,
            202850037,
            202856111,
            202863740,
            202868777,
            202865633,
            202858626,
            202863992,
            202876455
        ],
        "D": [
            202839910,
            202837788,
            202840967,
            202837261,
            202846749,
            202839594,
            202843601,
            202842780,
            202848113,
            202843851,
            202849914,
            202836012,
            202848152,
            202848821,
            202851217,
            202856400,
            202848668,
            202853904,
            202847149
        ],
        "C": [
            202829555,
            202830560,
            202832642,
            202830912,
            202836849,
            202832172,
            202834957,
            202827979,
            202831432,
            202832058,
            202834744,
            202833738,
            202834719,
            202831454,
            202838345,
            202836024,
            202839448,
            202842531,
            202836507
        ],
        "B": [
            202826167,
            202826238,
            202826386,
            202826297,
            202828596,
            202827059,
            202829521,
            202825674,
            202826732,
            202829400,
            202829530,
            202825769,
            202828359,
            202826421,
            202828754,
            202830182,
            202834397,
            202837813,
            202832744
        ],
        "A": [
            202824330,
            202824182,
            202824201,
            202824170,
            202825451,
            202824300,
            202825020,
            202824095,
            202824581,
            202824237,
            202824979,
            202824089,
            202824602,
            202824298,
            202824347,
            202824916,
            202826157,
            202824991,
            202825871
        ]
    },
    "name": "B. Sort the Subarray",
    "statement": "Monocarp had an array a consisting of n integers. He has decided to\r\nchoose two integers l and r such that 1\r\nle l\r\nle r\r\nle n, and then sort the subarray a[l..r] (the subarray a[l..r] is the\r\npart of the array a containing the elements a_l, a_{l+1}, a_{l+2},\r\ndots, a_{r-1}, a_r) in . After sorting the subarray, Monocarp has\r\nobtained a new array, which we denote as a\u2019.For example, if a = [6, 7,\r\n3, 4, 4, 6, 5], and Monocarp has chosen l = 2, r = 5, then a\u2019 = [6, 3,\r\n4, 4, 7, 6, 5].You are given the arrays a and a\u2019. Find the integers l\r\nand r that Monocarp could have chosen. If there are multiple pairs of\r\nvalues (l, r), find the one which .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=300005,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        int N;cin>>N;\n        vector<int> A(N),B(N);\n        int L=INF,R=-INF;\n        for(int i=0;i<N;i++) cin>>A[i];\n        for(int i=0;i<N;i++) cin>>B[i];\n        for(int i=0;i<N;i++){\n            if(A[i]!=B[i]){\n                chmin(L,i);\n                chmax(R,i);\n            }\n        }\n        int mi=INF,ma=-INF;\n        for(int i=L;i<=R;i++){\n            chmin(mi,A[i]);\n            chmax(ma,A[i]);\n        }\n        for(int i=L-1;i>=0;i--){\n            if(B[i]<=B[i+1]) L--;\n            else break;\n        }\n        \n        for(int i=R+1;i<N;i++){\n            if(B[i]>=B[i-1]) R++;\n            else break;\n        }\n        cout<<L+1<<\" \"<<R+1<<\"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Sort the Subarray.json",
    "editorial_link": "https://codeforces.com//blog/entry/115296",
    "editorial": "Let\u00e2\u0080\u0099s find the leftmost and the rightmost position in which the arrays\r\nand differ. Since only the elements in the chosen subsegment might\r\nchange, the subarray we sorted should contain these two positions.Let\u00e2\u0080\u0099s\r\nstart with the subarray from the leftmost \"different\" position to the\r\nrightmost one, and then expand it to get the longest subarray which\r\nmeets the conditions. Suppose we want to expand it to the left. Let the\r\ncurrent left border be ; how to decide if we can make it or less? If ,\r\nthen we cannot include in the subarray we sort, since otherwise the\r\norder of these two elements would have changed. Otherwise, is not\r\ngreater than any element in the subarray we have chosen, so we can\r\ninclude it and reduce by . We do this until it\u00e2\u0080\u0099s impossible to reduce\r\nfurther.The same goes for the right border: we expand it to the right\r\nuntil we find an element which is less than the previous element, and we\r\ncannot include this element in the subarray.\r\n"
}