{
    "link": "https://codeforces.com//contest/1366/problem/B",
    "problemId": "646800",
    "problem_idx": "B",
    "shortId": "1366B",
    "contest_number": "1366",
    "problem_submissions": {
        "F": [
            83447668,
            83448434,
            83444622,
            83426763,
            83441574,
            83428280,
            83460965,
            83423891,
            83442353,
            83757770,
            83445090,
            83429919,
            83438895,
            83437207,
            83492622,
            83492442,
            83474062,
            83453556,
            83447806
        ],
        "G": [
            83429184,
            83428882,
            83457684,
            83412158,
            83433864,
            83437984,
            83494857,
            83757790,
            83510645,
            83444271,
            83455262,
            83440823,
            83444943,
            83578671,
            83450093
        ],
        "E": [
            83398532,
            83418602,
            83409360,
            83402434,
            83412489,
            83410962,
            83757722,
            83418361,
            83408316,
            83407997,
            83427080,
            83413277,
            83416924,
            83424580,
            83418188,
            83406625,
            83420403,
            83421638
        ],
        "D": [
            83393167,
            83406995,
            83402251,
            83397827,
            83397479,
            83404641,
            83397199,
            83402779,
            83757690,
            83407778,
            83401287,
            83402226,
            83406676,
            83407995,
            83406280,
            83407838,
            83409402,
            83421660,
            83414839,
            83414935
        ],
        "C": [
            83390782,
            83401605,
            83394916,
            83391593,
            83392337,
            83394149,
            83393867,
            83397548,
            83757664,
            83394207,
            83391231,
            83395559,
            83398133,
            83401855,
            83400985,
            83402206,
            83402544,
            83397821,
            83396193,
            83400630
        ],
        "B": [
            83389935,
            83490415,
            83397273,
            83390226,
            83389902,
            83389999,
            83390997,
            83390624,
            83757653,
            83390343,
            83389925,
            83392810,
            83391891,
            83392040,
            83392753,
            83394886,
            83392865,
            83391554,
            83391226,
            83391686
        ],
        "A": [
            83389637,
            83390640,
            83389645,
            83389626,
            83389634,
            83389655,
            83389755,
            83757620,
            83389748,
            83389663,
            83390083,
            83389875,
            83389821,
            83390216,
            83392108,
            83390187,
            83390121,
            83389679,
            83389858
        ]
    },
    "name": "B. Shuffle",
    "statement": "You are given an array consisting of n integers a_1, a_2, ..., a_n.\r\nInitially a_x = 1, all other elements are equal to 0.You have to perform\r\nm operations. During the i-th operation, you choose two indices c and d\r\nsuch that l_i\r\nle c, d\r\nle r_i, and swap a_c and a_d.Calculate the number of indices k such that\r\nit is possible to choose the operations so that a_k = 1 in the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, x, m;\n\tcin >> n >> x >> m;\n\tx--;\n\tint l = x;\n\tint r = x;\n\tfor(int i = 0; i < m; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tif(b < l || r < a) continue;\n\t\tl = min(l, a);\n\t\tr = max(r, b);\n\t}\n\tcout << r - l + 1 << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Shuffle.json",
    "editorial_link": "https://codeforces.com//blog/entry/78735",
    "editorial": "Let\u00e2\u0080\u0099s consider how the set of possible indices where the can be changes.\r\nInitially, only one index is correct . After performing an operation\r\nsuch that or this set does not change. But after performing an operation\r\nsuch that we should insert the elements into this set, if they are not\r\npresent. Now consider how the set changes. If segments and do not share\r\nany indices, there are no changes but if they do, the set turns into .So\r\nthe set of reachable indices is always a segment of numbers, and to\r\nprocess an operation, we should check whether the segment from operation\r\nintersects with the segment of indices we have and if it is true, unite\r\nthem.\r\n"
}