{
    "link": "https://codeforces.com//contest/962/problem/G",
    "problemId": "173208",
    "problem_idx": "G",
    "shortId": "962G",
    "contest_number": "962",
    "problem_submissions": {
        "G": [
            37172159,
            83380479,
            37224207
        ],
        "F": [
            37161607,
            37156639,
            37157368,
            37160858,
            37168373,
            37163241,
            37162662,
            37165808,
            37164621,
            37171463,
            37169577,
            37166104,
            37163342,
            37173342,
            37165989,
            37161726,
            37173135,
            37178620
        ],
        "E": [
            37153541,
            37151735,
            37153606,
            37152970,
            37152043,
            37166043,
            37160792,
            37170495,
            37160553,
            37168665,
            37158596,
            37163761,
            37162634,
            37170755,
            37158513,
            37157137,
            37165223,
            37172878,
            37170948,
            37159083,
            37152437
        ],
        "D": [
            37152390,
            37151214,
            37151627,
            37153937,
            37156427,
            37155745,
            37155575,
            37154679,
            37154153,
            37157155,
            37157760,
            37157154,
            37160470,
            37158892,
            37157799,
            37158412,
            37156233,
            37151441
        ],
        "C": [
            37150680,
            37149822,
            37150471,
            37152075,
            37154129,
            37152922,
            37153000,
            37151382,
            37151999,
            37153115,
            37152133,
            37154853,
            37152337,
            37154136,
            37153887,
            37154222,
            37150166
        ],
        "B": [
            37148859,
            37148433,
            37150807,
            37150329,
            37150353,
            37151339,
            37150005,
            37149509,
            37149604,
            37150809,
            37150669,
            37150725,
            37163838,
            37150528,
            37151572,
            37173974,
            37149032
        ],
        "A": [
            37147366,
            37147343,
            37147362,
            37147371,
            37147659,
            37147394,
            37147434,
            37147365,
            37147570,
            37147605,
            37147447,
            37147530,
            37147430,
            37147619,
            37147410,
            37174371,
            37147400
        ]
    },
    "name": "G. Visible Black Areas",
    "statement": "Petya has a polygon consisting of n vertices. All sides of the Petya\u2019s\r\npolygon are parallel to the coordinate axes, and each two adjacent sides\r\nof the Petya\u2019s polygon are perpendicular. It is guaranteed that the\r\npolygon is simple, that is, it doesn\u2019t have self-intersections and\r\nself-touches. All internal area of the polygon (borders are not\r\nincluded) was painted in black color by Petya.Also, Petya has a\r\nrectangular window, defined by its coordinates, through which he looks\r\nat the polygon. A rectangular window can not be moved. The sides of the\r\nrectangular window are parallel to the coordinate axes. Determine the\r\nnumber of black connected areas of Petya\u2019s polygon, which can be seen\r\nthrough the rectangular window.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ], nex=0;\n    DSU() {\n        F0R(i,SZ) par[i] = i, sz[i] = 1;\n    }\n    \n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n    \n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tif (sz[x] < sz[y]) swap(x,y);\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<100001> D;\n\nint n,ans;\npi X,Y;\npi p[15000];\nvpi v[15001];\nset<pair<pi,int>> cur;\n\npair<pi,int> mergeLeft(int ind, pair<pi,int> z) {\n    // last one with second <= z.f \n    auto it = cur.ub(z);\n    if (it != cur.end() && it->f.f == z.f.s) {\n        ans -= D.unite(it->s,z.s);\n        z.f.s = it->f.s;\n        cur.erase(it);\n    }\n    return z;\n}\n\npair<pi,int> mergeRight(int ind, pair<pi,int> z) {\n    auto it = cur.ub(z);\n    if (it != cur.begin() && prev(it)->f.s == z.f.f) {\n        it = prev(it);\n        ans -= D.unite(it->s,z.s);\n        z.f.f = it->f.f;\n        cur.erase(it);\n    }\n    return z;\n}\n\nvoid mod(int ind, pi t) {\n    auto a = cur.ub({{t.f,MOD},MOD});\n    if (a != cur.begin() && prev(a)->f.s >= t.s) {\n        auto A = *prev(a); cur.erase(A);\n        if (A.f.f < t.f) cur.insert({{A.f.f,t.f},A.s});\n        if (t.s < A.f.s) cur.insert({{t.s,A.f.s},A.s});\n    } else {\n        pair<pi,int> z = mp(t,D.nex++); if (ind <= X.s) ans ++;\n        z = mergeLeft(ind,z);\n        z = mergeRight(ind,z);\n        cur.insert(z);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> X.f >> X.s >> Y.f >> Y.s;\n    cin >> n;\n    F0R(i,n) cin >> p[i].f >> p[i].s; // only horizontal\n    F0R(i,n) if (p[i].s == p[(i+1)%n].s) {\n        pi z = {p[i].f,p[(i+1)%n].f};\n        if (z.f > z.s) swap(z.f,z.s);\n        z.f = max(z.f,X.f); z.s = min(z.s,Y.f);\n        if (z.f < z.s) v[p[i].s].pb(z);\n    }\n    F0Rd(i,15001) {\n        if (i == Y.s) {\n            cout << ans;\n            return 0;\n        }\n        for (auto t: v[i]) {\n            mod(i,t);\n        }\n        if (i == X.s) {\n            D = DSU<100001>();\n            ans = 0;\n            \n            set<pair<pi,int>> CUR;\n            for (auto t: cur) {\n                CUR.insert({t.f,D.nex++});\n                ans ++;\n            }\n            cur = CUR;\n            // for (auto a: CUR) cout << a.f.f << \" \" << a.f.s << \"\\n\";\n            // cout << \"HI \" << ans << \" \" << i << \"\\n\";\n        } \n    }\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "geometry",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Visible Black Areas.json",
    "editorial_link": "https://codeforces.com//blog/entry/58869",
    "editorial": "First, lets build a graph that represents only part of the polygon that\r\nis inside the window, as well as borders of the window. Do do this, for\r\neach segment of the polygon, find the intersection of that segment with\r\nthe window, and, if it still is a segment with non-zero length, add it\r\nto the graph (add both endpoints as vertices and the segment itself as\r\nan edge). Next, add four corners of the window as vertices. Last,\r\nconnect all the points on each of the four borders of the window with\r\nedges.This way, we have a planar graph, and we can find faces in this\r\ngraph which will represent all the connected areas inside the window,\r\nboth belonging to the polygon and not. To count only those that belong\r\nto the polygon one can mark those oriented edges, that were created\r\nwhile intersecting polygon\u00e2\u0080\u0099s segments with the window, as important.\r\nOnly mark an edge if it is directed the same way as the corresponding\r\nsegment of the polygon. This way, those faces of the graph that are to\r\nthe left of important edges, are the ones belonging to the polygon.But\r\nthere is one bad case when no segment of the polygon intersects with the\r\nwindow. It such case, the window is either entirely outside of the\r\npolygon, or entirely inside of it. To check this, find number of\r\nintersections of the polygon with a ray starting from inside of the\r\nwindow. If the number of intersections is even, the window is outside of\r\nthe polygon. If it is odd, the window is outside.\r\n"
}