{
    "link": "https://codeforces.com//contest/1452/problem/E",
    "problemId": "802108",
    "problem_idx": "E",
    "shortId": "1452E",
    "contest_number": "1452",
    "problem_submissions": {
        "F": [
            98942480,
            98939437,
            98940434,
            106494164,
            106494140,
            98942341,
            98945383,
            98935697,
            98927001,
            98944945,
            98934044,
            98976764,
            99270253
        ],
        "E": [
            98926708,
            98926305,
            98923150,
            98930994,
            98926114,
            98927253,
            98926662,
            99001021,
            98943947,
            99042260,
            98926234,
            98930834,
            98943700,
            98921374,
            98925742,
            98930269,
            98929950,
            98918489,
            98928745,
            98929548
        ],
        "D": [
            98906301,
            98909937,
            98915472,
            98909763,
            98919427,
            98912085,
            99000804,
            98903628,
            98909739,
            98911723,
            98911927,
            98913556,
            98901042,
            98908884,
            98907045,
            98910263,
            98910231,
            98913804,
            98909129
        ],
        "C": [
            98899318,
            98901635,
            98905651,
            98903381,
            98906519,
            98900085,
            98896987,
            98906559,
            98901684,
            98905788,
            98906611,
            98898047,
            98901391,
            98899348,
            98900377,
            98902439,
            98902965,
            98898261
        ],
        "B": [
            98897777,
            98898220,
            98901029,
            98900303,
            98904013,
            98898005,
            99000726,
            99000688,
            98978607,
            98898951,
            98904401,
            98905057,
            98908639,
            98904166,
            98896699,
            98898174,
            98897853,
            98902989,
            98899546,
            98900510,
            98903751
        ],
        "A": [
            98895449,
            98895686,
            98896660,
            98896462,
            98897246,
            98895467,
            98895360,
            98896351,
            100779606,
            98895507,
            98904547,
            98896942,
            98895363,
            98895604,
            98895575,
            98895460,
            98903659,
            98895637,
            98896531
        ],
        "G": [
            99251139,
            98943421,
            99550385,
            99358496,
            99358463,
            99358399,
            99296629,
            99296419,
            99053359,
            99052180,
            98944458,
            98945555,
            99287849
        ]
    },
    "name": "E. Two Editorials",
    "statement": "Berland regional ICPC contest has just ended. There were m participants\r\nnumbered from 1 to m, who competed on a problemset of n problems\r\nnumbered from 1 to n.Now the editorial is about to take place. There are\r\ntwo problem authors, each of them is going to tell the tutorial to of\r\nthe problemset. The authors choose the segment of k consecutive tasks\r\nfor themselves independently of each other. The segments can coincide,\r\nintersect or not intersect at all.The i-th participant is interested in\r\nlistening to the tutorial of all consecutive tasks from l_i to r_i. Each\r\nparticipant always chooses to listen to only the problem author that\r\ntells the tutorials to the maximum number of tasks he is interested in.\r\nLet this maximum number be a_i. No participant can listen to both of the\r\nauthors, even if their segments don’t intersect.The authors want to\r\nchoose the segments of k consecutive tasks for themselves in such a way\r\nthat the sum of a_i over all participants is maximized.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Z = 2200;\n\nint N, M, K;\nint L[2020];\nint R[2020];\n\nstruct NODE {\n\tint lz, sum;\n};\n\nstruct SegTree {\n\tNODE T[4 * 5050];\n\n\tvoid init(int idx, int s, int e) {\n\t\tT[idx].lz = T[idx].sum = 0;\n\t\tif(s == e) return;\n\t\tint m = s + e >> 1;\n\t\tinit(idx << 1, s, m);\n\t\tinit(idx << 1 | 1, m + 1, e);\n\t}\n\n\tvoid init() { init(1, 1, N + Z); }\n\n\tvoid propa(int idx, int s, int e) {\n\t\tT[idx].sum += (e - s + 1) * T[idx].lz;\n\t\tif(s != e) {\n\t\t\tT[idx << 1].lz += T[idx].lz;\n\t\t\tT[idx << 1 | 1].lz += T[idx].lz;\n\t\t}\n\t\tT[idx].lz = 0;\n\t}\n\n\tvoid upd(int idx, int s, int e, int p, int q, int x) {\n\t\tpropa(idx, s, e);\n\t\tif(q < p || q < s || e < p) return;\n\t\tif(p <= s && e <= q) {\n\t\t\tT[idx].lz += x;\n\t\t\tpropa(idx, s, e);\n\t\t\treturn;\n\t\t}\n\t\tint m = s + e >> 1;\n\t\tupd(idx << 1, s, m, p, q, x);\n\t\tupd(idx << 1 | 1, m + 1, e, p, q, x);\n\t\tT[idx].sum = T[idx << 1].sum + T[idx << 1 | 1].sum;\n\t}\n\n\tint get(int idx, int s, int e, int p, int q) {\n\t\tpropa(idx, s, e);\n\t\tif(q < p || q < s || e < p) return 0;\n\t\tif(p <= s && e <= q) return T[idx].sum;\n\t\tint m = s + e >> 1;\n\t\treturn get(idx << 1, s, m, p, q) + get(idx << 1 | 1, m + 1, e, p, q);\n\t}\n\n\tvoid upd(int p, int q, int x) { upd(1, 1, N + Z, max(1, p + Z), min(q + Z, N + Z), x); }\n\tint query(int i) {\n\t\treturn get(1, 1, N + Z, 1, i + Z);\n\t}\n}seg;\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\tfor(int i = 1; i <= M; i++) scanf(\"%d%d\", &L[i], &R[i]);\n\tint ans = 0;\n\tfor(int i = 1; i <= N - K + 1; i++) {\n\t\tint l = i, r = i + K - 1;\n\t\tint add = 0;\n\t\tseg.init();\n\t\tfor(int j = 1; j <= M; j++) {\n\t\t\tbool ok = false;\n\t\t\tif(l <= L[j] && R[j] <= r) ok = true;\n\t\t\tif(L[j] <= l && r <= R[j]) ok = true;\n\t\t\tif(ok) { add += min(R[j] - L[j] + 1, K); continue; }\n\n\t\t\tif(R[j] < l || r < L[j]) {\n\t\t\t\tif(R[j] - L[j] + 1 >= K) {\n\t\t\t\t\tseg.upd(L[j] - K + 1, L[j], 1);\n\t\t\t\t\tseg.upd(R[j] - K + 2, R[j] + 1, -1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tseg.upd(L[j] - K + 1, R[j] - K + 1, 1);\n\t\t\t\t\tseg.upd(L[j] + 1, R[j] + 1, -1);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint t = min(R[j] - l, r - L[j]) + 1;\n\t\t\tadd += t;\n\t\t\tif(R[j] - L[j] + 1 >= K) {\n\t\t\t\tseg.upd(L[j] - (K - t) + 1, L[j], 1);\n\t\t\t\tseg.upd(R[j] - K + 2, R[j] - t + 1, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tseg.upd(L[j] - (K - t) + 1, R[j] - K + 1, 1);\n\t\t\t\tseg.upd(L[j] + 1, R[j] - t + 1, -1);\n\t\t\t}\n\t\t}\n\n\t\tint mx = 0;\n\t\tfor(int j = 1; j <= N; j++) mx = max(mx, seg.query(j));\n\t\t// printf(\"%d %d %d\\n\", i, add, mx);\n\t\tans = max(ans, mx + add);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Two Editorials.json",
    "editorial_link": "https://codeforces.com//blog/entry/84847",
    "editorial": "Consider some participantâs segment and one of the authorâs segment .\r\nHow does the length of intersection change when you move from left to\r\nright? It first increases until the centers of both segments coincide\r\n(thatâs the easiest to notice on the segments of the same length) and\r\nthen decreases. The increase is totally symmetrical to the decrease.With\r\nthat idea you can conclude that the authorâs segment, whose center is\r\nthe closest to the center of participantâs segment, has the larger\r\nintersection length.Letâs sort the participantsâ segments by their\r\ncenter. You can see that the first author will be optimal for the prefix\r\nof the segments and the second author for the remaining suffix.So you\r\ncan just iterate over the length of the prefix and update the answer\r\nwith all options.Overall complexity: .\r\n",
    "hint": []
}