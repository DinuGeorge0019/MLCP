{
    "link": "https://codeforces.com//contest/1644/problem/D",
    "problemId": "1306305",
    "problem_idx": "D",
    "shortId": "1644D",
    "contest_number": "1644",
    "problem_submissions": {
        "F": [
            147320866,
            147353077,
            147335774,
            147336779,
            147338284,
            147344072,
            147361395,
            147361328,
            147360591,
            147341020,
            147347713,
            147363763,
            147363723,
            147322590,
            152772960,
            147359576,
            147689521
        ],
        "E": [
            147306717,
            147306569,
            147311348,
            147309095,
            147307844,
            147307929,
            147314427,
            147326156,
            147310695,
            147307982,
            147306896,
            147305676,
            147310587,
            147307037,
            147315289,
            147313121,
            147313445,
            147321773
        ],
        "D": [
            147293584,
            147307300,
            147301707,
            147294952,
            147298642,
            147298634,
            147300618,
            147333853,
            147291913,
            147295056,
            147298209,
            147295009,
            147295505,
            147297361,
            147296680,
            147301724,
            147303329,
            147296313
        ],
        "C": [
            147288888,
            147290549,
            147296803,
            147287863,
            147292950,
            147291474,
            147293826,
            147331175,
            147286835,
            147291088,
            147291894,
            147288455,
            147290620,
            147288872,
            147289111,
            147292816,
            147293660,
            147289532
        ],
        "B": [
            147281121,
            147281154,
            147291952,
            147280086,
            147282998,
            147283506,
            147285667,
            147332125,
            147281901,
            147282926,
            147283802,
            147281429,
            147284985,
            147282861,
            147283027,
            147287392,
            147286913,
            147282167
        ],
        "A": [
            147278514,
            147278406,
            147278697,
            147278304,
            147278969,
            147279113,
            147278307,
            147332805,
            147278673,
            147278387,
            147278783,
            147278331,
            147278464,
            147278483,
            147278302,
            147278920,
            147278819,
            147278413
        ]
    },
    "name": "D. Cross Coloring",
    "statement": "There is a sheet of paper that can be represented with a grid of size n\r\ntimes m: n rows and m columns of cells. All cells are colored in white\r\ninitially.q operations have been applied to the sheet. The i-th of them\r\ncan be described as follows: x_i y_i choose one of k non-white colors\r\nand color the entire row x_i and the entire column y_i in it. The new\r\ncolor is applied to each cell, regardless of whether the cell was\r\ncolored before the operation. The sheet after applying all q operations\r\nis called a coloring. Two colorings are different if there exists at\r\nleast one cell that is colored in different colors.How many different\r\ncolorings are there? Print the number modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    int n, m, k, q; cin>>n>>m>>k>>q;\n    vector<pair<int, int>> a(q);\n    for (int i = 0; i<q; i++)\n    {\n        cin>>a[i].first>>a[i].second;\n    }\n\n    set<int> x, y;\n    int cnt = 0;\n\n    for (int i = q-1; i>=0; i--)\n    {\n        bool have = false;\n        if (!x.count(a[i].first) && y.size()<m) have = true;\n        if (!y.count(a[i].second) && x.size()<n) have = true;\n\n        if (have) cnt++;\n\n        x.insert(a[i].first);\n        y.insert(a[i].second);\n    }\n\n    cout<<po(k, cnt)<<endl;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Cross Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/100227",
    "editorial": "Letâs take a look at a final coloring. Each cell has some color. There\r\nexist cells such that there were no operation in their row and their\r\ncolumn. They are left white, and they donât affect the answer.All other\r\ncells are colored in one of colors. For each cell there is a query that\r\nhas been the last one to color this cell (it covered row , column or\r\nboth of them). So all cells that have the same query as the last one\r\nwill have the same color. Since the color for each query is chosen\r\nindependently, the number of colorings will be to the power of the\r\nnumber of queries that have at least one cell belong to them.How to\r\ndetermine if a query has at least one cell. This is true unless one of\r\nthese things happen afterwards: both its row and its column are\r\nrecolored; all rows are recolored; all columns are recolored. So the\r\nsolution is to process the queries backwards. Maintain the set of\r\ncolored rows and colored columns. For each query, check the conditions.\r\nIf none hold, multiply the answer by .Overall complexity: or per\r\ntestcase.\r\n",
    "hint": []
}