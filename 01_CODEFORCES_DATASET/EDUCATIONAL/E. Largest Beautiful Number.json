{
    "link": "https://codeforces.com//contest/946/problem/E",
    "problemId": "162810",
    "problem_idx": "E",
    "shortId": "946E",
    "contest_number": "946",
    "problem_submissions": {
        "G": [
            36021661,
            36026384,
            36022849,
            36018588,
            36030003,
            36031880,
            36023496,
            36141030,
            36023713,
            36019743,
            36021921
        ],
        "F": [
            36016439,
            36010306,
            36011759,
            36017801,
            36015918,
            36015627,
            36017713,
            36012422,
            36018592,
            36017729,
            36020768,
            36016813,
            36019907,
            36021177,
            36017821,
            36021462
        ],
        "E": [
            36007161,
            36005953,
            36006973,
            36007671,
            36003744,
            36009603,
            36013999,
            36014555,
            36006191,
            36012983,
            36013994,
            36013308,
            36012827,
            36016281,
            36012410,
            36015253,
            36015878,
            36009347,
            36016909
        ],
        "D": [
            36001071,
            36002106,
            35999863,
            36001996,
            36001455,
            36003959,
            36005490,
            36004597,
            36014071,
            36007176,
            36006435,
            36007071,
            36005693,
            36006922,
            36007333,
            36006139,
            36006839,
            36019644,
            36007254
        ],
        "C": [
            35997922,
            35999476,
            35998023,
            35998548,
            35998939,
            35999238,
            36000359,
            35999969,
            35998896,
            36000616,
            36003485,
            36001243,
            36000192,
            36002608,
            35999675,
            36001749,
            36003789,
            35999684,
            36002661
        ],
        "B": [
            35996866,
            35998672,
            35996504,
            35997493,
            35996253,
            35997312,
            35998806,
            35998462,
            35998652,
            35999416,
            35998242,
            35998547,
            35997873,
            35998443,
            36000126,
            35998309,
            35998592,
            35998542
        ],
        "A": [
            35995800,
            35997505,
            35995802,
            35996074,
            35995799,
            35995844,
            35997767,
            35996078,
            35996606,
            35997456,
            35995903,
            35995883,
            35995904,
            35996096,
            35995831,
            35996261,
            35997282,
            35997134
        ]
    },
    "name": "E. Largest Beautiful Number",
    "statement": ".Let’s call a positive integer if its decimal representation without\r\nleading zeroes contains even number of digits, and there exists a\r\npermutation of this representation which is palindromic. For example, is\r\na beautiful number, since it contains digits, and there exists a\r\npalindromic permutation .Given a positive integer , find the largest\r\nbeautiful number which is less than .\r\n",
    "solutions": [
        "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=2e5+10;\nchar s[N],z[N];\nint n;\n\nbool solve( int p, array<int,10> c ) {\n    c[z[p]-'0']++;\n    dump(p,z,c);\n    {\n        int odd=0;\n        REP(i,10) if ( c[i]%2==1 ) odd++;\n        if ( odd>n-p-1 ) return 0;\n    }\n    REP1(i,p+1,n-1) {\n        int odd=0;\n        REP(j,10) if ( c[j]%2==1 ) odd++;\n        dump(i,odd,n-i);\n        if ( odd==n-i ) {\n            int o=9;\n            while ( o>=0 && c[o]%2==0 ) o--;\n            dump(o,c[o]);\n            assert(o>=0 && c[o]%2==1);\n            c[o]++;\n            z[i]=o+'0';\n        } else if ( odd<n-i ) {\n            c[9]++;\n            z[i]='9';\n        } else assert(0);\n    }\n    return 1;\n}\n\nbool solve( int p ) {\n    REP(i,p) z[i]=s[i];\n    array<int,10> c={};\n    REP(i,p) c[z[i]-'0']++;\n    for ( char d=s[p]-1; d>='0'; d-- ) {\n        if ( d=='0' && p==0 ) continue;\n        dump(d);\n        z[p]=d;\n        if ( solve(p,c) ) return 1;\n    }\n    return 0;\n}\n\nvoid solve() {\n    for ( int i=n-1; i>=0 && i>=n-15; i-- ) {\n        if ( solve(i) ) return;\n    }\n    assert(n>=4);\n    REP(i,n-2) z[i]='9';\n    z[n-2]=0;\n}\n\nvoid main() {\n    int t;\n    R(t);\n    while ( t-- ) {\n        R(s);\n        n=strlen(s);\n        REP(i,n+1) z[i]=0;\n        solve();\n        W(z);\n        int c[10]={};\n        int m=strlen(z);\n        REP(i,m) c[z[i]-'0']++;\n        REP(i,10) assert(c[i]%2==0);\n    }\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Largest Beautiful Number.json",
    "editorial_link": "https://codeforces.com//blog/entry/58210",
    "editorial": "This is pretty typical problem on greedy construction: you are asked to\r\nbuild lexicographically maximal string. In the majority of cases itâs\r\ndone like this. Imagine youâve built some prefix of length with all\r\nnumbers equal to the prefix of length of the original string. You are\r\nalso sure there exists some suffix for it that will give proper\r\nbeautiful number.Now you have two options: you either put if possible\r\nand proceed to the same task of longer prefix or you put the smaller\r\nnumber and fill the entire suffix with the maximum possible beautiful\r\nnumber you can obtain.Now you should learn how to check if any valid\r\nsuffix exists. It means at least the smallest possible beautiful number\r\nwith current prefix is smaller than . Itâs built like this. Let be the\r\nnumber of digits which currently have odd number of occurences. You put\r\nall zeroes but the last digits and then output these odd occurence\r\nnumber digits in increasing order. The first part can be checked with\r\npartial sums on the number of zeroes on segment in the original string\r\nand the second part has its length not greater than and can be checked\r\nnaively. Overall complexity: .\r\n",
    "hint": []
}