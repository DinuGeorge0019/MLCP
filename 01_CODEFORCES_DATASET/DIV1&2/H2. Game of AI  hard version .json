{
    "link": "https://codeforces.com//contest/1704/problem/H2",
    "problemId": "1489132",
    "problem_idx": "H2",
    "shortId": "1704H2",
    "contest_number": "1704",
    "problem_submissions": {
        "G": [
            166399832,
            166392509,
            166397270,
            166638387,
            166637822,
            166637785,
            166398104,
            166405958,
            166752775
        ],
        "H1": [
            166382413,
            166388635,
            166396747,
            166390624,
            166393948,
            166394968,
            166395394,
            166395219,
            166399131,
            166395533,
            167610683,
            166399678,
            166398389,
            166393517,
            166397144,
            166394482,
            166410457,
            166410434,
            166410387,
            166397758,
            166388826
        ],
        "F": [
            166375942,
            166373341,
            166380920,
            166379078,
            166375083,
            166374406,
            166381370,
            166374889,
            166379414,
            166377998,
            166381484,
            166382056,
            166383687,
            167610801,
            167610658,
            166377446,
            166386899,
            166386972,
            166382080,
            166385431,
            166386767,
            166397839
        ],
        "E": [
            166364243,
            166366722,
            166377362,
            166370668,
            166369471,
            166363533,
            166365063,
            166369098,
            166371591,
            166372062,
            166371621,
            166363068,
            166369922,
            167610979,
            166372272,
            166368343,
            166370920,
            166372137,
            166377343,
            166374205,
            166366243
        ],
        "D": [
            166356732,
            166359032,
            166354225,
            166361715,
            166364424,
            166358723,
            166360532,
            166363384,
            166359682,
            166359426,
            166360174,
            166357237,
            166358099,
            167610772,
            167610622,
            166360647,
            166358359,
            166360520,
            166363303,
            166368469,
            166361316,
            166360453
        ],
        "C": [
            166354884,
            166355766,
            166368189,
            166358588,
            166361497,
            166354947,
            166356916,
            166357737,
            166356376,
            166355591,
            166357410,
            166354410,
            166354789,
            167610761,
            167610600,
            166356402,
            166355566,
            166357431,
            166360930,
            166363594,
            166359066,
            166357566
        ],
        "B": [
            166350601,
            166350801,
            166351510,
            166352475,
            166352194,
            166351471,
            166350940,
            166351732,
            166351784,
            166352133,
            166351498,
            166351569,
            166351237,
            167610589,
            166351144,
            166351469,
            166352214,
            166353113,
            166355462,
            166352514,
            166351316
        ],
        "A": [
            166350367,
            166350415,
            166350414,
            166351113,
            166350822,
            166350510,
            166350405,
            166350518,
            166350539,
            166350824,
            166350499,
            166350452,
            166350409,
            167610545,
            166350456,
            166350502,
            166350981,
            166354346,
            166351283,
            166350461,
            166350432
        ],
        "H2": [
            166808527
        ]
    },
    "name": "H2. Game of AI  hard version ",
    "statement": "Cirno is playing a war simulator game with n towers (numbered from 1 to\r\nn) and n bots (numbered from 1 to n). The i-th tower is initially\r\noccupied by the i-th bot for 1\r\nle i\r\nle n.Before the game, Cirno first chooses a permutation p = [p_1, p_2,\r\nldots, p_n] of length n (A permutation of length n is an array of length\r\nn where each integer between 1 and n appears exactly once). After that,\r\nshe can choose a sequence a = [a_1, a_2,\r\nldots, a_n] (1\r\nle a_i\r\nle n and a_i\r\nne i for all 1\r\nle i\r\nle n).The game has n rounds of attacks. In the i-th round, if the p_i-th\r\nbot is still in the game, it will begin its attack, and as the result\r\nthe a_{p_i}-th tower becomes occupied by the p_i-th bot; the bot that\r\npreviously occupied the a_{p_i}-th tower will no longer occupy it. If\r\nthe p_i-th bot is not in the game, nothing will happen in this\r\nround.After each round, if a bot doesn’t occupy any towers, it will be\r\neliminated and leave the game. Please note that no tower can be occupied\r\nby more than one bot, but one bot can occupy more than one tower during\r\nthe game.At the end of the game, Cirno will record the result as a\r\nsequence b = [b_1, b_2,\r\nldots, b_n], where b_i is the number of the bot that occupies the i-th\r\ntower at the end of the game.However, as a mathematics master, she wants\r\nyou to solve the following counting problem instead of playing\r\ngames:Count the number of different pairs of sequences a, b from all\r\npossible choices of sequence a and permutation p.Calculate the answers\r\nfor all n such that 1\r\nle n\r\nle k. Since these numbers may be large, output them modulo M.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(\"1.in\",\"r\",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nconst int maxn=262144;\nint mod,_g;\ninline void inc(int &x,int y){x+=y;if (x>=mod) x-=mod;}\ninline void dec(int &x,int y){x-=y;if (x<0) x+=mod;}\ninline int qp(int x,int y){int z=1;while(y){if(y&1)z=1ll*z*x%mod;y>>=1;x=1ll*x*x%mod;}return z;}\nnamespace polynomial\n{\n\tnamespace basic\n\t{\n\t\tint fac[maxn+5],inv[maxn+5],fi[maxn+5],lg[maxn+5],pw[maxn+5],w[maxn+5],iw[maxn+5];\n\t\tbool tag=0;\n\t\tinline void init()\n\t\t{\n\t\t\ttag=1;int i;fz(i,2,maxn) lg[i]=lg[i>>1]+1;pw[0]=1;fz1(i,lg[maxn]) pw[i]=pw[i-1]*2; \n\t\t\tfac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,maxn){\n\t\t\t\tfac[i]=1ll*fac[i-1]*i%mod;inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;\n\t\t\t}\n\t\t\tw[0]=1;w[1]=qp(_g,(mod-1)/maxn);fz(i,2,maxn) w[i]=1ll*w[i-1]*w[1]%mod;\n\t\t\tiw[maxn]=qp(w[maxn],mod-2);fd0k(i,maxn) iw[i]=1ll*iw[i+1]*w[1]%mod;\n\t\t\tif (iw[0]!=1){puts(\"wrong iw!!!!!!!!!!!!!!!!!\");exit(-1);}\n\t\t}\n\t\tint rev[maxn+5],a[maxn+5],b[maxn+5];\n\t\tinline int getrev(int x)\n\t\t{\n\t\t\tif (!tag) init();int i,s=1;while (s<x) s*=2;rev[0]=0;fz1(i,s-1) rev[i]=((rev[i>>1]>>1)|((i&1)<<(lg[s]-1)));return s;\n\t\t}\n\t\tinline void ntt(int *a,int n,int *w)\n\t\t{\n\t\t\tif (!tag) init();int i,j,k;\n\t\t\tfz0k(i,n) if (rev[i]<i) swap(a[i],a[rev[i]]);\n\t\t\tfor (i=1;i<n;i<<=1){int ys=maxn/i/2;\n\t\t\t\tfor (j=0;j<n;j+=i+i){\n\t\t\t\t\tint *t=w;\n\t\t\t\t\tfz0k(k,i){\n\t\t\t\t\t\tint x=a[j+k],y=1ll*a[j+k+i]*(*t)%mod;\n\t\t\t\t\t\ta[j+k]=x+y;if (a[j+k]>=mod) a[j+k]-=mod;\n\t\t\t\t\t\ta[j+k+i]=x-y;if (a[j+k+i]<0) a[j+k+i]+=mod;\n\t\t\t\t\t\tt+=ys;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinline vector<int> mul(const vector<int> &aa,const vector<int> &bb) //aa*bb\n\t\t{\n\t\t\tvector<int> ans;long long br=1ll*aa.size()*bb.size(),ft=1ll*(aa.size()+bb.size())*lg[aa.size()+bb.size()]*10+100;\n\t\t\tif (br<ft){\n\t\t\t\twhile (ans.size()+1<aa.size()+bb.size()) ans.push_back(0);\n\t\t\t\tint i,j;fz0k(i,aa.size()) fz0k(j,bb.size()) inc(ans[i+j],1ll*aa[i]*bb[j]%mod);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint len=getrev(aa.size()+bb.size()),i;\n\t\t\t\tfz0k(i,len) a[i]=b[i]=0;\n\t\t\t\tfz0k(i,aa.size()) a[i]=aa[i];\n\t\t\t\tfz0k(i,bb.size()) b[i]=bb[i];\n\t\t\t\tntt(a,len,w);ntt(b,len,w);\n\t\t\t\tfz0k(i,len) a[i]=1ll*a[i]*b[i]%mod;\n\t\t\t\tntt(a,len,iw);int inv=qp(len,mod-2);\n\t\t\t\tfz0k(i,len) ans.push_back(1ll*a[i]*inv%mod);\n\t\t\t}\n\t\t\twhile (!ans.empty()&&!ans.back()) ans.pop_back();\n\t\t\treturn ans;\n\t\t}\n\t\tinline vector<int> mul2(const vector<int> &aa,const vector<int> &bb) //aa^2*bb\n\t\t{\n\t\t\tint len=getrev(aa.size()+aa.size()+bb.size()),i;\n\t\t\tfz0k(i,len) a[i]=b[i]=0;fz0k(i,aa.size()) a[i]=aa[i];fz0k(i,bb.size()) b[i]=bb[i];\n\t\t\tntt(a,len,w);ntt(b,len,w);fz0k(i,len) a[i]=1ll*a[i]*b[i]%mod*a[i]%mod;ntt(a,len,iw);\n\t\t\tvector<int> ans;int inv=qp(len,mod-2);fz0k(i,len) ans.push_back(1ll*a[i]*inv%mod);while (!ans.empty()&&!ans.back()) ans.pop_back();\n\t\t\treturn ans;\n\t\t}\n\t};\n\tstruct poly\n\t{\n\t\tvector<int> v;\n\t\tinline void clear(){v.clear();}\n\t\tinline int size(){return v.size();}\n\t\tinline bool empty(){return v.empty();}\n\t\tinline int back(){return v.back();}\n\t\tinline void pop_back(){v.pop_back();}\n\t\tinline void push_back(int x){v.push_back(x);}\n\t\tinline void read(int n){clear();while (n--){int x;scanf(\"%d\",&x);v.push_back(x);}}\n\t\tinline void print(){ff(v,it) printf(\"%d \",*it);puts(\"\");} \n\t\tinline void eprint(){int i;fz0k(i,v.size()) printf(\"%lld \",1ll*basic::fac[i]*v[i]%mod);puts(\"\");} \n\t\tinline void print(int n){int i;for(i=0;i<n;i++)if(i<v.size())printf(\"%d \",v[i]);else printf(\"0 \");puts(\"\");}\n\t\tinline poly operator+(const poly &x)const{vector<int> s;int i;for (i=0;i<x.v.size()||i<v.size();i++){int t=0;if(i<v.size())inc(t,v[i]);if(i<x.v.size())inc(t,x.v[i]);s.push_back(t);}return(poly){s};}\n\t\tinline poly operator-(const poly &x)const{vector<int> s;int i;for (i=0;i<x.v.size()||i<v.size();i++){int t=0;if(i<v.size())inc(t,v[i]);if(i<x.v.size())dec(t,x.v[i]);s.push_back(t);}return(poly){s};}\n\t\tinline poly operator*(const int &x)const{vector<int> s;int i;for (i=0;i<v.size();i++)s.push_back(1ll*x*v[i]%mod);return(poly){s};}\n\t\tinline poly operator*(const poly &x)const{return (poly){basic::mul(v,x.v)};}\n\t\tinline void mul_x(){int i;v.push_back(0);fd1(i,v.size()-1)v[i]=v[i-1];v[0]=0;} // this*=x\n\t\tinline void divi_x(){int i;fz0k(i,((int)v.size())-1)v[i]=v[i+1];v.pop_back();} // this/=x\n\t\tinline void derivation(){int i;fz0k(i,((int)v.size())-1)v[i]=1ll*v[i+1]*(i+1)%mod;v.pop_back();} // this=this的导数\n\t\tinline void integral(){int i;v.push_back(0);fd1(i,v.size()-1)v[i]=1ll*v[i-1]*basic::inv[i]%mod;v[0]=0;} // this=this的积分 \n\t\tinline void size_down(int x){while (v.size()>x)v.pop_back();}\n\t\tinline void size_up(int x){while (v.size()<x)v.push_back(0);}\n\t\tinline void resize(int x){size_down(x);size_up(x);}\n\t\tinline int &operator[](const int &x){if (v.size()<=x)size_up(x+1);return v[x];}\n\t};\n\tinline poly derivation(poly a){a.derivation();return a;}\n\tinline poly integral(poly a){a.integral();return a;}\n\tinline poly mul_x(poly a){a.mul_x();return a;}\n\tinline poly divi_x(poly a){a.divi_x();return a;}\n\tinline poly poly_inv(poly a,int n)\n\t{\n\t\twhile (!a.empty()&&!a.back()) a.pop_back();\n\t\tif (a.empty()){fprintf(stderr,\"wrong poly_inv(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;}\n\t\tpoly ta,tb;ta.push_back(a[0]);tb.push_back(qp(a[0],mod-2));int i,j;\n\t\tfor (i=1;i<n;i<<=1){\n\t\t\tfor (j=i;j<(i<<1)&&j<n;j++){\n\t\t\t\tta.push_back(a[j]);\n\t\t\t}\n\t\t\ttb=tb*2-((poly){basic::mul2(tb.v,ta.v)});\n\t\t\ttb.size_down(min((i<<1),n));\n\t\t}\n\t\treturn tb;\n\t}\n\tinline poly poly_ln(poly a,int n)\n\t{\n\t\twhile (!a.empty()&&!a.back()) a.pop_back();\n\t\tif (a.empty()){fprintf(stderr,\"wrong poly_ln(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;}\n\t\tif (a[0]!=1){\n\t\t\tfprintf(stderr,\"bad template poly_ln a[0]!=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;\n\t\t}\n\t\ta=integral(derivation(a)*poly_inv(a,n));a.size_down(n);\n\t\treturn a;\n\t}\n\tinline poly poly_exp(poly a,int n)\n\t{\n\t\twhile (!a.empty()&&!a.back()) a.pop_back();\n\t\tif (a.empty()){a.push_back(1);return a;}\n\t\tif (a[0]!=0){\n\t\t\tfprintf(stderr,\"bad template poly_exp a[0]!=0 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;\n\t\t}\n\t\tpoly ta,tb,uit;uit.push_back(1);ta.push_back(a[0]);tb.push_back(1);int i,j;\n\t\tfor (i=1;i<n;i<<=1){\n\t\t\tfor (j=i;j<n&&j<(i<<1);j++){\n\t\t\t\tta.push_back(a[j]);\n\t\t\t}\n\t\t\ttb=tb*(uit-poly_ln(tb,(i<<1))+ta);\n\t\t\ttb.size_down(min((i<<1),n));\n\t\t}\n\t\treturn tb;\n\t}\n};using namespace polynomial;\npoly calcF0(int n)\n{\n\tif(n==1){poly f;return f;}\n\tif(n==2){poly f;f[2]=1;return f;}\n\tpoly f0=calcF0((n+1)/2);\n\tpoly t1=mul_x(poly_exp(f0,n+1)); // xexp(F(x))\n\tpoly t2=f0+t1; // F(x)+xexp(F(x))\n\tpoly t3=mul_x(poly_exp(t2,n+1)); // xexp(F(x)+xexp(F(x)))\n\tpoly c=t2*t3-f0;c.size_down(n+1);\n\tpoly b;\n//\t(t1+(poly){{1}}).print();\n\tb=(t1+(poly){{1}})*(t2+(poly){{1}});b.size_down(n+1);\n//\tb.print();\n\tb=b*t3;b.size_down(n+1);\n\tb=b-(poly){{1}};\n//\tc.print();b.print();\n\tpoly f1=f0-c*poly_inv(b,n+1);\n\tf1.size_down(n+1);\n//\tf1.eprint();cerr<<endl;\n\treturn f1;\n}\nint n,m,i,j;\nint main()\n{\n\tread(n);read(mod);\n\tint tmp=mod-1;vector<int> v;for(i=2;i*i<=tmp;i++)if(tmp%i==0){v.push_back(i);while(tmp%i==0)tmp/=i;}if(tmp>1)v.push_back(tmp);\n\t_g=2;for(;;){bool flg=0;ff(v,it)if(qp(_g,(mod-1)/(*it))==1){flg=1;break;}if(!flg)break;_g++;}\n\tbasic::init();\n\tpoly F0=calcF0(n);\n//\tF0.eprint();\n\tpoly F1=mul_x(poly_exp(F0,n+1));F1.size_down(n+1);\n//\tF1.eprint();\n//\tpoly tt=mul_x(poly_exp(F0+F1,n+1)*(F0+F1));tt.size_down(n+1);fz0g(i,n) assert(F0[i]==tt[i]);\n\tpoly SF=mul_x(poly_exp(F0+F1,n+1));SF.size_down(n+1);\n//\tSF.eprint();\n\tpoly G0=F0+SF;\n//\tG0.eprint();\n\tpoly G1=F1*G0;G1.size_down(n+1);\n//\tG1.eprint();\n\tpoly G2=G0+G1;\n//\tG2.eprint();\n//\t((poly){{0}}-poly_ln((poly){{1}}-G2,n+1)).eprint();\n//\t(poly_ln((poly){{1}}-G2,n+1)+G0).eprint();\n//\t(poly_ln((poly){{1}}-SF,n+1)+SF).eprint();\n\tpoly ans=(poly_ln((poly){{1}}-SF,n+1)+SF)-(poly_ln((poly){{1}}-G2,n+1)+G0);\n//\tans.eprint();\n\tans=poly_exp(ans,n+1);\n\tfz1(i,n) printf(\"%lld\\n\",1ll*basic::fac[i]*ans[i]%mod);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "fft",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H2. Game of AI  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/105464",
    "editorial": "Given , The conclusion of possible array remains. If we fix array , we\r\nwill find that for each , will only be that or . For any pair , if , we\r\nwill find that and at the same time is impossible. All arrays which\r\nsatisfies the above conditions are valid.So for a fixed array , and we\r\nfix the position that (It can be shown that the chosen nodes form a\r\nindependent set), then the number of possible will be product of each\r\nin-degree of each that .Now we can see if we build a graph according to\r\n, the answer will be the sume of product over all independent sets. We\r\nneed to solve the problem of three parts: the nodes form a tree, some\r\ntreesâ roots form a ring, some trees based on rings form a graph.For the\r\ntree part, let be generating function of the sum of pruducts if the root\r\nis not included in the independent set, and otherwise. Then we have:We\r\ncan solve the equation, and use Newtonâs method to calculate and\r\n.Consider how to merge trees together. If one root is not in the\r\nindependent set, It can either be occupied by one of its children or the\r\nprevious node on the ring, so its generating function can be represented\r\nas (compared with , it adds the contribution caused by that itâs\r\noccupied by the previous node on the ring), which is easy to\r\ncalculate.For those which are in the independent set, their previous\r\nnodes must not be in. So we binding them together and their generating\r\nfunctions can be represented as .The final answer is .Note that when\r\nevery node on the ring is occupied by previous node, it is also\r\nimpossible. So we need to minus this answer. It can be calculated with\r\nsimilar method.At last, we need to combine these rings into a graph,\r\nwhich can be done with operation.Time complexity is .\r\n",
    "hint": []
}