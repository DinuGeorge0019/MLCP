{"link": "https://codeforces.com//contest/1530/problem/E", "problemId": "1049172", "problem_idx": "E", "shortId": "1530E", "contest_number": "1530", "problem_submissions": {"H": [122851665, 122838743, 122844195, 122849012, 122871696, 122848567, 122889728], "G": [122840209, 122852256, 122900209, 122846129, 122844934, 122847648, 122853646, 122874899, 122880351, 122921209], "F": [122810446, 122819713, 122812617, 122825773, 122868869, 122809297, 122821188, 122827035, 122824965, 122821818, 122829815, 122826847, 122822005, 122826789, 122826175, 122826918, 122836373, 122830797, 122814894, 122838442, 122834199], "E": [122803663, 122805810, 122805166, 122812311, 122817063, 122814296, 122807127, 122808379, 122800583, 122808253, 122808203, 122811232, 122807495, 122807208, 122811521, 122828022, 122805125, 122810921], "D": [122791676, 122796247, 122793005, 122795921, 122795213, 122793368, 122796651, 122796980, 122803859, 122791210, 122799331, 122796501, 122797048, 122796533, 122791355, 122798720, 122801973, 122792843, 122800740], "C": [122785861, 122787673, 122786660, 122785034, 122784856, 122787839, 122786985, 122784250, 122795439, 122782668, 122786465, 122789088, 122786999, 122788656, 122784366, 122787966, 122789017, 122785054, 122790340], "B": [122781549, 122782427, 122782526, 122782097, 122782078, 122780831, 122781690, 122789087, 122786285, 122785455, 122781801, 122781479, 122782615, 122783296, 122794583, 122783767, 122783971, 122780469, 122782275], "A": [122775440, 122775417, 122775273, 122775738, 122775580, 122775190, 122775752, 122790605, 122781313, 122775806, 122775746, 122775311, 122776001, 122775468, 122776055, 122775938, 122777214, 122775025, 122775038]}, "name": "E. Minimax", "statement": "of string t = t_1 t_2\r\nldots t_n and position i in it is defined as the length k of the longest\r\nproper (not equal to the whole substring) prefix of substring t_1 t_2\r\nldots t_i which is also a suffix of the same substring.For example, for\r\nstring t = the values of the prefix function in positions 1, 2,\r\nldots, 7 are equal to [0, 0, 1, 0, 1, 2, 3].Let f(t) be equal to the\r\nvalue of the prefix function of string t over all its positions. For\r\nexample, f() = 3.You are given a string s. Reorder its characters\r\narbitrarily to get a string t (the number of occurrences of any\r\ncharacter in strings s and t must be equal). The value of f(t) must be .\r\nOut of all options to minimize f(t), choose the one where string t is\r\nthe .\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.length();\n    \n    int cnt[26] = {};\n    for (int i = 0; i < n; i++) {\n        cnt[s[i] - 'a']++;\n    }\n    \n    if (s == std::string(n, s[0])) {\n        std::cout << s << \"\\n\";\n        return;\n    }\n    \n    int x = 0;\n    while (x < 26 && cnt[x] != 1) {\n        x++;\n    }\n    \n    if (x < 26) {\n        std::swap(s[0], s[s.find('a' + x)]);\n        std::sort(s.begin() + 1, s.end());\n        std::cout << s << \"\\n\";\n        return;\n    }\n    \n    x = 0;\n    while (cnt[x] == 0) {\n        x++;\n    }\n    \n    std::string t;\n    t += 'a' + x;\n    cnt[x]--;\n    \n    if (cnt[x] <= n / 2) {\n        t += 'a' + x;\n        cnt[x]--;\n        int y = x + 1;\n        while (cnt[x] > 0) {\n            while (cnt[y] == 0) {\n                y++;\n            }\n            t += 'a' + y;\n            cnt[y]--;\n            t += 'a' + x;\n            cnt[x]--;\n        }\n        while (int(t.length()) < n) {\n            while (cnt[y] == 0) {\n                y++;\n            }\n            t += 'a' + y;\n            cnt[y]--;\n        }\n        std::cout << t << \"\\n\";\n        return;\n    }\n    \n    int y = x + 1;\n    while (cnt[y] == 0) {\n        y++;\n    }\n    \n    if (cnt[x] + cnt[y] == n - 1) {\n        while (cnt[y]--) {\n            t += 'a' + y;\n        }\n        while (cnt[x]--) {\n            t += 'a' + x;\n        }\n        std::cout << t << \"\\n\";\n        return;\n    }\n    \n    int z = y + 1;\n    while (cnt[z] == 0) {\n        z++;\n    }\n    \n    t += 'a' + y;\n    cnt[y]--;\n    \n    while (cnt[x]--) {\n        t += 'a' + x;\n    }\n    \n    t += 'a' + z;\n    cnt[z]--;\n    \n    for (int i = y; i < 26; i++) {\n        while (cnt[i]--) {\n            t += 'a' + i;\n        }\n    }\n    \n    std::cout << t << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "strings"], "dificulty": "2100", "interactive": false}