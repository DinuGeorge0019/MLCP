{
    "link": "https://codeforces.com//contest/1556/problem/G",
    "problemId": "1093328",
    "problem_idx": "G",
    "shortId": "1556G",
    "contest_number": "1556",
    "problem_submissions": {
        "H": [
            127528421,
            127373567,
            127527040,
            127375388,
            127394013,
            127386870,
            127381921,
            127387937,
            127394050,
            127389040,
            127428317,
            127427887,
            127554513,
            127394843,
            127394720,
            127394710,
            127394566,
            127388015,
            127563493,
            127391319,
            127413892,
            127413850,
            127391995,
            190714866,
            127387774
        ],
        "G": [
            127390700,
            127387983,
            127394350,
            127373122,
            127379900,
            127386180,
            127417272,
            127382224,
            127382638,
            127388751,
            127407653,
            127407647,
            127407608,
            127407584,
            127407566,
            127386088,
            127384803,
            127387460,
            127387640
        ],
        "F": [
            127355517,
            127358676,
            127354501,
            127360575,
            127359102,
            127358993,
            127363463,
            127363603,
            127365708,
            127364449,
            127360085,
            127362064,
            127372929,
            127362249,
            127375013,
            127359868,
            127372641,
            127367693,
            127374334,
            127375402
        ],
        "E": [
            127351296,
            127352912,
            127351562,
            127356521,
            127354559,
            127354907,
            127360891,
            127356050,
            127360001,
            127359317,
            127356239,
            127358250,
            127364802,
            127356923,
            127358834,
            127355363,
            127366513,
            127364481,
            127365791,
            127370671
        ],
        "D": [
            127346830,
            127349657,
            127348248,
            127352056,
            127350226,
            127351918,
            127354957,
            127351335,
            127356577,
            127354677,
            127353022,
            127352794,
            127358047,
            127352764,
            127356062,
            127349435,
            127357493,
            127359353,
            127355308,
            127356263
        ],
        "C": [
            127342221,
            127343475,
            127345171,
            127346052,
            127344444,
            127347970,
            127343862,
            127341055,
            127350101,
            127347701,
            127344590,
            127346041,
            127349062,
            127346563,
            127349912,
            127346975,
            127349244,
            127343756,
            127348599,
            127364090
        ],
        "A": [
            127338005,
            127334498,
            127334512,
            127336074,
            127334497,
            127335667,
            127334534,
            127334495,
            127334713,
            127336416,
            127334993,
            127336217,
            127334858,
            127334721,
            127334712,
            127334514,
            127335446,
            127334480,
            127334660,
            127334680
        ],
        "B": [
            127336233,
            127336922,
            127337115,
            127340977,
            127338217,
            127339999,
            127337368,
            127336161,
            127338774,
            127342382,
            127338043,
            127341949,
            127339720,
            127340565,
            127339178,
            127338941,
            127341395,
            127336543,
            127339094,
            127344978
        ]
    },
    "name": "G. Gates to Another World",
    "statement": "As mentioned previously William really likes playing video games. In one\r\nof his favorite games, the player character is in a universe where every\r\nplanet is designated by a binary number from 0 to 2^n - 1. On each\r\nplanet, there are gates that allow the player to move from planet i to\r\nplanet j if the binary representations of i and j differ in exactly one\r\nbit.William wants to test you and see how you can handle processing the\r\nfollowing queries in this game universe: Destroy planets with numbers\r\nfrom l to r inclusively. These planets cannot be moved to anymore.\r\nFigure out if it is possible to reach planet b from planet a using some\r\nnumber of planetary gates. It is guaranteed that the planets a and b are\r\nnot destroyed.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<ll>\n#define pi pair<ll, ll>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int N = 30000005;\nconst int maxn = 100005;\n\nint ch[N][2];\nint id[N];\nint n;\nll l[maxn], r[maxn];\nint tp[maxn];\nint fa[N];\nint gfa(int x) {\n    if (fa[x] == x) return x;\n    return fa[x] = gfa(fa[x]);\n}\nint u;\nint cnt = 0;\nset<pair<ll, int> > uu; \nint fid(ll x) {\n    auto h = uu.lower_bound(mp(x + 1, 0));\n    h--;\n    return (*h).se;\n}\nint rt = 1;\nint trcnt = 1;\nvoid ins(ll a, int sz, int ids) {\n    int pl = rt;\n    for (int m = u - 1; m >= sz; m--) {\n        int cr = (a >> m) & 1;\n        if (!ch[pl][cr]) ch[pl][cr] = ++trcnt;\n        pl = ch[pl][cr];\n    }\n    assert(trcnt < N * 2 / 3);\n    id[pl] = ids;\n}\nvoid lk(int a, int b) {\n    if (gfa(a) == gfa(b)) return;\n    //cout << \"LK \" << a << ' ' << b << endl;\n    fa[gfa(a)] = gfa(b);\n}\nvoid lk_all(int pl, int ids) {\n    if (!pl) return ;\n    if (id[pl]) {\n        lk(id[pl], ids);\n        return ;\n    }\n    for (int i = 0; i < 2; i++)\n        lk_all(ch[pl][i], ids);\n}\nvoid push_seg(ll a, int sz) {\n    // a ~ (a + (1 << sz) - 1)\n    cnt += 1;\n    //cout << \"ADE_SEG\" << a << ' ' << sz << ' ' << cnt << endl;\n    ins(a, sz, cnt);\n    uu.insert(mp(a, cnt));\n    fa[cnt] = cnt;\n    for (int m = u - 1; m >= sz; m--) {\n        // m 位 不同\n        int pl = rt;\n        for (int j = u - 1; j >= sz; j--) {\n            int cr = (a >> j) & 1;\n            if (j == m) cr ^= 1;\n            if (!ch[pl][cr]) {\n                pl = 0;\n                break;\n            }\n            pl = ch[pl][cr];\n            if (id[pl]) {\n            //    cout << \"???\" << m << ' ' << j << ' ' << pl << endl;\n                lk(cnt, id[pl]);\n                break;\n            }\n        }\n        if (pl) lk_all(pl, cnt);\n    }\n}\nvoid add(ll l, ll r) {\n    #define vl vector<ll>\n    //cout << \"ADE \" << l << ' ' << r << endl;\n    vl cr = {0};\n    for (int i = u - 1; i >= 0; i--) {\n        vl ed;\n        for (auto v : cr) {\n            ed.pb(v); ed.pb(v + (1ll << i));\n        }\n        vl ted;\n        for (auto v : ed) {\n            if (v > r || v + (1ll << i) - 1 < l) continue;\n            if (v >= l && (v + (1ll << i) - 1) <= r) push_seg(v, i);\n            else ted.pb(v);\n        }\n        cr = ted;\n    }\n}\nint ans[maxn];\n#undef int \nint main() {\n    #define int long long\n    cin >> u >> n;\n    vector<pair<ll, ll> >  de;\n    for (int i = 1; i <= n; i++) {\n        char inp[5];\n        scanf(\"%s\", inp);\n        scanf(\"%lld%lld\", &l[i], &r[i]);\n        if (inp[0] == 'b') de.pb(mp(l[i], r[i])), tp[i] = 0;\n        else tp[i] = 1;\n    }\n    sort(de.begin(), de.end());\n    ll ls = 0;\n    for (auto h : de) {\n        if (ls < h.fi) add(ls, h.fi - 1);\n        chkmax(ls, h.se + 1);\n    }\n    if (ls < (1ll << u))\n        add(ls, (1ll << u) - 1);\n    for (int i = n; i >= 1; i--) {\n        if (tp[i] == 1) {\n            int uf = fid(l[i]), vf = fid(r[i]);\n            //cout << \"ASK\" << uf << ' ' << vf << ' ' << l[i] << ' ' << r[i] << endl;\n            if (gfa(uf) == gfa(vf)) ans[i] = 1;\n            else ans[i] = 0;\n        }\n        else add(l[i], r[i]);\n    }\n    for (int i = 1; i <= n; i++)\n        if (tp[i] == 1) printf(\"%d\\n\", ans[i]);\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dsu",
        "two pointers"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Gates to Another World.json",
    "editorial_link": "https://codeforces.com//blog/entry/94384",
    "editorial": "Letâs change the formulation of the problem: we will execute queries in\r\nreverse order, and assign a lifetime to each segment of blocked\r\nvertices. Lifetime until what moment the segment is blocked. Note, if we\r\nlook through the requests in reverse order, then for each segment it is\r\npossible to determine the moment of time after which the vertices from\r\nthis segment cease to be blocked.Thus, the problem looks like this:\r\ngiven a graph that is an -dimensional hypercube (each vertex has edges\r\nto adjacent vertices that differ from it by only one coordinate), and\r\nthere are blocked vertex segments that live up to the time .Consider the\r\nfollowing fact:If we take an -dimensional hypercube and sequences of\r\nvertices and , then the numbers in the corresponding positions from\r\nthese two sequences are neighbours to each other, since they differ only\r\nin the most significant bit, that is, in the bit. For a better\r\nunderstanding, letâs depict this for : Here denotes that is a neighbour\r\nof , and is present in the first sequence, and in the second.For\r\nsimplicity, we will only prohibit movement between a blocked vertex and\r\nan unblocked one. Letâs learn how to get a \"compressed\" graph, each\r\nvertex of which would represent a connected subset of the vertices of\r\nthe hypercube. Also, this set, which represents a vertex, is a set of\r\nconsecutive vertices, that is, it is a segment. On each edge of this\r\ngraph is written the time when this edge begins to exist. Time makes\r\nsense, since an edge can be drawn between a vertex that represents a set\r\nof blocked vertices and a vertex that represents a set of unblocked\r\nvertices. And the time on this edge there will be a moment in time when\r\nthe set of vertices is unblocked. Recall that now we are solving a\r\nproblem in which the vertices are blocked until a certain moment in\r\ntime. The answer to the reachability request is the reachability request\r\nfor a given \"compressed\" graph. It is only necessary to correctly\r\ndetermine the reachability of which two vertices of the \"compressed\"\r\ngraph we are interested in.Letâs learn how to recursively build a given\r\ncompressed graph.Input data for the construction of this graph are: the\r\ndimension of the hypercube, the set of blocked vertices. If there are no\r\nsegments worth blocking, then the compressed graph is one vertex, which\r\nis responsible for the connected set of hypercube vertices. If there is\r\none segment , then the compressed graph is one vertex representing all\r\nvertices, and they are all blocked.Otherwise, we can divide the\r\nhypercube into two parts: by the most significant bit. That is, into two\r\nhypercubes of dimensions . And each segment can go further, as input,\r\neither into two hypercubes, or into one of them. Having received\r\ncompressed graphs from each of the two hypercubes, we can match the\r\nadjacent vertices of these hypercubes, as illustrated above.It is not\r\ndifficult to combine two such graphs, since each vertex of the graph\r\ndescribes the set of vertices of the hypercube, and this set is a\r\nsegment, therefore, if we have the vertices of the first and second\r\ngraphs, and , respectively, in ascending order of the segments for which\r\nthey answer, then it is possible to combine these two graphs in time,\r\nand create no more than edges and obtain a new graph of size .In total,\r\nthe resulting graph will have a size of , and the final asymptotics will\r\nbe , where is the cost of the operation in the DSU. The DSU is needed to\r\npass queries in reverse order and connect the edges at the right times\r\nwhen the edges begin to exist.The asymptotics is as follows, since each\r\nvertex of the graph may go through all layers of recursion (as you may\r\nhave noticed, the solution procedure resembles divide and conquer) and\r\nat the same time create a new edge in each layer. And the graph has such\r\na size, since each blocked segment in this procedure can be split into\r\nsegments.For a better understanding, see the authorâs solution.\r\n",
    "hint": []
}