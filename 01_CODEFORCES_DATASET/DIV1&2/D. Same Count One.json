{"link": "https://codeforces.com//contest/1774/problem/D", "problemId": "1697944", "problem_idx": "D", "shortId": "1774D", "contest_number": "1774", "problem_submissions": {"G": [185692788, 185688701, 185709786, 185704068, 185700930, 185701804, 185702434, 185710209, 185706872, 185904256, 185795210, 185793397, 185819250], "F2": [185676745, 185670281, 185675729, 185668671, 185681524, 185686567, 185677180, 185669013, 185668157, 185689966, 185688723, 185695825, 185693474, 185692885, 185688234, 185691854, 185681271, 185694474, 185685579], "F1": [185676593, 185670463, 185663684, 185668833, 185681601, 185716882, 185686479, 185674297, 185669194, 185668049, 185679440, 185670075, 185683714, 185693266, 185692482, 185683082, 185681999, 185681061, 185687683, 185683570], "E": [185655499, 185660825, 185651479, 185656124, 185655058, 185662458, 185662357, 185652494, 185657012, 185662649, 185653972, 185662778, 185664782, 185668838, 185669645, 185656956, 185667038, 185672369, 185663098], "D": [185649610, 185653248, 185643125, 185650993, 185649142, 185653531, 185657439, 185657348, 185650869, 185657200, 185661330, 185657425, 185655644, 185661084, 185663734, 185649769, 185662028, 185662351, 185658693], "A": [185644231, 185636102, 185635462, 185635619, 185635678, 185635790, 185637888, 185635854, 185636970, 185636959, 185635664, 185635988, 185635613, 185637777, 185636615, 185635469, 185636037, 185640093, 185635898], "B": [185642990, 185641490, 185645977, 185640363, 185639666, 185641314, 185642797, 185639691, 185640833, 185692584, 185643672, 185638403, 185645169, 185646911, 185640445, 185643451, 185646071, 185642995], "C": [185639008, 185648162, 185647183, 185644645, 185643844, 185645738, 185648229, 185644184, 185645698, 185650776, 185648822, 185648683, 185646713, 185653638, 185655962, 185643940, 185653656, 185654108, 185651616]}, "name": "D. Same Count One", "statement": "ChthollyNotaSeniorious received a special gift from AquaMoon: n binary\r\narrays of length m. AquaMoon tells him that in one operation, he can\r\nchoose any two arrays and any position pos from 1 to m, and swap the\r\nelements at positions pos in these arrays.He is fascinated with this\r\ngame, and he wants to find the minimum number of operations needed to\r\nmake the numbers of 1s in all arrays the same. He has invited you to\r\nparticipate in this interesting game, so please try to find it!If it is\r\npossible, please output specific exchange steps in the format described\r\nin the output section. Otherwise, please output -1.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 100100;\nconst int M = (int)1e6 + 7;\nint n, m;\narray<int, 3> ans[M];\nint ansSz;\nvector<int> a[N];\nint sum[N];\n\nvoid solve() {\n\tscanf(\"%d%d\", &n, &m);\n\tint tot = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i].resize(m);\n\t\tsum[i] = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tsum[i] += a[i][j];\n\t\t}\n\t\ttot += sum[i];\n\t}\n\tif (tot % n != 0) {\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\ttot /= n;\n\tansSz = 0;\n\tint p = 0, q = 0;\n\twhile(true) {\n\t\twhile(p < n && sum[p] >= tot) p++;\n\t\twhile(q < n && sum[q] <= tot) q++;\n\t\tassert(1 ^ (p == n) ^ (q == n));\n\t\tif (p == n) break;\n\t\tfor (int i = 0; sum[p] < tot && sum[q] > tot && i < m; i++) {\n\t\t\tif (a[p][i] == 1 || a[q][i] == 0) continue;\n\t\t\tans[ansSz++] = {p, q, i};\n\t\t\tsum[p]++;\n\t\t\tsum[q]--;\n\t\t\tswap(a[p][i], a[q][i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ansSz);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(\"%d %d %d\\n\", ans[i][0] + 1, ans[i][1] + 1, ans[i][2] + 1);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "greedy", "implementation", "two pointers"], "dificulty": "1600", "interactive": false}