{
    "link": "https://codeforces.com//contest/1060/problem/H",
    "problemId": "230453",
    "problem_idx": "H",
    "shortId": "1060H",
    "contest_number": "1060",
    "problem_submissions": {
        "H": [
            43777582,
            43775787,
            43778301,
            43775359,
            43805399,
            43782088,
            43777602,
            44116240,
            43850241,
            43778906,
            43778773
        ],
        "F": [
            43769322,
            43774726,
            43772403,
            43778102,
            43769241,
            43772326,
            43773423,
            43775493,
            43777323,
            43776810,
            44345662,
            43998198,
            43776461,
            43777805,
            43885359,
            43777579,
            43776355,
            43779796,
            43779608,
            43780204
        ],
        "E": [
            43762417,
            43764663,
            43763746,
            43764167,
            43763212,
            43766061,
            43765524,
            43768205,
            43766236,
            43763603,
            43766034,
            43766754,
            43768368,
            43766310,
            43767829,
            43764919,
            43769766,
            43765300,
            43766971,
            43767710
        ],
        "B": [
            43761076,
            43759115,
            43759168,
            43759290,
            43758265,
            43759025,
            43759632,
            43759678,
            43759571,
            43759528,
            43758792,
            43759203,
            43760228,
            43760411,
            43761202,
            43772055,
            43761410,
            43759136,
            43761174,
            43759666
        ],
        "C": [
            43760028,
            43761053,
            43760979,
            43760607,
            43760834,
            43761267,
            43761559,
            43762200,
            43761558,
            43761781,
            43761097,
            43763023,
            43762854,
            43762864,
            43763097,
            43761814,
            43765269,
            43760939,
            43763385,
            43762549
        ],
        "D": [
            43758517,
            43762752,
            43762719,
            43762340,
            43759631,
            43763257,
            43762507,
            43764164,
            43763131,
            43760435,
            43762978,
            43764580,
            43764519,
            43765425,
            43764660,
            43762881,
            43766760,
            43767791,
            43764938,
            43764650
        ],
        "A": [
            43757554,
            43758213,
            43757544,
            43758262,
            43757552,
            43757711,
            43757958,
            43758105,
            43757983,
            43757586,
            43757752,
            43757708,
            43758583,
            43757806,
            43757592,
            43757955,
            43759122,
            43757641,
            43757856,
            43757849
        ],
        "G": [
            44020164,
            44543288
        ]
    },
    "name": "H. Sophisticated Device",
    "statement": "You are given integers d and p, p is prime. Also you have a mysterious\r\ndevice. It has memory cells, each contains an integer between 0 and p-1.\r\nAlso two instructions are supported, addition and raising to the d-th\r\npower.\r\ntextbf{Both are modulo} p.The memory cells are numbered 1, 2,\r\ndots, 5000. Initially cells 1 and 2 contain integers x and y,\r\nrespectively (0\r\nleqslant x, y\r\nleq p - 1). All other cells contain\r\ntextbf{1}s. You can not directly access values in cells, and you\r\ntextbf{don\u2019t know} values of x and y (but you know they are written in\r\nfirst two cells). You mission, should you choose to accept it, is to\r\nwrite a program using the available instructions to obtain the product\r\nxy modulo p in one of the cells. You program should work for all\r\npossible x and y.Addition instruction evaluates sum of values in two\r\ncells and writes it to third cell. This instruction is encoded by a\r\nstring \"\", which writes sum of values in cells and into cell . Any\r\nvalues of , , can coincide. Second instruction writes the d-th power of\r\na value in some cell to the target cell. This instruction is encoded by\r\na string \"\". Values and can coincide, in this case value in the cell\r\nwill be overwritten. Last instruction is special, this is the return\r\ninstruction, and it is encoded by a string \"\". This means you obtained\r\nvalues xy\r\nbmod p in the cell . No instructions should be called after this\r\ninstruction.Provide a program that obtains xy\r\nbmod p and uses no more than 5000 instructions (including the return\r\ninstruction).It is guaranteed that, under given constrains, a solution\r\nexists.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 12;\n\nint P, D;\nint A, B, ONE;\nint TOT;\nint cloc;\n\nvoid put_add (int l, int r, int e)\n{\n    cout << \"+ \" << l << \" \" << r << \" \" << e << \"\\n\";\n}\n\nvoid put_pow (int s, int e)\n{\n    cout << \"^ \" << s << \" \" << e << \"\\n\";\n}\n\nint mmake (vector <int> v)\n{\n    // D-th power of sum of v[i]\n    int res_loc = cloc++;\n    if (v.size() == 1)\n    {\n        put_pow (v[0], res_loc);\n        return res_loc;\n    }\n    put_add(v[0], v[1], res_loc);\n    for (int i = 2; i < v.size(); i++)\n        put_add(v[i], res_loc, res_loc);\n    put_pow(res_loc, res_loc);\n    return res_loc;\n}\n\nint mmult (int ncur, int val)\n{\n    if (val == 1) return ncur;\n    int nloc = cloc++;\n    put_add(ncur, ncur, nloc);\n    int gloc = mmult (nloc, val / 2);\n    if (val % 2)\n        put_add(ncur, gloc, gloc);\n    return gloc;\n}\n\nll inv (ll x)\n{\n    ll cpow = x, b = P - 2;\n    ll cres = 1;\n    while (b)\n    {\n        if (b & 1)\n        {\n            cres = (cres * cpow) % P;\n        }\n        cpow = (cpow * cpow) % P;\n        b /= 2;\n    }\n    return cres;\n}\n\nint pascal[MAXN][MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    A = 1;\n    B = 2;\n    ONE = 3;\n    TOT = -1;\n\n    cin >> D >> P;\n    pascal[0][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = 0; j < MAXN; j++)\n        {\n            pascal[i][j] = pascal[i-1][j];\n            if (j) pascal[i][j] += pascal[i-1][j-1];\n        }\n\n    cloc = 10;\n    for (int ac = 0; ac <= 1; ac++)\n    {\n        for (int bc = 0; bc <= 1; bc++)\n        {\n            for (int oc = 0; oc <= D - 2; oc++)\n            {\n                if (ac + bc + oc == 0) continue;\n                vector <int> vloc;\n                for (int i = 0; i < ac; i++)\n                    vloc.push_back(A);\n                for (int i = 0; i < bc; i++)\n                    vloc.push_back(B);\n                for (int i = 0; i < oc; i++)\n                    vloc.push_back(ONE);\n                int cg = mmake (vloc);\n\n                ll cc = 1;\n                if ((ac + bc + oc + D) % 2 != 0)\n                    cc = -cc;\n                cc *= pascal[D-2][oc];\n                cc = (cc % P + P) % P;\n\n                int ng = mmult (cg, cc);\n                if (TOT == -1)\n                    TOT = ng;\n                else\n                    put_add (ng, TOT, TOT);\n            }\n        }\n    }\n    ll cc = 1;\n    for (int i = 1; i <= D; i++)\n        cc *= i;\n    cc %= P;\n    cc = inv (cc);\n    int nres = mmult (TOT, cc);\n    cout << \"f \" << nres << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Sophisticated Device.json",
    "editorial_link": "https://codeforces.com//blog/entry/113725",
    "editorial": "Using addition, we can implement multiplication by a \u0093compile-time\u0094 constant \nn\nn in \nO\n(\nlog\n?\nn\n)\nO(logn) steps. Since arithmetic is modular, we can implement this in \nO\n(\nlog\n?\np\n)\nO(logp) steps (remember that multiplication by \n0\n0 is an edge case here, so it needs to be handled like multiplication by \np\np).\n\nIf you try \nd\n=\n2\nd=2, you can realize that it suffices to be able to find \na\n2\na \n2\n  from a variable \na\na, because then we have \nx\ny\n=\n(\n(\nx\n+\ny\n)\n2\n?\nx\n2\n?\ny\n2\n)\n?\n(\n(\np\n+\n1\n)\n/\n2\n)\n)\nxy=((x+y) \n2\n ?x \n2\n ?y \n2\n )?((p+1)/2)).\n\nNow we only want to be able to go from \nx\nd\nx \nd\n  to \nx\n2\nx \n2\n . For this, note that there is a set of \nd\n+\n1\nd+1 linear equations in the formal variables \n1\n,\nx\n,\nx\n2\n,\n\u0085\n,\nx\nd\n1,x,x \n2\n ,\u0085,x \nd\n  relating them to \n(\nx\n+\ni\n)\nd\n(x+i) \nd\n  for \ni\n=\n0\ni=0 to \nd\nd. The determinant of the matrix is non-zero since it is a non-zero (mod \np\np too, because \nd\n<\np\nd<p) factor times the Vandermonde determinant (which is non-zero mod \np\np because \nd\n<\np\nd<p), so it is invertible.\n\nBy inverting this matrix, we can get \nx\n2\nx \n2\n  from \n(\nx\n+\ni\n)\nd\n(x+i) \nd\n  for \ni\n=\n0\ni=0 to \nd\nd. The total number of queries is about \nO\n(\nd\nlog\n?\np\n)\nO(dlogp) in both space and memory, and it passes very comfortably."
}