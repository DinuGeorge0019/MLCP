{
    "link": "https://codeforces.com//contest/2002/problem/F1",
    "problemId": "2809243",
    "problem_idx": "F1",
    "shortId": "2002F1",
    "contest_number": "2002",
    "problem_submissions": {
        "H": [
            275883821,
            276030000,
            276029533,
            276718944,
            276718931,
            276716412,
            276716121,
            276379907
        ],
        "G": [
            275814532,
            275831532,
            275862936,
            275862868,
            275857045,
            275856914,
            275852957,
            275835244,
            275830497,
            275836895,
            275844798,
            275836685,
            275839620,
            275876408,
            275835680,
            276384839,
            275855186,
            275854807,
            275854377,
            275854233,
            275853273,
            275853001,
            277160193,
            275873413
        ],
        "F2": [
            275803261,
            275805293,
            275815511,
            275803726,
            275821855,
            275826602,
            275804715,
            275817099,
            275812698,
            275821433,
            275820135,
            275822519,
            275814615,
            275832819,
            275821881,
            275820944,
            275827250
        ],
        "F1": [
            275803106,
            275797405,
            275810054,
            275805934,
            275822144,
            275821908,
            275808780,
            275842679,
            275842498,
            275804501,
            275809897,
            275810999,
            275804801,
            275820307,
            275807320,
            275814303,
            275818257,
            275821104,
            275812786,
            275819730
        ],
        "E": [
            275776266,
            275785744,
            275852219,
            275788914,
            275771707,
            275802566,
            275795962,
            275769983,
            275789286,
            275807515,
            275787919,
            275785680,
            275785359,
            275786354,
            275779961,
            275794439,
            275802251,
            275789750,
            275800998,
            275803752,
            275804830
        ],
        "D2": [
            275767991,
            275777830,
            275771186,
            275817652,
            275793116,
            275788319,
            275778566,
            275781543,
            275797706,
            275776037,
            275778290,
            275777713,
            275779770,
            275786761,
            275779192,
            275790952,
            275773357,
            275786731,
            275789591,
            275775563
        ],
        "D1": [
            275767248,
            275777327,
            275771493,
            275817851,
            275793580,
            275790111,
            275778728,
            275771118,
            275797900,
            275776414,
            275778256,
            275777934,
            275780036,
            275787162,
            275779917,
            275791115,
            275772837,
            275787063,
            275789991,
            275776578
        ],
        "C": [
            275759851,
            275761703,
            275759373,
            275759241,
            275760994,
            275777407,
            275759928,
            275758928,
            275788566,
            275759503,
            275761991,
            275762069,
            275758442,
            275761405,
            275763148,
            275760323,
            275761934,
            275768403,
            275764562,
            275765401
        ],
        "B": [
            275757139,
            275757734,
            275756638,
            275756387,
            275757424,
            275758576,
            275756620,
            275756121,
            275770304,
            275762131,
            275757965,
            275758270,
            275756051,
            275757393,
            275759268,
            275756663,
            275757687,
            275761514,
            275758840,
            275756832
        ],
        "A": [
            275755167,
            275755315,
            275754910,
            275755027,
            275755132,
            275755590,
            275754949,
            275754911,
            275767431,
            275754975,
            275755752,
            275755110,
            275754896,
            275755382,
            275755090,
            275755155,
            275754903,
            275755222,
            275756059,
            275754981
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132569",
    "editorial": "TutorialWe view the problem as a walk on\ngrid, starting at . WLOG, we suppose , thus only cells where would be\nconsidered.Notice that when is large enough, the largest prime satisfies\n. As such, all cells where will be unblocked and reachable.However,\nwe\u00e2\u0080\u0099ve only bounded one side of the final result. We take this a step\nfurther, let be the second-largest prime . By the same logic, we assume\nthat . As such, all cells , where will be unblocked and reachable.Thus,\nwe have constructed an area where the optimal solution must be, with its\ndimensions bounded by and . We just need to run any brute force solution\n(dfs with memorization or dp) on this area to find the result.If we\nassume the asymptotic of prime gap is , this yields a solution, where\nthe is from taking the gcd of two numbers which differ by . This can\nalso be optimized to by preprocessing gcd.We added the constraints that\n\u00e2\u0080\u0099s are pairwise distinct to avoid forcing participants to write\nmemorizations. In fact, under the constraints of the problem, the\nmaximum area is , and the sum of the largest areas is .Time complexity:\n",
    "name": "F1. Court Blue  Easy Version ",
    "statement": "In the court of the Blue King, Lelle and Flamm are having a performance\r\nmatch. The match consists of several rounds. In each round, either Lelle\r\nor Flamm wins.Let W_L and W_F denote the number of wins of Lelle and\r\nFlamm, respectively. The Blue King considers a match to be if and only\r\nif: after every round,\r\ngcd(W_L,W_F)\r\nle 1; at the end of the match, W_L\r\nle n, W_F\r\nle m. Note that\r\ngcd(0,x)=\r\ngcd(x,0)=x for every non-negative integer x.Lelle and Flamm can decide\r\nto stop the match whenever they want, and the final score of the\r\nperformance is l\r\ncdot W_L + f\r\ncdot W_F.Please help Lelle and Flamm coordinate their wins and losses\r\nsuch that the performance is , and the total score of the performance is\r\nmaximized.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\u00a0constexpr int N = 2E7;std::vector<int> minp, primes;\u00a0void sieve(int n) {    minp.assign(n + 1, 0);    primes.clear();        for (int i = 2; i <= n; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }                for (auto p : primes) {            if (i * p > n) {                break;            }            minp[i * p] = p;            if (p == minp[i]) {                break;            }        }    }}\u00a0void solve() {    int n, m, l, f;    std::cin >> n >> m >> l >> f;        int q = m;    while (q > 1 && minp[q] != q) {        q--;    }    int p = std::min(q - 1, n);    while (p > 1 && (minp[p] != p || m / p != q / p)) {        p--;    }        // std::cerr << \"p : \" << p << \", q : \" << q << \"\\n\";    std::vector vis(n - p + 1, std::vector<bool>(m - q + 1));    i64 ans = 0;    for (int i = 0; i <= n - p; i++) {        for (int j = 0; j <= m - q; j++) {            int g = std::gcd(p + i, q + j);            if (i == 0 || j == 0) {                vis[i][j] = (g == 1 && p + i <= q + j);            } else if (g == 1) {                vis[i][j] = vis[i - 1][j] || vis[i][j - 1];            }            if (vis[i][j]) {                // std::cerr << \"(\" << p + i << \", \" << q + j << \")\\n\";                ans = std::max(ans, 1LL * l * (p + i) + 1LL * f * (q + j));                if (q + j <= n) {                    ans = std::max(ans, 1LL * f * (p + i) + 1LL * l * (q + j));                }            }        }    }    std::cout << ans << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        // for (int i = 0; i <= 30; i++) {    //     for (int j = 0; j <= 30; j++) {    //         std::cerr << (std::gcd(i, j) <= 1 ? \"O\" : \" \");    //     }    //     std::cerr << \"\\n\";    // }        sieve(N);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F1. Court Blue  Easy Version .json"
}