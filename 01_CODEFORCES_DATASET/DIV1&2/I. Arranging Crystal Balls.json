{"link": "https://codeforces.com//contest/1740/problem/I", "problemId": "1611418", "problem_idx": "I", "shortId": "1740I", "contest_number": "1740", "problem_submissions": {"H": [178379430, 178389839, 178370970, 178389787, 178394159, 178405718, 178393380, 178400994, 178473578], "G": [178363447, 178373152, 178390136, 178380782, 178380133, 178366412, 178381208, 178372252, 178364309, 178377085, 178379805, 178389960, 178394186, 178390668, 178429073, 178399239, 178398964, 178398319, 178393777, 178389532, 178457114, 178457090, 178457069, 178456881, 178456598], "F": [178342509, 178355726, 178353094, 178359313, 178375325, 178347566, 178343206, 178355344, 178419766, 178363409, 178364030, 178360259, 178371042, 178378751, 178405026, 178404845, 178404014, 178403791, 178403569, 178376955, 178368121, 178355891, 178355560, 178363171, 178364934], "E": [178337370, 178346224, 178348715, 178344194, 178352039, 178338198, 178335731, 178340043, 178343562, 178350554, 178352735, 178349059, 178343925, 178345775, 178364103, 178352981, 178344981, 178359372, 178346165, 178350475], "D": [178334153, 178339631, 178345824, 178338369, 178344365, 178352777, 178346625, 178336331, 178336614, 178338914, 178339308, 178344306, 178335725, 178354316, 178351979, 178370227, 178339993, 178338550, 178340955, 178340858], "C": [178329483, 178334722, 178336471, 178331649, 178333101, 178332328, 178330724, 178331197, 178330550, 178331983, 178331086, 178337583, 178330090, 178335594, 178335112, 178340402, 178335550, 178333891, 178336207, 178332182], "B": [178326239, 178328080, 178333593, 178327287, 178329054, 178327314, 178327001, 178329448, 178327787, 178327568, 178327277, 178328845, 178326455, 178328799, 178328762, 178333879, 178327499, 178329269, 178328122, 178330549], "A": [178322883, 178322996, 178323296, 178323217, 178323002, 178322816, 178327673, 178322982, 178323305, 178322810, 178323224, 178323080, 178322764, 178323327, 178324186, 178325267, 178322814, 178324090, 178323226, 178322754], "I": [179538712]}, "name": "I. Arranging Crystal Balls", "statement": "In the world of Compfestnesia, Pak Chanek discovers a secret underground\r\ndungeon. Inside it, there is a treasure chest that is surrounded by n\r\nstatues that are arranged in a circular manner. The statues are numbered\r\nfrom 0 to n-1 with statue i being to the left of statue i+1 and statue\r\nn-1 being to the left of statue 0.Pak Chanek observes that each statue\r\nis holding a crystal ball with an integer between 0 and m-1 inclusive.\r\nLet\u2019s say the integer in the crystal ball of statue i is a_i.The dungeon\r\nprovides instructions that every integer in the crystal balls must be 0\r\nin order to open the treasure chest. To achieve that, Pak Chanek is\r\ngiven an integer k, and he can do zero or more operations. In a single\r\noperation, Pak Chanek does the following: Choose exactly k consecutive\r\nstatues. In other words, choose the statues p, (p+1)\r\nbmod n, (p+2)\r\nbmod n, (p+3)\r\nbmod n,\r\nldots, (p+k-1)\r\nbmod n for some chosen index p. Do one of the following: For all chosen\r\nstatues, change their values of a_i into (a_i+1)\r\nbmod m. For all chosen statues, change their values of a_i into (a_i-1)\r\nbmod m. Help Pak Chanek find the minimum possible number of operations\r\nto open the treasure chest.\r\n", "solutions": ["#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class t,class u>\nvoid print_offset(const pair<t,u>&p,ll off,int suc=1){\n\tprint(p.a+off,2);\n\tprint(p.b+off,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\n//f(a,b) \u304c true \u306a\u3089 a \u3092\u524a\u9664\u3059\u308b\n//less \u3092\u308f\u305f\u3059\u3068 slide max \u304c\u53d6\u308c\u308b\ntemplate<class t,class u>\nstruct slide{\n\tvc<t> x;\n\tvi y;\n\tu f;\n\tint b,e,c,d;\n\tslide(u ff=u()):f(ff){init();}\n\tvoid init(){b=e=c=d=0;}\n\tvoid push(t a){\n\t\twhile(b<e&&f(x[e-1],a))e--;\n\t\tif(e==(int)x.size()){\n\t\t\tx.eb();\n\t\t\ty.eb();\n\t\t}\n\t\tx[e]=a;\n\t\ty[e++]=c++;\n\t}\n\tvoid pop(){if(y[b]==d)b++;d++;}\n\tt get(){return x[b];}\n\tbool has(){return b<e;}\n};\n\nvoid muri(){\n\tcout<<-1<<endl;\n\texit(0);\n}\n\nvoid slv(){\n\tint n,m,k;cin>>n>>m>>k;\n\tvi rw=readvi(n);\n\tint g=gcd(k,n);\n\tvvc<int> ls(g,vi(n/g));\n\tvi dif(n);\n\trep(i,n)dif[i]=(rw[i]-rw[(i+n-1)%n]+m)%m;\n\tvi sum(n);\n\tauto sub=[&](int l,int r,int v){\n\t\tl%=n;r%=n;\n\t\tsum[l]=(sum[l]+m-v)%m;\n\t\tsum[r]=(sum[r]+v)%m;\n\t\tif(r<l)sum[0]=(sum[0]+m-v)%m;\n\t};\n\trep(ini,g){\n\t\tint s=0;\n\t\trep(i,n/g){\n\t\t\tint pos=(ini+i*k)%n;\n\t\t\ts=(s+dif[pos])%m;\n\t\t\tsub(pos,pos+k,s);\n\t\t\tls[ini][i]=s;\n\t\t}\n\t\tif(s){\n\t\t\tmuri();\n\t\t}\n\t}\n\trep(i,n-1)sum[i+1]=(sum[i+1]+sum[i])%m;\n\trep(i,n)rw[i]=(rw[i]+sum[i])%m;\n\tassert(rw==vi(n,rw[0]));\n\t\n\tvi dp(m,inf);\n\tdp[0]=0;\n\t\n\tslide<int,greater<int>> z;\n\t\n\trep(ini,g){\n\t\tvi pos{0,m};\n\t\tvc<tuple<int,int,int,int>> qs;\n\t\tauto add=[&](int l,int r,int a,int b){\n\t\t\tb-=a*l;\n\t\t\tqs.eb(l,r,a,b);\n\t\t\tpos.pb(l);\n\t\t\tpos.pb(r);\n\t\t};\n\t\tfor(auto j:ls[ini]){\n\t\t\tint cur=0;\n\t\t\twhile(cur<m){\n\t\t\t\tif(j<m-j){\n\t\t\t\t\tint w=m/2+1;\n\t\t\t\t\tint nx=min(cur+w-j,m);\n\t\t\t\t\tadd(cur,nx,1,j);\n\t\t\t\t\tj=w%m;\n\t\t\t\t\tcur=nx;\n\t\t\t\t}else{\n\t\t\t\t\tint w=m+1;\n\t\t\t\t\tint nx=min(cur+w-j,m);\n\t\t\t\t\tadd(cur,nx,-1,m-j);\n\t\t\t\t\tj=w%m;\n\t\t\t\t\tcur=nx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmkuni(pos);\n\t\tint s=si(pos)-1;\n\t\tvi as(s+1),bs(s+1);\n\t\tfor(auto [l,r,a,b]:qs){\n\t\t\tl=lwb(pos,l);\n\t\t\tr=lwb(pos,r);\n\t\t\tas[l]+=a;as[r]-=a;\n\t\t\tbs[l]+=b;bs[r]-=b;\n\t\t}\n\t\trep(i,s)as[i+1]+=as[i];\n\t\trep(i,s)bs[i+1]+=bs[i];\n\t\tvi nx(m,inf);\n\t\trep(i,s){\n\t\t\tint l=pos[i],r=pos[i+1],a=as[i],b=bs[i];\n\t\t\tz.init();\n\t\t\trng(j,l-r,0)z.push(dp[j+m]-j*a);\n\t\t\trep(j,m){\n\t\t\t\tz.pop();\n\t\t\t\tz.push(dp[j]-j*a);\n\t\t\t\tint tar=(j+l);\n\t\t\t\tint val=a*tar+b+z.get();\n\t\t\t\tchmin(nx[tar%m],val);\n\t\t\t}\n\t\t}\n\t\tdp.swap(nx);\n\t}\n\tint ans=inf;\n\trep(i,m)if((i*k/g)%m==rw[0])chmin(ans,dp[i]);\n\tif(ans>inf/2)ans=-1;\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "divide and conquer", "dp", "geometry", "graphs", "number theory"], "dificulty": "3500", "interactive": false}