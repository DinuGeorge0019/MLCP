{
    "link": "https://codeforces.com//contest/1787/problem/H",
    "problemId": "1756751",
    "problem_idx": "H",
    "shortId": "1787H",
    "contest_number": "1787",
    "problem_submissions": {
        "I": [
            197474547,
            191162667,
            191147076,
            191159474,
            191182912,
            191180384,
            191173195,
            191158380,
            191159985,
            191279548,
            191153893,
            191147979,
            191219667,
            191170332
        ],
        "G": [
            191152988,
            191152586,
            191141714,
            191145745,
            191143792,
            191147352,
            191147519,
            191158898,
            191159891,
            191160943,
            191153438,
            191155040,
            191144883,
            191170407,
            191170114,
            191152547
        ],
        "F": [
            191146155,
            191132842,
            191134802,
            191136901,
            191128020,
            191139771,
            191139131,
            191147114,
            191152778,
            191144574,
            191147232,
            191145790,
            191135060,
            191146379,
            191144901,
            191136231,
            191134824,
            191143478,
            191143747,
            191145614
        ],
        "E": [
            191137894,
            191126319,
            191169100,
            191131011,
            191146734,
            191132024,
            191134009,
            191128652,
            191130752,
            191135324,
            191128162,
            191137413,
            191115850,
            191140133,
            191140025,
            191121022,
            191131209,
            191138279,
            191133339,
            191131279
        ],
        "D": [
            191132976,
            191120161,
            191124203,
            191123443,
            191137713,
            191128946,
            191128273,
            191122289,
            191126977,
            191131112,
            191124722,
            191125562,
            191128102,
            191135389,
            191135592,
            191131056,
            191123065,
            191127620,
            191126290,
            191127861
        ],
        "C": [
            191125268,
            191113889,
            191117948,
            191115059,
            191116269,
            191118107,
            191120001,
            191140669,
            191115010,
            191125411,
            191117705,
            191118998,
            191121343,
            191121072,
            191117056,
            191128472,
            191115952,
            191117237,
            191118951,
            191120349
        ],
        "B": [
            191121944,
            191109607,
            191111770,
            191108995,
            191110155,
            191109908,
            191113645,
            191109634,
            191109874,
            191121868,
            191110598,
            191110575,
            191117560,
            191109576,
            191110819,
            191112301,
            191110138,
            191111938,
            191108264,
            191111930
        ],
        "A": [
            191118000,
            191106352,
            191108603,
            191106770,
            191106814,
            191106284,
            191107425,
            191105859,
            191106157,
            191118169,
            191107747,
            191106297,
            191105730,
            191106101,
            191107070,
            191108687,
            191105956,
            191107701,
            191105869,
            191106761
        ],
        "H": [
            191116884,
            191151161,
            191155682,
            191157247,
            191138915,
            191146913,
            191162451,
            191161022,
            191128443,
            191126961,
            191251422,
            191150263,
            191149572,
            191156328
        ]
    },
    "name": "H. Codeforces Scoreboard",
    "statement": "You are participating in a Codeforces Round with n problems. You spend\r\nexactly one minute to solve each problem, the time it takes to submit a\r\nproblem can be ignored. You can only solve at most one problem at any\r\ntime. The contest starts at time 0, so you can make your first\r\nsubmission at any time t\r\nge 1 minutes. Whenever you submit a problem, it is always accepted.The\r\nscoring of the i-th problem can be represented by three integers k_i,\r\nb_i, and a_i. If you solve it at time t minutes, you get\r\nmax(b_i - k_i\r\ncdot t,a_i) points.Your task is to choose an order to solve all these n\r\nproblems to get the maximum possible score. You can assume the contest\r\nis long enough to solve all problems.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nconst int MAXN = 1000005;\nconst int MAXT = 2100000;\nconst lint inf = 4e18;\nconst int mod = 1e9 + 7;\n\nstruct line {\n\tlint A, B;\n\tint idx;\n\tlint eval(lint x) { return A * x + B; }\n\t// returns the x-intercept of intersection \"strictly\" larger than T\n\tlint cross_after(line &x, lint T) {\n\t\tif (x.A == A) {\n\t\t\treturn inf;\n\t\t}\n\t\tlint up = x.B - B;\n\t\tlint dn = A - x.A;\n\t\tif (dn < 0) {\n\t\t\tdn *= -1;\n\t\t\tup *= -1;\n\t\t}\n\t\tlint incep = (up <= 0 ? -((-up) / dn) : (up + dn - 1) / dn);\n\t\tif (incep > T)\n\t\t\treturn incep;\n\t\treturn inf;\n\t}\n};\n\nstruct kst { // min kinetic segment tree\n\tline tree[MAXT];\n\tlint melt[MAXT], T;\n\tpi lazy[MAXT];\n\tint n;\n\tbool cmp(line &a, line &b) {\n\t\tlint l = a.eval(T), r = b.eval(T);\n\t\tif (l != r)\n\t\t\treturn l > r;\n\t\treturn a.A > b.A;\n\t}\n\tvoid pull(int p) {\n\t\ttree[p] = cmp(tree[2 * p], tree[2 * p + 1]) ? tree[2 * p + 1] : tree[2 * p];\n\t\tmelt[p] = min({melt[2 * p], melt[2 * p + 1], tree[2 * p].cross_after(tree[2 * p + 1], 0)});\n\t}\n\tvoid init(int s, int e, int p, vector<line> &l) {\n\t\tif (s == e) {\n\t\t\ttree[p] = l[s];\n\t\t\tmelt[p] = inf;\n\t\t\tlazy[p] = {0, 0};\n\t\t\treturn;\n\t\t}\n\t\tlazy[p] = {0, 0};\n\t\tint m = (s + e) / 2;\n\t\tinit(s, m, 2 * p, l);\n\t\tinit(m + 1, e, 2 * p + 1, l);\n\t\tpull(p);\n\t}\n\tvoid lazydown(int p) {\n\t\tfor (int i = 2 * p; i < 2 * p + 2; i++) {\n\t\t\tlazy[i][0] += lazy[p][0];\n\t\t\tlazy[i][1] += lazy[p][1];\n\t\t\ttree[i].B += lazy[p][0] * tree[i].A + lazy[p][1];\n\t\t\tmelt[i] -= lazy[p][0];\n\t\t}\n\t\tlazy[p][0] = lazy[p][1] = 0;\n\t}\n\tvoid propagate(int p) {\n\t\tif (melt[p] > 0)\n\t\t\treturn;\n\t\tlazydown(p);\n\t\tpropagate(2 * p);\n\t\tpropagate(2 * p + 1);\n\t\tpull(p);\n\t}\n\tlint query(int s, int e, int ps, int pe, int p = 1) {\n\t\tif (e < ps || pe < s)\n\t\t\treturn inf;\n\t\tif (s <= ps && pe <= e)\n\t\t\treturn tree[p].eval(0);\n\t\tint pm = (ps + pe) / 2;\n\t\tlazydown(p);\n\t\treturn min(query(s, e, ps, pm, 2 * p), query(s, e, pm + 1, pe, 2 * p + 1));\n\t}\n\tvoid heaten(int s, int e, int ps, int pe, int p, lint v) {\n\t\tif (e < ps || pe < s)\n\t\t\treturn;\n\t\tif (s <= ps && pe <= e) {\n\t\t\tlazy[p][0] += v;\n\t\t\ttree[p].B += v * tree[p].A;\n\t\t\tmelt[p] -= v;\n\t\t\tpropagate(p);\n\t\t\treturn;\n\t\t}\n\t\tlazydown(p);\n\t\tint pm = (ps + pe) / 2;\n\t\theaten(s, e, ps, pm, 2 * p, v);\n\t\theaten(s, e, pm + 1, pe, 2 * p + 1, v);\n\t\tpull(p);\n\t}\n\tvoid add(int s, int e, int ps, int pe, int p, lint v) {\n\t\tif (e < ps || pe < s)\n\t\t\treturn;\n\t\tif (s <= ps && pe <= e) {\n\t\t\tlazy[p][1] += v;\n\t\t\ttree[p].B += v;\n\t\t\treturn;\n\t\t}\n\t\tlazydown(p);\n\t\tint pm = (ps + pe) / 2;\n\t\tadd(s, e, ps, pm, 2 * p, v);\n\t\tadd(s, e, pm + 1, pe, 2 * p + 1, v);\n\t\tpull(p);\n\t}\n\n\tvoid init(vector<line> &l, lint _T) {\n\t\tn = sz(l);\n\t\tT = _T;\n\t\tinit(0, n - 1, 1, l);\n\t}\n} kst;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tlint sum = 0;\n\t\tvector<int> k(n), b(n), a(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> k[i] >> b[i] >> a[i];\n\t\t\tb[i] -= a[i];\n\t\t\tsum += a[i];\n\t\t}\n\t\tvector<line> seg(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tseg[i].A = k[i];\n\t\t\tseg[i].B = k[i] - b[i];\n\t\t}\n\t\tsort(all(seg), [&](const line &a, const line &b) { return pi{a.A, a.B} > pi{b.A, b.B}; });\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tseg[i].idx = i;\n\t\t}\n\t\tkst.init(seg, 0);\n\t\tlint ret = sum;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tauto val = kst.tree[1].idx;\n\t\t\tsum -= kst.tree[1].eval(0);\n\t\t\tret = max(ret, sum);\n\t\t\tkst.heaten(val + 1, n - 1, 0, n - 1, 1, 1);\n\t\t\tkst.add(0, val - 1, 0, n - 1, 1, seg[val].A);\n\t\t\tkst.add(val, val, 0, n - 1, 1, lint(1e18));\n\t\t}\n\t\tcout << ret << \"\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "geometry"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Codeforces Scoreboard.json",
    "editorial_link": "https://codeforces.com//blog/entry/112009",
    "editorial": "Since , we can pre-calculate the sum of . Let . Now our mission is to\r\nminimize the sum of .If we assume for some , sort these problems in\r\ndescending order of , then assign to their in order. For , they can be\r\ndirectly calculated.There comes a DP solution: Let be the minimum sum,\r\nwhen considering first problems (after sorting), problems of them\r\nsatisfying .The time complexity is .We can find that is convex. Proof\r\nbelow:Let .Thus , rewrite this formula with the original recursive\r\nformula.Then Let be Subtract the above two formulas from each other\r\nBecause is monotone non-increasing, so we can use mathematical induction\r\nto proof that for , the increase speed of is faster than that of . We\r\ncan find a critical value that and .So compared with , the first part of\r\nthe sequence remains unchanged, and the last part is added with , with\r\nan additional number in the middle, where is the maximum number\r\nsatisfied . Use the treap to maintain this sequence, which might be\r\ncalled the slope trick.\r\n",
    "hint": []
}