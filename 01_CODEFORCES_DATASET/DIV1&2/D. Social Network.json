{
    "link": "https://codeforces.com//contest/1609/problem/D",
    "problemId": "1205812",
    "problem_idx": "D",
    "shortId": "1609D",
    "contest_number": "1609",
    "problem_submissions": {
        "H": [
            137263072,
            140966657,
            137541381,
            137373776,
            137353707,
            137353217
        ],
        "G": [
            137246775,
            137257898,
            137258174,
            137261032,
            137258429,
            137256905,
            137250571,
            137257690,
            137251480,
            137263274,
            137259638,
            137276051,
            137269427,
            137261135,
            137260806,
            137259792,
            137262185,
            137263614,
            137264862,
            137254900,
            137261420,
            137264154
        ],
        "F": [
            137240106,
            137246731,
            137244466,
            137246785,
            137246316,
            137246745,
            137260178,
            137270360,
            137247766,
            137257633,
            137249504,
            137249777,
            137249032,
            137252722,
            137252015,
            137251624,
            137252333,
            137250283,
            137261839,
            137252294,
            137249612
        ],
        "E": [
            137234780,
            137235959,
            137233979,
            137232935,
            137235656,
            137237935,
            137233267,
            137237781,
            137236310,
            137235301,
            137237711,
            137241732,
            137237330,
            137241596,
            137235797,
            137236926,
            137239464,
            137239281,
            137241206,
            137238999
        ],
        "D": [
            137226570,
            137230215,
            137231182,
            137228712,
            137232181,
            137231416,
            137229857,
            137231314,
            137233347,
            137230846,
            137231581,
            137229849,
            137233415,
            137234328,
            137231105,
            137231235,
            137232699,
            137231119,
            137233860,
            137235117
        ],
        "C": [
            137224003,
            137226381,
            137228113,
            137226088,
            137228622,
            137227880,
            137227092,
            137227813,
            137229692,
            137227035,
            137228022,
            137226433,
            137228702,
            137230474,
            137231768,
            137227164,
            137229482,
            137228456,
            137229353,
            137230487
        ],
        "B": [
            137222196,
            137223090,
            137224802,
            137223100,
            137224371,
            137223720,
            137223346,
            137224383,
            137222999,
            137223539,
            137224162,
            137223482,
            137224120,
            137224040,
            137223954,
            137223074,
            137224144,
            137224291,
            137224533,
            137224451
        ],
        "A": [
            137221600,
            137221784,
            137221681,
            137221800,
            137221985,
            137221740,
            137221875,
            137222467,
            137221786,
            137221979,
            137222676,
            137221642,
            137222045,
            137222137,
            137226851,
            137224172,
            137221659,
            137222130,
            137222631,
            137222150
        ]
    },
    "name": "D. Social Network",
    "statement": "William arrived at a conference dedicated to cryptocurrencies.\r\nNetworking, meeting new people, and using friends’ connections are\r\nessential to stay up to date with the latest news from the world of\r\ncryptocurrencies.The conference has n participants, who are initially\r\nunfamiliar with each other. William can introduce any two people, a and\r\nb, who were not familiar before, to each other. William has d\r\nconditions, i’th of which requires person x_i to have a connection to\r\nperson y_i. Formally, two people x and y have a connection if there is\r\nsuch a chain p_1=x, p_2, p_3,\r\ndots, p_k=y for which for all i from 1 to k - 1 it’s true that two\r\npeople with numbers p_i and p_{i + 1} know each other.For every i (1\r\nle i\r\nle d) William wants you to calculate the maximal number of acquaintances\r\none person can have, assuming that William satisfied all conditions from\r\n1 and up to and including i and performed i introductions. The\r\nconditions are being checked after William performed i introductions.\r\nThe answer for each i must be calculated independently. It means that\r\nwhen you compute an answer for i, you should assume that no two people\r\nhave been introduced to each other yet.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 28.11.2021 17:43:04       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n  vector<int> sz;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n    sz.assign(n, 1);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      sz[y] += sz[x];\n      sz[x] = 0;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, dd;\n  cin >> n >> dd;\n  dsu d(n);\n  int cc = 1;\n  for (int it = 1; it <= dd; it++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    if (!d.unite(x, y)) {\n      cc += 1;\n    }\n    vector<int> b;\n    for (int i = 0; i < n; i++) {\n      if (d.get(i) == i) {\n        b.push_back(d.sz[i]);\n      }\n    }\n    sort(b.rbegin(), b.rend());\n    assert(cc <= (int) b.size());\n    cout << accumulate(b.begin(), b.begin() + cc, 0) - 1 << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Social Network.json",
    "editorial_link": "https://codeforces.com//blog/entry/97350",
    "editorial": "Note that the conditions form a collection of disjoint sets. Consider\r\ntwo situations: The next condition connects two previously unconnected\r\nsets: then we will simply unite. The next condition connects two\r\npreviously connected sets: this case allows us to \"postpone\" an edge to\r\nuse it as we like. The second observation is that inside a set, the most\r\nadvantageous construction for us has the shape of a star (a star is a\r\ngraph, wherefrom one vertex there is an edge to all the others in this\r\nset). It remains not to forget about the deferred ribs. We can use them\r\nto connect some sets. The most profitable solution would be to connect\r\nsets with maximum sizes. The constraints of the problem make it possible\r\nto do this by a simple traversal over the sets in the order of sorting\r\nby the number of vertices in them.Note that it was possible to solve the\r\nproblem for more complex constraints using a tree of segments or two\r\nset<>, but this was not required in this problem.\r\n",
    "hint": []
}