{
    "link": "https://codeforces.com//contest/1740/problem/C",
    "problemId": "1611412",
    "problem_idx": "C",
    "shortId": "1740C",
    "contest_number": "1740",
    "problem_submissions": {
        "H": [
            178379430,
            178389839,
            178370970,
            178389787,
            178394159,
            178405718,
            178393380,
            178400994,
            178473578
        ],
        "G": [
            178363447,
            178373152,
            178390136,
            178380782,
            178380133,
            178366412,
            178381208,
            178372252,
            178364309,
            178377085,
            178379805,
            178389960,
            178394186,
            178390668,
            178429073,
            178399239,
            178398964,
            178398319,
            178393777,
            178389532,
            178457114,
            178457090,
            178457069,
            178456881,
            178456598
        ],
        "F": [
            178342509,
            178355726,
            178353094,
            178359313,
            178375325,
            178347566,
            178343206,
            178355344,
            178419766,
            178363409,
            178364030,
            178360259,
            178371042,
            178378751,
            178405026,
            178404845,
            178404014,
            178403791,
            178403569,
            178376955,
            178368121,
            178355891,
            178355560,
            178363171,
            178364934
        ],
        "E": [
            178337370,
            178346224,
            178348715,
            178344194,
            178352039,
            178338198,
            178335731,
            178340043,
            178343562,
            178350554,
            178352735,
            178349059,
            178343925,
            178345775,
            178364103,
            178352981,
            178344981,
            178359372,
            178346165,
            178350475
        ],
        "D": [
            178334153,
            178339631,
            178345824,
            178338369,
            178344365,
            178352777,
            178346625,
            178336331,
            178336614,
            178338914,
            178339308,
            178344306,
            178335725,
            178354316,
            178351979,
            178370227,
            178339993,
            178338550,
            178340955,
            178340858
        ],
        "C": [
            178329483,
            178334722,
            178336471,
            178331649,
            178333101,
            178332328,
            178330724,
            178331197,
            178330550,
            178331983,
            178331086,
            178337583,
            178330090,
            178335594,
            178335112,
            178340402,
            178335550,
            178333891,
            178336207,
            178332182
        ],
        "B": [
            178326239,
            178328080,
            178333593,
            178327287,
            178329054,
            178327314,
            178327001,
            178329448,
            178327787,
            178327568,
            178327277,
            178328845,
            178326455,
            178328799,
            178328762,
            178333879,
            178327499,
            178329269,
            178328122,
            178330549
        ],
        "A": [
            178322883,
            178322996,
            178323296,
            178323217,
            178323002,
            178322816,
            178327673,
            178322982,
            178323305,
            178322810,
            178323224,
            178323080,
            178322764,
            178323327,
            178324186,
            178325267,
            178322814,
            178324090,
            178323226,
            178322754
        ],
        "I": [
            179538712
        ]
    },
    "name": "C. Bricks and Bags",
    "statement": "There are n bricks numbered from 1 to n. Brick i has a weight of a_i.Pak\r\nChanek has 3 bags numbered from 1 to 3 that are initially empty. For\r\neach brick, Pak Chanek must put it into one of the bags. After this,\r\neach bag must contain at least one brick.After Pak Chanek distributes\r\nthe bricks, Bu Dengklek will take exactly one brick from each bag. Let\r\nw_j be the weight of the brick Bu Dengklek takes from bag j. The score\r\nis calculated as |w_1 - w_2| + |w_2 - w_3|, where |x| denotes the\r\nabsolute value of x.It is known that Bu Dengklek will take the bricks in\r\nsuch a way that minimises the score. What is the maximum possible final\r\nscore if Pak Chanek distributes the bricks optimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::sort(a.begin(), a.end());\n    \n    int ans = a[n - 1] - a[0];\n    for (int i = 0; i < n - 1; i++) {\n        ans = std::max({ans, a[i + 1] + a[n - 1] - 2 * a[i], 2 * a[i + 1] - a[i] - a[0]});\n    }\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "greedy",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Bricks and Bags.json",
    "editorial_link": "https://codeforces.com//blog/entry/108567",
    "editorial": "Firstly, sort . From now on, we will always refer to the sorted array\r\n.Let be the index of the brick taken by Bu Dengklek from bag . The\r\nconfiguration of must be in the form of one of the following: Letâs look\r\nat the third case. Letâs consider the case where . If this is the case,\r\nletâs look at all possible cases for the brick at index . If Pak Chanek\r\nputs brick into bag , it is more optimal for Bu Dengklek to take that\r\nbrick from bag instead of because . If Pak Chanek puts brick into bag ,\r\nit is more optimal for Bu Dengklek to take that brick from bag instead\r\nof because . If Pak Chanek puts brick into bag , it is more optimal for\r\nBu Dengklek to take that brick from bag instead of because . This means,\r\nchoosing such that is always less optimal for Bu Dengklek. Therefore, Bu\r\nDengklek will take the bricks such that if , then also holds.A similar\r\nlogic can be used for the fourth case. So, we can obtain that Bu\r\nDengklek will always take the bricks such that the configuration of is\r\nin the form of one of the following: and and In fact, Pak Chanek is\r\nalways able to force it such that the bricks taken by Bu Dengklek form\r\nany configuration of that follows one of the constraints above. Letâs\r\nlook at one possible construction. For a configuration of construct an\r\norder of the bags such that . Then, Pak Chanek can force Bu Dengklek to\r\nchoose that configuration by doing the following: Put the bricks at\r\nindices from to into bag . Put the bricks at indices from to into bag .\r\nPut the bricks at indices from to into bag . Therefore, we just need to\r\nfind the values of satisfying the constraints above such that is\r\nmaximised.To maximise the final score, we can see that it is always more\r\noptimal to either use the third or the fourth case for . For the third\r\ncase, it is always more optimal to maximise , so we should set . A\r\nsimilar logic can be used for the fourth case to see that we should set\r\n.Therefore, the maximum final score is the maximum of these two cases:\r\nwith . with . Time complexity for each test case:\r\n",
    "hint": []
}