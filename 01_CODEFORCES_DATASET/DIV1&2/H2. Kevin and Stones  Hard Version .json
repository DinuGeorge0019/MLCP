{
    "link": "https://codeforces.com//contest/2061/problem/H2",
    "problemId": "3155963",
    "problem_idx": "H2",
    "shortId": "2061H2",
    "contest_number": "2061",
    "problem_submissions": {
        "F2": [
            302127475,
            302092403,
            302114656,
            302114350,
            302118052,
            302128136,
            302099327,
            302127501,
            302105569,
            302158287,
            302158231,
            302158981,
            302158740,
            302158593,
            302155955
        ],
        "H1": [
            302102508,
            302123846,
            302123275,
            302120307,
            302128240,
            302113263,
            302214973,
            302214838,
            302492170,
            302128311,
            302150853
        ],
        "G": [
            302087277,
            302104836,
            302092310,
            302101290,
            302098614,
            302099751,
            302090244,
            302079497,
            302107342,
            302102846,
            302118471,
            302119832,
            302088828,
            302085801,
            302097252,
            302107147,
            302100360,
            302104471
        ],
        "F1": [
            302070705,
            302068249,
            302076903,
            302139304,
            302085853,
            302085964,
            302087951,
            302076823,
            302099111,
            302088499,
            302088697,
            302106078,
            302076066,
            302095307,
            302083979,
            302077009,
            302082649,
            302158914,
            302081283
        ],
        "E": [
            302060766,
            302059898,
            302064375,
            302146780,
            302146561,
            302146204,
            302145996,
            302145832,
            302145821,
            302145812,
            302060519,
            302071650,
            302062756,
            302067337,
            302066558,
            302071373,
            302078018,
            302075359,
            302069841,
            302067118,
            302063628,
            302073608,
            302071649,
            302075889,
            302072748
        ],
        "D": [
            302057147,
            302056206,
            302056876,
            302056600,
            302064486,
            302056648,
            302061458,
            302060302,
            302063595,
            302065433,
            302068805,
            302064352,
            302061742,
            302059104,
            302069059,
            302065232,
            302069194,
            302062940
        ],
        "C": [
            302053893,
            302052972,
            302060290,
            302053477,
            302058781,
            302053556,
            302058513,
            302056661,
            302060439,
            302057971,
            302066087,
            302059912,
            302059144,
            302055184,
            302066070,
            302060621,
            302062953,
            302059461
        ],
        "B": [
            302048946,
            302050832,
            302052328,
            302049723,
            302053638,
            302049221,
            302054664,
            302052475,
            302055824,
            302052997,
            302059041,
            302057352,
            302051579,
            302051983,
            302056196,
            302056129,
            302055478,
            302054565
        ],
        "A": [
            302047037,
            302049009,
            302047309,
            302047023,
            302047283,
            302047053,
            302047177,
            302047108,
            302047316,
            302047521,
            302047571,
            302047610,
            302047369,
            302048738,
            302047337,
            302048364,
            302049028,
            302047123
        ],
        "H2": [
            302541217
        ],
        "I": [
            302144176,
            302142123,
            302142064,
            302141919,
            302124920,
            302518298,
            302518173,
            302517883
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138620",
    "editorial": "First, if , the transformation is trivially feasible. Beyond this\r\ntrivial case, let us consider the necessary conditions: The initial\r\nstate must allow at least one valid move. The target state must allow at\r\nleast one valid move. For every connected component, the number of\r\nstones in the initial state must match the number of stones in the\r\ntarget state. If a connected component is a bipartite graph, then after\r\na coloring of the graph, the number of stones in each part must also\r\nsatisfy corresponding constraints. We can represent a node as two\r\nseparate nodes: and , corresponding to states reachable in even and odd\r\nsteps, respectively.For an undirected edge , create directed edges\r\nbetween and , as well as between and .Using this transformation: It is\r\nsufficient to enumerate whether the target state is reached on an even\r\nor odd step. For each connected component, count the number of stones\r\nand verify that the condition is satisfied. The bipartite graph\r\nconstraint is inherently handled within this framework, eliminating the\r\nneed for special-case treatment. The first two conditions, ensuring that\r\nthe initial and target states allow at least one valid move, can be\r\nverified using bipartite graph matching. If a valid matching exists, the\r\nconditions are satisfied.Time Complexity: , where is the number of nodes\r\nand is the number of edges.It can be shown that the above conditions are\r\nnot only necessary but also sufficient. By satisfying these conditions,\r\nit is guaranteed that a valid transformation from to can be\r\nconstructed.This is a simpler, non-constructive proof. Below is a brief\r\noutline of the proof idea. Since this proof doesnâ€™t provide much help\r\nfor the construction part, some details are omitted.The problem can be\r\neasily formulated as a network flow problem. You can construct a layered\r\ngraph where each layer represents one step of stone movement, and the\r\nflow represents the movement of stones. Determining whether the stones\r\ncan move from the initial state to the target state is equivalent to\r\nchecking whether the flow is saturated. Let represent the number of\r\nstones. According to the Max-flow Min-cut Theorem, we need to consider\r\nwhether there exists a cut with a capacity smaller than .If we sort all\r\nthe cut edges by their layer indices, there must exist two adjacent cut\r\nedges whose layers, or their distance from the source or sink, exceed .\r\nTo disconnect the graph, one of these two regions must fully disconnect\r\nthe graph. Otherwise, after layers, the graph will remain connected.\r\nHowever, since there exists a valid matching between the initial and\r\ntarget states, it is possible to repeatedly move along this matching.\r\nThis ensures that there exists a flow of size from the source or sink to\r\nany layer, meaning that the graph cannot be disconnected using fewer\r\nthan edges. In the graph after splitting the nodes, if we combine the\r\nmatching edges from and , we obtain a structure consisting of chains and\r\ncycles. Note that for any cycle, the and edges alternate, meaning we can\r\nalways adjust the matching of in this cycle to make it identical to .\r\nAfterward, we can find a spanning tree among the remaining edges. This\r\nspanning tree still satisfies both the existence of matching and\r\nconnectivity conditions. Moreover, all stones in and (after coloring the\r\ngraph with black and white) will reside on the same layer.For trees, it\r\nseems straightforward to move stones outward for subtrees with more\r\nstones and inward for subtrees with fewer stones. However, due to the\r\nconstraint that each step must involve movement, deadlock situations may\r\narise, making it less trivial.For example, consider the following\r\nscenario: After the first move, shifts to positions and . If we only\r\nconsider the number of stones in the subtrees of and or simply match\r\nbased on the shortest distance, the stones might return to and , leading\r\nto a deadlock. The correct sequence of moves should be , , then , and\r\nfinally .Since and are symmetric, a meet-in-the-middle approach can be\r\napplied, where we simultaneously consider both and and aim to transform\r\nthem into identical states. First find the matching for and . The idea\r\nis to identify the \"outermost\" matching edge (the definition of\r\n\"outermost\" will be formalized below). WLOG, we assume it is in . Then,\r\nlocate the nearest matching edge in relative to . Move the stones from\r\nto the corresponding nodes in . Once they reach , let them move back and\r\nforth between and . For the remaining unmatched nodes in , let them\r\noscillate along their own matching edges for the first two steps. If the\r\n\"outermost\" matching edge is in , we can perform the corresponding\r\noperations in reverse order. The explanation of how it works: First,\r\nsince we are choosing the nearest matching edge in , and the remaining\r\nstones move along their matching edges for the first two steps. The\r\nremaining stones will not meet the path corresponding to . Otherwise, it\r\nwould contradict the definition of \"nearest\". After moving to , the\r\nstones will repeatedly move along the matching edge until the end of the\r\nprocess. This means becomes impassable for subsequent moves. Therefore,\r\nwe require this edge to be \"outermost,\" meaning that after removing\r\nthese two nodes, the remaining parts of and must still be connected. To\r\nfind the \"outermost\" edge, we can iteratively remove the leaf nodes of\r\nthe graph (nodes with degree at most 1). The first matching edge where\r\nboth nodes are removed is the \"outermost\" edge. Note that this\r\n\"outermost\" criterion must consider both and , taking the \"outermost\"\r\nedge among all matches in and . For the remaining stones, since we\r\nensure the process does not encounter this path or , the problem reduces\r\nto a subproblem, which can be solved using the same method.This approach\r\ntakes two steps each time and removes one matching edge. If the tree has\r\nnodes, the number of matching edges will not exceed , so we can solve\r\nthe problem in at most steps.Time complexity: .Note: The bound of is\r\ntight. For example, consider a chain with an additional triangular loop\r\nat the tail. If the goal is to move from to , at least one stone must\r\ntraverse the triangular loop to change its parity. This requires at\r\nleast steps.\r\n",
    "name": "H2. Kevin and Stones  Hard Version ",
    "statement": "Kevin has an undirected graph with n vertices and m edges. Initially,\r\nsome vertices contain stones, which Kevin wants to move to new\r\npositions. Kevin can perform the following operation: For each stone at\r\nu_i, select a neighboring vertex v_i. Simultaneously move each stone\r\nfrom u_i to its corresponding v_i. At any time, each vertex can contain\r\nstone.Determine whether a valid sequence of operations exists that moves\r\nthe stones from the initial state to the target state. Output a valid\r\nsequence of operations with no more than 2n moves if one exists. It can\r\nbe proven that if a valid sequence exists, a valid sequence with no more\r\nthan 2n moves exists.\r\n",
    "solutions": [
        "#include <algorithm>#include <array>#include <bitset>#include <cassert>#include <chrono>#include <climits>#include <cmath>#include <complex>#include <cstring>#include <functional>#include <iomanip>#include <iostream>#include <map>#include <numeric>#include <queue>#include <random>#include <set>#include <vector>using namespace std;Â using ll = long long;using db = long double;  // or double, if TL is tightusing str = string;      // yay python!Â // pairsusing pi = pair<int, int>;using pl = pair<ll, ll>;using pd = pair<db, db>;#define mp make_pair#define f first#define s secondÂ #define tcT template <class T#define tcTU tcT, class U// ^ lol this makes everything look weird but I'll try ittcT > using V = vector<T>;tcT, size_t SZ > using AR = array<T, SZ>;using vi = V<int>;using vb = V<bool>;using vl = V<ll>;using vd = V<db>;using vs = V<str>;using vpi = V<pi>;using vpl = V<pl>;using vpd = V<pd>;Â // vectors#define sz(x) int(size(x))#define bg(x) begin(x)#define all(x) bg(x), end(x)#define rall(x) rbegin(x), rend(x)#define sor(x) sort(all(x))#define rsz resize#define ins insert#define pb push_back#define eb emplace_back#define ft front()#define bk back()Â #define lb lower_bound#define ub upper_boundtcT > int lwb(const V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }tcT > int upb(const V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }Â // loops#define FOR(i, a, b) for (int i = (a); i < (b); ++i)#define F0R(i, a) FOR(i, 0, a)#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)#define R0F(i, a) ROF(i, 0, a)#define rep(a) F0R(_, a)#define each(a, x) for (auto &a : x)Â const int MOD = 998244353;  // 1e9+7;const int MX = (int)2e5 + 5;const ll BIG = 1e18;  // not too close to LLONG_MAXconst db PI = acos((db)-1);const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!mt19937 rng(0);template <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;Â // bitwise ops// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.htmlconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits setconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\t                         // USACO updates ...\treturn x == 0 ? 0 : 31 - __builtin_clz(x);}  // floor(log2(x))constexpr int p2(int x) { return 1 << x; }constexpr int msk2(int x) { return p2(x) - 1; }Â ll cdiv(ll a, ll b) {\treturn a / b + ((a ^ b) > 0 && a % b);}  // divide a by b rounded upll fdiv(ll a, ll b) {\treturn a / b - ((a ^ b) < 0 && a % b);}  // divide a by b rounded downÂ tcT > bool ckmin(T &a, const T &b) {\treturn b < a ? a = b, 1 : 0;}  // set a = min(a,b)tcT > bool ckmax(T &a, const T &b) {\treturn a < b ? a = b, 1 : 0;}  // set a = max(a,b)Â tcTU > T fstTrue(T lo, T hi, U f) {\t++hi;\tassert(lo <= hi);  // assuming f is increasing\twhile (lo < hi) {  // find first index such that f is true\t\tT mid = lo + (hi - lo) / 2;\t\tf(mid) ? hi = mid : lo = mid + 1;\t}\treturn lo;}tcTU > T lstTrue(T lo, T hi, U f) {\t--lo;\tassert(lo <= hi);  // assuming f is decreasing\twhile (lo < hi) {  // find first index such that f is true\t\tT mid = lo + (hi - lo + 1) / 2;\t\tf(mid) ? lo = mid : hi = mid - 1;\t}\treturn lo;}tcT > void remDup(vector<T> &v) {  // sort and remove duplicates\tsort(all(v));\tv.erase(unique(all(v)), end(v));}tcTU > void safeErase(T &t, const U &u) {\tauto it = t.find(u);\tassert(it != end(t));\tt.erase(it);}Â inline namespace IO {#define SFINAE(x, ...)                                                         \\\ttemplate <class, class = void> struct x : std::false_type {};              \\\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}Â SFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));SFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));SFINAE(IsTuple, typename std::tuple_size<T>::type);SFINAE(Iterable, decltype(std::begin(std::declval<T>())));Â template <auto &is> struct Reader {\ttemplate <class T> void Impl(T &t) {\t\tif constexpr (DefaultI<T>::value) is >> t;\t\telse if constexpr (Iterable<T>::value) {\t\t\tfor (auto &x : t) Impl(x);\t\t} else if constexpr (IsTuple<T>::value) {\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\t}\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }};Â template <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }#define def(t, args...)                                                        \\\tt args;                                                                    \\\tre(args);Â template <auto &os, bool debug, bool print_nd> struct Writer {\tstring comma() const { return debug ? \",\" : \"\"; }\ttemplate <class T> constexpr char Space(const T &) const {\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\t\t                                                             : ' ';\t}\ttemplate <class T> void Impl(T const &t) const {\t\tif constexpr (DefaultO<T>::value) os << t;\t\telse if constexpr (Iterable<T>::value) {\t\t\tif (debug) os << '{';\t\t\tint i = 0;\t\t\tfor (auto &&x : t)\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\t\t\tif (debug) os << '}';\t\t} else if constexpr (IsTuple<T>::value) {\t\t\tif (debug) os << '(';\t\t\tstd::apply(\t\t\t    [this](auto const &...args) {\t\t\t\t    int i = 0;\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\t\t\t\t     ...);\t\t\t    },\t\t\t    t);\t\t\tif (debug) os << ')';\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\t}\ttemplate <class T> void ImplWrapper(T const &t) const {\t\tif (debug) os << \"\\033[0;31m\";\t\tImpl(t);\t\tif (debug) os << \"\\033[0m\";\t}\ttemplate <class... Ts> void print(Ts const &...ts) const {\t\t((Impl(ts)), ...);\t}\ttemplate <class F, class... Ts>\tvoid print_with_sep(const std::string &sep, F const &f,\t                    Ts const &...ts) const {\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\t}\tvoid print_with_sep(const std::string &) const { os << '\\n'; }};Â template <class... Ts> void pr(Ts const &...ts) {\tWriter<cout, false, true>{}.print(ts...);}template <class... Ts> void ps(Ts const &...ts) {\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);}}  // namespace IOÂ inline namespace Debug {template <typename... Args> void err(Args... args) {\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);}template <typename... Args> void errn(Args... args) {\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);}Â void err_prefix(str func, int line, string args) {\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\t     << \" | \"\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\t     << \":\"\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\t     << \" - \"\t     << \"[\" << args << \"] = \";}Â #ifdef LOCAL#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)#else#define dbg(...)#define dbgn(args...)#endifÂ const auto beg_time = std::chrono::high_resolution_clock::now();// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1double time_elapsed() {\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\t                                beg_time)\t    .count();}}  // namespace DebugÂ inline namespace FileIO {void setIn(str s) { freopen(s.c_str(), \"r\", stdin); }void setOut(str s) { freopen(s.c_str(), \"w\", stdout); }void setIO(str s = \"\") {\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\tcout << fixed << setprecision(12);\t// cin.exceptions(cin.failbit);\t// throws exception when do smth illegal\t// ex. try to read letter into int\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO}}  // namespace FileIOÂ // make sure to intialize ALL GLOBAL VARS between tcs!Â int N, ones;Â /** * Description: Fast bipartite matching. * Time: $O(M\\sqrt N)$ * Source: Own * Verification: https://old.yosupo.jp/problem/bipartitenxting */Â vpi maxMatch(int L, int R, const vpi &edges) {\tV<vi> adj = V<vi>(L);\tvi nxt(L, -1), prv(R, -1), lev, ptr;\tF0R(i, sz(edges)) adj.at(edges[i].f).pb(edges[i].s);\twhile (true) {\t\tlev = ptr = vi(L);\t\tint max_lev = 0;\t\tqueue<int> q;\t\tF0R(i, L) if (nxt[i] == -1) lev[i] = 1, q.push(i);\t\twhile (sz(q)) {\t\t\tint x = q.ft;\t\t\tq.pop();\t\t\tfor (int y : adj[x]) {\t\t\t\tint z = prv[y];\t\t\t\tif (z == -1) max_lev = lev[x];\t\t\t\telse if (!lev[z]) lev[z] = lev[x] + 1, q.push(z);\t\t\t}\t\t\tif (max_lev) break;\t\t}\t\tif (!max_lev) break;\t\tF0R(i, L) if (lev[i] > max_lev) lev[i] = 0;\t\tauto dfs = [&](auto self, int x) -> bool {\t\t\tfor (; ptr[x] < sz(adj[x]); ++ptr[x]) {\t\t\t\tint y = adj[x][ptr[x]], z = prv[y];\t\t\t\tif (z == -1 || (lev[z] == lev[x] + 1 && self(self, z)))\t\t\t\t\treturn nxt[x] = y, prv[y] = x, ptr[x] = sz(adj[x]), 1;\t\t\t}\t\t\treturn 0;\t\t};\t\tF0R(i, L) if (nxt[i] == -1) dfs(dfs, i);\t}\tvpi ans;\tF0R(i, L) if (nxt[i] != -1) ans.pb({i, nxt[i]});\treturn ans;}Â vpi get_match(str S, V<vi> adj) {\tvpi edges;\tF0R(i, sz(S)) if (S.at(i) == '1') {\t\tfor (int j : adj.at(i)) { edges.pb({i, j}); }\t}\tauto v = maxMatch(N, N, edges);\tif (sz(v) != ones) return {};\treturn v;}Â /** * Description: Disjoint Set Union with path compression * and union by size. Add edges and test connectivity. * Use for Kruskal's or Boruvka's minimum spanning tree. * Time: O(\\alpha(N)) * Source: CSAcademy, KACTL * Verification: * */Â struct DSU {\tvi e;\tvoid init(int N) { e = vi(N, -1); }\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\tbool sameSet(int a, int b) { return get(a) == get(b); }\tint size(int x) { return -e[get(x)]; }\tbool unite(int x, int y) {  // union by size\t\tx = get(x), y = get(y);\t\tif (x == y) return 0;\t\tif (e[x] > e[y]) swap(x, y);\t\te[x] += e[y];\t\te[y] = x;\t\treturn 1;\t}};Â /**tcT> T kruskal(int N, vector<pair<T,pi>> ed) {    sort(all(ed));    T ans = 0; DSU D; D.init(N); // edges that unite are in MST    each(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;    return ans;}*/Â bool allzero(vi v) {\teach(t, v) if (t != 0) return 0;\treturn 1;}Â str transition(str S, vpi v) {\t// dbg(\"TRANSITION\", S, v);\tassert(sz(v) == ones);\tstr nS(N, '0');\tfor (auto [x, y] : v) {\t\tassert(S.at(x) == '1' && nS.at(y) == '0');\t\tS.at(x) = '0';\t\tnS.at(y) = '1';\t}\treturn nS;}Â V<vpi> solve_even(str S, str T, vpi forest_matching, vpi forest_extra,                  int goal) {\tvi other(2 * N, -1);\tDSU D;\tD.init(2 * N);\tfor (auto [x, y] : forest_matching) {\t\tassert(other.at(x) == -1);\t\tassert(other.at(y) == -1);\t\tother.at(x) = y;\t\tother.at(y) = x;\t\tassert(D.unite(x, y));\t}\tfor (auto [x, y] : forest_extra) { assert(D.unite(x, y)); }Â \t// dbg(S, T, forest_matching, forest_extra, goal);\tF0R(i, N) if (S.at(i) == '1') assert(other.at(2 * i + 1) != -1);\tF0R(i, N) if (T.at(i) == '1') assert(other.at(2 * i + 1) != -1);\tV<set<int>> adj(2 * N);\tauto ae = [&](int x, int y) {\t\tassert(x % 2 == 0);\t\tassert(y % 2 == 1);\t\tadj.at(x).ins(y), adj.at(y).ins(x);\t};\tfor (auto [x, y] : forest_matching) ae(x, y);\tfor (auto [x, y] : forest_extra) ae(x, y);\tauto del_edge = [&](int x, int y) {\t\tassert(adj.at(x).count(y) && adj.at(y).count(x));\t\tadj.at(x).erase(y);\t\tadj.at(y).erase(x);\t};\tV<vpi> ans(goal);\tauto extract_shortest_path = [&](str &s, int odd_vert) -> vi {\t\tvi par(2 * N, -1);\t\tqueue<int> q;\t\tq.push(odd_vert);\t\tpar.at(odd_vert) = odd_vert;\t\twhile (true) {\t\t\tint x = q.ft;\t\t\tq.pop();\t\t\tif (x % 2 == 1 && s.at(x / 2) == '1') {\t\t\t\ts.at(x / 2) = '0';\t\t\t\tvi path{x};\t\t\t\twhile (path.bk != odd_vert) path.pb(par.at(path.bk));\t\t\t\treturn path;\t\t\t}\t\t\tif (x % 2 == 0 && other.at(x) != -1 &&\t\t\t    s.at(other.at(x) / 2) == '1') {\t\t\t\tpar.at(other.at(x)) = x;\t\t\t\tx = other.at(x);\t\t\t\ts.at(x / 2) = '0';\t\t\t\tvi path{x};\t\t\t\twhile (path.bk != odd_vert) path.pb(par.at(path.bk));\t\t\t\treturn path;\t\t\t}\t\t\t// if (x % 2 == 0 && s.at())\t\t\tfor (int y : adj.at(x))\t\t\t\tif (par.at(y) == -1) {\t\t\t\t\tpar.at(y) = x;\t\t\t\t\tq.push(y);\t\t\t\t}\t\t}\t\tassert(false);\t};\tint L = 0, R = goal;\twhile (true) {\t\tassert(L <= R);\t\tif (S == T) {\t\t\tvpi match, rmatch;\t\t\tfor (auto [x, y] : forest_matching)\t\t\t\tif (S.at(y / 2) == '1') {\t\t\t\t\trmatch.pb({y / 2, x / 2});\t\t\t\t\tmatch.pb({x / 2, y / 2});\t\t\t\t}\t\t\tFOR(i, L, R) {\t\t\t\tif (i % 2 == 0) {\t\t\t\t\tans.at(i).ins(end(ans.at(i)), all(rmatch));\t\t\t\t} else {\t\t\t\t\tans.at(i).ins(end(ans.at(i)), all(match));\t\t\t\t}\t\t\t}\t\t\teach(t, ans) assert(sz(t) == ones);\t\t\treturn ans;\t\t}\t\tbool flag = 0;\t\tF0R(i, 2 * N) if (sz(adj.at(i)) == 1) {\t\t\tint x = *begin(adj.at(i));\t\t\tif (other.at(i) == -1) {\t\t\t\tdel_edge(i, x);\t\t\t\tflag = true;\t\t\t\tbreak;\t\t\t}\t\t\tassert(other.at(i) == x);\t\t\tif (sz(adj.at(x)) == 2) {\t\t\t\tint odd_vert = i % 2 == 1 ? i : x;\t\t\t\tint even_vert = i ^ x ^ odd_vert;\t\t\t\tif (S.at(odd_vert / 2) == '1') {\t\t\t\t\tS.at(odd_vert / 2) = '0';\t\t\t\t\tvi path = extract_shortest_path(T, odd_vert);\t\t\t\t\tassert(sz(path) % 2 == 1);\t\t\t\t\tassert(sz(path) - 1 <= R - L);\t\t\t\t\tF0R(j, sz(path) - 1) {\t\t\t\t\t\tassert(R - 1 - j >= L);\t\t\t\t\t\tans.at(R - 1 - j).pb(\t\t\t\t\t\t    {path.at(j + 1) / 2, path.at(j) / 2});\t\t\t\t\t}\t\t\t\t\tFOR(j, sz(path) - 1, R - L) {\t\t\t\t\t\tans.at(R - 1 - j).pb(\t\t\t\t\t\t    j % 2 == 0 ? pi{even_vert / 2, odd_vert / 2}\t\t\t\t\t\t               : pi{odd_vert / 2, even_vert / 2});\t\t\t\t\t}\t\t\t\t\tfor (auto [x, y] : forest_matching) {\t\t\t\t\t\tassert(y % 2 == 1);\t\t\t\t\t\tif (T.at(y / 2) == '1') {\t\t\t\t\t\t\tans.at(R - 2).pb({y / 2, x / 2});\t\t\t\t\t\t\tans.at(R - 1).pb({x / 2, y / 2});\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tR -= 2;\t\t\t\t} else if (T.at(odd_vert / 2) == '1') {\t\t\t\t\tT.at(odd_vert / 2) = '0';\t\t\t\t\tvi path = extract_shortest_path(S, odd_vert);\t\t\t\t\tassert(sz(path) % 2 == 1);\t\t\t\t\tassert(sz(path) - 1 <= R - L);\t\t\t\t\tF0R(j, sz(path) - 1) {\t\t\t\t\t\tans.at(L + j).pb({path.at(j) / 2, path.at(j + 1) / 2});\t\t\t\t\t}\t\t\t\t\tFOR(j, sz(path) - 1, R - L) {\t\t\t\t\t\tif (j % 2 == 0) {  // starts with odd vert\t\t\t\t\t\t\tans.at(L + j).pb({odd_vert / 2, even_vert / 2});\t\t\t\t\t\t} else {\t\t\t\t\t\t\tans.at(L + j).pb({even_vert / 2, odd_vert / 2});\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tfor (auto [x, y] : forest_matching) {\t\t\t\t\t\tassert(y % 2 == 1);\t\t\t\t\t\tif (S.at(y / 2) == '1') {\t\t\t\t\t\t\tans.at(L).pb({y / 2, x / 2});\t\t\t\t\t\t\tans.at(L + 1).pb({x / 2, y / 2});\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tL += 2;\t\t\t\t}\t\t\t\tdel_edge(i, x);\t\t\t\tdel_edge(x, *begin(adj.at(x)));\t\t\t\tflag = true;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (!flag) {\t\t\tdbg(\"OOPS\", L, R, S, T);\t\t\tdbg(forest_matching, forest_extra);\t\t\texit(0);\t\t}\t\tassert(flag);\t\tcontinue;\t}}Â optional<V<vpi>> solve_two_N_minus_one(V<vi> adj, str S, str T, vpi mS,                                       vpi mT) {\t// dbg(\"START\");\ttransition(S, mS);\ttransition(T, mT);\t// dbg(\"EN\");Â \t{\t\tDSU D;\t\tD.init(2 * N);\t\tvi balance(2 * N);\t\tF0R(i, N) for (int j : adj.at(i)) D.unite(2 * i, 2 * j + 1);\t\tF0R(i, N) if (S.at(i) == '1')++ balance.at(D.get(2 * i));\t\tF0R(i, N) if (T.at(i) == '1')-- balance.at(D.get(2 * i + 1));\t\tif (!allzero(balance)) return {};\t}Â \t// dbg(\"TRYING\", adj, S, T, mS, mT);Â \tV<vi> cyc_out(2 * N), cyc_in(2 * N);\tauto directed = [&](int a, int b) {\t\t// dbg(\"DIRECTED\", a, b);\t\tcyc_out.at(a).pb(b);\t\tcyc_in.at(b).pb(a);\t};Â \tfor (auto [x, y] : mS) directed(2 * x, 2 * y + 1);\tfor (auto [x, y] : mT) directed(2 * x + 1, 2 * y);\teach(t, cyc_in) assert(sz(t) <= 1);\teach(t, cyc_out) assert(sz(t) <= 1);Â \tvpi forest_matching;\tauto add_matched_edge = [&](int x, int y) {\t\tif (x % 2 != 0) swap(x, y);\t\tassert(x % 2 == 0 && y % 2 == 1);\t\tforest_matching.pb({x, y});\t};\tF0R(i, 2 * N) if (sz(cyc_out[i]) && !sz(cyc_in[i])) {\t\tvi path{i};\t\twhile (sz(cyc_out[path.bk])) path.pb(cyc_out[path.bk].bk);\t\teach(t, path) cyc_in[t].clear(), cyc_out[t].clear();Â \t\tif (sz(path) % 2 == 1) path.pop_back();Â \t\tF0R(j, sz(path) / 2)\t\tadd_matched_edge(path.at(2 * j), path.at(2 * j + 1));\t}\tF0R(i, 2 * N) if (i % 2 == 0 && (sz(cyc_in[i]) && sz(cyc_out[i]))) {\t\tvi path{i};\t\twhile (true) {\t\t\tassert(sz(cyc_out[path.bk]));\t\t\tint nxt = cyc_out[path.bk].bk;\t\t\tif (nxt == path.ft) break;\t\t\tpath.pb(nxt);\t\t}\t\tassert(sz(path) % 2 == 0);\t\teach(t, path) cyc_in[t].clear(), cyc_out[t].clear();\t\tF0R(j, sz(path) / 2)\t\tadd_matched_edge(path.at(2 * j), path.at(2 * j + 1));\t}\teach(t, cyc_in) assert(sz(t) == 0);\teach(t, cyc_out) assert(sz(t) == 0);Â \tDSU D;\tD.init(2 * N);\tfor (auto [x, y] : forest_matching) assert(D.unite(x, y));\tvpi forest_extra;\tF0R(i, N) for (int j : adj.at(i)) {\t\tint a = 2 * i, b = 2 * j + 1;\t\tif (D.unite(a, b)) forest_extra.pb({a, b});\t}\tvpi first_match;\tfor (auto [x, y] : forest_matching)\t\tif (S.at(x / 2) == '1') first_match.pb({x / 2, y / 2});\tS = transition(S, first_match);\tauto ret = solve_even(S, T, forest_matching, forest_extra, 2 * N - 2);\tret.ins(begin(ret), first_match);\treturn ret;}Â str tran_all(str S, V<vpi> ans) {\teach(t, ans) S = transition(S, t);\treturn S;}Â void finish(str S, str T, V<vpi> ans) {\tps(\"Yes\");\tassert(tran_all(S, ans) == T);\tps(sz(ans));\tvi loc(N, -1);\tV<vi> ans_vec;\tans_vec.eb();\tF0R(i, N) if (S.at(i) == '1') {\t\tloc.at(i) = sz(ans_vec.bk);\t\tans_vec.bk.pb(i);\t}\teach(t, ans) {\t\tans_vec.pb(vi(ones, -1));\t\tvi nloc(N, -1);\t\tfor (auto [x, y] : t) {\t\t\tnloc.at(y) = loc.at(x);\t\t\tans_vec.bk.at(nloc.at(y)) = y;\t\t}\t\tswap(loc, nloc);\t}Â \teach(t, ans_vec) {\t\teach(u, t)++ u;\t\tps(t);\t}}Â void solve(int N_, int M, str orig_S, str orig_T, vpi edges) {\tauto S = orig_S, T = orig_T;\tN = N_;Â \t// dbg(\"TEST\", N, M, S, T, edges);Â \tV<vi> adj(N);\tfor (auto [u, v] : edges) {\t\t--u, --v;\t\tadj.at(u).pb(v), adj.at(v).pb(u);\t}\tones = 0;\teach(t, S) ones += t == '1';\tif (S == T) {\t\tps(\"Yes\");\t\tps(0);\t\tvi ans;\t\tF0R(i, N) if (S[i] == '1') ans.pb(i + 1);\t\tps(ans);\t\treturn;\t}\tauto mS = get_match(orig_S, adj);\tif (!sz(mS)) {\t\tps(\"No\");\t\treturn;\t}\tauto mT = get_match(T, adj);\tif (!sz(mT)) {\t\tps(\"No\");\t\treturn;\t}\tauto ans1 = solve_two_N_minus_one(adj, S, T, mS, mT);\tif (ans1.has_value()) return finish(orig_S, orig_T, ans1.value());Â \tT = transition(T, mT);\tfor (auto &[x, y] : mT) swap(x, y);Â \tauto ans2 = solve_two_N_minus_one(adj, S, T, mS, mT);\tif (ans2.has_value()) {\t\tauto ans = ans2.value();\t\tans.pb(mT);\t\treturn finish(orig_S, orig_T, ans);\t}\t// dbg(\"OOP\");\tps(\"No\");}Â void solve(int tc) {\tdef(int, N);\tdef(int, M);\tdef(str, S);\tdef(str, T);\tvpi edges(M);\tre(edges);\tsolve(N, M, S, T, edges);}Â int main() {\tsetIO();\t// FOR(N, 1, 10) {\t// \trep(100) {\t// \t\tvpi edges;\t// \t\tFOR(i, 1, N) FOR(j, i + 1, N + 1) if (rng() & 1) edges.pb({i, j});\t// \t\tvi pos(N);\t// \t\tiota(all(pos), 0);\t// \t\tint c = rng() % (N + 1);\t// \t\tstr S(N, '0'), T(N, '0');\t// \t\tshuffle(all(pos), rng);\t// \t\tF0R(i, c) S.at(pos.at(i)) = '1';\t// \t\tshuffle(all(pos), rng);\t// \t\tF0R(i, c) T.at(pos.at(i)) = '1';\t// \t\tsolve(N, sz(edges), S, T, edges);\t// \t}\t// }\tint TC;\tre(TC);\tFOR(i, 1, TC + 1) solve(i);}Â /* stuff you should look for * int overflow, array bounds * special cases (n=1?) * do smth instead of nothing and stay organized * WRITE STUFF DOWN * DON'T GET STUCK ON ONE APPROACH */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graphs"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H2. Kevin and Stones  Hard Version .json"
}