{
    "link": "https://codeforces.com//contest/1761/problem/F1",
    "problemId": "1651706",
    "problem_idx": "F1",
    "shortId": "1761F1",
    "contest_number": "1761",
    "problem_submissions": {
        "F1": [
            181783681,
            181789408,
            181787826,
            181807817,
            181793725,
            181798874,
            181812117,
            181796851,
            181792193,
            181797286,
            181792466,
            181800291,
            181799120,
            181798951,
            181797538,
            181796549,
            181801616,
            181795934,
            181802212,
            181805577,
            181795481
        ],
        "E": [
            181767412,
            181775228,
            181773318,
            181773199,
            181776029,
            181768641,
            181774177,
            181773946,
            181778599,
            181783359,
            181770606,
            181780149,
            181779791,
            181784860,
            181784163,
            181786738,
            181799018,
            181784766,
            181805355,
            181777139
        ],
        "B": [
            181758217,
            181754631,
            181753022,
            181750562,
            181750818,
            181752710,
            181752904,
            181761535,
            181751867,
            181753244,
            181749713,
            181752562,
            181752197,
            181751335,
            181785787,
            181754006,
            181756438,
            181751473,
            181751400,
            181750387
        ],
        "C": [
            181757137,
            181757883,
            181756839,
            181754860,
            181753609,
            181755220,
            181756960,
            181758423,
            181755837,
            181756467,
            181755169,
            181757040,
            181757304,
            181769451,
            181757169,
            181757887,
            181761524,
            181755570,
            181754021,
            181753237
        ],
        "D": [
            181754215,
            181780914,
            181764059,
            181764559,
            181763628,
            181762248,
            181763698,
            181768454,
            181766485,
            181764872,
            181761188,
            181770079,
            181765691,
            181765764,
            181766812,
            181780108,
            181774890,
            181778415,
            181762397,
            181766534
        ],
        "A": [
            181747969,
            181747996,
            181753999,
            181748106,
            181748091,
            181748074,
            181748126,
            181748232,
            181748177,
            181750270,
            181748024,
            181748492,
            181748221,
            181748149,
            181749212,
            181750341,
            181748955,
            181748081,
            181748111,
            181748040
        ],
        "G": [
            181798925,
            181813421
        ],
        "F2": [
            181809122,
            181811738,
            181814199,
            181819747,
            181813452,
            181813278,
            181812897,
            181812682,
            181812626,
            181812463,
            181811716,
            181806789
        ]
    },
    "name": "F1. Anti-median  Easy Version ",
    "statement": "Let\u2019s call an array a of odd length 2m+1 (with m\r\nge 1) , if element a_{m+1} is equal to the median of this array. In\r\nother words, the array is bad if, after sorting it, the element at\r\nm+1-st position remains the same.Let\u2019s call a permutation p of integers\r\nfrom 1 to n , if every its subarray of odd length\r\nge 3 is not bad.You are already given values of some elements of the\r\npermutation. Find the number of ways to set unknown values to obtain an\r\npermutation. As this number can be very large, find it modulo 10^9+7.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 20.11.2022 19:36:59       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      if (a[i] > 0) {\n        --a[i];\n      }\n    }\n    vector<int> order;\n    for (int i = 0; i < n; i++) {\n      if (i % 2 == 0) {\n        order.push_back(i);\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      if (i % 2 == 1) {\n        order.push_back(i);\n      }\n    }\n    vector<vector<bool>> is_seg(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n      int mn = n;\n      int mx = -1;\n      for (int k = 0; k < n; k++) {\n        int j = (i + k) % n;\n        mn = min(mn, order[j]);\n        mx = max(mx, order[j]);\n        if (mx - mn == k && (mn == 0 || mx == n - 1)) {\n          is_seg[i][j] = true;\n        }\n      }\n    }\n    vector<vector<Mint>> dp(n, vector<Mint>(n));\n    for (int i = 0; i < n; i++) {\n      if (a[order[i]] == 0 || a[order[i]] == -1) {\n        dp[i][i] = 1;\n      }\n    }\n    Mint ans = 0;\n    for (int len = 1; len <= n - 1; len++) {\n      for (int i = 0; i < n; i++) {\n        int j = (i + len - 1) % n;\n        if (len == n - 1) {\n          int lst = (j + 1) % n;\n          if (a[order[lst]] == len || a[order[lst]] == -1) {\n            ans += dp[i][j];\n          }\n          continue;\n        }\n        int pi = (i + n - 1) % n;\n        if (a[order[pi]] == len || a[order[pi]] == -1) {\n//          if (order[i] + order[pi] == 2 * order[j]) {\n//          debug(i, j, pi, j, \"check\");\n          if (!is_seg[i][j] || !is_seg[pi][j]) {\n//            debug(i, j, pi, j);\n            dp[pi][j] += dp[i][j];\n          }\n        }\n        int pj = (j + 1) % n;\n        if (a[order[pj]] == len || a[order[pj]] == -1) {\n//          if (order[j] + order[pj] == 2 * order[i]) {\n//          debug(i, j, i, pj, \"check\");\n          if (!is_seg[i][j] || !is_seg[i][pj]) {\n//            debug(i, j, i, pj);\n            dp[i][pj] += dp[i][j];\n          }\n        }\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F1. Anti-median  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/109256",
    "editorial": "Let\u00e2\u0080\u0099s analyze the structure of anti-median permutations.First, if for\r\nany holds , or , then segment is bad. So, the signs between adjacent\r\nelements are alternating. So, consider two cases: all elements on even\r\npositions are local maximums, and on odd local minimums, and vice\r\nversa.Let\u00e2\u0080\u0099s find the answer for the first case (for the second, you can\r\nfind the answer similarly). Consider a segment of length , . Consider\r\nthe case when is even first. Then . For to not be median, it has to be\r\nlarger than one of . So, when we consider only even elements, each\r\nelement (except the first and last one) has at least one adjacent\r\nelement smaller than it. It\u00e2\u0080\u0099s easy to see that this implies that\r\nelements at even positions are first increasing and then decreasing.\r\nSimilarly, we can see that elements at odd positions are first\r\ndecreasing, then increasing. It\u00e2\u0080\u0099s not hard to see that these conditions\r\nare sufficient. Indeed, suppose that: All elements on even positions are\r\nlocal maximums, and all elements on odd positions are local minimums\r\nElements at even positions are first increasing and then decreasing.\r\nElements at odd positions are first decreasing, then increasing.Then,\r\nconsider any segment of odd length. Denote it by , and wlog is local\r\nmaximum. If we look at local maximums, at least one of the following two\r\nconditions has to hold: all local maximums to the right of are smaller\r\nthan it, or all local maximums to the left of are smaller than it. Wlog\r\nfirst case. Then all elements to the right of are smaller than it, and\r\nis also smaller than it, so can\u00e2\u0080\u0099t be a median.Now, let\u00e2\u0080\u0099s put all\r\nelements on the circle in the following order: first, all even elements\r\nfrom left to right, then all odd elements from right to left. In this\r\ncircle, the elements on both paths between and are decreasing. It\r\nfollows that for any , numbers from to form a segment (in this cyclic\r\narrangement).Then, we can write a of the form: : how many ways are there\r\nto arrange the largest elements so that they end up in the positions\r\nfrom -th to -th in this cyclic arrangement. All the transitions and\r\nchecks are done in , and there are states, so we are done.\r\n"
}