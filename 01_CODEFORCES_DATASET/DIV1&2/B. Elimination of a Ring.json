{
    "link": "https://codeforces.com//contest/1761/problem/B",
    "problemId": "1651702",
    "problem_idx": "B",
    "shortId": "1761B",
    "contest_number": "1761",
    "problem_submissions": {
        "F1": [
            181783681,
            181789408,
            181787826,
            181807817,
            181793725,
            181798874,
            181812117,
            181796851,
            181792193,
            181797286,
            181792466,
            181800291,
            181799120,
            181798951,
            181797538,
            181796549,
            181801616,
            181795934,
            181802212,
            181805577,
            181795481
        ],
        "E": [
            181767412,
            181775228,
            181773318,
            181773199,
            181776029,
            181768641,
            181774177,
            181773946,
            181778599,
            181783359,
            181770606,
            181780149,
            181779791,
            181784860,
            181784163,
            181786738,
            181799018,
            181784766,
            181805355,
            181777139
        ],
        "B": [
            181758217,
            181754631,
            181753022,
            181750562,
            181750818,
            181752710,
            181752904,
            181761535,
            181751867,
            181753244,
            181749713,
            181752562,
            181752197,
            181751335,
            181785787,
            181754006,
            181756438,
            181751473,
            181751400,
            181750387
        ],
        "C": [
            181757137,
            181757883,
            181756839,
            181754860,
            181753609,
            181755220,
            181756960,
            181758423,
            181755837,
            181756467,
            181755169,
            181757040,
            181757304,
            181769451,
            181757169,
            181757887,
            181761524,
            181755570,
            181754021,
            181753237
        ],
        "D": [
            181754215,
            181780914,
            181764059,
            181764559,
            181763628,
            181762248,
            181763698,
            181768454,
            181766485,
            181764872,
            181761188,
            181770079,
            181765691,
            181765764,
            181766812,
            181780108,
            181774890,
            181778415,
            181762397,
            181766534
        ],
        "A": [
            181747969,
            181747996,
            181753999,
            181748106,
            181748091,
            181748074,
            181748126,
            181748232,
            181748177,
            181750270,
            181748024,
            181748492,
            181748221,
            181748149,
            181749212,
            181750341,
            181748955,
            181748081,
            181748111,
            181748040
        ],
        "G": [
            181798925,
            181813421
        ],
        "F2": [
            181809122,
            181811738,
            181814199,
            181819747,
            181813452,
            181813278,
            181812897,
            181812682,
            181812626,
            181812463,
            181811716,
            181806789
        ]
    },
    "name": "B. Elimination of a Ring",
    "statement": "Define a cyclic sequence of size n as an array s of length n, in which\r\ns_n is adjacent to s_1.Muxii has a ring represented by a cyclic sequence\r\na of size n.However, the ring itself hates equal adjacent elements. So\r\nif two adjacent elements in the sequence are equal at any time, will be\r\nerased . The sequence doesn\u2019t contain equal adjacent elements\r\ninitially.Muxii can perform the following operation until the sequence\r\nbecomes empty: Choose an element in a and erase it. For example, if ring\r\nis [1, 2, 4, 2, 3, 2], and Muxii erases element 4, then ring would erase\r\none of the elements equal to 2, and the ring will become [1, 2, 3,\r\n2].Muxii wants to find the number of operations he could perform.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 20.11.2022 18:49:35       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    bool c = true;\n    for (int i = 0; i < n; i++) {\n      if (a[i] != a[i % 2]) {\n        c = false;\n        break;\n      }\n    }\n    if (c) {\n      cout << n / 2 + 1 << '\\n';\n    } else {\n      cout << n << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Elimination of a Ring.json",
    "editorial_link": "https://codeforces.com//blog/entry/109256",
    "editorial": "HintDo we need more than types of elements? Try to solve the problem\r\nwith .SolutionFirst of all, when there\u00e2\u0080\u0099re only types of elements\r\nappearing in the sequence, the answer would be .Otherwise, the\r\nconclusion is that we can always reach operations when there are more\r\nthan types of elements appearing in the sequence.The proof is given\r\nbelow: When the length of the sequence is greater than , there will\r\nalways be a pair of positions , such that and has two different\r\nneighboring elements. Then we can erase and then the problem is\r\ndecomposed into a smaller one. If there do not exist such pairs, then we\r\ncan infer that there exists at least element which appeared only once in\r\nthe sequence. If there exists such element , then we can continuously\r\nerase all the elements next to , then erase at last. When the length of\r\nthe sequence is less than , it is clear that there will be exactly\r\noperations as well.So we only need to check the number of elements that\r\nappeared in the sequence of length . If the number is , the answer will\r\nbe . Otherwise, the answer equals .\r\n"
}