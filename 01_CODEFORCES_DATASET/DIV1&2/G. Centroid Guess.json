{
    "link": "https://codeforces.com//contest/1761/problem/G",
    "problemId": "1651708",
    "problem_idx": "G",
    "shortId": "1761G",
    "contest_number": "1761",
    "problem_submissions": {
        "F1": [
            181783681,
            181789408,
            181787826,
            181807817,
            181793725,
            181798874,
            181812117,
            181796851,
            181792193,
            181797286,
            181792466,
            181800291,
            181799120,
            181798951,
            181797538,
            181796549,
            181801616,
            181795934,
            181802212,
            181805577,
            181795481
        ],
        "E": [
            181767412,
            181775228,
            181773318,
            181773199,
            181776029,
            181768641,
            181774177,
            181773946,
            181778599,
            181783359,
            181770606,
            181780149,
            181779791,
            181784860,
            181784163,
            181786738,
            181799018,
            181784766,
            181805355,
            181777139
        ],
        "B": [
            181758217,
            181754631,
            181753022,
            181750562,
            181750818,
            181752710,
            181752904,
            181761535,
            181751867,
            181753244,
            181749713,
            181752562,
            181752197,
            181751335,
            181785787,
            181754006,
            181756438,
            181751473,
            181751400,
            181750387
        ],
        "C": [
            181757137,
            181757883,
            181756839,
            181754860,
            181753609,
            181755220,
            181756960,
            181758423,
            181755837,
            181756467,
            181755169,
            181757040,
            181757304,
            181769451,
            181757169,
            181757887,
            181761524,
            181755570,
            181754021,
            181753237
        ],
        "D": [
            181754215,
            181780914,
            181764059,
            181764559,
            181763628,
            181762248,
            181763698,
            181768454,
            181766485,
            181764872,
            181761188,
            181770079,
            181765691,
            181765764,
            181766812,
            181780108,
            181774890,
            181778415,
            181762397,
            181766534
        ],
        "A": [
            181747969,
            181747996,
            181753999,
            181748106,
            181748091,
            181748074,
            181748126,
            181748232,
            181748177,
            181750270,
            181748024,
            181748492,
            181748221,
            181748149,
            181749212,
            181750341,
            181748955,
            181748081,
            181748111,
            181748040
        ],
        "G": [
            181798925,
            181813421
        ],
        "F2": [
            181809122,
            181811738,
            181814199,
            181819747,
            181813452,
            181813278,
            181812897,
            181812682,
            181812626,
            181812463,
            181811716,
            181806789
        ]
    },
    "name": "G. Centroid Guess",
    "statement": ".There is an unknown tree consisting of n nodes, which has centroid. You\r\nonly know n at first, and your task is to find the centroid of the\r\ntree.You can ask the distance between any two vertices for at most 2\r\ncdot10^5 times. Note that the interactor is adaptive. That is, the tree\r\nis fixed in each test beforehand and does not depend on your queries.A\r\nvertex is called a centroid if its removal splits the tree into subtrees\r\nwith at most\r\nlfloor\r\nfrac{n}{2}\r\nrfloor vertices each.\r\n",
    "solutions": [
        "//DUEL\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#pragma GCC optimize(\"unroll-loops\")\n#define shandom_ruffle(a, b) shuffle(a, b, rng)\n#define vi vector<int>\n#define vl vector<ll>\n#define popcnt __builtin_popcountll\n#define all(a) begin(a),end(a)\n//for kactl\n#define sz(x) (int)(x).size()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nusing ll=long long;\nusing ull=unsigned long long;\nusing ld=long double;\nint MOD=1000000007;\nint MOD2=998244353;\nvector<int> bases;\nconst ll LLINF=1ll<<60;\nconst char en='\\n';\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid yes() {cout<<\"YES\"<<en; exit(0);}\nvoid no() {cout<<\"NO\"<<en; exit(0);}\ninline int rund() {int x576363482791fuweh=rng();return abs(x576363482791fuweh)%RAND_MAX;}\ntemplate<class T>\nvoid prVec(vector<T> w,bool fl=false)\n{\n\tcout<<w.size()<<en;\n\tfor (int i=0;i<int(w.size())-1;++i) cout<<w[i]<<' ';\n\tif (w.size()) cout<<w[w.size()-1]<<en;\n\tif (fl) cout<<flush;\n}\n\nvoid M998()\n{\n\tswap(MOD,MOD2);\n}\n\nll raand()\n{\n\tll a=rund();\n\ta*=RAND_MAX;\n\ta+=rund();\n    return a;\n}\n\n#define rand raand\n\nll raaand()\n{\n\treturn raand()*(MOD-7)+raand();\n}\n\ntemplate<class T>\nvi compress(vector<T>&v)\n{\n\tset<T> s;\n\tfor (auto a: v) s.insert(a);\n\tvector<T> o(all(s));\n\tvi nv;\n\tfor (int i=0;i<(int)v.size();++i) nv.pb(lower_bound(all(o),v[i])-o.begin());\n\treturn nv;\n}\n\nstring to_upper(string a)\n{\n\tfor (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A';\n\treturn a;\n}\n\nstring to_lower(string a)\n{\n\tfor (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A';\n\treturn a;\n}\n\nll sti(string a,int base=10)\n{\n\tll k=0;\n\tfor (int i=0;i<(int)a.size();++i)\n\t{\n\t\tk*=base;\n\t\tk+=a[i]-'0';\n\t}\n\treturn k;\n}\n\ntemplate<class T>\nvoid eras(vector<T>& a,T b)\n{\n\ta.erase(find(a.begin(),a.end(),b));\n}\n\nstring its(ll k,int base=10)\n{\n\tif (k==0) return \"0\";\n\tstring a;\n\twhile (k)\n\t{\n\t\ta.push_back((k%base)+'0');\n\t\tk/=base;\n\t}\n\treverse(a.begin(),a.end());\n\treturn a;\n}\n\nll min(ll a,int b)\n{\n\tif (a<b) return a;\n\treturn b;\n}\n\nll min(int a,ll b)\n{\n\tif (a<b) return a;\n\treturn b;\n}\n\nll max(ll a,int b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nll max(int a,ll b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nll gcd(ll a,ll b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b)\n{\n\treturn a/gcd(a,b)*b;\n}\n\ntemplate<class T,class K>\npair<T,K> mp(T a,K b)\n{\n\treturn make_pair(a,b);\n}\n\ninline int mult(ll a,ll b)\n{\n\treturn (a*b)%MOD;\n}\n\ninline int pot(int n,int k)\n{\n\tif (k==0) return 1;\n\tll a=pot(n,k/2);\n\ta=mult(a,a);\n\tif (k%2) return mult(a,n);\n\telse return a;\n}\n\nint divide(int a,int b)\n{\n\treturn mult(a,pot(b,MOD-2));\n}\n\ninline int sub(int a,int b)\n{\n\tif (a-b>=0) return a-b;\n\treturn a-b+MOD;\n}\n\ninline int add(int a,int b)\n{\n\tif (a+b>=MOD) return a+b-MOD;\n\treturn a+b;\n}\n\nvoid ad(int&a,int b)\n{\n\ta+=b;\n\tif (a>=MOD) a-=MOD;\n}\n\nvoid su(int&a,int b)\n{\n\ta-=b;\n\tif (a<0) a+=MOD;\n}\n\nbool prime(ll a)\n{\n\tif (a==1) return 0;\n\tfor (int i=2;i<=round(sqrt(a));++i)\n\t{\n\t\tif (a%i==0) return 0;\n\t}\n\treturn 1;\n}\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nconst int N=75010,KO=20,OT=350;\nint remq=199900;\nint n,de[N],cn[N],cn2[N];\nmap<pii,int> bi;\n\nint dis(int u,int v)\n{\n\tif (u==v) return 0;\n\tif (bi[{u,v}]) return bi[{u,v}];\n\t--remq;\n\tcout<<\"? \"<<u<<' '<<v<<endl;\n\tint x;\n\tcin>>x;\n\tbi[{u,v}]=bi[{v,u}]=x;\n\treturn x;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tfor (int i=0;i<10;++i) bases.push_back(rand()%(MOD-13893829*2)+13893829);\n\tcin>>n;\n\tint ro=rand()%n+1;\n\tfor (int i=1;i<=n;++i) de[i]=dis(ro,i);\n\tvector<pii> po;\n\tfor (int i=0;i<KO;++i)\n\t{\n\t\tvi od;\n\t\tint no=rand()%n+1;\n\t\tfor (int j=0;j<OT;++j)\n\t\t{\n\t\t\tint dr=rand()%n+1;\n\t\t\tod.pb((de[no]+de[dr]-dis(no,dr))/2);\n\t\t}\n\t\tsort(all(od));\n\t\tpo.pb({od[OT/2],no});\n\t}\n\tsort(all(po));\n\treverse(all(po));\n\tint poc=po[0].y;\n\tfor (int i=1;i<=n;++i) ++cn[(de[poc]+de[i]-dis(poc,i))/2];\n\tfor (int i=n-1;i>=0;--i) cn[i]+=cn[i+1];\n\tfor (int i=n;i>=0;--i) if (cn[i]>n/2)\n\t{\n\t\tif (remq>=n-cn[i+1])\n\t\t{\n\t\t\tfor (int u=1;u<KO;++u)\n\t\t\t{\n\t\t\t\tint cno=po[u].y;\n\t\t\t\tint ndu=(de[poc]+de[cno]-dis(poc,cno))/2;\n\t\t\t\tif (ndu==i)\n\t\t\t\t{\n\t\t\t\t\tcn2[i]=cn[i+1];\n\t\t\t\t\tfor (int k=1;k<=n;++k) if ((de[poc]+de[k]-dis(poc,k))/2<=i) ++cn2[(de[cno]+de[k]-dis(cno,k))/2];\n\t\t\t\t\tfor (int k=n-1;k>=0;--k) cn2[k]+=cn2[k+1];\n\t\t\t\t\tint mu=i;\n\t\t\t\t\twhile (cn2[mu+1]>n/2) ++mu;\n\t\t\t\t\tfor (int k=1;k<=n;++k) if ((de[poc]+de[k]-dis(poc,k))/2<=i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (de[k]==mu && de[k]+dis(cno,k)==de[cno])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout<<\"! \"<<k<<endl;\n\t\t\t\t\t\t\texit(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tassert(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k=1;k<=n;++k) if (de[k]==i && de[k]+dis(poc,k)==de[poc])\n\t\t{\n\t\t\tcout<<\"! \"<<k<<endl;\n\t\t\texit(0);\n\t\t}\n\t}\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "interactive",
        "probabilities",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Centroid Guess.json",
    "editorial_link": "https://codeforces.com//blog/entry/109256",
    "editorial": "Assuming we have already determined that the centroid of the tree is\r\nlocated on the path between and , we may now consider how to locate\r\nit.Let be the vertices on the path from to . Let be the set of vertices\r\nreachable from (including ) if we erase all other vertices on the path\r\nfrom to . Then we may find that are a division of all vertices.Let be\r\nthe size of . Then there must exist a vertex on the path satisfying that\r\n. Notice that the vertices that do not satisfy the condition could not\r\nbe a centroid, and it is already determined that the centroid is on the\r\npath, so is exactly the centroid of the tree.Then we may consider\r\nfinding out which set each vertex belongs to with queries so that we can\r\ncalculate the value of . For each vertex , we may query and . For any\r\ntwo vertices and that belong to the same set, should be equal to . Let\r\nand , then . Thus we have found out the sets each vertex belongs to, as\r\nwell as the value of , as well as the centroid. This process requires at\r\nmost queries.Now the problem remains to find a pair of vertices and such\r\nthat the centroid locates on the path from to .We can pick a constant\r\nsatisfying that , then select vertices on the tree randomly, and query\r\nthe distances between every pair of selected vertices. This requires\r\nqueries.Let these vertices be . We can build a virtual tree with being\r\nthe root that contains all the LCAs of each pair of vertices. Observe\r\nthat if and only if is located on the path between and . For a vertex ,\r\nwe can find out all vertices on the path from to , and then find out the\r\nclosest vertex to and connect them. It is exactly the deepest ancestor\r\nof .Now that we have constructed the virtual tree without the LCAs with\r\nbeing the root, we will then add the LCAs into the virtual tree.Start\r\nDFS from . Assume the current vertex is . Enumerate through the nodes\r\nadjacent to . Assume the current vertex is . If there exists another\r\nvertex which is adjacent to satisfying that is not on the path between\r\nand , then and should be both in the subtree of one of \u00e2\u0080\u0099s child nodes.\r\nAfter finding out all vertices that are in the same subtree as , it\r\nwould be easy to calculate the depth of their LCAs as well as the\r\ndistance between an LCA vertex and all other vertices in the virtual\r\ntree. Then, remove the old edge, and then add edges between the LCA and\r\nall vertices found in the same subtree as . Lastly, add an edge between\r\nthe LCA and . Then repeat the process above, until any two vertices\r\nadjacent to are not in the same subtree of a child node of . Then DFS\r\nthe child nodes of . We will get the whole virtual tree after all DFS\r\nare done.For the vertices chosen from the beginning, we assume that\r\ntheir weights are all , while other vertices have weight. Then we may\r\nfind the weighted centroid of the virtual tree (when there are multiple\r\nsuch centroids, arbitrarily pick one), and then make it the root. Then\r\nfor the two vertices with the largest and second-largest subtree of the\r\nroot, DFS them, recursively find their child vertex with the largest\r\nsubtree. We will be resulted with leaf nodes. Then the centroid of the\r\nhidden tree is highly possible to be located on the path between these\r\nnodes. The number of queries in both parts would not exceed .Proof of\r\ncorrectness:If the centroid is not on the path between and , assume the\r\ncentroid of the virtual tree is in the subtree of the centroid of the\r\nhidden tree. If the subtrees other than contain at least of the\r\nvertices, then the centroid of the hidden tree must be on the path\r\nbetween and . So there will be at most of the vertices not being in . In\r\nother words, for each of vertices, it has a possibility greater than of\r\nnot being in , and there will be at most of the vertices which are not\r\nin . The possibility of the algorithm being wrong is not greater than ,\r\nlet , then the value would be approximately .\r\n"
}