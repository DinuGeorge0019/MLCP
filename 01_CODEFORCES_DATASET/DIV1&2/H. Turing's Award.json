{
    "link": "https://codeforces.com//contest/1530/problem/H",
    "problemId": "1049175",
    "problem_idx": "H",
    "shortId": "1530H",
    "contest_number": "1530",
    "problem_submissions": {
        "H": [
            122851665,
            122838743,
            122844195,
            122849012,
            122871696,
            122848567,
            122889728
        ],
        "G": [
            122840209,
            122852256,
            122900209,
            122846129,
            122844934,
            122847648,
            122853646,
            122874899,
            122880351,
            122921209
        ],
        "F": [
            122810446,
            122819713,
            122812617,
            122825773,
            122868869,
            122809297,
            122821188,
            122827035,
            122824965,
            122821818,
            122829815,
            122826847,
            122822005,
            122826789,
            122826175,
            122826918,
            122836373,
            122830797,
            122814894,
            122838442,
            122834199
        ],
        "E": [
            122803663,
            122805810,
            122805166,
            122812311,
            122817063,
            122814296,
            122807127,
            122808379,
            122800583,
            122808253,
            122808203,
            122811232,
            122807495,
            122807208,
            122811521,
            122828022,
            122805125,
            122810921
        ],
        "D": [
            122791676,
            122796247,
            122793005,
            122795921,
            122795213,
            122793368,
            122796651,
            122796980,
            122803859,
            122791210,
            122799331,
            122796501,
            122797048,
            122796533,
            122791355,
            122798720,
            122801973,
            122792843,
            122800740
        ],
        "C": [
            122785861,
            122787673,
            122786660,
            122785034,
            122784856,
            122787839,
            122786985,
            122784250,
            122795439,
            122782668,
            122786465,
            122789088,
            122786999,
            122788656,
            122784366,
            122787966,
            122789017,
            122785054,
            122790340
        ],
        "B": [
            122781549,
            122782427,
            122782526,
            122782097,
            122782078,
            122780831,
            122781690,
            122789087,
            122786285,
            122785455,
            122781801,
            122781479,
            122782615,
            122783296,
            122794583,
            122783767,
            122783971,
            122780469,
            122782275
        ],
        "A": [
            122775440,
            122775417,
            122775273,
            122775738,
            122775580,
            122775190,
            122775752,
            122790605,
            122781313,
            122775806,
            122775746,
            122775311,
            122776001,
            122775468,
            122776055,
            122775938,
            122777214,
            122775025,
            122775038
        ]
    },
    "name": "H. Turing's Award",
    "statement": "Alan Turing is standing on a tape divided into cells that is infinite in\r\nboth directions.Cells are numbered with consecutive integers from left\r\nto right. Alan is initially standing in cell 0. Every cell x has cell\r\nx - 1 on the left and cell x + 1 on the right.Each cell can either\r\ncontain an integer or be empty. Initially all cells are empty.Alan is\r\ngiven a permutation a_1, a_2,\r\nldots, a_n of integers from 1 to n that was chosen among all\r\npermutations of length n.At time 1, integer a_1 is written down into\r\ncell 0 where Alan is located.At each time i from 2 to n inclusive, the\r\nfollowing happens. First, Alan decides whether to stay in the same cell\r\nhe\u2019s currently in, move to the neighboring cell on the left, or move to\r\nthe neighboring cell on the right. After that, integer a_i is written\r\ndown into the cell where Alan is located. If that cell already contained\r\nsome integer, the old integer is overwritten and irrelevant from that\r\nmoment on.Once a_n is written down into some cell at time n, sequence b\r\nof all integers contained in the cells from left to right is formed.\r\nEmpty cells are ignored.Turing\u2019s award is equal to the length of the\r\nlongest increasing subsequence of sequence b.Help Alan and determine the\r\nlargest possible value of his award if he acts optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int L = 600;\n\nstruct Fenwick {\n    const int n;\n    std::vector<int> a;\n    Fenwick(int n) : n(n), a(n, -1) {}\n    void add(int x, int v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] = std::max(a[i - 1], v);\n        }\n    }\n    int query(int x) {\n        int ans = -1;\n        for (int i = x; i > 0; i -= i & -i) {\n            ans = std::max(ans, a[i - 1]);\n        }\n        return ans;\n    }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n    }\n    \n    std::reverse(a.begin(), a.end());\n    \n    int ans = 1;\n    \n    for (int t = 0; t < 2; t++) {\n        std::vector f(n, std::vector(L, -1)), g(n, std::vector(L, n));\n        \n        std::vector t1(L, Fenwick(n)), t2(t1), t3(t1), t4(t1);\n        \n        if (t == 0) {\n            t1[1].add(a[0], a[0]);\n            t2[1].add(n - 1 - a[0], n - 1 - a[0]);\n            f[0][1] = a[0];\n            g[0][1] = a[0];\n        }\n        \n        for (int i = 1; i < n; i++) {\n            if (t == 1) {\n                f[i][2] = a[i];\n                g[i][2] = a[i];\n                t1[2].add(a[i], a[i]);\n                t2[2].add(n - 1 - a[i], n - 1 - a[i]);\n            }\n            for (int j = 2; j < L; j++) {\n                f[i][j] = t1[j - 1].query(a[i]);\n                g[i][j] = n - 1 - t2[j - 1].query(n - 1 - a[i]);\n                \n                int x = i - j + 1;\n                if (x >= 0 && g[x][j - 1] < n) {\n                    t3[j - 1].add(g[x][j - 1], a[x]);\n                }\n                if (x >= 0 && f[x][j - 1] >= 0) {\n                    t4[j - 1].add(n - 1 - f[x][j - 1], n - 1 - a[x]);\n                }\n                f[i][j] = std::max(f[i][j], t3[j - 1].query(a[i]));\n                g[i][j] = std::min(g[i][j], n - 1 - t4[j - 1].query(n - 1 - a[i]));\n                \n                if (f[i][j] >= 0 || g[i][j] < n) {\n                    ans = std::max(ans, j - t);\n                }\n            }\n            for (int j = 2; j < L; j++) {\n                if (f[i][j] >= 0) {\n                    t1[j].add(a[i], f[i][j]);\n                }\n                if (g[i][j] < n) {\n                    t2[j].add(n - 1 - a[i], n - 1 - g[i][j]);\n                }\n            }\n        }\n    }\n    \n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Turing's Award.json",
    "editorial_link": "https://codeforces.com//blog/entry/92951",
    "editorial": "Let\u00e2\u0080\u0099s look at Alan\u00e2\u0080\u0099s moves in reverse. The process can be reformulated\r\nas follows. Initially, is written down into the cell where Alan is\r\nlocated. Then, for each from down to , first Alan decides whether to\r\nstay or move to a neighboring cell, and then is written down into Alan\u00e2\u0080\u0099s\r\ncell . This way, it\u00e2\u0080\u0099s easier to reason about the process since numbers\r\nnever get overwritten.The state at any moment can be described by the\r\ncurrent sequence and Alan\u00e2\u0080\u0099s position inside this sequence. The only way\r\nwe can change is by appending a number to either end.Suppose we have\r\ndecided which elements of the permutation appear in the final sequence ,\r\nand for each element, whether it gets appended to the front or to the\r\nback. Let\u00e2\u0080\u0099s call these elements . As a special case, is always useful.\r\nTwo things to notice here: We don\u00e2\u0080\u0099t care about intermediate Alan\u00e2\u0080\u0099s\r\npositions, as long as he has enough time to move between consecutive\r\nuseful elements. For example, suppose gets appended to the front of (the\r\nother case is symmetrical), and there are exactly useful elements among\r\n. Let be the \"next\" useful element, that is, and there are no useful\r\nelements between and . If should be appended to the front of , Alan can\r\njust stay in the same cell for elements , and then move to the left to\r\nappend . Here, Alan is always in time. If should be appended to the back\r\nof , Alan has to move to the other end of , and he needs to make steps\r\nto the right. This is possible if and only if . Consider a useful\r\nelement that neither belongs to the LIS (longest increasing subsequence)\r\nof , nor is . We can always change this element\u00e2\u0080\u0099s status to \"not\r\nuseful\", and it won\u00e2\u0080\u0099t harm us in any way. Thus, we can assume that all\r\nof the useful elements, except for maybe , belong to the LIS. Let\u00e2\u0080\u0099s\r\ncasework on whether belongs to the LIS. From now on, we will assume that\r\ndoes belong to the LIS. However, the other case differs just\r\nslightly.Armed with the above observations, we can solve the problem\r\nusing dynamic programming: : suppose is a useful element that gets\r\nappended to the , and there are useful elements among . Then is the\r\npossible value of the element at the of the LIS. : suppose is a useful\r\nelement that gets appended to the , and there are useful elements among\r\n. Then is the possible value of the element at the of the LIS. Note that\r\nsome DP states might be unreachable: in this case, we set to and to\r\n.Consider transitions from (transitions from are similar): For any such\r\nthat , we can set to . For any such that , we can set to . (If we can\r\nset to multiple values, we should choose the smallest one for and the\r\nlargest one for .)Thus, we can transition from to in time. We can\r\noptimize it to if we sweep through the permutation in reverse order ()\r\nand maintain a segment tree for minimum/maximum indexed with element\r\nvalues.The answer to the problem is the largest such that or is a\r\nreachable state for some . The complexity of our solution is thus\r\n.Finally, note that the part of to the left of forms an increasing\r\nsubsequence of , and the part of to the right of forms a decreasing\r\nsubsequence of . It is well-known that the expected length of the\r\nlongest increasing/decreasing subsequence in a random permutation is .\r\nTherefore, our solution works in on average.\r\n"
}