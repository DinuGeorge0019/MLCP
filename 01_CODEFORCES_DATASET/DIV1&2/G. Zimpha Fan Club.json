{
    "link": "https://codeforces.com//contest/1975/problem/G",
    "problemId": "2665478",
    "problem_idx": "G",
    "shortId": "1975G",
    "contest_number": "1975",
    "problem_submissions": {
        "H": [
            262631844,
            262612241,
            262600659,
            262612635,
            263096548
        ],
        "G": [
            262620370,
            262584629,
            262630306,
            262578664,
            262622745,
            262588918,
            262593694,
            262594206,
            262595918,
            262599422,
            262708940,
            262706456,
            262598241,
            262653444,
            262620831,
            262602673,
            262607334,
            262630272,
            262607273,
            262706071,
            262602704,
            262606536,
            262606903,
            262607812,
            263091775,
            263089587,
            263088604,
            263088409,
            263086834,
            263086045,
            262606154,
            264861303,
            262776553,
            262774627,
            262774590,
            262661298,
            262661024,
            262660704,
            262660316,
            262660273,
            262649420,
            262647737,
            262637294,
            262637274,
            262636778,
            262636749,
            262636610,
            262628729,
            262609429
        ],
        "E": [
            262558741,
            262555523,
            262542791,
            262569978,
            262560342,
            262572286,
            262561563,
            262558869,
            262555295,
            262569100,
            262560726,
            262553867,
            262556464,
            262558648,
            262561133,
            262565554,
            262576529,
            262575502,
            262635435,
            262635401,
            262635086,
            262635019,
            262630627,
            262630590,
            262570080
        ],
        "F": [
            262544594,
            262562050,
            262557811,
            262552279,
            262571108,
            262585701,
            262572669,
            262581085,
            262582375,
            262578636,
            262570215,
            262564737,
            262572783,
            262580057,
            262586122,
            262583527,
            262590488,
            262590492,
            262629974,
            262593633
        ],
        "D": [
            262526751,
            262533906,
            262549799,
            262548001,
            262535765,
            262555432,
            262532809,
            262542647,
            262536556,
            262547635,
            262538823,
            262574019,
            262544846,
            262547400,
            262544181,
            262539052,
            262538393,
            262538893,
            262629935,
            262543856
        ],
        "A": [
            262522755,
            262521103,
            262521181,
            262521345,
            262530553,
            262521158,
            262521224,
            262521209,
            262523388,
            262521604,
            262521957,
            262521117,
            262521171,
            262521739,
            262524060,
            262521821,
            262521219,
            262521958
        ],
        "C": [
            262522159,
            262524942,
            262525029,
            262526905,
            262542130,
            262526806,
            262529464,
            262528086,
            262531414,
            262526373,
            262530226,
            262525393,
            262531728,
            262530061,
            262528640,
            262528306,
            262542306,
            262526711
        ],
        "B": [
            262521205,
            262521505,
            262522451,
            262522658,
            262534024,
            262523709,
            262523854,
            262522613,
            262526293,
            262523579,
            262524186,
            262521924,
            262522192,
            262523093,
            262522741,
            262523954,
            262521898,
            262521340
        ],
        "I": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/129801",
    "editorial": "In the following, we consider n,m\n to be of the same order.\n\nConsider the case where s\n and t\n do not contain ?\n. We only need to be compared bit by bit.\n\nConsider the case where s,t\n both contain ?\n, if the beginning of s\n is not ?\n or the beginning of t\n is not ?\n:\n\nIf one of the first characters of s\n and t\n is ?\n or the first characters can match, delete the first characters of the two strings that are not ?\n.\nOherwise the answer is obviously No.\nPerforming the same operation on the last characters, it is not difficult to find that it will be reduced to two strings ?s?\n and t??\n, where s?\n and t?\n are arbitrary strings. Then it is not difficult to find that t?s?\n matches two strings at the same time. Therefore, as long as the head and tail can be successfully deleted, the answer must be Yes.\n\nConsider the hardest case. Without loss of generality, we assume that only t\n contains ?\n, otherwise s,t\n can be exchanged. We still delete the beginning and the end first. It is not difficult to find that thereafter t\n can be written as ?t?1?t?2???t?k?\n.\n\nThen we will have a greedy solution. We iterate i\n from 1\n to n\n, find the first matching position of t?i\n in s\n each time, and delete tthese matching characters and all preceding characters in s\n, that is, remove a prefix of s\n, and then until all matching is completed or no matching position is found in s\n.\n\nAssume that we use FFT to brute force solve this problem every time. See Hint.3 for the specific solution, then the complexity is O(nklogn)\n.\n\nBut it is not difficult to find that this is very wasteful. In fact, we can do this:\n\nWhen matching t?i\n, only take out the first |2t?i|\n characters of s\n each time and try to match t?i\n. Because if the match is successful, then since all positions matching t?i\n are deleted, it is not difficult to find that at least |t?i|\n characters are deleted. And if the match fails, it is not difficult to find that the first |t?i|\n characters of s\n will no longer be useful and can also be deleted. Therefore we remove at least the first |t?i|\n characters in s\n in complexity O(|t?i|log|t?i|)\n.",
    "name": "G. Zimpha Fan Club",
    "statement": "One day, Zimpha casually came up with a problem. As a member of \"Zimpha\r\nfan club\", you decided to solve that problem.You are given two strings s\r\nand t of length n and m, respectively. Both strings only consist of\r\nlowercase English letters, and .You need to replace all occurrences of\r\nand , observing the following rules: For each , you must replace it with\r\nany lowercase English letter. For each , you must replace it with a\r\nstring of any (possibly, zero) length which only consists of lowercase\r\nEnglish letters. Note that you can replace two different instances of\r\nwith different characters. You can also replace each two different\r\ninstances of with different strings.Suppose s and t have been\r\ntransformed into s’ and t’. Now you’re wondering if there’s a\r\nreplacement that makes s’=t’.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 25.05.2024 11:48:05**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif template <typename T>T inverse(T a, T m) {  T u = 0, v = 1;  while (a != 0) {    T t = m / a;    m -= t * a; swap(a, m);    u -= t * v; swap(u, v);  }  assert(m == 1);  return u;} template <typename T>class Modular { public:  using Type = typename decay<decltype(T::value)>::type;   constexpr Modular() : value() {}  template <typename U>  Modular(const U& x) {    value = normalize(x);  }   template <typename U>  static Type normalize(const U& x) {    Type v;    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);    else v = static_cast<Type>(x % mod());    if (v < 0) v += mod();    return v;  }   const Type& operator()() const { return value; }  template <typename U>  explicit operator U() const { return static_cast<U>(value); }  constexpr static Type mod() { return T::value; }   Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }  Modular& operator++() { return *this += 1; }  Modular& operator--() { return *this -= 1; }  Modular operator++(int) { Modular result(*this); *this += 1; return result; }  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }  Modular operator-() const { return Modular(-value); }   template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));    return *this;  }  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());    value = normalize(value * rhs.value - q * mod());    return *this;  }  template <typename U = T>  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(value * rhs.value);    return *this;  }   Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }   friend const Type& abs(const Modular& x) { return x.value; }   template <typename U>  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);   template <typename U>  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);   template <typename V, typename U>  friend V& operator>>(V& stream, Modular<U>& number);  private:  Type value;}; template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; } template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); } template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; } template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; } template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; } template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; } template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; } template<typename T, typename U>Modular<T> power(const Modular<T>& a, const U& b) {  assert(b >= 0);  Modular<T> x = a, res = 1;  U p = b;  while (p > 0) {    if (p & 1) res *= x;    x *= x;    p >>= 1;  }  return res;} template <typename T>bool IsZero(const Modular<T>& number) {  return number() == 0;} template <typename T>string to_string(const Modular<T>& number) {  return to_string(number());} // U == std::ostream? but done this way because of fastoutputtemplate <typename U, typename T>U& operator<<(U& stream, const Modular<T>& number) {  return stream << number();} // U == std::istream? but done this way because of fastinputtemplate <typename U, typename T>U& operator>>(U& stream, Modular<T>& number) {  typename common_type<typename Modular<T>::Type, long long>::type x;  stream >> x;  number.value = Modular<T>::normalize(x);  return stream;} /*using ModType = int; struct VarMod { static ModType value; };ModType VarMod::value;ModType& md = VarMod::value;using Mint = Modular<VarMod>;*/ constexpr int md = 998244353;using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>; /*vector<Mint> fact(1, 1);vector<Mint> inv_fact(1, 1); Mint C(int n, int k) {  if (k < 0 || k > n) {    return 0;  }  while ((int) fact.size() < n + 1) {    fact.push_back(fact.back() * (int) fact.size());    inv_fact.push_back(1 / fact.back());  }  return fact[n] * inv_fact[k] * inv_fact[n - k];}*/ template <typename T>class NTT { public:  using Type = typename decay<decltype(T::value)>::type;   static Type md;  static Modular<T> root;  static int base;  static int max_base;  static vector<Modular<T>> roots;  static vector<int> rev;   static void clear() {    root = 0;    base = 0;    max_base = 0;    roots.clear();    rev.clear();  }   static void init() {    md = T::value;    assert(md >= 3 && md % 2 == 1);    auto tmp = md - 1;    max_base = 0;    while (tmp % 2 == 0) {      tmp /= 2;      max_base++;    }    root = 2;    while (power(root, (md - 1) >> 1) == 1) {      root++;    }    assert(power(root, md - 1) == 1);    root = power(root, (md - 1) >> max_base);    base = 1;    rev = {0, 1};    roots = {0, 1};  }   static void ensure_base(int nbase) {    if (md != T::value) {      clear();    }    if (roots.empty()) {      init();    }    if (nbase <= base) {      return;    }    assert(nbase <= max_base);    rev.resize(1 << nbase);    for (int i = 0; i < (1 << nbase); i++) {      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));    }    roots.resize(1 << nbase);    while (base < nbase) {      Modular<T> z = power(root, 1 << (max_base - 1 - base));      for (int i = 1 << (base - 1); i < (1 << base); i++) {        roots[i << 1] = roots[i];        roots[(i << 1) + 1] = roots[i] * z;      }      base++;    }  }   static void fft(vector<Modular<T>> &a) {    int n = (int) a.size();    assert((n & (n - 1)) == 0);    int zeros = __builtin_ctz(n);    ensure_base(zeros);    int shift = base - zeros;    for (int i = 0; i < n; i++) {      if (i < (rev[i] >> shift)) {        swap(a[i], a[rev[i] >> shift]);      }    }    for (int k = 1; k < n; k <<= 1) {      for (int i = 0; i < n; i += 2 * k) {        for (int j = 0; j < k; j++) {          Modular<T> x = a[i + j];          Modular<T> y = a[i + j + k] * roots[j + k];          a[i + j] = x + y;          a[i + j + k] = x - y;        }      }    }  }   static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {    if (a.empty() || b.empty()) {      return {};    }    int eq = (a == b);    int need = (int) a.size() + (int) b.size() - 1;    int nbase = 0;    while ((1 << nbase) < need) nbase++;    ensure_base(nbase);    int sz = 1 << nbase;    a.resize(sz);    b.resize(sz);    fft(a);    if (eq) b = a; else fft(b);    Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);    for (int i = 0; i < sz; i++) {      a[i] *= b[i] * inv_sz;    }    reverse(a.begin() + 1, a.end());    fft(a);    a.resize(need);    return a;  }}; template <typename T> typename NTT<T>::Type NTT<T>::md;template <typename T> Modular<T> NTT<T>::root;template <typename T> int NTT<T>::base;template <typename T> int NTT<T>::max_base;template <typename T> vector<Modular<T>> NTT<T>::roots;template <typename T> vector<int> NTT<T>::rev; template <typename T>vector<Modular<T>> inverse(const vector<Modular<T>>& a) {  assert(!a.empty());  int n = (int) a.size();  vector<Modular<T>> b = {1 / a[0]};  while ((int) b.size() < n) {    vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));    x.resize(b.size() << 1);    b.resize(b.size() << 1);    vector<Modular<T>> c = b;    NTT<T>::fft(c);    NTT<T>::fft(x);    Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());    for (int i = 0; i < (int) x.size(); i++) {      x[i] *= c[i] * inv;    }    reverse(x.begin() + 1, x.end());    NTT<T>::fft(x);    rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());    fill(x.begin() + (x.size() >> 1), x.end(), 0);    NTT<T>::fft(x);    for (int i = 0; i < (int) x.size(); i++) {      x[i] *= c[i] * inv;    }    reverse(x.begin() + 1, x.end());    NTT<T>::fft(x);    for (int i = 0; i < ((int) x.size() >> 1); i++) {      b[i + ((int) x.size() >> 1)] = -x[i];    }  }  b.resize(n);  return b;} template <typename T>vector<Modular<T>> inverse_old(vector<Modular<T>> a) {  assert(!a.empty());  int n = (int) a.size();  if (n == 1) {    return {1 / a[0]};  }  int m = (n + 1) >> 1;  vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));  int need = n << 1;  int nbase = 0;  while ((1 << nbase) < need) {    ++nbase;  }  NTT<T>::ensure_base(nbase);  int size = 1 << nbase;  a.resize(size);  b.resize(size);  NTT<T>::fft(a);  NTT<T>::fft(b);  Modular<T> inv = 1 / static_cast<Modular<T>>(size);  for (int i = 0; i < size; ++i) {    a[i] = (2 - a[i] * b[i]) * b[i] * inv;  }  reverse(a.begin() + 1, a.end());  NTT<T>::fft(a);  a.resize(n);  return a;} template <typename T>vector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {  if (a.empty() || b.empty()) {    return {};  }  if (min(a.size(), b.size()) < 150) {    vector<Modular<T>> c(a.size() + b.size() - 1, 0);    for (int i = 0; i < (int) a.size(); i++) {      for (int j = 0; j < (int) b.size(); j++) {        c[i + j] += a[i] * b[j];      }    }    return c;  }  return NTT<T>::multiply(a, b);} template <typename T>vector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {  return a = a * b;} int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int n, m;  cin >> n >> m;  string s, t;  cin >> s >> t;  int ls = 0, rs = n;  int lt = 0, rt = m;  while (ls < rs && lt < rt) {    if (s[ls] != '*' && t[lt] != '*') {      if (s[ls] != '-' && t[lt] != '-' && s[ls] != t[lt]) {        cout << \"No\" << '\\n';        return 0;      }      ls += 1;      lt += 1;    } else {      break;    }  }  while (ls < rs && lt < rt) {    if (s[rs - 1] != '*' && t[rt - 1] != '*') {      if (s[rs - 1] != '-' && t[rt - 1] != '-' && s[rs - 1] != t[rt - 1]) {        cout << \"No\" << '\\n';        return 0;      }      rs -= 1;      rt -= 1;    } else {      break;    }  }  bool star_s = false;  bool star_t = false;  for (int i = ls; i < rs; i++) {    if (s[i] == '*') {      star_s = true;    }  }  for (int i = lt; i < rt; i++) {    if (t[i] == '*') {      star_t = true;    }  }  if (star_s && star_t) {    cout << \"Yes\" << '\\n';    return 0;  }  if (!star_s && !star_t) {    cout << (ls == rs && lt == rt ? \"Yes\" : \"No\") << '\\n';    return 0;  }  if (star_t) {    swap(s, t);    swap(n, m);    swap(ls, lt);    swap(rs, rt);    swap(star_s, star_t);  }  assert(star_s && !star_t);  if (!(s[ls] == '*' && s[rs - 1] == '*')) {    cout << \"No\" << '\\n';    return 0;  }  vector<string> subs;  string cur = \"\";  for (int i = ls; i < rs; i++) {    if (s[i] == '*') {      if (cur != \"\") {        subs.push_back(cur);        cur = \"\";      }    } else {      cur += s[i];    }  }  t = t.substr(lt, rt - lt);  m = int(t.size());  vector<Mint> code(26);  vector<Mint> inv(26);  mt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());  for (int i = 0; i < 26; i++) {    code[i] = rng() % (md - 10) + 5;    inv[i] = 1 / code[i];  }  int ptr = 0;  for (string& w : subs) {    int len = int(w.size());    vector<Mint> b(len);    vector<Mint> b1(len);    for (int i = 0; i < len; i++) {      b[len - 1 - i] = (w[i] == '-' ? 0 : inv[int(w[i] - 'a')]);      b1[len - 1 - i] = (w[i] == '-' ? 0 : 1);    }    bool found = false;    while (ptr + len <= m) {      int until = min(m, ptr + 2 * len);      vector<Mint> a(until - ptr);      vector<Mint> a1(until - ptr);      for (int i = ptr; i < until; i++) {        a[i - ptr] = (t[i] == '-' ? 0 : code[int(t[i] - 'a')]);        a1[i - ptr] = (t[i] == '-' ? 0 : 1);      }      auto p = a * b;      auto p1 = a1 * b1;      for (int i = ptr; i <= until - len; i++) {        int at = i + len - 1;        if (p[at - ptr] == p1[at - ptr]) {          found = true;          ptr = i + len;          break;        }      }      if (found) {        break;      }      ptr = until - len + 1;    }    if (!found) {      cout << \"No\" << '\\n';      return 0;    }  }  cout << \"Yes\" << '\\n';  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "fft",
        "greedy",
        "math",
        "strings"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Zimpha Fan Club.json",
    "hint": [
        "Hint 1 If both have , or both don't have , then it will be a simple problem. Can you try to solve this problem?",
        "Hint 2 According to the first hint, we have discussed two cases. In the remaining cases, without loss of generality, we think that only has . Suppose we write as . Where does not take , assuming that is satisfied for all , can you solve this problem?",
        "Hint 3 There is a strictly subproblem of this problem, namely, given two strings and consisting only of characters from to and , you need to find all positions in where can be matched. This problem has a classic solution, where is set to , and to are sequentially assigned values from to , and then let , then all positions of satisfy can match $t$​. Decompose the calculation formula, . For , you can prefix and process it, and for the remaining part, you can use FFT in to be resolved. What is the use of this solution in the original problem?"
    ]
}