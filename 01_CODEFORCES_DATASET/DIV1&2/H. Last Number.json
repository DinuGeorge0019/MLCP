{
    "link": "https://codeforces.com//contest/1810/problem/H",
    "problemId": "1858193",
    "problem_idx": "H",
    "shortId": "1810H",
    "contest_number": "1810",
    "problem_submissions": {
        "H": [
            200016390,
            200313241,
            200015282,
            200812601,
            200812580
        ],
        "G": [
            199990963,
            200002014,
            199996533,
            200001110,
            200003038,
            200004181,
            200005432,
            199993820,
            200004120,
            200568360,
            200010476,
            200003987,
            200009790,
            200084069,
            200013246,
            200017198,
            200016482,
            200017082
        ],
        "F": [
            199985968,
            199984766,
            199989455,
            199989236,
            199990364,
            199996618,
            199996912,
            199994977,
            200012837,
            199994874,
            200568272,
            200001624,
            200000551,
            200004906,
            200000508,
            200003276,
            200003731,
            200007640,
            199989234,
            200033060,
            200032756,
            200032417,
            199995728
        ],
        "E": [
            199973604,
            199973630,
            199978803,
            199976534,
            199977412,
            199980989,
            199981737,
            199978795,
            199980030,
            199987523,
            200568220,
            199981333,
            199992052,
            199984164,
            199985692,
            199981426,
            199983733,
            199981446,
            199972392,
            199985691
        ],
        "D": [
            199968387,
            199968634,
            199971474,
            199971965,
            199971391,
            199974445,
            199974261,
            199971649,
            199972646,
            199975130,
            200568168,
            199974978,
            199975450,
            199972122,
            199977461,
            199974856,
            199972685,
            199972896,
            199981843,
            199971530
        ],
        "C": [
            199963369,
            199964848,
            199966060,
            199965953,
            199966410,
            199967396,
            199960693,
            199966704,
            199968525,
            199967275,
            200567509,
            199968793,
            199967659,
            199965932,
            199965761,
            199966489,
            199966901,
            199965471,
            199965927,
            199965128
        ],
        "B": [
            199960187,
            199959404,
            199963381,
            199961597,
            199960246,
            199963356,
            199965608,
            199963400,
            199964087,
            199961201,
            200567461,
            199963792,
            199967959,
            199962648,
            199961478,
            199962690,
            199964055,
            199962786,
            199961957,
            199961076
        ],
        "A": [
            199957585,
            199957600,
            199957721,
            199957828,
            199957624,
            199957823,
            199967044,
            199957994,
            199959433,
            199957593,
            200567421,
            199957914,
            199957630,
            199957622,
            199957736,
            199957568,
            199959457,
            199957708,
            199957575,
            199957879
        ]
    },
    "name": "H. Last Number",
    "statement": "You are given a multiset S. Initially, S =\r\n{1,2,3,\r\nldots, n\r\n}.You will perform the following operation n-1 times. Choose the largest\r\nnumber S_{\r\ntext{max}} in S and the smallest number S_{\r\ntext{min}} in S. Remove the two numbers from S, and add S_{\r\ntext{max}} - S_{\r\ntext{min}} into S. It’s easy to show that there will be exactly one\r\nnumber left after n-1 operations. Output that number.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconst long double phi = (1 + std::sqrt(5.L)) / 2;\n\ni64 floor_sum(i64 n, i64 m, i64 a, i64 b) {\n    i64 ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\nconstexpr i64 X = 701408733;\nconstexpr i64 Y = 1134903170;\n\nint g(int n) {\n    int ans = 0;\n    ans -= floor_sum(n / 2 + 1, Y, 2 * X, 0);\n    ans += floor_sum((n + 1) / 2, Y, 2 * X, X);\n    return ans;\n}\n\nint get(int n) {\n    int t = (n + 1) * Y / (2 * Y + X);\n    \n    int ans = 0;\n    ans += g(n - 1);\n    ans -= g(t);\n    if (n % 2 == 0) {\n        ans *= -1;\n    }\n    ans += int(n * X / Y) * ((n - t - 1) % 2 == 0 ? -1 : 1);\n    if ((n - t) % 2 == 1) {\n        ans += n;\n    }\n    \n    return ans;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::cout << get(n) << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Last Number.json",
    "editorial_link": "https://codeforces.com//blog/entry/114521",
    "editorial": "TutorialAssume that the moment before the -th operation(but after -th),\r\nthe first time we have . Letâs divide the operation into two part:\r\nbefore and equal or after .Still, at the moment just before the -th\r\noperation, let us sort the elements in the multiset in non-decreasing\r\norder, . We will show that the answer is . ProofThis lemma is based on\r\nthe fact that, after each operation(which is after -th), to will not\r\nchange, is removed, and turn to . Which also means always holds.At the\r\nvery beginning, obviously holds. And we can observe that either or .\r\nWhen , the new after two operations is equal to the old . When , the new\r\nafter two operations is equal to the old minus one. So if we write the\r\nas an array by time order, always holds. Thus, always holds.Let be the\r\nvalue in the -th operation. Letâs prove that before the -th operation, ,\r\nwhere . ProofWe prove this by Mathematical induction. One fact should be\r\nknown that during these operations, always holds for the -th\r\noperation(since ).For , it is true because and .Assume for , it is true.\r\nStill use the fact that or . The necessary and sufficient condition for\r\nis all the numbers greater or equal to is âusedâ. How many numbers are\r\nthere? We have numbers from the original multiset, and some numbers that\r\noccurs during the operations, which are the number of satisfying . Thus,\r\nis equivalent to:Note that is always increasing, which means that\r\nformula holds for , but does not hold for .The first equation, always\r\nholds. Because , and ofcourse .Letâs do the research when the second\r\nequation does not hold. Let , and (). Note that , since . The topic we\r\nare going to research is when hold(which also means, ).Then letâs focus\r\non, if , when will hold? Itâs easy to find when , holds. And since , we\r\ncan tell . Thus, we proved the topic, for all (before the -th\r\noperation), .Then, by solve , we can get . Now letâs prove for , also\r\nholds ! ProofUsing the similar idea as lemma 2, find out when holds.\r\nHowever, at this time, only will contribute(since for those , according\r\nto lemma 1, they become the minimal one and do not contribute to\r\nanything). Similarly, that is . Seems to be different this time, but\r\nactually they are the same, because holds(the proving is easy, leave it\r\nas a exercise). This condition holds means that we can use the same\r\nmethod in lemma 2 to prove it.Till now, the lemmas told us the solving\r\nthe problem is actually solving something like . We can divide them into\r\npositive part and negtive part, and then solving , where range from some\r\nto , and is a irrational constant. Since is not very large, we can\r\napproximate by , where are integers, and turn it into a traditional\r\ntask. (Maybe it is called floor sum or something like, Iâm not sure\r\nabout the algorithmâs english name).The marvelous jiangly told me in\r\nlong long range is enough. But the tester used int128.We can dig more\r\nabout the . Let (sorted, before the -th operation), and what we care is\r\n. We can find that array is actually a consecutive substring of\r\nfibonacci string. More over, let be the starting point of array in the\r\nfibonacci string when the initial size is , we have the conclusion for\r\n:, where . represents a list of numbers .Now the only left problem is to\r\nfind the prefix sum of fibonacci string(of even positions, or of odd\r\npositions). This is quite a simple task by using any or solution.\r\n",
    "hint": []
}