{"link": "https://codeforces.com//contest/1810/problem/H", "problemId": "1858193", "problem_idx": "H", "shortId": "1810H", "contest_number": "1810", "problem_submissions": {"H": [200016390, 200313241, 200015282, 200812601, 200812580], "G": [199990963, 200002014, 199996533, 200001110, 200003038, 200004181, 200005432, 199993820, 200004120, 200568360, 200010476, 200003987, 200009790, 200084069, 200013246, 200017198, 200016482, 200017082], "F": [199985968, 199984766, 199989455, 199989236, 199990364, 199996618, 199996912, 199994977, 200012837, 199994874, 200568272, 200001624, 200000551, 200004906, 200000508, 200003276, 200003731, 200007640, 199989234, 200033060, 200032756, 200032417, 199995728], "E": [199973604, 199973630, 199978803, 199976534, 199977412, 199980989, 199981737, 199978795, 199980030, 199987523, 200568220, 199981333, 199992052, 199984164, 199985692, 199981426, 199983733, 199981446, 199972392, 199985691], "D": [199968387, 199968634, 199971474, 199971965, 199971391, 199974445, 199974261, 199971649, 199972646, 199975130, 200568168, 199974978, 199975450, 199972122, 199977461, 199974856, 199972685, 199972896, 199981843, 199971530], "C": [199963369, 199964848, 199966060, 199965953, 199966410, 199967396, 199960693, 199966704, 199968525, 199967275, 200567509, 199968793, 199967659, 199965932, 199965761, 199966489, 199966901, 199965471, 199965927, 199965128], "B": [199960187, 199959404, 199963381, 199961597, 199960246, 199963356, 199965608, 199963400, 199964087, 199961201, 200567461, 199963792, 199967959, 199962648, 199961478, 199962690, 199964055, 199962786, 199961957, 199961076], "A": [199957585, 199957600, 199957721, 199957828, 199957624, 199957823, 199967044, 199957994, 199959433, 199957593, 200567421, 199957914, 199957630, 199957622, 199957736, 199957568, 199959457, 199957708, 199957575, 199957879]}, "name": "H. Last Number", "statement": "You are given a multiset S. Initially, S =\r\n{1,2,3,\r\nldots, n\r\n}.You will perform the following operation n-1 times. Choose the largest\r\nnumber S_{\r\ntext{max}} in S and the smallest number S_{\r\ntext{min}} in S. Remove the two numbers from S, and add S_{\r\ntext{max}} - S_{\r\ntext{min}} into S. It\u2019s easy to show that there will be exactly one\r\nnumber left after n-1 operations. Output that number.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconst long double phi = (1 + std::sqrt(5.L)) / 2;\n\ni64 floor_sum(i64 n, i64 m, i64 a, i64 b) {\n    i64 ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\nconstexpr i64 X = 701408733;\nconstexpr i64 Y = 1134903170;\n\nint g(int n) {\n    int ans = 0;\n    ans -= floor_sum(n / 2 + 1, Y, 2 * X, 0);\n    ans += floor_sum((n + 1) / 2, Y, 2 * X, X);\n    return ans;\n}\n\nint get(int n) {\n    int t = (n + 1) * Y / (2 * Y + X);\n    \n    int ans = 0;\n    ans += g(n - 1);\n    ans -= g(t);\n    if (n % 2 == 0) {\n        ans *= -1;\n    }\n    ans += int(n * X / Y) * ((n - t - 1) % 2 == 0 ? -1 : 1);\n    if ((n - t) % 2 == 1) {\n        ans += n;\n    }\n    \n    return ans;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::cout << get(n) << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "math"], "dificulty": "2900", "interactive": false}