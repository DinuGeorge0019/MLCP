{
    "link": "https://codeforces.com//contest/868/problem/D",
    "problemId": "126219",
    "problem_idx": "D",
    "shortId": "868D",
    "contest_number": "868",
    "problem_submissions": {
        "E": [
            31023051,
            31024523,
            31024148,
            31025167,
            31018209,
            31025864,
            31026369,
            31028260,
            31026372,
            31044397,
            31026066,
            31027557,
            31023308,
            31023861,
            31019541,
            31162068,
            31021787
        ],
        "F": [
            31020755,
            31020638,
            33743391,
            31021116,
            31022470,
            31023238,
            31022737,
            31023926,
            31023102,
            31028638,
            31028134,
            31020706,
            31027648,
            31019840,
            31023078,
            31023660,
            31027919
        ],
        "D": [
            31018151,
            31017707,
            31016713,
            31018303,
            31025757,
            31018243,
            31018489,
            31024010,
            31018691,
            31020147,
            31017621,
            31017612,
            31016732,
            31017515,
            31015826,
            31017997,
            31021417
        ],
        "C": [
            31014273,
            31014407,
            31012209,
            31014307,
            31013815,
            31013945,
            31015314,
            31013335,
            31014790,
            31016275,
            31030598,
            31013440,
            31030706,
            31066551,
            31014026,
            31012823,
            31014457,
            31014258,
            31016540
        ],
        "B": [
            31013104,
            31012812,
            31013438,
            31013042,
            31012539,
            31026919,
            31016195,
            31015461,
            31013166,
            31014218,
            31022627,
            31012140,
            31012861,
            31016249,
            31011794,
            31012575,
            31013032,
            31014544
        ],
        "A": [
            31010698,
            31010763,
            31010903,
            31010896,
            31010747,
            31010833,
            31010957,
            31012028,
            31010858,
            31021512,
            31010696,
            31010727,
            31012054,
            31010635,
            31010757,
            31011798,
            31010661
        ],
        "G": [
            31179602
        ]
    },
    "name": "D. Huge Strings",
    "statement": "You are given strings consisting of characters and . operations are\r\nperformed, on each of them you concatenate two existing strings into a\r\nnew one. On the -th operation the concatenation is saved into a new\r\nstring (the operations are numbered starting from ). After each\r\noperation you need to find the maximum positive integer such that all\r\npossible strings consisting of and of length (there are such strings)\r\nare substrings of the new string. If there is no such , print .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nstruct str {\n\tstring pre, suf;\n\tint r;\n\tchar a[65536];\n} d[202];\n\nstr operator +(const str &u, const str &v) {\n\tstr res;\n\tint i, j, t, tt;\n\tfor (i = 0; i < 65536; i++) res.a[i] = u.a[i] || v.a[i];\n\tif (u.pre == u.suf) {\n\t\tres.pre = u.pre + v.pre;\n\t\tif (res.pre.size() > 20) res.pre.resize(20);\n\t}\n\telse res.pre = u.pre;\n\tif (v.pre == v.suf) {\n\t\tres.suf = u.suf + v.suf;\n\t\tif (res.suf.size() > 20) res.suf = res.suf.substr(res.suf.size() - 20, 20);\n\t}\n\telse res.suf = v.suf;\n\tt = 0;\n\tfor (i = 0; i < 16 && i < u.suf.size(); i++) {\n\t\tt |= (u.suf[u.suf.size() - i - 1] & 1) << i;\n\t\ttt = t;\n\t\tfor (j = 0; j < 16 && j < v.pre.size(); j++) {\n\t\t\ttt = tt << 1 | v.pre[j] & 1;\n\t\t\tif (i + j + 2 < 16) res.a[1 << i + j + 2 | tt] = 1;\n\t\t}\n\t}\n\tfor (res.r = 0;; res.r++) {\n\t\tfor (i = 0; i < 1 << res.r && res.a[1 << res.r | i]; i++);\n\t\tif (i < 1 << res.r) break;\n\t}\n\treturn res;\n}\n\nchar tt[256];\n\nint main() {\n\tint i, j, k, n, m, t;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", tt);\n\t\td[i].pre = d[i].suf = tt;\n\t\td[i].a[1] = 1;\n\t\tfor (j = 0; j < d[i].pre.size(); j++) for (k = t = 0; k < 15 && j + k < d[i].pre.size(); k++) {\n\t\t\tt = t << 1 | d[i].pre[j + k] & 1;\n\t\t\td[i].a[1 << k + 1 | t] = 1;\n\t\t}\n\t}\n\tscanf(\"%d\", &m);\n\tfor (k = 1; k <= m; k++) {\n\t\tscanf(\"%d%d\", &i, &j);\n\t\td[n + k] = d[i] + d[j];\n\t\tprintf(\"%d\\n\", d[n + k].r - 1);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "implementation",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Huge Strings.json",
    "editorial_link": "https://codeforces.com/blog/entry/55046",
    "editorial": "The key insight is that despite the strings can get very long, the\r\nanswer for each string at most 9. Indeed, let us keep track of the\r\nnumber of distinct substrings of length 10 across all strings.\r\nObviously, this number is at most 100 for the initial strings. Once we\r\nobtain a new string as a concatenation of two old ones, the only new\r\nsubstrings can arise on the border of these two strings, and there can\r\nbe at most 9 of these substrings. Since , it is impossible to construct\r\na string with answer 10.Now, the solution is for each new string store\r\nthe set of all distinct substrings of length at most 9. In order to\r\nconstruct this set for subsequent strings, we will have to store the\r\nfirst and the last 9 characters of each string (probably less if the\r\nstring is shorter than 9). The number of operations is roughly if we\r\nstore the distinct substrings in arrays, but can be made smaller if we\r\nuse bitsets.\r\n",
    "hint": []
}