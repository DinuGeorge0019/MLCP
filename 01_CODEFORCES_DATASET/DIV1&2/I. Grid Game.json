{
    "link": "https://codeforces.com//contest/1991/problem/I",
    "problemId": "2781509",
    "problem_idx": "I",
    "shortId": "1991I",
    "contest_number": "1991",
    "problem_submissions": {
        "H": [
            273210632,
            273212730,
            273219908,
            273194851,
            273200656,
            273213505,
            273204889,
            273220591,
            273225451,
            273220804,
            273226512,
            273222266,
            273229115,
            278405080,
            273216843
        ],
        "G": [
            273180456,
            273179521,
            273174064,
            273209283,
            273179708,
            273185549,
            273216085,
            273188851,
            273191410,
            273193985,
            273189153,
            273194518,
            273197531,
            273190195,
            273195818,
            273188177,
            273190908,
            273195464,
            273198241
        ],
        "F": [
            273160781,
            273160990,
            273158593,
            273158141,
            273171320,
            273168196,
            273159727,
            273170129,
            273173513,
            273170857,
            273165439,
            273182207,
            273174869,
            273166190,
            273163947,
            273173198,
            273175470,
            273163587,
            273174682,
            273170108
        ],
        "E": [
            273150868,
            273153734,
            273152235,
            273150823,
            273156934,
            273151786,
            273150935,
            273157824,
            273151366,
            273154414,
            273174335,
            273161395,
            273159133,
            273156803,
            273161464,
            273162124,
            273154749,
            273158567,
            273155964
        ],
        "D": [
            273143134,
            273144551,
            273142645,
            273141713,
            273147820,
            273143829,
            273141673,
            273145581,
            273156995,
            273145729,
            273149790,
            273146459,
            273144249,
            273145676,
            273154684,
            273150687,
            273147840,
            273144991,
            273148567
        ],
        "C": [
            273139495,
            273142387,
            273139319,
            273241170,
            273142853,
            273141897,
            273140491,
            273138783,
            273141460,
            273141958,
            273141853,
            273144830,
            273141321,
            273143714,
            273141051,
            273142758,
            273145128,
            273137630,
            273141184,
            273143400
        ],
        "B": [
            273133106,
            273134906,
            273133339,
            273134525,
            273138116,
            273135569,
            273133092,
            273135379,
            273136693,
            273135755,
            273136343,
            273135805,
            273132915,
            273135366,
            273136849,
            273139913,
            273132449,
            273135138,
            273136549
        ],
        "A": [
            273130858,
            273132065,
            273130939,
            273130875,
            273131982,
            273132539,
            273130929,
            273131106,
            273131228,
            273130992,
            273131052,
            273131178,
            273130862,
            273131382,
            273131308,
            273132778,
            273130871,
            273130965,
            273131362
        ],
        "I": [
            273238749,
            273429741
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132021",
    "editorial": "Notice that if the problem requires our selected numbers' sum to be greater than the interactor's sum, instead of smaller, the essence of the problem changes. Specifically, when n?m\n is odd, the interactor will select one more number than us. If the goal is to have a greater sum of numbers, the interactor will have an advantage; conversely, if the goal is to have a smaller sum, we will have an advantage.\n\nDepending on whether n?m\n is odd or even, we can use different methods to fill the grid and adapt our game strategy. Here, we will explain these two methods and strategies in detail.\n\nWhen n?m\n is odd, we can adopt a strategy that forces the interactor to choose the largest number, n?m\n. Specifically, we can divide the grid into:\n\n?n?m2?\n dominos (1\u00d72\n or 2\u00d71\n tiles), each containing two adjacent numbers.\nIn the remaining single cell, we place the largest number.\nOur strategy is as follows: If the interactor chooses a number from a domino and the other number has not yet been chosen, we choose that number; otherwise, we choose any valid number from the dominos. This ensures that:\n\nIn each domino, both we and the interactor select one number. Proof: The interactor cannot choose both numbers in a domino because as soon as they choose the first one, we immediately choose the second one. Therefore, we select at least one number in each domino. We cannot select two numbers in any domino because our total number of selections would exceed the number of dominos, which equals our total number of selections. Hence, we exactly select one number in each domino.\nThe interactor will inevitably choose the largest number. Proof: Since we only choose numbers from the dominos, the remaining largest number will not be selected by us.\nIn the worst case, we will choose the larger number in each domino. However, the interactor will always select the largest number. Therefore, in this scenario, our sum will be less than the interactor's sum by n?m??n?m2?=?n?m2?\n.\n\nWhen n?m\n is even, we can divide the grid into several tiles. After the interactor chooses a number from a tile, we immediately choose from the same tile. We set each tile size to be even, ensuring we always select the second number from each tile.\n\nIf a small number is surrounded by large numbers in a tile, as the second chooser we can choose the small number. We place the small numbers on the edges of the grid, where the number of surrounding cells is odd, ensuring that each tile has an even number of cells. This tiling arrangement gives us a significant advantage; only a few such tiles are needed, while the rest of the grid can be filled with dominos containing adjacent numbers, making our sum of numbers smaller. Here are the detailed descriptions of grid filling and game strategy:\n\nWe divide the grid into:\n\n4\n T-shaped tiles, each with a small number at the edge of the grid, surrounded by three large numbers.\nn?m?162\n dominos, each containing two adjacent numbers.\nSpecifically, we define [1,4]\n as small numbers, and [n?m?11,n?m]\n as large numbers. Numbers [n?m?11,n?m?9]\n surround number 1\n, [n?m?8,n?m?6]\n surround number 2\n, [n?m?5,n?m?3]\n surround number 3\n, and [n?m?2,n?m]\n surround number 4\n.\n\nAssuming n?m\n, we divide the grid as follows:\n\nFor n=4\n and m=4\n, as well as n=4\n and m=5\n, we manually divide the grid.\n\nThis is a specific layout for a 4\u00d74\n grid, with bold lines indicating tiles division, green cells representing small numbers, and red cells representing large numbers.\n\nThis is a specific layout for a 4\u00d75\n grid, with additional settings, where yellow cells represent adjacent numbers in dominos.\nFor m?6\n, we place two T-shaped tiles and two dominos in the top left and top right 4\u00d73\n areas. The remaining part of the top four rows can be filled with vertical dominos. For rows beyond the top four, if m\n is even, we fill them with horizontal dominos; if m\n is odd, we fill them with vertical dominos.\n\nThis is a specific layout for a 5\u00d78\n grid, an example where m\n is even.\n\nThis is a specific layout for a 6\u00d77\n grid, an example where m\n is odd.\nOur strategy is as follows: After the interactor chooses a number from a tile, we will immediately choose the smallest valid number from the same tile. This ensures that the interactor can only start choosing from the large numbers in each T-shaped tile, allowing us to choose the small number, except for the small number that the interactor initially chooses.\n\nNext, we will analyze why this strategy ensures a smaller sum. For each T-shaped tile, if the interactor did not initially choose from this tile, we can at least choose the smallest and largest numbers; if the interactor initially chose from this tile, we can at least choose the second smallest and largest numbers. We find that if the interactor chooses to start from the T-shaped tile, they take away our smallest number and give us the second smallest number. Thus, in the worst case, the interactor starts choosing from number 4\n, where the difference between the smallest and second smallest numbers in that tile is the largest. In dominos, we assume we will choose the larger number.\n\nIn the worst case, the calculation of our sum of numbers minus the interactor's sum of numbers is: (1?(n?m?11)?(n?m?10)+(n?m?9))+\n\n(2?(n?m?8)?(n?m?7)+(n?m?6))+\n\n(3?(n?m?5)?(n?m?4)+(n?m?3))+\n\n(?4+(n?m?2)?(n?m?1)+n?m)+\n\n(n?m?16)/2=\n\n20?1.5?n?m\n\nWhen n\n and m\n are at their minimum, this value is the largest and unfavorable for us. However, when n\n and m\n are at their minimum of 4\n, our sum of numbers is still 4\n less than the interactor's (20?1.5?4?4=?4\n).",
    "name": "I. Grid Game",
    "statement": "You are given a grid with n rows and m columns. You need to fill each\r\ncell with a unique integer from 1 to n\r\ncdot m.After filling the grid, you will play a game on this grid against\r\nthe interactor. Players take turns selecting one of the previously\r\nunselected cells from the grid, with the interactor going first.On the\r\nfirst turn, the interactor can choose any cell from the grid. After\r\nthat, any chosen cell must be orthogonally adjacent to at least one\r\npreviously selected cell. Two cells are considered orthogonally adjacent\r\nif they share an edge. The game continues until all cells have been\r\nselected.Your goal is to let the sum of numbers in the cells selected by\r\nyou be less than the sum of numbers in the cells selected by the\r\ninteractor.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0void solve(){\tint N, M;\tcin >> N >> M;\tvector<vector<int> > grid(N, vector<int>(M));\tvector<vector<int> > unsafe(N, vector<int>(M, 0));\tif(N % 2 == 0 || M % 2 == 0){\t\tvector<pair<int,int> > good;\t\tfor(int i = 0; i < N; i++){\t\t\tfor(int j = 0; j < M; j++){\t\t\t\tif((i == 0 && j == 1) || (j == M-1 && i == N-3) || (i == N-1 && j == M-2) || (j == 0 && i == 2)){\t\t\t\t\tgood.push_back({i, j});\t\t\t\t}\t\t\t}\t\t}\t\tif(N == 4 && M == 5){\t\t\tgood = {{0, 1}, {2, 0}, {3, 2}, {2, 4}};\t\t} else if(N == 5 && M == 4){\t\t\tgood = {{1, 0}, {0, 2}, {2, 3}, {4, 2}};\t\t}\t\tint cur = 1;\t\tfor(auto [x, y] : good){\t\t\tgrid[x][y] = cur;\t\t\tcur++;\t\t}\t\tint z = N*M + 1 - good.size() * 3;\t\tfor(auto [x, y] : good){\t\t\tvector<pair<int,int> > neighbors;\t\t\tfor(int dx = -1; dx <= 1; dx++){\t\t\t\tfor(int dy = -1; dy <= 1; dy++){\t\t\t\t\tif(abs(dx) + abs(dy) <= 1 && abs(dx) + abs(dy) > 0){\t\t\t\t\t\tneighbors.push_back({x + dx, y + dy});\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tunsafe[x][y] = -1;\t\t\tfor(auto [c, d] : neighbors){\t\t\t\tif(c >= 0 && c < N && d >= 0 && d < M && grid[c][d] == 0){\t\t\t\t\tgrid[c][d] = z;\t\t\t\t\tz++;\t\t\t\t\tunsafe[c][d] = 1;\t\t\t\t}\t\t\t}\t\t}\t\tfor(int i = 0; i < N; i++){\t\t\tfor(int j = 0; j < M; j++){\t\t\t\tif(grid[i][j] == 0){\t\t\t\t\tgrid[i][j] = cur;\t\t\t\t\tcur++;\t\t\t\t}\t\t\t}\t\t}\t} else {\t\tint cur = 1;\t\tfor(int i = 0; i < N; i++){\t\t\tfor(int j = 0; j < M; j++){\t\t\t\tgrid[i][j] = cur;\t\t\t\tcur++;\t\t\t}\t\t}\t}\tfor(int i = 0; i < N; i++){\t\tfor(int j = 0; j < M; j++){\t\t\tcout << grid[i][j] << \" \";\t\t}\t\tcout << \"\\n\";\t}\tcout << flush;\tauto get_neighbors = [&](int x, int y){\t\tvector<pair<int,int> > neighbors;\t\tfor(int dx = -1; dx <= 1; dx++){\t\t\tfor(int dy = -1; dy <= 1; dy++){\t\t\t\tif(abs(dx) + abs(dy) <= 1 && abs(dx) + abs(dy) > 0){\t\t\t\t\tif(x + dx >= 0 && x + dx < N && y + dy >= 0 && y + dy < M){\t\t\t\t\t\tneighbors.push_back({x + dx, y + dy});\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\treturn neighbors;\t};\tvector<vector<int> > played(N, vector<int>(M, 0));\tvector<vector<int> > allowed(N, vector<int>(M, 0));\tfor(int i = 0; i < N*M; i++){\t\tint x, y;\t\tif(i % 2 == 0){\t\t\tcin >> x >> y;\t\t\tx--; y--;\t\t} else {\t\t\tpair<int,int> best = {-1, -1};\t\t\tfor(int a = 0; a < N; a++){\t\t\t\tfor(int b = 0; b < M; b++){\t\t\t\t\tif(allowed[a][b] == 1 && played[a][b] == 0){\t\t\t\t\t\tint score = grid[a][b];\t\t\t\t\t\tif(unsafe[a][b] == 1) continue;\t\t\t\t\t\tif(best == make_pair(-1, -1) || score < grid[best.first][best.second]){\t\t\t\t\t\t\tbest = {a, b};\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\ttie(x, y) = best;\t\t\tcout << (x + 1) << \" \" << (y + 1) << \"\\n\";\t\t\tcout << flush;\t\t}\t\tplayed[x][y] = 1;\t\tvector<pair<int,int> > neighbors = get_neighbors(x, y);\t\tfor(auto [c, d] : neighbors){\t\t\tallowed[c][d] = 1;\t\t}\t\tif(unsafe[x][y] == -1){\t\t\tunsafe[x][y] = 0;\t\t\tfor(auto [c, d] : neighbors){\t\t\t\tunsafe[c][d] = 0;\t\t\t}\t\t}\t}\t}\u00a0int main(){\tios_base::sync_with_stdio(false), cin.tie(nullptr);\tint T;\tcin >> T;\twhile(T--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "graph matchings",
        "greedy",
        "interactive"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Grid Game.json"
}