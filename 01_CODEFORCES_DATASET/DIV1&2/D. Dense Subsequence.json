{"link": "https://codeforces.com//contest/724/problem/D", "problemId": "74853", "problem_idx": "D", "shortId": "724D", "contest_number": "724", "problem_submissions": {"G": [21292263, 21289389, 21296363, 21288425, 21294631, 21287775, 21293574, 21292770, 21291944, 21288934, 21292172, 21288247, 21292559, 21295809, 21290880, 21290578, 21290415, 21293943], "E": [21288925, 21292133, 21297352, 21291033, 21288200, 23659645, 21290576, 21290313, 21292937, 21296159, 21294663, 21290237, 21296769, 21292864, 21297544, 23608572], "F": [21288190, 21295097, 21291428, 21408768, 21292926, 21298468, 145553208, 21294689], "D": [21285401, 21285608, 21286235, 21283645, 21284412, 21288117, 21285995, 21287478, 21286772, 21286376, 21289028, 21285265, 21288845, 21286726, 21290761, 21285673, 21284100, 21286467, 21288075], "B": [21284134, 21280714, 21282752, 21281462, 21280744, 21282751, 21280902, 21282004, 21281773, 21281431, 21281779, 21284722, 21286664, 21280972, 21281353, 21282957, 21282648], "C": [21283255, 21284495, 21288232, 21285743, 21285969, 21285870, 21284787, 21286083, 21285861, 21284725, 21286899, 21284034, 21287013, 21285582, 21297034, 21283106, 21286310, 21285066, 21286458], "A": [21280305, 21279735, 21280413, 21279914, 21280000, 21280810, 21279870, 21279953, 21279966, 21279817, 21280008, 21279884, 21281495, 21279783, 21281061, 21279908, 21279971, 21280674, 21280506]}, "name": "D. Dense Subsequence", "statement": "You are given a string , consisting of lowercase English letters, and\r\nthe integer .One should choose some symbols from the given string so\r\nthat any contiguous subsegment of length has at least one selected\r\nsymbol. Note that here we choose positions of symbols, not the symbols\r\nthemselves.Then one uses the chosen symbols to form . All symbols from\r\nthe chosen position should be used, but we are allowed to rearrange them\r\nin any order.Formally, we choose a subsequence of indices . The selected\r\nsequence must meet the following condition: for every such that , there\r\nmust be at least one selected index that belongs to the segment , i.e.\r\nthere should exist a from to , such that .Then we take any permutation\r\nof the selected indices and form a new string .Find the\r\nlexicographically smallest string, that can be obtained using this\r\nprocedure.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nchar s[N];\nint m,v[30],n;\n\nint gao(int c) {\n\tint pre=-1,cand=-1,ret=0;\n\trep(i,0,n) {\n\t\tif (s[i]<'a'+c) pre=i,cand=i;\n\t\tif (s[i]=='a'+c) cand=i;\n\t\tif (i-pre==m) {\n\t\t\tif (cand>pre) {\n\t\t\t\tret++; pre=cand;\n\t\t\t} else return -1;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d\",&m);\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\trep(i,0,n) v[s[i]-'a']++;\n\trep(i,0,26) {\n\t\tint c=gao(i);\n\t\tif (c!=-1) {\n\t\t\trep(j,0,i) rep(k,0,v[j]) putchar('a'+j);\n\t\t\trep(k,0,c) putchar('a'+i);\n\t\t\tputs(\"\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(0);\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy", "strings"], "dificulty": "1900", "interactive": false}