{
    "link": "https://codeforces.com//contest/724/problem/D",
    "problemId": "74853",
    "problem_idx": "D",
    "shortId": "724D",
    "contest_number": "724",
    "problem_submissions": {
        "G": [
            21292263,
            21289389,
            21296363,
            21288425,
            21294631,
            21287775,
            21293574,
            21292770,
            21291944,
            21288934,
            21292172,
            21288247,
            21292559,
            21295809,
            21290880,
            21290578,
            21290415,
            21293943
        ],
        "E": [
            21288925,
            21292133,
            21297352,
            21291033,
            21288200,
            23659645,
            21290576,
            21290313,
            21292937,
            21296159,
            21294663,
            21290237,
            21296769,
            21292864,
            21297544,
            23608572
        ],
        "F": [
            21288190,
            21295097,
            21291428,
            21408768,
            21292926,
            21298468,
            145553208,
            21294689
        ],
        "D": [
            21285401,
            21285608,
            21286235,
            21283645,
            21284412,
            21288117,
            21285995,
            21287478,
            21286772,
            21286376,
            21289028,
            21285265,
            21288845,
            21286726,
            21290761,
            21285673,
            21284100,
            21286467,
            21288075
        ],
        "B": [
            21284134,
            21280714,
            21282752,
            21281462,
            21280744,
            21282751,
            21280902,
            21282004,
            21281773,
            21281431,
            21281779,
            21284722,
            21286664,
            21280972,
            21281353,
            21282957,
            21282648
        ],
        "C": [
            21283255,
            21284495,
            21288232,
            21285743,
            21285969,
            21285870,
            21284787,
            21286083,
            21285861,
            21284725,
            21286899,
            21284034,
            21287013,
            21285582,
            21297034,
            21283106,
            21286310,
            21285066,
            21286458
        ],
        "A": [
            21280305,
            21279735,
            21280413,
            21279914,
            21280000,
            21280810,
            21279870,
            21279953,
            21279966,
            21279817,
            21280008,
            21279884,
            21281495,
            21279783,
            21281061,
            21279908,
            21279971,
            21280674,
            21280506
        ]
    },
    "name": "D. Dense Subsequence",
    "statement": "You are given a string , consisting of lowercase English letters, and\r\nthe integer .One should choose some symbols from the given string so\r\nthat any contiguous subsegment of length has at least one selected\r\nsymbol. Note that here we choose positions of symbols, not the symbols\r\nthemselves.Then one uses the chosen symbols to form . All symbols from\r\nthe chosen position should be used, but we are allowed to rearrange them\r\nin any order.Formally, we choose a subsequence of indices . The selected\r\nsequence must meet the following condition: for every such that , there\r\nmust be at least one selected index that belongs to the segment , i.e.\r\nthere should exist a from to , such that .Then we take any permutation\r\nof the selected indices and form a new string .Find the\r\nlexicographically smallest string, that can be obtained using this\r\nprocedure.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nchar s[N];\nint m,v[30],n;\n\nint gao(int c) {\n\tint pre=-1,cand=-1,ret=0;\n\trep(i,0,n) {\n\t\tif (s[i]<'a'+c) pre=i,cand=i;\n\t\tif (s[i]=='a'+c) cand=i;\n\t\tif (i-pre==m) {\n\t\t\tif (cand>pre) {\n\t\t\t\tret++; pre=cand;\n\t\t\t} else return -1;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d\",&m);\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\trep(i,0,n) v[s[i]-'a']++;\n\trep(i,0,26) {\n\t\tint c=gao(i);\n\t\tif (c!=-1) {\n\t\t\trep(j,0,i) rep(k,0,v[j]) putchar('a'+j);\n\t\t\trep(k,0,c) putchar('a'+i);\n\t\t\tputs(\"\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tassert(0);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Dense Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/47644",
    "editorial": "It is not hard to see that if we choose some subset of the letters then\r\nto achieve lexicographically smallest string you must first write all of\r\nthe letters \u00e2\u0080\u009d, then all of the letters \u00e2\u0080\u0099b\u00e2\u0080\u0099 and so on.Let\u00e2\u0080\u0099s assume that\r\nthe string in the answer consists only of the letters \u00e2\u0080\u009d. Then it should\r\nbe as small of them as possible to get lexicographically smallest\r\nstring. We can check whether it is enough to take only the letters \u00e2\u0080\u009d to\r\nmeet the requirement on the density of the indices (in each subsegment\r\nof length it has to be at least one letter \u00e2\u0080\u009d). If this is true, we can\r\nfind the minimum number of letters \u00e2\u0080\u009d, which will satisfy the density\r\nrequirement, using the greedy algorithm (every time we will take the\r\nrightmost letter \u00e2\u0080\u009d, which is separated from the previous one by no more\r\nthan positions). If this is not true, then the answer must contain some\r\nother letters except for \u00e2\u0080\u009d. This means that we need to take as much \u00e2\u0080\u009d\r\nletters as possible. So we can take all of them, because adding any\r\nadditional letter will not affect the density requirement.Then do the\r\nsame with the letter \u00e2\u0080\u009d, bearing in mind that all of the letters \u00e2\u0080\u009d is\r\nalready taken. If the letters \u00e2\u0080\u009d is not enough, then take all of the\r\nletters \u00e2\u0080\u009d, all of the letters \u00e2\u0080\u009d and proceed to the next letter, and so\r\non.\r\n"
}