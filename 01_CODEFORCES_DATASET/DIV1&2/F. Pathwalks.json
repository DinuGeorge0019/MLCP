{
    "link": "https://codeforces.com//contest/960/problem/F",
    "problemId": "172423",
    "problem_idx": "F",
    "shortId": "960F",
    "contest_number": "960",
    "problem_submissions": {
        "H": [
            37076939,
            37076112,
            37074469,
            37077049
        ],
        "G": [
            37071263,
            57709834,
            57709811,
            37070456,
            37070524,
            37070914,
            37073469,
            37074485,
            37075164,
            37076234,
            37075338,
            37079339,
            37075175,
            37074093,
            37077545
        ],
        "E": [
            37066041,
            37079944,
            37063783,
            37066048,
            37064488,
            37061915,
            37065298,
            37064523,
            37070733,
            37072090,
            37076676,
            37064464,
            37069828,
            37067545,
            37067744,
            37066196,
            37072966
        ],
        "D": [
            37064105,
            37063850,
            37067264,
            37066015,
            37064335,
            37059946,
            37066190,
            37067902,
            37062007,
            37066676,
            37068757,
            37066067,
            37061947,
            37066618,
            37070708,
            37069032,
            37065961
        ],
        "F": [
            37061228,
            37060911,
            37058043,
            37061179,
            37057703,
            37061709,
            37063433,
            37060626,
            37066935,
            37063565,
            37062126,
            37065836,
            37069620,
            37066690,
            37061224,
            37061530,
            37061194,
            37061393,
            37069132
        ],
        "C": [
            37059020,
            37058186,
            37073747,
            37057785,
            37060772,
            37057801,
            37056055,
            37058782,
            37058698,
            37060994,
            37061675,
            37062340,
            37067775,
            37058977,
            37058993,
            37058400,
            37058570,
            37060826
        ],
        "B": [
            37057197,
            37056331,
            37056347,
            37056532,
            37059595,
            37056085,
            37057341,
            37056165,
            37056262,
            37056554,
            37057292,
            37058927,
            37056440,
            37056660,
            37057273,
            37056784,
            37056702,
            37058078
        ],
        "A": [
            37055508,
            37055332,
            37055423,
            37055343,
            37058650,
            37055377,
            37058231,
            37055321,
            37055350,
            37055370,
            37055431,
            37055718,
            37055347,
            37055410,
            37055539,
            37055383,
            37055552
        ]
    },
    "name": "F. Pathwalks",
    "statement": "You are given a directed graph with nodes and edges, with all edges\r\nhaving a certain weight. There might be multiple edges and self loops,\r\nand the graph can also be disconnected. You need to choose a path\r\n(possibly passing through same vertices multiple times) in the graph\r\nsuch that the weights of the edges are in strictly increasing order, and\r\nthese edges come in the order of input. Among all such paths, you need\r\nto find the the path that has the maximum possible number of edges, and\r\nreport this value.Please note that the edges picked don\u2019t have to be\r\nconsecutive in the input.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint n,m,u,v,w;\nmap<int,int> c[N];\nint query(int u,int w) {\n\tint s=0;\n\tfor (;w;w-=w&-w) {\n\t\tauto it=c[u].find(w);\n\t\tif (it!=c[u].end()) s=max(s,it->se);\n\t}\n\treturn s;\n}\nvoid modify(int u,int w,int s) {\n\tfor (;w<=100001;w+=w&-w) c[u][w]=max(c[u][w],s);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tw++;\n\t\tmodify(v,w,query(u,w-1)+1);\n\t}\n\tint ret=0;\n\trep(i,1,n+1) ret=max(ret,query(i,100001));\n\tprintf(\"%d\\n\",ret);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Pathwalks.json",
    "editorial_link": "https://codeforces.com//blog/entry/58802",
    "editorial": "The problem is similar to Longest Increasing Subsequence, done on a\r\ngraph instead of an array. The solution for this problem can be obtained\r\nin the following ways:- Maintain a map for every node, consisting of\r\nweights and the corresponding max no of edges you can achieve for some\r\npath ending at that node at a given point. Now when you process the next\r\nedge, suppose , you query max no of edges having weight in map of node .\r\nLet\u00e2\u0080\u0099s call this . Now, you try to insert for weight in map of node .\r\nMaintain it in such a way that no of edges for higher weights in a\r\nparticular node is always larger than that for smaller weights. You can\r\ndo this with (kind of) the conventional sliding window idea, by removing\r\nhigher weight edges with smaller values than the current inserted answer\r\nin the map, or not inserting the current value at all because an\r\nequivalent or better answer exists for weights for the node . Finally\r\nthe max of all such you encounter during processing the graph is the\r\nmaximum number of edges in any given path. You can also solve this\r\nproblem with the help of sparse/dynamic/persistent segment tree on every\r\nnode of the graph. Suppose you are at the edge at some point in your\r\nprocessing, and the query was . Do a Range Max Query on segtree at node\r\n, uptil value . Suppose this answer was . Now update segtree at location\r\nwith value of . Store the max of all such , and this is the length of\r\nlongest path in your graph.\r\n"
}