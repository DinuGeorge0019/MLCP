{"link": "https://codeforces.com//contest/960/problem/F", "problemId": "172423", "problem_idx": "F", "shortId": "960F", "contest_number": "960", "problem_submissions": {"H": [37076939, 37076112, 37074469, 37077049], "G": [37071263, 57709834, 57709811, 37070456, 37070524, 37070914, 37073469, 37074485, 37075164, 37076234, 37075338, 37079339, 37075175, 37074093, 37077545], "E": [37066041, 37079944, 37063783, 37066048, 37064488, 37061915, 37065298, 37064523, 37070733, 37072090, 37076676, 37064464, 37069828, 37067545, 37067744, 37066196, 37072966], "D": [37064105, 37063850, 37067264, 37066015, 37064335, 37059946, 37066190, 37067902, 37062007, 37066676, 37068757, 37066067, 37061947, 37066618, 37070708, 37069032, 37065961], "F": [37061228, 37060911, 37058043, 37061179, 37057703, 37061709, 37063433, 37060626, 37066935, 37063565, 37062126, 37065836, 37069620, 37066690, 37061224, 37061530, 37061194, 37061393, 37069132], "C": [37059020, 37058186, 37073747, 37057785, 37060772, 37057801, 37056055, 37058782, 37058698, 37060994, 37061675, 37062340, 37067775, 37058977, 37058993, 37058400, 37058570, 37060826], "B": [37057197, 37056331, 37056347, 37056532, 37059595, 37056085, 37057341, 37056165, 37056262, 37056554, 37057292, 37058927, 37056440, 37056660, 37057273, 37056784, 37056702, 37058078], "A": [37055508, 37055332, 37055423, 37055343, 37058650, 37055377, 37058231, 37055321, 37055350, 37055370, 37055431, 37055718, 37055347, 37055410, 37055539, 37055383, 37055552]}, "name": "F. Pathwalks", "statement": "You are given a directed graph with nodes and edges, with all edges\r\nhaving a certain weight. There might be multiple edges and self loops,\r\nand the graph can also be disconnected. You need to choose a path\r\n(possibly passing through same vertices multiple times) in the graph\r\nsuch that the weights of the edges are in strictly increasing order, and\r\nthese edges come in the order of input. Among all such paths, you need\r\nto find the the path that has the maximum possible number of edges, and\r\nreport this value.Please note that the edges picked don\u2019t have to be\r\nconsecutive in the input.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint n,m,u,v,w;\nmap<int,int> c[N];\nint query(int u,int w) {\n\tint s=0;\n\tfor (;w;w-=w&-w) {\n\t\tauto it=c[u].find(w);\n\t\tif (it!=c[u].end()) s=max(s,it->se);\n\t}\n\treturn s;\n}\nvoid modify(int u,int w,int s) {\n\tfor (;w<=100001;w+=w&-w) c[u][w]=max(c[u][w],s);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tw++;\n\t\tmodify(v,w,query(u,w-1)+1);\n\t}\n\tint ret=0;\n\trep(i,1,n+1) ret=max(ret,query(i,100001));\n\tprintf(\"%d\\n\",ret);\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "graphs"], "dificulty": "2100", "interactive": false}