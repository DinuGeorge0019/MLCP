{
    "link": "https://codeforces.com//contest/2039/problem/D",
    "problemId": "3044244",
    "problem_idx": "D",
    "shortId": "2039D",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "For problems where we need to construct something under some conditions,\r\nthen a good idea is to first see the nature of the sequences that\r\nsatisfy the conditions. And to find the properties of such sequences we\r\ncan try to find some necessary conditions that must have to be met for\r\nthe sequence to satisfy the conditions. The given condition is that all\r\n. As the given operation is gcd on indices and values, itâs hard to\r\ndirectly find the properties of the sequence.But what happens when\r\ndivides ? Then . So the condition becomes which translates to can not\r\ndivide because otherwise .So we have found a necessary condition: for\r\nany pair where divides , can not divide . Hmm, but is the condition\r\nsufficient? One way to check the sufficiency is to find a contradiction.\r\nImagine two indices and where does not divide but the condition is\r\nviolated: .Then is a divisor of both and and as divides both and , so\r\nfor pair we have and because divides . So for this pair the condition is\r\nviolated!So if the condition is violated for some pair then it is\r\nviolated for the pair and as well where .So if there is no pair where\r\ndivides and the condition is violated, then all the pairs also satisfy\r\nthe condition. This proves the sufficiency of the condition. So we have\r\nfound a necessary and sufficient condition. Now we need to construct the\r\nlexicographically largest sequence that satisfies the condition.Consider\r\na . Such that divides , divides , ..., divides .Then we know that we\r\nhave to put distinct values for all the indices in the otherwise one\r\nnumber will be divisible by another which will violate the condition.And\r\nas we are aiming for the lexicographically largest sequence, it makes\r\nsense to put the values in decreasing order in a i.e. . This way we\r\ndonât have to care about the divisibility condition, as the numbers are\r\nin decreasing order.Now, we definitely will try to put the largest\r\nnumber possible for each index. So what is the largest number that we\r\ncan put for the index ?Consider a directed graph where there is an edge\r\nfrom to if divides . Then the question is what is the length of the\r\nlongest path in this graph ending at .You can find it using a simple DP\r\non this directed acyclic graph in time.But if you think about it, the\r\nanswer is actually simple. Let the number of prime factors of counted\r\nwith multiplicity. Then the answer is . For example, if , then one of\r\nthe longest chains ending at is which has length .We can precalculate\r\nthe values for all in time using sieve.So at index we will put the ()-th\r\nlargest number from the set . And the largest value of for is for the\r\nchain .So if , then we canât construct the sequence and the answer is .\r\nOtherwise set for all .Also, unless you have noticed already, the actual\r\nnumbers donât matter! As we are trying to construct the\r\nlexicographically largest sequence, itâs always better to take larger\r\nvalues first. Let be the -th smallest number in the set . So, initially\r\nset . Then we canât use for any other index as it will violate the\r\ncondition. Then set (because we canât use ). Then we canât use for any\r\nother index where is divisible by as it will violate the condition. Then\r\nset (because we canât use ). Then we canât use for any other index where\r\nis divisible by as it will violate the condition. Now set (because we\r\ncanât use or ). Then we canât use for any other index where is divisible\r\nby as it will violate the condition. Then for we can actually use as is\r\nnot divisible by or so the only constraint is that . ... Notice that\r\nthis is a sieve-like process where we are using the maximum number that\r\nwe can use for the current index and then we are remembering that in the\r\nmultiples of the current index, the current number canât be used. We can\r\nuse sets to simulate the process.So this process will always construct a\r\nvalid lexicographically largest sequence. If it is not possible to\r\nconstruct the sequence, then the answer is .Also, if you notice the\r\nconstruction process carefully, the actual numbers donât matter!\r\n",
    "name": "D. Shohag Loves GCD",
    "statement": "Shohag has an integer n and a set S of m unique integers. Help him find\r\nthe lexicographically largest^{\r\ntext{ }} integer array a_1, a_2,\r\nldots, a_n such that a_i\r\nin S for each 1\r\nle i\r\nle n and a_{\r\noperatorname{gcd}(i, j)}\r\nneq\r\noperatorname{gcd}(a_i, a_j)^{\r\ntext{ }} is satisfied over all pairs 1\r\nle i\r\nlt j\r\nle n, or state that no such array exists.^{\r\ntext{ }}An array a is lexicographically larger than an array b of the\r\nsame length if a\r\nne b, and in the first position where a and b differ, the array a has a\r\nlarger element than the corresponding element in b.^{\r\ntext{ }}\r\ngcd(x, y) denotes the greatest common divisor (GCD) of integers x and y.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;int n, m;int len[N];int a[N];int qwq[N];void Main() {\tcin >> n >> m;\tL(i, 1, m) {\t\tcin >> a[i];\t}\tsort(a + 1, a + m + 1);\treverse(a + 1, a + m + 1);\tL(i, 1, n) {\t\tif(qwq[i] > m) {\t\t\tcout << \"-1\\n\";\t\t\treturn;\t\t}\t}\tL(i, 1, n) {\t\tcout << a[qwq[i]] << ' ';\t}\tcout << '\\n';}int pr[N];void xxs(int n) {\tL(i, 2, n) pr[i] = 1;\tL(i, 1, n) qwq[i] = 1;\tL(i, 2, n) if(pr[i]) {\t\tL(j, 2, n / i) pr[i * j] = 0;\t\tfor(ll pw = i; pw <= n; pw *= i)\t\t\tL(j, 1, n / pw)\t\t\t\t++qwq[pw * j];\t}}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\txxs(1e6);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Shohag Loves GCD.json",
    "hint": []
}