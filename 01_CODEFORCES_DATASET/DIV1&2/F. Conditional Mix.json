{
    "link": "https://codeforces.com//contest/1740/problem/F",
    "problemId": "1611415",
    "problem_idx": "F",
    "shortId": "1740F",
    "contest_number": "1740",
    "problem_submissions": {
        "H": [
            178379430,
            178389839,
            178370970,
            178389787,
            178394159,
            178405718,
            178393380,
            178400994,
            178473578
        ],
        "G": [
            178363447,
            178373152,
            178390136,
            178380782,
            178380133,
            178366412,
            178381208,
            178372252,
            178364309,
            178377085,
            178379805,
            178389960,
            178394186,
            178390668,
            178429073,
            178399239,
            178398964,
            178398319,
            178393777,
            178389532,
            178457114,
            178457090,
            178457069,
            178456881,
            178456598
        ],
        "F": [
            178342509,
            178355726,
            178353094,
            178359313,
            178375325,
            178347566,
            178343206,
            178355344,
            178419766,
            178363409,
            178364030,
            178360259,
            178371042,
            178378751,
            178405026,
            178404845,
            178404014,
            178403791,
            178403569,
            178376955,
            178368121,
            178355891,
            178355560,
            178363171,
            178364934
        ],
        "E": [
            178337370,
            178346224,
            178348715,
            178344194,
            178352039,
            178338198,
            178335731,
            178340043,
            178343562,
            178350554,
            178352735,
            178349059,
            178343925,
            178345775,
            178364103,
            178352981,
            178344981,
            178359372,
            178346165,
            178350475
        ],
        "D": [
            178334153,
            178339631,
            178345824,
            178338369,
            178344365,
            178352777,
            178346625,
            178336331,
            178336614,
            178338914,
            178339308,
            178344306,
            178335725,
            178354316,
            178351979,
            178370227,
            178339993,
            178338550,
            178340955,
            178340858
        ],
        "C": [
            178329483,
            178334722,
            178336471,
            178331649,
            178333101,
            178332328,
            178330724,
            178331197,
            178330550,
            178331983,
            178331086,
            178337583,
            178330090,
            178335594,
            178335112,
            178340402,
            178335550,
            178333891,
            178336207,
            178332182
        ],
        "B": [
            178326239,
            178328080,
            178333593,
            178327287,
            178329054,
            178327314,
            178327001,
            178329448,
            178327787,
            178327568,
            178327277,
            178328845,
            178326455,
            178328799,
            178328762,
            178333879,
            178327499,
            178329269,
            178328122,
            178330549
        ],
        "A": [
            178322883,
            178322996,
            178323296,
            178323217,
            178323002,
            178322816,
            178327673,
            178322982,
            178323305,
            178322810,
            178323224,
            178323080,
            178322764,
            178323327,
            178324186,
            178325267,
            178322814,
            178324090,
            178323226,
            178322754
        ],
        "I": [
            179538712
        ]
    },
    "name": "F. Conditional Mix",
    "statement": "Pak Chanek is given an array a of n integers. For each i (1\r\nleq i\r\nleq n), Pak Chanek will write the one-element set\r\n{a_i\r\n} on a whiteboard.After that, in one operation, Pak Chanek may do the\r\nfollowing: Choose two different sets S and T on the whiteboard such that\r\nS\r\ncap T =\r\nvarnothing (S and T do not have any common elements). Erase S and T from\r\nthe whiteboard and write S\r\ncup T (the union of S and T) onto the whiteboard. After performing zero\r\nor more operations, Pak Chanek will construct a multiset M containing\r\nthe sizes of all sets written on the whiteboard. In other words, each\r\nelement in M corresponds to the size of a set after the operations.How\r\nmany distinct^\r\ndagger multisets M can be created by this process? Since the answer may\r\nbe large, output it modulo 998\r\n,244\r\n,353.^\r\ndagger Multisets B and C are different if and only if there exists a\r\nvalue k such that the number of elements with value k in B is different\r\nthan the number of elements with value k in C.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        a[x - 1]++;\n    }\n    \n    std::vector<int> c(n + 1);\n    for (int i = 0; i < n; i++) {\n        c[a[i]]++;\n    }\n    \n    std::vector<int> lim(n + 1);\n    int v = 0, res = n;\n    for (int i = 0; i <= n; i++) {\n        v += i * c[i];\n        res -= c[i];\n        lim[i] = v + res * i;\n    }\n    \n    std::vector dp(n + 1, std::vector<Z>(n + 1));\n    dp[0][0] = 1;\n    for (int x = n; x; x--) {\n        for (int i = 0; i + x <= n; i++) {\n            for (int j = 0; j * x <= i; j++) {\n                if (i + x <= lim[j + 1]) {\n                    dp[i + x][j + 1] += dp[i][j];\n                }\n            }\n        }\n    }\n    \n    auto ans = std::accumulate(dp[n].begin(), dp[n].end(), Z(0));\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Conditional Mix.json",
    "editorial_link": "https://codeforces.com//blog/entry/108567",
    "editorial": "Let denote the number of occurrences of element in array .Claim: A\r\nmultiset of size , where is good if and only if and for every .The proof\r\nof that claim has been discussed in the comment section here.We proceed\r\nwith formulating a dynamic programming solution. Let denote that we have\r\npicked a prefix such that and . Our transition is going from to for all\r\n, this can be easily handled using prefix sums. However, we still have\r\nstates.We can cut down the number of states by noting that . That is,\r\nfor each value of , there are only values of . Since , the number of\r\nstates is bounded by .Time complexity:\r\n"
}