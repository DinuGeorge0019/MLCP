{"link": "https://codeforces.com//contest/1556/problem/E", "problemId": "1093326", "problem_idx": "E", "shortId": "1556E", "contest_number": "1556", "problem_submissions": {"H": [127528421, 127373567, 127527040, 127375388, 127394013, 127386870, 127381921, 127387937, 127394050, 127389040, 127428317, 127427887, 127554513, 127394843, 127394720, 127394710, 127394566, 127388015, 127563493, 127391319, 127413892, 127413850, 127391995, 190714866, 127387774], "G": [127390700, 127387983, 127394350, 127373122, 127379900, 127386180, 127417272, 127382224, 127382638, 127388751, 127407653, 127407647, 127407608, 127407584, 127407566, 127386088, 127384803, 127387460, 127387640], "F": [127355517, 127358676, 127354501, 127360575, 127359102, 127358993, 127363463, 127363603, 127365708, 127364449, 127360085, 127362064, 127372929, 127362249, 127375013, 127359868, 127372641, 127367693, 127374334, 127375402], "E": [127351296, 127352912, 127351562, 127356521, 127354559, 127354907, 127360891, 127356050, 127360001, 127359317, 127356239, 127358250, 127364802, 127356923, 127358834, 127355363, 127366513, 127364481, 127365791, 127370671], "D": [127346830, 127349657, 127348248, 127352056, 127350226, 127351918, 127354957, 127351335, 127356577, 127354677, 127353022, 127352794, 127358047, 127352764, 127356062, 127349435, 127357493, 127359353, 127355308, 127356263], "C": [127342221, 127343475, 127345171, 127346052, 127344444, 127347970, 127343862, 127341055, 127350101, 127347701, 127344590, 127346041, 127349062, 127346563, 127349912, 127346975, 127349244, 127343756, 127348599, 127364090], "A": [127338005, 127334498, 127334512, 127336074, 127334497, 127335667, 127334534, 127334495, 127334713, 127336416, 127334993, 127336217, 127334858, 127334721, 127334712, 127334514, 127335446, 127334480, 127334660, 127334680], "B": [127336233, 127336922, 127337115, 127340977, 127338217, 127339999, 127337368, 127336161, 127338774, 127342382, 127338043, 127341949, 127339720, 127340565, 127339178, 127338941, 127341395, 127336543, 127339094, 127344978]}, "name": "E. Equilibrium", "statement": "William has two arrays a and b, each consisting of n items.For some\r\nsegments l..r of these arrays William wants to know if it is possible to\r\nequalize the values of items in these segments using a balancing\r\noperation. Formally, the values are equalized if for each i from l to r\r\nholds a_i = b_i.To perform a balancing operation an even number of\r\nindices must be selected, such that l\r\nle pos_1 < pos_2 <\r\ndots < pos_k\r\nle r. Next the items of at positions pos_1, pos_3, pos_5,\r\ndots get incremented by one and the items of at positions pos_2, pos_4,\r\npos_6,\r\ndots get incremented by one.William wants to find out if it is possible\r\nto equalize the values of elements in two arrays for each segment using\r\nsome number of balancing operations, and what is the minimal number of\r\noperations required for that. Note that for each segment the operations\r\nare performed independently.\r\n", "solutions": ["//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 100005;\nll mx[maxn][20];\nll mn[maxn][20];\nint mb[maxn];\nll qmx(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return max(mx[l][j], mx[r - (1 << j) + 1][j]);\n}\nll qmn(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return min(mn[l][j], mn[r - (1 << j) + 1][j]);\n}\nint a[maxn];\nint b[maxn];\nll s[maxn];\nint main() {\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &b[i]);\n        a[i] -= b[i];\n        s[i] = s[i - 1] + a[i];\n    } \n    for (int i = 0; i < maxn; i++)\n        for (int j = 0; j < 20; j++)\n            if ((1 << j) <= i) mb[i] = j;\n    \n    for (int i = 0; i < 20; i++)\n        for (int j = 1; j <= n - (1 << i) + 1; j++) {\n            if (i == 0) mx[j][i] = s[j];\n            else {\n                mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    \n    for (int i = 0; i < 20; i++)\n        for (int j = 1; j <= n - (1 << i) + 1; j++) {\n            if (i == 0) mn[j][i] = s[j];\n            else {\n                mn[j][i] = min(mn[j][i - 1], mn[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    for (int i = 1; i <= q; i++) {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        ll ans = -(qmn(l, r) - s[l - 1]);\n        if (s[r] != s[l - 1]) ans = -1;\n        if (qmx(l, r) > s[l - 1]) ans = -1;\n        printf(\"%lld\\n\", ans);\n    }\n    return (0-0); //<3\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "greedy"], "dificulty": "2200", "interactive": false}