{
    "link": "https://codeforces.com//contest/1556/problem/E",
    "problemId": "1093326",
    "problem_idx": "E",
    "shortId": "1556E",
    "contest_number": "1556",
    "problem_submissions": {
        "H": [
            127528421,
            127373567,
            127527040,
            127375388,
            127394013,
            127386870,
            127381921,
            127387937,
            127394050,
            127389040,
            127428317,
            127427887,
            127554513,
            127394843,
            127394720,
            127394710,
            127394566,
            127388015,
            127563493,
            127391319,
            127413892,
            127413850,
            127391995,
            190714866,
            127387774
        ],
        "G": [
            127390700,
            127387983,
            127394350,
            127373122,
            127379900,
            127386180,
            127417272,
            127382224,
            127382638,
            127388751,
            127407653,
            127407647,
            127407608,
            127407584,
            127407566,
            127386088,
            127384803,
            127387460,
            127387640
        ],
        "F": [
            127355517,
            127358676,
            127354501,
            127360575,
            127359102,
            127358993,
            127363463,
            127363603,
            127365708,
            127364449,
            127360085,
            127362064,
            127372929,
            127362249,
            127375013,
            127359868,
            127372641,
            127367693,
            127374334,
            127375402
        ],
        "E": [
            127351296,
            127352912,
            127351562,
            127356521,
            127354559,
            127354907,
            127360891,
            127356050,
            127360001,
            127359317,
            127356239,
            127358250,
            127364802,
            127356923,
            127358834,
            127355363,
            127366513,
            127364481,
            127365791,
            127370671
        ],
        "D": [
            127346830,
            127349657,
            127348248,
            127352056,
            127350226,
            127351918,
            127354957,
            127351335,
            127356577,
            127354677,
            127353022,
            127352794,
            127358047,
            127352764,
            127356062,
            127349435,
            127357493,
            127359353,
            127355308,
            127356263
        ],
        "C": [
            127342221,
            127343475,
            127345171,
            127346052,
            127344444,
            127347970,
            127343862,
            127341055,
            127350101,
            127347701,
            127344590,
            127346041,
            127349062,
            127346563,
            127349912,
            127346975,
            127349244,
            127343756,
            127348599,
            127364090
        ],
        "A": [
            127338005,
            127334498,
            127334512,
            127336074,
            127334497,
            127335667,
            127334534,
            127334495,
            127334713,
            127336416,
            127334993,
            127336217,
            127334858,
            127334721,
            127334712,
            127334514,
            127335446,
            127334480,
            127334660,
            127334680
        ],
        "B": [
            127336233,
            127336922,
            127337115,
            127340977,
            127338217,
            127339999,
            127337368,
            127336161,
            127338774,
            127342382,
            127338043,
            127341949,
            127339720,
            127340565,
            127339178,
            127338941,
            127341395,
            127336543,
            127339094,
            127344978
        ]
    },
    "name": "E. Equilibrium",
    "statement": "William has two arrays a and b, each consisting of n items.For some\r\nsegments l..r of these arrays William wants to know if it is possible to\r\nequalize the values of items in these segments using a balancing\r\noperation. Formally, the values are equalized if for each i from l to r\r\nholds a_i = b_i.To perform a balancing operation an even number of\r\nindices must be selected, such that l\r\nle pos_1 < pos_2 <\r\ndots < pos_k\r\nle r. Next the items of at positions pos_1, pos_3, pos_5,\r\ndots get incremented by one and the items of at positions pos_2, pos_4,\r\npos_6,\r\ndots get incremented by one.William wants to find out if it is possible\r\nto equalize the values of elements in two arrays for each segment using\r\nsome number of balancing operations, and what is the minimal number of\r\noperations required for that. Note that for each segment the operations\r\nare performed independently.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 100005;\nll mx[maxn][20];\nll mn[maxn][20];\nint mb[maxn];\nll qmx(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return max(mx[l][j], mx[r - (1 << j) + 1][j]);\n}\nll qmn(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return min(mn[l][j], mn[r - (1 << j) + 1][j]);\n}\nint a[maxn];\nint b[maxn];\nll s[maxn];\nint main() {\n    int n, q;\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &b[i]);\n        a[i] -= b[i];\n        s[i] = s[i - 1] + a[i];\n    } \n    for (int i = 0; i < maxn; i++)\n        for (int j = 0; j < 20; j++)\n            if ((1 << j) <= i) mb[i] = j;\n    \n    for (int i = 0; i < 20; i++)\n        for (int j = 1; j <= n - (1 << i) + 1; j++) {\n            if (i == 0) mx[j][i] = s[j];\n            else {\n                mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    \n    for (int i = 0; i < 20; i++)\n        for (int j = 1; j <= n - (1 << i) + 1; j++) {\n            if (i == 0) mn[j][i] = s[j];\n            else {\n                mn[j][i] = min(mn[j][i - 1], mn[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    for (int i = 1; i <= q; i++) {\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        ll ans = -(qmn(l, r) - s[l - 1]);\n        if (s[r] != s[l - 1]) ans = -1;\n        if (qmx(l, r) > s[l - 1]) ans = -1;\n        printf(\"%lld\\n\", ans);\n    }\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Equilibrium.json",
    "editorial_link": "https://codeforces.com//blog/entry/94384",
    "editorial": "The first step to solving this problem is to create some array , where .\r\nThen we can select some elements from this array C and do operations for\r\nthese elements for the corresponding elements. And the challenge is to\r\nmake this array consist of zeros.It is argued that this can always be\r\ndone if the following conditions are met: 1. no prefix with positive-sum\r\nand no suffix with negative 2. the sum of all elements is zeroLet us\r\nprove the sufficiency of these conditions: we can find the smallest\r\nprefix with a negative sum and the smallest suffix with a positive one,\r\ndo the operation with one and one , and reduce the sum of the absolute\r\nvalues of the elements.Assertion: the minimum number of operations is\r\nthe maximum modulus of the sum on the subsegment. This is a lower\r\nestimate, since on any segment, the sum changes by at most 1. Let us\r\nprove the upper bound by presenting a constructive solution. Let now the\r\narray of differences , and the maximum modulus of the sum is .Letâs do\r\nthe following: find the first negative number, there is , the first\r\npositive number after it, there is , and so on. Statement: the last\r\noperation will be , because otherwise, our last nonzero number is\r\nnegative, which means it is a negative prefix.We can reformulate greed\r\nas follows: throw out all zeros, put in the first element for each\r\nnegative segment, and for each positive one in the first element. Let us\r\nprove that on any subsegment with the sum , it has decreased in absolute\r\nvalue. Without loss of generality, consider the segment with a\r\npositive-sum [the prefix corresponds to the suffix].Consider again the\r\narray obtained by throwing out zeros. It is clear that our segment did\r\nnot cut any segment of negative/positive ones, otherwise, it has no\r\nmaximum sum. It is also clear that the first and last segments in are\r\npositive, so we have bet more than .\r\n",
    "hint": []
}