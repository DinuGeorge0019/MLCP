{"link": "https://codeforces.com//contest/1037/problem/D", "problemId": "214573", "problem_idx": "D", "shortId": "1037D", "contest_number": "1037", "problem_submissions": {"G": [42400284, 42399505, 42393700, 42391956, 42395688, 49109531, 42416815, 42416802, 42408231, 42478375, 42723385, 42723256], "H": [42390789, 42393047, 42400959, 42399660, 42398441, 42399087, 42414998, 42453023, 42876495, 42876025, 42875988, 42875931], "E": [42383633, 42376516, 42374024, 42375460, 42374374, 42376325, 42382856, 42374364, 42376990, 42377973, 42378251, 42378271, 42378643, 42380819, 42380647, 42383308, 42382412, 42381355], "F": [42381395, 42382506, 42383872, 42380708, 42386216, 42379786, 42391156, 42378290, 42387714, 42379959, 42384150, 42386649, 42388704, 42386435, 42387614, 42390065, 42389970, 42390483], "D": [42369087, 42370798, 42380041, 42371136, 42379827, 42374961, 42370290, 42370315, 42380263, 42370259, 42374008, 42373176, 42374905, 42371349, 42379998, 42373150, 42374030], "C": [42367060, 42368485, 42368461, 42367940, 42368563, 42368341, 42378567, 42367842, 42367459, 42369272, 42375102, 42369783, 42370363, 42370761, 42367752, 42376902, 42370198, 42370636], "B": [42366092, 42367373, 42367083, 42366507, 42366793, 42366735, 42367983, 42366366, 42366278, 42367057, 42372146, 42367428, 42368851, 42367360, 42366696, 42366630, 42368278, 42367696], "A": [42365839, 42365922, 42366199, 42365850, 42365879, 42366070, 42366134, 42365823, 42365810, 42366029, 42366879, 43951943, 42366275, 42367664, 42365933, 42365869, 42365891, 42366540, 42366060]}, "name": "D. Valid BFS ", "statement": "The BFS algorithm is defined as follows. Consider an undirected graph\r\nwith vertices numbered from 1 to n. Initialize q as a new queue\r\ncontaining only vertex 1, mark the vertex 1 as used. Extract a vertex v\r\nfrom the head of the queue q. Print the index of vertex v. Iterate in\r\narbitrary order through all such vertices u that u is a neighbor of v\r\nand is not marked yet as used. Mark the vertex u as used and insert it\r\ninto the tail of the queue q. If the queue is not empty, continue from\r\nstep . Otherwise finish. Since the order of choosing neighbors of each\r\nvertex can vary, it turns out that there may be multiple sequences which\r\ncan print.In this problem you need to check whether a given sequence\r\ncorresponds to some valid traversal of the given tree . The tree is an\r\nundirected graph, such that there is exactly one simple path between any\r\ntwo vertices.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 02.09.2018 17:40:58       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid err() {\n  cout << \"No\" << '\\n';\n  exit(0);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> order(n);\n  for (int i = 0; i < n; i++) {\n    cin >> order[i];\n    order[i]--;\n  }\n  if (order[0] != 0) {\n    err();\n  }\n  vector<int> was(n, 0);\n  was[0] = 1;\n  int b = 0;\n  int e = 1;\n  while (b < e) {\n    int i = order[b];\n    set<int> put;\n    for (int j : g[i]) {\n      if (!was[j]) {\n        put.insert(j);\n      }\n    }\n    set<int> get;\n    for (int id = e; id < e + (int) put.size(); id++) {\n      get.insert(order[id]);\n    }\n    if (put != get) {\n      err();\n    }\n    for (int x : put) {\n      was[x] = 1;\n    }\n    e += (int) put.size();\n    b++;\n  }\n  if (e != n) {\n    err();\n  }\n  cout << \"Yes\" << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "shortest paths", "trees"], "dificulty": "1700", "interactive": false}