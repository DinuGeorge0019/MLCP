{
    "link": "https://codeforces.com//contest/1987/problem/D",
    "problemId": "2726563",
    "problem_idx": "D",
    "shortId": "1987D",
    "contest_number": "1987",
    "problem_submissions": {
        "E": [
            268229906,
            268158602,
            268423905,
            268422817,
            268157857,
            268152628,
            268233241,
            268233207,
            268156681,
            268158666,
            268162964,
            268158456,
            268163362,
            268156782,
            268165522,
            268170420,
            268158686,
            268162341,
            268233753,
            268228306,
            268160955,
            268160065,
            268161194,
            268164320,
            268163376,
            268166928,
            268264962,
            268164535
        ],
        "H": [
            268205560,
            268243575,
            268242763,
            268242753,
            268226875,
            268226200,
            286117872,
            286117361,
            268621342,
            270559507
        ],
        "G2": [
            268199327,
            268183184,
            268209905,
            268197988,
            268210865,
            268209119,
            268201265,
            268217291,
            268203603,
            268206936,
            268211532,
            268216966,
            268392569
        ],
        "G1": [
            268197008,
            268183589,
            268183559,
            268192970,
            268191020,
            268190335,
            268201091,
            268194194,
            268192954,
            268200485,
            268201459,
            268210583,
            268191184,
            268204488,
            268195197,
            268205593,
            268203056,
            268392539,
            268196879,
            268201576,
            268201255
        ],
        "F2": [
            268174418,
            268166457,
            268162505,
            268182920,
            268168846,
            268174436,
            268185759,
            268178301,
            268181565,
            268191599,
            268193415,
            268177500,
            268170902,
            268180818,
            268174520,
            268182719,
            268178817,
            268190336,
            268190071
        ],
        "F1": [
            268173831,
            268166694,
            268162641,
            268178377,
            268169399,
            268174193,
            268185332,
            268177979,
            268170897,
            268181978,
            268191481,
            268193293,
            268177600,
            268169616,
            268180668,
            268173797,
            268182414,
            268176479,
            268181249,
            268189979
        ],
        "D": [
            268149772,
            268151878,
            268147683,
            268147422,
            268149471,
            268152924,
            268151963,
            268155962,
            268148798,
            268153037,
            268153285,
            268152472,
            268152498,
            268151784,
            268149550,
            268150424,
            268156633,
            268151156,
            268159183,
            268155639
        ],
        "C": [
            268144323,
            268147501,
            268383290,
            268143974,
            268142997,
            268142336,
            268156117,
            268145345,
            268149662,
            268144034,
            268146014,
            268146306,
            268146500,
            268154494,
            268145000,
            268144648,
            268146061,
            268146320,
            268145299,
            268148183,
            268146033
        ],
        "B": [
            268142097,
            268138793,
            268136942,
            268137419,
            268137014,
            268140558,
            268141012,
            268143732,
            268140016,
            268142374,
            268143256,
            268141729,
            268142582,
            268139760,
            268140776,
            268140696,
            268140576,
            268139314,
            268141992,
            268141951
        ],
        "A": [
            268135899,
            268135441,
            268135342,
            268135356,
            268135339,
            268135852,
            268135895,
            268139203,
            268135363,
            268137561,
            268136567,
            268135744,
            268136590,
            268135768,
            268135350,
            268135764,
            268135555,
            268135575,
            268136024,
            268138028
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131053",
    "editorial": "Let\u00e2\u0080\u0099s consider Alice\u00e2\u0080\u0099s strategy. Notice that if both players play\r\noptimally, Alice eating a cake with a tastiness value of is equivalent\r\nto her eating all remaining cakes with . Since it is better for her to\r\nhave more cakes to choose from later on, she will choose the minimum\r\npossible on each turn.Now let\u00e2\u0080\u0099s consider Bob\u00e2\u0080\u0099s strategy. Suppose Bob ate\r\nat least one cake with a tastiness value of . Then he has to have eaten\r\nall of them, because eating only some of them does not affect Alice\u00e2\u0080\u0099s\r\npossible moves, resulting in wasted turns (he might be forced to waste\r\nmoves at the end of the game when there are some leftover cakes).Let be\r\nthe sorted unique values of , and let be the number of occurrences of in\r\n. Then the game is reduced to Alice finding the first and assigning ,\r\nand Bob choosing any and decreasing it by .Since Bob\u00e2\u0080\u0099s optimal strategy\r\nis for each either not to touch it or make , we can model it as him\r\nselecting some set of indices and zeroing out in this order. To be able\r\nto zero out (), Alice must not have gotten to the value . In turns,\r\nAlice will zero out exactly that many values. Additionally, Bob would\r\nhave zeroed out values before index . So, must be less than .\r\nTransforming this a bit, we get that the condition must hold for all\r\n.Bob\u00e2\u0080\u0099s objective to maximize the size of the set of incides . Let the\r\nminimum possible over all valid sets of indices . Initialize , and\r\neverything else to . The main idea is to grow valid sets of indices one\r\nindex at a time.We will iterate over all from to , and then for each\r\nfrom to . The transitions are: , which corresponds to not using the\r\ncurrent index in the set. Let . If , update , which is equivalent to\r\nadding the current index to the set. We only need to check the condition\r\non the last index because it is already satisfied for all the previous\r\nindices. The answer to the problem is , where is the largest value where\r\n.Complexity: Note: it is possible to solve in by making an additional\r\nobservation.\r\n",
    "name": "D. World is Mine",
    "statement": "Alice and Bob are playing a game. Initially, there are n cakes, with the\r\ni-th cake having a value of a_i.Alice and Bob take turns eating them,\r\nwith Alice starting first: In her turn, Alice chooses and eats any\r\nremaining cake whose tastiness is than the tastiness of any of the cakes\r\nshe\u2019s eaten before that. Note that on the first turn, she can choose any\r\ncake. In his turn, Bob chooses any remaining cake and eats it. The game\r\nends when the current player can\u2019t eat a suitable cake. Let x be the\r\nnumber of cakes that Alice ate. Then, Alice wants to maximize x, while\r\nBob wants to minimize x.Find out how many cakes Alice will eat if both\r\nplayers play optimally.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, \"/stack:200000000\")#pragma GCC optimize(\"O3\")//~ #pragma GCC target (\"avx2\")//~ #pragma GCC optimize(\"Ofast\")//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")//~ #pragma GCC optimize(\"unroll-loops\")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>\u00a0using namespace __gnu_pbds;using namespace std;\u00a0template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\u00a0#define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << \"(\" << d.first << \", \" << d.second << \")\";}sim dor(rge<c> d) {  *this << \"[\";  for (auto it = d.b; it != d.e; ++it)    *this << \", \" + 2 * (it == d.b) << *it;  ris << \"]\";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\u00a0#define shandom_ruffle random_shuffle\u00a0using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=5007;const int inf=1e9;\u00a0int n;int tab[nax];\u00a0int ile[nax];\u00a0int dp[nax][nax];\u00a0void mini(int &a, int b){\ta=min(a, b);}\u00a0void test(){\tscanf(\"%d\", &n);\tfor (int i=1; i<=n; i++)\t\tscanf(\"%d\", &tab[i]);\tsort(tab+1, tab+1+n);\tfor (int i=0; i<=n+3; i++)\t\tile[i]=0;\tfor (int i=1; i<=n; i++)\t\tile[tab[i]]++;\tfor (int i=0; i<=n; i++)\t\tfor (int j=0; j<=n; j++)\t\t\tdp[i][j]=inf;\tdp[0][0]=0;\tfor (int i=0; i<n; i++)\t{\t\tfor (int j=0; j<=n; j++)\t\t{\t\t\tif (dp[i][j]>=inf)\t\t\t\tcontinue;\t\t\tif (!ile[i+1])\t\t\t{\t\t\t\tmini(dp[i+1][j], dp[i][j]);\t\t\t\tcontinue;\t\t\t}\t\t\tif (j>=ile[i+1])\t\t\t\tmini(dp[i+1][j-ile[i+1]], dp[i][j]);\t\t\tmini(dp[i+1][j+1], dp[i][j]+1);\t\t}\t}\tint wyn=inf;\tfor (int i=0; i<=n; i++)\t\tmini(wyn, dp[n][i]);\tprintf(\"%d\\n\", wyn);}\u00a0int main(){\tint t;\tscanf(\"%d\", &t);\twhile(t--)\t\ttest();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. World is Mine.json"
}