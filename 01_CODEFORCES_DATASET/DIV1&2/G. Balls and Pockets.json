{
    "link": "https://codeforces.com//contest/1060/problem/G",
    "problemId": "230452",
    "problem_idx": "G",
    "shortId": "1060G",
    "contest_number": "1060",
    "problem_submissions": {
        "H": [
            43777582,
            43775787,
            43778301,
            43775359,
            43805399,
            43782088,
            43777602,
            44116240,
            43850241,
            43778906,
            43778773
        ],
        "F": [
            43769322,
            43774726,
            43772403,
            43778102,
            43769241,
            43772326,
            43773423,
            43775493,
            43777323,
            43776810,
            44345662,
            43998198,
            43776461,
            43777805,
            43885359,
            43777579,
            43776355,
            43779796,
            43779608,
            43780204
        ],
        "E": [
            43762417,
            43764663,
            43763746,
            43764167,
            43763212,
            43766061,
            43765524,
            43768205,
            43766236,
            43763603,
            43766034,
            43766754,
            43768368,
            43766310,
            43767829,
            43764919,
            43769766,
            43765300,
            43766971,
            43767710
        ],
        "B": [
            43761076,
            43759115,
            43759168,
            43759290,
            43758265,
            43759025,
            43759632,
            43759678,
            43759571,
            43759528,
            43758792,
            43759203,
            43760228,
            43760411,
            43761202,
            43772055,
            43761410,
            43759136,
            43761174,
            43759666
        ],
        "C": [
            43760028,
            43761053,
            43760979,
            43760607,
            43760834,
            43761267,
            43761559,
            43762200,
            43761558,
            43761781,
            43761097,
            43763023,
            43762854,
            43762864,
            43763097,
            43761814,
            43765269,
            43760939,
            43763385,
            43762549
        ],
        "D": [
            43758517,
            43762752,
            43762719,
            43762340,
            43759631,
            43763257,
            43762507,
            43764164,
            43763131,
            43760435,
            43762978,
            43764580,
            43764519,
            43765425,
            43764660,
            43762881,
            43766760,
            43767791,
            43764938,
            43764650
        ],
        "A": [
            43757554,
            43758213,
            43757544,
            43758262,
            43757552,
            43757711,
            43757958,
            43758105,
            43757983,
            43757586,
            43757752,
            43757708,
            43758583,
            43757806,
            43757592,
            43757955,
            43759122,
            43757641,
            43757856,
            43757849
        ],
        "G": [
            44020164,
            44543288
        ]
    },
    "name": "G. Balls and Pockets",
    "statement": "There is a strip with an infinite number of cells. Cells are numbered\r\nstarting with 0. Initially the cell i contains a ball with the number\r\ni.There are n pockets located at cells a_1,\r\nldots, a_n. Each cell contains at most one pocket. is the following\r\nsequence of operations: All pockets at cells a_1,\r\nldots, a_n open simultaneously, which makes balls currently located at\r\nthose cells disappear. After the balls disappear, the pockets close\r\nagain. For each cell i from 0 to\r\ninfty, if the cell i contains a ball, we move that ball to the free cell\r\nj with the lowest number. If there is no free cell j < i, the ball stays\r\nat the cell i.Note that after each filtering operation each cell will\r\nstill contain exactly one ball.For example, let the cells 1, 3 and 4\r\ncontain pockets. The initial configuration of balls is shown below\r\n(underscores display the cells with pockets): 0 2 5 6 7 8 9 ... After\r\nopening and closing the pockets, balls 1, 3 and 4 disappear: 0 2 5 6 7 8\r\n9 ... After moving all the balls to the left, the configuration looks\r\nlike this: 0 5 8 9 10 11 12 ... Another filtering repetition results in\r\nthe following: 0 8 11 12 13 14 15 ... You have to answer m questions.\r\nThe i-th of these questions is \"what is the number of the ball located\r\nat the cell x_i after k_i repetitions of the filtering operation?\"\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\nconst int M = 10000005;\n\nstruct node_t {\n  int l, r, value;\n} tree[M];\n\nint n, m, start, total, a[N], b[N], fenw[N], last[N], root[N], times[N];\nlong long sum[N];\n\nvoid modify(int x, int value) {\n  for (; x <= n; x += x & -x) {\n    fenw[x] += value;\n  }\n}\n\nint query(int x) {\n  int result = 0;\n  for (; x; x -= x & -x) {\n    result += fenw[x];\n  }\n  return result;\n}\n\nint erase(int x) {\n  int l = 1, r = n, p = n + 1;\n  while (l <= r) {\n    int mid = l + r >> 1;\n    if (query(mid) > x) {\n      p = mid;\n      r = mid - 1;\n    } else {\n      l = mid + 1;\n    }\n  }\n  modify(p, -1);\n  return p - 1;\n}\n\npair<long long, int> check(int p, int k, int x) {\n  x += times[p] - k;\n  int q = upper_bound(times, times + n, x) - times;\n  return make_pair((long long)x * q - sum[q], q);\n}\n\nint query_where(int x, int k) {\n  int l = 1, r = n - 1, result = 0;\n  while (l <= r) {\n    int mid = l + r >> 1;\n    if (check(mid, k, 0).first <= x) {\n      result = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return result;\n}\n\nint query_exact(int x, int k, int p) {\n  int l = 1, r = times[p + 1] - times[p], result = 0;\n  if (p == n - 1) {\n    r = x / n + k + 1;\n  }\n  while (l <= r) {\n    int mid = l + (r - l >> 1);\n    if (check(p, k, mid).first <= x) {\n      result = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return result;\n}\n\nvoid modify(int &x, int y, int l, int r, int p) {\n  tree[x = ++total] = tree[y];\n  ++tree[x].value;\n  if (l != r) {\n    int mid = l + r >> 1;\n    if (p <= mid) {\n      modify(tree[x].l, tree[y].l, l, mid, p);\n    } else {\n      modify(tree[x].r, tree[y].r, mid + 1, r, p);\n    }\n  }\n}\n\nint query_kth(int x, int l, int r, int k) {\n  if (l == r) {\n    return l;\n  } else {\n    int mid = l + r >> 1;\n    if (k >= tree[tree[x].l].value) {\n      return query_kth(tree[x].r, mid + 1, r, k - tree[tree[x].l].value);\n    } else {\n      return query_kth(tree[x].l, l, mid, k);\n    }\n  }\n}\n\nint query_sum(int x, int l, int r, int p) {\n  if (r == p) {\n    return tree[x].value;\n  }\n  int mid = l + r >> 1;\n  if (p <= mid) {\n    return query_sum(tree[x].l, l, mid, p);\n  } else {\n    return tree[tree[x].l].value + query_sum(tree[x].r, mid + 1, r, p);\n  }\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  start = a[0];\n  for (int i = 0; i < n; ++i) {\n    a[i] -= start;\n  }\n  for (int i = 1; i < n; ++i) {\n    times[i] = times[i - 1] + (a[i] - last[i - 1]) / i;\n    last[i] = last[i - 1] + i * (times[i] - times[i - 1]);\n    sum[i + 1] = sum[i] + times[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    modify(i, 1);\n  }\n  for (int i = n - 1; ~i; --i) {\n    b[i] = erase(a[i] - last[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    modify(root[i + 1], root[i], 0, n - 1, b[i]);\n  }\n  while (m--) {\n    int x, k;\n    scanf(\"%d %d\", &x, &k);\n    if (x < start) {\n      printf(\"%d\\n\", x);\n    } else {\n      x -= start;\n      int p = query_where(x, k);\n      int q = query_exact(x, k, p);\n      pair<long long, int> result = check(p, k, q);\n      int remain = x - result.first, prefix = result.second;\n      int rank = query_kth(root[prefix], 0, n - 1, remain);\n      int numbers = 0;\n      if (rank) {\n        numbers = query_sum(root[p + 1], 0, n - 1, rank - 1);\n      }\n      printf(\"%lld\\n\", start + last[p] + (long long)q * (p + 1) + numbers);\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Balls and Pockets.json",
    "editorial_link": "https://codeforces.com//blog/entry/113725",
    "editorial": "We\u0092ll reindex \na\na for its indices to start from \n0\n0.\n\nLet\u0092s start out with an easy to prove observation:\n\nWe call an interval \n[\na\n,\nb\n]\n[a,b] of positive integers good if there are exactly \nb\n?\na\n+\n1\nb?a+1 pockets with positions \n<\nb\n<b. Then after a single operation, a good interval moves to positions that form a good interval. The proof goes as follows: let\u0092s say there are \nc\nc pockets under the interval. Then the left endpoint moves by \nb\n?\na\n+\n1\n?\nc\nb?a+1?c (potentially falling into a pocket), the right endpoint moves by \nb\n?\na\n+\n1\nb?a+1, and balls that didn\u0092t fall into a pocket remain contiguous (filling holes if formed).\n\nLet\u0092s try to take advantage of such good intervals. We will try to construct good intervals with some maximal right endpoints, so as to partition the integer line into some partitions.\n\nDefine the sequence \n{\nr\ni\n}\ni\n=\n0\nn\n?\n1\n{r \ni\n?\n } \ni=0\nn?1\n?\n  by \nr\n0\n=\na\n0\n?\n1\nr \n0\n?\n =a \n0\n?\n ?1 and \nr\ni\n=\nr\ni\n?\n1\n+\ni\n?\n?\na\ni\n?\n1\n?\nr\ni\n?\n1\ni\n?\nr \ni\n?\n =r \ni?1\n?\n +i?? \ni\na \ni\n?\n ?1?r \ni?1\n?\n \n?\n ? for \ni\n>\n0\ni>0. This is clearly a non-decreasing sequence.\n\nThis roughly corresponds to the set of right endpoints of our intervals (though some \nr\ni\nr \ni\n?\n  will be repeated here, and though we\u0092ll ignore them in the current analysis, they\u0092ll be helpful for implementation).\n\nObservation 1. By the definition of floor, we have \nr\ni\n+\n1\n?\na\ni\n?\nr\ni\n+\ni\nr \ni\n?\n +1?a \ni\n?\n ?r \ni\n?\n +i.\n\nObservation 2. Whenever \nr\ni\n>\nr\ni\n?\n1\nr \ni\n?\n >r \ni?1\n?\n , we have \nr\ni\n>\na\ni\n?\n1\nr \ni\n?\n >a \ni?1\n?\n .\n\nProof. Since \nr\ni\n?\nr\ni\n?\n1\nr \ni\n?\n ?r \ni?1\n?\n  is divisible by \ni\ni, the difference is at least \ni\ni. So by the previous observation, we have \nr\ni\n?\nr\ni\n?\n1\n+\ni\n?\na\ni\n?\n1\n+\n1\n>\na\ni\n?\n1\nr \ni\n?\n ?r \ni?1\n?\n +i?a \ni?1\n?\n +1>a \ni?1\n?\n , as desired.\n\nFrom this, we get that if \nr\ni\n>\nr\ni\n?\n1\nr \ni\n?\n >r \ni?1\n?\n , the length of the moving interval \n[\nr\ni\n?\ni\n+\n1\n,\nr\ni\n]\n[r \ni\n?\n ?i+1,r \ni\n?\n ] stays intact for \n?\na\ni\n?\n1\n?\nr\ni\n?\n1\ni\n?\n?\n1\n? \ni\na \ni\n?\n ?1?r \ni?1\n?\n \n?\n ??1 operations, and after one more operation, it ends up at some suffix of positions \n?\nr\ni\n?\n1\n?r \ni?1\n?\n . That is, \nr\ni\nr \ni\n?\n  after some operations hits \nr\ni\n?\n1\nr \ni?1\n?\n . This sequence gives a partition of the integer line into smaller chunks that can be reasoned about locally.\n\nNow that the main idea of the solution is complete, all that remains is to back-compute the number that ends up at a given position. For this, it is (theoretically) straightforward to compute the answer if you reason about the number that ends up at certain \nr\ni\nr \ni\n?\n -s close to \nx\nx. For the relevant book-keeping that needs to be done as a part of implementation details, a persistent segment tree can be used. Note that the queries can also be solved offline, but that needs some more work."
}