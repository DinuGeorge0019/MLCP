{
    "link": "https://codeforces.com//contest/653/problem/F",
    "problemId": "52170",
    "problem_idx": "F",
    "shortId": "653F",
    "contest_number": "653",
    "problem_submissions": {
        "D": [
            16882408,
            16811537,
            16810665,
            16808469,
            16808880,
            16810169,
            16810193,
            16817835,
            16817684,
            16809816,
            16810008,
            16809541,
            16810009,
            16809483,
            16815488,
            16815467,
            16809743,
            16815857,
            16810399,
            16830307,
            16830297,
            16830295,
            16809555
        ],
        "C": [
            16814329,
            16808201,
            16807277,
            16809824,
            16809484,
            16809237,
            16808970,
            16808978,
            16808649,
            16810747,
            16824380,
            16810982,
            16808580,
            16808306,
            16809772,
            16808759,
            16815412,
            16808885,
            16810588
        ],
        "F": [
            16813454,
            16812764,
            16813359,
            16811313,
            16812655,
            16813981,
            16813203,
            16812204,
            16812853,
            16813207,
            16813077,
            16811759,
            16813557,
            16817070,
            16813698,
            16812540,
            16812526
        ],
        "E": [
            16812212,
            16809858,
            16810442,
            16814020,
            16811168,
            16811817,
            16811727,
            16814449,
            16814876,
            16813977,
            16814689,
            16810991,
            16810903,
            16815613,
            16810612,
            16812105,
            16811842
        ],
        "B": [
            16811122,
            16806823,
            16808941,
            16806712,
            16806895,
            16807172,
            16806271,
            16807190,
            16807288,
            16809090,
            16808193,
            16806845,
            16806473,
            16807895,
            16806798,
            16807486,
            16808397,
            16806933
        ],
        "A": [
            16810886,
            16805361,
            16805416,
            16805408,
            16805395,
            16805730,
            16805338,
            16805605,
            16805967,
            16806396,
            16807313,
            16805370,
            16805342,
            16805498,
            16805369,
            16805701,
            16806883,
            16805397
        ],
        "G": [
            16810637,
            16830434,
            16849997,
            16871778,
            16820127,
            16813576,
            16863345,
            16813594,
            16830285
        ]
    },
    "name": "F. Paper task",
    "statement": "Alex was programming while Valentina (his toddler daughter) got there\r\nand started asking many questions about the round brackets (or\r\nparenthesis) in the code. He explained her a bit and when she got it he\r\ngave her a task in order to finish his code on time.For the purpose of\r\nthis problem we consider only strings consisting of opening and closing\r\nround brackets, that is characters \u201d and \u201d.The sequence of brackets is\r\ncalled if: it\u2019s empty; it\u2019s a correct sequence of brackets, enclosed in\r\na pair of opening and closing brackets; it\u2019s a concatenation of two\r\ncorrect sequences of brackets. For example, the sequences \"\" and \"\" are\r\ncorrect, while \"\", \"\" and \"\" are not.Alex took a piece of paper, wrote a\r\nstring consisting of brackets and asked Valentina to count the number of\r\nnon-empty substrings of that are correct sequences of brackets. In other\r\nwords, her task is to count the number of non-empty correct sequences of\r\nbrackets that occur in a string as a (don\u2019t mix up with\r\nsubsequences).When Valentina finished the task, Alex noticed he doesn\u2019t\r\nknow the answer. Help him don\u2019t loose face in front of Valentina and\r\nsolve the problem!\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=501000*2;\nchar s[N];\nint n,rk[N],sa[N],ht[N],r[N],pro[N];\npair<PII,int> pos[N];\nVI vec[N];\n\nvoid buildSA(char *p) {\n\trep(i,0,n) rk[i]=p[i];\n\trep(j,0,19) {\n\t\trep(i,0,n) pos[i]=mp(mp(rk[i],rk[i+(1<<j)]),i);\n\t\tsort(pos,pos+n);\n\t\tint cnt=0;\n\t\trep(i,0,n) {\n\t\t\trk[pos[i].se]=cnt+1;\n\t\t\tcnt+=(pos[i].fi!=pos[i+1].fi);\n\t\t}\n\t\tif (cnt==n) break;\n\t}\n\trep(i,0,n) sa[rk[i]]=i;\n}\nvoid height() {\n\tint k=0;\n\trep(i,0,n) {\n//\t\tprintf(\"%d\\n\",rk[i]);\n\t\tif (rk[i]==1) continue;\n\t\tk=max(0,k-1);\n\t\tfor (int j=sa[rk[i]-1];s[i+k]==s[j+k];k++);\n\t\tht[rk[i]]=k;\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tbuildSA(s);\n\theight();\n\trep(i,1,n+1) {\n//\t\tprintf(\"%d %d\\n\",sa[i],ht[i]);\n\t\tr[sa[i]]=sa[i]+ht[i];\n\t}\n/*\trep(i,0,n) {\n\t\tprintf(\"%d\\n\",r[i]);\n\t}*/\n\tint cur=n;\n\trep(i,0,n) {\n\t\tpro[i]=cur;\n\t\tif (s[i]=='(') cur++; else cur--;\n\t}\n\tpro[n]=cur;\n\tll ret=0;\n\tper(i,0,n) {\n\t\tvec[pro[i+1]].pb(-i-1);\n\t\t// start at pro[i] end at n\n\t\tint pr=n;\n\t\tif (!vec[pro[i]-1].empty()) pr=-vec[pro[i]-1].back()-1;\n//\t\tprintf(\"%d %d\\n\",r[i],pr);\n\t\tif (pr<=r[i]) continue;\n\t\t// r[i].. pr\n\t\tret-=lower_bound(all(vec[pro[i]]),-(pr+1))-lower_bound(all(vec[pro[i]]),-r[i]);\n//\t\tprintf(\"%d %d\\n\",i,r);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Paper task.json",
    "editorial_link": "https://codeforces.com//blog/entry/43886",
    "editorial": "There are two solutions. The first and more common solution\nrequired understanding how do SA (suffix array) and LCP (longest common\nprefix) work. The second processed the input string first and then run\nSA+LCP like a blackbox, without modifying or caring about those\nalgorithms. Modify-SA-solution The main idea is to modify the algorithm\nfor computing the number of distinct substrings using SA + LCP. Let\ndenote the number of well formed prefixes of . For example, for we would\nhave because we count oraz . How to be able to get fast? You can treat\nthe opening bracket as and the ending bracket as . Then you are\ninterested in the number of intervals starting in , ending not after ,\nwith sum on the interval equal to zero. Additionally, the sum from to\nany earlier right end can\u00e2\u0080\u0099t be less than zero. Maybe you will need some\npreprocessing here, maybe binary search, maybe segment trees. It\u00e2\u0080\u0099s an\nexercise for you. We can iterate over suffix array values and for each\nsuffix we add to the answer. In other words we count the number of well\nformed substrings in the current suffix and subtract the ones we counted\nin the previous step. The complexity is but you could get AC with very\nfast solution with extra . Compressing-solution I will slowly compress\nthe input string, changing small well-formed substrings to some new\ncharacters (in my code they are represented by integer numbers, not by\nletters). Let\u00e2\u0080\u0099s take a look at the example:or equivalently: Whenever I\nhave a maximum (not possible to expand) substring with single letters\nonly, without any brackets, then I add this substring to some global\nlist of strings. At the end I will count distinct substrings in the\nfound list of strings (using SA+LCP). In the example above I would first\nadd a string \"a\" and later I would add \"baa\". Note that each letter\nrepresents some well formed substring, e.g. \u00e2\u0080\u0099b\u00e2\u0080\u0099 represents here. I must\nmake sure that the same substrings will be compressed to the same\nletters. To do it, I always move from left to right, and I use trie with\nmap (two know what to get from some two letters). problem G you can\nconsider each prime number separately. Can you find the answer if there\nare only 1\u00e2\u0080\u0099s and 2\u00e2\u0080\u0099s in the input? It may be hard to try to iterate over\npossible placements of the median. Maybe it\u00e2\u0080\u0099s better to think how many\nnumbers we will change from 2^p to 2^{p+1}.\n"
}