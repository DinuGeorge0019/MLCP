{"link": "https://codeforces.com//contest/1864/problem/B", "problemId": "2181265", "problem_idx": "B", "shortId": "1864B", "contest_number": "1864", "problem_submissions": {"I": [220596748, 220625703, 220625365, 220625093], "H": [220568821, 220567695, 220569504, 220765807, 220735033, 220733694, 220582422, 220590968, 220584872, 220585832, 220586273, 220588653, 220869529, 220592706, 220587781, 220596085, 222139412, 220596294], "G": [220562227, 220575493, 220588511, 220576272, 220574639, 220576772, 220595506, 220568659, 220611309, 221223033, 220575904, 220585515, 220590419, 220591092, 220590354, 220590686], "F": [220551620, 220555802, 220557675, 220718976, 220558576, 220553574, 220558951, 220567707, 220555900, 220612295, 220564492, 220564273, 220565836, 220560759, 220571802, 220564441, 220571627, 220556155, 220556855, 220560337, 220568919, 220567748], "E": [220545674, 220547229, 220549551, 220553761, 220544098, 220550014, 220550285, 220550294, 220555536, 220557391, 220559164, 220553118, 220556990, 220555427, 220553548, 220549618, 220563369, 220552727, 220558630, 220553863], "D": [220537006, 220537255, 220535722, 220536129, 220534069, 220542850, 220539341, 220538198, 220541287, 220542463, 220545447, 220548373, 220544205, 220540271, 220536187, 220541552, 220541368, 220545083, 220544975], "C": [220533606, 220528455, 220528101, 220528155, 220527489, 220537748, 220525134, 220530359, 220532079, 220533694, 220541070, 220542060, 220535618, 220533106, 220530771, 220535184, 220536493, 220534865, 220537384], "B": [220524699, 220524727, 220525716, 220524082, 220524572, 220524039, 220522756, 220522640, 220528173, 220525137, 220528062, 220531552, 220524275, 220526451, 220524531, 220529349, 220526226, 220525961, 220525118], "A": [220521618, 220521580, 220521747, 220521485, 220521753, 220521570, 220521442, 220521465, 220524365, 220521707, 220524695, 220522808, 220521703, 220522789, 220521679, 220521789, 220521663, 220522116, 220521966]}, "name": "B. Swap and Reverse", "statement": "You are given a string s of length n consisting of lowercase English\r\nletters, and an integer k. In one step you can perform of the two\r\noperations below: Pick an index i (1\r\nle i\r\nle n - 2) and swap s_{i} and s_{i+2}. Pick an index i (1\r\nle i\r\nle n-k+1) and reverse the order of letters formed by the range [i,i+k-1]\r\nof the string. Formally, if the string currently is equal to s_1\r\nldots s_{i-1}s_is_{i+1}\r\nldots s_{i+k-2}s_{i+k-1}s_{i+k}\r\nldots s_{n-1}s_n, change it to s_1\r\nldots s_{i-1}s_{i+k-1}s_{i+k-2}\r\nldots s_{i+1}s_is_{i+k}\r\nldots s_{n-1}s_n. You can make as many steps as you want (possibly,\r\nzero). Your task is to find the lexicographically string you can obtain\r\nafter some number of steps. A string a is lexicographically smaller than\r\na string b of the same length if and only if the following holds: in the\r\nfirst position where a and b differ, the string a has a letter that\r\nappears earlier in the alphabet than the corresponding letter in b.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nchar wcz[nax];\n\nvector<char> lit[2];\n\nvoid test()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tscanf(\"%s\", wcz+1);\n\tlit[0].clear();\n\tlit[1].clear();\n\tfor (int i=1; i<=n; i++)\n\t\tlit[i&1].push_back(wcz[i]);\n\tsort(lit[0].begin(), lit[0].end());\n\tsort(lit[1].begin(), lit[1].end());\n\treverse(lit[0].begin(), lit[0].end());\n\treverse(lit[1].begin(), lit[1].end());\n\tif (k&1)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tchar c=lit[i&1].back();\n\t\t\tlit[i&1].pop_back();\n\t\t\tprintf(\"%c\", c);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\telse\n\t{\n\t\tfor (char i : lit[1])\n\t\t\tlit[0].push_back(i);\n\t\tsort(lit[0].begin(), lit[0].end());\n\t\tfor (char i : lit[0])\n\t\t\tprintf(\"%c\", i);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings", "strings"], "dificulty": "1100", "interactive": false}