{
    "link": "https://codeforces.com//contest/1782/problem/G",
    "problemId": "1738313",
    "problem_idx": "G",
    "shortId": "1782G",
    "contest_number": "1782",
    "problem_submissions": {
        "G": [
            189352903,
            189354160,
            189342529,
            189347964,
            189346429,
            189415258,
            189347317,
            189738607,
            189347232,
            189347696,
            189403021,
            189438204,
            189354810,
            189338967,
            189344949
        ],
        "H1": [
            189341567,
            189339761,
            189349634,
            189355935,
            189355012,
            189341367,
            189348685,
            189366896,
            189384259,
            189345985,
            189353203,
            189354256,
            189356712
        ],
        "F": [
            189325657,
            189363621,
            189331442,
            189327188,
            189334558,
            189331825,
            189332228,
            189332897,
            189335481,
            189328585,
            189328764,
            189334100,
            189338796,
            189342861,
            189333278,
            189345646,
            189348301,
            189336716,
            189329952,
            189336813
        ],
        "E": [
            189322203,
            189324476,
            189336013,
            189324984,
            189327367,
            189324941,
            189325259,
            189324742,
            189325043,
            189324750,
            189330839,
            189330033,
            189340117,
            189340110,
            189356727,
            189364874,
            189338107,
            189329882
        ],
        "D": [
            189315553,
            189316553,
            189320757,
            189315522,
            189321240,
            189315774,
            189315356,
            189317449,
            189316444,
            189318717,
            189318855,
            189319485,
            189321217,
            189322258,
            189322561,
            189316855,
            189317394,
            189318806,
            189319611
        ],
        "C": [
            189312571,
            189313515,
            189317007,
            189313044,
            189315685,
            189312570,
            189312443,
            189313938,
            189314521,
            189313780,
            189316398,
            189315035,
            189318312,
            189317410,
            189321818,
            189314789,
            189315093,
            189314367
        ],
        "B": [
            189309405,
            189309603,
            189311019,
            189308821,
            189310918,
            189309246,
            189308942,
            189310194,
            189308126,
            189309056,
            189311263,
            189310085,
            189312839,
            189309172,
            189329674,
            189309853,
            189310568,
            189309470
        ],
        "A": [
            189307515,
            189306919,
            189307198,
            189307124,
            189307391,
            189307301,
            189307111,
            189307534,
            189306943,
            189307353,
            189307056,
            189307424,
            189308244,
            189319051,
            189308061,
            189307499,
            189307060,
            189307053
        ],
        "H2": [
            189361277,
            189352155,
            189886586,
            189749780,
            189366917,
            189362146
        ]
    },
    "name": "G. Diverse Coloring",
    "statement": "In this problem, we will be working with rooted binary trees. A tree is\r\ncalled a rooted binary tree if it has a fixed root and every vertex has\r\nat most two children.Let\u2019s assign a color white or blue to each vertex\r\nof the tree, and call this assignment a of the tree. Let\u2019s call a\r\ncoloring if every vertex has a neighbor (a parent or a child) colored\r\ninto an opposite color compared to this vertex. It can be shown that any\r\ntree with at least two vertices allows a diverse coloring.Let\u2019s define\r\nthe of a coloring as the absolute value of the difference between the\r\nnumber of white vertices and the number of blue vertices.Now to the\r\nproblem. Initially, the tree consists of a single vertex with the number\r\n1 which is its root. Then, for each i from 2 to n, a new vertex i\r\nappears in the tree, and it becomes a child of vertex p_i. It is\r\nguaranteed that after each step the tree will keep being a binary tree\r\nrooted at vertex 1, that is, each vertex will have at most two\r\nchildren.After every new vertex is added, print the smallest value of\r\ndisbalance over all possible diverse colorings of the current tree.\r\nMoreover, after adding the last vertex with the number n, also print a\r\ndiverse coloring with the smallest possible disbalance as well.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1e6 + 7;\nint n, p[N], deg[N], ns, vis[N], tag[N], ans[N];\nint to[N], tow[N], sum[N];\nvi e[N], G[N];\nvoid dfs(int x, int rt, int rtx) {\n\tif(rtx) \n\t\tsum[rt] -= 1;\n\telse \n\t\tsum[rt] += 1;\n\tto[x] = rt;\n\ttow[x] = rtx;\n\tfor(auto v : G[x]) if(!to[v]) \n//\t\tcout << x << \" -> \" << v << endl, \n\t\tdfs(v, rt, rtx ^ 1);\n}\nint S[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) deg[i] = 0, sum[i] = 0, tow[i] = 0, ans[i] = 0, \n\t\tto[i] = 0, tow[i] = 0, e[i].clear(), G[i].clear();\n\tL(i, 2, n) {\n\t\tcin >> p[i];\n\t\tdeg[i] += 1;\n\t\tdeg[p[i]] += 1;\n\t\tns = i & 1;\n\t\tif(i == 4) {\n\t\t\tL(i, 1, 4) \n\t\t\t\tif(deg[i] == 3)\n\t\t\t\t\tns = 2;\n \t\t}\n \t\tcout << ns << '\\n';\n\t\te[i].emplace_back(p[i]);\n\t\te[p[i]].emplace_back(i);\n\t} \n\tif(n <= 4) {\n\t\tL(msk, 0, (1 << n) - 1) {\n\t\t\tint bt = __builtin_popcount(msk);\n\t\t\tif(n - bt * 2 != ns) continue;\n\t\t\tint qwq = 1;\n\t\t\tL(i, 1, n) {\n\t\t\t\tint ok = 0;\n\t\t\t\tfor(auto v : e[i]) {\n\t\t\t\t\tif((msk >> (i - 1) & 1) != (msk >> (v - 1) & 1)) {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t} \n\t\t\t\t} \n\t\t\t\tif(!ok) qwq = 0;\n\t\t\t}\n\t\t\tif(qwq) {\n\t\t\t\tL(i, 1, n) cout << ((msk >> (i - 1) & 1) ? 'w' : 'b');\n\t\t\t\tcout << '\\n';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t\treturn ;\n\t}\n\tqueue < int > q;\n\tL(i, 1, n) if(deg[i] == 1) q.push(i);\n\tL(i, 1, n) vis[i] = 0, tag[i] = 0, S[i] = 1; \n\twhile(sz(q)) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tvis[u] = 1;\n//\t\tcout << \"u = \" << u << endl;\n\t\t\n\t\tint to = -1;\n\t\tfor(auto v : e[u]) {\n\t\t\tif(!vis[v]) {\n\t\t\t\t--deg[v];\n\t\t\t\tif(deg[v] == 1) \n\t\t\t\t\tq.push(v);\n\t\t\t\tto = v;\n\t\t\t}\n\t\t}\n\t\t\n//\t\tcout << \"act \" << u << \" : \" << S[u] << endl;\n\t\tif(tag[u]) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(auto v : e[u]) \n\t\t\tif(S[v] >= 0) \n\t\t\t\tto = v;\n\t\tif(to == -1) \n\t\t\tto = e[u][0];\n//\t\tcout << u << \" : \" << S[u] << endl;\n\t\t\n\t\tG[u].emplace_back(to);\n\t\tG[to].emplace_back(u);\n\t\tS[to] -= S[u];\n\t\ttag[u] = tag[to] = true;\n\t}\n\t\n//\tL(i, 1, n) \n//\t\tcout << S[i] << ' ';\n//\tcout << endl;\n\t\n\tvi arr;\n\tL(i, 1, n) if(!to[i]) \n\t\tsum[i] = 0, dfs(i, i, 0), arr.emplace_back(i);\n\t\n\tsort(arr.begin(), arr.end(), [&] (int x, int y) {\n\t\treturn abs(sum[x]) > abs(sum[y]);\n\t});\n\tint all = 0;\n\tfor(auto u : arr) {\n\t\tint ab = abs(sum[u]);\n//\t\tcout << \"ab = \" << ab << endl; \n\t\tif(all <= 0) {\n\t\t\tall += ab;\n\t\t\tans[u] = 0 ^ (sum[u] < 0);\n\t\t} else {\n\t\t\tall -= ab;\n\t\t\tans[u] = 1 ^ (sum[u] < 0);\n\t\t}\n\t}\n\tL(i, 1, n) \n\t\tans[i] = ans[to[i]] ^ tow[i];\n\tassert(all == ns);\n\t\n\tL(i, 1, n) \n\t\tif(ans[i]) cout << 'w';\n\t\telse cout << 'b';\n\tcout << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Diverse Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/111783",
    "editorial": "It turns out that it is always possible to construct a diverse coloring\r\nwith disbalance or (depending on the parity of ), except for the case of\r\na tree with vertices with one vertex of degree (which is given in the\r\nexample).Let\u00e2\u0080\u0099s traverse the tree from bottom to top. For each subtree,\r\nwe will try to construct a diverse coloring where the subtree root is\r\ncolored white. We will define the disbalance of the subtree coloring to\r\nbe the number of vertices colored white, minus the number of vertices\r\ncolored blue. This is equivalent to the original definition, except that\r\nnow the number also has a sign.We will aim at obtaining disbalances and\r\n, if possible. In some small cases, it will be impossible. We will say\r\n\"subtree has disbalance \" or \"vertex has disbalance \", meaning that we\r\nhave constructed a coloring of the (vertex\u00e2\u0080\u0099s) subtree with disbalance\r\n.Let be the root of the subtree (colored white): If has no children, the\r\nonly coloring has disbalance ; however, it is not diverse. Thus, we will\r\nhave to be careful about the leaf case in the future. If has one child ,\r\nflip the colors in \u00e2\u0080\u0099s subtree to create a blue neighbor for : If had\r\ndisbalance before the flip, now has disbalance . If had disbalance\r\nbefore the flip, now has disbalance . If has two children and : If both\r\nhave disbalance , flip the colors in at least one of \u00e2\u0080\u0099s and \u00e2\u0080\u0099s subtrees,\r\nnow has disbalance . If both have disbalance , flip the colors in either\r\n\u00e2\u0080\u0099s or \u00e2\u0080\u0099s subtree, now has disbalance . If one has disbalance and the\r\nother has disbalance , flip the colors in the one with , now has\r\ndisbalance . The only issue happens when has two children that are both\r\nleaves: we have to recolor both and into blue, which will force to have\r\ndisbalance . Let\u00e2\u0080\u0099s add new cases to the analysis above based on the\r\nexistence of subtrees with disbalance : If has one child with disbalance\r\n: Flip the colors in \u00e2\u0080\u0099s subtree, now has disbalance . If has two\r\nchildren and , where has disbalance : If has disbalance , flip the\r\ncolors in either \u00e2\u0080\u0099s or \u00e2\u0080\u0099s subtree, now has disbalance . If has\r\ndisbalance , flip the colors in \u00e2\u0080\u0099s subtree, now has disbalance . If has\r\ndisbalance , flip the colors in both \u00e2\u0080\u0099s and \u00e2\u0080\u0099s subtrees, now has\r\ndisbalance . We can see that, once again, a new case appears where a\r\nsubtree has disbalance (described at the beginning of this tutorial),\r\nand unfortunately we can\u00e2\u0080\u0099t avoid that. We can see that this case only\r\nhappens for a specific subtree of vertices. Let\u00e2\u0080\u0099s proceed with the case\r\nanalysis... If has one child with disbalance : Flip \u00e2\u0080\u0099s color (not the\r\nwhole subtree, but just ), now has disbalance . If has two children and\r\n, where has disbalance : If has disbalance , flip the colors in both \u00e2\u0080\u0099s\r\nand \u00e2\u0080\u0099s subtrees, now has disbalance . If has disbalance , flip \u00e2\u0080\u0099s color,\r\nnow has disbalance . If has disbalance , flip \u00e2\u0080\u0099s color and the colors in\r\n\u00e2\u0080\u0099s subtree, now has disbalance . If has disbalance , flip the colors in\r\neither \u00e2\u0080\u0099s or \u00e2\u0080\u0099s subtree, now has disbalance . It follows that for any\r\nother tree, except two special cases of a -vertex tree and a -vertex\r\ntree, it is possible to obtain disbalance or .From this point, one way\r\nto implement the solution is to carefully consider all the cases. Note\r\nthat whenever we say \"flip the colors in \u00e2\u0080\u0099s subtree\", we can just set\r\nsome flag in vertex . Then, as we traverse the tree from top to bottom,\r\nwe can construct the correct coloring in time.Another way is to use\r\ndynamic programming : whether it is possible to color \u00e2\u0080\u0099s subtree to\r\nobtain disbalance so that all vertices except have neighbors of opposite\r\ncolor, and has such a neighbor iff . Since it is enough to limit\r\ndisbalance by , we can conclude that the number of states, the number of\r\ntransitions, and the time complexity are all .\r\n"
}