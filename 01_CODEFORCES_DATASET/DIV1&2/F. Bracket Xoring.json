{
    "link": "https://codeforces.com//contest/1896/problem/F",
    "problemId": "2346410",
    "problem_idx": "F",
    "shortId": "1896F",
    "contest_number": "1896",
    "problem_submissions": {
        "H2": [
            234305435,
            234294276,
            234316807,
            234293989,
            234307453,
            234313145,
            234308430,
            234674727,
            234674461,
            234674412,
            234348461,
            234317754,
            234317500
        ],
        "H1": [
            234300435,
            234288752,
            234294076,
            234304469,
            234296832,
            234303366,
            234305063,
            234305336,
            234301810,
            234292381
        ],
        "G": [
            234290728,
            234312960,
            234419627,
            234295328,
            234299457,
            234326268,
            234302972,
            234306994,
            234344999,
            234302897,
            234304455,
            234306035,
            234296895,
            234525586
        ],
        "F": [
            234279344,
            234262280,
            234278356,
            234281909,
            234284183,
            234288595,
            234278118,
            234284621,
            234280975,
            234283777,
            234307968,
            234293096,
            234293697,
            234294644,
            234304686,
            234282511,
            234279944,
            234277321
        ],
        "E": [
            234266080,
            234275828,
            234270895,
            234263950,
            234269369,
            234263464,
            234267763,
            234270201,
            234272007,
            234268761,
            234270245,
            234285745,
            234275911,
            234277731,
            234273316,
            234269329,
            234260178,
            234268619,
            234263914
        ],
        "D": [
            234260515,
            234269507,
            234266479,
            234257220,
            234264143,
            234256547,
            234261136,
            234260603,
            234265661,
            234261124,
            234261787,
            234269263,
            234266704,
            234265834,
            234268166,
            234280921,
            234253907,
            234259650,
            234255630
        ],
        "C": [
            234253899,
            234266056,
            234253267,
            234251911,
            234261130,
            234253006,
            234255721,
            234254779,
            234258245,
            234287578,
            234255535,
            234262815,
            234255118,
            234261416,
            234262126,
            234255695,
            234249255,
            234253498,
            234251351
        ],
        "B": [
            234249421,
            234247262,
            234248984,
            234247486,
            234250283,
            234247863,
            234248979,
            234248837,
            234302894,
            234248804,
            234248842,
            234247845,
            234248167,
            234249751,
            234253337,
            234249856,
            234245662,
            234248853,
            234246737
        ],
        "A": [
            234245828,
            234244872,
            234245833,
            234244939,
            234247553,
            234244853,
            234245867,
            234245696,
            234303768,
            234246110,
            234245020,
            234245161,
            234244947,
            234245703,
            234249430,
            234244871,
            234244771,
            234245709,
            234244767
        ]
    },
    "name": "F. Bracket Xoring",
    "statement": "You are given a binary string s of length 2n where each element is\r\nmathtt{0} or\r\nmathtt{1}. You can do the following operation: Choose a balanced bracket\r\nsequence^\r\ndagger b of length 2n. For every index i from 1 to 2n in order, where\r\nb_i is an open bracket, let p_i denote the minimum index such that\r\nb[i,p_i] is a balanced bracket sequence. Then, we perform a range toggle\r\noperation^\r\nddagger from i to p_i on s. Note that since a balanced bracket sequence\r\nof length 2n will have n open brackets, we will do n range toggle\r\noperations on s. Your task is to find a sequence of no more than 10\r\noperations that changes all elements of s to\r\nmathtt{0}, or determine that it is impossible to do so. Note that you do\r\nhave to minimize the number of operations.Under the given constraints,\r\nit can be proven that if it is possible to change all elements of s to\r\nmathtt{0}, there exists a way that requires no more than 10 operations.^\r\ndagger A sequence of brackets is called balanced if one can turn it into\r\na valid math expression by adding characters + and 1. For example,\r\nsequences \"\", \"\", and \"\" are balanced, while \"\", \"\", and \"\" are not.^\r\nddagger If we perform a range toggle operation from l to r on a binary\r\nstring s, then we toggle all values of s_i such that l\r\nleq i\r\nleq r. If s_i is toggled, we will set s_i :=\r\nmathtt{0} if s_i =\r\nmathtt{1} or vice versa. For example, if s=\r\nmathtt{1000101} and we perform a range toggle operation from 3 to 5, s\r\nwill be changed to s=\r\nmathtt{1011001}.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\nint tab[nax];\n\nvector<string> wyn;\n\nvoid zrob(string s)\n{\n\twyn.push_back(s);\n\tint gl=0;\n\tfor (int i=0; i<2*n; i++)\n\t{\n\t\tif (s[i]=='(')\n\t\t{\n\t\t\tgl++;\n\t\t\tif (gl&1)\n\t\t\t\ttab[i+1]^=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (gl&1)\n\t\t\t\ttab[i+1]^=1;\n\t\t\tgl--;\n\t\t}\n\t}\n}\n\nint musz[nax];\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz+1);\n\tfor (int i=1; i<=2*n; i++)\n\t\ttab[i]=(wcz[i]-'0');\n\t{\n\t\tint p=0;\n\t\tfor (int i=1; i<=2*n; i++)\n\t\t\tp+=tab[i];\n\t\tif ((p&1) || tab[1]!=tab[2*n])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\twyn.clear();\n\t\n\t\n\tfor (int i=1; i<=2*n+7; i++)\n\t\tmusz[i]=0;\n\t\n\tfor (int i=2; i<2*n; i++)\n\t\tif (tab[i]!=musz[i-1])\n\t\t\tmusz[i]=1;\n\t//~ debug() << range(musz+1, musz+1+2*n);\n\t\n\t{\n\t\tstring s;\n\t\ts.push_back('(');\n\t\tfor (int i=2; i<2*n; i+=2)\n\t\t{\n\t\t\tif (musz[i])\n\t\t\t{\n\t\t\t\ts.push_back('(');\n\t\t\t\ts.push_back(')');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts.push_back(')');\n\t\t\t\ts.push_back('(');\n\t\t\t}\n\t\t}\n\t\ts.push_back(')');\n\t\tzrob(s);\n\t\ts=\"\";\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\ts.push_back('(');\n\t\t\ts.push_back(')');\n\t\t}\n\t\tzrob(s);\n\t}\n\t\n\tif (n>1)\n\t{\n\t\tstring s;\n\t\ts.push_back('(');\n\t\ts.push_back('(');\n\t\tfor (int i=3; i<2*n-1; i+=2)\n\t\t{\n\t\t\tif (musz[i])\n\t\t\t{\n\t\t\t\ts.push_back('(');\n\t\t\t\ts.push_back(')');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts.push_back(')');\n\t\t\t\ts.push_back('(');\n\t\t\t}\n\t\t}\n\t\ts.push_back(')');\n\t\ts.push_back(')');\n\t\tzrob(s);\n\t}\n\t\n\tif (tab[1])\n\t{\n\t\tstring s;\n\t\ts.push_back('(');\n\t\tfor (int i=1; i<n; i++)\n\t\t{\n\t\t\ts.push_back('(');\n\t\t\ts.push_back(')');\n\t\t}\n\t\ts.push_back(')');\n\t\tzrob(s);\n\t}\n\t\n\t\n\tfor (int i=1; i<=2*n; i++)\n\t\tassert(!tab[i]);\n\t\n\tprintf(\"%d\\n\", (int)wyn.size());\n\tfor (string i : wyn)\n\t{\n\t\tfor (char j : i)\n\t\t\tprintf(\"%c\", j);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Bracket Xoring.json",
    "editorial_link": "https://codeforces.com//blog/entry/122172",
    "editorial": "ProofSuppose there are open brackets and close brackets between\r\npositions and . Note that by definition of balanced bracket sequences. -\r\nCase 1: is an open bracket. Position will be toggled exactly times as of\r\nthe open brackets will be matched before position , and the remaining\r\nopen brackets will only be matched after position . This means that\r\nposition will be toggled only if is odd, and hence, must be odd as\r\nwell. - Case 2: is a close bracket. Position will be toggled exactly\r\ntimes as of the open brackets will be matched before , of the open\r\nbracket will be matched with position , and the remaining open brackets\r\nwill be matched after position . This means that position will be\r\ntoggled only if is even, and hence, must be even as well.\r\n"
}