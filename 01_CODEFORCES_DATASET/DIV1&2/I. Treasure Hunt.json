{
    "link": "https://codeforces.com//contest/1787/problem/I",
    "problemId": "1756752",
    "problem_idx": "I",
    "shortId": "1787I",
    "contest_number": "1787",
    "problem_submissions": {
        "I": [
            197474547,
            191162667,
            191147076,
            191159474,
            191182912,
            191180384,
            191173195,
            191158380,
            191159985,
            191279548,
            191153893,
            191147979,
            191219667,
            191170332
        ],
        "G": [
            191152988,
            191152586,
            191141714,
            191145745,
            191143792,
            191147352,
            191147519,
            191158898,
            191159891,
            191160943,
            191153438,
            191155040,
            191144883,
            191170407,
            191170114,
            191152547
        ],
        "F": [
            191146155,
            191132842,
            191134802,
            191136901,
            191128020,
            191139771,
            191139131,
            191147114,
            191152778,
            191144574,
            191147232,
            191145790,
            191135060,
            191146379,
            191144901,
            191136231,
            191134824,
            191143478,
            191143747,
            191145614
        ],
        "E": [
            191137894,
            191126319,
            191169100,
            191131011,
            191146734,
            191132024,
            191134009,
            191128652,
            191130752,
            191135324,
            191128162,
            191137413,
            191115850,
            191140133,
            191140025,
            191121022,
            191131209,
            191138279,
            191133339,
            191131279
        ],
        "D": [
            191132976,
            191120161,
            191124203,
            191123443,
            191137713,
            191128946,
            191128273,
            191122289,
            191126977,
            191131112,
            191124722,
            191125562,
            191128102,
            191135389,
            191135592,
            191131056,
            191123065,
            191127620,
            191126290,
            191127861
        ],
        "C": [
            191125268,
            191113889,
            191117948,
            191115059,
            191116269,
            191118107,
            191120001,
            191140669,
            191115010,
            191125411,
            191117705,
            191118998,
            191121343,
            191121072,
            191117056,
            191128472,
            191115952,
            191117237,
            191118951,
            191120349
        ],
        "B": [
            191121944,
            191109607,
            191111770,
            191108995,
            191110155,
            191109908,
            191113645,
            191109634,
            191109874,
            191121868,
            191110598,
            191110575,
            191117560,
            191109576,
            191110819,
            191112301,
            191110138,
            191111938,
            191108264,
            191111930
        ],
        "A": [
            191118000,
            191106352,
            191108603,
            191106770,
            191106814,
            191106284,
            191107425,
            191105859,
            191106157,
            191118169,
            191107747,
            191106297,
            191105730,
            191106101,
            191107070,
            191108687,
            191105956,
            191107701,
            191105869,
            191106761
        ],
        "H": [
            191116884,
            191151161,
            191155682,
            191157247,
            191138915,
            191146913,
            191162451,
            191161022,
            191128443,
            191126961,
            191251422,
            191150263,
            191149572,
            191156328
        ]
    },
    "name": "I. Treasure Hunt",
    "statement": "Define the of a sequence b_1,b_2,\r\nldots,b_c as the maximum value of\r\nsum\r\nlimits_{i=1}^{q}b_i +\r\nsum\r\nlimits_{i=s}^{t}b_i, where q, s, t are all integers and s > q or t\r\nleq q. Note that b_i = 0 when i<1 or i>c,\r\nsum\r\nlimits_{i=s}^{t}b_i = 0 when s>t.For example, when b = [-1,-2,-3], we\r\nmay have q = 0, s = 3, t = 2 so the value is 0 + 0 = 0. And when b =\r\n[-1,2,-3], we have q = s = t = 2 so the value is 1 + 2 = 3.You are given\r\na sequence a of length n, determine the sum of the of all non-empty\r\nsubsegments a_l,a_{l+1},\r\nldots,a_r (1\r\nleq l\r\nleq r\r\nleq n) of the sequence a.Print the answer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(), (a).end()\nconst int mod = 998244353;\nconst int MAXN = 500005;\nstruct mint {\n\tint val;\n\tmint() { val = 0; }\n\tmint(const lint &v) {\n\t\tval = (-mod <= v && v < mod) ? v : v % mod;\n\t\tif (val < 0)\n\t\t\tval += mod;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const mint &a) { return os << a.val; }\n\tfriend bool operator==(const mint &a, const mint &b) { return a.val == b.val; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.val < b.val; }\n\n\tmint operator-() const { return mint(-val); }\n\tmint &operator+=(const mint &m) {\n\t\tif ((val += m.val) >= mod)\n\t\t\tval -= mod;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &m) {\n\t\tif ((val -= m.val) < 0)\n\t\t\tval += mod;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &m) {\n\t\tval = (lint)val * m.val % mod;\n\t\treturn *this;\n\t}\n\tfriend mint ipow(mint a, lint p) {\n\t\tmint ans = 1;\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1)\n\t\t\t\tans *= a;\n\t\treturn ans;\n\t}\n\tmint inv() const { return ipow(*this, mod - 2); }\n\tmint &operator/=(const mint &m) { return (*this) *= m.inv(); }\n\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n\toperator int64_t() const { return val; }\n};\n\ntemplate <typename T> struct fenwick {\n\tarray<T, 2> tree[MAXN], total;\n\tint thres;\n\tvoid add(int x, array<T, 2> v) {\n\t\ttotal[0] += v[0];\n\t\ttotal[1] += v[1];\n\t\tfor (int i = x + 1; i < thres + 3; i += i & -i) {\n\t\t\ttree[i][0] += v[0];\n\t\t\ttree[i][1] += v[1];\n\t\t}\n\t}\n\tarray<T, 2> query(int x) {\n\t\tarray<T, 2> ret = {T(0), T(0)};\n\t\tfor (int i = x + 1; i; i -= i & -i) {\n\t\t\tret[0] += tree[i][0];\n\t\t\tret[1] += tree[i][1];\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid clear() {\n\t\ttotal = {T(0), T(0)};\n\t\tfor (int i = 0; i < thres + 3; i++)\n\t\t\ttree[i] = total;\n\t}\n};\n\nfenwick<mint> bit;\nvector<pi> a, b;\n\ntemplate <typename T> T merge(vector<int> &L, vector<int> &R) {\n\ta.resize(sz(L));\n\tb.resize(sz(R));\n\t{\n\t\tlint sum = 0, pmaxsum = -1e18;\n\t\tlint cur = 0, opt = -1e18;\n\t\tfor (int i = 0; i < sz(L); i++) {\n\t\t\tsum += L[i];\n\t\t\tpmaxsum = max(pmaxsum, sum);\n\t\t\tcur = max(cur, 0ll) + L[i];\n\t\t\topt = max(opt, cur);\n\t\t\ta[i] = pi{pmaxsum, opt};\n\t\t}\n\t}\n\t{\n\t\tlint sum = 0, pmaxsum = -1e18;\n\t\tlint cur = 0, opt = -1e18;\n\t\tfor (int i = 0; i < sz(R); i++) {\n\t\t\tsum += R[i];\n\t\t\tpmaxsum = max(pmaxsum, sum);\n\t\t\tcur = max(cur, 0ll) + R[i];\n\t\t\topt = max(opt, cur);\n\t\t\tb[i] = pi{pmaxsum, opt};\n\t\t}\n\t}\n\tT ret = T(0);\n\t{\n\t\tint p = 0;\n\t\tvector<lint> vect;\n\t\tfor (int j = 0; j < sz(b); j++) {\n\t\t\tvect.push_back(b[j][0]);\n\t\t}\n\t\tsort(all(vect));\n\t\tvect.resize(unique(all(vect)) - vect.begin());\n\t\tvector<int> comp(sz(b));\n\t\tfor (int i = 0; i < sz(b); i++) {\n\t\t\tcomp[i] = lower_bound(all(vect), b[i][0]) - vect.begin();\n\t\t}\n\t\tbit.thres = sz(vect);\n\t\tint lo;\n\t\tfor (int i = 0; i < sz(a); i++) {\n\t\t\twhile (p < sz(b) && b[p][1] < a[i][1]) {\n\t\t\t\tbit.add(comp[p], {T(1), T(b[p][0])});\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret += T(p) * T(a[i][0]);\n\t\t\tif (i == 0 || a[i - 1][1] - a[i - 1][0] != a[i][1] - a[i][0]) {\n\t\t\t\tlo = lower_bound(all(vect), a[i][1] - a[i][0]) - vect.begin();\n\t\t\t}\n\t\t\tauto sol1 = bit.query(lo - 1);\n\t\t\tauto sol2 = bit.total;\n\t\t\tret += (sol2[1] - sol1[1]) + T(a[i][1] - a[i][0]) * (sol1[0]);\n\t\t}\n\t\tbit.clear();\n\t}\n\t{\n\t\tswap(a, b);\n\t\tint p = 0;\n\t\tvector<lint> vect;\n\t\tfor (int j = 0; j < sz(b); j++) {\n\t\t\tvect.push_back(b[j][0]);\n\t\t}\n\t\tsort(all(vect));\n\t\tvect.resize(unique(all(vect)) - vect.begin());\n\t\tbit.thres = sz(vect);\n\t\tvector<int> comp(sz(b));\n\t\tfor (int i = 0; i < sz(b); i++) {\n\t\t\tcomp[i] = lower_bound(all(vect), b[i][0]) - vect.begin();\n\t\t}\n\t\tint lo;\n\t\tfor (int i = 0; i < sz(a); i++) {\n\t\t\twhile (p < sz(b) && b[p][1] <= a[i][1]) {\n\t\t\t\tbit.add(comp[p], {T(1), T(b[p][0])});\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret += T(p) * T(a[i][0]);\n\t\t\tif (i == 0 || a[i - 1][1] - a[i - 1][0] != a[i][1] - a[i][0]) {\n\t\t\t\tlo = lower_bound(all(vect), a[i][1] - a[i][0]) - vect.begin();\n\t\t\t}\n\t\t\tauto sol1 = bit.query(lo - 1);\n\t\t\tauto sol2 = bit.total;\n\t\t\tret += (sol2[1] - sol1[1]) + T(a[i][1] - a[i][0]) * (sol1[0]);\n\t\t}\n\t\tbit.clear();\n\t}\n\treturn ret;\n}\n\ntemplate <typename T> T solve(int s, int e, vector<int> &a) {\n\tif (s == e)\n\t\treturn T(a[s]);\n\tvector<int> L, R;\n\tint m = (s + e) / 2;\n\tfor (int i = m; i >= s; i--)\n\t\tL.push_back(a[i]);\n\tfor (int i = m + 1; i <= e; i++)\n\t\tR.push_back(a[i]);\n\tT ret = merge<T>(L, R);\n\treturn ret + solve<T>(s, m, a) + solve<T>(m + 1, e, a);\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tauto maxhap = [&](vector<lint> &a) {\n\t\tint n = sz(a);\n\t\tmint ret = 0;\n\t\tvector<int> l(n, -1), r(n, n);\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\twhile (sz(stk) && a[stk.back()] < a[i]) {\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t\tif (sz(stk))\n\t\t\t\t\tl[i] = stk.back();\n\t\t\t\tstk.push_back(i);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\twhile (sz(stk) && a[stk.back()] <= a[i]) {\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t\tif (sz(stk))\n\t\t\t\t\tr[i] = stk.back();\n\t\t\t\tstk.push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret += mint(r[i] - i) * mint(i - l[i]) * mint(a[i]);\n\t\t}\n\t\treturn ret;\n\t};\n\n\tint tc;\n\tcin >> tc;\n\twhile (tc--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &x : a)\n\t\t\tcin >> x;\n\t\tmint ans = solve<mint>(0, n - 1, a);\n\t\tfor (int i = 0; i < n;) {\n\t\t\tif (a[i] >= 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i;\n\t\t\tvector<lint> v;\n\t\t\twhile (j < n && a[j] < 0) {\n\t\t\t\tv.push_back(a[j++]);\n\t\t\t}\n\t\t\tans -= maxhap(v);\n\t\t\ti = j;\n\t\t}\n\t\tvector<lint> b(n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tb[i] = b[i - 1] + a[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans -= mint(n - i + 1) * mint(b[i]);\n\t\t}\n\t\tans -= mint(b[n]);\n\t\tans += maxhap(b);\n\t\tcout << ans << \"\\n\";\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "two pointers"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Treasure Hunt.json",
    "editorial_link": "https://codeforces.com//blog/entry/112009",
    "editorial": "First, we observe that: .Proof: We can proof it by contradiction. Define\r\nas . Suppose when hits the maximum value. If , , otherwise . So the\r\nabove observation is always correct.So we can divide the problem into\r\ntwo parts: and .For , itâs easy to solve it by using a stack to\r\ncalculate the prefix maximum value, and then calculate the answer.And\r\nfor , consider divide and conquer. For a part ,let . Define as . We want\r\nto calculate the sum of satisfied . Obviously , and itâs easy to\r\ncalculate above four value in the time complexity of . We can use binary\r\nsearch to calculate the maximum value. So the problem can be solved in\r\nthe time complexity of .But itâs not good enough. We can solve it in the\r\ntime complexity of based on the following theorem:Define as . is\r\nnon-decreasing.Proof: Actually, if we extend the first theorem, we will\r\nfind or :If , so . When we add an element at the back of the sequence:\r\nIf , and become at the same time. So since . Otherwise if , while . So\r\nthe theorem always holds in this circumstance.If , , so the theorem\r\nholds too.Because of the theorem, we can replace binary search by two\r\npointers. So the final time complexity is .\r\n",
    "hint": []
}