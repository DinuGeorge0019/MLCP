{
    "link": "https://codeforces.com//contest/1025/problem/D",
    "problemId": "209739",
    "problem_idx": "D",
    "shortId": "1025D",
    "contest_number": "1025",
    "problem_submissions": {
        "E": [
            41858738,
            41856429,
            41850768,
            41855385,
            41852484,
            41858727,
            41848268,
            41855122,
            41883001,
            41858915,
            41855225,
            41852858,
            41868516,
            41860862,
            41856872,
            41860887,
            41851802
        ],
        "F": [
            41848629,
            41847210,
            41861209,
            41860806,
            41863443,
            41862402,
            41853998,
            41862178,
            41845081,
            41877837,
            41887505,
            41887279,
            41887255,
            41878485,
            41856047,
            41861957,
            41858912,
            41906629,
            41858319,
            41868413
        ],
        "D": [
            41845183,
            41851596,
            41961545,
            41841784,
            41841903,
            41840812,
            41849010,
            41840988,
            41846701,
            41841230,
            41874808,
            41841578,
            41847099,
            41842212,
            41945631,
            41911317,
            41911277,
            41878022,
            41877990,
            41877935,
            41874708,
            41874699,
            41874650,
            41873983,
            41873792,
            41873701,
            41873477,
            41849952,
            41843783,
            41842954,
            41842230,
            41844472,
            41848949,
            41844612
        ],
        "C": [
            41839685,
            41838607,
            41835815,
            41834650,
            41838762,
            41837233,
            41866845,
            41840107,
            41835687,
            41833279,
            41836241,
            41835918,
            41839785,
            41834860,
            41839690,
            41836558,
            41837913,
            41843576,
            41837629
        ],
        "A": [
            41835541,
            41829219,
            41829281,
            41828966,
            41829689,
            41834202,
            41835387,
            41829112,
            41829095,
            41842587,
            41837894,
            41829018,
            41830134,
            41829065,
            41830329,
            41829109,
            41829662,
            41832973,
            41831018
        ],
        "B": [
            41832044,
            41834103,
            41852766,
            41831349,
            41836588,
            41831557,
            41837237,
            41833957,
            41833253,
            41830677,
            41832816,
            41833177,
            41836737,
            41831907,
            41867411,
            41832885,
            41833414,
            41837270,
            41834779
        ],
        "G": [
            41866839,
            41868176,
            42077886,
            41877542,
            41872667,
            41951029,
            41921003
        ]
    },
    "name": "D. Recovering BST",
    "statement": "Dima the hamster enjoys nibbling different things: cages, sticks, bad\r\nproblemsetters and even trees!Recently he found a binary search tree and\r\ninstinctively nibbled all of its edges, hence messing up the vertices.\r\nDima knows that if Andrew, who has been thoroughly assembling the tree\r\nfor a long time, comes home and sees his creation demolished, he’ll get\r\nextremely upset. To not let that happen, Dima has to recover the binary\r\nsearch tree. Luckily, he noticed that any two vertices connected by a\r\ndirect edge had their greatest common divisor value exceed 1.Help Dima\r\nconstruct such a or determine that it’s impossible. The definition and\r\nproperties of a binary search tree can be found here.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 710;\nbitset<N> dp[N][N];\nbitset<N> can[N];\nbitset<N> root_right[N];\nbitset<N> root_left[N];\nint a[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    cin>>a[i];\n  }\n  RE (i, n) {\n    RE (j, n) {\n      can[i][j] = __gcd(a[i], a[j]) > 1;\n    }\n  }\n  bitset<N> full;\n  REP (i, N) {\n    full[i] = 1;\n  }\n  REP (i, N) {\n    REP (j, N) {\n      if (i >= j) {\n        root_right[i][j] = 1;\n        root_left[i][j] = 1;\n      }\n    }\n  }\n  RE (len, n) {\n    bitset<N> slide;\n    RE (i, len) {\n      slide[i] = 1;\n    }\n    RE (i, n - len + 1) {\n      \n      int j = i + len - 1;\n      slide[i - 1] = 0;\n      slide[j] = 1;\n      dp[i][j] = root_right[i] & root_left[j] & slide;\n//       FOR (k, i, j) {\n//         dp[i][j][k] = 1;\n//         if (k != i) {\n//           if (root_right[i][k] == 0) {\n//             dp[i][j][k] = 0;\n//           }\n//         }\n//         if (k != j) {\n//           if (root_left[k][j] == 0) {\n//             dp[i][j][k] = 0;\n//           }\n//         }\n      root_right[i][j + 1] = (dp[i][j] & can[j + 1]).any();\n      root_left[j][i - 1] = (dp[i][j] & can[i - 1]).any();\n//         if (dp[i][j][k] && can[k][i - 1]) {\n//           root_left[i - 1][j] = 1;\n//         }\n//         if (dp[i][j][k] && can[k][j + 1]) {\n//           root_right[i][j + 1] = 1;\n//         }\n//       }\n    }\n  }\n  int any = 0;\n  RE (i, n) {\n    any |= dp[1][n][i];\n  }\n  if (any) {\n    cout<<\"Yes\\n\";\n  } else {\n    cout<<\"No\\n\";\n  }\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Recovering BST.json",
    "editorial_link": "https://codeforces.com//blog/entry/61323",
    "editorial": "Let be a dp determining whether itâs possible to assemble a tree rooted\r\nat from the subsegment .Itâs easy to see that calculating it requires\r\nextracting such from and from that: ; ; ; . This can be done in provided\r\nwe are given all values for all subsegments of . Considering a total of\r\ndp states, the final complexity is . Thatâs too much.Letâs turn our dp\r\ninto where can be either or is it possible to make a tree from rooted at\r\nor respectively. It immediately turns out that is inherited form and .\r\nNow we have states, but at the same time all transitions are performed\r\nin linear time; thus final complexity is which is sufficient to pass.\r\n",
    "hint": []
}