{
    "link": "https://codeforces.com//contest/1870/problem/F",
    "problemId": "2216419",
    "problem_idx": "F",
    "shortId": "1870F",
    "contest_number": "1870",
    "problem_submissions": {
        "G": [
            225207978,
            225118072,
            225116519,
            225114767,
            225113735,
            225113326,
            223895142,
            223905506,
            223908839,
            223914354,
            223924067,
            223915464,
            224102694,
            224102570,
            224101929,
            224101915,
            224101882,
            223930185,
            223922526,
            223898384,
            223902193
        ],
        "H": [
            223910262,
            223971766,
            225204927,
            223912817
        ],
        "F": [
            223881664,
            223880000,
            223885884,
            223900845,
            223885822,
            223925076,
            223908747,
            223887023,
            223881416,
            223893441,
            223967145,
            223892630,
            223898214,
            223897234,
            223895227,
            223893254,
            223897195,
            223887464,
            223885585,
            223897533
        ],
        "E": [
            223869750,
            223870667,
            223875420,
            223879930,
            223894576,
            223875622,
            223877104,
            223888049,
            223879090,
            223876643,
            223870896,
            223878535,
            223873841,
            223880057,
            223880667,
            223881985,
            223871304,
            223980583,
            223900716,
            223895756,
            223883035
        ],
        "D": [
            223864393,
            223860234,
            223865660,
            223863718,
            223865473,
            223859881,
            223865206,
            223867969,
            223868314,
            223865007,
            223866155,
            223863717,
            223863491,
            223869388,
            223869302,
            223866987,
            223863771,
            223868821,
            223873483,
            223869884
        ],
        "C": [
            223858926,
            223856692,
            223860376,
            223856772,
            223861967,
            223857013,
            223862311,
            223860027,
            223860530,
            223857444,
            223858871,
            223859210,
            223859070,
            223862641,
            223864669,
            223860558,
            223859030,
            223856443,
            223870325,
            223863825
        ],
        "B": [
            223855786,
            223853418,
            223854541,
            223852626,
            223857522,
            223852531,
            223856711,
            223853615,
            223855334,
            223852785,
            223853742,
            223853640,
            223854539,
            223856641,
            223856452,
            223856337,
            223854108,
            223864851,
            223860995,
            223858101
        ],
        "A": [
            223852532,
            223851971,
            223852416,
            223851983,
            223854260,
            223851952,
            223853042,
            223852087,
            223852502,
            223853463,
            223852096,
            223852189,
            223852238,
            223852875,
            223853328,
            223852660,
            223852270,
            223860422,
            223858579,
            223854841
        ]
    },
    "name": "F. Lazy Numbers",
    "statement": "You are given positive integers n and k. For each number from 1 to n, we\r\nwrite its representation in the number system with base k (without\r\nleading zeros) and then sort the resulting array in lexicographic order\r\nas strings. In the sorted array, we number the elements from 1 to n\r\n(i.e., indexing starts from 1). Find the number of values i such that\r\nthe representation of number i is at the i-th position in the sorted\r\narray of representations.Examples of representations: 1 in any number\r\nsystem is equal to 1, 7 with k = 3 is written as 21, and 81 with k = 9\r\nis written as 100.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 5007, S = 8300, M = 8192;\n#define i128 __int128\nll n, k; \n\nint top;\nll L[N], R[N]; \n\nll get(ll x) {\n\tint cur = 1;\n\twhile(x > R[cur]) {\n\t\t++cur;\n\t}\n\t\n\tll ans = -x + 1;\n\tll mul = 1;\n\tR(i, cur - 1, 1) {\n\t\tmul *= k, ans += x / mul - L[i] + 1;\n\t}\n\tmul = 1;\n\tL(i, cur, top) \n\t\tans += min((i128)x * mul - 1, (i128)n) - L[i] + 1, mul *= k;\n\treturn ans;\n}\nvoid Main() {\n\tcin >> n >> k;\n\tif(n < k) {\n\t\tcout << n << '\\n';\n\t\treturn ;\n\t}\n\t\n\ttop = 0;\n\ti128 l = 1, r;\n\tint cnt = 0;\n\tfor(; l <= n; l = r + 1) {\n\t\tr = l * k - 1;\n\t\tr = min(r, (i128) n);\n\t\t++top;\n\t\tL[top] = l;\n\t\tR[top] = r;\n\t}\n\t\n\tll ans = 0;\n\tL(i, 1, top) {\n\t\tll ansl = R[i] + 1, ansr = R[i] + 1;\n\t\t// go up \n\t\t{\n\t\tll l = L[i], r = R[i];\n\t\twhile(l <= r) {\n\t\t\tll mid = (l + r) >> 1;\n\t\t\tif(get(mid) >= 0) {\n\t\t\t\tansl = mid, r = mid - 1;\n\t\t\t} else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\t{\n\t\tll l = L[i], r = R[i];\n\t\twhile(l <= r) {\n\t\t\tll mid = (l + r) >> 1;\n\t\t\tif(get(mid) > 0) {\n\t\t\t\tansr = mid, r = mid - 1;\n\t\t\t} else {\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tans += ansr - ansl;\n\t}\n\tcout << ans << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "math"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Lazy Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/120524",
    "editorial": "Tutorial Let\u00e2\u0080\u0099s store all the number entries in a trie. Consider two\ntraversals of this trie depth-first search (DFS) and breadth-first\nsearch (BFS). In both traversals, we go to the children of a node in\nascending order of the number on the edge (in the trie). Let the index\nof the node representing the number in the DFS traversal be , and in the\nBFS traversal be . Then notice that , as in BFS on the trie, we simply\nlook at all the number entries with a certain length in order (lengths\nare concidered in increasing order). On the other hand, is the index of\nthe number entry in the sorted array. Therefore, we want to calculate\nthe number of for which .Let\u00e2\u0080\u0099s fix a layer in the trie, meaning we only\nconsider numbers with a fixed, equal length of representation. Then\nlet\u00e2\u0080\u0099s look at for the numbers in this layer. Notice that for two numbers\nand in this layer, it holds that , and . This means that for a fixed\nlayer, the function is non-decreasing. Therefore, we can find the of\nthis function using binary search on each layer.Now let\u00e2\u0080\u0099s learn how to\ncalculate . , which we can calculate. To find , we can traverse up from\nthe trie node corresponding to , and at each step, add the sizes of the\nsubtrees that we have traversed in DFS before the subtree with the node\n.The trie has a depth of , binary search takes the same time, so the\noverall asymptotic complexity of the solution is .I apologize for the\nissues some participants faced with the time limit, if they implemented\nthe author\u00e2\u0080\u0099s idea suboptimally.\n"
}