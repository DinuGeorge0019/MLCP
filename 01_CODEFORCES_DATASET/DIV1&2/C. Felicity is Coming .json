{
    "link": "https://codeforces.com//contest/757/problem/C",
    "problemId": "88530",
    "problem_idx": "C",
    "shortId": "757C",
    "contest_number": "757",
    "problem_submissions": {
        "F": [
            32228238,
            32220657,
            32216667,
            32216552,
            30180757,
            24068926,
            24068888,
            24068798,
            24068629,
            24068020,
            23762892,
            23760952,
            23776891,
            23764568,
            23762696,
            23763271,
            23761197,
            23764419,
            23761836,
            23846483,
            23765505,
            23762407,
            23766587,
            23766646,
            23767253,
            23767207,
            23767008,
            23767913,
            23761400
        ],
        "G": [
            23782048,
            23772049,
            23771661,
            23771463
        ],
        "D": [
            23749937,
            23749579,
            23748811,
            23749322,
            23755716,
            23754682,
            23757768,
            23754805,
            23755156,
            23752956,
            23758947,
            23752935,
            23758202,
            23754949,
            23757044,
            23760439,
            23761231,
            23760141,
            23748525
        ],
        "C": [
            23747486,
            23744300,
            23743556,
            23745034,
            23746542,
            23748856,
            23755316,
            23748726,
            23749207,
            23747491,
            23752146,
            23747894,
            23750245,
            23746080,
            23751561,
            23747227,
            23747661,
            23744168
        ],
        "E": [
            23746626,
            23754640,
            23751784,
            23751547,
            23750068,
            23759139,
            23752714,
            23760482,
            23759055,
            23761627,
            23755834,
            23761719,
            23760932,
            23763128,
            23759765,
            23757483,
            23764011,
            23741658,
            23752894
        ],
        "B": [
            23740589,
            23741483,
            23740480,
            23740520,
            23742781,
            23741337,
            23746337,
            23742823,
            23741509,
            23741548,
            23745601,
            23743745,
            23742092,
            23740912,
            23741886,
            23742317,
            23743047,
            23746203,
            23741743
        ],
        "A": [
            23740335,
            23739759,
            23739764,
            23739789,
            23739801,
            23739786,
            23739911,
            23740392,
            23739871,
            23740001,
            23740128,
            23739744,
            23740216,
            23765002,
            23754212,
            23766705,
            23742440,
            23748544,
            23739773
        ]
    },
    "name": "C. Felicity is Coming ",
    "statement": "It\u2019s that time of the year, Felicity is around the corner and you can\r\nsee people celebrating all around the Himalayan region. The Himalayan\r\nregion has gyms. The -th gym has Pokemon in it. There are distinct\r\nPokemon types in the Himalayan region numbered from to . There is a\r\nspecial evolution camp set up in the fest which claims to evolve any\r\nPokemon. The type of a Pokemon could change after evolving, subject to\r\nthe constraint that if two Pokemon have the same type before evolving,\r\nthey will have the same type after evolving. Also, if two Pokemon have\r\ndifferent types before evolving, they will have different types after\r\nevolving. It is also possible that a Pokemon has the same type before\r\nand after evolving. Formally, an is a permutation of , such that means\r\nthat a Pokemon of type evolves into a Pokemon of type .The gym leaders\r\nare intrigued by the special evolution camp and all of them plan to\r\nevolve their Pokemons. The protocol of the mountain states that in each\r\ngym, for every type of Pokemon, the number of Pokemon of that type\r\nbefore evolving any Pokemon should be equal the number of Pokemon of\r\nthat type after evolving all the Pokemons according to the evolution\r\nplan. They now want to find out how many distinct exist which satisfy\r\nthe protocol.Two evolution plans and are distinct, if they have at least\r\none Pokemon type evolving into a different Pokemon type in the two\r\nplans, i. e. there exists an such that .Your task is to find how many\r\ndistinct are possible such that if all Pokemon in all the gyms are\r\nevolved, the number of Pokemon of each type in each of the gyms remains\r\nthe same. As the answer can be large, output it modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\nconst int N = 1234567;\n\nvector <int> a[N];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    while (foo--) {\n      int bar;\n      scanf(\"%d\", &bar);\n      a[bar].push_back(i);\n    }\n  }\n  sort(a + 1, a + m + 1);\n  int ans = 1;\n  int t = 1;\n  for (int i = 2; i <= m; i++) {\n    if (a[i] == a[i - 1]) {\n      t++;\n      ans = (long long) ans * t % md;\n    } else {\n      t = 1;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing",
        "sortings",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Felicity is Coming .json",
    "editorial_link": "https://codeforces.com//blog/entry/49743",
    "editorial": "Main idea: Divide pokemon types into equivalence classes based on their counts in each list.\n\nConsider a valid evolution plan f. Let c[p,?g] be the number of times Pokemon p appears in gym g. If f(p)?=?q then .\n\nNow consider a group of Pokemon P such that all of them occur equal number of times in each gym (i.e. for each ). Any permutation of this group would be a valid bijection.\n\nSay we have groups s1,?s2,?s3,?..., then the answer would be |s1|!?|s2|!?|s3|!?... ?mod?109?+?7.\n\nFor implementing groups, we can use vector?<?vector?<?int?>??>? and for i-th pokemon, add the index of the gym to i-th vector.\n\nNow we need to find which of these vectors are equal. If we have the sorted vector?<?vector?<?int?>??>?, we can find equal elements by iterating over it and comparing adjacent elements.\n\nConsider the merge step of merge sort. For a comparison between 2 vectors v1 and v2, we cover at least min(v1.size(),?v2.size()) elements. Hence  work is done at each level. There are  levels.\n"
}