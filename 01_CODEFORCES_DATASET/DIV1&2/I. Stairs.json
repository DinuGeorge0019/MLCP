{
    "link": "https://codeforces.com//contest/1553/problem/I",
    "problemId": "1054401",
    "problem_idx": "I",
    "shortId": "1553I",
    "contest_number": "1553",
    "problem_submissions": {
        "D": [
            169191520,
            123296941,
            123297806,
            123297663,
            123302145,
            123308082,
            123355626,
            123288615,
            123300005,
            123355719,
            123297926,
            123297145,
            123301190,
            123300345,
            123299820,
            123296403,
            123414687,
            123301042
        ],
        "H": [
            123620131,
            123313713,
            123332871,
            123326771,
            123329496,
            123333989,
            123327301,
            123320158,
            123330448,
            123338196,
            123333236,
            123338401,
            123339450,
            123342781,
            123346257,
            123330113,
            123344278,
            123343331,
            123340506,
            123344699
        ],
        "I": [
            123385111,
            123378631,
            123333612,
            123339868,
            123334989,
            123340246,
            123340158,
            123346691,
            123345519,
            123347924,
            123346852,
            123345828,
            123329031,
            123548176,
            123381216,
            123337606
        ],
        "G": [
            123322139,
            123324013,
            123321746,
            123321324,
            123324373,
            123338543,
            123315387,
            123310652,
            123325687,
            123319695,
            123350018,
            123330904,
            123330071,
            123330047,
            123346137,
            123335160,
            123331375,
            123334289,
            123332355,
            123335282
        ],
        "F": [
            123306764,
            123309877,
            123310012,
            123392723,
            123310903,
            123315821,
            123307909,
            123309621,
            123319362,
            123318112,
            123308206,
            123352164,
            123324585,
            123316981,
            123321240,
            123314522,
            123303931,
            123317244,
            123313175,
            123319108,
            123319049
        ],
        "E": [
            123300512,
            123302793,
            123299691,
            123304552,
            123309312,
            123320116,
            123302497,
            123304058,
            123306678,
            123300713,
            123324247,
            123303928,
            123305621,
            123309549,
            123305199,
            123316284,
            123309014,
            123300003,
            123313006,
            123309633
        ],
        "C": [
            123294603,
            123295240,
            123286810,
            123296632,
            123299566,
            123315601,
            123293486,
            123297325,
            123297140,
            123294686,
            123300590,
            123295373,
            123294039,
            123298187,
            123296026,
            123297131,
            123295966,
            123292213,
            123298615,
            123298316
        ],
        "B": [
            123289760,
            123290630,
            123290780,
            123294146,
            123295752,
            123312695,
            123293947,
            123360805,
            123291933,
            123289878,
            123293488,
            123291285,
            123290092,
            123293677,
            123291240,
            123302534,
            123292951,
            123288227,
            123295004,
            123294200
        ],
        "A": [
            123284749,
            123284683,
            123291431,
            123285002,
            123285048,
            123309755,
            123284637,
            123297912,
            123285183,
            123284625,
            123284798,
            123284624,
            123284941,
            123285138,
            123284922,
            123289388,
            123284597,
            123284633,
            123285043,
            123286496
        ]
    },
    "name": "I. Stairs",
    "statement": "For a permutation p of numbers 1 through n, we define a a as follows:\r\na_i is length of the longest segment of permutation which contains\r\nposition i and is made of consecutive values in sorted order: [x, x+1,\r\nldots, y-1, y] or [y, y-1,\r\nldots, x+1, x] for some x\r\nleq y. For example, for permutation p = [4, 1, 2, 3, 7, 6, 5] we have a\r\n= [1, 3, 3, 3, 3, 3, 3]. You are given the stair array a. Your task is\r\nto calculate the number of permutations which have stair array equal to\r\na. Since the number can be big, compute it modulo 998\r\n,244\r\n,353. Note that this number can be equal to zero.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$. \n \t* For XOR convolution ignore \\texttt{m} within \\texttt{fft}. \n * Time: O(N\\log N)\n * Source: \n \t* KACTL (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n \t* https://cp-algorithms.com/algebra/fft.html\n \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n \t* maroonrk\n \t* https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp\n * Verification: \n\t* https://judge.yosupo.jp/problem/convolution_mod\n\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding\n\t* http://codeforces.com/contest/632/problem/E\n */\n\n// #include \"ModInt.h\"\n// const int MOD = 998244353;\n\ntemplate<class T> void fft(V<T>& A, bool inv = 0) { // NTT\n\tint n = sz(A); assert((T::mod-1)%n == 0); V<T> B(n);\n\tfor(int b = n/2; b; b /= 2, swap(A,B)) {\n\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1; // n/b'th root of unity\n\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {\n\t\t\tT u = A[i+j], v = A[i+j+b]*m;\n\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;\n\t\t}\n\t}\n\tif (inv) { reverse(1+all(A)); \n\t\tT z = T(1)/T(n); each(t,A) t *= z; }\n}\ntemplate<class T> V<T> mul(V<T> A, V<T> B) { // only special moduli for NTT\n\tif (!min(sz(A),sz(B))) return {};\n\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);\n\tbool eq = A == B; A.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i,n) A[i] *= B[i];\n\tfft(A,1); A.rsz(s); return A;\n}\ntemplate<class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T>& v) {\n\t\tV<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];\n\t\treturn w; };\n\treturn mul(con(x),con(y));\n}\ntemplate<class T> V<T> MUL(const V<T>& A, const V<T>& B) { // arbitrary moduli\n\tusing m0 = mint<(119<<23)+1,62>; auto c0 = mulMod<m0>(A,B);\n\tusing m1 = mint<(5<<25)+1,  62>; auto c1 = mulMod<m1>(A,B);\n\tusing m2 = mint<(7<<26)+1,  62>; auto c2 = mulMod<m2>(A,B);\n\tint n = sz(c0); V<T> res(n);\n\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);\n\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;\n\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod\n\t}\n\treturn res;\n}\n\n/**\n * Description: Basic poly ops including division. Can replace \\texttt{T} with double, complex.\n * Source: Own. Also see\n\t* https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/PolyInterpolate.h\n\t* https://github.com/ecnerwala/icpc-book/blob/master/content/numerical/fft.cpp\n * Verification: see FFT\n */\n\n// #include \"../../number-theory (11.1)/Modular Arithmetic/ModInt.h\"\n\nusing T = mi; using poly = V<T>;\nvoid remz(poly& p) { while (sz(p)&&p.bk==T(0)) p.pop_back(); }\npoly REMZ(poly p) { remz(p); return p; }\npoly rev(poly p) { reverse(all(p)); return p; }\npoly shift(poly p, int x) { \n\tif (x >= 0) p.insert(begin(p),x,0); \n\telse assert(sz(p)+x >= 0), p.erase(begin(p),begin(p)-x);\n\treturn p; \n}\npoly RSZ(const poly& p, int x) { \n\tif (x <= sz(p)) return poly(begin(p),begin(p)+x);\n\tpoly q = p; q.rsz(x); return q;  }\nT eval(const poly& p, T x) { // evaluate at point x\n\tT res = 0; R0F(i,sz(p)) res = x*res+p[i]; \n\treturn res; }\npoly dif(const poly& p) { // differentiate\n\tpoly res; FOR(i,1,sz(p)) res.pb(T(i)*p[i]); \n\treturn res; }\npoly integ(const poly& p) { // integratepoly integ(const poly& p) { // integrate\n\tstatic poly invs{0,1};\n\tfor (int i = sz(invs); i <= sz(p); ++i) \n\t\tinvs.pb(-MOD/i*invs[MOD%i]);\n\tpoly res(sz(p)+1); F0R(i,sz(p)) res[i+1] = p[i]*invs[i+1];\n\treturn res; \n}\n\npoly& operator+=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] += r[i]; \n\treturn l; }\npoly& operator-=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] -= r[i]; \n\treturn l; }\npoly& operator*=(poly& l, const T& r) { each(t,l) t *= r; \n\treturn l;\t }\npoly& operator/=(poly& l, const T& r) { each(t,l) t /= r; \n\treturn l; }\npoly operator+(poly l, const poly& r) { return l += r; }\npoly operator-(poly l, const poly& r) { return l -= r; }\npoly operator-(poly l) { each(t,l) t *= -1; return l; }\npoly operator*(poly l, const T& r) { return l *= r; }\npoly operator*(const T& r, const poly& l) { return l*r; }\npoly operator/(poly l, const T& r) { return l /= r;\t }\npoly operator*(const poly& l, const poly& r) {\n\tif (!min(sz(l),sz(r))) return {};\n\tpoly x(sz(l)+sz(r)-1); \n\tF0R(i,sz(l)) F0R(j,sz(r)) x[i+j] += l[i]*r[j];\n\treturn x;\n}\npoly& operator*=(poly& l, const poly& r) { return l = l*r; }\n\npair<poly,poly> quoRem(poly a, poly b) { \n\tremz(a); remz(b); assert(sz(b));\n\tT lst = b.bk, B = T(1)/lst; each(t,a) t *= B; \n\teach(t,b) t *= B;\n\tpoly q(max(sz(a)-sz(b)+1,0));\n\tfor (int dif; (dif=sz(a)-sz(b)) >= 0; remz(a)) {\n\t\tq[dif] = a.bk; F0R(i,sz(b)) a[i+dif] -= q[dif]*b[i]; }\n\teach(t,a) t *= lst;\n\treturn {q,a}; // quotient, remainder\n}\npoly operator/(const poly& a, const poly& b) { return quoRem(a,b).f; }\npoly operator%(const poly& a, const poly& b) { return quoRem(a,b).s; }\n/**poly a = {1,3,5,8,6,0,0,0,0}, b = {1,5,1};\nps(quoRem(a,b)); a = 2*a, b = 2*b; ps(quoRem(a,b));*/\npoly gcd(poly a, poly b) { return b == poly{} ? a : gcd(b,a%b); }\nT resultant(poly a, poly b) { // R(A,B)\n\t// =b_m^n*prod_{j=1}^mA(mu_j)\n\t// =b_m^na_m^n*prod_{i=1}^nprod_{j=1}^m(mu_j-lambda_i)\n\t// =(-1)^{mn}a_n^m*prod_{i=1}^nB(lambda_i)\n\t// =(-1)^{nm}R(B,A)\n\t// Also, R(A,B)=b_m^{deg(A)-deg(A-CB)}R(A-CB,B)\n\tint ad = sz(a)-1, bd = sz(b)-1; \n\tif (bd <= 0) return bd < 0 ? 0 : pow(b.bk,ad);\n\tint pw = ad; a = a%b; pw -= (ad = sz(a)-1);\n\treturn resultant(b,a)*pow(b.bk,pw)*T((bd&ad&1)?-1:1);\n}\n\n/**\n * Description: Multiply small polys directly, otherwise use FFT.\n * Source: KACTL, https://cp-algorithms.com/algebra/fft.html\n */\n\n// #include \"Poly.h\"\n// #include \"FFT.h\"\n\nbool small(const poly& a, const poly& b) { // multiply directly\n\treturn min(sz(a),sz(b)) <= 60; }\n// vmi smart(const vmi& a, const vmi& b) { return mul(a,b); }\n// vl smart(const vl& a, const vl& b) {\n// \tauto X = mul(vcd(all(a)),vcd(all(b)));\n// \tvl x(sz(X)); F0R(i,sz(X)) x[i] = round(X[i].real());\n// \treturn x; }\npoly conv(const poly& a, const poly& b) {\n\treturn small(a,b) ? a*b : mul(a,b); } \n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvmi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = mi(-(ll)MOD/i*(int)invs[MOD%i]);\n\tFOR(i,1,SZ) {\n\t\tfac[i] = fac[i-1]*i;\n\t\tifac[i] = ifac[i-1]*invs[i];\n\t}\n}\nmi comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn fac[a]*ifac[b]*ifac[a-b];\n}\n\nvoid fassert(bool b) {\n\tif (!b) {\n\t\tps(0);\n\t\texit(0);\n\t}\n}\n\nvmi stor[100005][2][2];\n\nconst mi i2 = (MOD+1)/2;\nvmi calc(int len, int l, int r) {\n\tif (l > r) swap(l,r);\n\tif (sz(stor[len][l][r])) return stor[len][l][r];\n\tif (len == 0) return stor[len][l][r] = {1};\n\tif (len == 1) return stor[len][l][r] = {1,pow(mi(2),2-l-r)*i2};\n\tif (len == 2) return stor[len][l][r] = {1,4-l-r,pow(mi(2),2-l-r)*i2};\n\tF0R(i,2) {\n\t\tvmi a = calc((len-1)/2,l,i);\n\t\tvmi b = calc(len/2,i,r);\n\t\tvmi res = conv(a,b);\n\t\tif (i == 1) {\n\t\t\tres *= 2;\n\t\t\tres.ins(begin(res),0);\n\t\t}\n\t\tstor[len][l][r] += res;\n\t}\n\treturn stor[len][l][r];\n}\n\nvmi conv_all(const V<vmi>& v, int l, int r) {\n\tif (l == r) return {1};\n\tif (l+1 == r) return v[l];\n\tint m = (l+r)/2;\n\treturn conv(conv_all(v,l,m),conv_all(v,m,r));\n}\n\nstruct Dat {\n\tvmi v;\n\tDat(vmi _v):v(_v){}\n\tfriend bool operator<(const Dat& x, const Dat& y) {\n\t\treturn sz(x.v) > sz(y.v);\n\t}\n};\n\nint main() {\n\tsetIO();\n\tvi segs;\n\tints(N); vi A(N); re(A);\n\tgenFac(N+2);\n\tfor (int i = 0; i < N; ) {\n\t\tint lef = min(N-i,A[i]);\n\t\tvi v; rep(lef) v.pb(A[i++]);\n\t\tfassert(sz(v) == v.ft);\n\t\teach(t,v) fassert(t == v[0]);\n\t\tif (sz(v) > 1) segs.pb(2);\n\t\telse segs.pb(1);\n\t}\n\tV<vmi> all_conv;\n\tpriority_queue<Dat> pq;\n\tfor (int l = 0; l < sz(segs); ++l) {\n\t\tif (segs[l] != 1) continue;\n\t\tint r = l; while (r+1 < sz(segs) && segs[r+1] == 1) ++r;\n\t\tvmi v = calc(r-l + (l != 0) + (r != sz(segs)-1), l != 0, r != sz(segs)-1);\n\t\tl = r;\n\t\tpq.push(Dat(v));\n\t}\n\tint pairs = 0;\n\tF0R(l,sz(segs)-1) if (segs[l] != 1 && segs[l+1] != 1) ++pairs;\n\tvmi tmp(pairs+1);\n\tmi cur_term = 1;\n\tF0R(i,sz(tmp)) {\n\t\ttmp[i] = comb(pairs,i)*cur_term;\n\t\tcur_term *= i2;\n\t}\n\tpq.push(Dat(tmp));\n\twhile (sz(pq) > 1) {\n\t\tDat a = pq.top(); pq.pop();\n\t\tDat b = pq.top(); pq.pop();\n\t\tpq.push(Dat(conv(a.v,b.v)));\n\t}\n\n\t// all_conv.pb(tmp);\n\t// // dbg(\"GOT ALL CONV\",all_conv);\n\t// vmi res = conv_all(all_conv,0,sz(all_conv));\n\tmi ans;\n\tvmi res = pq.top().v;\n\tF0R(i,sz(res)) {\n\t\tres[i] *= fac[sz(segs)-i];\n\t\tif (i&1) ans -= res[i];\n\t\telse ans += res[i];\n\t}\n\teach(t,segs) if (t == 2) ans *= 2;\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Stairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/93105",
    "editorial": "First of all, we need to transform the stair array into some other\r\nstructure. Letâs show that for each number, there is only one longest\r\nstair covering it, and these longest stairs are disjoint.Suppose that\r\nsome number belongs to two different ascending stairs. We can easily\r\nexpand these stairs to the left and to the right and find the longest\r\nascending stair covering the number. So, it means that the longest\r\nascending stair covering a number is unique. The same for descending\r\nstairs.Now suppose that some number belongs to an ascending stair of\r\nlength and a descending stair of length . It is impossible because it\r\nwould mean that we have consecutive values or in the permutation, but\r\nsince it is a permutation, all values should be distinct. So, the\r\nlongest stair covering each number is unique.Letâs split the stair array\r\ninto this sequence of longest stairs. The first element of the stair\r\narray belongs to some stair. If , then the first elements form a stair.\r\nLetâs check that all these elements are equal to and split them into a\r\nstair of length , then continue the same algorithm from .Okay, now we\r\nhave an array of the lengths of the longest stairs. Each stair\r\nrepresents some segment of numbers, and all stairs can be enumerated by\r\nthe index of their value segment. So, it looks like the number of\r\npermutations that yeild this array of longest stairs is , where is the\r\nnumber of stairs and is the number of stairs having length . The\r\nreasoning behind this formula is that each stair gets assigned an index\r\ncorresponding to the index of its value segment in the sorted order, and\r\nfor stairs of length , we can choose whether they are ascending or\r\ndescending. Is that formula right?Unfortunately, no. The fact that we\r\nhave the array of stairs means that we need to ensure that no pair of\r\nadjacent stairs merge. And thereâs no easy way to change this formula,\r\nunfortunately.Letâs use inclusion-exclusion to eliminate all \"bad\"\r\npermutations. We have constraints that shouldnât be violated: stairs and\r\nshouldnât merge; stairs and shouldnât merge; ...; stairs and shouldnât\r\nmerge. For every from to , we can calculate the number of ways to choose\r\nconstraints to be violated and a permutation that violates these\r\nconstrains (and maybe some others), like in the usual\r\ninclusion-exclusion formula applications. These values can be calculated\r\nwith the following dynamic programming: is the number of ways to choose\r\nthis set of violated constraints and a permutation for first stairs, and\r\nrepresents the type of the last stair (ascending/descending or having\r\nsize ).What are the transitions in this dynamic programming? When\r\nplacing a new stair, we may choose either to explicitly violate the\r\nconstraint on merging it with the previous one (so, we transition to a\r\nstate and maybe multiply/divide the value by if we are merging two size-\r\nstairs or merging two stairs with different types). Or we can choose to\r\njust make an entirely new stair, choosing one of values for it (since we\r\nalready have stairs), choosing its type if its length is , and\r\ntransitioning to .The main drawback of this solution is that itâs .\r\nLetâs find a way to optimize it.Letâs calculate this dynamic programming\r\nin a divide-and-conquer fashion. Letâs say that for some segment of\r\nstairs, we will calculate a three-dimensional array the number of ways\r\nto violate constraints in this segment so that the leftmost stair in\r\nthis segment has type , and the rightmost stair in this segment has type\r\n.Suppose we want to merge these two segments. We either merge the\r\nleftmost stair of the right segment with the rightmost stair of the left\r\nsegment, or donât. Letâs analyze the case when we donât merge them.\r\nLetâs analyze the value of in the resulting array. Suppose we violate\r\nconstraints in the left segment, this leaves us to violate constraints\r\nin the right segment. So, the value of in the resulting merged structure\r\nwill be the sum of from the left segment multiplied by from the right\r\nsegment (where can represent any type). And if we treat the values from\r\nthe left and the right segment as polynomials (where value of or is the\r\ncoefficient for ), merging them is exactly polynomial multiplication! So\r\nwe can use FFT so speed up the merging.If we want to merge two segments\r\nwhile explicitly violating the constraint that the rightmost stair in\r\nthe left segment and the leftmost stair in the right segment shouldnât\r\nbe merged into one, it can be done with polynomial multiplication as\r\nwell, but you also have to multiply the result by some coefficient that\r\narises from merging those two stairs (if both of them had size , then we\r\nmultiply the result by since we can choose whether the resulting stair\r\nis ascending or descending; and if both of them had size , we divide the\r\nresult by since we cannot merge an ascending stair with a descending\r\none).So, this optimization allows us to merge two segments of length in\r\ntime , and as the usual FFT + D&C combination, this results in a\r\ncomplexity of , though with a fairly large constant factor.\r\n",
    "hint": []
}