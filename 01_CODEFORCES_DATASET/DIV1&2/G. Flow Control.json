{"link": "https://codeforces.com//contest/1804/problem/G", "problemId": "1824146", "problem_idx": "G", "shortId": "1804G", "contest_number": "1804", "problem_submissions": {"H": [197133699, 197211600], "G": [197106837, 197116479, 197124948, 197127592, 197122958, 197137640, 197134544, 197138362], "F": [197093293, 197105349, 197095528, 197104786, 197106624, 197098643, 197101524, 197103930, 197102162, 197105107, 197108552, 197108666, 197107628, 197142671, 197140184, 197139967, 197139883, 197139641, 197111482, 197111626, 197113675, 197111909, 197110044, 197110987, 197113933], "E": [197089405, 197085286, 197090524, 197097633, 197097337, 197091345, 197092803, 197096473, 197096893, 197095376, 197096756, 197096855, 197096490, 197096936, 197101267, 197098474, 197101399, 197096360, 197103528, 197097046], "D": [197081706, 197080440, 197082836, 197086161, 197088893, 197081349, 197083999, 197084952, 197086950, 197076993, 197086858, 197086874, 197084897, 197084889, 197084721, 197084970, 197089163, 197084662, 197086535, 197082927], "C": [197078079, 197076920, 197078785, 197081523, 197083238, 197076107, 197077574, 197078670, 197077463, 197082879, 197080775, 197081089, 197078608, 197079622, 197080414, 197078487, 197079270, 197080239, 197080507, 197079932], "B": [197075523, 197075248, 197075383, 197077168, 197080868, 197074547, 197074457, 197076648, 197075635, 197080800, 197077487, 197076188, 197075795, 197076995, 197076635, 197075839, 197076655, 197076988, 197077650, 197075789], "A": [197073420, 197073942, 197073446, 197073814, 197078430, 197073370, 197073351, 197073646, 197073456, 197078319, 197074505, 197073977, 197073328, 197073488, 197073501, 197073461, 197073950, 197074331, 197075653, 197073687]}, "name": "G. Flow Control", "statement": "Raj has a single physical network line that connects his office to the\r\nInternet. This line bandwidth is b bytes per millisecond.There are n\r\nusers who would like to use this network line to transmit some data. The\r\ni-th of them will use the line from millisecond s_i to millisecond f_i\r\ninclusive. His initial data rate will be set to d_i. That means he will\r\nuse data rate equal to d_i for millisecond s_i, and then it will change\r\naccording to the procedure described below.The flow control will happen\r\nas follows. Suppose there are m users trying to transmit some data via\r\nthe given network line during millisecond x. Denote as t_i the data rate\r\nthat the i-th of these m users has at the beginning of this millisecond.\r\nAll t_i are non-negative integer values. If m = 0, i. e. there are no\r\nusers trying to transmit data during this millisecond, nothing happens.\r\nIf the sum of all t_i is less than or equal to b, each active user\r\nsuccessfully completes his transmission (the i-th active user transmits\r\nt_i bytes). After that, the data rate of each active user grows by 1, i.\r\ne. each t_i is increased by 1. If the sum of all t_i is greater than b,\r\nthe congestion occurs and no data transmissions succeed this millisecond\r\nat all. If that happens, each t_i decreases twice, i. e. each t_i is\r\nreplaced with\r\nlfloor\r\nfrac{t_i}{2}\r\nrfloor. Raj knows all the values n, b, s_i, f_i, and d_i, he wants to\r\ncalculate the total number of bytes transmitted by all the users in the\r\naggregate.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    const int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    void half(int p, int l, int r) {\n        if (info[p].act == 0) {\n            return;\n        }\n        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {\n            apply(p, {-(info[p].min + 1) / 2});\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        half(2 * p, l, m);\n        half(2 * p + 1, m, r);\n        pull(p);\n    }\n    void half() {\n        half(1, 0, n);\n    }\n};\n\nconstexpr i64 inf = 1E18;\n\nstruct Tag {\n    i64 add = 0;\n    \n    void apply(Tag t) {\n        add += t.add;\n    }\n};\n\nstruct Info {\n    i64 min = inf;\n    i64 max = -inf;\n    i64 sum = 0;\n    i64 act = 0;\n    \n    void apply(Tag t) {\n        min += t.add;\n        max += t.add;\n        sum += act * t.add;\n    }\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.min = std::min(a.min, b.min);\n    c.max = std::max(a.max, b.max);\n    c.sum = a.sum + b.sum;\n    c.act = a.act + b.act;\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b;\n    std::cin >> n >> b;\n    \n    i64 ans = 0;\n    \n    std::vector<std::array<int, 3>> events;\n    for (int i = 0; i < n; i++) {\n        int s, f, d;\n        std::cin >> s >> f >> d;\n        s--;\n        events.push_back({s, i, d});\n        events.push_back({f, i, 0});\n    }\n    \n    std::sort(events.begin(), events.end());\n    \n    LazySegmentTree<Info, Tag> seg(n);\n    int cur = 0;\n    for (auto [t, i, d] : events) {\n        Info last = {-1, -1, -1, -1};\n        i64 lastc = -1;\n        i64 lastans = -1;\n        while (cur < t) {\n            auto info = seg.rangeQuery(0, n);\n            if (info.act == 0) {\n                cur = t;\n                break;\n            }\n            if (info.min == last.min && info.max == last.max && info.sum == last.sum && info.max - info.min <= 1) {\n                i64 dt = cur - lastc;\n                i64 dans = ans - lastans;\n                i64 phase = (t - cur) / dt;\n                cur += phase * dt;\n                ans += phase * dans;\n            }\n            last = info;\n            lastc = cur;\n            lastans = ans;\n            i64 u = (b - info.sum + info.act) / info.act;\n            if (u > t - cur) {\n                u = t - cur;\n            }\n            if (u < 0) {\n                u = 0;\n            }\n            cur += u;\n            ans += (info.sum + info.sum + info.act * (u - 1)) * u / 2;\n            seg.rangeApply(0, n, {u});\n            if (t == cur) {\n                break;\n            }\n            cur += 1;\n            seg.half();\n        }\n        if (d != 0) {\n            seg.modify(i, {d, d, d, 1});\n        } else {\n            seg.modify(i, Info());\n        }\n    }\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "implementation"], "dificulty": "3500", "interactive": false}