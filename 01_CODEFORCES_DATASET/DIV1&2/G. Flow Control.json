{
    "link": "https://codeforces.com//contest/1804/problem/G",
    "problemId": "1824146",
    "problem_idx": "G",
    "shortId": "1804G",
    "contest_number": "1804",
    "problem_submissions": {
        "H": [
            197133699,
            197211600
        ],
        "G": [
            197106837,
            197116479,
            197124948,
            197127592,
            197122958,
            197137640,
            197134544,
            197138362
        ],
        "F": [
            197093293,
            197105349,
            197095528,
            197104786,
            197106624,
            197098643,
            197101524,
            197103930,
            197102162,
            197105107,
            197108552,
            197108666,
            197107628,
            197142671,
            197140184,
            197139967,
            197139883,
            197139641,
            197111482,
            197111626,
            197113675,
            197111909,
            197110044,
            197110987,
            197113933
        ],
        "E": [
            197089405,
            197085286,
            197090524,
            197097633,
            197097337,
            197091345,
            197092803,
            197096473,
            197096893,
            197095376,
            197096756,
            197096855,
            197096490,
            197096936,
            197101267,
            197098474,
            197101399,
            197096360,
            197103528,
            197097046
        ],
        "D": [
            197081706,
            197080440,
            197082836,
            197086161,
            197088893,
            197081349,
            197083999,
            197084952,
            197086950,
            197076993,
            197086858,
            197086874,
            197084897,
            197084889,
            197084721,
            197084970,
            197089163,
            197084662,
            197086535,
            197082927
        ],
        "C": [
            197078079,
            197076920,
            197078785,
            197081523,
            197083238,
            197076107,
            197077574,
            197078670,
            197077463,
            197082879,
            197080775,
            197081089,
            197078608,
            197079622,
            197080414,
            197078487,
            197079270,
            197080239,
            197080507,
            197079932
        ],
        "B": [
            197075523,
            197075248,
            197075383,
            197077168,
            197080868,
            197074547,
            197074457,
            197076648,
            197075635,
            197080800,
            197077487,
            197076188,
            197075795,
            197076995,
            197076635,
            197075839,
            197076655,
            197076988,
            197077650,
            197075789
        ],
        "A": [
            197073420,
            197073942,
            197073446,
            197073814,
            197078430,
            197073370,
            197073351,
            197073646,
            197073456,
            197078319,
            197074505,
            197073977,
            197073328,
            197073488,
            197073501,
            197073461,
            197073950,
            197074331,
            197075653,
            197073687
        ]
    },
    "name": "G. Flow Control",
    "statement": "Raj has a single physical network line that connects his office to the\r\nInternet. This line bandwidth is b bytes per millisecond.There are n\r\nusers who would like to use this network line to transmit some data. The\r\ni-th of them will use the line from millisecond s_i to millisecond f_i\r\ninclusive. His initial data rate will be set to d_i. That means he will\r\nuse data rate equal to d_i for millisecond s_i, and then it will change\r\naccording to the procedure described below.The flow control will happen\r\nas follows. Suppose there are m users trying to transmit some data via\r\nthe given network line during millisecond x. Denote as t_i the data rate\r\nthat the i-th of these m users has at the beginning of this millisecond.\r\nAll t_i are non-negative integer values. If m = 0, i. e. there are no\r\nusers trying to transmit data during this millisecond, nothing happens.\r\nIf the sum of all t_i is less than or equal to b, each active user\r\nsuccessfully completes his transmission (the i-th active user transmits\r\nt_i bytes). After that, the data rate of each active user grows by 1, i.\r\ne. each t_i is increased by 1. If the sum of all t_i is greater than b,\r\nthe congestion occurs and no data transmissions succeed this millisecond\r\nat all. If that happens, each t_i decreases twice, i. e. each t_i is\r\nreplaced with\r\nlfloor\r\nfrac{t_i}{2}\r\nrfloor. Raj knows all the values n, b, s_i, f_i, and d_i, he wants to\r\ncalculate the total number of bytes transmitted by all the users in the\r\naggregate.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    const int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    void half(int p, int l, int r) {\n        if (info[p].act == 0) {\n            return;\n        }\n        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {\n            apply(p, {-(info[p].min + 1) / 2});\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        half(2 * p, l, m);\n        half(2 * p + 1, m, r);\n        pull(p);\n    }\n    void half() {\n        half(1, 0, n);\n    }\n};\n\nconstexpr i64 inf = 1E18;\n\nstruct Tag {\n    i64 add = 0;\n    \n    void apply(Tag t) {\n        add += t.add;\n    }\n};\n\nstruct Info {\n    i64 min = inf;\n    i64 max = -inf;\n    i64 sum = 0;\n    i64 act = 0;\n    \n    void apply(Tag t) {\n        min += t.add;\n        max += t.add;\n        sum += act * t.add;\n    }\n};\n\nInfo operator+(Info a, Info b) {\n    Info c;\n    c.min = std::min(a.min, b.min);\n    c.max = std::max(a.max, b.max);\n    c.sum = a.sum + b.sum;\n    c.act = a.act + b.act;\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, b;\n    std::cin >> n >> b;\n    \n    i64 ans = 0;\n    \n    std::vector<std::array<int, 3>> events;\n    for (int i = 0; i < n; i++) {\n        int s, f, d;\n        std::cin >> s >> f >> d;\n        s--;\n        events.push_back({s, i, d});\n        events.push_back({f, i, 0});\n    }\n    \n    std::sort(events.begin(), events.end());\n    \n    LazySegmentTree<Info, Tag> seg(n);\n    int cur = 0;\n    for (auto [t, i, d] : events) {\n        Info last = {-1, -1, -1, -1};\n        i64 lastc = -1;\n        i64 lastans = -1;\n        while (cur < t) {\n            auto info = seg.rangeQuery(0, n);\n            if (info.act == 0) {\n                cur = t;\n                break;\n            }\n            if (info.min == last.min && info.max == last.max && info.sum == last.sum && info.max - info.min <= 1) {\n                i64 dt = cur - lastc;\n                i64 dans = ans - lastans;\n                i64 phase = (t - cur) / dt;\n                cur += phase * dt;\n                ans += phase * dans;\n            }\n            last = info;\n            lastc = cur;\n            lastans = ans;\n            i64 u = (b - info.sum + info.act) / info.act;\n            if (u > t - cur) {\n                u = t - cur;\n            }\n            if (u < 0) {\n                u = 0;\n            }\n            cur += u;\n            ans += (info.sum + info.sum + info.act * (u - 1)) * u / 2;\n            seg.rangeApply(0, n, {u});\n            if (t == cur) {\n                break;\n            }\n            cur += 1;\n            seg.half();\n        }\n        if (d != 0) {\n            seg.modify(i, {d, d, d, 1});\n        } else {\n            seg.modify(i, Info());\n        }\n    }\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "implementation"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Flow Control.json",
    "editorial_link": "https://codeforces.com//blog/entry/113830",
    "editorial": "The problem is inspired by AIMD algorithm for TCP flow and congestion\r\ncontrol.The key solution idea comes from a real-world networking, every\r\ntime the congestion happens the difference between the maximum active\r\nt_i and the minimum active t_i halves. Thus, if all users were to start\r\nand to stop at the same time there will be no more than two distinct\r\nvalues of t_i in just\r\nlog C congestions. Here C stands for the upper limit on values d_i and\r\nb.Letâs store all the unique values of active t_i in a hash-map together\r\nwith a supplementary information. Information we need is the sum of all\r\nt_i right after the last congestion, the number of milliseconds past\r\nsince the last congestion and so on. Using this information we can\r\ncompute the time of the next congestion in O(1).The processing of one\r\ncongestion will work in O(d) time where d is the current number of\r\ndistinct values of t_i. We also need to be able to merge two groups when\r\ncongestion happens, this information will be used to process delete\r\noperations. That can be done using DSU with path compression and doesnât\r\nadd much to the total complexity.We will call the period between two\r\nconsecutive congestions an epoch. There are epochs of two types: general\r\nand repetitive. A repetitive epoch is an epoch that goes in exactly the\r\nsame way as the previous epoch. That means no new users appear, no users\r\nturn off, the epoch starts with exactly the same values of t_i as the\r\nprevious epoch and gets to exactly the same state after the closest\r\ncongestion happens. All other epochs are called general.Though the total\r\nnumber of epochs can be large (up to\r\nmax(f_i)), there will be no more than n\r\nlog{C} general epochs. Indeed, if no users start or finish data\r\ntransmission, the process will converge to a repetitive epoch in no more\r\nthan\r\nlog{C} congestions. Here, C is the upper bound for b and values\r\nd_i.Repetitive epochs contain no more than two distinct value of t_i,\r\nthey can be identified and simulated efficiently. How do we simulate\r\ngeneral epochs? There is no need to this efficiently, doing this in O(d)\r\n(d is the number of distinct t_i) will be efficient enough. One can\r\nprove this using amortized analysis with the following potential\r\nfunction. Let d be the number of distinct values of t_i and t_0 < t_1 <\r\nldots < t_{d - 1} be the sequence of these values. P(epoch) = d +\r\nsum_{i = 0}^{d - 2}\r\nlog{(t_{i + 1} - t_i)}.The total complexity is O(n\r\nlog C + n\r\nlog n).\r\n",
    "hint": []
}