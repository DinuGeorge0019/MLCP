{
    "link": "https://codeforces.com//contest/1534/problem/F2",
    "problemId": "1015235",
    "problem_idx": "F2",
    "shortId": "1534F2",
    "contest_number": "1534",
    "problem_submissions": {
        "H": [
            119381214,
            119371780,
            119388875,
            119396687,
            119388441,
            119735727,
            119401011,
            156903357,
            119399410
        ],
        "G": [
            119363923,
            119381755,
            119379035,
            119379747,
            119375709,
            119378954,
            119381639,
            119386175,
            119382951,
            119385742,
            119388314,
            119371330,
            120158205,
            119404077,
            119378000,
            119386837,
            119386916,
            119395182,
            119389738,
            119408279,
            119408209,
            119408093
        ],
        "F2": [
            119359019,
            119387021,
            119400446,
            119368476,
            119369247,
            119507067,
            119404750,
            119370022,
            119374004,
            119374154,
            119376176,
            119372366,
            119378246,
            119399836,
            119402771,
            119402687,
            119397406,
            119363483,
            119371811,
            119375364
        ],
        "F1": [
            119354959,
            119349642,
            119359129,
            119361761,
            119507346,
            119371842,
            119361335,
            119365559,
            119364097,
            119370075,
            119372716,
            119373779,
            119373986,
            119373292,
            119365686,
            119365605,
            119370635,
            119378959,
            119363180,
            119357763,
            119355433
        ],
        "E": [
            119348058,
            119345554,
            119352930,
            119351617,
            119349306,
            119353802,
            119353388,
            119357278,
            119361448,
            119356611,
            119347260,
            119354563,
            119406882,
            119406872,
            119406814,
            119366978,
            119358316,
            119361081,
            119365117,
            119367416,
            119352636,
            119352851,
            119349844
        ],
        "D": [
            119342350,
            119341721,
            119344490,
            119344598,
            119352385,
            119347199,
            119345707,
            119344090,
            119352267,
            119362889,
            119351680,
            119347922,
            119347628,
            119350545,
            119353880,
            119345904,
            119350322,
            119344632,
            119344948,
            119343924
        ],
        "C": [
            119339545,
            119339824,
            119341150,
            119341051,
            119342258,
            119342361,
            119342280,
            119341468,
            119346665,
            119340382,
            119340132,
            119340253,
            119340431,
            119342595,
            119342664,
            119342788,
            119344299,
            119340875,
            119340120,
            119340815
        ],
        "B": [
            119338881,
            119339003,
            119339770,
            119339655,
            119340047,
            119340398,
            119340981,
            119340203,
            119342335,
            119339310,
            119338676,
            119339188,
            119339149,
            119339395,
            119344148,
            119340653,
            119341897,
            119339460,
            119339065,
            119339496
        ],
        "A": [
            119338623,
            119338599,
            119338780,
            119338750,
            119338699,
            119338727,
            119339260,
            119338754,
            119339237,
            119338711,
            119339353,
            119338692,
            119338629,
            119345132,
            119342442,
            119338896,
            119339494,
            119338744,
            119338632,
            119338713
        ]
    },
    "name": "F2. Falling Sand  Hard Version ",
    "statement": "Little Dormi has recently received a puzzle from his friend and needs\r\nyour help to solve it. The puzzle consists of an upright board with n\r\nrows and m columns of cells, some empty and some filled with blocks of\r\nsand, and m non-negative integers a_1,a_2,\r\nldots,a_m (0\r\nleq a_i\r\nleq n). In this version of the problem, a_i will always be the number of\r\nblocks of sand in column i.When a cell filled with a block of sand is\r\ndisturbed, the block of sand will fall from its cell to the sand counter\r\nat the bottom of the column (each column has a sand counter). While a\r\nblock of sand is falling, other blocks of sand that are adjacent at any\r\npoint to the falling block of sand will also be disturbed and start to\r\nfall. Specifically, a block of sand disturbed at a cell (i,j) will pass\r\nthrough all cells below and including the cell (i,j) within the column,\r\ndisturbing all adjacent cells along the way. Here, the cells adjacent to\r\na cell (i,j) are defined as (i-1,j), (i,j-1), (i+1,j), and (i,j+1) (if\r\nthey are within the grid). Note that the newly falling blocks can\r\ndisturb other blocks.In one operation you are able to disturb any piece\r\nof sand. The puzzle is solved when there are a_i blocks of sand counted\r\nin the i-th sand counter for each column from 1 to m.You are now tasked\r\nwith finding the minimum amount of operations in order to solve the\r\npuzzle. Note that Little Dormi will never give you a puzzle that is\r\nimpossible to solve.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\nvpi range;\n\nvoid upd_range(int c, pi p) {\n\tckmin(range[c].f,p.f);\n\tckmax(range[c].s,p.s);\n}\n\n/**\n * Description: Tarjan's, DFS once to generate \n \t* strongly connected components in topological order. $a,b$\n \t* in same component if both $a\\to b$ and $b\\to a$ exist.\n \t* Uses less memory than Kosaraju b/c doesn't store reverse edges.\n * Time: O(N+M)\n * Source: KACTL\n \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/graph/SCC.h\n * Verification: https://cses.fi/problemset/task/1686/\n */\n\nstruct SCC {\n\tint N, ti = 0; V<vi> adj;\n\tvi disc, comp, stk, comps;\n\tV<vi> comp_radj;\n\tvoid init(int _N) { N = _N; adj.rsz(N), disc.rsz(N), comp = vi(N,-1); }\n\tvoid ae(int x, int y) { adj[x].pb(y); }\n\tint dfs(int x) {\n\t\tint low = disc[x] = ++ti; stk.pb(x);\n\t\teach(y,adj[x]) if (comp[y] == -1) // comp[y] == -1, disc[y] != 0 -> in stack\n\t\t\tckmin(low,disc[y]?:dfs(y)); \n\t\tif (low == disc[x]) { // make new SCC, pop off stack until you find x\n\t\t\tcomps.pb(x); for (int y = -1; y != x;) \n\t\t\t\tcomp[y = stk.bk] = x, stk.pop_back();\n\t\t}\n\t\treturn low;\n\t}\n\tvoid gen() {\n\t\tF0R(i,N) if (!disc[i]) dfs(i);\n\t\treverse(all(comps));\n\t\t// vi in_deg(N);\n\t\tcomp_radj.rsz(N);\n\t\tF0R(i,N) each(j,adj[i]) if (comp[i] != comp[j]) {\n\t\t\tcomp_radj[comp[j]].pb(comp[i]);\n\t\t\t// ++in_deg[comp[j]];\n\t\t}\n\t\t// int ans = 0;\n\t\t// F0R(i,N) if (comp[i] == i && in_deg[i] == 0) ++ans;\n\t\t// return ans;\n\t}\n};\n\nint N,M;\nvs B;\nvi A;\nV<vb> done;\n\n// void make_done(int x, int y) {\n// \tif (x < 0 || x >= N || y <)\n// \tif (!done[x][y]) return;\n// \tdone[x][y] = 1;\n\n// }\n\nint main() {\n\tsetIO();\n\tre(N,M);\n\tB.rsz(N); re(B);\n\tA.rsz(M); re(A);\n\t// done = V<vb>(N,vb(M));\n\t// int ans = 0;\n\tV<vi> imp(N,vi(M));\n\tF0R(i,N) F0R(j,M) {\n\t\timp[i][j] = B[i][j] == '#';\n\t\tif (i) imp[i][j] |= imp[i-1][j];\n\t}\n\tauto exists = [&](int x, int y) {\n\t\treturn 0 <= x && x < N && 0 <= y && y < M && B[x][y] == '#';\n\t};\n\tSCC S; S.init(N*M);\n\tauto hsh = [&](int x, int y) {\n\t\treturn M*x+y;\t\n\t};\n\tauto ae = [&](pi x, pi y) {\n\t\tS.ae(hsh(x.f,x.s),hsh(y.f,y.s));\n\t};\n\tF0R(i,N) F0R(j,M) if (imp[i][j]) {\n\t\tF0R(d,4) {\n\t\t\tint ii = i+dx[d], jj = j+dy[d];\n\t\t\tif (exists(ii,jj)) ae({i,j},{ii,jj});\n\t\t}\n\t\tif (i+1 < N) ae({i,j},{i+1,j});\n\t}\n\tS.gen();\n\trange = vpi(N*M,mp(MOD,-MOD));\n\tF0R(i,N) F0R(j,M) if (exists(i,j)) {\n\t\tupd_range(hsh(i,j),{j,j});\n\t}\n\teach(c,S.comps) {\n\t\teach(u,S.comp_radj[c]) upd_range(c,range[u]);\n\t}\n\tvpi intervals;\n\tF0R(j,M) if (A[j]) {\n\t\tint i = N, cnt = 0;\n\t\twhile (cnt < A[j]) {\n\t\t\tassert(i); --i;\n\t\t\tcnt += B[i][j] == '#';\n\t\t}\n\t\tintervals.pb(range[S.comp[hsh(i,j)]]);\n\t\t// dbg(\"GOT\",i,j);\n\t}\n\tdbg(intervals);\n\teach(t,intervals) swap(t.s,t.f);\n\tsort(all(intervals));\n\n\tint last_done = -MOD, ans = 0;\n\teach(t,intervals) {\n\t\tif (last_done >= t.s) continue;\n\t\tlast_done = t.f; ++ans;\n\t}\n\tps(ans);\n\n\t// sort(all(intervals));\n\n\t// dbg(\"OH\",ans);\n\t// F0R(i,N) F0R(j,M) if (!imp[i][j]) --ans;\n\t// ps(ans);\n\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "greedy"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F2. Falling Sand  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/91760",
    "editorial": "Where differs from is that not all blocks of sand have to fall, instead\r\nonly some subset of them within each column need to fall. Let\u00e2\u0080\u0099s go back\r\nto the Directed Acyclic Graph constructed in . Instead of all nodes\r\nbeing required to be reachable, we only need the nodes which are the\r\nfirst blocks of sand within each column (counting from the bottom) to be\r\nreachable. Let\u00e2\u0080\u0099s denote the set which contains the nodes which have to\r\nbe reachable as .We can then observe that can be reduced down to just\r\nthe block of sand within each column as all blocks of sand below will be\r\ndistributed when it is disturbed. Let us call the nodes that are left in\r\nthis set \"special nodes\". From here, observe that any special node that\r\nis reachable from another special node can be removed from as a\r\ndisturbance of the node will also guarantee that will be disturbed. Now\r\nremove all such nodes from . Note that these nodes can be found with BFS\r\nor DFS.Now I claim that all nodes within the graph will reach some\r\nsubarray of when is sorted by column index (if a node represents\r\nmultiple nodes within the puzzle, take the left-most column). Let us\r\ncall this sorted array of as .Proof: Imagine a node that does not reach\r\nan exact subsegment of . This means that it must reach some node on the\r\npuzzle and then another node such that they are both in and none of the\r\nspecial nodes on the columns between them are reachable. Let\u00e2\u0080\u0099s denote a\r\nrandom special node that is not reachable as . As you can only go\r\ndirectly from one column to the next, must reach some set of nodes on\r\nthe columns between and . Denote the reachable node which is in the same\r\ncolumn as as . If is above in the column, is reachable from , and thus\r\nreachable from . Thus, must be below . However, this means that is\r\nreachable from . As is used to reach either or depending on which side\r\nis on (WLOG, assume its ), must also be reachable from . But since is a\r\nspecial node, can not be part of the set and array . This creates a\r\ncontradiction, proving that must reach an exact subsegment of .Now run a\r\ndp on the directed acyclic graph and find the minimum and maximum index\r\nof that is reachable from every node.The question is then converted to,\r\ngiven some intervals, what is the minimal amount of intervals that will\r\nbe able to cover the entire range of . This question is well known and\r\ncan be solved in many ways. One of the simplest methods is a greedy\r\napproach. Loop from left to right on , maintaining the rightmost index\r\nof an interval that starts before or at the current index and also\r\nmaintain the furthest right that any taken interval reaches. As soon as\r\nyou reach an index that is not within the range of taken intervals, take\r\nthe interval with the rightmost index and add one to the answer. The\r\nfinal answer is then the value after the loop has completed.Final\r\nComplexity: or depending on implementation.\r\n"
}