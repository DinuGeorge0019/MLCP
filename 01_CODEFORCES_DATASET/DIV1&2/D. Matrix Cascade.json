{"link": "https://codeforces.com//contest/1864/problem/D", "problemId": "2181267", "problem_idx": "D", "shortId": "1864D", "contest_number": "1864", "problem_submissions": {"I": [220596748, 220625703, 220625365, 220625093], "H": [220568821, 220567695, 220569504, 220765807, 220735033, 220733694, 220582422, 220590968, 220584872, 220585832, 220586273, 220588653, 220869529, 220592706, 220587781, 220596085, 222139412, 220596294], "G": [220562227, 220575493, 220588511, 220576272, 220574639, 220576772, 220595506, 220568659, 220611309, 221223033, 220575904, 220585515, 220590419, 220591092, 220590354, 220590686], "F": [220551620, 220555802, 220557675, 220718976, 220558576, 220553574, 220558951, 220567707, 220555900, 220612295, 220564492, 220564273, 220565836, 220560759, 220571802, 220564441, 220571627, 220556155, 220556855, 220560337, 220568919, 220567748], "E": [220545674, 220547229, 220549551, 220553761, 220544098, 220550014, 220550285, 220550294, 220555536, 220557391, 220559164, 220553118, 220556990, 220555427, 220553548, 220549618, 220563369, 220552727, 220558630, 220553863], "D": [220537006, 220537255, 220535722, 220536129, 220534069, 220542850, 220539341, 220538198, 220541287, 220542463, 220545447, 220548373, 220544205, 220540271, 220536187, 220541552, 220541368, 220545083, 220544975], "C": [220533606, 220528455, 220528101, 220528155, 220527489, 220537748, 220525134, 220530359, 220532079, 220533694, 220541070, 220542060, 220535618, 220533106, 220530771, 220535184, 220536493, 220534865, 220537384], "B": [220524699, 220524727, 220525716, 220524082, 220524572, 220524039, 220522756, 220522640, 220528173, 220525137, 220528062, 220531552, 220524275, 220526451, 220524531, 220529349, 220526226, 220525961, 220525118], "A": [220521618, 220521580, 220521747, 220521485, 220521753, 220521570, 220521442, 220521465, 220524365, 220521707, 220524695, 220522808, 220521703, 220522789, 220521679, 220521789, 220521663, 220522116, 220521966]}, "name": "D. Matrix Cascade", "statement": "There is a matrix of size n\r\ntimes n which consists of s and s. The rows are numbered from 1 to n\r\nfrom top to bottom, the columns are numbered from 1 to n from left to\r\nright. The cell at the intersection of the x-th row and the y-th column\r\nis denoted as (x, y).AquaMoon wants to turn all elements of the matrix\r\nto s. In one step she can perform the following operation: Select an\r\narbitrary cell, let it be (i, j), then invert the element in (i, j) and\r\nalso invert all elements in cells (x, y) for x > i and x - i\r\nge\r\nleft|y - j\r\nright|. To invert a value means to change it to the opposite: changes to\r\n, changes to . Help AquaMoon determine the minimum number of steps she\r\nneed to perform to turn all elements of the matrix to s. We can show\r\nthat an answer always exists.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=3007;\n\nint n;\nchar wcz[nax];\n\nint tab[nax][nax];\n\nint lew[nax][nax];\nint pra[nax][nax];\nint dol[nax][nax];\n\nint wyn;\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=0; i<=n+1; i++)\n\t\tfor (int j=0; j<=n+1; j++)\n\t\t\ttab[i][j]=lew[i][j]=pra[i][j]=dol[i][j]=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%s\", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t\ttab[i][j]=(wcz[j]-'0');\n\t}\n\twyn=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tpra[i][j]^=pra[i-1][j-1];\n\t\t\tlew[i][j]^=lew[i-1][j+1];\n\t\t\tdol[i][j]^=lew[i][j]^pra[i][j]^dol[i-1][j];\n\t\t\ttab[i][j]^=dol[i][j];\n\t\t\tif (tab[i][j])\n\t\t\t{\n\t\t\t\twyn++;\n\t\t\t\tlew[i+1][j-1]^=1;\n\t\t\t\tpra[i+1][j+1]^=1;\n\t\t\t\tdol[i+1][j]^=1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "data structures", "dp", "greedy", "math"], "dificulty": "1700", "interactive": false}