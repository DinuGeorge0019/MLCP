{
    "link": "https://codeforces.com//contest/1799/problem/F",
    "problemId": "1800603",
    "problem_idx": "F",
    "shortId": "1799F",
    "contest_number": "1799",
    "problem_submissions": {
        "H": [
            195172140,
            195179948,
            195176943,
            195177627,
            195177612,
            195187046,
            195170243,
            195186163,
            195181900,
            195178648,
            195187740,
            195188641,
            195181162,
            195197683,
            195197622,
            195197452,
            195197330,
            195195992,
            195195702,
            195195592,
            195189428,
            222390709,
            195183885,
            195192378
        ],
        "G": [
            195165805,
            195168765,
            195163877,
            195170080,
            195166062,
            195173874,
            195159286,
            195167233,
            195175284,
            195171112,
            195175174,
            195176292,
            195166497,
            195167039,
            195174540,
            195165113,
            195172643,
            195174992,
            195179660
        ],
        "F": [
            195162556,
            195161415,
            195167047,
            195167029,
            195169902,
            195165660,
            195176867,
            195177074,
            195171218,
            195182224,
            195179445,
            195181473,
            195185750,
            195200279,
            195171757,
            195192151,
            195177698,
            195192345,
            195178905,
            195177004
        ],
        "E": [
            195155464,
            195155926,
            195160608,
            195157188,
            195161547,
            195155405,
            195184653,
            195161068,
            195166323,
            195173130,
            195168387,
            195173064,
            195218892,
            195198896,
            195162114,
            195161002,
            195160161,
            195165268,
            195163227,
            195160677
        ],
        "D2": [
            195149687,
            195148531,
            195151569,
            195149401,
            195152435,
            195149320,
            195159443,
            195154372,
            195157592,
            195155987,
            195161428,
            195244200,
            195161041,
            195153968,
            195155870,
            195151311,
            195155278,
            195159787,
            195153371,
            195151855
        ],
        "D1": [
            195149644,
            195148457,
            195150430,
            195149466,
            195152497,
            195149250,
            195150661,
            195154425,
            195157658,
            195153741,
            195161504,
            195150409,
            195152774,
            195155970,
            195151278,
            195153482,
            195159732,
            195149352,
            195149899
        ],
        "C": [
            195146230,
            195145019,
            195147190,
            195145539,
            195148295,
            195145217,
            195148636,
            195146815,
            195151203,
            195151265,
            195151601,
            195146561,
            195147507,
            195149080,
            195145370,
            195151542,
            195158458,
            195147153,
            195147120
        ],
        "B": [
            195140902,
            195141064,
            195140888,
            195140956,
            195140810,
            195141011,
            195142268,
            195146249,
            195143844,
            195142681,
            195143326,
            195142296,
            195140849,
            195142634,
            195140165,
            195142125,
            195141309,
            195141669,
            195140680
        ],
        "A": [
            195139293,
            195139594,
            195139424,
            195139401,
            195139388,
            195139558,
            195139905,
            195143164,
            195139695,
            195139287,
            195140212,
            195139506,
            195139370,
            195139520,
            195139228,
            195140320,
            195142809,
            195139497,
            195139286
        ]
    },
    "name": "F. Halve or Subtract",
    "statement": "You have an array of positive integers a_1, a_2,\r\nldots, a_n, of length n. You are also given a positive integer b.You are\r\nallowed to perform the following operations (possibly several) times in\r\nany order: Choose some 1\r\nle i\r\nle n, and replace a_i with\r\nlceil\r\nfrac{a_i}{2}\r\nrceil. Here,\r\nlceil x\r\nrceil denotes the smallest integer not less than x. Choose some 1\r\nle i\r\nle n, and replace a_i with\r\nmax(a_i - b, 0). However, you must also follow these rules: You can\r\nperform at most k_1 operations of type 1 in total. You can perform at\r\nmost k_2 operations of type 2 in total. For all 1\r\nle i\r\nle n, you can perform at most 1 operation of type 1 on element a_i. For\r\nall 1\r\nle i\r\nle n, you can perform at most 1 operation of type 2 on element a_i. The\r\nof an array is the sum of its elements. Find the minimum cost of a you\r\ncan achieve by performing these operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, b, k1, k2;\n    std::cin >> n >> b >> k1 >> k2;\n    \n    i64 sum = 0;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        sum += a[i];\n    }\n    \n    i64 ans = 0;\n    \n    std::sort(a.begin(), a.end(), std::greater());\n    \n    std::vector f(k1 + 1, std::vector<i64>(k2 + 1));\n    int mid = 0;\n    while (mid < n && a[mid] >= b) {\n        mid++;\n    }\n    \n    i64 res = 0;\n    for (int i = 0; i <= k1; i++) {\n        if (i > 0 && i <= mid) {\n            res += a[i - 1] / 2;\n        }\n        int t = std::min(i, mid);\n        i64 v = res;\n        for (int j = 0; j <= k2; j++) {\n            if (j > 0) {\n                if (t + j <= mid) {\n                    v += b;\n                } else if (j <= mid) {\n                    v += std::min(b, (a[t + j - mid - 1] + 1) / 2);\n                }\n            }\n            f[i][j] = v;\n        }\n    }\n    \n    res = 0;\n    for (int i = 0; i <= std::min(k2, n - mid); i++) {\n        if (i > 0) {\n            res += a[mid + i - 1];\n        }\n        i64 v = res;\n        for (int j = 0; j <= std::min(k1, n - i - mid); j++) {\n            if (j > 0) {\n                v += a[mid + i + j - 1] / 2;\n            }\n            ans = std::max(ans, v + f[k1 - j][k2 - i]);\n        }\n    }\n    \n    ans = sum - ans;\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Halve or Subtract.json",
    "editorial_link": "https://codeforces.com//blog/entry/113321",
    "editorial": "For convenience, let denote , and denote .First, notice that if we apply\r\nboth operations to some element, it will be optimal to apply halving\r\nfirst, then subtraction. We can prove this with 2 cases: . In this case,\r\n, and so . Since applying either function to a nonnegative integer\r\nresults in a nonnegative integer, . Otherwise, . Then , and . Since , .\r\nNext, suppose there are exactly elements to which we apply both\r\noperations. Then, it will be optimal to apply both operations to the\r\ngreatest elements in the array. This should be somewhat intuitive, but\r\nhereâs a proof: Suppose there are some such that . Suppose we apply both\r\noperations to , and only one operation to . Then applying both\r\noperations to and a single operation to instead wonât increase the\r\nresulting sum. We can prove this with two cases: We apply to . Note that\r\nsince itâs optimal to apply first when applying both operations, this\r\ncase is essentially: halve both elements, then choose one to apply to.\r\nAnd itâs better to subtract from the greater element, since for . We\r\napply to . We can analyze this with (surprise!) a few cases: . Then\r\nwhichever element we apply both operations to will be , and the result\r\nwill depend only on the other element. for , so itâs better to apply\r\nboth operations to the greater element. . If we apply both operations to\r\nthe greater element, we subtract from the sum. But applying both\r\noperations to the lesser element subtracts from the sum. So itâs optimal\r\nto apply both operations to the greater element. And this covers all\r\ncases where . Letâs fix , the number of elements we apply both\r\noperations to. After taking them out, we will be left with the smallest\r\nelements in the array. Suppose we have operations of type 1 left, and\r\noperations of type 2 left. Weâll assume (otherwise we can apply both\r\noperations to more elements).Notice that itâs optimal to apply our\r\noperations to the greatest remaining elements: subtracting from a\r\ngreater element canât decrease the amount we subtract, and halving a\r\ngreater element canât decrease the amount we take away. So weâre left\r\nwith elements, and we want to choose of them to apply the halving to.\r\nLetâs consider a few cases and try to analyze them. Let , and suppose we\r\nwant to apply to one of them and to the other. . Then it will be optimal\r\nto apply to the greater element. . Then it will be optimal to apply to\r\nthe smaller element. Using this information, we can form the final lemma\r\nwe need for our solution: Let . Suppose we apply to and , and to . Then\r\nit will not increase the answer to apply to one of or instead. There are\r\n4 cases we should consider to prove this lemma: . Then we should apply\r\nto and to the others. . Then we should apply to and to the others. .\r\nThen we should apply to and to the others. . Then we should apply to and\r\nto the others. You can verify that doing this produces the optimal\r\nanswer. And using this lemma, we find that the optimal answer has all\r\noperations applied to some of the middle elements, with all operations\r\napplied to the endpoints.To summarize, the optimal answer will have a\r\nform like this (assuming is sorted in non-increasing order, ): First\r\ncome some elements to which we apply both operations. Second come some\r\nelements to which we apply only . Third come some elements to which we\r\napply only . Fourth come some elements to which we apply only . Finally\r\ncome some elements to which we apply no operations. Note that some of\r\nthese segments may be empty.Itâs easy to verify that itâs optimal to use\r\nall given operations. So if we loop through all possible sizes for the\r\nfirst two segments, we can uniquely determine the sizes of the last\r\nthree. Finally, using prefix sums to quickly find the sums of elements\r\nin a segment, we get an solution.There is an interesting fact: if we\r\nwill fix the size of the first group and calculate the answer for it,\r\nthe function is convex. So the ternary or binary search can be used here\r\nto find the minimum in time, but it was not necessary.\r\n",
    "hint": []
}