{"link": "https://codeforces.com//contest/960/problem/H", "problemId": "172425", "problem_idx": "H", "shortId": "960H", "contest_number": "960", "problem_submissions": {"H": [37076939, 37076112, 37074469, 37077049], "G": [37071263, 57709834, 57709811, 37070456, 37070524, 37070914, 37073469, 37074485, 37075164, 37076234, 37075338, 37079339, 37075175, 37074093, 37077545], "E": [37066041, 37079944, 37063783, 37066048, 37064488, 37061915, 37065298, 37064523, 37070733, 37072090, 37076676, 37064464, 37069828, 37067545, 37067744, 37066196, 37072966], "D": [37064105, 37063850, 37067264, 37066015, 37064335, 37059946, 37066190, 37067902, 37062007, 37066676, 37068757, 37066067, 37061947, 37066618, 37070708, 37069032, 37065961], "F": [37061228, 37060911, 37058043, 37061179, 37057703, 37061709, 37063433, 37060626, 37066935, 37063565, 37062126, 37065836, 37069620, 37066690, 37061224, 37061530, 37061194, 37061393, 37069132], "C": [37059020, 37058186, 37073747, 37057785, 37060772, 37057801, 37056055, 37058782, 37058698, 37060994, 37061675, 37062340, 37067775, 37058977, 37058993, 37058400, 37058570, 37060826], "B": [37057197, 37056331, 37056347, 37056532, 37059595, 37056085, 37057341, 37056165, 37056262, 37056554, 37057292, 37058927, 37056440, 37056660, 37057273, 37056784, 37056702, 37058078], "A": [37055508, 37055332, 37055423, 37055343, 37058650, 37055377, 37058231, 37055321, 37055350, 37055370, 37055431, 37055718, 37055347, 37055410, 37055539, 37055383, 37055552]}, "name": "H. Santa's Gift", "statement": "Santa has an infinite number of candies for each of m flavours. You are\r\ngiven a rooted tree with n vertices. The root of the tree is the\r\nvertex 1. Each vertex contains exactly one candy. The i-th vertex has a\r\ncandy of flavour f_i.Sometimes Santa fears that candies of flavour k\r\nhave melted. He chooses any vertex x randomly and sends the subtree of x\r\nto the Bakers for a replacement. In a replacement, all the candies with\r\nflavour k are replaced with a new candy of the same flavour. The candies\r\nwhich are not of flavour k are left unchanged. After the replacement,\r\nthe tree is restored.The cost of replacing one candy of flavour k is c_k\r\n(given for each k). The Baker keeps the price fixed in order to make\r\ncalculation simple. Every time when a subtree comes for a replacement,\r\nthe Baker charges C, no matter which subtree it is and which flavour it\r\nis.Suppose that for a given flavour k the probability that Santa chooses\r\na vertex for replacement is same for all the vertices. You need to find\r\nout the expected value of in calculating the cost of replacement of\r\nflavour k. The error in calculating the cost is defined as follows.\r\nError\r\nE(k) =\r\n(Actual Cost\r\nPrice\r\ncharged\r\nby\r\nthe\r\nBakers) ^ 2.Note that the actual cost is the cost of replacement of one\r\ncandy of the flavour k multiplied by the number of candies in the\r\nsubtree.Also, sometimes Santa may wish to replace a candy at vertex x\r\nwith a candy of some flavour from his pocket.You need to handle two\r\ntypes of operations: Change the flavour of the candy at vertex x to w.\r\nCalculate the expected value of error in calculating the cost of\r\nreplacement for a given flavour k.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nVI e[N];\nint q[N],hs[N],hv[N],dep[N],id[N],l[N],r[N],bel[N],s[N],f[N],tot;\nll ret[N],ret2[N];\nint n,m,Q,C,fla[N],c[N],ty,u,w,W;\nvoid dfs(int u,int f) {\n\tid[l[u]=++tot]=u;\n\tdep[u]=dep[f]+1;\n\tif (hv[u]) dfs(hv[u],u);\n\trep(j,0,SZ(e[u])) if (e[u][j]!=f&&e[u][j]!=hv[u])\n\t\tdfs(e[u][j],u);\n\tr[u]=tot;\n}\nvoid HLDoT(int rt) {\n\tint t=1;\n\tq[0]=rt;\n\trep(i,0,n) {\n\t\tint u=q[i];\n\t\trep(j,0,SZ(e[u])) if (e[u][j]!=f[u])\n\t\t\tf[e[u][j]]=u,dep[q[t++]=e[u][j]]=dep[u]+1;\n\t}\n\tper(i,0,n) {\n\t\tint u=q[i],p=f[u];\n\t\ts[u]++,s[p]+=s[u];\n\t\tif (!l[u]) l[u]=1;\n\t\tif (hs[p]<s[u]) hs[p]=s[u],hv[p]=u,l[p]=l[u]+1;\n\t}\n\trep(i,0,n) {\n\t\tint u=q[i];\n\t\tif (!bel[u]) bel[u]=u;\n\t\tif (hv[u]) bel[hv[u]]=bel[u];\n\t}\n\tdfs(rt,0);\n}\n\nconst int M=20100000;\nstruct node {\n\tnode *l,*r;\n\tint d;\n\tll s;\n}pool[M],*cur=pool,*rt[N];\n\nnode* newnode() {\n\tnode *p=cur++; p->l=p->r=0; p->d=0;\n\treturn p;\n}\nvoid modify(node *p,int l,int r,int pl,int pr,int v,int d) {\n\tif (l==pl&&r==pr) {\n//\t\tprintf(\"ff %d %d %lld %lld\\n\",l,r,p->s,2ll*d*(p->s+(ll)v*(r-l+1)));\n\t\tret2[W]+=2ll*d*(p->s+(ll)v*(r-l+1));\n\t\tp->s+=(ll)(pr-pl+1)*d;\n\t\tp->d+=d;\n\t} else {\n\t\tp->s+=(ll)(pr-pl+1)*d;\n\t\tv+=p->d;\n\t\tint md=(l+r)>>1;\n\t\tif (pl<=md) {\n\t\t\tif (!p->l) p->l=newnode();\n\t\t\tmodify(p->l,l,md,pl,min(pr,md),v,d);\n\t\t}\n\t\tif (pr>md) {\n\t\t\tif (!p->r) p->r=newnode();\n\t\t\tmodify(p->r,md+1,r,max(md+1,pl),pr,v,d);\n\t\t}\n\t}\n}\n\nvoid add(int u,int val) {\n\tint w=fla[u];\n\twhile (u) {\n\t\tW=w;\n\t\tmodify(rt[w],1,n,l[bel[u]],l[u],0,val);\n\t\tret2[W]+=l[u]-l[bel[u]]+1;\n\t\tret[W]+=val*(l[u]-l[bel[u]]+1);\n\t\tu=f[bel[u]];\n\t}\n}\nvoid build() {\n\tcur=pool;\n\trep(i,1,m+1) rt[i]=newnode(),ret[i]=ret2[i]=0;\n\trep(i,1,n+1) add(i,1);\n}\nint main() {\n\tscanf(\"%d%d%d%d\",&n,&m,&Q,&C);\n\trep(i,1,n+1) scanf(\"%d\",fla+i);\n\trep(i,2,n+1) {\n\t\tscanf(\"%d\",f+i);\n\t\te[f[i]].pb(i);\n\t}\n\tHLDoT(1);\n\tbuild();\n\trep(i,1,m+1) scanf(\"%d\",c+i);\n//\trep(i,1,m+1) printf(\"%d %lld %lld\\n\",i,ret[i],ret2[i]);\n\trep(i,0,Q) {\n\t\tscanf(\"%d%d\",&ty,&u);\n\t\tif (ty==1) {\n\t\t\tscanf(\"%d\",&w);\n\t\t\tadd(u,-1);\n\t\t\tfla[u]=w;\n\t\t\tadd(u,1);\n\t\t} else {\n\t\t\tprintf(\"%.10f\\n\",(1.*ret2[u]*c[u]*c[u]-2.*ret[u]*c[u]*C+1.*C*C*n)/n);\n\t\t}\n\t\tif (cur-pool>=M-2000) build();\n//\t\trep(i,1,m+1) printf(\"%d %lld %lld\\n\",i,ret[i],ret2[i]);\n\t}\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "3100", "interactive": false}