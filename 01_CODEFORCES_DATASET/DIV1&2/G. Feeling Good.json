{"link": "https://codeforces.com//contest/1214/problem/G", "problemId": "403810", "problem_idx": "G", "shortId": "1214G", "contest_number": "1214", "problem_submissions": {"G": [60015427, 60116387, 60017546, 60017495, 60020107, 60006609, 60352777, 60002997, 60009463, 60011243], "H": [60007228, 60007997, 60003236, 60009685, 60010066, 60011259, 60011282, 60010896, 60009334, 60014724, 60008843, 60014112, 60047947, 60007110, 60062101, 60075338], "F": [59997972, 59999955, 60011529, 60001435, 59997615, 60004519, 60003172, 60003385, 60014786, 60014588, 60009696, 60014299, 60009888, 60047758, 60003766, 59999966, 60002829, 60000810], "E": [59991588, 59992896, 59995584, 59992549, 59995811, 59995619, 59997178, 59995808, 59993809, 59992236, 59997269, 59997999, 59997711, 59993230, 59995040, 59995208, 59994715, 59993710, 59996947, 59988545], "D": [59988102, 59989658, 59989675, 59986719, 59990868, 59992865, 59990765, 59991828, 59988538, 59989605, 59989462, 59992741, 59999498, 59988876, 60017942, 59989391, 59991386, 59989567, 59990626, 60046854, 59985851], "C": [59984445, 59985337, 59984895, 59983957, 59985031, 59985481, 59984019, 59986980, 59984427, 59984066, 59984382, 59987002, 59982712, 59984754, 59984720, 59985711, 59985097, 59984496, 59982839, 59983656], "B": [59983717, 59984061, 59983687, 59983257, 59983195, 59983710, 59983075, 59985335, 59983154, 59983158, 59983522, 59985251, 59983191, 59983505, 59982763, 59984237, 59983907, 59983359, 59984573, 59982988], "A": [59982834, 59982716, 59982610, 59982747, 59982737, 59982711, 59982633, 59982961, 59982657, 59982623, 59982788, 59982811, 59983962, 59982673, 59985703, 59982891, 59983099, 59982727, 59985651, 59982701]}, "name": "G. Feeling Good", "statement": "Recently biologists came to a fascinating conclusion about how to find a\r\nchameleon mood. Consider chameleon body to be a rectangular table n\r\ntimes m, each cell of which may be green or blue and may change between\r\nthese two colors. We will denote as (x, y) (1\r\nleq x\r\nleq n, 1\r\nleq y\r\nleq m) the cell in row x and column y.Let us define a chameleon to be\r\nfour cells which are corners of some subrectangle of the table, such\r\nthat colors in opposite cells among these four are similar, and at the\r\nsame time not all of the four cell colors are similar. Formally, it is a\r\ngroup of four cells (x_1, y_1), (x_1, y_2), (x_2, y_1), (x_2, y_2) for\r\nsome 1\r\nleq x_1 < x_2\r\nleq n, 1\r\nleq y_1 < y_2\r\nleq m, that colors of (x_1, y_1) and (x_2, y_2) coincide and colors of\r\n(x_1, y_2) and (x_2, y_1) coincide, but not all of the four cells share\r\nthe same color. It was found that whenever such four cells are present,\r\nchameleon is in good mood, and vice versa: if there are no such four\r\ncells, chameleon is in bad mood.You are asked to help scientists write a\r\nprogram determining the mood of chameleon. Let us consider that\r\ninitially all cells of chameleon are green. After that chameleon\r\ncoloring may change several times. On one change, colors of contiguous\r\nsegment of some table row are replaced with the opposite. Formally, each\r\ncolor change is defined by three integers a, l, r (1\r\nleq a\r\nleq n, 1\r\nleq l\r\nleq r\r\nleq m). On such change colors of all cells (a, b) such that l\r\nleq b\r\nleq r are replaced with the opposite.Write a program that reports mood\r\nof the chameleon after each change. Additionally, if the chameleon mood\r\nis good, program should find out any four numbers x_1, y_1, x_2, y_2\r\nsuch that four cells (x_1, y_1), (x_1, y_2), (x_2, y_1), (x_2, y_2) are\r\nthe good mood certificate.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=2050;\nbitset<2048> f[N],mask[N];\nint pc[N],n,m,q;\nset<PII> st,inv;\nPII cc[N][N];\n\nint ff(const bitset<2048> &a) {\n//\trep(i,0,2048) if (a[i]) return i;\n\treturn a._Find_first();\n}\n\nbool check(int a,int b) {\n//\tprintf(\"gg %d %d\\n\",a,b);\n\tif (a==-1||b==-1) return 0;\n\tbitset<2048> g=f[a]&f[b]; g[2047]=1;\n\n\tcc[a][b]=mp(ff(g^f[a]),ff(g^f[b]));\n\treturn (cc[a][b].fi!=2047);\n}\nvoid output(int a,int b) {\n\tPII x(a,cc[a][b].fi+1),y(b,cc[a][b].se+1);\n\tif (x>y) swap(x,y);\n\tif (x.se>y.se) swap(x.se,y.se);\n/*\tassert(x.fi<y.fi); assert(1<=x.fi&&y.fi<=n);\n\tassert(x.se<y.se); assert(1<=x.se&&y.se<=m);\n\tassert(f[x.fi][x.se-1]==f[y.fi][y.se-1]&&f[x.fi][x.se-1]!=f[y.fi][x.se-1]&&\n\t\tf[x.fi][x.se-1]!=f[x.fi][y.se-1]);\n\tputs(\"1\");*/\n\tprintf(\"%d %d %d %d\\n\",x.fi,x.se,y.fi,y.se);\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\trep(i,1,m+1) {\n\t\tmask[i]=mask[i-1];\n\t\tmask[i][i-1]=1;\n\t}\n\trep(i,1,n+1) st.insert(mp(0,i));\n\tst.insert(mp(-1,-1));\n\tst.insert(mp(m+1,-1));\t\n\trep(i,0,q) {\n\t\tint a,l,r;\n\t\tscanf(\"%d%d%d\",&a,&l,&r);\n\t\tauto it=st.find(mp(pc[a],a));\n\t\tauto pit=it,qit=it;\n\t\t--pit; ++qit;\n\t\tif (inv.count(mp(pit->se,it->se))) {\n\t\t\tinv.erase(mp(pit->se,it->se));\n\t\t}\n\t\tif (inv.count(mp(it->se,qit->se))) {\n\t\t\tinv.erase(mp(it->se,qit->se));\n\t\t}\n\t\tif (check(pit->se,qit->se)) inv.insert(mp(pit->se,qit->se));\n\t\tst.erase(it);\n\t\tf[a]^=mask[r]^mask[l-1];\n\t\tpc[a]=f[a].count();\n\t\tst.insert(mp(pc[a],a));\n\t\tit=st.find(mp(pc[a],a));\n\t\tpit=it,qit=it;\n\t\t--pit; ++qit;\n\t\tif (inv.count(mp(pit->se,qit->se))) {\n\t\t\tinv.erase(mp(pit->se,qit->se));\n\t\t}\n\t\tif (check(pit->se,it->se)) inv.insert(mp(pit->se,it->se));\n\t\tif (check(it->se,qit->se)) inv.insert(mp(it->se,qit->se));\n\t\tif (inv.empty()) {\n\t\t\tputs(\"-1\");\n\t\t} else {\n\t\t\tauto it=inv.begin();\n\t\t\toutput(it->fi,it->se);\n\t\t}\n\t}\n}"], "input": "", "output": "", "tags": ["bitmasks", "data structures"], "dificulty": "3200", "interactive": false}