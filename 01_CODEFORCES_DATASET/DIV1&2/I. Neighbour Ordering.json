{
    "link": "https://codeforces.com//contest/1656/problem/I",
    "problemId": "1341212",
    "problem_idx": "I",
    "shortId": "1656I",
    "contest_number": "1656",
    "problem_submissions": {
        "H": [
            150787257,
            150834092,
            150833898,
            150779624,
            150791810,
            150792367,
            150793746,
            150802821,
            150793244,
            150784328,
            150836239,
            150786830,
            150787392,
            150775313,
            150792322,
            150812291,
            150837917,
            150835814,
            150835788,
            150835748,
            150835735,
            150835565,
            150835404,
            150835313,
            150835295,
            150835202,
            150835140,
            150813121
        ],
        "G": [
            150769137,
            150790740,
            150776335,
            150781798,
            150778878,
            150781350,
            150783120,
            150789415,
            150791824,
            150790309,
            150773559,
            150791984,
            150793946,
            150800739,
            150800780
        ],
        "F": [
            150759585,
            150758819,
            150757088,
            150759741,
            150768307,
            150764851,
            150771817,
            150759499,
            150756577,
            150773688,
            150782772,
            150774145,
            150769570,
            150765258,
            150764625,
            150756214,
            150776414,
            150776503,
            150774655,
            150777047
        ],
        "E": [
            150751361,
            150745742,
            150744206,
            150750256,
            150757531,
            150753091,
            150760157,
            150764520,
            150764445,
            150756529,
            150749400,
            150762413,
            150747229,
            150753617,
            150756813,
            150745115,
            150752324,
            150758442,
            150759352,
            150761061
        ],
        "D": [
            150742723,
            150736825,
            150739691,
            150737309,
            150752373,
            150748905,
            150751158,
            150737577,
            150743318,
            150744109,
            150743943,
            150742795,
            150742345,
            150737178,
            150746671,
            150740470,
            150742866,
            150748659,
            150752013,
            150752792
        ],
        "C": [
            150733096,
            150732015,
            150737243,
            150731632,
            150734197,
            150741651,
            150741487,
            150729270,
            150734650,
            150732482,
            150734630,
            150733212,
            150733482,
            150730538,
            150732987,
            150735181,
            150734697,
            150735222,
            150738885,
            150734495
        ],
        "B": [
            150727707,
            150727564,
            150729524,
            150727729,
            150727957,
            150730109,
            150730045,
            150725120,
            150728043,
            150726472,
            150725778,
            150727111,
            150726454,
            150727018,
            150729221,
            150817665,
            150730058,
            150728199,
            150728859,
            150727704
        ],
        "A": [
            150725204,
            150724798,
            150724946,
            150724479,
            150724835,
            150724855,
            150724694,
            150724426,
            150724692,
            150724405,
            150724424,
            150724740,
            150724465,
            150724564,
            150725589,
            150725242,
            150725512,
            150724576,
            150724789,
            150724666
        ],
        "I": [
            150839781,
            150825396
        ]
    },
    "name": "I. Neighbour Ordering",
    "statement": "Given an undirected graph G, we say that a is an ordered list of all the\r\nneighbours of a vertex for each of the vertices of G. Consider a given\r\nneighbour ordering of G and three vertices u, v and w, such that v is a\r\nneighbor of u and w. We write u <_{v} w if u comes after w in vâ€™s\r\nneighbor list.A neighbour ordering is said to be if, for each simple\r\ncycle v_1, v_2,\r\nldots, v_c of the graph, one of the following is satisfied: v_1 <_{v_2}\r\nv_3, v_2 <_{v_3} v_4,\r\nldots, v_{c-2} <_{v_{c-1}} v_c, v_{c-1} <_{v_c} v_1, v_c <_{v_1} v_2.\r\nv_1 >_{v_2} v_3, v_2 >_{v_3} v_4,\r\nldots, v_{c-2} >_{v_{c-1}} v_c, v_{c-1} >_{v_c} v_1, v_c >_{v_1} v_2.\r\nGiven a graph G, determine whether there exists a good neighbour\r\nordering for it and construct one if it does.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\n/** Block-Cut/SPQR Tree\n *\n *  A class to compute and represent the block-cut and SPQR trees of a static\n *  undirected (multi)graph.\n *\n *  We have several node types:\n *  - Q: a single real edge and a single virtual edge\n *  - I: a bridge edge of the original graph\n *  - O: exactly 1 self loop or 2 parallel edges (a degenerate case of both S and P)\n *  - S: at least 3 series edges (in a cycle)\n *  - P: at least 3 parallel edges\n *  - R: a rigid component\n *  Note that 2 parallel Q nodes are never glued directly together; they are always\n *  glued to an O or P node.\n *\n *  Every real edge is stored in a Q node. The Q node for edge e is numbered e\n *  and contains virtual edge e. You can test that virtual edge corresponds\n *  to a single real edge using `tree.vedges[ve].o_type == node_type::Q` or\n *  less directly `tree.vedges[ve].o_ve < NE`.\n *\n *  We have several named objects: Vertices, Components (CCs), Blocks (BCCs),\n *  Nodes (TCCs), and VirtualEdges (which include edges as described above).\n *  The various objects have the following relationships:\n *   * Components contain Vertices\n *   * Components contain Blocks contain Nodes contain VirtualEdges\n *   * Vertices are adjacent to Blocks, Nodes, and VirtualEdges (many-to-many)\n *\n *  The tree is specified unrooted, but is implicitly rooted: everything is\n *  numbered in postorder (except for Q nodes/their virtual edges). In\n *  particular, Nodes contain intervals of VirtualEdges, Blocks contain\n *  intervals of Nodes, and so on. Note that the Block/Component intervals do\n *  not include their Q Nodes/VEdges!\n *\n *  More specifically, vectors of adjacent/contained objects are all\n *  represented as range_t's, representing subintervals of the corresponding\n *  array. Note that, vertices do not have 1-to-1 relationships, so for those\n *  relations, we need to look up the corresponding array.\n */\nstruct spqr_tree {\n\tstatic constexpr bool PRINT_DEBUG = false;\n\n\t// Number of vertices\n\tint NV = 0;\n\t// Number of real edges\n\tint NE = 0;\n\n\t// Number of connected components\n\tint NC = 0;\n\t// Number of blocks\n\tint NB = 0;\n\t// Number of SPQR nodes\n\tint NN = 0;\n\t// Number of virtual edges\n\tint NVE = 0;\n\n\t// TODO: make range_t's easier to use, particularly the ones requiring a second indirection.\n\tstruct range_t {\n\t\tint st = -1, en = -1;\n\t\tint size() const { return en - st; }\n\t\tbool contains(int v) const { return st <= v && v < en; }\n\t};\n\tstruct iterable_range_t : public range_t {\n\t\tstruct iterator {\n\t\t\tint v;\n\t\t\tint operator * () const { return v; }\n\t\t\titerator& operator ++ () { ++v; return *this; }\n\t\t\tfriend bool operator != (iterator a, iterator b) { return a.v != b.v; }\n\t\t};\n\t\titerator begin() const { return iterator{st}; }\n\t\titerator end() const { return iterator{en}; }\n\t};\n\ttemplate <typename T> struct bound_array_range_t {\n\t\ttypename std::vector<T>::const_iterator st, en;\n\t\tint size() const { return int(en - st); }\n\t\tauto begin() const { return st; }\n\t\tauto end() const { return en; }\n\t};\n\ttemplate <typename T, std::vector<T> spqr_tree::* array> struct array_range_t : public range_t {\n\t\tbound_array_range_t<T> bind(const spqr_tree& tree) const {\n\t\t\treturn {(tree.*array).begin() + st, (tree.*array).begin() + en};\n\t\t}\n\t};\n\ttemplate <typename T, std::vector<T> spqr_tree::* array> struct enumerable_array_range_t : public iterable_range_t {\n\t\tbound_array_range_t<T> bind(const spqr_tree& tree) const {\n\t\t\treturn {(tree.*array).begin() + st, (tree.*array).begin() + en};\n\t\t}\n\t};\n\n\tstruct vertex_t;\n\tstd::vector<vertex_t> vertices;\n\tstd::vector<int> vertex_blocks;\n\n\tstruct component_t;\n\tstd::vector<component_t> components;\n\tstd::vector<int> component_vertices;\n\n\tstruct block_t;\n\tstd::vector<block_t> blocks;\n\tstd::vector<int> block_vertices;\n\n\tstruct node_t;\n\tstd::vector<node_t> nodes;\n\tstd::vector<int> node_vertices;\n\n\tstruct vedge_t;\n\tstd::vector<vedge_t> vedges;\n\n\tstruct vertex_t {\n\t\tint component = -1;\n\t\tarray_range_t<int, &spqr_tree::vertex_blocks> vertex_blocks;\n\t\t// TODO: maybe we want vertex_nodes or even vertex_block_nodes or something\n\t};\n\tstruct component_t {\n\t\tenumerable_array_range_t<block_t, &spqr_tree::blocks> blocks;\n\t\tenumerable_array_range_t<node_t, &spqr_tree::nodes> nodes;\n\t\tenumerable_array_range_t<vedge_t, &spqr_tree::vedges> vedges;\n\t\tarray_range_t<int, &spqr_tree::component_vertices> component_vertices;\n\t};\n\n\tstruct block_t {\n\t\tint component = -1;\n\t\tenumerable_array_range_t<node_t, &spqr_tree::nodes> nodes;\n\t\tenumerable_array_range_t<vedge_t, &spqr_tree::vedges> vedges;\n\t\tarray_range_t<int, &spqr_tree::block_vertices> block_vertices;\n\t};\n\n\tenum class node_type : char {\n\t\tQ = 'Q', I = 'I', O = 'O', S = 'S', P = 'P', R = 'R'\n\t};\n\n\tstruct node_t {\n\t\tnode_type type;\n\t\tint component = -1;\n\t\tint block = -1;\n\t\tenumerable_array_range_t<vedge_t, &spqr_tree::vedges> vedges;\n\t\tarray_range_t<int, &spqr_tree::node_vertices> node_vertices;\n\t};\n\n\tstruct vedge_t {\n\t\tstd::array<int, 2> vs;\n\t\tint component = -1;\n\t\tint block = -1;\n\t\tint node = -1;\n\t\tbool is_tree = false;\n\n\t\t// Information on the opposite virtual edge and its node\n\t\tint o_ve = -1;\n\t\tint o_node = -1;\n\t\tnode_type o_type;\n\t};\n\n\tstd::vector<int> depth;\n\nprivate:\n\t// Pairs of nxt, e\n\t// Negative e means new block; otherwise, it's 2*e + (has_nontrivial_lowval2)\n\tstd::vector<std::pair<int, int>> adj_lists;\n\tstd::vector<array_range_t<std::pair<int, int>, &spqr_tree::adj_lists>> adj;\n\n\tstruct bucket_edge_t {\n\t\tint v; int e; int cur, nxt;\n\t};\n\tstd::vector<bucket_edge_t> bucket_edges;\n\n\tstd::pair<int, int> dfs_lowval(int cur, int d, int prvE) {\n\t\tdepth[cur] = d;\n\t\tint v1 = d, v2 = d;\n\t\tfor (auto [nxt, e] : adj[cur].bind(*this)) {\n\t\t\tif (e == prvE) continue;\n\t\t\tif (depth[nxt] == -1) {\n\t\t\t\tconst auto [n1, n2] = dfs_lowval(nxt, d+1, e);\n\n\t\t\t\tif (n1 >= d) {\n\t\t\t\t\tbucket_edges.push_back({0, ~e, cur, nxt});\n\t\t\t\t} else {\n\t\t\t\t\tbucket_edges.push_back({1 + n1 * 2 + (n2 < d), 2*e + (n2 < d), cur, nxt});\n\t\t\t\t}\n\n\t\t\t\tif (n1 < v1) {\n\t\t\t\t\tv2 = std::min(v1, n2);\n\t\t\t\t\tv1 = n1;\n\t\t\t\t} else if (n1 == v1) {\n\t\t\t\t\tv2 = std::min(v2, n2);\n\t\t\t\t} else {\n\t\t\t\t\tv2 = std::min(v2, n1);\n\t\t\t\t}\n\t\t\t} else if (depth[nxt] <= d) {\n\t\t\t\tint nd = depth[nxt];\n\t\t\t\tif (nd == d) {\n\t\t\t\t\t// Self-loop\n\t\t\t\t\tbucket_edges.push_back({0, ~e, cur, nxt});\n\t\t\t\t} else {\n\t\t\t\t\tbucket_edges.push_back({1 + nd * 2, 2*e, cur, nxt});\n\t\t\t\t}\n\n\t\t\t\tif (nd < v1) {\n\t\t\t\t\tv2 = v1;\n\t\t\t\t\tv1 = nd;\n\t\t\t\t} else if (v1 < nd) {\n\t\t\t\t\tv2 = std::min(v2, nd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// reverse of a back-edge (downwards)\n\t\t\t\t// skip it\n\t\t\t}\n\t\t}\n\t\treturn {v1, v2};\n\t}\n\n\tvoid build_sorted_adj(std::vector<std::array<int, 2>> edges, int root) {\n\t\t{\n\t\t\tstd::vector<int> deg(NV, 0);\n\t\t\tfor (auto e : edges) {\n\t\t\t\tfor (int v : e) {\n\t\t\t\t\tdeg[v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj.resize(NV);\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < NV; i++) {\n\t\t\t\tadj[i].st = adj[i].en = cur;\n\t\t\t\tcur += deg[i];\n\t\t\t}\n\t\t\tadj_lists.resize(cur);\n\t\t}\n\t\tfor (int e = 0; e < int(edges.size()); e++) {\n\t\t\tauto [u, v] = edges[e];\n\t\t\tadj_lists[adj[u].en++] = {v, e};\n\t\t\tif (u != v) {\n\t\t\t\tadj_lists[adj[v].en++] = {u, e};\n\t\t\t}\n\t\t}\n\n\t\tdepth = std::vector<int>(NV, -1);\n\n\t\t// Bucketed so that bridges come first, then BCCs, then children from shallowest to deepest lowval\n\t\tbucket_edges.reserve(NE);\n\n\t\tfor (int rt = 0; rt < NV; rt++) {\n\t\t\tif (root != -1 && rt != root) continue;\n\t\t\tif (depth[rt] != -1) continue;\n\t\t\tdfs_lowval(rt, 0, -1);\n\t\t}\n\t\tassert(int(bucket_edges.size()) == NE);\n\n\t\tfor (auto& v : adj) {\n\t\t\tv.en = v.st;\n\t\t}\n\n\t\tstd::vector<int> bucket_st(1 + NV * 2);\n\t\tfor (int i = 0; i < int(bucket_edges.size()); i++) {\n\t\t\t++bucket_st[bucket_edges[i].v];\n\t\t}\n\t\t{\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < int(bucket_st.size()); i++) {\n\t\t\t\tbucket_st[i] = std::exchange(cur, cur + bucket_st[i]);\n\t\t\t}\n\t\t\tassert(cur == int(bucket_edges.size()));\n\t\t}\n\t\tstd::vector<bucket_edge_t> bucket_edges_2(bucket_edges.size());\n\t\tfor (int i = 0; i < int(bucket_edges.size()); i++) {\n\t\t\tbucket_edges_2[bucket_st[bucket_edges[i].v]++] = bucket_edges[i];\n\t\t}\n\t\tbucket_edges = {};\n\t\tfor (auto [_, e, cur, nxt] : bucket_edges_2) {\n\t\t\tadj_lists[adj[cur].en++] = {nxt, e};\n\t\t}\n\t}\n\n\t// Tree edges have v = {child, parent}\n\t// Backedges edges have v = {top, bottom}\n\n\tstruct vestack_t {\n\t\tstd::array<int, 2> vs;\n\t\tbool is_tree = false;\n\t\tint o_ve = -1;\n\t\tint o_node = -1;\n\t\tnode_type o_type;\n\t};\n\tstd::vector<vestack_t> vestack;\n\n\tusing vestack_range_t = enumerable_array_range_t<vestack_t, &spqr_tree::vestack>;\n\n\tstruct estack_t {\n\t\tstd::array<int, 2> vs;\n\t\tvestack_range_t vestack_range;\n\t\tnode_type type;\n\t\tbool is_tree;\n\t};\n\tstd::vector<estack_t> estack;\n\n\tstruct tstack_t {\n\t\tint idx; // idx in estack\n\t\tint vstart;\n\t\tint top_depth;\n\t};\n\tstd::vector<tstack_t> tstack;\n\n\tstd::vector<int> first_occurrence;\n\n\tint cur_component;\n\tint cur_block;\n\n\tvoid finalize_node(estack_t es, vestack_t cap) {\n\t\tassert(es.type != node_type::Q);\n\t\tint node = int(nodes.size());\n\n\t\tnode_t n;\n\t\tn.type = es.type;\n\t\tn.component = cur_component;\n\t\tn.block = cur_block;\n\n\t\tn.vedges.st = int(vedges.size());\n\t\tn.node_vertices.st = int(node_vertices.size());\n\n\t\tauto push_vestack_t = [&](const vestack_t& ves) {\n\t\t\tvedges.push_back(vedge_t{\n\t\t\t\tves.vs,\n\t\t\t\tcur_component,\n\t\t\t\tcur_block,\n\t\t\t\tnode,\n\t\t\t\tves.is_tree,\n\t\t\t\tves.o_ve,\n\t\t\t\tves.o_node,\n\t\t\t\tves.o_type,\n\t\t\t});\n\t\t\tint ve = int(vedges.size()) - 1;\n\t\t\tint o_ve = ves.o_ve;\n\t\t\tif (o_ve != -1) {\n\t\t\t\tvedges[o_ve].o_ve = ve;\n\t\t\t\tvedges[o_ve].o_node = node;\n\t\t\t\tvedges[o_ve].o_type = n.type;\n\t\t\t}\n\t\t};\n\n\t\tfor (const auto& ves : es.vestack_range.bind(*this)) {\n\t\t\tpush_vestack_t(ves);\n\t\t\tif (ves.is_tree) {\n\t\t\t\tint cnd = ves.vs[0];\n\t\t\t\tif (cnd != cap.vs[0] && cnd != cap.vs[1]) {\n\t\t\t\t\tnode_vertices.push_back(cnd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(cap.vs[0] == es.vs[1]);\n\t\tassert(cap.vs[1] == es.vs[0]);\n\t\tassert(cap.is_tree == !es.is_tree);\n\t\tpush_vestack_t(cap);\n\t\tif (cap.vs[0] == cap.vs[1]) {\n\t\t\tnode_vertices.push_back(cap.vs[0]);\n\t\t} else {\n\t\t\tfor (int v : cap.vs) {\n\t\t\t\tnode_vertices.push_back(v);\n\t\t\t}\n\t\t}\n\n\t\tNVE = int(vedges.size());\n\n\t\tn.vedges.en = int(vedges.size());\n\t\tn.node_vertices.en = int(node_vertices.size());\n\n\t\tNN++;\n\t\tnodes.push_back(n);\n\t}\n\n\tvestack_t finalize_estack(estack_t es) {\n\t\tvestack_t cap;\n\t\tcap.vs[0] = es.vs[1];\n\t\tcap.vs[1] = es.vs[0];\n\t\tcap.is_tree = !es.is_tree;\n\n\t\tint o_ve;\n\t\tint o_node;\n\t\tif (es.type == node_type::Q) {\n\t\t\tint e = vestack[es.vestack_range.st].o_ve;\n\t\t\to_ve = o_node = e;\n\t\t\tassert(cap.vs == vedges[e].vs && cap.is_tree == vedges[e].is_tree);\n\t\t} else {\n\t\t\tfinalize_node(es, cap);\n\t\t\to_ve = int(vedges.size()) - 1;\n\t\t\to_node = int(nodes.size()) - 1;\n\t\t}\n\n\t\tvestack_t ve;\n\t\tve.vs = es.vs;\n\t\tve.is_tree = es.is_tree;\n\t\tve.o_ve = o_ve;\n\t\tve.o_node = o_node;\n\t\tve.o_type = es.type;\n\t\treturn ve;\n\t}\n\n\tvoid push_estack(estack_t e_ins) {\n\t\tif constexpr (PRINT_DEBUG) std::cerr << \"push_estack \" << e_ins.vs[0] << '-' << e_ins.vs[1] << ' ' << e_ins.is_tree << '\\n';\n\t\testack.push_back(e_ins);\n\t\tint v = e_ins.vs[0];\n\t\tif (first_occurrence[v] == -1) {\n\t\t\tfirst_occurrence[v] = int(estack.size()) - 1;\n\t\t}\n\t}\n\n\tvoid push_estack_p(estack_t e_ins) {\n\t\tif constexpr (PRINT_DEBUG) std::cerr << \"push_estack_p \" << e_ins.vs[0] << '-' << e_ins.vs[1] << ' ' << e_ins.is_tree << '\\n';\n\t\tif (estack.back().type == node_type::P) {\n\t\t\tint st = e_ins.vestack_range.st;\n\t\t\tvestack[st] = finalize_estack(e_ins);\n\t\t\tvestack.resize(st+1);\n\t\t\tassert(estack.back().vestack_range.en == st);\n\t\t\testack.back().vestack_range.en ++;\n\t\t} else {\n\t\t\tint st = estack.back().vestack_range.st;\n\t\t\tvestack[st] = finalize_estack(estack.back());\n\t\t\tvestack[st+1] = finalize_estack(e_ins);\n\t\t\tvestack.resize(st+2);\n\t\t\testack.back().vestack_range = {st, st+2};\n\t\t\testack.back().type = node_type::P;\n\t\t}\n\t}\n\n\tvoid prepare_pop_estack(int z) {\n\t\tint v = estack[z].vs[0];\n\t\tif (first_occurrence[v] == z) {\n\t\t\tfirst_occurrence[v] = -1;\n\t\t}\n\t}\n\tvoid pop_estack() {\n\t\tprepare_pop_estack(int(estack.size()) - 1);\n\t\testack.pop_back();\n\t}\n\n\t// push_estack_p is a lot like push_estack + pop_estack_range, but their\n\t// handling of first_occurrence would differ, so we'll leave them separate\n\tstd::pair<vestack_range_t, node_type> pop_estack_range(int idx) {\n\t\tassert(int(estack.size()) - idx > 1);\n\t\tfor (int z = idx; z < int(estack.size()); z++) {\n\t\t\tprepare_pop_estack(z);\n\t\t}\n\n\t\tbool is_S = (int(estack.size()) - idx == 2);\n\t\tif (is_S) {\n\t\t\tassert(estack.back().type != node_type::S);\n\t\t}\n\t\tbool should_reuse = (is_S && estack[idx].type == node_type::S);\n\t\tint st = estack[idx].vestack_range.st;\n\n\t\tint sidx = idx + should_reuse;\n\t\tint en = estack[sidx].vestack_range.st;\n\t\tfor (int z = sidx; z < int(estack.size()); z++) {\n\t\t\tvestack[en++] = finalize_estack(estack[z]);\n\t\t}\n\n\t\tvestack.resize(en);\n\t\testack.resize(idx);\n\t\treturn {{st, en}, is_S ? node_type::S : node_type::R};\n\t}\n\n\testack_t make_q_node(int e, int cur, int nxt, bool is_tree) {\n\t\tvedges[e].vs = {cur, nxt};\n\t\tvedges[e].component = cur_component;\n\t\tvedges[e].block = cur_block;\n\t\tvedges[e].node = e;\n\t\tvedges[e].is_tree = !is_tree;\n\t\t// We're gonna put a dummy entry on vestack for 2 reasons:\n\t\t// 1. This lets the pop_estack_range logic has 1 scratch space per estack\n\t\t// 2. We need to lookup the edge for finalize_estack, which we'll smuggle in as o_ve\n\t\tvestack.emplace_back();\n\t\tvestack.back().o_ve = e;\n\n\t\tnodes[e].type = node_type::Q;\n\t\tnodes[e].component = cur_component;\n\t\tnodes[e].block = cur_block;\n\t\tnodes[e].vedges = {e, e+1};\n\t\tnodes[e].node_vertices = {2*e, 2*e + (cur == nxt ? 1 : 2)};\n\t\tnode_vertices[2*e] = cur;\n\t\tnode_vertices[2*e+1] = nxt;\n\n\t\treturn estack_t{{nxt, cur}, {int(vestack.size()) - 1, int(vestack.size())}, node_type::Q, is_tree};\n\t}\n\n\tvoid dfs_spqr(int cur, int cur_low) {\n\t\tint cur_depth = depth[cur];\n\t\tfor (auto [nxt, e] : adj[cur].bind(*this)) {\n\t\t\tif (e < 0) continue;\n\t\t\tbool is_type_1 = !(e & 1);\n\t\t\te >>= 1;\n\n\t\t\tint orig_size = int(estack.size());\n\n\t\t\tbool is_tree = (depth[nxt] > cur_depth);\n\t\t\tif (is_tree) {\n\t\t\t\tdfs_spqr(nxt, cur_low);\n\n\t\t\t\t// Before we insert our edge, we may have to fix the single-tree-edge tstack\n\t\t\t\tassert(!tstack.empty());\n\t\t\t\tif (tstack.back().top_depth == cur_depth + 1) {\n\t\t\t\t\tassert(tstack.back().idx == int(estack.size())-1);\n\t\t\t\t\ttstack.back().top_depth = cur_depth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Deal with the current vedge\n\t\t\testack_t e_ins = make_q_node(e, cur, nxt, is_tree);\n\t\t\tif (is_tree) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (estack.back().vs == std::array<int, 2>{cur, nxt}) {\n\t\t\t\t\t\tpush_estack_p(e_ins);\n\t\t\t\t\t\te_ins.vestack_range = estack.back().vestack_range;\n\t\t\t\t\t\tassert(estack.back().type == node_type::P);\n\t\t\t\t\t\te_ins.type = node_type::P;\n\n\t\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t\t\tif (tstack.back().idx == int(estack.size()) - 1) {\n\t\t\t\t\t\t\ttstack.pop_back();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Pop it all the way off since we need to\n\t\t\t\t\t\t// change the backedge to a tree edge\n\t\t\t\t\t\tpop_estack();\n\t\t\t\t\t}\n\n\t\t\t\t\tpush_estack(e_ins);\n\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t\tif (tstack.back().top_depth != cur_depth) break;\n\t\t\t\t\tassert(tstack.back().idx > orig_size);\n\t\t\t\t\tif (estack[tstack.back().idx].is_tree) {\n\t\t\t\t\t\tassert(estack[tstack.back().idx].vs[0] == tstack.back().vstart);\n\t\t\t\t\t\tif (int(estack.size()) - tstack.back().idx > 2) {\n\t\t\t\t\t\t\ttstack.push_back({\n\t\t\t\t\t\t\t\ttstack.back().idx + 1,\n\t\t\t\t\t\t\t\testack[tstack.back().idx].vs[1],\n\t\t\t\t\t\t\t\ttstack.back().top_depth\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint idx = tstack.back().idx;\n\t\t\t\t\tassert(idx > orig_size);\n\t\t\t\t\tnxt = tstack.back().vstart;\n\t\t\t\t\ttstack.pop_back();\n\t\t\t\t\tauto [vestack_range, type] = pop_estack_range(idx);\n\t\t\t\t\te_ins = estack_t{{nxt, cur}, vestack_range, type, true};\n\t\t\t\t}\n\n\t\t\t\tif (is_type_1) {\n\t\t\t\t\t// Handle type 1 split\n\n\t\t\t\t\tnxt = estack[orig_size].vs[0];\n\n\t\t\t\t\t// It's possible there are candidates before orig_size\n\t\t\t\t\t// on the stack, but those are doomed to fail, so\n\t\t\t\t\t// it's fine to pop them prematurely.\n\t\t\t\t\twhile (tstack.back().idx > orig_size) tstack.pop_back();\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t\tif (tstack.back().idx == orig_size) {\n\t\t\t\t\t\tassert(tstack.back().vstart == cur_low && tstack.back().top_depth == depth[nxt]);\n\t\t\t\t\t}\n\n\t\t\t\t\tint idx = orig_size;\n\t\t\t\t\tauto [vestack_range, type] = pop_estack_range(idx);\n\t\t\t\t\te_ins = estack_t{{nxt, cur}, vestack_range, type, false};\n\t\t\t\t\tif (!estack.empty() && estack.back().vs == e_ins.vs) {\n\t\t\t\t\t\tpush_estack_p(e_ins);\n\t\t\t\t\t\t// Pop our tstack and use the previous value\n\t\t\t\t\t\tif (tstack.back().idx == orig_size) tstack.pop_back();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush_estack(e_ins);\n\t\t\t\t\t\t// We don't need to change tstack at all\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_low == cur) {\n\t\t\t\t\t// Pop until we get to the entire range; that's\n\t\t\t\t\t// the only permissible one, since we previously use something\n\t\t\t\t\twhile (tstack.back().idx > orig_size) tstack.pop_back();\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t} else if (first_occurrence[cur] != -1) {\n\t\t\t\t\t// We're the first node, so cur can be interior, but we must include all backedges to cur\n\t\t\t\t\twhile (tstack.back().idx > first_occurrence[cur]) tstack.pop_back();\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t} else {\n\t\t\t\t\t// This is the only case where we can have the tree-edge start the cut.\n\t\t\t\t\t// Notably, this is the only tstack entry with top == cur\n\t\t\t\t\t// (otherwise it's always strictly shallower)\n\t\t\t\t\t// By the time it's resolved, top will be\n\t\t\t\t\t// shallower than cur, but that depends on the\n\t\t\t\t\t// next edge, so we'll fix it then.\n\t\t\t\t\t// We'll also omit the following (equivalent) entry entirely and\n\t\t\t\t\t// handle it when we pop it out.\n\t\t\t\t\ttstack.push_back({int(estack.size())-1, nxt, cur_depth});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!estack.empty() && estack.back().vs == e_ins.vs) {\n\t\t\t\t\tpush_estack_p(e_ins);\n\t\t\t\t\t// Don't change tstack, keep its old low value\n\t\t\t\t} else {\n\t\t\t\t\tpush_estack(e_ins);\n\n\t\t\t\t\t// nxt should be shallower\n\t\t\t\t\tassert(depth[cur_low] > depth[nxt]);\n\t\t\t\t\ttstack_t t_ins{int(estack.size())-1, cur_low, depth[nxt]};\n\t\t\t\t\tassert(tstack.empty() || tstack.back().top_depth <= depth[cur_low]);\n\t\t\t\t\twhile (!tstack.empty() && tstack.back().top_depth > t_ins.top_depth) {\n\t\t\t\t\t\tt_ins.idx = tstack.back().idx;\n\t\t\t\t\t\tt_ins.vstart = tstack.back().vstart;\n\t\t\t\t\t\ttstack.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\ttstack.push_back(t_ins);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur_low = cur;\n\t\t}\n\n\t\tblock_vertices.push_back(cur);\n\t\tvertex_blocks[vertices[cur].vertex_blocks.en++] = cur_block;\n\t}\n\n\tint start_spqr(int cur, int nxt, int e) {\n\t\tint block = NB++;\n\t\tblocks.emplace_back();\n\t\tblocks[block].component = cur_component;\n\t\tblocks[block].nodes.st = int(nodes.size());\n\t\tblocks[block].vedges.st = int(vedges.size());\n\t\tblocks[block].block_vertices.st = int(block_vertices.size());\n\t\tcur_block = block;\n\n\t\tif (nxt != cur) {\n\t\t\tdfs_spqr(nxt, nxt);\n\t\t\tif (estack.empty()) {\n\t\t\t\testack.push_back(estack_t{{cur, nxt}, {int(vestack.size()), int(vestack.size())}, node_type::I, false});\n\t\t\t} else {\n\t\t\t\tassert(int(estack.size()) == 1);\n\t\t\t\tassert((estack.back().vs == std::array<int, 2>{cur, nxt}));\n\t\t\t\tassert(!estack.back().is_tree);\n\n\t\t\t\tif (estack.back().type == node_type::Q) {\n\t\t\t\t\tvestack.back() = finalize_estack(estack.back());\n\t\t\t\t\t// Don't have to change anything else, since Q nodes always have size 1\n\t\t\t\t\testack.back().type = node_type::O;\n\t\t\t\t}\n\n\t\t\t\tassert(!tstack.empty() && tstack.back().idx == 0);\n\t\t\t\ttstack.pop_back();\n\t\t\t}\n\t\t} else {\n\t\t\testack.push_back(estack_t{{cur, cur}, {int(vestack.size()), int(vestack.size())}, node_type::O, true});\n\t\t}\n\n\t\t// Make the q node and immediately overwrite its spot with our desired one\n\t\tauto q_estack = make_q_node(e, cur, nxt, cur != nxt);\n\t\tvestack.back() = finalize_estack(q_estack);\n\n\t\tauto es = estack.back();\n\t\tpop_estack();\n\t\tfinalize_node(es, vestack.back());\n\t\tvestack.resize(es.vestack_range.st);\n\n\t\tassert(tstack.empty());\n\t\tassert(estack.empty());\n\t\tassert(vestack.empty());\n\n\t\tblock_vertices.push_back(cur);\n\n\t\tcur_block = -1;\n\t\tblocks[block].nodes.en = int(nodes.size());\n\t\tblocks[block].vedges.en = int(vedges.size());\n\t\tblocks[block].block_vertices.en = int(block_vertices.size());\n\t\treturn block;\n\t}\n\n\tstd::vector<int> vertex_blocks_buf;\n\tvoid dfs_block(int cur) {\n\t\tint buf_st = int(vertex_blocks_buf.size());\n\t\tfor (auto [nxt, e] : adj[cur].bind(*this)) {\n\t\t\tassert(depth[nxt] <= depth[cur] + 1);\n\t\t\tif (depth[nxt] < depth[cur]) continue;\n\t\t\tif (nxt != cur) {\n\t\t\t\tdfs_block(nxt);\n\t\t\t}\n\t\t\tif (e < 0) {\n\t\t\t\te = ~e;\n\t\t\t\t// Root of a block\n\t\t\t\tint block = start_spqr(cur, nxt, e);\n\n\t\t\t\tvertex_blocks_buf.push_back(block);\n\t\t\t}\n\t\t}\n\n\t\tvertices[cur].vertex_blocks.st = int(vertex_blocks.size());\n\t\tvertex_blocks.insert(vertex_blocks.end(), vertex_blocks_buf.begin() + buf_st, vertex_blocks_buf.end());\n\t\tvertex_blocks_buf.resize(buf_st);\n\t\tvertices[cur].vertex_blocks.en = int(vertex_blocks.size());\n\n\t\t// Placeholder for our parent\n\t\tif (depth[cur] > 0) {\n\t\t\tvertex_blocks.push_back(-1);\n\t\t}\n\n\t\tcomponent_vertices.push_back(cur);\n\t\tvertices[cur].component = cur_component;\n\t}\n\n\tvoid build_spqr() {\n\t\tvertices.resize(NV);\n\t\tvertex_blocks.reserve(NV + NE);\n\n\t\tcomponents.reserve(NV);\n\t\tcomponent_vertices.reserve(NV);\n\n\t\tblocks.reserve(NE);\n\t\tblock_vertices.reserve(NV + NE);\n\n\t\t// # nodes <= 2 * # Q nodes\n\t\tnodes.reserve(2 * NE);\n\t\tNN = NE;\n\t\tnodes.resize(NN);\n\t\t// # node_vertices <= # block_vertices + 2 * # nodes\n\t\tnode_vertices.reserve(NV + 5 * NE);\n\t\tnode_vertices.resize(2 * NE);\n\n\t\t// # vedges ~ 2 * (# nodes - # blocks)\n\t\tvedges.reserve(2 * (2 * NE));\n\t\tNVE = NE;\n\t\tvedges.resize(NVE);\n\n\t\tvertex_blocks_buf.reserve(NE);\n\t\tvestack.reserve(NE);\n\t\testack.reserve(NE);\n\t\ttstack.reserve(NE);\n\t\tfirst_occurrence.assign(NV, -1);\n\n\t\tfor (int rt = 0; rt < NV; rt++) {\n\t\t\tif (depth[rt] != 0) continue;\n\t\t\tint component = NC++;\n\t\t\tcomponents.emplace_back();\n\t\t\tcomponent_t& c = components[component];\n\t\t\tc.blocks.st = int(blocks.size());\n\t\t\tc.nodes.st = int(nodes.size());\n\t\t\tc.vedges.st = int(vedges.size());\n\t\t\tc.component_vertices.st = int(component_vertices.size());\n\n\t\t\tcur_component = component;\n\t\t\tdfs_block(rt);\n\t\t\tcur_component = -1;\n\n\t\t\tc.blocks.en = int(blocks.size());\n\t\t\tc.nodes.en = int(nodes.size());\n\t\t\tc.vedges.en = int(vedges.size());\n\t\t\tc.component_vertices.en = int(component_vertices.size());\n\t\t}\n\n\t\tvertex_blocks_buf = {};\n\t\tvestack = {};\n\t\testack = {};\n\t\ttstack = {};\n\t\tfirst_occurrence = {};\n\t}\n\npublic:\n\tspqr_tree() = default;\n\texplicit spqr_tree(int NV_, std::vector<std::array<int, 2>> edges, int root = -1) {\n\t\tNV = NV_;\n\t\tif (NV == 0) return;\n\n\t\tif (root != -1) {\n\t\t\tassert(0 <= root && root < NV);\n\t\t}\n\n\t\tNE = int(edges.size());\n\n\t\tbuild_sorted_adj(std::move(edges), root);\n\n\t\tbuild_spqr();\n\n\t\tadj = {};\n\t\tadj_lists = {};\n\t\t// Leave depth since it's sometimes useful\n\t\t//depth = {};\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, M; cin >> N >> M;\n\t\tstd::vector<std::array<int, 2>> edges(M);\n\t\tfor (auto& e : edges) {\n\t\t\tfor (auto& v : e) cin >> v;\n\t\t}\n\n\t\tstd::vector<std::vector<int>> ans(N);\n\t\tauto solve = [&]() -> bool {\n\t\t\tconst spqr_tree tree(N, edges);\n\n\t\t\tfor (int node = tree.NE; node < tree.NN; node++) {\n\t\t\t\tif (tree.nodes[node].type == spqr_tree::node_type::R) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::S) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::P) {\n\t\t\t\t\tassert(tree.nodes[node].vedges.size() >= 3);\n\t\t\t\t\tif (tree.nodes[node].vedges.size() > 3) return false;\n\t\t\t\t\tassert(tree.nodes[node].vedges.size() == 3);\n\t\t\t\t\tbool has_real_edge = false;\n\t\t\t\t\tfor (const auto& ve : tree.nodes[node].vedges.bind(tree)) {\n\t\t\t\t\t\tif (ve.o_type == spqr_tree::node_type::Q) {\n\t\t\t\t\t\t\thas_real_edge = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!has_real_edge) return false;\n\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::I) {\n\t\t\t\t} else assert(false);\n\t\t\t}\n\n\t\t\tstd::vector<int> succ(2 * tree.NVE);\n\n\t\t\tfor (int block = 0; block < tree.NB; block++) {\n\t\t\t\tint root_node = tree.blocks[block].nodes.en-1;\n\t\t\t\tauto dfs = std::y_combinator([&](auto self, int node, bool flip) -> void {\n\t\t\t\t\tif (tree.nodes[node].type == spqr_tree::node_type::Q) {\n\t\t\t\t\t\tconst auto& ve = tree.vedges[tree.nodes[node].vedges.st];\n\t\t\t\t\t\tans[ve.vs[0]].push_back(ve.vs[1]);\n\t\t\t\t\t\tans[ve.vs[1]].push_back(ve.vs[0]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::P) {\n\t\t\t\t\t\tint a = tree.nodes[node].vedges.st;\n\t\t\t\t\t\tint b = tree.nodes[node].vedges.st+1;\n\t\t\t\t\t\tint c = tree.nodes[node].vedges.st+2;\n\t\t\t\t\t\tassert(tree.vedges[c].o_type != spqr_tree::node_type::Q);\n\t\t\t\t\t\tif (tree.vedges[a].o_type == spqr_tree::node_type::Q) {\n\t\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(tree.vedges[b].o_type == spqr_tree::node_type::Q);\n\t\t\t\t\t\tassert(tree.vedges[a].o_type != spqr_tree::node_type::Q);\n\n\t\t\t\t\t\tflip ^= tree.vedges[c].is_tree == tree.vedges[a].is_tree;\n\n\t\t\t\t\t\tint x = tree.vedges[a].vs[0];\n\t\t\t\t\t\tint y = tree.vedges[a].vs[1];\n\n\t\t\t\t\t\tif (flip) swap(x, y);\n\t\t\t\t\t\tans[x].push_back(y);\n\t\t\t\t\t\tself(tree.vedges[a].o_node, flip);\n\t\t\t\t\t\tans[y].push_back(x);\n\t\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::S) {\n\t\t\t\t\t\tint st = tree.nodes[node].vedges.st;\n\t\t\t\t\t\tint en = tree.nodes[node].vedges.en-1;\n\t\t\t\t\t\tif (flip) {\n\t\t\t\t\t\t\tfor (int ve = en-1; ve >= st; ve--) {\n\t\t\t\t\t\t\t\tself(tree.vedges[ve].o_node, flip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int ve = st; ve < en; ve++) {\n\t\t\t\t\t\t\t\tself(tree.vedges[ve].o_node, flip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else assert(false);\n\t\t\t\t});\n\t\t\t\tif (tree.nodes[root_node].type == spqr_tree::node_type::P) {\n\t\t\t\t\tint a = tree.nodes[root_node].vedges.st;\n\t\t\t\t\tint b = tree.nodes[root_node].vedges.st+1;\n\t\t\t\t\tconst auto& ve = tree.vedges[tree.nodes[root_node].vedges.en-1];\n\t\t\t\t\tint st = int(ans[ve.vs[1]].size());\n\t\t\t\t\tans[ve.vs[1]].push_back(ve.vs[0]);\n\t\t\t\t\tdfs(tree.vedges[a].o_node, false);\n\t\t\t\t\tint l = int(ans[ve.vs[1]].size());\n\t\t\t\t\tans[ve.vs[0]].push_back(ve.vs[1]);\n\t\t\t\t\tdfs(tree.vedges[b].o_node, true);\n\t\t\t\t\tstd::rotate(ans[ve.vs[1]].begin() + st, ans[ve.vs[1]].begin() + l, ans[ve.vs[1]].end());\n\t\t\t\t} else if (tree.nodes[root_node].type == spqr_tree::node_type::S) {\n\t\t\t\t\tconst auto& ve = tree.vedges[tree.nodes[root_node].vedges.en-1];\n\t\t\t\t\tassert(ve.is_tree);\n\t\t\t\t\tans[ve.vs[1]].push_back(ve.vs[0]);\n\t\t\t\t\tdfs(root_node, false);\n\t\t\t\t\tans[ve.vs[0]].push_back(ve.vs[1]);\n\t\t\t\t} else if (tree.nodes[root_node].type == spqr_tree::node_type::I) {\n\t\t\t\t\tfor (const auto& ve : tree.nodes[root_node].vedges.bind(tree)) {\n\t\t\t\t\t\tdfs(ve.o_node, false);\n\t\t\t\t\t}\n\t\t\t\t} else assert(false);\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tif (solve()) {\n\t\t\tcout << \"YES\" << '\\n';\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int z = 0; z < int(ans[i].size()); z++) {\n\t\t\t\t\tcout << ans[i][z] << \" \\n\"[z+1==int(ans[i].size())];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Neighbour Ordering.json",
    "editorial_link": "https://codeforces.com//blog/entry/101211",
    "editorial": "First, note that, for each vertex , the relative order between\r\nneighbours that belong to different biconnected components (i. e.,\r\nneighbours and so that the edges and belong to different biconnected\r\ncomponents) is irrelevant, since there can not be any (vertex-disjoint)\r\ncycle using edges from different biconnected components. Therefore, a\r\ngood ordering for the entire graph will be possible if and only if a\r\ngood ordering for each of the biconnected components is possible, and if\r\nso the ordering for the entire graph can be obtained from the orderings\r\nfor each of the components by arbitrarily merging the lists of each\r\ncomponent for each vertex (preserving the relative order for the lists\r\nof each component). Therefore, from now on we will assume that the graph\r\nis biconnected. Also, we assume that the graph has at least 3 vertices\r\nto avoid trivialities.: If the graph has a cycle , and there are two\r\nvertices not adjacent in the cycle such that there is a path from to\r\nthat passes through a vertex , then the graph can not have a good\r\nordering.: Assume the graph has a good ordering, and label the vertices\r\nof the cycle so that and and with . Let the path between and be , where\r\n, , and we can assume that all lie outside the cycle. Considering the\r\ncycle , we can see that since , it must happen too that . Now,\r\nconsidering the cycle , we see that since (with possibly ), we must have\r\n. Since , we canÃ¢Â€Â™t have the inequality both ways and we reach a\r\ncontradiction. : If the (biconnected) graph has a good ordering, then it\r\nhas a hamiltonian cycle.: Assume it doesnÃ¢Â€Â™t have a hamiltonian cycle.\r\nSince it is biconnected with at least 3 vertices, it must have some\r\ncycle. Let be a longest cycle of the graph. Because the cycle does not\r\nvisit all the vertices of the graph and the graph is connected, there\r\nmust be some vertex not in the cycle which is a neighbour of a vertex in\r\nthe cycle. Because the graph is biconnected, there must be some path not\r\npassing through with and , a vertex in the cycle. We can choose the path\r\nso that vertices are not in the cycle, since we can just finish the path\r\nat the first vertex that is in the cycle. Now we consider two cases:\r\nCase 1: and are adjacent in the cycle (i. e. or , where we admit taking\r\nindices modulo ). Now we can consider the cycle , which is strictly\r\nlonger than the original cycle, but we said it was a longest cycle,\r\ncontradiction. Case 2: and are not adjacent in the cycle. Assume and\r\nconsider the cycle . We have a path that passes through vertices not in\r\nthe cycle, so by the first lemma it is not possible to have a good\r\nordering, contradiction. Now, letÃ¢Â€Â™s see how we can compute this\r\nhamiltonian cycle efficiently. The argument we used in the proof already\r\ngives a good algorithm: we find a cycle, and repeatedly find paths that\r\ngo out of the cycle and then return to it. We will either find a path\r\nwhich returns to an adjacent vertex and therefore we can use it to\r\naugment the cycle (Case 1) or we will find that it is impossible to have\r\na good ordering and halt (Case 2). However, implementing this directly\r\nis in worst case . We will find a way to implement this idea in time,\r\nusing properties of the DFS tree. : In a DFS tree of a (biconnected)\r\ngraph with a good ordering, each vertex can have at most two children.:\r\nSuppose that some vertex has more than two children. Because the graph\r\nis biconnected, we have can not be the root, and that from each of the\r\nchild subtrees there is a back edge to a proper ancestor of . Let be\r\nthree children of that have back edges (in their respective subtrees) to\r\nthree vertices with , where is the depth in the DFS tree. Consider the\r\ncycle (goes back to ) and the path between and , two non-adjacent\r\nvertices in the cycle. This contradicts lemma 1. : In a DFS tree of a\r\n(biconnected) graph with a good ordering, consider a vertex that is not\r\nthe root and whose parent is not the root either with two children and ,\r\nand let be the vertex with least depth that can be reached with a back\r\nedge from the subtree of . Then there is exactly one such that : Assume\r\nthat and are both proper ancestors of (they can not be descendants of\r\nsince the graph is biconnected). Then, if we consider the cycle which\r\nincludes the path and then cycles back using back edges without passing\r\nthrough , we have a contradiction with lemma 1 considering the path from\r\nsome vertex in the cycle which is a proper ancestor of to going down the\r\nDFS tree. Therefore, at least one of or is equal to . Now letÃ¢Â€Â™s see that\r\nit can not happen that . Assume that it is the case. Since the graph is\r\nbiconnected, we must have that since it must be a proper ancestor of\r\n(note that here we are using that is not the root). Therefore, since the\r\ntwo children subtrees donÃ¢Â€Â™t have back edges to vertices higher than ,\r\nmust have a back edge to . Consider the cycle . Now with the path lemma\r\n1 is violated. : In a DFS tree of a (biconnected) graph with a good\r\nordering, consider a vertex that is not the root with parent and with\r\nonly one child . If , then .: Consider the cycle . If and are not\r\nadjacent, the path violates lemma 1. : In a DFS tree of a (biconnected)\r\ngraph with a good ordering, we can partition the front edges into: One\r\npath of the form , where is the parent of for , and is the root, and\r\nthere is a back edge between and . Some paths of the form , where is the\r\nparent of for , and there is a back edge between and . : Let be a vertex\r\nwhich is not the root. We say that the associated with vertex is the\r\nback edge from Ã¢Â€Â™s subtree that goes to : if there are multiple such back\r\nedges, we choose the one that has as the other vertex the one that has a\r\nhighest DFS visitation number. We partition the front edges into groups\r\nwith the same representative edge associated with . We have to prove\r\nthat this partition has the desired properties.Let be vertices with the\r\nsame representative edge. One vertex must be an ancestor of the other\r\n(otherwise their subtrees would be disjoint and they can not have the\r\nsame back edges), and every vertex in the path going from one to the\r\nother in the tree has the same representative edge (if there was some\r\nbetter edge, the higher vertex would have it as a representative). This\r\nproves that the groups form paths of the form , where is the parent of\r\nfor (note that here would be the vertices with the same representative\r\nedge but wouldnÃ¢Â€Â™t; is in the path because the partition is of edges, not\r\nvertices, and is an edge in the group).Now, letÃ¢Â€Â™s see the other\r\nproperty. It is clear that , the vertex with most depth of the path, has\r\nthe representative edge of the path as one of its back edges. Now\r\nconsider . We have multiple cases: is not the root and it has only one\r\nchild . Then since it doesnÃ¢Â€Â™t have the same representative edge\r\nnecessarily it must have a back edge and . By lemma 4, we must have and\r\nthe back edge from goes to the parent of , as desired. is not the root,\r\nits parent is not the root either, and it has two children, one of which\r\nis . Then by lemma 3, exactly one of the two children has its Low value\r\nequal to the parent of . If it were not , then would have the same\r\nrepresentative edge as , which is not possible since it is the endpoint\r\nof the path. Therefore again we have , and the back edge from goes to\r\nthe parent of . is the child of the root and it has two children. Now we\r\nmust have once again once again because there is no other vertex with\r\nleast depth than the parent of , and the back from goes to the parent of\r\n. is the root. This happens for only for one path, and clearly there\r\nmust be a back edge from to . This is just what we wanted: doing just\r\none DFS we can get one initial cycle and a series of paths we can use to\r\nsuccessively augment our cycle until we have a hamiltonian cycle. One\r\nway to implement this is the following: first, we partition the graph\r\ninto paths as in the previous theorem (we can mantain the representative\r\nback edge during the DFS; if a violation of the properties proven in the\r\nlemmas is detected, we halt). Then, we begin exploring the initial path\r\n(the one that forms a cycle with the root) in a downwards direction that\r\nis, first we visit , then its child , until we visit , which has a edge\r\nback to . When we visit one vertex, we push it into a vector that will\r\ncontain the hamiltonian cycle at the end. If at some point we visit a\r\nvertex that is the parent of the endpoint of another path, we\r\nrecursively visit that path and after visiting it we continue with our\r\noriginal path. But when recursively visiting the new path, we traverse\r\nit upwards, that is, we start with and go up to the parent of the\r\nvertex. If at some point we visit the endpoint of some other path, we\r\nagain do a recursive visit of that path, this time in downwards\r\ndirection. This way, we end up visiting all paths in a DFS-like way, and\r\nsince we alternate between upward and downward traversals we end up\r\nhaving all the vertices of the graph in the vector ordered in a way that\r\nthey form a hamiltonian cycle. Now that we have found how to compute\r\nthat hamiltonian cycle in linear time (or halt if we find that some of\r\nthe necessary conditions for a good ordering are violated), letÃ¢Â€Â™s see an\r\nadditional necessary condition for a good ordering.: In a (biconnected)\r\ngraph with a good ordering, for any hamiltonian cycle, then there can\r\nnot be any pair of edges that \"cross\", that is, if we draw the graph\r\nwith vertices placed in a circle in the hamiltonian cycle order and with\r\nnon-cycle edges drawn as chords, no two chords intersect. : Assume that\r\ntwo edges cross. We can label the vertices so that forms the hamiltonian\r\ncycle in that order, and the endpoints of the chords are and , with .\r\nConsider the cycle . Because of the orientation of the hamiltonian cycle\r\n(note that there are at least three consecutive vertices from the\r\nhamiltonian cycle in this cycle) we have that . Similarly for the cycle\r\n, we see that . But now consider the cycle . Because , we must also have\r\n, contradiction. Once we have found the hamiltonian cycle, this property\r\ncan be checked in linear time. And now the properties we have checked\r\nare not only necessary but also sufficient:: A biconnected graph with a\r\nhamiltonian cycle such that non-cycle edges do not cross admits a good\r\nordering. : We assign an ordering by choosing one orientation of the\r\ncycle, and ordering the edges of each vertex by how far is the endpoint\r\nof the edge traversing the cycle in that orientation. We have to prove\r\nthat this is a good ordering. Let be any cycle, and label the vertices\r\nso that and according to the orientation. If we show that , we will have\r\nshown that the cycle is consistent with the ordering. We already have by\r\nthe labelling choice. Note that is is the first index to break the\r\ninequality, then if the edge between and crosses some previous edge, and\r\nif , then the cycle from then onwards be contained in the interval\r\nbetween vertices and , which is not possible since vertex lies outside.\r\nThis ordering can be reconstructed in time by applying any standard\r\nsorting algorithm to the adjacency lists of the vertices (the comparison\r\nfunction is different for each vertex), and it can be improved to linear\r\ntime by making an array of pairs consisting on the information of all\r\nthe adjacency lists (each edge is included two times in the array, one\r\nfor each end), sorting the array in linear time using counting sort, and\r\nthen for each of the vertices the sorted adjacency list can be restored\r\nby applying one splice operation to the list given in the order in which\r\nthe array was sorted.\r\n",
    "hint": []
}