{"link": "https://codeforces.com//contest/1656/problem/I", "problemId": "1341212", "problem_idx": "I", "shortId": "1656I", "contest_number": "1656", "problem_submissions": {"H": [150787257, 150834092, 150833898, 150779624, 150791810, 150792367, 150793746, 150802821, 150793244, 150784328, 150836239, 150786830, 150787392, 150775313, 150792322, 150812291, 150837917, 150835814, 150835788, 150835748, 150835735, 150835565, 150835404, 150835313, 150835295, 150835202, 150835140, 150813121], "G": [150769137, 150790740, 150776335, 150781798, 150778878, 150781350, 150783120, 150789415, 150791824, 150790309, 150773559, 150791984, 150793946, 150800739, 150800780], "F": [150759585, 150758819, 150757088, 150759741, 150768307, 150764851, 150771817, 150759499, 150756577, 150773688, 150782772, 150774145, 150769570, 150765258, 150764625, 150756214, 150776414, 150776503, 150774655, 150777047], "E": [150751361, 150745742, 150744206, 150750256, 150757531, 150753091, 150760157, 150764520, 150764445, 150756529, 150749400, 150762413, 150747229, 150753617, 150756813, 150745115, 150752324, 150758442, 150759352, 150761061], "D": [150742723, 150736825, 150739691, 150737309, 150752373, 150748905, 150751158, 150737577, 150743318, 150744109, 150743943, 150742795, 150742345, 150737178, 150746671, 150740470, 150742866, 150748659, 150752013, 150752792], "C": [150733096, 150732015, 150737243, 150731632, 150734197, 150741651, 150741487, 150729270, 150734650, 150732482, 150734630, 150733212, 150733482, 150730538, 150732987, 150735181, 150734697, 150735222, 150738885, 150734495], "B": [150727707, 150727564, 150729524, 150727729, 150727957, 150730109, 150730045, 150725120, 150728043, 150726472, 150725778, 150727111, 150726454, 150727018, 150729221, 150817665, 150730058, 150728199, 150728859, 150727704], "A": [150725204, 150724798, 150724946, 150724479, 150724835, 150724855, 150724694, 150724426, 150724692, 150724405, 150724424, 150724740, 150724465, 150724564, 150725589, 150725242, 150725512, 150724576, 150724789, 150724666], "I": [150839781, 150825396]}, "name": "I. Neighbour Ordering", "statement": "Given an undirected graph G, we say that a is an ordered list of all the\r\nneighbours of a vertex for each of the vertices of G. Consider a given\r\nneighbour ordering of G and three vertices u, v and w, such that v is a\r\nneighbor of u and w. We write u <_{v} w if u comes after w in v\u2019s\r\nneighbor list.A neighbour ordering is said to be if, for each simple\r\ncycle v_1, v_2,\r\nldots, v_c of the graph, one of the following is satisfied: v_1 <_{v_2}\r\nv_3, v_2 <_{v_3} v_4,\r\nldots, v_{c-2} <_{v_{c-1}} v_c, v_{c-1} <_{v_c} v_1, v_c <_{v_1} v_2.\r\nv_1 >_{v_2} v_3, v_2 >_{v_3} v_4,\r\nldots, v_{c-2} >_{v_{c-1}} v_c, v_{c-1} >_{v_c} v_1, v_c >_{v_1} v_2.\r\nGiven a graph G, determine whether there exists a good neighbour\r\nordering for it and construct one if it does.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\n/** Block-Cut/SPQR Tree\n *\n *  A class to compute and represent the block-cut and SPQR trees of a static\n *  undirected (multi)graph.\n *\n *  We have several node types:\n *  - Q: a single real edge and a single virtual edge\n *  - I: a bridge edge of the original graph\n *  - O: exactly 1 self loop or 2 parallel edges (a degenerate case of both S and P)\n *  - S: at least 3 series edges (in a cycle)\n *  - P: at least 3 parallel edges\n *  - R: a rigid component\n *  Note that 2 parallel Q nodes are never glued directly together; they are always\n *  glued to an O or P node.\n *\n *  Every real edge is stored in a Q node. The Q node for edge e is numbered e\n *  and contains virtual edge e. You can test that virtual edge corresponds\n *  to a single real edge using `tree.vedges[ve].o_type == node_type::Q` or\n *  less directly `tree.vedges[ve].o_ve < NE`.\n *\n *  We have several named objects: Vertices, Components (CCs), Blocks (BCCs),\n *  Nodes (TCCs), and VirtualEdges (which include edges as described above).\n *  The various objects have the following relationships:\n *   * Components contain Vertices\n *   * Components contain Blocks contain Nodes contain VirtualEdges\n *   * Vertices are adjacent to Blocks, Nodes, and VirtualEdges (many-to-many)\n *\n *  The tree is specified unrooted, but is implicitly rooted: everything is\n *  numbered in postorder (except for Q nodes/their virtual edges). In\n *  particular, Nodes contain intervals of VirtualEdges, Blocks contain\n *  intervals of Nodes, and so on. Note that the Block/Component intervals do\n *  not include their Q Nodes/VEdges!\n *\n *  More specifically, vectors of adjacent/contained objects are all\n *  represented as range_t's, representing subintervals of the corresponding\n *  array. Note that, vertices do not have 1-to-1 relationships, so for those\n *  relations, we need to look up the corresponding array.\n */\nstruct spqr_tree {\n\tstatic constexpr bool PRINT_DEBUG = false;\n\n\t// Number of vertices\n\tint NV = 0;\n\t// Number of real edges\n\tint NE = 0;\n\n\t// Number of connected components\n\tint NC = 0;\n\t// Number of blocks\n\tint NB = 0;\n\t// Number of SPQR nodes\n\tint NN = 0;\n\t// Number of virtual edges\n\tint NVE = 0;\n\n\t// TODO: make range_t's easier to use, particularly the ones requiring a second indirection.\n\tstruct range_t {\n\t\tint st = -1, en = -1;\n\t\tint size() const { return en - st; }\n\t\tbool contains(int v) const { return st <= v && v < en; }\n\t};\n\tstruct iterable_range_t : public range_t {\n\t\tstruct iterator {\n\t\t\tint v;\n\t\t\tint operator * () const { return v; }\n\t\t\titerator& operator ++ () { ++v; return *this; }\n\t\t\tfriend bool operator != (iterator a, iterator b) { return a.v != b.v; }\n\t\t};\n\t\titerator begin() const { return iterator{st}; }\n\t\titerator end() const { return iterator{en}; }\n\t};\n\ttemplate <typename T> struct bound_array_range_t {\n\t\ttypename std::vector<T>::const_iterator st, en;\n\t\tint size() const { return int(en - st); }\n\t\tauto begin() const { return st; }\n\t\tauto end() const { return en; }\n\t};\n\ttemplate <typename T, std::vector<T> spqr_tree::* array> struct array_range_t : public range_t {\n\t\tbound_array_range_t<T> bind(const spqr_tree& tree) const {\n\t\t\treturn {(tree.*array).begin() + st, (tree.*array).begin() + en};\n\t\t}\n\t};\n\ttemplate <typename T, std::vector<T> spqr_tree::* array> struct enumerable_array_range_t : public iterable_range_t {\n\t\tbound_array_range_t<T> bind(const spqr_tree& tree) const {\n\t\t\treturn {(tree.*array).begin() + st, (tree.*array).begin() + en};\n\t\t}\n\t};\n\n\tstruct vertex_t;\n\tstd::vector<vertex_t> vertices;\n\tstd::vector<int> vertex_blocks;\n\n\tstruct component_t;\n\tstd::vector<component_t> components;\n\tstd::vector<int> component_vertices;\n\n\tstruct block_t;\n\tstd::vector<block_t> blocks;\n\tstd::vector<int> block_vertices;\n\n\tstruct node_t;\n\tstd::vector<node_t> nodes;\n\tstd::vector<int> node_vertices;\n\n\tstruct vedge_t;\n\tstd::vector<vedge_t> vedges;\n\n\tstruct vertex_t {\n\t\tint component = -1;\n\t\tarray_range_t<int, &spqr_tree::vertex_blocks> vertex_blocks;\n\t\t// TODO: maybe we want vertex_nodes or even vertex_block_nodes or something\n\t};\n\tstruct component_t {\n\t\tenumerable_array_range_t<block_t, &spqr_tree::blocks> blocks;\n\t\tenumerable_array_range_t<node_t, &spqr_tree::nodes> nodes;\n\t\tenumerable_array_range_t<vedge_t, &spqr_tree::vedges> vedges;\n\t\tarray_range_t<int, &spqr_tree::component_vertices> component_vertices;\n\t};\n\n\tstruct block_t {\n\t\tint component = -1;\n\t\tenumerable_array_range_t<node_t, &spqr_tree::nodes> nodes;\n\t\tenumerable_array_range_t<vedge_t, &spqr_tree::vedges> vedges;\n\t\tarray_range_t<int, &spqr_tree::block_vertices> block_vertices;\n\t};\n\n\tenum class node_type : char {\n\t\tQ = 'Q', I = 'I', O = 'O', S = 'S', P = 'P', R = 'R'\n\t};\n\n\tstruct node_t {\n\t\tnode_type type;\n\t\tint component = -1;\n\t\tint block = -1;\n\t\tenumerable_array_range_t<vedge_t, &spqr_tree::vedges> vedges;\n\t\tarray_range_t<int, &spqr_tree::node_vertices> node_vertices;\n\t};\n\n\tstruct vedge_t {\n\t\tstd::array<int, 2> vs;\n\t\tint component = -1;\n\t\tint block = -1;\n\t\tint node = -1;\n\t\tbool is_tree = false;\n\n\t\t// Information on the opposite virtual edge and its node\n\t\tint o_ve = -1;\n\t\tint o_node = -1;\n\t\tnode_type o_type;\n\t};\n\n\tstd::vector<int> depth;\n\nprivate:\n\t// Pairs of nxt, e\n\t// Negative e means new block; otherwise, it's 2*e + (has_nontrivial_lowval2)\n\tstd::vector<std::pair<int, int>> adj_lists;\n\tstd::vector<array_range_t<std::pair<int, int>, &spqr_tree::adj_lists>> adj;\n\n\tstruct bucket_edge_t {\n\t\tint v; int e; int cur, nxt;\n\t};\n\tstd::vector<bucket_edge_t> bucket_edges;\n\n\tstd::pair<int, int> dfs_lowval(int cur, int d, int prvE) {\n\t\tdepth[cur] = d;\n\t\tint v1 = d, v2 = d;\n\t\tfor (auto [nxt, e] : adj[cur].bind(*this)) {\n\t\t\tif (e == prvE) continue;\n\t\t\tif (depth[nxt] == -1) {\n\t\t\t\tconst auto [n1, n2] = dfs_lowval(nxt, d+1, e);\n\n\t\t\t\tif (n1 >= d) {\n\t\t\t\t\tbucket_edges.push_back({0, ~e, cur, nxt});\n\t\t\t\t} else {\n\t\t\t\t\tbucket_edges.push_back({1 + n1 * 2 + (n2 < d), 2*e + (n2 < d), cur, nxt});\n\t\t\t\t}\n\n\t\t\t\tif (n1 < v1) {\n\t\t\t\t\tv2 = std::min(v1, n2);\n\t\t\t\t\tv1 = n1;\n\t\t\t\t} else if (n1 == v1) {\n\t\t\t\t\tv2 = std::min(v2, n2);\n\t\t\t\t} else {\n\t\t\t\t\tv2 = std::min(v2, n1);\n\t\t\t\t}\n\t\t\t} else if (depth[nxt] <= d) {\n\t\t\t\tint nd = depth[nxt];\n\t\t\t\tif (nd == d) {\n\t\t\t\t\t// Self-loop\n\t\t\t\t\tbucket_edges.push_back({0, ~e, cur, nxt});\n\t\t\t\t} else {\n\t\t\t\t\tbucket_edges.push_back({1 + nd * 2, 2*e, cur, nxt});\n\t\t\t\t}\n\n\t\t\t\tif (nd < v1) {\n\t\t\t\t\tv2 = v1;\n\t\t\t\t\tv1 = nd;\n\t\t\t\t} else if (v1 < nd) {\n\t\t\t\t\tv2 = std::min(v2, nd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// reverse of a back-edge (downwards)\n\t\t\t\t// skip it\n\t\t\t}\n\t\t}\n\t\treturn {v1, v2};\n\t}\n\n\tvoid build_sorted_adj(std::vector<std::array<int, 2>> edges, int root) {\n\t\t{\n\t\t\tstd::vector<int> deg(NV, 0);\n\t\t\tfor (auto e : edges) {\n\t\t\t\tfor (int v : e) {\n\t\t\t\t\tdeg[v]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj.resize(NV);\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < NV; i++) {\n\t\t\t\tadj[i].st = adj[i].en = cur;\n\t\t\t\tcur += deg[i];\n\t\t\t}\n\t\t\tadj_lists.resize(cur);\n\t\t}\n\t\tfor (int e = 0; e < int(edges.size()); e++) {\n\t\t\tauto [u, v] = edges[e];\n\t\t\tadj_lists[adj[u].en++] = {v, e};\n\t\t\tif (u != v) {\n\t\t\t\tadj_lists[adj[v].en++] = {u, e};\n\t\t\t}\n\t\t}\n\n\t\tdepth = std::vector<int>(NV, -1);\n\n\t\t// Bucketed so that bridges come first, then BCCs, then children from shallowest to deepest lowval\n\t\tbucket_edges.reserve(NE);\n\n\t\tfor (int rt = 0; rt < NV; rt++) {\n\t\t\tif (root != -1 && rt != root) continue;\n\t\t\tif (depth[rt] != -1) continue;\n\t\t\tdfs_lowval(rt, 0, -1);\n\t\t}\n\t\tassert(int(bucket_edges.size()) == NE);\n\n\t\tfor (auto& v : adj) {\n\t\t\tv.en = v.st;\n\t\t}\n\n\t\tstd::vector<int> bucket_st(1 + NV * 2);\n\t\tfor (int i = 0; i < int(bucket_edges.size()); i++) {\n\t\t\t++bucket_st[bucket_edges[i].v];\n\t\t}\n\t\t{\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < int(bucket_st.size()); i++) {\n\t\t\t\tbucket_st[i] = std::exchange(cur, cur + bucket_st[i]);\n\t\t\t}\n\t\t\tassert(cur == int(bucket_edges.size()));\n\t\t}\n\t\tstd::vector<bucket_edge_t> bucket_edges_2(bucket_edges.size());\n\t\tfor (int i = 0; i < int(bucket_edges.size()); i++) {\n\t\t\tbucket_edges_2[bucket_st[bucket_edges[i].v]++] = bucket_edges[i];\n\t\t}\n\t\tbucket_edges = {};\n\t\tfor (auto [_, e, cur, nxt] : bucket_edges_2) {\n\t\t\tadj_lists[adj[cur].en++] = {nxt, e};\n\t\t}\n\t}\n\n\t// Tree edges have v = {child, parent}\n\t// Backedges edges have v = {top, bottom}\n\n\tstruct vestack_t {\n\t\tstd::array<int, 2> vs;\n\t\tbool is_tree = false;\n\t\tint o_ve = -1;\n\t\tint o_node = -1;\n\t\tnode_type o_type;\n\t};\n\tstd::vector<vestack_t> vestack;\n\n\tusing vestack_range_t = enumerable_array_range_t<vestack_t, &spqr_tree::vestack>;\n\n\tstruct estack_t {\n\t\tstd::array<int, 2> vs;\n\t\tvestack_range_t vestack_range;\n\t\tnode_type type;\n\t\tbool is_tree;\n\t};\n\tstd::vector<estack_t> estack;\n\n\tstruct tstack_t {\n\t\tint idx; // idx in estack\n\t\tint vstart;\n\t\tint top_depth;\n\t};\n\tstd::vector<tstack_t> tstack;\n\n\tstd::vector<int> first_occurrence;\n\n\tint cur_component;\n\tint cur_block;\n\n\tvoid finalize_node(estack_t es, vestack_t cap) {\n\t\tassert(es.type != node_type::Q);\n\t\tint node = int(nodes.size());\n\n\t\tnode_t n;\n\t\tn.type = es.type;\n\t\tn.component = cur_component;\n\t\tn.block = cur_block;\n\n\t\tn.vedges.st = int(vedges.size());\n\t\tn.node_vertices.st = int(node_vertices.size());\n\n\t\tauto push_vestack_t = [&](const vestack_t& ves) {\n\t\t\tvedges.push_back(vedge_t{\n\t\t\t\tves.vs,\n\t\t\t\tcur_component,\n\t\t\t\tcur_block,\n\t\t\t\tnode,\n\t\t\t\tves.is_tree,\n\t\t\t\tves.o_ve,\n\t\t\t\tves.o_node,\n\t\t\t\tves.o_type,\n\t\t\t});\n\t\t\tint ve = int(vedges.size()) - 1;\n\t\t\tint o_ve = ves.o_ve;\n\t\t\tif (o_ve != -1) {\n\t\t\t\tvedges[o_ve].o_ve = ve;\n\t\t\t\tvedges[o_ve].o_node = node;\n\t\t\t\tvedges[o_ve].o_type = n.type;\n\t\t\t}\n\t\t};\n\n\t\tfor (const auto& ves : es.vestack_range.bind(*this)) {\n\t\t\tpush_vestack_t(ves);\n\t\t\tif (ves.is_tree) {\n\t\t\t\tint cnd = ves.vs[0];\n\t\t\t\tif (cnd != cap.vs[0] && cnd != cap.vs[1]) {\n\t\t\t\t\tnode_vertices.push_back(cnd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(cap.vs[0] == es.vs[1]);\n\t\tassert(cap.vs[1] == es.vs[0]);\n\t\tassert(cap.is_tree == !es.is_tree);\n\t\tpush_vestack_t(cap);\n\t\tif (cap.vs[0] == cap.vs[1]) {\n\t\t\tnode_vertices.push_back(cap.vs[0]);\n\t\t} else {\n\t\t\tfor (int v : cap.vs) {\n\t\t\t\tnode_vertices.push_back(v);\n\t\t\t}\n\t\t}\n\n\t\tNVE = int(vedges.size());\n\n\t\tn.vedges.en = int(vedges.size());\n\t\tn.node_vertices.en = int(node_vertices.size());\n\n\t\tNN++;\n\t\tnodes.push_back(n);\n\t}\n\n\tvestack_t finalize_estack(estack_t es) {\n\t\tvestack_t cap;\n\t\tcap.vs[0] = es.vs[1];\n\t\tcap.vs[1] = es.vs[0];\n\t\tcap.is_tree = !es.is_tree;\n\n\t\tint o_ve;\n\t\tint o_node;\n\t\tif (es.type == node_type::Q) {\n\t\t\tint e = vestack[es.vestack_range.st].o_ve;\n\t\t\to_ve = o_node = e;\n\t\t\tassert(cap.vs == vedges[e].vs && cap.is_tree == vedges[e].is_tree);\n\t\t} else {\n\t\t\tfinalize_node(es, cap);\n\t\t\to_ve = int(vedges.size()) - 1;\n\t\t\to_node = int(nodes.size()) - 1;\n\t\t}\n\n\t\tvestack_t ve;\n\t\tve.vs = es.vs;\n\t\tve.is_tree = es.is_tree;\n\t\tve.o_ve = o_ve;\n\t\tve.o_node = o_node;\n\t\tve.o_type = es.type;\n\t\treturn ve;\n\t}\n\n\tvoid push_estack(estack_t e_ins) {\n\t\tif constexpr (PRINT_DEBUG) std::cerr << \"push_estack \" << e_ins.vs[0] << '-' << e_ins.vs[1] << ' ' << e_ins.is_tree << '\\n';\n\t\testack.push_back(e_ins);\n\t\tint v = e_ins.vs[0];\n\t\tif (first_occurrence[v] == -1) {\n\t\t\tfirst_occurrence[v] = int(estack.size()) - 1;\n\t\t}\n\t}\n\n\tvoid push_estack_p(estack_t e_ins) {\n\t\tif constexpr (PRINT_DEBUG) std::cerr << \"push_estack_p \" << e_ins.vs[0] << '-' << e_ins.vs[1] << ' ' << e_ins.is_tree << '\\n';\n\t\tif (estack.back().type == node_type::P) {\n\t\t\tint st = e_ins.vestack_range.st;\n\t\t\tvestack[st] = finalize_estack(e_ins);\n\t\t\tvestack.resize(st+1);\n\t\t\tassert(estack.back().vestack_range.en == st);\n\t\t\testack.back().vestack_range.en ++;\n\t\t} else {\n\t\t\tint st = estack.back().vestack_range.st;\n\t\t\tvestack[st] = finalize_estack(estack.back());\n\t\t\tvestack[st+1] = finalize_estack(e_ins);\n\t\t\tvestack.resize(st+2);\n\t\t\testack.back().vestack_range = {st, st+2};\n\t\t\testack.back().type = node_type::P;\n\t\t}\n\t}\n\n\tvoid prepare_pop_estack(int z) {\n\t\tint v = estack[z].vs[0];\n\t\tif (first_occurrence[v] == z) {\n\t\t\tfirst_occurrence[v] = -1;\n\t\t}\n\t}\n\tvoid pop_estack() {\n\t\tprepare_pop_estack(int(estack.size()) - 1);\n\t\testack.pop_back();\n\t}\n\n\t// push_estack_p is a lot like push_estack + pop_estack_range, but their\n\t// handling of first_occurrence would differ, so we'll leave them separate\n\tstd::pair<vestack_range_t, node_type> pop_estack_range(int idx) {\n\t\tassert(int(estack.size()) - idx > 1);\n\t\tfor (int z = idx; z < int(estack.size()); z++) {\n\t\t\tprepare_pop_estack(z);\n\t\t}\n\n\t\tbool is_S = (int(estack.size()) - idx == 2);\n\t\tif (is_S) {\n\t\t\tassert(estack.back().type != node_type::S);\n\t\t}\n\t\tbool should_reuse = (is_S && estack[idx].type == node_type::S);\n\t\tint st = estack[idx].vestack_range.st;\n\n\t\tint sidx = idx + should_reuse;\n\t\tint en = estack[sidx].vestack_range.st;\n\t\tfor (int z = sidx; z < int(estack.size()); z++) {\n\t\t\tvestack[en++] = finalize_estack(estack[z]);\n\t\t}\n\n\t\tvestack.resize(en);\n\t\testack.resize(idx);\n\t\treturn {{st, en}, is_S ? node_type::S : node_type::R};\n\t}\n\n\testack_t make_q_node(int e, int cur, int nxt, bool is_tree) {\n\t\tvedges[e].vs = {cur, nxt};\n\t\tvedges[e].component = cur_component;\n\t\tvedges[e].block = cur_block;\n\t\tvedges[e].node = e;\n\t\tvedges[e].is_tree = !is_tree;\n\t\t// We're gonna put a dummy entry on vestack for 2 reasons:\n\t\t// 1. This lets the pop_estack_range logic has 1 scratch space per estack\n\t\t// 2. We need to lookup the edge for finalize_estack, which we'll smuggle in as o_ve\n\t\tvestack.emplace_back();\n\t\tvestack.back().o_ve = e;\n\n\t\tnodes[e].type = node_type::Q;\n\t\tnodes[e].component = cur_component;\n\t\tnodes[e].block = cur_block;\n\t\tnodes[e].vedges = {e, e+1};\n\t\tnodes[e].node_vertices = {2*e, 2*e + (cur == nxt ? 1 : 2)};\n\t\tnode_vertices[2*e] = cur;\n\t\tnode_vertices[2*e+1] = nxt;\n\n\t\treturn estack_t{{nxt, cur}, {int(vestack.size()) - 1, int(vestack.size())}, node_type::Q, is_tree};\n\t}\n\n\tvoid dfs_spqr(int cur, int cur_low) {\n\t\tint cur_depth = depth[cur];\n\t\tfor (auto [nxt, e] : adj[cur].bind(*this)) {\n\t\t\tif (e < 0) continue;\n\t\t\tbool is_type_1 = !(e & 1);\n\t\t\te >>= 1;\n\n\t\t\tint orig_size = int(estack.size());\n\n\t\t\tbool is_tree = (depth[nxt] > cur_depth);\n\t\t\tif (is_tree) {\n\t\t\t\tdfs_spqr(nxt, cur_low);\n\n\t\t\t\t// Before we insert our edge, we may have to fix the single-tree-edge tstack\n\t\t\t\tassert(!tstack.empty());\n\t\t\t\tif (tstack.back().top_depth == cur_depth + 1) {\n\t\t\t\t\tassert(tstack.back().idx == int(estack.size())-1);\n\t\t\t\t\ttstack.back().top_depth = cur_depth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Deal with the current vedge\n\t\t\testack_t e_ins = make_q_node(e, cur, nxt, is_tree);\n\t\t\tif (is_tree) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (estack.back().vs == std::array<int, 2>{cur, nxt}) {\n\t\t\t\t\t\tpush_estack_p(e_ins);\n\t\t\t\t\t\te_ins.vestack_range = estack.back().vestack_range;\n\t\t\t\t\t\tassert(estack.back().type == node_type::P);\n\t\t\t\t\t\te_ins.type = node_type::P;\n\n\t\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t\t\tif (tstack.back().idx == int(estack.size()) - 1) {\n\t\t\t\t\t\t\ttstack.pop_back();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Pop it all the way off since we need to\n\t\t\t\t\t\t// change the backedge to a tree edge\n\t\t\t\t\t\tpop_estack();\n\t\t\t\t\t}\n\n\t\t\t\t\tpush_estack(e_ins);\n\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t\tif (tstack.back().top_depth != cur_depth) break;\n\t\t\t\t\tassert(tstack.back().idx > orig_size);\n\t\t\t\t\tif (estack[tstack.back().idx].is_tree) {\n\t\t\t\t\t\tassert(estack[tstack.back().idx].vs[0] == tstack.back().vstart);\n\t\t\t\t\t\tif (int(estack.size()) - tstack.back().idx > 2) {\n\t\t\t\t\t\t\ttstack.push_back({\n\t\t\t\t\t\t\t\ttstack.back().idx + 1,\n\t\t\t\t\t\t\t\testack[tstack.back().idx].vs[1],\n\t\t\t\t\t\t\t\ttstack.back().top_depth\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tint idx = tstack.back().idx;\n\t\t\t\t\tassert(idx > orig_size);\n\t\t\t\t\tnxt = tstack.back().vstart;\n\t\t\t\t\ttstack.pop_back();\n\t\t\t\t\tauto [vestack_range, type] = pop_estack_range(idx);\n\t\t\t\t\te_ins = estack_t{{nxt, cur}, vestack_range, type, true};\n\t\t\t\t}\n\n\t\t\t\tif (is_type_1) {\n\t\t\t\t\t// Handle type 1 split\n\n\t\t\t\t\tnxt = estack[orig_size].vs[0];\n\n\t\t\t\t\t// It's possible there are candidates before orig_size\n\t\t\t\t\t// on the stack, but those are doomed to fail, so\n\t\t\t\t\t// it's fine to pop them prematurely.\n\t\t\t\t\twhile (tstack.back().idx > orig_size) tstack.pop_back();\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t\tif (tstack.back().idx == orig_size) {\n\t\t\t\t\t\tassert(tstack.back().vstart == cur_low && tstack.back().top_depth == depth[nxt]);\n\t\t\t\t\t}\n\n\t\t\t\t\tint idx = orig_size;\n\t\t\t\t\tauto [vestack_range, type] = pop_estack_range(idx);\n\t\t\t\t\te_ins = estack_t{{nxt, cur}, vestack_range, type, false};\n\t\t\t\t\tif (!estack.empty() && estack.back().vs == e_ins.vs) {\n\t\t\t\t\t\tpush_estack_p(e_ins);\n\t\t\t\t\t\t// Pop our tstack and use the previous value\n\t\t\t\t\t\tif (tstack.back().idx == orig_size) tstack.pop_back();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush_estack(e_ins);\n\t\t\t\t\t\t// We don't need to change tstack at all\n\t\t\t\t\t}\n\t\t\t\t} else if (cur_low == cur) {\n\t\t\t\t\t// Pop until we get to the entire range; that's\n\t\t\t\t\t// the only permissible one, since we previously use something\n\t\t\t\t\twhile (tstack.back().idx > orig_size) tstack.pop_back();\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t} else if (first_occurrence[cur] != -1) {\n\t\t\t\t\t// We're the first node, so cur can be interior, but we must include all backedges to cur\n\t\t\t\t\twhile (tstack.back().idx > first_occurrence[cur]) tstack.pop_back();\n\t\t\t\t\tassert(!tstack.empty());\n\t\t\t\t} else {\n\t\t\t\t\t// This is the only case where we can have the tree-edge start the cut.\n\t\t\t\t\t// Notably, this is the only tstack entry with top == cur\n\t\t\t\t\t// (otherwise it's always strictly shallower)\n\t\t\t\t\t// By the time it's resolved, top will be\n\t\t\t\t\t// shallower than cur, but that depends on the\n\t\t\t\t\t// next edge, so we'll fix it then.\n\t\t\t\t\t// We'll also omit the following (equivalent) entry entirely and\n\t\t\t\t\t// handle it when we pop it out.\n\t\t\t\t\ttstack.push_back({int(estack.size())-1, nxt, cur_depth});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!estack.empty() && estack.back().vs == e_ins.vs) {\n\t\t\t\t\tpush_estack_p(e_ins);\n\t\t\t\t\t// Don't change tstack, keep its old low value\n\t\t\t\t} else {\n\t\t\t\t\tpush_estack(e_ins);\n\n\t\t\t\t\t// nxt should be shallower\n\t\t\t\t\tassert(depth[cur_low] > depth[nxt]);\n\t\t\t\t\ttstack_t t_ins{int(estack.size())-1, cur_low, depth[nxt]};\n\t\t\t\t\tassert(tstack.empty() || tstack.back().top_depth <= depth[cur_low]);\n\t\t\t\t\twhile (!tstack.empty() && tstack.back().top_depth > t_ins.top_depth) {\n\t\t\t\t\t\tt_ins.idx = tstack.back().idx;\n\t\t\t\t\t\tt_ins.vstart = tstack.back().vstart;\n\t\t\t\t\t\ttstack.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\ttstack.push_back(t_ins);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcur_low = cur;\n\t\t}\n\n\t\tblock_vertices.push_back(cur);\n\t\tvertex_blocks[vertices[cur].vertex_blocks.en++] = cur_block;\n\t}\n\n\tint start_spqr(int cur, int nxt, int e) {\n\t\tint block = NB++;\n\t\tblocks.emplace_back();\n\t\tblocks[block].component = cur_component;\n\t\tblocks[block].nodes.st = int(nodes.size());\n\t\tblocks[block].vedges.st = int(vedges.size());\n\t\tblocks[block].block_vertices.st = int(block_vertices.size());\n\t\tcur_block = block;\n\n\t\tif (nxt != cur) {\n\t\t\tdfs_spqr(nxt, nxt);\n\t\t\tif (estack.empty()) {\n\t\t\t\testack.push_back(estack_t{{cur, nxt}, {int(vestack.size()), int(vestack.size())}, node_type::I, false});\n\t\t\t} else {\n\t\t\t\tassert(int(estack.size()) == 1);\n\t\t\t\tassert((estack.back().vs == std::array<int, 2>{cur, nxt}));\n\t\t\t\tassert(!estack.back().is_tree);\n\n\t\t\t\tif (estack.back().type == node_type::Q) {\n\t\t\t\t\tvestack.back() = finalize_estack(estack.back());\n\t\t\t\t\t// Don't have to change anything else, since Q nodes always have size 1\n\t\t\t\t\testack.back().type = node_type::O;\n\t\t\t\t}\n\n\t\t\t\tassert(!tstack.empty() && tstack.back().idx == 0);\n\t\t\t\ttstack.pop_back();\n\t\t\t}\n\t\t} else {\n\t\t\testack.push_back(estack_t{{cur, cur}, {int(vestack.size()), int(vestack.size())}, node_type::O, true});\n\t\t}\n\n\t\t// Make the q node and immediately overwrite its spot with our desired one\n\t\tauto q_estack = make_q_node(e, cur, nxt, cur != nxt);\n\t\tvestack.back() = finalize_estack(q_estack);\n\n\t\tauto es = estack.back();\n\t\tpop_estack();\n\t\tfinalize_node(es, vestack.back());\n\t\tvestack.resize(es.vestack_range.st);\n\n\t\tassert(tstack.empty());\n\t\tassert(estack.empty());\n\t\tassert(vestack.empty());\n\n\t\tblock_vertices.push_back(cur);\n\n\t\tcur_block = -1;\n\t\tblocks[block].nodes.en = int(nodes.size());\n\t\tblocks[block].vedges.en = int(vedges.size());\n\t\tblocks[block].block_vertices.en = int(block_vertices.size());\n\t\treturn block;\n\t}\n\n\tstd::vector<int> vertex_blocks_buf;\n\tvoid dfs_block(int cur) {\n\t\tint buf_st = int(vertex_blocks_buf.size());\n\t\tfor (auto [nxt, e] : adj[cur].bind(*this)) {\n\t\t\tassert(depth[nxt] <= depth[cur] + 1);\n\t\t\tif (depth[nxt] < depth[cur]) continue;\n\t\t\tif (nxt != cur) {\n\t\t\t\tdfs_block(nxt);\n\t\t\t}\n\t\t\tif (e < 0) {\n\t\t\t\te = ~e;\n\t\t\t\t// Root of a block\n\t\t\t\tint block = start_spqr(cur, nxt, e);\n\n\t\t\t\tvertex_blocks_buf.push_back(block);\n\t\t\t}\n\t\t}\n\n\t\tvertices[cur].vertex_blocks.st = int(vertex_blocks.size());\n\t\tvertex_blocks.insert(vertex_blocks.end(), vertex_blocks_buf.begin() + buf_st, vertex_blocks_buf.end());\n\t\tvertex_blocks_buf.resize(buf_st);\n\t\tvertices[cur].vertex_blocks.en = int(vertex_blocks.size());\n\n\t\t// Placeholder for our parent\n\t\tif (depth[cur] > 0) {\n\t\t\tvertex_blocks.push_back(-1);\n\t\t}\n\n\t\tcomponent_vertices.push_back(cur);\n\t\tvertices[cur].component = cur_component;\n\t}\n\n\tvoid build_spqr() {\n\t\tvertices.resize(NV);\n\t\tvertex_blocks.reserve(NV + NE);\n\n\t\tcomponents.reserve(NV);\n\t\tcomponent_vertices.reserve(NV);\n\n\t\tblocks.reserve(NE);\n\t\tblock_vertices.reserve(NV + NE);\n\n\t\t// # nodes <= 2 * # Q nodes\n\t\tnodes.reserve(2 * NE);\n\t\tNN = NE;\n\t\tnodes.resize(NN);\n\t\t// # node_vertices <= # block_vertices + 2 * # nodes\n\t\tnode_vertices.reserve(NV + 5 * NE);\n\t\tnode_vertices.resize(2 * NE);\n\n\t\t// # vedges ~ 2 * (# nodes - # blocks)\n\t\tvedges.reserve(2 * (2 * NE));\n\t\tNVE = NE;\n\t\tvedges.resize(NVE);\n\n\t\tvertex_blocks_buf.reserve(NE);\n\t\tvestack.reserve(NE);\n\t\testack.reserve(NE);\n\t\ttstack.reserve(NE);\n\t\tfirst_occurrence.assign(NV, -1);\n\n\t\tfor (int rt = 0; rt < NV; rt++) {\n\t\t\tif (depth[rt] != 0) continue;\n\t\t\tint component = NC++;\n\t\t\tcomponents.emplace_back();\n\t\t\tcomponent_t& c = components[component];\n\t\t\tc.blocks.st = int(blocks.size());\n\t\t\tc.nodes.st = int(nodes.size());\n\t\t\tc.vedges.st = int(vedges.size());\n\t\t\tc.component_vertices.st = int(component_vertices.size());\n\n\t\t\tcur_component = component;\n\t\t\tdfs_block(rt);\n\t\t\tcur_component = -1;\n\n\t\t\tc.blocks.en = int(blocks.size());\n\t\t\tc.nodes.en = int(nodes.size());\n\t\t\tc.vedges.en = int(vedges.size());\n\t\t\tc.component_vertices.en = int(component_vertices.size());\n\t\t}\n\n\t\tvertex_blocks_buf = {};\n\t\tvestack = {};\n\t\testack = {};\n\t\ttstack = {};\n\t\tfirst_occurrence = {};\n\t}\n\npublic:\n\tspqr_tree() = default;\n\texplicit spqr_tree(int NV_, std::vector<std::array<int, 2>> edges, int root = -1) {\n\t\tNV = NV_;\n\t\tif (NV == 0) return;\n\n\t\tif (root != -1) {\n\t\t\tassert(0 <= root && root < NV);\n\t\t}\n\n\t\tNE = int(edges.size());\n\n\t\tbuild_sorted_adj(std::move(edges), root);\n\n\t\tbuild_spqr();\n\n\t\tadj = {};\n\t\tadj_lists = {};\n\t\t// Leave depth since it's sometimes useful\n\t\t//depth = {};\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, M; cin >> N >> M;\n\t\tstd::vector<std::array<int, 2>> edges(M);\n\t\tfor (auto& e : edges) {\n\t\t\tfor (auto& v : e) cin >> v;\n\t\t}\n\n\t\tstd::vector<std::vector<int>> ans(N);\n\t\tauto solve = [&]() -> bool {\n\t\t\tconst spqr_tree tree(N, edges);\n\n\t\t\tfor (int node = tree.NE; node < tree.NN; node++) {\n\t\t\t\tif (tree.nodes[node].type == spqr_tree::node_type::R) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::S) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::P) {\n\t\t\t\t\tassert(tree.nodes[node].vedges.size() >= 3);\n\t\t\t\t\tif (tree.nodes[node].vedges.size() > 3) return false;\n\t\t\t\t\tassert(tree.nodes[node].vedges.size() == 3);\n\t\t\t\t\tbool has_real_edge = false;\n\t\t\t\t\tfor (const auto& ve : tree.nodes[node].vedges.bind(tree)) {\n\t\t\t\t\t\tif (ve.o_type == spqr_tree::node_type::Q) {\n\t\t\t\t\t\t\thas_real_edge = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!has_real_edge) return false;\n\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::I) {\n\t\t\t\t} else assert(false);\n\t\t\t}\n\n\t\t\tstd::vector<int> succ(2 * tree.NVE);\n\n\t\t\tfor (int block = 0; block < tree.NB; block++) {\n\t\t\t\tint root_node = tree.blocks[block].nodes.en-1;\n\t\t\t\tauto dfs = std::y_combinator([&](auto self, int node, bool flip) -> void {\n\t\t\t\t\tif (tree.nodes[node].type == spqr_tree::node_type::Q) {\n\t\t\t\t\t\tconst auto& ve = tree.vedges[tree.nodes[node].vedges.st];\n\t\t\t\t\t\tans[ve.vs[0]].push_back(ve.vs[1]);\n\t\t\t\t\t\tans[ve.vs[1]].push_back(ve.vs[0]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::P) {\n\t\t\t\t\t\tint a = tree.nodes[node].vedges.st;\n\t\t\t\t\t\tint b = tree.nodes[node].vedges.st+1;\n\t\t\t\t\t\tint c = tree.nodes[node].vedges.st+2;\n\t\t\t\t\t\tassert(tree.vedges[c].o_type != spqr_tree::node_type::Q);\n\t\t\t\t\t\tif (tree.vedges[a].o_type == spqr_tree::node_type::Q) {\n\t\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(tree.vedges[b].o_type == spqr_tree::node_type::Q);\n\t\t\t\t\t\tassert(tree.vedges[a].o_type != spqr_tree::node_type::Q);\n\n\t\t\t\t\t\tflip ^= tree.vedges[c].is_tree == tree.vedges[a].is_tree;\n\n\t\t\t\t\t\tint x = tree.vedges[a].vs[0];\n\t\t\t\t\t\tint y = tree.vedges[a].vs[1];\n\n\t\t\t\t\t\tif (flip) swap(x, y);\n\t\t\t\t\t\tans[x].push_back(y);\n\t\t\t\t\t\tself(tree.vedges[a].o_node, flip);\n\t\t\t\t\t\tans[y].push_back(x);\n\t\t\t\t\t} else if (tree.nodes[node].type == spqr_tree::node_type::S) {\n\t\t\t\t\t\tint st = tree.nodes[node].vedges.st;\n\t\t\t\t\t\tint en = tree.nodes[node].vedges.en-1;\n\t\t\t\t\t\tif (flip) {\n\t\t\t\t\t\t\tfor (int ve = en-1; ve >= st; ve--) {\n\t\t\t\t\t\t\t\tself(tree.vedges[ve].o_node, flip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int ve = st; ve < en; ve++) {\n\t\t\t\t\t\t\t\tself(tree.vedges[ve].o_node, flip);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else assert(false);\n\t\t\t\t});\n\t\t\t\tif (tree.nodes[root_node].type == spqr_tree::node_type::P) {\n\t\t\t\t\tint a = tree.nodes[root_node].vedges.st;\n\t\t\t\t\tint b = tree.nodes[root_node].vedges.st+1;\n\t\t\t\t\tconst auto& ve = tree.vedges[tree.nodes[root_node].vedges.en-1];\n\t\t\t\t\tint st = int(ans[ve.vs[1]].size());\n\t\t\t\t\tans[ve.vs[1]].push_back(ve.vs[0]);\n\t\t\t\t\tdfs(tree.vedges[a].o_node, false);\n\t\t\t\t\tint l = int(ans[ve.vs[1]].size());\n\t\t\t\t\tans[ve.vs[0]].push_back(ve.vs[1]);\n\t\t\t\t\tdfs(tree.vedges[b].o_node, true);\n\t\t\t\t\tstd::rotate(ans[ve.vs[1]].begin() + st, ans[ve.vs[1]].begin() + l, ans[ve.vs[1]].end());\n\t\t\t\t} else if (tree.nodes[root_node].type == spqr_tree::node_type::S) {\n\t\t\t\t\tconst auto& ve = tree.vedges[tree.nodes[root_node].vedges.en-1];\n\t\t\t\t\tassert(ve.is_tree);\n\t\t\t\t\tans[ve.vs[1]].push_back(ve.vs[0]);\n\t\t\t\t\tdfs(root_node, false);\n\t\t\t\t\tans[ve.vs[0]].push_back(ve.vs[1]);\n\t\t\t\t} else if (tree.nodes[root_node].type == spqr_tree::node_type::I) {\n\t\t\t\t\tfor (const auto& ve : tree.nodes[root_node].vedges.bind(tree)) {\n\t\t\t\t\t\tdfs(ve.o_node, false);\n\t\t\t\t\t}\n\t\t\t\t} else assert(false);\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tif (solve()) {\n\t\t\tcout << \"YES\" << '\\n';\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int z = 0; z < int(ans[i].size()); z++) {\n\t\t\t\t\tcout << ans[i][z] << \" \\n\"[z+1==int(ans[i].size())];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs"], "dificulty": "3500", "interactive": false}