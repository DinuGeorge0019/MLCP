{
    "link": "https://codeforces.com//contest/1975/problem/H",
    "problemId": "2665479",
    "problem_idx": "H",
    "shortId": "1975H",
    "contest_number": "1975",
    "problem_submissions": {
        "H": [
            262631844,
            262612241,
            262600659,
            262612635,
            263096548
        ],
        "G": [
            262620370,
            262584629,
            262630306,
            262578664,
            262622745,
            262588918,
            262593694,
            262594206,
            262595918,
            262599422,
            262708940,
            262706456,
            262598241,
            262653444,
            262620831,
            262602673,
            262607334,
            262630272,
            262607273,
            262706071,
            262602704,
            262606536,
            262606903,
            262607812,
            263091775,
            263089587,
            263088604,
            263088409,
            263086834,
            263086045,
            262606154,
            264861303,
            262776553,
            262774627,
            262774590,
            262661298,
            262661024,
            262660704,
            262660316,
            262660273,
            262649420,
            262647737,
            262637294,
            262637274,
            262636778,
            262636749,
            262636610,
            262628729,
            262609429
        ],
        "E": [
            262558741,
            262555523,
            262542791,
            262569978,
            262560342,
            262572286,
            262561563,
            262558869,
            262555295,
            262569100,
            262560726,
            262553867,
            262556464,
            262558648,
            262561133,
            262565554,
            262576529,
            262575502,
            262635435,
            262635401,
            262635086,
            262635019,
            262630627,
            262630590,
            262570080
        ],
        "F": [
            262544594,
            262562050,
            262557811,
            262552279,
            262571108,
            262585701,
            262572669,
            262581085,
            262582375,
            262578636,
            262570215,
            262564737,
            262572783,
            262580057,
            262586122,
            262583527,
            262590488,
            262590492,
            262629974,
            262593633
        ],
        "D": [
            262526751,
            262533906,
            262549799,
            262548001,
            262535765,
            262555432,
            262532809,
            262542647,
            262536556,
            262547635,
            262538823,
            262574019,
            262544846,
            262547400,
            262544181,
            262539052,
            262538393,
            262538893,
            262629935,
            262543856
        ],
        "A": [
            262522755,
            262521103,
            262521181,
            262521345,
            262530553,
            262521158,
            262521224,
            262521209,
            262523388,
            262521604,
            262521957,
            262521117,
            262521171,
            262521739,
            262524060,
            262521821,
            262521219,
            262521958
        ],
        "C": [
            262522159,
            262524942,
            262525029,
            262526905,
            262542130,
            262526806,
            262529464,
            262528086,
            262531414,
            262526373,
            262530226,
            262525393,
            262531728,
            262530061,
            262528640,
            262528306,
            262542306,
            262526711
        ],
        "B": [
            262521205,
            262521505,
            262522451,
            262522658,
            262534024,
            262523709,
            262523854,
            262522613,
            262526293,
            262523579,
            262524186,
            262521924,
            262522192,
            262523093,
            262522741,
            262523954,
            262521898,
            262521340
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129801",
    "editorial": "Solution Consider the maximum character of the string .If only appears\nonce, then obviously the string starting with it is the largest in\nlexicographical order. To make it the smallest, should be arranged at\nthe end. Other characters can be arranged arbitrarily.If appears more\nthan twice, it can be proven that the beginning and end of the answer\nstring must be . If the beginning of the string is not , moving the\ncharacter at the beginning to somewhere before a non-first can make the\nsuffix lexicographical order starting with this smaller, while the\nsuffix lexicographical order starting with after this remains unchanged.\nFor suffixes that do not start with , they are definitely not the\nlargest, so they do not need to be considered. If the end of the string\nis not , first remove it, and all suffix lexicographical orders become\nsmaller. Similarly, it can also be placed in front of a certain to\nreduce the lexicographical order.In this case, the answer is always in\nthe form of . Where contain characters that are less than , it could\nalso be an empty string. Now suppose that the set is determined, and\nconsider how to arrange their order. Suppose we are currently comparing\ntwo suffixes and , and suppose and are the first two substrings that\nappear differently. Then and must be equal, and the size relationship\nbetween and is the same as the size relationship between and . In this\nway, all can be sorted according to lexicographical order, and regarded\nas a new character, and Solving the original problem for is\nsufficient.Now consider how to determine the set . For a certain , it\nshould obviously be ordered, because this can make smaller. There is\nalso another property. Suppose there are and such that is the current\nlexicographically largest string, and , where is a character less than .\nPutting after can make the answer smaller.The proof of the property is\nas follows. Without loss of generality, let , , , , then we have and .\nConsider the subproblem after iteration, by definition, is the largest\ncharacter in the problem. If and are used, and there is an to the left\nof some in the optimal solution string, then replacing this and its\nnearest on the left with and respectively, it is easy to prove that the\nlargest suffix will definitely become smaller or unchanged. Otherwise,\nall are to the left of all , at this time you can arbitrarily replace\nsome and with and respectively, it is easy to prove that the largest\nsuffix still becomes smaller or unchanged.Based on the above discussion,\nwe can now give the final greedy algorithm for the problem. Suppose the\nlargest character has occurrences. If , then put the only at the end,\nand the other characters can be arranged arbitrarily. Otherwise, suppose\nthere are characters less than , if , it can be proved that there is at\nmost one character between any two . Consider , (empty string), then\nthey meet the above properties, and it is more optimal to exchange the\nlast character of to . Therefore, is a single character, , and\nrecursively solve the subproblem. Note that to ensure time complexity,\nwhen , multiple rounds of recursion need to be combined.If , it can be\nsimilarly proved that there will not be an that is an empty string. In\naddition, consider the first character of all , for those among these\ncharacters that are not the largest, using the same property, it can be\nproved that the length of the string they are in must be , and no other\ncharacters will follow. Also, since is ordered, it can be proved that\nthe first character of all must be the smallest characters less than .\nNext, the remaining characters will only be filled after those largest\ncharacters among these characters, and it can be similarly proved that\nthose filled in the second position of these strings are also the\nsmallest among the remaining characters, and so on, until all characters\nare used up.Notice that the complexity of each recursion is linear, and\neach recursion at least halves the number of characters, so the total\ncomplexity is .\n",
    "name": "H. 378QAQ and Core",
    "statement": "378QAQ has a string s of length n. Define the of a string as the\r\nsubstring^\r\ndagger with maximum lexicographic^\r\nddagger order.For example, the core of \"\r\nmathtt{bazoka}\" is \"\r\nmathtt{zoka}\", and the core of \"\r\nmathtt{aaa}\" is \"\r\nmathtt{aaa}\".378QAQ wants to rearrange the string s so that the core is\r\nlexicographically minimum. Find the lexicographically minimum possible\r\ncore over all rearrangements of s.^\r\ndagger A substring of string s is a continuous segment of letters from\r\ns. For example, \"\r\nmathtt{defor}\", \"\r\nmathtt{code}\" and \"\r\nmathtt{o}\" are all substrings of \"\r\nmathtt{codeforces}\" while \"\r\nmathtt{codes}\" and \"\r\nmathtt{aaa}\" are not.^\r\nddagger A string p is lexicographically smaller than a string q if and\r\nonly if one of the following holds: p is a prefix of q, but p\r\nne q; or in the first position where p and q differ, the string p has a\r\nsmaller element than the corresponding element in q (when compared by\r\ntheir ASCII code). For example, \"\r\nmathtt{code}\" and \"\r\nmathtt{coda}\" are both lexicographically smaller than \"\r\nmathtt{codeforces}\" while \"\r\nmathtt{codeforceston}\" and \"\r\nmathtt{z}\" are not.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 25.05.2024 12:30:26**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int foo;    cin >> foo;    string s;    cin >> s;    auto Dfs = [&](auto&& self, vector<int> a) -> vector<int> {      int n = int(a.size());      if (n == 0) {        return vector<int>();      }      sort(a.begin(), a.end());      int sz = 1;      for (int i = n - 2; i >= 0; i--) {        if (a[i] == a[n - 1]) {          sz += 1;        } else {          break;        }      }      if (sz == 1) {        return vector<int>(1, a[n - 1]);      }      vector<vector<int>> b;      int rest = n - sz;      int times = max(1, sz / (rest + 1));      b.assign(sz, vector<int>(1, a[n - 1]));      int start = times;      int ptr = times;      for (int i = 0; i < rest; i++) {        if (b[ptr].size() == 1) {          b[ptr].assign(times, a[n - 1]);          b.resize(b.size() - (times - 1));        }        b[ptr].push_back(a[i]);        if (i > 0 && a[i] != a[i - 1]) {          start = ptr;        }        ptr += 1;        if (ptr == sz) {          ptr = start;        }      }      vector<int> c(b.size());      vector<int> any;      for (int i = 0; i < int(b.size()); i++) {        if (i == 0 || b[i] != b[i - 1]) {          any.push_back(i);        }        c[i] = int(any.size()) - 1;      }      c.erase(c.begin(), c.begin() + times);      auto got = self(self, c);      for (int i = 0; i < times; i++) {        got.push_back(0);      }      vector<int> res;      for (int x : got) {        for (int y : b[any[x]]) {          res.push_back(y);        }      }      return res;    };    vector<int> a(foo);    for (int i = 0; i < foo; i++) {      a[i] = int(s[i] - 'a');    }    auto res = Dfs(Dfs, a);    for (int x : res) {      cout << char(x + 'a');    }    cout << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. 378QAQ and Core.json"
}