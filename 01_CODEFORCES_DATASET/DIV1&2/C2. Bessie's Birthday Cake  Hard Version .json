{
    "link": "https://codeforces.com//contest/1942/problem/C2",
    "problemId": "2562660",
    "problem_idx": "C2",
    "shortId": "1942C2",
    "contest_number": "1942",
    "problem_submissions": {
        "H": [
            254183902,
            254188108,
            254201851,
            254183582,
            254190002,
            254198277,
            254202464,
            254201777
        ],
        "G": [
            254162531,
            254164622,
            254151822,
            254172554,
            254170602,
            254147291,
            254169050,
            254165219,
            254167927,
            254162501,
            254160773,
            254158971,
            254158358,
            254162939,
            254174812,
            254166519,
            254160779,
            254190901,
            254172694
        ],
        "F": [
            254158172,
            254152768,
            254191293,
            254157909,
            254159055,
            254161327,
            254156776,
            254157963,
            254160983,
            254169304,
            254173612,
            254173846,
            254172970,
            254168440,
            254167804,
            254178450,
            254203408,
            254180148,
            254161110,
            254162666
        ],
        "E": [
            254144668,
            254141645,
            254144010,
            254144661,
            254150949,
            254131679,
            254143965,
            254147690,
            254143510,
            254152706,
            254144759,
            254152214,
            254138579,
            254146127,
            254149515,
            254151573,
            254147613,
            254146631,
            254149743
        ],
        "D": [
            254140034,
            254136242,
            254134735,
            254138534,
            254140561,
            254139068,
            254133778,
            254140913,
            254137432,
            254142449,
            254137105,
            254142252,
            254145710,
            254140092,
            254138595,
            254139592,
            254140216,
            254137967,
            254143121
        ],
        "C1": [
            254131817,
            254128192,
            254204108,
            254125718,
            254128016,
            254124090,
            254123140,
            254122427,
            254125306,
            254127382,
            254129295,
            254126939,
            254129179,
            254122148,
            254134385,
            254126328,
            254132572,
            254129060,
            254125449,
            254134104
        ],
        "C2": [
            254131346,
            254132277,
            254203957,
            254203739,
            254128200,
            254133096,
            254129236,
            254126373,
            254125814,
            254128450,
            254131487,
            254132145,
            254131700,
            254133377,
            254130111,
            254134317,
            254129340,
            254132361,
            254129276,
            254129577,
            254134556
        ],
        "B": [
            254123310,
            254123064,
            254120037,
            254123258,
            254119059,
            254120381,
            254119896,
            254118664,
            254120410,
            254124572,
            254120489,
            254125154,
            254128773,
            254119724,
            254122914,
            254121539,
            254119687,
            254120045,
            254122462
        ],
        "A": [
            254117704,
            254118878,
            254117338,
            254117275,
            254117327,
            254117266,
            254117244,
            254117366,
            254117469,
            254117281,
            254117396,
            254117230,
            254117295,
            254117454,
            254117450,
            254117301,
            254117455,
            254117981
        ]
    },
    "name": "C2. Bessie's Birthday Cake  Hard Version ",
    "statement": "Bessie has received a birthday cake from her best friend Elsie, and it\r\ncame in the form of a regular polygon with n sides. The vertices of the\r\ncake are numbered from 1 to n clockwise. You and Bessie are going to\r\nchoose some of those vertices to cut diagonals into the cake. In other\r\nwords, the endpoints of the diagonals must be part of the chosen\r\nvertices.Bessie would only like to give out pieces of cake which result\r\nin a triangle to keep consistency. The size of the pieces doesn’t\r\nmatter, and the whole cake does not have to be separated into all\r\ntriangles (other shapes are allowed in the cake, but those will not be\r\ncounted). Bessie has already chosen x of those vertices that can be used\r\nto form diagonals. She wants you to choose y other vertices such that\r\nthe number of triangular pieces of cake she can give out is\r\nmaximized.What is the maximum number of triangular pieces of cake Bessie\r\ncan give out?\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\nbool dbg=false;\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\nusing vvi=vc<vc<int>>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\nstring rand_string(int n,char lw,char up){\n\tstring s(n,'?');\n\trep(i,n)s[i]=rand_int(lw,up);\n\treturn s;\n}\n\nint current_run_id,run_batch_size=1000;\nint calc_random_limit(){\n\treturn current_run_id/run_batch_size+1;\n}\ntemplate<class t>\nvoid generate_single(t&a){\n\ta=rand_int(1,calc_random_limit());\n}\nvoid generate_single(string&a){\n\tint n;generate_single(n);\n\ta=rand_string(n,'a','b');\n}\ntemplate<class t,class u>\nvoid generate_single(pair<t,u>&a){\n\tgenerate_single(a.a);\n\tgenerate_single(a.b);\n}\n//https://trap.jp/post/1224/\ntemplate<class... Args>\nvoid input(Args&... a){\n\tif(dbg){\n\t\t(generate_single(a),...);\n\t}else{\n\t\t(cin >> ... >> a);\n\t}\n}\n#define INT(...) int __VA_ARGS__;input(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;input(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;input(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;input(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;input(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;input(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;input(__VA_ARGS__)\n#define overload3(a,b,c,d,...) d\n#define VI2(name,size) vi name(size);rep(i_##name,size)input(name[i_##name]);\n#define VI3(name,size,offset) vi name(size);rep(i_##name,size)input(name[i_##name]),name[i_##name]+=offset;\n#define VI(...) overload3(__VA_ARGS__,VI3,VI2)(__VA_ARGS__)\n#define VPI(name,size) vc<pi> name(size);rep(i_##name,size)input(name[i_##name]);\n#define VVI(name,sizeN,sizeM) vvi name(sizeN,vi(sizeM));\\\nrep(i_##name,sizeN)rep(j_##name,sizeM)input(name[i_##name][j_##name]);\n\n#define VVT(type,name,sizeN,sizeM) vvc<type> name(sizeN,vc<type>(sizeM));\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1){\n\t\tif(dbg)cout<<endl;\n\t\telse cout<<\"\\n\";\n\t}\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\ntemplate<class T>\nvoid printvv(const vvc<T>&vs){\n\tfor(const auto&row:vs)print(row);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class S> void mkuni(S&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t> bool isuni(vc<t> v){\n\tint s=si(v);\n\tmkuni(v);\n\treturn si(v)==s;\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class S,class u>\nint lwb(const S&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tvoid clear(){\n\t\tfill(all(p),-1);\n\t\tfill(all(s),1);\n\t\tc=si(p);\n\t}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\tif(dbg){\n\t\tvvc<int> t(n);\n\t\tunionfind uf(n);\n\t\twhile(uf.c>1){\n\t\t\tint a=rand_int(n);\n\t\t\tint b=rand_int(n);\n\t\t\tif(uf.unite(a,b)){\n\t\t\t\tt[a].pb(b);\n\t\t\t\tt[b].pb(a);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}else{\n\t\treturn readGraph(n,n-1);\n\t}\n}\n\nvoid printTree(const vvc<int> t){\n\tint n=si(t);\n\tint degsum=0;\n\trep(i,n)degsum+=si(t[i]);\n\tif(degsum==n-1){\n\t\t//directed\n\t\trep(i,si(t))for(auto j:t[i]){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else if(degsum==2*(n-1)){\n\t\t//undirected\n\t\trep(i,si(t))for(auto j:t[i])if(i<j){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else{\n\t\tassert(false);\n\t}\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\ntemplate<class t,class u,class v>\npair<t,u>&operator*=(pair<t,u>&a,v b){\n\ta.a*=b;a.b*=b;return a;}\ntemplate<class t,class u,class v>\npair<t,u> operator*(pair<t,u> a,v b){return a*=b;}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a){return mp(-a.a,-a.b);}\nnamespace std{\ntemplate<class t,class u>\nistream&operator>>(istream&is,pair<t,u>&a){\n\treturn is>>a.a>>a.b;\n}\n}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator*=(vc<t>&a,u x){\n\tfor(auto&v:a)v*=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator*(vc<t> a,u x){\n\treturn a*=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n//消した要素の個数を返してくれる\n//UCUP 2-8-F\ntemplate<class t,class F>\nint remif(vc<t>&a,F f){\n\tauto itr=remove_if(all(a),f);\n\tint res=a.ed-itr;\n\ta.erase(itr,a.ed);\n\treturn res;\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//Multiuni2023-8 C\n//f(lw)=false,...,f(n-1)=false,f(n)=true,...,f(up)=true,\n//のときに n を返す\ntemplate<class F>\nint find_min_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))up=mid;\n\t\telse lw=mid;\n\t}\n\treturn up;\n}\n//f(lw)=true,f(up)=false\ntemplate<class F>\nint find_max_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))lw=mid;\n\t\telse up=mid;\n\t}\n\treturn lw;\n}\n\ntemplate<class t> using pqmin=priority_queue<t,vc<t>,greater<t>>;\ntemplate<class t> using pqmax=priority_queue<t>;\nusing T=tuple<int,int,int>;\n\nvoid slv(){\n\tINT(n,x,y);\n\tVI(a,x,-1);\n\tsoin(a);\n\ta.pb(a[0]+n);\n\tvi ls;\n\trep(i,x)ls.pb(a[i+1]-a[i]);\n\tdmp(ls);\n\t\n\tint ans=(x-2);\n\tint odd=0;\n\tvi even;\n\tfor(auto w:ls){\n\t\tif(w%2==0){\n\t\t\tif(w==2){\n\t\t\t\tans+=1;\n\t\t\t}else{\n\t\t\t\teven.pb(w/2-1);\n\t\t\t}\n\t\t}else{\n\t\t\todd+=w/2;\n\t\t}\n\t}\n\tsoin(even);\n\t\n\tfor(auto v:even){\n\t\tif(v<=y){\n\t\t\tans+=v*2+1;\n\t\t\ty-=v;\n\t\t}else{\n\t\t\tans+=y*2;\n\t\t\ty=0;\n\t\t}\n\t}\n\tans+=min(y,odd)*2;\n\t\n\tprint(ans);\n}\n\nsigned main(signed argc,char*argv[]){\n\tif(argc>1&&strcmp(argv[1],\"D\")==0)dbg=true;\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1){\n\t\t\tif(current_run_id%run_batch_size==0){\n\t\t\t\tcerr<<\"Current Run \"<<current_run_id<<endl;\n\t\t\t}\n\t\t\tslv();\n\t\t\tcurrent_run_id++;\n\t\t}\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "greedy",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C2. Bessie's Birthday Cake  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/126942",
    "editorial": null,
    "hint": []
}