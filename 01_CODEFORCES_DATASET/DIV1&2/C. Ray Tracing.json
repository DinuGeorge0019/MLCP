{
    "link": "https://codeforces.com//contest/724/problem/C",
    "problemId": "74852",
    "problem_idx": "C",
    "shortId": "724C",
    "contest_number": "724",
    "problem_submissions": {
        "G": [
            21292263,
            21289389,
            21296363,
            21288425,
            21294631,
            21287775,
            21293574,
            21292770,
            21291944,
            21288934,
            21292172,
            21288247,
            21292559,
            21295809,
            21290880,
            21290578,
            21290415,
            21293943
        ],
        "E": [
            21288925,
            21292133,
            21297352,
            21291033,
            21288200,
            23659645,
            21290576,
            21290313,
            21292937,
            21296159,
            21294663,
            21290237,
            21296769,
            21292864,
            21297544,
            23608572
        ],
        "F": [
            21288190,
            21295097,
            21291428,
            21408768,
            21292926,
            21298468,
            145553208,
            21294689
        ],
        "D": [
            21285401,
            21285608,
            21286235,
            21283645,
            21284412,
            21288117,
            21285995,
            21287478,
            21286772,
            21286376,
            21289028,
            21285265,
            21288845,
            21286726,
            21290761,
            21285673,
            21284100,
            21286467,
            21288075
        ],
        "B": [
            21284134,
            21280714,
            21282752,
            21281462,
            21280744,
            21282751,
            21280902,
            21282004,
            21281773,
            21281431,
            21281779,
            21284722,
            21286664,
            21280972,
            21281353,
            21282957,
            21282648
        ],
        "C": [
            21283255,
            21284495,
            21288232,
            21285743,
            21285969,
            21285870,
            21284787,
            21286083,
            21285861,
            21284725,
            21286899,
            21284034,
            21287013,
            21285582,
            21297034,
            21283106,
            21286310,
            21285066,
            21286458
        ],
        "A": [
            21280305,
            21279735,
            21280413,
            21279914,
            21280000,
            21280810,
            21279870,
            21279953,
            21279966,
            21279817,
            21280008,
            21279884,
            21281495,
            21279783,
            21281061,
            21279908,
            21279971,
            21280674,
            21280506
        ]
    },
    "name": "C. Ray Tracing",
    "statement": "There are sensors located in the rectangular room of size meters. The\r\n-th sensor is located at point . All sensors are located at distinct\r\npoints strictly inside the rectangle. Opposite corners of the room are\r\nlocated at points and . Walls of the room are parallel to coordinate\r\naxes.At the moment , from the point the laser ray is released in the\r\ndirection of point . The ray travels with a speed of meters per second.\r\nThus, the ray will reach the point in exactly one second after the\r\nstart.When the ray meets the wall it’s reflected by the rule that the\r\nangle of incidence is equal to the angle of reflection. If the ray\r\nreaches any of the four corners, it immediately stops.For each sensor\r\nyou have to determine the first moment of time when the ray will pass\r\nthrough the point where this sensor is located. If the ray will never\r\npass through this point, print for such sensors.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nset<PII> f[N],g[N];\nll t[N];\nint x,y,n,m,k;\nvoid add(int x,int y,int id) {\n\tf[x+y].insert(mp(x,id));\n\tg[x+m-y].insert(mp(x,id));\n}\nint go(int &x,int &y,int dir,ll &t) {\n\tif (dir==0) {\n\t\tauto it=g[x+m-y].upper_bound(mp(x,-1));\n\t\tassert(it!=g[x+m-y].end());\n\t\tint st=it->fi-x,id=it->se;\n\t\tx+=st,y+=st; t+=st;\n\t\tf[x+y].erase(mp(x,id));\n\t\tg[x+m-y].erase(mp(x,id));\n\t\treturn id;\n\t} else if (dir==2) {\n\t\tauto it=g[x+m-y].lower_bound(mp(x,-1));\n\t\tassert(it!=g[x+m-y].begin());\n\t\t--it;\n\t\tint st=x-it->fi,id=it->se;\n\t\tx-=st,y-=st; t+=st;\n\t\tf[x+y].erase(mp(x,id));\n\t\tg[x+m-y].erase(mp(x,id));\n\t\treturn id;\t\t\n\t} else if (dir==3) {\n\t\tauto it=f[x+y].upper_bound(mp(x,-1));\n\t\tassert(it!=f[x+y].end());\n\t\tint st=it->fi-x,id=it->se;\n\t\tx+=st,y-=st; t+=st;\n\t\tf[x+y].erase(mp(x,id));\n\t\tg[x+m-y].erase(mp(x,id));\n\t\treturn id;\n\t} else {\n\t\tauto it=f[x+y].lower_bound(mp(x,-1));\n\t\tassert(it!=f[x+y].begin());\n\t\t--it;\n\t\tint st=x-it->fi,id=it->se;\n\t\tx-=st,y+=st; t+=st;\n\t\tf[x+y].erase(mp(x,id));\n\t\tg[x+m-y].erase(mp(x,id));\n\t\treturn id;\n\t}\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d\",&k);\n\trep(i,0,k) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tt[i]=-1;\n\t\tadd(x,y,i);\n\t}\n\trep(i,0,n+1) {\n\t\tadd(i,0,-1);\n\t\tadd(i,m,-1);\n\t}\n\trep(i,1,m) add(0,i,-1),add(n,i,-1);\n\tint dir=0,x=0,y=0;\n\tll mt=0;\n\twhile (1) {\n\t\tint id=go(x,y,dir,mt);\n//\t\tprintf(\"%d %d\\n\",x,y);\n\t\tif ((x==0||x==n)&&(y==0||y==m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (id!=-1) t[id]=mt;\n\t\telse {\n\t\t\tif (x==n||x==0) dir=dir^1;\n\t\t\telse dir=dir^3;\n\t\t}\n\t}\n\trep(i,0,k) printf(\"%lld\\n\",t[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "hashing",
        "implementation",
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Ray Tracing.json",
    "editorial_link": "https://codeforces.com//blog/entry/47644",
    "editorial": "Letâs simulate the flight of the beam. It can be seen that for any\r\nsegment between two successive reflections is true that the sum of the\r\ncoordinates for each point of this segment is constant or the difference\r\nof the coordinates is constant.Thus, we can make lists of sensors for\r\neach possible sum and difference of coordinates. Then, when we process\r\nthe segment of the beam trajectory, we can take all the points from the\r\ncorresponding list and update result for them.This solution works fast,\r\nbecause each point is passed by the beam (and therefore viewed by us)\r\nnot more than two times.\r\n",
    "hint": []
}