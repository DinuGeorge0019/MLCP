{
    "link": "https://codeforces.com//contest/765/problem/F",
    "problemId": "93902",
    "problem_idx": "F",
    "shortId": "765F",
    "contest_number": "765",
    "problem_submissions": {
        "F": [
            24663045,
            24662127,
            24676770,
            24660358,
            24667152,
            24667397,
            24662544,
            24672838,
            24672753,
            24667598,
            31935479,
            24716746,
            24682448,
            24679841,
            24679801,
            24670904,
            24670698,
            24670489
        ],
        "E": [
            24655066,
            24654207,
            24663627,
            24664513,
            24664094,
            24658430,
            24660515,
            24666458,
            24658142,
            24662259,
            24662493,
            24655583,
            24656953,
            24655759,
            24661672,
            24653196,
            24657812,
            24658375,
            24656880
        ],
        "D": [
            24651389,
            24649417,
            24662180,
            24649659,
            24650176,
            24654581,
            24653214,
            24651939,
            24652955,
            24653924,
            24658681,
            24649453,
            24651451,
            24650652,
            24650490,
            24649885,
            24654333,
            24652778,
            24651423
        ],
        "C": [
            24648852,
            24646235,
            24650994,
            24645410,
            24646069,
            24647071,
            24647842,
            24648558,
            24647605,
            24648623,
            24647741,
            24647343,
            24648346,
            24646116,
            24646007,
            24646516,
            24646082,
            24647004,
            24651850
        ],
        "B": [
            24646782,
            24644999,
            24653327,
            24644551,
            24644873,
            24645624,
            24645777,
            24646431,
            24646046,
            24646603,
            24645747,
            24645801,
            24644851,
            24645211,
            24644761,
            24644995,
            24644787,
            24645473,
            24645892
        ],
        "A": [
            24645504,
            24644450,
            24647516,
            24644412,
            24644455,
            24644858,
            24644550,
            24644940,
            24644763,
            24644751,
            24644918,
            24644439,
            24644463,
            24644604,
            24644437,
            24644462,
            24644460,
            24644469,
            24645016
        ],
        "G": [
            24665280,
            24660267
        ]
    },
    "name": "F. Souvenirs",
    "statement": "Artsem is on vacation and wants to buy souvenirs for his two teammates.\r\nThere are souvenir shops along the street. In -th shop Artsem can buy\r\none souvenir for dollars, and he cannot buy more than one souvenir in\r\none shop. He doesn\u2019t want to introduce envy in his team, so he wants to\r\nbuy two souvenirs with least possible difference in price.Artsem has\r\nvisited the shopping street times. For some strange reason on the -th\r\nday only shops with numbers from to were operating (weird? yes it is,\r\nbut have you ever tried to come up with a reasonable legend for a range\r\nquery problem?). For each visit, Artsem wants to know the minimum\r\npossible difference in prices of two different souvenirs he can buy in\r\nthe opened shops.In other words, for each Artsem\u2019s visit you should find\r\nthe minimum possible value of where , .\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 3e5 + 100;\nint as[N];\nint a[N];\n\nconst int LOG = 18;\nconst int LEVEL = (1 << LOG);\nconst int SZ = (LEVEL << 1);\n\nstruct tree\n{\n\tint mx[SZ];\n\ttree() : mx() \n\t{\n\t\tmemset(mx, -1, sizeof mx);\n\t}\n\tvoid set(int pos, int val)\n\t{\n\t\tpos += LEVEL;\n\t\tmx[pos] = max(mx[pos], val);\n\t\tpos /= 2;\n\t\twhile (pos >= 1)\n\t\t{\n\t\t\tmx[pos] = max(mx[2 * pos], mx[2 * pos + 1] );\n\t\t\tpos /= 2;\n\t\t}\n\t}\n\tint getMax(int v, int l, int r, int tl, int tr)\n\t{\n\t\tif (tr < l || r < tl) return -1;\n\t\tif (l <= tl && tr <= r) return mx[v];\n\t\tint tm = (tl + tr) / 2;\n\t\treturn max(\n\t\t\t\tgetMax(2 * v, l, r, tl, tm),\n\t\t\t\tgetMax(2 * v + 1, l, r, tm + 1, tr)\n\t\t\t\t);\n\t}\n\tint getMax(int l, int r)\n\t{\n\t\tif (l > r) return -1;\n\t\treturn getMax(1, l, r, 0, LEVEL - 1);\n\t}\n\tint getMaxVal(int vl, int vr, int k)\n\t{\n\t\tint l = lower_bound(as, as + k, vl) - as;\n\t\tint r = upper_bound(as, as + k, vr) - as;\n\t\tr--;\n\t\treturn getMax(l, r);\n\t}\n\n} tree;\n\nvector <int> listD[N], listU[N];\n\nvoid init(int n, int k)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n//\t\tint cnt = 0;\n//\t\teprintf(\"init i = %d\\n\", i);\n\t\tint deltaUp = as[k - 1] - as[a[i] ];\n\t\twhile (true)\n\t\t{\n//\t\t\tcnt++;\n//\t\t\tif (cnt > LOG * 2) throw;\n\t\t\tint mxPos = tree.getMaxVal(as[a[i] ], as[a[i] ] + deltaUp, k);\n//\t\t\teprintf(\"deltaUp = %d, mxPos = %d\\n\", deltaUp, mxPos);\n\t\t\tif (mxPos == -1) break;\n\t\t\tlistU[i].push_back(mxPos);\n\t\t\tdeltaUp = as[a[mxPos] ] - as[a[i] ];\n//\t\t\teprintf(\"deltaUp = %d\\n\", deltaUp);\n\t\t\tif (deltaUp == 0) break;\n\t\t\tdeltaUp /= 2;\n\t\t}\n\t\tint deltaDown = as[a[i] ] - as[0];\n//\t\tcnt = 0;\n\t\twhile (true)\n\t\t{\n//\t\t\tcnt++;\n//\t\t\tif (cnt > LOG * 2) throw;\n//\t\t\teprintf(\"i = %d: %d ... %d\\n\", i, as[a[i] ] - deltaDown, as[a[i] ] );\n\t\t\tint mxPos = tree.getMaxVal(as[a[i] ] - deltaDown, as[a[i] ], k);\n//\t\t\teprintf(\"deltaDown = %d, mxPos = %d\\n\", deltaDown, mxPos);\n\t\t\tif (mxPos == -1) break;\n\t\t\tlistD[i].push_back(mxPos);\n\t\t\tdeltaDown = as[a[i] ] - as[a[mxPos] ];\n\t\t\tif (deltaDown == 0) break;\n\t\t\tdeltaDown /= 2;\n\t\t}\n\t\ttree.set(a[i], i);\n\t}\n\n//\tfor (int x : listD[15] )\n//\t\teprintf(\"%d \", x);\n//\teprintf(\"\\n\");\n}\n\n\nvector <int> qsmall[N];\nvector <int> qu[N];\nint ans[N];\nconst int BL = 320; // TODO\n//const int BL = 5;\n\n/*\nint solveSlow(int l, int r)\n{\n\tint answ = abs(as[a[r] ] - as[a[l] ] );\n\tfor (int i = l; i <= r; i++)\n\t\tfor (int j = i + 1; j <= r; j++)\n\t\t\tansw = min(answ, abs(as[a[i] ] - as[a[j] ] ) );\n\treturn answ;\n}\n*/\n\nint l[N], r[N];\nbool cmpR(int i, int j)\n{\n\treturn r[i] < r[j];\n}\n\nint val[N], slow[N];\n\nvoid solve(int n, int k)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tslow[i] = as[k - 1] - as[0];\n\t\tval[i] = as[k - 1] - as[0];\n\t}\n\n\tfor (int bs = 0; bs < n; bs += BL)\n\t{\n\t\tint be = min(bs + BL - 1, n - 1);\n//\t\teprintf(\"bs = %d, be = %d\\n\", bs, be);\n\t\tvector <int> qs;\n\t\tfor (int i = bs; i <= be; i++)\n\t\t\tfor (int x : qu[i] )\n\t\t\t\tqs.push_back(x);\n\t\tsort(qs.begin(), qs.end(), cmpR);\n\t\n\n\t\tfor (int cr = bs; cr <= be; cr++)\n\t\t{\n\t\t\tfor (int cl = bs; cl < cr; cl++)\n\t\t\t\tslow[cl] = min(slow[cl], abs(as[a[cr] ] - as[a[cl] ] ));\n\t\t\tfor (int cl = cr - 1; cl >= bs; cl--)\n\t\t\t\tslow[cl] = min(slow[cl], slow[cl + 1] );\n\t\t\twhile (!qsmall[cr].empty() )\n\t\t\t{\n\t\t\t\tint id = qsmall[cr].back();\n\t\t\t\tqsmall[cr].pop_back();\n\t\t\t\tans[id] = slow[l[id] ];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = be - 1; i >= bs; i--)\n\t\t{\n\t\t\tslow[i] = slow[i + 1];\n\t\t\tfor (int j = i + 1; j <= be; j++)\n\t\t\t\tslow[i] = min(slow[i], abs(as[a[i] ] - as[a[j] ] ) );\n\t\t}\n\n\t\tint ptr = 0;\n\t\tint mnR = as[k - 1] - as[0] + 1;\n\t\tfor (int i = be + 1; i <= n; i++)\n\t\t{\n\t\t\twhile (!listD[i].empty() && listD[i].back() <= be)\n\t\t\t{\n\t\t\t\tint x = listD[i].back();\n\t\t\t\tval[x] = min(val[x], as[a[i] ] - as[a[x] ] );\n\t\t\t\tlistD[i].pop_back();\n\t\t\t}\n\t\t\twhile (!listU[i].empty() && listU[i].back() <= be)\n\t\t\t{\n\t\t\t\tint x = listU[i].back();\n\t\t\t\tval[x] = min(val[x], as[a[x] ] - as[a[i] ] );\n\t\t\t\tlistU[i].pop_back();\n\t\t\t}\n\t\t\tif (!listD[i].empty() )\n\t\t\t{\n\t\t\t\tint x = listD[i].back();\n\t\t\t\tmnR = min(mnR, as[a[i] ] - as[a[x] ] );\n\t\t\t}\n\t\t\tif (!listU[i].empty() )\n\t\t\t{\n\t\t\t\tint x = listU[i].back();\n\t\t\t\tmnR = min(mnR, as[a[x] ] - as[a[i] ] );\n\t\t\t}\n\n\t\t\twhile (ptr != (int) qs.size() && r[qs[ptr] ] == i)\n\t\t\t{\n\t\t\t\tint id = qs[ptr++];\n\n\t\t\t\tint answ = min(mnR, slow[l[id] ] );\n\t\t\t\tfor (int j = l[id]; j <= be; j++)\n\t\t\t\t\tansw = min(answ, val[j] );\n\t\t\t\tans[id] = answ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i] );\n\t\tas[i] = a[i];\n\t}\n\tsort(as, as + n);\n\tint k = unique(as, as + n) - as;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = lower_bound(as, as + k, a[i] ) - as;\n\n//\tfor (int i = 0; i < k; i++)\n//\t\teprintf(\"%d \", as[i] );\n//\teprintf(\"\\n\");\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d%d\", &l[i], &r[i] );\n\t\tl[i]--;\n\t\tr[i]--;\n\t\tif (r[i] / BL == l[i] / BL)\n\t\t\tqsmall[r[i] ].push_back(i);//ans[i] = solveSlow(l[i], r[i]);\n\t\telse\n\t\t\tqu[l[i] ].push_back(i);\n\t}\n\tinit(n, k);\n\tsolve(n, k);\n\tfor (int i = 0; i < m; i++)\n\t\tprintf(\"%d\\n\", ans[i] );\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Souvenirs.json",
    "editorial_link": "https://codeforces.com//blog/entry/50456",
    "editorial": "We will answer queries offline, moving right endpoint to the right and\r\nstoring the answer for each left endpoint in a segment tree. The tree\r\nwill support two operations: set minimum on a segment and get a value in\r\nthe point. More, we assume that among two elements and in our array and\r\nand solve the problem twice for the original array and for the reversed\r\none.Consider one step of moving the right endpoint and adding new\r\nelement to the position . We find the first element to the left of which\r\nis not less than ; denote it with . Obviously, now the answer for all\r\nleft endpoints in range is . Now we find some such that and , and the\r\nanswer for all left endpoints in range is . If we repeat this step while\r\npossible, we maintain correct values in our segment tree.The crucial\r\nidea of the problem is the following inequality: . Why? Because each\r\nsegment with and contains elements and , and adding will improve the\r\nanswer for these endpoints only if this inequality holds. Having this,\r\nwe need to consider only values of .The asymptotic of the solution is .\r\n"
}