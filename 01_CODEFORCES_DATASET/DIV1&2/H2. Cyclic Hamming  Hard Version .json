{"link": "https://codeforces.com//contest/1896/problem/H2", "problemId": "2346413", "problem_idx": "H2", "shortId": "1896H2", "contest_number": "1896", "problem_submissions": {"H2": [234305435, 234294276, 234316807, 234293989, 234307453, 234313145, 234308430, 234674727, 234674461, 234674412, 234348461, 234317754, 234317500], "H1": [234300435, 234288752, 234294076, 234304469, 234296832, 234303366, 234305063, 234305336, 234301810, 234292381], "G": [234290728, 234312960, 234419627, 234295328, 234299457, 234326268, 234302972, 234306994, 234344999, 234302897, 234304455, 234306035, 234296895, 234525586], "F": [234279344, 234262280, 234278356, 234281909, 234284183, 234288595, 234278118, 234284621, 234280975, 234283777, 234307968, 234293096, 234293697, 234294644, 234304686, 234282511, 234279944, 234277321], "E": [234266080, 234275828, 234270895, 234263950, 234269369, 234263464, 234267763, 234270201, 234272007, 234268761, 234270245, 234285745, 234275911, 234277731, 234273316, 234269329, 234260178, 234268619, 234263914], "D": [234260515, 234269507, 234266479, 234257220, 234264143, 234256547, 234261136, 234260603, 234265661, 234261124, 234261787, 234269263, 234266704, 234265834, 234268166, 234280921, 234253907, 234259650, 234255630], "C": [234253899, 234266056, 234253267, 234251911, 234261130, 234253006, 234255721, 234254779, 234258245, 234287578, 234255535, 234262815, 234255118, 234261416, 234262126, 234255695, 234249255, 234253498, 234251351], "B": [234249421, 234247262, 234248984, 234247486, 234250283, 234247863, 234248979, 234248837, 234302894, 234248804, 234248842, 234247845, 234248167, 234249751, 234253337, 234249856, 234245662, 234248853, 234246737], "A": [234245828, 234244872, 234245833, 234244939, 234247553, 234244853, 234245867, 234245696, 234303768, 234246110, 234245020, 234245161, 234244947, 234245703, 234249430, 234244871, 234244771, 234245709, 234244767]}, "name": "H2. Cyclic Hamming  Hard Version ", "statement": "In this statement, all strings are 0-indexed.For two strings a, b of the\r\nsame length p, we define the following definitions: The hamming distance\r\nbetween a and b, denoted as h(a, b), is defined as the number of\r\npositions i such that 0\r\nle i < p and a_i\r\nne b_i. b is a cyclic shift of a if there exists some 0\r\nleq k < p such that b_{(i+k)\r\nbmod p} = a_i for all 0\r\nle i < p. Here x\r\nbmod y denotes the remainder from dividing x by y. You are given two\r\nbinary strings s and t of length 2^{k+1} each. Both strings may contain\r\nmissing characters (denoted by the character \u201d). Your task is to count\r\nthe number of ways to replace the missing characters in both strings\r\nwith the characters \u201d or \u201d such that: Each string s and t contains\r\nexactly 2^k occurrences of each character \u201d and \u201d h(s, c)\r\nge 2^k for all strings c that is a cyclic shift of t. As the result can\r\nbe very large, you should print the value modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\nconst int kax=20;\nconst ll mod=998244353;\nconst ll modk=mod*mod*5;\n\nint invfast[nax];\n\nvoid init_inv()\n{\n\tinvfast[1]=1;\n\tfor (int i=2; i<nax; i++)\n\t\tinvfast[i]=invfast[mod%i]*(mod-mod/i)%mod;\n}\n\nll inv(ll v)\n{\n\tif (v<nax)\n\t\treturn invfast[v];\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nstruct ntt\n{\n\tvll omega[30];\n\tll gen=1;\n\tntt()\n\t{\n\t\twhile(1)\n\t\t{\n\t\t\tgen++;\n\t\t\tll x=gen;\n\t\t\tfor (int i=1; i<__builtin_ctzll(mod-1); i++)\n\t\t\t\tx=(x*x)%mod;\n\t\t\tif (x==mod-1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint lift(int v)\n\t{\n\t\tint ret=1;\n\t\twhile(ret<v)\n\t\t\tret<<=1;\n\t\treturn ret;\n\t}\n\tvoid omegas(int v)\n\t{\n\t\tif (!omega[v].empty())\n\t\t\treturn;\n\t\tint n=(1<<v);\n\t\tint should=((mod-1)&(-(mod-1)));\n\t\tll mul=gen;\n\t\twhile(n<should)\n\t\t{\n\t\t\tmul=(mul*mul)%mod;\n\t\t\tshould>>=1;\n\t\t}\n\t\tomega[v].resize(n+1);\n\t\tomega[v][0]=1;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tomega[v][i]=(omega[v][i-1]*mul)%mod;\n\t}\n\tvoid dft(vll &a, int dir)\n\t{\n\t\tint n=a.size();\n\t\tstatic vll b;\n\t\tb.resize(n);\n\t\tconst int ch=(!dir ? 1 : -1);\n\t\tfor (int i=1, w=1; i<n; i<<=1, w++)\n\t\t{\n\t\t\tomegas(w);\n\t\t\tll *om=omega[w].data();\n\t\t\tb.swap(a);\n\t\t\tconst int &d=n>>w;\n\t\t\tll *pa=a.data();\n\t\t\tll *pb=b.data();\n\t\t\tint now=(!dir ? 0 : (i<<1));\n\t\t\tfor (int j=0; j<n; j+=d, now+=ch)\n\t\t\t{\n\t\t\t\tconst ll &mul=om[now];\n\t\t\t\tint left=(j<<1);\n\t\t\t\tif (left>=n)\n\t\t\t\t\tleft-=n;\n\t\t\t\tint right=(left+d);\n\t\t\t\tfor (int l=0; l<d; l++)\n\t\t\t\t\tpa[j+l]=(pb[left+l]+pb[right+l]*mul)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tvll multi(vll a, vll b)\n\t{\n\t\tif (a.empty() || b.empty())\n\t\t\treturn {};\n\t\tint ra=a.size();\n\t\tint rb=b.size();\n\t\t//~ if (max(ra, rb)<=8)\n\t\t//~ {\n\t\t\t//~ vll ret(ra+rb-1);\n\t\t\t//~ for (int i=0; i<ra; i++)\n\t\t\t\t//~ for (int j=0; j<rb; j++)\n\t\t\t\t\t//~ if ((ret[i+j]+=a[i]*b[j])>=modk)\n\t\t\t\t\t\t//~ ret[i+j]-=modk;\n\t\t\t//~ for (ll &i : ret)\n\t\t\t\t//~ i%=mod;\n\t\t\t//~ return ret;\n\t\t//~ }\n\t\tint n=lift(a.size()+b.size());\n\t\ta.resize(n);\n\t\tb.resize(n);\n\t\tdft(a, 0);\n\t\tdft(b, 0);\n\t\tfor (int i=0; i<n; i++)\n\t\t\ta[i]=(a[i]*b[i])%mod;\n\t\tdft(a, 1);\n\t\tll div=inv(n);\n\t\tfor (ll &i : a)\n\t\t\ti=(i*div)%mod;\n\t\treturn a;\n\t}\n};\n\nntt janusz=ntt();\n\nint k;\n\nchar wcz[nax];\nint raz[nax];\nint dwa[nax];\n\nint tab[nax];\n\nvoid czyt(int *w)\n{\n\tscanf(\"%s\", wcz);\n\t//~ for (int i=0; i<(1<<k); i++)\n\t\t//~ wcz[i]='?';\n\tfor (int i=0; i<(1<<k); i++)\n\t{\n\t\tif (wcz[i]=='0')\n\t\t{\n\t\t\tw[i]=-1;\n\t\t}\n\t\tif (wcz[i]=='1')\n\t\t{\n\t\t\tw[i]=1;\n\t\t}\n\t\tif (wcz[i]=='?')\n\t\t{\n\t\t\tw[i]=0;\n\t\t}\n\t}\n}\n\nll res[nax];\n\nvll wiels[kax][nax];\n\nvll trans(int v)\n{\n\t//~ vll ret(3);\n\t//~ if (v==1)\n\t//~ {\n\t\t//~ ret[2]=1;\n\t//~ }\n\t//~ if (v==-1)\n\t//~ {\n\t\t//~ ret[0]=1;\n\t//~ }\n\t//~ if (v==0)\n\t//~ {\n\t\t//~ ret[0]=1;\n\t\t//~ ret[2]=1;\n\t//~ }\n\t//~ return ret;\n\tvll ret(2);\n\tif (v==1)\n\t{\n\t\tret[1]=1;\n\t}\n\tif (v==-1)\n\t{\n\t\tret[0]=1;\n\t}\n\tif (v==0)\n\t{\n\t\tret[0]=1;\n\t\tret[1]=1;\n\t}\n\treturn ret;\n}\n\nll suma=0;\n\nvoid rek(int v, int maska)\n{\n\tint roz=wiels[v+1][0].size();\n\tif (v==-1)\n\t{\n\t\tif (!(roz&1))\n\t\t{\n\t\t\tres[maska]=0;\n\t\t\t//~ debug() << imie(maska);\n\t\t\t//~ assert(0);\n\t\t\treturn;\n\t\t}\n\t\t//~ debug() << imie(roz);\n\t\tres[maska]=wiels[0][0][roz/2];\n\t\treturn;\n\t}\n\t//~ suma+=(1<<v)*roz;\n\t{\n\t\tfor (int i=0; i<(1<<v); i++)\n\t\t{\n\t\t\tif (v)\n\t\t\t{\n\t\t\t\twiels[v][i]=janusz.multi(wiels[v+1][i], wiels[v+1][i+(1<<v)]);\n\t\t\t\twiels[v][i].resize(2*roz-1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twiels[v][i].resize(2*roz-1);\n\t\t\t\tint cel=(2*roz-1)/2;\n\t\t\t\twiels[v][i][cel]=0;\n\t\t\t\tfor (int j=0; j<=cel; j++)\n\t\t\t\t\tif (j<(int)wiels[v+1][i].size() && cel-j<(int)wiels[v+1][i+(1<<v)].size())\n\t\t\t\t\t\twiels[v][i][cel]=(wiels[v][i][cel]+wiels[v+1][i][j]*wiels[v+1][i+(1<<v)][cel-j])%mod;\n\t\t\t}\n\t\t}\n\t\trek(v-1, maska);\n\t}\n\t{\n\t\tfor (int i=0; i<(1<<v); i++)\n\t\t{\n\t\t\t//~ wiels[v][i].assign(2*roz-1, 0);\n\t\t\t//~ for (int j=0; j<roz; j++)\n\t\t\t\t//~ wiels[v][i][2*j]=(wiels[v+1][i][j]*wiels[v+1][i+(1<<v)][j])%mod;\n\t\t\twiels[v][i].assign(roz, 0);\n\t\t\tfor (int j=0; j<roz; j++)\n\t\t\t\twiels[v][i][j]=(wiels[v+1][i][j]*wiels[v+1][i+(1<<v)][j])%mod;\n\t\t}\n\t\trek(v-1, maska^(1<<v));\n\t}\n}\n\nvll przerob()\n{\n\t//~ suma=0;\n\tfor (int i=0; i<(1<<k); i++)\n\t\tres[i]=0;\n\t\n\tfor (int i=0; i<(1<<k); i++)\n\t\twiels[k][i]=trans(tab[i]);\n\t\n\trek(k-1, 0);\n\t\n\t//~ debug() << imie(suma);\n\t\n\tvll ret;\n\tfor (int i=0; i<(1<<k); i++)\n\t\tret.push_back(res[i]);\n\tfor (int i=0; i<k; i++)\n\t\tfor (int j=0; j<(1<<k); j++)\n\t\t\tif (!(j&(1<<i)))\n\t\t\t\tret[j]=(ret[j]+mod-ret[j^(1<<i)])%mod;\n\treturn ret;\n}\n\nint main()\n{\n\tinit_inv();\n\tscanf(\"%d\", &k);\n\tk++;\n\tczyt(raz);\n\tczyt(dwa);\n\tfor (int i=0; i<(1<<k); i++)\n\t\ttab[i]=raz[i];\n\tvll w1=przerob();\n\t//~ debug() << imie(w1);\n\tfor (int i=0; i<(1<<k); i++)\n\t\ttab[i]=dwa[i];\n\tvll w2=przerob();\n\t//~ debug() << imie(w2);\n\tll wyn=0;\n\tfor (int i=0; i<(1<<k); i++)\n\t\tfor (int j=0; j<(1<<k); j++)\n\t\t\tif ((i|j)==((1<<k)-1))\n\t\t\t\twyn=(wyn+w1[i]*w2[j])%mod;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "fft", "math", "number theory"], "dificulty": "3500", "interactive": false}