{"link": "https://codeforces.com//contest/1023/problem/F", "problemId": "209194", "problem_idx": "F", "shortId": "1023F", "contest_number": "1023", "problem_submissions": {"F": [41706962, 41711449, 41703443, 41713059, 41716623, 41714553, 41714671, 41707623, 41713235, 41712334, 41728092, 41715075, 41696075, 41713356, 41714801, 41709605, 41719826, 41712664, 41715258, 41716252], "E": [41698618, 41698291, 41699659, 41704092, 41694722, 41704680, 41704917, 41699573, 41705681, 41707263, 41704649, 41710828, 41705364, 41701903, 41705217, 41705636, 41706969, 41702766, 41702871], "D": [41694804, 41690882, 41694456, 41696667, 41700369, 41697794, 41697937, 41696439, 41697953, 41699194, 41695409, 41701962, 41696987, 41693065, 41702154, 41698952, 41700314, 41697292, 41697057], "C": [41689677, 41687726, 41688316, 41690341, 41688011, 41691766, 41691373, 41708581, 41689935, 41688178, 41690416, 41703451, 41690697, 41687815, 41690419, 41689708, 41692238, 41691341, 41691501], "B": [41687853, 41686964, 41687392, 41687955, 41687163, 41687657, 41689074, 41696355, 41687990, 41690278, 41688421, 41705049, 41689143, 41688949, 41689104, 41687914, 41689486, 41689269, 41689603], "A": [41686640, 41686676, 41686712, 41686970, 41686742, 41686759, 41687401, 41696322, 41687071, 41686971, 41706549, 41687626, 41686813, 41686865, 41686818, 41686780, 41686879, 41726126], "G": [55938906, 48502404, 46583960, 42546293, 42609540]}, "name": "F. Mobile Phone Network", "statement": "You are managing a mobile phone network, and want to offer competitive\r\nprices to connect a network.The network has n nodes.Your competitor has\r\nalready offered some connections between some nodes, with some fixed\r\nprices. These connections are bidirectional. There are initially m\r\nconnections the competitor is offering. The i-th connection your\r\ncompetitor is offering will connect nodes fa_i and fb_i and costs fw_i.\r\nYou have a list of k connections that you want to offer. It is\r\nguaranteed that this set of connection does not form any cycle. The j-th\r\nof these connections will connect nodes ga_j and gb_j. These connections\r\nare also bidirectional. The cost of these connections have not been\r\ndecided yet.You can set the prices of these connections to any arbitrary\r\ninteger value. These prices are set independently for each connection.\r\nAfter setting the prices, the customer will choose such n - 1\r\nconnections that all nodes are connected in a single network and the\r\ntotal cost of chosen connections is minimum possible. If there are\r\nmultiple ways to choose such networks, the customer will choose an\r\narbitrary one that also maximizes the number of your connections in\r\nit.You want to set prices in such a way such that your k connections are\r\nchosen by the customer, and the sum of prices of your connections is\r\nmaximized.Print the maximum profit you can achieve, or -1 if it is\r\nunbounded.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 500005;\n\nint n, m, k;\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstruct edg{\n\tint s, e, x;\n\tbool operator<(const edg &e)const{\n\t\treturn x < e.x;\n\t}\n};\n\nvector<edg> mst, repl;\nvector<pi> gph[MAXN];\n\nint dep[MAXN];\nint par[19][MAXN], isquery[MAXN];\n\nvoid dfs(int x, int p){\n\tfor(auto &i : gph[x]){\n\t\tif(i.second == p) continue;\n\t\tif(i.first == 0) isquery[i.second] = 1;\n\t\tdep[i.second] = dep[x] + 1;\n\t\tpar[0][i.second] = x;\n\t\tdfs(i.second, x);\n\t}\n}\n\nint lca(int s, int e){\n\tif(dep[s] > dep[e]) swap(s, e);\n\tint dx = dep[e] - dep[s];\n\tfor(int i=0; i<19; i++){\n\t\tif((dx >> i) & 1) e = par[i][e];\n\t}\n\tfor(int i=18; i>=0; i--){\n\t\tif(par[i][s] != par[i][e]){\n\t\t\ts = par[i][s];\n\t\t\te = par[i][e];\n\t\t}\n\t}\n\tif(s != e) return par[0][s];\n\treturn s;\n}\n\n\nint pa[MAXN], ans[MAXN];\n\nint paint(int s, int l, int v, int *ans){\n\tif(s != pa[s]) return pa[s] = paint(pa[s], l, v, ans);\n\tif(dep[s] <= dep[l]) return s;\n\telse{\n\t\tans[s] = v;\n\t\treturn pa[s] = paint(par[0][s], l, v, ans);\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&n,&k,&m);\n\tfor(int i=0; i<k; i++){\n\t\tint s, e; scanf(\"%d %d\",&s,&e);\n\t\tmst.push_back({s, e, 0});\n\t}\n\tfor(int i=0; i<m;i++){\n\t\tint s, e, x;\n\t\tscanf(\"%d %d %d\",&s,&e,&x);\n\t\tmst.push_back({s, e, x});\n\t}\n\tdisj.init(n);\n\tsort(mst.begin(), mst.end());\n\tfor(auto &i : mst){\n\t\tif(disj.uni(i.s, i.e)){\n\t\t\tgph[i.s].push_back(pi(i.x, i.e));\n\t\t\tgph[i.e].push_back(pi(i.x, i.s));\n\t\t}\n\t\telse{\n\t\t\trepl.push_back(i);\n\t\t}\n\t}\n\tdfs(1, 0);\n\tfor(int i=1; i<19; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tpar[i][j] = par[i-1][par[i-1][j]];\n\t\t\tpa[j] = j;\n\t\t}\n\t}\n\tfor(auto &i : repl){\n\t\tint l = lca(i.s, i.e);\n\t\tpaint(i.s, l, i.x, ans);\n\t\tpaint(i.e, l, i.x, ans);\n\t}\n\tlint dap = 0;\n\tfor(int i=2; i<=n; i++){\n\t\tif(isquery[i]){\n\t\t\tif(ans[i] == 0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdap += ans[i];\n\t\t}\n\t}\n\tcout <<dap << endl;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "graphs", "trees"], "dificulty": "2600", "interactive": false}