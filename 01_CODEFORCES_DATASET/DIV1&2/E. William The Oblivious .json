{
    "link": "https://codeforces.com//contest/1609/problem/E",
    "problemId": "1205813",
    "problem_idx": "E",
    "shortId": "1609E",
    "contest_number": "1609",
    "problem_submissions": {
        "H": [
            137263072,
            140966657,
            137541381,
            137373776,
            137353707,
            137353217
        ],
        "G": [
            137246775,
            137257898,
            137258174,
            137261032,
            137258429,
            137256905,
            137250571,
            137257690,
            137251480,
            137263274,
            137259638,
            137276051,
            137269427,
            137261135,
            137260806,
            137259792,
            137262185,
            137263614,
            137264862,
            137254900,
            137261420,
            137264154
        ],
        "F": [
            137240106,
            137246731,
            137244466,
            137246785,
            137246316,
            137246745,
            137260178,
            137270360,
            137247766,
            137257633,
            137249504,
            137249777,
            137249032,
            137252722,
            137252015,
            137251624,
            137252333,
            137250283,
            137261839,
            137252294,
            137249612
        ],
        "E": [
            137234780,
            137235959,
            137233979,
            137232935,
            137235656,
            137237935,
            137233267,
            137237781,
            137236310,
            137235301,
            137237711,
            137241732,
            137237330,
            137241596,
            137235797,
            137236926,
            137239464,
            137239281,
            137241206,
            137238999
        ],
        "D": [
            137226570,
            137230215,
            137231182,
            137228712,
            137232181,
            137231416,
            137229857,
            137231314,
            137233347,
            137230846,
            137231581,
            137229849,
            137233415,
            137234328,
            137231105,
            137231235,
            137232699,
            137231119,
            137233860,
            137235117
        ],
        "C": [
            137224003,
            137226381,
            137228113,
            137226088,
            137228622,
            137227880,
            137227092,
            137227813,
            137229692,
            137227035,
            137228022,
            137226433,
            137228702,
            137230474,
            137231768,
            137227164,
            137229482,
            137228456,
            137229353,
            137230487
        ],
        "B": [
            137222196,
            137223090,
            137224802,
            137223100,
            137224371,
            137223720,
            137223346,
            137224383,
            137222999,
            137223539,
            137224162,
            137223482,
            137224120,
            137224040,
            137223954,
            137223074,
            137224144,
            137224291,
            137224533,
            137224451
        ],
        "A": [
            137221600,
            137221784,
            137221681,
            137221800,
            137221985,
            137221740,
            137221875,
            137222467,
            137221786,
            137221979,
            137222676,
            137221642,
            137222045,
            137222137,
            137226851,
            137224172,
            137221659,
            137222130,
            137222631,
            137222150
        ]
    },
    "name": "E. William The Oblivious ",
    "statement": "Before becoming a successful trader William got a university degree.\r\nDuring his education an interesting situation happened, after which\r\nWilliam started to listen to homework assignments much more attentively.\r\nWhat follows is a formal description of the homework assignment as\r\nWilliam heard it:You are given a string s of length n only consisting of\r\ncharacters \"\", \"\" and \"\". There are q queries of format (pos, c),\r\nmeaning replacing the element of string s at position pos with character\r\nc. After each query you must output the minimal number of characters in\r\nthe string, which have to be replaced, so that the string doesn’t\r\ncontain string \"\" as a . A valid replacement of a character is replacing\r\nit with \"\", \"\" or \"\".A string x is said to be a subsequence of string y\r\nif x can be obtained from y by deleting some characters without changing\r\nthe ordering of the remaining characters.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 28.11.2021 17:36:59       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = (int) 1e9;\n\nconst int CNT = 12;\n\nvector<vector<int>> to;\nvector<array<int, CNT>> init(3);\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    array<int, CNT> a;\n\n    void apply(int l, int r, char c) {\n      int id = (int) (c - 'a');\n      a = init[id];\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    fill(res.a.begin(), res.a.end(), inf);\n    for (int i = 0; i < CNT; i++) {\n      for (int j = 0; j < CNT; j++) {\n        if (to[i][j] != -1) {\n          res.a[to[i][j]] = min(res.a[to[i][j]], a.a[i] + b.a[j]);\n        }\n      }\n    }\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<string> fun = {\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"};\n  auto Build = [&](string s) {\n    vector<string> found;\n    for (string z : fun) {\n      int ptr = 0;\n      for (int i = 0; i < (int) s.size(); i++) {\n        if (ptr < (int) z.size() && z[ptr] == s[i]) {\n          ++ptr;\n        }\n      }\n      if (ptr == (int) z.size()) {\n        found.push_back(z);\n      }\n    }\n    return found;\n  };\n  map<vector<string>, string> mp;\n  for (int len = 1; len <= 9; len++) {\n    int p3 = 1;\n    for (int i = 0; i < len; i++) {\n      p3 *= 3;\n    }\n    for (int t = 0; t < p3; t++) {\n      string s = \"\";\n      int tmp = t;\n      for (int i = 0; i < len; i++) {\n        s += (char) (tmp % 3 + 'a');\n        tmp /= 3;\n      }\n      vector<string> found = Build(s);\n      if (find(found.begin(), found.end(), (string) \"abc\") != found.end()) {\n        continue;\n      }\n      mp[found] = s;\n    }\n  }\n  vector<pair<vector<string>, string>> all(mp.begin(), mp.end());\n  int cnt = (int) all.size();\n  assert(cnt == 12);\n  auto GetId = [&](vector<string> found) {\n    auto it = lower_bound(all.begin(), all.end(), make_pair(found, (string) \"\"));\n    if (it != all.end() && it->first == found) {\n      return (int) (it - all.begin());\n    }\n    return -1;\n  };\n  to.assign(cnt, vector<int>(cnt, -1));\n  for (int i = 0; i < cnt; i++) {\n    for (int j = 0; j < cnt; j++) {\n      string s = all[i].second + all[j].second;\n      auto found = Build(s);\n      to[i][j] = GetId(found);\n    }\n  }\n  vector<int> w(3);\n  w[0] = GetId(Build((string) \"a\"));\n  w[1] = GetId(Build((string) \"b\"));\n  w[2] = GetId(Build((string) \"c\"));\n  for (int it = 0; it < 3; it++) {\n    fill(init[it].begin(), init[it].end(), inf);\n    init[it][w[it]] = 0;\n    init[it][w[(it + 1) % 3]] = 1;\n    init[it][w[(it + 2) % 3]] = 1;\n  }\n  string s;\n  cin >> s;\n  vector<char> ss(n);\n  for (int i = 0; i < n; i++) {\n    ss[i] = s[i];\n  }\n  segtree st(ss);\n  while (q--) {\n    int pos;\n    char c;\n    cin >> pos >> c;\n    --pos;\n    st.modify(pos, pos, c);\n    auto nd = st.get(0, n - 1);\n    cout << *min_element(nd.a.begin(), nd.a.end()) << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dp",
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. William The Oblivious .json",
    "editorial_link": "https://codeforces.com//blog/entry/97350",
    "editorial": "To solve this problem we will use a segment tree. Letâs maintain the\r\nfollowing informaton for each segment: stores the minimal number of\r\ncharacters that have to be replaced to make the string only contain\r\nsubsequences equal to .Next letâs define what is. Let the first bit of\r\nthe mask correspond to subsequence , the second bit correspond to\r\nsubsequence , the third bit correspond to subsequence , the fourth bit\r\ncorrespond to subsequence , the fifth bit correspond to subsequence .\r\nThen contains those subsequences, which have a number corresponding to\r\nthe number of 1 bits in them.Letâs define the value as a resulting mask\r\nwhich contains the subsequences from both masks and the subsequences\r\nthat are created as a result of their merge.Then for a new node and for\r\nall masks we can define as the minimal among all values , where and are\r\nthe left and right child nodes of the in the segment tree and and are\r\nmasks for which .The final answer is the minimal among all .\r\n",
    "hint": []
}