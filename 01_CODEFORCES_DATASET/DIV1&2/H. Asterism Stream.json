{
    "link": "https://codeforces.com//contest/1864/problem/H",
    "problemId": "2181271",
    "problem_idx": "H",
    "shortId": "1864H",
    "contest_number": "1864",
    "problem_submissions": {
        "I": [
            220596748,
            220625703,
            220625365,
            220625093
        ],
        "H": [
            220568821,
            220567695,
            220569504,
            220765807,
            220735033,
            220733694,
            220582422,
            220590968,
            220584872,
            220585832,
            220586273,
            220588653,
            220869529,
            220592706,
            220587781,
            220596085,
            222139412,
            220596294
        ],
        "G": [
            220562227,
            220575493,
            220588511,
            220576272,
            220574639,
            220576772,
            220595506,
            220568659,
            220611309,
            221223033,
            220575904,
            220585515,
            220590419,
            220591092,
            220590354,
            220590686
        ],
        "F": [
            220551620,
            220555802,
            220557675,
            220718976,
            220558576,
            220553574,
            220558951,
            220567707,
            220555900,
            220612295,
            220564492,
            220564273,
            220565836,
            220560759,
            220571802,
            220564441,
            220571627,
            220556155,
            220556855,
            220560337,
            220568919,
            220567748
        ],
        "E": [
            220545674,
            220547229,
            220549551,
            220553761,
            220544098,
            220550014,
            220550285,
            220550294,
            220555536,
            220557391,
            220559164,
            220553118,
            220556990,
            220555427,
            220553548,
            220549618,
            220563369,
            220552727,
            220558630,
            220553863
        ],
        "D": [
            220537006,
            220537255,
            220535722,
            220536129,
            220534069,
            220542850,
            220539341,
            220538198,
            220541287,
            220542463,
            220545447,
            220548373,
            220544205,
            220540271,
            220536187,
            220541552,
            220541368,
            220545083,
            220544975
        ],
        "C": [
            220533606,
            220528455,
            220528101,
            220528155,
            220527489,
            220537748,
            220525134,
            220530359,
            220532079,
            220533694,
            220541070,
            220542060,
            220535618,
            220533106,
            220530771,
            220535184,
            220536493,
            220534865,
            220537384
        ],
        "B": [
            220524699,
            220524727,
            220525716,
            220524082,
            220524572,
            220524039,
            220522756,
            220522640,
            220528173,
            220525137,
            220528062,
            220531552,
            220524275,
            220526451,
            220524531,
            220529349,
            220526226,
            220525961,
            220525118
        ],
        "A": [
            220521618,
            220521580,
            220521747,
            220521485,
            220521753,
            220521570,
            220521442,
            220521465,
            220524365,
            220521707,
            220524695,
            220522808,
            220521703,
            220522789,
            220521679,
            220521789,
            220521663,
            220522116,
            220521966
        ]
    },
    "name": "H. Asterism Stream",
    "statement": "Bogocubic is playing a game with amenotiomoi. First, Bogocubic fixed an\r\ninteger n, and then he gave amenotiomoi an integer x which is initially\r\nequal to 1.In one move amenotiomoi performs of the following operations\r\nwith the same probability: increase x by 1; multiply x by 2. Bogocubic\r\nwants to find the expected number of moves amenotiomoi has to do to make\r\nx greater than or equal to n. Help him find this number modulo 998\r\n,244\r\n,353.Formally, let M = 998\r\n,244\r\n,353. It can be shown that the answer can be expressed as an irreducible\r\nfraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, output such an integer y that 0\r\nle y < M and y\r\ncdot q\r\nequiv p\r\npmod{M}.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst ll o2=(mod+1)/2;\nconst int d=64;\n//~ const int d=5;\n\n//~ map<ll,ll> mapa;\n\n//~ ll solve(ll n)\n//~ {\n\t//~ if (n==1)\n\t\t//~ return 0;\n\t//~ if (mapa.count(n))\n\t\t//~ return mapa[n];\n\t//~ ll ret=solve(n-1)+solve((n+1)/2);\n\t//~ ret*=o2;\n\t//~ ret++;\n\t//~ ret%=mod;\n\t//~ return mapa[n]=ret;\n//~ }\n\nstruct mac\n{\n\tll w[d][d];\n\tmac()\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tw[i][j]=0;\n\t}\n\tmac(ll v)\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tw[i][j]=(i==j)*v;\n\t}\n\tvoid wypisz()\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tdebug() << range(w[i], w[i]+d);\n\t\tdebug();\n\t}\n};\n\nmac operator *(mac a, mac b)\n{\n\tmac ret=mac();\n\tfor (int i=0; i<d; i++)\n\t\tfor (int j=0; j<d; j++)\n\t\t\tfor (int l=0; l<d; l++)\n\t\t\t\tret.w[i][l]=(ret.w[i][l]+a.w[i][j]*b.w[j][l])%mod;\n\treturn ret;\n}\n\nvector<mac> kolejne;\nvector<mac> pref;\n\nll dpn[nax];\nll dps[nax];\n\nvoid przyloz(mac &v)\n{\n\tfor (int i=0; i<d; i++)\n\t{\n\t\tdps[i]=dpn[i];\n\t\tdpn[i]=0;\n\t}\n\tfor (int i=0; i<d; i++)\n\t\tfor (int j=0; j<d; j++)\n\t\t\tdpn[j]=(dpn[j]+dps[i]*v.w[i][j])%mod;\n}\n\nvoid zrob(ll n)\n{\n\tif (!n)\n\t\treturn;\n\tint kt=0;\n\tll x=1;\n\twhile(2*x<=n)\n\t{\n\t\tkt++;\n\t\tx*=2;\n\t}\n\tif (kt)\n\t\tprzyloz(pref[kt-1]);\n\tprzyloz(kolejne[kt]);\n\tzrob(n-x);\n}\n\nvoid test()\n{\n\tll n;\n\tscanf(\"%lld\", &n);\n\tfor (int i=0; i<d; i++)\n\t\tdpn[i]=0;\n\tdpn[d-1]=1;\n\tzrob(n-1);\n\tprintf(\"%lld\\n\", dpn[0]);\n\t//~ mac pus=mac(1);\n\t//~ for (ll i=1; i<n; i++)\n\t//~ {\n\t\t//~ int x=__builtin_ctz(i);\n\t\t//~ pus=pus*kolejne[x];\n\t//~ }\n\t//~ printf(\"%lld\\n\", pus.w[d-1][0]);\n}\n\nint main()\n{\n\tfor (int i=0; i+1<d; i++)\n\t{\n\t\tmac tu=mac(1);\n\t\ttu.w[i][i]=o2;\n\t\ttu.w[i+1][i]=o2;\n\t\ttu.w[d-1][i]=1;\n\t\tif (i)\n\t\t\ttu=tu*kolejne.back();\n\t\tkolejne.push_back(tu);\n\t\t//~ debug() << imie(i);\n\t\t//~ kolejne[i].wypisz();\n\t}\n\tfor (int i=0; i+1<d; i++)\n\t{\n\t\tif (!i)\n\t\t{\n\t\t\tpref.push_back(kolejne[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmac tu=(pref.back()*kolejne[i])*pref.back();\n\t\t\tpref.push_back(tu);\n\t\t}\n\t}\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "matrices"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Asterism Stream.json",
    "editorial_link": "https://codeforces.com//blog/entry/119772",
    "editorial": "Tutorial Here is a basic dp solution.Before that let . At the same time,\nbecause a special geometric sequence will be frequently used next, it is\ndefined as .Let be the expected number of moves needed if we start with\n. Obviously, there is the following formula: Itâs easy to see that for\nthe interval value of is .If for an interval , it can already be\nrepresented by the sum of several , then it can be represented by a\nsmall number of new for all , where First there is . So, can be\nrepresented as .By analogy, one can get by substitution, it can be shown\nas Because of the interval where is already known, the value of can be\ncalculated quickly. So, the first term of can be represented as below:\nThen the last term of , is sum of an ordinary geometric sequence. So,\nafter applying the formula it can represented as .For the second term ,\nit has been assumed that is , so split it into the following form (the\nderivation process depends on ): Because of the obvious combination law\n, the number of its geometric series is linear with the number of\nrecursions.For , which can be represented as , so this recursive rule\ncan always be used, Until the is obtained, to get the result.The\ncomplexity varies depending on the implementation or .\n",
    "hint": []
}