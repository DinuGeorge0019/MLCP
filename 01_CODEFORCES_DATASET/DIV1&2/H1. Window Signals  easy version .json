{
    "link": "https://codeforces.com//contest/1782/problem/H1",
    "problemId": "1738314",
    "problem_idx": "H1",
    "shortId": "1782H1",
    "contest_number": "1782",
    "problem_submissions": {
        "G": [
            189352903,
            189354160,
            189342529,
            189347964,
            189346429,
            189415258,
            189347317,
            189738607,
            189347232,
            189347696,
            189403021,
            189438204,
            189354810,
            189338967,
            189344949
        ],
        "H1": [
            189341567,
            189339761,
            189349634,
            189355935,
            189355012,
            189341367,
            189348685,
            189366896,
            189384259,
            189345985,
            189353203,
            189354256,
            189356712
        ],
        "F": [
            189325657,
            189363621,
            189331442,
            189327188,
            189334558,
            189331825,
            189332228,
            189332897,
            189335481,
            189328585,
            189328764,
            189334100,
            189338796,
            189342861,
            189333278,
            189345646,
            189348301,
            189336716,
            189329952,
            189336813
        ],
        "E": [
            189322203,
            189324476,
            189336013,
            189324984,
            189327367,
            189324941,
            189325259,
            189324742,
            189325043,
            189324750,
            189330839,
            189330033,
            189340117,
            189340110,
            189356727,
            189364874,
            189338107,
            189329882
        ],
        "D": [
            189315553,
            189316553,
            189320757,
            189315522,
            189321240,
            189315774,
            189315356,
            189317449,
            189316444,
            189318717,
            189318855,
            189319485,
            189321217,
            189322258,
            189322561,
            189316855,
            189317394,
            189318806,
            189319611
        ],
        "C": [
            189312571,
            189313515,
            189317007,
            189313044,
            189315685,
            189312570,
            189312443,
            189313938,
            189314521,
            189313780,
            189316398,
            189315035,
            189318312,
            189317410,
            189321818,
            189314789,
            189315093,
            189314367
        ],
        "B": [
            189309405,
            189309603,
            189311019,
            189308821,
            189310918,
            189309246,
            189308942,
            189310194,
            189308126,
            189309056,
            189311263,
            189310085,
            189312839,
            189309172,
            189329674,
            189309853,
            189310568,
            189309470
        ],
        "A": [
            189307515,
            189306919,
            189307198,
            189307124,
            189307391,
            189307301,
            189307111,
            189307534,
            189306943,
            189307353,
            189307056,
            189307424,
            189308244,
            189319051,
            189308061,
            189307499,
            189307060,
            189307053
        ],
        "H2": [
            189361277,
            189352155,
            189886586,
            189749780,
            189366917,
            189362146
        ]
    },
    "name": "H1. Window Signals  easy version ",
    "statement": "A house at the sea has h floors, all of the same height. The side of the\r\nhouse facing the sea has w windows at equal distances from each other on\r\nevery floor. Thus, the windows are positioned in cells of a rectangular\r\ngrid of size h\r\ntimes w.In every window, the light can be turned either on or off,\r\nexcept for the given k (at most 2) windows. In these k windows the light\r\ncan not be turned on, because it is broken.In the dark, we can send a\r\nsignal to a ship at sea using a configuration of lights turned on and\r\noff. However, the ship can not see the position of the lights with\r\nrespect to the house. Thus, if one configuration of windows with lights\r\non can be transformed into another using parallel translation, these\r\nconfigurations are considered equal. Note that only parallel translation\r\nis allowed, but neither rotations nor flips are. Moreover, a\r\nconfiguration without any light at all is not considered valid.Find how\r\nmany different signals the ship can receive and print this number modulo\r\n998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1607, mod = 998244353;\nint n, m, xn, xm, k, r[N], c[N], pw[N];\nbool vis[N][N];\nint msk[N];\nint ok[N];\nvi e[N];\ninline int getid(pair < int, int > o) {\n\treturn (o.first - 1) * xm + o.second;\n}\nvi T;\nbool use[N];\nvoid getlen(int u) {\n\tif(use[u]) return ;\n\tuse[u] = true;\n\tT.emplace_back(u);\n\tfor(auto v : e[u]) \n\t\tgetlen(v);\n}\nint dp[1 << 4];\nint ndp[1 << 4];\nvoid clear() {\n\tme(dp, 0);\n\tdp[0] = 1;\n}\nvoid push(vi msk, vi cnt) {\n\t\n\tme(ndp, 0);\n\tL(t, 0, sz(msk) - 1) {\n\t\tint v = msk[t];\n\t\tint c = cnt[t];\n\t\tL(i, 0, 15)\n\t\t\t(ndp[i | v] += (ll) c * dp[i] % mod) %= mod; \n\t}\n\tswap(dp, ndp);\n}\nint F[2][16], G[2][16];\nvoid Main() {\n\tcin >> n >> m >> k;\n\tpw[0] = 1;\n\tL(i, 1, n * m) pw[i] = (ll) pw[i - 1] * 2 % mod; \n\tL(i, 1, k) {\n\t\tcin >> r[i] >> c[i]; \n\t}\n\t\n\tint ns = 0;\n\tfor(xn = 1; xn <= n; ++xn) {\n\t\tfor(xm = 1; xm <= m; ++xm) {\n\t\t\tme(use, 0);\n\t\t\tL(i, 1, xn) \n\t\t\t\tL(j, 1, xm) \n\t\t\t\t\tvis[i][j] = true;\n\t\t\tL(i, 1, xn) {\n\t\t\t\tL(j, 1, xm) {\n\t\t\t\t\tint Msk = 0;\n\t\t\t\t\tif(i == 1) {\n\t\t\t\t\t\tMsk += 1;\n\t\t\t\t\t} \n\t\t\t\t\tif(i == xn) {\n\t\t\t\t\t\tMsk += 2;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == 1) {\n\t\t\t\t\t\tMsk += 4;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == xm) {\n\t\t\t\t\t\tMsk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tmsk[(i - 1) * xm + j] = Msk;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tclear();\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tpush(vi{0, msk[i]}, vi{1, 1});\n\t\t\t(ns += dp[15]) %= mod;\n\t\t\t\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tok[i] = true, e[i].clear();\n\t\t\tbool okay = false;\n\t\t\tL(lx, 1, n - xn + 1) if(!okay) {\n\t\t\t\tL(ly, 1, m - xm + 1) if(!okay) {\n\t\t\t\t\tint rx = lx + xn - 1;\n\t\t\t\t\tint ry = ly + xm - 1;\n\t\t\t\t\tvector < pair < int, int > > vc; \n\t\t\t\t\tL(i, 1, k) {\n\t\t\t\t\t\tif(lx <= r[i] && r[i] <= rx) {\n\t\t\t\t\t\t\tif(ly <= c[i] && c[i] <= ry) {\n\t\t\t\t\t\t\t\tvc.emplace_back(r[i] - lx + 1, c[i] - ly + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!sz(vc)) {\n\t\t\t\t\t\tokay = true;\n\t\t\t\t\t} else if(sz(vc) == 1) {\n\t\t\t\t\t\tok[getid(vc[0])] = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint u = getid(vc[0]);\n\t\t\t\t\t\tint v = getid(vc[1]);\n\t\t\t\t\t\te[u].emplace_back(v);\n\t\t\t\t\t\te[v].emplace_back(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(okay) continue;\n\t\t\t\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tif(sz(e[i]) > 2) {\n\t\t\t\t\tfor(auto v : e[i]) cout << v << ' ';\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\n\t\t\tclear();\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tif(!use[i]) {\n//\t\t\t\t\tif(sz(e[i]) == 1) {\n//\t\t\t\t\t\tpush(vi{0, msk[i]}, vi{ok[i], 1});\n//\t\t\t\t\t\tcontinue; \n//\t\t\t\t\t}\n\t\t\t\t\tT.clear();\n\t\t\t\t\tgetlen(i);\n\t\t\t\t\t\t\n\t\t\t\t\tme(F, 0);\n\t\t\t\t\tF[1][0] = 1;\n\t\t\t\t\tfor(auto u : T) {\n\t\t\t\t\t\tme(G, 0);\n\t\t\t\t\t\tL(x, 0, 1) {\n\t\t\t\t\t\t\tL(y, 0, 1) if(x || y) {\n\t\t\t\t\t\t\t\tif(!ok[u] && !y) continue;\n\t\t\t\t\t\t\t\tint t = msk[u];\n\t\t\t\t\t\t\t\tif(!y) t = 0;\n\t\t\t\t\t\t\t\tL(i, 0, 15) (G[y][i | t] += F[x][i]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(F, G);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvi A, B;\n\t\t\t\t\tL(i, 0, 15) {\n\t\t\t\t\t\tint s = (F[0][i] + F[1][i]) % mod; \n\t\t\t\t\t\tif(s) A.emplace_back(i), B.emplace_back(s);\n\t\t\t\t\t}\n\t\t\t\t\tpush(A, B);\n//\t\t\t\t\tcout << ok[i] << ' ' << msk[i] << '\\n';\n//\t\t\t\t\tL(i, 0, sz(A) - 1) cout << A[i] << \" : \" << B[i] << '\\n';\n//\t\t\t\t\tcout << '\\n';\n\t\t\t\t}\n\t\t\t(ns += mod - dp[15]) %= mod;\n\t\t}\n\t}\n\tcout << ns << '\\n';\n} \nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} \n/*\n1\n40 40 2\n10 11\n20 23\n\n1\n40 40 2\n10 11\n11 12\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "math"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H1. Window Signals  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/111783",
    "editorial": "Let\u00e2\u0080\u0099s iterate over the dimensions of the bounding box of the image of\r\nwindows with lights on, (), count images with such bounding box, and sum\r\nall these values up.An image has a bounding box of size exactly if and\r\nonly if: it fits inside an rectangle; it has a light on each of its four\r\nborders. To account for the second condition, we can use\r\ninclusion-exclusion principle. This way, we will have an \"it does not\r\nhave a light on some of its borders\" condition instead, at the cost of\r\nan extra time factor. We will disregard this condition in the rest of\r\nthis tutorial.There are possible images fitting in an rectangles. How\r\nmany of them are impossible to show because of broken lights? Let\u00e2\u0080\u0099s find\r\nthis number and subtract it.Consider all possible ways to place a\r\nrectangle of size on the given grid: If there are no broken lights\r\ninside, any image of size is possible to show, so we don\u00e2\u0080\u0099t need to\r\nsubtract anything for this size at all. If there is broken light inside,\r\nits relative position in the rectangle must be turned on (for an image\r\nto be impossible to show). If there are broken lights inside, find their\r\nrelative positions in the rectangle. For an image to be impossible to\r\nshow, at least one of the two positions must be turned on. Unless a\r\nplacement with no broken lights exists, we have some cells in the\r\nrectangle where the light must be turned on let\u00e2\u0080\u0099s call the set of these\r\ncells , and some pairs of cells where at least one light must be turned\r\non let\u00e2\u0080\u0099s call the set of these pairs .If a pair from contains a cell\r\nfrom , this pair can be removed from . Once we do that, note that the\r\npairs from form several chains that happens because the coordinate-wise\r\ndistance between the cells in each pair is equal to the distance between\r\nthe broken lights, which is .If we have a chain of length , it can be\r\nseen that there are ways to turn lights on so that every pair of\r\nneighboring cells has at least one light, where are Fibonacci\r\nnumbers.Thus, the number to subtract is the product of: , where is the\r\nnumber of cells not included in and ; over all chains formed by , where\r\nis the length of a chain. Every subgrid size is processed in time, and\r\nthere are different sizes, thus, the overall time complexity is .It is\r\npossible to optimize the constant factor of this solution to pass the\r\nhard version too. However, a solution of time complexity exists as well.\r\nHere is a sketch of it: Instead of fixing both dimensions of the lights\r\nimage, and , let\u00e2\u0080\u0099s only fix . Use inclusion-exclusion like described at\r\nthe beginning of this tutorial; however, only use it for the top, left,\r\nand right borders. We will not use it for the bottom border, since we\r\nare not fixing the height of the image. Go through all top-left corners\r\nof the lights image in lexicographic order (). For each top-left corner,\r\ncount how many images of width can be shown using this top-left corner,\r\nwhich can not be shown using any previous top-left corner. Similarly to\r\nthe previous solution, consider cases of , , and broken lights inside\r\nthe current subgrid. Note, however, that we are not fixing the height of\r\nthe subgrid, so just assume that it stretches all the way down to the\r\nbottom border of the whole grid. Maintain the set of cells using an\r\narray, and maintain the set of pairs using linked lists. Once a cell\r\njoins set , remove all pairs that touch it from set . Once a pair joins\r\nset , if neither of its ends belongs to , merge two corresponding linked\r\nlists. Maintain a variable denoting the product of over all chains\r\nformed by . Once any split or merge happens to the lists, update this\r\nvariable using multiplications/divisions. Whenever (the row number of\r\nthe top-left corner) increases by , the maximum available height of the\r\nlights image decreases by . Thus, we have to \"remove\" the cells in the\r\ncurrent bottom row: that is, for any future image, we won\u00e2\u0080\u0099t be able to\r\nlight up those cells. If any such cell belongs to , just stop: we won\u00e2\u0080\u0099t\r\nget any new images. Otherwise, if such a cell belongs to a pair in , add\r\nthe second end of this pair to . For fixed width and for each top-left\r\ncorner , we need to spend time. Moreover, for fixed width , once\r\nincreases (which happens times), we need to spend time to process cell\r\nremovals. Hence, the time complexity of both parts is .\r\n"
}