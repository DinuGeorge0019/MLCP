{"link": "https://codeforces.com//contest/724/problem/G", "problemId": "74856", "problem_idx": "G", "shortId": "724G", "contest_number": "724", "problem_submissions": {"G": [21292263, 21289389, 21296363, 21288425, 21294631, 21287775, 21293574, 21292770, 21291944, 21288934, 21292172, 21288247, 21292559, 21295809, 21290880, 21290578, 21290415, 21293943], "E": [21288925, 21292133, 21297352, 21291033, 21288200, 23659645, 21290576, 21290313, 21292937, 21296159, 21294663, 21290237, 21296769, 21292864, 21297544, 23608572], "F": [21288190, 21295097, 21291428, 21408768, 21292926, 21298468, 145553208, 21294689], "D": [21285401, 21285608, 21286235, 21283645, 21284412, 21288117, 21285995, 21287478, 21286772, 21286376, 21289028, 21285265, 21288845, 21286726, 21290761, 21285673, 21284100, 21286467, 21288075], "B": [21284134, 21280714, 21282752, 21281462, 21280744, 21282751, 21280902, 21282004, 21281773, 21281431, 21281779, 21284722, 21286664, 21280972, 21281353, 21282957, 21282648], "C": [21283255, 21284495, 21288232, 21285743, 21285969, 21285870, 21284787, 21286083, 21285861, 21284725, 21286899, 21284034, 21287013, 21285582, 21297034, 21283106, 21286310, 21285066, 21286458], "A": [21280305, 21279735, 21280413, 21279914, 21280000, 21280810, 21279870, 21279953, 21279966, 21279817, 21280008, 21279884, 21281495, 21279783, 21281061, 21279908, 21279971, 21280674, 21280506]}, "name": "G. Xor-matic Number of the Graph", "statement": "You are given an undirected graph, constisting of vertices and edges.\r\nEach edge of the graph has some non-negative integer written on it.Let\u2019s\r\ncall a triple , if and there is a path (, i.e. it can visit the same\r\nvertices and edges multiple times) between vertices and such that xor of\r\nall numbers written on the edges of this path is equal to . It\u2019s not\r\nhard to prove that there are finite number of such triples.Calculate the\r\nsum over modulo of the values of over all triples.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nvector<pair<int,ll> > e[N];\nint ret,vis[N],n,m,u,v;\nll dep[N],w,pw[210];\nstruct guass {\n\tint cnt[66][2],rk;\n\tll cyc[66],s;\n\tvoid init() {\n\t\trep(i,0,61) cyc[i]=cnt[i][0]=cnt[i][1]=0;\n\t\trk=0; s=0;\n\t}\n\tvoid dda(ll w) {\n\t\trep(i,0,61) cnt[i][(w>>i)&1]++;\n\t}\n\tvoid add(ll w) {\n\t\ts|=w;\n\t\tper(i,0,61) {\n\t\t\tif (w&(1ll<<i)) {\n\t\t\t\tif (cyc[i]==0) {\n\t\t\t\t\tcyc[i]=w,rk++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw=min(w,w^cyc[i]);\n\t\t}\n\t}\n\tvoid count() {\n\t\trep(i,0,61) {\n\t\t\tif (s&(1ll<<i)) {\n\t\t\t\tret=(ret+(ll)(cnt[i][0]+cnt[i][1])*(cnt[i][0]+cnt[i][1]-1)/2%mod*pw[i+rk-1])%mod;\n\t\t\t} else {\n\t\t\t\tret=(ret+(ll)cnt[i][0]*cnt[i][1]%mod*pw[i+rk])%mod;\n\t\t\t}\n\t\t}\n\t}\n}base;\nvoid dfs(int u,int f,ll w) {\n\tvis[u]=1; dep[u]=w;\n\tbase.dda(w);\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f) continue;\n\t\tif (vis[v]) {\n\t\t\tbase.add(dep[u]^dep[v]^p.se);\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u,w^p.se);\n\t}\n}\nint main() {\n\tpw[0]=1;\n\trep(i,1,201) pw[i]=pw[i-1]*2%mod;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%lld\",&u,&v,&w);\n\t\te[u].pb(mp(v,w));\n\t\te[v].pb(mp(u,w));\n\t}\n\trep(i,1,n+1) if (!vis[i]) {\n\t\tbase.init();\n\t\tdfs(i,0,0);\n\t\tbase.count();\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "graphs", "math", "number theory", "trees"], "dificulty": "2600", "interactive": false}