{
    "link": "https://codeforces.com//contest/724/problem/G",
    "problemId": "74856",
    "problem_idx": "G",
    "shortId": "724G",
    "contest_number": "724",
    "problem_submissions": {
        "G": [
            21292263,
            21289389,
            21296363,
            21288425,
            21294631,
            21287775,
            21293574,
            21292770,
            21291944,
            21288934,
            21292172,
            21288247,
            21292559,
            21295809,
            21290880,
            21290578,
            21290415,
            21293943
        ],
        "E": [
            21288925,
            21292133,
            21297352,
            21291033,
            21288200,
            23659645,
            21290576,
            21290313,
            21292937,
            21296159,
            21294663,
            21290237,
            21296769,
            21292864,
            21297544,
            23608572
        ],
        "F": [
            21288190,
            21295097,
            21291428,
            21408768,
            21292926,
            21298468,
            145553208,
            21294689
        ],
        "D": [
            21285401,
            21285608,
            21286235,
            21283645,
            21284412,
            21288117,
            21285995,
            21287478,
            21286772,
            21286376,
            21289028,
            21285265,
            21288845,
            21286726,
            21290761,
            21285673,
            21284100,
            21286467,
            21288075
        ],
        "B": [
            21284134,
            21280714,
            21282752,
            21281462,
            21280744,
            21282751,
            21280902,
            21282004,
            21281773,
            21281431,
            21281779,
            21284722,
            21286664,
            21280972,
            21281353,
            21282957,
            21282648
        ],
        "C": [
            21283255,
            21284495,
            21288232,
            21285743,
            21285969,
            21285870,
            21284787,
            21286083,
            21285861,
            21284725,
            21286899,
            21284034,
            21287013,
            21285582,
            21297034,
            21283106,
            21286310,
            21285066,
            21286458
        ],
        "A": [
            21280305,
            21279735,
            21280413,
            21279914,
            21280000,
            21280810,
            21279870,
            21279953,
            21279966,
            21279817,
            21280008,
            21279884,
            21281495,
            21279783,
            21281061,
            21279908,
            21279971,
            21280674,
            21280506
        ]
    },
    "name": "G. Xor-matic Number of the Graph",
    "statement": "You are given an undirected graph, constisting of vertices and edges.\r\nEach edge of the graph has some non-negative integer written on it.Let\u2019s\r\ncall a triple , if and there is a path (, i.e. it can visit the same\r\nvertices and edges multiple times) between vertices and such that xor of\r\nall numbers written on the edges of this path is equal to . It\u2019s not\r\nhard to prove that there are finite number of such triples.Calculate the\r\nsum over modulo of the values of over all triples.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nvector<pair<int,ll> > e[N];\nint ret,vis[N],n,m,u,v;\nll dep[N],w,pw[210];\nstruct guass {\n\tint cnt[66][2],rk;\n\tll cyc[66],s;\n\tvoid init() {\n\t\trep(i,0,61) cyc[i]=cnt[i][0]=cnt[i][1]=0;\n\t\trk=0; s=0;\n\t}\n\tvoid dda(ll w) {\n\t\trep(i,0,61) cnt[i][(w>>i)&1]++;\n\t}\n\tvoid add(ll w) {\n\t\ts|=w;\n\t\tper(i,0,61) {\n\t\t\tif (w&(1ll<<i)) {\n\t\t\t\tif (cyc[i]==0) {\n\t\t\t\t\tcyc[i]=w,rk++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw=min(w,w^cyc[i]);\n\t\t}\n\t}\n\tvoid count() {\n\t\trep(i,0,61) {\n\t\t\tif (s&(1ll<<i)) {\n\t\t\t\tret=(ret+(ll)(cnt[i][0]+cnt[i][1])*(cnt[i][0]+cnt[i][1]-1)/2%mod*pw[i+rk-1])%mod;\n\t\t\t} else {\n\t\t\t\tret=(ret+(ll)cnt[i][0]*cnt[i][1]%mod*pw[i+rk])%mod;\n\t\t\t}\n\t\t}\n\t}\n}base;\nvoid dfs(int u,int f,ll w) {\n\tvis[u]=1; dep[u]=w;\n\tbase.dda(w);\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f) continue;\n\t\tif (vis[v]) {\n\t\t\tbase.add(dep[u]^dep[v]^p.se);\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v,u,w^p.se);\n\t}\n}\nint main() {\n\tpw[0]=1;\n\trep(i,1,201) pw[i]=pw[i-1]*2%mod;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%lld\",&u,&v,&w);\n\t\te[u].pb(mp(v,w));\n\t\te[v].pb(mp(u,w));\n\t}\n\trep(i,1,n+1) if (!vis[i]) {\n\t\tbase.init();\n\t\tdfs(i,0,0);\n\t\tbase.count();\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "graphs",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Xor-matic Number of the Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/47644",
    "editorial": "Without loss of generality, let\u00e2\u0080\u0099s assume that the graph is connected. If\r\nnot, we will calculate the answer for each connected component and then\r\nsum them up.Let\u00e2\u0080\u0099s hoose two arbitrary vertices and such that and try to\r\nfind all the interesting triples of the form . Let\u00e2\u0080\u0099s find any path ,\r\nconnecting these two vertices and calculate the xor of the numbers\r\nwritten on the edges of the path. Let\u00e2\u0080\u0099s denote the obtained xor as .Then\r\ntake an arbitrary interesting triple and any path , with the xor of the\r\nnumbers on it equals to . Consider the cycle of the following form:\r\nlet\u00e2\u0080\u0099s go through the first path , and then through the reversed\r\ndirection of the second path . Thus, we will get a cycle containing the\r\nvertex , with the xor of the numbers on it equals to .On the other hand,\r\nwe can take any cycle which starts and ends in the vertex , with the xor\r\nof the numbers on it equals to , and insert it before the path . Thus,\r\nwe will get the path , with the xor of the numbers on it equals to ,\r\ni.e. we will get an interesting triple .Note that in the same manner we\r\ncan add cycle, that doesn\u00e2\u0080\u0099t pass through the vertex . To do this, we can\r\nfind any path from the vertex to some of the vertices of the cycle, then\r\ngo through the cycle itself, and then add the edges of same path in\r\nreversed order. As a result, all the edges of this path will be included\r\nin the resulting path twice and will not affect the resulting xor.From\r\nthis we get the following idea: for a fixed pair of vertices, we can\r\nfind some path between them, and then add different cycles to it to\r\nobtain all interesting triples.Basis of the cycle space of the graph can\r\nbe obtained as follows: we find some spanning tree, and then for each\r\nedge, which is not included in that tree, add the cycle containing this\r\nedge and the path in the tree connecting its endpoints to the basis. For\r\neach cycle of the basis we will find xor of the numbers written in its\r\nedges.Now, let\u00e2\u0080\u0099s move from the operation of taking xor of numbers to the\r\noperations with vectors. To do this, we can represent all the numbers in\r\nthe graph in the form of vectors of length , where -th element of the\r\nvector will be equal to the value of the -th bit in this number. Then\r\ntaking xor of two numbers will be reduced to the addition of two vectors\r\nover the modulo . As a result, we can move from cycle space of the graph\r\nto the space .A linear combination of cycles of the graph, gives us a\r\nlinear combination of vectors corresponding to xor of the numbers on the\r\nedges of the cycles. The set of linear combinations of the vectors form\r\na subspace of . We can find the basis of this subspace using Gaussian\r\nelimination.Let\u00e2\u0080\u0099s denote the dimension of the basis as . Then, for every\r\npair of vertices and , the amount of interest triples for these vertices\r\nis equal to , and all values of the parameter for these triples can be\r\nobtained by adding the vector corresponding to an arbitrary path between\r\nthese vertices to the described subspace.Let\u00e2\u0080\u0099s choose a pair of vertices\r\nand and some bit and count how many times the value of will appear in\r\nthe resulting sum. Let\u00e2\u0080\u0099s assume that the value of the -th bit on the\r\npath between the chosen vertices is equal to . If -th bit is equal to\r\none for at least one vector of the basis, then this bit will be equal to\r\none in the triples. Otherwise, -th bit in all the triples will be equal\r\nto .Let\u00e2\u0080\u0099s start the depth first search from some vertex fixed vertex ,\r\nand find a paths to each vertex of the graph. For each of this paths we\r\ncalculate the value of xor of the numbers on them. For each bit let\u00e2\u0080\u0099s\r\ncount how many times it was equal to zero and one on these paths (denote\r\nthis numbers and ).Then, for a fixed bit , for exactly pairs of vertices\r\nit will be equal to one on the path connecting this vertices, and for\r\npairs it will be zero.Thus, if the -th bit is equal to one in at least\r\none vector from the basis, we should add to the answer. In the other\r\ncase, if bits is equal to zero for all vectors from the basis, we should\r\nadd to the answer.The resulting complexity of this solution is .\r\n"
}