{
    "link": "https://codeforces.com//contest/2002/problem/F2",
    "problemId": "2809244",
    "problem_idx": "F2",
    "shortId": "2002F2",
    "contest_number": "2002",
    "problem_submissions": {
        "H": [
            275883821,
            276030000,
            276029533,
            276718944,
            276718931,
            276716412,
            276716121,
            276379907
        ],
        "G": [
            275814532,
            275831532,
            275862936,
            275862868,
            275857045,
            275856914,
            275852957,
            275835244,
            275830497,
            275836895,
            275844798,
            275836685,
            275839620,
            275876408,
            275835680,
            276384839,
            275855186,
            275854807,
            275854377,
            275854233,
            275853273,
            275853001,
            277160193,
            275873413
        ],
        "F2": [
            275803261,
            275805293,
            275815511,
            275803726,
            275821855,
            275826602,
            275804715,
            275817099,
            275812698,
            275821433,
            275820135,
            275822519,
            275814615,
            275832819,
            275821881,
            275820944,
            275827250
        ],
        "F1": [
            275803106,
            275797405,
            275810054,
            275805934,
            275822144,
            275821908,
            275808780,
            275842679,
            275842498,
            275804501,
            275809897,
            275810999,
            275804801,
            275820307,
            275807320,
            275814303,
            275818257,
            275821104,
            275812786,
            275819730
        ],
        "E": [
            275776266,
            275785744,
            275852219,
            275788914,
            275771707,
            275802566,
            275795962,
            275769983,
            275789286,
            275807515,
            275787919,
            275785680,
            275785359,
            275786354,
            275779961,
            275794439,
            275802251,
            275789750,
            275800998,
            275803752,
            275804830
        ],
        "D2": [
            275767991,
            275777830,
            275771186,
            275817652,
            275793116,
            275788319,
            275778566,
            275781543,
            275797706,
            275776037,
            275778290,
            275777713,
            275779770,
            275786761,
            275779192,
            275790952,
            275773357,
            275786731,
            275789591,
            275775563
        ],
        "D1": [
            275767248,
            275777327,
            275771493,
            275817851,
            275793580,
            275790111,
            275778728,
            275771118,
            275797900,
            275776414,
            275778256,
            275777934,
            275780036,
            275787162,
            275779917,
            275791115,
            275772837,
            275787063,
            275789991,
            275776578
        ],
        "C": [
            275759851,
            275761703,
            275759373,
            275759241,
            275760994,
            275777407,
            275759928,
            275758928,
            275788566,
            275759503,
            275761991,
            275762069,
            275758442,
            275761405,
            275763148,
            275760323,
            275761934,
            275768403,
            275764562,
            275765401
        ],
        "B": [
            275757139,
            275757734,
            275756638,
            275756387,
            275757424,
            275758576,
            275756620,
            275756121,
            275770304,
            275762131,
            275757965,
            275758270,
            275756051,
            275757393,
            275759268,
            275756663,
            275757687,
            275761514,
            275758840,
            275756832
        ],
        "A": [
            275755167,
            275755315,
            275754910,
            275755027,
            275755132,
            275755590,
            275754949,
            275754911,
            275767431,
            275754975,
            275755752,
            275755110,
            275754896,
            275755382,
            275755090,
            275755155,
            275754903,
            275755222,
            275756059,
            275754981
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132569",
    "editorial": "We generalize the solution in F1.\nLet be the largest prime and be the largest prime . The problem is that\nthere might be for some , thus invalidating our previous analysis.To\nsolve this, we simply choose to be the largest integer such that and for\nall . An asymptotic analysis of this solution is as follows:As the\nlength of is , and each of these integers have at most prime divisors of\nmagnitude, which means that if we only restrict to primes, we will have\nto skip at most primes to find the largest . As the density of primes is\n, the asymptotic of will be , our actual (which is not restricted to\nprimes) will not be worse than this. Thus, our total area will be ,\ntimes the gcd complexity gives us an solution. However, the actual area\nis much lower than this.Under the constraints of the problem, when\nforcing to take primes, the maximum area is , and the sum of the largest\nareas is . The actual solution will not be worse than this.Because we\nonly need to check whether , the complexity can actually be optimized to\nwith some sieves. Namely, iterating over prime divisors of and and\nmarking all cells which has as its common divisor.This solution is by\nfar from optimal. We invite you to continue optimizing your solutions\nand try to minimize the number of cells visited in each query :)Time\ncomplexity: Select solutions from paticipants and testersSolution 1Keep\nthe same, set to and only keep reachable cells in . is some constant (\nshould work).We found this solution during testing, tried, and failed to\nhack it. Solution 2Keep the same, do dfs from each cell , prioritizing\nincreasing over increasing , and stop the process the first time you\nreach any cell , take the maximum of all cells visited.This should not\nbe worse than the intended solution, and actually runs quite fast.\nSolution 3Simply take all cells in and mark everything outside as\nreachable. works.We found this solution the day before the round, we\ndon\u00e2\u0080\u0099t know how to hack it either.UPD: was hacked. Hats off to the\nhacker. Solution 4Do dfs with pruning. Run dfs starting at , return when\nthe cell is (i.e. obviously reachable because of primes), or when the\nvalue of the cell is smaller than the current answer. Add some\nmemorization and it passes.\n",
    "name": "F2. Court Blue  Hard Version ",
    "statement": "In the court of the Blue King, Lelle and Flamm are having a performance\r\nmatch. The match consists of several rounds. In each round, either Lelle\r\nor Flamm wins.Let W_L and W_F denote the number of wins of Lelle and\r\nFlamm, respectively. The Blue King considers a match to be if and only\r\nif: after every round,\r\ngcd(W_L,W_F)\r\nle 1; at the end of the match, W_L\r\nle n, W_F\r\nle m. Note that\r\ngcd(0,x)=\r\ngcd(x,0)=x for every non-negative integer x.Lelle and Flamm can decide\r\nto stop the match whenever they want, and the final score of the\r\nperformance is l\r\ncdot W_L + f\r\ncdot W_F.Please help Lelle and Flamm coordinate their wins and losses\r\nsuch that the performance is , and the total score of the performance is\r\nmaximized.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\u00a0constexpr int N = 2E7;std::vector<int> minp, primes;\u00a0void sieve(int n) {    minp.assign(n + 1, 0);    primes.clear();        for (int i = 2; i <= n; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }                for (auto p : primes) {            if (i * p > n) {                break;            }            minp[i * p] = p;            if (p == minp[i]) {                break;            }        }    }}\u00a0void solve() {    int n, m, l, f;    std::cin >> n >> m >> l >> f;        int q = m;    while (q > 1 && minp[q] != q) {        q--;    }    int p = std::min(q - 1, n);    while (p > 1 && (minp[p] != p || m / p != q / p)) {        p--;    }        // std::cerr << \"p : \" << p << \", q : \" << q << \"\\n\";    std::vector vis(n - p + 1, std::vector<bool>(m - q + 1));    i64 ans = 0;    for (int i = 0; i <= n - p; i++) {        for (int j = 0; j <= m - q; j++) {            int g = std::gcd(p + i, q + j);            if (i == 0 || j == 0) {                vis[i][j] = (g == 1 && p + i <= q + j);            } else if (g == 1) {                vis[i][j] = vis[i - 1][j] || vis[i][j - 1];            }            if (vis[i][j]) {                // std::cerr << \"(\" << p + i << \", \" << q + j << \")\\n\";                ans = std::max(ans, 1LL * l * (p + i) + 1LL * f * (q + j));                if (q + j <= n) {                    ans = std::max(ans, 1LL * f * (p + i) + 1LL * l * (q + j));                }            }        }    }    std::cout << ans << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        // for (int i = 0; i <= 30; i++) {    //     for (int j = 0; j <= 30; j++) {    //         std::cerr << (std::gcd(i, j) <= 1 ? \"O\" : \" \");    //     }    //     std::cerr << \"\\n\";    // }        sieve(N);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F2. Court Blue  Hard Version .json"
}