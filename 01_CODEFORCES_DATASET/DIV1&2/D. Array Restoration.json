{
    "link": "https://codeforces.com//contest/1023/problem/D",
    "problemId": "209192",
    "problem_idx": "D",
    "shortId": "1023D",
    "contest_number": "1023",
    "problem_submissions": {
        "F": [
            41706962,
            41711449,
            41703443,
            41713059,
            41716623,
            41714553,
            41714671,
            41707623,
            41713235,
            41712334,
            41728092,
            41715075,
            41696075,
            41713356,
            41714801,
            41709605,
            41719826,
            41712664,
            41715258,
            41716252
        ],
        "E": [
            41698618,
            41698291,
            41699659,
            41704092,
            41694722,
            41704680,
            41704917,
            41699573,
            41705681,
            41707263,
            41704649,
            41710828,
            41705364,
            41701903,
            41705217,
            41705636,
            41706969,
            41702766,
            41702871
        ],
        "D": [
            41694804,
            41690882,
            41694456,
            41696667,
            41700369,
            41697794,
            41697937,
            41696439,
            41697953,
            41699194,
            41695409,
            41701962,
            41696987,
            41693065,
            41702154,
            41698952,
            41700314,
            41697292,
            41697057
        ],
        "C": [
            41689677,
            41687726,
            41688316,
            41690341,
            41688011,
            41691766,
            41691373,
            41708581,
            41689935,
            41688178,
            41690416,
            41703451,
            41690697,
            41687815,
            41690419,
            41689708,
            41692238,
            41691341,
            41691501
        ],
        "B": [
            41687853,
            41686964,
            41687392,
            41687955,
            41687163,
            41687657,
            41689074,
            41696355,
            41687990,
            41690278,
            41688421,
            41705049,
            41689143,
            41688949,
            41689104,
            41687914,
            41689486,
            41689269,
            41689603
        ],
        "A": [
            41686640,
            41686676,
            41686712,
            41686970,
            41686742,
            41686759,
            41687401,
            41696322,
            41687071,
            41686971,
            41706549,
            41687626,
            41686813,
            41686865,
            41686818,
            41686780,
            41686879,
            41726126
        ],
        "G": [
            55938906,
            48502404,
            46583960,
            42546293,
            42609540
        ]
    },
    "name": "D. Array Restoration",
    "statement": "Initially there was an array a consisting of n integers. Positions in it\r\nare numbered from 1 to n.Exactly q queries were performed on the array.\r\nDuring the i-th query some segment (l_i, r_i) (1\r\nle l_i\r\nle r_i\r\nle n) was selected and values of elements on positions from l_i to r_i\r\ninclusive got changed to i. The order of the queries couldn\u2019t be changed\r\nand all q queries were applied. It is also known that every position\r\nfrom 1 to n got covered by at least one segment.We could have offered\r\nyou the problem about checking if some given array (consisting of n\r\nintegers with values from 1 to q) can be obtained by the aforementioned\r\nqueries. However, we decided that it will come too easy for you.So the\r\nenhancement we introduced to it is the following. Some set of positions\r\n(possibly empty) in this array is selected and values of elements on\r\nthese positions are set to 0.Your task is to check if this array can be\r\nobtained by the aforementioned queries. Also if it can be obtained then\r\nrestore this array.If there are multiple possible arrays then print any\r\nof them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 200005;\nconst int MAXT = 530000;\nconst int mod = 1e9 + 7;\n\nstruct seg{\n\tint tree[MAXT], lim;\n\tvoid init(int n){\n\t\tmemset(tree, 0x3f, sizeof(tree));\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t}\n\tvoid upd(int x, int v){\n\t\tx += lim;\n\t\ttree[x] = v;\n\t\twhile(x > 1){\n\t\t\tx >>= 1;\n\t\t\ttree[x] = min(tree[x], v);\n\t\t}\n\t}\n\tint query(int s, int e){\n\t\ts += lim;\n\t\te += lim;\n\t\tint ret = 1e9;\n\t\twhile(s < e){\n\t\t\tif(s%2 == 1) ret = min(ret, tree[s++]);\n\t\t\tif(e%2 == 0) ret = min(ret, tree[e--]);\n\t\t\ts >>= 1;\n\t\t\te >>= 1;\n\t\t}\n\t\tif(s == e) ret = min(ret, tree[s]);\n\t\treturn ret;\n\t}\n}seg;\n\nint n, q, arr[MAXN];\nint l[MAXN], r[MAXN];\n\nint main(){\n\tcin >> n >> q;\n\tseg.init(n);\n\tmemset(l, 0x3f, sizeof(l));\n\tint anny = -1;\n\tset<int> s;\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t\tl[arr[i]] = min(l[arr[i]], i);\n\t\tr[arr[i]] = max(r[arr[i]], i);\n\t\tif(arr[i] == 0) s.insert(i);\n\t\telse seg.upd(i, arr[i]);\n\t}\n\tif(!s.empty()) anny = *s.begin();\n\tfor(int i=q; i; i--){\n\t\tif(l[i] > r[i]) continue;\n\t\tif(seg.query(l[i], r[i]) < i){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tauto it = s.lower_bound(l[i]);\n\t\twhile(it != s.end()){\n\t\t\tif(*it <= r[i]){\n\t\t\t\tarr[*it] = i;\n\t\t\t\tit = s.erase(it);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tfor(auto &i : s) arr[i] = 1;\n\tif(l[q] > r[q]){\n\t\tif(anny == -1){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tarr[anny] = q;\n\t}\n\tputs(\"YES\");\n\tfor(int i=1; i<=n; i++) printf(\"%d \", arr[i]);\n\t// TODO : make sure q appears\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Array Restoration.json",
    "editorial_link": "https://codeforces.com//blog/entry/61356",
    "editorial": "Let\u00e2\u0080\u0099s firstly solve the problem as if there are no zeroes in the given\r\narray. Let be the leftmost occurrence of in the array and be the\r\nrightmost occurrence of . The main observation is that you can choose\r\nsegments for the corresponding queries and this sequence will be correct\r\nif and only if there exists any answer for the given array. If there is\r\nno occurrence of some value in the array then you can put the segment\r\nfor it under the segment of some greater value. If there is no\r\noccurrence of in the array then the answer doesn\u00e2\u0080\u0099t exist.For sure,\r\nsegment is the minimum segment you can choose. You can expand it in both\r\ndirections but it will never matter: these positions either will get\r\ncovered by the segments of greater values or will replace the smaller\r\nvalues with (and turn to if the answer existed). Finally, each position\r\nwill be covered as each element is a left bound of a segment, a right\r\nbound of a segment or just covered by the segment of its value.That\r\nproblem can be solved with any data structure that allows you to assign\r\nvalues on segment and get the value of every position (segment tree,\r\nsqrt decomposition).However, all the queries are performed offline (the\r\nresulting values are only needed after the queries) and the operation\r\ncan be replaced with assigning maximum of the current value of element\r\nand the value of the query.This can also be done using set. For each\r\nposition you should keep the segments which start there and end there.\r\nFor each segment you push to the list for and push to the list for . Now\r\nyou iterate from to , when entering you add all values of opening\r\nsegments to the set, assign the element at position the maximum value of\r\nthe set and remove all the values of closing segments from the set. The\r\ncomplexity of this algorithm is .This algorithm can be easily applied to\r\nthe problem with zeroes in the array. At the beginning you fill the\r\nresulting array with ones. After you performed the algorithm with set on\r\nthe values from to , while constructing the segments from the non-zero\r\nelements of the given array, you check if the values you assigned are\r\nless or equal than the corresponding values of the given array. If that\r\nholds then the resulting array is already the correct one. Otherwise the\r\nanswer doesn\u00e2\u0080\u0099t exist. The only corner case there is if no value was in\r\narray and there were some zeroes. That way you should just change any\r\nzero to .Overall complexity: .\r\n"
}