{"link": "https://codeforces.com//contest/1023/problem/D", "problemId": "209192", "problem_idx": "D", "shortId": "1023D", "contest_number": "1023", "problem_submissions": {"F": [41706962, 41711449, 41703443, 41713059, 41716623, 41714553, 41714671, 41707623, 41713235, 41712334, 41728092, 41715075, 41696075, 41713356, 41714801, 41709605, 41719826, 41712664, 41715258, 41716252], "E": [41698618, 41698291, 41699659, 41704092, 41694722, 41704680, 41704917, 41699573, 41705681, 41707263, 41704649, 41710828, 41705364, 41701903, 41705217, 41705636, 41706969, 41702766, 41702871], "D": [41694804, 41690882, 41694456, 41696667, 41700369, 41697794, 41697937, 41696439, 41697953, 41699194, 41695409, 41701962, 41696987, 41693065, 41702154, 41698952, 41700314, 41697292, 41697057], "C": [41689677, 41687726, 41688316, 41690341, 41688011, 41691766, 41691373, 41708581, 41689935, 41688178, 41690416, 41703451, 41690697, 41687815, 41690419, 41689708, 41692238, 41691341, 41691501], "B": [41687853, 41686964, 41687392, 41687955, 41687163, 41687657, 41689074, 41696355, 41687990, 41690278, 41688421, 41705049, 41689143, 41688949, 41689104, 41687914, 41689486, 41689269, 41689603], "A": [41686640, 41686676, 41686712, 41686970, 41686742, 41686759, 41687401, 41696322, 41687071, 41686971, 41706549, 41687626, 41686813, 41686865, 41686818, 41686780, 41686879, 41726126], "G": [55938906, 48502404, 46583960, 42546293, 42609540]}, "name": "D. Array Restoration", "statement": "Initially there was an array a consisting of n integers. Positions in it\r\nare numbered from 1 to n.Exactly q queries were performed on the array.\r\nDuring the i-th query some segment (l_i, r_i) (1\r\nle l_i\r\nle r_i\r\nle n) was selected and values of elements on positions from l_i to r_i\r\ninclusive got changed to i. The order of the queries couldn\u2019t be changed\r\nand all q queries were applied. It is also known that every position\r\nfrom 1 to n got covered by at least one segment.We could have offered\r\nyou the problem about checking if some given array (consisting of n\r\nintegers with values from 1 to q) can be obtained by the aforementioned\r\nqueries. However, we decided that it will come too easy for you.So the\r\nenhancement we introduced to it is the following. Some set of positions\r\n(possibly empty) in this array is selected and values of elements on\r\nthese positions are set to 0.Your task is to check if this array can be\r\nobtained by the aforementioned queries. Also if it can be obtained then\r\nrestore this array.If there are multiple possible arrays then print any\r\nof them.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 200005;\nconst int MAXT = 530000;\nconst int mod = 1e9 + 7;\n\nstruct seg{\n\tint tree[MAXT], lim;\n\tvoid init(int n){\n\t\tmemset(tree, 0x3f, sizeof(tree));\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t}\n\tvoid upd(int x, int v){\n\t\tx += lim;\n\t\ttree[x] = v;\n\t\twhile(x > 1){\n\t\t\tx >>= 1;\n\t\t\ttree[x] = min(tree[x], v);\n\t\t}\n\t}\n\tint query(int s, int e){\n\t\ts += lim;\n\t\te += lim;\n\t\tint ret = 1e9;\n\t\twhile(s < e){\n\t\t\tif(s%2 == 1) ret = min(ret, tree[s++]);\n\t\t\tif(e%2 == 0) ret = min(ret, tree[e--]);\n\t\t\ts >>= 1;\n\t\t\te >>= 1;\n\t\t}\n\t\tif(s == e) ret = min(ret, tree[s]);\n\t\treturn ret;\n\t}\n}seg;\n\nint n, q, arr[MAXN];\nint l[MAXN], r[MAXN];\n\nint main(){\n\tcin >> n >> q;\n\tseg.init(n);\n\tmemset(l, 0x3f, sizeof(l));\n\tint anny = -1;\n\tset<int> s;\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t\tl[arr[i]] = min(l[arr[i]], i);\n\t\tr[arr[i]] = max(r[arr[i]], i);\n\t\tif(arr[i] == 0) s.insert(i);\n\t\telse seg.upd(i, arr[i]);\n\t}\n\tif(!s.empty()) anny = *s.begin();\n\tfor(int i=q; i; i--){\n\t\tif(l[i] > r[i]) continue;\n\t\tif(seg.query(l[i], r[i]) < i){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tauto it = s.lower_bound(l[i]);\n\t\twhile(it != s.end()){\n\t\t\tif(*it <= r[i]){\n\t\t\t\tarr[*it] = i;\n\t\t\t\tit = s.erase(it);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tfor(auto &i : s) arr[i] = 1;\n\tif(l[q] > r[q]){\n\t\tif(anny == -1){\n\t\t\tputs(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t\tarr[anny] = q;\n\t}\n\tputs(\"YES\");\n\tfor(int i=1; i<=n; i++) printf(\"%d \", arr[i]);\n\t// TODO : make sure q appears\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures"], "dificulty": "1700", "interactive": false}