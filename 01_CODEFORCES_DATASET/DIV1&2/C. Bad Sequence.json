{
    "link": "https://codeforces.com//contest/1214/problem/C",
    "problemId": "403806",
    "problem_idx": "C",
    "shortId": "1214C",
    "contest_number": "1214",
    "problem_submissions": {
        "G": [
            60015427,
            60116387,
            60017546,
            60017495,
            60020107,
            60006609,
            60352777,
            60002997,
            60009463,
            60011243
        ],
        "H": [
            60007228,
            60007997,
            60003236,
            60009685,
            60010066,
            60011259,
            60011282,
            60010896,
            60009334,
            60014724,
            60008843,
            60014112,
            60047947,
            60007110,
            60062101,
            60075338
        ],
        "F": [
            59997972,
            59999955,
            60011529,
            60001435,
            59997615,
            60004519,
            60003172,
            60003385,
            60014786,
            60014588,
            60009696,
            60014299,
            60009888,
            60047758,
            60003766,
            59999966,
            60002829,
            60000810
        ],
        "E": [
            59991588,
            59992896,
            59995584,
            59992549,
            59995811,
            59995619,
            59997178,
            59995808,
            59993809,
            59992236,
            59997269,
            59997999,
            59997711,
            59993230,
            59995040,
            59995208,
            59994715,
            59993710,
            59996947,
            59988545
        ],
        "D": [
            59988102,
            59989658,
            59989675,
            59986719,
            59990868,
            59992865,
            59990765,
            59991828,
            59988538,
            59989605,
            59989462,
            59992741,
            59999498,
            59988876,
            60017942,
            59989391,
            59991386,
            59989567,
            59990626,
            60046854,
            59985851
        ],
        "C": [
            59984445,
            59985337,
            59984895,
            59983957,
            59985031,
            59985481,
            59984019,
            59986980,
            59984427,
            59984066,
            59984382,
            59987002,
            59982712,
            59984754,
            59984720,
            59985711,
            59985097,
            59984496,
            59982839,
            59983656
        ],
        "B": [
            59983717,
            59984061,
            59983687,
            59983257,
            59983195,
            59983710,
            59983075,
            59985335,
            59983154,
            59983158,
            59983522,
            59985251,
            59983191,
            59983505,
            59982763,
            59984237,
            59983907,
            59983359,
            59984573,
            59982988
        ],
        "A": [
            59982834,
            59982716,
            59982610,
            59982747,
            59982737,
            59982711,
            59982633,
            59982961,
            59982657,
            59982623,
            59982788,
            59982811,
            59983962,
            59982673,
            59985703,
            59982891,
            59983099,
            59982727,
            59985651,
            59982701
        ]
    },
    "name": "C. Bad Sequence",
    "statement": "Petya\u2019s friends made him a birthday present a bracket sequence. Petya\r\nwas quite disappointed with his gift, because he dreamed of correct\r\nbracket sequence, yet he told his friends nothing about his dreams and\r\ndecided to fix present himself. To make everything right, Petya is going\r\nto move at most one bracket from its original place in the sequence to\r\nany other position. Reversing the bracket (e.g. turning \"(\" into \")\" or\r\nvice versa) isn\u2019t allowed. We remind that bracket sequence s is called\r\ncorrect if: s is empty; s is equal to \"t\", where t is correct bracket\r\nsequence; s is equal to t_1 t_2, i.e. concatenation of t_1 and t_2,\r\nwhere t_1 and t_2 are correct bracket sequences. For example, \"\", \"\" are\r\ncorrect, while \"\" and \"\" are not. Help Petya to fix his birthday present\r\nand understand whether he can move one bracket so that the sequence\r\nbecomes correct.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n;\nchar s[N];\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tint bal=0,mbal=0;\n\trep(i,0,n) {\n\t\tif (s[i]=='(') bal++; else bal--;\n\t\tmbal=min(mbal,bal);\n\t}\n\tputs((bal==0&&mbal>=-1)?\"Yes\":\"No\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Bad Sequence.json",
    "editorial_link": "https://codeforces.com/blog/entry/69563",
    "editorial": "Let\u00e2\u0080\u0099s call a of bracket sequence a number of opening brackets minus the\r\nnumber of closing brackets. Correct bracket sequence is such a sequence\r\nthat balance of any of its prefixes is at least and the balance of the\r\nentire sequence is equal to . To solve the problem let\u00e2\u0080\u0099s consider the\r\nshortest prefix with balance equal to . In this prefix last symbol is\r\nobviously equal to \"\", so let\u00e2\u0080\u0099s move this closing bracket to the end of\r\nthe sequence. If the sequence is correct now, then the answer is \"\",\r\notherwise it is \"\", because it means that in original sequence there\r\nexists some longer prefix with balance equal to . Let\u00e2\u0080\u0099s show why we\r\ncan\u00e2\u0080\u0099t move some bracket so that the sequence becomes correct.Consider\r\nthe shortest prefix with balance equal to . If we move some opening\r\nbracket to the beginning of the sequence, balance of considered prefix\r\nbecomes and the sequence is not correct yet. Moving opening bracket from\r\nconsidered prefix to the beginning doesn\u00e2\u0080\u0099t change anything. Even more,\r\nif we move the closing bracket from the end of the considered prefix to\r\nthe end of the sequence, it still doesn\u00e2\u0080\u0099t become correct, because\r\nbalance of the prefix is .This results in a following solution: if\r\nbalance of all prefixes is not less than , answer is \"\", otherwise it\u00e2\u0080\u0099s\r\n\"\".\r\n"
}