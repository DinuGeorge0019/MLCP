{
    "link": "https://codeforces.com//contest/932/problem/D",
    "problemId": "156997",
    "problem_idx": "D",
    "shortId": "932D",
    "contest_number": "932",
    "problem_submissions": {
        "G": [
            51774341,
            35308371,
            35309948,
            35309510,
            35328593,
            35312755,
            35340195,
            35324025,
            38386676,
            35314606
        ],
        "F": [
            35314668,
            35310572,
            35468380,
            35310269,
            35309416,
            35312292,
            35310748,
            35546358,
            35310551,
            35314451,
            35994490,
            35310830,
            35314597,
            35313005,
            35315153,
            35311414,
            35314861
        ],
        "E": [
            35305602,
            35300676,
            35303983,
            35302322,
            35304627,
            35307360,
            35305500,
            35300979,
            35304741,
            35308375,
            35305972,
            35304083,
            35308467,
            35308589,
            35308504,
            35313014,
            35308160,
            35300247
        ],
        "D": [
            35304182,
            35304652,
            35301520,
            35312731,
            35302822,
            35304942,
            35303273,
            35308561,
            35309596,
            35306303,
            35302532,
            35308788,
            35304471,
            35304933,
            35304868,
            35308529,
            35306123,
            35312012
        ],
        "C": [
            35298412,
            35298036,
            35296739,
            35298645,
            35298179,
            35298553,
            35299152,
            35297891,
            35299526,
            35299903,
            35298326,
            35305061,
            35298463,
            35300385,
            35298472,
            35299312,
            35300289,
            35313442
        ],
        "B": [
            35297094,
            35297006,
            35297939,
            35296994,
            35296930,
            35296422,
            35297855,
            35301880,
            35297864,
            35297983,
            35297247,
            35296879,
            35297467,
            35297739,
            35296808,
            35297547,
            35298510,
            35302031
        ],
        "A": [
            35295015,
            35294909,
            35298217,
            35294978,
            35294827,
            35294828,
            35295219,
            35296140,
            35296578,
            35294771,
            35294859,
            35294967,
            35294941,
            35294775,
            35295820,
            35295673,
            35300844
        ]
    },
    "name": "D. Tree",
    "statement": "You are given a node of the tree with index and with weight . Let be the\r\nnumber of nodes in the tree at any instant (initially, is set to ).\r\nSupport queries of following two types: Add a new node (index ) with\r\nweight and add edge between node and this node. Output the maximum\r\nlength of sequence of nodes which starts with . Every node in the\r\nsequence is an ancestor of its predecessor. Sum of weight of nodes in\r\nsequence does not exceed . For some nodes that are consecutive in the\r\nsequence if is an ancestor of then and there should not exist a node on\r\nsimple path from to such that The tree is rooted at node at any instant.\r\n",
    "solutions": [
        "//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=1000*1007;\n\nint n=1;\n\nint q;\n\nint odl[nax];\n\nll tab[nax];\nint oj[nax];\n\nvector < pair <int,ll> > jump[nax];\n\nint last;\n\nvoid dodaj(int v, ll w)\n{\n\tfor (int i=20; i>=0; i--)\n\t\tif (i<(int)jump[v].size() && jump[v][i].first && tab[jump[v][i].first]<w)\n\t\t\tv=jump[v][i].first;\n\tif (tab[v]<w)\n\t\tv=oj[v];\n\tn++;\n\t\n\t//~ debug() << n << \" \" << v << \" \" << w;\n\t\n\todl[n]=odl[v]+1;\n\toj[n]=v;\n\ttab[n]=w;\n\tjump[n].push_back({v, w});\n\twhile(jump[n].back().first)\n\t{\n\t\tint p1=jump[n].back().first;\n\t\tint p2=min(jump[n].size(), jump[p1].size())-1;\n\t\tll mag=jump[n].back().second+jump[p1][p2].second;\n\t\tjump[n].push_back({jump[p1][p2].first, mag});\n\t}\n\t//~ debug() << n << \" \" << jump[n];\n}\n\nvoid pytaj(int v, ll w)\n{\n\t//~ debug() << v << \"  \" << w;\n\tint sta=v;\n\tfor (int i=20; i>=0; i--)\n\t{\n\t\tif (i<(int)jump[v].size() && jump[v][i].second<=w)\n\t\t{\n\t\t\tw-=jump[v][i].second;\n\t\t\tv=jump[v][i].first;\n\t\t}\n\t}\n\tlast=odl[sta]-odl[v];\n\tprintf(\"%d\\n\", last);\n}\n\nint main()\n{\n\ttab[0]=-1;\n\tjump[1].push_back({0, 0});\n\todl[1]=1;\n\tscanf(\"%d\", &q);\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tll p, q;\n\t\tscanf(\"%d%lld%lld\", &typ, &p, &q);\n\t\tp^=last;\n\t\tq^=last;\n\t\tif (typ==1)\n\t\t\tdodaj(p, q);\n\t\telse\n\t\t\tpytaj(p, q);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/57796",
    "editorial": "The main idea is that we will use binary lifting. Twice. Let\u00e2\u0080\u0099s consider\r\nthe following algorithm for every vertex (when inserted) find the\r\nclosest vertex above it with . Lets have an array , such that . Then the\r\nquery will be done by simply jumping to the vertex in , until our sum\r\nbecomes larger than . Obviously this is .To speed it up, we will have\r\nbinary liftings. The first one will be for finding the and the second\r\none will be for answering the queries. For the first one we will store\r\nthe -th parent and the maximum weight on the path and for the second\r\none, we will store the -th vertex and the sum of the weights on the\r\npath. Well that\u00e2\u0080\u0099s all and in such a way you can achieve .\r\n"
}