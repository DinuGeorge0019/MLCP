{
    "link": "https://codeforces.com//contest/618/problem/F",
    "problemId": "46789",
    "problem_idx": "F",
    "shortId": "618F",
    "contest_number": "618",
    "problem_submissions": {
        "E": [
            15660896,
            15660810,
            25267684,
            15661349,
            15660954,
            15669573,
            15669552,
            15657805,
            15659540,
            15660389,
            15659859,
            15661631,
            15661128,
            15659694,
            15662154,
            15661797,
            15661848,
            15663282,
            15660127,
            15662115
        ],
        "D": [
            15656948,
            15655133,
            15655445,
            15667159,
            15665258,
            15655421,
            15655925,
            15656563,
            15656409,
            15655319,
            15659360,
            39354565,
            15656312,
            15656752,
            15657964,
            15663170,
            15658748
        ],
        "C": [
            15652141,
            15652363,
            15652477,
            15652597,
            15653006,
            15652229,
            15653352,
            15654441,
            15653369,
            15652636,
            15663125,
            15652085,
            15653674,
            15653050,
            15652997,
            15652103,
            15653430
        ],
        "A": [
            15650445,
            15649636,
            15649663,
            15649788,
            15649765,
            15649822,
            15650160,
            15649790,
            15649745,
            15649679,
            15649632,
            15649853,
            15649674,
            15649848,
            15649720,
            15649691,
            15650068
        ],
        "B": [
            15649885,
            15650154,
            15650770,
            15651204,
            15650301,
            15650651,
            15651598,
            15651581,
            15651312,
            15651165,
            15649859,
            15650851,
            15650978,
            15651073,
            15650933,
            15650396,
            15651924
        ],
        "F": [
            15662761,
            15674016,
            15665529,
            15670689
        ]
    },
    "name": "F. Double Knapsack",
    "statement": "You are given two multisets and . Each multiset has exactly integers\r\neach between and inclusive. Multisets may contain multiple copies of the\r\nsame number.You would like to find a nonempty subset of and a nonempty\r\nsubset of such that the sum of elements in these subsets are equal.\r\nSubsets are also multisets, i.e. they can contain elements with equal\r\nvalues.If no solution exists, print . Otherwise, print the indices of\r\nelements in any such subsets of and that have the same sum.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(\"rdtsc\" : \"=A\"(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"text\"\n\nconst int INF = (int) 1.01e9;\nconst ld EPS = 1e-9;\n\nconst ld PI = acos(-1.0L);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e6 + 10;\nint a[maxn], b[maxn];\n\nint n;\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", b + i);\n  }\n  return 1;\n}\n\nint as[maxn], bs[maxn];\n\nint was[maxn];\n\nvoid solve() {\n  if (a[0] > b[0]) {\n    for (int i = 0; i < n; ++i) {\n      b[i] = -b[i];\n    }\n  } else {\n    for (int i = 0; i < n; ++i) {\n      a[i] = -a[i];\n    }\n  }\n  as[0] = 0, bs[0] = 0;\n  int sum = 0;\n  for (int i = 0; i < n; ++i) {\n    was[i] = -1;\n  }\n  was[0] = 0;\n  for (int i = 1; i <= n; ++i) {\n    as[i] = as[i - 1], bs[i] = bs[i - 1];\n    if (0 <= sum + a[as[i]] && sum + a[as[i]] < n) {\n      sum += a[as[i]];\n      ++as[i];\n    } else {\n      if (0 <= sum + b[bs[i]] && sum + b[bs[i]] < n) {\n        sum += b[bs[i]];\n        ++bs[i];\n      } else {\n        sum += a[as[i]] + b[bs[i]];\n        ++as[i], ++bs[i];\n        assert(0 <= sum && sum < n);\n      }\n    }\n    if (was[sum] >= 0) {\n      int last = was[sum];\n      printf(\"%d\\n\", as[i] - as[last]);\n      assert(as[i] > as[last]);\n      for (int j = as[last]; j < as[i]; ++j) {\n        printf(\"%d%c\", j + 1, \" \\n\"[j == as[i] - 1]);\n      }\n      printf(\"%d\\n\", bs[i] - bs[last]);\n      assert(bs[i] > bs[last]);\n      for (int j = bs[last]; j < bs[i]; ++j) {\n        printf(\"%d%c\", j + 1, \" \\n\"[j == bs[i] - 1]);\n      }\n      return;\n    }\n    was[sum] = i;\n  }\n  assert(0);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME\".out\", \"w\", stdout);\n  assert(freopen(TASKNAME\".in\", \"r\", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time: %.18lf\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Double Knapsack.json",
    "editorial_link": "https://codeforces.com//blog/entry/23142",
    "editorial": "Letâs replace \"set\" with \"array\", and \"subset\" with \"consecutive\r\nsubarray\". Let denote the sum of the first elements of and be the sum of\r\nthe first elements of . WLOG, letâs assume . For each , we can find the\r\nlargest such that . Then, the difference will be between and inclusive.\r\nThere are such differences (including ), but only integers it can take\r\non, so by pigeon hole principle, at least two of them are the same. So,\r\nwe have . Suppose that . It can be shown that . So, we rearranging our\r\nequation, we have , which allows us to extract the indices. Example\r\ncode: http://codeforces.com/contest/618/submission/15669546 Comment: It\r\nseemed difficult for me to generate strong cases. Is there an easy way\r\nto do it? I tried my best, but there may be some weird solutions that\r\ncan pass that I just overloooked.\r\n",
    "hint": []
}