{
    "link": "https://codeforces.com//contest/1307/problem/E",
    "problemId": "542681",
    "problem_idx": "E",
    "shortId": "1307E",
    "contest_number": "1307",
    "problem_submissions": {
        "D": [
            71334675,
            71329379,
            71297375,
            71300630,
            71300597,
            71296525,
            71299736,
            71299787,
            71299649,
            71294218,
            71299266,
            71353437,
            71301135,
            71298819,
            71297533,
            71302173,
            71301113,
            71306340,
            71311289,
            71303681,
            71296481
        ],
        "F": [
            71318320,
            71328004,
            71328410,
            71313540,
            71342732,
            71342701,
            71342679,
            71342641,
            71378556,
            71386768,
            71330817,
            71353605,
            71341156,
            71340667,
            71331133,
            71325872,
            71974189
        ],
        "E": [
            71311504,
            71318452,
            71321704,
            71329781,
            71312470,
            71310373,
            71310234,
            71311741,
            71326064,
            71325657,
            71312968,
            71315289,
            71309289,
            71345858,
            71345831,
            71345723,
            71345591,
            71345520,
            71345206,
            71344772,
            71344661,
            71308214,
            71331493,
            71309218,
            71315974,
            71328300,
            71317669,
            71329605
        ],
        "G": [
            71303096,
            71336439,
            71307493,
            71308346,
            71320475,
            71303320,
            71313925,
            71322572,
            71322223,
            71309226,
            71311369,
            71356337,
            71319400,
            71321748,
            71313979,
            71354003,
            71316843,
            71327328,
            71316390,
            71329594,
            71321365
        ],
        "C": [
            71291268,
            71289526,
            71293976,
            71293545,
            71288006,
            71294250,
            71293163,
            71291197,
            71300886,
            71294829,
            71291105,
            71294718,
            71292675,
            71291425,
            71296070,
            71290915,
            71292479,
            71297176,
            71298646,
            71291499
        ],
        "B": [
            71289205,
            71287726,
            71290885,
            71290721,
            71289353,
            71290602,
            71289374,
            71288121,
            71299427,
            71291607,
            71289046,
            71290292,
            71334215,
            71288723,
            71290619,
            71288909,
            71289266,
            71289248,
            71288946,
            71288924
        ],
        "A": [
            71287300,
            71287160,
            71287363,
            71290273,
            71290150,
            71287273,
            71287420,
            71292915,
            71295372,
            71287966,
            71287342,
            71287721,
            71287194,
            71287212,
            71288221,
            71287271,
            71287331,
            71287368,
            71290172,
            71287362
        ]
    },
    "name": "E. Cow and Treats",
    "statement": "After a successful year of milk production, Farmer John is rewarding his\r\ncows with their favorite treat: tasty grass!On the field, there is a row\r\nof n units of grass, each with a sweetness s_i. Farmer John has m cows,\r\neach with a favorite sweetness f_i and a hunger value h_i. He would like\r\nto pick two disjoint subsets of cows to line up on the left and right\r\nside of the grass row. There is no restriction on how many cows must be\r\non either side. The cows will be treated in the following manner: The\r\ncows from the left and right side will take turns feeding in an order\r\ndecided by Farmer John. When a cow feeds, it walks towards the other end\r\nwithout changing direction and eats grass of its favorite sweetness\r\nuntil it eats h_i units. The moment a cow eats h_i units, it will fall\r\nasleep there, preventing further cows from passing it from both\r\ndirections. If it encounters another sleeping cow or reaches the end of\r\nthe grass row, it will get upset. Farmer John absolutely does not want\r\nany cows to get upset. Note that grass does not grow back. Also, to\r\nprevent cows from getting upset, not every cow has to feed since FJ can\r\nchoose a subset of them. Surprisingly, FJ has determined that sleeping\r\ncows are the most satisfied. If FJ orders optimally, what is the maximum\r\nnumber of sleeping cows that can result, and how many ways can FJ choose\r\nthe subset of cows on the left and right side to achieve that maximum\r\nnumber of sleeping cows (modulo 10^9+7)? The order in which FJ sends the\r\ncows does not matter as long as no cows get upset.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=5010;\nint n,m,s[N],f[N],h[N],cl[N],cr[N],clr[N];\nll way;\nint ans;\nPII l[N],r[N];\nVI pos[N];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,n) {\n\t\tscanf(\"%d\",s+i);\n\t\t--s[i];\n\t\tpos[s[i]].pb(i);\n\t}\n\trep(i,0,m) {\n\t\tscanf(\"%d%d\",f+i,h+i);\n\t\t--f[i];\n\t\tif (h[i]>SZ(pos[f[i]])) {\n\t\t\t--i; --m;\n\t\t\tcontinue;\n\t\t}\n\t\tl[i]=mp(pos[f[i]][h[i]-1],i);\n\t\tr[i]=mp(pos[f[i]][SZ(pos[f[i]])-h[i]],i);\n\t}\n\tif (m==0) {\n\t\tputs(\"0 1\");\n\t\treturn 0;\n\t}\n\tf[m]=-1;\n\tl[m]=mp(-1,0);\n\trep(i,0,m+1) {\n\t\trep(j,0,n) cl[j]=0,cr[j]=0,clr[j]=0;\n\t\trep(j,0,m) {\n\t\t\tif (j!=i) {\n\t\t\t\tif (f[j]==f[i]) {\n\t\t\t\t\tif (r[j].fi>l[i].fi) cr[f[j]]++;\n\t\t\t\t} else {\n\t\t\t\t\tif (l[j]<l[i]&&r[j].fi>l[i].fi) clr[f[j]]++;\n\t\t\t\t\telse if (l[j]<l[i]) cl[f[j]]++;\n\t\t\t\t\telse if (r[j].fi>l[i].fi) cr[f[j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(j,0,n) printf(\"col: %d cl :%d cr :%d clr %d\\n\",j,cl[j],cr[j],clr[j]);\n\t\tint p1=(i<m); ll p2=1;\n\t\trep(j,0,n) {\n\t\t\tif (j==f[i]) {\n\t\t\t\tif (cr[j]) p1++,p2=p2*cr[j]%mod;\n\t\t\t} else {\n\t\t\t\tif (cl[j]==0&&cr[j]==0&&clr[j]==0) continue;\n\t\t\t\tif (cr[j]==0&&clr[j]==0) {\n\t\t\t\t\tp1++; p2=p2*cl[j]%mod;\n\t\t\t\t} else if (cl[j]==0&&clr[j]==0) {\n\t\t\t\t\tp1++; p2=p2*cr[j]%mod;\n\t\t\t\t} else if (cl[j]==0&&cr[j]==0&&clr[j]==1) {\n\t\t\t\t\tp1++; p2=p2*(2*clr[j])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tp1+=2;\n\t\t\t\t\tint way=clr[j]*(clr[j]-1);\n\t\t\t\t\tway+=cl[j]*cr[j];\n\t\t\t\t\tway+=cl[j]*clr[j]+cr[j]*clr[j];\n\t\t\t\t\tp2=p2*way%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %lld\\n\",i,p1,p2);\n\t\tif (p1>ans) ans=p1,way=0;\n\t\tif (p1==ans) way=(way+p2)%mod;\n\t}\n\tprintf(\"%d %lld\\n\",ans,way);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Cow and Treats.json",
    "editorial_link": "https://codeforces.com//blog/entry/73953",
    "editorial": "First, we observe that it is impossible to send more than one cow with\r\nthe same favorite sweetness on the same side without upsetting any of\r\nthem. This means we can send at most two cows of each favorite\r\nsweetness, one on each side.Now, let\u00e2\u0080\u0099s assume we know the index of the\r\nrightmost cow that came from the left side. For each sweetness , we\r\ndenote the number of units of grass to the left of the index as and to\r\nthe right as . There are three cases we have to consider. If there does\r\nnot exist a cow of this favorite sweetness or the one of this favorite\r\nsweetness with minimum hunger cannot be satisfied from either direction,\r\nthen cows of the type will be asleep. Otherwise, or cows will be asleep,\r\nand we can derive a simple formula based on , , and the cows of this\r\ntype. Remember that we always maximize the number of sleeping cows\r\nfirst.We maintain how much each sweetness contributed to the answer.\r\nWhen we shift this index of the rightmost cow to the right, we can undo\r\nand recompute our answer.You can speed up the solution using binary\r\nsearch, but we chose not to require it. We also chose to allow other and\r\nsolutions to pass.Time Complexity:\r\n"
}