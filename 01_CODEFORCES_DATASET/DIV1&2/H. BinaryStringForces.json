{"link": "https://codeforces.com//contest/1750/problem/H", "problemId": "1626964", "problem_idx": "H", "shortId": "1750H", "contest_number": "1750", "problem_submissions": {"H": [179823917], "G": [179612953, 179618975, 179623473, 179614248, 179621065, 179645973, 179633214, 179622344, 180705510, 179933269, 180030556, 179950229, 179707183], "F": [179601347, 179603972, 179609105, 179620641, 179625110, 179609284, 179617930, 179604395, 179604949, 179608846, 179612187, 179613972, 179616254, 179614949, 179615429, 179614224, 179615399, 179617910], "E": [179577415, 179590864, 179604325, 179609562, 179600474, 179602399, 179611817, 179580954, 179591449, 179601210, 179600339, 179600865, 179602667, 179599833, 179601353, 179598843, 179836904, 179836835, 179604528, 179600892, 179603405], "D": [179570869, 179571769, 179580666, 179601268, 179580689, 179577888, 179591514, 179570023, 179569288, 179572989, 179577454, 179572611, 179571219, 179573391, 179577136, 179566640, 179577304, 179584005, 179571264], "C": [179566484, 179564254, 179566602, 179574509, 179568597, 179566588, 179569992, 179564018, 179563887, 179567519, 179569743, 179565401, 179565441, 179566302, 179568300, 179573635, 179569848, 179573882, 179567502], "B": [179560866, 179561834, 179561786, 179562451, 179561566, 179560845, 179563612, 179559937, 179559753, 179560949, 179562540, 179560960, 179559578, 179560145, 179563310, 179559663, 179562762, 179562300, 179560917], "A": [179559080, 179559855, 179559766, 179559866, 179559680, 179559121, 179560548, 179559129, 179559072, 179559167, 179559582, 179559013, 179559040, 179559136, 179561310, 179568564, 179559973, 179560198, 179559513]}, "name": "H. BinaryStringForces", "statement": "You are given a binary string s of length n. We define a as a substring\r\nthat cannot be extended while keeping all elements equal. For example,\r\nin the string 11000111 there are three maximal substrings: 11, 000 and\r\n111.In one operation, you can select two maximal adjacent substrings.\r\nSince they are maximal and adjacent, it\u2019s easy to see their elements\r\nmust have different values. Let a be the length of the sequence of ones\r\nand b be the length of the sequence of zeros. Then do the following: If\r\na\r\nge b, then replace b selected zeros with b ones. If a < b, then replace\r\na selected ones with a zeros.As an example, for 1110000 we make it\r\n0000000, for 0011 we make it 1111. We call a string being if it can be\r\nturned into 1111...1111 using the aforementioned operation any number of\r\ntimes (possibly, zero). Find the number of good substrings among all\r\nfrac{n(n+1)}{2} non-empty substrings of s.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng(0);\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don't erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = \"{\";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += \"}\";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return \"(\" + ts(p.f) + \", \" + ts(p.s) + \")\"; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = \"\";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn \"{\" + ts_sep(v, \", \") + \"}\";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += \",\";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = \" \";\n\t\tif (i == 0) bef = \"{\";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += \"}\";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, \"\", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << \"\\n\"; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, \" \", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, \" | \", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t), \"\\n\") << \"\\n\" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don't actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\"); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nV<vpi> end_with_one(str S) {\n\tconst int N = sz(S);\n\tvi prv(N + 1), nxt(N + 1);\n\t{\n\t\tint cur = -1;\n\t\tF0R(i, N + 1) {\n\t\t\tif (i == N || S.at(i) == '1') cur = i;\n\t\t\tprv.at(i) = cur;\n\t\t}\n\t}\n\t{\n\t\tnxt.at(N) = N;\n\t\tR0F(i, N) {\n\t\t\tif (S.at(i) == '1') nxt.at(i) = i;\n\t\t\telse nxt.at(i) = nxt.at(i + 1);\n\t\t}\n\t}\n\tV<vpi> ival(N + 1);\n\tR0F(i, N) {\n\t\tint lst = i;\n\t\tint cur = S.at(i) == '1' ? i : i - 1;\n\t\tbool good = (S.at(i) == '1');\n\t\t// dbg(\"GOING\", i);\n\t\twhile (true) {\n\t\t\tif (good) {\n\t\t\t\t// [lst, cur] is good\n\t\t\t\tint next_one = prv.at(min(2 * cur + 2 - i, N));\n\t\t\t\tif (next_one > cur) {\n\t\t\t\t\tcur = next_one;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// dbg(\"HA\", S, i, lst, cur);\n\t\t\t\tassert((lst == N || S.at(lst) == '1') &&\n\t\t\t\t\t   (cur == N || S.at(cur) == '1'));\n\t\t\t\tival.at(i).pb({lst, cur});\n\t\t\t\tgood = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cur == N) break;\n\t\t\t// dbg(\"OOPS\", i, cur);\n\t\t\tint next_one = nxt.at(cur + 1);\n\t\t\tint need_r = 2 * next_one - 2 - cur;\n\t\t\t// dbg(\"HA\", cur, next_one, need_r);\n\t\t\tassert(need_r >= next_one);\n\t\t\tint idx = fstTrue(0, sz(ival.at(next_one)) - 1, [&](int x) {\n\t\t\t\treturn ival.at(next_one).at(x).s >= need_r;\n\t\t\t});\n\t\t\tif (idx == sz(ival.at(next_one))) break;\n\t\t\tlst = cur = nxt.at(max(ival.at(next_one).at(idx).f, need_r));\n\t\t\tgood = 1;\n\t\t\t// dbg(\"SET\", lst, cur);\n\t\t}\n\t\t// dbg(i, ival.at(i));\n\t}\n\treturn ival;\n}\n\nstr rev(str S) {\n\treverse(all(S));\n\treturn S;\n}\n\n/**\n * Description: 1D range minimum query. Can also do queries\n * for any associative operation in $O(1)$ with D\\&C\n * Source: KACTL\n * Verification:\n * https://cses.fi/problemset/stats/1647/\n * http://wcipeg.com/problem/ioi1223\n * https://pastebin.com/ChpniVZL\n * Memory: O(N\\log N)\n * Time: O(1)\n */\n\ntcT > struct RMQ {\n\tint level(int x) { return 31 - __builtin_clz(x); }\n\tV<T> v;\n\tV<vi> jmp;\n\tint cmb(int a, int b) {\n\t\treturn v[a] == v[b] ? min(a, b) : (v[a] > v[b] ? a : b);\n\t}\n\tvoid init(const V<T> &_v) {\n\t\tv = _v;\n\t\tjmp = {vi(sz(v))};\n\t\tiota(all(jmp[0]), 0);\n\t\tfor (int j = 1; 1 << j <= sz(v); ++j) {\n\t\t\tjmp.pb(vi(sz(v) - (1 << j) + 1));\n\t\t\tF0R(i, sz(jmp[j]))\n\t\t\tjmp[j][i] = cmb(jmp[j - 1][i], jmp[j - 1][i + (1 << (j - 1))]);\n\t\t}\n\t}\n\tint index(int l, int r) {\n\t\tassert(l <= r);\n\t\tint d = level(r - l + 1);\n\t\treturn cmb(jmp[d][l], jmp[d][r - (1 << d) + 1]);\n\t}\n\tT query(int l, int r) { return v[index(l, r)]; }\n};\n\n/**\n * Author: Lukas Polacek\n * Date: 2009-10-30\n * License: CC0\n * Source: folklore/TopCoder\n * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], and\n * updates single elements a[i], taking the difference between the old and new\n * value. Time: Both operations are $O(\\log N)$. Status: Stress-tested\n */\n\ntcT > struct BIT {\n\tint N;\n\tV<T> data;\n\tvoid init(int _N) {\n\t\tN = _N;\n\t\tdata.rsz(N);\n\t}\n\tvoid add(int p, T x) {\n\t\tfor (++p; p <= N; p += p & -p) data[p - 1] += x;\n\t}\n\tT sum(int l, int r) { return sum(r + 1) - sum(l); }\n\tT sum(int r) {\n\t\tT s = 0;\n\t\tfor (; r; r -= r & -r) s += data[r - 1];\n\t\treturn s;\n\t}\n\tint lower_bound(T sum) {\n\t\tif (sum <= 0) return -1;\n\t\tint pos = 0;\n\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {\n\t\t\tint npos = pos + pw;\n\t\t\tif (npos <= N && data[npos - 1] < sum)\n\t\t\t\tpos = npos, sum -= data[pos - 1];\n\t\t}\n\t\treturn pos;\n\t}\n};\n\nvoid solve(int N, str S) {\n\tauto l_to_r = end_with_one(S);\n\tauto r_to_l = end_with_one(rev(S));\n\tvi cum{0};\n\teach(c, S) cum.pb(cum.bk + (c == '1'));\n\tll ans = 0;\n\tF0R(i, N) { // end with 1\n\t\tfor (auto [a, b] : l_to_r.at(i)) {\n\t\t\tckmin(b, N - 1);\n\t\t\tans += cum.at(b + 1) - cum.at(a);\n\t\t}\n\t}\n\tdbg(l_to_r);\n\tdbg(\"ANS END WITH 1\", ans);\n\tF0R(i, N) if (S.at(i) == '0') { // begin with 1, end with 0\n\t\tfor (auto [a, b] : r_to_l.at(N - 1 - i)) {\n\t\t\tckmin(b, N - 1);\n\t\t\t// N-1-b, N-1-a\n\t\t\tans += cum.at(N - a) - cum.at(N - 1 - b);\n\t\t}\n\t}\n\tdbg(\"ANS BEGIN WITH 1, END WITH 0\", ans);\n\tconst AR<int, 3> ID{-2, -2, -2};\n\tV<AR<int, 3>> query_l, query_r;\n\tvi tot_l, tot_r;\n\tRMQ<int> zeros_starting, zeros_ending;\n\t{\n\t\tvi tmp(N);\n\t\tint cnt = 0;\n\t\tR0F(i, N) {\n\t\t\tif (S.at(i) == '0') ++cnt;\n\t\t\telse cnt = 0;\n\t\t\ttmp.at(i) = cnt;\n\t\t}\n\t\tzeros_starting.init(tmp);\n\t}\n\t{\n\t\tvi tmp(N);\n\t\tint cnt = 0;\n\t\tF0R(i, N) {\n\t\t\tif (S.at(i) == '0') ++cnt;\n\t\t\telse cnt = 0;\n\t\t\ttmp.at(i) = cnt;\n\t\t}\n\t\tzeros_ending.init(tmp);\n\t}\n\tvi cum_zero{0};\n\teach(c,S) cum_zero.pb(cum_zero.bk + (c == '0'));\n\tauto zeros_in_range = [&](int l, int r) {\n\t\treturn cum_zero.at(r+1) - cum_zero.at(l);\n\t};\n\t\n\tF0R(r, N) {\n\t\tif (S.at(r) == '1') continue;\n\t\tint l = r;\n\t\twhile (r < N && S.at(r) == '0') ++r;\n\t\t--r;\n\t\t{\n\t\t\t// l ... r\n\t\t\tint L = fstTrue(0, l - 1, [&](int x) {\n\t\t\t\treturn zeros_starting.query(x, l - 1) < r - l + 1;\n\t\t\t});\n\t\t\tint R = lstTrue(r + 1, N - 1, [&](int x) {\n\t\t\t\treturn zeros_ending.query(r + 1, x) <= r - l + 1;\n\t\t\t});\n\t\t\ttot_l.pb(zeros_in_range(L, l));\n\t\t\tquery_l.pb({L, 2 * l - r - 1, l - 1});\n\t\t\ttot_r.pb(zeros_in_range(r, R));\n\t\t\tquery_r.pb({2 * r - l + 1, R, r + 1});\n\t\t\t// count # x in [L, 2*l-r-1] such that [x, l-1] is good\n\t\t\t// count # x in [2*r-l+1, R] such that [r+1, R] is good\n\t\t\t// dbg(l, r, query_l.bk, query_r.bk);\n\t\t}\n\t\tFOR(small_r, l, r) {\n\t\t\tint L = fstTrue(0, l - 1, [&](int x) {\n\t\t\t\treturn zeros_starting.query(x, l - 1) < small_r - l + 1;\n\t\t\t});\n\t\t\ttot_l.pb(zeros_in_range(L, l));\n\t\t\tquery_l.pb({L, 2 * l - small_r - 1, l - 1});\n\t\t\ttot_r.pb(1);\n\t\t\tquery_r.pb(ID);\n\t\t\t// dbg(l, small_r, query_l.bk, query_r.bk);\n\t\t}\n\t\tFOR(small_l, l + 1, r + 1) {\n\t\t\tint R = lstTrue(r + 1, N - 1, [&](int x) {\n\t\t\t\treturn zeros_ending.query(r + 1, x) <= r - small_l + 1;\n\t\t\t});\n\t\t\ttot_l.pb(1);\n\t\t\tquery_l.pb(ID);\n\t\t\ttot_r.pb(zeros_in_range(r, R));\n\t\t\tquery_r.pb({2 * r - small_l + 1, R, r + 1});\n\t\t\tdbg(small_l, r, query_l.bk, query_r.bk);\n\t\t}\n\t}\n\tvi ans_l(sz(query_l)), ans_r(sz(query_r));\n\t{ // do query l\n\t\tV<AR<int, 4>> offline_queries;\n\t\tF0R(i, sz(query_l)) if (query_l.at(i) != ID) {\n\t\t\tauto [l, r, pos] = query_l.at(i);\n\t\t\tif (l > r) continue;\n\t\t\toffline_queries.pb({l - 1, pos, -1, i});\n\t\t\toffline_queries.pb({r, pos, 1, i});\n\t\t}\n\t\tsor(offline_queries);\n\t\t// dbg(offline_queries);\n\t\tBIT<int> B;\n\t\tB.init(N + 5);\n\t\tint nxt = 0;\n\t\tfor (auto [l, pos, mul, id] : offline_queries) {\n\t\t\tfor (; nxt <= l; ++nxt)\n\t\t\t\tif (S.at(nxt) == '0') {\n\t\t\t\t\tfor (auto [a, b] : l_to_r.at(nxt)) {\n\t\t\t\t\t\tassert(a <= b);\n\t\t\t\t\t\tB.add(a, 1);\n\t\t\t\t\t\tB.add(b + 1, -1);\n\t\t\t\t\t}\n\t\t\t\t\t// dbg(\"ANS L\", l, pos, mul, id, B.sum(pos + 1));\n\t\t\t\t}\n\t\t\tans_l.at(id) += mul * B.sum(pos + 1);\n\t\t}\n\t}\n\t{ // do_query_r\n\t\tV<AR<int, 4>> offline_queries;\n\t\tF0R(i, sz(query_r)) if (query_r.at(i) != ID) {\n\t\t\tauto [l, r, pos] = query_r.at(i);\n\t\t\tif (l > r) continue;\n\t\t\toffline_queries.pb({N - 2 - r, N - 1 - pos, -1, i});\n\t\t\toffline_queries.pb({N - 1 - l, N - 1 - pos, 1, i});\n\t\t}\n\t\tsor(offline_queries);\n\t\tBIT<int> B;\n\t\tB.init(N + 5);\n\t\tint nxt = 0;\n\t\tfor (auto [l, pos, mul, id] : offline_queries) {\n\t\t\tfor (; nxt <= l; ++nxt)\n\t\t\t\tif (S.at(N - 1 - nxt) == '0') {\n\t\t\t\t\tfor (auto [a, b] : r_to_l.at(nxt)) {\n\t\t\t\t\t\tB.add(a, 1);\n\t\t\t\t\t\tB.add(b + 1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tans_r.at(id) += mul * B.sum(pos + 1);\n\t\t}\n\t}\n\t// dbg(ans_l);\n\t// dbg(ans_r);\n\teach(t, ans_l) assert(t >= 0);\n\teach(t, ans_r) assert(t >= 0);\n\tdbg(\"ans before\", ans);\n\tF0R(i, sz(ans_l)) {\n\t\tauto bad_l = tot_l.at(i) - ans_l.at(i);\n\t\tauto bad_r = tot_r.at(i) - ans_r.at(i);\n\t\t// dbg(i, tot_l.at(i), bad_l, tot_r.at(i), bad_r);\n\t\tans += (ll)tot_l.at(i) * tot_r.at(i) - (ll)bad_l * bad_r;\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\t// rep(10000) {\n\t// \t// int N = 6;\n\t// \t// str S; rep(N) S += char('0'+(rng()&1));\n\t// \t// dbg(N, S);\n\t// \t// int N, S; re(N, S);\n\t// \tsolve(N,S);\n\t// }\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) {\n\t\tint N; str S;\n\t\tre(N,S);\n\t\tsolve(N,S);\n\t}\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dp"], "dificulty": "3500", "interactive": false}