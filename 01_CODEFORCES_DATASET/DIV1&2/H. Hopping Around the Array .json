{
    "link": "https://codeforces.com//contest/1523/problem/H",
    "problemId": "1000218",
    "problem_idx": "H",
    "shortId": "1523H",
    "contest_number": "1523",
    "problem_submissions": {
        "F": [
            117916146,
            117914065,
            117905350,
            117900425,
            117909780,
            117912951,
            117923029,
            117905457,
            117920531,
            117920496,
            117911483,
            117908634,
            117907048,
            117936734,
            117936707,
            117936638,
            117936633,
            117936625,
            117936608,
            117905940,
            117911622,
            117911227,
            117910828,
            117920430,
            117916378,
            117911950,
            117912347,
            117936103,
            117935723
        ],
        "G": [
            117899863,
            117912955,
            117908386,
            117915802,
            117906341,
            117903204,
            117907803,
            117932659,
            117932628,
            117911801,
            118597582,
            117989759,
            117915684,
            117936837,
            117918793,
            117916945,
            117917431
        ],
        "D": [
            117881477,
            117886244,
            117886334,
            117887661,
            118167966,
            117918101,
            117929591,
            117890786,
            117890676,
            117893739,
            118119250,
            117887458,
            117887290,
            117893940,
            117890382,
            118081143,
            117890914,
            117883607,
            117887959,
            117895275,
            117888883,
            117902109,
            117889374
        ],
        "E": [
            117878219,
            117881962,
            117910641,
            117881787,
            117884807,
            117893823,
            117886171,
            117885405,
            117882043,
            117890552,
            117888754,
            117897027,
            117898439,
            117887443,
            117893294,
            117903524,
            117892701,
            117896279,
            117896129
        ],
        "C": [
            117876664,
            117878149,
            117877887,
            117879093,
            117889641,
            117882853,
            117877348,
            117879069,
            117877404,
            117877723,
            117880898,
            117876222,
            117880296,
            117876946,
            117880601,
            117879874,
            117879926,
            117880242,
            117902829
        ],
        "B": [
            117875490,
            117875567,
            117880589,
            117875816,
            117876680,
            117877360,
            117875700,
            117876723,
            117878349,
            117876280,
            117877999,
            117880072,
            117876899,
            117875787,
            117877756,
            117876654,
            117875833,
            117878179,
            117879465
        ],
        "A": [
            117874746,
            117874821,
            117882081,
            117874974,
            117874835,
            117874828,
            117874778,
            117874933,
            117874911,
            117874900,
            117876005,
            117883186,
            117874918,
            117874908,
            117875902,
            117874738,
            117874753,
            117874913,
            117876371
        ],
        "H": [
            117981868,
            117981132,
            118023855,
            118349130,
            117933591,
            118312467,
            118312428,
            119224810
        ]
    },
    "name": "H. Hopping Around the Array ",
    "statement": "William really wants to get a pet. Since his childhood he dreamt about\r\ngetting a pet grasshopper. William is being very responsible about\r\nchoosing his pet, so he wants to set up a trial for the grasshopper!The\r\ntrial takes place on an array a of length n, which defines lengths of\r\nhops for each of n cells. A grasshopper can hop around the sells\r\naccording to the following rule: from a cell with index i it can jump to\r\nany cell with indices from i to i+a_i inclusive.Let\u2019s call the of some\r\narray the smallest number of hops it would take a grasshopper to hop\r\nfrom the first cell to the last, but before starting you can select no\r\nmore than k cells and remove them from the array. When a cell is removed\r\nall other cells are renumbered but the values of a_i for each cell\r\nremains the same. It is required to process q queries of the following\r\nformat: you are given three numbers l, r, k. You are required to find\r\nthe k-grasshopper value for an array, which is a subarray of the array a\r\nwith elements from l to r inclusive.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int nax=20*1007;\nconst int d=15;\nconst int kax=32;\n\nint n, q;\nint tab[nax];\nint cel[nax];\nint jump[nax][kax][kax];\nint aktu[kax][kax];\n\nint dalszy(int a, int b)\n{\n\treturn (tab[a]>tab[b] ? a : b);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t\ttab[i]=min(n, i+tab[i]);\n\t}\n\tvector<int> stos;\n\tfor (int i=n; i; i--)\n\t{\n\t\twhile(!stos.empty() && tab[i]>tab[stos.back()])\n\t\t\tstos.pop_back();\n\t\tstos.push_back(i);\n\t\tint bsa=0;\n\t\tint bsb=(int)stos.size()-1;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb)>>1;\n\t\t\tif (stos[bss]<=tab[i])\n\t\t\t\tbsb=bss;\n\t\t\telse\n\t\t\t\tbsa=bss+1;\n\t\t}\n\t\tcel[i]=stos[bsa];\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\tjump[i][0][0]=cel[i];\n\t\tfor (int j=1; j<kax; j++)\n\t\t\tjump[i][0][j]=dalszy(min(n, tab[i]+j), jump[i][0][j-1]);\n\t\tfor (int j=1; j<d; j++)\n\t\t\tfor (int l=0; l<kax; l++)\n\t\t\t\tfor (int p=0; p<=l; p++)\n\t\t\t\t\tjump[i][j][l]=dalszy(jump[i][j][l], jump[jump[i][j-1][p]][j-1][l-p]);\n\t}\n\twhile(q--)\n\t{\n\t\tint a, b, k;\n\t\tscanf(\"%d%d%d\", &a, &b, &k);\n\t\tif (a==b)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (tab[a]+k>=b)\n\t\t{\n\t\t\tprintf(\"1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint wyn=0;\n\t\tfor (int j=0; j<=k; j++)\n\t\t\taktu[d][j]=a;\n\t\tfor (int j=d-1; j>=0; j--)\n\t\t{\n\t\t\tfor (int l=0; l<=k; l++)\n\t\t\t\taktu[j][l]=a;\n\t\t\tint moge=0;\n\t\t\tfor (int l=0; l<=k; l++)\n\t\t\t{\n\t\t\t\taktu[j][l]=a;\n\t\t\t\tfor (int p=0; p<=l; p++)\n\t\t\t\t\taktu[j][l]=dalszy(aktu[j][l], jump[aktu[j+1][p]][j][l-p]);\n\t\t\t\tif (tab[aktu[j][l]]+k-l>=b)\n\t\t\t\t\tmoge=1;\n\t\t\t}\n\t\t\tif (moge)\n\t\t\t{\n\t\t\t\tfor (int l=0; l<=k; l++)\n\t\t\t\t\taktu[j][l]=aktu[j+1][l];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twyn+=(1<<j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", wyn+2);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Hopping Around the Array .json",
    "editorial_link": "https://codeforces.com//blog/entry/91271",
    "editorial": "Let\u00e2\u0080\u0099s look into all jumps in the optimal answer except the last one with\r\n. Thereafter, from the position it is most effective to jump at such\r\nposition that: and is the maximal possible. For each we can use a\r\nsegment tree for maximum to find that optimal .Let\u00e2\u0080\u0099s also notice that if\r\nwe want to jump from position having done removals of cells which\r\nindices are from to , then we want to end up in a cell , because we can\r\ndo fewer removals otherwise.These observations are sufficient for us to\r\nuse the idea of dynamic programming. Let store the maximal pair in which\r\nwe can end up jumping from position , having performed jumps and removed\r\nnot greater than cells. With we can initialize the dynamic with optimal\r\n. Now we will iterate over , and in increasing order and see how to\r\nrecalculate the dynamic. Let\u00e2\u0080\u0099s iterate over the number of removals for\r\nthe first jumps. Then, using the value we know in which position we\r\nstopped. Now we need to perform jumps from that position having done not\r\ngreater than removals.Additionally, let\u00e2\u0080\u0099s make another dynamic stores\r\nsuch maximal position of initial array in which we can end up jumping\r\nfrom position , having performed jumps and removed not greater than\r\ncells. Just like for the previous dynamic we can initialize it using ,\r\nand then similarly recalculate the value of the dynamic, but using two\r\ndynamics this time and .It is noteworthy that both dynamics need it to\r\nbe supposed that when we start in element we do not remove it.Let\u00e2\u0080\u0099s see\r\nhow we can answer the query using the calculated dynamics. To begin\r\nwith, let\u00e2\u0080\u0099s consider particular cases. If , then the answer is equal to\r\n. If , then the answer is equal to . Farther on, let\u00e2\u0080\u0099s make one more\r\ndynamic , in which we will maintain three numbers . With that the first\r\nnumber is the number of jumps (we minimize it), two following numbers\r\ndeclare our current position , and we maximize these two numbers as a\r\npair . Using that dynamic we wish to end up in the last but one cell of\r\nthe optimal way, having removed not greater than cells. Initially, the\r\nvalues of dynamic are equal to . Let\u00e2\u0080\u0099s iterate over in decreasing order\r\n(which is to say, we iterate over the jumps). Let\u00e2\u0080\u0099s create a dynamic ,\r\nwhich we are going to recalculate on the current step, and then make (in\r\nother words, we recalculate the dynamic ). Let\u00e2\u0080\u0099s iterate over the number\r\nof removals during the preceding steps and the number of removals we are\r\ngoing to do on the current step. Using the value we know in which\r\nposition we stopped, and with dynamic we can check if we cannot overjump\r\n(or end up in it) having performed jumps. If we cannot overjump , then\r\nwe will try to update the value , otherwise, it\u00e2\u0080\u0099s not profitable to\r\nperform the jump and thus let\u00e2\u0080\u0099s update .As a result, we have the\r\ncalculated dynamic . Let\u00e2\u0080\u0099s iterate over it and find -s such that we can\r\njump to with one jump and take the minimal answer over these -s (don\u00e2\u0080\u0099t\r\nforget to add , since we jumped to the last by one cell in the\r\ndynamic).We calculate the dynamics in , answer the query in , thus the\r\nsolution is in .\r\n"
}