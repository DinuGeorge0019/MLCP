{
    "link": "https://codeforces.com//contest/757/problem/G",
    "problemId": "88534",
    "problem_idx": "G",
    "shortId": "757G",
    "contest_number": "757",
    "problem_submissions": {
        "F": [
            32228238,
            32220657,
            32216667,
            32216552,
            30180757,
            24068926,
            24068888,
            24068798,
            24068629,
            24068020,
            23762892,
            23760952,
            23776891,
            23764568,
            23762696,
            23763271,
            23761197,
            23764419,
            23761836,
            23846483,
            23765505,
            23762407,
            23766587,
            23766646,
            23767253,
            23767207,
            23767008,
            23767913,
            23761400
        ],
        "G": [
            23782048,
            23772049,
            23771661,
            23771463
        ],
        "D": [
            23749937,
            23749579,
            23748811,
            23749322,
            23755716,
            23754682,
            23757768,
            23754805,
            23755156,
            23752956,
            23758947,
            23752935,
            23758202,
            23754949,
            23757044,
            23760439,
            23761231,
            23760141,
            23748525
        ],
        "C": [
            23747486,
            23744300,
            23743556,
            23745034,
            23746542,
            23748856,
            23755316,
            23748726,
            23749207,
            23747491,
            23752146,
            23747894,
            23750245,
            23746080,
            23751561,
            23747227,
            23747661,
            23744168
        ],
        "E": [
            23746626,
            23754640,
            23751784,
            23751547,
            23750068,
            23759139,
            23752714,
            23760482,
            23759055,
            23761627,
            23755834,
            23761719,
            23760932,
            23763128,
            23759765,
            23757483,
            23764011,
            23741658,
            23752894
        ],
        "B": [
            23740589,
            23741483,
            23740480,
            23740520,
            23742781,
            23741337,
            23746337,
            23742823,
            23741509,
            23741548,
            23745601,
            23743745,
            23742092,
            23740912,
            23741886,
            23742317,
            23743047,
            23746203,
            23741743
        ],
        "A": [
            23740335,
            23739759,
            23739764,
            23739789,
            23739801,
            23739786,
            23739911,
            23740392,
            23739871,
            23740001,
            23740128,
            23739744,
            23740216,
            23765002,
            23754212,
            23766705,
            23742440,
            23748544,
            23739773
        ]
    },
    "name": "G. Can Bash Save the Day ",
    "statement": "Whoa! You did a great job helping Team Rocket who managed to capture all\r\nthe Pokemons sent by Bash. Meowth, part of Team Rocket, having already\r\nmastered the human language, now wants to become a master in programming\r\nas well. He agrees to free the Pokemons if Bash can answer his\r\nquestions.Initially, Meowth gives Bash a weighted tree containing nodes\r\nand a sequence which is a permutation of . Now, Mewoth makes queries of\r\none of the following forms: : meaning Bash should report , where is the\r\nlength of the shortest path from node to node in the given tree. :\r\nmeaning Bash should swap and in the given sequence. This new sequence is\r\nused for later queries. Help Bash to answer the questions!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long inf = (long long) 1e18;\n\nconst int N = 400010;\n\nvector < pair <int, long long> > forc[N];\nvector < pair <int, long long> > centroid[N];\nlong long dist[N];\nlong long last_dist[N];\nint sub[N];\nbool alive[N];\nvector < pair <int, int> > g[N];\nint perm[N], pos[N];\nint v_goes_to[N];\nvector <int> all;\nvector <int> in_forc[N];\n\nvoid dfs(int v, int pr) {\n  all.push_back(v);\n  sub[v] = 1;\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (!alive[u] || u == pr) {\n      continue;\n    }\n    int len = g[v][j].second;\n    dist[u] = dist[v] + len;\n    dfs(u, v);\n    sub[v] += sub[u];\n  }\n}\n\nvoid build(int v) {\n  all.clear();\n  dfs(v, -1);\n  {\n    // changing the root\n    int old_v = v;\n    int total = sub[v];\n    int pr = -1;\n    while (true) {\n      bool found = false;\n      int sz = g[v].size();\n      for (int j = 0; j < sz; j++) {\n        int u = g[v][j].first;\n        if (!alive[u] || u == pr) {\n          continue;\n        }\n        if (2 * sub[u] >= total) {\n          pr = v;\n          v = u;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        break;\n      }\n    }\n    v_goes_to[old_v] = v;\n  }\n  all.clear();\n  dist[v] = 0;\n  dfs(v, -1);\n  int cnt = all.size();\n  for (int i = 0; i < cnt; i++) {\n    int u = all[i];\n    centroid[u].push_back(make_pair(v, dist[u]));\n  }\n  for (int i = 0; i < cnt; i++) {\n    int u = all[i];\n    forc[v].push_back(make_pair(pos[u], dist[u] - last_dist[u]));\n    last_dist[u] = dist[u];\n  }\n  sort(forc[v].begin(), forc[v].end());\n  for (int j = 1; j < cnt; j++) {\n    forc[v][j].second += forc[v][j - 1].second;\n  }\n  for (int i = 0; i < cnt; i++) {\n    int u = perm[forc[v][i].first];\n    in_forc[u].push_back(i);\n  }\n  vector <int> children;\n  for (int i = 0; i < (int) g[v].size(); i++) {\n    int u = g[v][i].first;\n    if (alive[u]) {\n      children.push_back(u);\n    }\n  }\n  alive[v] = false;\n  for (int i = 0; i < (int) children.size(); i++) {\n    build(children[i]);\n  }\n}\n\nint main() {\n  int n, tt;\n  scanf(\"%d %d\", &n, &tt);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", perm + i);\n    perm[i]--;\n    pos[perm[i]] = i;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, z;\n    scanf(\"%d %d %d\", &x, &y, &z);\n    x--; y--;\n    g[x].push_back(make_pair(y, z));\n    g[y].push_back(make_pair(x, z));\n  }\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n  }\n  build(0);\n  int last = 0;\n  while (tt--) {\n    int com;\n    scanf(\"%d\", &com);\n    if (com == 1) {\n      int from, to, ver;\n      scanf(\"%d %d %d\", &from, &to, &ver);\n      from ^= last;\n      to ^= last;\n      ver ^= last;\n      from--; to--; ver--;\n      long long ans = 0;\n      long long prev_d = 0;\n      for (pair <int, long long> p : centroid[ver]) {\n        int v = p.first;\n        long long d = p.second;\n        long long sumd = 0;\n        int cnt = 0;\n        {\n          int pf = lower_bound(forc[v].begin(), forc[v].end(), make_pair(from, -inf)) - forc[v].begin();\n          int pt = lower_bound(forc[v].begin(), forc[v].end(), make_pair(to + 1, -inf)) - forc[v].begin();\n          if (pf < pt) {\n            sumd += forc[v][pt - 1].second;\n            if (pf > 0) {\n              sumd -= forc[v][pf - 1].second;\n            }\n            cnt += pt - pf;\n          }\n        }\n        ans += sumd + cnt * (d - prev_d);\n        prev_d = d;\n      }\n      printf(\"%I64d\\n\", ans);\n      last = ans & ((1 << 30) - 1);\n    } else {\n      int x;\n      scanf(\"%d\", &x);\n      x ^= last;\n      x--;\n      int v1 = perm[x];\n      int v2 = perm[x + 1];\n      int c1 = centroid[v1].size();\n      int c2 = centroid[v2].size();\n      int i1 = 0;\n      int i2 = 0;\n      long long prev_d2 = 0;\n      while (i1 < c1 && i2 < c2 && centroid[v1][i1].first == centroid[v2][i2].first) {\n        int v = centroid[v1][i1].first;\n        long long d2 = centroid[v2][i2].second;\n        {\n          int at = in_forc[v1][i1];\n          forc[v][at].second = (at == 0 ? 0LL : forc[v][at - 1].second) + d2 - prev_d2;\n          swap(in_forc[v1][i1], in_forc[v2][i2]);\n        }\n        prev_d2 = d2;\n        i1++; i2++;\n      }\n      for (int rot = 0; rot < 2; rot++) {\n        while (i1 < c1) {\n          int v = centroid[v1][i1].first;\n          {\n            int at = in_forc[v1][i1];\n            forc[v][at].first = pos[v2];\n          }\n          i1++;\n        }\n        swap(v1, v2);\n        swap(c1, c2);\n        swap(i1, i2);\n      }\n      swap(perm[x], perm[x + 1]);\n      pos[perm[x]] = x;\n      pos[perm[x + 1]] = x + 1;\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "graphs",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Can Bash Save the Day .json",
    "editorial_link": "https://codeforces.com//blog/entry/49743",
    "editorial": "Main idea: Making the Centroid Tree Persistent.\n\nSimpler Problem\nFirst let's try to solve a much simpler problem given as follows.\n\nQuestion: Given a weighted tree, initially all the nodes of the given tree are inactive. We need to support the following operations fast :\nQuery v : Report the sum of distances of all active nodes from node v in the given tree.\nActivate v : Mark node v to be an active node.\n\nSolution: The above problem can be easily solved by a fairly standard technique called Centroid Decomposition. You can read more about here\n\nSolution Idea\nEach query of the form (L R v) can be divided into two queries of form (1 R v) ?-? (1 L?-?1 v). Hence it is sufficient if we can support the following query: (i v) : Report the answer to query (1 i v)\nTo answer a single query of the form (i v) we can think of it as what is the sum of distance of all active nodes from node v, if we consider the first i nodes to be active.\nHence initially if we can preprocess the tree such that we activate nodes from 1 to n and after each update, store a copy of the centroid tree, then for each query (i v) we can lookup the centroid tree corresponding to i, which would have the first i nodes activated, and query for node v in  time by looking at itÂ’s ancestors.\nTo store a copy of the centroid tree for each i, we need to make it persistent.\nPersistent Centroid Tree : Key Ideas\nImportant thing to note is that single update in the centroid tree affects only the ancestors of the node in the tree.\nSince height of the centroid tree is , each update affects only  other nodes in the centroid tree.\nThe idea is very similar to that of a persistent segment tree BUT unlike segtree, here each node of the centroid tree can have arbitrarily many children and hence simply creating a new copy of the affected nodes would not work because linking them to the children of old copy would take  for each affected node and this number could be as large as N, hence it could take  time in total !\nBinarizing the Input Tree\nTo overcome the issue, we convert the given tree T into an equivalent binary tree T' by adding extra dummy nodes such that degree of each node in the transformed tree T' is ?<??=?3, and the number of dummy nodes added is bounded by .\nThe dummy nodes are added such that the structure of the tree is preserved and weights of the edges added are set to 0.\nTo do this, consider a node x with degree d?>?3 and let c1,?c2...cd be it's adjacent nodes. Add a new node y and change the edges as follows :\nDelete the edges (x?-?c3), (x?-?c4) ... (x?-?cd) and add the edge (x?-?y) such that degree of node x reduces to 3 from d.\nAdd edges (y?-?c3), (y?-?c4) ... (y?-?cd) such that degree of node y is d?-?1. Recursively call the procedure on node y.\nSince degree of node y is d?-?1 instead of original degree d of node x, it can be proved that we need to add at most  new nodes before degree of each node in the tree is ?<??=?3.\nConclusion\nHence we perform centroid decomposition of this transformed tree T'. The centroid tree formed would have the following properties.\n\nThe height of the centroid tree is \nEach node in the centroid tree has ???3 children.\nNow we can easily make this tree persistent by path-copying approach.\nTo handle the updates,\n\nWay-1 : Observe that swapping A[i] and A[i?+?1] would affect only the i'th persistent centroid tree, which can be rebuilt from the tree of i?-?1 by a single update query. In this approach, for each update we add  new nodes. See author's code below for more details.\nWay-2 : First we go down to the lca of A[x] and A[x?+?1] in the x'th persistent tree, updating the values as we go. Now, let cl be the child of lca which is an ancestor of A[x], and let cr be the child which is an ancestor of A[x?+?1]. Now, we replace cr of x'th persistent tree with cr of (x?+?1)'th persistent tree. Similarly, we replace cl of x?+?1'th persistent tree with cl of x'th persistent tree. So now A[x?+?1] is active in x'th persistent tree and both A[x] and A[x?+?1] are active in (x?+?1)'th persistent tree.To deactivate A[x] in x'th persistent tree we replace cl of x'th persistent tree with cl of (x?-?1)'th persistent tree. Hence in this approach we do not need to create new  nodes for each update. See testers's code below for more details.",
    "hint": []
}