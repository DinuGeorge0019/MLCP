{
    "link": "https://codeforces.com//contest/653/problem/B",
    "problemId": "52167",
    "problem_idx": "B",
    "shortId": "653B",
    "contest_number": "653",
    "problem_submissions": {
        "D": [
            16882408,
            16811537,
            16810665,
            16808469,
            16808880,
            16810169,
            16810193,
            16817835,
            16817684,
            16809816,
            16810008,
            16809541,
            16810009,
            16809483,
            16815488,
            16815467,
            16809743,
            16815857,
            16810399,
            16830307,
            16830297,
            16830295,
            16809555
        ],
        "C": [
            16814329,
            16808201,
            16807277,
            16809824,
            16809484,
            16809237,
            16808970,
            16808978,
            16808649,
            16810747,
            16824380,
            16810982,
            16808580,
            16808306,
            16809772,
            16808759,
            16815412,
            16808885,
            16810588
        ],
        "F": [
            16813454,
            16812764,
            16813359,
            16811313,
            16812655,
            16813981,
            16813203,
            16812204,
            16812853,
            16813207,
            16813077,
            16811759,
            16813557,
            16817070,
            16813698,
            16812540,
            16812526
        ],
        "E": [
            16812212,
            16809858,
            16810442,
            16814020,
            16811168,
            16811817,
            16811727,
            16814449,
            16814876,
            16813977,
            16814689,
            16810991,
            16810903,
            16815613,
            16810612,
            16812105,
            16811842
        ],
        "B": [
            16811122,
            16806823,
            16808941,
            16806712,
            16806895,
            16807172,
            16806271,
            16807190,
            16807288,
            16809090,
            16808193,
            16806845,
            16806473,
            16807895,
            16806798,
            16807486,
            16808397,
            16806933
        ],
        "A": [
            16810886,
            16805361,
            16805416,
            16805408,
            16805395,
            16805730,
            16805338,
            16805605,
            16805967,
            16806396,
            16807313,
            16805370,
            16805342,
            16805498,
            16805369,
            16805701,
            16806883,
            16805397
        ],
        "G": [
            16810637,
            16830434,
            16849997,
            16871778,
            16820127,
            16813576,
            16863345,
            16813594,
            16830285
        ]
    },
    "name": "B. Bear and Compressing",
    "statement": "Limak is a little polar bear. Polar bears hate long strings and thus\r\nthey like to compress them. You should also know that Limak is so young\r\nthat he knows only first six letters of the English alphabet: \u201d, \u201d, \u201d,\r\n\u201d, \u201d and \u201d.You are given a set of possible operations. Limak can perform\r\nthem in any order, any operation may be applied any number of times. The\r\n-th operation is described by a string of length two and a string of\r\nlength one. No two of possible operations have the same string .When\r\nLimak has a string he can perform the -th operation on if the first two\r\nletters of match a two-letter string . Performing the -th operation\r\nremoves first two letters of and inserts there a string . See the notes\r\nsection for further clarification.You may note that performing an\r\noperation decreases the length of a string exactly by . Also, for some\r\nsets of operations there may be a string that cannot be compressed any\r\nfurther, because the first two letters don\u2019t match any .Limak wants to\r\nstart with a string of length and perform operations to finally get a\r\none-letter string \"\". In how many ways can he choose the starting string\r\nto be able to get \"\"? Remember that Limak can use only letters he knows.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,q,ans,tran[10][10],dp[10][10];\nchar s[20],t[20];\nint main() {\n\tscanf(\"%d%d\",&n,&q);\n\trep(i,0,q) {\n\t\tscanf(\"%s%s\",s,t);\n\t\ttran[t[0]-'a'][s[0]-'a']++;\n\t}\n\tdp[0][0]=1;\n\trep(i,0,n) {\n\t\trep(j,0,6) rep(k,0,6) dp[i+1][k]+=dp[i][j]*tran[j][k];\n\t}\n\trep(j,0,6) ans+=dp[n-1][j];\n\tprintf(\"%d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Bear and Compressing.json",
    "editorial_link": "https://codeforces.com//blog/entry/43886",
    "editorial": "you should generate all 6n possible starting strings and for each of them check whether you will get \"a\" at the end. Remember that you should check two first letters, not last ones (there were many questions about it)."
}