{
    "link": "https://codeforces.com//contest/1586/problem/D",
    "problemId": "1147384",
    "problem_idx": "D",
    "shortId": "1586D",
    "contest_number": "1586",
    "problem_submissions": {
        "I": [
            132349267,
            132252923,
            132320064,
            132673395,
            132289506,
            132263256
        ],
        "H": [
            132247560,
            132253721,
            134930470,
            132350321,
            132254025,
            132660661,
            132275048,
            132253966,
            132270155
        ],
        "G": [
            132239647,
            132244340,
            132241119,
            135794866,
            135794713,
            132234650,
            132248115,
            132244256,
            132257761,
            132255193,
            132256199,
            132255919,
            132258648,
            132257515,
            132250742,
            132255333,
            132257553,
            132255311
        ],
        "F": [
            132231955,
            132236161,
            132234366,
            132240633,
            132243967,
            132235859,
            132234337,
            132237395,
            132239493,
            132241376,
            132248866,
            132245654,
            132241416,
            132246161,
            132245018,
            132259456,
            132244979,
            132249686,
            132260019,
            132238761
        ],
        "E": [
            132228491,
            132224206,
            132228693,
            132232413,
            132231532,
            132229745,
            132230672,
            132232315,
            132218494,
            132235319,
            132232020,
            132237413,
            132239524,
            132237023,
            132236410,
            132236319,
            132238669,
            132240928,
            132230421,
            132229492
        ],
        "D": [
            132225001,
            132227375,
            132224444,
            132226879,
            132227724,
            132226231,
            132226626,
            132227371,
            132224235,
            132227654,
            132224635,
            132229641,
            132234990,
            132231067,
            132230536,
            132228432,
            132234258,
            132232998,
            132241147,
            132223955
        ],
        "C": [
            132221243,
            132218519,
            132219460,
            132219748,
            132219799,
            132222571,
            132220819,
            132219850,
            132232802,
            132223481,
            132218757,
            132219927,
            132230956,
            132218216,
            132224263,
            132222192,
            132227273,
            132228072,
            132226595,
            132220025
        ],
        "B": [
            132214722,
            132213701,
            132215490,
            132214516,
            132214317,
            132214601,
            132215162,
            132222197,
            132229955,
            132216968,
            132214347,
            132216468,
            132226751,
            132220812,
            132216772,
            132216742,
            132216324,
            132213579,
            132217316,
            132213929
        ],
        "A": [
            132213139,
            132213078,
            132214020,
            132213141,
            132213243,
            132213267,
            132213377,
            132220659,
            132228179,
            132218691,
            132213234,
            132214356,
            132213033,
            132224973,
            132214120,
            132214349,
            132213337,
            132213011,
            132242338,
            132213128
        ]
    },
    "name": "D. Omkar and the Meaning of Life",
    "statement": "It turns out that the meaning of life is a permutation p_1, p_2,\r\nldots, p_n of the integers 1, 2,\r\nldots, n (2\r\nleq n\r\nleq 100). Omkar, having created all life, knows this permutation, and\r\nwill allow you to figure it out using some queries.A query consists of\r\nan array a_1, a_2,\r\nldots, a_n of integers between 1 and n. a is required to be a\r\npermutation. Omkar will first compute the pairwise sum of a and p,\r\nmeaning that he will compute an array s where s_j = p_j + a_j for all j\r\n= 1, 2,\r\nldots, n. Then, he will find the smallest index k such that s_k occurs\r\nmore than once in s, and answer with k. If there is no such index k,\r\nthen he will answer with 0.You can perform at most 2n queries. Figure\r\nout the meaning of life p.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, perm[105], nxt[105], pre[105];\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n) {\n\t\tprintf(\"?\"); rep1(j, n) printf(\" %d\", j == i ? 2 : 1); printf(\"\\n\"); fflush(stdout);\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif(x != i) nxt[i] = x;\n\t}\n\trep1(i, n) {\n\t\tprintf(\"?\"); rep1(j, n) printf(\" %d\", j == i ? 1 : 2); printf(\"\\n\"); fflush(stdout);\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif(x != i) nxt[x] = i;\n\t}\n\t\n\trep1(i, n) pre[nxt[i]] = i;\n\trep1(i, n) if(pre[i] == 0) {\n\t\trep1(j, n) {\n\t\t\tperm[i] = j; i = nxt[i];\n\t\t}\n\t\tbreak;\n\t}\n\tprintf(\"! \"); rep1(i, n) printf(\"%d \", perm[i]); fflush(stdout);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "interactive",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Omkar and the Meaning of Life.json",
    "editorial_link": "https://codeforces.com//blog/entry/96072",
    "editorial": "We will determine for each , the index such that . For each index ,\r\nperform a query with all s except that . If the result exists, then we\r\nshould set .Also, for each index , perform a query with all s except\r\nthat . If the result exists, then we should set .For each such that ,\r\neither , in which case the first set of queries will find , or , in\r\nwhich case the second set of queries will find . Therefore we will fully\r\ndetermine the array .To compute , note that the index such that will not\r\nappear in the array . Therefore, find this , and set . Then set to , and\r\nset , and so on.The total number of queries used is , which is exactly\r\nthe limit.We will first determine for all .For each value of from to\r\n(these are the only possible values of ), if is nonnegative, then make a\r\nquery where all of is except that ; otherwise, make a query where all of\r\nis except that . If the result exists, then .Note that there is at most\r\none such that for each , so we will fully determine this way (obviously\r\nwe need to manually set ). is then equal to the number of such that .\r\nUsing this, we can determine the rest of as .The total number of queries\r\nused is , which is below the limit.Bonus question: Optimize this\r\nsolution to use queries.\r\n"
}