{"link": "https://codeforces.com//contest/1684/problem/D", "problemId": "1404374", "problem_idx": "D", "shortId": "1684D", "contest_number": "1684", "problem_submissions": {"H": [157720671, 157721062, 157737875, 157719283, 157728267, 157723148, 157726010, 157736069, 157792151, 157760208, 157735749, 157733310, 157739555, 157762123, 157758402, 157757414], "G": [157708800, 157705200, 157707312, 157718616, 157706754, 157714488, 157707640, 157712978, 157718288, 157710983, 157717212, 157716133, 157711996, 157713632, 157715613, 157714692, 157708417, 157712457, 157717126], "F": [157703000, 157698430, 157700853, 157708707, 157699813, 157705688, 157700819, 157704615, 157713662, 157705196, 157701872, 157704273, 157706345, 157707380, 157707253, 157706734, 157720973, 157723693, 157711135], "E": [157687824, 157689230, 157686803, 157694670, 157693301, 157693626, 157692297, 157688860, 157691406, 157698450, 157692770, 157697303, 157697857, 157695549, 157699844, 157698604, 157694457, 157697019, 157700499], "D": [157681158, 157683410, 157690778, 157683407, 157688074, 157688564, 157683855, 157682485, 157678956, 157684552, 157688505, 157689349, 157690936, 157696580, 157687171, 157693792, 157688577, 157691760, 157692016], "C": [157676125, 157679761, 157680827, 157678864, 157733908, 157680852, 157679175, 157675870, 157680982, 157722992, 157680866, 157688681, 157680491, 157680374, 157689989, 157710336, 157680413, 157683798], "B": [157669712, 157671031, 157673644, 157673851, 157673406, 157672145, 157673363, 157673187, 157671551, 157673379, 157675976, 157675416, 157675741, 157672916, 157673228, 157675698, 157678091, 157671319, 157673490], "A": [157669088, 157669275, 157669176, 157669141, 157669362, 157669203, 157669522, 157669224, 157669098, 157669297, 157671508, 157669642, 157676097, 157669933, 157669278, 157670146, 157669180, 157669153, 157669255]}, "name": "D. Traps", "statement": "There are n traps numbered from 1 to n. You will go through them one by\r\none in order. The i-th trap deals a_i base damage to you.Instead of\r\ngoing through a trap, you can jump it over. You can jump over no more\r\nthan k traps. If you jump over a trap, it does not deal any damage to\r\nyou. But there is an additional rule: if you jump over a trap, all next\r\ntraps damages increase by 1 (this is a bonus damage).Note that if you\r\njump over a trap, you don\u2019t get any damage (neither base damage nor\r\nbonus damage). Also, the bonus damage stacks so, for example, if you go\r\nthrough a trap i with base damage a_i, and you have already jumped over\r\n3 traps, you get (a_i + 3) damage.You have to find the minimal damage\r\nthat it is possible to get if you are allowed to jump over no more than\r\nk traps.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 19.05.2022 18:46:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> order(n);\n    iota(order.begin(), order.end(), 0);\n    sort(order.begin(), order.end(), [&](int i, int j) {\n      return a[i] + i > a[j] + j;\n    });\n    vector<bool> skip(n, false);\n    for (int i = 0; i < k; i++) {\n      skip[order[i]] = true;\n    }\n    int bonus = 0;\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n      if (skip[i]) {\n        bonus += 1;\n      } else {\n        ans += a[i] + bonus;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings"], "dificulty": "1700", "interactive": false}