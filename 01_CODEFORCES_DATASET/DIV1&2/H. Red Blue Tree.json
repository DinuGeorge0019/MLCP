{"link": "https://codeforces.com//contest/1208/problem/H", "problemId": "395883", "problem_idx": "H", "shortId": "1208H", "contest_number": "1208", "problem_submissions": {"H": [59484058, 59502734, 76052313], "G": [59465495, 59473655, 59462360, 59469582, 59476496, 59467194, 59474332, 59471219, 59476758, 59478641, 59474463, 59471571, 59487164, 59486904, 59486576, 59482130, 59477683, 59476449, 59473994, 59479017, 59477708, 59480546], "F": [59463879, 59465198, 59467560, 59476238, 59468730, 59478991, 59464681, 59477905, 59488265, 59473195, 59472737, 59472853, 59477583, 59487223, 59467058, 59472365, 59474724, 59482091, 59473763, 59474219, 59475026], "E": [59458500, 59460001, 59471123, 59460976, 59465221, 59464240, 59471956, 59467792, 59468080, 59468210, 59467089, 59468111, 59463881, 59468884, 59466520, 59466354, 59469354, 59470023, 59470503], "C": [59454101, 59453008, 59450929, 59452783, 59454696, 59455218, 59454973, 59451236, 59458825, 59456015, 59453250, 59456008, 59453716, 59453732, 59453888, 59456639, 59456258, 59457694, 59458473], "D": [59453338, 59455109, 59457439, 59466058, 59460513, 59457371, 59457830, 59458661, 59462381, 59461784, 59460829, 59462458, 59456674, 59462814, 59457263, 59459344, 59458893, 59462907, 59461567], "B": [59451380, 59451457, 59455342, 59451327, 59452833, 59452235, 59452686, 59455049, 59452214, 59453318, 59450989, 59453232, 59451916, 59457683, 59451681, 59453837, 59452400, 59452282, 59455051], "A": [59449116, 59449294, 59449254, 59449364, 59450306, 59449785, 59449160, 59452256, 59449743, 59449309, 59449227, 59449840, 59449173, 59458690, 59449209, 59449159, 59450221, 59449398, 59450162]}, "name": "H. Red Blue Tree", "statement": "You are given a tree of n nodes. The tree is rooted at node 1, which is\r\nnot considered as a leaf regardless of its degree.Each leaf of the tree\r\nhas one of the two colors: or . Leaf node v initially has color\r\ns_{v}.The color of each of the internal nodes (including the root) is\r\ndetermined as follows. Let b be the number of immediate children, and r\r\nbe the number of immediate children of a given vertex. Then the color of\r\nthis vertex is if and only if b - r\r\nge k, otherwise . Integer k is a parameter that is same for all the\r\nnodes.You need to handle the following types of queries: : print the\r\ncolor of node v; : change the color of leaf v to c (c = 0 means red, c =\r\n1 means blue); : update the current value of k to h.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 25.08.2019 18:50:27       \n**/\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nconst int N = 100010;\n\nint from_leaves[N];\nint from_others[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> color(n);\n  for (int i = 0; i < n; i++) {\n    cin >> color[i];\n  }\n  vector<int> order;\n  vector<int> pos(n, -1);\n  vector<int> endd(n, -1);\n  vector<bool> is_leaf(n, false);\n  vector<int> map_to(n);\n  vector<int> deg(n);\n  vector<int> parent(n, -1);\n  iota(map_to.begin(), map_to.end(), 0);\n  function<void(int, int)> Dfs = [&](int v, int pv) {\n    parent[v] = pv;\n    deg[v] = (int) g[v].size() - (pv != -1);\n    if (pv != -1 && deg[v] == 1 && deg[pv] == 1) {\n      map_to[v] = map_to[pv];\n      for (int u : g[v]) {\n        if (u == pv) {\n          continue;\n        }\n        Dfs(u, v);\n      }\n      return;\n    }\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    for (int u : g[v]) {\n      if (u == pv) {\n        continue;\n      }\n      Dfs(u, v);\n    }\n    endd[v] = (int) order.size() - 1;\n    if (deg[v] == 0) {\n      is_leaf[v] = true;\n      order.pop_back();\n      pos[v] = endd[v] = -1;\n    }\n  };\n  Dfs(0, -1);\n  int cnt = (int) order.size();\n  memset(from_leaves, 0, sizeof(int) * cnt);\n  memset(from_others, 0, sizeof(int) * cnt);\n  for (int i = 0; i < n; i++) {\n    if (is_leaf[i]) {\n      from_leaves[pos[map_to[parent[i]]]] += (color[i] == 1 ? 1 : -1);\n    }\n  }\n  vector<int> go_to(cnt);\n  for (int i = 1; i < cnt; i++) {\n    go_to[i] = pos[map_to[parent[order[i]]]];\n  }\n  int tt;\n  cin >> tt;\n  vector<int> op(tt), ver(tt), val(tt), res(tt, -1);\n  for (int i = 0; i < tt; i++) {\n    cin >> op[i];\n    if (op[i] == 1) {\n      cin >> ver[i];\n      --ver[i];\n    }\n    if (op[i] == 2) {\n      cin >> ver[i] >> val[i];\n      --ver[i];\n    }\n    if (op[i] == 3) {\n      cin >> val[i];\n    }\n  }\n  map<int, int> mp;\n  int beg = 0;\n  while (beg < tt) {\n    int end = beg;\n    while (end + 1 < tt && op[end + 1] == op[end]) {\n      ++end;\n    }\n    if (op[beg] == 1) {\n      mp.clear();\n      for (int i = beg; i <= end; i++) {\n        int v = ver[i];\n        if (!is_leaf[v]) {\n          v = map_to[v];\n          from_others[pos[v]] = 0;\n          mp[pos[v] + 1] += 1;\n          mp[endd[v] + 1] -= 1;\n        }\n      }\n      vector<pair<int, int>> segs;\n      int balance = 0;\n      int start = -1;\n      for (auto& p : mp) {\n        if (p.second == 0) {\n          continue;\n        }\n        if (balance == 0) {\n          start = p.first;\n        }\n        balance += p.second;\n        if (balance == 0) {\n          segs.emplace_back(start, p.first - 1);\n          start = -1;\n        }\n      }\n      for (auto& p : segs) {\n        int from = p.first;\n        int to = p.second;\n        memset(from_others + from, 0, sizeof(int) * (to - from + 1));\n        for (int i = to; i >= from; i--) {\n          from_others[go_to[i]] += (from_others[i] + from_leaves[i] >= k ? 1 : -1);\n        }\n      }\n      for (int i = beg; i <= end; i++) {\n        int v = ver[i];\n        if (is_leaf[v]) {\n          res[i] = color[v];\n        } else {\n          v = map_to[v];\n          res[i] = (from_others[pos[v]] + from_leaves[pos[v]] >= k);\n        }\n      }\n    }\n    if (op[beg] == 2) {\n      for (int i = beg; i <= end; i++) {\n        int v = ver[i];\n        from_leaves[pos[map_to[parent[v]]]] -= (color[v] == 1 ? 1 : -1);\n        color[v] = val[i];\n        from_leaves[pos[map_to[parent[v]]]] += (color[v] == 1 ? 1 : -1);\n      }\n    }\n    if (op[beg] == 3) {\n      k = val[end];\n    }\n    beg = end + 1;\n  }\n  for (int i = 0; i < tt; i++) {\n    if (op[i] == 1) {\n      cout << res[i] << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "implementation", "trees"], "dificulty": "3500", "interactive": false}