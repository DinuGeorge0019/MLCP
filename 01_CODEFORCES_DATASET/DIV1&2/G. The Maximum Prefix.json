{
    "link": "https://codeforces.com//contest/1810/problem/G",
    "problemId": "1858192",
    "problem_idx": "G",
    "shortId": "1810G",
    "contest_number": "1810",
    "problem_submissions": {
        "H": [
            200016390,
            200313241,
            200015282,
            200812601,
            200812580
        ],
        "G": [
            199990963,
            200002014,
            199996533,
            200001110,
            200003038,
            200004181,
            200005432,
            199993820,
            200004120,
            200568360,
            200010476,
            200003987,
            200009790,
            200084069,
            200013246,
            200017198,
            200016482,
            200017082
        ],
        "F": [
            199985968,
            199984766,
            199989455,
            199989236,
            199990364,
            199996618,
            199996912,
            199994977,
            200012837,
            199994874,
            200568272,
            200001624,
            200000551,
            200004906,
            200000508,
            200003276,
            200003731,
            200007640,
            199989234,
            200033060,
            200032756,
            200032417,
            199995728
        ],
        "E": [
            199973604,
            199973630,
            199978803,
            199976534,
            199977412,
            199980989,
            199981737,
            199978795,
            199980030,
            199987523,
            200568220,
            199981333,
            199992052,
            199984164,
            199985692,
            199981426,
            199983733,
            199981446,
            199972392,
            199985691
        ],
        "D": [
            199968387,
            199968634,
            199971474,
            199971965,
            199971391,
            199974445,
            199974261,
            199971649,
            199972646,
            199975130,
            200568168,
            199974978,
            199975450,
            199972122,
            199977461,
            199974856,
            199972685,
            199972896,
            199981843,
            199971530
        ],
        "C": [
            199963369,
            199964848,
            199966060,
            199965953,
            199966410,
            199967396,
            199960693,
            199966704,
            199968525,
            199967275,
            200567509,
            199968793,
            199967659,
            199965932,
            199965761,
            199966489,
            199966901,
            199965471,
            199965927,
            199965128
        ],
        "B": [
            199960187,
            199959404,
            199963381,
            199961597,
            199960246,
            199963356,
            199965608,
            199963400,
            199964087,
            199961201,
            200567461,
            199963792,
            199967959,
            199962648,
            199961478,
            199962690,
            199964055,
            199962786,
            199961957,
            199961076
        ],
        "A": [
            199957585,
            199957600,
            199957721,
            199957828,
            199957624,
            199957823,
            199967044,
            199957994,
            199959433,
            199957593,
            200567421,
            199957914,
            199957630,
            199957622,
            199957736,
            199957568,
            199959457,
            199957708,
            199957575,
            199957879
        ]
    },
    "name": "G. The Maximum Prefix",
    "statement": "You\u2019re going to generate an array a with a length of at most n, where\r\neach a_{i} equals either 1 or -1.You generate this array in the\r\nfollowing way. First, you choose some integer k (1\r\nle k\r\nle n), which decides the length of a. Then, for each i (1\r\nle i\r\nle k), you set a_{i} = 1 with probability p_{i}, otherwise set a_{i} =\r\n-1 (with probability 1 - p_{i}). After the array is generated, you\r\ncalculate s_{i} = a_{1} + a_{2} + a_{3}+\r\nldots + a_{i}. Specially, s_{0} = 0. Then you let S equal to\r\ndisplaystyle\r\nmax_{i=0}^{k}{s_{i}}. That is, S is the maximum prefix sum of the array\r\na.You are given n+1 integers h_{0} , h_{1},\r\nldots ,h_{n}. The of an array a with maximum prefix sum S is h_{S}. Now,\r\nfor each k, you want to know the expected score for an array of length k\r\nmodulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = 1;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 1;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 1000000007;\nusing Z = MInt<P>;\n\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<Z> p(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        p[i] = Z(x) / y;\n    }\n    \n    std::vector<Z> h(n + 1);\n    for (int i = 0; i <= n; i++) {\n        std::cin >> h[i];\n    }\n    \n    for (int k = 1; k <= n; k++) {\n        std::vector<Z> g(n + 1);\n        g[0] += h[0] * (1 - p[k - 1]);\n        g[1] += h[0] * (1 - p[k - 1]);\n        for (int i = 1; i <= n; i++) {\n            g[i - 1] += h[i] * p[k - 1];\n            if (i < n) {\n                g[i + 1] += h[i] * (1 - p[k - 1]);\n            }\n        }\n        h = std::move(g);\n        Z ans = h[0];\n        std::cout << ans << \" \\n\"[k == n];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. The Maximum Prefix.json",
    "editorial_link": "https://codeforces.com//blog/entry/114521",
    "editorial": "TutorialConsider this method to find maximal prefix sum: let and . We\r\ncan discover that the only influence has(to the whole array\u00e2\u0080\u0099s maximal\r\nprefix sum) is its maximal prefix sum. Then we let be : the expect score\r\nwe can get, if we assume that the maximal prefix sum of is (Read the\r\ndefinition carefully). The answer for each is , since if the maximal\r\nprefix sum for is , that is equivalent to removing them from the array.\r\nAnd also .And we have . The first section represents chosing and the\r\nsecond one represents chosing .We also have other solutions, using\r\ninclusion-exclusion or generate function. Actually all the testers\u00e2\u0080\u0099\r\nsolutions differs from each other.\r\n"
}