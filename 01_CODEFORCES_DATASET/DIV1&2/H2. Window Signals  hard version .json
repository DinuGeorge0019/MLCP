{
    "link": "https://codeforces.com//contest/1782/problem/H2",
    "problemId": "1738315",
    "problem_idx": "H2",
    "shortId": "1782H2",
    "contest_number": "1782",
    "problem_submissions": {
        "G": [
            189352903,
            189354160,
            189342529,
            189347964,
            189346429,
            189415258,
            189347317,
            189738607,
            189347232,
            189347696,
            189403021,
            189438204,
            189354810,
            189338967,
            189344949
        ],
        "H1": [
            189341567,
            189339761,
            189349634,
            189355935,
            189355012,
            189341367,
            189348685,
            189366896,
            189384259,
            189345985,
            189353203,
            189354256,
            189356712
        ],
        "F": [
            189325657,
            189363621,
            189331442,
            189327188,
            189334558,
            189331825,
            189332228,
            189332897,
            189335481,
            189328585,
            189328764,
            189334100,
            189338796,
            189342861,
            189333278,
            189345646,
            189348301,
            189336716,
            189329952,
            189336813
        ],
        "E": [
            189322203,
            189324476,
            189336013,
            189324984,
            189327367,
            189324941,
            189325259,
            189324742,
            189325043,
            189324750,
            189330839,
            189330033,
            189340117,
            189340110,
            189356727,
            189364874,
            189338107,
            189329882
        ],
        "D": [
            189315553,
            189316553,
            189320757,
            189315522,
            189321240,
            189315774,
            189315356,
            189317449,
            189316444,
            189318717,
            189318855,
            189319485,
            189321217,
            189322258,
            189322561,
            189316855,
            189317394,
            189318806,
            189319611
        ],
        "C": [
            189312571,
            189313515,
            189317007,
            189313044,
            189315685,
            189312570,
            189312443,
            189313938,
            189314521,
            189313780,
            189316398,
            189315035,
            189318312,
            189317410,
            189321818,
            189314789,
            189315093,
            189314367
        ],
        "B": [
            189309405,
            189309603,
            189311019,
            189308821,
            189310918,
            189309246,
            189308942,
            189310194,
            189308126,
            189309056,
            189311263,
            189310085,
            189312839,
            189309172,
            189329674,
            189309853,
            189310568,
            189309470
        ],
        "A": [
            189307515,
            189306919,
            189307198,
            189307124,
            189307391,
            189307301,
            189307111,
            189307534,
            189306943,
            189307353,
            189307056,
            189307424,
            189308244,
            189319051,
            189308061,
            189307499,
            189307060,
            189307053
        ],
        "H2": [
            189361277,
            189352155,
            189886586,
            189749780,
            189366917,
            189362146
        ]
    },
    "name": "H2. Window Signals  hard version ",
    "statement": "A house at the sea has h floors, all of the same height. The side of the\r\nhouse facing the sea has w windows at equal distances from each other on\r\nevery floor. Thus, the windows are positioned in cells of a rectangular\r\ngrid of size h\r\ntimes w.In every window, the light can be turned either on or off,\r\nexcept for the given k (at most 2) windows. In these k windows the light\r\ncan not be turned on, because it is broken.In the dark, we can send a\r\nsignal to a ship at sea using a configuration of lights turned on and\r\noff. However, the ship can not see the position of the lights with\r\nrespect to the house. Thus, if one configuration of windows with lights\r\non can be transformed into another using parallel translation, these\r\nconfigurations are considered equal. Note that only parallel translation\r\nis allowed, but neither rotations nor flips are. Moreover, a\r\nconfiguration without any light at all is not considered valid.Find how\r\nmany different signals the ship can receive and print this number modulo\r\n998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=40*1007;\nconst ll mod=998244353;\n\nint n, m, k;\n\nvector<pii> zle;\n\nll wyn;\n\nint p;\n\nint gwys, gsze;\n\nint daj(int a, int b)\n{\n\tif (a<1 || b<1 || a>gwys || b>gsze)\n\t\treturn 0;\n\treturn (a-1)*gsze+b;\n}\n\nint samo;\nint nast[nax];\nint poprz[nax];\nint jedno[nax];\n\nint mas[nax];\n\nll dps[16][2];\nll dpn[16][2];\n\nll dp[400][16][2][2];\n\n//~ vi lan;\n\nvoid dod(ll &a, ll b)\n{\n\tif ((a+=b)>=mod)\n\t\ta-=mod;\n}\n\n//~ ll fast[nax][2][2][2][2];//pierwszy, ostatni, przed, dwa\n\nint gr;\nint lan[nax];\n\nll pomdp[16][2];\n\nll fast[400][16][16];//ile, pierwszy, ostatni;\n\nvoid policz()\n{\n\t//~ int r=lan.size();\n\tint r=gr;\n\tfor (int i=0; i<=r; i++)\n\t\tfor (int j=0; j<16; j++)\n\t\t\tfor (int l=0; l<2; l++)\n\t\t\t\tdp[i][j][l][0]=dp[i][j][l][1]=0;\n\tdp[0][0][0][1]=1;\n\tfor (int i=0; i<r; i++)\n\t{\n\t\tint x=lan[i];\n\t\tfor (int j=0; j<16; j++)\n\t\t{\n\t\t\tfor (int l=0; l<2; l++)\n\t\t\t{\n\t\t\t\tfor (int h=0; h<2; h++)\n\t\t\t\t{\n\t\t\t\t\t//~ if (dp[i][j][l][h])\n\t\t\t\t\t\t//~ debug() << \"no kurwa\";\n\t\t\t\t\t{//zgasz\n\t\t\t\t\t\t//~ dod(dp[i+1][j][l|(!h)][0], dp[i][j][l][h]);\n\t\t\t\t\t\tdp[i+1][j][l|(!h)][0]+=dp[i][j][l][h];\n\t\t\t\t\t}\n\t\t\t\t\t{//zap\n\t\t\t\t\t\tdp[i+1][j|mas[x]][l][1]+=dp[i][j][l][h];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(i%30) || i+1==r)\n\t\t{\n\t\t\tfor (int j=0; j<16; j++)\n\t\t\t{\n\t\t\t\tfor (int l=0; l<2; l++)\n\t\t\t\t{\n\t\t\t\t\tfor (int h=0; h<2; h++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+1][j][l][h]%=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//~ debug() << \"policzone\";\n\t//~ for (int j=0; j<16; j++)\n\t\t//~ for (int l=0; l<2; l++)\n\t\t\t//~ for (int h=0; h<2; h++)\n\t\t\t\t//~ if (dp[r][j][l][h])\n\t\t\t\t\t//~ debug() << j << \" \" << l << \" \" << h << \" \" << dp[r][j][l][h];\n}\n\nll pot(ll v, int wyk)\n{\n\tll ret=1;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\tret=(ret*v)%mod;\n\t\tv=(v*v)%mod;\n\t\twyk>>=1;\n\t}\n\treturn ret;\n}\n\nvoid test()\n{\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tzle.resize(k);\n\tfor (pii &i : zle)\n\t\tscanf(\"%d%d\", &i.first, &i.second);\n\tsort(zle.begin(), zle.end());\n\twyn=0;\n\tfor (int wys=1; wys<=n; wys++)\n\t{\n\t\tfor (int sze=1; sze<=m; sze++)\n\t\t{\n\t\t\tgwys=wys;\n\t\t\tgsze=sze;\n\t\t\tp=wys*sze;\n\t\t\tsamo=0;\n\t\t\tfor (int i=1; i<=p; i++)\n\t\t\t{\n\t\t\t\tjedno[i]=0;\n\t\t\t\tnast[i]=poprz[i]=0;\n\t\t\t}\n\t\t\tvi tu;\n\t\t\tfor (int i=1; i+wys-1<=n && !samo; i++)\n\t\t\t{\n\t\t\t\tfor (int j=1; j+sze-1<=m && !samo; j++)\n\t\t\t\t{\n\t\t\t\t\ttu.clear();\n\t\t\t\t\tfor (pii l : zle)\n\t\t\t\t\t{\n\t\t\t\t\t\tint g=daj(l.first-i+1, l.second-j+1);\n\t\t\t\t\t\tif (g)\n\t\t\t\t\t\t\ttu.push_back(g);\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)tu.size()==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsamo=1;\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)tu.size()==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tjedno[tu[0]]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)tu.size()==2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tu[0]>tu[1])\n\t\t\t\t\t\t\tswap(tu[0], tu[1]);\n\t\t\t\t\t\tnast[tu[0]]=tu[1];\n\t\t\t\t\t\tpoprz[tu[1]]=tu[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (samo)\n\t\t\t{\n\t\t\t\tfor (int i=1; i<=p; i++)\n\t\t\t\t{\n\t\t\t\t\tnast[i]=poprz[i]=0;\n\t\t\t\t\tjedno[i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=1; i<=p; i++)\n\t\t\t{\n\t\t\t\tif (jedno[i])\n\t\t\t\t{\n\t\t\t\t\tif (poprz[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tnast[poprz[i]]=0;\n\t\t\t\t\t\tpoprz[i]=0;\n\t\t\t\t\t}\n\t\t\t\t\tif (nast[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tpoprz[nast[i]]=0;\n\t\t\t\t\t\tnast[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=1; i<=p; i++)\n\t\t\t\tmas[i]=0;\n\t\t\tfor (int i=1; i<=wys; i++)\n\t\t\t{\n\t\t\t\tfor (int j=1; j<=sze; j++)\n\t\t\t\t{\n\t\t\t\t\tif (i==1)\n\t\t\t\t\t\tmas[daj(i, j)]|=1;\n\t\t\t\t\tif (i==wys)\n\t\t\t\t\t\tmas[daj(i, j)]|=2;\n\t\t\t\t\tif (j==1)\n\t\t\t\t\t\tmas[daj(i, j)]|=4;\n\t\t\t\t\tif (j==sze)\n\t\t\t\t\t\tmas[daj(i, j)]|=8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=0; i<16; i++)\n\t\t\t\tfor (int j=0; j<2; j++)\n\t\t\t\t\tdpn[i][j]=0;\n\t\t\tdpn[0][samo]=1;\n\t\t\t//~ debug() << imie(wys) << imie(sze);\n\t\t\t//~ debug() << imie(samo);\n\t\t\t//~ for (int i=1; i<=p; i++)\n\t\t\t\t//~ debug() << i << \" \" << jedno[i] << \" \" << mas[i] << \"  \" << poprz[i] << \" \" << nast[i];\n\t\t\tint fake=0;\n\t\t\tint fake2=0;\n\t\t\tfor (int i=1; i<=max(n, m); i++)\n\t\t\t\tfor (int j=0; j<16; j++)\n\t\t\t\t\tfor (int l=0; l<16; l++)\n\t\t\t\t\t\tfast[i][j][l]=0;\n\t\t\t\n\t\t\tfor (int i=1; i<=p; i++)\n\t\t\t{\n\t\t\t\tif (poprz[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (jedno[i])\n\t\t\t\t{\n\t\t\t\t\tif (!mas[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tfake2++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdps[a][b]=dpn[a][b];\n\t\t\t\t\t\t\tdpn[a][b]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdod(dpn[a][1], dps[a][b]);\n\t\t\t\t\t\t\tdod(dpn[a|mas[i]][b], dps[a][b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!nast[i] && !mas[i])\n\t\t\t\t{\n\t\t\t\t\tfake++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//~ lan.clear();\n\t\t\t\tgr=0;\n\t\t\t\tint x=i;\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tlan[gr]=x;\n\t\t\t\t\tgr++;\n\t\t\t\t\t//~ lan.push_back(x);\n\t\t\t\t\tif (!nast[x])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tx=nast[x];\n\t\t\t\t}\n\t\t\t\tfast[gr][mas[lan[0]]][mas[lan[gr-1]]]++;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor (int i=1; i<=p; i++)\n\t\t\t{\n\t\t\t\tif (poprz[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (jedno[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!nast[i] && !mas[i])\n\t\t\t\t\tcontinue;\n\t\t\t\t//~ lan.clear();\n\t\t\t\tgr=0;\n\t\t\t\tint x=i;\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tlan[gr]=x;\n\t\t\t\t\tgr++;\n\t\t\t\t\t//~ lan.push_back(x);\n\t\t\t\t\tif (!nast[x])\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tx=nast[x];\n\t\t\t\t}\n\t\t\t\tif (!fast[gr][mas[lan[0]]][mas[lan[gr-1]]])\n\t\t\t\t\tcontinue;\n\t\t\t\tint kopie=fast[gr][mas[lan[0]]][mas[lan[gr-1]]];\n\t\t\t\tfast[gr][mas[lan[0]]][mas[lan[gr-1]]]=0;\n\t\t\t\tint r=gr;\n\t\t\t\tpolicz();\n\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdps[a][b]=dpn[a][b];\n\t\t\t\t\t\tdpn[a][b]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i=0; i<16; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int j=0; j<2; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tpomdp[i][j]=(dp[r][i][j][0]+dp[r][i][j][1]);\n\t\t\t\t\t\tif (pomdp[i][j]>=mod)\n\t\t\t\t\t\t\tpomdp[i][j]-=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i=0; i<4; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!(a&(1<<i)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdps[a^(1<<i)][b]+=dps[a][b];\n\t\t\t\t\t\t\t\tpomdp[a^(1<<i)][b]+=pomdp[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t{\n\t\t\t\t\tdps[a][1]+=dps[a][0];\n\t\t\t\t\tpomdp[a][1]+=pomdp[a][0];\n\t\t\t\t}\n\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdps[a][b]%=mod;\n\t\t\t\t\t\tpomdp[a][b]%=mod;\n\t\t\t\t\t\t//~ dpn[a][b]=dps[a][b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//~ while(kopie--)\n\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//~ dpn[a][b]=(dps[a][b]%mod*(pomdp[a][b]%mod))%mod;\n\t\t\t\t\t\t//~ dpn[a][b]=(dpn[a][b]*pomdp[a][b])%mod;\n\t\t\t\t\t\tdpn[a][b]=dps[a][b]*pot(pomdp[a][b], kopie);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t{\n\t\t\t\t\tdpn[a][1]-=dpn[a][0];\n\t\t\t\t}\n\t\t\t\tfor (int i=0; i<4; i++)\n\t\t\t\t{\n\t\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!(a&(1<<i)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdpn[a^(1<<i)][b]-=dpn[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int a=0; a<16; a++)\n\t\t\t\t{\n\t\t\t\t\tfor (int b=0; b<2; b++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdpn[a][b]%=mod;\n\t\t\t\t\t\tif (dpn[a][b]<0)\n\t\t\t\t\t\t\tdpn[a][b]+=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tll a=dpn[15][1]%mod;\n\t\t\tll b=dpn[15][0]%mod;\n\t\t\tif (a<0)\n\t\t\t\ta+=mod;\n\t\t\tif (b<0)\n\t\t\t\tb+=mod;\n\t\t\twhile(fake--)\n\t\t\t{\n\t\t\t\ta=(2*a)%mod;\n\t\t\t\tb=(2*b)%mod;\n\t\t\t}\n\t\t\twhile(fake2--)\n\t\t\t{\n\t\t\t\ta=(2*a+b)%mod;\n\t\t\t}\n\t\t\tdod(wyn, a);\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n\tprintf(\"%lld\\n\", wyn);\n}\n//~ 712237431\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H2. Window Signals  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/111783",
    "editorial": "Let's iterate over the dimensions of the bounding box of the image of windows with lights on, h?\u00d7w?\n (1?h??h;1?w??w\n), count images with such bounding box, and sum all these values up.\n\nAn image has a bounding box of size exactly h?\u00d7w?\n if and only if:\n\nit fits inside an h?\u00d7w?\n rectangle;\nit has a light on each of its four borders.\nTo account for the second condition, we can use inclusion-exclusion principle. This way, we will have an \"it does not have a light on some of its borders\" condition instead, at the cost of an extra 24\n time factor. We will disregard this condition in the rest of this tutorial.\n\nThere are 2h?w?\n possible images fitting in an h?\u00d7w?\n rectangles. How many of them are impossible to show because of broken lights? Let's find this number and subtract it.\n\nConsider all possible ways to place a rectangle of size h?\u00d7w?\n on the given h\u00d7w\n grid:\n\nIf there are no broken lights inside, any image of size h?\u00d7w?\n is possible to show, so we don't need to subtract anything for this size at all.\nIf there is 1\n broken light inside, its relative position in the h?\u00d7w?\n rectangle must be turned on (for an image to be impossible to show).\nIf there are 2\n broken lights inside, find their relative positions in the h?\u00d7w?\n rectangle. For an image to be impossible to show, at least one of the two positions must be turned on.\nUnless a placement with no broken lights exists, we have some cells in the rectangle where the light must be turned on \u0097 let's call the set of these cells X\n, and some pairs of cells where at least one light must be turned on \u0097 let's call the set of these pairs Y\n.\n\nIf a pair from Y\n contains a cell from X\n, this pair can be removed from Y\n. Once we do that, note that the pairs from Y\n form several chains \u0097 that happens because the coordinate-wise distance between the cells in each pair is equal to the distance between the broken lights, which is (r2?r1,c2?c1)\n.\n\nIf we have a chain of length p\n, it can be seen that there are f(p)\n ways to turn lights on so that every pair of neighboring cells has at least one light, where f(p)=f(p?1)+f(p?2)\n are Fibonacci numbers.\n\nThus, the number to subtract is the product of:\n\n2w\n, where w\n is the number of cells not included in X\n and Y\n;\nf(p)\n over all chains formed by Y\n, where p\n is the length of a chain.\nEvery subgrid size h?\u00d7w?\n is processed in O(hw)\n time, and there are hw\n different sizes, thus, the overall time complexity is O(h2w2)\n.\n\nIt is possible to optimize the constant factor of this solution to pass the hard version too. However, a solution of O(hw2)\n time complexity exists as well. Here is a sketch of it:\n\nInstead of fixing both dimensions of the lights image, h?\n and w?\n, let's only fix w?\n.\nUse inclusion-exclusion like described at the beginning of this tutorial; however, only use it for the top, left, and right borders. We will not use it for the bottom border, since we are not fixing the height of the image.\nGo through all top-left corners (i,j)\n of the lights image in lexicographic order (1?i?h;1?j?w?w?+1\n).\nFor each top-left corner, count how many images of width w?\n can be shown using this top-left corner, which can not be shown using any previous top-left corner.\nSimilarly to the previous solution, consider cases of 0\n, 1\n, and 2\n broken lights inside the current subgrid. Note, however, that we are not fixing the height of the subgrid, so just assume that it stretches all the way down to the bottom border of the whole grid.\nMaintain the set of cells X\n using an array, and maintain the set of pairs Y\n using linked lists.\nOnce a cell joins set X\n, remove all pairs that touch it from set Y\n. Once a pair joins set Y\n, if neither of its ends belongs to X\n, merge two corresponding linked lists.\nMaintain a variable denoting the product of f(p)\n over all chains formed by Y\n. Once any split or merge happens to the lists, update this variable using O(1)\n multiplications/divisions.\nWhenever i\n (the row number of the top-left corner) increases by 1\n, the maximum available height of the lights image decreases by 1\n. Thus, we have to \"remove\" the cells in the current bottom row: that is, for any future image, we won't be able to light up those cells. If any such cell belongs to X\n, just stop: we won't get any new images. Otherwise, if such a cell belongs to a pair in Y\n, add the second end of this pair to X\n.\nFor fixed width w?\n and for each top-left corner (i,j)\n, we need to spend O(1)\n time. Moreover, for fixed width w?\n, once i\n increases (which happens O(h)\n times), we need to spend O(w)\n time to process cell removals. Hence, the time complexity of both parts is O(hw2)\n."
}