{
    "link": "https://codeforces.com//contest/1060/problem/D",
    "problemId": "230449",
    "problem_idx": "D",
    "shortId": "1060D",
    "contest_number": "1060",
    "problem_submissions": {
        "H": [
            43777582,
            43775787,
            43778301,
            43775359,
            43805399,
            43782088,
            43777602,
            44116240,
            43850241,
            43778906,
            43778773
        ],
        "F": [
            43769322,
            43774726,
            43772403,
            43778102,
            43769241,
            43772326,
            43773423,
            43775493,
            43777323,
            43776810,
            44345662,
            43998198,
            43776461,
            43777805,
            43885359,
            43777579,
            43776355,
            43779796,
            43779608,
            43780204
        ],
        "E": [
            43762417,
            43764663,
            43763746,
            43764167,
            43763212,
            43766061,
            43765524,
            43768205,
            43766236,
            43763603,
            43766034,
            43766754,
            43768368,
            43766310,
            43767829,
            43764919,
            43769766,
            43765300,
            43766971,
            43767710
        ],
        "B": [
            43761076,
            43759115,
            43759168,
            43759290,
            43758265,
            43759025,
            43759632,
            43759678,
            43759571,
            43759528,
            43758792,
            43759203,
            43760228,
            43760411,
            43761202,
            43772055,
            43761410,
            43759136,
            43761174,
            43759666
        ],
        "C": [
            43760028,
            43761053,
            43760979,
            43760607,
            43760834,
            43761267,
            43761559,
            43762200,
            43761558,
            43761781,
            43761097,
            43763023,
            43762854,
            43762864,
            43763097,
            43761814,
            43765269,
            43760939,
            43763385,
            43762549
        ],
        "D": [
            43758517,
            43762752,
            43762719,
            43762340,
            43759631,
            43763257,
            43762507,
            43764164,
            43763131,
            43760435,
            43762978,
            43764580,
            43764519,
            43765425,
            43764660,
            43762881,
            43766760,
            43767791,
            43764938,
            43764650
        ],
        "A": [
            43757554,
            43758213,
            43757544,
            43758262,
            43757552,
            43757711,
            43757958,
            43758105,
            43757983,
            43757586,
            43757752,
            43757708,
            43758583,
            43757806,
            43757592,
            43757955,
            43759122,
            43757641,
            43757856,
            43757849
        ],
        "G": [
            44020164,
            44543288
        ]
    },
    "name": "D. Social Circles",
    "statement": "You invited n guests to dinner! You plan to arrange one or more circles\r\nof chairs. Each chair is going to be either occupied by one guest, or be\r\nempty. You can make any number of circles. Your guests happen to be a\r\nlittle bit shy, so the i-th guest wants to have a least l_i free chairs\r\nto the left of his chair, and at least r_i free chairs to the right. The\r\n\"left\" and \"right\" directions are chosen assuming all guests are going\r\nto be seated towards the center of the circle. Note that when a guest is\r\nthe only one in his circle, the l_i chairs to his left and r_i chairs to\r\nhis right may overlap.What is smallest total number of chairs you have\r\nto use?\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100100;\n\nint N;\nint l[MAXN], r[MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> l[i] >> r[i];\n    sort (l, l + N);\n    sort (r, r + N);\n\n    ll ans = N;\n    for (int i = 0; i < N; i++)\n        ans += max (l[i], r[i]);\n    cout << ans << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Social Circles.json",
    "editorial_link": "https://codeforces.com//blog/entry/113725",
    "editorial": "Firstly, lets try finding a lower bound on the answer. To visualize this setup better, lets construct a graph where there is an edge from a person to the person on their right. Then the resulting graph is a union of isolated cycles (and possibly self-loops).\n\nClearly, for a person, there is exactly one person to their right, and every person has exactly one person on their left. So the function that maps a person to the person on their right is a permutation. Also, note that every permutation has a cycle decomposition, and by arranging people according to the cycles in the decomposition, we can recover a valid seating plan. In other words, there is a bijection between seating plans and permutations.\n\nAny edge from a person \ni\ni to person \nj\nj contributes \nmax\n?\n(\nr\ni\n,\nl\nj\n)\nmax(r \ni\n?\n ,l \nj\n?\n ) to the answer, and every person contributes \n1\n1. So we want to minimize \nn\n+\n?\ni\n=\n1\nn\nmax\n?\n(\nr\ni\n,\nl\np\ni\n)\nn+? \ni=1\nn\n?\n max(r \ni\n?\n ,l \np \ni\n?\n \n?\n ) over all permutations \np\np of size \nn\nn. We claim that this expression is minimized when \nr\ni\nr \ni\n?\n  and \nl\np\ni\nl \np \ni\n?\n \n?\n  are sorted the same way. The proof will be via construction.\n\nWithout loss of generality, lets say \nr\nr is sorted (reindex people if this is not the case).\n\nConsider a permutation \np\np with at least one inversion. Note that here an inversion is defined as \nl\np\nj\n>\nl\np\ni\nl \np \nj\n?\n \n?\n >l \np \ni\n?\n \n?\n  for \ni\n<\nj\ni<j  in particular, we are not looking at inversions in \np\np, but in the permutation \nl\n?\np\nl?p, or more precisely the composition of the permutation that you get when you map elements of \nl\nl to their ranks (ties broken arbitrarily), and \np\np.\n\nEvery permutation with at least one inversion has at least one inversion with adjacent indices. Lets say those indices are \n(\ni\n,\ni\n+\n1\n)\n(i,i+1). This means \nl\np\ni\n+\n1\n<\nl\np\ni\nl \np \ni+1\n?\n \n?\n <l \np \ni\n?\n \n?\n  and \nr\ni\n?\nr\ni\n+\n1\nr \ni\n?\n ?r \ni+1\n?\n . We now construct the permutation \np\n\np by applying a swap \n(\ni\n,\ni\n+\n1\n)\n(i,i+1) to \np\np. We claim that \np\n\np is at least as good as \np\np. In particular, we just need to show that for positive integers \na\n?\nb\na?b and \nc\n<\nd\nc<d, the following holds: \nmax\n?\n(\na\n,\nc\n)\n+\nmax\n?\n(\nb\n,\nd\n)\n?\nmax\n?\n(\na\n,\nd\n)\n+\nmax\n?\n(\nb\n,\nc\n)\nmax(a,c)+max(b,d)?max(a,d)+max(b,c), or equivalently, that \nmax\n?\n(\na\n,\nd\n)\n?\nmax\n?\n(\na\n,\nc\n)\n?\nmax\n?\n(\nb\n,\nd\n)\n?\nmax\n?\n(\nb\n,\nc\n)\nmax(a,d)?max(a,c)?max(b,d)?max(b,c). Consider the function \nf\n(\nx\n)\n=\nmax\n?\n(\nx\n,\nd\n)\n?\nmax\n?\n(\nx\n,\nc\n)\nf(x)=max(x,d)?max(x,c). For \nx\n?\nc\nx?c it evaluates to \nd\n?\nc\nd?c, for \nc\n<\nx\n?\nd\nc<x?d it evaluates to \nd\n?\nx\nd?x, and for \nd\n<\nx\nd<x it evaluates to \n0\n0. So, this is a non-increasing function, and we are done.\n\nThis operation (replacing \np\np by \np\n\np) reduces the number of inversions by exactly one. By doing this process while there is at least one inversion, we come to a permutation such that \nl\n?\np\nl?p is the identity permutation  that is, \nl\nl and \nr\nr are sorted the same way.\n\nNow that we are done with the proof, we have shown that there exists an optimal seating plan which requires \nn\n+\n?\ni\n=\n1\nn\nmax\n?\n(\nL\ni\n,\nR\ni\n)\nn+? \ni=1\nn\n?\n max(L \ni\n?\n ,R \ni\n?\n ) chairs, where \nL\n,\nR\nL,R are the arrays you get when you sort \nl\n,\nr\nl,r respectively.",
    "hint": []
}