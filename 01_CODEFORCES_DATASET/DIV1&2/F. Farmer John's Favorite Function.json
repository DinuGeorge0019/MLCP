{
    "link": "https://codeforces.com//contest/1942/problem/F",
    "problemId": "2562663",
    "problem_idx": "F",
    "shortId": "1942F",
    "contest_number": "1942",
    "problem_submissions": {
        "H": [
            254183902,
            254188108,
            254201851,
            254183582,
            254190002,
            254198277,
            254202464,
            254201777
        ],
        "G": [
            254162531,
            254164622,
            254151822,
            254172554,
            254170602,
            254147291,
            254169050,
            254165219,
            254167927,
            254162501,
            254160773,
            254158971,
            254158358,
            254162939,
            254174812,
            254166519,
            254160779,
            254190901,
            254172694
        ],
        "F": [
            254158172,
            254152768,
            254191293,
            254157909,
            254159055,
            254161327,
            254156776,
            254157963,
            254160983,
            254169304,
            254173612,
            254173846,
            254172970,
            254168440,
            254167804,
            254178450,
            254203408,
            254180148,
            254161110,
            254162666
        ],
        "E": [
            254144668,
            254141645,
            254144010,
            254144661,
            254150949,
            254131679,
            254143965,
            254147690,
            254143510,
            254152706,
            254144759,
            254152214,
            254138579,
            254146127,
            254149515,
            254151573,
            254147613,
            254146631,
            254149743
        ],
        "D": [
            254140034,
            254136242,
            254134735,
            254138534,
            254140561,
            254139068,
            254133778,
            254140913,
            254137432,
            254142449,
            254137105,
            254142252,
            254145710,
            254140092,
            254138595,
            254139592,
            254140216,
            254137967,
            254143121
        ],
        "C1": [
            254131817,
            254128192,
            254204108,
            254125718,
            254128016,
            254124090,
            254123140,
            254122427,
            254125306,
            254127382,
            254129295,
            254126939,
            254129179,
            254122148,
            254134385,
            254126328,
            254132572,
            254129060,
            254125449,
            254134104
        ],
        "C2": [
            254131346,
            254132277,
            254203957,
            254203739,
            254128200,
            254133096,
            254129236,
            254126373,
            254125814,
            254128450,
            254131487,
            254132145,
            254131700,
            254133377,
            254130111,
            254134317,
            254129340,
            254132361,
            254129276,
            254129577,
            254134556
        ],
        "B": [
            254123310,
            254123064,
            254120037,
            254123258,
            254119059,
            254120381,
            254119896,
            254118664,
            254120410,
            254124572,
            254120489,
            254125154,
            254128773,
            254119724,
            254122914,
            254121539,
            254119687,
            254120045,
            254122462
        ],
        "A": [
            254117704,
            254118878,
            254117338,
            254117275,
            254117327,
            254117266,
            254117244,
            254117366,
            254117469,
            254117281,
            254117396,
            254117230,
            254117295,
            254117454,
            254117450,
            254117301,
            254117455,
            254117981
        ]
    },
    "name": "F. Farmer John's Favorite Function",
    "statement": "Farmer John has an array a of length n. He also has a function f with\r\nthe following recurrence: f(1) =\r\nsqrt{a_1}; For all i > 1, f(i) =\r\nsqrt{f(i-1)+a_i}. Note that f(i) is not necessarily an integer.He plans\r\nto do q updates to the array. Each update, he gives you two integers k\r\nand x and he wants you to set a_k = x. After each update, he wants to\r\nknow\r\nlfloor f(n)\r\nrfloor, where\r\nlfloor t\r\nrfloor denotes the value of t rounded down to the nearest integer.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\nbool dbg=false;\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\nusing vvi=vc<vc<int>>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\nstring rand_string(int n,char lw,char up){\n\tstring s(n,'?');\n\trep(i,n)s[i]=rand_int(lw,up);\n\treturn s;\n}\n\nint current_run_id,run_batch_size=1000;\nint calc_random_limit(){\n\treturn current_run_id/run_batch_size+1;\n}\ntemplate<class t>\nvoid generate_single(t&a){\n\ta=rand_int(1,calc_random_limit());\n}\nvoid generate_single(string&a){\n\tint n;generate_single(n);\n\ta=rand_string(n,'a','b');\n}\ntemplate<class t,class u>\nvoid generate_single(pair<t,u>&a){\n\tgenerate_single(a.a);\n\tgenerate_single(a.b);\n}\n//https://trap.jp/post/1224/\ntemplate<class... Args>\nvoid input(Args&... a){\n\tif(dbg){\n\t\t(generate_single(a),...);\n\t}else{\n\t\t(cin >> ... >> a);\n\t}\n}\n#define INT(...) int __VA_ARGS__;input(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;input(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;input(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;input(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;input(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;input(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;input(__VA_ARGS__)\n#define overload3(a,b,c,d,...) d\n#define VI2(name,size) vi name(size);rep(i_##name,size)input(name[i_##name]);\n#define VI3(name,size,offset) vi name(size);rep(i_##name,size)input(name[i_##name]),name[i_##name]+=offset;\n#define VI(...) overload3(__VA_ARGS__,VI3,VI2)(__VA_ARGS__)\n#define VPI(name,size) vc<pi> name(size);rep(i_##name,size)input(name[i_##name]);\n#define VVI(name,sizeN,sizeM) vvi name(sizeN,vi(sizeM));\\\nrep(i_##name,sizeN)rep(j_##name,sizeM)input(name[i_##name][j_##name]);\n\n#define VVT(type,name,sizeN,sizeM) vvc<type> name(sizeN,vc<type>(sizeM));\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1){\n\t\tif(dbg)cout<<endl;\n\t\telse cout<<\"\\n\";\n\t}\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\ntemplate<class T>\nvoid printvv(const vvc<T>&vs){\n\tfor(const auto&row:vs)print(row);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class S> void mkuni(S&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t> bool isuni(vc<t> v){\n\tint s=si(v);\n\tmkuni(v);\n\treturn si(v)==s;\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class S,class u>\nint lwb(const S&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tvoid clear(){\n\t\tfill(all(p),-1);\n\t\tfill(all(s),1);\n\t\tc=si(p);\n\t}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\tif(dbg){\n\t\tvvc<int> t(n);\n\t\tunionfind uf(n);\n\t\twhile(uf.c>1){\n\t\t\tint a=rand_int(n);\n\t\t\tint b=rand_int(n);\n\t\t\tif(uf.unite(a,b)){\n\t\t\t\tt[a].pb(b);\n\t\t\t\tt[b].pb(a);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}else{\n\t\treturn readGraph(n,n-1);\n\t}\n}\n\nvoid printTree(const vvc<int> t){\n\tint n=si(t);\n\tint degsum=0;\n\trep(i,n)degsum+=si(t[i]);\n\tif(degsum==n-1){\n\t\t//directed\n\t\trep(i,si(t))for(auto j:t[i]){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else if(degsum==2*(n-1)){\n\t\t//undirected\n\t\trep(i,si(t))for(auto j:t[i])if(i<j){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else{\n\t\tassert(false);\n\t}\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\ntemplate<class t,class u,class v>\npair<t,u>&operator*=(pair<t,u>&a,v b){\n\ta.a*=b;a.b*=b;return a;}\ntemplate<class t,class u,class v>\npair<t,u> operator*(pair<t,u> a,v b){return a*=b;}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a){return mp(-a.a,-a.b);}\nnamespace std{\ntemplate<class t,class u>\nistream&operator>>(istream&is,pair<t,u>&a){\n\treturn is>>a.a>>a.b;\n}\n}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator*=(vc<t>&a,u x){\n\tfor(auto&v:a)v*=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator*(vc<t> a,u x){\n\treturn a*=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n//消した要素の個数を返してくれる\n//UCUP 2-8-F\ntemplate<class t,class F>\nint remif(vc<t>&a,F f){\n\tauto itr=remove_if(all(a),f);\n\tint res=a.ed-itr;\n\ta.erase(itr,a.ed);\n\treturn res;\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//Multiuni2023-8 C\n//f(lw)=false,...,f(n-1)=false,f(n)=true,...,f(up)=true,\n//のときに n を返す\ntemplate<class F>\nint find_min_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))up=mid;\n\t\telse lw=mid;\n\t}\n\treturn up;\n}\n//f(lw)=true,f(up)=false\ntemplate<class F>\nint find_max_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))lw=mid;\n\t\telse up=mid;\n\t}\n\treturn lw;\n}\n\ntemplate<class t> using pqmin=priority_queue<t,vc<t>,greater<t>>;\ntemplate<class t> using pqmax=priority_queue<t>;\nusing T=tuple<int,int,int>;\n\n//merge で片方が inactive のときはもう片方をそのまま返す，\n//といったときに，lazy の情報までコピーして渡さないようにする\n\n//atcoder-library をまあまあコピーして使っている\n\n//VERIFY:\n//Japan Mirror Camp 2022 Day2 F\ntemplate<class N>\nstruct segbeats{\n\tvc<N> x;\n\tint L,s;\n\tsegbeats(){}\n\ttemplate<class T>\n\tsegbeats(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tsegbeats(int n){\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.assign(s*2,N());\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tN::merge(x[i*2],x[i*2+1],x[i]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<r&&r<=s);\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml[2],smr[2];\n\t\tint p=0,q=0;\n\t\tbool lnone=true,rnone=true;\n\t\twhile (l < r) {\n\t\t\tif (l & 1){\n\t\t\t\tif(lnone)sml[0]=x[l++];\n\t\t\t\telse{\n\t\t\t\t\tN::merge(sml[p],x[l++],sml[p^1]);\n\t\t\t\t\tp^=1;\n\t\t\t\t}\n\t\t\t\tlnone=false;\n\t\t\t}\n\t\t\tif (r & 1){\n\t\t\t\tif(rnone)smr[0]=x[--r];\n\t\t\t\telse {\n\t\t\t\t\tN::merge(x[--r],smr[q],smr[q^1]);\n\t\t\t\t\tq^=1;\n\t\t\t\t}\n\t\t\t\trnone=false;\n\t\t\t}\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\t\tassert(!lnone||!rnone);\n\t\tif(lnone)return smr[q];\n\t\telse if(rnone)return sml[p];\n\t\telse{\n\t\t\tN::merge(sml[p],smr[q],sml[p^1]);\n\t\t\treturn sml[p^1];\n\t\t}\n\t}//\n\ttemplate<class F,class... Args>\n\tvoid ch_work(int i,F f,Args&&... args){\n\t\tint ini=i;\n\t\twhile(1){\n\t\t\tif((x[i].*f)(forward<Args>(args)...)){\n\t\t\t\twhile(i>ini&&(i&1)){\n\t\t\t\t\ti>>=1;\n\t\t\t\t\tupd(i);\n\t\t\t\t}\n\t\t\t\tif(i==ini)break;\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tpush(i);\n\t\t\t\ti*=2;\n\t\t\t}\n\t\t}\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r,F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t//(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[0][cnt[0]++]=l++;\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t//(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t\tbuf[1][cnt[1]++]=--r;\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\t\t//rep(i,cnt[0])(x[buf[0][i]].*f)(forward<Args>(args)...);\n\t\t//per(i,cnt[1])(x[buf[1][i]].*f)(forward<Args>(args)...);\n\t\trep(i,cnt[0])ch_work(buf[0][i],f,forward<Args>(args)...);\n\t\tper(i,cnt[1])ch_work(buf[1][i],f,forward<Args>(args)...);\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\t/*template <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\t//XXI Opencup Krakow M\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\tassert(0<=r&&r<=s);\n        if(r==0)return mp(0,N());\n        r+=s;\n        for (int i = L; i >= 1; i--) push((r - 1) >> i);\n        N sm;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    push(r);\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}*/\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\nint f(int v,int a){\n\treturn sqrtl(v+a);\n}\n\n//N::push\n//pushしたあとはclearする\n//N::merge\n\n//set then add\nconst int none=-inf;\nstruct N{\n\tint mx,mn,lzset,lzadd;\n\tN():mx(-inf),mn(inf),lzset(none),lzadd(0){}\n\tN(int v):mx(v),mn(v),lzset(none),lzadd(0){}\n\tvoid add(int v){\n\t\tmx+=v;\n\t\tmn+=v;\n\t\tlzadd+=v;\n\t}\n\tvoid setval(int v){\n\t\tif(v==none)return;\n\t\tmx=mn=lzset=v;\n\t\tlzadd=0;\n\t}\n\tbool essential(int a){\n\t\tint u=f(mn,a);\n\t\tint v=f(mx,a);\n\t\tif(u==v){\n\t\t\tsetval(u);\n\t\t\treturn true;\n\t\t}else if((u-mn)==(v-mx)){\n\t\t\tadd(u-mn);\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\tvoid push(N&x,N&y){\n\t\tx.setval(lzset);\n\t\ty.setval(lzset);\n\t\tlzset=none;\n\t\tx.add(lzadd);\n\t\ty.add(lzadd);\n\t\tlzadd=0;\n\t}\n\tstatic void merge(N x,N y,N&res){\n\t\tres.mx=max(x.mx,y.mx);\n\t\tres.mn=min(x.mn,y.mn);\n\t\tres.lzset=none;\n\t\tres.lzadd=0;\n\t}\n};\n\nvoid slv(){\n\tINT(n,q);\n\tvvc<pi> val(n);\n\trep(i,n){\n\t\tINT(a);\n\t\tval[i].eb(0,a);\n\t}\n\trng(i,1,q+1){\n\t\tINT(k,x);\n\t\tk--;\n\t\tval[k].eb(i,x);\n\t}\n\trep(i,n)val[i].eb(q+1,0);\n\tvi ini(q+1);\n\trep(k,si(val[0])-1){\n\t\trng(i,val[0][k].a,val[0][k+1].a){\n\t\t\tini[i]=sqrtl(val[0][k].b);\n\t\t}\n\t}\n\tsegbeats<N> seg(ini);\n\trng(i,1,n){\n\t\trep(k,si(val[i])-1){\n\t\t\tseg.ch(val[i][k].a,val[i][k+1].a,&N::essential,val[i][k].b);\n\t\t}\n\t}\n\tvc<N> ans;\n\tseg.enumerate(0,q+1,ans);\n\tvi vs;\n\trng(i,1,q+1)vs.pb(ans[i].mn);\n\tfor(auto v:vs)print(v);\n}\n\nsigned main(signed argc,char*argv[]){\n\tif(argc>1&&strcmp(argv[1],\"D\")==0)dbg=true;\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1){\n\t\t\tif(current_run_id%run_batch_size==0){\n\t\t\t\tcerr<<\"Current Run \"<<current_run_id<<endl;\n\t\t\t}\n\t\t\tslv();\n\t\t\tcurrent_run_id++;\n\t\t}\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Farmer John's Favorite Function.json",
    "editorial_link": "https://codeforces.com//blog/entry/126942",
    "editorial": "Problem Credits: sum Analysis: sum SolutionLet’s first look at the\r\nimpact of earlier numbers on the final result. Earlier numbers can still\r\ninfluence when is large. Suppose that all are integers. Then decreasing\r\nany will decrease . However, it is clear that the impact of earlier\r\nnumber on is still extremely small. A key observation is that when ,\r\nchanging will only affect by at most .Another observation is that we can\r\ntake the floor each time we square root. Specifically, we can define as:\r\nFor all , This allows us to work with integers. From here on, we work\r\nwith this new definition of .Let’s divide our array into blocks of size\r\n. We can append zeroes to the front of the array to make a multiple of .\r\nConsider some block representing range . Let’s consider the subarray .\r\nLet be the value of if we let . Using our first observation, we know\r\nthat will be either or depending on . So let’s find the smallest value\r\nsuch that if , then . This can be done by iterating over the elements of\r\nthe block backwards.For each block, we store its corresponding (). We\r\ncan build a segment tree over the blocks for an solution. Alternatively,\r\nwe can do square root decomposition by having which leads to an solution\r\n(in practice, we should set to something small like ).\r\n",
    "hint": [
        "Hint 1 Consider the case where all are integers. Decreasing any will decrease . So solutions that iterate over the last few elements will not work.",
        "Hint 2 If , changing will only affect by at most .",
        "Hint 3 We can take the floor each time we square root. Specifically, we can define as: For all , This allows us to work with integers.",
        "Hint 4 We can divide our array into blocks of size (note that the value of depends on the solution). How can we use hint ? What should we store for each block?"
    ]
}