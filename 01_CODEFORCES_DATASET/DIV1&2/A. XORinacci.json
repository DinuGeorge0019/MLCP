{
    "link": "https://codeforces.com//contest/1208/problem/A",
    "problemId": "395876",
    "problem_idx": "A",
    "shortId": "1208A",
    "contest_number": "1208",
    "problem_submissions": {
        "H": [
            59484058,
            59502734,
            76052313
        ],
        "G": [
            59465495,
            59473655,
            59462360,
            59469582,
            59476496,
            59467194,
            59474332,
            59471219,
            59476758,
            59478641,
            59474463,
            59471571,
            59487164,
            59486904,
            59486576,
            59482130,
            59477683,
            59476449,
            59473994,
            59479017,
            59477708,
            59480546
        ],
        "F": [
            59463879,
            59465198,
            59467560,
            59476238,
            59468730,
            59478991,
            59464681,
            59477905,
            59488265,
            59473195,
            59472737,
            59472853,
            59477583,
            59487223,
            59467058,
            59472365,
            59474724,
            59482091,
            59473763,
            59474219,
            59475026
        ],
        "E": [
            59458500,
            59460001,
            59471123,
            59460976,
            59465221,
            59464240,
            59471956,
            59467792,
            59468080,
            59468210,
            59467089,
            59468111,
            59463881,
            59468884,
            59466520,
            59466354,
            59469354,
            59470023,
            59470503
        ],
        "C": [
            59454101,
            59453008,
            59450929,
            59452783,
            59454696,
            59455218,
            59454973,
            59451236,
            59458825,
            59456015,
            59453250,
            59456008,
            59453716,
            59453732,
            59453888,
            59456639,
            59456258,
            59457694,
            59458473
        ],
        "D": [
            59453338,
            59455109,
            59457439,
            59466058,
            59460513,
            59457371,
            59457830,
            59458661,
            59462381,
            59461784,
            59460829,
            59462458,
            59456674,
            59462814,
            59457263,
            59459344,
            59458893,
            59462907,
            59461567
        ],
        "B": [
            59451380,
            59451457,
            59455342,
            59451327,
            59452833,
            59452235,
            59452686,
            59455049,
            59452214,
            59453318,
            59450989,
            59453232,
            59451916,
            59457683,
            59451681,
            59453837,
            59452400,
            59452282,
            59455051
        ],
        "A": [
            59449116,
            59449294,
            59449254,
            59449364,
            59450306,
            59449785,
            59449160,
            59452256,
            59449743,
            59449309,
            59449227,
            59449840,
            59449173,
            59458690,
            59449209,
            59449159,
            59450221,
            59449398,
            59450162
        ]
    },
    "name": "A. XORinacci",
    "statement": "Cengiz recently learned Fibonacci numbers and now he is studying\r\ndifferent algorithms to find them. After getting bored of reading them,\r\nhe came with his own new type of numbers that he named numbers. He\r\ndefined them as follows: f(0) = a; f(1) = b; f(n) = f(n-1)\r\noplus f(n-2) when n > 1, where\r\noplus denotes the bitwise XOR operation. You are given three integers a,\r\nb, and n, calculate f(n).You have to answer for T independent test\r\ncases.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 25.08.2019 17:33:16       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, n;\n    cin >> a >> b >> n;\n    n %= 3;\n    if (n == 0) cout << a << '\\n'; else\n    if (n == 1) cout << b << '\\n';\n    else cout << (a ^ b) << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\A. XORinacci.json",
    "editorial_link": "https://codeforces.com/blog/entry/69357",
    "editorial": "Transform queries into two types: \"change color of a leaf\", and \"answer\r\ncolor of some vertex if k is given\". Note that when all internal\r\nvertices are red. When increasing , each vertex will change its color\r\nexactly once, letâs call this value of as boundary value for this\r\nvertex. If we can keep boundary values for all vertices, answering\r\nqueries is easy. Letâs do sqrt decomposition on queries: group them in\r\nblocks and process in blocks of size . When starting a block, compress\r\nthe tree so that there are interesting vertices: vertices involved in\r\nqueries and LCAs of them. Letâs call subtrees without interesting\r\nvertices as outer subtrees. We can compute the boundary values for all\r\nvertices in outer subtrees once for each block since the colors of\r\nleaves do not change. Now we should compress the paths between the\r\ninteresting vertices. Note that the boundary values on a path only\r\ndepend on the color of the vertex in the bottom end of the path. So for\r\neach such path compute two boundary values: if the vertex in the bottom\r\nend is red or blue. Now we can process queries by using the\r\ncorresponding values of boundary values, going down-up. Straightforward\r\nimplementation leads to preprocessing of each block and query time,\r\nmeaning the overall complexity is . The logarithms are from sorting and\r\nbinary search, respectively, so this solution is already fast enough to\r\nget AC. To implement compression in you need to go from lowest to\r\nhighest possible and maintain which vertices are red in outer subtrees.\r\nNote that the number of different boundary values is , so you can store\r\nfor each the list of vertices having this boundary value. To implement\r\nqueries in , you need to precompute binary search outcomes for the given\r\nvalues while computing the boundary values. This way the overall\r\ncomplexity becomes .\r\n",
    "hint": []
}