{
    "link": "https://codeforces.com//contest/1810/problem/E",
    "problemId": "1858190",
    "problem_idx": "E",
    "shortId": "1810E",
    "contest_number": "1810",
    "problem_submissions": {
        "H": [
            200016390,
            200313241,
            200015282,
            200812601,
            200812580
        ],
        "G": [
            199990963,
            200002014,
            199996533,
            200001110,
            200003038,
            200004181,
            200005432,
            199993820,
            200004120,
            200568360,
            200010476,
            200003987,
            200009790,
            200084069,
            200013246,
            200017198,
            200016482,
            200017082
        ],
        "F": [
            199985968,
            199984766,
            199989455,
            199989236,
            199990364,
            199996618,
            199996912,
            199994977,
            200012837,
            199994874,
            200568272,
            200001624,
            200000551,
            200004906,
            200000508,
            200003276,
            200003731,
            200007640,
            199989234,
            200033060,
            200032756,
            200032417,
            199995728
        ],
        "E": [
            199973604,
            199973630,
            199978803,
            199976534,
            199977412,
            199980989,
            199981737,
            199978795,
            199980030,
            199987523,
            200568220,
            199981333,
            199992052,
            199984164,
            199985692,
            199981426,
            199983733,
            199981446,
            199972392,
            199985691
        ],
        "D": [
            199968387,
            199968634,
            199971474,
            199971965,
            199971391,
            199974445,
            199974261,
            199971649,
            199972646,
            199975130,
            200568168,
            199974978,
            199975450,
            199972122,
            199977461,
            199974856,
            199972685,
            199972896,
            199981843,
            199971530
        ],
        "C": [
            199963369,
            199964848,
            199966060,
            199965953,
            199966410,
            199967396,
            199960693,
            199966704,
            199968525,
            199967275,
            200567509,
            199968793,
            199967659,
            199965932,
            199965761,
            199966489,
            199966901,
            199965471,
            199965927,
            199965128
        ],
        "B": [
            199960187,
            199959404,
            199963381,
            199961597,
            199960246,
            199963356,
            199965608,
            199963400,
            199964087,
            199961201,
            200567461,
            199963792,
            199967959,
            199962648,
            199961478,
            199962690,
            199964055,
            199962786,
            199961957,
            199961076
        ],
        "A": [
            199957585,
            199957600,
            199957721,
            199957828,
            199957624,
            199957823,
            199967044,
            199957994,
            199959433,
            199957593,
            200567421,
            199957914,
            199957630,
            199957622,
            199957736,
            199957568,
            199959457,
            199957708,
            199957575,
            199957879
        ]
    },
    "name": "E. Monsters",
    "statement": "There is an undirected graph with n vertices and m edges. Initially, for\r\neach vertex i, there is a monster with danger a_{i} on that vertex. For\r\na monster with danger a_{i}, you can defeat it if and only if you have\r\ndefeated at least a_{i} other monsters before.Now you want to defeat all\r\nthe monsters. First, you choose some vertex s and defeat the monster on\r\nthat vertex (since you haven\u2019t defeated any monsters before, a_{s} has\r\nto be 0). Then, you can move through the edges. If you want to move from\r\nvertex u to vertex v, then the following must hold: either the monster\r\non vertex v has been defeated before, or you can defeat it now. For the\r\nsecond case, you defeat the monster on vertex v and reach vertex v.You\r\ncan pass the vertices and the edges any number of times. Determine\r\nwhether you can defeat all the monsters or not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int leader(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return leader(x) == leader(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[leader(x)];\n    }\n};\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        \n        if (std::pair(a[u], u) < std::pair(a[v], v)) {\n            std::swap(u, v);\n        }\n        adj[u].push_back(v);\n    }\n    \n    std::vector<bool> ok(n);\n    \n    std::vector<int> order(n);\n    std::iota(order.begin(), order.end(), 0);\n    std::sort(order.begin(), order.end(), [&](int i, int j) {\n        return std::pair(a[i], i) < std::pair(a[j], j);\n    });\n    \n    DSU dsu(n);\n    \n    for (auto x : order) {\n        ok[x] = a[x] == 0;\n        for (auto y : adj[x]) {\n            y = dsu.leader(y);\n            if (ok[y] && dsu.size(y) >= a[x]) {\n                ok[x] = true;\n            }\n            dsu.merge(x, y);\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!dsu.same(0, i)) {\n            std::cout << \"NO\\n\";\n            return;\n        }\n    }\n    \n    if (ok[dsu.leader(0)]) {\n        std::cout << \"YES\\n\";\n    } else {\n        std::cout << \"NO\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Monsters.json",
    "editorial_link": "https://codeforces.com//blog/entry/114521",
    "editorial": "TutorialFor some vertex set , let\u00e2\u0080\u0099s define as the \u00e2\u0080\u009dneighbours\u00e2\u0080\u009d of vertex\r\nset . Formally, if and only if , but there exist some vertex , such that\r\nthere\u00e2\u0080\u0099s an edge in the graph, and .Now let\u00e2\u0080\u0099s consider how to solve the\r\nproblem for some fixed starting vertex ? Let\u00e2\u0080\u0099s maintain the set and .\r\nInitially, . We keep doing the procedure: choose a vertex with minimal\r\nvalue . If , we add into set , and update set simultaneously. Since is\r\nalways connected during the procedure, we are actually doing such a\r\nthing: find a vertex that is \u00e2\u0080\u009dreachable\u00e2\u0080\u009d now with minimal value , and\r\ntry to defeat the monster on it. Our goal is to find some such that\r\n.Then let\u00e2\u0080\u0099s move to a lemma: if , then . ProofIf it is not, consider the\r\nprocedure above and the first time we add some vertex such that into .\r\nAt this moment, must hold(since it\u00e2\u0080\u0099s the first time we add some vertex\r\nnot in ). On the other side, must hold, and hence . Thus, we can not add\r\ninto .Then we can tell, if , then for , . So it\u00e2\u0080\u0099s unnecessary to search\r\nstarting from . And we can construct such an algorithm: Search from in\r\norder, if some has been included in some before, do not search from\r\nit.Surprisingly, this algorithm is correct. We can prove it\u00e2\u0080\u0099s time\r\ncomplexity. For each vertex , if now, and when searching from vertex ,\r\nis add into again, then . Thus, one vertex can not be visited more than\r\ntimes, which means the time complexity is .This problem has many other\r\nmethods to solve. This one I think is the easiest to implement.\r\n"
}