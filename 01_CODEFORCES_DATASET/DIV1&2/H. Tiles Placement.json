{
    "link": "https://codeforces.com//contest/1214/problem/H",
    "problemId": "403811",
    "problem_idx": "H",
    "shortId": "1214H",
    "contest_number": "1214",
    "problem_submissions": {
        "G": [
            60015427,
            60116387,
            60017546,
            60017495,
            60020107,
            60006609,
            60352777,
            60002997,
            60009463,
            60011243
        ],
        "H": [
            60007228,
            60007997,
            60003236,
            60009685,
            60010066,
            60011259,
            60011282,
            60010896,
            60009334,
            60014724,
            60008843,
            60014112,
            60047947,
            60007110,
            60062101,
            60075338
        ],
        "F": [
            59997972,
            59999955,
            60011529,
            60001435,
            59997615,
            60004519,
            60003172,
            60003385,
            60014786,
            60014588,
            60009696,
            60014299,
            60009888,
            60047758,
            60003766,
            59999966,
            60002829,
            60000810
        ],
        "E": [
            59991588,
            59992896,
            59995584,
            59992549,
            59995811,
            59995619,
            59997178,
            59995808,
            59993809,
            59992236,
            59997269,
            59997999,
            59997711,
            59993230,
            59995040,
            59995208,
            59994715,
            59993710,
            59996947,
            59988545
        ],
        "D": [
            59988102,
            59989658,
            59989675,
            59986719,
            59990868,
            59992865,
            59990765,
            59991828,
            59988538,
            59989605,
            59989462,
            59992741,
            59999498,
            59988876,
            60017942,
            59989391,
            59991386,
            59989567,
            59990626,
            60046854,
            59985851
        ],
        "C": [
            59984445,
            59985337,
            59984895,
            59983957,
            59985031,
            59985481,
            59984019,
            59986980,
            59984427,
            59984066,
            59984382,
            59987002,
            59982712,
            59984754,
            59984720,
            59985711,
            59985097,
            59984496,
            59982839,
            59983656
        ],
        "B": [
            59983717,
            59984061,
            59983687,
            59983257,
            59983195,
            59983710,
            59983075,
            59985335,
            59983154,
            59983158,
            59983522,
            59985251,
            59983191,
            59983505,
            59982763,
            59984237,
            59983907,
            59983359,
            59984573,
            59982988
        ],
        "A": [
            59982834,
            59982716,
            59982610,
            59982747,
            59982737,
            59982711,
            59982633,
            59982961,
            59982657,
            59982623,
            59982788,
            59982811,
            59983962,
            59982673,
            59985703,
            59982891,
            59983099,
            59982727,
            59985651,
            59982701
        ]
    },
    "name": "H. Tiles Placement",
    "statement": "The new pedestrian zone in Moscow city center consists of n squares\r\nconnected with each other by n - 1 footpaths. We define a as a sequence\r\nof squares such that no square appears in this sequence twice and any\r\ntwo adjacent squares in this sequence are directly connected with a\r\nfootpath. The size of a simple path is the number of squares in it. The\r\nfootpaths are designed in a such a way that there is exactly one simple\r\npath between any pair of different squares.During preparations for\r\nMoscow City Day the city council decided to renew ground tiles on all n\r\nsquares. There are k tile types of different colors, numbered from 1 to\r\nk. For each square exactly one tile type must be selected and then used\r\nto cover this square surface. To make walking through the city center\r\nmore fascinating, it was decided to select tiles types for each square\r\nin such a way that any possible simple path of size exactly k contains\r\nsquares with all k possible tile colors.You need to find out whether it\r\nis possible to place the tiles this way or not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\n\n#define LOGN 19\n\nconst int N=201000;\nint p[N][22],dep[N];\nint n,k,u,v,lev[N],vis[N],col[N];\nVI e[N];\nvoid dfs(int u,int f) {\n\tp[u][0]=f;\n\tdep[u]=dep[f]+1;\n\tfor (auto v:e[u]) if (v!=f) {\n\t\tdfs(v,u);\n\t}\n}\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) v=p[v][i];\n\tif (u==v) return u;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) u=p[u][i],v=p[v][i];\n\treturn p[u][0];\n}\nint dist(int u,int v) {\n\treturn dep[u]+dep[v]-2*dep[lca(u,v)];\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\trep(j,1,LOGN) rep(i,1,n+1) p[i][j]=p[p[i][j-1]][j-1];\n\tint pu=1,pd=0;\n\trep(i,1,n+1) {\n\t\tint d=dist(1,i);\n\t\tif (d>pd) pd=d,pu=i;\n\t}\n\tint pv=pu; pd=0;\n\trep(i,1,n+1) {\n\t\tint d=dist(pu,i);\n\t\tif (d>pd) pd=d,pv=i;\n\t}\n//\tprintf(\"%d %d %d\\n\",pu,pv,pd);\n\trep(i,1,n+1) {\n\t\tint d1=dist(pu,i);\n\t\tif (d1+dist(pv,i)==pd) {\n\t\t\tvis[i]=1;\n\t\t\tlev[i]=d1;\n\t\t}\n\t}\n\tif (k==2) {\n\t\tputs(\"Yes\");\n\t\trep(i,1,n+1) printf(\"%d%c\",dep[i]%2+1,\" \\n\"[i==n]);\n\t\treturn 0;\n\t}\n\t--k;\n\trep(i,1,n+1) {\n\t\tif (vis[i]) continue;\n\t\tint d1=dist(i,pu),d2=dist(i,pv);\n\t\tif (d1>=k&&d2>=k) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (d1<k&&d2<k) {\n\t\t\tif (d1==d2) lev[i]=0;\n\t\t\telse if (d1>d2) lev[i]=d1;\n\t\t\telse lev[i]=pd-d2;\n\t\t} else if (d1>=k) {\n\t\t\tlev[i]=d1;\n\t\t} else {\n\t\t\tlev[i]=pd-d2;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\n\n\trep(i,1,n+1) {\n\t\tprintf(\"%d%c\",lev[i]%(k+1)+1,\" \\n\"[i==n]);\n\t\tcol[i]=lev[i]%(k+1)+1;\n\t}\n/*\trep(i,1,n+1) rep(j,1,n+1) if (dist(i,j)==k) {\n\t\tset<int> cc;\n\t\trep(z,1,n+1) if (dist(i,z)+dist(z,j)==k) cc.insert(col[z]);\n\t\tassert(SZ(cc)==k+1);\n\t}*/\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Tiles Placement.json",
    "editorial_link": "https://codeforces.com/blog/entry/69563",
    "editorial": "Suppose there exists a vertex with tree with a tree paths going from it,\r\nwith longest paths of lengths , and (in edges). Then if , , , then\r\nclearly the answer is Impossible.We can check whether such vertex exists\r\nin using subtree dp and \"uptree dp\".Good news: this is the only case\r\nwhen the answer is \"No\".Bad news: providing the coloring is slightly\r\nmore sophisticated.In fact, we can prove that the following coloring\r\nworks: Construct a tree\u00e2\u0080\u0099s diameter. Color vertices on diameter with\r\nperiodic colors: , , ..., , , , ... By the way, if diameter has less\r\nthan vertices, any coloring will be correct. Cut the diameter in half,\r\nthe parts\u00e2\u0080\u0099 lengths will differ by atmost. Color both halves of the tree\r\nwith dfs: colors in the left part will decrease , while colors in the\r\nright part will increase . The result will look roughly as follows: The\r\ntotal complexity is .Let\u00e2\u0080\u0099s give a sketch of the why this coloring works.\r\nWell, suppose there is some bad path of vertices. Let\u00e2\u0080\u0099s analyze path\u00e2\u0080\u0099s\r\nposition with respect to the diameter.. The bad path is not related to\r\nthe diameter. It\u00e2\u0080\u0099s easy to see that blue part of diameter is greater or\r\nequal than any half of the red path; so the vertex is a bad vertex to\r\nthe our criterion.. The bad path goes through a diameter, but lies in\r\none half of it. The vertex makes a bad vertex for the criterion, just\r\nfor the same reasons.. The bad path goes through a diameter, and lies in\r\nboth halves. If you recall how our coloring looks like, you will see\r\nthat all paths of this form are well-colored.\r\n"
}