{"link": "https://codeforces.com//contest/1214/problem/H", "problemId": "403811", "problem_idx": "H", "shortId": "1214H", "contest_number": "1214", "problem_submissions": {"G": [60015427, 60116387, 60017546, 60017495, 60020107, 60006609, 60352777, 60002997, 60009463, 60011243], "H": [60007228, 60007997, 60003236, 60009685, 60010066, 60011259, 60011282, 60010896, 60009334, 60014724, 60008843, 60014112, 60047947, 60007110, 60062101, 60075338], "F": [59997972, 59999955, 60011529, 60001435, 59997615, 60004519, 60003172, 60003385, 60014786, 60014588, 60009696, 60014299, 60009888, 60047758, 60003766, 59999966, 60002829, 60000810], "E": [59991588, 59992896, 59995584, 59992549, 59995811, 59995619, 59997178, 59995808, 59993809, 59992236, 59997269, 59997999, 59997711, 59993230, 59995040, 59995208, 59994715, 59993710, 59996947, 59988545], "D": [59988102, 59989658, 59989675, 59986719, 59990868, 59992865, 59990765, 59991828, 59988538, 59989605, 59989462, 59992741, 59999498, 59988876, 60017942, 59989391, 59991386, 59989567, 59990626, 60046854, 59985851], "C": [59984445, 59985337, 59984895, 59983957, 59985031, 59985481, 59984019, 59986980, 59984427, 59984066, 59984382, 59987002, 59982712, 59984754, 59984720, 59985711, 59985097, 59984496, 59982839, 59983656], "B": [59983717, 59984061, 59983687, 59983257, 59983195, 59983710, 59983075, 59985335, 59983154, 59983158, 59983522, 59985251, 59983191, 59983505, 59982763, 59984237, 59983907, 59983359, 59984573, 59982988], "A": [59982834, 59982716, 59982610, 59982747, 59982737, 59982711, 59982633, 59982961, 59982657, 59982623, 59982788, 59982811, 59983962, 59982673, 59985703, 59982891, 59983099, 59982727, 59985651, 59982701]}, "name": "H. Tiles Placement", "statement": "The new pedestrian zone in Moscow city center consists of n squares\r\nconnected with each other by n - 1 footpaths. We define a as a sequence\r\nof squares such that no square appears in this sequence twice and any\r\ntwo adjacent squares in this sequence are directly connected with a\r\nfootpath. The size of a simple path is the number of squares in it. The\r\nfootpaths are designed in a such a way that there is exactly one simple\r\npath between any pair of different squares.During preparations for\r\nMoscow City Day the city council decided to renew ground tiles on all n\r\nsquares. There are k tile types of different colors, numbered from 1 to\r\nk. For each square exactly one tile type must be selected and then used\r\nto cover this square surface. To make walking through the city center\r\nmore fascinating, it was decided to select tiles types for each square\r\nin such a way that any possible simple path of size exactly k contains\r\nsquares with all k possible tile colors.You need to find out whether it\r\nis possible to place the tiles this way or not.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\n\n#define LOGN 19\n\nconst int N=201000;\nint p[N][22],dep[N];\nint n,k,u,v,lev[N],vis[N],col[N];\nVI e[N];\nvoid dfs(int u,int f) {\n\tp[u][0]=f;\n\tdep[u]=dep[f]+1;\n\tfor (auto v:e[u]) if (v!=f) {\n\t\tdfs(v,u);\n\t}\n}\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) v=p[v][i];\n\tif (u==v) return u;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) u=p[u][i],v=p[v][i];\n\treturn p[u][0];\n}\nint dist(int u,int v) {\n\treturn dep[u]+dep[v]-2*dep[lca(u,v)];\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\trep(j,1,LOGN) rep(i,1,n+1) p[i][j]=p[p[i][j-1]][j-1];\n\tint pu=1,pd=0;\n\trep(i,1,n+1) {\n\t\tint d=dist(1,i);\n\t\tif (d>pd) pd=d,pu=i;\n\t}\n\tint pv=pu; pd=0;\n\trep(i,1,n+1) {\n\t\tint d=dist(pu,i);\n\t\tif (d>pd) pd=d,pv=i;\n\t}\n//\tprintf(\"%d %d %d\\n\",pu,pv,pd);\n\trep(i,1,n+1) {\n\t\tint d1=dist(pu,i);\n\t\tif (d1+dist(pv,i)==pd) {\n\t\t\tvis[i]=1;\n\t\t\tlev[i]=d1;\n\t\t}\n\t}\n\tif (k==2) {\n\t\tputs(\"Yes\");\n\t\trep(i,1,n+1) printf(\"%d%c\",dep[i]%2+1,\" \\n\"[i==n]);\n\t\treturn 0;\n\t}\n\t--k;\n\trep(i,1,n+1) {\n\t\tif (vis[i]) continue;\n\t\tint d1=dist(i,pu),d2=dist(i,pv);\n\t\tif (d1>=k&&d2>=k) {\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (d1<k&&d2<k) {\n\t\t\tif (d1==d2) lev[i]=0;\n\t\t\telse if (d1>d2) lev[i]=d1;\n\t\t\telse lev[i]=pd-d2;\n\t\t} else if (d1>=k) {\n\t\t\tlev[i]=d1;\n\t\t} else {\n\t\t\tlev[i]=pd-d2;\n\t\t}\n\t}\n\tputs(\"Yes\");\n\n\n\trep(i,1,n+1) {\n\t\tprintf(\"%d%c\",lev[i]%(k+1)+1,\" \\n\"[i==n]);\n\t\tcol[i]=lev[i]%(k+1)+1;\n\t}\n/*\trep(i,1,n+1) rep(j,1,n+1) if (dist(i,j)==k) {\n\t\tset<int> cc;\n\t\trep(z,1,n+1) if (dist(i,z)+dist(z,j)==k) cc.insert(col[z]);\n\t\tassert(SZ(cc)==k+1);\n\t}*/\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "trees"], "dificulty": "2800", "interactive": false}