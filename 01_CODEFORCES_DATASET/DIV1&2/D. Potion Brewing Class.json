{
    "link": "https://codeforces.com//contest/1654/problem/D",
    "problemId": "1337001",
    "problem_idx": "D",
    "shortId": "1654D",
    "contest_number": "1654",
    "problem_submissions": {
        "G": [
            150299206,
            150291434,
            150262682,
            150264693,
            150279932,
            150262802,
            150264575,
            150265515,
            150270995,
            150269889,
            150268570,
            150658744,
            150262050,
            150410744
        ],
        "F": [
            150251411,
            150252834,
            150256351,
            150258591,
            150257352,
            150258765,
            150260950,
            150260548,
            150253390,
            155820292,
            150253676,
            150260302,
            150259236,
            150258476,
            150253068,
            150258272,
            150260151,
            150258857,
            150253870
        ],
        "E": [
            150249388,
            150250832,
            150247329,
            150252856,
            150255337,
            150250196,
            150255012,
            150258473,
            150245581,
            150250984,
            150250253,
            150246690,
            150250591,
            150243463,
            150281667,
            150281018,
            150257789,
            150252457,
            150252381,
            150254404,
            150260615
        ],
        "D": [
            150242905,
            150248369,
            150245387,
            150248435,
            150250315,
            150245874,
            150249516,
            150253299,
            150250969,
            150245477,
            150245136,
            150243688,
            150246539,
            150254801,
            150249615,
            150245204,
            150245282,
            150246887,
            150243365
        ],
        "C": [
            150236387,
            150236280,
            150236050,
            150237265,
            150241937,
            150237951,
            150242839,
            150238439,
            150239664,
            150239447,
            150236298,
            150237311,
            150240477,
            150246874,
            150236567,
            150236644,
            150238032,
            150240021,
            150238619
        ],
        "B": [
            150233906,
            150232250,
            150249236,
            150233827,
            150235226,
            150232832,
            150239572,
            150233210,
            150235633,
            150231291,
            150231026,
            150232476,
            150233263,
            150235368,
            150231705,
            150232694,
            150231566,
            150233122,
            150232190
        ],
        "A": [
            150228234,
            150228426,
            150228045,
            150228869,
            150232031,
            150228616,
            150230908,
            150228192,
            150232849,
            150228032,
            150227955,
            150228792,
            150228208,
            150229654,
            223450681,
            150228295,
            150228644,
            150228162,
            150228813,
            150228169
        ],
        "H": [
            150278254,
            150276173,
            150276315,
            150560549
        ]
    },
    "name": "D. Potion Brewing Class",
    "statement": "Alice\u2019s potion making professor gave the following assignment to his\r\nstudents: brew a potion using n ingredients, such that the proportion of\r\ningredient i in the final potion is r_i > 0 (and r_1 + r_2 +\r\ncdots + r_n = 1).He forgot the recipe, and now all he remembers is a set\r\nof n-1 facts of the form, \"ingredients i and j should have a ratio of x\r\nto y\" (i.e., if a_i and a_j are the amounts of ingredient i and j in the\r\npotion respectively, then it must hold a_i/a_j = x/y), where x and y are\r\npositive integers. However, it is guaranteed that the set of facts he\r\nremembers is sufficient to uniquely determine the original values r_i.He\r\ndecided that he will allow the students to pass the class as long as\r\nthey submit a potion which satisfies all of the n-1 requirements (there\r\nmay be many such satisfactory potions), and contains a positive integer\r\namount of each ingredient.Find the minimum total amount of ingredients\r\nneeded to make a potion which passes the class. As the result can be\r\nvery large, you should print the answer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\npair<vector<int>, vector<int>> sieve(int n) {\n\tvector<int> erat(n + 1);\n\tvector<int> primes;\n\terat[1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (erat[i] == 0) {\n\t\t\terat[i] = i;\n\t\t\tprimes.push_back(i);\n\t\t}\n\t\tfor (int p : primes) {\n\t\t\tif (p > erat[i] || i * p > n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terat[i * p] = p;\n\t\t}\n\t}\n\treturn {erat, primes};\n}\n\ntemplate <class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate <class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate <class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\ntemplate <uint32_t base>\nstruct Montgomery {\n\tusing i32 = int32_t;\n\tusing u32 = uint32_t;\n\tusing u64 = uint64_t;\n\n\tstatic constexpr u32 mod() {\n\t\treturn base;\n\t}\n\n\tstatic constexpr u32 np = []() {\n\t\tu32 x = base;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tx *= 2u - base * x;\n\t\t}\n\t\treturn -x;\n\t}();\n\tstatic constexpr u32 r2 = -(u64)(base) % base;\n\n\tstatic_assert(base < (1u << 30));\n\tstatic_assert(base * np + 1 == 0);\n\n\tstatic u32 reduce(u64 x) {\n\t\treturn (x + (u64)((u32)x * np) * base) >> 32;\n\t}\n\n\tu32 x;\n\tMontgomery(): x(0) {}\n\tconstexpr Montgomery(long long y): x(y ? reduce((u64)(y % base + base) * r2) : 0) {}\n\n\tMontgomery& operator +=(const Montgomery& ot) {\n\t\tif ((i32)(x += ot.x - 2 * base) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator -=(const Montgomery& ot) {\n\t\tif ((i32)(x -= ot.x) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator *=(const Montgomery& ot) {\n\t\tx = reduce((u64)x * ot.x);\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator /=(const Montgomery& ot) {\n\t\treturn *this *= ot.inverse();\n\t}\n\n\tfriend Montgomery operator +(Montgomery a, const Montgomery& b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator -(Montgomery a, const Montgomery& b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator *(Montgomery a, const Montgomery& b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator /(Montgomery a, const Montgomery& b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\n\tMontgomery operator -() const {\n\t\treturn Montgomery() - *this;\n\t}\n\n\tu32 get() const {\n\t\tu32 res = reduce(x);\n\t\treturn res < base ? res : res - base;\n\t}\n\n\tu32 operator ()() const {\n\t\treturn get();\n\t}\n\n\tMontgomery inverse() const {\n\t\treturn pow(base - 2);\n\t}\n\n\tMontgomery inv() const {\n\t\treturn inverse();\n\t}\n\n\tMontgomery pow(int64_t p) const {\n\t\tif (p < 0) {\n\t\t\treturn pow(-p).inverse();\n\t\t}\n\t\tMontgomery res = 1;\n\t\tMontgomery a = *this;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\ta *= a;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend istream& operator >>(istream& istr, Montgomery& m) {\n\t\tlong long x;\n\t\tistr >> x;\n\t\tm = Montgomery(x);\n\t\treturn istr;\n\t}\n\n\tfriend ostream& operator <<(ostream& ostr, const Montgomery& m) {\n\t\treturn ostr << m.get();\n\t}\n\n\tbool operator ==(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) == (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\tbool operator !=(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) != (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\texplicit operator int64_t() const {\n\t\treturn x;\n\t}\n\n\texplicit operator bool() const {\n\t\treturn x;\n\t}\n};\n\nconstexpr int mod = 998'244'353;\nusing Mint = Montgomery<mod>;\n\nstruct Edge {\n\tint to;\n\tint x, y;\n};\n\nvoid remin(int& x, int y) {\n\tx = (x < y) ? x : y;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tauto erat = sieve(n).first;\n\tvector<vector<Edge>> a(n);\n\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\tint x = nxt(), y = nxt();\n\t\ta[u].push_back({v, x, y});\n\t\ta[v].push_back({u, y, x});\n\t}\n\n\tvector<int> mind(n + 1);\n\tvector<int> curd(n + 1);\n\tauto add = [&](int x, int val) {\n\t\twhile (x > 1) {\n\t\t\tint p = erat[x];\n\t\t\tx /= p;\n\t\t\tremin(mind[p], curd[p] += val);\n\t\t}\n\t};\n\n\tvector<Mint> val(n, 1);\n\n\tauto dfs = y_combinator([&](auto self, int v, int p) -> void {\n\t\tfor (auto [to, x, y] : a[v]) {\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd(y, 1);\n\t\t\tadd(x, -1);\n\t\t\tval[to] = val[v] * y / x;\n\t\t\tself(to, v);\n\t\t\tadd(x, 1);\n\t\t\tadd(y, -1);\n\t\t}\n\t});\n\tdfs(0, -1);\n\n\tMint ans = accumulate(all(val), Mint(0));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans *= Mint(i).pow(-mind[i]);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Potion Brewing Class.json",
    "editorial_link": "https://codeforces.com//blog/entry/100127",
    "editorial": "SolutionRead the hints. The rest is just implementation.Start a DFS from\r\nnode . Keep an array such that is the exponent of in the amount of\r\ningredients of the current node. Keep also . At the beginning, the\r\namount of ingredients (of node ) is , so for each . Whenever you move\r\nfrom node to node , and , for each such that and , decrease by ; for\r\neach such that and , increase by . Notice that there exist such values\r\nof for each edge, and you can find them by precalculating either the\r\nsmallest prime factor (with the sieve of Eratosthenes) or the whole\r\nfactorization of every integer in .Let be the minimum value of during\r\nthe DFS. Then, for every , you have to multiply the amount of\r\ningredients of node by .The answer is the sum of , multiplied by the\r\namount of ingredients of node .Complexity:\r\n"
}