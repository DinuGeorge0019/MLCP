{
    "link": "https://codeforces.com//contest/1740/problem/B",
    "problemId": "1611411",
    "problem_idx": "B",
    "shortId": "1740B",
    "contest_number": "1740",
    "problem_submissions": {
        "H": [
            178379430,
            178389839,
            178370970,
            178389787,
            178394159,
            178405718,
            178393380,
            178400994,
            178473578
        ],
        "G": [
            178363447,
            178373152,
            178390136,
            178380782,
            178380133,
            178366412,
            178381208,
            178372252,
            178364309,
            178377085,
            178379805,
            178389960,
            178394186,
            178390668,
            178429073,
            178399239,
            178398964,
            178398319,
            178393777,
            178389532,
            178457114,
            178457090,
            178457069,
            178456881,
            178456598
        ],
        "F": [
            178342509,
            178355726,
            178353094,
            178359313,
            178375325,
            178347566,
            178343206,
            178355344,
            178419766,
            178363409,
            178364030,
            178360259,
            178371042,
            178378751,
            178405026,
            178404845,
            178404014,
            178403791,
            178403569,
            178376955,
            178368121,
            178355891,
            178355560,
            178363171,
            178364934
        ],
        "E": [
            178337370,
            178346224,
            178348715,
            178344194,
            178352039,
            178338198,
            178335731,
            178340043,
            178343562,
            178350554,
            178352735,
            178349059,
            178343925,
            178345775,
            178364103,
            178352981,
            178344981,
            178359372,
            178346165,
            178350475
        ],
        "D": [
            178334153,
            178339631,
            178345824,
            178338369,
            178344365,
            178352777,
            178346625,
            178336331,
            178336614,
            178338914,
            178339308,
            178344306,
            178335725,
            178354316,
            178351979,
            178370227,
            178339993,
            178338550,
            178340955,
            178340858
        ],
        "C": [
            178329483,
            178334722,
            178336471,
            178331649,
            178333101,
            178332328,
            178330724,
            178331197,
            178330550,
            178331983,
            178331086,
            178337583,
            178330090,
            178335594,
            178335112,
            178340402,
            178335550,
            178333891,
            178336207,
            178332182
        ],
        "B": [
            178326239,
            178328080,
            178333593,
            178327287,
            178329054,
            178327314,
            178327001,
            178329448,
            178327787,
            178327568,
            178327277,
            178328845,
            178326455,
            178328799,
            178328762,
            178333879,
            178327499,
            178329269,
            178328122,
            178330549
        ],
        "A": [
            178322883,
            178322996,
            178323296,
            178323217,
            178323002,
            178322816,
            178327673,
            178322982,
            178323305,
            178322810,
            178323224,
            178323080,
            178322764,
            178323327,
            178324186,
            178325267,
            178322814,
            178324090,
            178323226,
            178322754
        ],
        "I": [
            179538712
        ]
    },
    "name": "B. Jumbo Extra Cheese 2",
    "statement": "Pak Chanek has n two-dimensional slices of cheese. The i-th slice of\r\ncheese can be represented as a rectangle of dimensions a_i\r\ntimes b_i. We want to arrange them on the two-dimensional plane such\r\nthat: Each edge of each cheese is parallel to either the x-axis or the\r\ny-axis. The bottom edge of each cheese is a segment of the x-axis. No\r\ntwo slices of cheese overlap, but their sides can touch. They form one\r\nconnected shape. Note that we can arrange them in any order (the\r\nleftmost slice of cheese is not necessarily the first slice of cheese).\r\nAlso note that we can rotate each slice of cheese in any way as long as\r\nall conditions still hold.Find the minimum possible perimeter of the\r\nconstructed shape.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    i64 ans = 0;\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i] >> b[i];\n        if (a[i] > b[i]) {\n            std::swap(a[i], b[i]);\n        }\n        ans += a[i];\n    }\n    ans += *std::max_element(b.begin(), b.end());\n    ans *= 2;\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "greedy",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Jumbo Extra Cheese 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/108567",
    "editorial": "According to the problem, the arrays and denote the dimensions of the\r\nrectangles. Define arrays and as a certain orientation configuration of\r\nthe rectangles with denoting the width and denoting the height. Define\r\narrays and as a certain permutation of the orientation configuration\r\nsuch that the -th rectangle from the left has width and height .Consider\r\na certain configuration of and . The perimeter of the connected shape\r\nwill be .Notice that if we sort the rectangles based on , the perimeter\r\nwould become . This is actually the minimum possible perimeter for a\r\nfixed configuration of and as we cannot get a smaller perimeter than\r\nthis. This means, if we have a certain configuration of and , the\r\noptimal perimeter is . Now, we just need to find a configuration of and\r\nfrom and that results in the minimum value of .Notice that each element\r\nof and can only be counted either or times in the final answer. Consider\r\nthe maximum value out of all elements of and . If there are multiple\r\nvalues that are maximum, just consider one of them. We can see that that\r\nvalue will always be counted times no matter how we construct and .We\r\nneed to determine whether to put that maximum value in (width) or\r\n(height). It is actually better to put that value in as it will cause\r\nall other values of to be counted times in the final answer.Now, we just\r\nneed to determine the orientation for each of the other rectangles. We\r\nhave determined that the maximum value in and must be put in , which\r\nwill automatically become the value of . Therefore, all other values in\r\nwill be counted times in the final answer. This means, because we want\r\nto minimise the final answer, for each , it is always better to put the\r\nlarger value out of and in as it will cause the value that is not being\r\ncounted in the final answer to be larger.Using every observation above,\r\nin order to get the minimum possible perimeter, we can do the following:\r\nConstruct the arrays and with and taking their values from and while\r\nmaking . The answer is . Time complexity for each test case:\r\n"
}