{
    "link": "https://codeforces.com//contest/914/problem/G",
    "problemId": "148493",
    "problem_idx": "G",
    "shortId": "914G",
    "contest_number": "914",
    "problem_submissions": {
        "E": [
            34383567,
            34380688,
            34384037,
            34379971,
            34385853,
            34381341,
            34377061,
            34385471,
            34377068,
            34383097,
            34381216,
            34377930,
            34393845,
            34378590,
            34386380,
            34381164
        ],
        "C": [
            34382803,
            34382793,
            34364057,
            34365651,
            34386486,
            34396063,
            34363721,
            34365741,
            34364774,
            34366702,
            34391506,
            34365007,
            34367351,
            34382826,
            34374119,
            34384464,
            34372151,
            34370073
        ],
        "G": [
            34376415,
            34377275,
            34377412,
            34382707,
            34380896,
            34376017,
            34382091,
            34379406,
            34377065,
            34381510,
            34378767,
            34384171,
            34382760,
            34380461,
            34386445,
            34380566,
            34388276,
            34376347,
            34387872,
            34388821
        ],
        "F": [
            34372924,
            34364964,
            34388114,
            34388527,
            34377465,
            34383969,
            34384849,
            34382075,
            34408585,
            34427444,
            34427415,
            34427411,
            34427369,
            34426234,
            34426219,
            34426204,
            34426181,
            34395428,
            34395305,
            34393742,
            34393096,
            34392685,
            34377829,
            34381405,
            34389663,
            34384026
        ],
        "D": [
            34370762,
            34371655,
            34369773,
            34368591,
            34374188,
            34367037,
            34369044,
            34372797,
            34370541,
            34371781,
            34370647,
            34370823,
            34372317,
            34370221,
            34393812,
            34371853,
            34371865,
            34370930,
            34372046,
            34375276,
            34374115
        ],
        "B": [
            34360667,
            34360722,
            34374939,
            34362210,
            34374843,
            34362983,
            34377719,
            34363222,
            34359679,
            34359608,
            34366166,
            34384598,
            34360320,
            34360372,
            34361647,
            34362020,
            34368128,
            34362137,
            34362752,
            34361533
        ],
        "A": [
            34357760,
            34358042,
            34374626,
            34357833,
            34358764,
            34358376,
            34358219,
            34358285,
            34357836,
            34357713,
            34358130,
            34358072,
            34357931,
            34391604,
            34358333,
            34358022,
            34358632,
            34358260,
            34359117,
            34357845
        ],
        "H": [
            34391572,
            34389095
        ]
    },
    "name": "G. Sum the Fibonacci",
    "statement": "You are given an array of non-negative integers.A 5-tuple of integers is\r\nsaid to be valid if it satisfies the following conditions: | & & ^ for\r\nsome integer & Here, ’|’ is the bitwise OR, ’&’ is the bitwise AND and\r\n’^’ is the bitwise XOR operation.Find the sum of |^ over all valid\r\n5-tuples , where is the -th Fibonnaci number ().Since answer can be is\r\nhuge output it modulo .\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int P=1000000007;\ninline int Pow(int a,int b){\n\tint c=1;\n\tfor(;b;b>>=1,a=a*1ll*a%P)if(b&1)c=c*1ll*a%P;\n\treturn c;\n}\ninline void FWT(int *A,int f,int N){\n    int p2=Pow(2,P-2);\n    for(int i=1;i<N;i<<=1)\n    for(int j=0;j<N;j+=(i<<1))\n    for(int k=0;k<i;k++){\n        int x0=A[j+k];int x1=A[i+j+k];\n        if(f==0){\n            A[j+k]=(x0-x1+P)%P;\n            A[i+j+k]=(x0+x1)%P;\n        }\n        else{\n            A[j+k]=(x0+x1)*1ll*p2%P;\n            A[i+j+k]=(x1-x0)*1ll*p2%P;\n            if(A[i+j+k]<0)A[i+j+k]+=P;\n        }\n    }\n}\nconst int N=1<<17;\nint cnt[N];\nint ss;\nint n=17;\nint f[N][18];\nint bit[N];\nint gt[18];\nint p1[N];\nint p2[N];\n\nint p3[N];\n\nint fib[N];\nvoid tr(int *a){\n\trep(i,0,n-1)per(S,(1<<n)-1,0)if(!(S&(1<<i)))a[S]=(a[S]+a[S^(1<<i)])%P;\n}\nvoid ntr(int *a){\n\tper(i,n-1,0)rep(S,0,(1<<n)-1)if(!(S&(1<<i)))a[S]=(a[S]+P-a[S^(1<<i)])%P;\n}\nint main(){\n\tscanf(\"%d\",&ss);\n\trep(i,1,(1<<n)-1)bit[i]=bit[i>>1]+(i&1);\n\tfib[0]=0;fib[1]=1;\n\trep(i,2,(1<<n)-1)fib[i]=(fib[i-1]+fib[i-2])%P;\n\twhile(ss--){\n\t\tint x;scanf(\"%d\",&x);\n\t\tcnt[x]++;\n\t}\n\trep(i,0,(1<<n)-1){\n\t\tf[i][bit[i]]=cnt[i];\n\t}\n\trep(i,0,n-1)rep(S,0,(1<<n)-1)if(S&(1<<i))rep(j,0,n)f[S][j]=(f[S][j]+f[S^(1<<i)][j])%P;\n\trep(S,0,(1<<n)-1){\n\t\tmemset(gt,0,sizeof gt);\n\t\trep(i,0,n)rep(j,0,n-i)gt[i+j]=(gt[i+j]+f[S][i]*1ll*f[S][j])%P;\n\t\trep(i,0,n)f[S][i]=gt[i];\n\t}\n\tper(i,n-1,0)per(S,(1<<n)-1,0)if(S&(1<<i))rep(j,0,n)f[S][j]=(f[S][j]+P-f[S^(1<<i)][j])%P;\n\trep(S,0,(1<<n)-1)p1[S]=f[S][bit[S]]*1ll*fib[S]%P;\n\trep(S,0,(1<<n)-1)p2[S]=cnt[S]*1ll*fib[S]%P;\n\n\trep(S,0,(1<<n)-1)p3[S]=cnt[S];\n\n\tFWT(p3,0,1<<n);\n\trep(S,0,(1<<n)-1)p3[S]=p3[S]*1ll*p3[S]%P;\n\tFWT(p3,1,1<<n);\n\trep(S,0,(1<<n)-1)p3[S]=p3[S]*1ll*fib[S]%P;\n\n\ttr(p1);tr(p2);tr(p3);\n\trep(i,0,(1<<n)-1)p1[i]=(p1[i]*1ll*p2[i]%P)*1ll*p3[i]%P;\n\tntr(p1);\n\tint ans=0;\n\trep(i,0,n-1)ans=(ans+p1[1<<i])%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "divide and conquer",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Sum the Fibonacci.json",
    "editorial_link": "https://codeforces.com//blog/entry/57250",
    "editorial": "Apologies, we didnât expect an solution. The expected solution was as\r\nfollows.Let be the number of pairs in the array such that their bitwise\r\nOR is and , multiplied by . This can be done using subset convolution.\r\nLet be the count of each element in array, multiplied by . Let be the\r\nnumber of pairs such that their bitwise xor is , multiplied by . This\r\ncan be done using Xor convolution.Let be the And Convolution of , , and\r\n. Then the answer is given by the expression .Complexity:\r\n",
    "hint": []
}