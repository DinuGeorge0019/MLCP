{
    "link": "https://codeforces.com//contest/1214/problem/E",
    "problemId": "403808",
    "problem_idx": "E",
    "shortId": "1214E",
    "contest_number": "1214",
    "problem_submissions": {
        "G": [
            60015427,
            60116387,
            60017546,
            60017495,
            60020107,
            60006609,
            60352777,
            60002997,
            60009463,
            60011243
        ],
        "H": [
            60007228,
            60007997,
            60003236,
            60009685,
            60010066,
            60011259,
            60011282,
            60010896,
            60009334,
            60014724,
            60008843,
            60014112,
            60047947,
            60007110,
            60062101,
            60075338
        ],
        "F": [
            59997972,
            59999955,
            60011529,
            60001435,
            59997615,
            60004519,
            60003172,
            60003385,
            60014786,
            60014588,
            60009696,
            60014299,
            60009888,
            60047758,
            60003766,
            59999966,
            60002829,
            60000810
        ],
        "E": [
            59991588,
            59992896,
            59995584,
            59992549,
            59995811,
            59995619,
            59997178,
            59995808,
            59993809,
            59992236,
            59997269,
            59997999,
            59997711,
            59993230,
            59995040,
            59995208,
            59994715,
            59993710,
            59996947,
            59988545
        ],
        "D": [
            59988102,
            59989658,
            59989675,
            59986719,
            59990868,
            59992865,
            59990765,
            59991828,
            59988538,
            59989605,
            59989462,
            59992741,
            59999498,
            59988876,
            60017942,
            59989391,
            59991386,
            59989567,
            59990626,
            60046854,
            59985851
        ],
        "C": [
            59984445,
            59985337,
            59984895,
            59983957,
            59985031,
            59985481,
            59984019,
            59986980,
            59984427,
            59984066,
            59984382,
            59987002,
            59982712,
            59984754,
            59984720,
            59985711,
            59985097,
            59984496,
            59982839,
            59983656
        ],
        "B": [
            59983717,
            59984061,
            59983687,
            59983257,
            59983195,
            59983710,
            59983075,
            59985335,
            59983154,
            59983158,
            59983522,
            59985251,
            59983191,
            59983505,
            59982763,
            59984237,
            59983907,
            59983359,
            59984573,
            59982988
        ],
        "A": [
            59982834,
            59982716,
            59982610,
            59982747,
            59982737,
            59982711,
            59982633,
            59982961,
            59982657,
            59982623,
            59982788,
            59982811,
            59983962,
            59982673,
            59985703,
            59982891,
            59983099,
            59982727,
            59985651,
            59982701
        ]
    },
    "name": "E. Petya and Construction Set",
    "statement": "It\u2019s Petya\u2019s birthday party and his friends have presented him a brand\r\nnew \"Electrician-n\" construction set, which they are sure he will enjoy\r\nas he always does with weird puzzles they give him.Construction set\r\n\"Electrician-n\" consists of 2n - 1 wires and 2n light bulbs. Each bulb\r\nhas its own unique index that is an integer from 1 to 2n, while all\r\nwires look the same and are indistinguishable. In order to complete this\r\nconstruction set one has to use each of the wires to connect two\r\ndistinct bulbs. We define a in a completed construction set as a\r\nsequence of distinct bulbs of length at least two, such that every two\r\nconsecutive bulbs in this sequence are directly connected by a wire.\r\nCompleted construction set configuration is said to be correct if a\r\nresulting network of bulbs and wires has a tree structure, i.e. any two\r\ndistinct bulbs are the endpoints of some chain.Petya was assembling\r\ndifferent configurations for several days, and he noticed that sometimes\r\nsome of the bulbs turn on. After a series of experiments he came up with\r\na conclusion that bulbs indexed 2i and 2i - 1 turn on if the chain\r\nconnecting them consists of exactly d_i wires. Moreover, the following\r\ncondition holds: the value of d_i is never greater than n.Petya did his\r\nbest but was not able to find a configuration that makes all bulbs to\r\nturn on, so he seeks your assistance. Please, find out a configuration\r\nthat makes all bulbs shine. It is guaranteed that such configuration\r\nalways exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n,pos[N];\nPII p[N];\nvector<PII> ans;\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",&p[i].fi),p[i].se=i;\n\tsort(p+1,p+n+1); reverse(p+1,p+n+1);\n\tauto add=[&](int u,int v) {\n\t\tans.pb(mp(u,v));\n\t};\n\trep(i,1,n+1) {\n\t\tpos[i]=2*p[i].se-1;\n\t\tif (i>1) add(pos[i-1],pos[i]);\n\t}\n\tint len=n;\n\trep(i,1,n+1) {\n\t\tint c=i+p[i].fi;\n\t\tif (c==len+1) {\n\t\t\tpos[c]=2*p[i].se;\n\t\t\tadd(pos[len],pos[c]);\n\t\t\tlen++;\n\t\t} else {\n\t\t\tadd(pos[c-1],2*p[i].se);\n\t\t}\n\t}\n\tfor (auto p:ans) printf(\"%d %d\\n\",p.fi,p.se);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "math",
        "sortings",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Petya and Construction Set.json",
    "editorial_link": "https://codeforces.com/blog/entry/69563",
    "editorial": "Assume without loss of generality that the array sorted in\r\nnon-increasing order. Let\u00e2\u0080\u0099s make a linear (\"bamboo\") graph from the\r\nvertices in this order. We will add nodes one by one, we will also\r\nmaintain the longest route during that. On the -th step we are looking\r\nfor the vertex at the distance from . That node is -th on the route. So\r\nwe can connect to it vertex . If was connected to the last vertex of the\r\nroute we should add to the end of it. -th node on the longest route\r\nalways exists because of two limitations: for all : .\r\n"
}