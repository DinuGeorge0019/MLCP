{"link": "https://codeforces.com//contest/1209/problem/H", "problemId": "411986", "problem_idx": "H", "shortId": "1209H", "contest_number": "1209", "problem_submissions": {"H": [60570135, 60593253, 60571964, 60573026, 60725224, 60568078], "G1": [60556287, 60555918, 60560660, 60545193, 60554924, 60565714, 60564847, 60552798, 60544388, 60543295, 60556776, 60547912, 60548472, 60548343, 60554445, 60552013, 60553528, 60550140], "F": [60551951, 60559474, 60551041, 60555531, 60550649, 60550897, 60556467, 60559990, 60548723, 60548870, 60575790, 60552616, 60555309, 60557639, 60553869, 60548929, 60549043, 60560725], "E1": [60550756, 60549748, 60556687, 60542418, 60544279, 60546177, 60548542, 60550504, 60541823, 60540929, 60549430, 60545745, 60545737, 60545738, 60546288, 60556058, 60558038, 60546083], "E2": [60550484, 60549405, 60556943, 60542599, 60544405, 60546112, 60548494, 60550663, 60542010, 60541156, 60549544, 60546078, 60546087, 60546121, 60546350, 60556107, 60589552, 60589526, 60589450, 60589386, 60588908, 60588877, 60579849, 60579734, 60579573, 60558088, 60546300], "D": [60539597, 60542953, 60544285, 60538671, 60541008, 60541094, 60543213, 60542943, 60537333, 60538028, 60540579, 60538998, 60541063, 60539296, 60540559, 60539902, 60539449, 60540533], "C": [60538071, 60541013, 60542624, 60537384, 60538008, 60539883, 60540890, 60540668, 60537787, 60537103, 60538560, 60537646, 60538820, 60541917, 60538555, 60538406, 60537838, 60538612], "B": [60534755, 60535450, 60536787, 60534226, 60534529, 60537069, 60535685, 60535878, 60534260, 60533467, 60534967, 60535176, 60536131, 60536594, 60535887, 60533931, 60532807, 60535219], "A": [60532612, 60532698, 60532910, 60532511, 60532605, 60536220, 60532574, 60532833, 60532652, 60532527, 60532568, 60532602, 60532828, 60533109, 60532549, 60532535, 60534221, 60532564], "G2": [60566672, 60567960, 60565628, 60564728, 60572926, 60607969, 60701078, 60577013, 60576902, 60576886]}, "name": "H. Moving Walkways", "statement": "Airports often use moving walkways to help you walking big distances\r\nfaster. Each such walkway has some speed that effectively increases your\r\nspeed. You can stand on such a walkway and let it move you, or you could\r\nalso walk and then your effective speed is your walking speed plus\r\nwalkway\u2019s speed.Limak wants to get from point 0 to point L on a straight\r\nline. There are n disjoint walkways in between. The i-th walkway is\r\ndescribed by two integers x_i and y_i and a real value s_i. The i-th\r\nwalkway starts at x_i, ends at y_i and has speed s_i. Every walkway is\r\nlocated inside the segment [0, L] and no two walkways have positive\r\nintersection. However, they can touch by endpoints.Limak needs to decide\r\nhow to distribute his energy. For example, it might make more sense to\r\nstand somewhere (or to walk slowly) to then have a lot of energy to walk\r\nfaster.Limak\u2019s initial energy is 0 and it must never drop below that\r\nvalue. At any moment, he can walk with any speed v in the interval [0,\r\n2] and it will cost him v energy per second, but he continuously\r\nrecovers energy with speed of 1 energy per second. So, when he walks\r\nwith speed v, his energy increases by (1-v). Note that negative value\r\nwould mean losing energy.In particular, he can walk with speed 1 and\r\nthis won\u2019t change his energy at all, while walking with speed 0.77\r\neffectively gives him 0.23 energy per second.Limak can choose his speed\r\narbitrarily (any real value in interval [0, 2]) at every moment of time\r\n(including the moments when he is located on non-integer positions).\r\nEverything is continuous (non-discrete).What is the fastest time Limak\r\ncan get from 0 to L?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\ntypedef long double db;\nconst int N=401000;\nint n,m,L;\ndb l[N],r[N],len[N],sp[N],f[N],cs[N],ct[N];\nint ord[N];\nstruct node {\n\tdb fg,s;\n}nd[4*N];\nvoid upd(int p) {\n\tnd[p].s=min(nd[p+p].s,nd[p+p+1].s);\n}\nvoid setf(int p,db v) {\n\tnd[p].fg+=v;\n\tnd[p].s-=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t\tnd[p].s=f[l];\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg>0) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\ndb query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return min(query(p+p,l,md,tl,md),query(p+p+1,md+1,r,md+1,tr));\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,db v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&L);\n\tint px=0;\n\tauto add=[&](int x,int y,db s) {\n\t\tlen[m]=y-x;\n\t\tsp[m]=s;\n\t\t++m;\n\t};\n\trep(i,0,n) {\n\t\tint x,y;\n\t\tdouble s;\n\t\tscanf(\"%d%d%lf\",&x,&y,&s);\n\t\tif (x>px) add(px,x,1);\n\t\tadd(x,y,s+1);\n\t\tpx=y;\n\t}\n\tif (px<L) add(px,L,1);\n\tdb ans=0,sr=0;\n\trep(i,0,m) {\n\t\tif (sp[i]==1) r[i]=len[i]; else r[i]=len[i]/(sp[i]-1)*sp[i];\n\t\tl[i]=len[i]/(sp[i]+1)*sp[i];\n\t\tct[i]=1/sp[i];\n\t\tcs[i]=r[i]-l[i];\n\t\tsr+=r[i]-len[i];\n\t\tf[i]=sr;\n\t\tans+=ct[i]*r[i];\n\t\tord[i]=i;\n\t\t//printf(\"%d %.10Lf %.10Lf %.10Lf %.10Lf %.10Lf\\n\",i,l[i],r[i],ct[i],cs[i],f[i]);\n\t}\n\tbuild(1,0,m-1);\n\tsort(ord,ord+m,[&](int a,int b) {\n\t\treturn ct[a]>ct[b];\n\t});\n\trep(i,0,m) {\n\t\tint x=ord[i];\n\t\tdb val=min(query(1,0,m-1,x,m-1),cs[x]);\n\t\t//printf(\"gg %d %.10Lf\\n\",x,val);\n\t\tr[x]-=val;\n\t\tans-=val*ct[x];\n\t\tmodify(1,0,m-1,x,m-1,val);\n\t}\n\t//rep(i,0,m) printf(\"%.10Lf\\n\",r[i]);\n\tprintf(\"%.10f\\n\",(double)ans);\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy", "math"], "dificulty": "3300", "interactive": false}