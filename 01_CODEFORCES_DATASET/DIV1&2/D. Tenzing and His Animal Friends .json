{
    "link": "https://codeforces.com//contest/1842/problem/D",
    "problemId": "1978968",
    "problem_idx": "D",
    "shortId": "1842D",
    "contest_number": "1842",
    "problem_submissions": {
        "H": [
            210909272,
            210915649,
            210920105,
            210920155,
            210922877,
            210917228,
            210922837,
            210930795,
            210943236,
            210937664,
            210940497,
            210923705,
            210946319,
            210934622,
            210945105,
            210899880,
            210946698,
            210939780,
            210945932
        ],
        "F": [
            210904139,
            210906080,
            210912565,
            210912372,
            210898025,
            210899929,
            210907320,
            210916813,
            210914105,
            210920055,
            210921458,
            210913885,
            210930158,
            210926455,
            210915591,
            210926376,
            210920616,
            210915480,
            210926627
        ],
        "E": [
            210900474,
            210894310,
            210898608,
            210904065,
            210915135,
            210928274,
            210898671,
            210908613,
            210902774,
            210908660,
            210907798,
            210940198,
            210905531,
            210907005,
            210910569,
            210945488,
            210908738,
            210905745,
            210907496
        ],
        "D": [
            210896488,
            210888362,
            210895704,
            210886302,
            210889254,
            210887549,
            210895428,
            210893212,
            210903157,
            210896694,
            210890657,
            210891182,
            210892762,
            210896576,
            210915222,
            210891979,
            210892349,
            210897573
        ],
        "G": [
            210891898,
            210900879,
            210908657,
            210918356,
            210923373,
            210939093,
            210921066,
            210918175,
            210911260,
            210924814,
            210932494,
            210913130,
            210941401,
            210927457,
            210933616,
            210927314,
            210931000,
            210936010
        ],
        "C": [
            210877958,
            210881836,
            210878997,
            210877037,
            210879744,
            210878770,
            210882382,
            210884108,
            210887371,
            210884900,
            210892630,
            210896219,
            210883482,
            210884636,
            210910637,
            210882729,
            210933971,
            210885406
        ],
        "A": [
            210875095,
            210875812,
            210874424,
            210888796,
            210874470,
            210876122,
            210874664,
            210877287,
            210875659,
            210882217,
            210874539,
            210875197,
            210874805,
            210874426,
            210902716,
            210874934,
            210945780,
            210885821
        ],
        "B": [
            210874375,
            210878347,
            210876059,
            210890061,
            210876166,
            210875757,
            210877955,
            210879984,
            210877325,
            210880724,
            210876899,
            210877184,
            210877441,
            210885377,
            210916237,
            210877578,
            210940672,
            210885692
        ],
        "I": [
            210953525,
            211184344,
            211107115
        ]
    },
    "name": "D. Tenzing and His Animal Friends ",
    "statement": "Tenzing has n animal friends. He numbers them from 1 to n.One day\r\nTenzing wants to play with his animal friends. To do so, Tenzing will\r\nhost several games.In one game, he will choose a set S which is a subset\r\nof\r\n{1,2,3,...,n\r\n} and choose an integer t. Then, he will play the game with the animals\r\nin S for t minutes.But there are some restrictions: Tenzing loves friend\r\n1 very much, so 1 must be an element of S. Tenzing doesn\u2019t like friend\r\nn, so n must not be an element of S. There are m additional\r\nrestrictions. The i-th special restriction is described by integers u_i,\r\nv_i and y_i, suppose x is the time that one of u_i and v_i is playing\r\nwith Tenzing. Tenzing must ensure that x is less or equal to y_i.\r\nOtherwise, there will be unhappiness. Tenzing wants to know the maximum\r\ntotal time that he can play with his animal friends. Please find out the\r\nmaximum total time that Tenzing can play with his animal friends and a\r\nway to organize the games that achieves this maximum total time, or\r\nreport that he can play with his animal friends for an infinite amount\r\nof time. Also, Tenzing does not want to host so many games, so he will\r\nhost at most n^2 games.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.06.2023 10:31:38       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  const long long inf = (long long) 1e18;\n  vector<vector<long long>> g(n, vector<long long>(n, inf));\n  for (int i = 0; i < n; i++) {\n    g[i][i] = 0;\n  }\n  dsu d(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    d.unite(x, y);\n    g[x][y] = z;\n    g[y][x] = z;\n  }\n  if (d.get(0) != d.get(n - 1)) {\n    cout << \"inf\" << '\\n';\n    return 0;\n  }\n  vector<pair<string, long long>> res;\n  long long ans = 0;\n  while (true) {\n    string s(n, '0');\n    s[0] = '1';\n    vector<int> que(1, 0);\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int to = 0; to < n; to++) {\n        if (s[to] == '0' && g[que[b]][to] == 0) {\n          que.push_back(to);\n          s[to] = '1';\n        }\n      }\n    }\n    if (s[n - 1] == '1') {\n      break;\n    }\n    long long T = inf;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == '1') {\n        for (int j = 0; j < n; j++) {\n          if (s[j] == '0') {\n            T = min(T, g[i][j]);\n          }\n        }\n      }\n    }\n    ans += T;\n    res.emplace_back(s, T);\n    for (int i = 0; i < n; i++) {\n      if (s[i] == '1') {\n        for (int j = 0; j < n; j++) {\n          if (s[j] == '0') {\n            g[i][j] -= T;\n            g[j][i] -= T;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << \" \" << res.size() << '\\n';\n  for (auto& p : res) {\n    cout << p.first << \" \" << p.second << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Tenzing and His Animal Friends .json",
    "editorial_link": "https://codeforces.com//blog/entry/117606",
    "editorial": "TutorialConsider the restrictions on , , and as a weighted edge between\r\nand with weight . Obviously, the final answer will not exceed the\r\nshortest path from to .One possible approach to construct the solution\r\nis to start with the set and add vertices one by one. If is added to the\r\nset at time , then we need to ensure that for any edge between and in\r\nthe set. This can be modeled as a system of difference constraints\r\nproblem and solved using shortest path algorithms.To be more specific,\r\nwe can add vertices in increasing order of their distances from . The\r\ntime for each set can be calculated as the difference between the\r\ndistances from to the two adjacent vertices in the sorted order.\r\n"
}