{
    "link": "https://codeforces.com//contest/1870/problem/G",
    "problemId": "2216420",
    "problem_idx": "G",
    "shortId": "1870G",
    "contest_number": "1870",
    "problem_submissions": {
        "G": [
            225207978,
            225118072,
            225116519,
            225114767,
            225113735,
            225113326,
            223895142,
            223905506,
            223908839,
            223914354,
            223924067,
            223915464,
            224102694,
            224102570,
            224101929,
            224101915,
            224101882,
            223930185,
            223922526,
            223898384,
            223902193
        ],
        "H": [
            223910262,
            223971766,
            225204927,
            223912817
        ],
        "F": [
            223881664,
            223880000,
            223885884,
            223900845,
            223885822,
            223925076,
            223908747,
            223887023,
            223881416,
            223893441,
            223967145,
            223892630,
            223898214,
            223897234,
            223895227,
            223893254,
            223897195,
            223887464,
            223885585,
            223897533
        ],
        "E": [
            223869750,
            223870667,
            223875420,
            223879930,
            223894576,
            223875622,
            223877104,
            223888049,
            223879090,
            223876643,
            223870896,
            223878535,
            223873841,
            223880057,
            223880667,
            223881985,
            223871304,
            223980583,
            223900716,
            223895756,
            223883035
        ],
        "D": [
            223864393,
            223860234,
            223865660,
            223863718,
            223865473,
            223859881,
            223865206,
            223867969,
            223868314,
            223865007,
            223866155,
            223863717,
            223863491,
            223869388,
            223869302,
            223866987,
            223863771,
            223868821,
            223873483,
            223869884
        ],
        "C": [
            223858926,
            223856692,
            223860376,
            223856772,
            223861967,
            223857013,
            223862311,
            223860027,
            223860530,
            223857444,
            223858871,
            223859210,
            223859070,
            223862641,
            223864669,
            223860558,
            223859030,
            223856443,
            223870325,
            223863825
        ],
        "B": [
            223855786,
            223853418,
            223854541,
            223852626,
            223857522,
            223852531,
            223856711,
            223853615,
            223855334,
            223852785,
            223853742,
            223853640,
            223854539,
            223856641,
            223856452,
            223856337,
            223854108,
            223864851,
            223860995,
            223858101
        ],
        "A": [
            223852532,
            223851971,
            223852416,
            223851983,
            223854260,
            223851952,
            223853042,
            223852087,
            223852502,
            223853463,
            223852096,
            223852189,
            223852238,
            223852875,
            223853328,
            223852660,
            223852270,
            223860422,
            223858579,
            223854841
        ]
    },
    "name": "G. MEXanization",
    "statement": "Let\u2019s define f(S). Let S be a multiset (i.e., it can contain repeated\r\nelements) of non-negative integers. In one operation, you can choose any\r\nnon-empty subset of S (which can also contain repeated elements), remove\r\nthis subset (all elements in it) from S, and add the MEX of the removed\r\nsubset to S. You can perform any number of such operations. After all\r\nthe operations, S should contain exactly 1 number. f(S) is the largest\r\nnumber that could remain in S after any sequence of operations.You are\r\ngiven an array of non-negative integers a of length n. For each of its n\r\nprefixes, calculate f(S) if S is the corresponding prefix (for the i-th\r\nprefix, S consists of the first i elements of array a).The MEX (minimum\r\nexcluded) of an array is the smallest non-negative integer that does not\r\nbelong to the array. For instance: The MEX of [2,2,1] is 0, because 0\r\ndoes not belong to the array. The MEX of [3,1,0,1] is 2, because 0 and 1\r\nbelong to the array, but 2 does not. The MEX of [0,3,1,2] is 4, because\r\n0, 1, 2 and 3 belong to the array, but 4 does not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1 << 19;\nint n;\nint a[N];\nint ans[N];\nint cnt[N];\n\nstruct node {\n\tint r;\n\tll k0, b0; // time to go\n\tll k1, b1;\n};\n\nvector < node > con[N]; \n\nint up[N];\nvoid adjust(int x) {\n\twhile(true) {\n\t\tauto &tmp = con[x].back();\n\t\tif(tmp.r * tmp.k0 + tmp.b0 > up[x]) {\n\t\t\ttmp.r = (up[x] - tmp.b0) / tmp.k0;\n\t\t}\n\t\tif(sz(con[x]) > 1 && tmp.r <= con[x][sz(con[x]) - 2].r) {\n\t\t\tcon[x].pop_back();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tR(i, sz(con[x]) - 1, 1) \n\t\tif(con[x][i].r == con[x][i - 1].r + 1) {\n\t\t\tauto &tmp = con[x][i];\n\t\t\tll v1 = tmp.r * tmp.k0 + tmp.b0;\n\t\t\tll v2 = tmp.r * tmp.k1 + tmp.b1;\n\t\t\ttmp.k0 = 1, tmp.b0 = v1 - tmp.r;\n\t\t\ttmp.k1 = 1, tmp.b1 = v2 - tmp.r;\n\t\t}\n\tassert(sz(con[x]) <= 36);\n}\nvoid upd(int x) {\n\tauto &v2 = con[x * 2];\n\tauto &v1 = con[x * 2 + 1];\n\tcon[x].clear();\n\tll cur = 0;\n\tint p1 = 0, p2 = 0;\n\twhile(true) {\n\t\twhile(p1 < sz(v1) && v1[p1].r < cur) ++p1;\n\t\tif(p1 == sz(v1)) break;\n\t\tll valc = cur * v1[p1].k0 + v1[p1].b0;\n\t\twhile(p2 < sz(v2) && v2[p2].r < valc) ++p2;\n\t\tif(p2 == sz(v2)) break;\n\t\tll r1 = v1[p1].r;\n\t\tll r2 = (v2[p2].r - v1[p1].b0) / v1[p1].k0; \n\t\tnode nw;\n\t\tnw.r = min(r1, r2);\n\t\tnw.k0 = v1[p1].k0 * v2[p2].k0, nw.b0 = v1[p1].b0 * v2[p2].k0 + v2[p2].b0;\n\t\tnw.k1 = v1[p1].k0 * v2[p2].k1 + v1[p1].k1;\n\t\tnw.b1 = v1[p1].b0 * v2[p2].k1 + v1[p1].b1 + v2[p2].b1;\n\t\tcur = nw.r + 1;\n\t\tcon[x].emplace_back(nw);\n\t}\n\tadjust(x);\n}\nvoid make(int x, int p) {\n\tnode z0, z1;\n\tz0.r = cnt[p], z0.k0 = 1, z0.b0 = 0, z0.k1 = -1, z0.b1 = cnt[p]; \n\tz1.r = n, z1.k0 = 2, z1.b0 = -cnt[p], z1.k1 = 0, z1.b1 = 0;\n\tcon[x] = vector < node > {z0, z1};\n\tadjust(x);\n}\nvoid build(int x, int L, int R) {\n\tup[x] = n / max(L - 1, 1);\n\tif(L == R) {\n\t\tmake(x, L);\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tbuild(x * 2, L, mid);\n\tbuild(x * 2 + 1, mid + 1, R);\n\tupd(x);\n}\nvoid modify(int x, int L, int R, int p) {\n\tif(L == R) {\n\t\tmake(x, L);\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tp <= mid ? modify(x * 2, L, mid, p) : modify(x * 2 + 1, mid + 1, R, p);\n\tupd(x);\n}\n\nint need, zero, curp;\nvoid slv(int x, int L, int R, int l, int r) {\n\tif(l <= L && R <= r) {\n\t\tif(need > curp / R) {\n\t\t\tneed = n * 2;\n\t\t\treturn ;\n\t\t}\n\t\tint pos = 0;\n\t\twhile(pos < sz(con[x]) && con[x][pos].r < need) ++pos;\n\t\tif(pos == sz(con[x])) {\n\t\t\tneed = n * 2;\t\n\t\t} else {\n\t\t\tzero += con[x][pos].k1 * need + con[x][pos].b1;\n\t\t\tneed = con[x][pos].k0 * need + con[x][pos].b0;\n\t\t}\n//\t\tcout << \"after \" << L << ' ' << R << \" : \" << need << ' ' << zero\n//\t\t\t<<\", \" << con[x][pos].k0 << ' ' << con[x][pos].b0 << ' ' << \n//\t\t\t\tcon[x][pos].k1 << ' ' << con[x][pos].b1 << endl;\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tif(r > mid) slv(x * 2 + 1, mid + 1, R, l, r);\n\tif(l <= mid) slv(x * 2, L, mid, l, r);\n}\n\nint a1;\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\ta1 = a[1];\n\tL(i, 1, n) {\n\t\tif(a[i] > n) {\n\t\t\ta[i] = 0;\n\t\t}\n\t}\n\tL(i, 0, n) {\n\t\tcnt[i] = 0;\n\t}\n\t\n\tbuild(1, 0, n);\n\tint ns = 1;\n\tint SUM = 0;\n\tL(i, 1, n) {\n\t\tif(a[i] >= ns) {\n\t\t\t++SUM;\n\t\t}\n\t\t++cnt[a[i]];\n\t\tmodify(1, 0, n, a[i]);\n\t\tcurp = i;\n\t\twhile(ns <= i) {\n//\t\t\tcout << \"checking \" << ns << endl;\n\t\t\tneed = 1, zero = SUM + cnt[0]; \n\t\t\tif(1 < ns) slv(1, 0, n, 1, ns - 1);\n\t\t\tif(zero < need) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSUM -= cnt[ns];\n\t\t\t++ns;\n\t\t}\n\t\tans[i] = ns - 1;\n\t}\n\t\n\tans[1] = max(ans[1], a1);\n\tL(i, 1, n) {\n\t\tcout << ans[i] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. MEXanization.json",
    "editorial_link": "https://codeforces.com//blog/entry/120524",
    "editorial": "Let\u00e2\u0080\u0099s start by introducing a more convenient way to store\nnumbers an array , where represents the number of occurrences of in the\nprefix for which we are finding the answer. All such that will be added\nto because applying the operation to in such cases is optimal.Let\u00e2\u0080\u0099s\nintroduce a few array operations that will be sufficient to solve the\nproblem. Create the number . Apply the operation to the set of numbers .\nIn terms of the array , this is equivalent to subtracting from the range\nto and adding to . Turn the number into . To do this, apply the\noperation to . In terms of the array , this is equivalent to subtracting\nfrom and adding to . Create the number and clear the multiset. This is\nthe same as creating the number , but we apply the operation to all\nother numbers, leaving only the single number (or a larger number) in\nthe set. It can be proven that by using only operations of this kind, we\ncan always obtain the optimal answer.Now we can forget about the\noriginal condition and solve the problem for the array.Let\u00e2\u0080\u0099s learn how\nto check if it is possible to create the number and clear the\nmultiset:First, let\u00e2\u0080\u0099s try to create the number . If it is possible, the\nanswer is yes. Otherwise, we look at the rightmost number that is\nmissing (or in other words, the rightmost ). We try to create it, and\nnow we need to find the rightmost element to the left of it, and so on.\nTo implement this, we need to maintain a number such that we subtract\nfrom all elements in the prefix (initially ), iterate through the array\nfrom right to left, and if , assign . When we reach zero, may be greater\nthan , in which case we need to use the operation to turn any number\ninto . To do this, simply check that the remaining number of elements in\nthe array is greater than or equal to .This currently works in time,\nwhich is not very efficient.Optimization techniques:First, let\u00e2\u0080\u0099s\nmaintain the sum of elements and as soon as it becomes negative,\nterminate the process. To achieve this, when subtracting from , let\u00e2\u0080\u0099s\nsubtract from . Now let\u00e2\u0080\u0099s use a bottom-up segment tree to find the\nnearest number smaller than to the left in time.Now let\u00e2\u0080\u0099s notice that\nwhen we update through , we subtract at least from , so there can\u00e2\u0080\u0099t be\nmore than different values of through which we will update.Now we can\nanswer for a specific in time, but in reality, the complexity is (due to\nthe peculiarities of the bottom-up segment tree), and the authors have a\nproof for this, but they are afraid that you will find an error in it,\nso they decided not to provide it(we will add proof later).Now let\u00e2\u0080\u0099s see\nhow to solve the full problem:Initially, the answer is , and we notice\nthat it does not decrease. So after each addition, we will check if it\nis possible to increase the answer and increase it as long as possible.\nThe answer cannot exceed , so we will perform no more than\nchecks.Overall, the solution works in time. That\u00e2\u0080\u0099s how it is.\n"
}