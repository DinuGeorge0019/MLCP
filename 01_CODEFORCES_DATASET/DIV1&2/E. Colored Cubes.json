{
    "link": "https://codeforces.com//contest/1025/problem/E",
    "problemId": "209740",
    "problem_idx": "E",
    "shortId": "1025E",
    "contest_number": "1025",
    "problem_submissions": {
        "E": [
            41858738,
            41856429,
            41850768,
            41855385,
            41852484,
            41858727,
            41848268,
            41855122,
            41883001,
            41858915,
            41855225,
            41852858,
            41868516,
            41860862,
            41856872,
            41860887,
            41851802
        ],
        "F": [
            41848629,
            41847210,
            41861209,
            41860806,
            41863443,
            41862402,
            41853998,
            41862178,
            41845081,
            41877837,
            41887505,
            41887279,
            41887255,
            41878485,
            41856047,
            41861957,
            41858912,
            41906629,
            41858319,
            41868413
        ],
        "D": [
            41845183,
            41851596,
            41961545,
            41841784,
            41841903,
            41840812,
            41849010,
            41840988,
            41846701,
            41841230,
            41874808,
            41841578,
            41847099,
            41842212,
            41945631,
            41911317,
            41911277,
            41878022,
            41877990,
            41877935,
            41874708,
            41874699,
            41874650,
            41873983,
            41873792,
            41873701,
            41873477,
            41849952,
            41843783,
            41842954,
            41842230,
            41844472,
            41848949,
            41844612
        ],
        "C": [
            41839685,
            41838607,
            41835815,
            41834650,
            41838762,
            41837233,
            41866845,
            41840107,
            41835687,
            41833279,
            41836241,
            41835918,
            41839785,
            41834860,
            41839690,
            41836558,
            41837913,
            41843576,
            41837629
        ],
        "A": [
            41835541,
            41829219,
            41829281,
            41828966,
            41829689,
            41834202,
            41835387,
            41829112,
            41829095,
            41842587,
            41837894,
            41829018,
            41830134,
            41829065,
            41830329,
            41829109,
            41829662,
            41832973,
            41831018
        ],
        "B": [
            41832044,
            41834103,
            41852766,
            41831349,
            41836588,
            41831557,
            41837237,
            41833957,
            41833253,
            41830677,
            41832816,
            41833177,
            41836737,
            41831907,
            41867411,
            41832885,
            41833414,
            41837270,
            41834779
        ],
        "G": [
            41866839,
            41868176,
            42077886,
            41877542,
            41872667,
            41951029,
            41921003
        ]
    },
    "name": "E. Colored Cubes",
    "statement": "Vasya passes all exams! Despite expectations, Vasya is not tired,\r\nmoreover, he is ready for new challenges. However, he does not want to\r\nwork too hard on difficult problems.Vasya remembered that he has a\r\nnot-so-hard puzzle: m colored cubes are placed on a chessboard of size n\r\ntimes n. The fact is that m\r\nleq n and all cubes have distinct colors. Each cube occupies exactly one\r\ncell. Also, there is a designated cell for each cube on the board, the\r\npuzzle is to place each cube on its place. The cubes are fragile, so in\r\none operation you only can move one cube onto one of four neighboring by\r\nside cells, if only it is empty. Vasya wants to be careful, so each\r\noperation takes exactly one second. Vasya used to train hard for VK Cup\r\nFinal, so he can focus his attention on the puzzle for at most 3 hours,\r\nthat is 10800 seconds. Help Vasya find such a sequence of operations\r\nthat all cubes will be moved onto their designated places, and Vasya\r\nwon\u2019t lose his attention.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int kDir = 4;\nint di[] = {1, -1, 0, 0};\nint dj[] = {0, 0, 1, -1};\nconst int N = 55;\nPII par[N][N];\nint vis[N][N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m;\n  cin>>n>>m;\n  function<bool(int)> Valid = [&](int k) {\n    return k >= 1 && k <= n;\n  };\n  function<VVI(VI, VI)> Solve = [&](VI si, VI sj) {\n    vector<VI> board(n + 2, VI(n + 2));\n    vector<int> gotten(m + 2);\n    RE (i, m) {\n      board[si[i]][sj[i]] = i;\n      if (si[i] == i && sj[i] == i) {\n        gotten[i] = 1;\n      }\n    }\n    VVI res;\n    function<void(int, int, int, int)>  Move = [&](int i1, int j1, int i2, int j2) {\n      assert(abs(i1 - i2) + abs(j1 - j2) == 1);\n      assert(board[i1][j1] != 0);\n      assert(board[i2][j2] == 0);\n      res.PB({i1, j1, i2, j2});\n      int cube = board[i1][j1];\n      swap(board[i1][j1], board[i2][j2]);\n      assert(Valid(i1) && Valid(i2) && Valid(j1) && Valid(j2));\n      si[cube] = i2;\n      sj[cube] = j2;\n    };\n    while (1) {\n      int sup = 1;\n      RE (i, m) {\n        if (gotten[i]) { continue; }\n        sup = 0;\n        if (si[i] == sj[i]) {\n          REP (dir, kDir) {\n            int ni = si[i] + di[dir];\n            int nj = sj[i] + dj[dir];\n            if (Valid(ni) && Valid(nj) && board[ni][nj] == 0) {\n              Move(si[i], sj[i], ni, nj);\n              break;\n            }\n          }\n        }\n      }\n      if (sup) { break; }\n      //int wh_shortest = -1;\n      VPII best_path;\n      RE (i, m) {\n        if (gotten[i]) { continue; }\n        vector<PII> que;\n        que.PB({si[i], sj[i]});\n        if (board[i][i]) { continue; }\n        //PII target = {i, i};\n        RE (j, n) {\n          RE (k, n) {\n            vis[j][k] = 0;\n          }\n        }\n        vis[si[i]][sj[i]] = 1;\n        for (int ii = 0; ii < SZ(que); ii++) {\n          PII ziom = que[ii];\n          debug(ziom);\n          REP (dir, kDir) {\n            int ni = ziom.st + di[dir];\n            int nj = ziom.nd + dj[dir];\n            if (!Valid(ni) || !Valid(nj) || board[ni][nj] || vis[ni][nj]) { continue; }\n            que.PB({ni, nj});\n            par[ni][nj] = ziom;\n            vis[ni][nj] = 1;\n            if (ni == i && nj == i) {\n              int ci = i, cj = i;\n              VPII path;\n              while (ci != si[i] || cj != sj[i]) {\n                debug(ci, cj);\n                path.PB({ci, cj});\n                PII prv = par[ci][cj];\n                ci = prv.st;\n                cj = prv.nd;\n              }\n              path.PB({si[i], sj[i]});\n              if (best_path.empty() || SZ(path) < SZ(best_path)) {\n                best_path = path;\n              }\n              goto End;\n            }\n            \n          }\n        }\n        End: ;\n      }\n      reverse(ALL(best_path));\n      debug(best_path);\n      RE (i, SZ(best_path) - 1) {\n        Move(best_path[i - 1].st, best_path[i - 1].nd, best_path[i].st, best_path[i].nd);\n      }\n      gotten[best_path.back().st] = 1;\n    }\n    debug(res);\n    return res;\n  };\n  VI si(m + 2), sj(m + 2);\n  RE (i, m) {\n    cin>>si[i]>>sj[i];\n  }\n  VI ti(m + 2), tj(m + 2);\n  RE (i, m) {\n    cin>>ti[i]>>tj[i];\n  }\n  \n  VVI s1 = Solve(si, sj);\n  VVI s2 = Solve(ti, tj);\n  reverse(ALL(s2));\n  for (auto& v : s2) {\n    swap(v[0], v[2]);\n    swap(v[1], v[3]);\n  }\n  cout<<SZ(s1) + SZ(s2)<<endl;\n  s1.insert(s1.end(), ALL(s2));\n  for (auto p : s1) {\n    for (auto w : p) {\n      cout<<w<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n//   for (auto p : s2) {\n//     for (auto w : p) {\n//       cout<<w<<\" \";\n//     }\n//     cout<<\"\\n\";\n//   }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "matrices"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Colored Cubes.json",
    "editorial_link": "https://codeforces.com//blog/entry/61323",
    "editorial": "We\u00e2\u0080\u0099re gonna show how to turn an arbitrary arrangement of cubes into the\r\narrangement where -th cube is located at (we call such an arrangement\r\nbasic) in no more than operations. For simplicity, we imply that we have\r\nexactly cubes where is even.Say we have some arrangement where -th cube\r\noccupies some cell . On the first step, we turn it into the arrangement\r\nwhere all cubes have distinct coordinates. In order to do this, we sort\r\ncubes in ascending order of their coordinates (with ties broken\r\narbitrarily) . If cube is at position in the sorted list, we say that\r\nits desired coordinates are . It\u00e2\u0080\u0099s easy to check that such choice always\r\nallows to move at least one cube from its current position to the\r\ndesired one through the line. If we perform this operation times, we\u00e2\u0080\u0099ll\r\nmove all cubes to their desired positions. In addition, the maximum\r\nnumber of operations will occur if all the cubes were initially located\r\non the line or , and in this case the number of operations will be equal\r\nto < . The formal proof of this inequality can be given using the\r\ninduction principle. Indeed, the base () is obvious. Now let the\r\nstatement be true for all . Let\u00e2\u0080\u0099s prove that if the number of cubes (and\r\nthe size of the board) changes from to , the upper limit of the number\r\nof operations increases by no more than . Consider the cube with maximum\r\ncoordinate which we have to move to . If initially is less than , we\r\nmove this cube to the desired position in no more than operations, and\r\nother cubes have coordinates which implies the upper limit of operations\r\nby definition. But if is initially , we don\u00e2\u0080\u0099t have to move it whereas\r\neach of the remaining cubes requires one more additional (i.e total)\r\noperation since we added only one diagonal. In total we\u00e2\u0080\u0099ll make a total\r\nof operations.Now all coordinates are distinct and that means that\r\nnothing restricts us from changing their coordinates. Let\u00e2\u0080\u0099s move the\r\ncubes in such a way that -th cube ends at position . One cube can be\r\nprocessed in no more than operations. According to this, we need at most\r\noperations in total. Now we obtain an arrangement where all coordinates\r\nare also distinct. If we apply the same operation to cubes\u00e2\u0080\u0099 coordinates,\r\nwe will end up with -th cube at position . This requires no more than\r\noperations.Now we can switch any arrangement to the basic one. Let\u00e2\u0080\u0099s get\r\nthe list of operations for turning the initial position to basic and the\r\nfinal position to basic. Now it\u00e2\u0080\u0099s sufficient to reverse one of the lists\r\nand concatenate these actions. This yields no more than operations in\r\ntotal.Note that this estimate is quite rough; however, this is enough\r\nunder given constraints.\r\n"
}