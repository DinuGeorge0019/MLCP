{
    "link": "https://codeforces.com//contest/776/problem/C",
    "problemId": "95207",
    "problem_idx": "C",
    "shortId": "776C",
    "contest_number": "776",
    "problem_submissions": {
        "G": [
            24939347,
            24933167,
            24937192,
            24938688,
            24939300,
            24936369,
            24933254,
            24936389,
            24938260,
            50496579,
            24939610,
            24974394,
            24937125,
            24938166,
            24937440
        ],
        "F": [
            24931137,
            24940601,
            24934717,
            24935180,
            24936216,
            24930744,
            24935991,
            24934536,
            24933196,
            24934631,
            25009829,
            24934356,
            24935407,
            25145968,
            24938938
        ],
        "E": [
            24926469,
            24922427,
            24928701,
            24929827,
            24927281,
            24926330,
            24922998,
            24928645,
            24928568,
            24927117,
            24927967,
            24932026,
            24926259,
            24928494,
            24925814,
            24933222,
            24929687,
            24929132
        ],
        "D": [
            24923588,
            24926240,
            24925398,
            24926362,
            24924696,
            24942987,
            24926743,
            24925181,
            24923636,
            24922793,
            24927891,
            24924422,
            24923885,
            24928078,
            25388280,
            24929601,
            24924674,
            24952921,
            24926279
        ],
        "A": [
            24920848,
            24918716,
            24917411,
            24917501,
            24928258,
            24917338,
            24918133,
            24917381,
            24917351,
            24917379,
            24917385,
            24917553,
            24917364,
            24918205,
            24917450,
            24917668,
            24918624
        ],
        "C": [
            24919677,
            24924230,
            24922174,
            24922015,
            24918784,
            24920506,
            24921334,
            24921898,
            24920669,
            24950107,
            24929487,
            24921634,
            24921526,
            24921083,
            24921835,
            25114288,
            24921821,
            24922186,
            24923226
        ],
        "B": [
            24917670,
            24919248,
            24918919,
            24919261,
            24920428,
            24918897,
            24919671,
            24919894,
            24918987,
            24918567,
            24918525,
            24922327,
            24918984,
            24918395,
            24919865,
            24919010,
            24920231,
            24920427
        ]
    },
    "name": "C. Molly's Chemicals",
    "statement": "Molly Hooper has different kinds of chemicals arranged in a line. Each\r\nof the chemicals has an affection value, The -th of them has affection\r\nvalue .Molly wants Sherlock to fall in love with her. She intends to do\r\nthis by mixing a contiguous segment of chemicals together to make a love\r\npotion with total affection value as a non-negative power of . Total\r\naffection value of a continuous segment of chemicals is the sum of\r\naffection values of each chemical in that segment.Help her to do so in\r\nfinding the total number of such segments.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nmap<long long, int>Map;\nint n, K;\nlong long s, res, t;\nint main(){\n    int a, i;\n    scanf(\"%d%d\",&n,&K);\n    Map[0] = 1;\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&a);\n        s += a;\n        if(K==1){\n            res += Map[s-1];\n        }\n        else if(K==-1){\n            res += Map[s-1] + Map[s+1];\n        }\n        else{\n            t = 1;\n            while(1){\n                res += Map[s-t];\n                t*=K;\n                if(t > 1e15 || -t > 1e15)break;\n            }\n        }\n        Map[s]++;\n    }\n    printf(\"%lld\\n\",res);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Molly's Chemicals.json",
    "editorial_link": "https://codeforces.com//blog/entry/50622",
    "editorial": "Hint: The number of possible powers will be less than 50 for any .\r\nEditorial: We are going to loop over all possible non-negative powers of\r\n. Since the maximum possible value of subarray sum can be , there can be\r\nat most possible powers that can be the sum of subarrays. Let be the sum\r\nof elements from index to index . We can precalculate in time\r\ncomplexity. (Prefix sum)We will try to find the count of subarrays\r\nstarting from index . The sum of any such subarray ending at index can\r\nbe written as . Now, where is a power of . We have to count the values\r\nof such that . For this part, we can store the count of in a dictionary\r\nas we move from right of the array and use the dictionary to find count\r\nof for corresponding and .PS: Do take care of a corner case for while\r\ncalculating powers of .\r\n",
    "hint": []
}