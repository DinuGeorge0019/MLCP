{
    "link": "https://codeforces.com//contest/1523/problem/G",
    "problemId": "1000217",
    "problem_idx": "G",
    "shortId": "1523G",
    "contest_number": "1523",
    "problem_submissions": {
        "F": [
            117916146,
            117914065,
            117905350,
            117900425,
            117909780,
            117912951,
            117923029,
            117905457,
            117920531,
            117920496,
            117911483,
            117908634,
            117907048,
            117936734,
            117936707,
            117936638,
            117936633,
            117936625,
            117936608,
            117905940,
            117911622,
            117911227,
            117910828,
            117920430,
            117916378,
            117911950,
            117912347,
            117936103,
            117935723
        ],
        "G": [
            117899863,
            117912955,
            117908386,
            117915802,
            117906341,
            117903204,
            117907803,
            117932659,
            117932628,
            117911801,
            118597582,
            117989759,
            117915684,
            117936837,
            117918793,
            117916945,
            117917431
        ],
        "D": [
            117881477,
            117886244,
            117886334,
            117887661,
            118167966,
            117918101,
            117929591,
            117890786,
            117890676,
            117893739,
            118119250,
            117887458,
            117887290,
            117893940,
            117890382,
            118081143,
            117890914,
            117883607,
            117887959,
            117895275,
            117888883,
            117902109,
            117889374
        ],
        "E": [
            117878219,
            117881962,
            117910641,
            117881787,
            117884807,
            117893823,
            117886171,
            117885405,
            117882043,
            117890552,
            117888754,
            117897027,
            117898439,
            117887443,
            117893294,
            117903524,
            117892701,
            117896279,
            117896129
        ],
        "C": [
            117876664,
            117878149,
            117877887,
            117879093,
            117889641,
            117882853,
            117877348,
            117879069,
            117877404,
            117877723,
            117880898,
            117876222,
            117880296,
            117876946,
            117880601,
            117879874,
            117879926,
            117880242,
            117902829
        ],
        "B": [
            117875490,
            117875567,
            117880589,
            117875816,
            117876680,
            117877360,
            117875700,
            117876723,
            117878349,
            117876280,
            117877999,
            117880072,
            117876899,
            117875787,
            117877756,
            117876654,
            117875833,
            117878179,
            117879465
        ],
        "A": [
            117874746,
            117874821,
            117882081,
            117874974,
            117874835,
            117874828,
            117874778,
            117874933,
            117874911,
            117874900,
            117876005,
            117883186,
            117874918,
            117874908,
            117875902,
            117874738,
            117874753,
            117874913,
            117876371
        ],
        "H": [
            117981868,
            117981132,
            118023855,
            118349130,
            117933591,
            118312467,
            118312428,
            119224810
        ]
    },
    "name": "G. Try Booking",
    "statement": "William owns a flat in central London. He decided to rent his flat out\r\nfor the next n days to earn some money.Since his flat is in the center\r\nof the city, he instantly got m offers in the form (l_i, r_i), which\r\nmeans that someone wants to book the flat from day l_i until day r_i\r\ninclusive. To avoid spending a lot of time figuring out whether it\u2019s\r\nprofitable for him to accept an offer, William decided to develop an\r\nalgorithm. The algorithm processes all offers as they arrive and will\r\nonly accept offer i if the following two conditions are satisfied: r_i -\r\nl_i + 1\r\nge x. None of the days between l_i and r_i are occupied by a previously\r\naccepted offer William isn\u2019t sure what value x should have and he asks\r\nyou for help. For all x from 1 to n he wants you to calculate the total\r\nnumber of days for which the flat would be occupied if the corresponding\r\nvalue will be assigned to x.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.05.2021 18:27:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1 << 17;\n\nstruct segtree {\n\n  set<pair<int, int>> tree[2 * MAX];\n\n  segtree() {\n  }\n\n  bool is_good(int v, int x, int y) {\n    auto it = tree[v].lower_bound(make_pair(x, -1));\n    return (it != tree[v].end() && it->second <= y);\n  }\n\n  int find_first(int x, int y) {\n    int v = 1;\n    if (!is_good(v, x, y)) {\n      return -1;\n    }\n    while (v < MAX) {\n      if (is_good(2 * v, x, y)) {\n        v = 2 * v;\n      } else {\n//        assert(is_good(2 * v + 1, x, y));\n        v = 2 * v + 1;\n      }\n    }\n    return v - MAX;\n  }\n\n  void add(int v, int x, int y) {\n    v += MAX;\n    while (v > 0) {\n      auto it = tree[v].lower_bound(make_pair(x + 1, -1));\n      if (it != tree[v].end() && it->second <= y) {\n        // pass\n      } else {\n        while (it != tree[v].begin()) {\n          --it;\n          if (it->second < y) {\n            break;\n          }\n          it = tree[v].erase(it);\n        }\n        tree[v].emplace(x, y);\n      }\n      v /= 2;\n    }\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> l(m), r(m);\n  vector<vector<int>> by_len(n + 1);\n  for (int i = 0; i < m; i++) {\n    cin >> l[i] >> r[i];\n    --l[i]; --r[i];\n    by_len[r[i] - l[i] + 1].push_back(i);\n  }\n  segtree st;\n  vector<int> res(n + 1);\n  for (int x = n; x >= 1; x--) {\n    for (int i : by_len[x]) {\n      st.add(i, l[i], r[i]);\n    }\n    function<void(int, int)> Solve = [&](int from, int to) {\n      if (to - from + 1 < x) {\n        return;\n      }\n      int u = st.find_first(from, to);\n      if (u == -1) {\n        return;\n      }\n      res[x] += r[u] - l[u] + 1;\n      Solve(from, l[u] - 1);\n      Solve(r[u] + 1, to);\n    };\n    Solve(0, n - 1);\n  }\n  for (int x = 1; x <= n; x++) {\n    cout << res[x] << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Try Booking.json",
    "editorial_link": "https://codeforces.com//blog/entry/91271",
    "editorial": "Note that if you think of the answer as the number accepted offers for\r\nrent, the sum of the answers in the worst case will be no more than .\r\nThis value can be estimated in . So for each we can try to learn how to\r\nprocess only those offers that are actually included in the answer for\r\nthis .Let\u00e2\u0080\u0099s learn how to solve the problem recursively for a fixed and\r\nassume that all segments have a length of at least . The recursion will\r\ncontain two parameters and a continuous segment of days on which all\r\ndays are still free. Now, if we learn how to find an offer with a\r\nminimum for the segment and such that , then we can solve our problem.\r\nWe will only need to recursively find the answer for and .To find the\r\nminimum , you can use a 2D data structure that supports the following\r\nqueries: Get: Minimum on the prefix matrix (one of the corners of the\r\nsubmatrix lies in the cell ). The minimum can be found on the prefix\r\nmatrix because we are dealing with segments for which the condition is\r\nis satisfied. Update: Updates the value in the cell by a strictly\r\nsmaller number than it was there before. In the author\u00e2\u0080\u0099s solution such a\r\ndata structure was a 2D segments tree.We can iterate from to so that we\r\nonly need to add new segments.Total complexity .\r\n"
}