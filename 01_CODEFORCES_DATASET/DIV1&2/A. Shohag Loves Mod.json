{
    "link": "https://codeforces.com//contest/2039/problem/A",
    "problemId": "3044240",
    "problem_idx": "A",
    "shortId": "2039A",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "A general approach to tackle ad-hoc problems is to play around with the\r\nconditions and see if we can add more constraints to limit the search\r\nspace. Let\u00e2\u0080\u0099s analyze the modular condition .We know that , and all\r\nvalues are distinct. Let\u00e2\u0080\u0099s explore this step by step: is always . can be\r\nor . But since all values must be distinct, must be (otherwise, it would\r\nequal ). can be , , or . Similarly, must be (to avoid duplication with\r\nor ). must be . This leads to the constraint . Next, let\u00e2\u0080\u0099s consider the\r\nincreasing sequence condition. Since the sequence must be increasing, we\r\nadd the constraint . To further limit the search space, note that can be\r\nup to , and must be . This suggests that we can restrict to values up to\r\n. Let\u00e2\u0080\u0099s compile the constraints: . . . Now we need to build the sequence\r\nthat satisfies these conditions. Let\u00e2\u0080\u0099s build the sequence starting from\r\nthe end. . Thus, can be or . Since , must be . . So can be or . Since ,\r\nmust be . . Thus, can be or or . Since and the odd numbers greater than\r\nhave already been used, must be . If we limit the elements to , there is\r\nexactly one sequence that satisfies all conditions. The sequence is ,\r\nwhich is . We can validate the solution by checking if it satisfies all\r\nthe constraints. . So all are distinct and values are under . So the\r\nsequence is valid. .\r\n",
    "name": "A. Shohag Loves Mod",
    "statement": "Shohag has an integer n. Please help him find an integer sequence 1\r\nle a_1\r\nlt a_2\r\nlt\r\nldots\r\nlt a_n\r\nle 100 such that a_i\r\nbmod i\r\nneq a_j\r\nbmod j ^{\r\ntext{ }} is satisfied over all pairs 1\r\nle i\r\nlt j\r\nle n.It can be shown that such a sequence always exists under the given\r\nconstraints.^{\r\ntext{ }}a\r\nbmod b denotes the remainder of a after division by b. For example, 7\r\nbmod 3 = 1, 8\r\nbmod 4 = 0 and 69\r\nbmod 10 = 9.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;int n;void Main() {\tcin >> n;\tL(i, 1, n) cout << i * 2 - 1 << ' ';\tcout << '\\n';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "number theory"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\A. Shohag Loves Mod.json"
}