{"link": "https://codeforces.com//contest/1586/problem/B", "problemId": "1147382", "problem_idx": "B", "shortId": "1586B", "contest_number": "1586", "problem_submissions": {"I": [132349267, 132252923, 132320064, 132673395, 132289506, 132263256], "H": [132247560, 132253721, 134930470, 132350321, 132254025, 132660661, 132275048, 132253966, 132270155], "G": [132239647, 132244340, 132241119, 135794866, 135794713, 132234650, 132248115, 132244256, 132257761, 132255193, 132256199, 132255919, 132258648, 132257515, 132250742, 132255333, 132257553, 132255311], "F": [132231955, 132236161, 132234366, 132240633, 132243967, 132235859, 132234337, 132237395, 132239493, 132241376, 132248866, 132245654, 132241416, 132246161, 132245018, 132259456, 132244979, 132249686, 132260019, 132238761], "E": [132228491, 132224206, 132228693, 132232413, 132231532, 132229745, 132230672, 132232315, 132218494, 132235319, 132232020, 132237413, 132239524, 132237023, 132236410, 132236319, 132238669, 132240928, 132230421, 132229492], "D": [132225001, 132227375, 132224444, 132226879, 132227724, 132226231, 132226626, 132227371, 132224235, 132227654, 132224635, 132229641, 132234990, 132231067, 132230536, 132228432, 132234258, 132232998, 132241147, 132223955], "C": [132221243, 132218519, 132219460, 132219748, 132219799, 132222571, 132220819, 132219850, 132232802, 132223481, 132218757, 132219927, 132230956, 132218216, 132224263, 132222192, 132227273, 132228072, 132226595, 132220025], "B": [132214722, 132213701, 132215490, 132214516, 132214317, 132214601, 132215162, 132222197, 132229955, 132216968, 132214347, 132216468, 132226751, 132220812, 132216772, 132216742, 132216324, 132213579, 132217316, 132213929], "A": [132213139, 132213078, 132214020, 132213141, 132213243, 132213267, 132213377, 132220659, 132228179, 132218691, 132213234, 132214356, 132213033, 132224973, 132214120, 132214349, 132213337, 132213011, 132242338, 132213128]}, "name": "B. Omkar and Heavenly Tree", "statement": "Lord Omkar would like to have a tree with n nodes (3\r\nle n\r\nle 10^5) and has asked his disciples to construct the tree. However,\r\nLord Omkar has created m (\r\nmathbf{1\r\nle m < n}) restrictions to ensure that the tree will be as heavenly as\r\npossible. A tree with n nodes is an connected undirected graph with n\r\nnodes and n-1 edges. Note that for any two nodes, there is exactly one\r\nsimple path between them, where a simple path is a path between two\r\nnodes that does not contain any node more than once.Here is an example\r\nof a tree: A restriction consists of 3 pairwise distinct integers, a, b,\r\nand c (1\r\nle a,b,c\r\nle n). It signifies that node b cannot lie on the simple path between\r\nnode a and node c. Can you help Lord Omkar and become his most trusted\r\ndisciple? You will need to find heavenly trees for multiple sets of\r\nrestrictions. It can be shown that a heavenly tree will always exist for\r\nany set of restrictions under the given constraints.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nbool ok[100005];\nvoid solve()\n{\n\tint n, m, a, b, c;\n\tscanf(\"%d%d\", &n, &m);\n\trep1(i, n) ok[i] = true;\n\trep(i, m) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tok[b] = false;\n\t}\n\trep1(i, n) if(ok[i]) {\n\t\trep1(j, n) if(i != j) printf(\"%d %d\\n\", i, j);\n\t\treturn;\n\t}\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "trees"], "dificulty": "1200", "interactive": false}