{
    "link": "https://codeforces.com//contest/724/problem/F",
    "problemId": "74855",
    "problem_idx": "F",
    "shortId": "724F",
    "contest_number": "724",
    "problem_submissions": {
        "G": [
            21292263,
            21289389,
            21296363,
            21288425,
            21294631,
            21287775,
            21293574,
            21292770,
            21291944,
            21288934,
            21292172,
            21288247,
            21292559,
            21295809,
            21290880,
            21290578,
            21290415,
            21293943
        ],
        "E": [
            21288925,
            21292133,
            21297352,
            21291033,
            21288200,
            23659645,
            21290576,
            21290313,
            21292937,
            21296159,
            21294663,
            21290237,
            21296769,
            21292864,
            21297544,
            23608572
        ],
        "F": [
            21288190,
            21295097,
            21291428,
            21408768,
            21292926,
            21298468,
            145553208,
            21294689
        ],
        "D": [
            21285401,
            21285608,
            21286235,
            21283645,
            21284412,
            21288117,
            21285995,
            21287478,
            21286772,
            21286376,
            21289028,
            21285265,
            21288845,
            21286726,
            21290761,
            21285673,
            21284100,
            21286467,
            21288075
        ],
        "B": [
            21284134,
            21280714,
            21282752,
            21281462,
            21280744,
            21282751,
            21280902,
            21282004,
            21281773,
            21281431,
            21281779,
            21284722,
            21286664,
            21280972,
            21281353,
            21282957,
            21282648
        ],
        "C": [
            21283255,
            21284495,
            21288232,
            21285743,
            21285969,
            21285870,
            21284787,
            21286083,
            21285861,
            21284725,
            21286899,
            21284034,
            21287013,
            21285582,
            21297034,
            21283106,
            21286310,
            21285066,
            21286458
        ],
        "A": [
            21280305,
            21279735,
            21280413,
            21279914,
            21280000,
            21280810,
            21279870,
            21279953,
            21279966,
            21279817,
            21280008,
            21279884,
            21281495,
            21279783,
            21281061,
            21279908,
            21279971,
            21280674,
            21280506
        ]
    },
    "name": "F. Uniformly Branched Trees",
    "statement": "A tree is a connected graph without cycles.Two trees, consisting of\r\nvertices each, are called if there exists a permutation such that the\r\nedge is present in the first tree if and only if the edge is present in\r\nthe second tree.Vertex of the tree is called internal if its degree is\r\ngreater than or equal to two.Count the number of different\r\nnon-isomorphic trees, consisting of vertices, such that the degree of\r\neach internal vertex is . Print the answer over the given prime modulo .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\n//const ll mod=1000000007;\nint mod;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nll dp[N][20],pd[N][20],f[N],t[20];\nint n,d;\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&d,&mod);\n\tif (n<=2) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tif ((n-2)%(d-1)!=0) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\trep(i,1,n/2+1) if ((i-1)%(d-1)==0) {\n\t\tif (i==1) f[i]=1; else f[i]=dp[i-1][d-1];\n\t\tt[0]=1;\n\t\trep(j,1,d+1) {\n\t\t\tt[j]=t[j-1]*(f[i]+j-1)%mod*powmod(j,mod-2)%mod;\n\t\t}\n\t\trep(p,0,n+1) rep(q,0,d+1) pd[p][q]=0;\n\t\trep(r,0,d+1) rep(q,0,d+1) if (r+q<=d) rep(p,0,n+1) if (p+q*i<=n) {\n\t\t\tpd[p+q*i][r+q]=(pd[p+q*i][r+q]+dp[p][r]*t[q])%mod;\n\t\t}\n\t\trep(p,0,n+1) rep(q,0,d+1) if (pd[p][q]) {\n\t\t\tdp[p][q]=pd[p][q];\n\t\t}\n\t}\n\tint ret=dp[n-1][d];\n\tif (n%2==0) {\n\t\tret=(ret-dp[n/2-1][d-1]*(dp[n/2-1][d-1]-1)/2)%mod;\n\t\tif (ret<0) ret+=mod;\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Uniformly Branched Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/47644",
    "editorial": "At first, we will calculate the following dynamic programming: will be\r\nthe number of rooted trees, where the root has exactly directed\r\nsubtrees, the maximum size of which does not exceed , and the degree of\r\ninternal vertices is equal to (except for the root).Calculation of the\r\nvalue of the dynamics for fixed parameters is divided into two cases:\r\nthere are on subtrees of size at all. In this case, you can take the\r\nvalue of ; there are subtrees of size . In this case, we got different\r\ntrees. The main idea here is that we do not distinguish trees that\r\ndiffer only by a permutation of the sons for some vertices (this is\r\nwhere the number of combinations come from). Itâs enough to set some\r\norder in which we will place the sons of all vertices. In this case,\r\nthey are arranged in the order of ascending sizes and the index number\r\nof its subtrees (all the trees of fixed size can be written in one big\r\nlist and enumerated).Now we need to count the number of unrooted trees.\r\nLetâs get rid of this restriction, by rooting all the trees using some\r\nvertex. For this vertex, we will take the centroid (the vertex, after\r\nremoving which, the tree splits into connected components, with the\r\nsizes not larger than the half of the original size of the tree). The\r\nadvantage of this choice is that any tree always have either one or two\r\ncentroids.The number of trees that have exactly one centroid is equal to\r\n. The fact that we chose the centroid, implies that the size of subtrees\r\ncannot exceed .The number of trees that have exactly two centroids is\r\nequal to if is divisible by , and zero otherwise. If there are two\r\ncentroids, they will be connected by an edge, and the removing of this\r\nedge will split the graph into two parts, each of which will contain\r\nexactly vertices.The resulting complexity of this solution is .\r\n",
    "hint": []
}