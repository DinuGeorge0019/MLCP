{"link": "https://codeforces.com//contest/1684/problem/G", "problemId": "1404377", "problem_idx": "G", "shortId": "1684G", "contest_number": "1684", "problem_submissions": {"H": [157720671, 157721062, 157737875, 157719283, 157728267, 157723148, 157726010, 157736069, 157792151, 157760208, 157735749, 157733310, 157739555, 157762123, 157758402, 157757414], "G": [157708800, 157705200, 157707312, 157718616, 157706754, 157714488, 157707640, 157712978, 157718288, 157710983, 157717212, 157716133, 157711996, 157713632, 157715613, 157714692, 157708417, 157712457, 157717126], "F": [157703000, 157698430, 157700853, 157708707, 157699813, 157705688, 157700819, 157704615, 157713662, 157705196, 157701872, 157704273, 157706345, 157707380, 157707253, 157706734, 157720973, 157723693, 157711135], "E": [157687824, 157689230, 157686803, 157694670, 157693301, 157693626, 157692297, 157688860, 157691406, 157698450, 157692770, 157697303, 157697857, 157695549, 157699844, 157698604, 157694457, 157697019, 157700499], "D": [157681158, 157683410, 157690778, 157683407, 157688074, 157688564, 157683855, 157682485, 157678956, 157684552, 157688505, 157689349, 157690936, 157696580, 157687171, 157693792, 157688577, 157691760, 157692016], "C": [157676125, 157679761, 157680827, 157678864, 157733908, 157680852, 157679175, 157675870, 157680982, 157722992, 157680866, 157688681, 157680491, 157680374, 157689989, 157710336, 157680413, 157683798], "B": [157669712, 157671031, 157673644, 157673851, 157673406, 157672145, 157673363, 157673187, 157671551, 157673379, 157675976, 157675416, 157675741, 157672916, 157673228, 157675698, 157678091, 157671319, 157673490], "A": [157669088, 157669275, 157669176, 157669141, 157669362, 157669203, 157669522, 157669224, 157669098, 157669297, 157671508, 157669642, 157676097, 157669933, 157669278, 157670146, 157669180, 157669153, 157669255]}, "name": "G. Euclid Guess", "statement": "Let\u2019s consider Euclid\u2019s algorithm for finding the greatest common\r\ndivisor, where t is a list:function Euclid(a, b): if a < b: swap(a, b)\r\nif b == 0: return a r = reminder from dividing a by b if r > 0: append r\r\nto the back of t return Euclid(b, r)There is an array p of pairs of\r\npositive integers that are not greater than m. Initially, the list t is\r\nempty. Then the function is run on each pair in p. After that the list t\r\nis shuffled and given to you.You have to find an array p not greater\r\nthan 2\r\ncdot 10^4 that produces the given list t, or tell that no such array\r\nexists.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 19.05.2022 19:34:51       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> t(n);\n  for (int i = 0; i < n; i++) {\n    cin >> t[i];\n  }\n  for (int i = 0; i < n; i++) {\n    if (2 * t[i] + 1 > m) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  sort(t.begin(), t.end());\n  int ptr = n;\n  while (ptr > 0 && 3 * t[ptr - 1] > m) {\n    ptr -= 1;\n  }\n  matching mat(n - ptr, ptr);\n  for (int i = 0; i < ptr; i++) {\n    for (int j = ptr; j < n; j++) {\n      if (t[j] % t[i] == 0 && 2 * t[j] + t[i] <= m) {\n        mat.add(j - ptr, i);\n      }\n    }\n  }\n  if (mat.solve() < n - ptr) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  vector<pair<int, int>> res;\n  for (int j = ptr; j < n; j++) {\n    int i = mat.pa[j - ptr];\n    res.emplace_back(2 * t[j] + t[i], t[j] + t[i]);\n  }\n  for (int i = 0; i < ptr; i++) {\n    if (mat.pb[i] == -1) {\n      res.emplace_back(3 * t[i], 2 * t[i]);\n    }\n  }\n  cout << res.size() << '\\n';\n  for (auto& p : res) {\n    cout << p.first << \" \" << p.second << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "flows", "graph matchings", "math", "number theory"], "dificulty": "2800", "interactive": false}