{"link": "https://codeforces.com//contest/1942/problem/H", "problemId": "2562665", "problem_idx": "H", "shortId": "1942H", "contest_number": "1942", "problem_submissions": {"H": [254183902, 254188108, 254201851, 254183582, 254190002, 254198277, 254202464, 254201777], "G": [254162531, 254164622, 254151822, 254172554, 254170602, 254147291, 254169050, 254165219, 254167927, 254162501, 254160773, 254158971, 254158358, 254162939, 254174812, 254166519, 254160779, 254190901, 254172694], "F": [254158172, 254152768, 254191293, 254157909, 254159055, 254161327, 254156776, 254157963, 254160983, 254169304, 254173612, 254173846, 254172970, 254168440, 254167804, 254178450, 254203408, 254180148, 254161110, 254162666], "E": [254144668, 254141645, 254144010, 254144661, 254150949, 254131679, 254143965, 254147690, 254143510, 254152706, 254144759, 254152214, 254138579, 254146127, 254149515, 254151573, 254147613, 254146631, 254149743], "D": [254140034, 254136242, 254134735, 254138534, 254140561, 254139068, 254133778, 254140913, 254137432, 254142449, 254137105, 254142252, 254145710, 254140092, 254138595, 254139592, 254140216, 254137967, 254143121], "C1": [254131817, 254128192, 254204108, 254125718, 254128016, 254124090, 254123140, 254122427, 254125306, 254127382, 254129295, 254126939, 254129179, 254122148, 254134385, 254126328, 254132572, 254129060, 254125449, 254134104], "C2": [254131346, 254132277, 254203957, 254203739, 254128200, 254133096, 254129236, 254126373, 254125814, 254128450, 254131487, 254132145, 254131700, 254133377, 254130111, 254134317, 254129340, 254132361, 254129276, 254129577, 254134556], "B": [254123310, 254123064, 254120037, 254123258, 254119059, 254120381, 254119896, 254118664, 254120410, 254124572, 254120489, 254125154, 254128773, 254119724, 254122914, 254121539, 254119687, 254120045, 254122462], "A": [254117704, 254118878, 254117338, 254117275, 254117327, 254117266, 254117244, 254117366, 254117469, 254117281, 254117396, 254117230, 254117295, 254117454, 254117450, 254117301, 254117455, 254117981]}, "name": "H. Farmer John's Favorite Intern", "statement": "Ruby just won an internship position at Farmer John\u2019s farm by winning a\r\ncoding competition! As the newly recruited intern, Ruby is tasked with\r\nmaintaining Farmer John\u2019s peach tree, a tree consisting of n nodes\r\nrooted at node 1. Each node initially contains a_i = 0 peaches, and\r\nthere are two types of events that can happen: Growth event at some node\r\nx: Ruby must choose the parent of x any node in the subtree of x and\r\nincrease the amount of peaches it contains by one. Harvest event at some\r\nnode x: Ruby must choose a single node that is in the subtree of x and\r\ndecrease the amount of peaches it contains by one. Note that this is the\r\nsame set of nodes as the growth event. Note that the subtree of x\r\nincludes the node x as well.Ruby is also given an array b of length n.\r\nThe peach tree is deemed healthy if a_i\r\nge b_i for every node i.Ruby is asked to perform q operations of two\r\ntypes: Perform v growth events on node x. Ruby does have to choose the\r\nsame node to increase in every growth event. Perform v harvest events on\r\nnode x. Ruby does have to choose the same node to decrease in every\r\nharvest event. For every prefix of operations, Ruby asks you to find if\r\nshe can perform these operations such that the resulting peach tree (at\r\nthe end of these operations) is healthy. Note that Ruby can\u2019t perform a\r\nharvest event that makes any a_i negative.Every prefix is independent,\r\nmeaning that for a given operation, Ruby may choose different nodes to\r\nperform events on for every prefix that contains that operation.\r\n", "solutions": ["#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\nbool dbg=false;\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\nusing vvi=vc<vc<int>>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\nstring rand_string(int n,char lw,char up){\n\tstring s(n,'?');\n\trep(i,n)s[i]=rand_int(lw,up);\n\treturn s;\n}\n\nint current_run_id,run_batch_size=1000;\nint calc_random_limit(){\n\treturn current_run_id/run_batch_size+1;\n}\ntemplate<class t>\nvoid generate_single(t&a){\n\ta=rand_int(1,calc_random_limit());\n}\nvoid generate_single(string&a){\n\tint n;generate_single(n);\n\ta=rand_string(n,'a','b');\n}\ntemplate<class t,class u>\nvoid generate_single(pair<t,u>&a){\n\tgenerate_single(a.a);\n\tgenerate_single(a.b);\n}\n//https://trap.jp/post/1224/\ntemplate<class... Args>\nvoid input(Args&... a){\n\tif(dbg){\n\t\t(generate_single(a),...);\n\t}else{\n\t\t(cin >> ... >> a);\n\t}\n}\n#define INT(...) int __VA_ARGS__;input(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;input(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;input(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;input(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;input(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;input(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;input(__VA_ARGS__)\n#define overload3(a,b,c,d,...) d\n#define VI2(name,size) vi name(size);rep(i_##name,size)input(name[i_##name]);\n#define VI3(name,size,offset) vi name(size);rep(i_##name,size)input(name[i_##name]),name[i_##name]+=offset;\n#define VI(...) overload3(__VA_ARGS__,VI3,VI2)(__VA_ARGS__)\n#define VPI(name,size) vc<pi> name(size);rep(i_##name,size)input(name[i_##name]);\n#define VVI(name,sizeN,sizeM) vvi name(sizeN,vi(sizeM));\\\nrep(i_##name,sizeN)rep(j_##name,sizeM)input(name[i_##name][j_##name]);\n\n#define VVT(type,name,sizeN,sizeM) vvc<type> name(sizeN,vc<type>(sizeM));\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1){\n\t\tif(dbg)cout<<endl;\n\t\telse cout<<\"\\n\";\n\t}\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\ntemplate<class T>\nvoid printvv(const vvc<T>&vs){\n\tfor(const auto&row:vs)print(row);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class S> void mkuni(S&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t> bool isuni(vc<t> v){\n\tint s=si(v);\n\tmkuni(v);\n\treturn si(v)==s;\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class S,class u>\nint lwb(const S&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tvoid clear(){\n\t\tfill(all(p),-1);\n\t\tfill(all(s),1);\n\t\tc=si(p);\n\t}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\tif(dbg){\n\t\tvvc<int> t(n);\n\t\tunionfind uf(n);\n\t\twhile(uf.c>1){\n\t\t\tint a=rand_int(n);\n\t\t\tint b=rand_int(n);\n\t\t\tif(uf.unite(a,b)){\n\t\t\t\tt[a].pb(b);\n\t\t\t\tt[b].pb(a);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}else{\n\t\treturn readGraph(n,n-1);\n\t}\n}\n\nvoid printTree(const vvc<int> t){\n\tint n=si(t);\n\tint degsum=0;\n\trep(i,n)degsum+=si(t[i]);\n\tif(degsum==n-1){\n\t\t//directed\n\t\trep(i,si(t))for(auto j:t[i]){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else if(degsum==2*(n-1)){\n\t\t//undirected\n\t\trep(i,si(t))for(auto j:t[i])if(i<j){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else{\n\t\tassert(false);\n\t}\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT \u3067\u6570\u5217\u3092\u7ba1\u7406\u3059\u308b\u3068\u304d\u306b\u4f7f\u3046 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \u3057\u3066\u306a\u3044\u3084\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//\u30bd\u30fc\u30c8\u3057\u3066 i \u756a\u76ee\u304c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//\u4f8b\u3048\u3070 sortidx \u3067\u5f97\u305f idx \u3092\u4f7f\u3048\u3070\u5358\u306b\u30bd\u30fc\u30c8\u5217\u306b\u306a\u3063\u3066\u8fd4\u3063\u3066\u304f\u308b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\ntemplate<class t,class u,class v>\npair<t,u>&operator*=(pair<t,u>&a,v b){\n\ta.a*=b;a.b*=b;return a;}\ntemplate<class t,class u,class v>\npair<t,u> operator*(pair<t,u> a,v b){return a*=b;}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a){return mp(-a.a,-a.b);}\nnamespace std{\ntemplate<class t,class u>\nistream&operator>>(istream&is,pair<t,u>&a){\n\treturn is>>a.a>>a.b;\n}\n}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator*=(vc<t>&a,u x){\n\tfor(auto&v:a)v*=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator*(vc<t> a,u x){\n\treturn a*=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n//\u6d88\u3057\u305f\u8981\u7d20\u306e\u500b\u6570\u3092\u8fd4\u3057\u3066\u304f\u308c\u308b\n//UCUP 2-8-F\ntemplate<class t,class F>\nint remif(vc<t>&a,F f){\n\tauto itr=remove_if(all(a),f);\n\tint res=a.ed-itr;\n\ta.erase(itr,a.ed);\n\treturn res;\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//Multiuni2023-8 C\n//f(lw)=false,...,f(n-1)=false,f(n)=true,...,f(up)=true,\n//\u306e\u3068\u304d\u306b n \u3092\u8fd4\u3059\ntemplate<class F>\nint find_min_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))up=mid;\n\t\telse lw=mid;\n\t}\n\treturn up;\n}\n//f(lw)=true,f(up)=false\ntemplate<class F>\nint find_max_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))lw=mid;\n\t\telse up=mid;\n\t}\n\treturn lw;\n}\n\ntemplate<class t> using pqmin=priority_queue<t,vc<t>,greater<t>>;\ntemplate<class t> using pqmax=priority_queue<t>;\nusing T=tuple<int,int,int>;\n\n//N() \u304c\u5358\u4f4d\u5143\n//VERIFY: yosupo\n//CF407E\ntemplate<class N>\nstruct segtree{\n\tvc<N> x;\n\tint n,s;\n\tsegtree(){}\n\ttemplate<class t>\n\tsegtree(const vc<t>&a){\n\t\tn=a.size();\n\t\ts=1;\n\t\twhile(s<n){s*=2;}\n\t\tx.resize(s*2);\n\t\trep(i,n)\n\t\t\tx[s+i]=N(a[i]);\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\t//NOT Verified\n\tsegtree(int nn){\n\t\tresize(nn);\n\t}\n\tvoid resize(int nn){\n\t\tn=nn;\n\t\ts=1;\n\t\twhile(s<n){s*=2;}\n\t\tx.assign(s*2,N());\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\ttemplate<class t>\n\tvoid init(const vc<t>&a){\n\t\tn=a.size();\n\t\ts=1;\n\t\twhile(s<n){s*=2;}\n\t\tx.resize(s*2);\n\t\trep(i,n)\n\t\t\tx[s+i]=N(a[i]);\n\t\trng(i,n,s)\n\t\t\tx[s+i]=N();\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid clear(){\n\t\trep(i,n)\n\t\t\tx[s+i]=N();\n\t\tgnr(i,1,s)\n\t\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tN point_get(int i){\n\t\tassert(inc(0,i,n-1));\n\t\treturn x[i+s];\n\t}\n\tvoid point_set(int i,const N&t){\n\t\tassert(inc(0,i,n-1));\n\t\ti+=s;\n\t\tx[i]=t;\n\t\twhile(i>>=1)x[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid point_merge(int i,const N&t){\n\t\tassert(inc(0,i,n-1));\n\t\ti+=s;\n\t\tx[i]=N::merge(x[i],t);\n\t\twhile(i>>=1)x[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid point_change(int i,F f,Args&&...args){\n\t\tassert(inc(0,i,n-1));\n\t\ti+=s;\n\t\t(x[i].*f)(forward<Args>(args)...);\n\t\twhile(i>>=1)x[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int b,int e){\n\t\tassert(0<=b&&b<=e&&e<=n);\n\t\tN lf,rt;\n\t\tfor(int l=b+s,r=e+s;l<r;l>>=1,r>>=1){\n\t\t\tif (l&1){\n\t\t\t\tlf=N::merge(lf,x[l]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r&1){\n\t\t\t\tr--;\n\t\t\t\trt=N::merge(x[r],rt);\n\t\t\t}\n\t\t}\n\t\treturn N::merge(lf,rt);\n\t}\n\tN getall(){\n\t\treturn x[1];\n\t}\n\t//UTPC2020E\n\t//n \u8d85\u3048\u308b\u304b\u3082\u3057\u308c\u306a\u3044\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert((N().*f)(forward<Args>(args)...));\n\t\tassert(0<=l&&l<=n);\n\t\tif(l==n)return mp(n,N());\n\t\tl+=s;\n\t\t\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(n,sm);\n\t}\n\t//UCUP-2-22-K\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left_withinit(int r,N sm,F f,Args&&... args){\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tassert(0<=r&&r<=n);\n        if(r==0)return mp(0,sm);\n        r+=s;\n        do {\n            r--;\n            while (r > 1 && (r % 2)) r >>= 1;\n            if (!(N::merge(x[r],sm).*f)(forward<Args>(args)...)) {\n                while (r < s) {\n                    r = (2 * r + 1);\n                    N tmp=N::merge(x[r],sm);\n                    if ((tmp.*f)(forward<Args>(args)...)) {\n                        sm = tmp;\n                        r--;\n                    }\n                }\n                return mp(r + 1 - s,sm);\n            }\n            sm = N::merge(x[r], sm);\n        } while ((r & -r) != r);\n        return mp(0,sm);\n    }\n\t//UTPC2020E\n\ttemplate <class F,class... Args> \n\tpair<int,N> min_left(int r,F f,Args&&... args){\n\t\treturn min_left_withinit(r,N(),f,forward<Args>(args)...);\n    }\n    //\u884c\u5217\u3068\u304b\u4e57\u305b\u3066\u5fc5\u8981\u306a\u306e\u306f\u30d9\u30af\u30c8\u30eb\u3068\u306e\u7a4d\uff0c\u307f\u305f\u3044\u306a\u3068\u304d\u306b\u4f7f\u3048\u308b\uff1f\n    //CF Goodbye 2016 E\n    //CF 896 F\n\ttemplate<class F,class T,class... Args>\n\tT accumulate(int l,int r,F f,T t,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=n);\n\t\tstatic int buf[2][30];\n\t\tint cnt[2]{};\n\t\tfor(l+=s,r+=s;l<r;l>>=1,r>>=1){\n\t\t\tif(l&1)buf[0][cnt[0]++]=l;\n\t\t\tif(r&1)buf[1][cnt[1]++]=r-1;\n\t\t\tl++;\n\t\t}\n\t\trep(i,cnt[0])t=(x[buf[0][i]].*f)(t,forward<Args>(args)...);\n\t\tper(i,cnt[1])t=(x[buf[1][i]].*f)(t,forward<Args>(args)...);\n\t\treturn t;\n\t}\n};\n\n\n//\u5185\u90e8\u3067\u30b0\u30e9\u30d5\u3092\u3044\u3058\u308b\u304b\u3089 in,out \u3092\u4f7f\u3046\u3068\u304d\u306f\u6ce8\u610f\n//hei[v] -> heavy edge \u3067\u6f5c\u3063\u3066\u3044\u3063\u305f\u6642\uff0c\u81ea\u5206\u542b\u3081\u3066\u4f55\u500b\u3042\u308b\u304b\n//pe[v]: v->par[v] \u306e\u8fba\u306e\u60c5\u5831\n//-\u6709\u5411\u6728\u306e\u3068\u304d\u306f\u4e0a\u304b\u3089\u4e0b\u306e\u8fba\u3092\u5165\u308c\u3066\u308b\n//-\u7121\u5411\u6728\u306e\u3068\u304d\u306f\u4e0b\u304b\u3089\u4e0a\u306e\u8fba\u3092\u5165\u308c\u3066\u308b\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tpe[e]=e;\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//UCUP 1-22 F\n\tint adv(int a,int d){\n\t\tif(hei[a]<=d)return -1;\n\t\telse return ni[in[a]+d];\n\t}\n\t//CF692F\n\tint getpar(int v,int len){\n\t\tassert(dep[v]>=len);\n\t\tint tar=dep[v]-len;\n\t\twhile(1){\n\t\t\tint h=head[v];\n\t\t\tif(dep[h]<=tar){\n\t\t\t\treturn ni[in[h]+(tar-dep[h])];\n\t\t\t}\n\t\t\tv=par[h];\n\t\t}\n\t\tassert(false);\n\t}\n\t//1st UCUP 13 G\n\tint jump(int a,int b,int d){\n\t\tint c=lca(a,b);\n\t\tif(d<=(dep[a]-dep[c])){\n\t\t\treturn getpar(a,d);\n\t\t}else{\n\t\t\td=(dep[a]+dep[b]-dep[c]*2)-d;\n\t\t\tassert(d>=0);\n\t\t\treturn getpar(b,d);\n\t\t}\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\t//Universal Cup 2023 Stage 1 G\n\tvi index;\n\t//vs \u3092\u542b\u3080 virtual tree \u3092\u8fd4\u3059\n\t//\u8fd4\u3059\u306e\u306f virtual tree \u306b\u4f7f\u308f\u308c\u305f\u9802\u70b9\u3068\uff0c\u8fba\u306e\u96c6\u5408\n\t//\u8fba\u306e\u7aef\u70b9\u306f\uff0cvirtual tree \u306b\u304a\u3051\u308b\u756a\u53f7\n\t//\u5143\u306e\u6728\u306b\u304a\u3051\u308b\u756a\u53f7\u3092 virtual tree \u306e\u9802\u70b9\u756a\u53f7\u306b\u5199\u3059\u306e\u304c\uff0cindex \u3068\u3044\u3046\u5909\u6570\n\t//\u8fba\u306f ch->par \u306e\u9806\n\t//virtual tree \u306f\u884c\u304d\u639b\u3051\u9806\u3067\u756a\u53f7\u304c\u3064\u3044\u3066\u3044\u308b\n\t//\u7279\u306b\uff0c\u9802\u70b9 0 \u304c\u6839\u306b\u306a\u308b\u3088\u3046\u306b\u3067\u304d\u3066\u3044\u308b\n\t//pair<vi,vc<pi>> tree_compress(vi vs){\n\tvoid tree_compress(vi&vs,vc<pi>&es){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tassert(is_sorted(all(vs),comp));\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tes.clear();\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\t//return mp(vs,es);\n\t}\n\t//assume a is desdendant of b\n\t//ex=true <=> exclude b\n\ttemplate<class F>\n\tvoid subpath_work(int a,int b,bool ex,F f){\n\t\twhile(1){\n\t\t\tif(head[a]==head[b]){\n\t\t\t\tf(in[b]+ex,in[a]+1);\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tint h=head[a];\n\t\t\t\tf(in[h],in[a]+1);\n\t\t\t\ta=par[h];\n\t\t\t}\n\t\t}\n\t}\n\t//KUPC2021E\n\t//\u30d1\u30b9\u306b\u5bfe\u3059\u308b\u64cd\u4f5c\u9806\u306b\u6ce8\u610f\n\t//euler-tour \u9806\u306b\u3057\u305f\u3068\u304d\u306e\u533a\u9593\u306b\u4f5c\u7528\u3057\u3066\u3044\u308b\u3053\u3068\u306b\u6ce8\u610f\n\t//ex=true exclude lca(a,b) (=apply path edges)\n\ttemplate<class F>\n\tvoid path_work(int a,int b,bool ex,F f){\n\t\tint c=lca(a,b);\n\t\tsubpath_work(a,c,ex,f);\n\t\tsubpath_work(b,c,true,f);\n\t}\n\t//v->false\n\t//-1->true\n\t//root-v \u30d1\u30b9\u4e0a\u3067 f(x)=true \u3068\u306a\u308b\u6700\u3082\u6df1\u3044\u9802\u70b9\u3092\u8fd4\u3059\n\t//CF857G\n\ttemplate<class F>\n\tint find_lowest(int v,F f)const{\n\t\twhile(v>=0){\n\t\t\tint h=head[v];\n\t\t\tif(!f(h)){\n\t\t\t\tv=par[h];\n\t\t\t}else{\n\t\t\t\tint l=0,r=dep[v]-dep[h]+1;\n\t\t\t\twhile(r-l>1){\n\t\t\t\t\tconst int mid=(l+r)/2;\n\t\t\t\t\tif(f(ni[in[h]+mid]))l=mid;\n\t\t\t\t\telse r=mid;\n\t\t\t\t}\n\t\t\t\treturn ni[in[h]+l];\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t//-1->false\n\t//v->true\n\t//root-v \u30d1\u30b9\u4e0a\u3067 f(x)=true \u3068\u306a\u308b\u6700\u3082\u6d45\u3044\u9802\u70b9\u3092\u8fd4\u3059\n\t//Yandex Cup 2023 Semifinal F (TLE...)\n\ttemplate<class F>\n\tint find_highest(int v,F f)const{\n\t\twhile(1){\n\t\t\tint h=head[v];\n\t\t\tint p=par[h];\n\t\t\tif(p!=-1&&f(p)){\n\t\t\t\tv=p;\n\t\t\t}else{\n\t\t\t\tint l=-1,r=dep[v]-dep[h];\n\t\t\t\twhile(r-l>1){\n\t\t\t\t\tconst int mid=(l+r)/2;\n\t\t\t\t\tif(f(ni[in[h]+mid]))r=mid;\n\t\t\t\t\telse l=mid;\n\t\t\t\t}\n\t\t\t\treturn ni[in[h]+r];\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n};\n\nstruct E{\n\tint to,idx;\n\toperator int()const{\n\t\treturn to;\n\t}\n};\n\nstruct N{\n\tbool emp;\n\tint f,e,fe,fa;\n\tN():emp(true){}\n\tN(int fc,int ec,int gc,int a,int b,int d):emp(false){\n\t\tf=max(gc-a,fc+b-a);\n\t\te=d+b-a+ec;\n\t\tfe=max(f,e);\n\t\tfa=gc-a;\n\t}\n\tstatic N merge(const N&x,const N&y){\n\t\tif(x.emp)return y;\n\t\tif(y.emp)return x;\n\t\tN z;\n\t\tz.emp=false;\n\t\tz.f=x.f+y.f;\n\t\tz.e=x.e+y.e;\n\t\tz.fe=max(x.f+y.fe,x.fe+y.e);\n\t\tz.fa=max(x.fa,x.f+y.fa);\n\t\treturn z;\n\t}\n\tint getf(){\n\t\treturn max(fe,fa);\n\t}\n};\n\nstruct Ms{\n\tvi fs,es,gs;\n\tint fsum,esum,gsum;\n\tvoid init(vc<pi> x){\n\t\tfs.resize(si(x));\n\t\tes.resize(si(x));\n\t\tgs.resize(si(x));\n\t\trep(i,si(x)){\n\t\t\tauto [f,e]=x[i];\n\t\t\tint g=max<int>(f,0);\n\t\t\tfs[i]=f;\n\t\t\tes[i]=e;\n\t\t\tgs[i]=g;\n\t\t}\n\t\tfsum=SUM(fs);\n\t\tesum=SUM(es);\n\t\tgsum=SUM(gs);\n\t}\n\tvoid point_set(int i,pi x){\n\t\tauto [f,e]=x;\n\t\tint g=max<int>(f,0);\n\t\tfsum-=fs[i];\n\t\tesum-=es[i];\n\t\tgsum-=gs[i];\n\t\tfs[i]=f;\n\t\tes[i]=e;\n\t\tgs[i]=g;\n\t\tfsum+=fs[i];\n\t\tesum+=es[i];\n\t\tgsum+=gs[i];\n\t}\n};\n\nvoid slv(){\n\tINT(n,q);\n\tvvc<int> rw(n);\n\trng(i,1,n){\n\t\tINT(p);p--;\n\t\trw[p].pb(i);\n\t}\n\t\n\tvi a(n);\n\tvi d(n);\n\tVI(b,n);\n\t\n\tHLD<int> hld=HLD<int>(rw,0);\n\tvi lid(n,-1);\n\tvc<segtree<N>> seg(n);\n\tvc<Ms> lch(n);\n\t\n\t//\u3069\u306e segtree \u306e\u3069\u306e\u4f4d\u7f6e\u306b\u3044\u308b\u304b\n\tauto getij=[&](int v){\n\t//auto getij(int v){\n\t\tint h=hld.head[v];\n\t\treturn pi(h,hld.dep[v]-hld.dep[h]);\n\t};\n\t//lch[v] \u53ca\u3073 v \u672c\u4f53\u306e\u30c7\u30fc\u30bf\u304b\u3089 segtree \u60c5\u5831\u3092\u66f4\u65b0\n\tauto gen_N=[&](int v){\n\t//auto gen_N(int v){\n\t\treturn N(lch[v].fsum,lch[v].esum,lch[v].gsum,a[v],b[v],d[v]);\n\t};\n\tauto upd_seg=[&](int v){\n\t//void upd_seg(int v){\n\t\tauto [i,j]=getij(v);\n\t\tseg[i].point_set(j,gen_N(v));\n\t};\n\t//v \u306e subtree \u3092 light node \u3068\u3057\u3066\u4f55\u3089\u304b\u306e\u30c7\u30fc\u30bf\u306b\u5727\u7e2e\n\t//\u305d\u306e\u5f8c sub[par[v]] \u306b\u7a81\u3063\u8fbc\u307e\u308c\u308b\n\tauto gen_light=[&](int v){\n\t//auto gen_light(int v){\n\t\tassert(hld.head[v]==v);\n\t\tN w=seg[v].getall();\n\t\treturn pi(w.getf(),w.e);\n\t};\n\tauto get_subtree=[&](int v){\n\t//auto get_subtree(int v){\n\t\tauto [i,j]=getij(v);\n\t\treturn seg[i].composite(j,seg[i].n);\n\t};\n\t//init\n\tfor(auto v:reout(hld.ni)){\n\t\t{\n\t\t\tint s=max<int>(si(hld.g[v])-1,0);\n\t\t\t//vc<M> ls(s);\n\t\t\tvc<pi> ls(s);\n\t\t\trep(i,s){\n\t\t\t\tint to=hld.g[v][i+1];\n\t\t\t\tlid[to]=i;\n\t\t\t\tls[i]=gen_light(to);\n\t\t\t}\n\t\t\tlch[v].init(ls);\n\t\t}\n\t\tif(hld.head[v]==v){\n\t\t\tint s=hld.hei[v];\n\t\t\tvc<N> ls(s);\n\t\t\trep(i,s)ls[i]=gen_N(hld.adv(v,i));\n\t\t\tseg[v]=segtree<N>(ls);\n\t\t}\n\t}\n\t\n\trep(_,q){\n\t\t{\n\t\t\tINT(kind,v,w);\n\t\t\tv--;\n\t\t\tif(kind==1){\n\t\t\t\ta[v]+=w;\n\t\t\t}else{\n\t\t\t\td[v]+=w;\n\t\t\t}\n\t\t\tupd_seg(v);\n\t\t\t\n\t\t\twhile(v>=0){\n\t\t\t\tv=hld.head[v];\n\t\t\t\tint p=hld.par[v];\n\t\t\t\tif(p!=-1){\n\t\t\t\t\tlch[p].point_set(lid[v],gen_light(v));\n\t\t\t\t\tupd_seg(p);\n\t\t\t\t}\n\t\t\t\tv=p;\n\t\t\t}\n\t\t}\n\t\tint f=get_subtree(0).getf();\n\t\tif(f>0){\n\t\t\tNO(0);\n\t\t}else{\n\t\t\tYES(0);\n\t\t}\n\t}\n\t\n}\n\nsigned main(signed argc,char*argv[]){\n\tif(argc>1&&strcmp(argv[1],\"D\")==0)dbg=true;\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1){\n\t\t\tif(current_run_id%run_batch_size==0){\n\t\t\t\tcerr<<\"Current Run \"<<current_run_id<<endl;\n\t\t\t}\n\t\t\tslv();\n\t\t\tcurrent_run_id++;\n\t\t}\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "flows", "trees"], "dificulty": "", "interactive": false}