{"link": "https://codeforces.com//contest/618/problem/D", "problemId": "46787", "problem_idx": "D", "shortId": "618D", "contest_number": "618", "problem_submissions": {"E": [15660896, 15660810, 25267684, 15661349, 15660954, 15669573, 15669552, 15657805, 15659540, 15660389, 15659859, 15661631, 15661128, 15659694, 15662154, 15661797, 15661848, 15663282, 15660127, 15662115], "D": [15656948, 15655133, 15655445, 15667159, 15665258, 15655421, 15655925, 15656563, 15656409, 15655319, 15659360, 39354565, 15656312, 15656752, 15657964, 15663170, 15658748], "C": [15652141, 15652363, 15652477, 15652597, 15653006, 15652229, 15653352, 15654441, 15653369, 15652636, 15663125, 15652085, 15653674, 15653050, 15652997, 15652103, 15653430], "A": [15650445, 15649636, 15649663, 15649788, 15649765, 15649822, 15650160, 15649790, 15649745, 15649679, 15649632, 15649853, 15649674, 15649848, 15649720, 15649691, 15650068], "B": [15649885, 15650154, 15650770, 15651204, 15650301, 15650651, 15651598, 15651581, 15651312, 15651165, 15649859, 15650851, 15650978, 15651073, 15650933, 15650396, 15651924], "F": [15662761, 15674016, 15665529, 15670689]}, "name": "D. Hamiltonian Spanning Tree", "statement": "A group of cities is connected by a network of roads. There is an\r\nundirected road between every pair of cities, so there are roads in\r\ntotal. It takes exactly seconds to traverse single road.A is a set of\r\nroads containing exactly roads such that it\u2019s possible to travel between\r\nany two cities using only these roads.Some spanning tree of the initial\r\nnetwork was chosen. For every road in this tree the time one needs to\r\ntraverse this road was changed from to seconds. Note that it\u2019s not\r\nguaranteed that is smaller than .You would like to travel through all\r\nthe cities using the shortest path possible. Given , , and a description\r\nof the spanning tree that was chosen, find the cost of the shortest path\r\nthat starts in any city, ends in any city and visits all cities .\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nll x, y;\nconst int INF = (int)1e7;\nconst int N = 200200;\nint n;\nvector<int> g[N];\nint deg[N];\nint dp[N][2];\nbool used[N];\n\nll solveEasy()\n{\n\tint val = n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint d = n - 1 - (int)g[i].size();\n\t\tval = min(val, d);\n\t}\n\tif (val == 0)\n\t\treturn (n - 2) * y + x;\n\telse\n\t\treturn (n - 1) * y;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = 1;\n\tint sum = 0;\n\tint delta1 = INF, delta2 = INF;\n\tfor (int u : g[v])\n\t{\n\t\tif (used[u]) continue;\n\t\tdfs(u);\n\t\tsum += dp[u][0];\n\t\tint d = dp[u][1] - dp[u][0];\n\t\tif (d < delta1)\n\t\t{\n\t\t\tdelta2 = delta1;\n\t\t\tdelta1 = d;\n\t\t}\n\t\telse if (d < delta2)\n\t\t\tdelta2 = d;\n\t}\n\tdp[v][1] = min(sum + 1, sum + delta1);\n\tdp[v][0] = min(dp[v][1], sum + delta1 + delta2 - 1);\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%lld%lld\", &n, &x, &y);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tif (x >= y)\n\t{\n\t\tprintf(\"%lld\\n\", solveEasy());\n\t\treturn 0;\n\t}\n\tdfs(0);\n//\tfor (int i = 0; i < n; i++)\n//\t\tprintf(\"%d %d\\n\", dp[i][0], dp[i][1]);\n\tprintf(\"%lld\\n\", (n - dp[0][0]) * x + (dp[0][0] - 1) * y);\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graph matchings", "greedy", "trees"], "dificulty": "2200", "interactive": false}