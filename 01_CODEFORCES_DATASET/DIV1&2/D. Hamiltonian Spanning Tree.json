{
    "link": "https://codeforces.com//contest/618/problem/D",
    "problemId": "46787",
    "problem_idx": "D",
    "shortId": "618D",
    "contest_number": "618",
    "problem_submissions": {
        "E": [
            15660896,
            15660810,
            25267684,
            15661349,
            15660954,
            15669573,
            15669552,
            15657805,
            15659540,
            15660389,
            15659859,
            15661631,
            15661128,
            15659694,
            15662154,
            15661797,
            15661848,
            15663282,
            15660127,
            15662115
        ],
        "D": [
            15656948,
            15655133,
            15655445,
            15667159,
            15665258,
            15655421,
            15655925,
            15656563,
            15656409,
            15655319,
            15659360,
            39354565,
            15656312,
            15656752,
            15657964,
            15663170,
            15658748
        ],
        "C": [
            15652141,
            15652363,
            15652477,
            15652597,
            15653006,
            15652229,
            15653352,
            15654441,
            15653369,
            15652636,
            15663125,
            15652085,
            15653674,
            15653050,
            15652997,
            15652103,
            15653430
        ],
        "A": [
            15650445,
            15649636,
            15649663,
            15649788,
            15649765,
            15649822,
            15650160,
            15649790,
            15649745,
            15649679,
            15649632,
            15649853,
            15649674,
            15649848,
            15649720,
            15649691,
            15650068
        ],
        "B": [
            15649885,
            15650154,
            15650770,
            15651204,
            15650301,
            15650651,
            15651598,
            15651581,
            15651312,
            15651165,
            15649859,
            15650851,
            15650978,
            15651073,
            15650933,
            15650396,
            15651924
        ],
        "F": [
            15662761,
            15674016,
            15665529,
            15670689
        ]
    },
    "name": "D. Hamiltonian Spanning Tree",
    "statement": "A group of cities is connected by a network of roads. There is an\r\nundirected road between every pair of cities, so there are roads in\r\ntotal. It takes exactly seconds to traverse single road.A is a set of\r\nroads containing exactly roads such that it\u2019s possible to travel between\r\nany two cities using only these roads.Some spanning tree of the initial\r\nnetwork was chosen. For every road in this tree the time one needs to\r\ntraverse this road was changed from to seconds. Note that it\u2019s not\r\nguaranteed that is smaller than .You would like to travel through all\r\nthe cities using the shortest path possible. Given , , and a description\r\nof the spanning tree that was chosen, find the cost of the shortest path\r\nthat starts in any city, ends in any city and visits all cities .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nll x, y;\nconst int INF = (int)1e7;\nconst int N = 200200;\nint n;\nvector<int> g[N];\nint deg[N];\nint dp[N][2];\nbool used[N];\n\nll solveEasy()\n{\n\tint val = n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint d = n - 1 - (int)g[i].size();\n\t\tval = min(val, d);\n\t}\n\tif (val == 0)\n\t\treturn (n - 2) * y + x;\n\telse\n\t\treturn (n - 1) * y;\n}\n\nvoid dfs(int v)\n{\n\tused[v] = 1;\n\tint sum = 0;\n\tint delta1 = INF, delta2 = INF;\n\tfor (int u : g[v])\n\t{\n\t\tif (used[u]) continue;\n\t\tdfs(u);\n\t\tsum += dp[u][0];\n\t\tint d = dp[u][1] - dp[u][0];\n\t\tif (d < delta1)\n\t\t{\n\t\t\tdelta2 = delta1;\n\t\t\tdelta1 = d;\n\t\t}\n\t\telse if (d < delta2)\n\t\t\tdelta2 = d;\n\t}\n\tdp[v][1] = min(sum + 1, sum + delta1);\n\tdp[v][0] = min(dp[v][1], sum + delta1 + delta2 - 1);\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%lld%lld\", &n, &x, &y);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tif (x >= y)\n\t{\n\t\tprintf(\"%lld\\n\", solveEasy());\n\t\treturn 0;\n\t}\n\tdfs(0);\n//\tfor (int i = 0; i < n; i++)\n//\t\tprintf(\"%d %d\\n\", dp[i][0], dp[i][1]);\n\tprintf(\"%lld\\n\", (n - dp[0][0]) * x + (dp[0][0] - 1) * y);\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graph matchings",
        "greedy",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Hamiltonian Spanning Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/23142",
    "editorial": "This is two separate problems: One where X > Y and when X <= Y. Suppose\r\nX > Y. Then, we can almost always choose a path that avoides any\r\nspanning tree edges. There is one tricky case, which is the case of a\r\nstar graph. To prove the above statement, we know a tree is bipartite,\r\nso let\u00e2\u0080\u0099s choose a bipartition X,Y. As long as there is exists a pair x\r\nin X and y in Y such that there isn\u00e2\u0080\u0099t an edge between x and y, we can\r\nform a hamiltonian path without visiting any spanning tree edges (i.e.\r\ntravel through all vertices in X and end at x, then go to y, then travel\r\nthrough all vertices in Y). We can see that this happens as long as it\r\nis not a complete bipartite graph, which can only happen when |X| = 1 or\r\n|Y| = 1 (which is the case of a star graph). For the other case, X <= Y.\r\nSome intuition is that you want to maximize the number of edges that you\r\nuse within the spanning tree. So, you might think along the lines of a\r\n\"maximum path cover\". Restating the problem is a good idea at this\r\npoint. Here\u00e2\u0080\u0099s a restated version of the problem. You\u00e2\u0080\u0099re given a tree.\r\nChoose the maximum number of edges such that all nodes are incident to\r\nat most 2 edges. (or equivalent a \"2-matching\" in this tree). Roughly,\r\nthe intuition is that a 2-matching is a path cover, and vice versa. This\r\ncan be done with a tree dp, but here is a greedy solution for this\r\nproblem. Root the tree arbitrarily. Then, let\u00e2\u0080\u0099s perform a dfs so we\r\nprocess all of a node\u00e2\u0080\u0099s children before processing a node. To process a\r\nnode, let\u00e2\u0080\u0099s count the number of \"available\" children. If this number is\r\n0, then mark the node as available. If this number is 1, draw an edge\r\nfrom the node to its only available child and mark the node as\r\navailable. Otherwise, if this number is 2 or greater, choose two\r\narbitrary children and use those edges. Do not mark the node as\r\navailable in this case. Now, let U be the number of edges that we used\r\nfrom the above greedy algorithm. Then, the final answer is (n-1-U)*y +\r\nU*x). (Proof may be added later, as mine is a bit long, unless someone\r\nhas an easier proof they want to post). Example code:\r\nhttp://codeforces.com/contest/618/submission/15669516 Comment: The case\r\nwhere X > Y and the tree is a star was not included in pretests. Thus,\r\nthis could have been used to hack.\r\n"
}