{
    "link": "https://codeforces.com//contest/618/problem/E",
    "problemId": "46788",
    "problem_idx": "E",
    "shortId": "618E",
    "contest_number": "618",
    "problem_submissions": {
        "E": [
            15660896,
            15660810,
            25267684,
            15661349,
            15660954,
            15669573,
            15669552,
            15657805,
            15659540,
            15660389,
            15659859,
            15661631,
            15661128,
            15659694,
            15662154,
            15661797,
            15661848,
            15663282,
            15660127,
            15662115
        ],
        "D": [
            15656948,
            15655133,
            15655445,
            15667159,
            15665258,
            15655421,
            15655925,
            15656563,
            15656409,
            15655319,
            15659360,
            39354565,
            15656312,
            15656752,
            15657964,
            15663170,
            15658748
        ],
        "C": [
            15652141,
            15652363,
            15652477,
            15652597,
            15653006,
            15652229,
            15653352,
            15654441,
            15653369,
            15652636,
            15663125,
            15652085,
            15653674,
            15653050,
            15652997,
            15652103,
            15653430
        ],
        "A": [
            15650445,
            15649636,
            15649663,
            15649788,
            15649765,
            15649822,
            15650160,
            15649790,
            15649745,
            15649679,
            15649632,
            15649853,
            15649674,
            15649848,
            15649720,
            15649691,
            15650068
        ],
        "B": [
            15649885,
            15650154,
            15650770,
            15651204,
            15650301,
            15650651,
            15651598,
            15651581,
            15651312,
            15651165,
            15649859,
            15650851,
            15650978,
            15651073,
            15650933,
            15650396,
            15651924
        ],
        "F": [
            15662761,
            15674016,
            15665529,
            15670689
        ]
    },
    "name": "E. Robot Arm",
    "statement": "Roger is a robot. He has an arm that is a series of segments connected\r\nto each other. The endpoints of the -th segment are initially located at\r\npoints and . The endpoint at is colored red and the endpoint at is\r\ncolored blue for all segments. Thus, the blue endpoint of the -th\r\nsegment is touching the red endpoint of the -th segment for all valid\r\n.Roger can move his arm in two different ways: He can choose some\r\nsegment and some value. This is denoted as choosing the segment number\r\nand picking some positive . This change happens as follows: the red\r\nendpoint of segment number and segments from to are all fixed in place.\r\nImagine a ray from the red endpoint to the blue endpoint. The blue\r\nendpoint and segments through are translated units in the direction of\r\nthis ray. In this picture, the red point labeled and segments before\r\nstay in place, while the blue point labeled and segments after gets\r\ntranslated. He can choose a segment and rotate it. This is denoted as\r\nchoosing the segment number , and an angle . The red endpoint of the -th\r\nsegment will stay fixed in place. The blue endpoint of that segment and\r\nsegments to will rotate clockwise by an angle of degrees around the red\r\nendpoint. In this picture, the red point labeled and segments before\r\nstay in place, while the blue point labeled and segments after get\r\nrotated around point . Roger will move his arm times. These\r\ntransformations are a bit complicated, and Roger easily loses track of\r\nwhere the blue endpoint of the last segment is. Help him compute the\r\ncoordinates of the blue endpoint of the last segment after applying each\r\noperation. Note that these operations are cumulative, and Roger\u2019s arm\r\nmay intersect itself arbitrarily during the moves.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 4 * atan(1);\nconst int N = 1 << 19;\nint n;\nint q;\n\nstruct Matrix\n{\n\tdouble a[3][3];\n\n\tMatrix()\n\t{\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\ta[i][j] = (int)(i == j);\n\t}\n\n\tMatrix operator * (const Matrix &A) const\n\t{\n\t\tMatrix R = Matrix();\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tR.a[i][j] = 0;\n\t\t\t\tfor (int h = 0; h < 3; h++)\n\t\t\t\t\tR.a[i][j] += a[i][h] * A.a[h][j];\n\t\t\t}\n\t\treturn R;\n\t}\n};\n\nMatrix getShift(double dx, double dy)\n{\n\tMatrix R = Matrix();\n\tR.a[0][0] = R.a[1][1] = R.a[2][2] = 1;\n\tR.a[2][0] = dx;\n\tR.a[2][1] = dy;\n\treturn R;\n}\nMatrix getRotate(double x, double y, double ang)\n{\n\tMatrix R = Matrix();\n\tR.a[2][0] = R.a[2][1] = R.a[0][2] = R.a[1][2] = 0;\n\tR.a[2][2] = 1;\n\tR.a[0][0] = cos(ang);\n\tR.a[1][0] = -sin(ang);\n\tR.a[0][1] = sin(ang);\n\tR.a[1][1] = cos(ang);\n\treturn getShift(-x, -y) * R * getShift(x, y);\n}\n\nstruct Node\n{\n\tint l, r;\n\tMatrix A;\n\n\tNode () : l(), r(), A() {}\n\tNode(int _l, int _r) : l(_l), r(_r) {}\n};\n\nNode tree[2 * N];\n\nvoid buildTree()\n{\n\tfor (int i = 0; i < N; i++)\n\t\ttree[N + i] = Node(i, i + 1);\n\tfor (int i = N - 1; i > 0; i--)\n\t\ttree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n\treturn;\n}\n\nvoid push(int v)\n{\n\tif (v >= N) throw;\n\tfor (int i = 0; i < 2; i++)\n\t\ttree[2 * v + i].A = tree[2 * v + i].A * tree[v].A;\n\ttree[v].A = Matrix();\n\treturn;\n}\n\nvoid apply(int v, int l, int r, Matrix A)\n{\n\tif (l <= tree[v].l && tree[v].r <= r)\n\t{\n\t\ttree[v].A = tree[v].A * A;\n\t\treturn;\n\t}\n\tif (l >= tree[v].r || tree[v].l >= r) return;\n\tpush(v);\n\tfor (int i = 0; i < 2; i++)\n\t\tapply(2 * v + i, l, r, A);\n\treturn;\n}\n\nMatrix getVal(int p)\n{\n\tint v = 1;\n\twhile(v < N)\n\t{\n\t\tpush(v);\n\t\tv *= 2;\n\t\tif (p >= tree[v].r) v++;\n\t}\n\treturn tree[v].A;\n}\n\nvoid query1(int p, double L)\n{\n\tMatrix A = getVal(p);\n\tMatrix B = getVal(p + 1);\n\tdouble x = B.a[0][0] - A.a[0][0], y = B.a[0][1] - A.a[0][1];\n\tL /= sqrt(x * x + y * y);\n\tx *= L;\n\ty *= L;\n\tapply(1, p + 1, n + 1, getShift(x, y));\n\treturn;\n}\nvoid query2(int p, double ang)\n{\n\tMatrix A = getVal(p);\n\tapply(1, p + 1, n + 1, getRotate(A.a[0][0], A.a[0][1], ang));\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tbuildTree();\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\ttree[N + i].A.a[x][y] = 0;\n\t\ttree[N + i].A.a[0][0] = i;\n\t\ttree[N + i].A.a[0][2] = 1;\n\t}\n\twhile(q--)\n\t{\n\t\tint t, pos;\n\t\tscanf(\"%d%d\", &t, &pos);\n\t\tif (t == 1)\n\t\t{\n\t\t\tdouble len;\n\t\t\tscanf(\"%lf\", &len);\n\t\t\tquery1(pos - 1, len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble ang;\n\t\t\tscanf(\"%lf\", &ang);\n\t\t\tang = (360. - ang) / 180. * PI;\n\t\t\tquery2(pos - 1, ang);\n\t\t}\n\t\tMatrix R = getVal(n);\n\t\tprintf(\"%.10lf %.10lf\\n\", R.a[0][0], R.a[0][1]);\n\t}\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "geometry"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Robot Arm.json",
    "editorial_link": "https://codeforces.com//blog/entry/23142",
    "editorial": "We can view a segment as a linear transformation in two stages, first a\r\nrotation, then a translation. We can describe a linear transformation\r\nwith a 3x3 matrix, so for example, a rotation by theta is given by the\r\nmatrix {{cos(theta), sin(theta), 0}, {-sin(theta), cos(theta), 0}, {0,\r\n0, 1}} and a translation by L units is, {{1, 0, L}, {0, 1, 0}, {0, 0,\r\n1}} (these can also be found by searching on google). So, we can create\r\na segment tree on the segments, where a node in the segment tree\r\ndescribes the 3x3 matrix of a range of nodes. Thus updating takes O(log\r\nn) time, and getting the coordinates of the last blue point can be\r\ntaken. Some speedups. There is no need to store a 3x3 matrix. You can\r\ninstead store the x,y, and angle at each node, and combine them\r\nappropriately (see code for details). Also, another simple speedup is to\r\nprecompute cos/sin for all 360 degrees so we don\u00e2\u0080\u0099t repeatedly call these\r\nfunctions. Example code (Java):\r\nhttp://codeforces.com/contest/618/submission/15669521 Example code\r\n(C++): http://codeforces.com/contest/618/submission/15669530 Comment:\r\nI\u00e2\u0080\u0099m very sorry about precision issues. We realized this at the last\r\nminute, and I didn\u00e2\u0080\u0099t expect so many solutions to fail because of this. I\r\nhave checked my own answers against a BigDecimal implementation in Java,\r\nso try to use long doubles. Also, as a side note, this is the first ever\r\ndata structure question that I\u00e2\u0080\u0099ve written.\r\n"
}