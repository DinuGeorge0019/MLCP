{"link": "https://codeforces.com//contest/618/problem/E", "problemId": "46788", "problem_idx": "E", "shortId": "618E", "contest_number": "618", "problem_submissions": {"E": [15660896, 15660810, 25267684, 15661349, 15660954, 15669573, 15669552, 15657805, 15659540, 15660389, 15659859, 15661631, 15661128, 15659694, 15662154, 15661797, 15661848, 15663282, 15660127, 15662115], "D": [15656948, 15655133, 15655445, 15667159, 15665258, 15655421, 15655925, 15656563, 15656409, 15655319, 15659360, 39354565, 15656312, 15656752, 15657964, 15663170, 15658748], "C": [15652141, 15652363, 15652477, 15652597, 15653006, 15652229, 15653352, 15654441, 15653369, 15652636, 15663125, 15652085, 15653674, 15653050, 15652997, 15652103, 15653430], "A": [15650445, 15649636, 15649663, 15649788, 15649765, 15649822, 15650160, 15649790, 15649745, 15649679, 15649632, 15649853, 15649674, 15649848, 15649720, 15649691, 15650068], "B": [15649885, 15650154, 15650770, 15651204, 15650301, 15650651, 15651598, 15651581, 15651312, 15651165, 15649859, 15650851, 15650978, 15651073, 15650933, 15650396, 15651924], "F": [15662761, 15674016, 15665529, 15670689]}, "name": "E. Robot Arm", "statement": "Roger is a robot. He has an arm that is a series of segments connected\r\nto each other. The endpoints of the -th segment are initially located at\r\npoints and . The endpoint at is colored red and the endpoint at is\r\ncolored blue for all segments. Thus, the blue endpoint of the -th\r\nsegment is touching the red endpoint of the -th segment for all valid\r\n.Roger can move his arm in two different ways: He can choose some\r\nsegment and some value. This is denoted as choosing the segment number\r\nand picking some positive . This change happens as follows: the red\r\nendpoint of segment number and segments from to are all fixed in place.\r\nImagine a ray from the red endpoint to the blue endpoint. The blue\r\nendpoint and segments through are translated units in the direction of\r\nthis ray. In this picture, the red point labeled and segments before\r\nstay in place, while the blue point labeled and segments after gets\r\ntranslated. He can choose a segment and rotate it. This is denoted as\r\nchoosing the segment number , and an angle . The red endpoint of the -th\r\nsegment will stay fixed in place. The blue endpoint of that segment and\r\nsegments to will rotate clockwise by an angle of degrees around the red\r\nendpoint. In this picture, the red point labeled and segments before\r\nstay in place, while the blue point labeled and segments after get\r\nrotated around point . Roger will move his arm times. These\r\ntransformations are a bit complicated, and Roger easily loses track of\r\nwhere the blue endpoint of the last segment is. Help him compute the\r\ncoordinates of the blue endpoint of the last segment after applying each\r\noperation. Note that these operations are cumulative, and Roger\u2019s arm\r\nmay intersect itself arbitrarily during the moves.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 4 * atan(1);\nconst int N = 1 << 19;\nint n;\nint q;\n\nstruct Matrix\n{\n\tdouble a[3][3];\n\n\tMatrix()\n\t{\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t\ta[i][j] = (int)(i == j);\n\t}\n\n\tMatrix operator * (const Matrix &A) const\n\t{\n\t\tMatrix R = Matrix();\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tfor (int j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tR.a[i][j] = 0;\n\t\t\t\tfor (int h = 0; h < 3; h++)\n\t\t\t\t\tR.a[i][j] += a[i][h] * A.a[h][j];\n\t\t\t}\n\t\treturn R;\n\t}\n};\n\nMatrix getShift(double dx, double dy)\n{\n\tMatrix R = Matrix();\n\tR.a[0][0] = R.a[1][1] = R.a[2][2] = 1;\n\tR.a[2][0] = dx;\n\tR.a[2][1] = dy;\n\treturn R;\n}\nMatrix getRotate(double x, double y, double ang)\n{\n\tMatrix R = Matrix();\n\tR.a[2][0] = R.a[2][1] = R.a[0][2] = R.a[1][2] = 0;\n\tR.a[2][2] = 1;\n\tR.a[0][0] = cos(ang);\n\tR.a[1][0] = -sin(ang);\n\tR.a[0][1] = sin(ang);\n\tR.a[1][1] = cos(ang);\n\treturn getShift(-x, -y) * R * getShift(x, y);\n}\n\nstruct Node\n{\n\tint l, r;\n\tMatrix A;\n\n\tNode () : l(), r(), A() {}\n\tNode(int _l, int _r) : l(_l), r(_r) {}\n};\n\nNode tree[2 * N];\n\nvoid buildTree()\n{\n\tfor (int i = 0; i < N; i++)\n\t\ttree[N + i] = Node(i, i + 1);\n\tfor (int i = N - 1; i > 0; i--)\n\t\ttree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n\treturn;\n}\n\nvoid push(int v)\n{\n\tif (v >= N) throw;\n\tfor (int i = 0; i < 2; i++)\n\t\ttree[2 * v + i].A = tree[2 * v + i].A * tree[v].A;\n\ttree[v].A = Matrix();\n\treturn;\n}\n\nvoid apply(int v, int l, int r, Matrix A)\n{\n\tif (l <= tree[v].l && tree[v].r <= r)\n\t{\n\t\ttree[v].A = tree[v].A * A;\n\t\treturn;\n\t}\n\tif (l >= tree[v].r || tree[v].l >= r) return;\n\tpush(v);\n\tfor (int i = 0; i < 2; i++)\n\t\tapply(2 * v + i, l, r, A);\n\treturn;\n}\n\nMatrix getVal(int p)\n{\n\tint v = 1;\n\twhile(v < N)\n\t{\n\t\tpush(v);\n\t\tv *= 2;\n\t\tif (p >= tree[v].r) v++;\n\t}\n\treturn tree[v].A;\n}\n\nvoid query1(int p, double L)\n{\n\tMatrix A = getVal(p);\n\tMatrix B = getVal(p + 1);\n\tdouble x = B.a[0][0] - A.a[0][0], y = B.a[0][1] - A.a[0][1];\n\tL /= sqrt(x * x + y * y);\n\tx *= L;\n\ty *= L;\n\tapply(1, p + 1, n + 1, getShift(x, y));\n\treturn;\n}\nvoid query2(int p, double ang)\n{\n\tMatrix A = getVal(p);\n\tapply(1, p + 1, n + 1, getRotate(A.a[0][0], A.a[0][1], ang));\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tbuildTree();\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int x = 0; x < 3; x++)\n\t\t\tfor (int y = 0; y < 3; y++)\n\t\t\t\ttree[N + i].A.a[x][y] = 0;\n\t\ttree[N + i].A.a[0][0] = i;\n\t\ttree[N + i].A.a[0][2] = 1;\n\t}\n\twhile(q--)\n\t{\n\t\tint t, pos;\n\t\tscanf(\"%d%d\", &t, &pos);\n\t\tif (t == 1)\n\t\t{\n\t\t\tdouble len;\n\t\t\tscanf(\"%lf\", &len);\n\t\t\tquery1(pos - 1, len);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble ang;\n\t\t\tscanf(\"%lf\", &ang);\n\t\t\tang = (360. - ang) / 180. * PI;\n\t\t\tquery2(pos - 1, ang);\n\t\t}\n\t\tMatrix R = getVal(n);\n\t\tprintf(\"%.10lf %.10lf\\n\", R.a[0][0], R.a[0][1]);\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "geometry"], "dificulty": "2500", "interactive": false}