{
    "link": "https://codeforces.com//contest/1863/problem/F",
    "problemId": "2186457",
    "problem_idx": "F",
    "shortId": "1863F",
    "contest_number": "1863",
    "problem_submissions": {
        "G": [
            221136551,
            221139848,
            221147121,
            221150406,
            221156272,
            221151276,
            221147870,
            221157045,
            221150654,
            221158033,
            221156995,
            221150405,
            221155989,
            221155038,
            221160627,
            221149999,
            221166719,
            221155326,
            221159641,
            221165396
        ],
        "F": [
            221121590,
            221127771,
            221128307,
            221138108,
            221130805,
            221136021,
            221136737,
            221129060,
            221140638,
            221137056,
            221128211,
            221139417,
            221137699,
            221127026,
            221139802,
            221154849,
            221135761,
            221144061,
            221150102,
            221217304,
            221142638
        ],
        "E": [
            221110018,
            221117203,
            221116712,
            221116632,
            221114627,
            221123945,
            221125852,
            221119344,
            221123994,
            221117191,
            221120648,
            221126771,
            221126517,
            221139461,
            221119939,
            221121938,
            221123387,
            221126376,
            221121543,
            221217383,
            221127296
        ],
        "D": [
            221102414,
            221109581,
            221105244,
            221107918,
            221106665,
            221103992,
            221113320,
            221110649,
            221111108,
            221103919,
            221112047,
            221112174,
            221110753,
            221112715,
            221104010,
            221113678,
            221110048,
            221113375,
            221110273,
            221109100
        ],
        "C": [
            221098267,
            221102354,
            221100311,
            221098509,
            221100896,
            221098602,
            221107809,
            221105183,
            221098239,
            221098225,
            221102929,
            221105006,
            221102283,
            221103582,
            221098969,
            221099286,
            221102760,
            221106477,
            221099714,
            221101657
        ],
        "A": [
            221096643,
            221096074,
            221096129,
            221096043,
            221095975,
            221096016,
            221096907,
            221096642,
            221101230,
            221095943,
            221096347,
            221097350,
            221096423,
            221097791,
            221095953,
            221096058,
            221096941,
            221096889,
            221096069,
            221097073
        ],
        "B": [
            221096498,
            221097225,
            221097260,
            221096607,
            221096286,
            221096471,
            221098534,
            221098779,
            221102915,
            221096280,
            221097328,
            221098778,
            221097955,
            221099465,
            221096389,
            221096664,
            221099499,
            221099302,
            221096756,
            221098284
        ],
        "I": [
            221276607,
            221276430,
            221275617,
            221825420,
            221197104
        ],
        "H": [
            221188380,
            221214363,
            221182970,
            221376731,
            221376708,
            221376397,
            221187887
        ]
    },
    "name": "F. Divide, XOR, and Conquer",
    "statement": "You are given an array of n integers a_1, a_2,\r\nldots, a_n.In one operation you split the array into two parts: a\r\nnon-empty prefix and a non-empty suffix. The value of each part is the\r\nbitwise XOR of all elements in it. Next, discard the part with the\r\nsmaller value. If both parts have equal values, you can choose which one\r\nto discard. Replace the array with the remaining part.The operations are\r\nbeing performed until the length of the array becomes 1. For each i (1\r\nle i\r\nle n), determine whether it is possible to achieve the state when only\r\nthe i-th element (with respect to the original numbering)\r\nremains.Formally, you have two numbers l and r, initially l = 1 and r =\r\nn. The current state of the array is [a_l, a_{l+1},\r\nldots, a_r].As long as l < r, you apply the following operation: Choose\r\nan arbitrary k from the set\r\n{l, l + 1,\r\nldots, r - 1\r\n}. Denote x = a_l\r\noplus a_{l + 1}\r\noplus\r\nldots\r\noplus a_k and y = a_{k + 1}\r\noplus a_{k + 2}\r\noplus\r\nldots\r\noplus a_{r}, where\r\noplus denotes the bitwise XOR operation. If x < y, set l = k + 1. If x >\r\ny, set r = k. If x = y, either set l = k + 1, or set r = k. For each i\r\n(1\r\nle i\r\nle n), determine whether it is possible to achieve l = r = i.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.08.2023 11:00:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<long long> pref(n + 1);\n    for (int i = 0; i < n; i++) {\n      pref[i + 1] = pref[i] ^ a[i];\n    }\n    vector<vector<bool>> dp(n + 1, vector<bool>(n + 1));\n    vector<long long> L1(n + 1);\n    vector<long long> L0(n + 1);\n    vector<long long> R1(n + 1);\n    vector<long long> R0(n + 1);\n    string res = \"\";\n    dp[0][n] = true;\n    for (int i = 0; i < n; i++) {\n      for (int j = n; j >= i + 1; j--) {\n        if (pref[j] & L1[i]) {\n          dp[i][j] = true;\n        }\n        if ((~pref[j]) & L0[i]) {\n          dp[i][j] = true;\n        }\n        if (pref[i] & R1[j]) {\n          dp[i][j] = true;\n        }\n        if ((~pref[i]) & R0[j]) {\n          dp[i][j] = true;\n        }\n        if (i + 1 == j) {\n          res += (dp[i][j] ? \"1\" : \"0\");\n          continue;\n        }\n        if (!dp[i][j]) {\n          continue;\n        }\n        long long x = pref[i] ^ pref[j];\n        if (x == 0) {\n          L0[i] = -1;\n          L1[i] = -1;\n          R0[j] = -1;\n          R1[j] = -1;\n        } else {\n          int b = 63 - __builtin_clzll(x);\n          long long bit = 1LL << b;\n          if (pref[i] & bit) {\n            L0[i] |= bit;\n            R1[j] |= bit;\n          } else {\n            L1[i] |= bit;\n            R0[j] |= bit;\n          }\n        }\n      }  \n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Divide, XOR, and Conquer.json",
    "editorial_link": "https://codeforces.com//blog/entry/119902",
    "editorial": "Let , , .If is zero, than we can choose any and any side because .If is\r\nnot zero we can choose such for the left side that the most significant\r\nbit of is the same as the most significant bit of because does not have\r\nthis bit, and therefore less than . Same for the right side.We will\r\niterate over all subarrays in non-increasing order of length and will\r\ncalculate two set of bits and for each position of array bits, one of\r\nwhich must contain the XOR of subarray numbers to start/end at that\r\nposition.To check that we can achieve , we need to check that or or any\r\nsegment can start/end in these positions, since there was a segment with\r\nzero XOR with such start/end. If we can achieve than: if add the most\r\nsignificant bit of to and ; if remember that any subarray of shorter\r\nlength can start/end at these positions. The time complexity is , the\r\nspace complexity is .\r\n"
}