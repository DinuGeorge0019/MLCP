{
    "link": "https://codeforces.com//contest/722/problem/D",
    "problemId": "74002",
    "problem_idx": "D",
    "shortId": "722D",
    "contest_number": "722",
    "problem_submissions": {
        "F": [
            21091512,
            21085594,
            21089803,
            21092021,
            21091925,
            21091406,
            21083741,
            21089867,
            21089611,
            21086397,
            21088088,
            21089823,
            21086418,
            21090125,
            21089647,
            21089044,
            21089230,
            21089273
        ],
        "E": [
            21088023,
            21107688,
            21106067,
            21087044,
            21088852,
            21116611,
            21251507,
            21091238,
            21126451
        ],
        "D": [
            21080172,
            21076258,
            21078404,
            21076583,
            21076470,
            21078997,
            21077617,
            21080800,
            21077359,
            21076406,
            21076609,
            21078412,
            21075627,
            21078861,
            21077229,
            21077815,
            21082146,
            21079311,
            21080176,
            21080301
        ],
        "C": [
            21074766,
            21074143,
            21079601,
            21075184,
            21074110,
            21076772,
            21073504,
            21077447,
            21074819,
            21079500,
            21074909,
            21079654,
            21072018,
            21074306,
            21075294,
            21074312,
            21076102,
            21076830,
            21075898,
            21075171
        ],
        "A": [
            21071362,
            21070972,
            21070997,
            21070865,
            21070901,
            21080897,
            21070869,
            21071371,
            21070926,
            21071044,
            21070971,
            21074578,
            21078981,
            21070900,
            21072665,
            21071359,
            21071666,
            21071148,
            21070986,
            21070908
        ],
        "B": [
            21071955,
            21071959,
            21071961,
            21072182,
            21071953,
            21073607,
            21072621,
            21072656,
            21072545,
            21073995,
            21077019,
            21071668,
            21072069,
            21072511,
            21073331,
            21073657,
            21072159,
            21071949
        ]
    },
    "name": "D. Generating Sets",
    "statement": "You are given a set of positive integers .Set of positive integers is\r\nsaid to set if one can transform to by applying some number of the\r\nfollowing two operation to integers in : Take any integer and multiply\r\nit by two, i.e. replace with . Take any integer , multiply it by two and\r\nadd one, i.e. replace with . Note that integers in are not required to\r\nbe distinct after each operation.Two sets of distinct integers and are\r\nequal if they are equal as sets. In other words, if we write elements of\r\nthe sets in the array in the increasing order, these arrays would be\r\nequal.Note, that any set of integers (or its permutation) generates\r\nitself.You are given a set and have to find a set that generates and the\r\n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, n;\nint A[50000];\nint trie[50000*35][2];\nbool leaf[50000*35];\nvector<int> v;\n\nint dfs(int u, int lim, int x)\n{\n    int sum=leaf[u];\n    for(int i=0; i<2; i++) if(trie[u][i])\n        sum+=dfs(trie[u][i], lim, x*2+i);\n    if(x>=1 && x<=lim && sum>0)\n        sum--, v.push_back(x);\n    return sum;\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    n=1;\n    for(int i=0; i<N; i++)\n    {\n        scanf(\"%d\", A+i);\n        int cur=1;\n        for(int j=30; j>=0; j--) if(A[i]>>j)\n        {\n            int b=(A[i]>>j)&1;\n            if(!trie[cur][b])\n                trie[cur][b]=++n;\n            cur=trie[cur][b];\n        }\n        leaf[cur]=true;\n    }\n    int lo=1, mid, hi=1000000000;\n    while(lo<hi)\n    {\n        v.clear();\n        mid=(lo+hi)/2;\n        if(dfs(1, mid, 0)==0)\n            hi=mid;\n        else\n            lo=mid+1;\n    }\n    v.clear();\n    dfs(1, lo, 0);\n    for(auto& it: v)\n        printf(\"%d \", it);\n    printf(\"\\n\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "greedy",
        "strings",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Generating Sets.json",
    "editorial_link": "https://codeforces.com//blog/entry/47497",
    "editorial": "Authorâs solution appeared to be slightly more complicated than the\r\nsolutions of most of the participants, so we will describe that simple\r\nsolution.An arbitrary number can be obtained from one of the following\r\nnumbers - and only from them. Therefore, we will use the following\r\ngreedy algorithm:Letâs choose the maximum number from the set (assume\r\nthis number is ). We look through all the numbers from which you can\r\nobtain the selected number - . Among these numbers choose the maximum\r\nnumber, which is not included in the set yet. Replace with this number\r\nand do the above operation again.If at some point it turned out that all\r\nof these numbers already belong to the set , then we print the current\r\nset and finish the algorithm.To find the maximum number and to check\r\nwhether any number is belong to or not, you can use the binary search\r\ntree (f.e. set from STL) or the combination of priority queue and hash\r\ntable.Formally, the total complexity of this solution is .\r\n",
    "hint": []
}