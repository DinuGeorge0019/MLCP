{
    "link": "https://codeforces.com//contest/1428/problem/D",
    "problemId": "762866",
    "problem_idx": "D",
    "shortId": "1428D",
    "contest_number": "1428",
    "problem_submissions": {
        "H": [
            95798388,
            96079889,
            95822989,
            95819273
        ],
        "G2": [
            95777265,
            95779066,
            95783656,
            95782002,
            95792200,
            95787701,
            95792987,
            95787809,
            95792595,
            95788941,
            95788283,
            95789699,
            95792016,
            95786243,
            95795577,
            95795657,
            95796576,
            95798040,
            95805912,
            95794416
        ],
        "G1": [
            95777192,
            95778996,
            95783550,
            95782076,
            95787327,
            95787607,
            95787264,
            95787896,
            95792632,
            95789001,
            95788384,
            95789621,
            95791835,
            95786301,
            95795432,
            95795591,
            95796478,
            95795620,
            95794276,
            95794356
        ],
        "F": [
            95765157,
            95765965,
            95771166,
            95767388,
            95768274,
            95768695,
            95770215,
            95759208,
            95832501,
            95832498,
            95832480,
            95831607,
            95831604,
            95831342,
            95763101,
            95777757,
            95779436,
            95770353,
            95771012,
            95772923,
            95779700,
            95776557,
            95778129,
            95776549,
            95775700,
            95779883
        ],
        "E": [
            95758700,
            95760055,
            95763026,
            95762658,
            95754707,
            95762381,
            95764564,
            95752105,
            95754040,
            95762344,
            95751508,
            95766331,
            95750653,
            95764708,
            95767437,
            95759986,
            95764850,
            95764733,
            95758532,
            95759950
        ],
        "D": [
            95754864,
            95756381,
            95758710,
            95758367,
            95764528,
            95758021,
            95759449,
            95765541,
            95774991,
            95758395,
            95775675,
            95762065,
            95777703,
            95760640,
            95762966,
            95770799,
            95762173,
            95759561,
            95760180,
            95767247
        ],
        "B": [
            95745661,
            95741583,
            95746087,
            95741923,
            95743557,
            95741471,
            95742126,
            95742079,
            95743874,
            95742788,
            95744560,
            95742620,
            95745128,
            95748044,
            95745202,
            95746759,
            95741532,
            95741702,
            95742488,
            95749798
        ],
        "C": [
            95742981,
            95744852,
            95748437,
            95744808,
            95746831,
            95743810,
            95745097,
            95745356,
            95741031,
            95745159,
            95747546,
            95747612,
            95742323,
            95747442,
            95747895,
            95749106,
            95744992,
            95747455,
            95745170,
            95751867
        ],
        "A": [
            95740482,
            95739860,
            95740501,
            95739845,
            95741896,
            95739795,
            95739865,
            95739838,
            95739950,
            95739997,
            95739893,
            95739847,
            95740138,
            95852510,
            95844045,
            95839237,
            95838793,
            95838769,
            95838754,
            95838446,
            95824867,
            95812004,
            95742639,
            95740471,
            95741183,
            95739807,
            95739826,
            95740061,
            95740497
        ]
    },
    "name": "D. Bouncing Boomerangs",
    "statement": "To improve the boomerang throwing skills of the animals, Zookeeper has\r\nset up an n\r\ntimes n grid with some targets, . The rows are numbered from 1 to n from\r\ntop to bottom, and the columns are numbered from 1 to n from left to\r\nright. For each column, Zookeeper will throw a boomerang from the bottom\r\nof the column (below the grid) upwards. When the boomerang hits any\r\ntarget, it will bounce off, make a 90 degree turn to the right and fly\r\noff in a straight line in its new direction. The boomerang can hit\r\nmultiple targets and does not stop until it leaves the grid. In the\r\nabove example, n=6 and the black crosses are the targets. The boomerang\r\nin column 1 (blue arrows) bounces 2 times while the boomerang in column\r\n3 (red arrows) bounces 3 times. The boomerang in column i hits exactly\r\na_i targets before flying out of the grid. However, Zookeeper has lost\r\nthe original positions of the targets. Thus, he asks you to construct a\r\nvalid configuration of targets that matches the number of hits for each\r\ncolumn, or tell him that no such configuration exists. If multiple valid\r\nconfigurations exist, you may print any of them.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nvi wek[nax];\nvector<pii> wyn;\n\nvoid buduj(int kol, int wys)\n{\n\twyn.push_back({n+1-wys, kol});\n\twek[kol].push_back(wys);\n}\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nvi jedy[4];\n\nint daj(int v)\n{\n\tif (v==2)\n\t{\n\t\tif (jedy[1].empty())\n\t\t\tnope();\n\t\tint x=jedy[1].back();\n\t\tjedy[1].pop_back();\n\t\treturn x;\n\t}\n\tfor (int i=3; i; i--)\n\t{\n\t\tif (!jedy[i].empty())\n\t\t{\n\t\t\tint x=jedy[i].back();\n\t\t\tjedy[i].pop_back();\n\t\t\treturn x;\n\t\t}\n\t}\n\tnope();\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (!tab[i])\n\t\t\tcontinue;\n\t\tif (tab[i]==1)\n\t\t{\n\t\t\tbuduj(i, n+1-i);\n\t\t\tjedy[1].push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t\tint x=daj(tab[i]);\n\t\tif (tab[i]==2)\n\t\t{\n\t\t\tbuduj(i, n+1-x);\n\t\t\tjedy[2].push_back(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuduj(i, n+1-i);\n\t\t\tbuduj(x, n+1-i);\n\t\t\tjedy[3].push_back(i);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", (int)wyn.size());\n\tfor (pii i : wyn)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Bouncing Boomerangs.json",
    "editorial_link": "https://codeforces.com//blog/entry/83771",
    "editorial": "Clearly, columns with\nare completely empty and we can ignore them.Let\u00e2\u0080\u0099s first consider just\ncolumns with s and s. When a boomerang strikes its first target, it will\nchange directions from upwards to rightwards. If , the boomerang in\ncolumn exits the grid on the right. This means that if the target that\nit hits in on row , there is no other target to its right on row .For\ncolumns with , the boomerang in column has to hit second target in some\ncolumn before moving downwards. The targets that this boomerang hits\nmust be in the same row, and since no row contains more than targets,\nthese are the only targets in the row. Additionally, there isn\u00e2\u0080\u0099t any\ntarget below the second target. This means . This tells us that columns\nwith must be matched with columns with to its right with . If we only\nhad and , we can simply greedily match s to s that are available. s\ninitially seem difficult to handle. The key observation is that s can\n\"link\" to s to its right. The way to do this for the have the first\ntarget for one boomerang be the third target for another boomerang. This\nallows us to \"chain\" the s together in one long chain.Thus, we only care\nabout the first , which has to use either a or a (if it uses a , that\ncannot be matched with a ). We should always use a if possible since it\nwill never be used by anything else, and the exact that we use also\ndoesn\u00e2\u0080\u0099t matter.Thus the solution is as follows: Process from right to\nleft. If the current value is a , add it to a list of available ones. If\nthe current value is a , match it with an available and remove the from\nthe list. If the current value is a , match it with , or in that order\nof preference. Once we have found the chains and matches, we can go from\nleft to right and give each chain / match some number of rows to use so\nthat they do not overlap. The final time complexity is .Bonus : Show\nthat the directly simulating the path of each boomerang is overall\n.Bonus (unsolved): Solve for .\n"
}