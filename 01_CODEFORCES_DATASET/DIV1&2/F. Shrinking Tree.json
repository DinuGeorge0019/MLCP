{"link": "https://codeforces.com//contest/1060/problem/F", "problemId": "230451", "problem_idx": "F", "shortId": "1060F", "contest_number": "1060", "problem_submissions": {"H": [43777582, 43775787, 43778301, 43775359, 43805399, 43782088, 43777602, 44116240, 43850241, 43778906, 43778773], "F": [43769322, 43774726, 43772403, 43778102, 43769241, 43772326, 43773423, 43775493, 43777323, 43776810, 44345662, 43998198, 43776461, 43777805, 43885359, 43777579, 43776355, 43779796, 43779608, 43780204], "E": [43762417, 43764663, 43763746, 43764167, 43763212, 43766061, 43765524, 43768205, 43766236, 43763603, 43766034, 43766754, 43768368, 43766310, 43767829, 43764919, 43769766, 43765300, 43766971, 43767710], "B": [43761076, 43759115, 43759168, 43759290, 43758265, 43759025, 43759632, 43759678, 43759571, 43759528, 43758792, 43759203, 43760228, 43760411, 43761202, 43772055, 43761410, 43759136, 43761174, 43759666], "C": [43760028, 43761053, 43760979, 43760607, 43760834, 43761267, 43761559, 43762200, 43761558, 43761781, 43761097, 43763023, 43762854, 43762864, 43763097, 43761814, 43765269, 43760939, 43763385, 43762549], "D": [43758517, 43762752, 43762719, 43762340, 43759631, 43763257, 43762507, 43764164, 43763131, 43760435, 43762978, 43764580, 43764519, 43765425, 43764660, 43762881, 43766760, 43767791, 43764938, 43764650], "A": [43757554, 43758213, 43757544, 43758262, 43757552, 43757711, 43757958, 43758105, 43757983, 43757586, 43757752, 43757708, 43758583, 43757806, 43757592, 43757955, 43759122, 43757641, 43757856, 43757849], "G": [44020164, 44543288]}, "name": "F. Shrinking Tree", "statement": "Consider a tree T (that is, a connected graph without cycles) with n\r\nvertices labelled 1 through n. We start the following process with T:\r\nwhile T has more than one vertex, do the following: choose a random edge\r\nof T equiprobably; the chosen edge: if the edge was connecting vertices\r\nv and u, erase both v and u and create a new vertex adjacent to all\r\nvertices previously adjacent to either v or u. The new vertex is\r\nlabelled either v or u equiprobably.At the end of the process, T\r\nconsists of a single vertex labelled with one of the numbers 1,\r\nldots, n. For each of the numbers, what is the probability of this\r\nnumber becoming the label of the final vertex?\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 55;\n\nint N;\nvector <int> edge[MAXN];\n\nld pascal[MAXN][MAXN];\n\nld C (int x, int y)\n{\n    return pascal[x][y];\n}\n\nld eval (vector <ld> v)\n{\n    return v[(int) v.size() - 1];\n}\n\nvector <ld> append (vector <ld> v)\n{\n    vector <ld> res;\n    for (int i = 0; i <= v.size(); i++)\n        res.push_back(0.0);\n\n    int nsize = v.size();\n\n    for (int i = 0; i <= nsize; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            res[i] += v[j] / nsize / 2.;\n        }\n        if (i < nsize)\n            res[i] += v[i] * (nsize - i) / nsize;\n    }\n    return res;\n}\n\nvector <ld> combine (vector <ld> l, vector <ld> r)\n{\n    /*cout << \"combine\\n\";\n    for (int i = 0; i < l.size(); i++) cout << l[i] << \" \";\n    cout << \"\\n\";\n    for (int i = 0; i < r.size(); i++) cout << r[i] << \" \";\n    cout << \"\\n\";*/\n\n    vector <ld> res;\n    int ntot = l.size() + r.size() - 1;\n    for (int i = 0; i < ntot; i++)\n        res.push_back(0.0);\n\n    for (int i = 0; i < l.size(); i++)\n        for (int j = 0; j < r.size(); j++)\n        {\n            res[i+j] += l[i] * r[j] * C(i+j, i) * C(ntot - 1 - i - j, l.size() - i - 1) / C (ntot - 1, l.size() - 1);\n        }\n    //for (int i = 0; i < res.size(); i++) cout << res[i] << \" \";\n    //    cout << \"\\n\";\n    return res;\n}\n\nvector <ld> flood (int cloc, int last)\n{\n    vector <ld> v;\n    v.push_back(1.0);\n    for (int neigh : edge[cloc])\n    {\n        if (neigh == last) continue;\n        vector <ld> nv = flood (neigh, cloc);\n        nv = append (nv);\n        /*cout << \"neigh \" << neigh << \"\\n\";\n        for (int i = 0; i < nv.size(); i++) cout << nv[i] << \" \";\n        cout << \"\\n\";*/\n        v = combine (v, nv);\n    }\n    /*cout << \"cloc \" << cloc << \"\\n\";\n    for (int i = 0; i < v.size(); i++) cout << v[i] << \" \";\n    cout << \"\\n\";*/\n    return v;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    pascal[0][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = 0; j < MAXN; j++)\n        {\n            pascal[i][j] = pascal[i-1][j];\n            if (j) pascal[i][j] += pascal[i-1][j-1];\n        }\n\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    cout << fixed << setprecision(8);\n    for (int i = 0; i < N; i++)\n    {\n        vector <ld> v = flood (i, -1);\n        cout << eval (v) << \"\\n\";\n    }\n\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2900", "interactive": false}