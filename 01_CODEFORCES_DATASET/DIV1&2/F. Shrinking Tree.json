{
    "link": "https://codeforces.com//contest/1060/problem/F",
    "problemId": "230451",
    "problem_idx": "F",
    "shortId": "1060F",
    "contest_number": "1060",
    "problem_submissions": {
        "H": [
            43777582,
            43775787,
            43778301,
            43775359,
            43805399,
            43782088,
            43777602,
            44116240,
            43850241,
            43778906,
            43778773
        ],
        "F": [
            43769322,
            43774726,
            43772403,
            43778102,
            43769241,
            43772326,
            43773423,
            43775493,
            43777323,
            43776810,
            44345662,
            43998198,
            43776461,
            43777805,
            43885359,
            43777579,
            43776355,
            43779796,
            43779608,
            43780204
        ],
        "E": [
            43762417,
            43764663,
            43763746,
            43764167,
            43763212,
            43766061,
            43765524,
            43768205,
            43766236,
            43763603,
            43766034,
            43766754,
            43768368,
            43766310,
            43767829,
            43764919,
            43769766,
            43765300,
            43766971,
            43767710
        ],
        "B": [
            43761076,
            43759115,
            43759168,
            43759290,
            43758265,
            43759025,
            43759632,
            43759678,
            43759571,
            43759528,
            43758792,
            43759203,
            43760228,
            43760411,
            43761202,
            43772055,
            43761410,
            43759136,
            43761174,
            43759666
        ],
        "C": [
            43760028,
            43761053,
            43760979,
            43760607,
            43760834,
            43761267,
            43761559,
            43762200,
            43761558,
            43761781,
            43761097,
            43763023,
            43762854,
            43762864,
            43763097,
            43761814,
            43765269,
            43760939,
            43763385,
            43762549
        ],
        "D": [
            43758517,
            43762752,
            43762719,
            43762340,
            43759631,
            43763257,
            43762507,
            43764164,
            43763131,
            43760435,
            43762978,
            43764580,
            43764519,
            43765425,
            43764660,
            43762881,
            43766760,
            43767791,
            43764938,
            43764650
        ],
        "A": [
            43757554,
            43758213,
            43757544,
            43758262,
            43757552,
            43757711,
            43757958,
            43758105,
            43757983,
            43757586,
            43757752,
            43757708,
            43758583,
            43757806,
            43757592,
            43757955,
            43759122,
            43757641,
            43757856,
            43757849
        ],
        "G": [
            44020164,
            44543288
        ]
    },
    "name": "F. Shrinking Tree",
    "statement": "Consider a tree T (that is, a connected graph without cycles) with n\r\nvertices labelled 1 through n. We start the following process with T:\r\nwhile T has more than one vertex, do the following: choose a random edge\r\nof T equiprobably; the chosen edge: if the edge was connecting vertices\r\nv and u, erase both v and u and create a new vertex adjacent to all\r\nvertices previously adjacent to either v or u. The new vertex is\r\nlabelled either v or u equiprobably.At the end of the process, T\r\nconsists of a single vertex labelled with one of the numbers 1,\r\nldots, n. For each of the numbers, what is the probability of this\r\nnumber becoming the label of the final vertex?\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 55;\n\nint N;\nvector <int> edge[MAXN];\n\nld pascal[MAXN][MAXN];\n\nld C (int x, int y)\n{\n    return pascal[x][y];\n}\n\nld eval (vector <ld> v)\n{\n    return v[(int) v.size() - 1];\n}\n\nvector <ld> append (vector <ld> v)\n{\n    vector <ld> res;\n    for (int i = 0; i <= v.size(); i++)\n        res.push_back(0.0);\n\n    int nsize = v.size();\n\n    for (int i = 0; i <= nsize; i++)\n    {\n        for (int j = 0; j < i; j++)\n        {\n            res[i] += v[j] / nsize / 2.;\n        }\n        if (i < nsize)\n            res[i] += v[i] * (nsize - i) / nsize;\n    }\n    return res;\n}\n\nvector <ld> combine (vector <ld> l, vector <ld> r)\n{\n    /*cout << \"combine\\n\";\n    for (int i = 0; i < l.size(); i++) cout << l[i] << \" \";\n    cout << \"\\n\";\n    for (int i = 0; i < r.size(); i++) cout << r[i] << \" \";\n    cout << \"\\n\";*/\n\n    vector <ld> res;\n    int ntot = l.size() + r.size() - 1;\n    for (int i = 0; i < ntot; i++)\n        res.push_back(0.0);\n\n    for (int i = 0; i < l.size(); i++)\n        for (int j = 0; j < r.size(); j++)\n        {\n            res[i+j] += l[i] * r[j] * C(i+j, i) * C(ntot - 1 - i - j, l.size() - i - 1) / C (ntot - 1, l.size() - 1);\n        }\n    //for (int i = 0; i < res.size(); i++) cout << res[i] << \" \";\n    //    cout << \"\\n\";\n    return res;\n}\n\nvector <ld> flood (int cloc, int last)\n{\n    vector <ld> v;\n    v.push_back(1.0);\n    for (int neigh : edge[cloc])\n    {\n        if (neigh == last) continue;\n        vector <ld> nv = flood (neigh, cloc);\n        nv = append (nv);\n        /*cout << \"neigh \" << neigh << \"\\n\";\n        for (int i = 0; i < nv.size(); i++) cout << nv[i] << \" \";\n        cout << \"\\n\";*/\n        v = combine (v, nv);\n    }\n    /*cout << \"cloc \" << cloc << \"\\n\";\n    for (int i = 0; i < v.size(); i++) cout << v[i] << \" \";\n    cout << \"\\n\";*/\n    return v;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    pascal[0][0] = 1;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = 0; j < MAXN; j++)\n        {\n            pascal[i][j] = pascal[i-1][j];\n            if (j) pascal[i][j] += pascal[i-1][j-1];\n        }\n\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    cout << fixed << setprecision(8);\n    for (int i = 0; i < N; i++)\n    {\n        vector <ld> v = flood (i, -1);\n        cout << eval (v) << \"\\n\";\n    }\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Shrinking Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/113725",
    "editorial": "Read the previous spoiler if not done already for the basic intuition behind the solution.\n\nLet \n?\n? and \n?\n? be two permutations. Applying the mapping \nx\n?\nx\n+\n?\n?\n?\nx?x+??? to the array \n?\n? and shuffling the elements of \n?\n? and \n?\n? together, while keeping their internal order the same will generate another permutation with size \n?\n?\n?\n+\n?\n?\n?\n???+???. We shall call this operation interleaving. Note that when \n?\n? and \n?\n? vary over all permutations, and the interleavings are taken over all possible \n(\n?\n?\n?\n+\n?\n?\n?\n?\n?\n?\n)\n( \n???\n???+???\n?\n ) interleavings, this generates all possible permutations of size \n?\n?\n?\n+\n?\n?\n?\n???+???. We can generalize this to adding an extra bit of information with every element of \n?\n? and \n?\n?, and an analogous result holds true for this setup too.\n\nWe will look at the choices as interleavings of the choices for each of the childrens subtrees (with an extra edge added on top for each subtree). The operation corresponding to adding an extra edge corresponds to interleaving the permutation \n{\n1\n}\n{1} with the permutation for the subtree (and there is precisely one choice that must be taken whenever we consider the extra edge). Well call this edge the hanging edge for that subtree.\n\nNow at any stage of the interleaving, note how the structure of the tree looks like. It might be helpful to consider the shrinking operations in the following way: initially all edges are represented with dotted lines (implying that theyre just a template for connecting edges, and dont connect the edges at this stage), and every vertex is its own representative, and every shrinkage converts a dotted line into a solid line, and sets the representative of the sets of vertices connected by this edge to one of the representatives randomly. Basically how DSU works.\n\nIn this interpretation, consider the component containing the root. The choices made for the children subtrees that have only one correct choice (for the root to survive) correspond to the choices that end up in the roots component. Lets un-interleave these choices. Then this problem reduces to the same problem but for the child subtrees. Also, note that when interleaving these subtrees and counting the number of choices that allow the root to survive, only the number of choices made (before choosing the hanging edge) for each subtree matter. Also, note that we can do these interleavings associatively (that is, first the first subtree, then the second with the result of the first subtree, then the third with the result of the first and second subtrees and so on), and the computation remains the same.\n\nSo the merges will go as follows: for a vertex, we will compute the answers for its children, and for each child, extend the set of choices by the extra choice that needs to be made for adding a hanging edge (by interleaving with the single choice), and then interleave these choices again.\n\nUsing these ideas, we can do a DP with the following state: dp[u][k] is the number of choices for the subtree of a vertex \nu\nu when \nk\nk decisions are done before we choose the hanging edge. For the transitions, you can refer to the submission.",
    "hint": []
}