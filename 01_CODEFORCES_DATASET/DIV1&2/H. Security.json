{"link": "https://codeforces.com//contest/1037/problem/H", "problemId": "214577", "problem_idx": "H", "shortId": "1037H", "contest_number": "1037", "problem_submissions": {"G": [42400284, 42399505, 42393700, 42391956, 42395688, 49109531, 42416815, 42416802, 42408231, 42478375, 42723385, 42723256], "H": [42390789, 42393047, 42400959, 42399660, 42398441, 42399087, 42414998, 42453023, 42876495, 42876025, 42875988, 42875931], "E": [42383633, 42376516, 42374024, 42375460, 42374374, 42376325, 42382856, 42374364, 42376990, 42377973, 42378251, 42378271, 42378643, 42380819, 42380647, 42383308, 42382412, 42381355], "F": [42381395, 42382506, 42383872, 42380708, 42386216, 42379786, 42391156, 42378290, 42387714, 42379959, 42384150, 42386649, 42388704, 42386435, 42387614, 42390065, 42389970, 42390483], "D": [42369087, 42370798, 42380041, 42371136, 42379827, 42374961, 42370290, 42370315, 42380263, 42370259, 42374008, 42373176, 42374905, 42371349, 42379998, 42373150, 42374030], "C": [42367060, 42368485, 42368461, 42367940, 42368563, 42368341, 42378567, 42367842, 42367459, 42369272, 42375102, 42369783, 42370363, 42370761, 42367752, 42376902, 42370198, 42370636], "B": [42366092, 42367373, 42367083, 42366507, 42366793, 42366735, 42367983, 42366366, 42366278, 42367057, 42372146, 42367428, 42368851, 42367360, 42366696, 42366630, 42368278, 42367696], "A": [42365839, 42365922, 42366199, 42365850, 42365879, 42366070, 42366134, 42365823, 42365810, 42366029, 42366879, 43951943, 42366275, 42367664, 42365933, 42365869, 42365891, 42366540, 42366060]}, "name": "H. Security", "statement": "Some programming website is establishing a secure communication\r\nprotocol. For security reasons, they want to choose several more or less\r\nrandom strings.Initially, they have a string s consisting of lowercase\r\nEnglish letters. Now they want to choose q strings using the following\r\nsteps, and you are to help them. A string x consisting of lowercase\r\nEnglish letters and integers l and r (1\r\nleq l\r\nleq r\r\nleq |s|) are chosen. Consider all non-empty distinct substrings of the\r\ns_l s_{l + 1}\r\nldots s_r, that is all distinct strings s_i s_{i+1}\r\nldots s_{j} where l\r\nle i\r\nle j\r\nle r. Among all of them choose all strings that are lexicographically\r\ngreater than x. If there are no such strings, you should print -1.\r\nOtherwise print the lexicographically smallest among them. String a is\r\nlexicographically less than string b, if either a is a prefix of b and a\r\nne b, or there exists such a position i (1\r\nle i\r\nle min(|a|, |b|)), such that a_i < b_i and for all j (1\r\nle j < i) a_j = b_j. Here |a| denotes the length of the string a.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 02.09.2018 18:26:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1000010;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// http://e-maxx.ru/algo/ukkonen\n\nstring s;\nint n;\n \nstruct node {\n\tint l, r, par, link;\n\tmap<char,int> next;\n \n\tnode (int l=0, int r=0, int par=-1)\n\t\t: l(l), r(r), par(par), link(-1) {}\n\tint len()  {  return r - l;  }\n\tint &get (char c) {\n\t\tif (!next.count(c))  next[c] = -1;\n\t\treturn next[c];\n\t}\n};\nnode t[MAXN];\nint sz;\n \nstruct state {\n\tint v, pos;\n\tstate (int v, int pos) : v(v), pos(pos)  {}\n};\nstate ptr (0, 0);\n \nstate go (state st, int l, int r) {\n\twhile (l < r)\n\t\tif (st.pos == t[st.v].len()) {\n\t\t\tst = state (t[st.v].get( s[l] ), 0);\n\t\t\tif (st.v == -1)  return st;\n\t\t}\n\t\telse {\n\t\t\tif (s[ t[st.v].l + st.pos ] != s[l])\n\t\t\t\treturn state (-1, -1);\n\t\t\tif (r-l < t[st.v].len() - st.pos)\n\t\t\t\treturn state (st.v, st.pos + r-l);\n\t\t\tl += t[st.v].len() - st.pos;\n\t\t\tst.pos = t[st.v].len();\n\t\t}\n\treturn st;\n}\n \nint split (state st) {\n\tif (st.pos == t[st.v].len())\n\t\treturn st.v;\n\tif (st.pos == 0)\n\t\treturn t[st.v].par;\n\tnode v = t[st.v];\n\tint id = sz++;\n\tt[id] = node (v.l, v.l+st.pos, v.par);\n\tt[v.par].get( s[v.l] ) = id;\n\tt[id].get( s[v.l+st.pos] ) = st.v;\n\tt[st.v].par = id;\n\tt[st.v].l += st.pos;\n\treturn id;\n}\n \nint get_link (int v) {\n\tif (t[v].link != -1)  return t[v].link;\n\tif (t[v].par == -1)  return 0;\n\tint to = get_link (t[v].par);\n\treturn t[v].link = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));\n}\n \nvoid tree_extend (int pos) {\n\tfor(;;) {\n\t\tstate nptr = go (ptr, pos, pos+1);\n\t\tif (nptr.v != -1) {\n\t\t\tptr = nptr;\n\t\t\treturn;\n\t\t}\n \n\t\tint mid = split (ptr);\n\t\tint leaf = sz++;\n\t\tt[leaf] = node (pos, n, mid);\n\t\tt[mid].get( s[pos] ) = leaf;\n \n\t\tptr.v = get_link (mid);\n\t\tptr.pos = t[ptr.v].len();\n\t\tif (!mid)  break;\n\t}\n}\n \nvoid build_tree() {\n\tsz = 1;\n\tfor (int i=0; i<n; ++i)\n\t\ttree_extend (i);\n}\n\nstruct stateX {\n  int v;\n  int l;\n  int r;\n\n  stateX() {\n    v = 0;\n    l = r = 0;\n  }\n\n  void go(char c) {\n    if (l == r) {\n      if (t[v].next.find(c) == t[v].next.end()) {\n        v = -1;\n      } else {\n        v = t[v].next[c];\n        l = t[v].l + 1;\n        r = t[v].r;\n      }\n    } else {\n      if (s[l] != c) {\n        v = -1;\n      } else {\n        l++;\n      }\n    }\n  }\n};\n\nstruct query {\n  int from;\n  int to;\n  int id;\n  int pos;\n  char ch;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> s;\n  s = s + \"$\";\n  n = (int) s.size();\n  build_tree();\n  int m;\n  cin >> m;\n  vector<string> xs(m);\n  vector<int> change_pos(m, -1);\n  vector<char> change_char(m, '.');\n  auto update = [&](int id, int pos, char ch) {\n    if (pos > change_pos[id] || (pos == change_pos[id] && ch < change_char[id])) {\n      change_pos[id] = pos;\n      change_char[id] = ch;\n    }\n  };\n  vector<vector<query>> qs(sz);\n  for (int i = 0; i < m; i++) {\n    int from, to;\n    cin >> from >> to >> xs[i];\n    from--; to--;\n    int len = to - from + 1;\n    stateX st;\n    for (int j = 0; j <= (int) xs[i].size(); j++) {\n      if (j + 1 > len) {\n        break;\n      }\n      char start = (j < (int) xs[i].size() ? (char) (xs[i][j] + 1) : 'a');\n      for (char c = start; c <= 'z'; c++) {\n        stateX st2 = st;\n        st2.go(c);\n        if (st2.v == -1) {\n          continue;\n        }\n        qs[st2.v].push_back({from, to - j, i, j, c});\n      }\n      if (j == (int) xs[i].size()) {\n        break;\n      }\n      st.go(xs[i][j]);\n      if (st.v == -1) {\n        break;\n      }\n    }\n  }\n  vector<set<int>> leafs(sz);\n  vector<int> depth(sz, 0);\n  function<void(int)> dfs = [&](int v) {\n    if (t[v].next.empty()) {\n      leafs[v].insert(n - depth[v]);\n    }\n    for (auto &p : t[v].next) {\n      int u = p.second;\n      depth[u] = depth[v] + (t[u].r - t[u].l);\n      dfs(u);\n      if (leafs[u].size() > leafs[v].size()) {\n        swap(leafs[u], leafs[v]);\n      }\n      for (int x : leafs[u]) {\n        leafs[v].insert(x);\n      }\n      set<int>().swap(leafs[u]);\n    }\n    for (auto &q : qs[v]) {\n      auto it = leafs[v].lower_bound(q.from);\n      if (it != leafs[v].end() && *it <= q.to) {\n        update(q.id, q.pos, q.ch);\n      }\n    }\n  };\n  dfs(0);\n  for (int i = 0; i < m; i++) {\n    if (change_pos[i] == -1) {\n      cout << -1 << '\\n';\n    } else {\n      cout << xs[i].substr(0, change_pos[i]) << change_char[i] << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "string suffix structures"], "dificulty": "3200", "interactive": false}