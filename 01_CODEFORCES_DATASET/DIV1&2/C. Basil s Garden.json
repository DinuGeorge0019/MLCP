{
    "link": "https://codeforces.com//contest/1987/problem/C",
    "problemId": "2726562",
    "problem_idx": "C",
    "shortId": "1987C",
    "contest_number": "1987",
    "problem_submissions": {
        "E": [
            268229906,
            268158602,
            268423905,
            268422817,
            268157857,
            268152628,
            268233241,
            268233207,
            268156681,
            268158666,
            268162964,
            268158456,
            268163362,
            268156782,
            268165522,
            268170420,
            268158686,
            268162341,
            268233753,
            268228306,
            268160955,
            268160065,
            268161194,
            268164320,
            268163376,
            268166928,
            268264962,
            268164535
        ],
        "H": [
            268205560,
            268243575,
            268242763,
            268242753,
            268226875,
            268226200,
            286117872,
            286117361,
            268621342,
            270559507
        ],
        "G2": [
            268199327,
            268183184,
            268209905,
            268197988,
            268210865,
            268209119,
            268201265,
            268217291,
            268203603,
            268206936,
            268211532,
            268216966,
            268392569
        ],
        "G1": [
            268197008,
            268183589,
            268183559,
            268192970,
            268191020,
            268190335,
            268201091,
            268194194,
            268192954,
            268200485,
            268201459,
            268210583,
            268191184,
            268204488,
            268195197,
            268205593,
            268203056,
            268392539,
            268196879,
            268201576,
            268201255
        ],
        "F2": [
            268174418,
            268166457,
            268162505,
            268182920,
            268168846,
            268174436,
            268185759,
            268178301,
            268181565,
            268191599,
            268193415,
            268177500,
            268170902,
            268180818,
            268174520,
            268182719,
            268178817,
            268190336,
            268190071
        ],
        "F1": [
            268173831,
            268166694,
            268162641,
            268178377,
            268169399,
            268174193,
            268185332,
            268177979,
            268170897,
            268181978,
            268191481,
            268193293,
            268177600,
            268169616,
            268180668,
            268173797,
            268182414,
            268176479,
            268181249,
            268189979
        ],
        "D": [
            268149772,
            268151878,
            268147683,
            268147422,
            268149471,
            268152924,
            268151963,
            268155962,
            268148798,
            268153037,
            268153285,
            268152472,
            268152498,
            268151784,
            268149550,
            268150424,
            268156633,
            268151156,
            268159183,
            268155639
        ],
        "C": [
            268144323,
            268147501,
            268383290,
            268143974,
            268142997,
            268142336,
            268156117,
            268145345,
            268149662,
            268144034,
            268146014,
            268146306,
            268146500,
            268154494,
            268145000,
            268144648,
            268146061,
            268146320,
            268145299,
            268148183,
            268146033
        ],
        "B": [
            268142097,
            268138793,
            268136942,
            268137419,
            268137014,
            268140558,
            268141012,
            268143732,
            268140016,
            268142374,
            268143256,
            268141729,
            268142582,
            268139760,
            268140776,
            268140696,
            268140576,
            268139314,
            268141992,
            268141951
        ],
        "A": [
            268135899,
            268135441,
            268135342,
            268135356,
            268135339,
            268135852,
            268135895,
            268139203,
            268135363,
            268137561,
            268136567,
            268135744,
            268136590,
            268135768,
            268135350,
            268135764,
            268135555,
            268135575,
            268136024,
            268138028
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131053",
    "editorial": "First, letâs try to find when will first be equal to zero. The answer is\r\nclearly .Suppose for some we know that will first become equal to zero\r\nat time (). If at some point in time, was equal to (at the start of the\r\nsecond and before they are both equal to zero), is equal to . Since\r\nafter that point in time, if decreases, must decrease in the next\r\nsecond. If is never equal to (until they hit zero), must always be\r\nstrictly greater than . This means that will keep decreasing every\r\nsecond until it hits zero, so is equal to in this case.Examples: The\r\narray changes as follows: . If we focus on the first two elements, they\r\nchange as follows: . The array changes as follows: . Letâs combine the\r\ntwo cases. If initially holds, will become equal to at some point in\r\ntime, so . Else, , so . Combining the two, we get .Since we know , we\r\ncan easily calculate all the other values of by iterating from to . The\r\nanswer to the problem is , since for all .Complexity:\r\n",
    "name": "C. Basil s Garden",
    "statement": "There are n flowers in a row, the i-th of them initially has a positive\r\nheight of h_i meters.Every second, the wind will blow from the left,\r\ncausing the height of some flowers to decrease.Specifically, every\r\nsecond, for each i from 1 to n, in this order, the following happens: If\r\ni = n or h_i > h_{i + 1}, the value of h_i changes to\r\nmax(0, h_i - 1). How many seconds will pass before h_i=0 for all 1\r\nle i\r\nle n for the first time?\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, \"/stack:200000000\")#pragma GCC optimize(\"O3\")//~ #pragma GCC target (\"avx2\")//~ #pragma GCC optimize(\"Ofast\")//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")//~ #pragma GCC optimize(\"unroll-loops\")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds;using namespace std; template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; #define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << \"(\" << d.first << \", \" << d.second << \")\";}sim dor(rge<c> d) {  *this << \"[\";  for (auto it = d.b; it != d.e; ++it)    *this << \", \" + 2 * (it == d.b) << *it;  ris << \"]\";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \" #define shandom_ruffle random_shuffle using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=1000*1007; int n;ll tab[nax]; void test(){\tscanf(\"%d\", &n);\tfor (int i=1; i<=n; i++)\t\tscanf(\"%lld\", &tab[i]);\tll wyn=0;\tfor (int i=1; i<=n; i++)\t\twyn=max(wyn, tab[i]+i-1);\tprintf(\"%lld\\n\", wyn);} int main(){\tint t;\tscanf(\"%d\", &t);\twhile(t--)\t\ttest();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Basil s Garden.json",
    "hint": [
        "Hint 1 When will first become equal to zero?",
        "Hint 2 When will first become equal to zero?",
        "Hint 3 Consider solving from right to left.",
        "Hint 4 Suppose you want to find when will fist be equal to zero. Try splitting into the cases at some point (before both are zero) and when that is not true."
    ]
}