{
    "link": "https://codeforces.com//contest/1994/problem/G",
    "problemId": "2760787",
    "problem_idx": "G",
    "shortId": "1994G",
    "contest_number": "1994",
    "problem_submissions": {
        "H": [
            271268810,
            271261236,
            271268610,
            271257398,
            271256333,
            271267520,
            271313433,
            271274176,
            271248306,
            271287210,
            271283377,
            271283359,
            271282520
        ],
        "G": [
            271229872,
            271233816,
            271238208,
            271227356,
            271235437,
            271226550,
            271234367,
            271234742,
            271238779,
            271238270,
            271225091,
            271234935,
            271238841,
            271240257,
            271243721,
            271243649,
            271233908,
            271244521,
            271244063
        ],
        "F": [
            271214789,
            271228871,
            271233459,
            271220149,
            271228791,
            271236762,
            271228615,
            271226473,
            271231018,
            271229788,
            271213472,
            271228121,
            271232218,
            271232892,
            271232972,
            271231186,
            271267486,
            271243051,
            271234735,
            271231874
        ],
        "E": [
            271208462,
            271218792,
            271225076,
            271214384,
            271214472,
            271215377,
            271220481,
            271220501,
            271217729,
            271220075,
            271230923,
            271220200,
            271221333,
            271221570,
            271219993,
            271222653,
            271267440,
            271226341,
            271222083,
            271220365
        ],
        "D": [
            271202405,
            271212139,
            271218875,
            271208005,
            271207650,
            271208685,
            271211312,
            271203391,
            271211524,
            271212286,
            271234069,
            271211646,
            271213596,
            271214194,
            271209598,
            271213200,
            271211604,
            271209945,
            271214556
        ],
        "C": [
            271199233,
            271206203,
            271213680,
            271202592,
            271203860,
            271204743,
            271205070,
            271213462,
            271205158,
            271207577,
            271204749,
            271209599,
            271203078,
            271203590,
            271209662,
            271268293,
            271268187,
            271204900,
            271203748,
            271208451
        ],
        "B": [
            271196298,
            271197883,
            271199651,
            271199362,
            271196300,
            271198662,
            271198429,
            271197282,
            271197595,
            271196709,
            271198001,
            271201728,
            271198447,
            271198638,
            271200600,
            271198424,
            271197818,
            271196402
        ],
        "A": [
            271195365,
            271195316,
            271196075,
            271196307,
            271195291,
            271195470,
            271195498,
            271195546,
            271195401,
            271195293,
            271195685,
            271195898,
            271195396,
            271195975,
            271195344,
            271195348,
            271195380,
            271195303
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131666",
    "editorial": "We will do recursion. Let\u00e2\u0080\u0099s go from the lower bits to the significant\r\nbits. means that the first bits are selected, the sum of them divided by\r\nequals , and the first bits match the ones we need. Let the number of\r\nones in the numbers in the -th bit. Then we can go from state to and if\r\nthe lowest bit matches the -th bit in . There are at most states in such\r\na recursion (proof below). Thus, if we do the memoization, the solution\r\nwill run .Proof: is always at most . At the beginning of the recursion,\r\n, so the inequality is satisfied. When we go to the next step , , which\r\nwas required to prove.\r\n",
    "name": "G. Minecraft",
    "statement": "After winning another Bed Wars game, Masha and Olya wanted to relax and\r\ndecided to play a new game. Masha gives Olya an array a of length n and\r\na number s. Now Olya\u2019s task is to find a non-negative number x such that\r\ndisplaystyle\r\nsum_{i=1}^{n} a_i\r\noplus x = s. But she is very tired after a tight round, so please help\r\nher with this.But this task seemed too simple to them, so they decided\r\nto make the numbers larger (up to 2^k) and provide you with their binary\r\nrepresentation.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 19.07.2024 00:04:09**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, k;    cin >> n >> k;    string goal_s;    cin >> goal_s;    vector<string> s(n);    for (int i = 0; i < n; i++) {      cin >> s[i];    }    reverse(goal_s.begin(), goal_s.end());    vector<int> goal(k);    for (int i = 0; i < k; i++) {      goal[i] = int(goal_s[i] - '0');    }    vector<int> sum(k);    for (int i = 0; i < n; i++) {      reverse(s[i].begin(), s[i].end());      for (int j = 0; j < k; j++) {        sum[j] += (s[i][j] == '1');      }    }    vector<vector<bool>> dp(k + 1, vector<bool>(n, false));    vector<vector<int>> pr(k + 1, vector<int>(n, -1));    dp[0][0] = true;    for (int i = 0; i < k; i++) {      for (int j = 0; j < n; j++) {        if (dp[i][j]) {          for (int bit = 0; bit < 2; bit++) {            int val = j + (bit == 0 ? sum[i] : n - sum[i]);            if ((val & 1) == goal[i]) {              int new_val = val >> 1;              dp[i + 1][new_val] = true;              pr[i + 1][new_val] = (j << 1) + bit;            }          }        }      }    }    if (!dp[k][0]) {      cout << -1 << '\\n';      continue;    }    string res(k, '0');    int j = 0;    for (int i = k; i > 0; i--) {      auto p = pr[i][j];      int bit = p & 1;      if (bit) {        res[i - 1] = '1';      }      j = p >> 1;    }    reverse(res.begin(), res.end());    cout << res << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "graphs",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Minecraft.json"
}