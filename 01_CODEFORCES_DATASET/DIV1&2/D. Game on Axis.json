{
    "link": "https://codeforces.com//contest/1787/problem/D",
    "problemId": "1756747",
    "problem_idx": "D",
    "shortId": "1787D",
    "contest_number": "1787",
    "problem_submissions": {
        "I": [
            197474547,
            191162667,
            191147076,
            191159474,
            191182912,
            191180384,
            191173195,
            191158380,
            191159985,
            191279548,
            191153893,
            191147979,
            191219667,
            191170332
        ],
        "G": [
            191152988,
            191152586,
            191141714,
            191145745,
            191143792,
            191147352,
            191147519,
            191158898,
            191159891,
            191160943,
            191153438,
            191155040,
            191144883,
            191170407,
            191170114,
            191152547
        ],
        "F": [
            191146155,
            191132842,
            191134802,
            191136901,
            191128020,
            191139771,
            191139131,
            191147114,
            191152778,
            191144574,
            191147232,
            191145790,
            191135060,
            191146379,
            191144901,
            191136231,
            191134824,
            191143478,
            191143747,
            191145614
        ],
        "E": [
            191137894,
            191126319,
            191169100,
            191131011,
            191146734,
            191132024,
            191134009,
            191128652,
            191130752,
            191135324,
            191128162,
            191137413,
            191115850,
            191140133,
            191140025,
            191121022,
            191131209,
            191138279,
            191133339,
            191131279
        ],
        "D": [
            191132976,
            191120161,
            191124203,
            191123443,
            191137713,
            191128946,
            191128273,
            191122289,
            191126977,
            191131112,
            191124722,
            191125562,
            191128102,
            191135389,
            191135592,
            191131056,
            191123065,
            191127620,
            191126290,
            191127861
        ],
        "C": [
            191125268,
            191113889,
            191117948,
            191115059,
            191116269,
            191118107,
            191120001,
            191140669,
            191115010,
            191125411,
            191117705,
            191118998,
            191121343,
            191121072,
            191117056,
            191128472,
            191115952,
            191117237,
            191118951,
            191120349
        ],
        "B": [
            191121944,
            191109607,
            191111770,
            191108995,
            191110155,
            191109908,
            191113645,
            191109634,
            191109874,
            191121868,
            191110598,
            191110575,
            191117560,
            191109576,
            191110819,
            191112301,
            191110138,
            191111938,
            191108264,
            191111930
        ],
        "A": [
            191118000,
            191106352,
            191108603,
            191106770,
            191106814,
            191106284,
            191107425,
            191105859,
            191106157,
            191118169,
            191107747,
            191106297,
            191105730,
            191106101,
            191107070,
            191108687,
            191105956,
            191107701,
            191105869,
            191106761
        ],
        "H": [
            191116884,
            191151161,
            191155682,
            191157247,
            191138915,
            191146913,
            191162451,
            191161022,
            191128443,
            191126961,
            191251422,
            191150263,
            191149572,
            191156328
        ]
    },
    "name": "D. Game on Axis",
    "statement": "There are n points 1,2,\r\nldots,n, each point i has a number a_i on it. You\u2019re playing a game on\r\nthem. Initially, you are at point 1. When you are at point i, take\r\nfollowing steps: If 1\r\nle i\r\nle n, go to i+a_i, Otherwise, the game ends. Before the game begins, you\r\ncan choose two integers x and y satisfying 1\r\nle x\r\nle n, -n\r\nle y\r\nle n and replace a_x with y (set a_x := y). Find the number of distinct\r\npairs (x,y) such that the game that you start after making the change\r\nends in a finite number of steps.Notice that you do not have to satisfy\r\na_x\r\nnot=y.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nconst int MAXN = 200005;\n\nstruct disj {\n\tint pa[MAXN], sz[MAXN], cyc[MAXN];\n\tvoid init(int n) {\n\t\tiota(pa, pa + n + 1, 0);\n\t\tfill(sz, sz + n + 1, 1);\n\t\tfill(cyc, cyc + n + 1, 0);\n\t}\n\tint find(int x) { return pa[x] = (pa[x] == x ? x : find(pa[x])); }\n\tbool uni(int p, int q) {\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif (p == q) {\n\t\t\tcyc[p] = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tpa[q] = p;\n\t\tsz[p] += sz[q];\n\t\tcyc[p] |= cyc[q];\n\t\treturn 1;\n\t}\n\tbool iscyc(int v) { return cyc[v]; }\n} disj;\nint dp[MAXN];\nvector<int> gph[MAXN];\n\nint f(int x) {\n\tif (~dp[x])\n\t\treturn dp[x];\n\tint ret = 1;\n\tfor (auto &y : gph[x])\n\t\tret += f(y);\n\treturn dp[x] = ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t;\n\tcin >> t;\n\tmemset(dp, -1, sizeof(dp));\n\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tlint wrong = 0;\n\t\tdisj.init(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i + a[i] < n && i + a[i] >= 0) {\n\t\t\t\tdisj.uni(i, i + a[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (disj.find(i) == i && disj.iscyc(i))\n\t\t\t\twrong += disj.sz[i];\n\t\t}\n\t\tvector<int> vis(n);\n\t\tint curpath = 0;\n\t\tfor (int i = 0;; i += a[i]) {\n\t\t\tif (i < 0 || i >= n) {\n\t\t\t\tlint ans = 1ll * n * (2 * n + 1) - 1ll * curpath * wrong;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i + a[i] < n && i + a[i] >= 0) {\n\t\t\t\t\t\tgph[i + a[i]].push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j >= 0 && j < n; j += a[j]) {\n\t\t\t\t\tans -= f(j);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\t\tdp[i] = -1;\n\t\t\t\t\tgph[i].clear();\n\t\t\t\t}\n\t\t\t\tcout << ans << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t} else if (vis[i]) {\n\t\t\t\tcout << 1ll * curpath * (2 * n + 1 - wrong) << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[i] = 1;\n\t\t\tcurpath++;\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Game on Axis.json",
    "editorial_link": "https://codeforces.com//blog/entry/112009",
    "editorial": "First, add directed edges from to . If there\u00e2\u0080\u0099s a path from to satisfying\r\nor , the game end. We consider all nodes satisfying or to be the end\r\nnode, and we call the path which starts at node until it loops or ends\r\nthe key path.If we can end the game at first:Let\u00e2\u0080\u0099s count the opposite:\r\nthe number of invalid pairs. The graph with the end node forms a tree.\r\nChanging edges not on the key path is always legal. If changing the\r\nedges on the key path, for node , we can only change its successor to\r\nother connected components, its precursor or itself on the tree with the\r\nend node.For the answer, use dfs to count the number of precursors for\r\nevery nodes on this tree, which is the size of subtree.If we cannot end\r\nthe game at first:We can only change the edge on the key path, redirect\r\nthem to any nodes on the tree with the end node.\r\n"
}