{
    "link": "https://codeforces.com//contest/2061/problem/F1",
    "problemId": "3155959",
    "problem_idx": "F1",
    "shortId": "2061F1",
    "contest_number": "2061",
    "problem_submissions": {
        "F2": [
            302127475,
            302092403,
            302114656,
            302114350,
            302118052,
            302128136,
            302099327,
            302127501,
            302105569,
            302158287,
            302158231,
            302158981,
            302158740,
            302158593,
            302155955
        ],
        "H1": [
            302102508,
            302123846,
            302123275,
            302120307,
            302128240,
            302113263,
            302214973,
            302214838,
            302492170,
            302128311,
            302150853
        ],
        "G": [
            302087277,
            302104836,
            302092310,
            302101290,
            302098614,
            302099751,
            302090244,
            302079497,
            302107342,
            302102846,
            302118471,
            302119832,
            302088828,
            302085801,
            302097252,
            302107147,
            302100360,
            302104471
        ],
        "F1": [
            302070705,
            302068249,
            302076903,
            302139304,
            302085853,
            302085964,
            302087951,
            302076823,
            302099111,
            302088499,
            302088697,
            302106078,
            302076066,
            302095307,
            302083979,
            302077009,
            302082649,
            302158914,
            302081283
        ],
        "E": [
            302060766,
            302059898,
            302064375,
            302146780,
            302146561,
            302146204,
            302145996,
            302145832,
            302145821,
            302145812,
            302060519,
            302071650,
            302062756,
            302067337,
            302066558,
            302071373,
            302078018,
            302075359,
            302069841,
            302067118,
            302063628,
            302073608,
            302071649,
            302075889,
            302072748
        ],
        "D": [
            302057147,
            302056206,
            302056876,
            302056600,
            302064486,
            302056648,
            302061458,
            302060302,
            302063595,
            302065433,
            302068805,
            302064352,
            302061742,
            302059104,
            302069059,
            302065232,
            302069194,
            302062940
        ],
        "C": [
            302053893,
            302052972,
            302060290,
            302053477,
            302058781,
            302053556,
            302058513,
            302056661,
            302060439,
            302057971,
            302066087,
            302059912,
            302059144,
            302055184,
            302066070,
            302060621,
            302062953,
            302059461
        ],
        "B": [
            302048946,
            302050832,
            302052328,
            302049723,
            302053638,
            302049221,
            302054664,
            302052475,
            302055824,
            302052997,
            302059041,
            302057352,
            302051579,
            302051983,
            302056196,
            302056129,
            302055478,
            302054565
        ],
        "A": [
            302047037,
            302049009,
            302047309,
            302047023,
            302047283,
            302047053,
            302047177,
            302047108,
            302047316,
            302047521,
            302047571,
            302047610,
            302047369,
            302048738,
            302047337,
            302048364,
            302049028,
            302047123
        ],
        "H2": [
            302541217
        ],
        "I": [
            302144176,
            302142123,
            302142064,
            302141919,
            302124920,
            302518298,
            302518173,
            302517883
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138620",
    "editorial": "First, we divide the string into blocks.Let’s analyze the properties of\r\nthe blocks in that do not move (to simplify corner cases, we can add a\r\nblock with a different number at both ends of ): These blocks must\r\nalternate between and . Between two immovable blocks, the s will shift\r\ntoward the same side as the adjacent block of s, and the s will shift\r\ntoward the same side as the adjacent block of s. For example, will\r\nbecome after the shifting process. This properties can be proven by\r\ninduction. For the easy version, since the target string is known, we\r\ncan greedily determine whether each block in can remain\r\nimmovable.Specifically:For each block and the previous immovable block,\r\ncheck if the corresponding digits are different. Also, ensure that the\r\nnumbers in the interval between the two blocks meet the conditions\r\n(i.e., the s and s in this interval must shift to their respective\r\nsides). This can be solved efficiently using prefix sums.If there are\r\nblocks between two immovable blocks, then moves are required.Time\r\ncomplexity: . For the hard version, we use dynamic programming to\r\ndetermine which blocks can remain immovable.Let represent the minimum\r\ncost for the -th block to remain immovable. We have:Without loss of\r\ngenerality, assume that the -th block is composed of s. Let the distance\r\nbetween the -th block and the nearest preceding -block be . The number\r\nof s between blocks and cannot exceed . There is a restriction:\r\n.Similarly, for , we can derive a symmetric restriction: .We can use a\r\nsegment tree to maintain the values of for all valid . Specifically: For\r\na position , if the current , update the corresponding value to . For\r\neach , query the segment tree over the valid interval to compute the\r\nminimum efficiently. Time complexity: .\r\n",
    "name": "F1. Kevin and Binary String  Easy Version ",
    "statement": "Kevin has a binary string s of length n. Kevin can perform the following\r\noperation: Choose two adjacent blocks of s and swap them. A block is a\r\nmaximal substring^{\r\ntext{ }} of identical characters. Formally, denote s[l,r] as the\r\nsubstring s_l s_{l+1}\r\nldots s_r. A block is s[l,r] satisfying: l=1 or s_l\r\nnot=s_{l-1}. s_l=s_{l+1} =\r\nldots = s_{r}. r=n or s_r\r\nnot=s_{r+1}. Adjacent blocks are two blocks s[l_1,r_1] and s[l_2,r_2]\r\nsatisfying r_1+1=l_2.For example, if s=\r\nmathtt{000}\r\n,\r\nmathbf{11}\r\n,\r\nmathbf{00}\r\n,\r\nmathtt{111}, Kevin can choose the two blocks s[4,5] and s[6,7] and swap\r\nthem, transforming s into\r\nmathtt{000}\r\n,\r\nmathbf{00}\r\n,\r\nmathbf{11}\r\n,\r\nmathtt{111}.Given a string t of length n consisting of ’0’, ’1’ and ’?’,\r\nKevin wants to determine the minimum number of operations required to\r\nperform such that for any index i (1\r\nle i\r\nle n), if t_i\r\nnot= ’?’ then s_i=t_i. If it is impossible, output -1.^{\r\ntext{ }}A string a is a substring of a string b if a can be obtained\r\nfrom b by the deletion of several (possibly, zero or all) characters\r\nfrom the beginning and several (possibly, zero or all) characters from\r\nthe end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;using u128 = unsigned __int128; void solve() {    std::string s, t;    std::cin >> s >> t;        int n = s.size();        std::vector<int> f(n + 1);    for (int i = 0; i < n; i++) {        f[i + 1] = f[i] + s[i] - t[i];    }        if (f[n] != 0) {        std::cout << -1 << \"\\n\";        return;    }        int lst = 0;    for (int i = 1; i <= n; i++) {        if (f[i] == 0) {            if (i - lst > 1) {                int cnt = 0;                for (int j = lst + 1; j < i; j++) {                    if (t[j] != t[j - 1]) {                        cnt++;                    }                }                if (cnt != 1) {                    std::cout << -1 << \"\\n\";                    return;                }                if (lst > 0 && (t[lst] != t[lst - 1] || s[lst] == s[lst - 1])) {                    std::cout << -1 << \"\\n\";                    return;                }                if (i < n && (t[i] != t[i - 1] || s[i] == s[i - 1])) {                    std::cout << -1 << \"\\n\";                    return;                }            }            lst = i;        }    }        int ans = 0;    if (s[0] != t[0]) {        ans++;    }    if (s[n - 1] != t[n - 1]) {        ans++;    }    for (int i = 1; i < n; i++) {        if (s[i] != s[i - 1]) {            ans++;        }        if (t[i] != t[i - 1]) {            ans--;        }    }    ans /= 2;        std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "binary search",
        "bitmasks",
        "brute force",
        "chinese remainder theorem",
        "combinatorics",
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "dsu",
        "expression parsing",
        "fft",
        "flows",
        "geometry",
        "graph matchings",
        "graphs",
        "greedy",
        "hashing",
        "implementation",
        "interactive",
        "math",
        "matrices",
        "meet-in-the-middle",
        "number theory",
        "probabilities",
        "schedules",
        "shortest paths",
        "sortings",
        "strings",
        "ternary search",
        "trees",
        "two pointers"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F1. Kevin and Binary String  Easy Version .json"
}