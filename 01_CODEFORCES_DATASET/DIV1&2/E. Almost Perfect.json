{
    "link": "https://codeforces.com//contest/1726/problem/E",
    "problemId": "1532137",
    "problem_idx": "E",
    "shortId": "1726E",
    "contest_number": "1726",
    "problem_submissions": {
        "H": [
            171166152,
            173790631,
            203781522
        ],
        "G": [
            171127286,
            171123945,
            171187552,
            171141010,
            171140722,
            171664786,
            171144226,
            171145348,
            171099465,
            171201134,
            171130848,
            171158116,
            171157860,
            171157000,
            171126442,
            171148861,
            171157096,
            171154938,
            171734872,
            171170680,
            171137702,
            171157236,
            171205955
        ],
        "F": [
            171108903,
            171111157,
            171113439,
            171121881,
            171130813,
            171124755,
            171146710,
            171185756,
            171127747,
            171154469,
            171132548,
            171129760,
            171128679,
            171131869,
            171129630,
            171127886,
            171131493,
            171128356
        ],
        "E": [
            171094108,
            171082776,
            171092673,
            171103228,
            171099685,
            171107510,
            171130522,
            171086219,
            171098373,
            171093064,
            171087566,
            171101329,
            171097980,
            171106309,
            171103049,
            171115448,
            171104715,
            171104412,
            171103731,
            171103976
        ],
        "D": [
            171086407,
            171094193,
            171085018,
            171163183,
            171095551,
            171089125,
            171099036,
            171122521,
            171096908,
            171110181,
            171221601,
            171081072,
            171080401,
            171083405,
            171092300,
            171088283,
            171088398,
            171090938,
            171088918,
            171097824,
            171093263,
            171092066
        ],
        "C": [
            171077821,
            171073174,
            171072071,
            171078629,
            171077517,
            171086726,
            171108612,
            171075141,
            171072509,
            171072364,
            171070939,
            171070414,
            171078452,
            171075783,
            171074035,
            171078333,
            171078838,
            171087703,
            171078897,
            171079488
        ],
        "B": [
            171071571,
            171066055,
            171068756,
            171072172,
            171073247,
            171082438,
            171105681,
            171070428,
            171069384,
            171068782,
            171068043,
            171068503,
            171068633,
            171073450,
            171069653,
            171069194,
            171074033,
            171074318,
            171074355,
            171074835
        ],
        "A": [
            171065811,
            171064612,
            171065880,
            171065721,
            171066103,
            171072016,
            171102188,
            171066260,
            171065726,
            171065055,
            171065128,
            171065050,
            171064937,
            171065648,
            171066070,
            171065533,
            171067186,
            171069008,
            171074050,
            171065687
        ]
    },
    "name": "E. Almost Perfect",
    "statement": "A permutation p of length n is called if for all integer 1\r\nleq i\r\nleq n, it holds that\r\nlvert p_i - p^{-1}_i\r\nrvert\r\nle 1, where p^{-1} is the inverse permutation of p (i.e. p^{-1}_{k_1} =\r\nk_2 if and only if p_{k_2} = k_1).Count the number of permutations of\r\nlength n modulo 998244353.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int\n\tmint():v(0) {}\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tbool operator==(const mint& o) const {\n\t\treturn v == o.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& o) { \n\t\tif ((v += o.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& o) { \n\t\tif ((v -= o.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& o) { \n\t\tv = int((ll)v*o.v%MOD); return *this; }\n\tmint& operator/=(const mint& o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\nusing mi = mint<MOD,5>; // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi,mi>;\nusing vpmi = V<pmi>;\n\nV<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: pre-compute factorial mod inverses,\n \t* assumes $MOD$ is prime and $SZ < MOD$.\n * Time: O(SZ)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n */\n\nvmi invs, fac, ifac;\nvoid genFac(int SZ) {\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); \n\tinvs[1] = fac[0] = ifac[0] = 1; \n\tFOR(i,2,SZ) invs[i] = mi(-(ll)MOD/i*(int)invs[MOD%i]);\n\tFOR(i,1,SZ) fac[i] = fac[i-1]*i, ifac[i] = ifac[i-1]*invs[i];\n}\nmi comb(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn fac[a]*ifac[b]*ifac[a-b]; }\n\nvoid solve(int tc) {\n\tints(N);\n\tgenFac(N+1);\n\n\t// cycle of length <= 2 OK\n\t// length 4: opposites are <= 1\n\tauto ways = [&](int a, int b) {\n\t\treturn comb(a+b, b);\n\t};\n\tvmi falling_fac(N+1);\n\tfalling_fac[0] = 1;\n\tFOR(i,1,N+1) {\n\t\tfalling_fac[i] = (2*i-1)*falling_fac[i-1];\n\t}\n\tvmi pairup(N+1);\n\tpairup[0] = 1;\n\tFOR(i,1,N+1) {\n\t\tpairup[i] = pairup[i-1];\n\t\tif (i > 1) {\n\t\t\tpairup[i] += (i-1) * pairup[i-2];\n\t\t}\n\t}\n\tmi ans = 0;\n\tfor (int cyc_4 = 0; 4 * cyc_4 <= N; ++cyc_4) {\n\t\tmi mul = pow(mi(2), cyc_4) * ways(2 * cyc_4, N - 4 * cyc_4) * falling_fac[cyc_4];\n\t\tans += mul * pairup[N - 4 * cyc_4];\n\t\t// 2 * cyc_4 pairs\n\t\t// N - 4 * cyc_4 extras\n\n\t\t// int rem = N-cyc_4;\n\t\t// mi sum = 0, prod = 1;\n\t\t// int rem = N - 4 * cyc_4;\n\t\t// 2*cyc_4\n\t\t// 2^{cyc_4}\n\t\t// pairup\n\t\t// \n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "fft",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Almost Perfect.json",
    "editorial_link": "https://codeforces.com//blog/entry/106675",
    "editorial": "First of all, if there is only distinct value of happiness, any ordering\r\nis fine since no one has strictly greater or lesser happiness, and the\r\nanswer is . From here on, we assume that there are at least distinct\r\nvalues of happiness.: The notation refers to elements with happiness and\r\nbehaviour .: The happiness of a person can never decrease. It is\r\nobvious.Let\u00e2\u0080\u0099s call the final happiness value all elements will be equal\r\nto as the . Also, let the smallest happiness value of the array be , and\r\nthe largest be . Note that , otherwise, it is impossible for a valid\r\norder to exist, from observation .: For all , there can be at most one\r\noccurrence of in the array.Let\u00e2\u0080\u0099s say there is more than one occurrence\r\nof . Let\u00e2\u0080\u0099s say at some point, we can place one occurrence of it in our\r\norder, and we place it. But then for the remaining occurrences, it\r\nimmediately becomes impossible to place them anymore, because the number\r\nof strictly greater values increases by , and can only increase from\r\nthere. Hence, contradiction. : There is only one possible , given by\r\n.Let\u00e2\u0080\u0099s say we have . Then no matter what we do, its final happiness\r\nvalue will still be , since there will never be a value strictly lesser\r\nthan it. This means . This however, breaks our assumption of distinct\r\nvalues. So only can exist. But if that exists, from observation ,\r\nexactly one such occurrence exists. The number of values strictly\r\ngreater than will always be constant. So, no matter when we place it,\r\nthe final happiness value is going to be . : If it is possible to place\r\nmultiple numbers in the order at a certain point ( if there are multiple\r\npossible place which will all yield ), it is always better to prefer the\r\nlarger number, and to place a number with behaviour over one with\r\nbehaviour in case of a tie. Let\u00e2\u0080\u0099s say you pick something smaller than\r\nthe larger number. Now this number becomes , which is . Now consider the\r\nlarger number. If it had a , now it is impossible to place it anymore,\r\nbecause the number of numbers strictly lesser has reduced by , and it\r\ncan only reduce. A similar argument follows for .In the same group, you\r\nhave to prefer s over s. Let\u00e2\u0080\u0099s say you placed the first. Now the number\r\nof numbers strictly greater has increased by , and can only increase.\r\nTherefore you can never place the now. Placing the first does not affect\r\nthe viability of placing the s. If , the group is special, since it\r\ndoesn\u00e2\u0080\u0099t matter when you place it since the final happiness value will\r\nstill be , and it won\u00e2\u0080\u0099t affect any other group\u00e2\u0080\u0099s viability either. But\r\nthe observation still holds.In fact, except the group in the case of ,\r\nyou to follow this order. This means the order is unique upto\r\nconsidering equal elements as indistinguishable. This means, we can only\r\nchoose the order of placing equal values. We cannot choose the occupied\r\npositions in the final order.Hence the count is going to be the product\r\nof the number of possible permutations for each group. : For a valid\r\nordering (if exists), the behaving people would be sorted in\r\nnon-decreasing order of initial happiness. We assume the contrary:\r\nSuppose for , speaks before in some valid order. Since it is known that\r\nboth finally become , it must be the case that there were people with a\r\nsmaller happiness than , when speaks and people with a smaller happiness\r\nthan , when speaks. As , everyone having a happiness less than must also\r\nhave a happiness less than . Therefore when speaks people had a\r\nhappiness smaller than . Now ; which means the number of people having a\r\nvalue less than increased. But the happiness of each person can only\r\nincrease, and hence the number of poeple with a happiness less than\r\ncannot increase; . : For a valid ordering (if exists) and at any\r\nintermediate step, for all behaving people yet to speak, the number of\r\npeople with a larger happiness than cannot exceed . In other words, if\r\nwe placed at any intermediate step, its final happiness would not exceed\r\n. The happiness of everyone can only increase. So if the number of\r\npeople with happiness greater than exceeds before has spoken, the number\r\nof people with a happiness greater than would not decrease when\r\nsubsequently speaks. This means the final happiness of this person would\r\nbe greater than , which cannot happen. As mentioned before, in the case\r\nof the group if , it doesn\u00e2\u0080\u0099t matter where we place them in the order,\r\nbut the order of the remaining elements is fixed. If there are\r\noccurrences of this group, then we have spots we can choose to place\r\nthese values of the group in, and then the rest of the elements will\r\nfollow the order in the remaining positions. The count is going to be\r\nmultiplied by .However, it may be the case that no such ordering exists.\r\nWe thus try to find an order using and speed it up using and . We notice\r\nthat we can have a brute force simulation of to find the order in time.\r\nHowever, we can do the following: Place all occurrences of at the\r\nbeginning as their positions don\u00e2\u0080\u0099t matter. Keep a sorted\r\n(non-decreasing) list of all the behaving people who are yet to speak.\r\nFrom the only candidate who can be placed from this list at a given step\r\nis the least happy candidate. Keep a sorted (increasing) list of all\r\nbehaving people who are yet to speak where we keep track of the maximum\r\nof the final happiness reached if they were to speak now ( their initial\r\nhappiness + the number of people with a strictly greater happiness at\r\npresent) among all people in this list. From , we know that if this\r\nmaximum exceeds , there is no possible ordering and we output . Hence\r\nfrom now we will assume that the maximum happiness reached if they were\r\nto talk now to be at most . At each step, there are only two potential\r\nspeakers that we need to check (since we are breaking ties using ): The\r\nleast happy behaving person (if its happiness reached currently is ) and\r\nthe maximum stored in the last step (if it is equal to ). If neither is\r\nvalid, we report no answer. Otherwise, we break ties using and make that\r\nperson speak. We change their happiness to and the final happiness\r\nvalues if they speak now, of all the behaving people that had a greater\r\nhappiness (handled in step ) than the current person would increase by .\r\nIf we can complete the entire process, we have a valid ordering. This\r\ncan be done quickly using two segment trees: One for keeping the\r\nhappiness reached values of behaving people yet to speak and storing\r\ntheir maximum (so that steps and become max query and range updates);\r\nand another for keeping the count of people having a particular\r\nhappiness value (to speed up finding the current happiness value if they\r\nspeak now for the least happy behaving person in step ). Time\r\ncomplexity:\r\n"
}