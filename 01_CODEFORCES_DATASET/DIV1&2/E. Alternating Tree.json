{
    "link": "https://codeforces.com//contest/960/problem/E",
    "problemId": "172422",
    "problem_idx": "E",
    "shortId": "960E",
    "contest_number": "960",
    "problem_submissions": {
        "H": [
            37076939,
            37076112,
            37074469,
            37077049
        ],
        "G": [
            37071263,
            57709834,
            57709811,
            37070456,
            37070524,
            37070914,
            37073469,
            37074485,
            37075164,
            37076234,
            37075338,
            37079339,
            37075175,
            37074093,
            37077545
        ],
        "E": [
            37066041,
            37079944,
            37063783,
            37066048,
            37064488,
            37061915,
            37065298,
            37064523,
            37070733,
            37072090,
            37076676,
            37064464,
            37069828,
            37067545,
            37067744,
            37066196,
            37072966
        ],
        "D": [
            37064105,
            37063850,
            37067264,
            37066015,
            37064335,
            37059946,
            37066190,
            37067902,
            37062007,
            37066676,
            37068757,
            37066067,
            37061947,
            37066618,
            37070708,
            37069032,
            37065961
        ],
        "F": [
            37061228,
            37060911,
            37058043,
            37061179,
            37057703,
            37061709,
            37063433,
            37060626,
            37066935,
            37063565,
            37062126,
            37065836,
            37069620,
            37066690,
            37061224,
            37061530,
            37061194,
            37061393,
            37069132
        ],
        "C": [
            37059020,
            37058186,
            37073747,
            37057785,
            37060772,
            37057801,
            37056055,
            37058782,
            37058698,
            37060994,
            37061675,
            37062340,
            37067775,
            37058977,
            37058993,
            37058400,
            37058570,
            37060826
        ],
        "B": [
            37057197,
            37056331,
            37056347,
            37056532,
            37059595,
            37056085,
            37057341,
            37056165,
            37056262,
            37056554,
            37057292,
            37058927,
            37056440,
            37056660,
            37057273,
            37056784,
            37056702,
            37058078
        ],
        "A": [
            37055508,
            37055332,
            37055423,
            37055343,
            37058650,
            37055377,
            37058231,
            37055321,
            37055350,
            37055370,
            37055431,
            37055718,
            37055347,
            37055410,
            37055539,
            37055383,
            37055552
        ]
    },
    "name": "E. Alternating Tree",
    "statement": "Given a tree with n nodes numbered from 1 to n. Each node i has an\r\nassociated value V_i.If the simple path from u_1 to u_m consists of m\r\nnodes namely u_1\r\nrightarrow u_2\r\nrightarrow u_3\r\nrightarrow\r\ndots u_{m-1}\r\nrightarrow u_{m}, then its alternating function A(u_{1},u_{m}) is\r\ndefined as A(u_{1},u_{m}) =\r\nsum\r\nlimits_{i=1}^{m} (-1)^{i+1}\r\ncdot V_{u_{i}}. A path can also have 0 edges, i.e. u_{1}=u_{m}.Compute\r\nthe sum of alternating functions of all unique simple paths. Note that\r\nthe paths are directed: two paths are considered different if the\r\nstarting vertices differ or the ending vertices differ. The answer may\r\nbe large so compute it modulo 10^{9}+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n,val[N],u,v;\nVI e[N];\nll dp[N],up[N][2],down[N][2],cnt[N][2],ret;\nvoid dfs(int u,int f) {\n\tdp[u]=val[u];\n\tcnt[u][1]=1;\n\tup[u][1]=down[u][1]=val[u];\n\tfor (auto v:e[u]) if(v!=f) {\n\t\tdfs(v,u);\n\t\trep(p1,0,2) rep(p2,0,2) {\n\t\t\t// p1 p2\n\t\t\tdp[u]=(dp[u]+up[u][p1]*cnt[v][p2]+(1-2*p1)*down[v][p2]*cnt[u][p1])%mod;\n\t\t\tdp[u]=(dp[u]+up[v][p1]*cnt[u][p2]+(1-2*p1)*down[u][p2]*cnt[v][p1])%mod;\n\t\t}\n\t\trep(p1,0,2) {\n\t\t\tcnt[u][p1]=(cnt[u][p1]+cnt[v][p1^1])%mod;\n\t\t\tup[u][p1]=(up[u][p1]+up[v][p1^1]+(2*p1-1)*val[u]*cnt[v][p1^1])%mod;\n\t\t\tdown[u][p1]=(down[u][p1]+val[u]*cnt[v][p1^1]-down[v][p1^1])%mod;\n\t\t}\n\t}\n\tret+=dp[u];\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",val+i);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tret%=mod;\n\tif (ret<0) ret+=mod;\n\tprintf(\"%lld\\n\",ret);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "probabilities",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Alternating Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/58802",
    "editorial": "An important observation for the question is if there are even number of\r\nnodes on the simple path from to if there are odd number of nodes on the\r\nsimple path from to Hence for paths with even number of nodes. Hence the\r\ntask has been reduced to finding the total sum of alternating function\r\nof paths with odd number of nodes. Also we can make use of the fact that\r\n, but this does not hold true when , hence we must handle this case by\r\nsubtracting from the final answer. Now with the help of a single dfs we\r\ncan calculate the number of paths in the subtree of with odd number of\r\nnodes ending at node . the number of paths in the subtree of with even\r\nnumber of nodes ending at node . In the first part of the solution, for\r\neach node , we calculate its contribution to the alternating function\r\nfor paths passing through this node but strictly lying within its\r\nsubtree. For doing this we can merge two paths with either both having\r\neven or both having odd number of nodes ending at its children to create\r\nodd length paths. For the case where both the paths have even number of\r\nnodes, the current nodeâs contribution to the summation is because its\r\nposition in the sequence of nodes is odd . Similarly, we add for the\r\nother case. This can be done using a single dfs in time as we have and\r\nfor all the nodes. Now for the second part of the question, we have to\r\nconsider the paths which end up outside the subtree. We have the\r\ninformation and . We have to merge these paths with those ending at .\r\nHow do we get this information? Note that and just represent paths\r\nstrictly lying within the subtree of but not the entire tree. An\r\nimportant observation for this computation is - If node has a total of\r\nodd and even length paths ending at it then, if is the neighbour of then\r\nhas a total of odd and even length paths ending at it. It is fairly\r\nsimple to observe. We know and and since the subtree of is the entire\r\ntree, we can use these values for our requirement. Now letâs represent\r\nthe total number of odd and even length paths ending at by and\r\nrespectively. From our previous observation, if is odd number of nodes\r\naway from the node - if is even number of nodes away from the node - The\r\nnumber of paths ending at but lying strictly outside the subtree of can\r\nbe calculated - odd length paths even length paths Now we have to\r\nconstruct odd-length paths by merging paths in the subtree of ending at\r\nnode with paths ending at but strictly lying outside the subtree of .\r\nFor paths with odd-length component ending at we must add to the\r\nsummation and otherwise. Finally, the summation of contributions of each\r\nnode yields you the total summation of alternating functions for all\r\npair of nodes. This can be done for each node in time.The overall time\r\ncomplexity of the solution is .\r\n",
    "hint": []
}