{"link": "https://codeforces.com//contest/960/problem/E", "problemId": "172422", "problem_idx": "E", "shortId": "960E", "contest_number": "960", "problem_submissions": {"H": [37076939, 37076112, 37074469, 37077049], "G": [37071263, 57709834, 57709811, 37070456, 37070524, 37070914, 37073469, 37074485, 37075164, 37076234, 37075338, 37079339, 37075175, 37074093, 37077545], "E": [37066041, 37079944, 37063783, 37066048, 37064488, 37061915, 37065298, 37064523, 37070733, 37072090, 37076676, 37064464, 37069828, 37067545, 37067744, 37066196, 37072966], "D": [37064105, 37063850, 37067264, 37066015, 37064335, 37059946, 37066190, 37067902, 37062007, 37066676, 37068757, 37066067, 37061947, 37066618, 37070708, 37069032, 37065961], "F": [37061228, 37060911, 37058043, 37061179, 37057703, 37061709, 37063433, 37060626, 37066935, 37063565, 37062126, 37065836, 37069620, 37066690, 37061224, 37061530, 37061194, 37061393, 37069132], "C": [37059020, 37058186, 37073747, 37057785, 37060772, 37057801, 37056055, 37058782, 37058698, 37060994, 37061675, 37062340, 37067775, 37058977, 37058993, 37058400, 37058570, 37060826], "B": [37057197, 37056331, 37056347, 37056532, 37059595, 37056085, 37057341, 37056165, 37056262, 37056554, 37057292, 37058927, 37056440, 37056660, 37057273, 37056784, 37056702, 37058078], "A": [37055508, 37055332, 37055423, 37055343, 37058650, 37055377, 37058231, 37055321, 37055350, 37055370, 37055431, 37055718, 37055347, 37055410, 37055539, 37055383, 37055552]}, "name": "E. Alternating Tree", "statement": "Given a tree with n nodes numbered from 1 to n. Each node i has an\r\nassociated value V_i.If the simple path from u_1 to u_m consists of m\r\nnodes namely u_1\r\nrightarrow u_2\r\nrightarrow u_3\r\nrightarrow\r\ndots u_{m-1}\r\nrightarrow u_{m}, then its alternating function A(u_{1},u_{m}) is\r\ndefined as A(u_{1},u_{m}) =\r\nsum\r\nlimits_{i=1}^{m} (-1)^{i+1}\r\ncdot V_{u_{i}}. A path can also have 0 edges, i.e. u_{1}=u_{m}.Compute\r\nthe sum of alternating functions of all unique simple paths. Note that\r\nthe paths are directed: two paths are considered different if the\r\nstarting vertices differ or the ending vertices differ. The answer may\r\nbe large so compute it modulo 10^{9}+7.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n,val[N],u,v;\nVI e[N];\nll dp[N],up[N][2],down[N][2],cnt[N][2],ret;\nvoid dfs(int u,int f) {\n\tdp[u]=val[u];\n\tcnt[u][1]=1;\n\tup[u][1]=down[u][1]=val[u];\n\tfor (auto v:e[u]) if(v!=f) {\n\t\tdfs(v,u);\n\t\trep(p1,0,2) rep(p2,0,2) {\n\t\t\t// p1 p2\n\t\t\tdp[u]=(dp[u]+up[u][p1]*cnt[v][p2]+(1-2*p1)*down[v][p2]*cnt[u][p1])%mod;\n\t\t\tdp[u]=(dp[u]+up[v][p1]*cnt[u][p2]+(1-2*p1)*down[u][p2]*cnt[v][p1])%mod;\n\t\t}\n\t\trep(p1,0,2) {\n\t\t\tcnt[u][p1]=(cnt[u][p1]+cnt[v][p1^1])%mod;\n\t\t\tup[u][p1]=(up[u][p1]+up[v][p1^1]+(2*p1-1)*val[u]*cnt[v][p1^1])%mod;\n\t\t\tdown[u][p1]=(down[u][p1]+val[u]*cnt[v][p1^1]-down[v][p1^1])%mod;\n\t\t}\n\t}\n\tret+=dp[u];\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",val+i);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tret%=mod;\n\tif (ret<0) ret+=mod;\n\tprintf(\"%lld\\n\",ret);\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "divide and conquer", "dp", "probabilities", "trees"], "dificulty": "2300", "interactive": false}