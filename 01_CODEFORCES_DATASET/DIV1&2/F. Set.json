{
    "link": "https://codeforces.com//contest/1975/problem/F",
    "problemId": "2665477",
    "problem_idx": "F",
    "shortId": "1975F",
    "contest_number": "1975",
    "problem_submissions": {
        "H": [
            262631844,
            262612241,
            262600659,
            262612635,
            263096548
        ],
        "G": [
            262620370,
            262584629,
            262630306,
            262578664,
            262622745,
            262588918,
            262593694,
            262594206,
            262595918,
            262599422,
            262708940,
            262706456,
            262598241,
            262653444,
            262620831,
            262602673,
            262607334,
            262630272,
            262607273,
            262706071,
            262602704,
            262606536,
            262606903,
            262607812,
            263091775,
            263089587,
            263088604,
            263088409,
            263086834,
            263086045,
            262606154,
            264861303,
            262776553,
            262774627,
            262774590,
            262661298,
            262661024,
            262660704,
            262660316,
            262660273,
            262649420,
            262647737,
            262637294,
            262637274,
            262636778,
            262636749,
            262636610,
            262628729,
            262609429
        ],
        "E": [
            262558741,
            262555523,
            262542791,
            262569978,
            262560342,
            262572286,
            262561563,
            262558869,
            262555295,
            262569100,
            262560726,
            262553867,
            262556464,
            262558648,
            262561133,
            262565554,
            262576529,
            262575502,
            262635435,
            262635401,
            262635086,
            262635019,
            262630627,
            262630590,
            262570080
        ],
        "F": [
            262544594,
            262562050,
            262557811,
            262552279,
            262571108,
            262585701,
            262572669,
            262581085,
            262582375,
            262578636,
            262570215,
            262564737,
            262572783,
            262580057,
            262586122,
            262583527,
            262590488,
            262590492,
            262629974,
            262593633
        ],
        "D": [
            262526751,
            262533906,
            262549799,
            262548001,
            262535765,
            262555432,
            262532809,
            262542647,
            262536556,
            262547635,
            262538823,
            262574019,
            262544846,
            262547400,
            262544181,
            262539052,
            262538393,
            262538893,
            262629935,
            262543856
        ],
        "A": [
            262522755,
            262521103,
            262521181,
            262521345,
            262530553,
            262521158,
            262521224,
            262521209,
            262523388,
            262521604,
            262521957,
            262521117,
            262521171,
            262521739,
            262524060,
            262521821,
            262521219,
            262521958
        ],
        "C": [
            262522159,
            262524942,
            262525029,
            262526905,
            262542130,
            262526806,
            262529464,
            262528086,
            262531414,
            262526373,
            262530226,
            262525393,
            262531728,
            262530061,
            262528640,
            262528306,
            262542306,
            262526711
        ],
        "B": [
            262521205,
            262521505,
            262522451,
            262522658,
            262534024,
            262523709,
            262523854,
            262522613,
            262526293,
            262523579,
            262524186,
            262521924,
            262522192,
            262523093,
            262522741,
            262523954,
            262521898,
            262521340
        ],
        "I": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/129801",
    "editorial": "SolutionRead the hints.Consider enumerating each number from to whether\r\nit is contained by . Suppose that the current enumeration reaches , and\r\nin the remaining constraints, and are two sets, the only difference\r\nbetween them is whether they contain ( contains ): contains . We can\r\nmerge and into a new constraint and &. doesnât contain . We can merge\r\nand into a new constraint and &. We can merge constraints quickly when\r\nthe enumeration reaches a new number. And the time complexity is\r\n",
    "name": "F. Set",
    "statement": "Define the of a finite set of natural numbers T\r\nsubseteq\r\n{0,1,2,\r\nldots\r\n} as f(T) =\r\nsum\r\nlimits_{i\r\nin T} 2^i. For example, f(\r\n{0,2\r\n}) = 2^0 + 2^2 = 5 and f(\r\n{\r\n}) = 0. Notice that f is a bijection from all such sets to all\r\nnon-negative integers. As such, f^{-1} is also defined.You are given an\r\ninteger n along with 2^n-1 sets V_1,V_2,\r\nldots,V_{2^n-1}.Find all sets S that satisfy the following constraint: S\r\nsubseteq\r\n{0,1,\r\nldots,n-1\r\n}. Note that S can be . For all subsets T\r\nsubseteq\r\n{0,1,\r\nldots,n-1\r\n}, |S\r\ncap T|\r\nin V_{f(T)}. Due to the large input and output, both input and output\r\nwill be given in terms of binary encodings of the sets.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 25.05.2024 10:57:59**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int n;  cin >> n;  vector<int> v(1 << n);  for (int i = 1; i < (1 << n); i++) {    cin >> v[i];  }  v[0] = 1;  vector<vector<int>> a(n + 1);  a[0] = v;  for (int i = 1; i <= n; i++) {    a[i].resize(1 << (n - i));  }  vector<int> res;  auto Dfs = [&](auto&& self, int b, int num) {    if (b == n) {      if (a[b][0] > 0) {        res.push_back(num);      }      return;    }    for (int val = 0; val < 2; val++) {      for (int i = 0; i < (1 << (n - b - 1)); i++) {        a[b + 1][i] = a[b][2 * i] & (a[b][2 * i + 1] >> val);      }      self(self, b + 1, num + (val << b));    }  };  Dfs(Dfs, 0, 0);  sort(res.begin(), res.end());  cout << res.size() << '\\n';  for (int x : res) {    cout << x << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Set.json",
    "hint": [
        "Hint 1 Consider enumerating each number from to whether it is contained by , when we have enumerated the first numbers, there are only constraints."
    ]
}