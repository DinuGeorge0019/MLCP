{
    "link": "https://codeforces.com//contest/1740/problem/E",
    "problemId": "1611414",
    "problem_idx": "E",
    "shortId": "1740E",
    "contest_number": "1740",
    "problem_submissions": {
        "H": [
            178379430,
            178389839,
            178370970,
            178389787,
            178394159,
            178405718,
            178393380,
            178400994,
            178473578
        ],
        "G": [
            178363447,
            178373152,
            178390136,
            178380782,
            178380133,
            178366412,
            178381208,
            178372252,
            178364309,
            178377085,
            178379805,
            178389960,
            178394186,
            178390668,
            178429073,
            178399239,
            178398964,
            178398319,
            178393777,
            178389532,
            178457114,
            178457090,
            178457069,
            178456881,
            178456598
        ],
        "F": [
            178342509,
            178355726,
            178353094,
            178359313,
            178375325,
            178347566,
            178343206,
            178355344,
            178419766,
            178363409,
            178364030,
            178360259,
            178371042,
            178378751,
            178405026,
            178404845,
            178404014,
            178403791,
            178403569,
            178376955,
            178368121,
            178355891,
            178355560,
            178363171,
            178364934
        ],
        "E": [
            178337370,
            178346224,
            178348715,
            178344194,
            178352039,
            178338198,
            178335731,
            178340043,
            178343562,
            178350554,
            178352735,
            178349059,
            178343925,
            178345775,
            178364103,
            178352981,
            178344981,
            178359372,
            178346165,
            178350475
        ],
        "D": [
            178334153,
            178339631,
            178345824,
            178338369,
            178344365,
            178352777,
            178346625,
            178336331,
            178336614,
            178338914,
            178339308,
            178344306,
            178335725,
            178354316,
            178351979,
            178370227,
            178339993,
            178338550,
            178340955,
            178340858
        ],
        "C": [
            178329483,
            178334722,
            178336471,
            178331649,
            178333101,
            178332328,
            178330724,
            178331197,
            178330550,
            178331983,
            178331086,
            178337583,
            178330090,
            178335594,
            178335112,
            178340402,
            178335550,
            178333891,
            178336207,
            178332182
        ],
        "B": [
            178326239,
            178328080,
            178333593,
            178327287,
            178329054,
            178327314,
            178327001,
            178329448,
            178327787,
            178327568,
            178327277,
            178328845,
            178326455,
            178328799,
            178328762,
            178333879,
            178327499,
            178329269,
            178328122,
            178330549
        ],
        "A": [
            178322883,
            178322996,
            178323296,
            178323217,
            178323002,
            178322816,
            178327673,
            178322982,
            178323305,
            178322810,
            178323224,
            178323080,
            178322764,
            178323327,
            178324186,
            178325267,
            178322814,
            178324090,
            178323226,
            178322754
        ],
        "I": [
            179538712
        ]
    },
    "name": "E. Hanging Hearts",
    "statement": "Pak Chanek has n blank heart-shaped cards. Card 1 is attached directly\r\nto the wall while each of the other cards is hanging onto exactly one\r\nother card by a piece of string. Specifically, card i (i > 1) is hanging\r\nonto card p_i (p_i < i).In the very beginning, Pak Chanek must write one\r\ninteger number on each card. He does this by choosing any permutation a\r\nof [1, 2,\r\ndots, n]. Then, the number written on card i is a_i.After that, Pak\r\nChanek must do the following operation n times while maintaining a\r\nsequence s (which is initially empty): Choose a card x such that no\r\nother cards are hanging onto it. Append the number written on card x to\r\nthe end of s. If x\r\nneq 1 and the number on card p_x is larger than the number on card x,\r\nreplace the number on card p_x with the number on card x. Remove card x.\r\nAfter that, Pak Chanek will have a sequence s with n elements. What is\r\nthe maximum length of the longest non-decreasing subsequence^\r\ndagger of s at the end if Pak Chanek does all the steps optimally?^\r\ndagger A sequence b is a subsequence of a sequence c if b can be\r\nobtained from c by deletion of several (possibly, zero or all) elements.\r\nFor example, [3,1] is a subsequence of [3,2,1], [4,3,1] and [3,1], but\r\nnot [1,3,3,7] and [3,10,4].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n);\n    for (int i = 1; i < n; i++) {\n        std::cin >> p[i];\n        p[i]--;\n    }\n    p[0] = -1;\n    \n    std::vector<int> h(n, 1), dp(n);\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i] = std::max(dp[i], h[i]);\n        if (i) {\n            dp[p[i]] += dp[i];\n            h[p[i]] = std::max(h[p[i]], h[i] + 1);\n        }\n    }\n    \n    std::cout << dp[0] << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Hanging Hearts.json",
    "editorial_link": "https://codeforces.com//blog/entry/108567",
    "editorial": "The cards form a rooted tree with card being the root, where for each\r\n(), the parent of card is .Let be the number on card when it is about to\r\nget removed. To remove card , we must previously remove all cards in the\r\nsubtree of other than itself. Thus, we can see that is the minimum value\r\nof out of all cards in the subtree of .Let the sequence mean that the\r\n-th element of the longest non-decreasing subsequence comes from card .\r\nThen, we can get the following observations: We can only remove card if\r\nall other cards in the subtree of have been removed. Hence, for each ,\r\nevery with must not be in the subtree of . We can make to be the\r\nancestor of by making . This can be done by making it such that the\r\nminimum value of in the subtree of is simultaneously the minimum value\r\nof in the subtree of . If is not the ancestor of , then must hold.\r\nBecause forms a non-decreasing sequence, then must hold. That means, is\r\nguaranteed to be larger than the values of for all ancestors of . This\r\nmeans, after , cannot continue with any ancestors of . From the\r\ninformation above, it means that when constructing , we do one the\r\nfollowing operation several times: Append an ancestor of the last card.\r\nAppend a card that is not an ancestor of the last card and not a\r\ndescendant of any of the previous cards. After this, we cannot choose\r\nany ancestor of the card before this new card. In the optimal\r\nconfiguration, the sequence resembles the following: It consists of\r\nseveral paths of cards where each path is from a card to one of its\r\nancestors. For any pair of cards from two different paths, one must not\r\nbe an ancestor of the other. We will use dynamic programming on tree.\r\nLet denote the length of the longest non-decreasing subsequence created\r\nfrom only doing operations to the subtree of . Then, we have two cases:\r\nIf card is used in the longest non-decreasing subsequence, then the\r\nmaximum answer is the maximum number of cards in a path from card to one\r\nof the cards in the subtree of . If card is not used in the longest\r\nnon-decreasing subsequence, then the maximum answer is the sum of values\r\nof the children of card . Time complexity:\r\n"
}