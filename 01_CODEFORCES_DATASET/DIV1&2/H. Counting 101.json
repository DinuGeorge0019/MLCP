{
    "link": "https://codeforces.com//contest/2002/problem/H",
    "problemId": "2809246",
    "problem_idx": "H",
    "shortId": "2002H",
    "contest_number": "2002",
    "problem_submissions": {
        "H": [
            275883821,
            276030000,
            276029533,
            276718944,
            276718931,
            276716412,
            276716121,
            276379907
        ],
        "G": [
            275814532,
            275831532,
            275862936,
            275862868,
            275857045,
            275856914,
            275852957,
            275835244,
            275830497,
            275836895,
            275844798,
            275836685,
            275839620,
            275876408,
            275835680,
            276384839,
            275855186,
            275854807,
            275854377,
            275854233,
            275853273,
            275853001,
            277160193,
            275873413
        ],
        "F2": [
            275803261,
            275805293,
            275815511,
            275803726,
            275821855,
            275826602,
            275804715,
            275817099,
            275812698,
            275821433,
            275820135,
            275822519,
            275814615,
            275832819,
            275821881,
            275820944,
            275827250
        ],
        "F1": [
            275803106,
            275797405,
            275810054,
            275805934,
            275822144,
            275821908,
            275808780,
            275842679,
            275842498,
            275804501,
            275809897,
            275810999,
            275804801,
            275820307,
            275807320,
            275814303,
            275818257,
            275821104,
            275812786,
            275819730
        ],
        "E": [
            275776266,
            275785744,
            275852219,
            275788914,
            275771707,
            275802566,
            275795962,
            275769983,
            275789286,
            275807515,
            275787919,
            275785680,
            275785359,
            275786354,
            275779961,
            275794439,
            275802251,
            275789750,
            275800998,
            275803752,
            275804830
        ],
        "D2": [
            275767991,
            275777830,
            275771186,
            275817652,
            275793116,
            275788319,
            275778566,
            275781543,
            275797706,
            275776037,
            275778290,
            275777713,
            275779770,
            275786761,
            275779192,
            275790952,
            275773357,
            275786731,
            275789591,
            275775563
        ],
        "D1": [
            275767248,
            275777327,
            275771493,
            275817851,
            275793580,
            275790111,
            275778728,
            275771118,
            275797900,
            275776414,
            275778256,
            275777934,
            275780036,
            275787162,
            275779917,
            275791115,
            275772837,
            275787063,
            275789991,
            275776578
        ],
        "C": [
            275759851,
            275761703,
            275759373,
            275759241,
            275760994,
            275777407,
            275759928,
            275758928,
            275788566,
            275759503,
            275761991,
            275762069,
            275758442,
            275761405,
            275763148,
            275760323,
            275761934,
            275768403,
            275764562,
            275765401
        ],
        "B": [
            275757139,
            275757734,
            275756638,
            275756387,
            275757424,
            275758576,
            275756620,
            275756121,
            275770304,
            275762131,
            275757965,
            275758270,
            275756051,
            275757393,
            275759268,
            275756663,
            275757687,
            275761514,
            275758840,
            275756832
        ],
        "A": [
            275755167,
            275755315,
            275754910,
            275755027,
            275755132,
            275755590,
            275754949,
            275754911,
            275767431,
            275754975,
            275755752,
            275755110,
            275754896,
            275755382,
            275755090,
            275755155,
            275754903,
            275755222,
            275756059,
            275754981
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132569",
    "editorial": "A dp solution will be, let be the minimum number of elements left\nafter some operations, if we only consider elements in , without\ncreating any elements . If , then the answer is if is odd, and\notherwise. We simply repeatedly perform operations with middle element\nas the center. It is easy to see that this is optimal.If , then will be\npartitioned into blocks by elements equal to . Denote the length of the\nblocks as . Let be the number of operations that has the -th element\nwith value as its center.We can perform a dp as follows: let be the\nminimum number of elements left if we have already considered the first\nblocks, and .When adding a new block, we need to know several things: ,\nthe minimum/maximum number of elements of the new block after some\noperations, without creating an element greater than . , the value of .\nThe transition of the dp will be: , where is defined as follows: The\nfunction follows from the case where .Now, we have a solution to Problem\n101. We now consider generalizing it to Counting 101.We make some\nobservations regarding the structure of . If you printed a table of ,\nyou would discover that for each , if you subtract the minimum element\nfrom all in this row, you will get something like: .We can prove this by\ninduction and some casework, which is omitted for brevity. If a\nsatisfies this property, then we can express it with a triple , where is\nthe minimum element of , and are the minimum/maximum such that . Now\nthat we can express the structure of each with a triple , we can run a\ndp of dp. Our state will be , where is the current length, is the upper\nbound, and describes the current . For each transition, we need to\nenumerate , and the new can be found in with some casework. This gives\nus an solution.Now to optimize the solution. We optimize the solution by\nreducing the number of viable states. Suppose we have a state , we\nclaim, that the answer will remain the same if we replace it with .We\nprove this by examining their behaviour when we add any number of blocks\nafter them. If the answer remains unchanged for any blocks we can add,\nthen the claim stands. Suppose we are at , and we will add a sequence of\nblocks after . The final answer can be found by running a backwards dp\nsimilar to , on , and merging with in the middle.If we denote the\nbackwards dp as , then the answer will be over all . It can be shown\nafter some brief casework (using \u00e2\u0080\u0099s structure), that there exists an\noptimal where is the minimum of , thus the answer is just a range (with\na certain parity) min of , plus . Because also follow \u00e2\u0080\u0099s structure, any\nrange will be first decreasing, then increasing. It can be shown with\nthese properties, . Thus, our answer will not change when substituting\nthe states.After substituting, the total number of different pairs will\nbe , which yields an solution.The solution can also be optimized to\nusing Lagrange Interpolation, but it actually runs slower than because\nof large constants (or bad implementation by setters).\n",
    "name": "H. Counting 101",
    "statement": "Sorting through some notes that were left behind, you found a curious\r\nstatement named : Given a positive integer sequence a_1,a_2,\r\nldots,a_n, you can operate on it any number of times. In an operation,\r\nyou choose three consecutive elements a_i,a_{i+1},a_{i+2}, and merge\r\nthem into one element\r\nmax(a_i+1,a_{i+1},a_{i+2}+1). Please calculate the maximum number of\r\noperations you can do without creating an element greater than m. After\r\nsome thought, you decided to propose the following problem, named :\r\nGiven n and m. For each k=0,1,\r\nldots,\r\nleft\r\nlfloor\r\nfrac{n-1}{2}\r\nright\r\nrfloor, please find the number of integer sequences a_1,a_2,\r\nldots,a_n with elements in [1, m], such that when used as input for ,\r\nthe answer is k. As the answer can be very large, please print it modulo\r\n10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\u00a0// TODO: Dynamic ModInt\u00a0template<typename T>constexpr T power(T a, u64 b) {    T res {1};    for (; b != 0; b /= 2, a *= a) {        if (b % 2 == 1) {            res *= a;        }    }    return res;}\u00a0template<u32 P>constexpr u32 mulMod(u32 a, u32 b) {    return 1ULL * a * b % P;}\u00a0template<u64 P>constexpr u64 mulMod(u64 a, u64 b) {    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;    res %= P;    return res;}\u00a0template<typename U, U P>requires std::unsigned_integral<U>struct ModIntBase {public:    constexpr ModIntBase() : x {0} {}        template<typename T>    requires std::integral<T>    constexpr ModIntBase(T x_) : x {norm(x_ % T {P})} {}        constexpr static U norm(U x) {        if ((x >> (8 * sizeof(U) - 1) & 1) == 1) {            x += P;        }        if (x >= P) {            x -= P;        }        return x;    }        constexpr U val() const {        return x;    }        constexpr ModIntBase operator-() const {        ModIntBase res;        res.x = norm(P - x);        return res;    }        constexpr ModIntBase inv() const {        return power(*this, P - 2);    }        constexpr ModIntBase &operator*=(const ModIntBase &rhs) & {        x = mulMod<P>(x, rhs.val());        return *this;    }        constexpr ModIntBase &operator+=(const ModIntBase &rhs) & {        x = norm(x + rhs.x);        return *this;    }        constexpr ModIntBase &operator-=(const ModIntBase &rhs) & {        x = norm(x - rhs.x);        return *this;    }        constexpr ModIntBase &operator/=(const ModIntBase &rhs) & {        return *this *= rhs.inv();    }        friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &rhs) {        lhs *= rhs;        return lhs;    }        friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &rhs) {        lhs += rhs;        return lhs;    }        friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &rhs) {        lhs -= rhs;        return lhs;    }        friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &rhs) {        lhs /= rhs;        return lhs;    }        friend constexpr std::ostream &operator<<(std::ostream &os, const ModIntBase &a) {        return os << a.val();    }        friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() == rhs.val();    }        friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() != rhs.val();    }        friend constexpr bool operator<(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() < rhs.val();    }    private:    U x;};\u00a0template<u32 P>using ModInt = ModIntBase<u32, P>;\u00a0template<u64 P>using ModInt64 = ModIntBase<u64, P>;\u00a0constexpr u32 P = 1000000007;using Z = ModInt<P>;\u00a0\u00a0constexpr int N = 130;constexpr int M = 30;\u00a0Z dp[M + 1][N + 1][N / 2 + 1];Z sum[M + 1][N + 1];\u00a0void solve() {    int n, m;    std::cin >> n >> m;        for (int k = 0; k <= (n - 1) / 2; k++) {        std::cout << dp[m][n][k] << \" \\n\"[k == (n - 1) / 2];    }}int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        dp[0][0][0] = 1;    sum[0][0] = 1;    for (int m = 1; m <= M; m++) {        Z fl[N + 1][N + 1][N + 1];        Z fr[N + 1][N + 1][N + 1];        for (int a = 0; a <= N; a++) {            for (int b = 0; b <= a / 2; b++) {                fl[a][0][a - 2 * b] += dp[m - 1][a][b];                fr[a][0][a] += dp[m - 1][a][b];            }        }        for (int n = 0; n <= N; n++) {            for (int c = 0; c <= n; c++) {                for (int l = 0; l <= n; l++) {                    if (fl[n][c][l] == 0) {                        continue;                    }                    int nc = c + (l == 0 ? 0 : (l - 1) % 2 + 1);                    dp[m][n][(n - nc) / 2] += fl[n][c][l];                }                for (int a = 0; n + a < N; a++) {                    int nn = n + 1 + a;                    Z p[2], q[2];                    for (int l = 0; l <= n; l++) {                        if (fl[n][c][l] != 0) {                            int nc = c + 1;                            int nr;                            if (l <= a) {                                nr = a - l;                            } else {                                nc++;                                int v = std::min((l - 1) % 2, a);                                nr = a - v;                                if ((l - v) % 2 == 0) {                                    nc++;                                }                            }                            // for (int b = 0; b <= a / 2; b++) {                            //     fr[nn][nc][nr] += fl[n][c][l] * dp[m - 1][a][b];                            // }                            fr[nn][nc][nr] += fl[n][c][l] * sum[m - 1][a];                        }                    }                    for (int r = 0; r <= a; r++) {                        if (fr[n][c][r] != 0) {                            int nc = c + 1;                            for (int b = 0; b <= a / 2; b++) {                                int nl = a - r;                                nl -= 2 * std::min(nl / 2, b);                                fl[nn][nc][nl] += fr[n][c][r] * dp[m - 1][a][b];                            }                        }                    }                    for (int i = 0; i <= a; i++) {                        p[i % 2] += fl[n][c][i] - fr[n][c][i];                    }                    for (int i = a + 1; i <= n; i++) {                        q[i % 2] += fl[n][c][i];                    }                    for (int t = 0; t <= 1; t++) {                        if (p[t] != 0) {                            int u = a;                            if ((u - t) % 2 != 0) {                                u--;                            }                            assert(u >= 0);                            int nc = c + 1;                            int nl = a - u;                            fl[nn][nc][nl] += p[t] * sum[m - 1][a];                        }                        if (q[t] != 0) {                            int nc = c + 2;                            int u = a;                            if (u > 0 && (u - t) % 2 == 0) {                                u--;                            }                            if ((u - t) % 2 == 0) {                                nc++;                            }                            int nl = a - u;                            fl[nn][nc][nl] += q[t] * sum[m - 1][a];                        }                    }                }                // for (int l = 0; l <= n; l++) {                //     for (int r = l; r <= n; r += 2) {                //         if (f[n][c][l][r] == 0) {                //             continue;                //         }                //         assert((r - l) % 2 == 0);                //         int nc = c + (l == 0 ? 0 : (l - 1) % 2 + 1);                //         assert((n - nc) % 2 == 0);                //         dp[m][n][(n - nc) / 2] += f[n][c][l][r];                //         for (int a = 0; n + a < N; a++) {                //             int nn = n + 1 + a;                //             int nc;                //             int nl;                //             int nr;                //             if (l > a) {                //                 int u = a;                //                 if (u > 0 && (l - u) % 2 == 0) {                //                     u--;                    //                 }                //                 nc = c + 1;                //                 if ((l - u) % 2 == 0) {                //                     nc++;                //                 }                //                 int v = std::min((l - 1) % 2, a);                //                 assert((u - v) % 2 == 0);                //                 nl = a - u;                //                 nr = a - v;                //             } else if (r <= a) {                //                 nc = c;                //                 nr = a - l;                //                 nl = a - r;                //             } else {                //                 int u = a;                //                 if ((r - u) % 2 != 0) {                //                     u--;                //                 }                //                 nc = c;                //                 nr = a - l;                //                 nl = a - u;                //             }                //             nc++;                //             for (int b = 0; b <= a / 2; b++) {                //                 int nnl = nl - 2 * std::min(nl / 2, b);                //                 f[nn][nc][nnl][nr] += f[n][c][l][r] * dp[m - 1][a][b];                //             }                //         }                //     }                // }            }        }        for (int n = 0; n <= N; n++) {            for (int k = 0; k <= n / 2; k++) {                sum[m][n] += dp[m][n][k];            }        }    }        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Counting 101.json"
}