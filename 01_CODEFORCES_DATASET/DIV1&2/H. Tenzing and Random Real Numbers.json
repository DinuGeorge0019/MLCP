{"link": "https://codeforces.com//contest/1842/problem/H", "problemId": "1978972", "problem_idx": "H", "shortId": "1842H", "contest_number": "1842", "problem_submissions": {"H": [210909272, 210915649, 210920105, 210920155, 210922877, 210917228, 210922837, 210930795, 210943236, 210937664, 210940497, 210923705, 210946319, 210934622, 210945105, 210899880, 210946698, 210939780, 210945932], "F": [210904139, 210906080, 210912565, 210912372, 210898025, 210899929, 210907320, 210916813, 210914105, 210920055, 210921458, 210913885, 210930158, 210926455, 210915591, 210926376, 210920616, 210915480, 210926627], "E": [210900474, 210894310, 210898608, 210904065, 210915135, 210928274, 210898671, 210908613, 210902774, 210908660, 210907798, 210940198, 210905531, 210907005, 210910569, 210945488, 210908738, 210905745, 210907496], "D": [210896488, 210888362, 210895704, 210886302, 210889254, 210887549, 210895428, 210893212, 210903157, 210896694, 210890657, 210891182, 210892762, 210896576, 210915222, 210891979, 210892349, 210897573], "G": [210891898, 210900879, 210908657, 210918356, 210923373, 210939093, 210921066, 210918175, 210911260, 210924814, 210932494, 210913130, 210941401, 210927457, 210933616, 210927314, 210931000, 210936010], "C": [210877958, 210881836, 210878997, 210877037, 210879744, 210878770, 210882382, 210884108, 210887371, 210884900, 210892630, 210896219, 210883482, 210884636, 210910637, 210882729, 210933971, 210885406], "A": [210875095, 210875812, 210874424, 210888796, 210874470, 210876122, 210874664, 210877287, 210875659, 210882217, 210874539, 210875197, 210874805, 210874426, 210902716, 210874934, 210945780, 210885821], "B": [210874375, 210878347, 210876059, 210890061, 210876166, 210875757, 210877955, 210879984, 210877325, 210880724, 210876899, 210877184, 210877441, 210885377, 210916237, 210877578, 210940672, 210885692], "I": [210953525, 211184344, 211107115]}, "name": "H. Tenzing and Random Real Numbers", "statement": "There are n uniform random real variables between 0 and 1, inclusive,\r\nwhich are denoted as x_1, x_2,\r\nldots, x_n.Tenzing has m conditions. Each condition has the form of\r\nx_i+x_j\r\nle 1 or x_i+x_j\r\nge 1.Tenzing wants to know the probability that all the conditions are\r\nsatisfied, modulo 998\u00a0244\u00a0353.Formally, let M = 998\u00a0244\u00a0353. It can be\r\nshown that the answer can be expressed as an irreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, output the integer x that 0\r\nle x < M and x\r\ncdot q\r\nequiv p\r\npmod{M}.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 24.06.2023 10:56:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> m0(n);\n  vector<int> m1(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, w;\n    cin >> w >> x >> y;\n    --x; --y;\n    if (w == 0) {\n      m0[x] |= (1 << y);\n      m0[y] |= (1 << x);\n    } else {\n      m1[x] |= (1 << y);\n      m1[y] |= (1 << x);\n    }\n  }\n  vector<Mint> dp(1 << n);\n  dp[0] = 1;\n  for (int t = 0; t < (1 << n); t++) {\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int nt = t | (1 << i);\n      int v0 = m0[i] & nt;\n      int v1 = m1[i] & nt;\n      int ways = (int) (v0 == 0) + (int) (v1 == 0);\n      dp[nt] += dp[t] * ways;\n    }\n  }\n  Mint ans = dp.back();\n  for (int i = 1; i <= n; i++) {\n    ans /= 2 * i;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dp", "graphs", "math", "probabilities"], "dificulty": "3000", "interactive": false}