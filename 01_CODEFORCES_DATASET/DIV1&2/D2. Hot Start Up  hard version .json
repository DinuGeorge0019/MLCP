{
    "link": "https://codeforces.com//contest/1799/problem/D2",
    "problemId": "1800601",
    "problem_idx": "D2",
    "shortId": "1799D2",
    "contest_number": "1799",
    "problem_submissions": {
        "H": [
            195172140,
            195179948,
            195176943,
            195177627,
            195177612,
            195187046,
            195170243,
            195186163,
            195181900,
            195178648,
            195187740,
            195188641,
            195181162,
            195197683,
            195197622,
            195197452,
            195197330,
            195195992,
            195195702,
            195195592,
            195189428,
            222390709,
            195183885,
            195192378
        ],
        "G": [
            195165805,
            195168765,
            195163877,
            195170080,
            195166062,
            195173874,
            195159286,
            195167233,
            195175284,
            195171112,
            195175174,
            195176292,
            195166497,
            195167039,
            195174540,
            195165113,
            195172643,
            195174992,
            195179660
        ],
        "F": [
            195162556,
            195161415,
            195167047,
            195167029,
            195169902,
            195165660,
            195176867,
            195177074,
            195171218,
            195182224,
            195179445,
            195181473,
            195185750,
            195200279,
            195171757,
            195192151,
            195177698,
            195192345,
            195178905,
            195177004
        ],
        "E": [
            195155464,
            195155926,
            195160608,
            195157188,
            195161547,
            195155405,
            195184653,
            195161068,
            195166323,
            195173130,
            195168387,
            195173064,
            195218892,
            195198896,
            195162114,
            195161002,
            195160161,
            195165268,
            195163227,
            195160677
        ],
        "D2": [
            195149687,
            195148531,
            195151569,
            195149401,
            195152435,
            195149320,
            195159443,
            195154372,
            195157592,
            195155987,
            195161428,
            195244200,
            195161041,
            195153968,
            195155870,
            195151311,
            195155278,
            195159787,
            195153371,
            195151855
        ],
        "D1": [
            195149644,
            195148457,
            195150430,
            195149466,
            195152497,
            195149250,
            195150661,
            195154425,
            195157658,
            195153741,
            195161504,
            195150409,
            195152774,
            195155970,
            195151278,
            195153482,
            195159732,
            195149352,
            195149899
        ],
        "C": [
            195146230,
            195145019,
            195147190,
            195145539,
            195148295,
            195145217,
            195148636,
            195146815,
            195151203,
            195151265,
            195151601,
            195146561,
            195147507,
            195149080,
            195145370,
            195151542,
            195158458,
            195147153,
            195147120
        ],
        "B": [
            195140902,
            195141064,
            195140888,
            195140956,
            195140810,
            195141011,
            195142268,
            195146249,
            195143844,
            195142681,
            195143326,
            195142296,
            195140849,
            195142634,
            195140165,
            195142125,
            195141309,
            195141669,
            195140680
        ],
        "A": [
            195139293,
            195139594,
            195139424,
            195139401,
            195139388,
            195139558,
            195139905,
            195143164,
            195139695,
            195139287,
            195140212,
            195139506,
            195139370,
            195139520,
            195139228,
            195140320,
            195142809,
            195139497,
            195139286
        ]
    },
    "name": "D2. Hot Start Up  hard version ",
    "statement": "You have a device with two CPUs. You also have k programs, numbered 1\r\nthrough k, that you can run on the CPUs. The i-th program (1\r\nle i\r\nle k) takes cold_i seconds to run on some CPU. However, if the last\r\nprogram we ran on this CPU was also program i, it only takes hot_i\r\nseconds (hot_i\r\nle cold_i). Note that this only applies if we run program i multiple\r\ntimes consecutively if we run program i, then some different program,\r\nthen program i again, it will take cold_i seconds the second time.You\r\nare given a sequence a_1, a_2,\r\nldots, a_n of length n, consisting of integers from 1 to k. You need to\r\nuse your device to run programs a_1, a_2,\r\nldots, a_n in sequence. For all 2\r\nle i\r\nle n, you cannot start running program a_i until program a_{i - 1} has\r\ncompleted.Find the minimum amount of time needed to run all programs\r\na_1, a_2,\r\nldots, a_n in sequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 1E18;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> cold(k + 1), hot(k + 1), profit(k + 1);\n    i64 sum = 0;\n    for (int i = 1; i <= k; i++) {\n        std::cin >> cold[i];\n    }\n    for (int i = 1; i <= k; i++) {\n        std::cin >> hot[i];\n        profit[i] = cold[i] - hot[i];\n    }\n    for (int i = 0; i < n; i++) {\n        sum += cold[a[i]];\n    }\n    \n    std::vector<i64> dp(k + 1, -inf);\n    dp[0] = 0;\n    \n    i64 max = 0;\n    i64 add = 0;\n    \n    for (int i = 1; i < n; i++) {\n        i64 val = std::max(max, dp[a[i]] + add + profit[a[i]]);\n        \n        if (a[i] == a[i - 1]) {\n            max += profit[a[i]];\n            add += profit[a[i]];\n        }\n        \n        dp[a[i - 1]] = std::max(dp[a[i - 1]], val - add);\n        max = std::max(max, val);\n    }\n    \n    i64 ans = sum - max;\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D2. Hot Start Up  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/113321",
    "editorial": "Consider maintaining the following 2-dimensional DP: will be the minimum\r\ntime needed to run all previous programs such that the last program run\r\non CPU 1 was program , and the last program run on CPU 2 was program .\r\nInitially we have (here, is a placeholder program) and for . When we\r\ncome to a program , we can transition as follows. First, create a new DP\r\narray , initialized to all . Then: For all with , set . For all , set .\r\nFor all with , set . For all , set . After all updates, replace with\r\n.This works in . To optimize it, we can notice that after processing a\r\nprogram , only entries in with the row or column equal to will be non-.\r\nConsider instead the following 1-dimensional DP array: contains the\r\nminimum time to run previous programs if one CPU last ran program , and\r\nthe other last ran program . Initially, and all other . Also, we add a\r\ndummy program with ID , and (this will make implementation easier).When\r\nwe come to a program , again, letâs create a new DP array , again\r\ninitialized to all . Then, we can case on whether the previous program\r\nwas equal to . If the last program run was also : For all , set . For\r\nall , set . Set . Otherwise, let be the last program run. For all , set\r\n. For all , set . Set . This gets us a solution which gets accepted in\r\nthe easy version.To optimize it further, we can use a data structure to\r\nperform updates (since with each transition we either add some value to\r\nevery element, or add some value to a single index). It is possible to\r\ndo this in constant time per update, or using a segment tree or some\r\nother range update structure (though this is somewhat overkill). The\r\noverall complexity then becomes or per test.\r\n",
    "hint": []
}