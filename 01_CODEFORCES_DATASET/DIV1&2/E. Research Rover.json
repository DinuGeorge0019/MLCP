{"link": "https://codeforces.com//contest/722/problem/E", "problemId": "74003", "problem_idx": "E", "shortId": "722E", "contest_number": "722", "problem_submissions": {"F": [21091512, 21085594, 21089803, 21092021, 21091925, 21091406, 21083741, 21089867, 21089611, 21086397, 21088088, 21089823, 21086418, 21090125, 21089647, 21089044, 21089230, 21089273], "E": [21088023, 21107688, 21106067, 21087044, 21088852, 21116611, 21251507, 21091238, 21126451], "D": [21080172, 21076258, 21078404, 21076583, 21076470, 21078997, 21077617, 21080800, 21077359, 21076406, 21076609, 21078412, 21075627, 21078861, 21077229, 21077815, 21082146, 21079311, 21080176, 21080301], "C": [21074766, 21074143, 21079601, 21075184, 21074110, 21076772, 21073504, 21077447, 21074819, 21079500, 21074909, 21079654, 21072018, 21074306, 21075294, 21074312, 21076102, 21076830, 21075898, 21075171], "A": [21071362, 21070972, 21070997, 21070865, 21070901, 21080897, 21070869, 21071371, 21070926, 21071044, 21070971, 21074578, 21078981, 21070900, 21072665, 21071359, 21071666, 21071148, 21070986, 21070908], "B": [21071955, 21071959, 21071961, 21072182, 21071953, 21073607, 21072621, 21072656, 21072545, 21073995, 21077019, 21071668, 21072069, 21072511, 21073331, 21073657, 21072159, 21071949]}, "name": "E. Research Rover", "statement": "Research rover finally reached the surface of Mars and is ready to\r\ncomplete its mission. Unfortunately, due to the mistake in the\r\nnavigation system design, the rover is located in the wrong place.The\r\nrover will operate on the grid consisting of rows and columns. We will\r\ndefine as the cell located in the row and column . From each cell the\r\nrover is able to move to any cell that share a side with the current\r\none.The rover is currently located at cell and has to move to the cell .\r\nIt will randomly follow some between these two cells. Each possible way\r\nis chosen equiprobably.The cargo section of the rover contains the\r\nbattery required to conduct the research. Initially, the battery charge\r\nis equal to units of energy.Some of the cells contain anomaly. Each time\r\nthe rover gets to the cell with anomaly, the battery looses half of its\r\ncharge rounded down. Formally, if the charge was equal to before the\r\nrover gets to the cell with anomaly, the charge will change to .While\r\nthe rover picks a random shortest path to proceed, compute the expected\r\nvalue of the battery charge after it reaches cell . If the cells and\r\ncontain anomaly, they also affect the charge of the battery.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint N, M, K, S;\nint fact[200001];\nint ifact[200001];\n\nint powmod(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nint C(int n, int k)\n{\n    return 1LL*fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nint ways(int n, int m)\n{\n    return C(n+m, n);\n}\n\npair<int, int> A[2000];\nint X[2000];\nint Y[2000];\nint dp[2000][22];\nint ans[22];\n\nvoid addmod(int& x, int v)\n{\n    x+=v;\n    if(x>=MOD)\n        x-=MOD;\n}\n\nvoid submod(int& x, int v)\n{\n    addmod(x, MOD-v);\n}\n\nint main()\n{\n    fact[0]=1;\n    for(int i=1; i<=200000; i++)\n        fact[i]=1LL*fact[i-1]*i%MOD;\n    for(int i=0; i<=200000; i++)\n        ifact[i]=powmod(fact[i], MOD-2);\n    scanf(\"%d%d%d%d\", &N, &M, &K, &S);\n    for(int i=0; i<K; i++)\n        scanf(\"%d%d\", &A[i].first, &A[i].second), A[i].first--, A[i].second--;\n    sort(A, A+K);\n    for(int i=0; i<K; i++)\n        tie(X[i], Y[i])=A[i];\n    for(int i=0; i<K; i++) for(int x=1; x<=21; x++)\n    {\n        dp[i][x]=ways(X[i], Y[i]);\n        for(int j=0; j<i; j++) if(X[j]<=X[i] && Y[j]<=Y[i])\n            submod(dp[i][x], 1LL*dp[j][x]*ways(X[i]-X[j], Y[i]-Y[j])%MOD);\n        for(int j=0; j<x; j++)\n            submod(dp[i][x], dp[i][j]);\n    }\n    for(int x=0; x<=20; x++)\n    {\n        ans[x]=ways(N-1, M-1);\n        for(int i=0; i<K; i++)\n            submod(ans[x], 1LL*dp[i][x+1]*ways(N-1-X[i], M-1-Y[i])%MOD);\n        for(int i=0; i<x; i++)\n            submod(ans[x], ans[i]);\n    }\n    int tot=ways(N-1, M-1);\n    int rans=0;\n    for(int i=0; i<=20; i++)\n    {\n        submod(tot, ans[i]);\n        addmod(rans, 1LL*S*ans[i]%MOD);\n        S-=S/2;\n    }\n    addmod(rans, tot);\n    rans=1LL*rans*powmod(ways(N-1, M-1), MOD-2)%MOD;\n    printf(\"%d\\n\", rans);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2900", "interactive": false}