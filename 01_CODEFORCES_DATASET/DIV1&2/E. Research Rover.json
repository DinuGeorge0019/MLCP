{
    "link": "https://codeforces.com//contest/722/problem/E",
    "problemId": "74003",
    "problem_idx": "E",
    "shortId": "722E",
    "contest_number": "722",
    "problem_submissions": {
        "F": [
            21091512,
            21085594,
            21089803,
            21092021,
            21091925,
            21091406,
            21083741,
            21089867,
            21089611,
            21086397,
            21088088,
            21089823,
            21086418,
            21090125,
            21089647,
            21089044,
            21089230,
            21089273
        ],
        "E": [
            21088023,
            21107688,
            21106067,
            21087044,
            21088852,
            21116611,
            21251507,
            21091238,
            21126451
        ],
        "D": [
            21080172,
            21076258,
            21078404,
            21076583,
            21076470,
            21078997,
            21077617,
            21080800,
            21077359,
            21076406,
            21076609,
            21078412,
            21075627,
            21078861,
            21077229,
            21077815,
            21082146,
            21079311,
            21080176,
            21080301
        ],
        "C": [
            21074766,
            21074143,
            21079601,
            21075184,
            21074110,
            21076772,
            21073504,
            21077447,
            21074819,
            21079500,
            21074909,
            21079654,
            21072018,
            21074306,
            21075294,
            21074312,
            21076102,
            21076830,
            21075898,
            21075171
        ],
        "A": [
            21071362,
            21070972,
            21070997,
            21070865,
            21070901,
            21080897,
            21070869,
            21071371,
            21070926,
            21071044,
            21070971,
            21074578,
            21078981,
            21070900,
            21072665,
            21071359,
            21071666,
            21071148,
            21070986,
            21070908
        ],
        "B": [
            21071955,
            21071959,
            21071961,
            21072182,
            21071953,
            21073607,
            21072621,
            21072656,
            21072545,
            21073995,
            21077019,
            21071668,
            21072069,
            21072511,
            21073331,
            21073657,
            21072159,
            21071949
        ]
    },
    "name": "E. Research Rover",
    "statement": "Research rover finally reached the surface of Mars and is ready to\r\ncomplete its mission. Unfortunately, due to the mistake in the\r\nnavigation system design, the rover is located in the wrong place.The\r\nrover will operate on the grid consisting of rows and columns. We will\r\ndefine as the cell located in the row and column . From each cell the\r\nrover is able to move to any cell that share a side with the current\r\none.The rover is currently located at cell and has to move to the cell .\r\nIt will randomly follow some between these two cells. Each possible way\r\nis chosen equiprobably.The cargo section of the rover contains the\r\nbattery required to conduct the research. Initially, the battery charge\r\nis equal to units of energy.Some of the cells contain anomaly. Each time\r\nthe rover gets to the cell with anomaly, the battery looses half of its\r\ncharge rounded down. Formally, if the charge was equal to before the\r\nrover gets to the cell with anomaly, the charge will change to .While\r\nthe rover picks a random shortest path to proceed, compute the expected\r\nvalue of the battery charge after it reaches cell . If the cells and\r\ncontain anomaly, they also affect the charge of the battery.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint N, M, K, S;\nint fact[200001];\nint ifact[200001];\n\nint powmod(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nint C(int n, int k)\n{\n    return 1LL*fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nint ways(int n, int m)\n{\n    return C(n+m, n);\n}\n\npair<int, int> A[2000];\nint X[2000];\nint Y[2000];\nint dp[2000][22];\nint ans[22];\n\nvoid addmod(int& x, int v)\n{\n    x+=v;\n    if(x>=MOD)\n        x-=MOD;\n}\n\nvoid submod(int& x, int v)\n{\n    addmod(x, MOD-v);\n}\n\nint main()\n{\n    fact[0]=1;\n    for(int i=1; i<=200000; i++)\n        fact[i]=1LL*fact[i-1]*i%MOD;\n    for(int i=0; i<=200000; i++)\n        ifact[i]=powmod(fact[i], MOD-2);\n    scanf(\"%d%d%d%d\", &N, &M, &K, &S);\n    for(int i=0; i<K; i++)\n        scanf(\"%d%d\", &A[i].first, &A[i].second), A[i].first--, A[i].second--;\n    sort(A, A+K);\n    for(int i=0; i<K; i++)\n        tie(X[i], Y[i])=A[i];\n    for(int i=0; i<K; i++) for(int x=1; x<=21; x++)\n    {\n        dp[i][x]=ways(X[i], Y[i]);\n        for(int j=0; j<i; j++) if(X[j]<=X[i] && Y[j]<=Y[i])\n            submod(dp[i][x], 1LL*dp[j][x]*ways(X[i]-X[j], Y[i]-Y[j])%MOD);\n        for(int j=0; j<x; j++)\n            submod(dp[i][x], dp[i][j]);\n    }\n    for(int x=0; x<=20; x++)\n    {\n        ans[x]=ways(N-1, M-1);\n        for(int i=0; i<K; i++)\n            submod(ans[x], 1LL*dp[i][x+1]*ways(N-1-X[i], M-1-Y[i])%MOD);\n        for(int i=0; i<x; i++)\n            submod(ans[x], ans[i]);\n    }\n    int tot=ways(N-1, M-1);\n    int rans=0;\n    for(int i=0; i<=20; i++)\n    {\n        submod(tot, ans[i]);\n        addmod(rans, 1LL*S*ans[i]%MOD);\n        S-=S/2;\n    }\n    addmod(rans, tot);\n    rans=1LL*rans*powmod(ways(N-1, M-1), MOD-2)%MOD;\n    printf(\"%d\\n\", rans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Research Rover.json",
    "editorial_link": "https://codeforces.com//blog/entry/47497",
    "editorial": "Several auxiliary statements: The number of paths between cells with\r\ncoordinates and , for which and , is equal to . In order to get the\r\nanswer it is not necessary to find irreducible fraction . Suppose that\r\nwe have found some fraction , for which the following is true: , . Let\u00e2\u0080\u0099s\r\ncalculate the answer for this fraction: . From the second statement it\r\nimplies that the answer can be found in the following form: is equal to\r\nthe number of paths between cells and , and is equal to the sum of the\r\nbattery charges in the endpoint among all paths.The battery charge in\r\nthe endpoint does not depend on the order of visit of the anomalies, but\r\nonly on the number of anomalies on the path. Then in order to calculate\r\nthe required sum it is enough to count the number of paths that pass\r\nthrough the and so on anomalies. Note that since the original battery\r\ncharge does not exceed , and each time you visit the anomaly it is\r\nreduced by half, then in all paths, with the number of anomalies greater\r\nthan or equal to , the charge at the endpoint will be equal to .First\r\nlet\u00e2\u0080\u0099s try to solve a simpler problem: count the number of paths that do\r\nnot pass through the cells with anomalies. Sort all the cells with\r\nanomalies in increasing order of the sum of their coordinates. Then, if\r\nthe path passes through the anomaly with the number (in sorted order),\r\nthen the next cell with anomaly on the path can only be the cell with\r\nthe number greater than .We calculate the following dynamic: - number of\r\npaths which start in the anomaly with the number , end in the cell and\r\ndon\u00e2\u0080\u0099t pass through other anomalies.Let\u00e2\u0080\u0099s denote as the following value:\r\nif and otherwise. Values of can be calculated using the following\r\nformula: .Every path that passes through at least one anomaly different\r\nfrom the -th, will be subtracted from the total number of paths exactly\r\nonce - when the is equal to the number of the last anomaly on this\r\npath.Let\u00e2\u0080\u0099s go back to the original problem: denote as the number of\r\npaths which start in the anomaly with the number , end in the cell and\r\npass through exactly anomalies different from -th.For , .For , values of\r\ncan be calculated using the following formula: .Every path that passes\r\nthrough at least anomalies different from the -th, will be subtracted\r\nfrom the total number of paths exactly once - when the is equal to the\r\nnumber of -th anomaly from the end on this path. It remains only to\r\nsubtract all paths that contains less than anomalies (last part of the\r\nformula).For simplicity, you can add an additional anomaly with\r\ncoordinates .In the end, let\u00e2\u0080\u0099s iterate over the number of anomalies\r\n(from to ) on the path. For each number, we can find the value of the\r\nbattery charge in the endpoint and multiply it by the number of paths\r\ncalculated above. Also, add one to the sum for each path that visits or\r\nmore anomalies.The resulting complexity of the solution is .\r\n"
}