{
    "link": "https://codeforces.com//contest/794/problem/E",
    "problemId": "106234",
    "problem_idx": "E",
    "shortId": "794E",
    "contest_number": "794",
    "problem_submissions": {
        "F": [
            27081873,
            27083526,
            27083046,
            27085017,
            27081983,
            27082510,
            27086006,
            27083949,
            27080179,
            27086715,
            27082966,
            27079645,
            27084337,
            27084766,
            27081869,
            27081966,
            27084662
        ],
        "E": [
            27079377,
            27080585,
            27080375,
            27082137,
            27084820,
            27086075,
            27082614,
            27085336,
            27086070,
            27082160,
            27085721,
            27085903,
            27085376,
            27087205,
            27084980,
            27082950,
            27083172,
            27085134
        ],
        "D": [
            27077745,
            27078665,
            27078681,
            27079267,
            27079635,
            27079737,
            27080740,
            27079081,
            27083788,
            27079987,
            27082339,
            27082247,
            27082529,
            27080107,
            27094240,
            27094236,
            27094226,
            27094219,
            27094212,
            27094182,
            27094168,
            27094131,
            27094066,
            27080763,
            27081677,
            27089971,
            27089903,
            27087542,
            27080778
        ],
        "C": [
            27075178,
            27076116,
            27076013,
            27076437,
            27076459,
            27075605,
            27076203,
            27075986,
            27076793,
            27077625,
            27078065,
            27084041,
            27076700,
            27077790,
            27078769,
            27077244,
            27075390,
            27082931,
            27077078
        ],
        "B": [
            27072873,
            27073613,
            27072949,
            27073965,
            27073074,
            27073568,
            27073477,
            27073304,
            27073689,
            27073228,
            27073014,
            27073894,
            27072703,
            27074273,
            27072442,
            27074226,
            27073723,
            27073830,
            27073779
        ],
        "A": [
            27072392,
            27072471,
            27072465,
            27072459,
            27072555,
            27072760,
            27072661,
            27072604,
            27072817,
            27072481,
            27072447,
            27072409,
            27072476,
            27072463,
            27072773,
            27072976,
            27072422,
            27074544,
            27072598
        ],
        "G": [
            27216394,
            27227867
        ]
    },
    "name": "E. Choosing Carrot",
    "statement": "Oleg the bank client and Igor the analyst are arguing again. This time,\r\nthey want to pick a gift as a present for their friend, ZS the coder.\r\nAfter a long thought, they decided that their friend loves to eat\r\ncarrots the most and thus they want to pick the best carrot as their\r\npresent.There are carrots arranged in a line. The -th carrot from the\r\nleft has juiciness . Oleg thinks ZS loves juicy carrots whereas Igor\r\nthinks that he hates juicy carrots. Thus, Oleg would like to maximize\r\nthe juiciness of the carrot they choose while Igor would like to\r\nminimize the juiciness of the carrot they choose.To settle this issue,\r\nthey decided to play a game again. Oleg and Igor take turns to play the\r\ngame. In each turn, a player can choose a carrot from either end of the\r\nline, and eat it. The game ends when only one carrot remains. Oleg moves\r\nfirst. The last remaining carrot will be the carrot that they will give\r\ntheir friend, ZS.Oleg is a sneaky bank client. When Igor goes to a\r\nrestroom, he performs moves before the start of the game. Each move is\r\nthe same as above (eat a carrot from either end of the line). After Igor\r\nreturns, they start the game with Oleg still going first. Oleg wonders:\r\nfor each such that , what is the juiciness of the carrot they will give\r\nto ZS if he makes extra moves beforehand and both players play\r\noptimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 700001;\n\nint a[MAXN];\n\nint ans;\n\nint a0[MAXN], a1[MAXN];\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\n\tint n;\n\tcin >> n;\n\tint m = 2 * n - 2;\n\tans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i * 2];\n\t\tans = max(ans, a[i * 2]);\n\t}\n\tmemset(a0, 0, sizeof(a0));\n\tmemset(a1, 0, sizeof(a1));\n\tfor (int i = 1; i < m; i += 2) a0[i] = max(a[i - 1], a[i + 1]);\n\tfor (int i = 2; i < m; i += 2) a1[i] = max(min(a[i - 2], a[i]), min(a[i], a[i + 2]));\n\tint cur = m / 2, c0 = 0, c1 = 0;\n\tc0 = max(c0, a0[cur]);\n\tc1 = max(c1, a1[cur]);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tc0 = max(c0, max(a0[cur - i], a0[cur + i]));\n\t\tc1 = max(c1, max(a1[cur - i], a1[cur + i]));\n\t\tif ((n - i) & 1)\n\t\t\tcout << c1 << \" \";\n\t\telse\n\t\t\tcout << c0 << \" \";\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Choosing Carrot.json",
    "editorial_link": "https://codeforces.com/blog/entry/51962",
    "editorial": "First, we solve the problem when no one has any extra turns.\n\nSuppose we're binary searching the answer. Let all the numbers ???x be equal to 1 and all the numbers ?<?x be equal to 0. Both players can remove one number from one end of the row. The goal of the first player is to let the remaining number be 1 and the goal of the second player is to leave 0 in the end. If the first player can win, this means that the answer is at least x. Thus, we first try to solve this simpler problem.\n\nWe claim that the first player wins if and only if :\n\nn is even and one of the two middle numbers is 1.\n\nn is odd, the middle digit is 1 and at least one of the digits beside the middle digit is 1 (unless n?=?1, for which first players wins when the only carrot is labelled 1)\n\nIndeed, once we deduce this, we can easily prove this by induction on n. The proof is just doing casework and considering all possible moves.\n\nOnce we have this fact, we realize we don't actually have to binary search the answer. If n is even, the answer is  while if n???3 is odd, the answer is . (If n?=?1 then the answer is obviously a1.)\n\nNow, we have to take extra moves into account. Fortunately, it's not very difficult. Having k extra moves just means that Player 1 can choose to start the game in any subsegment of length n?-?k. Thus, we just have to compute the maximum answer for all subsegments of length n?-?k for all 0???k???n?-?1. With the formula above, you can find all the answers in O(n) time or even  time if you use sparse table for range maximum query."
}