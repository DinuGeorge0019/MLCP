{"link": "https://codeforces.com//contest/1864/problem/I", "problemId": "2181272", "problem_idx": "I", "shortId": "1864I", "contest_number": "1864", "problem_submissions": {"I": [220596748, 220625703, 220625365, 220625093], "H": [220568821, 220567695, 220569504, 220765807, 220735033, 220733694, 220582422, 220590968, 220584872, 220585832, 220586273, 220588653, 220869529, 220592706, 220587781, 220596085, 222139412, 220596294], "G": [220562227, 220575493, 220588511, 220576272, 220574639, 220576772, 220595506, 220568659, 220611309, 221223033, 220575904, 220585515, 220590419, 220591092, 220590354, 220590686], "F": [220551620, 220555802, 220557675, 220718976, 220558576, 220553574, 220558951, 220567707, 220555900, 220612295, 220564492, 220564273, 220565836, 220560759, 220571802, 220564441, 220571627, 220556155, 220556855, 220560337, 220568919, 220567748], "E": [220545674, 220547229, 220549551, 220553761, 220544098, 220550014, 220550285, 220550294, 220555536, 220557391, 220559164, 220553118, 220556990, 220555427, 220553548, 220549618, 220563369, 220552727, 220558630, 220553863], "D": [220537006, 220537255, 220535722, 220536129, 220534069, 220542850, 220539341, 220538198, 220541287, 220542463, 220545447, 220548373, 220544205, 220540271, 220536187, 220541552, 220541368, 220545083, 220544975], "C": [220533606, 220528455, 220528101, 220528155, 220527489, 220537748, 220525134, 220530359, 220532079, 220533694, 220541070, 220542060, 220535618, 220533106, 220530771, 220535184, 220536493, 220534865, 220537384], "B": [220524699, 220524727, 220525716, 220524082, 220524572, 220524039, 220522756, 220522640, 220528173, 220525137, 220528062, 220531552, 220524275, 220526451, 220524531, 220529349, 220526226, 220525961, 220525118], "A": [220521618, 220521580, 220521747, 220521485, 220521753, 220521570, 220521442, 220521465, 220524365, 220521707, 220524695, 220522808, 220521703, 220522789, 220521679, 220521789, 220521663, 220522116, 220521966]}, "name": "I. Future Dominators", "statement": "Dhruvil and amenotiomoi are sitting in different countries and chatting\r\nonline. Initially, amenotiomoi has an empty board of size n\r\ntimes n, and Dhruvil has a sequence of integers 1, 2,\r\nldots, n^2, each number occurring exactly once. The numbers may be\r\nplaced in the cells of the board, each cell is either empty or contains\r\nexactly one number.The current state of the board is called , if there\r\nis a way of placing the remaining numbers in empty cells so that all\r\nnumbers except 1 have a neighbor with a smaller value. Two cells are\r\nneighbors if they share an edge.The rows are numbered from 1 to n from\r\ntop to bottom, the columns are numbered from 1 to n from left to right.\r\nThe cell at the intersection of the x-th row and the y-th column is\r\ndenoted as (x, y).To chat, amenotiomoi asks q queries to Dhruvil. Each\r\ntime he provides Dhruvil with an empty cell (x, y). Dhruvil has to place\r\none of the remaining numbers in this cell so that the board is still\r\ngood. Among all ways to do this, he chooses the largest possible number\r\nhe can place and sends this number to amenotiomoi as the answer to the\r\nquery.Since amenotiomoi knows the correct answer every time, he tells\r\nDhruvil (x\r\noplus k,y\r\noplus k) instead of (x, y), where k is the answer for the previous\r\nquery. If amenotiomoi is sending the first query, he considers k = 0.\r\nEach time Dhruvil has to decode the query and send the answer to\r\namenotiomoi. Here\r\noplus denotes the bitwise XOR operation.Help Dhruvil reply to all\r\namenotiomoi\u2019s queries.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\nconst int vax=nax*nax;\n\nint n, q;\n\nint k;\nint ojf[vax];\n\nint blok[nax][nax];\n\nint s;\nint spo[nax][nax];\nint rozmiar[vax];\n\nint r;\npii ujscie[vax];//ktore ujscie i ile razy je widzi\npii pozycja[vax];\npii przedzial[vax];\n\nvi kandy;\n\nint fin(int v)\n{\n\tif (v!=ojf[v])\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nint wsp_to_int(pii v)\n{\n\treturn v.first*(n+1)+v.second;\n}\n\nint wsp_to_int(int a, int b)\n{\n\treturn a*(n+1)+b;\n}\n\npii int_to_wsp(int v)\n{\n\treturn {v/(n+1), v%(n+1)};\n}\n\n//~ set<pii> krawedzie;\n\nvector<pii> graf[nax][nax];\n\npair<pii,pii> pola_dla_krawedzi(pii a, pii b)\n{\n\tif (a>b)\n\t\tswap(a, b);\n\tif (a.second+1==b.second)\n\t\treturn {b, {b.first+1, b.second}};\n\tif (a.first+1==b.first)\n\t\treturn {b, {b.first, b.second+1}};\n\tassert(0);\n}\n\ntemplate <typename T> void usun(vector<T> &wek, T v)\n{\n\t//~ debug() << \"z \" << wek << \" mam usunac \" << v;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tif (wek[i]==v)\n\t\t{\n\t\t\tswap(wek[i], wek.back());\n\t\t\twek.pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(0);\n}\n\ntemplate <typename T> bool zawiera(const vector<T> &wek, T v)\n{\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tif (wek[i]==v)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint czas;\nint bylo[nax][nax];\n\nvoid edge(pii a, pii b)\n{\n\tgraf[a.first][a.second].push_back(b);\n\tgraf[b.first][b.second].push_back(a);\n}\n\nvector<pii> lacz(pii a, pii b)\n{\n\tif (a>b)\n\t\tswap(a, b);\n\tauto wez=pola_dla_krawedzi(a, b);\n\tif (!zawiera(graf[wez.first.first][wez.first.second], wez.second))\n\t\treturn {};\n\t//~ krawedzie.insert({wsp_to_int(a), wsp_to_int(b)});\n\tint aa=wsp_to_int(a);\n\tint bb=wsp_to_int(b);\n\t//~ debug() << \"dla pul \" << wez;\n\tusun(graf[wez.first.first][wez.first.second], wez.second);\n\tusun(graf[wez.second.first][wez.second.second], wez.first);\n\tif (fin(aa)!=fin(bb))\n\t{\n\t\tuni(aa, bb);\n\t\treturn {};\n\t}\n\tuni(aa, bb);\n\t\n\tqueue<pii> kol[2];\n\tvector<pii> ret[2];\n\tkol[0].push(wez.first);\n\tkol[1].push(wez.second);\n\tczas++;\n\tbylo[wez.first.first][wez.first.second]=czas;\n\tbylo[wez.second.first][wez.second.second]=czas;\n\tfor (int h=0; 1; h^=1)\n\t{\n\t\tif (kol[h].empty())\n\t\t\treturn ret[h];\n\t\tpii v=kol[h].front();\n\t\tkol[h].pop();\n\t\tret[h].push_back(v);\n\t\tfor (pii i : graf[v.first][v.second])\n\t\t{\n\t\t\tif (bylo[i.first][i.second]<czas)\n\t\t\t{\n\t\t\t\tbylo[i.first][i.second]=czas;\n\t\t\t\tkol[h].push(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rx[]={-1, 1, 0, 0};\nint ry[]={0, 0, -1, 1};\n\nint solve(int a, int b)\n{\n\t//~ debug() << \"solve \" << imie(a) << imie(b);\n\tvector<pii> rogi;\n\trogi.push_back({a-1, b-1});\n\trogi.push_back({a-1, b});\n\trogi.push_back({a, b});\n\trogi.push_back({a, b-1});\n\tfor (int h=0; h<4; h++)\n\t{\n\t\tpii x=rogi[h];\n\t\tpii y=rogi[(h+1)%4];\n\t\tint kto=spo[a][b];\n\t\tauto wez=lacz(x, y);\n\t\tif (!wez.empty())\n\t\t{\n\t\t\tdebug() << imie(wez);\n\t\t\ts++;\n\t\t\trozmiar[s]=0;\n\t\t\tujscie[s]={ujscie[kto].first, 0};\n\t\t\tfor (pii i : wez)\n\t\t\t{\n\t\t\t\trozmiar[kto]--;\n\t\t\t\trozmiar[s]++;\n\t\t\t\tspo[i.first][i.second]=s;\n\t\t\t\tfor (int j=0; j<4; j++)\n\t\t\t\t{\n\t\t\t\t\tpii u={i.first+rx[j], i.second+ry[j]};\n\t\t\t\t\tif (u==pozycja[ujscie[s].first])\n\t\t\t\t\t{\n\t\t\t\t\t\tujscie[s].second++;\n\t\t\t\t\t\tujscie[kto].second--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//~ debug() << \"po laczeniu:\";\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ debug() << range(spo[i]+1, spo[i]+1+n);\n\tint ja=spo[a][b];\n\tblok[a][b]=1;\n\tvi dook;\n\tfor (int j=0; j<4; j++)\n\t{\n\t\tpii u={a+rx[j], b+ry[j]};\n\t\tif (!blok[u.first][u.second] && !zawiera(dook, spo[u.first][u.second]))\n\t\t\tdook.push_back(spo[u.first][u.second]);\n\t}\n\t//~ debug() << imie(ja) << \" \" << imie(dook);\n\tint jest_kandy=0;\n\tif (zawiera(kandy, ja))\n\t\tjest_kandy=ja;\n\tfor (int i : dook)\n\t\tif (zawiera(kandy, i))\n\t\t\tjest_kandy=i;\n\t\n\t//~ debug() << imie(jest_kandy) << imie(kandy);\n\tif (jest_kandy && (int)kandy.size()>1)\n\t{\n\t\tusun(kandy, jest_kandy);\n\t\tif ((int)kandy.size()==1)\n\t\t{\n\t\t\tint kto=kandy[0];\n\t\t\tujscie[kto]={0, 0};\n\t\t}\n\t\tjest_kandy=0;\n\t}\n\t\n\tif (!jest_kandy)\n\t{\n\t\tint uj=ujscie[spo[a][b]].first;\n\t\tvi musze;\n\t\tfor (int i : dook)\n\t\t\tif (ujscie[i].second==0)\n\t\t\t\tmusze.push_back(i);\n\t\tif (!musze.empty())\n\t\t{\n\t\t\tr++;\n\t\t\tpozycja[r]={a, b};\n\t\t\tint roz=0;\n\t\t\tfor (int i : musze)\n\t\t\t{\n\t\t\t\troz+=rozmiar[i];\n\t\t\t\tujscie[i]={r, 0};\n\t\t\t}\n\t\t\tfor (int j=0; j<4; j++)\n\t\t\t{\n\t\t\t\tpii u={a+rx[j], b+ry[j]};\n\t\t\t\tif (!blok[u.first][u.second] && zawiera(musze, spo[u.first][u.second]))\n\t\t\t\t\tujscie[spo[u.first][u.second]].second++;\n\t\t\t}\n\t\t\tprzedzial[r]={przedzial[uj].second-roz+1, przedzial[uj].second};\n\t\t\tprzedzial[uj].second-=roz+1;\n\t\t\treturn przedzial[r].first-1;\n\t\t}\n\t\tprzedzial[uj].second--;\n\t\treturn przedzial[uj].second+1;\n\t}\n\t\n\tint mini=0;\n\tint sroz=0;\n\tfor (int i : dook)\n\t{\n\t\tmini=max(mini, rozmiar[i]);\n\t\tsroz+=rozmiar[i];\n\t}\n\t\n\tassert(przedzial[0].second==sroz+1);\n\t\n\tint uj=ujscie[spo[a][b]].first;\n\t\n\tdebug() << imie(spo[a][b]);\n\tdebug() << imie(uj) << imie(przedzial[uj]);\n\t\n\tif ((int)dook.size()<=1)\n\t{\n\t\tprzedzial[uj].second--;\n\t\treturn przedzial[uj].second+1;\n\t}\n\t\n\tint przeznaczam=sroz-mini;\n\t\n\t\n\tdebug() << imie(sroz) << imie(mini);\n\t\n\tr++;\n\tpozycja[r]={a, b};\n\tint zwroc=przedzial[uj].second-przeznaczam;\n\tprzedzial[r]={przedzial[uj].second-przeznaczam+1, przedzial[uj].second};\n\tfor (int i : dook)\n\t\tujscie[i]={r, 0};\n\tfor (int j=0; j<4; j++)\n\t{\n\t\tpii u={a+rx[j], b+ry[j]};\n\t\tif (!blok[u.first][u.second] && zawiera(dook, spo[u.first][u.second]))\n\t\t\tujscie[spo[u.first][u.second]].second++;\n\t}\n\tprzedzial[0].second-=przeznaczam+1;\n\tfor (int i : dook)\n\t\tassert(ujscie[i].second);\n\tkandy.clear();\n\tfor (int i : dook)\n\t\tif (rozmiar[i]==mini)\n\t\t\tkandy.push_back(i);\n\tif ((int)kandy.size()==1)\n\t\tujscie[kandy[0]]={0, 0};\n\treturn zwroc;\n}\n\nvoid test()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tk=(n+1)*(n+1);\n\tfor (int i=0; i<k; i++)\n\t\tojf[i]=i;\n\t//~ krawedzie.clear();\n\tfor (int i=0; i<n; i++)\n\t{\n\t\t//~ krawedzie.insert({wsp_to_int(0, i), wsp_to_int(0, i+1)});\n\t\t//~ krawedzie.insert({wsp_to_int(n, i), wsp_to_int(n, i+1)});\n\t\t//~ krawedzie.insert({wsp_to_int(i, 0), wsp_to_int(i+1, 0)});\n\t\t//~ krawedzie.insert({wsp_to_int(i, n), wsp_to_int(i+1, n)});\n\t\tuni(wsp_to_int(0, i), wsp_to_int(0, i+1));\n\t\tuni(wsp_to_int(n, i), wsp_to_int(n, i+1));\n\t\tuni(wsp_to_int(i, 0), wsp_to_int(i+1, 0));\n\t\tuni(wsp_to_int(i, n), wsp_to_int(i+1, n));\n\t}\n\t//~ for (pii i : krawedzie)\n\t\t//~ uni(i.first, i.second);\n\t\n\tfor (int i=0; i<=n+1; i++)\n\t\tfor (int j=0; j<=n+1; j++)\n\t\t\tblok[i][j]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tblok[i][j]=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tgraf[i][j].clear();\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (j+1<=n)\n\t\t\t\tedge({i, j}, {i, j+1});\n\t\t\tif (i+1<=n)\n\t\t\t\tedge({i, j}, {i+1, j});\n\t\t}\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tbylo[i][j]=0;\n\tczas=0;\n\t\n\ts=1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tspo[i][j]=1;\n\trozmiar[s]=n*n;\n\tr=0;\n\tujscie[s]={0, 0};\n\tprzedzial[0]={1, n*n};\n\t\n\tkandy={1};\n\t\n\tint last=0;\n\twhile(q--)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta^=last;\n\t\tb^=last;\n\t\tlast=solve(a, b);\n\t\t//~ printf(\"%d\\n\", last);\n\t\t//~ fflush(stdout);\n\t\tprintf(\"%d \", last);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "greedy"], "dificulty": "3500", "interactive": false}