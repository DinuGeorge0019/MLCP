{"link": "https://codeforces.com//contest/1684/problem/F", "problemId": "1404376", "problem_idx": "F", "shortId": "1684F", "contest_number": "1684", "problem_submissions": {"H": [157720671, 157721062, 157737875, 157719283, 157728267, 157723148, 157726010, 157736069, 157792151, 157760208, 157735749, 157733310, 157739555, 157762123, 157758402, 157757414], "G": [157708800, 157705200, 157707312, 157718616, 157706754, 157714488, 157707640, 157712978, 157718288, 157710983, 157717212, 157716133, 157711996, 157713632, 157715613, 157714692, 157708417, 157712457, 157717126], "F": [157703000, 157698430, 157700853, 157708707, 157699813, 157705688, 157700819, 157704615, 157713662, 157705196, 157701872, 157704273, 157706345, 157707380, 157707253, 157706734, 157720973, 157723693, 157711135], "E": [157687824, 157689230, 157686803, 157694670, 157693301, 157693626, 157692297, 157688860, 157691406, 157698450, 157692770, 157697303, 157697857, 157695549, 157699844, 157698604, 157694457, 157697019, 157700499], "D": [157681158, 157683410, 157690778, 157683407, 157688074, 157688564, 157683855, 157682485, 157678956, 157684552, 157688505, 157689349, 157690936, 157696580, 157687171, 157693792, 157688577, 157691760, 157692016], "C": [157676125, 157679761, 157680827, 157678864, 157733908, 157680852, 157679175, 157675870, 157680982, 157722992, 157680866, 157688681, 157680491, 157680374, 157689989, 157710336, 157680413, 157683798], "B": [157669712, 157671031, 157673644, 157673851, 157673406, 157672145, 157673363, 157673187, 157671551, 157673379, 157675976, 157675416, 157675741, 157672916, 157673228, 157675698, 157678091, 157671319, 157673490], "A": [157669088, 157669275, 157669176, 157669141, 157669362, 157669203, 157669522, 157669224, 157669098, 157669297, 157671508, 157669642, 157676097, 157669933, 157669278, 157670146, 157669180, 157669153, 157669255]}, "name": "F. Diverse Segments", "statement": "You are given an array a of n integers. Also you are given m subsegments\r\nof that array. The left and the right endpoints of the j-th segment are\r\nl_j and r_j respectively.You are allowed to make operation. In that\r\noperation you choose any subsegment of the array a and replace each\r\nvalue on this segment with any integer (you are also allowed to keep\r\nelements the same).You have to apply this operation so that for the\r\ngiven m segments, the elements on each segment are distinct. More\r\nformally, for each 1\r\nle j\r\nle m all elements a_{l_{j}}, a_{l_{j}+1},\r\nldots, a_{r_{j}-1}, a_{r_{j}} should be distinct.You don\u2019t want to use\r\nthe operation on a big segment, so you have to find the smallest length\r\nof a segment, so that you can apply the operation to this segment and\r\nmeet the above-mentioned conditions. If it is not needed to use this\r\noperation, the answer is 0.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 19.05.2022 19:05:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    int mx = -1;\n\n    void apply(int l, int r, int v) {\n      mx = max(mx, v);\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> xs = a;\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    for (int i = 0; i < n; i++) {\n      a[i] = (int) (lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin());\n    }\n    vector<int> l(m), r(m);\n    for (int i = 0; i < m; i++) {\n      cin >> l[i] >> r[i];\n      --l[i]; --r[i];\n    }\n    const int inf = (int) 1e9;\n    int L = -1, R = -1;\n    for (int rot = 0; rot < 2; rot++) {\n      vector<int> last(n, -1);\n      vector<int> pred(n, -1);\n      for (int i = 0; i < n; i++) {\n        pred[i] = last[a[i]];\n        last[a[i]] = i;\n      }\n      segtree st(pred);\n      int mn = inf;\n      for (int i = 0; i < m; i++) {\n        int id = st.find_first(l[i], r[i], [&](const segtree::node& nd) {\n          return nd.mx >= l[i];\n        });\n        if (id != -1) {\n          mn = min(mn, id);\n        }\n      }\n      if (mn == inf) {\n        break;\n      }\n      if (rot == 0) {\n        L = mn;\n      } else {\n        R = n - 1 - mn;\n      }\n      reverse(a.begin(), a.end());\n      for (int i = 0; i < m; i++) {\n        swap(l[i], r[i]);\n        l[i] = n - 1 - l[i];\n        r[i] = n - 1 - r[i];\n      }\n    }\n    if (L == -1) {\n      cout << 0 << '\\n';\n      continue;\n    }\n    vector<int> lft(n, -1);\n    vector<int> rgt(n, -1);\n    for (int i = 0; i < L; i++) {\n      lft[a[i]] = i;\n    }\n    for (int i = n - 1; i > R; i--) {\n      rgt[a[i]] = i;\n    }\n    segtree st(n);\n    for (int i = 0; i < m; i++) {\n      st.modify(l[i], l[i], r[i]);\n    }\n    segtree sf(n);\n    for (int i = 0; i < n; i++) {\n      if (lft[i] != -1 && rgt[i] != -1 && lft[i] != rgt[i]) {\n        if (st.get(0, lft[i]).mx >= rgt[i]) {\n          sf.modify(lft[i], lft[i], rgt[i]);\n        }\n      }\n    }\n    int ans = n;\n    for (int from = 0; from <= L; from++) {\n      int to = R;\n      if (from > 0) {\n        to = max(to, sf.get(0, from - 1).mx);\n      }\n      ans = min(ans, to - from + 1);\n    }\n    ans = max(ans, 1);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "two pointers"], "dificulty": "2600", "interactive": false}