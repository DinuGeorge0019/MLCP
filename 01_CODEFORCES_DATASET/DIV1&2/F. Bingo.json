{"link": "https://codeforces.com//contest/1530/problem/F", "problemId": "1049173", "problem_idx": "F", "shortId": "1530F", "contest_number": "1530", "problem_submissions": {"H": [122851665, 122838743, 122844195, 122849012, 122871696, 122848567, 122889728], "G": [122840209, 122852256, 122900209, 122846129, 122844934, 122847648, 122853646, 122874899, 122880351, 122921209], "F": [122810446, 122819713, 122812617, 122825773, 122868869, 122809297, 122821188, 122827035, 122824965, 122821818, 122829815, 122826847, 122822005, 122826789, 122826175, 122826918, 122836373, 122830797, 122814894, 122838442, 122834199], "E": [122803663, 122805810, 122805166, 122812311, 122817063, 122814296, 122807127, 122808379, 122800583, 122808253, 122808203, 122811232, 122807495, 122807208, 122811521, 122828022, 122805125, 122810921], "D": [122791676, 122796247, 122793005, 122795921, 122795213, 122793368, 122796651, 122796980, 122803859, 122791210, 122799331, 122796501, 122797048, 122796533, 122791355, 122798720, 122801973, 122792843, 122800740], "C": [122785861, 122787673, 122786660, 122785034, 122784856, 122787839, 122786985, 122784250, 122795439, 122782668, 122786465, 122789088, 122786999, 122788656, 122784366, 122787966, 122789017, 122785054, 122790340], "B": [122781549, 122782427, 122782526, 122782097, 122782078, 122780831, 122781690, 122789087, 122786285, 122785455, 122781801, 122781479, 122782615, 122783296, 122794583, 122783767, 122783971, 122780469, 122782275], "A": [122775440, 122775417, 122775273, 122775738, 122775580, 122775190, 122775752, 122790605, 122781313, 122775806, 122775746, 122775311, 122776001, 122775468, 122776055, 122775938, 122777214, 122775025, 122775038]}, "name": "F. Bingo", "statement": "Getting ready for VK Fest 2021, you prepared a table with n rows and n\r\ncolumns, and filled each cell of this table with some event related with\r\nthe festival that could either happen or not: for example, whether you\r\nwill win a prize on the festival, or whether it will rain.Forecasting\r\nalgorithms used in VK have already estimated the probability for each\r\nevent to happen. Event in row i and column j will happen with\r\nprobability a_{i, j}\r\ncdot 10^{-4}. All of the events are mutually independent.Let\u2019s call the\r\ntable if there exists a line such that all n events on it happen. The\r\nline could be any horizontal line (cells (i, 1), (i, 2),\r\nldots, (i, n) for some i), any vertical line (cells (1, j), (2, j),\r\nldots, (n, j) for some j), the main diagonal (cells (1, 1), (2, 2),\r\nldots, (n, n)), or the antidiagonal (cells (1, n), (2, n - 1),\r\nldots, (n, 1)).Find the probability of your table to be winning, and\r\noutput it modulo 31\r\n,607 (see Output section).\r\n", "solutions": ["#include <bits/stdc++.h>\n\nconstexpr int P = 31607;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, int b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    const auto inv = Z(10000).inv();\n    \n    std::vector a(n, std::vector<Z>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int x;\n            std::cin >> x;\n            a[i][j] = x * inv;\n        }\n    }\n    \n    Z ans = 1;\n    \n    for (int md = 0; md <= 1; md++) {\n        for (int ad = 0; ad <= 1; ad++) {\n            auto b = a;\n            \n            Z res = ((md + ad) % 2 == 0 ? -1 : 1);\n            \n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if ((md && i == j) || (ad && i + j == n - 1)) {\n                        res *= b[i][j];\n                        b[i][j] = 1;\n                    }\n                }\n            }\n            \n            std::function<void(int, std::vector<Z>, Z)> dfs = [&](int r, std::vector<Z> v, Z coef) {\n                if (r == n) {\n                    for (int i = 0; i < n; i++) {\n                        coef *= 1 - v[i];\n                    }\n                    ans += coef;\n                    return;\n                }\n                Z tmp = -coef;\n                for (int i = 0; i < n; i++) {\n                    tmp *= b[r][i];\n                }\n                dfs(r + 1, v, tmp);\n                for (int i = 0; i < n; i++) {\n                    v[i] *= b[r][i];\n                }\n                dfs(r + 1, v, coef);\n            };\n            dfs(0, std::vector<Z>(n, 1), res);\n        }\n    }\n    \n    std::cout << ans.val() << \"\\n\";\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "combinatorics", "dp", "math", "probabilities"], "dificulty": "2600", "interactive": false}