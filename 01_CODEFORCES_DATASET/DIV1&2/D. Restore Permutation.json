{
    "link": "https://codeforces.com//contest/1208/problem/D",
    "problemId": "395879",
    "problem_idx": "D",
    "shortId": "1208D",
    "contest_number": "1208",
    "problem_submissions": {
        "H": [
            59484058,
            59502734,
            76052313
        ],
        "G": [
            59465495,
            59473655,
            59462360,
            59469582,
            59476496,
            59467194,
            59474332,
            59471219,
            59476758,
            59478641,
            59474463,
            59471571,
            59487164,
            59486904,
            59486576,
            59482130,
            59477683,
            59476449,
            59473994,
            59479017,
            59477708,
            59480546
        ],
        "F": [
            59463879,
            59465198,
            59467560,
            59476238,
            59468730,
            59478991,
            59464681,
            59477905,
            59488265,
            59473195,
            59472737,
            59472853,
            59477583,
            59487223,
            59467058,
            59472365,
            59474724,
            59482091,
            59473763,
            59474219,
            59475026
        ],
        "E": [
            59458500,
            59460001,
            59471123,
            59460976,
            59465221,
            59464240,
            59471956,
            59467792,
            59468080,
            59468210,
            59467089,
            59468111,
            59463881,
            59468884,
            59466520,
            59466354,
            59469354,
            59470023,
            59470503
        ],
        "C": [
            59454101,
            59453008,
            59450929,
            59452783,
            59454696,
            59455218,
            59454973,
            59451236,
            59458825,
            59456015,
            59453250,
            59456008,
            59453716,
            59453732,
            59453888,
            59456639,
            59456258,
            59457694,
            59458473
        ],
        "D": [
            59453338,
            59455109,
            59457439,
            59466058,
            59460513,
            59457371,
            59457830,
            59458661,
            59462381,
            59461784,
            59460829,
            59462458,
            59456674,
            59462814,
            59457263,
            59459344,
            59458893,
            59462907,
            59461567
        ],
        "B": [
            59451380,
            59451457,
            59455342,
            59451327,
            59452833,
            59452235,
            59452686,
            59455049,
            59452214,
            59453318,
            59450989,
            59453232,
            59451916,
            59457683,
            59451681,
            59453837,
            59452400,
            59452282,
            59455051
        ],
        "A": [
            59449116,
            59449294,
            59449254,
            59449364,
            59450306,
            59449785,
            59449160,
            59452256,
            59449743,
            59449309,
            59449227,
            59449840,
            59449173,
            59458690,
            59449209,
            59449159,
            59450221,
            59449398,
            59450162
        ]
    },
    "name": "D. Restore Permutation",
    "statement": "An array of integers p_{1},p_{2},\r\nldots,p_{n} is called a permutation if it contains each number from 1 to\r\nn exactly once. For example, the following arrays are permutations:\r\n[3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not\r\npermutations: [2], [1,1], [2,3,4].There is a hidden permutation of\r\nlength n.For each index i, you are given s_{i}, which equals to the sum\r\nof all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is\r\nthe sum of elements before the i-th element that are smaller than the\r\ni-th element.Your task is to restore the permutation.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 25.08.2019 17:41:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  fenwick<long long> fenw(n);\n  for (int i = 0; i < n; i++) {\n    fenw.modify(i, i + 1);\n  }\n  vector<int> a(n);\n  for (int i = n - 1; i >= 0; i--) {\n    int low = 0, high = n - 1;\n    while (low < high) {\n      int mid = (low + high) >> 1;\n      if (fenw.get(mid) > s[i]) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    a[i] = low + 1;\n    fenw.modify(low, -low - 1);\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << a[i];\n  }\n  cout << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Restore Permutation.json",
    "editorial_link": "https://codeforces.com/blog/entry/69357",
    "editorial": "Transform queries into two types: \"change color of a leaf\", and \"answer\r\ncolor of some vertex if k is given\". Note that when all internal\r\nvertices are red. When increasing , each vertex will change its color\r\nexactly once, letâs call this value of as boundary value for this\r\nvertex. If we can keep boundary values for all vertices, answering\r\nqueries is easy. Letâs do sqrt decomposition on queries: group them in\r\nblocks and process in blocks of size . When starting a block, compress\r\nthe tree so that there are interesting vertices: vertices involved in\r\nqueries and LCAs of them. Letâs call subtrees without interesting\r\nvertices as outer subtrees. We can compute the boundary values for all\r\nvertices in outer subtrees once for each block since the colors of\r\nleaves do not change. Now we should compress the paths between the\r\ninteresting vertices. Note that the boundary values on a path only\r\ndepend on the color of the vertex in the bottom end of the path. So for\r\neach such path compute two boundary values: if the vertex in the bottom\r\nend is red or blue. Now we can process queries by using the\r\ncorresponding values of boundary values, going down-up. Straightforward\r\nimplementation leads to preprocessing of each block and query time,\r\nmeaning the overall complexity is . The logarithms are from sorting and\r\nbinary search, respectively, so this solution is already fast enough to\r\nget AC. To implement compression in you need to go from lowest to\r\nhighest possible and maintain which vertices are red in outer subtrees.\r\nNote that the number of different boundary values is , so you can store\r\nfor each the list of vertices having this boundary value. To implement\r\nqueries in , you need to precompute binary search outcomes for the given\r\nvalues while computing the boundary values. This way the overall\r\ncomplexity becomes .\r\n",
    "hint": []
}