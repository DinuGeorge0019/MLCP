{"link": "https://codeforces.com//contest/1208/problem/D", "problemId": "395879", "problem_idx": "D", "shortId": "1208D", "contest_number": "1208", "problem_submissions": {"H": [59484058, 59502734, 76052313], "G": [59465495, 59473655, 59462360, 59469582, 59476496, 59467194, 59474332, 59471219, 59476758, 59478641, 59474463, 59471571, 59487164, 59486904, 59486576, 59482130, 59477683, 59476449, 59473994, 59479017, 59477708, 59480546], "F": [59463879, 59465198, 59467560, 59476238, 59468730, 59478991, 59464681, 59477905, 59488265, 59473195, 59472737, 59472853, 59477583, 59487223, 59467058, 59472365, 59474724, 59482091, 59473763, 59474219, 59475026], "E": [59458500, 59460001, 59471123, 59460976, 59465221, 59464240, 59471956, 59467792, 59468080, 59468210, 59467089, 59468111, 59463881, 59468884, 59466520, 59466354, 59469354, 59470023, 59470503], "C": [59454101, 59453008, 59450929, 59452783, 59454696, 59455218, 59454973, 59451236, 59458825, 59456015, 59453250, 59456008, 59453716, 59453732, 59453888, 59456639, 59456258, 59457694, 59458473], "D": [59453338, 59455109, 59457439, 59466058, 59460513, 59457371, 59457830, 59458661, 59462381, 59461784, 59460829, 59462458, 59456674, 59462814, 59457263, 59459344, 59458893, 59462907, 59461567], "B": [59451380, 59451457, 59455342, 59451327, 59452833, 59452235, 59452686, 59455049, 59452214, 59453318, 59450989, 59453232, 59451916, 59457683, 59451681, 59453837, 59452400, 59452282, 59455051], "A": [59449116, 59449294, 59449254, 59449364, 59450306, 59449785, 59449160, 59452256, 59449743, 59449309, 59449227, 59449840, 59449173, 59458690, 59449209, 59449159, 59450221, 59449398, 59450162]}, "name": "D. Restore Permutation", "statement": "An array of integers p_{1},p_{2},\r\nldots,p_{n} is called a permutation if it contains each number from 1 to\r\nn exactly once. For example, the following arrays are permutations:\r\n[3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not\r\npermutations: [2], [1,1], [2,3,4].There is a hidden permutation of\r\nlength n.For each index i, you are given s_{i}, which equals to the sum\r\nof all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is\r\nthe sum of elements before the i-th element that are smaller than the\r\ni-th element.Your task is to restore the permutation.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 25.08.2019 17:41:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> s(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n  }\n  fenwick<long long> fenw(n);\n  for (int i = 0; i < n; i++) {\n    fenw.modify(i, i + 1);\n  }\n  vector<int> a(n);\n  for (int i = n - 1; i >= 0; i--) {\n    int low = 0, high = n - 1;\n    while (low < high) {\n      int mid = (low + high) >> 1;\n      if (fenw.get(mid) > s[i]) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    a[i] = low + 1;\n    fenw.modify(low, -low - 1);\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << a[i];\n  }\n  cout << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "greedy", "implementation"], "dificulty": "1900", "interactive": false}