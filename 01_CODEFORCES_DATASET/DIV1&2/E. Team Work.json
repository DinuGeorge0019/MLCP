{
    "link": "https://codeforces.com//contest/932/problem/E",
    "problemId": "156998",
    "problem_idx": "E",
    "shortId": "932E",
    "contest_number": "932",
    "problem_submissions": {
        "G": [
            51774341,
            35308371,
            35309948,
            35309510,
            35328593,
            35312755,
            35340195,
            35324025,
            38386676,
            35314606
        ],
        "F": [
            35314668,
            35310572,
            35468380,
            35310269,
            35309416,
            35312292,
            35310748,
            35546358,
            35310551,
            35314451,
            35994490,
            35310830,
            35314597,
            35313005,
            35315153,
            35311414,
            35314861
        ],
        "E": [
            35305602,
            35300676,
            35303983,
            35302322,
            35304627,
            35307360,
            35305500,
            35300979,
            35304741,
            35308375,
            35305972,
            35304083,
            35308467,
            35308589,
            35308504,
            35313014,
            35308160,
            35300247
        ],
        "D": [
            35304182,
            35304652,
            35301520,
            35312731,
            35302822,
            35304942,
            35303273,
            35308561,
            35309596,
            35306303,
            35302532,
            35308788,
            35304471,
            35304933,
            35304868,
            35308529,
            35306123,
            35312012
        ],
        "C": [
            35298412,
            35298036,
            35296739,
            35298645,
            35298179,
            35298553,
            35299152,
            35297891,
            35299526,
            35299903,
            35298326,
            35305061,
            35298463,
            35300385,
            35298472,
            35299312,
            35300289,
            35313442
        ],
        "B": [
            35297094,
            35297006,
            35297939,
            35296994,
            35296930,
            35296422,
            35297855,
            35301880,
            35297864,
            35297983,
            35297247,
            35296879,
            35297467,
            35297739,
            35296808,
            35297547,
            35298510,
            35302031
        ],
        "A": [
            35295015,
            35294909,
            35298217,
            35294978,
            35294827,
            35294828,
            35295219,
            35296140,
            35296578,
            35294771,
            35294859,
            35294967,
            35294941,
            35294775,
            35295820,
            35295673,
            35300844
        ]
    },
    "name": "E. Team Work",
    "statement": "You have a team of people. For a particular task, you can pick any\r\nnon-empty subset of people. The cost of having people for the task is .\r\nOutput the sum of costs over all non-empty subsets of people.\r\n",
    "solutions": [
        "//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=5007;\nconst ll mod=1000*1000*1000+7;\n\nll n, k;\n\nll kom[nax][nax];\n\nll dp[nax];\n\nll wyn;\n\nll pot(ll a, ll b)\n{\n\ta%=mod;\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif (b&1)\n\t\t\tret=(ret*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\n\nll dziel(ll a, ll b)\n{\n\treturn (a*pot(b, mod-2))%mod;\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\", &n, &k);\n\tfor (int i=0; i<=k; i++)\n\t{\n\t\tkom[i][0]=1;\n\t\tfor (int j=1; j<=i; j++)\n\t\t\tkom[i][j]=(kom[i-1][j]+kom[i-1][j-1])%mod;\n\t}\n\tdp[0]=0;\n\tfor (int i=1; i<=k; i++)\n\t{\n\t\tll niby=pot(i, k);\n\t\tfor (int j=1; j<i; j++)\n\t\t\tniby=(niby-dp[j]*kom[i][j])%mod;\n\t\t\n\t\tniby%=mod;\n\t\tniby+=mod;\n\t\tniby%=mod;\n\t\t\n\t\tdp[i]=niby;\n\t\t\n\t\t//~ debug() << i << \" \" << dp[i];\n\t}\n\tll li=1;\n\tll mi=1;\n\tfor (int i=1; i<=min(n, k); i++)\n\t{\n\t\tli=(li*(n+1-i))%mod;\n\t\tmi=(mi*i)%mod;\n\t\t\n\t\tll ula=dziel(li, mi);\n\t\t\n\t\t//~ debug() << i << \" \" << li << \" \" << mi;\n\t\t\n\t\tula=(ula*dp[i])%mod;\n\t\t\n\t\twyn=(wyn+ula*pot(2, n-i))%mod;\n\t}\n\t\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Team Work.json",
    "editorial_link": "https://codeforces.com//blog/entry/57796",
    "editorial": "The required sum can be expressed as .Differentiating the above equation\r\nand multiplying by , we getDifferentiating and multiplying by again, we\r\ngetRepeating the process (multiplying by and differentiating) times, and\r\nreplacing , we get the desired sum.This can be done using dynamic\r\nprogramming.Consider to be the value of the function after performing\r\nthe differentiation and multiplying by , times at . So, our final answer\r\nwill be . after 1 operation, the above function becomes: or So, Take\r\ncare of special cases when or .The above seems to be dimensional but\r\nactually has states since is constant reducing one dimension.\r\n"
}