{
    "link": "https://codeforces.com//contest/1987/problem/E",
    "problemId": "2726564",
    "problem_idx": "E",
    "shortId": "1987E",
    "contest_number": "1987",
    "problem_submissions": {
        "E": [
            268229906,
            268158602,
            268423905,
            268422817,
            268157857,
            268152628,
            268233241,
            268233207,
            268156681,
            268158666,
            268162964,
            268158456,
            268163362,
            268156782,
            268165522,
            268170420,
            268158686,
            268162341,
            268233753,
            268228306,
            268160955,
            268160065,
            268161194,
            268164320,
            268163376,
            268166928,
            268264962,
            268164535
        ],
        "H": [
            268205560,
            268243575,
            268242763,
            268242753,
            268226875,
            268226200,
            286117872,
            286117361,
            268621342,
            270559507
        ],
        "G2": [
            268199327,
            268183184,
            268209905,
            268197988,
            268210865,
            268209119,
            268201265,
            268217291,
            268203603,
            268206936,
            268211532,
            268216966,
            268392569
        ],
        "G1": [
            268197008,
            268183589,
            268183559,
            268192970,
            268191020,
            268190335,
            268201091,
            268194194,
            268192954,
            268200485,
            268201459,
            268210583,
            268191184,
            268204488,
            268195197,
            268205593,
            268203056,
            268392539,
            268196879,
            268201576,
            268201255
        ],
        "F2": [
            268174418,
            268166457,
            268162505,
            268182920,
            268168846,
            268174436,
            268185759,
            268178301,
            268181565,
            268191599,
            268193415,
            268177500,
            268170902,
            268180818,
            268174520,
            268182719,
            268178817,
            268190336,
            268190071
        ],
        "F1": [
            268173831,
            268166694,
            268162641,
            268178377,
            268169399,
            268174193,
            268185332,
            268177979,
            268170897,
            268181978,
            268191481,
            268193293,
            268177600,
            268169616,
            268180668,
            268173797,
            268182414,
            268176479,
            268181249,
            268189979
        ],
        "D": [
            268149772,
            268151878,
            268147683,
            268147422,
            268149471,
            268152924,
            268151963,
            268155962,
            268148798,
            268153037,
            268153285,
            268152472,
            268152498,
            268151784,
            268149550,
            268150424,
            268156633,
            268151156,
            268159183,
            268155639
        ],
        "C": [
            268144323,
            268147501,
            268383290,
            268143974,
            268142997,
            268142336,
            268156117,
            268145345,
            268149662,
            268144034,
            268146014,
            268146306,
            268146500,
            268154494,
            268145000,
            268144648,
            268146061,
            268146320,
            268145299,
            268148183,
            268146033
        ],
        "B": [
            268142097,
            268138793,
            268136942,
            268137419,
            268137014,
            268140558,
            268141012,
            268143732,
            268140016,
            268142374,
            268143256,
            268141729,
            268142582,
            268139760,
            268140776,
            268140696,
            268140576,
            268139314,
            268141992,
            268141951
        ],
        "A": [
            268135899,
            268135441,
            268135342,
            268135356,
            268135339,
            268135852,
            268135895,
            268139203,
            268135363,
            268137561,
            268136567,
            268135744,
            268136590,
            268135768,
            268135350,
            268135764,
            268135555,
            268135575,
            268136024,
            268138028
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131053",
    "editorial": "Let if is not empty and otherwise. Then, in one operation we decrease by\r\nand increase by ( is the parent of ), and our objective is to make for\r\nall vertices in as few operations as possible.We can actually chain our\r\noperations to form a more powerful one. In particular, the new operation\r\nbecomes: Select two vertices and such that and is an ancestor of by\r\npaying coins, where is the depth of vertex . Decrease by and increase by\r\n. The objective remains the same: make all by paying as few coins as\r\npossible.Suppose one optimal sequence of operations applies the\r\noperations on the pairs of vertices and and the paths and intersect.\r\nThen, applying the operations on the pairs of vertices and , is not less\r\noptimal since . This means that we can choose which operations to apply\r\non lower without caring about its ancestors. Suppose that after some\r\nsequence of operations, which includes the operation , there is a vertex\r\nin the subtree of with and . Then, it is optimal to apply the operation\r\non instead of . This means that we want to apply the operation on the\r\nclosest vertices in the subtree of .The two observations above lead to a\r\ngreedy. We will iterate over all from to , and while is less than zero,\r\nkeep applying the operation on , where is the closest vertex in the\r\nsubtree of with . This is possible to implement in a number of ways, one\r\nof them includes running a bfs from each vertex .Complexity: Note: it is\r\npossible to solve this problem faster, up to only time.\r\n",
    "name": "E. Wonderful Tree ",
    "statement": "A Random PebbleYou are given a tree with n vertices, rooted at vertex 1.\r\nThe i-th vertex has an integer a_i written on it.Let L be the set of all\r\ndirect children^{\r\ntext{ }} of v. A tree is called , if for all vertices v where L is not\r\nempty, a_v\r\nle\r\nsum_{u\r\nin L}{a_u}. In one operation, you choose any vertex v and increase a_v\r\nby 1.Find the minimum number of operations needed to make the given tree\r\n!^{\r\ntext{ }} Vertex u is called a direct child of vertex v if: u and v are\r\nconnected by an edge, and v is on the (unique) path from u to the root\r\nof the tree.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, \"/stack:200000000\")#pragma GCC optimize(\"O3\")//~ #pragma GCC target (\"avx2\")//~ #pragma GCC optimize(\"Ofast\")//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")//~ #pragma GCC optimize(\"unroll-loops\")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds;using namespace std; template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; #define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << \"(\" << d.first << \", \" << d.second << \")\";}sim dor(rge<c> d) {  *this << \"[\";  for (auto it = d.b; it != d.e; ++it)    *this << \", \" + 2 * (it == d.b) << *it;  ris << \"]\";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \" #define shandom_ruffle random_shuffle using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=5007;const ll inf=1e18; int n; ll tab[nax];int ojc[nax];vi graf[nax]; int gle[nax]; vector<pll> zbi[nax]; ll wyn; vector<pll> lacz(vector<pll> a, vector<pll> b){\tvector<pll> ret(a.size()+b.size());\tmerge(a.begin(), a.end(), b.begin(), b.end(), ret.begin());\treturn ret;} void dfs1(int v){\tif (graf[v].empty())\t{\t\tzbi[v]={{gle[v], inf}};\t\treturn;\t}\tzbi[v].clear();\tll s=0;\tfor (int i : graf[v])\t{\t\tgle[i]=gle[v]+1;\t\tdfs1(i);\t\ts+=tab[i];\t\tzbi[v]=lacz(zbi[v], zbi[i]);        exchange(zbi[i], {});\t}\tif (s>tab[v])\t{\t\tzbi[v].insert(zbi[v].begin(), pll{gle[v], s-tab[v]});\t}\telse\t{\t\treverse(zbi[v].begin(), zbi[v].end());\t\tll x=tab[v]-s;\t\twhile(x)\t\t{\t\t\tif (!zbi[v].back().second)\t\t\t{\t\t\t\tzbi[v].pop_back();\t\t\t\tcontinue;\t\t\t}\t\t\tll y=min(zbi[v].back().second, x);\t\t\tx-=y;\t\t\tzbi[v].back().second-=y;\t\t\twyn+=(zbi[v].back().first-gle[v])*y;\t\t}\t\treverse(zbi[v].begin(), zbi[v].end());\t}} void test(){\tscanf(\"%d\", &n);\tfor (int i=0; i<=n; i++)\t\tgraf[i].clear();\tfor (int i=1; i<=n; i++)\t\tscanf(\"%lld\", &tab[i]);\tfor (int i=2; i<=n; i++)\t{\t\tscanf(\"%d\", &ojc[i]);\t\tgraf[ojc[i]].push_back(i);\t}\twyn=0;\tgle[1]=1;\tdfs1(1);\tprintf(\"%lld\\n\", wyn);} int main(){\tint t;\tscanf(\"%d\", &t);\twhile(t--)\t\ttest();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dsu",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Wonderful Tree .json",
    "hint": [
        "Hint 1 Let if is not empty and otherwise. What does the operation do to the values of ? What does the objective change to?",
        "Hint 2 Let be an ancestor of and ( is the depth array). Then, you can add to and subtract from in operations. Let this be our new operation on a pair of vertices .",
        "Hint 3 Suppose one optimal sequence of operations uses it on and , and the paths and intersect. Let . Then, if , it is not less optimal to apply the operation on and .",
        "Hint 4 Pick the closest vertex to while ."
    ]
}