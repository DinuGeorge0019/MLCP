{
    "link": "https://codeforces.com//contest/1534/problem/H",
    "problemId": "1015237",
    "problem_idx": "H",
    "shortId": "1534H",
    "contest_number": "1534",
    "problem_submissions": {
        "H": [
            119381214,
            119371780,
            119388875,
            119396687,
            119388441,
            119735727,
            119401011,
            156903357,
            119399410
        ],
        "G": [
            119363923,
            119381755,
            119379035,
            119379747,
            119375709,
            119378954,
            119381639,
            119386175,
            119382951,
            119385742,
            119388314,
            119371330,
            120158205,
            119404077,
            119378000,
            119386837,
            119386916,
            119395182,
            119389738,
            119408279,
            119408209,
            119408093
        ],
        "F2": [
            119359019,
            119387021,
            119400446,
            119368476,
            119369247,
            119507067,
            119404750,
            119370022,
            119374004,
            119374154,
            119376176,
            119372366,
            119378246,
            119399836,
            119402771,
            119402687,
            119397406,
            119363483,
            119371811,
            119375364
        ],
        "F1": [
            119354959,
            119349642,
            119359129,
            119361761,
            119507346,
            119371842,
            119361335,
            119365559,
            119364097,
            119370075,
            119372716,
            119373779,
            119373986,
            119373292,
            119365686,
            119365605,
            119370635,
            119378959,
            119363180,
            119357763,
            119355433
        ],
        "E": [
            119348058,
            119345554,
            119352930,
            119351617,
            119349306,
            119353802,
            119353388,
            119357278,
            119361448,
            119356611,
            119347260,
            119354563,
            119406882,
            119406872,
            119406814,
            119366978,
            119358316,
            119361081,
            119365117,
            119367416,
            119352636,
            119352851,
            119349844
        ],
        "D": [
            119342350,
            119341721,
            119344490,
            119344598,
            119352385,
            119347199,
            119345707,
            119344090,
            119352267,
            119362889,
            119351680,
            119347922,
            119347628,
            119350545,
            119353880,
            119345904,
            119350322,
            119344632,
            119344948,
            119343924
        ],
        "C": [
            119339545,
            119339824,
            119341150,
            119341051,
            119342258,
            119342361,
            119342280,
            119341468,
            119346665,
            119340382,
            119340132,
            119340253,
            119340431,
            119342595,
            119342664,
            119342788,
            119344299,
            119340875,
            119340120,
            119340815
        ],
        "B": [
            119338881,
            119339003,
            119339770,
            119339655,
            119340047,
            119340398,
            119340981,
            119340203,
            119342335,
            119339310,
            119338676,
            119339188,
            119339149,
            119339395,
            119344148,
            119340653,
            119341897,
            119339460,
            119339065,
            119339496
        ],
        "A": [
            119338623,
            119338599,
            119338780,
            119338750,
            119338699,
            119338727,
            119339260,
            119338754,
            119339237,
            119338711,
            119339353,
            119338692,
            119338629,
            119345132,
            119342442,
            119338896,
            119339494,
            119338744,
            119338632,
            119338713
        ]
    },
    "name": "H. Lost Nodes",
    "statement": "As he qualified for IOI this year, Little Ericyi was given a gift from\r\nall his friends: a tree of n nodes!On the flight to IOI Little Ericyi\r\nwas very bored, so he decided to play a game with Little Yvonne with his\r\nnew tree. First, Little Yvonne selects two (not necessarily different)\r\nnodes a and b on the tree (without telling Ericyi), and then gives him a\r\nhint f (which is some node on the path from a to b).Then, Little Ericyi\r\nis able to ask the following question repeatedly: If I rooted the tree\r\nat node r (Ericyi gets to choose r), what would be the Lowest Common\r\nAncestor of a and b?Little Ericyi’s goal is to find the nodes a and b,\r\nand report them to Little Yvonne.However, Little Yvonne thought this\r\ngame was too easy, so before he gives the hint f to Little Ericyi, he\r\nalso wants him to first find the maximum number of queries required to\r\ndetermine a and b over all possibilities of a, b, and f assuming Little\r\nEricyi plays optimally. Little Ericyi defines an optimal strategy as one\r\nthat makes the minimum number of queries. Of course, once Little Ericyi\r\nreplies with the maximum number of queries, Little Yvonne will only let\r\nhim use that many queries in the game.The tree, a, b, and f are all\r\nfixed before the start of the game and do not change as queries are\r\nmade.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << endl; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\nint N;\nvi adj[MX];\nint par[MX], depth[MX];\nint dp_sub[MX], op_query_sub[MX];\nint dp_without[MX], op_query_without[MX];\n\nvoid dfs(int x) { // if we know ans is in subtree of x, >= 1 query\n\tdp_sub[x] = 1; op_query_sub[x] = x;\n\tdepth[x] = depth[par[x]]+1;\n\tvpi child_dp;\n\teach(y,adj[x]) if (y != par[x]) {\n\t\tpar[y] = x;\n\t\tdfs(y);\n\t\tchild_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(child_dp));\n\tF0R(i,sz(child_dp)) {\n\t\tckmax(dp_sub[x],child_dp[i].f+i);\n\t\tif (i == 0) op_query_sub[x] = op_query_sub[child_dp[i].s];\n\t}\n}\n\nint get_opt_query(int x, int p) {\n\tassert(x && p);\n\tif (par[x] == p) {\n\t\tassert(op_query_sub[x]);\n\t\treturn op_query_sub[x];\n\t} else {\n\t\tassert(par[p] == x);\n\t\tassert(op_query_without[p]);\n\t\treturn op_query_without[p];\n\t}\n}\n\nvoid dfs2(int x) {\n\tdbg(\"DFS2\",x);\n\tvpi child_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) child_dp.pb({dp_without[x],y});\n\t\telse child_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(child_dp));\n\teach(t,child_dp) assert(t.f);\n\t// dbg(\"GOT CHILD DP\",x,child_dp);\n\tvi pref(sz(child_dp)+1);\n\tvi suf(sz(child_dp)+1);\n\tF0R(i,sz(child_dp)) {\n\t\tpref[i+1] = max(pref[i],child_dp[i].f+i);\n\t}\n\tR0F(i,sz(child_dp)) {\n\t\tsuf[i] = max(suf[i+1],child_dp[i].f+i-1);\n\t}\n\tF0R(i,sz(child_dp)) {\n\t\tint y = child_dp[i].s;\n\t\tif (y != par[x]) {\n\t\t\tdp_without[y] = max(pref[i],suf[i+1]);\n\t\t\tif (dp_without[y] == 0) {\n\t\t\t\tassert(x == 1 && sz(adj[x]) == 1);\n\t\t\t\t// dbg(\"LINE CASE\");\n\t\t\t\tdp_without[y] = 1;\n\t\t\t\top_query_without[y] = x;\n\t\t\t} else {\n\t\t\t\tif (i) op_query_without[y] = get_opt_query(child_dp[0].s,x);\n\t\t\t\telse {\n\t\t\t\t\tassert(i+1 < sz(child_dp));\n\t\t\t\t\top_query_without[y] = get_opt_query(child_dp[1].s,x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// dbg(\"GEN DP WITHOUT\",y);\n\t\t\tassert(dp_without[y]);\n\t\t\tdfs2(y);\n\t\t}\n\t}\n}\n\nint queries_left;\n\nint query(int i) {\n\tassert(queries_left);\n\t--queries_left;\n\tps(\"?\",i);\n\tints(x); \n\trtn x;\n}\n\nvoid finish(int ans) {\n\tps(\"!\",ans);\n\texit(0);\n}\n\nvpi get_adj_dp(int x) {\n\tvpi adj_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) adj_dp.pb({dp_without[x],y});\n\t\telse adj_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(adj_dp));\n\treturn adj_dp;\n}\n\nvpi get_adj_queries(int x) { // return {vert, vertex to query}\n\tvpi adj_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) adj_dp.pb({dp_without[x],y});\n\t\telse adj_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(adj_dp));\n\teach(t,adj_dp) {\n\t\tswap(t.s,t.f);\n\t\tt.s = get_opt_query(t.f,x);\n\t}\n\treturn adj_dp;\n}\n\nvi endpoints;\n\nvb marked;\n\n// void process_query(int x, int y, int z) {\n// \tvi path = path_to(y,x);\n// \tif (z == x) {\n// \t\tmarked[path[sz(path)-2]] = 1;\n// \t}\n// }\n\nvi path_to(int a, int b) {\n\tvi st, en;\n\twhile (a != b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tst.pb(a);\n\t\t\ta = par[a];\n\t\t} else {\n\t\t\ten.pb(b);\n\t\t\tb = par[b];\n\t\t}\n\t}\n\tst.pb(b);\n\treverse(all(en));\n\tst.ins(end(st),all(en));\n\treturn st;\n}\n\nvoid solve_subtree(int x, int p) {\n\tassert(marked.at(p));\n\tauto deal_path = [&](int y, int z) {\n\t\t// dbg(\"DEAL PATH\",y,z);\n\t\tvi path = path_to(y,x);\n\t\tint ind = 0;\n\t\twhile (path.at(ind) != z) ++ind;\n\t\tx = path.at(ind);\n\t\tif (ind) marked[path.at(ind-1)] = 1;\n\t\tif (ind+1 < sz(path)) marked[path.at(ind+1)] = 1;\n\t};\n\t{\n\t\tint y = get_opt_query(x,p);\n\t\tint z = query(y); if (z == p) return;\n\t\tdeal_path(y,z);\n\t}\n\twhile (1) {\n\t\tassert(!marked.at(x));\n\t\tvpi cands;\n\t\t{\n\t\t\tvpi queries = get_adj_queries(x);\n\t\t\teach(t,queries) if (!marked.at(t.f)) cands.pb(t);\n\t\t}\n\t\tdbg(\"FOUND\",x,cands);\n\t\tbool found = 0;\n\t\teach(t,cands) {\n\t\t\tint y = t.s; int z = query(y);\n\t\t\tif (z == x) continue;\n\t\t\tdeal_path(y,z);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (found) continue;\n\t\tendpoints.pb(x); return;\n\t}\n}\n\nvoid solve(int f) {\n\tvpi v = get_adj_dp(f);\n\teach(t,v) {\n\t\tsolve_subtree(t.s,f);\n\t\tif (sz(endpoints) == 2) break;\n\t}\n\twhile (sz(endpoints) < 2) endpoints.pb(f);\n\tps(\"!\",endpoints[0],endpoints[1]);\n}\n\nint main() {\n\tre(N);\n\trep(N-1) {\n\t\tints(u,v);\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tdfs(1);\n\tdfs2(1);\n\tint ans = 0;\n\tFOR(x,1,N+1) {\n\t\tvpi adj_dp = get_adj_dp(x);\n\t\tF0R(i,sz(adj_dp)) {\n\t\t\tckmax(ans,adj_dp[i].f+i);\n\t\t\tif (i > 0) ckmax(ans,adj_dp[i].f+i+adj_dp[0].f-1);\n\t\t}\n\t}\n\t// FOR(x,1,N+1) dbg(x,op_query_sub[x],op_query_without[x]);\n\tps(ans);\n\tints(f);\n\tmarked = vb(N+1);\n\tmarked.at(f) = 1;\n\tqueries_left = ans;\n\tsolve(f);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "graphs",
        "interactive",
        "sortings",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Lost Nodes.json",
    "editorial_link": "https://codeforces.com//blog/entry/91760",
    "editorial": "For now, letâs only look at finding for fixed . We will expand for all\r\nlater.We know that is on the path from to . Let us root the tree at .\r\nThus, we know that the path will pass through the root, and that there\r\nare exactly non-negative length chains beginning at the root. With that\r\nin mind, letâs take a look at what a question \"? r really does. What\r\nhappens if is on the path from to ? In this case, we obtain as the\r\nanswer. What happens if is not on the path from to ? In this case, we\r\nobtain the node to on the path from to . Letâs try to find one endpoint\r\nof one of these chains first. Consider the following dynamic programming\r\nstructure: Let denote the minimum number of questions required to\r\n\"solve\" the subtree rooted at . By \"solve\", we mean to determine if the\r\nendpoint of a chain is in the subtree or not, and if it is in the\r\nsubtree, the exact node. The base case is pretty obvious. For a leaf\r\nnode, it will take exactly question to solve a leaf node. If the\r\nendpoint of the chain does indeed end at the leaf node, then a question\r\nwill return the leaf node. Otherwise itâll return an ancestor of the\r\nleaf.Letâs move on to a non-base case at a node . Letâs call the most\r\n\"expensive\" child of as the child with the largest (i.e. takes the most\r\nnumber of questions to \"solve\").For now, assume we know that an endpoint\r\nexists in the subtree rooted at , and is not . Thus, we will need to\r\niterate through each child to determine in which childâs subtree the\r\nendpoint exists. We will need to use one question per child. However,\r\nnote that not all of these questions count towards our question count.\r\nThere are two cases: In the current child we are exploring, the endpoint\r\ndoes exist there. In this case, the question we used does not count\r\ntowards our question count. We can use a question from the childâs\r\nquestion count. This may seem a bit strange, but if we query correctly,\r\nthen in the same time we check if the endpoint exists in the childâs\r\nsubtree, we also process the most \"expensive\" child of the child and\r\ndetermine if the endpoint exist in that child of the childâs subtree. In\r\nthe current child we are exploring, the endpoint doesnât exist there. In\r\nthis case, the question we used must count towards our question count.\r\nWe could consider this a \"wasted\" question as we didnât learn anything\r\nnew about where the endpoint is, just that itâs not in this child. Now,\r\nin which order should be explore the children? We can greedy this.\r\nRecall that any \"wasted\" questions count towards our question count.\r\nThus, for more \"expensive\" children, we want to have wasted less\r\nquestions when we get to the child, as in the case the endpoint does\r\nexist there, we would need even more questions (adding the \"wasted\"\r\nquestions to where is the child). This gives us the following idea: To\r\ndetermine if the (-indexed) child of contains the endpoint, we would\r\nneed to waste questions. If the endpoint does exist in , we would need\r\nto use a total of questions to \"solve\" the subtree rooted at . Since we\r\nare trying to find the worst case, we want to order the children of such\r\nas to minimize the maximum of all . The optimal ordering is the\r\nnon-increasing order of . The transition is thus: , where the values are\r\nsorted in non-increasing order, and are the children of .Now wait! We\r\nhavenât handled the case where the endpoint doesnât exist in or the case\r\nwhere the endpoint is yet! Turns out, both of these cases are already\r\nhandled for us. We only need to be a bit careful when we actually\r\nperform the interaction later on. If the endpoint doesnât exist in , we\r\nwould have already realized when one of the questions to a child of\r\nreturns an ancestor of . This question count wonât be lost though. It\r\nwill simply be counted towards a \"wasted\" question for one of the\r\nancestors of . If the endpoint is , then all of the questions to a child\r\nof will return (not a ancestor of ). Thus, we will know that the\r\nendpoint is with exactly wasted questions. Notice, however, that by the\r\nnature of the transition. Thus, this case will never be our worst case,\r\nso we can ignore it for the dynamic programming. We now have the dynamic\r\nprogramming complete, but notice that itâs only for the endpoint of one\r\nchain. At our root , there are two chains with two endpoints. Thus, our\r\nfinal answer wonât be simply taking . It will require a bit more\r\ncomputation.For now, assume that both endpoints are not (i.e. both\r\nchains have positive length). Following a similar analysis as the\r\ndynamic programming transition, we have that for any child that does not\r\ncontain either chain endpoint, we would need to \"waste\" a question. Once\r\nagain, the optimal ordering is to process in non-increasing order.\r\nHowever, adding to the child is no longer correct. Consider the\r\nfollowing observations: When processing a child that doesnât contain a\r\nchain, that child only takes one question to determine that chains are\r\nnot in that child. For the first child that we know contains a chain, we\r\ndonât \"waste\" a question. This question is included in that childâs\r\nquestion count. With observation , we are basically figuring out the\r\nfirst chainâs endpoint for free. There are no wasted questions, as all\r\nwasted questions will be counted for the second chain. With observation\r\n, we have that adding wasted questions is no longer correct. We only\r\nwaste questions for the child, as one of the processed children contains\r\nthe first chain (and thus doesnât waste a question).Thus, for the root,\r\nour formula is: , where the values are sorted in non-increasing order,\r\nand is the children of . Note that this formula has an worst case for a\r\nstar graph, so we will need to optimize it.Our optimized formula is: ,\r\nwhere the values are sorted in non-increasing order, and is the children\r\nof .Once again, with a similar analysis as what was done for the\r\ncomputation, the case that one (or both) chains have a zero length will\r\nnever be the worst case, and so we can ignore it for the dynamic\r\nprogramming. However, the case must still be handled during\r\ninteraction.Recall that the above was for a fixed . To find the maximum\r\nfor all , we can perform a tree walk. When transitioning from one root\r\nto an adjacent root, use a prefix and suffix max array to compute ,\r\nignoring the that is the new root. Both max arrays should store , not .\r\nRemember to subtract from the suffix array values, as there is one less\r\nwasted question. If you understood the initial dynamic programming\r\ncomputation for determining the theoretical maximum, the interaction\r\nshould be relatively straightforward, and so we will leave it as an\r\nexercise for the reader. Be careful when handling the special cases that\r\nwere ignored during the dynamic programming. The final time complexity\r\nis and memory complexity is .\r\n",
    "hint": []
}