{
    "link": "https://codeforces.com//contest/1863/problem/H",
    "problemId": "2186459",
    "problem_idx": "H",
    "shortId": "1863H",
    "contest_number": "1863",
    "problem_submissions": {
        "G": [
            221136551,
            221139848,
            221147121,
            221150406,
            221156272,
            221151276,
            221147870,
            221157045,
            221150654,
            221158033,
            221156995,
            221150405,
            221155989,
            221155038,
            221160627,
            221149999,
            221166719,
            221155326,
            221159641,
            221165396
        ],
        "F": [
            221121590,
            221127771,
            221128307,
            221138108,
            221130805,
            221136021,
            221136737,
            221129060,
            221140638,
            221137056,
            221128211,
            221139417,
            221137699,
            221127026,
            221139802,
            221154849,
            221135761,
            221144061,
            221150102,
            221217304,
            221142638
        ],
        "E": [
            221110018,
            221117203,
            221116712,
            221116632,
            221114627,
            221123945,
            221125852,
            221119344,
            221123994,
            221117191,
            221120648,
            221126771,
            221126517,
            221139461,
            221119939,
            221121938,
            221123387,
            221126376,
            221121543,
            221217383,
            221127296
        ],
        "D": [
            221102414,
            221109581,
            221105244,
            221107918,
            221106665,
            221103992,
            221113320,
            221110649,
            221111108,
            221103919,
            221112047,
            221112174,
            221110753,
            221112715,
            221104010,
            221113678,
            221110048,
            221113375,
            221110273,
            221109100
        ],
        "C": [
            221098267,
            221102354,
            221100311,
            221098509,
            221100896,
            221098602,
            221107809,
            221105183,
            221098239,
            221098225,
            221102929,
            221105006,
            221102283,
            221103582,
            221098969,
            221099286,
            221102760,
            221106477,
            221099714,
            221101657
        ],
        "A": [
            221096643,
            221096074,
            221096129,
            221096043,
            221095975,
            221096016,
            221096907,
            221096642,
            221101230,
            221095943,
            221096347,
            221097350,
            221096423,
            221097791,
            221095953,
            221096058,
            221096941,
            221096889,
            221096069,
            221097073
        ],
        "B": [
            221096498,
            221097225,
            221097260,
            221096607,
            221096286,
            221096471,
            221098534,
            221098779,
            221102915,
            221096280,
            221097328,
            221098778,
            221097955,
            221099465,
            221096389,
            221096664,
            221099499,
            221099302,
            221096756,
            221098284
        ],
        "I": [
            221276607,
            221276430,
            221275617,
            221825420,
            221197104
        ],
        "H": [
            221188380,
            221214363,
            221182970,
            221376731,
            221376708,
            221376397,
            221187887
        ]
    },
    "name": "H. Goldberg Machine 3",
    "statement": "There is a complete rooted binary tree, that is, a rooted tree in which\r\neach vertex has either 0 or 2 children. The root of the tree is\r\nvertex 1. A node without children is called a . Each leaf has a , we\r\ndenote the hunger value of leaf v by h_v.Each inner vertex of the tree\r\nhas a selector pointing to one of the children of the vertex.This tree\r\naccepts cookies. Before launching the process you can choose the initial\r\nstate of each selector individually. The process is as follows:\r\nInitially there are no cookies in vertices. You insert cookies into the\r\nroot one by one. As long as the cookie is not in a leaf, it falls to the\r\nchild defined by the selector in the current vertex. This selector then\r\nchanges its state to the opposite one, i. e. it starts pointing to the\r\nother child of the vertex. You stop inserting cookies when each leaf v\r\nhas at least h_v cookies in it. In this case, we say that the tree is\r\nfilled up. You have q queries. Each query changes the value of h_v for\r\nsome leaf v. You need to print q + 1 numbers, the i-th of them being the\r\nminimum number of cookies required to fill up the machine after (i - 1)\r\nupdates if you can pick any initial state for every selector. Since\r\nthese numbers may be very large, print the answers modulo 998\r\n,244\r\n,353.Please note that you can choose the initial state of all selectors\r\nindependently between queries. However, the queries themselves are not\r\nindependent: when answering the i-th query, you should also consider the\r\neffect of queries 1, 2,\r\nldots, i - 1.\r\n",
    "solutions": [
        "/*\nAuthor: QAQAutoMaton\nLang: C++\nCode: H.cpp\nMail: [email\u00a0protected]\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(qaq...) fprintf(stderr,qaq)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\ntemplate<class T,class ...T2>T mmin(T a,T2 ...b){return mmin(a,mmin(b...));}\ntemplate<class T,class ...T2>T mmax(T a,T2 ...b){return mmax(a,mmax(b...));}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst int p=998244353;\nint fpm(int a,int b){\n\tint c=1;\n\tfor(;b;b>>=1,a=(ll)a*a%p)if(b&1)c=(ll)c*a%p;\n\treturn c;\n}\nnamespace run{\n\tint n;\n\tvector<int> to[200005];\n\tint f[19][200005];\n\tint fa[200005],d[200005];\n\tint dfn[200005],low[200005],val[200005],t;\n\tvoid dfs(int x){\n\t\tf[0][x]=fa[x];\n\t\tdfn[x]=++t;\n\t\tval[t]=x;\n\t\tfor(int i=1;i<=18;++i)f[i][x]=f[i-1][f[i-1][x]];\n\t\tfor(auto i:to[x])dfs(i);\n\t\tlow[x]=t;\n\t}\n\tint lca(int x,int y){\n\t\tx=val[x];y=val[y];\n\t\tif(d[x]<d[y])swap(x,y);\n\t\tfor(int i=18;~i;--i)if(d[x]-(1<<i)>=d[y])x=f[i][x];\n\t\tif(x==y)return x;\n\t\tfor(int i=18;~i;--i)if(f[i][x]!=f[i][y]){x=f[i][x];y=f[i][y];}\n\t\treturn f[0][x];\n\t}\n\n\tint *s1[20000005],ov1[2000005],t1,t2,t3;\n\tvoid setv(int &a,int b){\n\t\ts1[++t1]=&a;ov1[t1]=a;a=b;\n\t}\n\tvoid revert1(){\n\t\t*s1[t1]=ov1[t1];--t1;\n\t}\n\tset<int> **s2[1000005],*ov2[1000005];//???\n\tset<int> *s3[10000005];\n\tint dlv[10000005];//???\n\tbitset<10000005>tp;\n\tvoid setv(set<int> * &a,set<int> *b){\n\t\ts2[++t2]=&a;\n\t\tov2[t2]=a;a=b;\n\t}\n\tvoid revert2(){\n\t\t*s2[t2]=ov2[t2];--t2;\n\t}\n\tvoid Ins(set<int> *x,int y){\n\t\ts3[++t3]=x;\n\t\tdlv[t3]=y;\n\t\ttp[t3]=0;\n\t\tx->insert(y);\n\t}\n\tvoid Del(set<int> *x,set<int>::iterator y){\n\t\ts3[++t3]=x;\n\t\tdlv[t3]=*y;\n\t\ttp[t3]=1;\n\t\tx->erase(y);\n\t}\n\tvoid revert3(){\n\t\tif(tp[t3])s3[t3]->insert(dlv[t3]);\n\t\telse s3[t3]->erase(dlv[t3]);\n\t\t--t3;\n\t}\n\n\tint pw[200005];\n\tint nxt[200005];\n\tset<int> stv[6000005],*cur=stv;\n\tset<int> *nodes[200005],*oval[1<<18|5];\n\tint mx[1<<18|5];\n\tint a[200005],at[200005];\n\tpii cmx(-1,0);\n\tint less(pii a,pii b){\n\t\tif(a.x<0)return 1;\n\t\tif((!a.x)!=(!b.x))return !a.x;\n\t\tif(!a.x && !b.x)return 0;\n\t\t// a.x*2^a.y+2c<y*2^d?\n\t\tif(abs(a.y-b.y)>30)return a.y<b.y;\n\t\tint v=min(a.y,b.y);\n\t\ta.y-=v;\n\t\tb.y-=v;\n\t\treturn (((ll)a.x)<<a.y) < (((ll)b.x)<<b.y);\n\t}\n\tint equal(pii a,pii b){\n\t\t// a.x*2^a.y+2c<y*2^d?\n\n\t\tif((!a.x)!=(!b.x))return 0;\n\t\tif(!a.x && !b.x)return 1;\n\t\tif(abs(a.y-b.y)>30)return 0;\n\t\tint v=min(a.y,b.y);\n\t\ta.y-=v;\n\t\tb.y-=v;\n\t\treturn (((ll)a.x)<<a.y) == (((ll)b.x)<<b.y);\n\t}\n\n\tconst int lim=1<<30;\n\tint xdp[200005];\n\tint merge(int x,int y){\n\t\treturn x==y?(x<<1|1):(max(x,y)<<1);\n\t\n\t}\n\tvoid setval(int x,int y){\n\t\t--y;\n\t\tif(!y){\n\t\t\tint dx=0;\n\t\t\tif(mx[y]>dx){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(mx[y]<dx){\n\t\t\t\tsetv(mx[y],dx);\n\t\t\t\tsetv(oval[y],++cur);\t\n\t\t\t\toval[y]->clear();\n\t\t\t}\n\t\t\tif(mx[y]==dx){\n\t\t\t\tpii mx={-inf,-inf};\n\t\t\t\tint cx=dfn[x];\n\t\t\t\tauto it=oval[y]->lower_bound(cx);\n\t\t\t\tif(it!=oval[y]->end()){\n\t\t\t\t\tif(*it==cx)return;\n\t\t\t\t\tint z=lca(cx,*it);\n\t\t\t\t\tchkmax(mx,pii(d[z],z));\n\t\t\t\t}\n\t\t\t\tif(it!=oval[y]->begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tint z=lca(cx,*it);\n\t\t\t\t\tchkmax(mx,pii(d[z],z));\n\t\t\t\t}\n\t\t\t\tIns(oval[y],cx);\n\t\t\t\tif(mx.x<0)goto ed;\n\t\t\t\ty|=1;\n\t\t\t\tx=mx.y;\n\t\t\t}\n\t\t}\n\t\tif(y<=xdp[x])return;\n\t\tsetv(xdp[x],y);\n\t\twhile(x!=1 && y<lim){\n\t\t\tx=fa[x];\n\t\t\tsetv(xdp[x],merge(xdp[to[x][0]],xdp[to[x][1]]));\n\t\t\tif((xdp[x]-y-y)>1)return;\n\t\t\ty=xdp[x];\n\t\t\t// dp[x]=y;\n\t\t}\n\t\ted:;\n\t\tif(less(cmx,{y,d[x]})){\n\t\t\tcmx={y,d[x]};\n\t\t\tsetv(nodes[n+1],++cur);\n\t\t\tsetv(nxt[n+1],-1);\n\t\t\tnodes[n+1]->clear();\n\t\t}\n\t\tif(equal(cmx,{y,d[x]})){\n\t\t\tint at=n+1;\n\t\t\tint cx=dfn[x];\n\t\t\twhile(1){\n\t\t\t\tpii mx={-inf,-inf};\n\t\t\t\tauto it=nodes[at]->lower_bound(cx);\n\t\t\t\tif(it!=nodes[at]->end()){\n\t\t\t\t\tif(*it==cx)return;\n\t\t\t\t\tint x=lca(cx,*it);\n\t\t\t\t\tif(dfn[x]==cx)return;\n\t\t\t\t\tchkmax(mx,pii(d[x],x));\n\t\t\t\t}\n\t\t\t\tif(it!=nodes[at]->begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tint x=lca(cx,*it);\n\t\t\t\t\twhile(dfn[x]==*it){\n\t\t\t\t\t\tif(it==nodes[at]->begin()){\n\t\t\t\t\t\t\tx=-1;\n\t\t\t\t\t\t\tDel(nodes[at],it);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto oit=it;\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tDel(nodes[at],oit);\n\t\t\t\t\t\tx=lca(cx,*it);\n\t\t\t\t\t}\n\t\t\t\t\tif(x!=-1)chkmax(mx,pii(d[x],x));\n\t\t\t\t}\n\t\t\t\tIns(nodes[at],cx);\n\t\t\t\tif(mx.x>nxt[at]){\n\t\t\t\t\tsetv(nxt[at],mx.x);\n\t\t\t\t\tsetv(nodes[nxt[at]],++cur);\n\t\t\t\t\tsetv(nxt[nxt[at]],-1);\n\t\t\t\t}\n\t\t\t\tif(mx.x==nxt[at]){\n\t\t\t\t\tcx=dfn[mx.y];\n\t\t\t\t\tat=nxt[at];\n\t\t\t\t}\n\t\t\t\telse return;\n\t\t\t}\n\t\t}\n\t}\n\tstruct smt{\n\t\tvector<pii> ask;\n\t\tint ls,rs;\n\t\tsmt *l,*r;\n\t\tsmt(){}\n\t\tsmt(int,int);\n\t\tvoid add(int la,int ra,pii w){\n\t\t\tif(la<=ls && rs<=ra){\n\t\t\t\task.emplace_back(w);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(la<=l->rs)l->add(la,ra,w);\n\t\t\tif(r->ls<=ra)r->add(la,ra,w);\n\t\t}\n\t\tvoid solve(){\n\t\t\tpii oc=cmx;\n\t\t\tint ct1=t1,ct2=t2,ct3=t3;\n\t\t\tset<int> *ocur=cur;\n\t\t\tfor(auto i:ask){\n\t\t\t\tsetval(i.x,i.y);\n\t\t\t}\n\t\t\tif(ls==rs){\n\t\t\t\tif(cmx.x<0){\n\t\t\t\t\twrite(\"0\\n\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint ans=((ll)cmx.x*pw[cmx.y]+1)%p;\n\t\t\t\t\tfor(int i=nxt[n+1];i>=0;i=nxt[i])ans=(ans+pw[i])%p;\n\t\t\t\t\twrite(ans,'\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl->solve();r->solve();\n\t\t\t}\n\t\t\tcmx=oc;\n\t\t\tcur=ocur;\n\t\t\twhile(t1>ct1)revert1();while(t2>ct2)revert2();\n\t\t\twhile(t3>ct3)revert3();\n\t\t}\n\t};\n\tsmt node[400005],*vat=node,*rt;\n\tsmt *newsmt(int la,int ra){\n\t\tsmt *rt=vat;++vat;\n\t\t*rt=smt(la,ra);\n\t\treturn rt;\n\t}\n\tsmt::smt(int la,int ra){\n\t\tls=la;rs=ra;\n\t\task.clear();\n\t\tif(ls==rs){\n\t\t\tl=r=0;return;\n\t\t}\n\t\tint mid=(ls+rs)>>1;\n\t\tl=newsmt(ls,mid);\n\t\tr=newsmt(mid+1,rs);\n\t}\n\tbool main(){\n\t\tread(n);\n\t\tcmx={-1,0};\n\t\tfor(int i=1;i<=n;++i)xdp[i]=-1;\n\t\tpw[0]=1;\n\t\tfor(int i=0;i<(1<<18);++i)mx[i]=-1;\n\t\tfor(int i=1;i<=n;++i)pw[i]=(pw[i-1]<<1)%p;\n\t\tfor(int i=0;i<=n+1;++i)nxt[i]=-1;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tread(fa[i]);\n\t\t\tto[fa[i]].emplace_back(i);\n\t\t\td[i]=d[fa[i]]+1;\n\t\t}\n\t\tdfs(1);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tread(a[i]);\n\t\t\tat[i]=0;\n\t\t}\n\t\tint q;\n\t\tread(q);\n\t\trt=newsmt(0,q);\n\t\tfor(int i=1;i<=q;++i){\n\t\t\tint x,y;\n\t\t\tread(x,y);\n\t\t\tif(a[x])rt->add(at[x],i-1,{x,a[x]});\n\t\t\tat[x]=i;a[x]=y;\n\t\t}\n\t\tfor(int i=1;i<=n;++i)if(a[i])rt->add(at[i],q,{i,a[i]});\n\t\trt->solve();\n\t\treturn 0;\n\t}\n}\n// dp[x]=(dp[ls]==dp[rs]?dp[ls]<<1):(max(dp[ls],dp[rs])<<1)-1\n// \u8003\u8651\u6240\u6709\u80fd\u53d6\u5230max\u7684\u4f4d\u7f6e\uff0c\u628a\u5b83\u4eec\u7684\u865a\u6811\u641e\u51fa\u6765(?)\n// \u627e\u5230\u6700\u6df1\u7684\u5408\u5e76\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u53ea\u7559\u4e0b\u8fd9\u4e9b\u4f4d\u7f6e\u9012\u5f52\u4e00\u6b21\uff0c\u7ed9\u7b54\u6848\u52a0\u4e0a\u8fd9\u4e2a2^\u6df1\u5ea6\n// \u7ebf\u6bb5\u6811\u5206\u6cbb\u4e00\u4e0b\uff0c\u6539\u6210\u4ec5chkmax\n// \u90a3\u5c31\u7ef4\u62a4\u6bcf\u4e00\u5c42\u8fd9\u6837\u7684\u7ed3\u6784(\uff1f\n// wc, 8s\uff0c\u90a3\u62113log\u4e86\uff0c\u868c\n// \u770b\u4e0a\u53bbO(n)-O(1)lca\u80fd2log\n// \u4e0d\u80fd\uff0c\u5f97set.lowerbound\n// \u8349\uff0c\u4fee\u4e0d\u5b8c\u4e86\n// tmd \u6839\u672c\u8fc7\u4e0d\u4e86\u62cd\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"H.in\",\"r\",stdin);\n\tfreopen(\"H.out\",\"w\",stdout);\n#endif\n\trun::main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Goldberg Machine 3.json",
    "editorial_link": "https://codeforces.com//blog/entry/119902",
    "editorial": "Let\u00e2\u0080\u0099s consider a dynamic programming approach: for leaves, set , and for\r\nan internal vertex with children and , set we use an indicator notation\r\n.Let , then the update becomes . Let denote the distance from the root\r\nto , and . Then .Notice that the binary representation of contains at\r\nmost ones (). This can be easily proven by induction: suppose the\r\nminimum size of a tree that can result in having ones is . Then, when ,\r\nand otherwise, since must be constructed from equal and from independent\r\nsubtrees.We\u00e2\u0080\u0099ll maintain a set of pairs , where is a lower bound on .\r\nInitially, put pairs into for all leaves with , and if there are and in\r\n(), put into , where . The answer is the maximum among all pairs in (if\r\nis empty, the answer is obviously ).Start with an empty and add all the\r\nleaves to it. A new pair can create at most one new lca with pairs , and\r\nat most one new pair , where is necessarily a new bit. The process of\r\ncreating new pairs continues, but it will finish in iterations since\r\nthere cannot be more bits. Different values can be stored in a trie\r\nbased on bit positions from most significant to least significant (or by\r\nsome hashing), and vertex sets in the trie nodes can be stored in the\r\norder of entry time.To change , remove the old pair from (similarly to\r\nadding) and add the new one. All together requires operations.\r\n"
}