{
    "link": "https://codeforces.com//contest/1810/problem/B",
    "problemId": "1858187",
    "problem_idx": "B",
    "shortId": "1810B",
    "contest_number": "1810",
    "problem_submissions": {
        "H": [
            200016390,
            200313241,
            200015282,
            200812601,
            200812580
        ],
        "G": [
            199990963,
            200002014,
            199996533,
            200001110,
            200003038,
            200004181,
            200005432,
            199993820,
            200004120,
            200568360,
            200010476,
            200003987,
            200009790,
            200084069,
            200013246,
            200017198,
            200016482,
            200017082
        ],
        "F": [
            199985968,
            199984766,
            199989455,
            199989236,
            199990364,
            199996618,
            199996912,
            199994977,
            200012837,
            199994874,
            200568272,
            200001624,
            200000551,
            200004906,
            200000508,
            200003276,
            200003731,
            200007640,
            199989234,
            200033060,
            200032756,
            200032417,
            199995728
        ],
        "E": [
            199973604,
            199973630,
            199978803,
            199976534,
            199977412,
            199980989,
            199981737,
            199978795,
            199980030,
            199987523,
            200568220,
            199981333,
            199992052,
            199984164,
            199985692,
            199981426,
            199983733,
            199981446,
            199972392,
            199985691
        ],
        "D": [
            199968387,
            199968634,
            199971474,
            199971965,
            199971391,
            199974445,
            199974261,
            199971649,
            199972646,
            199975130,
            200568168,
            199974978,
            199975450,
            199972122,
            199977461,
            199974856,
            199972685,
            199972896,
            199981843,
            199971530
        ],
        "C": [
            199963369,
            199964848,
            199966060,
            199965953,
            199966410,
            199967396,
            199960693,
            199966704,
            199968525,
            199967275,
            200567509,
            199968793,
            199967659,
            199965932,
            199965761,
            199966489,
            199966901,
            199965471,
            199965927,
            199965128
        ],
        "B": [
            199960187,
            199959404,
            199963381,
            199961597,
            199960246,
            199963356,
            199965608,
            199963400,
            199964087,
            199961201,
            200567461,
            199963792,
            199967959,
            199962648,
            199961478,
            199962690,
            199964055,
            199962786,
            199961957,
            199961076
        ],
        "A": [
            199957585,
            199957600,
            199957721,
            199957828,
            199957624,
            199957823,
            199967044,
            199957994,
            199959433,
            199957593,
            200567421,
            199957914,
            199957630,
            199957622,
            199957736,
            199957568,
            199959457,
            199957708,
            199957575,
            199957879
        ]
    },
    "name": "B. Candies",
    "statement": "This problem is about candy. Initially, you only have 1 candy, and you\r\nwant to have exactly n candies.You can use the two following spells in\r\nany order at most 40 times in total. Assume you have x candies now. If\r\nyou use the first spell, then x candies become 2x-1 candies. Assume you\r\nhave x candies now. If you use the second spell, then x candies become\r\n2x+1 candies. Construct a sequence of spells, such that after using them\r\nin order, you will have n candies, or determine itâ€™s impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    if (n % 2 == 0) {\n        std::cout << -1 << \"\\n\";\n        return;\n    }\n    \n    std::vector<int> ans;\n    while (n != 1) {\n        if ((n + 1) / 2 % 2 == 1) {\n            n += 1;\n            ans.push_back(1);\n        } else {\n            n -= 1;\n            ans.push_back(2);\n        }\n        n /= 2;\n    }\n    \n    std::reverse(ans.begin(), ans.end());\n    std::cout << ans.size() << \"\\n\";\n    for (int i = 0; i < ans.size(); i++) {\n        std::cout << ans[i] << \" \\n\"[i == ans.size() - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Candies.json",
    "editorial_link": "https://codeforces.com//blog/entry/114521",
    "editorial": "First, we notice that after each operation, the number of\ncandies is always a odd number. So even numbers can not be achieved.Then\nconsider how the binary representation changes for a odd number , after\nturn it into or . For the operation: turns into . For the operation:\nturns into . So, the operation is just insert a before the last digit.\nAnd the answer for an odd is just the binary representation of , after\nremoving the last digit.\n",
    "hint": []
}