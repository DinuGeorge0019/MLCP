{
    "link": "https://codeforces.com//contest/1704/problem/G",
    "problemId": "1489130",
    "problem_idx": "G",
    "shortId": "1704G",
    "contest_number": "1704",
    "problem_submissions": {
        "G": [
            166399832,
            166392509,
            166397270,
            166638387,
            166637822,
            166637785,
            166398104,
            166405958,
            166752775
        ],
        "H1": [
            166382413,
            166388635,
            166396747,
            166390624,
            166393948,
            166394968,
            166395394,
            166395219,
            166399131,
            166395533,
            167610683,
            166399678,
            166398389,
            166393517,
            166397144,
            166394482,
            166410457,
            166410434,
            166410387,
            166397758,
            166388826
        ],
        "F": [
            166375942,
            166373341,
            166380920,
            166379078,
            166375083,
            166374406,
            166381370,
            166374889,
            166379414,
            166377998,
            166381484,
            166382056,
            166383687,
            167610801,
            167610658,
            166377446,
            166386899,
            166386972,
            166382080,
            166385431,
            166386767,
            166397839
        ],
        "E": [
            166364243,
            166366722,
            166377362,
            166370668,
            166369471,
            166363533,
            166365063,
            166369098,
            166371591,
            166372062,
            166371621,
            166363068,
            166369922,
            167610979,
            166372272,
            166368343,
            166370920,
            166372137,
            166377343,
            166374205,
            166366243
        ],
        "D": [
            166356732,
            166359032,
            166354225,
            166361715,
            166364424,
            166358723,
            166360532,
            166363384,
            166359682,
            166359426,
            166360174,
            166357237,
            166358099,
            167610772,
            167610622,
            166360647,
            166358359,
            166360520,
            166363303,
            166368469,
            166361316,
            166360453
        ],
        "C": [
            166354884,
            166355766,
            166368189,
            166358588,
            166361497,
            166354947,
            166356916,
            166357737,
            166356376,
            166355591,
            166357410,
            166354410,
            166354789,
            167610761,
            167610600,
            166356402,
            166355566,
            166357431,
            166360930,
            166363594,
            166359066,
            166357566
        ],
        "B": [
            166350601,
            166350801,
            166351510,
            166352475,
            166352194,
            166351471,
            166350940,
            166351732,
            166351784,
            166352133,
            166351498,
            166351569,
            166351237,
            167610589,
            166351144,
            166351469,
            166352214,
            166353113,
            166355462,
            166352514,
            166351316
        ],
        "A": [
            166350367,
            166350415,
            166350414,
            166351113,
            166350822,
            166350510,
            166350405,
            166350518,
            166350539,
            166350824,
            166350499,
            166350452,
            166350409,
            167610545,
            166350456,
            166350502,
            166350981,
            166354346,
            166351283,
            166350461,
            166350432
        ],
        "H2": [
            166808527
        ]
    },
    "name": "G. Mio and Lucky Array",
    "statement": "Mio has an array a consisting of n integers, and an array b consisting\r\nof m integers. Mio can do the following operation to a: Choose an\r\ninteger i (1\r\nleq i\r\nleq n) that has been chosen before, then add 1 to a_i, subtract 2 from\r\na_{i+1}, add 3 to a_{i+2} an so on. Formally, the operation is to add\r\n(-1)^{j-i}\r\ncdot (j-i+1) to a_j for i\r\nleq j\r\nleq n.Mio wants to transform a so that it will contain b as a . Could\r\nyou answer her question, and provide a sequence of operations to do so,\r\nif it is possible?An array b is a of an array a if b can be obtained\r\nfrom a by deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 31.07.2022 18:53:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize((__int128) value * rhs.value % mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr long long md = (1LL << 61) - 1;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nmt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\nuint64_t step = (md >> 2) + rng() % (md >> 1);\n\n// make it understandable one day...\nnamespace fft {\n\ntypedef double dbl;\n\nstruct num {\n  dbl x, y;\n  num() { x = y = 0; }\n  num(dbl x_, dbl y_) : x(x_), y(y_) {}\n};\n\ninline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\ninline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\ninline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\ninline num conj(num a) { return num(a.x, -a.y); }\n\nint base = 1;\nvector<num> roots = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\n\nconst dbl PI = static_cast<dbl>(acosl(-1.0));\n\nvoid ensure_base(int nbase) {\n  if (nbase <= base) {\n    return;\n  }\n  rev.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); i++) {\n    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n    for (int i = 1 << (base - 1); i < (1 << base); i++) {\n      roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n      dbl angle_i = angle * (2 * i + 1 - (1 << base));\n      roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n    }\n    base++;\n  }\n}\n\nvoid fft(vector<num>& a, int n = -1) {\n  if (n == -1) {\n    n = (int) a.size();\n  }\n  assert((n & (n - 1)) == 0);\n  int zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; i++) {\n    if (i < (rev[i] >> shift)) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        num z = a[i + j + k] * roots[j + k];\n        a[i + j + k] = a[i + j] - z;\n        a[i + j] = a[i + j] + z;\n      }\n    }\n  }\n}\n\nvector<num> fa, fb;\n\nvector<int64_t> square(const vector<int>& a) {\n  if (a.empty()) {\n    return {};\n  }\n  int need = (int) a.size() + (int) a.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if ((sz >> 1) > (int) fa.size()) {\n    fa.resize(sz >> 1);\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n    int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz >> 1);\n  num r(1.0 / (sz >> 1), 0.0);\n  for (int i = 0; i <= (sz >> 2); i++) {\n    int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n    num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n    num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n    num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n    num tmp = fe * fo;\n    fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n    fa[j] = r * (aux + num(0, 2) * tmp);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int64_t> multiply(const vector<int>& a, const vector<int>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (a == b) {\n    return square(a);\n  }\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < sz; i++) {\n    int x = (i < (int) a.size() ? a[i] : 0);\n    int y = (i < (int) b.size() ? b[i] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz);\n  num r(0, -0.25 / (sz >> 1));\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n    fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n    fa[i] = z;\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n    num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n    fa[i] = A0 + A1 * num(0, 1);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  int eq = (a.size() == b.size() && a == b);\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < (int) a.size(); i++) {\n    int x = (a[i] % m + m) % m;\n    fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n  }\n  fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});\n  fft(fa, sz);\n  if (sz > (int) fb.size()) {\n    fb.resize(sz);\n  }\n  if (eq) {\n    copy(fa.begin(), fa.begin() + sz, fb.begin());\n  } else {\n    for (int i = 0; i < (int) b.size(); i++) {\n      int x = (b[i] % m + m) % m;\n      fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n    }\n    fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});\n    fft(fb, sz);\n  }\n  dbl ratio = 0.25 / sz;\n  num r2(0, -1);\n  num r3(ratio, 0);\n  num r4(0, -ratio);\n  num r5(0, 1);\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num a1 = (fa[i] + conj(fa[j]));\n    num a2 = (fa[i] - conj(fa[j])) * r2;\n    num b1 = (fb[i] + conj(fb[j])) * r3;\n    num b2 = (fb[i] - conj(fb[j])) * r4;\n    if (i != j) {\n      num c1 = (fa[j] + conj(fa[i]));\n      num c2 = (fa[j] - conj(fa[i])) * r2;\n      num d1 = (fb[j] + conj(fb[i])) * r3;\n      num d2 = (fb[j] - conj(fb[i])) * r4;\n      fa[i] = c1 * d1 + c2 * d2 * r5;\n      fb[i] = c1 * d2 + c2 * d1;\n    }\n    fa[j] = a1 * b1 + a2 * b2 * r5;\n    fb[j] = a1 * b2 + a2 * b1;\n  }\n  fft(fa, sz);\n  fft(fb, sz);\n  vector<int> res(need);\n  for (int i = 0; i < need; i++) {\n    int64_t aa = llround(fa[i].x);\n    int64_t bb = llround(fb[i].x);\n    int64_t cc = llround(fa[i].y);\n    res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);\n  }\n  return res;\n}\n\n}  // namespace fft\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type operator*(\n    const vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (min(a.size(), b.size()) < 150) {\n    vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        c[i + j] += a[i] * b[j];\n      }\n    }\n    return c;\n  } \n  vector<int> a_mul(a.size());\n  for (int i = 0; i < (int) a.size(); i++) {\n    a_mul[i] = static_cast<int>(a[i]);\n  }\n  vector<int> b_mul(b.size());\n  for (int i = 0; i < (int) b.size(); i++) {\n    b_mul[i] = static_cast<int>(b[i]);\n  }\n  vector<int> c_mul = fft::multiply_mod(a_mul, b_mul, T::value);\n  vector<Modular<T>> c(c_mul.size());\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = c_mul[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type& operator*=(\n    vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  return a = a * b;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int m;\n    cin >> m;\n    vector<long long> b(m);\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n    }\n    vector<Mint> pw(n + 1);\n    pw[0] = 1;\n    for (int i = 0; i < n; i++) {\n      pw[i + 1] = pw[i] * step;\n    }\n    vector<Mint> add(n + 1);\n    add[0] = 0;\n    for (int i = 0; i < n; i++) {\n      add[i + 1] = add[i] * step + (i % 2 == 0 ? i + 1 : (-i - 1));\n    }\n    vector<Mint> pref_a(n + 1);\n    for (int i = 0; i < n; i++) {\n      pref_a[i + 1] = pref_a[i] * step + a[i];\n    }\n    vector<Mint> pref_b(m + 1);\n    for (int i = 0; i < m; i++) {\n      pref_b[i + 1] = pref_b[i] * step + b[i];\n    }\n    vector<Mint> aux1(n + 1);\n    for (int i = 0; i < n; i++) {\n      aux1[i + 1] = aux1[i] * step + (i % 2 == 0 ? 1 : -1);\n    }\n    vector<Mint> aux2(n + 1);\n    for (int i = 0; i < n; i++) {\n      aux2[i + 1] = aux2[i] * step + (i % 2 == 0 ? -i : i);\n    }\n    auto FindMax = [&](long long odds, long long evens, long long limit) {\n      if (limit % 2 == 0) {\n        limit -= 1;\n      }\n      // limit + (limit - 2) + ... + (limit - 2 * odds + 2)\n      long long s1 = (limit + (limit - 2 * odds + 2)) * odds / 2;\n      // - 2 - 4 - ... - 2 * evens\n      long long s2 = evens * (evens + 1);\n      long long res = s1 - s2;\n      long long nxt = (limit - 2 * odds) + (limit - 2 * odds - 2) - (2 * evens + 2) - (2 * evens + 4);\n      if (nxt > 0) {\n        long long cnt = nxt / 16 + 1;\n        // nxt + (nxt - 16) + ... + (nxt - 16 * (cnt - 1))\n        res += (nxt + (nxt - 16 * (cnt - 1))) * cnt / 2;\n      }\n      return res;\n    };\n    auto FindMin = [&](long long odds, long long evens, long long limit) {\n      if (limit % 2 == 1) {\n        limit -= 1;\n      }\n      // limit + (limit - 2) + ... + (limit - 2 * evens + 2)\n      long long s1 = (limit + (limit - 2 * evens + 2)) * evens / 2;\n      // 1 + 3 + ... + (2 * odds - 1)\n      long long s2 = odds * odds;\n      long long res = s2 - s1;\n      long long nxt = (limit - 2 * evens) + (limit - 2 * evens - 2) - (2 * odds + 1) - (2 * odds + 3);\n      if (nxt > 0) {\n        long long cnt = nxt / 16 + 1;\n        // nxt + (nxt - 16) + ... + (nxt - 16 * (cnt - 1))\n        res -= (nxt + (nxt - 16 * (cnt - 1))) * cnt / 2;\n      }\n      return res;\n    };\n    auto Can = [&](long long sum, long long diff, long long limit) {\n      long long odds = (diff > 0 ? diff : 0);\n      long long evens = (diff < 0 ? -diff : 0);\n      if ((odds & 1) != (sum & 1)) {\n        odds += 1;\n        evens += 1;\n      }\n      if (odds > (limit + 1) / 2 || evens > limit / 2) {\n        return false;\n      }\n      long long mx = FindMax(odds, evens, limit);\n      long long mn = FindMin(odds, evens, limit);\n      return (mn <= sum && sum <= mx);\n    };\n    auto MUL = [&](vector<Mint> pa, vector<Mint> pb) {\n      int sz = (int) pa.size() + (int) pb.size() - 1;\n      vector<vector<int>> help(sz, vector<int>(3));\n      vector<int> mods = {998244353, (int) 1e9 + 7, (int) 1e9 + 9};\n      for (int id = 0; id < 3; id++) {\n        int mod = mods[id];\n        vector<int> qa(pa.size());\n        for (int i = 0; i < (int) pa.size(); i++) {\n          qa[i] = pa[i]() % mod;\n        }\n        vector<int> qb(pb.size());\n        for (int i = 0; i < (int) pb.size(); i++) {\n          qb[i] = pb[i]() % mod;\n        }\n        auto got = fft::multiply_mod(qa, qb, mod);\n        for (int i = 0; i < sz; i++) {\n          help[i][id] = got[i];\n        }\n      }\n      vector<Mint> pc(sz);\n      for (int pos = 0; pos < sz; pos++) {\n        Mint res = 0;\n        Mint mult = 1;\n        vector<int> x(3);\n        for (int i = 0; i < 3; i++) {\n          x[i] = help[pos][i];\n          for (int j = 0; j < i; j++) {\n            long long cur = (x[i] - x[j]) * 1LL * inverse(mods[j], mods[i]);\n            x[i] = (int)( (cur % mods[i] + mods[i]) % mods[i] );\t\t\t\t\t\n          }\n          res += mult * x[i];\n          mult *= mods[i];\n        }\n        pc[pos] = res;\n      }\n      return pc;\n    };\n    vector<Mint> extra(n - m + 1);\n    if (m > 2) {\n      for (int v = 0; v < 2; v++) {\n        vector<Mint> pa(n - 2);\n        for (int i = 1; i < n - 1; i++) {\n          if (((a[i - 1] - 2 * a[i] + a[i + 1]) & 1) == v) {\n            pa[i - 1] = 1;\n          }\n        }\n        vector<Mint> pb(m - 2);\n        for (int i = 1; i < m - 1; i++) {\n          if (((b[i - 1] - 2 * b[i] + b[i + 1]) & 1) != v) {\n            pb[i - 1] = add[m - 1 - i];\n          }\n        }\n        reverse(pb.begin(), pb.end());\n        auto pc = MUL(pa, pb);\n        for (int pos = 0; pos <= n - m; pos++) {\n          extra[pos] += pc[pos + m - 3];\n        }\n      }\n    }\n    bool found = false;\n    for (int pos = 0; pos <= n - m; pos++) {\n      Mint h = pref_a[pos + m] - pref_a[pos] * pw[m];\n      h += extra[pos];\n/*      for (int i = 1; i < m - 1; i++) {\n        int in_a = (a[pos + i - 1] - 2 * a[pos + i] + a[pos + i + 1]) & 1;\n        int in_b = (b[0 + i - 1] - 2 * b[0 + i] + b[0 + i + 1]) & 1;\n        if (in_a != in_b) {\n          h += add[m - 1 - i];\n        }\n      }*/\n      long long da = b[0] - a[pos + 0];\n      long long db = b[1] - a[pos + 1];\n      long long sum = db;\n      long long diff = da + db;\n      long long limit = pos + 2;\n      h += aux1[m] * da + aux2[m] * diff;\n      if (h == pref_b[m]) {\n        if (Can(sum, diff, limit)) {\n          vector<int> res;\n          for (int i = 1; i < m - 1; i++) {\n            int in_a = (a[pos + i - 1] - 2 * a[pos + i] + a[pos + i + 1]) & 1;\n            int in_b = (b[0 + i - 1] - 2 * b[0 + i] + b[0 + i + 1]) & 1;\n            if (in_a != in_b) {\n              res.push_back(pos + i + 1);\n            }\n          }\n          for (long long val = limit; val >= 1; val--) {\n            if (!Can(sum, diff, val - 1)) {\n              res.push_back(pos + 2 - val);\n              if (val % 2 == 1) {\n                sum -= val;\n                diff -= 1;\n              } else {\n                sum += val;\n                diff += 1;\n              }\n            }\n          }\n          assert(sum == 0 && diff == 0);\n          sort(res.begin(), res.end());\n          cout << res.size() << '\\n';\n          for (int i = 0; i < (int) res.size(); i++) {\n            cout << res[i] + 1 << \" \\n\"[i == (int) res.size() - 1];\n          }\n          found = true;\n          break;\n        }\n      }\n    }\n    if (!found) {\n      cout << -1 << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "fft",
        "math",
        "strings"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Mio and Lucky Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/105464",
    "editorial": "Letâs define . Cosidering after the operation on some index , for any ,\r\nwill remain the same; For , will be increased by . Then we can find the\r\noperation on is a single point operation on . It can be proved that the\r\nfollowing conditions are equivalent to the condition that can match :For\r\n, operation on will make . So the second condition restricts the\r\ndifference of operating times between odd positions and even positions\r\namong first positions. When conducting an operation on it will make .So\r\nwe can convert the problem to: using , to make the number of\r\nsubtractions(operations which make be decreased) minus the number of\r\nadditions(operations which make be increased) is , and the final should\r\nbe .Further, suppose I first select all the subtractions(), i.e. take\r\nall the operation on odd/even(depending on the parity of ) positions. If\r\nI donât want to select it afterwards, it can be regarded as a re-add\r\noperation, then the first and second restrictions can be converted to ,\r\nwhere indicates that numbers need to be selected, and indicates that the\r\nselected sum is . All which satisfies are legal and easy to\r\nconstruct.Next consider the third restriction, the constructor . If or ,\r\nthen the above formula is 0. Whether respectively represents whether we\r\nneed to operate on , otherwise the above formula must be greater than 0.\r\nIf matches , then , otherwise it must not match. So consider how to\r\ncalculate . For is in the form of differential convolution, can be\r\nflipped and converted into polynomial multiplication, which can be\r\nsolved by FFT. The other items are also simple.Considering that may be\r\nquite large, you need to test several different prime numbers if you use\r\nNTT, in order to avoid hacking.The total time complexity .Also the\r\navailable which satisfies the third restriction can also be found using\r\nbitset, the total time complexity .\r\n",
    "hint": []
}