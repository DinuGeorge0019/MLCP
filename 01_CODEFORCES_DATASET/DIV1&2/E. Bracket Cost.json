{
    "link": "https://codeforces.com//contest/1750/problem/E",
    "problemId": "1626961",
    "problem_idx": "E",
    "shortId": "1750E",
    "contest_number": "1750",
    "problem_submissions": {
        "H": [
            179823917
        ],
        "G": [
            179612953,
            179618975,
            179623473,
            179614248,
            179621065,
            179645973,
            179633214,
            179622344,
            180705510,
            179933269,
            180030556,
            179950229,
            179707183
        ],
        "F": [
            179601347,
            179603972,
            179609105,
            179620641,
            179625110,
            179609284,
            179617930,
            179604395,
            179604949,
            179608846,
            179612187,
            179613972,
            179616254,
            179614949,
            179615429,
            179614224,
            179615399,
            179617910
        ],
        "E": [
            179577415,
            179590864,
            179604325,
            179609562,
            179600474,
            179602399,
            179611817,
            179580954,
            179591449,
            179601210,
            179600339,
            179600865,
            179602667,
            179599833,
            179601353,
            179598843,
            179836904,
            179836835,
            179604528,
            179600892,
            179603405
        ],
        "D": [
            179570869,
            179571769,
            179580666,
            179601268,
            179580689,
            179577888,
            179591514,
            179570023,
            179569288,
            179572989,
            179577454,
            179572611,
            179571219,
            179573391,
            179577136,
            179566640,
            179577304,
            179584005,
            179571264
        ],
        "C": [
            179566484,
            179564254,
            179566602,
            179574509,
            179568597,
            179566588,
            179569992,
            179564018,
            179563887,
            179567519,
            179569743,
            179565401,
            179565441,
            179566302,
            179568300,
            179573635,
            179569848,
            179573882,
            179567502
        ],
        "B": [
            179560866,
            179561834,
            179561786,
            179562451,
            179561566,
            179560845,
            179563612,
            179559937,
            179559753,
            179560949,
            179562540,
            179560960,
            179559578,
            179560145,
            179563310,
            179559663,
            179562762,
            179562300,
            179560917
        ],
        "A": [
            179559080,
            179559855,
            179559766,
            179559866,
            179559680,
            179559121,
            179560548,
            179559129,
            179559072,
            179559167,
            179559582,
            179559013,
            179559040,
            179559136,
            179561310,
            179568564,
            179559973,
            179560198,
            179559513
        ]
    },
    "name": "E. Bracket Cost",
    "statement": "Daemon Targaryen decided to stop looking like a Metin2 character. He\r\nturned himself into the most beautiful thing, a bracket sequence.For a\r\nbracket sequence, we can do two kind of operations: Select one of its\r\nsubstrings^\r\ndagger and cyclic shift it to the right. For example, after a cyclic\r\nshift to the right, \"\" will become \"\"; Insert any bracket, opening \u201d or\r\nclosing \u201d, wherever you want in the sequence. We define the of a bracket\r\nsequence as the number of such operations to make it balanced^\r\nddagger.Given a bracket sequence s of length n, find the sum of costs\r\nacross all its\r\nfrac{n(n+1)}{2} non-empty substrings. Note that for each substring we\r\ncalculate the cost .^\r\ndagger A string a is a substring of a string b if a can be obtained from\r\nb by deletion of several (possibly, zero or all) characters from the\r\nbeginning and several (possibly, zero or all) characters from the end.^\r\nddagger A sequence of brackets is called balanced if one can turn it\r\ninto a valid math expression by adding characters + and 1. For example,\r\nsequences \"\", \"\", and \"\" are balanced, while \"\", \"\", and \"\" are not.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don't erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = \"{\";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += \"}\";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return \"(\" + ts(p.f) + \", \" + ts(p.s) + \")\"; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = \"\";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn \"{\" + ts_sep(v, \", \") + \"}\";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += \",\";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = \" \";\n\t\tif (i == 0) bef = \"{\";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += \"}\";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, \"\", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << \"\\n\"; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, \" \", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, \" | \", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t), \"\\n\") << \"\\n\" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don't actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\"); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: 1D range minimum query. Can also do queries\n * for any associative operation in $O(1)$ with D\\&C\n * Source: KACTL\n * Verification:\n * https://cses.fi/problemset/stats/1647/\n * http://wcipeg.com/problem/ioi1223\n * https://pastebin.com/ChpniVZL\n * Memory: O(N\\log N)\n * Time: O(1)\n */\n\ntcT > struct RMQ {\n\tint level(int x) { return 31 - __builtin_clz(x); }\n\tV<T> v;\n\tV<vi> jmp;\n\tint cmb(int a, int b) {\n\t\treturn v[a] == v[b] ? min(a, b) : (v[a] < v[b] ? a : b);\n\t}\n\tvoid init(const V<T> &_v) {\n\t\tv = _v;\n\t\tjmp = {vi(sz(v))};\n\t\tiota(all(jmp[0]), 0);\n\t\tfor (int j = 1; 1 << j <= sz(v); ++j) {\n\t\t\tjmp.pb(vi(sz(v) - (1 << j) + 1));\n\t\t\tF0R(i, sz(jmp[j]))\n\t\t\tjmp[j][i] = cmb(jmp[j - 1][i], jmp[j - 1][i + (1 << (j - 1))]);\n\t\t}\n\t}\n\tint index(int l, int r) {\n\t\tassert(l <= r);\n\t\tint d = level(r - l + 1);\n\t\treturn cmb(jmp[d][l], jmp[d][r - (1 << d) + 1]);\n\t}\n\tT query(int l, int r) { return v[index(l, r)]; }\n};\n\nvoid solve(int tc) {\n\tints(N);\n\tstr S;\n\tre(S);\n\tvl cum{0};\n\teach(c, S) {\n\t\tif (c == '(') cum.pb(cum.bk + 1);\n\t\telse cum.pb(cum.bk - 1);\n\t}\n\tll ans = 0;\n\tvl sort_cum = cum;\n\tsor(sort_cum);\n\tR0F(i, sz(sort_cum)) ans += i * sort_cum[i];\n\tRMQ<ll> R;\n\tR.init(cum);\n\tfunction<void(int, int)> dfs = [&](int l, int r) {\n\t\tif (l >= r) return;\n\t\tint m = R.index(l, r);\n\t\t// dbg(l, m, r, cum.at(m), (ll)(r - m + 1) * (m - l + 1) - 1);\n\t\tans -= ((ll)(r - m + 1) * (m - l + 1) - 1) * cum.at(m);\n\t\tdfs(l, m - 1);\n\t\tdfs(m + 1, r);\n\t};\n\tdfs(0, sz(cum) - 1);\n\t// F0R(l, sz(cum)) {\n\t// \tll mn = cum[l];\n\t// \tFOR(r, l + 1, sz(cum)) {\n\t// \t\tckmin(mn, cum[r]);\n\t// \t\tans -= mn;\n\t// \t\t// ans += max(cum[l], cum[r]) - mn;\n\t// \t}\n\t// }\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Bracket Cost.json",
    "editorial_link": "https://codeforces.com//blog/entry/108504",
    "editorial": "SolutionLet if , if and be the prefix sum of .Theorem: the cost of is\r\nNecessity: after one operation, decrease at most one.Sufficiency: If ,\r\nwe can do operation 2, add a right bracket at the end of string.If , we\r\ncan do operation 2, add a left bracket at the beginning of string.If ,\r\nassume x be the largest x that , then , so we can do operation 1, cyclic\r\nshift to right.Under any condition, decrease one after one operation.We\r\ncan use binary index tree to calculate and .\r\n"
}