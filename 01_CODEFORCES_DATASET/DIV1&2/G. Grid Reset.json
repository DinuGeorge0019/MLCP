{
    "link": "https://codeforces.com//contest/1991/problem/G",
    "problemId": "2781507",
    "problem_idx": "G",
    "shortId": "1991G",
    "contest_number": "1991",
    "problem_submissions": {
        "H": [
            273210632,
            273212730,
            273219908,
            273194851,
            273200656,
            273213505,
            273204889,
            273220591,
            273225451,
            273220804,
            273226512,
            273222266,
            273229115,
            278405080,
            273216843
        ],
        "G": [
            273180456,
            273179521,
            273174064,
            273209283,
            273179708,
            273185549,
            273216085,
            273188851,
            273191410,
            273193985,
            273189153,
            273194518,
            273197531,
            273190195,
            273195818,
            273188177,
            273190908,
            273195464,
            273198241
        ],
        "F": [
            273160781,
            273160990,
            273158593,
            273158141,
            273171320,
            273168196,
            273159727,
            273170129,
            273173513,
            273170857,
            273165439,
            273182207,
            273174869,
            273166190,
            273163947,
            273173198,
            273175470,
            273163587,
            273174682,
            273170108
        ],
        "E": [
            273150868,
            273153734,
            273152235,
            273150823,
            273156934,
            273151786,
            273150935,
            273157824,
            273151366,
            273154414,
            273174335,
            273161395,
            273159133,
            273156803,
            273161464,
            273162124,
            273154749,
            273158567,
            273155964
        ],
        "D": [
            273143134,
            273144551,
            273142645,
            273141713,
            273147820,
            273143829,
            273141673,
            273145581,
            273156995,
            273145729,
            273149790,
            273146459,
            273144249,
            273145676,
            273154684,
            273150687,
            273147840,
            273144991,
            273148567
        ],
        "C": [
            273139495,
            273142387,
            273139319,
            273241170,
            273142853,
            273141897,
            273140491,
            273138783,
            273141460,
            273141958,
            273141853,
            273144830,
            273141321,
            273143714,
            273141051,
            273142758,
            273145128,
            273137630,
            273141184,
            273143400
        ],
        "B": [
            273133106,
            273134906,
            273133339,
            273134525,
            273138116,
            273135569,
            273133092,
            273135379,
            273136693,
            273135755,
            273136343,
            273135805,
            273132915,
            273135366,
            273136849,
            273139913,
            273132449,
            273135138,
            273136549
        ],
        "A": [
            273130858,
            273132065,
            273130939,
            273130875,
            273131982,
            273132539,
            273130929,
            273131106,
            273131228,
            273130992,
            273131052,
            273131178,
            273130862,
            273131382,
            273131308,
            273132778,
            273130871,
            273130965,
            273131362
        ],
        "I": [
            273238749,
            273429741
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132021",
    "editorial": "Here is a strategy to ensure you can perform operations infinitely:\n\nPerform horizontal operations only on the leftmost k\n columns and vertical operations only on the topmost k\n rows.\nPrioritize operations that will lead to a reset. If multiple operations can cause a reset, perform any of them; if no operations can cause a reset, perform any available operation.\nThe correctness of this strategy is intuitive but not straightforward to prove.\nProof of Correctness\n\nFor a n×m\n grid, we define it to be in a horizontal state if its black cells can be covered by non-overlapping 1×m\n rectangles without gaps. Similarly, the grid is in a vertical state if its black cells can be covered by non-overlapping n×1\n rectangles without gaps.\n\nOur strategy ensures the grid always satisfies the following properties:\n\nThe k×k\n region in the top-left corner, the (n?k)×k\n region in the bottom-left corner, and the k×(m?k)\n region in the top-right corner are either in a horizontal state, vertical state, or both.\nThe top-left and bottom-left regions cannot both be purely in a vertical state; similarly, the top-left and top-right regions cannot both be purely in a horizontal state.\nWe will prove two points: first, when these properties are satisfied, there is always a valid operation; second, after performing operations according to our strategy, the grid still satisfies these properties.\n\nExistence of Valid Operations\n\nAssume the current operation is horizontal (the proof for vertical operations is similar). If the top-left and bottom-left regions cannot perform a horizontal operation, they must be completely black or in a purely vertical state. If one region is completely black, the other cannot be completely black or purely vertical, because that would have led to a reset earlier. According to the second property, the top-left and bottom-left regions cannot both be in a purely vertical state. Therefore, there is always a valid operation.\n\nMaintaining the First Property\n\nFor the bottom-left and top-right regions, they always satisfy the first property. Proof: Consider the bottom-left region (the proof for the top-right region is similar). It starts as completely white, turning black row by row, maintaining a horizontal state. Once it is completely black, it resets column by column, maintaining a vertical state. Thus, it alternates between horizontal and vertical states.\nFor the top-left region, it always satisfies the first property. Proof: After coloring and before resetting, the top-left region still satisfies the first property. Suppose it is in a horizontal state before resetting (the proof for a vertical state is similar). Since it cannot reset vertically, it remains at least in a horizontal state after resetting. If it becomes completely black and resets horizontally (the proof for a vertical reset is similar), it remains in a horizontal state. Unless k=1\n, rows and columns cannot reset simultaneously. Suppose both rows and columns can reset, and assume the current operation is horizontal in the top-left region (the proof for a vertical operation is similar). This means the top-left region was in a purely horizontal state before turning completely black. The row in the top-right region was completely black, while other rows were white, contradicting the second property before the operation.\nMaintaining the Second Property\n\nAssume the current operation is horizontal (the proof for vertical operations is similar) and causes a reset, the second property still holds. Proof: If the operation is in the bottom-left region, it was completely black before resetting. After resetting, the top-left region turns completely white, maintaining the second property. We previously proved that unless k=1\n, rows and columns cannot reset simultaneously. If the horizontal operation is in the top-left region and columns reset, the top-left region was completely black before resetting. After resetting, the top-left region becomes vertical, while the bottom-left region turns white, maintaining the second property. If the horizontal operation is in the top-left region and rows reset, the top-left region remains unchanged, while the row in the top-right region turns white. If the top-right region's state changes and resets to a purely horizontal state (the only possible violation of the second property), the top-right region is completely black before resetting. Thus, the top-left region was not in a purely horizontal state before resetting. Since the top-left region remains unchanged, it cannot be in a purely horizontal state, maintaining the second property.\nAssume the current operation is horizontal (the proof for vertical operations is similar) and does not cause a reset, the second property still holds. Proof: If the operation is in the bottom-left region, it remains in a horizontal state, maintaining the second property. If the operation is in the top-left region, the only possible violation of the second property is if the top-right region remains in a purely horizontal state while the top-left region becomes purely horizontal. This means the top-left region was completely white before the operation. In this case, we can choose to reset any completely black row in the top-right region. According to the strategy, we prioritize resets, leading to a contradiction. Thus, the second property still holds.",
    "name": "G. Grid Reset",
    "statement": "You are given a grid consisting of n rows and m columns, where each cell\r\nis initially white. Additionally, you are given an integer k, where 1\r\nle k\r\nle\r\nmin(n, m).You will process q operations of two types:\r\nmathtt{H} (horizontal operation) You choose a 1\r\ntimes k rectangle completely within the grid, where all cells in this\r\nrectangle are white. Then, all cells in this rectangle are changed to\r\nblack.\r\nmathtt{V} (vertical operation) You choose a k\r\ntimes 1 rectangle completely within the grid, where all cells in this\r\nrectangle are white. Then, all cells in this rectangle are changed to\r\nblack. After each operation, if any rows or columns become completely\r\nblack, all cells in these rows and columns are reset to white.\r\nSpecifically, if all cells in the row and column a cell is contained in\r\nbecome black, all cells in both the row and column will be reset to\r\nwhite.Choose the rectangles in a way that you can perform all given\r\noperations, or determine that it is impossible.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 28.07.2024 11:33:15**/#include <bits/stdc++.h> using namespace std; #ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int tt;  cin >> tt;  while (tt--) {    int h, w, k, q;    cin >> h >> w >> k >> q;    string ops;    cin >> ops;    vector<vector<int>> a(h, vector<int>(w, 0));    vector<int> row(h, 0);    vector<int> col(w, 0);    auto Place = [&](int i1, int j1, int i2, int j2) {      for (int i = i1; i < i2; i++) {        for (int j = j1; j < j2; j++) {          assert(a[i][j] == 0);          a[i][j] = 1;          row[i] += 1;          col[j] += 1;        }      }      vector<pair<int, int>> kill;      for (int i = 0; i < h; i++) {        for (int j = 0; j < w; j++) {          if (a[i][j] == 1 && (row[i] == w || col[j] == h)) {            kill.emplace_back(i, j);          }        }      }      for (auto& [i, j] : kill) {        a[i][j] = 0;        row[i] -= 1;        col[j] -= 1;      }    };    auto PrintH = [&](int i, int j) {      cout << i + 1 << \" \" << j + 1 << '\\n';      Place(i, j, i + 1, j + k);    };    auto PrintV = [&](int i, int j) {      cout << i + 1 << \" \" << j + 1 << '\\n';      Place(i, j, i + k, j + 1);    };    auto PutH = [&]() {      for (int i = k; i < h; i++) {        if (row[i] == 0) {          PrintH(i, 0);          return;        }      }      int mx = -1;      int id = -1;      for (int i = 0; i < k; i++) {        if (a[i][0] == 0 && row[i] > mx) {          mx = row[i];          id = i;        }      }      assert(id != -1);      PrintH(id, 0);    };    auto PutV = [&]() {      for (int i = k; i < w; i++) {        if (col[i] == 0) {          PrintV(0, i);          return;        }      }      int mx = -1;      int id = -1;      for (int i = 0; i < k; i++) {        if (a[0][i] == 0 && col[i] > mx) {          mx = col[i];          id = i;        }      }      assert(id != -1);      PrintV(0, id);    };    for (char c : ops) {      if (c == 'H') {        PutH();      } else {        PutV();      }    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Grid Reset.json",
    "hint": []
}