{
    "link": "https://codeforces.com//contest/1060/problem/E",
    "problemId": "230450",
    "problem_idx": "E",
    "shortId": "1060E",
    "contest_number": "1060",
    "problem_submissions": {
        "H": [
            43777582,
            43775787,
            43778301,
            43775359,
            43805399,
            43782088,
            43777602,
            44116240,
            43850241,
            43778906,
            43778773
        ],
        "F": [
            43769322,
            43774726,
            43772403,
            43778102,
            43769241,
            43772326,
            43773423,
            43775493,
            43777323,
            43776810,
            44345662,
            43998198,
            43776461,
            43777805,
            43885359,
            43777579,
            43776355,
            43779796,
            43779608,
            43780204
        ],
        "E": [
            43762417,
            43764663,
            43763746,
            43764167,
            43763212,
            43766061,
            43765524,
            43768205,
            43766236,
            43763603,
            43766034,
            43766754,
            43768368,
            43766310,
            43767829,
            43764919,
            43769766,
            43765300,
            43766971,
            43767710
        ],
        "B": [
            43761076,
            43759115,
            43759168,
            43759290,
            43758265,
            43759025,
            43759632,
            43759678,
            43759571,
            43759528,
            43758792,
            43759203,
            43760228,
            43760411,
            43761202,
            43772055,
            43761410,
            43759136,
            43761174,
            43759666
        ],
        "C": [
            43760028,
            43761053,
            43760979,
            43760607,
            43760834,
            43761267,
            43761559,
            43762200,
            43761558,
            43761781,
            43761097,
            43763023,
            43762854,
            43762864,
            43763097,
            43761814,
            43765269,
            43760939,
            43763385,
            43762549
        ],
        "D": [
            43758517,
            43762752,
            43762719,
            43762340,
            43759631,
            43763257,
            43762507,
            43764164,
            43763131,
            43760435,
            43762978,
            43764580,
            43764519,
            43765425,
            43764660,
            43762881,
            43766760,
            43767791,
            43764938,
            43764650
        ],
        "A": [
            43757554,
            43758213,
            43757544,
            43758262,
            43757552,
            43757711,
            43757958,
            43758105,
            43757983,
            43757586,
            43757752,
            43757708,
            43758583,
            43757806,
            43757592,
            43757955,
            43759122,
            43757641,
            43757856,
            43757849
        ],
        "G": [
            44020164,
            44543288
        ]
    },
    "name": "E. Sergey and Subway",
    "statement": "Sergey Semyonovich is a mayor of a county city N and he used to spend\r\nhis days and nights in thoughts of further improvements of Nkers’ lives.\r\nUnfortunately for him, anything and everything has been done already,\r\nand there are no more possible improvements he can think of during the\r\nday (he now prefers to sleep at night). However, his assistants have\r\nfound a solution and they now draw an imaginary city on a paper sheet\r\nand suggest the mayor can propose its improvements.Right now he has a\r\nmap of some imaginary city with n subway stations. Some stations are\r\ndirectly connected with tunnels in such a way that the whole map is a\r\ntree (assistants were short on time and enthusiasm). It means that there\r\nexists exactly one simple path between each pair of station. We call a\r\npath simple if it uses each tunnel no more than once.One of Sergey\r\nSemyonovich’s favorite quality objectives is the sum of all pairwise\r\ndistances between every pair of stations. The distance between two\r\nstations is the minimum possible number of tunnels on a path between\r\nthem.Sergey Semyonovich decided to add new tunnels to the subway map. In\r\nparticular, he connected any two stations u and v that were not\r\nconnected with a direct tunnel but share a common neighbor, i.e. there\r\nexists such a station w that the original map has a tunnel between u and\r\nw and a tunnel between w and v. You are given a task to compute the sum\r\nof pairwise distances between all pairs of stations in the new map.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\n\nint N;\nvector <int> edge[MAXN];\nint ddep[MAXN], ssize[MAXN];\n\nvoid flood (int cloc, int last)\n{\n    ssize[cloc] = 1;\n    for (int neigh : edge[cloc])\n    {\n        if (neigh == last) continue;\n        ddep[neigh] = ddep[cloc] + 1;\n        flood (neigh, cloc);\n        ssize[cloc] += ssize[neigh];\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    \n    cin >> N;\n    for (int i = 0; i < N - 1; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n\n    flood (0, -1);\n    ll nodd = 0;\n    ll res = 0;\n    for (int i = 1; i < N; i++)\n    {\n        res += ssize[i] * (ll) (N - ssize[i]);\n        if (ddep[i] % 2 == 1)\n            nodd++;\n    }\n    res += nodd * (ll) (N - nodd);\n    cout << res / 2 << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Sergey and Subway.json",
    "editorial_link": "https://codeforces.com//blog/entry/113725",
    "editorial": "Consider a shortest path between two vertices \nu\nu and \nv\nv in the new graph. It consists of two types of edges: edges that were originally in the tree, and edges that were added to the tree. Lets call them old and new edges respectively.\n\nWe construct a walk in the original tree corresponding to this shortest path: for every new edge, replace it by two adjacent old edges due to which this new edge was added.\n\nSo if the number of old edges is \nn\n1\nn \n1\n?\n  and the number of new edges is \nn\n2\nn \n2\n?\n , the length of the considered shortest path is \nn\n1\n+\nn\n2\nn \n1\n?\n +n \n2\n?\n , and the length of the walk in the original tree is \nn\n1\n+\n2\nn\n2\nn \n1\n?\n +2n \n2\n?\n . By reducing this walk to a path, we get a path in the tree of length \n?\nn\n1\n+\n2\nn\n2\n?n \n1\n?\n +2n \n2\n?\n . Note that this is at most twice the length of the considered shortest path.\n\nConversely, from a shortest path (in fact, the unique path) of length \nl\nl in the tree between \nu\nu and \nv\nv, we can construct a path of length \n?\nl\n/\n2\n?\n?l/2? in the new tree. Since \nl\n?\nn\n1\n+\n2\nn\n2\n?\n2\n(\nn\n1\n+\nn\n2\n)\nl?n \n1\n?\n +2n \n2\n?\n ?2(n \n1\n?\n +n \n2\n?\n ), we have \n?\nl\n/\n2\n?\n?\nn\n1\n+\nn\n2\n?l/2??n \n1\n?\n +n \n2\n?\n , so this is indeed the shortest path between the two vertices in the new graph.\n\nThis shows that for vertices \nu\n,\nv\nu,v, the distance between them in the new graph is \n?\nd\n(\nu\n,\nv\n)\n/\n2\n?\n?d(u,v)/2?.\n\nNow we only need to compute the sum of this expression over all \nu\n,\nv\nu,v. \n?\nd\n(\nu\n,\nv\n)\n/\n2\n?\n?d(u,v)/2? equals \nd\n(\nu\n,\nv\n)\n/\n2\nd(u,v)/2 if the distance between \nu\n,\nv\nu,v is even, and \n(\nd\n(\nu\n,\nv\n)\n+\n1\n)\n/\n2\n(d(u,v)+1)/2 otherwise. In other words, we just need to compute the sum of \nd\n(\nu\n,\nv\n)\nd(u,v) over all vertices, and the number of pairs of vertices that are at an odd distance to each other. Since we can color a tree in 2 colors, we just need to find the product of the sizes of the two bipartitions.\n\nComputing the sum of \nd\n(\nu\n,\nv\n)\nd(u,v) is standard: every edge contributes \n1\n1 to each pair \n(\nu\n,\nv\n)\n(u,v) of vertices such that removing that edge will disconnect these vertices. So we can root the tree, do a DFS, and then compute the number of such pairs for each edge quite easily.\n\nThe time complexity is \nO\n(\nn\n)\nO(n).",
    "hint": []
}