{
    "link": "https://codeforces.com//contest/1654/problem/G",
    "problemId": "1337004",
    "problem_idx": "G",
    "shortId": "1654G",
    "contest_number": "1654",
    "problem_submissions": {
        "G": [
            150299206,
            150291434,
            150262682,
            150264693,
            150279932,
            150262802,
            150264575,
            150265515,
            150270995,
            150269889,
            150268570,
            150658744,
            150262050,
            150410744
        ],
        "F": [
            150251411,
            150252834,
            150256351,
            150258591,
            150257352,
            150258765,
            150260950,
            150260548,
            150253390,
            155820292,
            150253676,
            150260302,
            150259236,
            150258476,
            150253068,
            150258272,
            150260151,
            150258857,
            150253870
        ],
        "E": [
            150249388,
            150250832,
            150247329,
            150252856,
            150255337,
            150250196,
            150255012,
            150258473,
            150245581,
            150250984,
            150250253,
            150246690,
            150250591,
            150243463,
            150281667,
            150281018,
            150257789,
            150252457,
            150252381,
            150254404,
            150260615
        ],
        "D": [
            150242905,
            150248369,
            150245387,
            150248435,
            150250315,
            150245874,
            150249516,
            150253299,
            150250969,
            150245477,
            150245136,
            150243688,
            150246539,
            150254801,
            150249615,
            150245204,
            150245282,
            150246887,
            150243365
        ],
        "C": [
            150236387,
            150236280,
            150236050,
            150237265,
            150241937,
            150237951,
            150242839,
            150238439,
            150239664,
            150239447,
            150236298,
            150237311,
            150240477,
            150246874,
            150236567,
            150236644,
            150238032,
            150240021,
            150238619
        ],
        "B": [
            150233906,
            150232250,
            150249236,
            150233827,
            150235226,
            150232832,
            150239572,
            150233210,
            150235633,
            150231291,
            150231026,
            150232476,
            150233263,
            150235368,
            150231705,
            150232694,
            150231566,
            150233122,
            150232190
        ],
        "A": [
            150228234,
            150228426,
            150228045,
            150228869,
            150232031,
            150228616,
            150230908,
            150228192,
            150232849,
            150228032,
            150227955,
            150228792,
            150228208,
            150229654,
            223450681,
            150228295,
            150228644,
            150228162,
            150228813,
            150228169
        ],
        "H": [
            150278254,
            150276173,
            150276315,
            150560549
        ]
    },
    "name": "G. Snowy Mountain",
    "statement": "There are n locations on a snowy mountain range (numbered from 1 to n),\r\nconnected by n-1 trails in the shape of a tree. Each trail has length 1.\r\nSome of the locations are base lodges. The height h_i of each location\r\nis equal to the distance to the nearest base lodge (a base lodge has\r\nheight 0).There is a skier at each location, each skier has initial\r\nkinetic energy 0. Each skier wants to ski along as many trails as\r\npossible. Suppose that the skier is skiing along a trail from location i\r\nto j. Skiers are not allowed to ski uphill (i.e., if h_i < h_j). It\r\ncosts one unit of kinetic energy to ski along flat ground (i.e., if h_i\r\n= h_j), and a skier gains one unit of kinetic energy by skiing downhill\r\n(i.e., if h_i > h_j). For each location, compute the length of the\r\nlongest sequence of trails that the skier starting at that location can\r\nski along without their kinetic energy ever becoming negative. Skiers\r\nare allowed to visit the same location or trail multiple times.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 202'222;\nvector<int> a[N];\nint h[N];\n\nvector<int> same[N];\nvector<int> up[N];\nbool good[N];\n\nint lowest[N];\nint could[N];\n\nvoid remin(int& x, int y) {\n\tx = (x < y) ? x : y;\n}\n\nvoid dfs(int v, int cur, int dest) {\n\tif (cur == 0) {\n\t\tremin(lowest[v], h[dest]);\n\t}\n\tif (h[dest] > lowest[v]) {\n\t\treturn;\n\t}\n\tif (cur >= could[v]) {\n\t\treturn;\n\t}\n\tcould[v] = cur;\n\tfor (int x : same[v]) {\n\t\tdfs(x, cur + 1, dest);\n\t}\n\tfor (int x : up[v]) {\n\t\tdfs(x, cur ? cur - 1 : 0, dest);\n\t}\n}\n\nvoid solve() {\n\tint n = nxt();\n\tfor (int i = 0; i < n; ++i) {\n\t\th[i] = nxt() - 1;\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (~h[i]) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tfor (int x : a[v]) {\n\t\t\tif (h[x] == -1) {\n\t\t\t\th[x] = h[v] + 1;\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tgood[i] = false;\n\t\tfor (int x : a[i]) {\n\t\t\tif (h[i] == h[x]) {\n\t\t\t\tsame[i].push_back(x);\n\t\t\t\tgood[i] = true;\n\t\t\t} else if (h[x] > h[i]) {\n\t\t\t\tup[i].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> all_good;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (good[i]) {\n\t\t\tall_good.push_back(i);\n\t\t}\n\t}\n\tsort(all(all_good), [&](int x, int y) {\n\t\treturn h[x] < h[y];\n\t});\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tlowest[i] = 1e9;\n\t\tcould[i] = 1e9;\n\t}\n\n\tfor (int v : all_good) {\n\t\tdfs(v, 0, v);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint ans = h[i];\n\t\tif (lowest[i] < 1e8) {\n\t\t\tans = max(ans, 2 * h[i] - lowest[i]);\n\t\t}\n\t\tcout << ans << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nint main() {\n\tint t = 1; // nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Snowy Mountain.json",
    "editorial_link": "https://codeforces.com//blog/entry/100127",
    "editorial": "SolutionRead the hints. The rest is just implementation.For each set of\r\nflippable vertices of the same height, we can calculate the set of\r\nstarting vertices which are able to reach at least one vertex in that\r\nflippable set. To do this, split the graph up into layers of equal\r\nheight. Let be the minimum required energy to reach a vertex in the\r\nflippable set. can be computed via shortests paths, where edges in the\r\nsame layer have weight and edges from layer to have weight . We can use\r\nbfs to relax the costs of vertices in a single layer, and then easily\r\ntransition to the next layer. We do this for different starting heights,\r\nso the total complexity is .\r\n"
}