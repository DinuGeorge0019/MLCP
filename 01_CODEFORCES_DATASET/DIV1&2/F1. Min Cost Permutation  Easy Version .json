{
    "link": "https://codeforces.com//contest/1844/problem/F1",
    "problemId": "2009576",
    "problem_idx": "F1",
    "shortId": "1844F1",
    "contest_number": "1844",
    "problem_submissions": {
        "H": [
            213401907,
            214586788,
            213482546,
            213575600
        ],
        "G": [
            213373899,
            213364706,
            213372549,
            213373590,
            213384164,
            213383282,
            213393963,
            213384409,
            213418393,
            213387981,
            213389348,
            213398375,
            213371949,
            213387199,
            213394165,
            213377360,
            213395667,
            213402058,
            213381593,
            213560869
        ],
        "F2": [
            213365751,
            213352374,
            213361750,
            213357168,
            213362030,
            213488425,
            213373147,
            213364872,
            213370323,
            213418391,
            213375744,
            213375673,
            213376380,
            213391972,
            213386286,
            213388069,
            230986552,
            216997553,
            213356538
        ],
        "F1": [
            213360737,
            213346552,
            213355844,
            213353769,
            213356474,
            213367301,
            213365016,
            213370233,
            213418390,
            213370693,
            213375568,
            213369192,
            213377984,
            213354083,
            213383020,
            213393303,
            213372669,
            213376461,
            213401679,
            213346392
        ],
        "E": [
            213337513,
            213326176,
            213327168,
            213328291,
            213335991,
            213344387,
            213331287,
            213347379,
            213418389,
            213352955,
            213345144,
            213334554,
            213382252,
            213336241,
            213360028,
            213342150,
            213401053,
            213350691,
            213367633,
            213327950
        ],
        "D": [
            213318341,
            213311325,
            213318771,
            213314733,
            213318035,
            213321179,
            213319226,
            213340653,
            213317181,
            213324442,
            213316839,
            213340146,
            213326482,
            213318777,
            213944519,
            213330783,
            213332314,
            213324111,
            213326152,
            213309266
        ],
        "C": [
            213311934,
            213315167,
            213312751,
            213311291,
            213312791,
            213313574,
            213311190,
            213319880,
            213418387,
            213328281,
            213316222,
            213310956,
            213328279,
            213320887,
            213311937,
            213944332,
            213316739,
            213317975,
            213317491,
            213320348,
            213316455
        ],
        "B": [
            213305232,
            213307651,
            213304802,
            213304382,
            213303223,
            213306708,
            213313221,
            213310598,
            213305162,
            213310610,
            213305169,
            213311924,
            213315219,
            213307143,
            213944329,
            213309459,
            213321407,
            213309510,
            213312105,
            213303380
        ],
        "A": [
            213298732,
            213301327,
            213298427,
            213298307,
            213298687,
            213299071,
            213298742,
            213299374,
            213298849,
            213300343,
            213298392,
            213301468,
            213298430,
            213298466,
            213944301,
            213301546,
            213298332,
            213298535,
            213305461,
            213298274
        ]
    },
    "name": "F1. Min Cost Permutation  Easy Version ",
    "statement": "You are given an array of n positive integers a_1,\r\ndots,a_n, and a (possibly negative) integer c.Across all permutations\r\nb_1,\r\ndots,b_n of the array a_1,\r\ndots,a_n, consider the minimum possible value of\r\nsum_{i=1}^{n-1} |b_{i+1}-b_i-c|. Find the lexicographically smallest\r\npermutation b of the array a that achieves this minimum.A sequence x is\r\nlexicographically smaller than a sequence y if and only if one of the\r\nfollowing holds: x is a prefix of y, but x\r\nne y; in the first position where x and y differ, the sequence x has a\r\nsmaller element than the corresponding element in y.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(\"1.in\",\"r\",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,c,i,j,a[200005];\nvoid solve(int l,int r)\n{\n\tmultiset<int> s;printf(\"%d \",a[l]);int i;\n\tif(l==r)return;\n\tfz(i,l+1,r)s.insert(a[i]);\n\tint lst=a[l];\n\twhile(s.size()>1){\n\t\tfor(multiset<int>::iterator it=next(s.begin());;it++){\n\t\t\tif(lst-c>*it) continue;\n\t\t\tif(next(it)==s.end()||*next(it)-c<=*prev(it)){\n\t\t\t\tprintf(\"%d \",*it);lst=*it;\n\t\t\t\ts.erase(it);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d \",*s.begin());\n}\nvoid solve()\n{\n\tread(n);read(c);fz1(i,n)read(a[i]);\n\tif(c>=0){\n\t\tsort(a+1,a+n+1);fz1(i,n)printf(\"%d \",a[i]);puts(\"\");\n\t\treturn;\n\t}\n\tc*=-1;\n\tsort(a+1,a+n+1);reverse(a+1,a+n+1);int lst=1;\n\tfz1(i,n){\n\t\tif(i==n||a[i]-c>a[i+1]){\n\t\t\tsolve(lst,i);\n\t\t\tlst=i+1;\n\t\t}\n\t}\n\tputs(\"\");\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F1. Min Cost Permutation  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/118128",
    "editorial": "Let the of a permutation of be the value .When , it can be proven that\r\nthe minimum cost can be obtained by sorting in nondecreasing order. As\r\nsorting in nondecreasing order is also the lexicographically smallest\r\narray, this is the answer.Similarly, when , it can be proven that the\r\nminimum cost can be obtained by sorting in nonincreasing order.\r\nFurthermore, if we have fixed the values of for some , then intuitively,\r\none optimal permutation of the remaining elements is to sort them in\r\nnonincreasing order.To find the lexicographically smallest permutation,\r\nwe can greedily loop through , each time taking the smallest that does\r\nnot increase the cost. If are the unused elements sorted in\r\nnonincreasing order, then the condition we need to check to determine if\r\nsetting is good is whether (with some adjustments in the corner cases\r\nwhen or ). This condition can be checked in constant time, and we try\r\nvalues of for each of the values of , so the time complexity is .The\r\nproofs of the claims used in this solution can be found at the end of\r\nthe solution for the hard version.This is actually not true as stated\r\n(e.g. when and we fix , is better than ), but it turns out it is true\r\nfor all states that the greedy algorithm can reach (i.e. in this\r\nexample, the greedy algorithm could not have chosen ).\r\n",
    "hint": [
        "Hint 1 Solve the case first. There is a very simple description of the answer. Another Hint What is the answer when ?",
        "Hint 2 When , the answer is the array sorted in nondecreasing order.",
        "Hint 3 When , the minimum cost is achieved by sorting the array in nonincreasing order, but this is not the lexicographically smallest. Try to greedily form the lexicographically smallest array one element at a time."
    ]
}