{
    "link": "https://codeforces.com//contest/1844/problem/F2",
    "problemId": "2009577",
    "problem_idx": "F2",
    "shortId": "1844F2",
    "contest_number": "1844",
    "problem_submissions": {
        "H": [
            213401907,
            214586788,
            213482546,
            213575600
        ],
        "G": [
            213373899,
            213364706,
            213372549,
            213373590,
            213384164,
            213383282,
            213393963,
            213384409,
            213418393,
            213387981,
            213389348,
            213398375,
            213371949,
            213387199,
            213394165,
            213377360,
            213395667,
            213402058,
            213381593,
            213560869
        ],
        "F2": [
            213365751,
            213352374,
            213361750,
            213357168,
            213362030,
            213488425,
            213373147,
            213364872,
            213370323,
            213418391,
            213375744,
            213375673,
            213376380,
            213391972,
            213386286,
            213388069,
            230986552,
            216997553,
            213356538
        ],
        "F1": [
            213360737,
            213346552,
            213355844,
            213353769,
            213356474,
            213367301,
            213365016,
            213370233,
            213418390,
            213370693,
            213375568,
            213369192,
            213377984,
            213354083,
            213383020,
            213393303,
            213372669,
            213376461,
            213401679,
            213346392
        ],
        "E": [
            213337513,
            213326176,
            213327168,
            213328291,
            213335991,
            213344387,
            213331287,
            213347379,
            213418389,
            213352955,
            213345144,
            213334554,
            213382252,
            213336241,
            213360028,
            213342150,
            213401053,
            213350691,
            213367633,
            213327950
        ],
        "D": [
            213318341,
            213311325,
            213318771,
            213314733,
            213318035,
            213321179,
            213319226,
            213340653,
            213317181,
            213324442,
            213316839,
            213340146,
            213326482,
            213318777,
            213944519,
            213330783,
            213332314,
            213324111,
            213326152,
            213309266
        ],
        "C": [
            213311934,
            213315167,
            213312751,
            213311291,
            213312791,
            213313574,
            213311190,
            213319880,
            213418387,
            213328281,
            213316222,
            213310956,
            213328279,
            213320887,
            213311937,
            213944332,
            213316739,
            213317975,
            213317491,
            213320348,
            213316455
        ],
        "B": [
            213305232,
            213307651,
            213304802,
            213304382,
            213303223,
            213306708,
            213313221,
            213310598,
            213305162,
            213310610,
            213305169,
            213311924,
            213315219,
            213307143,
            213944329,
            213309459,
            213321407,
            213309510,
            213312105,
            213303380
        ],
        "A": [
            213298732,
            213301327,
            213298427,
            213298307,
            213298687,
            213299071,
            213298742,
            213299374,
            213298849,
            213300343,
            213298392,
            213301468,
            213298430,
            213298466,
            213944301,
            213301546,
            213298332,
            213298535,
            213305461,
            213298274
        ]
    },
    "name": "F2. Min Cost Permutation  Hard Version ",
    "statement": "You are given an array of n positive integers a_1,\r\ndots,a_n, and a (possibly negative) integer c.Across all permutations\r\nb_1,\r\ndots,b_n of the array a_1,\r\ndots,a_n, consider the minimum possible value of\r\nsum_{i=1}^{n-1} |b_{i+1}-b_i-c|. Find the lexicographically smallest\r\npermutation b of the array a that achieves this minimum.A sequence x is\r\nlexicographically smaller than a sequence y if and only if one of the\r\nfollowing holds: x is a prefix of y, but x\r\nne y; in the first position where x and y differ, the sequence x has a\r\nsmaller element than the corresponding element in y.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(\"1.in\",\"r\",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,c,i,j,a[200005];\nvoid solve(int l,int r)\n{\n\tmultiset<int> s;printf(\"%d \",a[l]);int i;\n\tmultiset<int> rem;\n\tif(l==r)return;\n\tfz(i,l+1,r)s.insert(a[i]);\n\tfz(i,l+1,r-1)rem.insert(a[i]);\n\tint lst=a[l];\n\twhile(s.size()>1){\n\t\tif(rem.find(*s.rbegin())==rem.end())rem.insert(*s.rbegin());\n\t\tmultiset<int>::iterator it=rem.lower_bound(lst-c);\n\t\tmultiset<int>::iterator it2=s.lower_bound(*it);\n\t\tbool flg=0;\n\t\tif(next(it2)==s.end()||*next(it2)==*it||*next(it2)-c<=*prev(it2)){\n\t\t\tlst=*it;rem.erase(it);s.erase(s.lower_bound(*it));\n\t\t\tprintf(\"%d \",lst);\n\t\t}\n\t\telse{\n\t\t\trem.erase(it);\n\t\t}\n\t}\n\twhile(!s.empty()){\n\t\tprintf(\"%d \",*--s.end());\n\t\ts.erase(--s.end());\n\t}\n}\nvoid solve()\n{\n\tread(n);read(c);fz1(i,n)read(a[i]);\n\tif(c>=0){\n\t\tsort(a+1,a+n+1);fz1(i,n)printf(\"%d \",a[i]);puts(\"\");\n\t\treturn;\n\t}\n\tc*=-1;\n\tsort(a+1,a+n+1);reverse(a+1,a+n+1);int lst=1;\n\tfz1(i,n){\n\t\tif(i==n||a[i]-c>a[i+1]){\n\t\t\tsolve(lst,i);\n\t\t\tlst=i+1;\n\t\t}\n\t}\n\tputs(\"\");\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F2. Min Cost Permutation  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/118128",
    "editorial": "Let be the sum of the weights of the edges on the path from node to node\r\n. We know that and for all . This is a system of linear equations in\r\nvariables.As should be integers, letâs first solve this system modulo .\r\nThe term disappears, so we just have . Starting from , this uniquely\r\ndetermines , then , and so on.Now that we know , write where is the\r\nfirst bit of . We can rewrite our system of equations as which has the\r\nsame form as the original system. Thus we can repeat this process to\r\nfind (giving ), then , and so on. Note that each bit of is uniquely\r\ndetermined.If a solution exists, it satisfies for all , so it suffices\r\nto repeat this process until we have found the first bits of . Finally,\r\nwe check that these bits correspond to a valid solution where all the\r\noriginal weights are positive.The time complexity is , if the are\r\nprecomputed.Remark: This idea is related to the method of Hensel\r\nLifting.\r\n",
    "hint": [
        "Hint 4 We need to optimize the greedy with some data structures. There exist solutions with varying levels of data structure implementation depending on how much effort is put into characterizing the answer array. For a short solution, start by simplifying the formula (in the solution for the easy version) to get a cleaner description.",
        "Hint 5 The condition is actually equivalent to ( or or ) and ( ).",
        "Hint 6 Maintain a linked list of the unused entries of and a set of unused entries that satisfy ( or or )."
    ]
}