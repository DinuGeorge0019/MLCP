{
    "link": "https://codeforces.com//contest/2039/problem/C2",
    "problemId": "3044243",
    "problem_idx": "C2",
    "shortId": "2039C2",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "Consider the three cases of when is divisible by , , or both separately.\r\nis divisible by . Let . So . So we can rephrase the problem as counting\r\nthe number of integers such that is divisible by and . , because xor is\r\njust addition without carry. So it feels like almost all values of might\r\nwork! And itâs actually true because , so if i.e. then is always true.\r\nAll multiples of under always work! So the count is . But how about when\r\n? if , then , because xor is like subtraction without borrowing. So if\r\ni.e. then is always true. So no values of work when . And there are two\r\nmultiples of in the range . So we can just check them manually. Answer\r\nis plus manually checking the two multiples of in the range . is\r\ndivisible by . As we already know that , and when , .But as and , so is\r\nneither nor , so the smallest multiple of that can work is . But , so no\r\nsolution here. No solution when . And as is small in this problem, so we\r\ncan just iterate over all values of and manually check if is divisible\r\nby . is divisible by both and . So the xor is divisible by . So when ,\r\nbut , so no solution here. Only works when . So we just implement the\r\nabove cases and the answer is the sum of case and case subtracted by\r\ncase . .\r\n",
    "name": "C2. Shohag Loves XOR  Hard Version ",
    "statement": "Shohag has two integers x and m. Help him count the number of integers 1\r\nle y\r\nle m such that x\r\noplus y is either x, y, or both. Here\r\noplus is the bitwise XOR operator.^{\r\ntext{ }}The number a is divisible by the number b if there exists an\r\ninteger c such that a = b\r\ncdot c.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;ll x, m;void Main() {\tcin >> x >> m;\tll ans = 0;\tfor(ll t = m + 1; t; t -= t & -t) {\t\tll lb = t & -t;\t\tll cur = (t - lb) ^ x;\t\tcur -= cur & (lb - 1);\t\tans += (cur + x + lb - 1) / x;\t\tans -= (cur + x - 1) / x;\t}\t--ans;\tL(y, 1, min(x * 4, m)) {\t\tans -= (x ^ y) % x == 0;\t\tif((x ^ y) % x == 0 || (x ^ y) % y == 0) ++ans;\t}\tcout << ans << '\\n';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C2. Shohag Loves XOR  Hard Version .json",
    "hint": []
}