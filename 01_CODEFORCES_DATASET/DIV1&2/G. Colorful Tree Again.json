{
    "link": "https://codeforces.com//contest/1787/problem/G",
    "problemId": "1756750",
    "problem_idx": "G",
    "shortId": "1787G",
    "contest_number": "1787",
    "problem_submissions": {
        "I": [
            197474547,
            191162667,
            191147076,
            191159474,
            191182912,
            191180384,
            191173195,
            191158380,
            191159985,
            191279548,
            191153893,
            191147979,
            191219667,
            191170332
        ],
        "G": [
            191152988,
            191152586,
            191141714,
            191145745,
            191143792,
            191147352,
            191147519,
            191158898,
            191159891,
            191160943,
            191153438,
            191155040,
            191144883,
            191170407,
            191170114,
            191152547
        ],
        "F": [
            191146155,
            191132842,
            191134802,
            191136901,
            191128020,
            191139771,
            191139131,
            191147114,
            191152778,
            191144574,
            191147232,
            191145790,
            191135060,
            191146379,
            191144901,
            191136231,
            191134824,
            191143478,
            191143747,
            191145614
        ],
        "E": [
            191137894,
            191126319,
            191169100,
            191131011,
            191146734,
            191132024,
            191134009,
            191128652,
            191130752,
            191135324,
            191128162,
            191137413,
            191115850,
            191140133,
            191140025,
            191121022,
            191131209,
            191138279,
            191133339,
            191131279
        ],
        "D": [
            191132976,
            191120161,
            191124203,
            191123443,
            191137713,
            191128946,
            191128273,
            191122289,
            191126977,
            191131112,
            191124722,
            191125562,
            191128102,
            191135389,
            191135592,
            191131056,
            191123065,
            191127620,
            191126290,
            191127861
        ],
        "C": [
            191125268,
            191113889,
            191117948,
            191115059,
            191116269,
            191118107,
            191120001,
            191140669,
            191115010,
            191125411,
            191117705,
            191118998,
            191121343,
            191121072,
            191117056,
            191128472,
            191115952,
            191117237,
            191118951,
            191120349
        ],
        "B": [
            191121944,
            191109607,
            191111770,
            191108995,
            191110155,
            191109908,
            191113645,
            191109634,
            191109874,
            191121868,
            191110598,
            191110575,
            191117560,
            191109576,
            191110819,
            191112301,
            191110138,
            191111938,
            191108264,
            191111930
        ],
        "A": [
            191118000,
            191106352,
            191108603,
            191106770,
            191106814,
            191106284,
            191107425,
            191105859,
            191106157,
            191118169,
            191107747,
            191106297,
            191105730,
            191106101,
            191107070,
            191108687,
            191105956,
            191107701,
            191105869,
            191106761
        ],
        "H": [
            191116884,
            191151161,
            191155682,
            191157247,
            191138915,
            191146913,
            191162451,
            191161022,
            191128443,
            191126961,
            191251422,
            191150263,
            191149572,
            191156328
        ]
    },
    "name": "G. Colorful Tree Again",
    "statement": "An edge-weighted tree of n nodes is given with each edge colored in some\r\ncolor. Each node of this tree can be blocked or unblocked, all nodes are\r\nunblocked initially.A is a path in a graph that does not have repeating\r\nnodes. The of a path is defined as the sum of weights of all edges on\r\nthe path.A path is when it is a consisting of edges of the same color c,\r\nall edges of color c are on this path, and every node on the path is\r\nunblocked.You need to operate 2 kinds of queries: block a node, unblock\r\na node. After each query, print the maximum among all paths. If there\r\nare no paths, print 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = array<lint, 2>;\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nconst int MAXN = 200005;\n\nint n, q;\nvector<pi> gph[MAXN];\nint par[18][MAXN], dep[MAXN];\nlint sum[MAXN];\n\nint lca(int u, int v) {\n\tif (dep[u] < dep[v])\n\t\tswap(u, v);\n\tint dx = dep[u] - dep[v];\n\tfor (int i = 0; dx; i++) {\n\t\tif (dx & 1) {\n\t\t\tu = par[i][u];\n\t\t}\n\t\tdx >>= 1;\n\t}\n\tfor (int i = 17; i >= 0; i--) {\n\t\tif (par[i][u] != par[i][v]) {\n\t\t\tu = par[i][u];\n\t\t\tv = par[i][v];\n\t\t}\n\t}\n\tif (u != v)\n\t\treturn par[0][u];\n\treturn u;\n}\n\nvoid dfs(int x, int p) {\n\tfor (auto &[w, y] : gph[x]) {\n\t\tif (y != p) {\n\t\t\tpar[0][y] = x;\n\t\t\tdep[y] = dep[x] + 1;\n\t\t\tsum[y] = sum[x] + w;\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> q;\n\tvector<vector<int>> cols(n + 1);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w, c;\n\t\tcin >> u >> v >> w >> c;\n\t\tgph[u].push_back({w, v});\n\t\tgph[v].push_back({w, u});\n\t\tcols[c].push_back(u);\n\t\tcols[c].push_back(v);\n\t}\n\tvector<pi> path;\n\t// get path\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (sz(cols[i]) == 0)\n\t\t\tcontinue;\n\t\tsort(all(cols[i]));\n\t\tvector<int> onlys;\n\t\tfor (int j = 0; j < sz(cols[i]);) {\n\t\t\tint k = j;\n\t\t\twhile (k < sz(cols[i]) && cols[i][j] == cols[i][k])\n\t\t\t\tk++;\n\t\t\tif (k - j > 2) {\n\t\t\t\tonlys.push_back(-1);\n\t\t\t\tonlys.push_back(-1);\n\t\t\t\tonlys.push_back(-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k - j == 1) {\n\t\t\t\tonlys.push_back(cols[i][j]);\n\t\t\t}\n\t\t\tj = k;\n\t\t}\n\t\tif (sz(onlys) >= 3)\n\t\t\tcontinue;\n\t\tassert(sz(onlys) == 2);\n\t\tpath.push_back({onlys[0], onlys[1]});\n\t}\n\t// end get path\n\tdfs(1, -1);\n\tfor (int i = 1; i < 18; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tpar[i][j] = par[i - 1][par[i - 1][j]];\n\t\t}\n\t}\n\tvector<lint> cost(sz(path));\n\tvector<vector<int>> assoc(n + 1);\n\tvector<int> upPath(n + 1, -1);\n\tvector<int> banned(n + 1);\n\tvector<set<pi>> costList(n + 1);\n\tvector<int> cover(sz(path));\n\tfor (int i = 0; i < sz(path); i++) {\n\t\tint l = lca(path[i][0], path[i][1]);\n\t\tassoc[l].push_back(i);\n\t\tfor (int j = path[i][0]; j != l; j = par[0][j]) {\n\t\t\tupPath[j] = i;\n\t\t}\n\t\tfor (int j = path[i][1]; j != l; j = par[0][j]) {\n\t\t\tupPath[j] = i;\n\t\t}\n\t\tcost[i] = sum[path[i][0]] + sum[path[i][1]] - 2 * sum[l];\n\t\tcostList[l].insert({cost[i], i});\n\t}\n\tpriority_queue<pi> pq;\n\tauto getValue = [&](int i) {\n\t\tif (sz(costList[i]) == 0) {\n\t\t\treturn pi{0, i};\n\t\t}\n\t\treturn pi{(*costList[i].rbegin())[0], i};\n\t};\n\tauto addSinglePath = [&](int i) {\n\t\tint l = lca(path[i][0], path[i][1]);\n\t\tcostList[l].insert({cost[i], i});\n\t\tpq.push(getValue(l));\n\t};\n\tauto removeSinglePath = [&](int i) {\n\t\tint l = lca(path[i][0], path[i][1]);\n\t\tcostList[l].erase({cost[i], i});\n\t\tpq.push(getValue(l));\n\t};\n\tfor (int i = 1; i <= n; i++) {\n\t\tpq.push(getValue(i));\n\t}\n\twhile (q--) {\n\t\tint t, v;\n\t\tcin >> t >> v;\n\t\tif (t == 0) {\n\t\t\tbanned[v] = 1;\n\t\t\tif (~upPath[v]) {\n\t\t\t\tcover[upPath[v]]++;\n\t\t\t\tif (cover[upPath[v]] == 1)\n\t\t\t\t\tremoveSinglePath(upPath[v]);\n\t\t\t}\n\t\t}\n\t\tif (t == 1) {\n\t\t\tbanned[v] = 0;\n\t\t\tpq.push(getValue(v));\n\t\t\tif (~upPath[v]) {\n\t\t\t\tcover[upPath[v]]--;\n\t\t\t\tif (cover[upPath[v]] == 0)\n\t\t\t\t\taddSinglePath(upPath[v]);\n\t\t\t}\n\t\t}\n\t\twhile (sz(pq)) {\n\t\t\tauto &[cost, v] = pq.top();\n\t\t\tif (banned[v] == 0 && getValue(v)[0] == cost) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t\tif (sz(pq))\n\t\t\tcout << pq.top()[0] << \"\\n\";\n\t\telse\n\t\t\tcout << \"0\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Colorful Tree Again.json",
    "editorial_link": "https://codeforces.com//blog/entry/112009",
    "editorial": "On the original tree, all good paths are constant and one edge can only\r\nbe on at most one good path.For each color , find all edges of color ,\r\nand judge if they form a simple path by counting the degree of each node\r\non the path. If so, mark these edges and calculate the length.When a\r\nquery changes a node , several paths across are infected.For example, If\r\nwe are destroying node , path , , , and will not be good paths.A\r\nbrute-force solution is to use a priority queue, delete length of bad\r\npaths, find the maximum length.To gain better time complexity, treat two\r\ncases of influenced paths separately:1. Only one path that goes from the\r\nancestor of to its subtree, like .2. All paths whose LCA is will be\r\ninfected, like , , and .This inspires us to maintain these paths\r\naccording to their LCAs. That is, use priority queue on every node to\r\nmaintain all paths whose LCA is .Then use a global priority queue to\r\nmaintain the answer of all paths maintained on all nodes.\r\n"
}