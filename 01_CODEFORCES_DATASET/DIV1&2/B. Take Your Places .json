{
    "link": "https://codeforces.com//contest/1556/problem/B",
    "problemId": "1093323",
    "problem_idx": "B",
    "shortId": "1556B",
    "contest_number": "1556",
    "problem_submissions": {
        "H": [
            127528421,
            127373567,
            127527040,
            127375388,
            127394013,
            127386870,
            127381921,
            127387937,
            127394050,
            127389040,
            127428317,
            127427887,
            127554513,
            127394843,
            127394720,
            127394710,
            127394566,
            127388015,
            127563493,
            127391319,
            127413892,
            127413850,
            127391995,
            190714866,
            127387774
        ],
        "G": [
            127390700,
            127387983,
            127394350,
            127373122,
            127379900,
            127386180,
            127417272,
            127382224,
            127382638,
            127388751,
            127407653,
            127407647,
            127407608,
            127407584,
            127407566,
            127386088,
            127384803,
            127387460,
            127387640
        ],
        "F": [
            127355517,
            127358676,
            127354501,
            127360575,
            127359102,
            127358993,
            127363463,
            127363603,
            127365708,
            127364449,
            127360085,
            127362064,
            127372929,
            127362249,
            127375013,
            127359868,
            127372641,
            127367693,
            127374334,
            127375402
        ],
        "E": [
            127351296,
            127352912,
            127351562,
            127356521,
            127354559,
            127354907,
            127360891,
            127356050,
            127360001,
            127359317,
            127356239,
            127358250,
            127364802,
            127356923,
            127358834,
            127355363,
            127366513,
            127364481,
            127365791,
            127370671
        ],
        "D": [
            127346830,
            127349657,
            127348248,
            127352056,
            127350226,
            127351918,
            127354957,
            127351335,
            127356577,
            127354677,
            127353022,
            127352794,
            127358047,
            127352764,
            127356062,
            127349435,
            127357493,
            127359353,
            127355308,
            127356263
        ],
        "C": [
            127342221,
            127343475,
            127345171,
            127346052,
            127344444,
            127347970,
            127343862,
            127341055,
            127350101,
            127347701,
            127344590,
            127346041,
            127349062,
            127346563,
            127349912,
            127346975,
            127349244,
            127343756,
            127348599,
            127364090
        ],
        "A": [
            127338005,
            127334498,
            127334512,
            127336074,
            127334497,
            127335667,
            127334534,
            127334495,
            127334713,
            127336416,
            127334993,
            127336217,
            127334858,
            127334721,
            127334712,
            127334514,
            127335446,
            127334480,
            127334660,
            127334680
        ],
        "B": [
            127336233,
            127336922,
            127337115,
            127340977,
            127338217,
            127339999,
            127337368,
            127336161,
            127338774,
            127342382,
            127338043,
            127341949,
            127339720,
            127340565,
            127339178,
            127338941,
            127341395,
            127336543,
            127339094,
            127344978
        ]
    },
    "name": "B. Take Your Places ",
    "statement": "William has an array of n integers a_1, a_2,\r\ndots, a_n. In one move he can swap two neighboring items. Two items a_i\r\nand a_j are considered neighboring if the condition |i - j| = 1 is\r\nsatisfied.William wants you to calculate the minimal number of swaps he\r\nwould need to perform to make it so that the array does not contain two\r\nneighboring items with the same parity.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nint a[maxn];\nint n;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        scanf(\"%d\", &n);\n        int cnt[2] = {0, 0};\n        for (int i = 1; i <= n; i++)\n            scanf(\"%d\", &a[i]), a[i] %= 2, cnt[a[i]] += 1;\n        ll ans = 1e18;\n        for (int tp = 0; tp < 2; tp++) {\n            if (cnt[tp] != (n + 1) / 2) continue;\n            // tp : first\n            int g[2] = {0, 0};\n            ll na = 0;\n            for (int i = 1; i <= n; i++) {\n                g[a[i]] += 1;\n                if (a[i] == tp) {\n                    int cr = g[tp] - 1;\n                    na += abs(cr - g[tp ^ 1]);\n                }\n            }\n            chkmin(ans, na);\n        }\n        if (ans > 1e12) ans = -1;\n        printf(\"%lld\\n\", ans);\n    }\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Take Your Places .json",
    "editorial_link": "https://codeforces.com//blog/entry/94384",
    "editorial": "Note that if the condition is satisfied, where is the number of odd\r\nnumbers, and is the number of even numbers, then it is impossible to get\r\nthe required array.Now, note that it is enough to consider two cases and\r\nchoose the minimum answer from these cases: The first element will be an\r\nodd number. The first element will be an even number. Now we will\r\ndescribe the general solution. Suppose we are now at position and we\r\nmust put an element with parity on it. Then, we need to find the first\r\nelement with opposite parity , where . After we have done this, it is\r\nenough to swap and and add to the answer. To quickly search for a\r\nsuitable element, it is enough to use two pointers, which will point to\r\nthe current available even and odd numbers.\r\n"
}