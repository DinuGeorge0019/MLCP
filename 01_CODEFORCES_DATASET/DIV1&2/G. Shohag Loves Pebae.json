{
    "link": "https://codeforces.com//contest/2039/problem/G",
    "problemId": "3044248",
    "problem_idx": "G",
    "shortId": "2039G",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "Let\u00e2\u0080\u0099s say we assign to the node . Let be the maximum length of a simple\r\npath that passes through . Then a necessary condition is that can not be\r\na multiple of any number . Because if is a multiple of and is a node\r\nsuch that the unique simple path from to has length , then the LCM of\r\nthe values of the nodes from to is a multiple of , which is a\r\ncontradiction.The condition also means that can not be a multiple of any\r\nprime number .Is this a sufficient condition? Yes, and the proof is also\r\nsimple.So now the problem is to count the number of assignments such\r\nthat for each node , is not a multiple of any prime number and .Let be\r\nthe count of numbers from to that are not divisible by any prime , be\r\nthe diameter of the tree, A number is good if is not divisible by any\r\nprime , be the Mobius function, be the number of primes . Then the\r\nanswer to our problem is .As is a non-decreasing function and has at\r\nmost distinct values, we can iterate over and calculate range sums of\r\n.For calculating prefix sums of a multiplicative function (like ), it\u00e2\u0080\u0099s\r\na standard task and can be solved using Dirichlet convolution, Min25\r\nsieve or multiple other methods.Here, we need a slight variant of the\r\nmethod as we need the prefix sums of . This can be achieved using\r\nDirichlet convolution in if we just imagine the prime numbers do not\r\nexist in the number system. Refer to my code for more details.But for\r\neach fixed , how do we calculate fast enough? Trivially doing it will\r\nmake the total complexity around which is too slow.The key observation\r\nis to not forget that the values of are not random, they are the maximum\r\nlength of a simple path that passes through the node . So for all\r\nbecause from each node, the endpoints of the diameter are at least\r\naway.So now consider two cases: In this case, all for all . So only\r\nprimes or are the good numbers. So instead of going with the mobius\r\nroute, we can just directly solve it by calculating the total number of\r\nways and subtracting the number of ways where the gcd is a prime.We can\r\ncalculate the total number of ways by first calculating the number of\r\nprimes and then is just .And the number of ways where the gcd is a prime\r\nis just for all primes and otherwise.Counting primes under is also a\r\nstandard task and can be done in or faster. We can convert each to the\r\nmaximum prime and then group by their values. Then the maximum number of\r\ngroups will be . So for each fixed , if the sum of the mobius function\r\nin the range is non-zero (keep in mind that when all numbers in the\r\nrange are bad numbers, then the sum will definitely be ), then we can\r\ncalculate the product of directly. Then the upper bound of the\r\ncomplexity will be around . The proof will be added later. This works\r\nfast enough.\r\n",
    "name": "G. Shohag Loves Pebae",
    "statement": "Shohag has a tree with n nodes.Pebae has an integer m. She wants to\r\nassign each node a value an integer from 1 to m. So she asks Shohag to\r\ncount the number, modulo 998\r\n,244\r\n,353, of assignments such that following conditions are satisfied: For\r\neach pair 1\r\nle u\r\nlt v\r\nle n, the least common multiple (LCM) of the values of the nodes in the\r\nunique simple path from u to v is divisible by the number of nodes in\r\nthe path. The greatest common divisor (GCD) of the values of all nodes\r\nfrom 1 to n is 1. But this problem is too hard for Shohag to solve. As\r\nShohag loves Pebae, he has to solve the problem. Please save Shohag!\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int lim;bool Prime[N];int p[N], tot;void xxs(int x) {\tL(i, 2, x) {\t\tif(!Prime[i]) p[++tot] = i;\t\tfor(int j = 1; p[j] * i <= x && j <= tot; ++j) {\t\t\tPrime[p[j] * i] = true;\t\t\tif(i % p[j] == 0) break;\t\t} \t}}int calc_prm(int x) {\tx = min(x, lim);\treturn upper_bound(p + 1, p + tot + 1, x) - p - 1;}int mx_prm(int x) {\treturn upper_bound(p + 1, p + tot + 1, x) - p - 1;}template < int MX > struct Min_25 {\tfunction < mint(int, int)> fun; // rem\tvector < mint > buff; // rem\tint n, sq;\tbool Prime[N];\tint p[N], tot;\tll w[N], id1[N], id2[N], tp;\tinline int getid(ll x) {\t\treturn x <= sq ? id1[x] : id2[n / x];\t}\tvoid xxs(int x) {\t\tL(i, 2, x) {\t\t\tif(!Prime[i]) p[++tot] = i;\t\t\tfor(int j = 1; p[j] * i <= x && j <= tot; ++j) {\t\t\t\tPrime[p[j] * i] = true;\t\t\t\tif(i % p[j] == 0) break;\t\t\t} \t\t}\t}\tmint f[N], g[N];\tvoid solve(int NN) {\t\tn = NN;\t\tsq = sqrt(n);\t\txxs(sq);\t\tfor(ll l = 1, r; l <= n; l = r + 1) {\t\t\tr = n / (n / l);\t\t\tw[++tp] = n / l;\t\t\tif(w[tp] <= sq) id1[w[tp]] = tp;\t\t\telse id2[n / w[tp]] = tp;\t\t}\t\tL(kd, 0, sz(buff) - 1) {\t\t\tvector<mint>pd(kd + 2);\t\t\tL(i, 1, kd + 1) \t\t\t\tpd[i] = qpow(i, kd);\t\t\tL(i, 1, kd + 1)\t\t\t\tpd[i] += pd[i - 1];\t\t\tL(i, 0, kd + 1) \t\t\t\tL(j, 0, kd + 1) if(i != j) pd[i] /= i - j;\t\t\tL(i, 1, tp) {\t\t\t\tmint cur = 0, mul = 1;\t\t\t\tL(j, 0, kd + 1) {\t\t\t\t\tcur *= w[i] - j;\t\t\t\t\tcur += mul * pd[j];\t\t\t\t\tmul *= w[i] - j;\t\t\t\t}\t\t\t\tf[i] = cur - 1;\t\t\t}\t\t\tvector<mint>pref(tot + 1), V(tot + 1);\t\t\tL(i, 1, tot) \t\t\t\tV[i] = qpow(p[i], kd), pref[i] = pref[i - 1] + V[i];\t\t\tL(i, 1, tot) \t\t\t\tfor(int j = 1; j <= tp && w[j] >= p[i] * p[i]; ++j) \t\t\t\t\tf[j] -= (f[getid(w[j] / p[i])] - pref[i - 1]) * V[i];\t\t\tL(i, 1, tp) {\t\t\t\tg[i] += f[i] * buff[kd];\t\t\t}\t\t}\t\tL(i, 1, tp) g[i] += calc_prm(w[i]);\t\tvector<mint>ss(sq + 1);\t\tL(i, 1, tot) ss[p[i]] = fun(i, 1);\t\tL(i, 1, sq) ss[i] += ss[i - 1];\t\tR(i, tot, 1) {\t\t\tvector<mint>hoho = {1};\t\t\tvi pw = {1};\t\t\twhile((ll) pw.back() * p[i] <= n) {\t\t\t\thoho.pb(fun(i, sz(pw))), pw.pb(pw.back() * p[i]);\t\t\t}\t\t\tfor(int j = 1; j <= tp && w[j] >= p[i] * p[i]; ++j) {\t\t\t\tL(k, 1, sz(pw) - 1) {\t\t\t\t\tif(w[j] < pw[k])break;\t\t\t\t\tint val = w[j] / pw[k];\t\t\t\t\tg[j] += (g[getid(val)] - ss[min(val, p[i])] + (k > 1)) * hoho[k];\t\t\t\t}\t\t\t}\t\t}\t\tL(i, 1, tp) \t\t\tg[i] += 1;\t}};template < int MX > struct Min_25_2 {\tint n, sq;\tbool Prime[N];\tint p[N], tot;\tll w[N], id1[N], id2[N], tp;\tinline int getid(ll x) {\t\treturn x <= sq ? id1[x] : id2[n / x];\t}\tvoid xxs(int x) {\t\tL(i, 2, x) {\t\t\tif(!Prime[i]) p[++tot] = i;\t\t\tfor(int j = 1; p[j] * i <= x && j <= tot; ++j) {\t\t\t\tPrime[p[j] * i] = true;\t\t\t\tif(i % p[j] == 0) break;\t\t\t} \t\t}\t}\tmint f[N], g[N];\tmint query(int v, int j) {\t\t// cout << v << \" and \" << j << endl;\t\tif(v < p[j]) return 0;\t\tif(v < (ll) p[j] * p[j]) return g[getid(v)] - j + 1;\t\treturn query(v, j + 1) + query(v / p[j], j) + 1;\t}\tvoid solve(int NN) {\t\tn = NN;\t\tsq = sqrt(n);\t\txxs(1e6);\t\tfor(ll l = 1, r; l <= n; l = r + 1) {\t\t\tr = n / (n / l);\t\t\tw[++tp] = n / l;\t\t\tif(w[tp] <= sq) id1[w[tp]] = tp;\t\t\telse id2[n / w[tp]] = tp;\t\t}\t\t\t\tL(i, 1, tp) {\t\t\tf[i] = w[i] - 1;\t\t}\t\tvector<mint>pref(tot + 1), V(tot + 1);\t\tL(i, 1, tot) V[i] = 1, pref[i] = pref[i - 1] + V[i];\t\tL(i, 1, tot) \t\t\tfor(int j = 1; j <= tp && w[j] >=(ll) p[i] * p[i]; ++j) \t\t\t\tf[j] -= (f[getid(w[j] / p[i])] - pref[i - 1]) * V[i];\t\tL(i, 1, tp) {\t\t\tg[i] = f[i];\t\t\t// cout << w[i] << \" : \" << g[i].x << endl;\t\t}\t}};Min_25 < (int)1e9 > f;Min_25_2 < (int)1e9 > g;int n, m;int mxdep[N], outs[N];vi e[N];void dfs(int x, int fa) {\tmxdep[x] = 0;\tfor(auto v : e[x]) if(v != fa) {\t\tdfs(v, x);\t\tmxdep[x] = max(mxdep[x], mxdep[v] + 1);\t}}int seq1[N], seq2[N];int len[N];void dfs2(int x, int fa) {\tvi qwq = vi{outs[x], 0};\tfor(auto v : e[x]) if(v != fa) qwq.pb(mxdep[v] + 1);\tsort(qwq.begin(), qwq.end());\treverse(qwq.begin(), qwq.end());\tlen[x] = qwq[0] + qwq[1] + 1;\tL(o, 0, 1) {\t\tint mx = outs[x] + 1;\t\tfor(auto v : e[x]) if(v != fa) outs[v] = max(outs[v], mx), mx = max(mx, mxdep[v] + 2);\t\treverse(e[x].begin(), e[x].end());\t}\tfor(auto v : e[x]) if(v != fa) {\t\tdfs2(v, x);\t}}ll sq, w[N], id1[N], id2[N], tp;inline int getid(ll x) {\treturn x <= sq ? id1[x] : id2[m / x];}\u00a0int co[N];int num_p;mint cnt[N];int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\txxs(1e6);\tcin >> n >> m;\tL(i, 1, n - 1) {\t\tint u, v;\t\tcin >> u >> v;\t\te[u].pb(v);\t\te[v].pb(u);\t}\tdfs(1, 0);\tdfs2(1, 0);\t\t// n = 1e2,m=1e9;\t// L(i, 1, n) len[i] = max(i, n / 2);\tsq = sqrt(m);\tlim = *max_element(len + 1, len + n + 1);\tf.buff = {mod - 1};\tf.fun = [&] (int pid, int k) -> mint {\t\tif(k != 1) return 0;\t\tif(p[pid] <= lim) return 0;\t\treturn mod - 1;\t};\tf.solve(m);\tg.solve(m);\t// cout << \"query = \" << g.query(3, 1).x << endl;\tnum_p = mx_prm(lim);\tfor(ll l = 1, r; l <= m; l = r + 1) {\t\tr = m / (m / l);\t\tw[++tp] = m / l;\t\tif(w[tp] <= sq) id1[w[tp]] = tp;\t\telse id2[m / w[tp]] = tp;\t}\tL(i, 1, n) co[mx_prm(len[i])] += 1;\t// L(i, 1, num_p) {\t// \tcout << co[i] << ' ';\t// }\t// cout << endl;\tmint ret = 0;\tL(i, 1, tp) {\t\tmint qwq = f.g[i] - f.g[i + 1];\t\tif(!qwq.x) continue;\t\tint v = m / w[i];\t\tif(v <= lim / 2) {\t\t\tret += qwq;\t\t} else {\t\t\tmint ans = 1;\t\t\tmint all = v;\t\t\tL(i, 1, num_p) {\t\t\t\tif(v >= p[i])all -= g.query(v / p[i], i) + 1; //, cout << v / p[i] << ' ' << i << \"::\" << g.query(v / p[i], i).x << endl;\t\t\t\t// cout << \"all = \" << all.x << endl;\t\t\t\tif(co[i])ans *= qpow(all, co[i]);\t\t\t}\t\t\t// L(j, 1, n) {\t\t\t// \tint cnt = 0;\t\t\t// \tL(x, 1, v) {\t\t\t// \t\tint win = 1;\t\t\t// \t\tL(y, 2, len[j])\t\t\t// \t\t\twin &= x % y != 0;\t\t\t// \t\tif(win)++cnt;\t\t\t// \t}\t\t\t// \tans *= cnt;\t\t\t// }\t\t\tret += ans * qwq;\t\t}\t}\tcout << ret.x << '\\n';\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Shohag Loves Pebae.json"
}