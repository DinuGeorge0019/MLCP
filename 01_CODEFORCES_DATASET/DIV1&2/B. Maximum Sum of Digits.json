{
    "link": "https://codeforces.com//contest/1060/problem/B",
    "problemId": "230447",
    "problem_idx": "B",
    "shortId": "1060B",
    "contest_number": "1060",
    "problem_submissions": {
        "H": [
            43777582,
            43775787,
            43778301,
            43775359,
            43805399,
            43782088,
            43777602,
            44116240,
            43850241,
            43778906,
            43778773
        ],
        "F": [
            43769322,
            43774726,
            43772403,
            43778102,
            43769241,
            43772326,
            43773423,
            43775493,
            43777323,
            43776810,
            44345662,
            43998198,
            43776461,
            43777805,
            43885359,
            43777579,
            43776355,
            43779796,
            43779608,
            43780204
        ],
        "E": [
            43762417,
            43764663,
            43763746,
            43764167,
            43763212,
            43766061,
            43765524,
            43768205,
            43766236,
            43763603,
            43766034,
            43766754,
            43768368,
            43766310,
            43767829,
            43764919,
            43769766,
            43765300,
            43766971,
            43767710
        ],
        "B": [
            43761076,
            43759115,
            43759168,
            43759290,
            43758265,
            43759025,
            43759632,
            43759678,
            43759571,
            43759528,
            43758792,
            43759203,
            43760228,
            43760411,
            43761202,
            43772055,
            43761410,
            43759136,
            43761174,
            43759666
        ],
        "C": [
            43760028,
            43761053,
            43760979,
            43760607,
            43760834,
            43761267,
            43761559,
            43762200,
            43761558,
            43761781,
            43761097,
            43763023,
            43762854,
            43762864,
            43763097,
            43761814,
            43765269,
            43760939,
            43763385,
            43762549
        ],
        "D": [
            43758517,
            43762752,
            43762719,
            43762340,
            43759631,
            43763257,
            43762507,
            43764164,
            43763131,
            43760435,
            43762978,
            43764580,
            43764519,
            43765425,
            43764660,
            43762881,
            43766760,
            43767791,
            43764938,
            43764650
        ],
        "A": [
            43757554,
            43758213,
            43757544,
            43758262,
            43757552,
            43757711,
            43757958,
            43758105,
            43757983,
            43757586,
            43757752,
            43757708,
            43758583,
            43757806,
            43757592,
            43757955,
            43759122,
            43757641,
            43757856,
            43757849
        ],
        "G": [
            44020164,
            44543288
        ]
    },
    "name": "B. Maximum Sum of Digits",
    "statement": "You are given a positive integer n.Let S(x) be sum of digits in base 10\r\nrepresentation of x, for example, S(123) = 1 + 2 + 3 = 6, S(0) = 0.Your\r\ntask is to find two integers a, b, such that 0\r\nleq a, b\r\nleq n, a + b = n and S(a) + S(b) is the largest possible among all such\r\npairs.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n\n    ll N; cin >> N;\n    int ans = 0;\n    while (N % 10 == 9)\n    {\n        ans += 9;\n        N /= 10;\n    }\n\n    if (!N)\n    {\n        cout << ans << \"\\n\";\n        return 0;\n    }\n\n    int ndig = 0;\n    while (N)\n    {\n        ans += N % 10;\n        ndig++;\n        N /= 10;\n    }\n    cout << ans + (ndig - 1) * 9 << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Maximum Sum of Digits.json",
    "editorial_link": "https://codeforces.com//blog/entry/113725",
    "editorial": "Firstly let\u0092s show a claim to show that the intuition was correct.\n\nClaim 1. Let \na\n,\nb\na,b be two non-negative integers. Let the number of carry-bits encountered while adding them be \nc\nc. Then \nS\n(\na\n)\n+\nS\n(\nb\n)\n=\nS\n(\na\n+\nb\n)\n+\n9\nc\nS(a)+S(b)=S(a+b)+9c.\n\nProof. We will induct on the number of carry-bits in the addition. For this proof to be made amenable to induction, we will need the following observation, and a slight restructuring of the claim.\n\nObservation 1.1. The carry bit when adding two numbers can be at most 1.\n\nProof. Induction on the current position in the process of addition. At the rightmost position, the carry bit is \n0\n0. So the next carry bit can at most be \n?\n(\n9\n+\n9\n)\n/\n10\n?\n=\n1\n?(9+9)/10?=1, and the base case is shown. Let\u0092s say we are at some position \ni\ni from the right. Then the carry bit is at most \n1\n1. So the next carry bit can be at most \n?\n(\n1\n+\n9\n+\n9\n)\n/\n10\n?\n=\n1\n?(1+9+9)/10?=1, and we are done.\n\nClaim 1.2. (Relaxation of claim 1): Let \na\n,\nb\na,b be two non-negative integers, and let \n?\n? be one of \n0\n0 and \n1\n1. Let the number of carry bits encountered while adding \na\n,\nb\n,\n?\na,b,? be \nc\nc. Then \nS\n(\na\n)\n+\nS\n(\nb\n)\n+\nS\n(\n?\n)\n=\nS\n(\na\n+\nb\n+\n?\n)\n+\n9\nc\nS(a)+S(b)+S(?)=S(a+b+?)+9c.\n\nProof. Let\u0092s denote by \n?\n(\na\n)\n?(a) the number of digits in \na\na for \na\n>\n0\na>0 and let \n?\n(\n0\n)\n=\n0\n?(0)=0. We will induct on \nmax\n?\n(\n?\n(\na\n)\n,\n?\n(\nb\n)\n)\nmax(?(a),?(b)). The base case is trivial. For the inductive step, note that when there is a carry in the last place, then the carry bit \nh\nh can be at most \n?\n(\n1\n+\n9\n+\n9\n)\n/\n10\n?\n=\n1\n?(1+9+9)/10?=1. Applying the inductive hypothesis for \n(\n?\na\n/\n10\n?\n,\n?\nb\n/\n10\n?\n,\nh\n)\n(?a/10?,?b/10?,h), we know that \nS\n(\n?\na\n/\n10\n?\n)\n+\nS\n(\n?\nb\n/\n10\n?\n)\n+\nS\n(\nh\n)\n=\nS\n(\n?\na\n/\n10\n?\n+\n?\nb\n/\n10\n?\n+\nh\n)\nS(?a/10?)+S(?b/10?)+S(h)=S(?a/10?+?b/10?+h). Let\u0092s now see what happened at the last place.\n\nWe consider the quantity \na\n%\n10\n+\nb\n%\n10\n+\n?\n?\n(\na\n+\nb\n+\n?\n)\n%\n10\n?\nh\na%10+b%10+??(a+b+?)%10?h.\n\nIf there was a carry: this quantity reduces by \n9\n9.\nIf there was no carry: this quantity stays the same.\nNow note that this combined with the conclusion from the inductive hypothesis proves the claim. \n?\n?\n\nAs a consequence of claim 1, it is easy to see that we want \na\n,\nb\na,b satisfying \na\n+\nb\n=\nn\na+b=n that maximize the number of carry bits when added. By induction on the length of the suffix of the decimal representation of \nn\nn that consists only of \n9\n9-s, we can show that it is impossible to get any carry bit. Let\u0092s remove the largest suffix consisting entirely of \n9\n9-s from \nn\nn. It suffices to find the answer for this \nn\nn now.\n\nSo either you run out of \n9\n9-s in the suffix (in which case \nn\n=\n1\n0\nk\n?\n1\nn=10 \nk\n ?1 for some positive integer \nk\nk), or there is a digit that is not \n9\n9. In the former case, the answer is just the sum of digits of \nn\nn. In the latter, note that we can\u0092t get more than \n?\n(\nn\n)\n?\n1\n?(n)?1 carry bits. This is also achievable: consider \nb\n=\n1\n0\n?\n(\nn\n)\n?\n1\n?\n1\nb=10 \n?(n)?1\n ?1. (or \n1\n1 if \n?\n(\nn\n)\n=\n0\n?(n)=0)."
}