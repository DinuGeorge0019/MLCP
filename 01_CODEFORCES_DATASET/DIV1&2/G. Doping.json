{
    "link": "https://codeforces.com//contest/1750/problem/G",
    "problemId": "1626963",
    "problem_idx": "G",
    "shortId": "1750G",
    "contest_number": "1750",
    "problem_submissions": {
        "H": [
            179823917
        ],
        "G": [
            179612953,
            179618975,
            179623473,
            179614248,
            179621065,
            179645973,
            179633214,
            179622344,
            180705510,
            179933269,
            180030556,
            179950229,
            179707183
        ],
        "F": [
            179601347,
            179603972,
            179609105,
            179620641,
            179625110,
            179609284,
            179617930,
            179604395,
            179604949,
            179608846,
            179612187,
            179613972,
            179616254,
            179614949,
            179615429,
            179614224,
            179615399,
            179617910
        ],
        "E": [
            179577415,
            179590864,
            179604325,
            179609562,
            179600474,
            179602399,
            179611817,
            179580954,
            179591449,
            179601210,
            179600339,
            179600865,
            179602667,
            179599833,
            179601353,
            179598843,
            179836904,
            179836835,
            179604528,
            179600892,
            179603405
        ],
        "D": [
            179570869,
            179571769,
            179580666,
            179601268,
            179580689,
            179577888,
            179591514,
            179570023,
            179569288,
            179572989,
            179577454,
            179572611,
            179571219,
            179573391,
            179577136,
            179566640,
            179577304,
            179584005,
            179571264
        ],
        "C": [
            179566484,
            179564254,
            179566602,
            179574509,
            179568597,
            179566588,
            179569992,
            179564018,
            179563887,
            179567519,
            179569743,
            179565401,
            179565441,
            179566302,
            179568300,
            179573635,
            179569848,
            179573882,
            179567502
        ],
        "B": [
            179560866,
            179561834,
            179561786,
            179562451,
            179561566,
            179560845,
            179563612,
            179559937,
            179559753,
            179560949,
            179562540,
            179560960,
            179559578,
            179560145,
            179563310,
            179559663,
            179562762,
            179562300,
            179560917
        ],
        "A": [
            179559080,
            179559855,
            179559766,
            179559866,
            179559680,
            179559121,
            179560548,
            179559129,
            179559072,
            179559167,
            179559582,
            179559013,
            179559040,
            179559136,
            179561310,
            179568564,
            179559973,
            179560198,
            179559513
        ]
    },
    "name": "G. Doping",
    "statement": "We call an array a of length n if for each 1 < i\r\nle n it holds that a_i = a_{i-1} + 1.Let’s call f(p) applied to a\r\npermutation^\r\ndagger of length n as the number of subarrays it can be partitioned such\r\nthat each one of them is fancy. For example f([1,2,3]) = 1, while\r\nf([3,1,2]) = 2 and f([3,2,1]) = 3.Given n and a permutation p of length\r\nn, we define a permutation p’ of length n to be k-special if and only\r\nif: p’ is lexicographically smaller^\r\nddagger than p, and f(p’) = k. Your task is to count for each 1\r\nle k\r\nle n the number of k-special permutations modulo m.^\r\ndagger A permutation is an array consisting of n distinct integers from\r\n1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation,\r\nbut [1,2,2] is not a permutation (2 appears twice in the array) and\r\n[1,3,4] is also not a permutation (n=3 but there is 4 in the array).^\r\nddagger A permutation a of length n is lexicographically smaller than a\r\npermutation b of length n if and only if the following holds: in the\r\nfirst position where a and b differ, the permutation a has a smaller\r\nelement than the corresponding element in b.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don't erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = \"{\";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += \"}\";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return \"(\" + ts(p.f) + \", \" + ts(p.s) + \")\"; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = \"\";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn \"{\" + ts_sep(v, \", \") + \"}\";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += \",\";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = \" \";\n\t\tif (i == 0) bef = \"{\";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += \"}\";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, \"\", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << \"\\n\"; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, \" \", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, \" | \", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t), \"\\n\") << \"\\n\" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don't actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\"); // for old USACO\n}\n} // namespace FileIO\n\n/**\n * Description: Barrett reduction computes $a \\% b$ about 4 times faster than\n * usual where $b>1$ is constant but not known at compile time. Division by $b$\n * is replaced by multiplication by $m$ and shifting right 64 bits. Source:\n * KACTL\n * https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h\n * https://en.wikipedia.org/wiki/Barrett_reduction\n * Verification: http://www.usaco.org/index.php?page=viewproblem2&cpid=1045\n */\n\nusing ul = uint64_t;\nusing L = __uint128_t;\nstruct FastMod {\n\tul b, m;\n\tFastMod(ul b) : b(b), m(-1ULL / b) {}\n\tul reduce(ul a) {\n\t\tul q = (ul)((__uint128_t(m) * a) >> 64), r = a - q * b;\n\t\treturn r - (r >= b) * b;\n\t}\n};\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal)\n * https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp\n * Verification:\n * https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int id> struct Mint {\n\tstatic FastMod MF;\n\tstatic int mod() { return (int)MF.b; }\n\tstatic void set_mod(int m) {\n\t\tassert(1 <= m);\n\t\tMF = FastMod(m);\n\t}\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don't silently convert to int\n\tMint() { v = 0; }\n\tMint(ll _v) {\n\t\tv = int((-mod() < _v && _v < mod()) ? _v : _v % mod());\n\t\tif (v < 0) v += mod();\n\t}\n\tfriend bool operator==(const Mint &a, const Mint &b) { return a.v == b.v; }\n\tfriend bool operator!=(const Mint &a, const Mint &b) { return !(a == b); }\n\tfriend bool operator<(const Mint &a, const Mint &b) { return a.v < b.v; }\n\tfriend void re(Mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = Mint(x);\n\t}\n\tfriend str ts(Mint a) { return ts(a.v); }\n\n\tMint &operator+=(const Mint &m) {\n\t\tif ((v += m.v) >= mod()) v -= mod();\n\t\treturn *this;\n\t}\n\tMint &operator-=(const Mint &m) {\n\t\tif ((v -= m.v) < 0) v += mod();\n\t\treturn *this;\n\t}\n\tMint &operator*=(const Mint &m) {\n\t\tv = (int)MF.reduce((ll)v * m.v);\n\t\treturn *this;\n\t}\n\tMint &operator/=(const Mint &m) { return (*this) *= inv(m); }\n\tfriend Mint pow(Mint a, ll p) {\n\t\tMint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend Mint inv(const Mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, mod() - 2);\n\t}\n\n\tMint operator-() const { return Mint(-v); }\n\tMint &operator++() { return *this += 1; }\n\tMint &operator--() { return *this -= 1; }\n\tfriend Mint operator+(Mint a, const Mint &b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint &b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint &b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint &b) { return a /= b; }\n};\ntemplate <int id> FastMod Mint<id>::MF = FastMod(1);\nusing Mi = Mint<0>;\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don't silently convert to int\n\tmint() : v(0) {}\n\tmint(ll _v) {\n\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD;\n\t}\n\tbool operator==(const mint &o) const { return v == o.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend void re(mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = mint(x);\n\t}\n\tfriend str ts(mint a) { return ts(a.v); }\n\n\tmint &operator+=(const mint &o) {\n\t\tif ((v += o.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &o) {\n\t\tif ((v -= o.v) < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &o) {\n\t\tv = int((ll)v * o.v % MOD);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\n\nusing mi = mint<MOD, 5>; // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi, mi>;\nusing vpmi = V<pmi>;\n\nV<V<Mi>> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, V<Mi>(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$.\n * For XOR convolution ignore \\texttt{m} within \\texttt{fft}.\n * Time: O(N\\log N)\n * Source:\n * KACTL\n * (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n * https://cp-algorithms.com/algebra/fft.html\n * https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n * maroonrk\n * https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp\n * Verification:\n * https://judge.yosupo.jp/problem/convolution_mod\n * SPOJ polymul, CSA manhattan, CF Perfect Encoding\n * http://codeforces.com/contest/632/problem/E\n */\n\n// #include \"ModInt.h\"\n\n// const int MOD = 998244353;\ntcT > void fft(V<T> &A, bool inv = 0) { // NTT\n\tint n = sz(A);\n\tassert((T::mod - 1) % n == 0);\n\tV<T> B(n);\n\tfor (int b = n / 2; b; b /= 2, swap(A, B)) { // w = n/b'th root\n\t\tT w = pow(T::rt(), (T::mod - 1) / n * b), m = 1;\n\t\tfor (int i = 0; i < n; i += b * 2, m *= w) F0R(j, b) {\n\t\t\t\tT u = A[i + j], v = A[i + j + b] * m;\n\t\t\t\tB[i / 2 + j] = u + v;\n\t\t\t\tB[i / 2 + j + n / 2] = u - v;\n\t\t\t}\n\t}\n\tif (inv) {\n\t\treverse(1 + all(A));\n\t\tT z = T(1) / T(n);\n\t\teach(t, A) t *= z;\n\t}\n} // for NTT-able moduli\ntcT > V<T> mul(V<T> A, V<T> B) {\n\tif (!min(sz(A), sz(B))) return {};\n\tint s = sz(A) + sz(B) - 1, n = 1;\n\tfor (; n < s; n *= 2)\n\t\t;\n\tbool eq = A == B;\n\tA.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i, n) A[i] *= B[i];\n\tfft(A, 1);\n\tA.rsz(s);\n\treturn A;\n}\ntemplate <class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T> &v) {\n\t\tV<M> w(sz(v));\n\t\tF0R(i, sz(v)) w[i] = (int)v[i];\n\t\treturn w;\n\t};\n\treturn mul(con(x), con(y));\n} // arbitrary moduli\ntcT > V<T> MUL(const V<T> &A, const V<T> &B) {\n\tusing m0 = mint<(119 << 23) + 1, 62>;\n\tauto c0 = mulMod<m0>(A, B);\n\tusing m1 = mint<(5 << 25) + 1, 62>;\n\tauto c1 = mulMod<m1>(A, B);\n\tusing m2 = mint<(7 << 26) + 1, 62>;\n\tauto c2 = mulMod<m2>(A, B);\n\tint n = sz(c0);\n\tV<T> res(n);\n\tm1 r01 = 1 / m1(m0::mod);\n\tm2 r02 = 1 / m2(m0::mod), r12 = 1 / m2(m1::mod);\n\tF0R(i, n) { // a=remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i] - a) * r01).v,\n\t\t\tc = (((c2[i] - a) * r02 - b) * r12).v;\n\t\tres[i] = (T(c) * m1::mod + b) * m0::mod + a; // c fixes m2::mod\n\t}\n\treturn res;\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tints(N, M);\n\tMi::set_mod(M);\n\t// P = vi()\n\tvi P(N);\n\n\tre(P);\n\t// iota(all(P), 1);\n\t// shuffle(all(P), rng);\n\tvb used(N + 1);\n\tused.at(0) = 1;\n\tgenComb(N + 5);\n\tV<Mi> fac(N + 1);\n\tfac.at(0) = 1;\n\tFOR(i, 1, N + 1) fac.at(i) = i * fac.at(i - 1);\n\tauto get_comb = [&](int hi, int lo, int mid) {\n\t\treturn scmb.at(hi - lo).at(mid - lo) * fac.at(mid);\n\t};\n\tV<V<Mi>> to_add(N + 1);\n\tF0R(i, N + 1) { to_add.at(i).rsz(N + 1 - i); }\n\tauto shift = [&](V<Mi> v, int l, int r) {\n\t\tv.ins(begin(v), l, 0);\n\t\tF0R(i, sz(v)) to_add.at(r - l).at(i) += v.at(i);\n\t\t// to_add.at(r-l) += v;\n\t\t// // dbg(\"START SHIFT\", sz(v), l, r);\n\t\t// // dbg(v);\n\t\t// F0R(i, sz(v)) F0R(m, r - l + 1) {\n\t\t// \ttot_ways.at(i + m) += scmb.at(r - l).at(m) * v.at(i);\n\t\t// }\n\t};\n\tint comps_so_far = 0;\n\tF0R(i, N) {\n\t\tdbg(\"DOING\", i);\n\t\t// = p[1 ... i-1]\n\t\t// < p[i]\n\n\t\t// 0\n\t\t// 1: designated smaller\n\t\t// 2: designated equal to p[i-1] + 1\n\n\t\t// start < p[i]: for each k\n\t\t// start < p[i] and equal to p[i-1]+1\n\n\t\t// how many ways to select k segments and designate one as the start\n\t\tauto must_start = [&](int x) { return used.at(x - 1) && !used.at(x); };\n\t\tint num_unused = N - i;\n\t\tint num_must_start = 0;\n\t\tFOR(j, 1, N + 1) num_must_start += must_start(j);\n\t\tint ways_a = 0, ways_b = 0;\n\t\tFOR(start, 1, P.at(i)) if (!used.at(start)) {\n\t\t\tV<Mi> ways(num_unused + 1);\n\t\t\tif (must_start(start)) {\n\t\t\t\tif (i && start == P.at(i - 1) + 1) {\n\t\t\t\t\tFOR(comps, num_must_start - 1, num_unused) {\n\t\t\t\t\t\tways.at(1 + comps) =\n\t\t\t\t\t\t\tget_comb(num_unused - 1, num_must_start - 1, comps);\n\t\t\t\t\t}\n\t\t\t\t\tshift(ways, comps_so_far - 1, i);\n\t\t\t\t} else {\n\t\t\t\t\t++ways_a;\n\t\t\t\t\t// shift(ways, comps_so_far, i);\n\t\t\t\t}\n\t\t\t\t// num_unused - 1, num_must_start - 1\n\t\t\t} else {\n\t\t\t\t++ways_b;\n\t\t\t\t// num_unused - 1, num_must_start\n\t\t\t}\n\t\t}\n\t\tif (ways_a) {\n\t\t\tV<Mi> ways(num_unused + 1);\n\t\t\tFOR(comps, num_must_start - 1, num_unused) {\n\t\t\t\tways.at(1 + comps) =\n\t\t\t\t\tways_a *\n\t\t\t\t\tget_comb(num_unused - 1, num_must_start - 1, comps);\n\t\t\t}\n\t\t\tshift(ways, comps_so_far, i);\n\t\t}\n\t\tif (ways_b) {\n\t\t\tV<Mi> ways(num_unused + 1);\n\t\t\tFOR(comps, num_must_start, num_unused) {\n\t\t\t\tways.at(1 + comps) =\n\t\t\t\t\tways_b * get_comb(num_unused - 1, num_must_start, comps);\n\t\t\t}\n\t\t\tshift(ways, comps_so_far, i);\n\t\t}\n\t\tif (i && P.at(i) == P.at(i - 1) + 1) {\n\n\t\t} else {\n\t\t\t++comps_so_far;\n\t\t}\n\t\tused.at(P.at(i)) = 1;\n\t}\n\tROF(i, 1, N + 1) {\n\t\tF0R(j, sz(to_add.at(i))) {\n\t\t\tto_add.at(i - 1).at(j) += to_add.at(i).at(j);\n\t\t\tto_add.at(i - 1).at(j + 1) += to_add.at(i).at(j);\n\t\t}\n\t}\n\tauto tot_ways = to_add.at(0);\n\tFOR(i, 1, N + 1) {\n\t\tpr(tot_ways.at(i), ' ');\n\t\tFOR(j, i + 1, N + 1) {\n\t\t\ttot_ways.at(j) -= tot_ways.at(i) * scmb.at(N - i).at(j - i);\n\t\t}\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Doping.json",
    "editorial_link": "https://codeforces.com//blog/entry/108504",
    "editorial": "SolutionConsider a permutation that lexicographically smaller than given\r\npermutation, assume the first different position is , if we fix , the\r\nremaining numbers can be arranged in any order. Denote as the set of\r\nremaining numbers. Let be the number of consecutive pairs, , is included\r\nbecause it is possible that . Fix the number of positions that , this\r\nconsumes some consecutive pairs, the remaining consecutive pairs should\r\nnot increase the number of positions. Define a sequence good if and only\r\nif it has no that .Consider = number of good arrangements of values with\r\nconsecutive pairs. Consider one consecutive pair, if it is the only\r\nwrong pair, the number of values decrease by one and this situation\r\nshould be excluded, otherwise this pair can be ignored, so , with\r\nboundary . After enumrating , let , is chosen from and . Assume , if ,\r\nthe number of consecutive pairs decrease by one, otherwise it stay the\r\nsame. Additionally, if , the number of subarrays increase by one. For\r\nevery situation, count the number of and then calculate answer.Time\r\ncomplexity: .\r\n",
    "hint": []
}