{"link": "https://codeforces.com//contest/1586/problem/C", "problemId": "1147383", "problem_idx": "C", "shortId": "1586C", "contest_number": "1586", "problem_submissions": {"I": [132349267, 132252923, 132320064, 132673395, 132289506, 132263256], "H": [132247560, 132253721, 134930470, 132350321, 132254025, 132660661, 132275048, 132253966, 132270155], "G": [132239647, 132244340, 132241119, 135794866, 135794713, 132234650, 132248115, 132244256, 132257761, 132255193, 132256199, 132255919, 132258648, 132257515, 132250742, 132255333, 132257553, 132255311], "F": [132231955, 132236161, 132234366, 132240633, 132243967, 132235859, 132234337, 132237395, 132239493, 132241376, 132248866, 132245654, 132241416, 132246161, 132245018, 132259456, 132244979, 132249686, 132260019, 132238761], "E": [132228491, 132224206, 132228693, 132232413, 132231532, 132229745, 132230672, 132232315, 132218494, 132235319, 132232020, 132237413, 132239524, 132237023, 132236410, 132236319, 132238669, 132240928, 132230421, 132229492], "D": [132225001, 132227375, 132224444, 132226879, 132227724, 132226231, 132226626, 132227371, 132224235, 132227654, 132224635, 132229641, 132234990, 132231067, 132230536, 132228432, 132234258, 132232998, 132241147, 132223955], "C": [132221243, 132218519, 132219460, 132219748, 132219799, 132222571, 132220819, 132219850, 132232802, 132223481, 132218757, 132219927, 132230956, 132218216, 132224263, 132222192, 132227273, 132228072, 132226595, 132220025], "B": [132214722, 132213701, 132215490, 132214516, 132214317, 132214601, 132215162, 132222197, 132229955, 132216968, 132214347, 132216468, 132226751, 132220812, 132216772, 132216742, 132216324, 132213579, 132217316, 132213929], "A": [132213139, 132213078, 132214020, 132213141, 132213243, 132213267, 132213377, 132220659, 132228179, 132218691, 132213234, 132214356, 132213033, 132224973, 132214120, 132214349, 132213337, 132213011, 132242338, 132213128]}, "name": "C. Omkar and Determination", "statement": "Consider a grid in which some cells are empty and some cells are filled.\r\nCall a cell in this grid if, starting at that cell, you can exit the\r\ngrid by moving up and left through only empty cells. This includes the\r\ncell itself, so all filled in cells are not exitable. Note that you can\r\nexit the grid from any leftmost empty cell (cell in the first column) by\r\ngoing left, and from any topmost empty cell (cell in the first row) by\r\ngoing up.Let\u2019s call a grid if, given only which cells are exitable, we\r\ncan exactly determine which cells are filled in and which aren\u2019t.You are\r\ngiven a grid a of dimensions n\r\ntimes m , i. e. a grid with n rows and m columns. You need to answer q\r\nqueries (1\r\nleq q\r\nleq 2\r\ncdot 10^5). Each query gives two integers x_1, x_2 (1\r\nleq x_1\r\nleq x_2\r\nleq m) and asks whether the subgrid of a consisting of the columns x_1,\r\nx_1 + 1,\r\nldots, x_2 - 1, x_2 is determinable.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q;\nstring S[1000005];\nint dat[1000005];\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\trep(i, n) cin >> S[i];\n\t\n\trep1(i, n - 1) rep1(j, m - 1) dat[j] += S[i - 1][j] == 'X' && S[i][j - 1] == 'X';\n\trep1(i, m - 1) dat[i] += dat[i - 1];\n\t\n\tcin >> q;\n\trep(i, q) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif(dat[l - 1] == dat[r - 1]) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy", "implementation", "two pointers"], "dificulty": "1700", "interactive": false}