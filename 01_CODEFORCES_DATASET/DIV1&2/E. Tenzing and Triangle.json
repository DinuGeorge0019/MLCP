{
    "link": "https://codeforces.com//contest/1842/problem/E",
    "problemId": "1978969",
    "problem_idx": "E",
    "shortId": "1842E",
    "contest_number": "1842",
    "problem_submissions": {
        "H": [
            210909272,
            210915649,
            210920105,
            210920155,
            210922877,
            210917228,
            210922837,
            210930795,
            210943236,
            210937664,
            210940497,
            210923705,
            210946319,
            210934622,
            210945105,
            210899880,
            210946698,
            210939780,
            210945932
        ],
        "F": [
            210904139,
            210906080,
            210912565,
            210912372,
            210898025,
            210899929,
            210907320,
            210916813,
            210914105,
            210920055,
            210921458,
            210913885,
            210930158,
            210926455,
            210915591,
            210926376,
            210920616,
            210915480,
            210926627
        ],
        "E": [
            210900474,
            210894310,
            210898608,
            210904065,
            210915135,
            210928274,
            210898671,
            210908613,
            210902774,
            210908660,
            210907798,
            210940198,
            210905531,
            210907005,
            210910569,
            210945488,
            210908738,
            210905745,
            210907496
        ],
        "D": [
            210896488,
            210888362,
            210895704,
            210886302,
            210889254,
            210887549,
            210895428,
            210893212,
            210903157,
            210896694,
            210890657,
            210891182,
            210892762,
            210896576,
            210915222,
            210891979,
            210892349,
            210897573
        ],
        "G": [
            210891898,
            210900879,
            210908657,
            210918356,
            210923373,
            210939093,
            210921066,
            210918175,
            210911260,
            210924814,
            210932494,
            210913130,
            210941401,
            210927457,
            210933616,
            210927314,
            210931000,
            210936010
        ],
        "C": [
            210877958,
            210881836,
            210878997,
            210877037,
            210879744,
            210878770,
            210882382,
            210884108,
            210887371,
            210884900,
            210892630,
            210896219,
            210883482,
            210884636,
            210910637,
            210882729,
            210933971,
            210885406
        ],
        "A": [
            210875095,
            210875812,
            210874424,
            210888796,
            210874470,
            210876122,
            210874664,
            210877287,
            210875659,
            210882217,
            210874539,
            210875197,
            210874805,
            210874426,
            210902716,
            210874934,
            210945780,
            210885821
        ],
        "B": [
            210874375,
            210878347,
            210876059,
            210890061,
            210876166,
            210875757,
            210877955,
            210879984,
            210877325,
            210880724,
            210876899,
            210877184,
            210877441,
            210885377,
            210916237,
            210877578,
            210940672,
            210885692
        ],
        "I": [
            210953525,
            211184344,
            211107115
        ]
    },
    "name": "E. Tenzing and Triangle",
    "statement": "There are n points and a line x+y=k on a two-dimensional plane. The i-th\r\npoint is at (x_i,y_i). All points have non-negative coordinates and are\r\nstrictly below the line. Alternatively, 0\r\nleq x_i,y_i, x_i+y_i < k.Tenzing wants to erase all the points. He can\r\nperform the following two operations: Draw triangle: Tenzing will choose\r\ntwo non-negative integers a, b that satisfy a+b<k, then all points\r\ninside the triangle formed by lines x=a, y=b and x+y=k will be erased.\r\nIt can be shown that this triangle is an isosceles right triangle. Let\r\nthe side lengths of the triangle be l, l and\r\nsqrt 2 l respectively. Then, the cost of this operation is l\r\ncdot A.The blue area of the following picture describes the triangle\r\nwith a=1,b=1 with cost =1\r\ncdot A. Erase a specific point: Tenzing will choose an integer i that\r\nsatisfies 1\r\nleq i\r\nleq n and erase the point i. The cost of this operation is c_i.Help\r\nTenzing find the minimum cost to erase all of the points.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.06.2023 10:36:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    long long mx = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mx += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  long long A;\n  cin >> n >> k >> A;\n  vector<int> l(n), r(n);\n  vector<long long> cost(n);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y >> cost[i];\n    l[i] = x;\n    r[i] = k - y;\n    total += cost[i];\n  }\n  vector<vector<int>> at(k + 1);\n  for (int i = 0; i < n; i++) {\n    at[r[i]].push_back(i);\n  }\n  segtree st(k + 1);\n  long long dp = 0;\n  for (int i = 1; i <= k; i++) {\n    for (int id : at[i]) {\n      st.modify(0, l[id], +cost[id]);\n    }\n    dp = max(dp, -A * i + st.get(0, i - 1).mx);\n    st.modify(i, i, dp + A * i);\n  }\n  cout << total - dp << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "geometry",
        "greedy",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Tenzing and Triangle.json",
    "editorial_link": "https://codeforces.com//blog/entry/117606",
    "editorial": "TutorialObserve that all triangles will be disjoint, if two triangle\r\nwere not disjoint, we can merge them together to such that the cost used\r\nis less. Therefore, we can consider doing DP.The oblique side of the\r\ntriangle is a segment on the line . Therefore, we use the interval to\r\nrepresent the triangle with the upper left corner at and the lower right\r\ncorner at .First, suppose that all points will generate costs. After\r\ncovering points with a triangle, the costs can be reduced. Let represent\r\nthe sum of costs of points covered by triangle minus . We need to find\r\nseveral intervals without common parts and maximize .Let represent the\r\nmaximum value of when considering the prefix . There are two\r\ntransitions: If is not covered by any interval, then . If is covered by\r\ninterval , then . Enumerate from small to large for , maintain . When ,\r\nwill change as follows: Subtract from . For each point , add the cost of\r\nthe point to . needs to support interval addition and global maximum\r\nvalue (assuming that illegal positions are 0), which can be achieved\r\nusing a segment tree.Time complexity is .\r\n"
}