{
    "link": "https://codeforces.com//contest/1523/problem/D",
    "problemId": "1000214",
    "problem_idx": "D",
    "shortId": "1523D",
    "contest_number": "1523",
    "problem_submissions": {
        "F": [
            117916146,
            117914065,
            117905350,
            117900425,
            117909780,
            117912951,
            117923029,
            117905457,
            117920531,
            117920496,
            117911483,
            117908634,
            117907048,
            117936734,
            117936707,
            117936638,
            117936633,
            117936625,
            117936608,
            117905940,
            117911622,
            117911227,
            117910828,
            117920430,
            117916378,
            117911950,
            117912347,
            117936103,
            117935723
        ],
        "G": [
            117899863,
            117912955,
            117908386,
            117915802,
            117906341,
            117903204,
            117907803,
            117932659,
            117932628,
            117911801,
            118597582,
            117989759,
            117915684,
            117936837,
            117918793,
            117916945,
            117917431
        ],
        "D": [
            117881477,
            117886244,
            117886334,
            117887661,
            118167966,
            117918101,
            117929591,
            117890786,
            117890676,
            117893739,
            118119250,
            117887458,
            117887290,
            117893940,
            117890382,
            118081143,
            117890914,
            117883607,
            117887959,
            117895275,
            117888883,
            117902109,
            117889374
        ],
        "E": [
            117878219,
            117881962,
            117910641,
            117881787,
            117884807,
            117893823,
            117886171,
            117885405,
            117882043,
            117890552,
            117888754,
            117897027,
            117898439,
            117887443,
            117893294,
            117903524,
            117892701,
            117896279,
            117896129
        ],
        "C": [
            117876664,
            117878149,
            117877887,
            117879093,
            117889641,
            117882853,
            117877348,
            117879069,
            117877404,
            117877723,
            117880898,
            117876222,
            117880296,
            117876946,
            117880601,
            117879874,
            117879926,
            117880242,
            117902829
        ],
        "B": [
            117875490,
            117875567,
            117880589,
            117875816,
            117876680,
            117877360,
            117875700,
            117876723,
            117878349,
            117876280,
            117877999,
            117880072,
            117876899,
            117875787,
            117877756,
            117876654,
            117875833,
            117878179,
            117879465
        ],
        "A": [
            117874746,
            117874821,
            117882081,
            117874974,
            117874835,
            117874828,
            117874778,
            117874933,
            117874911,
            117874900,
            117876005,
            117883186,
            117874918,
            117874908,
            117875902,
            117874738,
            117874753,
            117874913,
            117876371
        ],
        "H": [
            117981868,
            117981132,
            118023855,
            118349130,
            117933591,
            118312467,
            118312428,
            119224810
        ]
    },
    "name": "D. Love-Hate",
    "statement": "William is hosting a party for n of his trader friends. They started a\r\ndiscussion on various currencies they trade, but there\u2019s an issue: not\r\nall of his trader friends like every currency. They like some\r\ncurrencies, but not others.For each William\u2019s friend i it is known\r\nwhether he likes currency j. There are m currencies in total. It is also\r\nknown that a trader may not like more than p currencies.Because friends\r\nneed to have some common topic for discussions they need to find the\r\nlargest by cardinality (possibly empty) subset of currencies, such that\r\nthere are at least\r\nlceil\r\nfrac{n}{2}\r\nrceil friends (rounded up) who like each currency in this subset.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.05.2021 17:49:57       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, p;\n  cin >> n >> m >> p;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    string foo;\n    cin >> foo;\n    for (int j = 0; j < m; j++) {\n      if (foo[j] == '1') {\n        a[i] |= (1LL << j);\n      }\n    }\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  shuffle(order.begin(), order.end(), rng);\n  int best = 0;\n  string ans(m, '0');\n  for (int it = 0; it < min(n, 200); it++) {\n    int me = order[it];\n    vector<int> bits;\n    for (int j = 0; j < m; j++) {\n      if ((a[me] >> j) & 1) {\n        bits.push_back(j);\n      }\n    }\n    int sz = (int) bits.size();\n    vector<int> cnt(1 << sz);\n    for (int i = 0; i < n; i++) {\n      int u = 0;\n      for (int j = 0; j < sz; j++) {\n        if ((a[i] >> bits[j]) & 1) {\n          u |= (1 << j);\n        }\n      }\n      cnt[u] += 1;\n    }\n    for (int bit = 0; bit < sz; bit++) {\n      for (int t = 0; t < (1 << sz); t++) {\n        if (t & (1 << bit)) {\n          cnt[t ^ (1 << bit)] += cnt[t];\n        }\n      }\n    }\n    for (int t = 0; t < (1 << sz); t++) {\n      if (2 * cnt[t] >= n && __builtin_popcount(t) > best) {\n        best = __builtin_popcount(t);\n        ans = string(m, '0');\n        for (int j = 0; j < sz; j++) {\n          if (t & (1 << j)) {\n            ans[bits[j]] = '1';\n          }\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "probabilities"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Love-Hate.json",
    "editorial_link": "https://codeforces.com//blog/entry/91271",
    "editorial": "Notice that the final answer will be a submask of one of friends.\r\nKnowing this, random generation may be used to pick a random mask. If we\r\ncheck a randomly-generated index 50 times then the probability of not\r\nhitting a single index of a friend from the required group is . This\r\nprobability is 1125899906 times smaller than the probability of the\r\ncontestant being hit by a falling meteorite, i.e. insignificant. Now\r\nthat we have some basis mask we can calculate the maximal answer for it.\r\nTo do this let\u00e2\u0080\u0099s \"compress\" each mask for each friend to a size no\r\nlarger than by only keeping those true bits which are also true in . Now\r\nfor each mask of length we can calculate which is the number of friends\r\nthat like this mask. For each mask is the sum of all such that s is a\r\nsubmask of . We can brute force all submasks in by using an algorithm\r\nfound . Now all we have to do is to pick the mask for which and which\r\nhas the largest number of true bits in its uncompressed state.Final\r\ncomplexity: or , depending on the implementation.\r\n"
}