{
    "link": "https://codeforces.com//contest/1864/problem/F",
    "problemId": "2181269",
    "problem_idx": "F",
    "shortId": "1864F",
    "contest_number": "1864",
    "problem_submissions": {
        "I": [
            220596748,
            220625703,
            220625365,
            220625093
        ],
        "H": [
            220568821,
            220567695,
            220569504,
            220765807,
            220735033,
            220733694,
            220582422,
            220590968,
            220584872,
            220585832,
            220586273,
            220588653,
            220869529,
            220592706,
            220587781,
            220596085,
            222139412,
            220596294
        ],
        "G": [
            220562227,
            220575493,
            220588511,
            220576272,
            220574639,
            220576772,
            220595506,
            220568659,
            220611309,
            221223033,
            220575904,
            220585515,
            220590419,
            220591092,
            220590354,
            220590686
        ],
        "F": [
            220551620,
            220555802,
            220557675,
            220718976,
            220558576,
            220553574,
            220558951,
            220567707,
            220555900,
            220612295,
            220564492,
            220564273,
            220565836,
            220560759,
            220571802,
            220564441,
            220571627,
            220556155,
            220556855,
            220560337,
            220568919,
            220567748
        ],
        "E": [
            220545674,
            220547229,
            220549551,
            220553761,
            220544098,
            220550014,
            220550285,
            220550294,
            220555536,
            220557391,
            220559164,
            220553118,
            220556990,
            220555427,
            220553548,
            220549618,
            220563369,
            220552727,
            220558630,
            220553863
        ],
        "D": [
            220537006,
            220537255,
            220535722,
            220536129,
            220534069,
            220542850,
            220539341,
            220538198,
            220541287,
            220542463,
            220545447,
            220548373,
            220544205,
            220540271,
            220536187,
            220541552,
            220541368,
            220545083,
            220544975
        ],
        "C": [
            220533606,
            220528455,
            220528101,
            220528155,
            220527489,
            220537748,
            220525134,
            220530359,
            220532079,
            220533694,
            220541070,
            220542060,
            220535618,
            220533106,
            220530771,
            220535184,
            220536493,
            220534865,
            220537384
        ],
        "B": [
            220524699,
            220524727,
            220525716,
            220524082,
            220524572,
            220524039,
            220522756,
            220522640,
            220528173,
            220525137,
            220528062,
            220531552,
            220524275,
            220526451,
            220524531,
            220529349,
            220526226,
            220525961,
            220525118
        ],
        "A": [
            220521618,
            220521580,
            220521747,
            220521485,
            220521753,
            220521570,
            220521442,
            220521465,
            220524365,
            220521707,
            220524695,
            220522808,
            220521703,
            220522789,
            220521679,
            220521789,
            220521663,
            220522116,
            220521966
        ]
    },
    "name": "F. Exotic Queries",
    "statement": "AquaMoon gives RiverHamster a sequence of integers a_1,a_2,\r\ndots,a_n, and RiverHamster gives you q queries. Each query is expressed\r\nby two integers l and r. For each query independently, you can take any\r\ncontinuous segment of the sequence and subtract an identical\r\nnon-negative value from all the numbers of this segment. You can do so\r\nmultiple (possibly, zero) times. However, you may not choose two\r\nintersecting segments which are not included in one another. Your goal\r\nis to convert to 0 all numbers whose initial was within the range [l,\r\nr]. You must do so in the minimum number of operations.Please note that\r\nthe queries are independent, the numbers in the array are restored to\r\ntheir initial values between the queries.Formally, for each query, you\r\nare to find the smallest m such that there exists a sequence\r\n{(x_j,y_j,z_j)\r\n}_{j=1}^{m} satisfying the following conditions: for any 1\r\nle j\r\nleq m, z_j\r\nge 0 and 1\r\nle x_j\r\nle y_j\r\nleq n (here [x_j, y_j] correspond to the segment of the sequence); for\r\nany 1\r\nle j < k\r\nle m, it is true that [x_j,y_j]\r\nsubseteq[x_{k},y_{k}], or [x_k,y_k]\r\nsubseteq[x_{j},y_{j}], or [x_j,y_j]\r\ncap[x_{k},y_{k}]=\r\nvarnothing; for any 1\r\nle i\r\nle n, such that l\r\nle a_i\r\nleq r, it is true that {\r\nlarge a_i =\r\nsum\r\nlimits_{\r\nsubstack {1\r\nle j\r\nle m\r\nx_j\r\nle i\r\nle y_j}} z_j. }\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int n1=(1<<20);\n\nint n, q;\nint tab[nax];\n\nint drz[2*n1];\n\nvector<pii> kar;\n\npii zap[nax];\nint wyn[nax];\n\nvi wrzuc[nax];\nvi zapy[nax];\n\nvoid pisz(int v, int w)\n{\n\tv+=n1-1;\n\tdrz[v]=w;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=max(drz[2*v], drz[2*v+1]);\n\t\tv>>=1;\n\t}\n}\n\nint czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\treturn drz[v];\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn 0;\n\t}\n\treturn max(\n\t\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\t\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\n\t);\n}\n\nint fen[nax];\n\nvoid pisz2(int v)\n{\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tfen[i]++;\n}\n\nint czyt2(int v)\n{\n\tint ret=0;\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\t{\n\t\tpii ost={0, 0};\n\t\tvector<pii> wek;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\twek.push_back({tab[i], i});\n\t\tsort(wek.begin(), wek.end());\n\t\tfor (pii i : wek)\n\t\t{\n\t\t\tif (ost.first==i.first)\n\t\t\t{\n\t\t\t\tint x=czyt(1, 1, n1, ost.second+1, i.second-1);\n\t\t\t\tif (x)\n\t\t\t\t\tkar.push_back({x, i.first});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkar.push_back({i.first, i.first});\n\t\t\t}\n\t\t\tost=i;\n\t\t\tpisz(i.second, i.first);\n\t\t}\n\t}\n\t//~ debug() << kar;\n\tfor (pii i : kar)\n\t\twrzuc[i.second].push_back(i.first);\n\tfor (int i=1; i<=q; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tzap[i]={a, b};\n\t\tzapy[b].push_back(i);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j : wrzuc[i])\n\t\t\tpisz2(j);\n\t\tfor (int j : zapy[i])\n\t\t\twyn[j]=czyt2(zap[j].first);\n\t}\n\t\n\tfor (int i=1; i<=q; i++)\n\t\tprintf(\"%d\\n\", wyn[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Exotic Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/119772",
    "editorial": "TutorialFirst, we consider only the sequence of elements to be\r\nmanipulated. We claim that it is optimal to operate on the whole\r\nsequence so that the minimum elements are all decreased to , and then\r\nsolve the problem on the segments separated by the 0s recursively.A\r\nstraightforward corollary of the claim is that two equal elements\r\nbetween which there are no smaller elements are handled in a single\r\noperation, so the final answer is (the number of elements to be\r\nmanipulated) minus the number of such adjacent pairs.Proof: Define to be\r\nthe answer for the segment . Do induction on the length of the segment.\r\nIf the first operation does not manipulate the whole segment, the\r\nsegment will be separated into several independent parts by the first\r\noperation, for the non-inclusive operations cannot intersect, and the\r\nfinal answer, which is the sum of of the parts, will not be less than\r\nthe initial answer according to the corollary, for some of the equal\r\npairs are separated.Now the original problem is converted into a data\r\nstructure task. Consider all adjacent equal pairs , and is the maximum\r\nelement between , m\u00e2\u0080\u0084<\u00e2\u0080\u0084a_(l). decrease the answer if and only if , which\r\ncan be easily calculated with a segment tree and sweeping lines.\r\n"
}