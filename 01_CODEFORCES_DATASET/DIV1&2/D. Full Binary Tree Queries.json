{
    "link": "https://codeforces.com//contest/960/problem/D",
    "problemId": "172421",
    "problem_idx": "D",
    "shortId": "960D",
    "contest_number": "960",
    "problem_submissions": {
        "H": [
            37076939,
            37076112,
            37074469,
            37077049
        ],
        "G": [
            37071263,
            57709834,
            57709811,
            37070456,
            37070524,
            37070914,
            37073469,
            37074485,
            37075164,
            37076234,
            37075338,
            37079339,
            37075175,
            37074093,
            37077545
        ],
        "E": [
            37066041,
            37079944,
            37063783,
            37066048,
            37064488,
            37061915,
            37065298,
            37064523,
            37070733,
            37072090,
            37076676,
            37064464,
            37069828,
            37067545,
            37067744,
            37066196,
            37072966
        ],
        "D": [
            37064105,
            37063850,
            37067264,
            37066015,
            37064335,
            37059946,
            37066190,
            37067902,
            37062007,
            37066676,
            37068757,
            37066067,
            37061947,
            37066618,
            37070708,
            37069032,
            37065961
        ],
        "F": [
            37061228,
            37060911,
            37058043,
            37061179,
            37057703,
            37061709,
            37063433,
            37060626,
            37066935,
            37063565,
            37062126,
            37065836,
            37069620,
            37066690,
            37061224,
            37061530,
            37061194,
            37061393,
            37069132
        ],
        "C": [
            37059020,
            37058186,
            37073747,
            37057785,
            37060772,
            37057801,
            37056055,
            37058782,
            37058698,
            37060994,
            37061675,
            37062340,
            37067775,
            37058977,
            37058993,
            37058400,
            37058570,
            37060826
        ],
        "B": [
            37057197,
            37056331,
            37056347,
            37056532,
            37059595,
            37056085,
            37057341,
            37056165,
            37056262,
            37056554,
            37057292,
            37058927,
            37056440,
            37056660,
            37057273,
            37056784,
            37056702,
            37058078
        ],
        "A": [
            37055508,
            37055332,
            37055423,
            37055343,
            37058650,
            37055377,
            37058231,
            37055321,
            37055350,
            37055370,
            37055431,
            37055718,
            37055347,
            37055410,
            37055539,
            37055383,
            37055552
        ]
    },
    "name": "D. Full Binary Tree Queries",
    "statement": "You have a full binary tree having infinite levels.Each node has an\r\ninitial value. If a node has value , then its left child has value and\r\nits right child has value . The value of the root is . You need to\r\nanswer queries. There are types of queries: Cyclically shift the of all\r\nnodes on the same level as node with value by units. (The values/nodes\r\nof any other level are not affected). Cyclically shift the on the same\r\nlevel as node with value by units. (The subtrees of these nodes will\r\nmove along with them). Print the value of every node encountered on the\r\nsimple path from the node with value to the root.Positive implies right\r\ncyclic shift and negative implies left cyclic shift. It is guaranteed\r\nthat atleast one type query is present.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint q,ty,lev;\nll cnt[66],off[66],x,k;\nint level(ll x) {\n\tint lev=0;\n\twhile (x) x/=2,lev++;\n\treturn lev;\n}\nint main() {\n\tscanf(\"%d\",&q);\n\trep(i,1,62) cnt[i]=1ll<<(i-1);\n\trep(i,0,q) {\n\t\tscanf(\"%d\",&ty);\n\t\tif (ty==1) {\n\t\t\tscanf(\"%lld%lld\",&x,&k);\n\t\t\tlev=level(x);\n\t\t\tk%=cnt[lev];\n\t\t\tif (k<0) k+=cnt[lev];\n\t\t\toff[lev]+=k;\n\t\t\tif (off[lev]>=cnt[lev]) off[lev]-=cnt[lev];\n\t\t} else if (ty==2) {\n\t\t\tscanf(\"%lld%lld\",&x,&k);\n\t\t\tlev=level(x);\n\t\t\tk%=cnt[lev];\n\t\t\tif (k<0) k+=cnt[lev];\n\t\t\trep(l,lev,62) {\n\t\t\t\toff[l]+=k;\n\t\t\t\tif (off[l]>=cnt[l]) off[l]-=cnt[l];\n\t\t\t\tk*=2;\n\t\t\t}\n\t\t} else if (ty==3) {\n//\t\t\trep(i,0,10) printf(\"%lld \",off[i]); puts(\"\");\n\t\t\tscanf(\"%lld\",&x);\n\t\t\tlev=level(x); x-=(1ll<<(lev-1));\n\t\t\tx=(x+off[lev])%cnt[lev];\n\t\t\tper(i,1,lev+1) {\n\t\t\t\tll r=x+cnt[i]-off[i];\n\t\t\t\tif (r<0) r+=cnt[i];\n\t\t\t\tif (r>=cnt[i]) r-=cnt[i];\n\t\t\t\tprintf(\"%lld \",r+(1ll<<(i-1)));\n\t\t\t\tx/=2;\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Full Binary Tree Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/58802",
    "editorial": "Let us define the root of the tree to be at level . Now, the level for\r\nany value can be found using this formula: (Number of leading unset bits\r\nin ). In C++, you can conveniently calculate the leading unset bits by\r\nusing __builtin_clzll(). Let us imagine each level of the tree as an\r\narray . Observe that we only need to consider upto due to the constraint\r\nthat . Queries of type are equivalent to performing a cyclic shift of on\r\narray . Queries of type are equivalent to performing a cyclic shift of\r\non array , on array , on array ... on array and so on. Since we only\r\ncare about the first levels, . Now,we can store the net shift of each\r\nlevel. Note that, for level , we calculate under modulo because there\r\nare exactly values in some . Finally, to answer queries of type , do the\r\nfollowing: Let the original index(0-indexed) of in be (). The new index\r\nafter the shift will be . The original value at this index was . We can\r\nfind the parent of this value in the original tree by dividing by\r\n(Integer Division).Thus, We can now find all the values in the path from\r\nto the root in the original tree. To get the values in the current tree,\r\nwe just apply the opposite shift at each level to find the value and\r\nprint it. Let the original value at index in at some level be . The\r\ncurrent value at this position after the shift will be the same as the\r\nvalue at index in the original array. Let this value be . Now,. Print\r\nand set . Repeat Step and stop when . Complexities of: Query : . Query :\r\n. Query : . Overall: Refer to the code for further understanding.\r\n",
    "hint": []
}