{"link": "https://codeforces.com//contest/960/problem/D", "problemId": "172421", "problem_idx": "D", "shortId": "960D", "contest_number": "960", "problem_submissions": {"H": [37076939, 37076112, 37074469, 37077049], "G": [37071263, 57709834, 57709811, 37070456, 37070524, 37070914, 37073469, 37074485, 37075164, 37076234, 37075338, 37079339, 37075175, 37074093, 37077545], "E": [37066041, 37079944, 37063783, 37066048, 37064488, 37061915, 37065298, 37064523, 37070733, 37072090, 37076676, 37064464, 37069828, 37067545, 37067744, 37066196, 37072966], "D": [37064105, 37063850, 37067264, 37066015, 37064335, 37059946, 37066190, 37067902, 37062007, 37066676, 37068757, 37066067, 37061947, 37066618, 37070708, 37069032, 37065961], "F": [37061228, 37060911, 37058043, 37061179, 37057703, 37061709, 37063433, 37060626, 37066935, 37063565, 37062126, 37065836, 37069620, 37066690, 37061224, 37061530, 37061194, 37061393, 37069132], "C": [37059020, 37058186, 37073747, 37057785, 37060772, 37057801, 37056055, 37058782, 37058698, 37060994, 37061675, 37062340, 37067775, 37058977, 37058993, 37058400, 37058570, 37060826], "B": [37057197, 37056331, 37056347, 37056532, 37059595, 37056085, 37057341, 37056165, 37056262, 37056554, 37057292, 37058927, 37056440, 37056660, 37057273, 37056784, 37056702, 37058078], "A": [37055508, 37055332, 37055423, 37055343, 37058650, 37055377, 37058231, 37055321, 37055350, 37055370, 37055431, 37055718, 37055347, 37055410, 37055539, 37055383, 37055552]}, "name": "D. Full Binary Tree Queries", "statement": "You have a full binary tree having infinite levels.Each node has an\r\ninitial value. If a node has value , then its left child has value and\r\nits right child has value . The value of the root is . You need to\r\nanswer queries. There are types of queries: Cyclically shift the of all\r\nnodes on the same level as node with value by units. (The values/nodes\r\nof any other level are not affected). Cyclically shift the on the same\r\nlevel as node with value by units. (The subtrees of these nodes will\r\nmove along with them). Print the value of every node encountered on the\r\nsimple path from the node with value to the root.Positive implies right\r\ncyclic shift and negative implies left cyclic shift. It is guaranteed\r\nthat atleast one type query is present.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint q,ty,lev;\nll cnt[66],off[66],x,k;\nint level(ll x) {\n\tint lev=0;\n\twhile (x) x/=2,lev++;\n\treturn lev;\n}\nint main() {\n\tscanf(\"%d\",&q);\n\trep(i,1,62) cnt[i]=1ll<<(i-1);\n\trep(i,0,q) {\n\t\tscanf(\"%d\",&ty);\n\t\tif (ty==1) {\n\t\t\tscanf(\"%lld%lld\",&x,&k);\n\t\t\tlev=level(x);\n\t\t\tk%=cnt[lev];\n\t\t\tif (k<0) k+=cnt[lev];\n\t\t\toff[lev]+=k;\n\t\t\tif (off[lev]>=cnt[lev]) off[lev]-=cnt[lev];\n\t\t} else if (ty==2) {\n\t\t\tscanf(\"%lld%lld\",&x,&k);\n\t\t\tlev=level(x);\n\t\t\tk%=cnt[lev];\n\t\t\tif (k<0) k+=cnt[lev];\n\t\t\trep(l,lev,62) {\n\t\t\t\toff[l]+=k;\n\t\t\t\tif (off[l]>=cnt[l]) off[l]-=cnt[l];\n\t\t\t\tk*=2;\n\t\t\t}\n\t\t} else if (ty==3) {\n//\t\t\trep(i,0,10) printf(\"%lld \",off[i]); puts(\"\");\n\t\t\tscanf(\"%lld\",&x);\n\t\t\tlev=level(x); x-=(1ll<<(lev-1));\n\t\t\tx=(x+off[lev])%cnt[lev];\n\t\t\tper(i,1,lev+1) {\n\t\t\t\tll r=x+cnt[i]-off[i];\n\t\t\t\tif (r<0) r+=cnt[i];\n\t\t\t\tif (r>=cnt[i]) r-=cnt[i];\n\t\t\t\tprintf(\"%lld \",r+(1ll<<(i-1)));\n\t\t\t\tx/=2;\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}\n"], "input": "", "output": "", "tags": ["brute force", "implementation", "trees"], "dificulty": "2100", "interactive": false}