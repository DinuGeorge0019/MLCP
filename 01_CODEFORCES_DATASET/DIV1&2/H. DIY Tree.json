{
    "link": "https://codeforces.com//contest/1556/problem/H",
    "problemId": "1093329",
    "problem_idx": "H",
    "shortId": "1556H",
    "contest_number": "1556",
    "problem_submissions": {
        "H": [
            127528421,
            127373567,
            127527040,
            127375388,
            127394013,
            127386870,
            127381921,
            127387937,
            127394050,
            127389040,
            127428317,
            127427887,
            127554513,
            127394843,
            127394720,
            127394710,
            127394566,
            127388015,
            127563493,
            127391319,
            127413892,
            127413850,
            127391995,
            190714866,
            127387774
        ],
        "G": [
            127390700,
            127387983,
            127394350,
            127373122,
            127379900,
            127386180,
            127417272,
            127382224,
            127382638,
            127388751,
            127407653,
            127407647,
            127407608,
            127407584,
            127407566,
            127386088,
            127384803,
            127387460,
            127387640
        ],
        "F": [
            127355517,
            127358676,
            127354501,
            127360575,
            127359102,
            127358993,
            127363463,
            127363603,
            127365708,
            127364449,
            127360085,
            127362064,
            127372929,
            127362249,
            127375013,
            127359868,
            127372641,
            127367693,
            127374334,
            127375402
        ],
        "E": [
            127351296,
            127352912,
            127351562,
            127356521,
            127354559,
            127354907,
            127360891,
            127356050,
            127360001,
            127359317,
            127356239,
            127358250,
            127364802,
            127356923,
            127358834,
            127355363,
            127366513,
            127364481,
            127365791,
            127370671
        ],
        "D": [
            127346830,
            127349657,
            127348248,
            127352056,
            127350226,
            127351918,
            127354957,
            127351335,
            127356577,
            127354677,
            127353022,
            127352794,
            127358047,
            127352764,
            127356062,
            127349435,
            127357493,
            127359353,
            127355308,
            127356263
        ],
        "C": [
            127342221,
            127343475,
            127345171,
            127346052,
            127344444,
            127347970,
            127343862,
            127341055,
            127350101,
            127347701,
            127344590,
            127346041,
            127349062,
            127346563,
            127349912,
            127346975,
            127349244,
            127343756,
            127348599,
            127364090
        ],
        "A": [
            127338005,
            127334498,
            127334512,
            127336074,
            127334497,
            127335667,
            127334534,
            127334495,
            127334713,
            127336416,
            127334993,
            127336217,
            127334858,
            127334721,
            127334712,
            127334514,
            127335446,
            127334480,
            127334660,
            127334680
        ],
        "B": [
            127336233,
            127336922,
            127337115,
            127340977,
            127338217,
            127339999,
            127337368,
            127336161,
            127338774,
            127342382,
            127338043,
            127341949,
            127339720,
            127340565,
            127339178,
            127338941,
            127341395,
            127336543,
            127339094,
            127344978
        ]
    },
    "name": "H. DIY Tree",
    "statement": "William really likes puzzle kits. For one of his birthdays, his friends\r\ngifted him a complete undirected edge-weighted graph consisting of n\r\nvertices.He wants to build a spanning tree of this graph, such that for\r\nthe first k vertices the following condition is satisfied: the degree of\r\na vertex with index i does not exceed d_i. Vertices from k + 1 to n may\r\nhave any degree.William wants you to find the minimum weight of a\r\nspanning tree that satisfies all the conditions.A spanning tree is a\r\nsubset of edges of a graph that forms a tree on all n vertices of the\r\ngraph. The weight of a spanning tree is defined as the sum of weights of\r\nall the edges included in a spanning tree.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 305;\nstruct th {\n    int u, v;\n    int w;\n    th() {}\n    th(int a, int b, int c) {\n        u = a, v = b, w = c;\n    }\n}p[maxn];\n\nint n, k;\nint cnt = 0;\nint fa[maxn];\nint gfa(int a) {\n    if (fa[a] == a) return a;\n    return fa[a] = gfa(fa[a]);\n}\nvoid ini() {\n    for (int i = 1; i <= n; i++) fa[i] = i;\n}\nvoid lk(int a, int b) {\n    fa[gfa(a)] = gfa(b);\n}\nvector<pi> eg[maxn];\nint dis[maxn];\nint S, T;\nint pre[maxn];\nconst int N = 55;\nint fl[maxn];\nint d[N], cd[N];\n\nint w[N][N];\n\nvector<pi> preg;\nint nans = 0;\nconst int inf = 50000;\n\nvoid ade(int u, int v, int w) {\n    eg[u].pb(mp(v, w));\n}\nint q[maxn * maxn], fr, ed;\nint inq[maxn];\nbool bfs() {\n    S = cnt + 1, T = cnt + 2;\n    for (int i = 1; i <= T; i++) eg[i].clear();\n    // \u52a0\u5165\u540e\u4e0d\u6210\u5708\uff1a \u5165\n    // \u52a0\u5165\u540e\u5ea6\u6570\u4e0d\u7206\u70b8\uff1a \u51fa\n    vi fls;\n    for (int i = 1; i <= cnt; i++) {\n        if (fl[i]) fls.pb(i);\n    }\n    for (int i = 0; i <= cnt; i++) {\n        if (i != 0 && !fl[i]) continue;\n        ini();\n        for (auto v : preg)\n            lk(v.fi, v.se);\n        for (auto j : fls) {\n            if (j == i) continue;\n            lk(p[j].u, p[j].v);\n        }\n        int nid = i;\n        if (i == 0) nid = S;\n        for (int i = 1; i <= cnt; i++) {\n            if (fl[i]) continue;\n            if (gfa(p[i].u) != gfa(p[i].v))     \n                ade(nid, i, inf - p[i].w);\n        }\n    }\n    for (int i = 0; i <= cnt; i++) {\n        if (i != 0 && !fl[i]) continue;\n        memset(cd, 0, sizeof(cd));\n        for (auto v : preg)\n            cd[v.fi] += 1, cd[v.se] += 1;\n        for (auto j : fls) {\n            if (j == i) continue;\n            cd[p[j].u] += 1, cd[p[j].v] += 1;\n        }\n        int nid = i;\n        if (i == 0) nid = T;\n        int nw = inf - p[nid].w;\n        if (nid == T) nw = 0;\n        for (int i = 1; i <= cnt; i++) {\n            if (fl[i]) continue;\n            if (cd[p[i].u] < d[p[i].u] && cd[p[i].v] < d[p[i].v]) \n                ade(i, nid, -nw);\n        }\n    }\n    for (int i = 1; i <= T; i++) dis[i] = -inf, inq[i] = 0;\n    int fr = 0, ed = 0;\n    dis[S] = 0; q[ed++] = S, inq[S] = 1;\n    while (fr < ed) {\n        int cur = q[fr++]; inq[cur] = 0;\n        for (auto v : eg[cur]) {\n            int eid = v.fi, ew = v.se;\n            if (chkmax(dis[eid], dis[cur] + ew)) {\n                pre[eid] = cur;\n                if (!inq[eid]) q[ed++] = eid, inq[eid] = 1;\n            }\n        }\n    }\n    if (dis[T] <= 0) return 0;\n    vi cc;\n    int ee = pre[T];\n    while (1) {\n        cc.pb(ee);\n        ee = pre[ee];\n        if (ee == S) break;\n    }\n    nans += dis[T];\n    //cout << \"INC\" << dis[T] << endl;\n    for (auto v : cc)\n        fl[v] ^= 1;\n    return 1;\n}\n\nint main() {\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++)\n        cin >> d[i];\n    for (int i = k + 1; i <= n; i++)\n        d[i] = 1e9;\n    \n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            scanf(\"%d\", &w[i][j]);\n    int ans = 1e9;\n\n    /*MST */\n    ini();\n    #define ar3 array<int, 3>\n    vector<ar3> u;\n    for (int i = k + 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) \n            u.pb({w[i][j], i, j});\n    \n    sort(u.begin(), u.end());\n    for (auto s : u) {\n        if (gfa(s[1]) == gfa(s[2])) continue;\n        lk(s[1], s[2]);\n        p[++cnt] = th(s[1], s[2], s[0]);\n    }\n    for (int i = 1; i <= k; i++)\n        for (int j = k + 1; j <= n; j++)\n            p[++cnt] = th(i, j, w[i][j]);\n    \n    for (int i = 0; i < (1 << (k * (k - 1) / 2)); i++) {\n        ini();\n        preg.clear();\n        memset(cd, 0, sizeof(cd));\n        nans = 0;\n        int ncnt = 0;\n        for (int u = 1; u <= k; u++) \n            for (int v = u + 1; v <= k; v++) {\n                if (i & (1 << ncnt)) preg.pb(mp(u, v));\n                ncnt += 1;\n            }\n        int flag = 1;\n        for (auto s : preg) {\n            if (gfa(s.fi) == gfa(s.se)) flag = 0;\n            lk(s.fi, s.se);\n            nans += inf - w[s.fi][s.se];\n            cd[s.fi] += 1, cd[s.se] += 1;\n        }\n        for (int i = 1; i <= k; i++)\n            if (cd[i] > d[i]) flag = 0;\n        if (!flag) continue;\n        //if (i == 0) cout << \"!!!\" << flag << endl;\n        memset(fl, 0, sizeof(fl));\n        for (int m = 0; m < n - 1 - preg.size(); m++) {\n            flag &= bfs();\n            //cout << \"???\" << flag << endl;\n            if (!flag) break;\n        }\n        if (flag) {\n            //cout << \"??? \" << i << ' ' << nans << endl;\n            chkmin(ans, (n - 1) * inf - nans);\n        }\n    }\n    cout << ans << endl;\n    return (0-0); // <3\n}\n/*\n1\n10\n8 6 2 9 10 4 5 1 3 7\n\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. DIY Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/94384",
    "editorial": "Let\u00e2\u0080\u0099s call the first vertices .First of all, let\u00e2\u0080\u0099s note that the number\r\nof different forests on vertices is at most . It means that we can try\r\nall of them, one by one, as the set of all edges of the answer with both\r\nendpoints being the special vertices.Let be the set of chosen edges with\r\nboth endpoints being the special vertices. With fixed , only edges with\r\nzero or one endpoint at special vertices are left. From now on, we will\r\nonly consider subsets of these edges.We will introduce two matroids:\r\nMatroid is defined as follows: A set of edges is independent for matroid\r\n, if the set has no cycles. is a matroid, because: Deleting edges\r\nproduces no cycles, so if is a superset of and is independent, then is\r\nalso independent. If , is independent and is independent, then from the\r\ngraphic matroid there should be an edge in that connects connected\r\ncomponents in . This edge can\u00e2\u0080\u0099t be from , so there is an element , s. t.\r\nis also independent. Matroid is defined as follows. A set of edges is\r\nindependent for matroid , if in the set degrees of vertices don\u00e2\u0080\u0099t exceed\r\n, respectively. is a matroid, because: Deleting edges decreases degrees,\r\nso if is a superset of and is independent, then is also independent. If\r\n, is independent and is independent, then one of the following\r\nstatements is true. Either there is an edge with zero endpoints at\r\nspecial vertices in , and we can add it to preserving independence. Or\r\nthere is some vertex that has larger degree in than in , and we can take\r\none of adjacent edges that are present in and add it to . Thus, there is\r\nan element , s. t. is also independent.Let\u00e2\u0080\u0099s find the minimum weight\r\nbase in the intersection of matroids and . If it has enough edges, we\r\ncan relax the answer with the total weight of edges in .Also note that\r\nwe are only interested in edges from and in the MST of edges from , so\r\nwe only have edges we need to consider.Total complexity is , and it will\r\neasily fit into TL if your solution is efficient enough.\r\n"
}