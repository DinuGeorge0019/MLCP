{
    "link": "https://codeforces.com//contest/960/problem/B",
    "problemId": "172419",
    "problem_idx": "B",
    "shortId": "960B",
    "contest_number": "960",
    "problem_submissions": {
        "H": [
            37076939,
            37076112,
            37074469,
            37077049
        ],
        "G": [
            37071263,
            57709834,
            57709811,
            37070456,
            37070524,
            37070914,
            37073469,
            37074485,
            37075164,
            37076234,
            37075338,
            37079339,
            37075175,
            37074093,
            37077545
        ],
        "E": [
            37066041,
            37079944,
            37063783,
            37066048,
            37064488,
            37061915,
            37065298,
            37064523,
            37070733,
            37072090,
            37076676,
            37064464,
            37069828,
            37067545,
            37067744,
            37066196,
            37072966
        ],
        "D": [
            37064105,
            37063850,
            37067264,
            37066015,
            37064335,
            37059946,
            37066190,
            37067902,
            37062007,
            37066676,
            37068757,
            37066067,
            37061947,
            37066618,
            37070708,
            37069032,
            37065961
        ],
        "F": [
            37061228,
            37060911,
            37058043,
            37061179,
            37057703,
            37061709,
            37063433,
            37060626,
            37066935,
            37063565,
            37062126,
            37065836,
            37069620,
            37066690,
            37061224,
            37061530,
            37061194,
            37061393,
            37069132
        ],
        "C": [
            37059020,
            37058186,
            37073747,
            37057785,
            37060772,
            37057801,
            37056055,
            37058782,
            37058698,
            37060994,
            37061675,
            37062340,
            37067775,
            37058977,
            37058993,
            37058400,
            37058570,
            37060826
        ],
        "B": [
            37057197,
            37056331,
            37056347,
            37056532,
            37059595,
            37056085,
            37057341,
            37056165,
            37056262,
            37056554,
            37057292,
            37058927,
            37056440,
            37056660,
            37057273,
            37056784,
            37056702,
            37058078
        ],
        "A": [
            37055508,
            37055332,
            37055423,
            37055343,
            37058650,
            37055377,
            37058231,
            37055321,
            37055350,
            37055370,
            37055431,
            37055718,
            37055347,
            37055410,
            37055539,
            37055383,
            37055552
        ]
    },
    "name": "B. Minimize the error",
    "statement": "You are given two arrays and , each of size . The error, , between these\r\ntwo arrays is defined . You have to perform operations on array and\r\noperations on array . In one operation, you have to choose one element\r\nof the array and increase or decrease it by .Output the minimum possible\r\nvalue of error after operations on array and operations on array have\r\nbeen performed.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010;\nint n,k1,k2;\nint a[N],b[N];\nll ret;\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&k1,&k2);\n\tk1+=k2;\n\trep(i,0,n) scanf(\"%d\",a+i);\n\trep(i,0,n) scanf(\"%d\",b+i),a[i]-=b[i];\n\trep(v,0,k1) {\n\t\tint val=-1,pos=-1;\n\t\trep(i,0,n) if (abs(a[i])>val) {\n\t\t\tval=abs(a[i]); pos=i;\n\t\t}\n\t\tif (a[pos]>0) a[pos]--; else a[pos]++;\n\t}\n\trep(i,0,n) ret+=(ll)a[i]*a[i];\n\tprintf(\"%lld\\n\",ret);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Minimize the error.json",
    "editorial_link": "https://codeforces.com//blog/entry/58802",
    "editorial": "The problem can be interpreted as follows: array is fixed and a total of\r\noperations allowed on . Let the array be defined as Now this is just a\r\nsimple greedy problem where value of is to be minimized after exactly\r\nsubtraction/addition operations spread over the elements of array . Till\r\nis non-zero, the largest element is chosen and is subtracted from it.\r\nThis is done as currently we want to maximize the reduction in error per\r\noperation and decreasing an element by reduces error by . Once all the\r\nelements become zero, we can use the remaining moves to alternately\r\nincrease and decrease the same element till we run out of moves. This\r\ncan be implemented using a priority queue or by sorting the array and\r\niterating over it.Expected complexity: or\r\n"
}