{
    "link": "https://codeforces.com//contest/2039/problem/F1",
    "problemId": "3044246",
    "problem_idx": "F1",
    "shortId": "2039F1",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "Let be the sequence of length subarray maximums of the array. Then is\r\njust the adjacent maximum sequence of .Also, let be the GCD of the\r\nelements of . Then notice that every element of is also divisible by .\r\nThat is divides .For the array to be good, must be different for all .\r\nSo and divides . This means if the length of the array is , then .Now\r\nconsider a non-decreasing sequence of integers of length such that for\r\nall . Then the length subarray maximums of are just the last elements of\r\n. So is the GCD of the last elements of . Then for to be different for\r\nall , all the elements of must be distinct. So the condition for to be\r\ngood is that the elements are distinct and all suffix GCDs are distinct\r\nas well.Next the question is how many permutations of this increasing\r\nsequence is good as well? To count this, lets start from . is just . Now\r\nconsider . We need to put in the sequence such that the adjacent maximum\r\nsequence of becomes . For this we clearly have ways: and .Now consider .\r\nWe need to put in the sequence such that the adjacent maximum sequence\r\nof becomes . For this we again have ways because can be inserted in\r\nplaces: before or after .Similarly for all other we have ways to insert\r\nit: putting it before or after . So the total number of good\r\npermutations of is .So our problem reduces to the following: Select a\r\nlength such that . Count the number of strictly increasing sequences of\r\nlength such that all suffix GCDs are distinct. Multiply the answer by .\r\nSum up the answer for all valid . For a fixed , let\u00e2\u0080\u0099s count the number\r\nof strictly increasing sequences of length such that all suffix GCDs are\r\ndistinct.Let be the number of strictly increasing sequences of length\r\nsuch that the starting element is and the GCD of the elements is .Now\r\niterate from to . Then the transition is to iterate over the next suffix\r\nGCD such that divides , and and then add to . Here is the sum of all for\r\nall .Another way to look at the transition is that for a fixed , we\r\niterate over all and if , then we add to .But doing everything like this\r\nwould still be which is too slow.Notice that all are the divisors of .\r\nHere the main difficulty is that we need update at the index over all\r\nbut it is hard to track the exact gcd but what\u00e2\u0080\u0099s easier is to track the\r\nmultiple of the gcd.So for each , let\u00e2\u0080\u0099s say we know the sum of all over\r\nall such that divides . So this sums up all such that divides . Then\r\nusing inclusion exclusion on the divisors of we can get the sum of all\r\nfor all such that is exactly . This will take time for each where is the\r\nnumber of divisors of .And once we calculate the for some and , then\r\nbefore transitioning to , we can add the value of to all divisors of to\r\nget the value of faster in the future. To keep track of this, we can use\r\na separate array.So for a fixed , the time complexity is . And we need\r\nto do this for all from to .So the overall time complexity is . We\r\nactually allowed this to pass in F1.We can make the time complexity much\r\nbetter with a simple modification in the dp. Note that we don\u00e2\u0080\u0099t need to\r\nuse the length of array in the dp state. As we need to sum up after\r\nmultiplying by at the end, we can modify the dp to directly store the\r\nsum of . So we can just multiply the dp by during each transition.So the\r\ntime complexity becomes . This is very fast for F1.\r\n",
    "name": "F1. Shohag Loves Counting  Easy Version ",
    "statement": "For an integer array a of length n, define f(k) as the greatest common\r\ndivisor (GCD) of the maximum values of all subarrays^{\r\ntext{ }} of length k. For example, if the array is [2, 1, 4, 6, 2], then\r\nf(3) =\r\noperatorname{gcd}(\r\noperatorname{max}([2, 1, 4]),\r\noperatorname{max}([1, 4, 6]),\r\noperatorname{max}([4, 6, 2])) =\r\noperatorname{gcd}(4, 6, 6) = 2.An array is good if f(i)\r\nneq f(j) is satisfied over all pairs 1\r\nle i\r\nlt j\r\nle n.Shohag has an integer m. Help him count the number, modulo 998\r\n,244\r\n,353, of non-empty good arrays of arbitrary length such that each\r\nelement of the array is an integer from 1 to m.^{\r\ntext{ }}An array d is a subarray of an array c if d can be obtained from\r\nc by deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n;mint dp[N]; vi dv[N];mint mut[N];mint mu[N];void Main() {\tcin >> n;\tL(i, 1, n) dp[i] = mut[i] = 0;\tmint ans = 0;\tR(i, n, 1) {\t\t// L(j, 1, n) if(__gcd(i, j) < j) {\t\t// \tdp[__gcd(i, j)] += dp[j] * 2;\t\t// \tans += dp[j] * 2;\t\t// }\t\tfor(int d : dv[i]) {\t\t\tmint qwq = 0;\t\t\tfor(int nd : dv[i / d]) qwq += mu[nd] * mut[d * nd];\t\t\tqwq -= dp[d];\t\t\t// cout << i <<' '<<d<<\"inc \" << qwq.x << ' ' << mut[d].x << ' ' << mut[d * 2].x << endl;\u00a0\t\t\tqwq *= 2;\t\t\tans += qwq;\t\t\tdp[d] += qwq;\t\t\tfor(auto s : dv[d]) {\t\t\t\tmut[s] += qwq;\t\t\t}\t\t}\t\tdp[i] += 1;\t\tans += 1;\t\tfor(auto j : dv[i]) mut[j] += 1;\t\t// L(j, 1, n) cout << dp[j].x << ' ';\t\t// cout << endl;\t}\tcout << ans.x << '\\n';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint mx = 1e6;\tL(i, 1, mx)\t\tL(j, 1, mx / i)\t\t\tdv[i * j].pb(i);\tL(i, 1, mx)\t\tmu[i] = (i == 1);\tL(i, 1, mx)\t\tL(j, 2, mx / i)\t\t\tmu[i * j] -= mu[i];\t// cout << \"mu = \" << mu[2].x << endl;\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F1. Shohag Loves Counting  Easy Version .json"
}