{
    "link": "https://codeforces.com//contest/1987/problem/A",
    "problemId": "2726560",
    "problem_idx": "A",
    "shortId": "1987A",
    "contest_number": "1987",
    "problem_submissions": {
        "E": [
            268229906,
            268158602,
            268423905,
            268422817,
            268157857,
            268152628,
            268233241,
            268233207,
            268156681,
            268158666,
            268162964,
            268158456,
            268163362,
            268156782,
            268165522,
            268170420,
            268158686,
            268162341,
            268233753,
            268228306,
            268160955,
            268160065,
            268161194,
            268164320,
            268163376,
            268166928,
            268264962,
            268164535
        ],
        "H": [
            268205560,
            268243575,
            268242763,
            268242753,
            268226875,
            268226200,
            286117872,
            286117361,
            268621342,
            270559507
        ],
        "G2": [
            268199327,
            268183184,
            268209905,
            268197988,
            268210865,
            268209119,
            268201265,
            268217291,
            268203603,
            268206936,
            268211532,
            268216966,
            268392569
        ],
        "G1": [
            268197008,
            268183589,
            268183559,
            268192970,
            268191020,
            268190335,
            268201091,
            268194194,
            268192954,
            268200485,
            268201459,
            268210583,
            268191184,
            268204488,
            268195197,
            268205593,
            268203056,
            268392539,
            268196879,
            268201576,
            268201255
        ],
        "F2": [
            268174418,
            268166457,
            268162505,
            268182920,
            268168846,
            268174436,
            268185759,
            268178301,
            268181565,
            268191599,
            268193415,
            268177500,
            268170902,
            268180818,
            268174520,
            268182719,
            268178817,
            268190336,
            268190071
        ],
        "F1": [
            268173831,
            268166694,
            268162641,
            268178377,
            268169399,
            268174193,
            268185332,
            268177979,
            268170897,
            268181978,
            268191481,
            268193293,
            268177600,
            268169616,
            268180668,
            268173797,
            268182414,
            268176479,
            268181249,
            268189979
        ],
        "D": [
            268149772,
            268151878,
            268147683,
            268147422,
            268149471,
            268152924,
            268151963,
            268155962,
            268148798,
            268153037,
            268153285,
            268152472,
            268152498,
            268151784,
            268149550,
            268150424,
            268156633,
            268151156,
            268159183,
            268155639
        ],
        "C": [
            268144323,
            268147501,
            268383290,
            268143974,
            268142997,
            268142336,
            268156117,
            268145345,
            268149662,
            268144034,
            268146014,
            268146306,
            268146500,
            268154494,
            268145000,
            268144648,
            268146061,
            268146320,
            268145299,
            268148183,
            268146033
        ],
        "B": [
            268142097,
            268138793,
            268136942,
            268137419,
            268137014,
            268140558,
            268141012,
            268143732,
            268140016,
            268142374,
            268143256,
            268141729,
            268142582,
            268139760,
            268140776,
            268140696,
            268140576,
            268139314,
            268141992,
            268141951
        ],
        "A": [
            268135899,
            268135441,
            268135342,
            268135356,
            268135339,
            268135852,
            268135895,
            268139203,
            268135363,
            268137561,
            268136567,
            268135744,
            268136590,
            268135768,
            268135350,
            268135764,
            268135555,
            268135575,
            268136024,
            268138028
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131053",
    "editorial": "First of all, note that you can upload GBs of RAM if you upload on the\r\nseconds , taking seconds in total. Letâs show that itâs impossible to do\r\nbetter.Suppose there is a solution where you upload on the times ,\r\ntaking seconds to upload GBs. Then, for all . Furthermore, . Thus, we\r\nhave the following inequalities: Using them, we get the inequalities So,\r\n, so the answer is at least . Since there is always a way to upload in\r\nexactly this many seconds, this is the answer to our problem.Complexity:\r\n",
    "name": "A. Upload More RAM",
    "statement": "You want to upload n GBs of RAM. Every second, you will upload either 0\r\nor 1 GB of RAM. However, there is a restriction on your network speed:\r\nin any k consecutive seconds, you can upload only at most 1 GB of RAM in\r\ntotal.Find the minimum number of seconds needed to upload n GBs of RAM!\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, \"/stack:200000000\")#pragma GCC optimize(\"O3\")//~ #pragma GCC target (\"avx2\")//~ #pragma GCC optimize(\"Ofast\")//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")//~ #pragma GCC optimize(\"unroll-loops\")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds;using namespace std; template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; #define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << \"(\" << d.first << \", \" << d.second << \")\";}sim dor(rge<c> d) {  *this << \"[\";  for (auto it = d.b; it != d.e; ++it)    *this << \", \" + 2 * (it == d.b) << *it;  ris << \"]\";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \" #define shandom_ruffle random_shuffle using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=1000*1007;  void test(){\tll n, k;\tscanf(\"%lld%lld\", &n, &k);\tprintf(\"%lld\\n\", n+(n-1)*(k-1));} int main(){\tint t;\tscanf(\"%d\", &t);\twhile(t--)\t\ttest();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\A. Upload More RAM.json",
    "hint": [
        "Hint 1 Your strategy is to upload more RAM as soon as you can upload.",
        "Hint 2 You will upload on the seconds ."
    ]
}