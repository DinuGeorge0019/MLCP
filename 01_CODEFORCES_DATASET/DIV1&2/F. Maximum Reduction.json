{"link": "https://codeforces.com//contest/1037/problem/F", "problemId": "214575", "problem_idx": "F", "shortId": "1037F", "contest_number": "1037", "problem_submissions": {"G": [42400284, 42399505, 42393700, 42391956, 42395688, 49109531, 42416815, 42416802, 42408231, 42478375, 42723385, 42723256], "H": [42390789, 42393047, 42400959, 42399660, 42398441, 42399087, 42414998, 42453023, 42876495, 42876025, 42875988, 42875931], "E": [42383633, 42376516, 42374024, 42375460, 42374374, 42376325, 42382856, 42374364, 42376990, 42377973, 42378251, 42378271, 42378643, 42380819, 42380647, 42383308, 42382412, 42381355], "F": [42381395, 42382506, 42383872, 42380708, 42386216, 42379786, 42391156, 42378290, 42387714, 42379959, 42384150, 42386649, 42388704, 42386435, 42387614, 42390065, 42389970, 42390483], "D": [42369087, 42370798, 42380041, 42371136, 42379827, 42374961, 42370290, 42370315, 42380263, 42370259, 42374008, 42373176, 42374905, 42371349, 42379998, 42373150, 42374030], "C": [42367060, 42368485, 42368461, 42367940, 42368563, 42368341, 42378567, 42367842, 42367459, 42369272, 42375102, 42369783, 42370363, 42370761, 42367752, 42376902, 42370198, 42370636], "B": [42366092, 42367373, 42367083, 42366507, 42366793, 42366735, 42367983, 42366366, 42366278, 42367057, 42372146, 42367428, 42368851, 42367360, 42366696, 42366630, 42368278, 42367696], "A": [42365839, 42365922, 42366199, 42365850, 42365879, 42366070, 42366134, 42365823, 42365810, 42366029, 42366879, 43951943, 42366275, 42367664, 42365933, 42365869, 42365891, 42366540, 42366060]}, "name": "F. Maximum Reduction", "statement": "Given an array a of n integers and an integer k (2\r\nle k\r\nle n), where each element of the array is denoted by a_i (0\r\nle i < n). Perform the operation z given below on a and print the value\r\nof z(a,k) modulo 10^{9}+7.function z(array a, integer k): if length(a) <\r\nk: return 0 else: b = empty array ans = 0 for i = 0 .. (length(a) - k):\r\ntemp = a[i] for j = i .. (i + k - 1): temp = max(temp, a[j]) append temp\r\nto the end of b ans = ans + temp return ans + z(b, k)\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 02.09.2018 17:54:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int INV2 = inv(2);\n\ninline int sum_positive(int start, int finish, int step) {\n  if (start <= 0) {\n    return 0;\n  }\n  if (finish < 0) {\n    finish += abs(finish) / step * step;\n  }\n  while (finish < 0) {\n    finish += step;\n  }\n  int cnt = (start - finish) / step + 1;\n  int value = mul(mul(start + finish, cnt), INV2);\n  return value;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<pair<int,int>> e(n);\n  for (int i = 0; i < n; i++) {\n    cin >> e[i].first;\n    e[i].second = i;\n  }\n  sort(e.begin(), e.end());\n  vector<int> pr(n), ne(n);\n  for (int i = 0; i < n; i++) {\n    pr[i] = i - 1;\n    ne[i] = i + 1;\n  }\n  const int step = k - 1;\n  int ans = 0;\n  for (auto &pp : e) {\n    int i = pp.second;\n    int L = pr[i] + 1;\n    int R = ne[i] - 1;\n    int len = (R - L + 1);\n    if (len >= k) {\n      int pos = i - L;\n      int xstart = k;\n      int xfinish = k + (len - k) / step * step;\n      int xcnt = (xfinish - xstart) / step + 1;\n      {\n        int value = sum_positive(pos + 1 - xstart, pos + 1 - xfinish, step);\n        sub(ans, mul(value, pp.first));\n      }\n      {\n        add(ans, mul(mul(pos, xcnt), pp.first));\n        int value = sum_positive(xfinish + pos - len, xstart + pos - len, step);\n        sub(ans, mul(value, pp.first));\n      }\n      add(ans, mul(xcnt, pp.first));\n    }\n    if (pr[i] != -1) {\n      ne[pr[i]] = ne[i];\n    }\n    if (ne[i] != n) {\n      pr[ne[i]] = pr[i];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "data structures", "math"], "dificulty": "2500", "interactive": false}