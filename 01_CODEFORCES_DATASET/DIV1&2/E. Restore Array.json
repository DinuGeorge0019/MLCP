{
    "link": "https://codeforces.com//contest/1028/problem/E",
    "problemId": "212303",
    "problem_idx": "E",
    "shortId": "1028E",
    "contest_number": "1028",
    "problem_submissions": {
        "F": [
            42179553,
            42173574,
            42172126,
            42183823,
            42179375,
            42177929,
            42176646,
            42176739,
            42168545,
            42174904,
            42175563,
            42187810,
            42177441,
            42180538,
            42178358,
            42178178
        ],
        "H": [
            42177022,
            42177937,
            42197383,
            42174346,
            42178267,
            42180853,
            42180364,
            42179125,
            42178613,
            42177685,
            42188074
        ],
        "G": [
            42174235,
            42180921,
            42179342,
            42179278,
            42183838,
            42181415,
            42188299,
            42175088,
            42183699,
            42177809,
            42199769,
            42180709
        ],
        "E": [
            42168417,
            42169350,
            42169465,
            42168142,
            42175311,
            42172346,
            42172643,
            42173588,
            42169997,
            42170922,
            42170783,
            42169728,
            42172341,
            42172392,
            42174203,
            42173993,
            42169247
        ],
        "D": [
            42165714,
            42166524,
            42166821,
            42171266,
            42167648,
            42168290,
            42168039,
            42170991,
            42171075,
            42166522,
            42165185,
            42167753,
            42167327,
            42166990,
            42167859,
            42166718,
            42169672,
            42169316,
            42172369
        ],
        "C": [
            42162420,
            42161280,
            42164158,
            42159623,
            42162254,
            42163150,
            42163507,
            42162131,
            42163347,
            42161576,
            42161023,
            42164637,
            42163616,
            42161801,
            42163884,
            42163193,
            42164354,
            42165199,
            42162360
        ],
        "B": [
            42159958,
            42159146,
            42159962,
            42160148,
            42160038,
            42161126,
            42160845,
            42163792,
            42159144,
            42162163,
            42159196,
            42160477,
            42160541,
            42159094,
            42160870,
            42160007,
            42160216,
            42160794,
            42159231
        ],
        "A": [
            42158947,
            42158816,
            42158953,
            42161141,
            42158802,
            42159721,
            42159618,
            42163119,
            42158831,
            42163007,
            42158820,
            42158811,
            42158901,
            42158777,
            42159186,
            42158929,
            42158806,
            42159328,
            42158825
        ]
    },
    "name": "E. Restore Array",
    "statement": "While discussing a proper problem A for a Codeforces Round, Kostya\r\ncreated a cyclic array of positive integers a_1, a_2,\r\nldots, a_n. Since the talk was long and not promising, Kostya created a\r\nnew cyclic array b_1, b_2,\r\nldots, b_{n} so that b_i = (a_i\r\nmod a_{i + 1}), where we take a_{n+1} = a_1. Here mod is the modulo\r\noperation. When the talk became interesting, Kostya completely forgot\r\nhow array a had looked like. Suddenly, he thought that restoring array a\r\nfrom array b would be an interesting problem (unfortunately, not A).\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 200000;\n\nint n;\nll a[MAXN];\nll b[MAXN];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tint sh = -1;\n\tll mx = *max_element(a, a + n);\n\tif (mx == 0) {\n\t\tcout << \"YES\\n\";\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcout << 1 << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t\treturn 0;\n\t}\n\tif (a[0] == mx && a[n - 1] < a[0]) {\n\t\trotate(a, a + 1, a + n);\n\t\tsh = 1;\n\t}\n\telse {\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tif (a[i + 1] == mx && a[i] < a[i + 1]) {\n\t\t\t\tif (i + 1 != n - 1) {\n\t\t\t\t\trotate(a, a + i + 1 + 1, a + n);\n\t\t\t\t}\n\t\t\t\tsh = i + 1 + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sh == -1) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tb[n - 1] = a[n - 1];\n\tb[n - 2] = 2 * a[n - 1] + a[n - 2];\n\tfor (int i = n - 3; i >= 0; --i) {\n\t\tb[i] = a[i] + b[i + 1];\n\t}\n\tint x = n - sh;\n\tif (x == n)\n\t\tx = 0;\n\trotate(b, b + x, b + n);\n\tcout << \"YES\\n\";\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << b[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Restore Array.json",
    "editorial_link": "https://codeforces.com/blog/entry/61493",
    "editorial": "Let\u00e2\u0080\u0099s consider a special case at first: all numbers are equal to . Then\r\nthe answer exists only if (prove it as an exercise).Now let be the\r\nmaximum value in array . Then there exists an index such that and (we\r\nassume ). We assume it\u00e2\u0080\u0099s , otherwise we just shift the array to make\r\nthis happen. Then and satisfies all the constraints. That\u00e2\u0080\u0099s true,\r\nbecause , for , for because is maximum value, which is greater than , ,\r\nbecause . Note that without multiplier before in the formula solution\r\nwon\u00e2\u0080\u0099t work if all numbers in the array except for one are zeroes,\r\nbecause in this case . Also instead of it\u00e2\u0080\u0099s possible to use something\r\nlike , the proof doesn\u00e2\u0080\u0099t change much in this case.\r\n"
}