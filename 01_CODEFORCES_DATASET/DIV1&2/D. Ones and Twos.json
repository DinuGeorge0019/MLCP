{
    "link": "https://codeforces.com//contest/1896/problem/D",
    "problemId": "2346408",
    "problem_idx": "D",
    "shortId": "1896D",
    "contest_number": "1896",
    "problem_submissions": {
        "H2": [
            234305435,
            234294276,
            234316807,
            234293989,
            234307453,
            234313145,
            234308430,
            234674727,
            234674461,
            234674412,
            234348461,
            234317754,
            234317500
        ],
        "H1": [
            234300435,
            234288752,
            234294076,
            234304469,
            234296832,
            234303366,
            234305063,
            234305336,
            234301810,
            234292381
        ],
        "G": [
            234290728,
            234312960,
            234419627,
            234295328,
            234299457,
            234326268,
            234302972,
            234306994,
            234344999,
            234302897,
            234304455,
            234306035,
            234296895,
            234525586
        ],
        "F": [
            234279344,
            234262280,
            234278356,
            234281909,
            234284183,
            234288595,
            234278118,
            234284621,
            234280975,
            234283777,
            234307968,
            234293096,
            234293697,
            234294644,
            234304686,
            234282511,
            234279944,
            234277321
        ],
        "E": [
            234266080,
            234275828,
            234270895,
            234263950,
            234269369,
            234263464,
            234267763,
            234270201,
            234272007,
            234268761,
            234270245,
            234285745,
            234275911,
            234277731,
            234273316,
            234269329,
            234260178,
            234268619,
            234263914
        ],
        "D": [
            234260515,
            234269507,
            234266479,
            234257220,
            234264143,
            234256547,
            234261136,
            234260603,
            234265661,
            234261124,
            234261787,
            234269263,
            234266704,
            234265834,
            234268166,
            234280921,
            234253907,
            234259650,
            234255630
        ],
        "C": [
            234253899,
            234266056,
            234253267,
            234251911,
            234261130,
            234253006,
            234255721,
            234254779,
            234258245,
            234287578,
            234255535,
            234262815,
            234255118,
            234261416,
            234262126,
            234255695,
            234249255,
            234253498,
            234251351
        ],
        "B": [
            234249421,
            234247262,
            234248984,
            234247486,
            234250283,
            234247863,
            234248979,
            234248837,
            234302894,
            234248804,
            234248842,
            234247845,
            234248167,
            234249751,
            234253337,
            234249856,
            234245662,
            234248853,
            234246737
        ],
        "A": [
            234245828,
            234244872,
            234245833,
            234244939,
            234247553,
            234244853,
            234245867,
            234245696,
            234303768,
            234246110,
            234245020,
            234245161,
            234244947,
            234245703,
            234249430,
            234244871,
            234244771,
            234245709,
            234244767
        ]
    },
    "name": "D. Ones and Twos",
    "statement": "You are given a 1-indexed array a of length n where each element is 1 or\r\n2.Process q queries of the following two types: \"\": check if there\r\nexists a subarray^{\r\ndagger} of a whose sum equals to s. \"\": change a_i to v. ^{\r\ndagger} An array b is a subarray of an array a if b can be obtained from\r\na by deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end. In\r\nparticular, an array is a subarray of itself.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\nint tab[nax];\n\nint fen[nax];\n\nvoid pisz(int v, int x)\n{\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tfen[i]+=x;\n}\n\nint czyt(int v)\n{\n\tint ret=0;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n}\n\nset<int> jed;\n\nint pier()\n{\n\tif (jed.empty())\n\t\treturn n+1;\n\treturn (*jed.begin());\n}\n\nint ost()\n{\n\tif (jed.empty())\n\t\treturn 0;\n\tauto it=jed.end();\n\tit--;\n\treturn (*it);\n}\n\nvoid test()\n{\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfen[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t\tpisz(i, tab[i]);\n\tjed.clear();\n\tfor (int i=1; i<=n; i++)\n\t\tif (tab[i]==1)\n\t\t\tjed.insert(i);\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(\"%d\", &typ);\n\t\tif (typ==2)\n\t\t{\n\t\t\tint x, w;\n\t\t\tscanf(\"%d%d\", &x, &w);\n\t\t\tpisz(x, -tab[x]);\n\t\t\tif (tab[x]==1)\n\t\t\t\tjed.erase(x);\n\t\t\ttab[x]=w;\n\t\t\tpisz(x, tab[x]);\n\t\t\tif (tab[x]==1)\n\t\t\t\tjed.insert(x);\n\t\t\tcontinue;\n\t\t}\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tif (czyt(n)<s)\n\t\t{\n\t\t\tans(0);\n\t\t\tcontinue;\n\t\t}\n\t\tint bsa=0;\n\t\tint bsb=n;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb+2)>>1;\n\t\t\tif (czyt(bss)<=s)\n\t\t\t\tbsa=bss;\n\t\t\telse\n\t\t\t\tbsb=bss-1;\n\t\t}\n\t\tif (czyt(bsa)==s)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ost()>bsa)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pier()<=n-bsa)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tans(0);\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "math",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Ones and Twos.json",
    "editorial_link": "https://codeforces.com//blog/entry/122172",
    "editorial": "SolutionDenote as the sum of subarray from to .Claim: If there is any\r\nsubarray with sum , we can find a subarray with sum .Proof: Suppose ,\r\nconsider 3 cases: , we have . , we have . , we have . So to check if\r\nthere exists a subarray whose sum equals , we can find the maximum\r\nsubarray sum having the same parity with and compare it with .The case\r\nwhere is obvious, suppose the opposite happens. If array is full of -s,\r\nthe answer is . Otherwise, let and be the positions of the first and\r\nlast in . Any subarray with will have a different parity with . So we\r\nwill compare with to get the answer.\r\n"
}