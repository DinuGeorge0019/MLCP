{
    "link": "https://codeforces.com//contest/914/problem/D",
    "problemId": "148489",
    "problem_idx": "D",
    "shortId": "914D",
    "contest_number": "914",
    "problem_submissions": {
        "E": [
            34383567,
            34380688,
            34384037,
            34379971,
            34385853,
            34381341,
            34377061,
            34385471,
            34377068,
            34383097,
            34381216,
            34377930,
            34393845,
            34378590,
            34386380,
            34381164
        ],
        "C": [
            34382803,
            34382793,
            34364057,
            34365651,
            34386486,
            34396063,
            34363721,
            34365741,
            34364774,
            34366702,
            34391506,
            34365007,
            34367351,
            34382826,
            34374119,
            34384464,
            34372151,
            34370073
        ],
        "G": [
            34376415,
            34377275,
            34377412,
            34382707,
            34380896,
            34376017,
            34382091,
            34379406,
            34377065,
            34381510,
            34378767,
            34384171,
            34382760,
            34380461,
            34386445,
            34380566,
            34388276,
            34376347,
            34387872,
            34388821
        ],
        "F": [
            34372924,
            34364964,
            34388114,
            34388527,
            34377465,
            34383969,
            34384849,
            34382075,
            34408585,
            34427444,
            34427415,
            34427411,
            34427369,
            34426234,
            34426219,
            34426204,
            34426181,
            34395428,
            34395305,
            34393742,
            34393096,
            34392685,
            34377829,
            34381405,
            34389663,
            34384026
        ],
        "D": [
            34370762,
            34371655,
            34369773,
            34368591,
            34374188,
            34367037,
            34369044,
            34372797,
            34370541,
            34371781,
            34370647,
            34370823,
            34372317,
            34370221,
            34393812,
            34371853,
            34371865,
            34370930,
            34372046,
            34375276,
            34374115
        ],
        "B": [
            34360667,
            34360722,
            34374939,
            34362210,
            34374843,
            34362983,
            34377719,
            34363222,
            34359679,
            34359608,
            34366166,
            34384598,
            34360320,
            34360372,
            34361647,
            34362020,
            34368128,
            34362137,
            34362752,
            34361533
        ],
        "A": [
            34357760,
            34358042,
            34374626,
            34357833,
            34358764,
            34358376,
            34358219,
            34358285,
            34357836,
            34357713,
            34358130,
            34358072,
            34357931,
            34391604,
            34358333,
            34358022,
            34358632,
            34358260,
            34359117,
            34357845
        ],
        "H": [
            34391572,
            34389095
        ]
    },
    "name": "D. Bash and a Tough Math Puzzle",
    "statement": "Bash likes playing with arrays. He has an array of integers. He likes to\r\nguess the greatest common divisor (gcd) of different segments of the\r\narray. Of course, sometimes the guess is not correct. However, Bash will\r\nbe satisfied if his guess is .Suppose he guesses that the gcd of the\r\nelements in the range of is . He considers the guess to be almost\r\ncorrect if he can change one element in the segment such that the gcd of\r\nthe segment is after making the change. Note that when he guesses, he\r\ndoesn\u2019t actually change the array he just wonders if the gcd of the\r\nsegment can be made . Apart from this, he also sometimes makes changes\r\nto the array itself.Since he can\u2019t figure it out himself, Bash wants you\r\nto tell him which of his guesses are almost correct. Formally, you have\r\nto process queries of one of the following forms: Bash guesses that the\r\ngcd of the range is . Report if this guess is almost correct. Bash sets\r\nto . The array is -indexed.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<assert.h>\n#include<queue>\n#include<string>\n#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)\n#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=510000;\ninline void read(int &x){\n\tx=0;char p=getchar();\n\twhile(!(p<='9'&&p>='0'))p=getchar();\n\twhile(p<='9'&&p>='0')x*=10,x+=p-48,p=getchar();\n}\t\nint gcd(int a,int b){\n\tif(!a||!b)return a+b;\n\treturn gcd(b,a%b);\n}\nint cc[N<<2];\nvoid build(int me,int l,int r){\n\tif(l==r){\n\t\tread(cc[me]);\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(me<<1,l,mid);\n\tbuild(me<<1|1,mid+1,r);\n\tcc[me]=gcd(cc[me<<1|1],cc[me<<1]);\n}\nvoid modify(int me,int l,int r,int x,int y){\n\tif(l==r){\n\t\tcc[me]=y;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid)modify(me<<1,l,mid,x,y);\n\telse modify(me<<1|1,mid+1,r,x,y);\n\tcc[me]=gcd(cc[me<<1|1],cc[me<<1]);\n}\nbool query(int me,int l,int r,int x,int y,int d,int &res){\n\tif(res<0)return 0;\n\tif(cc[me]%d==0)return 1;\n\tif(l==r){\n\t\t--res;\n\t\tif(res<0)return 0;\n\t\telse return 1;\n\t}\n\tint mid=(l+r)>>1;\n\tbool is=1;\n\tif(x<=mid)is=query(me<<1,l,mid,x,y,d,res);\n\tif(!is)return 0;\n\tif(y>mid)is=query(me<<1|1,mid+1,r,x,y,d,res);\n\tif(!is)return 0;\n\treturn 1;\n}\nint n,Q;\nint main(){\n\tscanf(\"%d\",&n);\n\tbuild(1,1,n);\n\tscanf(\"%d\",&Q);\n\twhile(Q--){\n\t\tint ty;read(ty);\n\t\tif(ty==1){\n\t\t\tint l,r,x;read(l);read(r);read(x);\n\t\t\tint rp=1;\n\t\t\tif(query(1,1,n,l,r,x,rp)){\n\t\t\t\tif(rp<0)puts(\"NO\");\n\t\t\t\telse puts(\"YES\");\n\t\t\t}\n\t\t\telse puts(\"NO\");\n\t\t}\n\t\telse{\n\t\t\tint x,y;read(x);read(y);\n\t\t\tmodify(1,1,n,x,y);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Bash and a Tough Math Puzzle.json",
    "editorial_link": "https://codeforces.com//blog/entry/57250",
    "editorial": "Build a segment tree on the array to answer range gcd queries. We can\r\nhandle single element updates in the segment tree. Let us see how to\r\nanswer an query.The segment tree decomposes the query range into nodes\r\nthat cover the range. If the gcds of all of these nodes are multiples of\r\n, then the answer is . If the gcd of two or more of these nodes is not a\r\nmultiple of , then the answer is .If the gcd of exactly one node is not\r\na multiple of , then we need to know how many elements in this node are\r\nnot multiples of . We can find this by traversing the descendents of\r\nthat node.If at a point only one child is not a multiple of , recurse\r\ninto it. If at any point, there are two children whose gcds are not\r\nmultiples of , then the answer is . Otherwise, if we reach a node that\r\ndoesn\u00e2\u0080\u0099t have any children, then the answer is .\r\n"
}