{
    "link": "https://codeforces.com//contest/1804/problem/E",
    "problemId": "1824144",
    "problem_idx": "E",
    "shortId": "1804E",
    "contest_number": "1804",
    "problem_submissions": {
        "H": [
            197133699,
            197211600
        ],
        "G": [
            197106837,
            197116479,
            197124948,
            197127592,
            197122958,
            197137640,
            197134544,
            197138362
        ],
        "F": [
            197093293,
            197105349,
            197095528,
            197104786,
            197106624,
            197098643,
            197101524,
            197103930,
            197102162,
            197105107,
            197108552,
            197108666,
            197107628,
            197142671,
            197140184,
            197139967,
            197139883,
            197139641,
            197111482,
            197111626,
            197113675,
            197111909,
            197110044,
            197110987,
            197113933
        ],
        "E": [
            197089405,
            197085286,
            197090524,
            197097633,
            197097337,
            197091345,
            197092803,
            197096473,
            197096893,
            197095376,
            197096756,
            197096855,
            197096490,
            197096936,
            197101267,
            197098474,
            197101399,
            197096360,
            197103528,
            197097046
        ],
        "D": [
            197081706,
            197080440,
            197082836,
            197086161,
            197088893,
            197081349,
            197083999,
            197084952,
            197086950,
            197076993,
            197086858,
            197086874,
            197084897,
            197084889,
            197084721,
            197084970,
            197089163,
            197084662,
            197086535,
            197082927
        ],
        "C": [
            197078079,
            197076920,
            197078785,
            197081523,
            197083238,
            197076107,
            197077574,
            197078670,
            197077463,
            197082879,
            197080775,
            197081089,
            197078608,
            197079622,
            197080414,
            197078487,
            197079270,
            197080239,
            197080507,
            197079932
        ],
        "B": [
            197075523,
            197075248,
            197075383,
            197077168,
            197080868,
            197074547,
            197074457,
            197076648,
            197075635,
            197080800,
            197077487,
            197076188,
            197075795,
            197076995,
            197076635,
            197075839,
            197076655,
            197076988,
            197077650,
            197075789
        ],
        "A": [
            197073420,
            197073942,
            197073446,
            197073814,
            197078430,
            197073370,
            197073351,
            197073646,
            197073456,
            197078319,
            197074505,
            197073977,
            197073328,
            197073488,
            197073501,
            197073461,
            197073950,
            197074331,
            197075653,
            197073687
        ]
    },
    "name": "E. Routing",
    "statement": "Ada operates a network that consists of n servers and m direct\r\nconnections between them. Each direct connection between a pair of\r\ndistinct servers allows bidirectional transmission of information\r\nbetween these two servers. Ada knows that these m direct connections\r\nallow to directly or indirectly transmit information between any two\r\nservers in this network. We say that server v is a neighbor of server u\r\nif there exists a direct connection between these two servers.Ada needs\r\nto configure her network\u2019s WRP (Weird Routing Protocol). For each server\r\nu she needs to select exactly one of its neighbors as an auxiliary\r\nserver a(u). After all a(u) are set, routing works as follows. Suppose\r\nserver u wants to find a path to server v (different from u). Server u\r\nchecks all of its direct connections to other servers. If it sees a\r\ndirect connection with server v, it knows the path and the process\r\nterminates. If the path was not found at the first step, server u asks\r\nits auxiliary server a(u) to find the path. Auxiliary server a(u)\r\nfollows this process starting from the first step. After a(u) finds the\r\npath, it returns it to u. Then server u constructs the resulting path as\r\nthe direct connection between u and a(u) plus the path from a(u) to v.\r\nAs you can see, this procedure either produces a correct path and\r\nfinishes or keeps running forever. Thus, it is critically important for\r\nAda to configure her network\u2019s WRP properly.Your goal is to assign an\r\nauxiliary server a(u) for each server u in the given network. Your\r\nassignment should make it possible to construct a path from any server u\r\nto any other server v using the aforementioned procedure. Or you should\r\nreport that such an assignment doesn\u2019t exist.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u] |= 1 << v;\n        adj[v] |= 1 << u;\n    }\n    \n    std::vector<int> dp(1 << n);\n    for (int i = 0; i < n; i++) {\n        dp[1 << i] |= 1 << i;\n    }\n    for (int s = 1; s < (1 << n); s++) {\n        int sadj = 0;\n        for (int i = 0; i < n; i++) {\n            if (s >> i & 1) {\n                sadj |= adj[i];\n            }\n        }\n        int lo = __builtin_ctz(s);\n        if (sadj == (1 << n) - 1 && (adj[lo] & dp[s])) {\n            int nxt = lo;\n            std::vector<int> cyc;\n            int S = s;\n            while (S != (1 << lo)) {\n                int t = __builtin_ctz(dp[S] & adj[nxt]);\n                cyc.push_back(t);\n                S ^= 1 << t;\n                nxt = t;\n            }\n            cyc.push_back(lo);\n            std::cout << \"Yes\\n\";\n            std::vector<int> a(n, -1);\n            std::queue<int> q;\n            for (int i = 0; i < cyc.size(); i++) {\n                a[cyc[i]] = cyc[(i + 1) % cyc.size()];\n                q.push(cyc[i]);\n            }\n            while (!q.empty()) {\n                int x = q.front();\n                q.pop();\n                for (int y = 0; y < n; y++) {\n                    if (~adj[x] >> y & 1) {\n                        continue;\n                    }\n                    if (a[y] == -1) {\n                        a[y] = x;\n                        q.push(y);\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                std::cout << a[i] + 1 << \" \\n\"[i == n - 1];\n            }\n            return 0;\n        }\n        int mask = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[s] >> i & 1) {\n                mask |= adj[i];\n            }\n        }\n        for (int i = lo; i < n; i++) {\n            if ((~s & mask) >> i & 1) {\n                dp[s | 1 << i] |= 1 << i;\n            }\n        }\n    }\n    \n    std::cout << \"No\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Routing.json",
    "editorial_link": "https://codeforces.com//blog/entry/113830",
    "editorial": "A directed graph where each node has an out-degree equal to 1 (exactly\r\none arc starts at this node) is called functional. By setting auxiliary\r\nservers a(v) for each server v we define a functional graph.The\r\nfollowing condition is necessary and sufficient. The answer exists if\r\nand only if there exists a functional graph defined by a(v) that\r\ncontains a cycle C such that N_G(C) = V(G). That means that each node\r\nshould be neighbouring to at least one node of this cycle in the\r\noriginal graph. Note that cycles of length 1 are not allowed as a(v)\r\nne v by definition. The proof is easy. If such a cycle C exists we can\r\nreconstruct all other a(v) to lead to this cycle. This will allow WRP to\r\nconstruct a path to each server after the procedure gets to the cycle.\r\nIf such a cycle doesn\u00e2\u0080\u0099t exists, we can pick any node of any cycle\r\n(functional graph always has at least one) and some servers will be\r\nunreachable from it.Wow we need to find a cycle of length\r\ngeq 2 such that each server belongs to this cycle or is directly\r\nconnected to at least one server of the cycle.First we run a dynamic\r\nprogramming similar to Hamiltonian path and identify all the subsets of\r\nservers that can form a cycle. This will take O(2^n\r\ncdot n^2) if we use the following meaning of d(m, v). d(m, v) = 0 if\r\nthere exists a path that starts from node u, visits all nodes of a\r\nsubset defined by bitmask m and ends in node v. Here node u is the node\r\nwith minimum index in subset m, as you can always pick the\r\nminimum-indexed node as the beginning of the cycle.After we compute d(m,\r\nv) we take all m such that there exists d(m, v) = 1 and check whether\r\nN_G(m) = V(G). This can be done in O(2^n\r\ncdot n^2) as well.Thus, the overall complexity is O(2^n\r\ncdot n^2).\r\n"
}