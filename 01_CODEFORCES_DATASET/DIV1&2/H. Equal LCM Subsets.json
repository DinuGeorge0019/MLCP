{
    "link": "https://codeforces.com//contest/1656/problem/H",
    "problemId": "1341211",
    "problem_idx": "H",
    "shortId": "1656H",
    "contest_number": "1656",
    "problem_submissions": {
        "H": [
            150787257,
            150834092,
            150833898,
            150779624,
            150791810,
            150792367,
            150793746,
            150802821,
            150793244,
            150784328,
            150836239,
            150786830,
            150787392,
            150775313,
            150792322,
            150812291,
            150837917,
            150835814,
            150835788,
            150835748,
            150835735,
            150835565,
            150835404,
            150835313,
            150835295,
            150835202,
            150835140,
            150813121
        ],
        "G": [
            150769137,
            150790740,
            150776335,
            150781798,
            150778878,
            150781350,
            150783120,
            150789415,
            150791824,
            150790309,
            150773559,
            150791984,
            150793946,
            150800739,
            150800780
        ],
        "F": [
            150759585,
            150758819,
            150757088,
            150759741,
            150768307,
            150764851,
            150771817,
            150759499,
            150756577,
            150773688,
            150782772,
            150774145,
            150769570,
            150765258,
            150764625,
            150756214,
            150776414,
            150776503,
            150774655,
            150777047
        ],
        "E": [
            150751361,
            150745742,
            150744206,
            150750256,
            150757531,
            150753091,
            150760157,
            150764520,
            150764445,
            150756529,
            150749400,
            150762413,
            150747229,
            150753617,
            150756813,
            150745115,
            150752324,
            150758442,
            150759352,
            150761061
        ],
        "D": [
            150742723,
            150736825,
            150739691,
            150737309,
            150752373,
            150748905,
            150751158,
            150737577,
            150743318,
            150744109,
            150743943,
            150742795,
            150742345,
            150737178,
            150746671,
            150740470,
            150742866,
            150748659,
            150752013,
            150752792
        ],
        "C": [
            150733096,
            150732015,
            150737243,
            150731632,
            150734197,
            150741651,
            150741487,
            150729270,
            150734650,
            150732482,
            150734630,
            150733212,
            150733482,
            150730538,
            150732987,
            150735181,
            150734697,
            150735222,
            150738885,
            150734495
        ],
        "B": [
            150727707,
            150727564,
            150729524,
            150727729,
            150727957,
            150730109,
            150730045,
            150725120,
            150728043,
            150726472,
            150725778,
            150727111,
            150726454,
            150727018,
            150729221,
            150817665,
            150730058,
            150728199,
            150728859,
            150727704
        ],
        "A": [
            150725204,
            150724798,
            150724946,
            150724479,
            150724835,
            150724855,
            150724694,
            150724426,
            150724692,
            150724405,
            150724424,
            150724740,
            150724465,
            150724564,
            150725589,
            150725242,
            150725512,
            150724576,
            150724789,
            150724666
        ],
        "I": [
            150839781,
            150825396
        ]
    },
    "name": "H. Equal LCM Subsets",
    "statement": "You are given two sets of positive integers A and B. You have to find\r\ntwo non-empty subsets S_A\r\nsubseteq A, S_B\r\nsubseteq B so that the least common multiple (LCM) of the elements of\r\nS_A is equal to the least common multiple (LCM) of the elements of S_B.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i128 = __int128;\n\nstd::istream &operator>>(std::istream &is, i128 &n) {\n    n = 0;\n    std::string s;\n    is >> s;\n    \n    for (auto c : s) {\n        n = 10 * n + c - '0';\n    }\n    return is;\n}\n\nstd::ostream &operator<<(std::ostream &os, i128 n) {\n    if (n == 0) {\n        return os << 0;\n    }\n    std::string s;\n    while (n > 0) {\n        s += '0' + n % 10;\n        n /= 10;\n    }\n    std::reverse(s.begin(), s.end());\n    return os << s;\n}\n\ni128 gcd(i128 a, i128 b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<i128> a(n), b(m);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < m; i++) {\n        std::cin >> b[i];\n    }\n    \n    std::set<i128> p;\n    std::function<void(i128)> add = [&](i128 n) {\n        if (n == 1) {\n            return;\n        }\n        for (auto x : p) {\n            while (n % x == 0) {\n                n /= x;\n            }\n        }\n        if (n == 1) {\n            return;\n        }\n        for (auto it = p.begin(); it != p.end(); it++) {\n            i128 x = *it;\n            i128 g = gcd(n, x);\n            if (g != 1) {\n                p.erase(it);\n                add(g);\n                add(n / g);\n                add(x / g);\n                return;\n            }\n        }\n        p.insert(n);\n    };\n    \n    for (int i = 0; i < n; i++) {\n        add(a[i]);\n    }\n    for (int i = 0; i < m; i++) {\n        add(b[i]);\n    }\n    \n    int N = p.size();\n    std::vector<i128> primes(p.begin(), p.end());\n    std::vector<std::set<std::pair<int, int>>> sa(N), sb(N);\n    std::vector<bool> ca(n, true), cb(m, true);\n    std::vector<std::vector<std::pair<int, int>>> pa(n), pb(m);\n    for (int i = 0; i < N; i++) {\n        sa[i].emplace(0, -1);\n        sb[i].emplace(0, -1);\n    }\n    \n    auto factor = [&](auto n) {\n        std::vector<std::pair<int, int>> p;\n        for (int i = 0; i < N; i++) {\n            int t = 0;\n            while (n % primes[i] == 0) {\n                n /= primes[i];\n                t++;\n            }\n            if (t > 0) {\n                p.emplace_back(i, t);\n            }\n        }\n        return p;\n    };\n    \n    for (int i = 0; i < n; i++) {\n        pa[i] = factor(a[i]);\n        for (auto [j, t] : pa[i]) {\n            sa[j].emplace(t, i);\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        pb[i] = factor(b[i]);\n        for (auto [j, t] : pb[i]) {\n            sb[j].emplace(t, i);\n        }\n    }\n    \n    std::function<void(int, int)> del;\n    \n    auto check = [&](int i) {\n        if (sa[i].rbegin()->first > sb[i].rbegin()->first) {\n            del(sa[i].rbegin()->second, 0);\n        }\n        if (sa[i].rbegin()->first < sb[i].rbegin()->first) {\n            del(sb[i].rbegin()->second, 1);\n        }\n    };\n    \n    del = [&](int i, int w) {\n        if (w == 0) {\n            if (!ca[i]) {\n                return;\n            }\n            ca[i] = false;\n            for (auto [j, t] : pa[i]) {\n                sa[j].erase({t, i});\n                check(j);\n            }\n        } else {\n            if (!cb[i]) {\n                return;\n            }\n            cb[i] = false;\n            for (auto [j, t] : pb[i]) {\n                sb[j].erase({t, i});\n                check(j);\n            }\n        }\n    };\n    \n    for (int i = 0; i < N; i++) {\n        check(i);\n    }\n    \n    if (ca != std::vector(n, false) && cb != std::vector(m, false)) {\n        std::cout << \"YES\\n\";\n        std::vector<int> ansa, ansb;\n        for (int i = 0; i < n; i++) {\n            if (ca[i]) {\n                ansa.push_back(i);\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            if (cb[i]) {\n                ansb.push_back(i);\n            }\n        }\n        std::cout << ansa.size() << \" \" << ansb.size() << \"\\n\";\n        for (auto i : ansa) {\n            std::cout << a[i] << \" \\n\"[i == ansa.back()];\n        }\n        for (auto i : ansb) {\n            std::cout << b[i] << \" \\n\"[i == ansb.back()];\n        }\n    } else {\n        std::cout << \"NO\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Equal LCM Subsets.json",
    "editorial_link": "https://codeforces.com//blog/entry/101211",
    "editorial": "First, we see how to check if the two entire sets have the same LCM\r\n(without subsets).To do this, for each element let us compute and check\r\nif it is . If it is greater than , that means has some prime power\r\ndividing it with exponent greater than any of the corresponding\r\nexponents in , and therefore the LCM cannot be equal. We perform the\r\nsame computations with the elements of (i.e., ). If all the results were\r\n, then the LCMs are equal. Complexity is , where .If , we can simply\r\ndelete from and solve recursively using the remaining sets (similarly if\r\n). We need to update the values and efficiently. We can do it using many\r\nsegment tree (one for each , and one for each ).The segment tree of , ,\r\nwill have the elements of as its leaves, and the node of , which will\r\ninclude a range of elements of will be , meaning that after removing an\r\nelement of , we will need to recompute all of the segment trees in time\r\neach (it is and not by a similar argument to the one used to compute the\r\ncomplexity of computing the gcd of an array of numbers) . Since we have\r\nto repeat this for steps, the total time complexity will be and the\r\nmemory complexity is .\r\n"
}