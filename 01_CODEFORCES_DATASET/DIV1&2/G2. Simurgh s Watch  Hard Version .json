{
    "link": "https://codeforces.com//contest/2034/problem/G2",
    "problemId": "3057443",
    "problem_idx": "G2",
    "shortId": "2034G2",
    "contest_number": "2034",
    "problem_submissions": {
        "G2": [
            294090902,
            294102835,
            294091710
        ],
        "H": [
            294074360,
            294061476,
            294070650,
            294080097,
            294083247,
            294085834,
            294087678,
            294090336,
            294084822,
            294087654,
            294090587,
            294104472,
            294104397,
            294104185,
            294103049,
            294058057,
            294072183,
            294081941,
            294086147,
            294091448
        ],
        "G1": [
            294068700,
            294089598,
            294090555,
            294512628,
            294279844,
            294078743,
            294092614,
            294083324,
            294137051,
            298736856
        ],
        "F2": [
            294044355,
            294048880,
            294057967,
            294058547,
            294044212,
            294052710,
            294062635,
            294059190,
            294064262,
            294068869,
            294068913,
            294056682,
            294087439,
            294054148,
            294055470,
            294067548,
            294048518,
            294098694,
            297729208
        ],
        "F1": [
            294044201,
            294045676,
            294057746,
            294058488,
            294044581,
            294052242,
            294063014,
            294059348,
            294064621,
            294068676,
            294069032,
            294056298,
            294079209,
            294055715,
            294050068,
            294055587,
            294059717,
            294048439,
            294065367,
            294063971
        ],
        "E": [
            294039732,
            294035256,
            294043120,
            294044445,
            294061596,
            294042263,
            294051208,
            294051638,
            294059206,
            294057047,
            294047623,
            294072917,
            294043657,
            294040686,
            294046402,
            294070560,
            294044216,
            294048932,
            294047270
        ],
        "D": [
            294029209,
            294029423,
            294031077,
            294032177,
            294053262,
            294029511,
            294040505,
            294041118,
            294048071,
            294036073,
            294034324,
            294064606,
            294034084,
            294023836,
            294028591,
            294031360,
            294038809,
            294039055
        ],
        "C": [
            294019511,
            294017117,
            294018450,
            294020877,
            294023563,
            294033582,
            294025662,
            294021753,
            294020563,
            294027112,
            294020897,
            294016537,
            294062723,
            294021341,
            294029864,
            294018381,
            294021917,
            294017733,
            294050791,
            294028560
        ],
        "B": [
            294013321,
            294006563,
            294009984,
            294010387,
            294010473,
            294013337,
            294026398,
            294010402,
            294011621,
            294010156,
            294007642,
            294050334,
            294011602,
            294008120,
            294012362,
            294012172,
            294084096,
            294006809,
            294008731
        ],
        "A": [
            294004839,
            294004703,
            294005425,
            294005031,
            294006081,
            294004631,
            294006317,
            294005105,
            294006032,
            294005086,
            294004777,
            294047604,
            294005991,
            294004926,
            294006968,
            294005489,
            294006094,
            294004648,
            294005025
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136579",
    "editorial": "Step 1: It is easy to check\nif the solution can be achieved with only one color. For any time point\n, there must be at most one interval containing , since if multiple\nintervals contain , they must be colored differently. Step 2: A simple\nstrategy is to solve the problem using three colors; First, we color\nsome intervals with colors 1 and 2, then color others with color 3. For\neach step, we find the leftmost point that has not been colored yet and\ncolor the segment that contains this point. We always choose the\ninterval with the largest endpoint that contains the current point. By\ncoloring the intervals alternately with colors 1 and 2, we ensure that\nall points are covered by exactly one of these colors. Step 3: Now, we\ncheck if we can color the intervals with just two colors. For some\npoint, , suppose we have already colored the intervals with , such that\nall points before have a unique color. At each step, we only need to\ndetermine which of the intervals like that can have a unique color. The\nkey observation is that if an interval can be uniquely colored at time ,\nit can also remain uniquely colored for all times such that . Lemma: If\nan interval can be uniquely colored at time , it can also be uniquely\ncolored at all subsequent times . Proof: Consider coloring the intervals\nat time . Intervals starting at will be colored with the opposite color\nto interval , ensuring that the interval remains uniquely colored at\ntime . With this lemma, we can conclude that the changes in the coloring\nare . It suffices to track the intervals that are added and removed at\neach point in time. Step 4: To efficiently move from time to , we\nperform the following steps: Remove the intervals that have (since they\nno longer contain ). Add the intervals that have . Update the set of\nintervals that can be uniquely colored at time . Step 5: Finally, we\nobserve that only the following points are important for the coloring:\nand for each interval. and , since these points mark the boundaries\nwhere intervals start or end. Thus, we can compress the numbers to\nreduce the range of values we need to process.\n",
    "name": "G2. Simurgh s Watch  Hard Version ",
    "statement": "The legendary Simurgh, a mythical bird, is responsible for keeping watch\r\nover vast lands, and for this purpose, she has enlisted n vigilant\r\nwarriors. Each warrior is alert during a specific time segment [l_i,\r\nr_i], where l_i is the start time (included) and r_i is the end time\r\n(included), both positive integers. One of Simurgh\u2019s trusted advisors,\r\nZal, is concerned that if multiple warriors are stationed at the same\r\ntime and all wear the same color, the distinction between them might be\r\nlost, causing confusion in the watch. To prevent this, whenever multiple\r\nwarriors are on guard at the same moment, there must be at least one\r\ncolor which is worn by exactly one warrior.So the task is to determine\r\nthe minimum number of colors required and assign a color c_i to each\r\nwarrior\u2019s segment [l_i, r_i] such that, for every (integer) time t\r\ncontained in at least one segment, there exists one color which belongs\r\nto exactly one segment containing t.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7;int n;struct inter {\tint l, r, id;\tinter() {\u00a0\t}} it[N];int l[N], r[N];int ans[N];int tak[N];int arr[N], atot;vi to[N], bak[N];int cov[N];int ncov[N];bool check_1() {\tL(i, 1, atot) ncov[i] = 0;\tL(i, 1, n) {\t\t++ncov[l[i]];\t\t--ncov[r[i] + 1];\t}\tL(i, 1, atot) ncov[i] += ncov[i - 1];\tL(i, 1, atot) if(ncov[i] > 1) return 0;\tcout << \"1\\n\";\tL(i, 1, n) cout << 1 << ' ';\tcout << '\\n';\treturn 1;}int p1[N], p2[N];\u00a0int dp[N], lst[N], mod[N], dif[N];ll s1[N], s2[N];vi gem[N];int col[N];\u00a0bool solve(int beg, int en) {\tvi all;\tL(i, beg, en) for(auto&j : to[i])all.pb(j);\tfor(auto u : all)\t\tif(l[u] == beg)\t\t\tdp[u] = 1, lst[u] = 0;\tL(i, beg, en - 1) {\t\tif(sz(gem[i]) == 2) {\t\t\tint x = gem[i][0];\t\t\tint y = gem[i][1];\t\t\tif(dp[y] && !dp[x]) swap(x, y);\t\t\tif(dp[x] && !dp[y]) {\t\t\t\tdp[y] = 1;\t\t\t\tlst[y] = x;\t\t\t\tmod[y] = i;\t\t\t\tdif[y] = 1;\t\t\t}\t\t}\t\tint pal = -1;\t\tfor(auto &u : bak[i]) {\t\t\tif(dp[u])pal = u;\t\t\tif(sz(gem[i]) == 1) {\t\t\t\tint v = gem[i][0];\t\t\t\tif(dp[u] && !dp[v]) {\t\t\t\t\tdp[v] = 1;\t\t\t\t\tlst[v] = u;\t\t\t\t\tmod[v] = i;\t\t\t\t\tdif[v] = 1;\t\t\t\t}\t\t\t}\t\t}\t\tif(pal != -1 && arr[i + 1] - arr[i] == 1) {\t\t\tfor(auto v : to[i + 1]) if(!dp[v]) {\t\t\t\tdp[v] = 1;\t\t\t\tlst[v] = pal;\t\t\t\tmod[v] = i;\t\t\t\tdif[v] = 0;\t\t\t}\t\t}\t\tfor(auto v : to[i + 1]) if(!dp[v]) {\t\t\tif(sz(gem[i]) == 1) {\t\t\t\tint u = gem[i][0];\t\t\t\tif(dp[u] && !dp[v]) {\t\t\t\t\tdp[v] = 1;\t\t\t\t\tlst[v] = u;\t\t\t\t\tmod[v] = i;\t\t\t\t\tdif[v] = 1;\t\t\t\t}\t\t\t}\t\t}\t}\tint good = -1;\tfor(auto u : all)\t\tif(r[u] == en && dp[u])\t\t\tgood = u;\tif(good == -1) return 0;\tvi qwq;\tfor(int p = good; p; p = lst[p]) {\t\tqwq.pb(p);\t}\treverse(qwq.begin(), qwq.end());\tvi ti = vi{beg};\tfor(auto u : qwq) if(lst[u]) {\t\tti.pb(mod[u] + 1);\t}\tti.pb(en + 1);\t// cout << \"SZ = \" << sz(ti) << endl;\tint cur = 0;\tL(i, 0, sz(qwq) - 1) {\t\tif(i)cur ^= dif[qwq[i]];\t\tans[qwq[i]] = cur + 1;\t\t// cout << qwq[i] << \" :: \" << ans[qwq[i]] << endl;\t\tL(j, ti[i], ti[i + 1] - 1) {\t\t\tcol[j] = ans[qwq[i]] ^ 3;\t\t}\t}\tfor(auto p : all) {\t\tif(!ans[p]) {\t\t\t// cout<<l[p]<<' '<<col[l[p]]<<endl;\t\t\tans[p] = col[l[p]];\t\t}\t}\treturn 1;}bool check_2() {\tL(i, 1, atot) s1[i] = s2[i] = 0;\tL(i, 1, n) {\t\ts1[l[i]] += i, s1[r[i]] -= i;\t\ts2[l[i]] += (ll)i * i, s2[r[i]] -= (ll)i * i;\t} \tL(i, 1, atot) s1[i] += s1[i - 1], s2[i] += s2[i - 1];\tL(i, 1, atot) {\t\tgem[i].clear();\t\tif(cov[i] <= 2) {\t\t\ts2[i] = (s1[i] * s1[i] - s2[i]) / 2;\t\t\t// cout << i << \" : \" << s1[i] << ' ' << s2[i] << endl;\t\t\tll dif = sqrt(s1[i] * s1[i] - 4 * s2[i]);\t\t\tassert((s1[i] - dif) % 2 == 0);\t\t\tassert(dif * dif == s1[i] * s1[i] - 4 * s2[i]);\t\t\tll x = (s1[i] + dif) / 2;\t\t\tll y = (s1[i] - dif) / 2;\t\t\tif(x)gem[i].pb(x);\t\t\tif(y)gem[i].pb(y);\t\t}\t}\tL(i, 1, n) dp[i] = 0, lst[i] = 0, ans[i] = 0;\tint can = 1;\tint cur_l = 1;\tL(i, 1, atot) {\t\tif(!cov[i]) {\t\t\tcan &= solve(cur_l, i);\t\t\tcur_l = i + 1;\t\t}\t}\tif(!can) return 0;\tL(i, 0, atot + 1) p1[i] = 0;\tL(o, 1, 2) {\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i] + 1] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p1[i] = 1;\u00a0\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i]] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p2[i] = 1;\t}\tL(i, 1, atot) if(!p1[i]) assert(false);\tL(i, 1, atot - 1) if(arr[i + 1] - arr[i] != 1 && !p2[i] && cov[i]) assert(false);\tcout << \"2\\n\";\tL(i, 1, n) cout << ans[i] << ' ';\tcout << '\\n';\treturn 1;}mt19937 rng;int rad(int l, int r) {\treturn rng() % (r - l + 1) + l;}void Main() {\t// n = 10;\t// L(i, 1, n) {\t// \tit[i].l = rng() % 10 + 1;\t// \tit[i].r = rng() % 10 + 1;\t// \tif(it[i].l > it[i].r) {\t// \t\tswap(it[i].l, it[i].r);\t// \t}\t// }\tcin >> n;\tL(i, 1, n) cin >> it[i].l >> it[i].r;\t\tatot = 0;\tL(i, 1, n) it[i].id = i;\tL(i, 1, n) arr[++atot] = it[i].l, arr[++atot] = it[i].r;\tsort(arr + 1, arr + atot + 1);\tatot = unique(arr + 1, arr + atot + 1) - arr - 1;\tL(i, 1, n) \t\tit[i].l = lower_bound(arr + 1, arr + atot + 1, it[i].l) - arr, \t\tit[i].r = lower_bound(arr + 1, arr + atot + 1, it[i].r) - arr;\tL(i, 0, atot + 1) cov[i] = 0, to[i].clear(), bak[i].clear();\tL(i, 1, n)\t\tl[i] = it[i].l, r[i] = it[i].r, to[l[i]].pb(i), bak[r[i]].pb(i);\tL(i, 1, n) cov[l[i]] += 1, cov[r[i]] -= 1;\tL(i, 1, atot) cov[i] += cov[i - 1];\tif(check_1()) {\t\treturn;\t}\tif(check_2()) {\t\treturn;\t}\tcout << \"3\\n\";\tvi vp;\tL(i, 1, atot) {\t\tsort(to[i].begin(), to[i].end(), [&] (int x, int y) {\t\t\treturn r[x] > r[y];\t\t});\t\tfor(auto j : to[i]) {\t\t\tif(!sz(vp) || r[j] > r[vp.back()]) {\t\t\t\twhile(sz(vp) > 1 && r[vp[sz(vp) - 2]] >= l[j]) {\t\t\t\t\tvp.pop_back();\t\t\t\t}\t\t\t\tvp.pb(j);\t\t\t}\t\t}\t}\t// cout<<\"SZ=\"<<sz(vp)<<endl;\tL(i, 1, n) ans[i] = 3;\tL(i, 0, sz(vp) - 1) {\t\tans[vp[i]] = 1 + (i & 1);\t}\tL(i, 1, n) cout << ans[i] << ' ';\tcout << '\\n';\tL(o, 1, 3) {\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i] + 1] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p1[i] = 1;\t}\t// for(auto u : vp) {\t// \tcout << l[u] << ' ' << r[u] << endl;\t// }\tL(i, 1, atot) if(!p1[i]) assert(false);}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G2. Simurgh s Watch  Hard Version .json"
}