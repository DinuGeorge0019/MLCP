{
    "link": "https://codeforces.com//contest/1654/problem/B",
    "problemId": "1336999",
    "problem_idx": "B",
    "shortId": "1654B",
    "contest_number": "1654",
    "problem_submissions": {
        "G": [
            150299206,
            150291434,
            150262682,
            150264693,
            150279932,
            150262802,
            150264575,
            150265515,
            150270995,
            150269889,
            150268570,
            150658744,
            150262050,
            150410744
        ],
        "F": [
            150251411,
            150252834,
            150256351,
            150258591,
            150257352,
            150258765,
            150260950,
            150260548,
            150253390,
            155820292,
            150253676,
            150260302,
            150259236,
            150258476,
            150253068,
            150258272,
            150260151,
            150258857,
            150253870
        ],
        "E": [
            150249388,
            150250832,
            150247329,
            150252856,
            150255337,
            150250196,
            150255012,
            150258473,
            150245581,
            150250984,
            150250253,
            150246690,
            150250591,
            150243463,
            150281667,
            150281018,
            150257789,
            150252457,
            150252381,
            150254404,
            150260615
        ],
        "D": [
            150242905,
            150248369,
            150245387,
            150248435,
            150250315,
            150245874,
            150249516,
            150253299,
            150250969,
            150245477,
            150245136,
            150243688,
            150246539,
            150254801,
            150249615,
            150245204,
            150245282,
            150246887,
            150243365
        ],
        "C": [
            150236387,
            150236280,
            150236050,
            150237265,
            150241937,
            150237951,
            150242839,
            150238439,
            150239664,
            150239447,
            150236298,
            150237311,
            150240477,
            150246874,
            150236567,
            150236644,
            150238032,
            150240021,
            150238619
        ],
        "B": [
            150233906,
            150232250,
            150249236,
            150233827,
            150235226,
            150232832,
            150239572,
            150233210,
            150235633,
            150231291,
            150231026,
            150232476,
            150233263,
            150235368,
            150231705,
            150232694,
            150231566,
            150233122,
            150232190
        ],
        "A": [
            150228234,
            150228426,
            150228045,
            150228869,
            150232031,
            150228616,
            150230908,
            150228192,
            150232849,
            150228032,
            150227955,
            150228792,
            150228208,
            150229654,
            223450681,
            150228295,
            150228644,
            150228162,
            150228813,
            150228169
        ],
        "H": [
            150278254,
            150276173,
            150276315,
            150560549
        ]
    },
    "name": "B. Prefix Removals",
    "statement": "You are given a string s consisting of lowercase letters of the English\r\nalphabet. You must perform the following algorithm on s: Let x be the\r\nlength of the longest prefix of s which occurs somewhere else in s as a\r\ncontiguous substring (the other occurrence may also intersect the\r\nprefix). If x = 0, break. Otherwise, remove the first x characters of s,\r\nand repeat. A prefix is a string consisting of several first letters of\r\na given string, without any reorders. An empty prefix is also a valid\r\nprefix. For example, the string \"\" has 5 prefixes: empty string, \"\", \"\",\r\n\"\" and \"\".For instance, if we perform the algorithm on s = \"\",\r\nInitially, \"\" is the longest prefix that also appears somewhere else as\r\na substring in s, so s = \"\" after 1 operation. Then, \"\" is the longest\r\nprefix that also appears somewhere else as a substring in s, so s = \"\"\r\nafter 2 operations. Now x=0 (because there are no non-empty prefixes of\r\n\"\" that also appear somewhere else as a substring in s), so the\r\nalgorithm terminates. Find the final state of the string after\r\nperforming the algorithm.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tvector<int> last(26, (int)s.length());\n\tfor (int i = 0; i < (int)s.length(); ++i) {\n\t\tint c = s[i] - 'a';\n\t\tlast[c] = i;\n\t}\n\ts = s.substr(*min_element(all(last)));\n\tcout << s << \"\\n\";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Prefix Removals.json",
    "editorial_link": "https://codeforces.com//blog/entry/100127",
    "editorial": "SolutionLet be the initial string. For a string , letâs define , i.e.,\r\nthe substring of from to . The final string is for some .In the final\r\nstring, , so the first character doesnât appear anywhere else in . This\r\nmeans that . In other words, is the rightmost occurrence of a letter in\r\n.Can you ever remove , if ? Notice that you would need to remove ():\r\nthis means that there must exist for some . So, , and this is a\r\ncontradiction.Therefore, is the smallest index such that .You can find\r\nby iterating over the string from right to left and updating the\r\nfrequency of each letter. Indeed if and only if the frequency of the\r\nletter is up to now (in the iteration from right to left we are\r\nperforming). The value of is the minimum such index .Complexity:\r\n",
    "hint": [
        "Hint 1 Are there any characters that you can never remove?",
        "Hint 2 You can't remove the rightmost occurrence of each letter. Can you remove the other characters?",
        "Hint 3 If you can remove and is not the rightmost occurrence of a letter, you can also remove ."
    ]
}