{
    "link": "https://codeforces.com//contest/1556/problem/F",
    "problemId": "1093327",
    "problem_idx": "F",
    "shortId": "1556F",
    "contest_number": "1556",
    "problem_submissions": {
        "H": [
            127528421,
            127373567,
            127527040,
            127375388,
            127394013,
            127386870,
            127381921,
            127387937,
            127394050,
            127389040,
            127428317,
            127427887,
            127554513,
            127394843,
            127394720,
            127394710,
            127394566,
            127388015,
            127563493,
            127391319,
            127413892,
            127413850,
            127391995,
            190714866,
            127387774
        ],
        "G": [
            127390700,
            127387983,
            127394350,
            127373122,
            127379900,
            127386180,
            127417272,
            127382224,
            127382638,
            127388751,
            127407653,
            127407647,
            127407608,
            127407584,
            127407566,
            127386088,
            127384803,
            127387460,
            127387640
        ],
        "F": [
            127355517,
            127358676,
            127354501,
            127360575,
            127359102,
            127358993,
            127363463,
            127363603,
            127365708,
            127364449,
            127360085,
            127362064,
            127372929,
            127362249,
            127375013,
            127359868,
            127372641,
            127367693,
            127374334,
            127375402
        ],
        "E": [
            127351296,
            127352912,
            127351562,
            127356521,
            127354559,
            127354907,
            127360891,
            127356050,
            127360001,
            127359317,
            127356239,
            127358250,
            127364802,
            127356923,
            127358834,
            127355363,
            127366513,
            127364481,
            127365791,
            127370671
        ],
        "D": [
            127346830,
            127349657,
            127348248,
            127352056,
            127350226,
            127351918,
            127354957,
            127351335,
            127356577,
            127354677,
            127353022,
            127352794,
            127358047,
            127352764,
            127356062,
            127349435,
            127357493,
            127359353,
            127355308,
            127356263
        ],
        "C": [
            127342221,
            127343475,
            127345171,
            127346052,
            127344444,
            127347970,
            127343862,
            127341055,
            127350101,
            127347701,
            127344590,
            127346041,
            127349062,
            127346563,
            127349912,
            127346975,
            127349244,
            127343756,
            127348599,
            127364090
        ],
        "A": [
            127338005,
            127334498,
            127334512,
            127336074,
            127334497,
            127335667,
            127334534,
            127334495,
            127334713,
            127336416,
            127334993,
            127336217,
            127334858,
            127334721,
            127334712,
            127334514,
            127335446,
            127334480,
            127334660,
            127334680
        ],
        "B": [
            127336233,
            127336922,
            127337115,
            127340977,
            127338217,
            127339999,
            127337368,
            127336161,
            127338774,
            127342382,
            127338043,
            127341949,
            127339720,
            127340565,
            127339178,
            127338941,
            127341395,
            127336543,
            127339094,
            127344978
        ]
    },
    "name": "F. Sports Betting",
    "statement": "William is not only interested in trading but also in betting on sports\r\nmatches. n teams participate in each match. Each team is characterized\r\nby strength a_i. Each two teams i < j play with each other exactly once.\r\nTeam i wins with probability\r\nfrac{a_i}{a_i + a_j} and team j wins with probability\r\nfrac{a_j}{a_i + a_j}.The team is called a winner if it directly or\r\nindirectly defeated all other teams. Team a defeated (directly or\r\nindirectly) team b if there is a sequence of teams c_1, c_2, ... c_k\r\nsuch that c_1 = a, c_k = b and team c_i defeated team c_{i + 1} for all\r\ni from 1 to k - 1. Note that it is possible that team a defeated team b\r\nand in the same time team b defeated team a.William wants you to find\r\nthe expected value of the number of winners.\r\n",
    "solutions": [
        "//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 1000000007\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 14;\nint d[maxn][maxn];\nint a[maxn];\nint f[1 << maxn];\nint to[1 << maxn][maxn];\nint n;\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            d[i][j] = 1ll * a[i] * ksm((a[i] + a[j]) % mod, mod - 2) % mod;\n    for (int i = 0; i < (1 << n); i++)\n        for (int j = 0; j < n; j++) {\n            to[i][j] = 1;\n            for (int k = 0; k < n; k++)\n                if (i & (1 << k))\n                    to[i][j] = 1ll * to[i][j] * d[j][k] % mod;\n        }\n    ll ans = 0;\n    for (int i = 0; i < n; i++) {\n        memset(f, 0, sizeof(f));\n        f[1 << i] = 1;\n        for (int j = 0; j < (1 << n); j++) {\n            if (!(j & (1 << i))) continue;\n            if (j == (1 << i)) continue;\n            f[j] = 1;\n            for (int u = j; u; u = (u - 1) & j) {\n                if (!(u & (1 << i))) continue;\n                if (u == j) continue;\n                ll cur = f[u];\n                for (int s = 0; s < n; s++) {\n                    if ((u ^ j) & (1 << s))\n                        cur = cur * to[u][s] % mod;\n                }\n                f[j] = (f[j] - cur) % mod;\n            }\n        }\n        ans += f[(1 << n) - 1];\n        ans %= mod;\n    }\n    if (ans < 0) ans += mod;\n    cout << ans << endl;\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "graphs",
        "math",
        "probabilities"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Sports Betting.json",
    "editorial_link": "https://codeforces.com//blog/entry/94384",
    "editorial": "Let be all teams, and be the probability that a set of teams are\r\nwinners, and the rest of teams are not.Then the answer will be the\r\nfollowing value:Let\u00e2\u0080\u0099s define extra value: the probability that all teams\r\nfrom the set are reachable from each other, that is, they form a\r\ncycle.Then is calculated as follows: .This is explained as follows: the\r\nprobability that the set will be the set of winners is equal to the\r\nprobability that the set forms a cycle and there is no edge from the set\r\nto .Where denotes the probability that all teams from the set defeat all\r\nteams from the set directly. More formally speaking, the probability\r\nthat for every in , and for every in , there is an edge from to .It\r\nremains to learn how to count .It is easy to see that this can be done\r\nusing the inclusion-exclusion principle:The formula is explained as\r\nfollows: we need to know the probability that all teams from the set are\r\nreachable to each other, initially we set this probability equal to ,\r\nthen subtract all options when only some subset of the set is reachable\r\nto itself. is calculated as follows: Writing these formulas into the\r\ncode in the simplest way, you can get a solution with asymptotics .\r\nSince here pairs exist, where is the set of winners and is its subset in\r\nthe inclusion-exclusion formula. Also, for each such pair, you will have\r\nto calculate the value of in .But it is possible to calculate faster.For\r\nexample, you can notice that , where is the probability that the command\r\ndefeated all teams from the set directly. can be pre-calculated in\r\nadvance for , which will allow us to calculate in instead of .In a\r\nsimilar way, you can learn how to calculate in , if you pre-calculate\r\nthe following four values: , , , .Where is an arbitrary division of\r\nteams into two equal (or almost equal) sets, so that is satisfied.Where\r\n, only for subsets such that .As a result:Each of can be pre-calculated\r\nin .Final asymptotics .\r\n"
}