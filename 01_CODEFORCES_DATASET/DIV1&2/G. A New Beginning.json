{
    "link": "https://codeforces.com//contest/1534/problem/G",
    "problemId": "1015236",
    "problem_idx": "G",
    "shortId": "1534G",
    "contest_number": "1534",
    "problem_submissions": {
        "H": [
            119381214,
            119371780,
            119388875,
            119396687,
            119388441,
            119735727,
            119401011,
            156903357,
            119399410
        ],
        "G": [
            119363923,
            119381755,
            119379035,
            119379747,
            119375709,
            119378954,
            119381639,
            119386175,
            119382951,
            119385742,
            119388314,
            119371330,
            120158205,
            119404077,
            119378000,
            119386837,
            119386916,
            119395182,
            119389738,
            119408279,
            119408209,
            119408093
        ],
        "F2": [
            119359019,
            119387021,
            119400446,
            119368476,
            119369247,
            119507067,
            119404750,
            119370022,
            119374004,
            119374154,
            119376176,
            119372366,
            119378246,
            119399836,
            119402771,
            119402687,
            119397406,
            119363483,
            119371811,
            119375364
        ],
        "F1": [
            119354959,
            119349642,
            119359129,
            119361761,
            119507346,
            119371842,
            119361335,
            119365559,
            119364097,
            119370075,
            119372716,
            119373779,
            119373986,
            119373292,
            119365686,
            119365605,
            119370635,
            119378959,
            119363180,
            119357763,
            119355433
        ],
        "E": [
            119348058,
            119345554,
            119352930,
            119351617,
            119349306,
            119353802,
            119353388,
            119357278,
            119361448,
            119356611,
            119347260,
            119354563,
            119406882,
            119406872,
            119406814,
            119366978,
            119358316,
            119361081,
            119365117,
            119367416,
            119352636,
            119352851,
            119349844
        ],
        "D": [
            119342350,
            119341721,
            119344490,
            119344598,
            119352385,
            119347199,
            119345707,
            119344090,
            119352267,
            119362889,
            119351680,
            119347922,
            119347628,
            119350545,
            119353880,
            119345904,
            119350322,
            119344632,
            119344948,
            119343924
        ],
        "C": [
            119339545,
            119339824,
            119341150,
            119341051,
            119342258,
            119342361,
            119342280,
            119341468,
            119346665,
            119340382,
            119340132,
            119340253,
            119340431,
            119342595,
            119342664,
            119342788,
            119344299,
            119340875,
            119340120,
            119340815
        ],
        "B": [
            119338881,
            119339003,
            119339770,
            119339655,
            119340047,
            119340398,
            119340981,
            119340203,
            119342335,
            119339310,
            119338676,
            119339188,
            119339149,
            119339395,
            119344148,
            119340653,
            119341897,
            119339460,
            119339065,
            119339496
        ],
        "A": [
            119338623,
            119338599,
            119338780,
            119338750,
            119338699,
            119338727,
            119339260,
            119338754,
            119339237,
            119338711,
            119339353,
            119338692,
            119338629,
            119345132,
            119342442,
            119338896,
            119339494,
            119338744,
            119338632,
            119338713
        ]
    },
    "name": "G. A New Beginning",
    "statement": "Annie has gotten bored of winning every coding contest and farming\r\nunlimited rating. Today, she is going to farm potatoes instead.Annie\u2019s\r\ngarden is an infinite 2D plane. She has n potatoes to plant, and the\r\ni-th potato must be planted at (x_i,y_i). Starting at the point (0, 0),\r\nAnnie begins walking, in one step she can travel one unit or (increasing\r\nher x or y coordinate by 1 respectively). At any point (X,Y) during her\r\nwalk she can plant some potatoes at arbitrary points using her potato\r\ngun, consuming\r\nmax(|X-x|,|Y-y|) units of energy in order to plant a potato at (x,y).\r\nFind the minimum total energy required to plant every potato.Note that\r\nAnnie may plant any number of potatoes from any point.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\nint N;\nvpl pot;\nll init_slope;\nll init_ans;\npriority_queue<ll> slope_left;\npriority_queue<ll,vl,greater<ll>> slope_right;\n\n\nint main() {\n\tsetIO(); re(N);\n\tpot.rsz(N); re(pot);\n\teach(t,pot) t = mp(t.f+t.s,t.f);\n\tsort(all(pot));\n\t// int last_add = 0;\n\teach(t,pot) {\n\t\t// last_add = t.f;\n\t\t--init_slope;\n\t\tinit_ans += t.s;\n\t\t// dbg(\"DOING\",t);\n\t\tif (sz(slope_left) && t.s < slope_left.top()) {\n\t\t\tslope_left.push(t.s);\n\t\t\tslope_left.push(t.s);\n\t\t} else {\n\t\t\tslope_right.push(t.s-t.f);\n\t\t\tslope_right.push(t.s-t.f);\n\n\t\t}\n\t\t// else {\n\t\t// \tslope_right.push(t.s-t.f);\n\t\t// \tslope_right.push(t.s-t.f);\n\t\t// }\n\t\twhile (sz(slope_left) > sz(slope_right)) {\n\t\t\tslope_right.push(slope_left.top()-t.f);\n\t\t\tslope_left.pop();\n\t\t}\n\t\twhile (sz(slope_left) < sz(slope_right)) {\n\t\t\tslope_left.push(slope_right.top()+t.f);\n\t\t\tslope_right.pop();\n\t\t}\n\t}\n\tdbg(\"HA\",init_ans);\n\t// ll ans = init_ans+init_slope*;\n\t// each(t,slope_left) {\n\n\t// }\n\twhile (sz(slope_left)) {\n\t\tdbg(\"TOP\",slope_left.top());\n\t\tinit_ans -= slope_left.top();\n\t\tslope_left.pop();\n\t}\n\tps(init_ans);\n\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "geometry",
        "sortings"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. A New Beginning.json",
    "editorial_link": "https://codeforces.com//blog/entry/91760",
    "editorial": "Observe that for any point and some path , the minimum distance from to\r\nwill occur on the intersection of and the antidiagonal of . Here the\r\nantidiagonal is defined as a line . Proof:Assume is the intersection of\r\nand the antidiagonal of . If , this distance is obviously minimal as it\r\nis equal to 0. Now consider the case where . As a result of being on the\r\nantidiagonal, two properties will be true: . Either and or and . Without\r\nloss of generality, assume and . When you move forward on the path,\r\nincreasing will only make larger. Thus, no matter how you change , will\r\nalways increase or stay the same. When you move backward on the path,\r\ndecreasing will only make larger. Thus, no matter how you change , will\r\nalways increase or stay the same. Thus, the shortest distance will\r\nalways occur at .Now we rotate the grid degrees clockwise so that the\r\nantidiagonals are now vertical lines on the new grid. Your movements on\r\nthe grid now go from to or . Furthermore, it is now optimal to plant a\r\npotato when you are on the same x coordinate as the potato. When you are\r\nat , planting a potato at costs . From here we can observe a slow dp.\r\nDefine as the minimum cost of any path that goes from to and plant all\r\npotatoes such that . Note: this function is only defined for when and\r\nhave the same parity. This is as a point in the old grid translates to\r\nin the new grid and has the same parity as . For speed, we also only\r\ncalculate when there is a potato with a x-coordinate of .The transition\r\nis then established as , where is the last x-coordinate containing a\r\npotato.This runs in .This dp can then be optimized using slope trick. If\r\nyou are not familiar with slope trick, we recommend learning it first at\r\nSlope trick explained and [Tutorial] Slope Trick. Instead of maintaining\r\na dimensional array, we can maintain functions where . To transition\r\nfrom to , we first set . This can be done by maintaining the\r\ncenter/minimum of the slope trick function and then offsetting all\r\nvalues in the left priority queue by and offsetting all values in the\r\nright priority queue by . Finally, we have to add the costs of the\r\npotatoes. Each of the potatoes is just a function such that . These\r\nfunctions can then be added onto finishing the conversion to . The final\r\nanswer is then the minimum of the last function.Final Complexity: .\r\n"
}