{
    "link": "https://codeforces.com//contest/1220/problem/F",
    "problemId": "415037",
    "problem_idx": "F",
    "shortId": "1220F",
    "contest_number": "1220",
    "problem_submissions": {
        "F": [
            60794655,
            60795420,
            60798012,
            60796211,
            60799458,
            60799042,
            60800694,
            60802837,
            60802344,
            60801389,
            60840886,
            60840780,
            60840626,
            60840499,
            60816071,
            60802432,
            60804302,
            60803333,
            60805888,
            60807155,
            60806082,
            60806528,
            60805639,
            60807120,
            60805696
        ],
        "E": [
            60790215,
            60792421,
            60792651,
            60792239,
            60793143,
            60792840,
            60795721,
            60794580,
            60796658,
            60794976,
            60796781,
            60798760,
            60797350,
            60797489,
            60796246,
            60798051,
            60800665,
            60797651,
            60800039,
            60800893
        ],
        "D": [
            60786802,
            60786831,
            60788316,
            60786890,
            60789386,
            60786761,
            60791950,
            60790977,
            60790845,
            60791802,
            60790799,
            60791826,
            60794564,
            60792553,
            60792010,
            60792977,
            60788272,
            60792327,
            60792666,
            60788893
        ],
        "C": [
            60784461,
            60784654,
            60786011,
            60784793,
            60786790,
            60784487,
            60788242,
            60786432,
            60786611,
            60789040,
            60786867,
            60788037,
            60788357,
            60788969,
            60787866,
            60789945,
            60786608,
            60789677,
            60787852,
            60786166
        ],
        "B": [
            60781859,
            60783053,
            60783409,
            60782430,
            60783345,
            60782386,
            60782468,
            60784465,
            60785209,
            60786375,
            60784225,
            60785909,
            60785762,
            60785740,
            60785272,
            60786460,
            60783349,
            60784859,
            60785464,
            60782087
        ],
        "A": [
            60780482,
            60780507,
            60780481,
            60782646,
            62687701,
            60784803,
            60780490,
            60784397,
            60781094,
            60781294,
            60786801,
            60780787,
            60780645,
            60785632,
            60782015,
            60781702,
            60780484,
            60780455,
            60781879,
            60780860,
            60783535
        ],
        "G": [
            76800366
        ]
    },
    "name": "F. Gardener Alex",
    "statement": "Gardener Alex loves to grow trees. We remind that tree is a connected\r\nacyclic graph on n vertices. Today he decided to grow a rooted binary\r\ntree. A binary tree is a tree where any vertex has no more than two\r\nsons. Luckily, Alex has a permutation of numbers from 1 to n which he\r\nwas presented at his last birthday, so he decided to grow a tree\r\naccording to this permutation. To do so he does the following process:\r\nhe finds a minimum element and makes it a root of the tree. After that\r\npermutation is divided into two parts: everything that is to the left of\r\nthe minimum element, and everything that is to the right. The minimum\r\nelement on the left part becomes the left son of the root, and the\r\nminimum element on the right part becomes the right son of the root.\r\nAfter that, this process is repeated recursively on both parts.Now Alex\r\nwants to grow a forest of trees: one tree for each cyclic shift of the\r\npermutation. He is interested in what cyclic shift gives the tree of\r\nminimum depth. Unfortunately, growing a forest is a hard and long\r\nprocess, but Alex wants the answer right now. Will you help him?We\r\nremind that cyclic shift of permutation a_1, a_2,\r\nldots, a_k,\r\nldots, a_n for k elements to the left is the permutation a_{k + 1},\r\na_{k + 2},\r\nldots, a_n, a_1, a_2,\r\nldots, a_k.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nstruct SegTree {\n\tstruct Node {\n\t\tint max_val;\n\t\tint push;\n\t\tNode() : max_val(0), push(0) {}\n\t};\n\t\n\tvector<Node> nodes;\n\tint base;\n\t\n\tSegTree(int n) : base(1) {\n\t\twhile (base < n + 5) { base *= 2; }\n\t\tnodes.resize(base * 2);\n\t}\n\t\n\tvoid Touch(int v) {\n\t\tif (v >= base) { return; }\n\t\tfor (int s : {v * 2, v * 2 + 1}) {\n\t\t\tnodes[s].max_val += nodes[v].push;\n\t\t\tnodes[s].push += nodes[v].push;\n\t\t}\n\t\tnodes[v].push = 0;\n\t}\n\t\n\tvoid AddIntvRec(int lv, int rv, int val, int lbase, int rbase, int v) {\n\t\tif (lbase >= rv || rbase <= lv) { return; }\n\t\tif (lv <= lbase && rbase <= rv) {\n\t\t\tnodes[v].max_val += val;\n\t\t\tnodes[v].push += val;\n\t\t\treturn;\n\t\t}\n\t\tTouch(v);\n\t\t\n\t\tconst int mid = (lbase + rbase) / 2;\n\t\tAddIntvRec(lv, rv, val, lbase, mid, v * 2);\n\t\tAddIntvRec(lv, rv, val, mid, rbase, v * 2 + 1);\n\t\tnodes[v].max_val = max(nodes[v*2].max_val, nodes[v*2+1].max_val);\n\t}\n\t\n\tvoid AddIntv(int lv, int rv, int val) {\n\t\tAddIntvRec(lv, rv, val, 0, base, 1);\n\t}\n\t\n\tint GetMax() const {\n\t\treturn nodes[1].max_val;\n\t}\n};\n\nconst int kMaxN = 5e5;\n\nint n;\nint perm[kMaxN];\nvi children[kMaxN];\nint pre[kMaxN], post[kMaxN], curtm;\n\nvoid Dfs(int v) {\n\tdebug() << imie(v) << imie(children[v]);\n\tpre[v] = curtm++;\n\tfor (int s : children[v]) {\n\t\tDfs(s);\n\t}\n\tpost[v] = curtm;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tcin >> n;\n\tvi order(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> perm[i];\n\t\torder[perm[i] - 1] = i;\n\t\tperm[i] *= 2;\n\t\tperm[i + n] = perm[i] + 1;\n\t}\n\t\n\tset<int> added{-1, 2 * n + 10};\n\t\n\tfor (int lbase : order) {\n\t\tfor (int loc : {lbase, lbase + n}) {\n\t\t\tauto piter = added.lower_bound(loc);\n\t\t\tauto iter = prev(piter);\n\t\t\t\n\t\t\tdebug() << imie(*iter) << imie(*piter);\n\t\t\t\n\t\t\tif (*piter < 0 && *iter > 2 * n) {\n\t\t\t\t\n\t\t\t} else if (*iter < 0) {\n\t\t\t\tchildren[*piter].push_back(loc);\n\t\t\t} else if (*piter > 2 * n) {\n\t\t\t\tchildren[*iter].push_back(loc);\n\t\t\t} else if (perm[*iter] > perm[*piter]) {\n\t\t\t\tchildren[*iter].push_back(loc);\n\t\t\t} else {\n\t\t\t\tchildren[*piter].push_back(loc);\n\t\t\t}\n\t\t\t\n\t\t\tadded.insert(loc);\n\t\t}\n\t}\n\t\n\tDfs(order[0]);\n\t\n\tSegTree tree(2 * n + 5);\n\tfor (int i = 0; i < n; ++i) {\n\t\ttree.AddIntv(pre[i], post[i], 1);\n\t}\n\t\n\tpii best = {tree.GetMax(), 0};\n\t\n\tfor (int shift = 1; shift < n; ++shift) {\n\t\ttree.AddIntv(pre[shift-1], post[shift-1], -1);\n\t\ttree.AddIntv(pre[shift+n-1], post[shift+n-1], 1);\n\t\tbest = min(best, pii{tree.GetMax(), shift});\n\t}\n\t\n\tcout << best.st << \" \" << best.nd << \"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Gardener Alex.json",
    "editorial_link": "https://codeforces.com//blog/entry/69899",
    "editorial": "Notice that element is an ancestor of an element when it\u00e2\u0080\u0099s minimum on a\r\nsubsegment from to . Count amount of ancestors for every element in\r\ninitial permutation. Now, when you remove element from the left, all\r\nelements between it and the leftmost element smaller than now have one\r\nancestor less. When you move it to the right, all elements between it\r\nand the rightmost element smaller than it have one ancestor more. And\r\nnew amount of ancestors for element moved to the right is one more than\r\namount of ancestors of the rightmost element smaller than it. You can\r\nstore amounts of ancestors in a segment tree with lazy propagation if\r\nyou concatenate given permutation with itself.\r\n"
}