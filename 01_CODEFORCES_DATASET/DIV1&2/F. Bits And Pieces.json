{"link": "https://codeforces.com//contest/1208/problem/F", "problemId": "395881", "problem_idx": "F", "shortId": "1208F", "contest_number": "1208", "problem_submissions": {"H": [59484058, 59502734, 76052313], "G": [59465495, 59473655, 59462360, 59469582, 59476496, 59467194, 59474332, 59471219, 59476758, 59478641, 59474463, 59471571, 59487164, 59486904, 59486576, 59482130, 59477683, 59476449, 59473994, 59479017, 59477708, 59480546], "F": [59463879, 59465198, 59467560, 59476238, 59468730, 59478991, 59464681, 59477905, 59488265, 59473195, 59472737, 59472853, 59477583, 59487223, 59467058, 59472365, 59474724, 59482091, 59473763, 59474219, 59475026], "E": [59458500, 59460001, 59471123, 59460976, 59465221, 59464240, 59471956, 59467792, 59468080, 59468210, 59467089, 59468111, 59463881, 59468884, 59466520, 59466354, 59469354, 59470023, 59470503], "C": [59454101, 59453008, 59450929, 59452783, 59454696, 59455218, 59454973, 59451236, 59458825, 59456015, 59453250, 59456008, 59453716, 59453732, 59453888, 59456639, 59456258, 59457694, 59458473], "D": [59453338, 59455109, 59457439, 59466058, 59460513, 59457371, 59457830, 59458661, 59462381, 59461784, 59460829, 59462458, 59456674, 59462814, 59457263, 59459344, 59458893, 59462907, 59461567], "B": [59451380, 59451457, 59455342, 59451327, 59452833, 59452235, 59452686, 59455049, 59452214, 59453318, 59450989, 59453232, 59451916, 59457683, 59451681, 59453837, 59452400, 59452282, 59455051], "A": [59449116, 59449294, 59449254, 59449364, 59450306, 59449785, 59449160, 59452256, 59449743, 59449309, 59449227, 59449840, 59449173, 59458690, 59449209, 59449159, 59450221, 59449398, 59450162]}, "name": "F. Bits And Pieces", "statement": "You are given an array a of n integers.You need to find the maximum\r\nvalue of a_{i} | ( a_{j}\r\n& a_{k} ) over all triplets (i,j,k) such that i < j < k.Here\r\n& denotes the bitwise AND operation, and | denotes the bitwise OR\r\noperation.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 25.08.2019 18:01:53       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int BITS = 21;\nconst int MAX = (1 << BITS);\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<pair<int, int>> bests(MAX, make_pair(-1, -1));\n  auto Update = [&](pair<int, int>& p, int v) {\n    if (v > p.first) {\n      p.second = p.first;\n      p.first = v;\n    } else {\n      p.second = max(p.second, v);\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    Update(bests[a[i]], i);\n  }\n  for (int j = 0; j < BITS; j++) {\n    for (int i = 0; i < MAX; i++) {\n      if (i & (1 << j)) {\n        Update(bests[i ^ (1 << j)], bests[i].first);\n        Update(bests[i ^ (1 << j)], bests[i].second);\n      }\n    }\n  }\n  auto Can = [&](int num, int high) {\n    for (int i = 0; i < n; i++) {\n      int x = (a[i] ^ num) & high;\n      if (bests[x].second > i) {\n        return true;\n      }\n    }\n    return false;\n  };\n  int ans = 0;\n  int high = 0;\n  for (int j = BITS - 1; j >= 0; j--) {\n    high += (1 << j);\n    if (Can(ans + (1 << j), high)) {\n      ans += (1 << j);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar", "dp", "greedy"], "dificulty": "2600", "interactive": false}