{
    "link": "https://codeforces.com//contest/1028/problem/G",
    "problemId": "212305",
    "problem_idx": "G",
    "shortId": "1028G",
    "contest_number": "1028",
    "problem_submissions": {
        "F": [
            42179553,
            42173574,
            42172126,
            42183823,
            42179375,
            42177929,
            42176646,
            42176739,
            42168545,
            42174904,
            42175563,
            42187810,
            42177441,
            42180538,
            42178358,
            42178178
        ],
        "H": [
            42177022,
            42177937,
            42197383,
            42174346,
            42178267,
            42180853,
            42180364,
            42179125,
            42178613,
            42177685,
            42188074
        ],
        "G": [
            42174235,
            42180921,
            42179342,
            42179278,
            42183838,
            42181415,
            42188299,
            42175088,
            42183699,
            42177809,
            42199769,
            42180709
        ],
        "E": [
            42168417,
            42169350,
            42169465,
            42168142,
            42175311,
            42172346,
            42172643,
            42173588,
            42169997,
            42170922,
            42170783,
            42169728,
            42172341,
            42172392,
            42174203,
            42173993,
            42169247
        ],
        "D": [
            42165714,
            42166524,
            42166821,
            42171266,
            42167648,
            42168290,
            42168039,
            42170991,
            42171075,
            42166522,
            42165185,
            42167753,
            42167327,
            42166990,
            42167859,
            42166718,
            42169672,
            42169316,
            42172369
        ],
        "C": [
            42162420,
            42161280,
            42164158,
            42159623,
            42162254,
            42163150,
            42163507,
            42162131,
            42163347,
            42161576,
            42161023,
            42164637,
            42163616,
            42161801,
            42163884,
            42163193,
            42164354,
            42165199,
            42162360
        ],
        "B": [
            42159958,
            42159146,
            42159962,
            42160148,
            42160038,
            42161126,
            42160845,
            42163792,
            42159144,
            42162163,
            42159196,
            42160477,
            42160541,
            42159094,
            42160870,
            42160007,
            42160216,
            42160794,
            42159231
        ],
        "A": [
            42158947,
            42158816,
            42158953,
            42161141,
            42158802,
            42159721,
            42159618,
            42163119,
            42158831,
            42163007,
            42158820,
            42158811,
            42158901,
            42158777,
            42159186,
            42158929,
            42158806,
            42159328,
            42158825
        ]
    },
    "name": "G. Guess the number",
    "statement": "This problem is interactive.You should guess hidden number x which is\r\nbetween 1 and M = 10004205361450474, inclusive.You could use up to 5\r\nqueries.In each query, you can output an increasing sequence of k\r\nleq x integers, each between 1 and M, inclusive, and you will obtain one\r\nof the following as an answer: either the hidden number belongs to your\r\nquery sequence, in this case you immediately win; or you will be given\r\nwhere the hidden number is located with respect to your query sequence,\r\nthat is, either it is less than all numbers from the sequence, greater\r\nthan all numbers from the sequence, or you will be given such an i that\r\nthe hidden number x is between the i-th and the (i+1)-st numbers of your\r\nsequence. See the interaction section for clarity.Be aware that the\r\ninteractor is , i.e. the hidden number can depend on queries the\r\nsolution makes. However, it is guaranteed that for any solution the\r\ninteractor works non-distinguishable from the situation when the hidden\r\nnumber is fixed beforehand.Hacks are allowed only with fixed hidden\r\nnumber. A hack is represented by a single integer between 1 and M. In\r\nall pretests the hidden number is fixed as well.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int K = 10000;\nconst ll INF = 1e18;\n\nll dp[6][K + 1];\n\nll get(int x, ll k) {\n\treturn dp[x][min(ll(K), k)];\n}\n\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tfor (int i = 1; i <= K; ++i)\n\t\tdp[1][i] = i;\n\tfor (int i = 2; i <= 5; ++i) {\n\t\tfor (int j = 1; j <= K; ++j) {\n\t\t\tll now = get(i - 1, j);\n\t\t\tfor (int k = 1; k <= j; ++k) {\n\t\t\t\t++now;\n\t\t\t\tnow += get(i - 1, j + now);\n\t\t\t\tnow = min(now, INF);\n\t\t\t}\n\t\t\tdp[i][j] = now;\n\t\t}\n\t}\n\tll l = 1;\n\tfor (int i = 5; i > 1; --i) {\n\t\tll now = get(i - 1, l);\n\t\tint j = min(ll(K), l);\n\t\tvector<ll> vv;\n\t\tfor (int k = 1; k <= j; ++k) {\n\t\t\tvv.push_back(l + now);\n\t\t\t++now;\n\t\t\tnow += get(i - 1, j + now);\n\t\t\tnow = min(now, INF);\n\t\t}\n\t\tcout << vv.size() << \" \";\n\t\tfor (ll i: vv)\n\t\t\tcout << i << \" \";\n\t\tcout << \"\\n\";\n\t\tcout.flush();\n\t\tint x;\n\t\tcin >> x;\n\t\t--x;\n\t\tif (x == -2) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (x != -1)\n\t\t\tl = vv[x] + 1;\n\t}\n\tint go = min(ll(K), l);\n\tvector<ll> vv;\n\tfor (ll i = l; i < l + go; ++i)\n\t\tvv.push_back(i);\n\tcout << vv.size() << \" \";\n\tfor (ll i: vv)\n\t\tcout << i << \" \";\n\tcout << \"\\n\";\n\tcout.flush();\n\tint x;\n\tcin >> x;\n\t--x;\n\tif (x == -2) {\n\t\treturn 0;\n\t}\n\tassert(false);\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "interactive"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Guess the number.json",
    "editorial_link": "https://codeforces.com/blog/entry/61493",
    "editorial": "Although it looks strange, the bound on the number from the problem\r\nstatement is actually tight for queries of length up to . Let\u00e2\u0080\u0099s find out\r\nhow to obtain this number.Let is the maximum such that we can guess the\r\nnumber which is known to be in using queries. The number is the bound\r\nfor the number of guesses in the next query, except for the case then ,\r\nsince from that time the bound for this number will be .The following\r\nprocess calculates : . The guesses for the current query will be .The\r\ncomplexity of the solution can be estimated as , where and , but\r\nactually it\u00e2\u0080\u0099s much faster if we calculate only for reachable states.\r\n"
}