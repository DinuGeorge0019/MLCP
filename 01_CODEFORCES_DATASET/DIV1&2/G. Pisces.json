{"link": "https://codeforces.com//contest/1023/problem/G", "problemId": "209195", "problem_idx": "G", "shortId": "1023G", "contest_number": "1023", "problem_submissions": {"F": [41706962, 41711449, 41703443, 41713059, 41716623, 41714553, 41714671, 41707623, 41713235, 41712334, 41728092, 41715075, 41696075, 41713356, 41714801, 41709605, 41719826, 41712664, 41715258, 41716252], "E": [41698618, 41698291, 41699659, 41704092, 41694722, 41704680, 41704917, 41699573, 41705681, 41707263, 41704649, 41710828, 41705364, 41701903, 41705217, 41705636, 41706969, 41702766, 41702871], "D": [41694804, 41690882, 41694456, 41696667, 41700369, 41697794, 41697937, 41696439, 41697953, 41699194, 41695409, 41701962, 41696987, 41693065, 41702154, 41698952, 41700314, 41697292, 41697057], "C": [41689677, 41687726, 41688316, 41690341, 41688011, 41691766, 41691373, 41708581, 41689935, 41688178, 41690416, 41703451, 41690697, 41687815, 41690419, 41689708, 41692238, 41691341, 41691501], "B": [41687853, 41686964, 41687392, 41687955, 41687163, 41687657, 41689074, 41696355, 41687990, 41690278, 41688421, 41705049, 41689143, 41688949, 41689104, 41687914, 41689486, 41689269, 41689603], "A": [41686640, 41686676, 41686712, 41686970, 41686742, 41686759, 41687401, 41696322, 41687071, 41686971, 41706549, 41687626, 41686813, 41686865, 41686818, 41686780, 41686879, 41726126], "G": [55938906, 48502404, 46583960, 42546293, 42609540]}, "name": "G. Pisces", "statement": "A group of researchers are studying fish population in a natural system\r\nof lakes and rivers. The system contains n lakes connected by n - 1\r\nrivers. Each river has integer length (in kilometers) and can be\r\ntraversed in both directions. It is possible to travel between any pair\r\nof lakes by traversing the rivers (that is, the network of lakes and\r\nrivers form a tree).There is an unknown number of indistinguishable fish\r\nliving in the lakes. On day 1, fish can be at arbitrary lakes. Fish can\r\ntravel between lakes by swimming the rivers. Each fish can swim a river\r\nl kilometers long in any direction in l days. Further, each fish can\r\nstay any number of days in any particular lake it visits. No fish ever\r\nappear or disappear from the lake system. Each lake can accomodate any\r\nnumber of fish at any time.The researchers made several observations.\r\nThe j-th of these observations is \"on day d_j there were at least f_j\r\ndistinct fish in the lake p_j\". Help the researchers in determining the\r\nsmallest possible total number of fish living in the lake system that\r\ndoesn\u2019t contradict the observations.\r\n", "solutions": ["/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nstruct seg {\n    map<int,int> neg, pos;\n    set<pair<int,pi>> dif;\n    int lazy;\n    int size() { return sz(pos)+sz(neg); }\n    vpi change() {\n        map<int,int> v;\n        trav(t,pos) v[t.f-lazy] += t.s;\n        trav(t,neg) v[t.f+lazy] += t.s;\n        return vpi(all(v));\n    }\n    bool ok(auto negIt, auto posIt) {\n        return negIt->f+2*lazy <= posIt->f;\n    }\n    void printInfo() {\n    \tps(\"LAZY: \",lazy);\n    \tpr(\"NEG: \"); trav(t,neg) pr(mp(t.f+lazy,t.s),' '); ps();\n    \tpr(\"POS: \"); trav(t,pos) pr(mp(t.f-lazy,t.s),' '); ps();\n    \tpr(\"DIF: \"); trav(t,dif) pr(mp(t.f-2*lazy,mp(t.s.f+lazy,t.s.s-lazy)),' '); ps();\n    }\n    void nrem(map<int,int>::iterator it) {\n        auto it1 = pos.lb(it->f+2*lazy);\n        if (it1 != pos.end() && (next(it) == neg.end() || !ok(next(it),it1)))\n            dif.erase({it1->f-it->f,{it->f,it1->f}});\n    }\n    void nins(map<int,int>::iterator it) {\n        auto it1 = pos.lb(it->f+2*lazy);\n        if (it1 != pos.end() && (next(it) == neg.end() || !ok(next(it),it1)))\n            dif.insert({it1->f-it->f,{it->f,it1->f}});\n    }\n    void prem(map<int,int>::iterator it) {\n        auto it1 = neg.ub(it->f-2*lazy); if (it1 == neg.begin()) return;\n        it1 --;\n        if (it == pos.begin() || !ok(it1,prev(it)))\n            dif.erase({it->f-it1->f,{it1->f,it->f}});\n    }\n    void pins(map<int,int>::iterator it) {\n        auto it1 = neg.ub(it->f-2*lazy); if (it1 == neg.begin()) return;\n        it1 --;\n        if (it == pos.begin() || !ok(it1,prev(it)))\n            dif.insert({it->f-it1->f,{it1->f,it->f}});\n    }\n    void insPos(int t, int f) {\n        auto it = neg.ub(t-2*lazy); \n        if (it != neg.begin()) nrem(prev(it));\n        pos[t] += f; \n        if (it != neg.begin()) nins(prev(it));\n    }\n    void insNeg(int t, int f) {\n        auto it = pos.lb(t+2*lazy); \n        if (it != pos.end()) prem(it);\n        neg[t] += f;\n        if (it != pos.end()) pins(it);\n    }\n    void ins(int t, int f) {\n        // printInfo();\n        if (f == 0) return;\n        if (f > 0) insPos(t+lazy,f);\n        else insNeg(t-lazy,f);\n        /*ps(\"INS\",t,f);\n        printInfo();\n        ps(\"-----\");*/\n    }\n    void INS(int t, int f) {\n        ins(t-1,f); ins(t,-f);\n    }\n    int getUpd(int x) {\n    \tint res = 0;\n    \tif (neg.count(x-lazy-1)) ckmax(res,-neg[x-lazy-1]);\n    \tif (pos.count(x+lazy)) ckmax(res,pos[x+lazy]);\n    \t// neg: x-lazy-1\n    \t// pos: x+lazy\n    \treturn res;\n    }\n    void adv(int x) {\n        /*ps(\"START ADV \",x);\n        printInfo();\n        ps(\"----\");*/\n        while (sz(dif) && dif.begin()->f <= 2*lazy+2*x) {\n            auto a = *dif.begin(); nrem(neg.find(a.s.f));\n            int tot = neg[a.s.f]+pos[a.s.s]; neg.erase(a.s.f), pos.erase(a.s.s);\n            if (tot < 0) {\n                neg[a.s.f] = tot;\n                nins(neg.find(a.s.f));\n                // ps(\"NINS\");\n            } else if (tot > 0) {\n                pos[a.s.s] = tot;\n                pins(pos.find(a.s.s));\n                // ps(\"PINS\");\n            } else {\n                auto it = neg.lb(a.s.f);\n                if (it != neg.begin()) nins(prev(it));\n            }\n            /*printInfo();\n            ps(\"----\");*/\n            // erase one or two \n            // maintain dif\n        }\n        //ps(\"WUT\",co);  if (co == 100) exit(0);\n        lazy += x; \n        // printInfo(); ps(\"DONE----\");\n    }\n};\n\nint n,k;\nvpi o[MX], adj[MX];\nseg S[MX];\n\nvoid init() {\n\tsetIO(); re(n);\n\tF0R(i,n-1) {\n\t    int u,v,l; re(u,v,l); l *= 2;\n\t    // ps(\"HA\",u,v,l);\n\t    adj[u].pb({v,l}), adj[v].pb({u,l});\n\t}\n\tre(k);\n\tF0R(i,k) {\n\t    int d,f,p; re(d,f,p); d *= 2;\n\t    // ps(\"OH\",d,f,p);\n\t    o[p].pb({d,f});\n\t}\n}\n\nvoid dfs(int x, int p, int l) {\n    trav(t,adj[x]) if (t.f != p) {\n        dfs(t.f,x,t.s);\n        if (sz(S[t.f]) > sz(S[x])) swap(S[x],S[t.f]);\n        auto v = S[t.f].change();\n        trav(t,v) S[x].ins(t.f,t.s);\n    }\n    // ps(\"WUT\",x,l);\n    if (!l) {\n\t    trav(t,o[x]) S[x].INS(t.f,t.s);\n    } else {\n\t    trav(t,o[x]) t.s = max(0,t.s-S[x].getUpd(t.f));\n\t    S[x].adv(1); trav(t,o[x]) S[x].INS(t.f,t.s);\n\t    S[x].adv(l-1);\n    }\n    // ps(\"HUH\",x,S[x].change(),l);\n}\n\nint main() {\n\tinit();\n\tdfs(1,0,0);\n\tauto v = S[1].change();\n\tint cur = 0, ret = 0;\n\ttrav(t,v) ckmax(ret,cur += t.s);\n\tps(ret);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"], "input": "", "output": "", "tags": ["data structures", "flows", "trees"], "dificulty": "3400", "interactive": false}