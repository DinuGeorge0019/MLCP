{
    "link": "https://codeforces.com//contest/1023/problem/G",
    "problemId": "209195",
    "problem_idx": "G",
    "shortId": "1023G",
    "contest_number": "1023",
    "problem_submissions": {
        "F": [
            41706962,
            41711449,
            41703443,
            41713059,
            41716623,
            41714553,
            41714671,
            41707623,
            41713235,
            41712334,
            41728092,
            41715075,
            41696075,
            41713356,
            41714801,
            41709605,
            41719826,
            41712664,
            41715258,
            41716252
        ],
        "E": [
            41698618,
            41698291,
            41699659,
            41704092,
            41694722,
            41704680,
            41704917,
            41699573,
            41705681,
            41707263,
            41704649,
            41710828,
            41705364,
            41701903,
            41705217,
            41705636,
            41706969,
            41702766,
            41702871
        ],
        "D": [
            41694804,
            41690882,
            41694456,
            41696667,
            41700369,
            41697794,
            41697937,
            41696439,
            41697953,
            41699194,
            41695409,
            41701962,
            41696987,
            41693065,
            41702154,
            41698952,
            41700314,
            41697292,
            41697057
        ],
        "C": [
            41689677,
            41687726,
            41688316,
            41690341,
            41688011,
            41691766,
            41691373,
            41708581,
            41689935,
            41688178,
            41690416,
            41703451,
            41690697,
            41687815,
            41690419,
            41689708,
            41692238,
            41691341,
            41691501
        ],
        "B": [
            41687853,
            41686964,
            41687392,
            41687955,
            41687163,
            41687657,
            41689074,
            41696355,
            41687990,
            41690278,
            41688421,
            41705049,
            41689143,
            41688949,
            41689104,
            41687914,
            41689486,
            41689269,
            41689603
        ],
        "A": [
            41686640,
            41686676,
            41686712,
            41686970,
            41686742,
            41686759,
            41687401,
            41696322,
            41687071,
            41686971,
            41706549,
            41687626,
            41686813,
            41686865,
            41686818,
            41686780,
            41686879,
            41726126
        ],
        "G": [
            55938906,
            48502404,
            46583960,
            42546293,
            42609540
        ]
    },
    "name": "G. Pisces",
    "statement": "A group of researchers are studying fish population in a natural system\r\nof lakes and rivers. The system contains n lakes connected by n - 1\r\nrivers. Each river has integer length (in kilometers) and can be\r\ntraversed in both directions. It is possible to travel between any pair\r\nof lakes by traversing the rivers (that is, the network of lakes and\r\nrivers form a tree).There is an unknown number of indistinguishable fish\r\nliving in the lakes. On day 1, fish can be at arbitrary lakes. Fish can\r\ntravel between lakes by swimming the rivers. Each fish can swim a river\r\nl kilometers long in any direction in l days. Further, each fish can\r\nstay any number of days in any particular lake it visits. No fish ever\r\nappear or disappear from the lake system. Each lake can accomodate any\r\nnumber of fish at any time.The researchers made several observations.\r\nThe j-th of these observations is \"on day d_j there were at least f_j\r\ndistinct fish in the lake p_j\". Help the researchers in determining the\r\nsmallest possible total number of fish living in the lake system that\r\ndoesn\u2019t contradict the observations.\r\n",
    "solutions": [
        "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nstruct seg {\n    map<int,int> neg, pos;\n    set<pair<int,pi>> dif;\n    int lazy;\n    int size() { return sz(pos)+sz(neg); }\n    vpi change() {\n        map<int,int> v;\n        trav(t,pos) v[t.f-lazy] += t.s;\n        trav(t,neg) v[t.f+lazy] += t.s;\n        return vpi(all(v));\n    }\n    bool ok(auto negIt, auto posIt) {\n        return negIt->f+2*lazy <= posIt->f;\n    }\n    void printInfo() {\n    \tps(\"LAZY: \",lazy);\n    \tpr(\"NEG: \"); trav(t,neg) pr(mp(t.f+lazy,t.s),' '); ps();\n    \tpr(\"POS: \"); trav(t,pos) pr(mp(t.f-lazy,t.s),' '); ps();\n    \tpr(\"DIF: \"); trav(t,dif) pr(mp(t.f-2*lazy,mp(t.s.f+lazy,t.s.s-lazy)),' '); ps();\n    }\n    void nrem(map<int,int>::iterator it) {\n        auto it1 = pos.lb(it->f+2*lazy);\n        if (it1 != pos.end() && (next(it) == neg.end() || !ok(next(it),it1)))\n            dif.erase({it1->f-it->f,{it->f,it1->f}});\n    }\n    void nins(map<int,int>::iterator it) {\n        auto it1 = pos.lb(it->f+2*lazy);\n        if (it1 != pos.end() && (next(it) == neg.end() || !ok(next(it),it1)))\n            dif.insert({it1->f-it->f,{it->f,it1->f}});\n    }\n    void prem(map<int,int>::iterator it) {\n        auto it1 = neg.ub(it->f-2*lazy); if (it1 == neg.begin()) return;\n        it1 --;\n        if (it == pos.begin() || !ok(it1,prev(it)))\n            dif.erase({it->f-it1->f,{it1->f,it->f}});\n    }\n    void pins(map<int,int>::iterator it) {\n        auto it1 = neg.ub(it->f-2*lazy); if (it1 == neg.begin()) return;\n        it1 --;\n        if (it == pos.begin() || !ok(it1,prev(it)))\n            dif.insert({it->f-it1->f,{it1->f,it->f}});\n    }\n    void insPos(int t, int f) {\n        auto it = neg.ub(t-2*lazy); \n        if (it != neg.begin()) nrem(prev(it));\n        pos[t] += f; \n        if (it != neg.begin()) nins(prev(it));\n    }\n    void insNeg(int t, int f) {\n        auto it = pos.lb(t+2*lazy); \n        if (it != pos.end()) prem(it);\n        neg[t] += f;\n        if (it != pos.end()) pins(it);\n    }\n    void ins(int t, int f) {\n        // printInfo();\n        if (f == 0) return;\n        if (f > 0) insPos(t+lazy,f);\n        else insNeg(t-lazy,f);\n        /*ps(\"INS\",t,f);\n        printInfo();\n        ps(\"-----\");*/\n    }\n    void INS(int t, int f) {\n        ins(t-1,f); ins(t,-f);\n    }\n    int getUpd(int x) {\n    \tint res = 0;\n    \tif (neg.count(x-lazy-1)) ckmax(res,-neg[x-lazy-1]);\n    \tif (pos.count(x+lazy)) ckmax(res,pos[x+lazy]);\n    \t// neg: x-lazy-1\n    \t// pos: x+lazy\n    \treturn res;\n    }\n    void adv(int x) {\n        /*ps(\"START ADV \",x);\n        printInfo();\n        ps(\"----\");*/\n        while (sz(dif) && dif.begin()->f <= 2*lazy+2*x) {\n            auto a = *dif.begin(); nrem(neg.find(a.s.f));\n            int tot = neg[a.s.f]+pos[a.s.s]; neg.erase(a.s.f), pos.erase(a.s.s);\n            if (tot < 0) {\n                neg[a.s.f] = tot;\n                nins(neg.find(a.s.f));\n                // ps(\"NINS\");\n            } else if (tot > 0) {\n                pos[a.s.s] = tot;\n                pins(pos.find(a.s.s));\n                // ps(\"PINS\");\n            } else {\n                auto it = neg.lb(a.s.f);\n                if (it != neg.begin()) nins(prev(it));\n            }\n            /*printInfo();\n            ps(\"----\");*/\n            // erase one or two \n            // maintain dif\n        }\n        //ps(\"WUT\",co);  if (co == 100) exit(0);\n        lazy += x; \n        // printInfo(); ps(\"DONE----\");\n    }\n};\n\nint n,k;\nvpi o[MX], adj[MX];\nseg S[MX];\n\nvoid init() {\n\tsetIO(); re(n);\n\tF0R(i,n-1) {\n\t    int u,v,l; re(u,v,l); l *= 2;\n\t    // ps(\"HA\",u,v,l);\n\t    adj[u].pb({v,l}), adj[v].pb({u,l});\n\t}\n\tre(k);\n\tF0R(i,k) {\n\t    int d,f,p; re(d,f,p); d *= 2;\n\t    // ps(\"OH\",d,f,p);\n\t    o[p].pb({d,f});\n\t}\n}\n\nvoid dfs(int x, int p, int l) {\n    trav(t,adj[x]) if (t.f != p) {\n        dfs(t.f,x,t.s);\n        if (sz(S[t.f]) > sz(S[x])) swap(S[x],S[t.f]);\n        auto v = S[t.f].change();\n        trav(t,v) S[x].ins(t.f,t.s);\n    }\n    // ps(\"WUT\",x,l);\n    if (!l) {\n\t    trav(t,o[x]) S[x].INS(t.f,t.s);\n    } else {\n\t    trav(t,o[x]) t.s = max(0,t.s-S[x].getUpd(t.f));\n\t    S[x].adv(1); trav(t,o[x]) S[x].INS(t.f,t.s);\n\t    S[x].adv(l-1);\n    }\n    // ps(\"HUH\",x,S[x].change(),l);\n}\n\nint main() {\n\tinit();\n\tdfs(1,0,0);\n\tauto v = S[1].change();\n\tint cur = 0, ret = 0;\n\ttrav(t,v) ckmax(ret,cur += t.s);\n\tps(ret);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "flows",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Pisces.json",
    "editorial_link": "https://codeforces.com//blog/entry/61356",
    "editorial": "First, how do we find the answer in any time complexity? Let us\r\nconstruct a partially ordered set where each element is a single fish in\r\none of the observations. For two elements and we put if and could\r\npossibly be two occurences of the same fish one after the other, that\r\nis, there is enough time to get from one observation to another, so that\r\n, where is the distance between the tree vertices, and and are\r\nrespective day numbers of the two observations. We can now see that the\r\nanswer is the smallest number of needed to cover all the vertices (a\r\nchain is a set of pairwise comparable elements of a p.o.set). By\r\nDilworth\u00e2\u0080\u0099s theorem, this is equal to the size of the largest (a set of\r\npairwise incomparable elements). Clearly, if a largest antichain\r\ncontains a fish from an observation, than it must include all fish from\r\nthis observation as well. We can now solve the problem in something like\r\ntime by trying all subsets of observations.To get a better complexity we\r\nneed to use the tree structure. To start, how do we check if a set of\r\nobservations forms an antichain? Here\u00e2\u0080\u0099s one criterion that works: A set\r\nof observations is an antichain iff: For each subtree of the root , a\r\nsubset of lying in that subtree is an antichain. There exists a time\r\nmoment such that it is impossible to reach at time from any observation\r\nin (possibly travelling back in time). Indeed, if both of these\r\nconditions hold, than for any two observations and happening in\r\ndifferent subtrees we have , hence these observations are incomparable.\r\nOn the other hand, if is an antichain, for any observation there is an\r\ninterval of time moments such that we cannot reach the root at any of\r\ntimes in . If two observations and are incomparable, then. But since we\r\nhave a set of intervals with pairwise non-empty intersections, they must\r\nall share a common point, hence our time moment exists.Note that in some\r\ncases is necessarily a non-integer: if there are two vertices at\r\ndistance from the root, and there are observations happening at days and\r\nrespectively at these vertices, than any will suffice. However, can\r\nalways be either an integer or a half-integer, hence we can multiply all\r\ntimes and distances by and assume is integer.The solution is going to be\r\nsubtree dynamic programming the total weight of the largest antichain in\r\nthe subtree of such that no observation can reach at time .\r\nRecalculation is a bit tricky, so let\u00e2\u0080\u0099s go step by step. First, if we\r\nhave values of , and no observations take place at , how do we change as\r\nwe travel up the edge to the top of ? If the length of this edge is ,\r\nthen the new values satisfy . Let\u00e2\u0080\u0099s call this procedure \"advancing steps\r\nforward\".How do we account for observations at ? For an observation with\r\nfishes we cannot simply add to since we can obviously reach at time from\r\nthis observation. Instead, the correct procedure is: advance the values\r\nstep; apply for all observations; advance the new values steps.Finally,\r\nto combine the answers from the subtrees of a vertex (after the\r\nadvancements were made in them), we simply add them element-wise for\r\neach : .Of course, we cannot store the DP values themselves since there\r\nare too much of them to store. Instead, we will need to use a data\r\nstructure that will maintain a piecewise constant function. More\r\nspecifically, let us maintain the positions where the function changes\r\nvalues: for each such that we store the pair . How all of the above\r\nmanipulations look like in terms of this difference structure?\r\nElement-wise sum of two functions is simply the union of the difference\r\nsets. (We may want to combine the differences with the same value, but\r\nfor most implementations this is not necessary) When we advance steps\r\nforward, the borders with positive differences will more units to the\r\nleft, and negative differences will move to the right. When two borders\r\ncollide, then some of them get eliminated. Consider the function , with\r\ntwo differences and . After advancing this one step, the new function is\r\n, so there is now a single difference . If we keep track of when and\r\nwhere these collisions take place, we can make changes to the structure\r\naccordingly.The structure of choice here is a treap of differences. When\r\nwe add two functions, we insert all elements of the smaller treap into\r\nthe larger one; a standard argument shows that at most insertions will\r\ntake place overall. To keep track of collisions, we\u00e2\u0080\u0099ll have to maintain\r\ncollision times for all adjacent border pairs, and store the minimal\r\nvalue in the root of each subtree. This may seem cumbersome, but every\r\nadjacent pair of elements occurs either as (the rightmost vertex in the\r\nleft subtree of , ), or (, the leftmost vertex in the right subtree of\r\n), hence the standard function in the treap implementation can handle\r\nthis.One further detail is that we don\u00e2\u0080\u0099t want to change the time values\r\nin our treaps. Instead, we\u00e2\u0080\u0099ll use \"lazy\" time shifting, that is, we\u00e2\u0080\u0099ll\r\nkeep an additional value associated with each treap, and assume that for\r\nentries with the actual time should be , and with the time should be .\r\nThis way, we won\u00e2\u0080\u0099t need to actually change anything in the treap when\r\nadvancing (apart from resolving collisions).The total complexity of this\r\nsolution is .\r\n"
}