{
    "link": "https://codeforces.com//contest/1799/problem/G",
    "problemId": "1800604",
    "problem_idx": "G",
    "shortId": "1799G",
    "contest_number": "1799",
    "problem_submissions": {
        "H": [
            195172140,
            195179948,
            195176943,
            195177627,
            195177612,
            195187046,
            195170243,
            195186163,
            195181900,
            195178648,
            195187740,
            195188641,
            195181162,
            195197683,
            195197622,
            195197452,
            195197330,
            195195992,
            195195702,
            195195592,
            195189428,
            222390709,
            195183885,
            195192378
        ],
        "G": [
            195165805,
            195168765,
            195163877,
            195170080,
            195166062,
            195173874,
            195159286,
            195167233,
            195175284,
            195171112,
            195175174,
            195176292,
            195166497,
            195167039,
            195174540,
            195165113,
            195172643,
            195174992,
            195179660
        ],
        "F": [
            195162556,
            195161415,
            195167047,
            195167029,
            195169902,
            195165660,
            195176867,
            195177074,
            195171218,
            195182224,
            195179445,
            195181473,
            195185750,
            195200279,
            195171757,
            195192151,
            195177698,
            195192345,
            195178905,
            195177004
        ],
        "E": [
            195155464,
            195155926,
            195160608,
            195157188,
            195161547,
            195155405,
            195184653,
            195161068,
            195166323,
            195173130,
            195168387,
            195173064,
            195218892,
            195198896,
            195162114,
            195161002,
            195160161,
            195165268,
            195163227,
            195160677
        ],
        "D2": [
            195149687,
            195148531,
            195151569,
            195149401,
            195152435,
            195149320,
            195159443,
            195154372,
            195157592,
            195155987,
            195161428,
            195244200,
            195161041,
            195153968,
            195155870,
            195151311,
            195155278,
            195159787,
            195153371,
            195151855
        ],
        "D1": [
            195149644,
            195148457,
            195150430,
            195149466,
            195152497,
            195149250,
            195150661,
            195154425,
            195157658,
            195153741,
            195161504,
            195150409,
            195152774,
            195155970,
            195151278,
            195153482,
            195159732,
            195149352,
            195149899
        ],
        "C": [
            195146230,
            195145019,
            195147190,
            195145539,
            195148295,
            195145217,
            195148636,
            195146815,
            195151203,
            195151265,
            195151601,
            195146561,
            195147507,
            195149080,
            195145370,
            195151542,
            195158458,
            195147153,
            195147120
        ],
        "B": [
            195140902,
            195141064,
            195140888,
            195140956,
            195140810,
            195141011,
            195142268,
            195146249,
            195143844,
            195142681,
            195143326,
            195142296,
            195140849,
            195142634,
            195140165,
            195142125,
            195141309,
            195141669,
            195140680
        ],
        "A": [
            195139293,
            195139594,
            195139424,
            195139401,
            195139388,
            195139558,
            195139905,
            195143164,
            195139695,
            195139287,
            195140212,
            195139506,
            195139370,
            195139520,
            195139228,
            195140320,
            195142809,
            195139497,
            195139286
        ]
    },
    "name": "G. Count Voting",
    "statement": "There are n people that will participate in voting. Each person has\r\nexactly one vote.i-th person has a team t_i (1\r\nleq t_i\r\nleq n) where t_i = t_j means i, j are in the same team. By the rules\r\neach person should vote for the person from the different team. Note\r\nthat it automatically means that each person can\u2019t vote for himself.Each\r\nperson knows the number of votes c_i he wants to get. How many possible\r\nvotings exists, such that each person will get the desired number of\r\nvotes? Due to this number can be big, find it by modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % P)} {}\n    \n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += P;\n        }\n        if (x >= P) {\n            x -= P;\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(P - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) {\n        x = 1LL * x * rhs.x % P;\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n    }\n    \n    std::vector<int> t(n);\n    std::vector<std::vector<int>> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> t[i];\n        t[i]--;\n        a[t[i]].push_back(c[i]);\n    }\n    \n    std::vector<Z> dp(n + 1);\n    dp[0] = 1;\n    \n    for (auto v : a) {\n        if (v.empty()) {\n            continue;\n        }\n        std::vector g(n + 1, std::vector<Z>(n + 1));\n        for (int i = 0; i <= n; i++) {\n            g[i][0] = dp[i];\n        }\n        for (auto c : v) {\n            if (c == 0) {\n                continue;\n            }\n            for (int i = n; i >= 0; i--) {\n                for (int j = n - i; j >= 0; j--) {\n                    if (g[i][j] == 0) {\n                        continue;\n                    }\n                    Z val = g[i][j];\n                    g[i][j] = 0;\n                    for (int x = 0; x <= c; x++) {\n                        g[i + x][j + c - x] += comb.invfac(x) * comb.invfac(c - x) * val;\n                    }\n                }\n            }\n        }\n        dp.assign(n + 1, 0);\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; i + j <= n; j++) {\n                if (g[i][j] == 0) {\n                    continue;\n                }\n                dp[i] += (j % 2 ? -1 : 1) * comb.fac(j) * g[i][j] * comb.binom(v.size(), j);\n            }\n        }\n    }\n    \n    Z ans = 0;\n    for (int i = 0; i <= n; i++) {\n        ans += dp[i] * comb.fac(i);\n    }\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Count Voting.json",
    "editorial_link": "https://codeforces.com//blog/entry/113321",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem using inclusion-conclusion principle. If we do\r\nnot consider teams, there are ways to make votings.But now consider such\r\nsets of bad votings: person made a vote for the person from the same\r\nteam . We want to calculate the size of the union of such sets of\r\nvotings.So the answer to the problem is , where is the number of ways to\r\nmake votings, where we firstly fix some subset of people who will vote\r\nfor the same team (for others the vote can be any) and calculate the\r\nnumber of votings for it, and we sum these numbers for all subsets of\r\npeople.Let\u00e2\u0080\u0099s define , where is the number of people from the same team\r\nwho made a vote for -th person (so, ). So, , where is the number of\r\nvotings, where for each we firstly fix people from team that will vote\r\nfor and calculate the number of votings, and we sum these numbers for\r\nall ways to fix.How is calculated? There are ways to make votes for\r\npeople who were not selected into subset. This should be multiplied for\r\nthe number of ways to vote for people that were fixed. This should be\r\nfound for each team separately.Let\u00e2\u0080\u0099s consider some team of people (WLOG\r\nthey are first people). There are ways (*) to fix people in this team.\r\nThese counts should be multiplied for all teams.Now to sum all for all\r\nwe of course can\u00e2\u0080\u0099t iterate over all possible , we will do it using\r\ndynamic programming. Let\u00e2\u0080\u0099s iterate over all possible teams and calculate\r\nthe sum of current counts for all prefixes of arrays , where we\r\nconsidered first teams and the sum of elements of on this prefix is\r\n.When we add a new team to our , we can write , where is the sum of (*)\r\nmultiplied by for all ways to choose inside the team with sum of in this\r\nteam equal to .To calculate values for each team we can also use a\r\nprefix dynamic programming inside the team.At the end we found , where\r\nis the number of teams.So, the time complexity of this solution is .\r\nWhere are many different ways of how the solution can be implemented\r\n(and even optimized with power series), but the inclusion-conclusion is\r\nnecessary to solve the problem.\r\n"
}