{
    "link": "https://codeforces.com//contest/722/problem/C",
    "problemId": "74001",
    "problem_idx": "C",
    "shortId": "722C",
    "contest_number": "722",
    "problem_submissions": {
        "F": [
            21091512,
            21085594,
            21089803,
            21092021,
            21091925,
            21091406,
            21083741,
            21089867,
            21089611,
            21086397,
            21088088,
            21089823,
            21086418,
            21090125,
            21089647,
            21089044,
            21089230,
            21089273
        ],
        "E": [
            21088023,
            21107688,
            21106067,
            21087044,
            21088852,
            21116611,
            21251507,
            21091238,
            21126451
        ],
        "D": [
            21080172,
            21076258,
            21078404,
            21076583,
            21076470,
            21078997,
            21077617,
            21080800,
            21077359,
            21076406,
            21076609,
            21078412,
            21075627,
            21078861,
            21077229,
            21077815,
            21082146,
            21079311,
            21080176,
            21080301
        ],
        "C": [
            21074766,
            21074143,
            21079601,
            21075184,
            21074110,
            21076772,
            21073504,
            21077447,
            21074819,
            21079500,
            21074909,
            21079654,
            21072018,
            21074306,
            21075294,
            21074312,
            21076102,
            21076830,
            21075898,
            21075171
        ],
        "A": [
            21071362,
            21070972,
            21070997,
            21070865,
            21070901,
            21080897,
            21070869,
            21071371,
            21070926,
            21071044,
            21070971,
            21074578,
            21078981,
            21070900,
            21072665,
            21071359,
            21071666,
            21071148,
            21070986,
            21070908
        ],
        "B": [
            21071955,
            21071959,
            21071961,
            21072182,
            21071953,
            21073607,
            21072621,
            21072656,
            21072545,
            21073995,
            21077019,
            21071668,
            21072069,
            21072511,
            21073331,
            21073657,
            21072159,
            21071949
        ]
    },
    "name": "C. Destroying Array",
    "statement": "You are given an array consisting of non-negative integers .You are\r\ngoing to destroy integers in the array one by one. Thus, you are given\r\nthe permutation of integers from to defining the order elements of the\r\narray are destroyed.After each element is destroyed you have to find out\r\nthe segment of the array, such that it contains no destroyed elements\r\nand the sum of its elements is maximum possible. The sum of elements in\r\nthe empty segment is considered to be .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nint A[100000];\nint P[100000];\nbool ok[100000];\nint fa[100000];\nlong long s[100000];\nlong long ans[100000];\n\nint find(int u)\n{\n    if(fa[u]!=u)\n        fa[u]=find(fa[u]);\n    return fa[u];\n}\n\nvoid merge(int u, int v)\n{\n    u=find(u), v=find(v);\n    fa[u]=v;\n    s[v]+=s[u];\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    for(int i=0; i<N; i++)\n        scanf(\"%d\", A+i);\n    for(int i=0; i<N; i++)\n    {\n        scanf(\"%d\", P+i);\n        P[i]--;\n        fa[i]=i;\n    }\n    long long rans=0;\n    for(int i=N-1; i>=0; i--)\n    {\n        s[P[i]]=A[P[i]];\n        if(P[i]>0 && ok[P[i]-1])\n            merge(P[i], P[i]-1);\n        if(P[i]+1<N && ok[P[i]+1])\n            merge(P[i], P[i]+1);\n        ok[P[i]]=true;\n        ans[i]=rans;\n        rans=max(rans, s[find(P[i])]);\n    }\n    for(int i=0; i<N; i++)\n        printf(\"%lld\\n\", ans[i]);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Destroying Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/47497",
    "editorial": "Main observation, that was necessary to solve the problem: since all\r\nnumbers are non-negative, it makes sense to consider only subsegments,\r\nmaximal with respect to inclusion. That is, such segments on both sides\r\nof which there are either destroyed numbers or the end of the\r\narray.Letâs solve the problem in reversed order: first destroy all the\r\nnumbers, and then add them back. We will carry a single value - the\r\ncurrent maximum sum among all subsegments. After destroying all the\r\nnumbers, the answer is equal to zero. Now, we add a new number on each\r\nstep. To find the maximum subsegment containing this number, we need to\r\nfind the nearest to the left and to the right destroyed number. This can\r\nbe done in using binary search tree (f.e. set from STL). To find the sum\r\nof the numbers in the subsegment, we can compute partial sums of the\r\noriginal array.Thus, at each step, we can update the maximum sum among\r\nall subsegments in time.The total complexity of this solution is .\r\n",
    "hint": []
}