{
    "link": "https://codeforces.com//contest/1028/problem/F",
    "problemId": "212304",
    "problem_idx": "F",
    "shortId": "1028F",
    "contest_number": "1028",
    "problem_submissions": {
        "F": [
            42179553,
            42173574,
            42172126,
            42183823,
            42179375,
            42177929,
            42176646,
            42176739,
            42168545,
            42174904,
            42175563,
            42187810,
            42177441,
            42180538,
            42178358,
            42178178
        ],
        "H": [
            42177022,
            42177937,
            42197383,
            42174346,
            42178267,
            42180853,
            42180364,
            42179125,
            42178613,
            42177685,
            42188074
        ],
        "G": [
            42174235,
            42180921,
            42179342,
            42179278,
            42183838,
            42181415,
            42188299,
            42175088,
            42183699,
            42177809,
            42199769,
            42180709
        ],
        "E": [
            42168417,
            42169350,
            42169465,
            42168142,
            42175311,
            42172346,
            42172643,
            42173588,
            42169997,
            42170922,
            42170783,
            42169728,
            42172341,
            42172392,
            42174203,
            42173993,
            42169247
        ],
        "D": [
            42165714,
            42166524,
            42166821,
            42171266,
            42167648,
            42168290,
            42168039,
            42170991,
            42171075,
            42166522,
            42165185,
            42167753,
            42167327,
            42166990,
            42167859,
            42166718,
            42169672,
            42169316,
            42172369
        ],
        "C": [
            42162420,
            42161280,
            42164158,
            42159623,
            42162254,
            42163150,
            42163507,
            42162131,
            42163347,
            42161576,
            42161023,
            42164637,
            42163616,
            42161801,
            42163884,
            42163193,
            42164354,
            42165199,
            42162360
        ],
        "B": [
            42159958,
            42159146,
            42159962,
            42160148,
            42160038,
            42161126,
            42160845,
            42163792,
            42159144,
            42162163,
            42159196,
            42160477,
            42160541,
            42159094,
            42160870,
            42160007,
            42160216,
            42160794,
            42159231
        ],
        "A": [
            42158947,
            42158816,
            42158953,
            42161141,
            42158802,
            42159721,
            42159618,
            42163119,
            42158831,
            42163007,
            42158820,
            42158811,
            42158901,
            42158777,
            42159186,
            42158929,
            42158806,
            42159328,
            42158825
        ]
    },
    "name": "F. Make Symmetrical",
    "statement": "Consider a set of points A, initially it is empty. There are three types\r\nof queries: Insert a point (x_i, y_i) to A. It is guaranteed that this\r\npoint does not belong to A at this moment. Remove a point (x_i, y_i)\r\nfrom A. It is guaranteed that this point belongs to A at this moment.\r\nGiven a point (x_i, y_i), calculate the minimum number of points\r\nrequired to add to A to make A symmetrical with respect to the line\r\ncontaining points (0, 0) and (x_i, y_i). Note that these points are not\r\nactually added to A, i.e. these queries are independent from each other.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nint gcd(int a, int b) {\n\twhile (b) {\n\t\tll q = a % b;\n\t\ta = b;\n\t\tb = q;\n\t}\n\treturn a;\n}\n\nconst int MAXN = 210000;\n\nvector<pair<int, int>> vv;\n\nmap<ll, vector<pair<int, int> > > mm;\n\nint q;\nint t[MAXN];\nint x[MAXN];\nint y[MAXN];\nint cc[MAXN];\n\nvoid add(int x, int y, int d) {\n\tint g = gcd(x, y);\n\tx /= g, y /= g;\n\tint xx = lower_bound(vv.begin(), vv.end(), make_pair(x, y)) - vv.begin();\n\tif (xx != vv.size() && vv[xx].first == x && vv[xx].second == y) {\n\t\tcc[xx] += d;\n\t}\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tcin >> t[i] >> x[i] >> y[i];\n\t\tif (t[i] == 3) {\n\t\t\tint g = gcd(x[i], y[i]);\n\t\t\tx[i] /= g;\n\t\t\ty[i] /= g;\n\t\t\tvv.emplace_back(x[i], y[i]);\n\t\t}\n\t}\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(ALL(vv)) - vv.begin());\n\tint cur = 0;\n\tfor (int i = 0; i < q; ++i) {\n\t\tll d = ll(x[i]) * x[i] + ll(y[i]) * y[i];\n\t\tif (t[i] == 1) {\n\t\t\t++cur;\n\t\t\tauto &v = mm[d];\n\t\t\tv.emplace_back(x[i], y[i]);\n\t\t\tadd(x[i], y[i], 1);\n\t\t\tfor (int j = 0; j + 1 < v.size(); ++j)\n\t\t\t\tadd(v[j].first + x[i], v[j].second + y[i], 2);\n\t\t}\n\t\telse if (t[i] == 2) {\n\t\t\t--cur;\n\t\t\tauto &v = mm[d];\n\t\t\tfor (int j = 0; j < v.size(); ++j) {\n\t\t\t\tif (v[j].first == x[i] && v[j].second == y[i]) {\n\t\t\t\t\tswap(v[j], v.back());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(x[i], y[i], -1);\n\t\t\tfor (int j = 0; j + 1 < v.size(); ++j)\n\t\t\t\tadd(v[j].first + x[i], v[j].second + y[i], -2);\n\t\t\tv.pop_back();\n\t\t}\n\t\telse {\n\t\t\tint ans = cur;\n\t\t\tint xx = lower_bound(vv.begin(), vv.end(), make_pair(x[i], y[i])) - vv.begin();\n\t\t\tans -= cc[xx];\n\t\t\tcout << ans << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Make Symmetrical.json",
    "editorial_link": "https://codeforces.com/blog/entry/61493",
    "editorial": "The key idea is the fact that the number of points , where , with fixed\r\nis not large. Actually it is equal to the number of divisors of after\r\nremoving all prime divisors of form (because if has such prime divisor,\r\nthen both are divisible by it). For the problem constraints it can be\r\nchecked by brute force that maximum number of points with fixed is\r\n.Since the circumference with the center in origin is symmetrical with\r\nrespect to any line containing origin, letâs solve the problem for each\r\ncircumference independently. We maintain two maps: holds the number of\r\npoints for each line containing origin, holds the number of pairs of\r\npoints that are symmetrical with respect to each line containing origin.\r\nWhen the point is added or removed on some circumference, we iterate\r\nover points lying on it and add or remove to , as well as add or remove\r\nto (where is the line through and ). The answer for query is , where is\r\nthe number of points at the moment. This solution makes queries to map\r\nor unordered_map, which is fast enough since .\r\n",
    "hint": []
}