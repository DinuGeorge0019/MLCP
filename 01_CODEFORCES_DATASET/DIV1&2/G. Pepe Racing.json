{"link": "https://codeforces.com//contest/1896/problem/G", "problemId": "2346411", "problem_idx": "G", "shortId": "1896G", "contest_number": "1896", "problem_submissions": {"H2": [234305435, 234294276, 234316807, 234293989, 234307453, 234313145, 234308430, 234674727, 234674461, 234674412, 234348461, 234317754, 234317500], "H1": [234300435, 234288752, 234294076, 234304469, 234296832, 234303366, 234305063, 234305336, 234301810, 234292381], "G": [234290728, 234312960, 234419627, 234295328, 234299457, 234326268, 234302972, 234306994, 234344999, 234302897, 234304455, 234306035, 234296895, 234525586], "F": [234279344, 234262280, 234278356, 234281909, 234284183, 234288595, 234278118, 234284621, 234280975, 234283777, 234307968, 234293096, 234293697, 234294644, 234304686, 234282511, 234279944, 234277321], "E": [234266080, 234275828, 234270895, 234263950, 234269369, 234263464, 234267763, 234270201, 234272007, 234268761, 234270245, 234285745, 234275911, 234277731, 234273316, 234269329, 234260178, 234268619, 234263914], "D": [234260515, 234269507, 234266479, 234257220, 234264143, 234256547, 234261136, 234260603, 234265661, 234261124, 234261787, 234269263, 234266704, 234265834, 234268166, 234280921, 234253907, 234259650, 234255630], "C": [234253899, 234266056, 234253267, 234251911, 234261130, 234253006, 234255721, 234254779, 234258245, 234287578, 234255535, 234262815, 234255118, 234261416, 234262126, 234255695, 234249255, 234253498, 234251351], "B": [234249421, 234247262, 234248984, 234247486, 234250283, 234247863, 234248979, 234248837, 234302894, 234248804, 234248842, 234247845, 234248167, 234249751, 234253337, 234249856, 234245662, 234248853, 234246737], "A": [234245828, 234244872, 234245833, 234244939, 234247553, 234244853, 234245867, 234245696, 234303768, 234246110, 234245020, 234245161, 234244947, 234245703, 234249430, 234244871, 234244771, 234245709, 234244767]}, "name": "G. Pepe Racing", "statement": "There are n^2 pepes labeled 1, 2,\r\nldots, n^2 with speeds. You would like to set up some races to find out\r\nthe relative speed of these pepes.In one race, you can choose exactly n\r\ndistinct pepes and make them race against each other. After each race,\r\nyou will only know the pepe of these n pepes.Can you order the n^2-n+1\r\nfastest pepes in 2n^2 - 2n + 1 races? Note that the slowest n - 1 pepes\r\nare indistinguishable from each other.Note that the interactor is . That\r\nis, the relative speeds of the pepes are not fixed in the beginning and\r\nmay depend on your queries. But it is guaranteed that at any moment\r\nthere is at least one initial configuration of pepes such that all the\r\nanswers to the queries are consistent.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint pyt(vi wek)\n{\n\tprintf(\"?\");\n\tfor (int i : wek)\n\t\tprintf(\" %d\", i);\n\tprintf(\"\\n\");\n\tff();\n\tint ret;\n\tscanf(\"%d\", &ret);\n\treturn ret;\n}\n\nvoid ans(vi wek)\n{\n\tprintf(\"!\");\n\tfor (int i : wek)\n\t\tprintf(\" %d\", i);\n\tprintf(\"\\n\");\n\tff();\n}\n\nvi stos[nax];\n\nvoid usun(vi &wek, int v)\n{\n\tfor (int &i : wek)\n\t{\n\t\tif (i==v)\n\t\t{\n\t\t\tswap(i, wek.back());\n\t\t\twek.pop_back();\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(0);\n}\n\nvoid cionk(vi &wek, int v)\n{\n\tfor (int &i : wek)\n\t{\n\t\tif (i==v)\n\t\t{\n\t\t\tswap(i, wek.back());\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(0);\n}\n\nbool mniej(vi a, vi b)\n{\n\treturn a.size()>b.size();\n}\n\nvoid popraw(vi &wek)\n{\n\tint x=pyt(wek);\n\tcionk(wek, x);\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tstos[i].clear();\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tstos[i].push_back((i-1)*n+j);\n\tvi res;\n\tfor (int i=1; i<=n; i++)\n\t\tpopraw(stos[i]);\n\t//~ while((int)res.size()<n*n-n+1)\n\twhile((int)res.size()<n*n-2*n)\n\t{\n\t\tvi ter;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tter.push_back(stos[i].back());\n\t\tint x=pyt(ter);\n\t\tres.push_back(x);\n\t\t{\n\t\t\tint g=1;\n\t\t\twhile((int)stos[g].back()!=x)\n\t\t\t\tg++;\n\t\t\tswap(stos[g], stos[1]);\n\t\t}\n\t\tsort(stos+2, stos+n+1, mniej);\n\t\t\n\t\tstos[1].pop_back();\n\t\tfor (int i=2; i<=n; i++)\n\t\t{\n\t\t\twhile((int)stos[1].size()<n && (int)stos[i].size()>2)\n\t\t\t{\n\t\t\t\tint y=stos[i][0];\n\t\t\t\tstos[i].erase(stos[i].begin());\n\t\t\t\tstos[1].push_back(y);\n\t\t\t}\n\t\t}\n\t\tif ((int)stos[1].size()==n)\n\t\t{\n\t\t\tpopraw(stos[1]);\n\t\t\tcontinue;\n\t\t}\n\t\tvi tu=stos[1];\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tif ((int)tu.size()<n)\n\t\t\t\ttu.push_back(stos[i][0]);\n\t\tint wez=pyt(tu);\n\t\tint g=2;\n\t\twhile(g<=n && stos[g][0]!=wez)\n\t\t\tg++;\n\t\tif (g>n)\n\t\t{\n\t\t\tcionk(stos[1], wez);\n\t\t\tcontinue;\n\t\t}\n\t\tswap(stos[1].back(), stos[g][0]);\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tassert((int)stos[i].size()==2);\n\t\n\twhile((int)res.size()<n*n-n)\n\t{\n\t\tvi ter;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tter.push_back(stos[i].back());\n\t\tint x=pyt(ter);\n\t\tres.push_back(x);\n\t\tint g=1;\n\t\twhile(stos[g].back()!=x)\n\t\t\tg++;\n\t\tstos[g].pop_back();\n\t\tif (stos[g].empty())\n\t\t{\n\t\t\tint d=1;\n\t\t\twhile((int)stos[d].size()!=2)\n\t\t\t\td++;\n\t\t\tstos[g].push_back(stos[d].back());\n\t\t\tstos[d].pop_back();\n\t\t}\n\t}\n\t{\n\t\tvi ter;\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tter.push_back(stos[i].back());\n\t\tint x=pyt(ter);\n\t\tres.push_back(x);\n\t}\n\tans(res);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation", "interactive", "sortings"], "dificulty": "3200", "interactive": false}