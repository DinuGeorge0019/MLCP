{
    "link": "https://codeforces.com//contest/768/problem/D",
    "problemId": "94875",
    "problem_idx": "D",
    "shortId": "768D",
    "contest_number": "768",
    "problem_submissions": {
        "F": [
            24840431,
            24838480,
            24834630,
            24841891,
            24838353,
            24840717,
            24837763,
            24842282,
            24838721,
            24833873,
            24842120,
            24844145,
            24842096,
            24840981,
            24845191,
            24842247,
            24840284,
            24847109,
            24843919
        ],
        "E": [
            24834774,
            24835983,
            24832451,
            24837828,
            24833805,
            24837182,
            24833920,
            24836646,
            24835033,
            24838913,
            24837846,
            24833547,
            24837106,
            24837362,
            24839266,
            24837276,
            24838051,
            24835972,
            24836022
        ],
        "D": [
            24832202,
            24833876,
            24835915,
            24835246,
            24832704,
            24834168,
            24832774,
            24838949,
            24833061,
            24836615,
            24839525,
            24834336,
            24833791,
            24835394,
            24835786,
            24835146,
            24835911,
            24837569,
            24837832
        ],
        "C": [
            24830784,
            24831935,
            24846692,
            24833492,
            24831356,
            24831859,
            24830894,
            24833465,
            24831521,
            24835038,
            24835013,
            24830101,
            24832003,
            24831977,
            24833696,
            24832023,
            24832927,
            24833660,
            24834203
        ],
        "B": [
            24828716,
            24830642,
            24828869,
            24830153,
            24830045,
            24829484,
            24830872,
            24829643,
            24837759,
            24831145,
            24828453,
            24830132,
            24829454,
            24830410,
            24829830,
            24830884,
            24831500,
            24831921
        ],
        "A": [
            24825770,
            24826388,
            24825799,
            24826247,
            24825814,
            24825782,
            24825775,
            24825815,
            24827152,
            24827361,
            24826212,
            24825822,
            24826382,
            24826002,
            24825750,
            24826264,
            24826016,
            24825780,
            24828293
        ],
        "G": [
            24850234,
            25339793,
            24854056,
            24855563,
            24855744
        ]
    },
    "name": "D. Jon and Orbs",
    "statement": "Jon Snow is on the lookout for some orbs required to defeat the white\r\nwalkers. There are different types of orbs and he needs at least one of\r\neach. One orb spawns daily at the base of a Weirwood tree north of the\r\nwall. The probability of this orb being of any kind is equal. As the\r\nnorth of wall is full of dangers, he wants to know the minimum number of\r\ndays he should wait before sending a ranger to collect the orbs such\r\nthat the probability of him getting at least one of each kind of orb is\r\nat least , where .To better prepare himself, he wants to know the answer\r\nfor different values of . Since he is busy designing the battle strategy\r\nwith Sam, he asks you for your help.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nconst ld TAU=2*acos(-1);\nconst ld eps=1e-7;\nconst int inf=1e9+99;\nconst ll linf=1e18+88;\n\n\n\nint32_t main() {\n\tconst int N=1024;\n\tstatic ld dp[2][N];\n\tint k,q; cin>>k>>q;\n\tdp[0][0]=1;\n\tvector<ld> Z={0};\n\tfor(;Z.back()<.5;) {\n\t\tstatic int qq=0;\n\t\tauto ndp=dp[qq^1];\n\t\tauto odp=dp[qq];\n\t\tqq^=1;\n\n\t\tfor(int i=0;i<=k;i++) ndp[i]=0;\n\t\tfor(int i=0;i<=k;i++) {\n\t\t\tndp[i]+=odp[i]*i/k;\n\t\t\tndp[i+1]+=odp[i]*(k-i)/k;\n\t\t}\n\n\n\t\tZ.push_back(ndp[k]);\n\t}\n\tfor(;q--;) {\n\t\tint p; cin>>p;\n\t\tld need = (p-eps)/2e3;\n\t\tcout<<lower_bound(Z.begin(),Z.end(),need)-Z.begin()<<endl;\n\t}\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Jon and Orbs.json",
    "editorial_link": "https://codeforces.com//blog/entry/50550",
    "editorial": "Set and Editorial by: arnabsamanta This problem can be solve using\r\ninclusion-exclusion principle but precision errors need to be handled.\r\nTherefore, we use the following dynamic programming approach to solve\r\nthis problem. On day there are two possibilities, Case-1 : Jon doesn\u00e2\u0080\u0099t\r\nfind a new orb then the probability of it is . Case-2 : Jon does find a\r\nnew orb then the probability of it is . Therefore, We need to find the\r\nminimum such that where, = number of days Jon waited. = number of\r\ndistinct orbs Jon have till now. = probability of Jon having distinct\r\norbs in days. = Total number of distinct orbs possible. Code\r\n"
}