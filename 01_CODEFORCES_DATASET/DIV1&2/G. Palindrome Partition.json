{
    "link": "https://codeforces.com//contest/932/problem/G",
    "problemId": "157000",
    "problem_idx": "G",
    "shortId": "932G",
    "contest_number": "932",
    "problem_submissions": {
        "G": [
            51774341,
            35308371,
            35309948,
            35309510,
            35328593,
            35312755,
            35340195,
            35324025,
            38386676,
            35314606
        ],
        "F": [
            35314668,
            35310572,
            35468380,
            35310269,
            35309416,
            35312292,
            35310748,
            35546358,
            35310551,
            35314451,
            35994490,
            35310830,
            35314597,
            35313005,
            35315153,
            35311414,
            35314861
        ],
        "E": [
            35305602,
            35300676,
            35303983,
            35302322,
            35304627,
            35307360,
            35305500,
            35300979,
            35304741,
            35308375,
            35305972,
            35304083,
            35308467,
            35308589,
            35308504,
            35313014,
            35308160,
            35300247
        ],
        "D": [
            35304182,
            35304652,
            35301520,
            35312731,
            35302822,
            35304942,
            35303273,
            35308561,
            35309596,
            35306303,
            35302532,
            35308788,
            35304471,
            35304933,
            35304868,
            35308529,
            35306123,
            35312012
        ],
        "C": [
            35298412,
            35298036,
            35296739,
            35298645,
            35298179,
            35298553,
            35299152,
            35297891,
            35299526,
            35299903,
            35298326,
            35305061,
            35298463,
            35300385,
            35298472,
            35299312,
            35300289,
            35313442
        ],
        "B": [
            35297094,
            35297006,
            35297939,
            35296994,
            35296930,
            35296422,
            35297855,
            35301880,
            35297864,
            35297983,
            35297247,
            35296879,
            35297467,
            35297739,
            35296808,
            35297547,
            35298510,
            35302031
        ],
        "A": [
            35295015,
            35294909,
            35298217,
            35294978,
            35294827,
            35294828,
            35295219,
            35296140,
            35296578,
            35294771,
            35294859,
            35294967,
            35294941,
            35294775,
            35295820,
            35295673,
            35300844
        ]
    },
    "name": "G. Palindrome Partition",
    "statement": "Given a string , find the number of ways to split to substrings such\r\nthat if there are substrings in partition, then for all and is\r\neven.Since the number of ways can be large, print it modulo .\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst ll mod=1000*1000*1000+7;\n\nconst int maxn=1000*1000+7, alfa=26;\nint len[maxn], link[maxn], to[maxn][alfa], slink[maxn], diff[maxn];\nint sz, last, n;\nchar s[maxn];\n\nvoid init() {\n\ts[n++]=len[1]=-1;\n\tlink[0]=1;\n\tsz=2;\n}\nint get_link(int v) {\n\twhile(s[n-len[v]-2]!=s[n-1]) v=link[v];\n\treturn v;\n}\nvoid add_letter(char c) {\n\ts[n++]=c-='a';\n\tlast=get_link(last);\n\tif(!to[last][c]) {\n\t\tlen[sz]=len[last]+2;\n\t\tlink[sz]=to[get_link(link[last])][c];\n\t\tdiff[sz]=len[sz]-len[link[sz]];\n\t\tslink[sz]=(diff[sz]==diff[link[sz]] ? slink[link[sz]] : link[sz]);\n\t\tto[last][c]=sz++;\n\t}\n\tlast=to[last][c];\n}\n\nconst int nax=1e6+7;\nint m;\nchar wcz[nax];\nchar tekst[nax];\n\nll dp[nax];\nll serdp[nax];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main() {\n\tscanf(\"%s\", wcz+1);\n\tm=strlen(wcz+1);\n\tfor (int i=1; i<=m/2; i++)\n\t{\n\t\ttekst[2*i-1]=wcz[i];\n\t\ttekst[2*i]=wcz[m+1-i];\n\t}\n\tinit();\n\tdp[0]=1;\n\tfor(int i=1; i<=m; i++) {\n\t\tadd_letter(tekst[i]);\n\t\tfor(int v=last; len[v]>0; v=slink[v]) {\n\t\t\tserdp[v]=dp[i-(len[slink[v]]+diff[v])];\n\t\t\tif(diff[v] == diff[link[v]])\n\t\t\t\tdod(serdp[v], serdp[link[v]]);\n\t\t\tif (!(i&1)) {\n\t\t\t\tdod(dp[i], serdp[v]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[m]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Palindrome Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/57796",
    "editorial": "Let n be the length of the string . Consider the string . The problem\r\ncan be reduced to finding the number of ways to partition string into\r\npalindromic substrings of even length. Proof: Let be the total number of\r\npartitions. Let where denotes length of and denotes character of . The\r\npart of string corresponding to these two partitions is which is an even\r\nlength palindrome. Similarly, the converse is also true. Dynamic\r\nprogramming can be used to solve the problem. Let be the number of ways\r\nto partition into even length palindromes. Then, where is an even length\r\npalindrome. Of course for odd , . As discussed in thisblog, we can use\r\nan eertree to implement the solution. On the other hand, we can avoid\r\nthe use of any suffix structure by following the algorithm described in\r\nthispaper.Complexity:\r\n",
    "hint": []
}