{
    "link": "https://codeforces.com//contest/794/problem/A",
    "problemId": "106230",
    "problem_idx": "A",
    "shortId": "794A",
    "contest_number": "794",
    "problem_submissions": {
        "F": [
            27081873,
            27083526,
            27083046,
            27085017,
            27081983,
            27082510,
            27086006,
            27083949,
            27080179,
            27086715,
            27082966,
            27079645,
            27084337,
            27084766,
            27081869,
            27081966,
            27084662
        ],
        "E": [
            27079377,
            27080585,
            27080375,
            27082137,
            27084820,
            27086075,
            27082614,
            27085336,
            27086070,
            27082160,
            27085721,
            27085903,
            27085376,
            27087205,
            27084980,
            27082950,
            27083172,
            27085134
        ],
        "D": [
            27077745,
            27078665,
            27078681,
            27079267,
            27079635,
            27079737,
            27080740,
            27079081,
            27083788,
            27079987,
            27082339,
            27082247,
            27082529,
            27080107,
            27094240,
            27094236,
            27094226,
            27094219,
            27094212,
            27094182,
            27094168,
            27094131,
            27094066,
            27080763,
            27081677,
            27089971,
            27089903,
            27087542,
            27080778
        ],
        "C": [
            27075178,
            27076116,
            27076013,
            27076437,
            27076459,
            27075605,
            27076203,
            27075986,
            27076793,
            27077625,
            27078065,
            27084041,
            27076700,
            27077790,
            27078769,
            27077244,
            27075390,
            27082931,
            27077078
        ],
        "B": [
            27072873,
            27073613,
            27072949,
            27073965,
            27073074,
            27073568,
            27073477,
            27073304,
            27073689,
            27073228,
            27073014,
            27073894,
            27072703,
            27074273,
            27072442,
            27074226,
            27073723,
            27073830,
            27073779
        ],
        "A": [
            27072392,
            27072471,
            27072465,
            27072459,
            27072555,
            27072760,
            27072661,
            27072604,
            27072817,
            27072481,
            27072447,
            27072409,
            27072476,
            27072463,
            27072773,
            27072976,
            27072422,
            27074544,
            27072598
        ],
        "G": [
            27216394,
            27227867
        ]
    },
    "name": "A. Bank Robbery",
    "statement": "A robber has attempted to rob a bank but failed to complete his task.\r\nHowever, he had managed to open all the safes.Oleg the bank client loves\r\nmoney (who doesn\u2019t), and decides to take advantage of this failed\r\nrobbery and steal some money from the safes. There are many safes\r\narranged in a line, where the -th safe from the left is called safe .\r\nThere are banknotes left in all the safes in total. The -th banknote is\r\nin safe . Oleg is now at safe . There are two security guards, one of\r\nwhich guards the safe such that , i.e. the first guard is to the left of\r\nOleg. The other guard guards the safe so that , i.e. he is to the right\r\nof Oleg.The two guards are very lazy, so they do not move. In every\r\nsecond, Oleg can either take all the banknotes from the current safe or\r\nmove to any of the neighboring safes. However, he cannot visit any safe\r\nthat is guarded by security guards at any time, becaues he might be\r\ncharged for stealing. Determine the maximum amount of banknotes Oleg can\r\ngather.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\t\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tint n, ans = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif ((x > b) && (x < c)) ans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\A. Bank Robbery.json",
    "editorial_link": "https://codeforces.com/blog/entry/51962",
    "editorial": "This is a simple implementation problem. We iterate through all banknotes one by one and check if Oleg can take each of them. If a banknote is at position x, then Oleg can take it if and only if b?<?x?<?c. This can be checked in O(1) time. Thus, the total complexity is O(n). Note that the information on the starting position of Oleg is useless here."
}