{
    "link": "https://codeforces.com//contest/1810/problem/F",
    "problemId": "1858191",
    "problem_idx": "F",
    "shortId": "1810F",
    "contest_number": "1810",
    "problem_submissions": {
        "H": [
            200016390,
            200313241,
            200015282,
            200812601,
            200812580
        ],
        "G": [
            199990963,
            200002014,
            199996533,
            200001110,
            200003038,
            200004181,
            200005432,
            199993820,
            200004120,
            200568360,
            200010476,
            200003987,
            200009790,
            200084069,
            200013246,
            200017198,
            200016482,
            200017082
        ],
        "F": [
            199985968,
            199984766,
            199989455,
            199989236,
            199990364,
            199996618,
            199996912,
            199994977,
            200012837,
            199994874,
            200568272,
            200001624,
            200000551,
            200004906,
            200000508,
            200003276,
            200003731,
            200007640,
            199989234,
            200033060,
            200032756,
            200032417,
            199995728
        ],
        "E": [
            199973604,
            199973630,
            199978803,
            199976534,
            199977412,
            199980989,
            199981737,
            199978795,
            199980030,
            199987523,
            200568220,
            199981333,
            199992052,
            199984164,
            199985692,
            199981426,
            199983733,
            199981446,
            199972392,
            199985691
        ],
        "D": [
            199968387,
            199968634,
            199971474,
            199971965,
            199971391,
            199974445,
            199974261,
            199971649,
            199972646,
            199975130,
            200568168,
            199974978,
            199975450,
            199972122,
            199977461,
            199974856,
            199972685,
            199972896,
            199981843,
            199971530
        ],
        "C": [
            199963369,
            199964848,
            199966060,
            199965953,
            199966410,
            199967396,
            199960693,
            199966704,
            199968525,
            199967275,
            200567509,
            199968793,
            199967659,
            199965932,
            199965761,
            199966489,
            199966901,
            199965471,
            199965927,
            199965128
        ],
        "B": [
            199960187,
            199959404,
            199963381,
            199961597,
            199960246,
            199963356,
            199965608,
            199963400,
            199964087,
            199961201,
            200567461,
            199963792,
            199967959,
            199962648,
            199961478,
            199962690,
            199964055,
            199962786,
            199961957,
            199961076
        ],
        "A": [
            199957585,
            199957600,
            199957721,
            199957828,
            199957624,
            199957823,
            199967044,
            199957994,
            199959433,
            199957593,
            200567421,
            199957914,
            199957630,
            199957622,
            199957736,
            199957568,
            199959457,
            199957708,
            199957575,
            199957879
        ]
    },
    "name": "F. M-tree",
    "statement": "A rooted tree is called if every vertex of the tree either is a leaf (a\r\nvertex with no children) or has exactly m children.For a good tree, each\r\nleaf u has a positive integer c_{u} written on it, and we define the\r\nvalue of the leaf as c_{u} +\r\nmathrm{dep}_{u}, where\r\nmathrm{dep}_{u} represents the number of edges of the path from vertex u\r\nto the root (also known as the depth of u). The of a good tree is the\r\nvalue of all its leaves.Now, you are given an array of n integers a_{1},\r\na_{2},\r\nldots, a_{n}, which are the integers that should be written on the\r\nleaves. You need to construct a good tree with n leaves and write the\r\nintegers from the array a to all the leaves. Formally, you should assign\r\neach leaf u an index b_{u}, where b is a permutation of length n, and\r\nrepresent that the integer written on leaf u is c_u = a_{b_{u}}. Under\r\nthese constraints, you need to the value of the good tree.You have q\r\nqueries. Each query gives you x, y and changes a_{x} to y, and after\r\nthat, you should output the minimum value of a good tree based on the\r\ncurrent array a. A permutation of length n is an array consisting of n\r\ndistinct integers from 1 to n in arbitrary order. For example,\r\n[2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2\r\nappears twice in the array), and [1,3,4] is also not a permutation (n=3\r\nbut there is 4 in the array).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::map<int, int> f;\n    f[0] = 0;\n    \n    auto split = [&](int x) {\n        auto it = std::prev(f.upper_bound(x));\n        f[x] = it->second;\n    };\n    \n    auto add = [&](int x) {\n        split(x);\n        auto it = f.find(x);\n        while (it->second == m - 1) {\n            it = f.erase(it);\n        }\n        if (it->first > x) {\n            f[x] = 0;\n        }\n        split(it->first + 1);\n        it->second += 1;\n    };\n    \n    auto del = [&](int x) {\n        split(x);\n        auto it = f.find(x);\n        while (it->second == 0) {\n            it = f.erase(it);\n        }\n        if (it->first > x) {\n            f[x] = m - 1;\n        }\n        split(it->first + 1);\n        it->second -= 1;\n    };\n    \n    for (int i = 0; i < n; i++) {\n        add(a[i]);\n    }\n    \n    while (q--) {\n        int x, y;\n        std::cin >> x >> y;\n        x--;\n        del(a[x]);\n        add(a[x] = y);\n        \n        del(0);\n        \n        auto it = std::prev(f.end());\n        while (it != f.begin() && std::prev(it)->second == 0) {\n            it--;\n            f.erase(std::next(it));\n        }\n        std::cout << it->first << \" \\n\"[q == 0];\n        \n        add(0);\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "sortings",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. M-tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/114521",
    "editorial": "TutorialLet be the number of occurances of integer in the array . To\r\ncheck whether the answer can be or not, we can do the following greedy:\r\nStarting with a single vertex written , which is the root. For each\r\n(from large ones to small ones), if the number of current leaves is\r\nsmaller than , then we can not make the answer . Otherwise, let leaves\r\nstop, and other leaves âgrowâ children each(these vertices are no longer\r\nleaves, but their children are). We can discover that each round, the\r\nâstoppedâ vertices have , which represents their value is .We can use\r\nthe following code to calculate it. Since a negtive number multiplies is\r\nstill a negtive number, the code can be as following: Find out\r\nsomething? The final is just , which represents itâs equivalent to\r\nchecking ! So now the answer is just . This is the highest bit plus one\r\nof in -base representation(except for that itâs just some . In this case\r\nthe answer is but not ). We can use a segment tree, supporting interval\r\nmin/max query and interval covering to solve the question.\r\n",
    "hint": []
}