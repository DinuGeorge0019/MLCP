{"link": "https://codeforces.com//contest/1804/problem/F", "problemId": "1824145", "problem_idx": "F", "shortId": "1804F", "contest_number": "1804", "problem_submissions": {"H": [197133699, 197211600], "G": [197106837, 197116479, 197124948, 197127592, 197122958, 197137640, 197134544, 197138362], "F": [197093293, 197105349, 197095528, 197104786, 197106624, 197098643, 197101524, 197103930, 197102162, 197105107, 197108552, 197108666, 197107628, 197142671, 197140184, 197139967, 197139883, 197139641, 197111482, 197111626, 197113675, 197111909, 197110044, 197110987, 197113933], "E": [197089405, 197085286, 197090524, 197097633, 197097337, 197091345, 197092803, 197096473, 197096893, 197095376, 197096756, 197096855, 197096490, 197096936, 197101267, 197098474, 197101399, 197096360, 197103528, 197097046], "D": [197081706, 197080440, 197082836, 197086161, 197088893, 197081349, 197083999, 197084952, 197086950, 197076993, 197086858, 197086874, 197084897, 197084889, 197084721, 197084970, 197089163, 197084662, 197086535, 197082927], "C": [197078079, 197076920, 197078785, 197081523, 197083238, 197076107, 197077574, 197078670, 197077463, 197082879, 197080775, 197081089, 197078608, 197079622, 197080414, 197078487, 197079270, 197080239, 197080507, 197079932], "B": [197075523, 197075248, 197075383, 197077168, 197080868, 197074547, 197074457, 197076648, 197075635, 197080800, 197077487, 197076188, 197075795, 197076995, 197076635, 197075839, 197076655, 197076988, 197077650, 197075789], "A": [197073420, 197073942, 197073446, 197073814, 197078430, 197073370, 197073351, 197073646, 197073456, 197078319, 197074505, 197073977, 197073328, 197073488, 197073501, 197073461, 197073950, 197074331, 197075653, 197073687]}, "name": "F. Approximate Diameter", "statement": "Jack has a graph of n vertices and m edges. All edges are bidirectional\r\nand of unit length. The graph is connected, i. e. there exists a path\r\nbetween any two of its vertices. There can be more than one edge\r\nconnecting the same pair of vertices. The graph can contain self-loops,\r\ni. e. edges connecting a node to itself.The distance between vertices u\r\nand v is denoted as\r\nrho(u, v) and equals the minimum possible number of edges on a path\r\nbetween u and v. The diameter of graph G is defined as the maximum\r\npossible distance between some pair of its vertices. We denote it as\r\nd(G). In other words, d(G) =\r\nmax_{1\r\nle u, v\r\nle n}{\r\nrho(u, v)}.Jack plans to consecutively apply q updates to his graph.\r\nEach update adds exactly one edge to the graph. Denote as G_i the graph\r\nafter exactly i updates are made. Jack wants to calculate q + 1 values\r\nd(G_0), d(G_1), d(G_2),\r\nldots, d(G_q).However, Jack suspects that finding the exact diameters of\r\nq + 1 graphs might be a difficult task, so he is fine with approximate\r\nanswers that differ from the correct answers no more than twice.\r\nFormally, Jack wants to find a sequence of positive integers a_0, a_1,\r\na_2,\r\nldots, a_q such that\r\nleft\r\nlceil\r\nfrac{d(G_i)}{2}\r\nright\r\nrceil\r\nle a_i\r\nle 2\r\ncdot d(G_i) for each i.You cannot make hacks in this problem.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].emplace_back(v, 0);\n        adj[v].emplace_back(u, 0);\n    }\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].emplace_back(v, i + 1);\n        adj[v].emplace_back(u, i + 1);\n    }\n    \n    auto get = [&](int t) {\n        std::queue<int> q;\n        std::vector<int> dis(n, -1);\n        q.push(0);\n        dis[0] = 0;\n        while (!q.empty()) {\n            int x = q.front();\n            q.pop();\n            for (auto [y, w] : adj[x]) {\n                if (w <= t && dis[y] == -1) {\n                    dis[y] = dis[x] + 1;\n                    q.push(y);\n                }\n            }\n        }\n        return *std::max_element(dis.begin(), dis.end());\n    };\n    \n    std::vector<int> ans(q + 1);\n    for (int i = 0; i < q + 1; ) {\n        int val = get(i);\n        int lo = i + 1, hi = q + 1;\n        while (lo < hi) {\n            int x = (lo + hi) / 2;\n            if (2 * get(x) < val) {\n                hi = x;\n            } else {\n                lo = x + 1;\n            }\n        }\n        while (i < lo) {\n            ans[i] = val;\n            i += 1;\n        }\n    }\n    for (int i = 0; i <= q; i++) {\n        std::cout << ans[i] << \" \\n\"[i == q];\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "divide and conquer", "graphs", "shortest paths"], "dificulty": "2700", "interactive": false}