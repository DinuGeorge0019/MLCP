{
    "link": "https://codeforces.com//contest/1804/problem/F",
    "problemId": "1824145",
    "problem_idx": "F",
    "shortId": "1804F",
    "contest_number": "1804",
    "problem_submissions": {
        "H": [
            197133699,
            197211600
        ],
        "G": [
            197106837,
            197116479,
            197124948,
            197127592,
            197122958,
            197137640,
            197134544,
            197138362
        ],
        "F": [
            197093293,
            197105349,
            197095528,
            197104786,
            197106624,
            197098643,
            197101524,
            197103930,
            197102162,
            197105107,
            197108552,
            197108666,
            197107628,
            197142671,
            197140184,
            197139967,
            197139883,
            197139641,
            197111482,
            197111626,
            197113675,
            197111909,
            197110044,
            197110987,
            197113933
        ],
        "E": [
            197089405,
            197085286,
            197090524,
            197097633,
            197097337,
            197091345,
            197092803,
            197096473,
            197096893,
            197095376,
            197096756,
            197096855,
            197096490,
            197096936,
            197101267,
            197098474,
            197101399,
            197096360,
            197103528,
            197097046
        ],
        "D": [
            197081706,
            197080440,
            197082836,
            197086161,
            197088893,
            197081349,
            197083999,
            197084952,
            197086950,
            197076993,
            197086858,
            197086874,
            197084897,
            197084889,
            197084721,
            197084970,
            197089163,
            197084662,
            197086535,
            197082927
        ],
        "C": [
            197078079,
            197076920,
            197078785,
            197081523,
            197083238,
            197076107,
            197077574,
            197078670,
            197077463,
            197082879,
            197080775,
            197081089,
            197078608,
            197079622,
            197080414,
            197078487,
            197079270,
            197080239,
            197080507,
            197079932
        ],
        "B": [
            197075523,
            197075248,
            197075383,
            197077168,
            197080868,
            197074547,
            197074457,
            197076648,
            197075635,
            197080800,
            197077487,
            197076188,
            197075795,
            197076995,
            197076635,
            197075839,
            197076655,
            197076988,
            197077650,
            197075789
        ],
        "A": [
            197073420,
            197073942,
            197073446,
            197073814,
            197078430,
            197073370,
            197073351,
            197073646,
            197073456,
            197078319,
            197074505,
            197073977,
            197073328,
            197073488,
            197073501,
            197073461,
            197073950,
            197074331,
            197075653,
            197073687
        ]
    },
    "name": "F. Approximate Diameter",
    "statement": "Jack has a graph of n vertices and m edges. All edges are bidirectional\r\nand of unit length. The graph is connected, i. e. there exists a path\r\nbetween any two of its vertices. There can be more than one edge\r\nconnecting the same pair of vertices. The graph can contain self-loops,\r\ni. e. edges connecting a node to itself.The distance between vertices u\r\nand v is denoted as\r\nrho(u, v) and equals the minimum possible number of edges on a path\r\nbetween u and v. The diameter of graph G is defined as the maximum\r\npossible distance between some pair of its vertices. We denote it as\r\nd(G). In other words, d(G) =\r\nmax_{1\r\nle u, v\r\nle n}{\r\nrho(u, v)}.Jack plans to consecutively apply q updates to his graph.\r\nEach update adds exactly one edge to the graph. Denote as G_i the graph\r\nafter exactly i updates are made. Jack wants to calculate q + 1 values\r\nd(G_0), d(G_1), d(G_2),\r\nldots, d(G_q).However, Jack suspects that finding the exact diameters of\r\nq + 1 graphs might be a difficult task, so he is fine with approximate\r\nanswers that differ from the correct answers no more than twice.\r\nFormally, Jack wants to find a sequence of positive integers a_0, a_1,\r\na_2,\r\nldots, a_q such that\r\nleft\r\nlceil\r\nfrac{d(G_i)}{2}\r\nright\r\nrceil\r\nle a_i\r\nle 2\r\ncdot d(G_i) for each i.You cannot make hacks in this problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m, q;\n    std::cin >> n >> m >> q;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].emplace_back(v, 0);\n        adj[v].emplace_back(u, 0);\n    }\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].emplace_back(v, i + 1);\n        adj[v].emplace_back(u, i + 1);\n    }\n    \n    auto get = [&](int t) {\n        std::queue<int> q;\n        std::vector<int> dis(n, -1);\n        q.push(0);\n        dis[0] = 0;\n        while (!q.empty()) {\n            int x = q.front();\n            q.pop();\n            for (auto [y, w] : adj[x]) {\n                if (w <= t && dis[y] == -1) {\n                    dis[y] = dis[x] + 1;\n                    q.push(y);\n                }\n            }\n        }\n        return *std::max_element(dis.begin(), dis.end());\n    };\n    \n    std::vector<int> ans(q + 1);\n    for (int i = 0; i < q + 1; ) {\n        int val = get(i);\n        int lo = i + 1, hi = q + 1;\n        while (lo < hi) {\n            int x = (lo + hi) / 2;\n            if (2 * get(x) < val) {\n                hi = x;\n            } else {\n                lo = x + 1;\n            }\n        }\n        while (i < lo) {\n            ans[i] = val;\n            i += 1;\n        }\n    }\n    for (int i = 0; i <= q; i++) {\n        std::cout << ans[i] << \" \\n\"[i == q];\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "divide and conquer",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Approximate Diameter.json",
    "editorial_link": "https://codeforces.com//blog/entry/113830",
    "editorial": "Letâs recall some definitions to start with.\r\nrho_G(u, v) is the length of the shortest path between vertices u and v\r\nin graph G. Define as c_G(u) the maximum distance from vertex u to some\r\nother vertex of graph G. c_G(u) =\r\nmax_{v\r\nin V(G)}\r\nrho(u, v). d(G) =\r\nmax_{u, v\r\nin V(G)}\r\nrho(u, v) =\r\nmax_{u\r\nin V(G)} c_G(u) is called the diameter of graph G. It is the maximum\r\ndistance between some pair of vertices of graph G. r(G) =\r\nmin_{u\r\nin V(G)}\r\nmax_{v\r\nin V(G)}\r\nrho(u, v) =\r\nmin_{u\r\nin V(G)} c(u) is called the radius of graph G. It is the minimum\r\npossible distance from one vertex of the graph to the farthest from it\r\nvertex of this graph. The key inequality we will use for this problem\r\nsolution is the following. Let v be arbitrary vertex of graph G.\r\nfrac{d(G)}{2}\r\nleq r(G)\r\nleq c_G(v)\r\nleq d(G)\r\nleq 2\r\ncdot r(G)\r\nleq 2\r\ncdot c_G(v)\r\nleq 2\r\ncdot d(G) r(G)\r\nleq c_G(v)\r\nleq d(G) by definition. d(G)\r\nleq 2\r\ncdot r(G) because of triangle inequality. All other inequalities are\r\nderived from the first two items. The good thing is that we can compute\r\nc_G(v) in linear time using BFS algorithm. Now we can solve the problem\r\nin O(q\r\ncdot (n + m + q)) time. It is important to note that the task tolerates\r\nerrors both ways, so any value between c_{G_i}(v) and 2\r\ncdot c_{G_i}(v) will be a correct approximation of d(G_i).The next key\r\nobservation is that the sequence of d_i(G) is non-increasing. If i < j\r\nand c_{G_i}(v)\r\nleq 2\r\ncdot c_{G_j}(v) we can use 2\r\ncdot c_{G_j}(v) as an approximation for d(G_{i + 1}), d(G_{i + 2}),\r\nldots, d(G_{j - 1}).Using the idea above we can do one of the following.\r\nHaving the correct value of c_{G_i}(v) we can use the binary search to\r\nfind the maximum j such that c_{G_i}(v)\r\nleq 2\r\ncdot c_{G_j}(v) in\r\nlog{q} iterations. Use divide&conquer with the stop condition c_{G_l}(v)\r\nleq 2\r\ncdot c_{G_r}(v). That would actually work a way more faster (up to five\r\ntimes) as it re-uses the information very efficiently. Thus, we have a\r\nsolion that runs BFS no more than\r\nlog{n}\r\ncdot\r\nlog{q} times. The overall complexity is O(\r\nlog{n}\r\ncdot\r\nlog{q}\r\ncdot (n + m + q)).How did we get the correct answers for the checker? We\r\nprecomputed them using the power of distributed computing. We are a\r\ncloud technology company after all!Bonus question, can you guess the\r\ntotal number of cpu-days we have used to compute all the answers? Post\r\nyou version in the comments!\r\n",
    "hint": []
}