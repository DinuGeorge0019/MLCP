{
    "link": "https://codeforces.com//contest/1037/problem/G",
    "problemId": "214576",
    "problem_idx": "G",
    "shortId": "1037G",
    "contest_number": "1037",
    "problem_submissions": {
        "G": [
            42400284,
            42399505,
            42393700,
            42391956,
            42395688,
            49109531,
            42416815,
            42416802,
            42408231,
            42478375,
            42723385,
            42723256
        ],
        "H": [
            42390789,
            42393047,
            42400959,
            42399660,
            42398441,
            42399087,
            42414998,
            42453023,
            42876495,
            42876025,
            42875988,
            42875931
        ],
        "E": [
            42383633,
            42376516,
            42374024,
            42375460,
            42374374,
            42376325,
            42382856,
            42374364,
            42376990,
            42377973,
            42378251,
            42378271,
            42378643,
            42380819,
            42380647,
            42383308,
            42382412,
            42381355
        ],
        "F": [
            42381395,
            42382506,
            42383872,
            42380708,
            42386216,
            42379786,
            42391156,
            42378290,
            42387714,
            42379959,
            42384150,
            42386649,
            42388704,
            42386435,
            42387614,
            42390065,
            42389970,
            42390483
        ],
        "D": [
            42369087,
            42370798,
            42380041,
            42371136,
            42379827,
            42374961,
            42370290,
            42370315,
            42380263,
            42370259,
            42374008,
            42373176,
            42374905,
            42371349,
            42379998,
            42373150,
            42374030
        ],
        "C": [
            42367060,
            42368485,
            42368461,
            42367940,
            42368563,
            42368341,
            42378567,
            42367842,
            42367459,
            42369272,
            42375102,
            42369783,
            42370363,
            42370761,
            42367752,
            42376902,
            42370198,
            42370636
        ],
        "B": [
            42366092,
            42367373,
            42367083,
            42366507,
            42366793,
            42366735,
            42367983,
            42366366,
            42366278,
            42367057,
            42372146,
            42367428,
            42368851,
            42367360,
            42366696,
            42366630,
            42368278,
            42367696
        ],
        "A": [
            42365839,
            42365922,
            42366199,
            42365850,
            42365879,
            42366070,
            42366134,
            42365823,
            42365810,
            42366029,
            42366879,
            43951943,
            42366275,
            42367664,
            42365933,
            42365869,
            42365891,
            42366540,
            42366060
        ]
    },
    "name": "G. A Game on Strings",
    "statement": "Alice and Bob are playing a game on strings.Initially, they have some\r\nstring t. In one move the first player selects the character c present\r\nin t and erases all it\u2019s occurrences in t, thus splitting t into many\r\nsmaller strings. The game then goes independently with each of the\r\nstrings to make the move player selects one of the strings and one of\r\nthe characters there, deletes all occurrences and adds the remaining\r\nstring back to the game.Alice always starts the game, and then Alice and\r\nBob take turns making moves. The player who is unable to make a move\r\n(because there is no string left) loses.Alice and Bob used to always\r\nstart with a string s, but recently they found out that this became too\r\nboring. Now before each game they choose two integers l and r such that\r\n1\r\nle l\r\nle r\r\nle |s| and play the game with the string s_{l} s_{l+1} s_{l+2}\r\nldots s_{r} instead.Given the string s and integers l, r for each game.\r\nFind who is going to win each game assuming they are smart and are\r\nplaying optimally.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 02.09.2018 19:09:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int ALPHA = 26;\nconst int MAX_G = 32;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string foo;\n  cin >> foo;\n  int n = (int) foo.size();\n  vector<int> s(n);\n  for (int i = 0; i < n; i++) {\n    s[i] = (int) (foo[i] - 'a');\n  }\n  vector<vector<int>> nxt(n + 1, vector<int>(ALPHA));\n  for (int c = 0; c < ALPHA; c++) {\n    nxt[n][c] = n;\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    for (int c = 0; c < ALPHA; c++) {\n      nxt[i][c] = nxt[i + 1][c];\n    }\n    nxt[i][s[i]] = i;\n  }\n  vector<vector<int>> prv(n + 1, vector<int>(ALPHA));\n  for (int c = 0; c < ALPHA; c++) {\n    prv[0][c] = -1;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int c = 0; c < ALPHA; c++) {\n      prv[i + 1][c] = prv[i][c];\n    }\n    prv[i + 1][s[i]] = i;\n  }\n  int m;\n  cin >> m;\n  vector<int> from(m), to(m);\n  for (int i = 0; i < m; i++) {\n    cin >> from[i] >> to[i];\n    from[i]--; to[i]--;\n  }\n  vector<vector<int>> add(n);\n  for (int i = 0; i < m; i++) {\n    add[from[i]].push_back(to[i]);\n    for (int c = 0; c < ALPHA; c++) {\n      int j = prv[to[i] + 1][c];\n      if (j < to[i] && j >= from[i]) {\n        add[j + 1].push_back(to[i]);\n      }\n    }\n  }\n  vector<vector<int>> rs(n);\n  vector<vector<int>> dp(n);\n  auto get_dp = [&](int i, int j) {\n    if (i > j) {\n      return 0;\n    }\n    auto it = lower_bound(rs[i].begin(), rs[i].end(), j);\n    assert(!(it == rs[i].end() || *it != j));\n    int pos = (int) (it - rs[i].begin());\n    return dp[i][pos];\n  };\n  vector<vector<int>> get_dp_to(n + 1, vector<int>(ALPHA));\n  vector<vector<int>> get_dp_from(n + 1, vector<int>(ALPHA));\n  vector<int> xorval(n + 1, 0);\n  vector<int> touched(MAX_G, 0);\n  int iter = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    if (i < n - 1) {\n      int j = nxt[i + 1][s[i]];\n      xorval[i] = xorval[j] ^ get_dp(i + 1, j - 1);\n    }\n    for (int c = 0; c < ALPHA; c++) {\n      if (nxt[i][c] != n && nxt[i][c] != i) {\n        rs[i].push_back(nxt[i][c] - 1);\n      }\n    }\n    rs[i].push_back(n - 1);\n    for (int j : add[i]) {\n      rs[i].push_back(j);\n    }\n    sort(rs[i].begin(), rs[i].end());\n    rs[i].resize(unique(rs[i].begin(), rs[i].end()) - rs[i].begin());\n    dp[i].resize(rs[i].size());\n    for (int jt = 0; jt < (int) rs[i].size(); jt++) {\n      int j = rs[i][jt];\n      iter++;\n      for (int c = 0; c < ALPHA; c++) {\n        if (nxt[i][c] > j) {\n          continue;\n        }\n        int A = nxt[i][c];\n        int B = prv[j + 1][c];\n        int cur = 0;\n        if (A > i) {\n          cur ^= get_dp_to[i][c];\n        }\n        if (B < j) {\n          cur ^= get_dp_from[j][c];\n        }\n        cur ^= xorval[A] ^ xorval[B];\n        touched[cur] = iter;\n      }\n      int &res = dp[i][jt];\n      res = 0;\n      while (touched[res] == iter) {\n        res++;\n      }\n      if (j < n - 1) {\n        if (nxt[i][s[j + 1]] == j + 1) {\n          get_dp_to[i][s[j + 1]] = res;\n        }\n      }\n      if (i > 0) {\n        if (prv[j + 1][s[i - 1]] == i - 1) {\n          get_dp_from[j][s[i - 1]] = res;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    int x = get_dp(from[i], to[i]);\n    cout << (x > 0 ? \"Alice\" : \"Bob\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. A Game on Strings.json",
    "editorial_link": "https://codeforces.com/blog/entry/61606",
    "editorial": "Say, we have a string . For each character, say , has at positions .Now,\r\nif we calculate grundy for strings for , and also for every prefix and\r\nsuffix for such strings, we can calculate the result using grundy.For a\r\nquery , we can iterate on the character removed in first move, and the\r\nresultant grundy number can be calculated using range xor of the\r\nprecomputed grundys.To precalculate grundys, we can compute grundy in\r\nsorted order of length and treat them as separate queries.\r\n"
}