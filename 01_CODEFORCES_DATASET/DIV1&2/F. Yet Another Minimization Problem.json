{
    "link": "https://codeforces.com//contest/868/problem/F",
    "problemId": "126221",
    "problem_idx": "F",
    "shortId": "868F",
    "contest_number": "868",
    "problem_submissions": {
        "E": [
            31023051,
            31024523,
            31024148,
            31025167,
            31018209,
            31025864,
            31026369,
            31028260,
            31026372,
            31044397,
            31026066,
            31027557,
            31023308,
            31023861,
            31019541,
            31162068,
            31021787
        ],
        "F": [
            31020755,
            31020638,
            33743391,
            31021116,
            31022470,
            31023238,
            31022737,
            31023926,
            31023102,
            31028638,
            31028134,
            31020706,
            31027648,
            31019840,
            31023078,
            31023660,
            31027919
        ],
        "D": [
            31018151,
            31017707,
            31016713,
            31018303,
            31025757,
            31018243,
            31018489,
            31024010,
            31018691,
            31020147,
            31017621,
            31017612,
            31016732,
            31017515,
            31015826,
            31017997,
            31021417
        ],
        "C": [
            31014273,
            31014407,
            31012209,
            31014307,
            31013815,
            31013945,
            31015314,
            31013335,
            31014790,
            31016275,
            31030598,
            31013440,
            31030706,
            31066551,
            31014026,
            31012823,
            31014457,
            31014258,
            31016540
        ],
        "B": [
            31013104,
            31012812,
            31013438,
            31013042,
            31012539,
            31026919,
            31016195,
            31015461,
            31013166,
            31014218,
            31022627,
            31012140,
            31012861,
            31016249,
            31011794,
            31012575,
            31013032,
            31014544
        ],
        "A": [
            31010698,
            31010763,
            31010903,
            31010896,
            31010747,
            31010833,
            31010957,
            31012028,
            31010858,
            31021512,
            31010696,
            31010727,
            31012054,
            31010635,
            31010757,
            31011798,
            31010661
        ],
        "G": [
            31179602
        ]
    },
    "name": "F. Yet Another Minimization Problem",
    "statement": "You are given an array of integers . The cost of a subsegment is the\r\nnumber of unordered pairs of distinct indices within the subsegment that\r\ncontain equal elements. Split the given array into non-intersecting\r\nnon-empty subsegments so that the sum of their costs is minimum\r\npossible. Each element should be present in exactly one subsegment.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nint a[100001];\nlong long d[22][100001];\nlong long tt;\nint b[100001];\nint L, R;\n\ninline void add(int x) {\n\ttt += b[x];\n\tb[x]++;\n}\n\ninline void sub(int x) {\n\tb[x]--;\n\ttt -= b[x];\n}\n\ninline void moveL(int tL) {\n\twhile (L < tL) sub(a[++L]);\n\twhile (L > tL) add(a[L--]);\n}\n\ninline void moveR(int tR) {\n\twhile (R < tR) add(a[++R]);\n\twhile (R > tR) sub(a[R--]);\n}\n\nint main() {\n\tqueue<tuple<int, int, int, int> > q;\n\tint i, j, k, n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\td[0][i] = 1e18;\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tq.emplace(1, n, 0, n - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint S, E, L, R, M;\n\t\t\ttie(S, E, L, R) = q.front();\n\t\t\tq.pop();\n\t\t\tif (S > E) continue;\n\t\t\tM = S + E >> 1;\n\t\t\tmoveR(M);\n\t\t\td[i][M] = 1e18;\n\t\t\tfor (j = k = L; j <= R && j < M; j++) {\n\t\t\t\tmoveL(j);\n\t\t\t\tlong long t = d[i - 1][j] + tt;\n\t\t\t\tif (t < d[i][M]) {\n\t\t\t\t\td[i][M] = t;\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.emplace(S, M - 1, L, k);\n\t\t\tq.emplace(M + 1, E, k, R);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", d[m][n]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Yet Another Minimization Problem.json",
    "editorial_link": "https://codeforces.com/blog/entry/55046",
    "editorial": "First, let us solve the problem in time with a simple DP. Let be the\r\nsmallest cost of a partition of first elements into parts. Clearly, . We\r\ncan optimize the cost computation by moving from right to left and\r\nmaintaining frequency for each element, since by introducing an element\r\ninto the segment, we increase the cost by the number of occurences of\r\n.To optimize this further, let us note that the (leftmost) optimal value\r\nof for a particular is monotonous in on any step . Indeed, suppose that\r\n, and for . But , since introducing an element into a segment is at\r\nleast as costly as introducing it into a segment . Finally, , and ,\r\nwhich contradicts the optimality of .We can now apply the\r\n\"divide-and-conquer\" DP optimization: suppose that for a segment we know\r\nthat for each . Choose as the midpoint of and find by explicitly trying\r\nall values in . We now proceed recursively into segments with , and with\r\n. Assuming unit cost for computation, one can show that the computation\r\nof all values of for a particular takes time.The final detail is that\r\nthe time needed to compute can be made amortized constant (that is, in\r\ntotal per layer) if we store the value from the parent segment, and\r\nadd/remove segment elements one by one to obtain all subsequent values.\r\nThe total complexity is now .\r\n"
}