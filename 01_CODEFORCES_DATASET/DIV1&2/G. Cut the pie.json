{
    "link": "https://codeforces.com//contest/799/problem/G",
    "problemId": "105989",
    "problem_idx": "G",
    "shortId": "799G",
    "contest_number": "799",
    "problem_submissions": {
        "E": [
            27057040,
            27057010,
            27056967,
            27026697,
            27023753,
            27025405,
            27024865,
            27030424,
            27025641,
            27029307,
            27027415,
            27027135,
            27026445,
            27030147,
            27029255,
            27030374,
            27031127,
            27029721,
            27029453,
            27032096
        ],
        "G": [
            27036616
        ],
        "F": [
            27030563,
            27037422,
            27034476,
            27039260,
            27041363,
            27040801,
            27291324
        ],
        "D": [
            27022631,
            27022286,
            27020681,
            27021344,
            27021554,
            27023148,
            27022862,
            27020910,
            27023070,
            27022767,
            27023676,
            27022207,
            27023905,
            27022671,
            27022391,
            27023340,
            27022748,
            27022866
        ],
        "B": [
            27019416,
            27017594,
            27035489,
            27019723,
            27017243,
            27017666,
            27017468,
            27016992,
            27017464,
            27018383,
            27017219,
            27017196,
            27017940,
            27020412,
            27017770,
            27018390,
            27017823,
            27017563
        ],
        "C": [
            27018858,
            27019675,
            27018439,
            27017585,
            27019861,
            27019164,
            27019715,
            27019543,
            27019587,
            27021111,
            27021089,
            27019694,
            27020343,
            27018899,
            27020067,
            27020926,
            27019896,
            27020090
        ],
        "A": [
            27018375,
            27016569,
            27037894,
            27018311,
            27016502,
            27016795,
            27016557,
            27016497,
            27016519,
            27016617,
            27016531,
            27016564,
            27016580,
            27016596,
            27016533,
            27016606,
            27016598,
            27016653
        ]
    },
    "name": "G. Cut the pie",
    "statement": "Arkady reached the -th level in Township game, so Masha decided to bake\r\na pie for him! Of course, the pie has a shape of convex -gon, i.e. a\r\npolygon with vertices.Arkady decided to cut the pie in two equal in area\r\nparts by cutting it by a straight line, so that he can eat one of them\r\nand give the other to Masha. There is a difficulty because Arkady has\r\nalready put a knife at some point of the pie, so he now has to cut the\r\npie by a straight line passing trough this point.Help Arkady: find a\r\nline that passes through the point Arkady has put a knife into and cuts\r\nthe pie into two parts of equal area, or determine that it\u2019s impossible.\r\nYour program has to quickly answer many queries with the same pie, but\r\ndifferent points in which Arkady puts a knife.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double pi = acos(-1.0);\n\nconst int N = 1234567;\n\nint x[N], y[N];\nint n;\ndouble areas[N];\n\nvoid line(int i, int j, double &a, double &b, double &c) {\n  i %= n;\n  j %= n;\n  a = y[j] - y[i];\n  b = x[i] - x[j];\n  c = -a * x[i] - b * y[i];\n}\n\nvoid intersect(double a, double b, double c, double aa, double bb, double cc, double &dx, double &dy) {\n  double d = a * bb - b * aa;\n  dx = (b * cc - c * bb) / d;\n  dy = (c * aa - a * cc) / d;\n}\n\nint main() {\n  int q;\n  scanf(\"%d %d\", &n, &q);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", x + i, y + i);\n  }\n  reverse(x, x + n);\n  reverse(y, y + n);\n  areas[0] = 0;\n  for (int i = 0; i < 4 * n; i++) {\n    areas[i + 1] = areas[i] + (x[i % n] - x[(i + 1) % n]) * 1.0 * (y[i % n] + y[(i + 1) % n]);\n  }\n  double total_area = 0.0;\n  for (int i = 0; i < n; i++) {\n    total_area += (x[i] - x[(i + 1) % n]) * 1.0 * (y[i] + y[(i + 1) % n]);\n  }\n  for (int i = 0; i < q; i++) {\n    int qx, qy;\n    scanf(\"%d %d\", &qx, &qy);\n    double low = 0, high = pi;\n    double zero = -1.0;\n    bool found = false;\n    double ans = -1.0;\n    for (int it = 0; it < 60; it++) {\n      double mid = 0.5 * (low + high);\n      if (mid == low || mid == high) {\n        break;\n      }\n      if (it == 0) {\n        mid = low;\n      }\n      double dx = cos(mid);\n      double dy = sin(mid);\n      double a = dy;\n      double b = -dx;\n      double c = -a * qx - b * qy;\n      double u0 = a * x[0] + b * y[0] + c;\n      double u1 = a * x[1] + b * y[1] + c;\n      bool flag = false;\n      if (u0 > u1) {\n        flag = true;\n        u0 = -u0;\n        u1 = -u1;\n        a = -a;\n        b = -b;\n        c = -c;\n      }\n      int ll = 0, rr = n - 1;\n      while (ll < rr) {\n        int i = (ll + rr + 1) >> 1;\n        int j = (i + 1) % n;\n        double ui = a * x[i] + b * y[i] + c;\n        double uj = a * x[j] + b * y[j] + c;\n        if (ui <= uj && ui >= 0.5 * (u0 + u1)) {\n          ll = i;\n        } else {\n          rr = i - 1;\n        }\n      }\n      int id_max = (ll + 1) % n;\n      ll = id_max + 1, rr = id_max + n - 1;\n      while (ll < rr) {\n        int i = (ll + rr) >> 1;\n        int j = i + 1;\n        double ui = a * x[i % n] + b * y[i % n] + c;\n        double uj = a * x[j % n] + b * y[j % n] + c;\n        if (ui > uj) {\n          ll = i + 1;\n        } else {\n          rr = i;\n        }\n      }\n      int id_min = ll;\n      int last, first;\n      {\n        ll = id_max, rr = id_min;\n        while (ll < rr) {\n          int i = (ll + rr + 1) >> 1;\n          double ui = a * x[i % n] + b * y[i % n] + c;\n          if (ui > 0) {\n            ll = i;\n          } else {\n            rr = i - 1;\n          }\n        }\n        last = ll + n;\n      }\n      {\n        ll = id_min, rr = id_max + n;\n        while (ll < rr) {\n          int i = (ll + rr) >> 1;\n          double ui = a * x[i % n] + b * y[i % n] + c;\n          if (ui < 0) {\n            ll = i + 1;\n          } else {\n            rr = i;\n          }\n        }\n        first = ll;\n      }\n      double xf, yf, xl, yl;\n      double aa, bb, cc;\n      line(first - 1, first, aa, bb, cc);\n      intersect(a, b, c, aa, bb, cc, xf, yf);\n      line(last, last + 1, aa, bb, cc);\n      intersect(a, b, c, aa, bb, cc, xl, yl);\n      double res = 0.0;\n      res += (xf - x[first % n]) * (yf + y[first % n]);\n      res += areas[last] - areas[first];\n      res += (x[last % n] - xl) * (y[last % n] + yl);\n      res += (xl - xf) * (yl + yf);\n      if (flag) {\n        res = total_area - res;\n      }\n      if (it == 0) {\n        zero = res;\n        continue;\n      }\n      {\n        // checking\n        double res1 = 0.5 * res;\n        double res2 = 0.5 * (total_area - res);\n        double diff = fabs(res1 - res2);\n        double sum = 0.5 * total_area;\n        if (diff / sum < 1e-6) {\n          found = true;\n          ans = mid;\n          break;\n        }\n      }\n      if ((res > 0.5 * total_area) == (zero > 0.5 * total_area)) {\n        low = mid;\n      } else {\n        high = mid;\n      }\n    }\n    printf(\"%.17f\\n\", found ? ans : (0.5 * (low + high)));\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "geometry"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Cut the pie.json",
    "editorial_link": "https://codeforces.com/blog/entry/51947",
    "editorial": "Let\u00e2\u0080\u0099s first prove that solution always exists. Define as the difference\r\nbetween the area of the polygon part contained in the halfplane with\r\npolar angles in range and the area of the polygon part contained in the\r\nhalfplane with polar angles in range . Note that , and since is a\r\ncontinuous function, it reaches zero somewhere on .The proof leads us to\r\nthe concept of a solution. If we can compute fast, we can do a binary\r\nsearch over to find the root. Computing consists of two parts. First, we\r\nshould find the intersection points of the line with the polygon, it is\r\na known problem which can be solved in . Second, we should compute the\r\narea, and there we can use prefix sums for oriented triangle (the origin\r\nand a polygon edge) areas that we use to compute the area of the whole\r\npolygon. The only thing we have to add is the oriented area of three new\r\nsegments, that is easy to compute. The overall complexity is , where is\r\nthe required precision. Note that the angle precision should be more\r\naccurate than the required area precision.\r\n"
}