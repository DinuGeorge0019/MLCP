{
    "link": "https://codeforces.com//contest/1586/problem/E",
    "problemId": "1147385",
    "problem_idx": "E",
    "shortId": "1586E",
    "contest_number": "1586",
    "problem_submissions": {
        "I": [
            132349267,
            132252923,
            132320064,
            132673395,
            132289506,
            132263256
        ],
        "H": [
            132247560,
            132253721,
            134930470,
            132350321,
            132254025,
            132660661,
            132275048,
            132253966,
            132270155
        ],
        "G": [
            132239647,
            132244340,
            132241119,
            135794866,
            135794713,
            132234650,
            132248115,
            132244256,
            132257761,
            132255193,
            132256199,
            132255919,
            132258648,
            132257515,
            132250742,
            132255333,
            132257553,
            132255311
        ],
        "F": [
            132231955,
            132236161,
            132234366,
            132240633,
            132243967,
            132235859,
            132234337,
            132237395,
            132239493,
            132241376,
            132248866,
            132245654,
            132241416,
            132246161,
            132245018,
            132259456,
            132244979,
            132249686,
            132260019,
            132238761
        ],
        "E": [
            132228491,
            132224206,
            132228693,
            132232413,
            132231532,
            132229745,
            132230672,
            132232315,
            132218494,
            132235319,
            132232020,
            132237413,
            132239524,
            132237023,
            132236410,
            132236319,
            132238669,
            132240928,
            132230421,
            132229492
        ],
        "D": [
            132225001,
            132227375,
            132224444,
            132226879,
            132227724,
            132226231,
            132226626,
            132227371,
            132224235,
            132227654,
            132224635,
            132229641,
            132234990,
            132231067,
            132230536,
            132228432,
            132234258,
            132232998,
            132241147,
            132223955
        ],
        "C": [
            132221243,
            132218519,
            132219460,
            132219748,
            132219799,
            132222571,
            132220819,
            132219850,
            132232802,
            132223481,
            132218757,
            132219927,
            132230956,
            132218216,
            132224263,
            132222192,
            132227273,
            132228072,
            132226595,
            132220025
        ],
        "B": [
            132214722,
            132213701,
            132215490,
            132214516,
            132214317,
            132214601,
            132215162,
            132222197,
            132229955,
            132216968,
            132214347,
            132216468,
            132226751,
            132220812,
            132216772,
            132216742,
            132216324,
            132213579,
            132217316,
            132213929
        ],
        "A": [
            132213139,
            132213078,
            132214020,
            132213141,
            132213243,
            132213267,
            132213377,
            132220659,
            132228179,
            132218691,
            132213234,
            132214356,
            132213033,
            132224973,
            132214120,
            132214349,
            132213337,
            132213011,
            132242338,
            132213128
        ]
    },
    "name": "E. Moment of Bloom",
    "statement": "Hu Tao, being the little prankster she is, has tried to scare you with\r\nthis graph problem! You are given a connected undirected graph of n\r\nnodes with m edges. You also have q queries. Each query consists of two\r\nnodes a and b.Initially, all edges in the graph have a weight of 0. For\r\neach query, you must choose a simple path starting from a and ending at\r\nb. Then you add 1 to every edge along this path. Determine if it\u2019s\r\npossible, after processing all q queries, for all edges in this graph to\r\nhave an even weight. If so, output the choice of paths for each query.\r\nIf it is not possible, determine the smallest number of extra queries\r\nyou could add to make it possible. It can be shown that this number will\r\nnot exceed 10^{18} under the given constraints.A simple path is defined\r\nas any path that does not visit a node more than once.An edge is said to\r\nhave an even weight if its value is divisible by 2.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q, qu[300005], qv[300005], par[300005], dep[300005], C[300005];\nvector<int> G[300005];\nbool vis[300005];\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\trep(i, G[v].size()) {\n\t\tint u = G[v][i];\n\t\tif(!vis[u]) {\n\t\t\tpar[u] = v; dep[u] = dep[v] + 1; dfs(u);\n\t\t}\n\t}\n}\n\nvector<int> A0, A1;\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[v].push_back(u); G[u].push_back(v);\n\t}\n\tdfs(1);\n\t\n\tscanf(\"%d\", &q);\n\trep(i, q) {\n\t\tscanf(\"%d%d\", &qu[i], &qv[i]);\n\t\tC[qu[i]] ^= 1; C[qv[i]] ^= 1;\n\t}\n\tint tot = 0;\n\trep1(i, n) tot += C[i];\n\tif(tot != 0) {\n\t\tprintf(\"NO\\n%d\\n\", tot / 2); return 0;\n\t}\n\tprintf(\"YES\\n\");\n\trep(i, q) {\n\t\tint x = qu[i], y = qv[i];\n\t\tA0.clear(); A1.clear();\n\t\twhile(x != y) if(dep[x] > dep[y]) {\n\t\t\tA0.push_back(x); x = par[x];\n\t\t} else {\n\t\t\tA1.push_back(y); y = par[y];\n\t\t}\n\t\treverse(A1.begin(), A1.end());\n\t\tprintf(\"%d\\n\", (int)A0.size() + (int)A1.size() + 1);\n\t\trep(j, A0.size()) printf(\"%d \", A0[j]);\n\t\tprintf(\"%d\", x);\n\t\trep(j, A1.size()) printf(\" %d\", A1[j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graph matchings",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Moment of Bloom.json",
    "editorial_link": "https://codeforces.com//blog/entry/96072",
    "editorial": "Let be the number of times appears in the queries. If is odd for any ,\r\nthen there does not exist an assignment of paths that will force all\r\neven edge weights. To see why, notice that one query will correspond to\r\nexactly one edge adjacent to . If an odd number of paths are adjacent to\r\n, this implies that at least one edge adjacent to will have an odd\r\ndegree.It turns out that this is the only condition that we need to\r\ncheck. In other words, if is even for all , then there will exist an\r\nassignment of paths that will force all edge weights to be even.Let\u00e2\u0080\u0099s\r\nassume all is even. We can find a solution by doing the following: take\r\nany spanning tree of the graph and assign each query to be the path from\r\nto in this tree.An intuitive way of thinking about this is the\r\nfollowing. Consider the case if the spanning tree is a line. Then each\r\nquery becomes a range and we\u00e2\u0080\u0099re checking if all points in this range are\r\ncovered an even number of times. For all points to be covered an even\r\nnumber of times, every point should occur an even number of times in the\r\nqueries. To generalize this to a tree, when the first path to is\r\nincremented, in order to make these values even again, we will need\r\nlater paths to also overlap the segment from to . One way this can be\r\ndone is if we use two paths to and to . Notice that even if a new\r\nsegment that makes the to path even makes some other edges odd, the\r\nlater queries will always fix these edges.\r\n"
}