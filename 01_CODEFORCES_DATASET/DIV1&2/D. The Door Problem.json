{
    "link": "https://codeforces.com//contest/776/problem/D",
    "problemId": "95208",
    "problem_idx": "D",
    "shortId": "776D",
    "contest_number": "776",
    "problem_submissions": {
        "G": [
            24939347,
            24933167,
            24937192,
            24938688,
            24939300,
            24936369,
            24933254,
            24936389,
            24938260,
            50496579,
            24939610,
            24974394,
            24937125,
            24938166,
            24937440
        ],
        "F": [
            24931137,
            24940601,
            24934717,
            24935180,
            24936216,
            24930744,
            24935991,
            24934536,
            24933196,
            24934631,
            25009829,
            24934356,
            24935407,
            25145968,
            24938938
        ],
        "E": [
            24926469,
            24922427,
            24928701,
            24929827,
            24927281,
            24926330,
            24922998,
            24928645,
            24928568,
            24927117,
            24927967,
            24932026,
            24926259,
            24928494,
            24925814,
            24933222,
            24929687,
            24929132
        ],
        "D": [
            24923588,
            24926240,
            24925398,
            24926362,
            24924696,
            24942987,
            24926743,
            24925181,
            24923636,
            24922793,
            24927891,
            24924422,
            24923885,
            24928078,
            25388280,
            24929601,
            24924674,
            24952921,
            24926279
        ],
        "A": [
            24920848,
            24918716,
            24917411,
            24917501,
            24928258,
            24917338,
            24918133,
            24917381,
            24917351,
            24917379,
            24917385,
            24917553,
            24917364,
            24918205,
            24917450,
            24917668,
            24918624
        ],
        "C": [
            24919677,
            24924230,
            24922174,
            24922015,
            24918784,
            24920506,
            24921334,
            24921898,
            24920669,
            24950107,
            24929487,
            24921634,
            24921526,
            24921083,
            24921835,
            25114288,
            24921821,
            24922186,
            24923226
        ],
        "B": [
            24917670,
            24919248,
            24918919,
            24919261,
            24920428,
            24918897,
            24919671,
            24919894,
            24918987,
            24918567,
            24918525,
            24922327,
            24918984,
            24918395,
            24919865,
            24919010,
            24920231,
            24920427
        ]
    },
    "name": "D. The Door Problem",
    "statement": "Moriarty has trapped people in distinct rooms in a hotel. Some rooms are\r\nlocked, others are unlocked. But, there is a condition that the people\r\nin the hotel can only escape when all the doors are unlocked at the same\r\ntime. There are switches. Each switch control doors of some rooms, but\r\neach door is controlled by switches.You are given the initial\r\nconfiguration of the doors. Toggling any switch, that is, turning it ON\r\nwhen it is OFF, or turning it OFF when it is ON, toggles the condition\r\nof the doors that this switch controls. Say, we toggled switch , which\r\nwas connected to room , and which were respectively locked, unlocked and\r\nunlocked. Then, after toggling the switch, they become unlocked, locked\r\nand locked.You need to tell Sherlock, if there exists a way to unlock\r\nall doors at the same time.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m, w[101000], P[101000][2], PC[101000];\nvector<int>E[201000];\nbool v[201000];\nint SCC[201000], cnt, ord[201000];\nvoid DFS(int a){\n    v[a]=true;\n    int i;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n    ord[++cnt] = a;\n}\nvoid DFS2(int a){\n    SCC[a] = cnt;\n    int i;\n    for(i=0;i<E[a].size();i++){\n        if(!SCC[E[a][i]])DFS2(E[a][i]);\n    }\n}\nint main(){\n    int i;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&w[i]);\n    }\n    for(i=1;i<=m;i++){\n        int c, a;\n        scanf(\"%d\",&c);\n        while(c--){\n            scanf(\"%d\",&a);\n            P[a][PC[a]++] = i;\n        }\n    }\n    for(i=1;i<=n;i++){\n        if(w[i] == 0){\n            E[P[i][0]].push_back(P[i][1] + m);\n            E[P[i][1]].push_back(P[i][0] + m);\n            E[P[i][0] + m].push_back(P[i][1]);\n            E[P[i][1] + m].push_back(P[i][0]);\n        }\n        else{\n            E[P[i][0]].push_back(P[i][1]);\n            E[P[i][1]].push_back(P[i][0]);\n            E[P[i][0] + m].push_back(P[i][1] + m);\n            E[P[i][1] + m].push_back(P[i][0] + m);\n        }\n    }\n    for(i=1;i<=m+m;i++){\n        if(!v[i])DFS(i);\n    }\n    cnt = 0;\n    for(i=m+m;i>=1;i--){\n        if(!SCC[ord[i]]){\n            cnt++;\n            DFS2(ord[i]);\n        }\n    }\n    for(i=1;i<=m;i++){\n        if(SCC[i]==SCC[i+m]){\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. The Door Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/50622",
    "editorial": "Hint : Try to model the situation as a graph with rooms as edges and\r\nswitches as nodes.Editorial : All rooms are represented as edges. Mark\r\nthe edges as if the room is open else mark the edge as closed. The\r\nanswer will be \"YES\" if you can color the graph in such a manner that\r\nthe edges having value have both nodes under different color (if the\r\ndoor is locked then one of the switches should be selected) and the\r\nedges having have both nodes under same color (if the door is unlocked\r\nyou should either select both switches or neither of them). For checking\r\nthe same start a bfs from switch and toggle it and proceed, if you are\r\nable to color all of the switches then the answer is \"YES\" else it is\r\nnot possible. See the setter\u00e2\u0080\u0099s solution for implementation details.\r\n"
}