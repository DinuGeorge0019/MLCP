{
    "link": "https://codeforces.com//contest/1991/problem/H",
    "problemId": "2781508",
    "problem_idx": "H",
    "shortId": "1991H",
    "contest_number": "1991",
    "problem_submissions": {
        "H": [
            273210632,
            273212730,
            273219908,
            273194851,
            273200656,
            273213505,
            273204889,
            273220591,
            273225451,
            273220804,
            273226512,
            273222266,
            273229115,
            278405080,
            273216843
        ],
        "G": [
            273180456,
            273179521,
            273174064,
            273209283,
            273179708,
            273185549,
            273216085,
            273188851,
            273191410,
            273193985,
            273189153,
            273194518,
            273197531,
            273190195,
            273195818,
            273188177,
            273190908,
            273195464,
            273198241
        ],
        "F": [
            273160781,
            273160990,
            273158593,
            273158141,
            273171320,
            273168196,
            273159727,
            273170129,
            273173513,
            273170857,
            273165439,
            273182207,
            273174869,
            273166190,
            273163947,
            273173198,
            273175470,
            273163587,
            273174682,
            273170108
        ],
        "E": [
            273150868,
            273153734,
            273152235,
            273150823,
            273156934,
            273151786,
            273150935,
            273157824,
            273151366,
            273154414,
            273174335,
            273161395,
            273159133,
            273156803,
            273161464,
            273162124,
            273154749,
            273158567,
            273155964
        ],
        "D": [
            273143134,
            273144551,
            273142645,
            273141713,
            273147820,
            273143829,
            273141673,
            273145581,
            273156995,
            273145729,
            273149790,
            273146459,
            273144249,
            273145676,
            273154684,
            273150687,
            273147840,
            273144991,
            273148567
        ],
        "C": [
            273139495,
            273142387,
            273139319,
            273241170,
            273142853,
            273141897,
            273140491,
            273138783,
            273141460,
            273141958,
            273141853,
            273144830,
            273141321,
            273143714,
            273141051,
            273142758,
            273145128,
            273137630,
            273141184,
            273143400
        ],
        "B": [
            273133106,
            273134906,
            273133339,
            273134525,
            273138116,
            273135569,
            273133092,
            273135379,
            273136693,
            273135755,
            273136343,
            273135805,
            273132915,
            273135366,
            273136849,
            273139913,
            273132449,
            273135138,
            273136549
        ],
        "A": [
            273130858,
            273132065,
            273130939,
            273130875,
            273131982,
            273132539,
            273130929,
            273131106,
            273131228,
            273130992,
            273131052,
            273131178,
            273130862,
            273131382,
            273131308,
            273132778,
            273130871,
            273130965,
            273131362
        ],
        "I": [
            273238749,
            273429741
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132021",
    "editorial": "First, let's consider how to split a single number x\n:\n\nFor an odd number x\n, it can only be split into x?2\n and 2\n. Proof: An odd number can only be split into an odd and an even number, and the only even prime is 2\n.\nFor an even number x\n, apart from x=4\n which can be split into 2\n and 2\n, it can only be split into two odd numbers. Proof: An even number can only be split into odd and odd, or even and even. The only even prime is 2\n, thus only 4\n can be split into even and even.\nNext, let's consider a simplified version of the game with only two piles of stones, where the first pile contains x\n stones, and the second pile contains one stone. If Alice wins in this setup, we call x\n a winning position; otherwise, it is a losing position. We first determine whether an odd x\n is a winning position, then determine whether an even x\n is a winning position:\n\nFor an odd x\n, we need to calculate how many times 2\n stones can be split from x\n until x?2\n is not a prime. If the number of splits is odd, then it is a winning position; otherwise, it is a losing position.\nFor an even x\n, if x\n can be split into two losing positions, then x\n is a winning position; otherwise, x\n is a losing position. Apart from x=4\n (a winning position), other even numbers can only be split into two odd numbers. Optimization: Directly checking all ways to split each even number will time out. However, we can use the Fast Fourier Transform (FFT) or bitset operations, based on the losing positions of odd numbers, to determine the winning positions of even numbers. If you are not familiar with this optimization technique, it is recommended to first solve 2014 ICPC SWERC Problem C Golf Bot, the tutorial is here.\nIn summary, the characteristics of winning and losing positions are: losing positions either cannot be split, or they must split out at least one winning position. Winning positions can be split into two losing positions.\n\nLet's return to the original game. If all ai\n are in losing positions, Bob will win. Proof: No matter how Alice moves, Bob can always turn all ai\n back to losing positions. Suppose Alice splits to produce 2?k\n new piles in one move, then at least k\n of them will be in winning positions. Bob can split these k\n piles into 2?k\n losing positions and remove the remaining k\n new piles. As a result, all piles will be back in losing positions. This process will continue until no more losing positions can be split, which will lead to Bob's win.\n\nSince we now have a general scenario where Bob wins, we can discuss all scenarios that can turn into this scenario with one move. In these scenarios, Alice will win:\n\nWhen n\n is even and the number of winning positions ai\n ranges between [1,n]\n, Alice will win. Proof: Assuming the number of winning positions is w\n, Alice can choose k=?w2?\n to select k\n winning positions and split them into 2?k\n losing positions. She then removes other winning positions and may remove one extra pile, to sum up k\n piles. After the move, all piles will be turned into losing positions, ensuring Alice's win.\nWhen n\n is odd and the number of winning positions ai\n ranges between [1,n?1]\n, Alice will win. Proof: Similar to the previous proof, Alice can turn all piles into losing positions in one move.\nThe only unresolved case is when n\n is odd and the number of winning positions ai\n equals n\n. Alice cannot turn all positions into losing positions in one move because at most 2?k\n positions can be changed in a single move. Since 2?k<n\n, it is impossible to change all n\n positions. In this case, if someone splits a winning position into a losing position, the number of winning positions will drop to [1,n?1]\n, leading to failure. However, winning positions can sometimes be split into two winning positions. Therefore, we only need to consider this splitting case.\n\nA number is called a good position if it can be split into two winning positions; otherwise, it is called a bad position. We find that odd numbers cannot be good positions because they can only be split into x?2\n and 2\n, and 2\n is not a winning position. Thus, only even numbers can be good positions if they can be split into two odd winning positions. Optimization: Directly checking ways to split each even number will time out. We can use FFT or bitset operations to identify good positions among even numbers.\n\nNote that good positions can only be split into two bad positions because even numbers can only be split into odd numbers or 2\n, both of which are considered bad positions. Thus, when n\n is odd and all ai\n are in winning positions, we only need to determine the winner based on the number of good positions:\n\nIf the number of good positions ai\n is 0\n, Bob will win. Proof: Any move by Alice will produce losing positions, as analyzed earlier, leading to failure.\nIf the number of good positions ai\n is between [1,n?1]\n, Alice will win. Proof: In one move, Alice can turn all numbers into bad positions using a method similar to when n\n is odd and winning positions are between [1,n?1]\n.\nIf the number of good positions ai\n is n\n, Bob will win. Proof: Any move by Alice will produce losing or bad positions, ultimately leading to the previous scenario and resulting in failure.",
    "name": "H. Prime Split Game",
    "statement": "Alice and Bob are playing a game with n piles of stones, where the i-th\r\npile has a_i stones. Players take turns making moves, with Alice going\r\nfirst.On each move, the player does the following three-step process:\r\nChoose an integer k (1\r\nleq k\r\nleq\r\nfrac n 2). Note that the value of k can be different for different\r\nmoves. Remove k piles of stones. Choose another k piles of stones and\r\nsplit each pile into two piles. The number of stones in each new pile\r\nmust be a prime number. The player who is unable to make a move\r\nloses.Determine who will win if both players play optimally.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 28.07.2024 12:33:45**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0const int N = 200010;\u00a0bool can[N][2][2];\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  vector<bool> prime(N, true);  prime[0] = prime[1] = false;  vector<int> p;  for (int i = 2; i < N; i++) {    if (prime[i]) {      p.push_back(i);      for (int j = i + i; j < N; j += i) prime[j] = false;    }  }  vector<int> g(N, -1);  for (int x = 1; x < N; x++) {    if (prime[x]) {      if (x > 2 && prime[x - 2]) {        g[x] = (g[x - 2] + 1) % 2;      } else {        g[x] = 0;      }    }  }  for (int i = 0; i < N; i++) {    for (int x = 0; x < 2; x++) {      for (int y = 0; y < 2; y++) {        can[i][x][y] = false;      }    }  }  for (int i = 0; i < int(p.size()); i++) {    for (int j = i; j < int(p.size()); j++) {      if (p[i] + p[j] >= N) {        break;      }      int a = g[p[i]];      int b = g[p[j]];      if (a > b) swap(a, b);      can[p[i] + p[j]][a][b] = true;    }  }  vector<int> val(N);  for (int x = 0; x < N; x++) {    if (prime[x]) {      val[x] = g[x];    } else {      if (!can[x][0][0]) {        val[x] = 0;      } else {        if (can[x][0][0] && can[x][1][1]) {          val[x] = 2;        } else {          val[x] = 1;        }      }    }  }  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    vector<int> cnt(3, 0);    for (int i = 0; i < n; i++) {      int a;      cin >> a;      cnt[val[a]] += 1;    }    bool win = true;    if (cnt[1] == 0 && cnt[2] == 0) {      win = false;    }    if (n % 2 == 1) {      if (cnt[1] == n && cnt[2] == 0) {        win = false;      }      if (cnt[1] == 0 && cnt[2] == n) {        win = false;      }    }    cout << (win ? \"Alice\" : \"Bob\") << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "fft",
        "games",
        "math",
        "number theory"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Prime Split Game.json"
}