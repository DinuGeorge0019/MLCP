{
    "link": "https://codeforces.com//contest/653/problem/D",
    "problemId": "52182",
    "problem_idx": "D",
    "shortId": "653D",
    "contest_number": "653",
    "problem_submissions": {
        "D": [
            16882408,
            16811537,
            16810665,
            16808469,
            16808880,
            16810169,
            16810193,
            16817835,
            16817684,
            16809816,
            16810008,
            16809541,
            16810009,
            16809483,
            16815488,
            16815467,
            16809743,
            16815857,
            16810399,
            16830307,
            16830297,
            16830295,
            16809555
        ],
        "C": [
            16814329,
            16808201,
            16807277,
            16809824,
            16809484,
            16809237,
            16808970,
            16808978,
            16808649,
            16810747,
            16824380,
            16810982,
            16808580,
            16808306,
            16809772,
            16808759,
            16815412,
            16808885,
            16810588
        ],
        "F": [
            16813454,
            16812764,
            16813359,
            16811313,
            16812655,
            16813981,
            16813203,
            16812204,
            16812853,
            16813207,
            16813077,
            16811759,
            16813557,
            16817070,
            16813698,
            16812540,
            16812526
        ],
        "E": [
            16812212,
            16809858,
            16810442,
            16814020,
            16811168,
            16811817,
            16811727,
            16814449,
            16814876,
            16813977,
            16814689,
            16810991,
            16810903,
            16815613,
            16810612,
            16812105,
            16811842
        ],
        "B": [
            16811122,
            16806823,
            16808941,
            16806712,
            16806895,
            16807172,
            16806271,
            16807190,
            16807288,
            16809090,
            16808193,
            16806845,
            16806473,
            16807895,
            16806798,
            16807486,
            16808397,
            16806933
        ],
        "A": [
            16810886,
            16805361,
            16805416,
            16805408,
            16805395,
            16805730,
            16805338,
            16805605,
            16805967,
            16806396,
            16807313,
            16805370,
            16805342,
            16805498,
            16805369,
            16805701,
            16806883,
            16805397
        ],
        "G": [
            16810637,
            16830434,
            16849997,
            16871778,
            16820127,
            16813576,
            16863345,
            16813594,
            16830285
        ]
    },
    "name": "D. Delivery Bears",
    "statement": "Niwel is a little golden bear. As everyone knows, bears live in forests,\r\nbut Niwel got tired of seeing all the trees so he decided to move to the\r\ncity.In the city, Niwel took on a job managing bears to deliver goods.\r\nThe city that he lives in can be represented as a directed graph with\r\nnodes and edges. Each edge has a weight capacity. A delivery consists of\r\na bear carrying weights with their bear hands on a simple path from node\r\nto node . The total weight that travels across a particular edge must\r\nnot exceed the weight capacity of that edge.Niwel has bears. In the\r\ninterest of fairness, no bear can rest, and the weight that each bear\r\ncarries must be exactly the same. However, each bear may take different\r\npaths if they like.Niwel would like to determine, what is the maximum\r\namount of weight he can deliver (it’s the sum of weights carried by\r\nbears). Find the maximum weight.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=0x20202020;\ntypedef int flowt;\nnamespace flow {\n\tconst int M=100000,N=1000;\n\tint y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\n\tflowt f[M];\n\tint S,T,tot,Tn;\n\tvoid init(int s,int t,int tn) {\n\t\ttot=1; assert(tn<N);\n\t\trep(i,0,tn) fst[i]=0;\n\t\tS=s;T=t;Tn=tn;\n\t}\n\tvoid add(int u,int v,flowt c1,flowt c2=0) {\n\t\ttot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\n\t\ttot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\n\t}\n\tflowt sap() {\n\t\tint u=S,t=1;flowt flow=0;\n\t\trep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\n\t\tq[0]=T;dis[T]=0;pre[S]=0;\n\t\trep(i,0,t) {\n\t\t\tint u=q[i];\n\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (dis[y[j]]>dis[u]+1&&f[j^1]) \n\t\t\t\tq[t++]=y[j],dis[y[j]]=dis[u]+1;\n\t\t}\n\t\trep(i,0,Tn) gap[dis[i]]++;\n\t\twhile (dis[S]<=Tn) {\n\t\t\twhile (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\n\t\t\tif (c[u]) {\n\t\t\t\tpre[y[c[u]]]=c[u]^1;\n\t\t\t\tu=y[c[u]];\n\t\t\t\tif (u==T) {\n\t\t\t\t\tflowt minf=inf;\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\n\t\t\t\t\tflow=min(flow+minf,inf);u=S;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(--gap[dis[u]])) break;\n\t\t\t\tint mind=Tn;\n\t\t\t\tc[u]=fst[u];\n\t\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind) \n\t\t\t\t\tmind=dis[y[j]],c[u]=j;\n\t\t\t\tdis[u]=mind+1;\n\t\t\t\tgap[dis[u]]++;\n\t\t\t\tif (u!=S) u=y[pre[u]];\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nconst int M=1010;\nint n,m,k,u[M],v[M],w[M];\nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",u+i,v+i,w+i); --u[i],--v[i];\n\t}\n\tdouble l=1./k,r=1e6;\n\trep(rd,0,60) {\n\t\tdouble md=(l+r)*0.5;\n\t\tflow::init(0,n-1,n);\n\t\trep(i,0,m) {\n\t\t\tflow::add(u[i],v[i],(int)min(w[i]/md,(double)k+1e-10));\n\t\t}\n\t\tif (flow::sap()>=k) l=md; else r=md;\n\t}\n\tprintf(\"%.10f\\n\",r*k);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "flows",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Delivery Bears.json",
    "editorial_link": "https://codeforces.com//blog/entry/43886",
    "editorial": "Letâs transform this into a flow problem. Here, we transform \"weight\"\ninto \"flow\", and each \"bear\" becomes a \"path\". Suppose we just want to\nfind the answer for a single . We can do this binary search on the flow\nfor each path. To check if a particular flow of is possible, reduce the\ncapacity of each edge from to . Then, check if the max flow in this\ngraph is at least . The final answer is then multiplied by the flow\nvalue that we found. MUCH HARDER VERSION you are also given an integer\n() and your task is to find the answer for paths, for paths, ..., and\nfor paths. There should be real values on the output. The solution of\nthe harder version.However, this is not fast enough when we have up to\n10^4 values of x to check.Instead, we look at a fast way of getting the\nflow value for x+1 paths given a flow with x paths in only O(m log m)\ntime.Suppose weâve found the paths for x bears, and we know that the\nnumber of bears who use edge number i is w_i. Also, let f_x be the\nweight that each bear carries, given that there are x bears.Then, we can\ncreate a residual graph as follows: For each edge (u_i -> v_i) with\ncapacity c_i, create an edge in th residual graph from u_i to v_i with\ncapacity (c_i) / (1 + w_i), and if w_i > 0, a backward edge with\ncapacity f_x.Then, we can find the fattest path in this graph with a\ndijsktraâs in O(m log m), giving us f_(x+1). This also allows us to\nupdate our paths. In particular, if we use a backwards edge, we subtract\nthe number of times the edge is used by 1, otherwise, we increase it\nby 1. This allows us to construct a new residual graph. It can be shown\nthat this only results in at most one new path.We can prove that this is\ncorrect by induction. Suppose the answer is correct for x bears.Now, one\nobservation is that f_(x+1) must be less than or equal to f_x, as any\nplan that x+1 bears follow will also be able to be executed with x\nbears. Suppose the optimal solution for x+1 bears is actually g_(x+1).\nWe just need to argue that f_(x+1) >= g_(x+1) and we are done. In the\noptimal solution, consider replacing each edge with capacity c_i to\nfloor(c_i/g_(x+1)). Now, consider the optimal paths for x bears in this\nreduced capacity graph (which we found through induction). Since there\nare only x bears, but we know we can support x+1 bears, there exists a\npath in the residual graph from the source to the sink. Letâs look at\nthe capacity of this path. If we travel along any backward edge, the\ncapacity of that edge is f_x which is at least g_(x+1). If we travel on\na forward edge, we have c_i/(1+w_i) >= g_(x+1) <=> c_i >=\n(1+w_i)*g_(x+1). The second inequality follows from reversing the\n\"divide by g_(x+1)\" step. Thus, the overall running time is O(mn^2 *\nlog(m*x) + k*m log m), where the first part comes from the initial\nbinary search, and the second part comes from doing k fattest path\ncomputations.\n",
    "hint": []
}