{"link": "https://codeforces.com//contest/653/problem/D", "problemId": "52182", "problem_idx": "D", "shortId": "653D", "contest_number": "653", "problem_submissions": {"D": [16882408, 16811537, 16810665, 16808469, 16808880, 16810169, 16810193, 16817835, 16817684, 16809816, 16810008, 16809541, 16810009, 16809483, 16815488, 16815467, 16809743, 16815857, 16810399, 16830307, 16830297, 16830295, 16809555], "C": [16814329, 16808201, 16807277, 16809824, 16809484, 16809237, 16808970, 16808978, 16808649, 16810747, 16824380, 16810982, 16808580, 16808306, 16809772, 16808759, 16815412, 16808885, 16810588], "F": [16813454, 16812764, 16813359, 16811313, 16812655, 16813981, 16813203, 16812204, 16812853, 16813207, 16813077, 16811759, 16813557, 16817070, 16813698, 16812540, 16812526], "E": [16812212, 16809858, 16810442, 16814020, 16811168, 16811817, 16811727, 16814449, 16814876, 16813977, 16814689, 16810991, 16810903, 16815613, 16810612, 16812105, 16811842], "B": [16811122, 16806823, 16808941, 16806712, 16806895, 16807172, 16806271, 16807190, 16807288, 16809090, 16808193, 16806845, 16806473, 16807895, 16806798, 16807486, 16808397, 16806933], "A": [16810886, 16805361, 16805416, 16805408, 16805395, 16805730, 16805338, 16805605, 16805967, 16806396, 16807313, 16805370, 16805342, 16805498, 16805369, 16805701, 16806883, 16805397], "G": [16810637, 16830434, 16849997, 16871778, 16820127, 16813576, 16863345, 16813594, 16830285]}, "name": "D. Delivery Bears", "statement": "Niwel is a little golden bear. As everyone knows, bears live in forests,\r\nbut Niwel got tired of seeing all the trees so he decided to move to the\r\ncity.In the city, Niwel took on a job managing bears to deliver goods.\r\nThe city that he lives in can be represented as a directed graph with\r\nnodes and edges. Each edge has a weight capacity. A delivery consists of\r\na bear carrying weights with their bear hands on a simple path from node\r\nto node . The total weight that travels across a particular edge must\r\nnot exceed the weight capacity of that edge.Niwel has bears. In the\r\ninterest of fairness, no bear can rest, and the weight that each bear\r\ncarries must be exactly the same. However, each bear may take different\r\npaths if they like.Niwel would like to determine, what is the maximum\r\namount of weight he can deliver (it\u2019s the sum of weights carried by\r\nbears). Find the maximum weight.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=0x20202020;\ntypedef int flowt;\nnamespace flow {\n\tconst int M=100000,N=1000;\n\tint y[M],nxt[M],gap[N],fst[N],c[N],pre[N],q[N],dis[N];\n\tflowt f[M];\n\tint S,T,tot,Tn;\n\tvoid init(int s,int t,int tn) {\n\t\ttot=1; assert(tn<N);\n\t\trep(i,0,tn) fst[i]=0;\n\t\tS=s;T=t;Tn=tn;\n\t}\n\tvoid add(int u,int v,flowt c1,flowt c2=0) {\n\t\ttot++;y[tot]=v;f[tot]=c1;nxt[tot]=fst[u];fst[u]=tot;\n\t\ttot++;y[tot]=u;f[tot]=c2;nxt[tot]=fst[v];fst[v]=tot;\n\t}\n\tflowt sap() {\n\t\tint u=S,t=1;flowt flow=0;\n\t\trep(i,0,Tn) c[i]=fst[i],dis[i]=Tn,gap[i]=0;\n\t\tq[0]=T;dis[T]=0;pre[S]=0;\n\t\trep(i,0,t) {\n\t\t\tint u=q[i];\n\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (dis[y[j]]>dis[u]+1&&f[j^1]) \n\t\t\t\tq[t++]=y[j],dis[y[j]]=dis[u]+1;\n\t\t}\n\t\trep(i,0,Tn) gap[dis[i]]++;\n\t\twhile (dis[S]<=Tn) {\n\t\t\twhile (c[u]&&(!f[c[u]]||dis[y[c[u]]]+1!=dis[u])) c[u]=nxt[c[u]];\n\t\t\tif (c[u]) {\n\t\t\t\tpre[y[c[u]]]=c[u]^1;\n\t\t\t\tu=y[c[u]];\n\t\t\t\tif (u==T) {\n\t\t\t\t\tflowt minf=inf;\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) minf=min(minf,f[p^1]);\n\t\t\t\t\tfor (int p=pre[T];p;p=pre[y[p]]) f[p^1]-=minf,f[p]+=minf;\n\t\t\t\t\tflow=min(flow+minf,inf);u=S;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!(--gap[dis[u]])) break;\n\t\t\t\tint mind=Tn;\n\t\t\t\tc[u]=fst[u];\n\t\t\t\tfor (int j=fst[u];j;j=nxt[j]) if (f[j]&&dis[y[j]]<mind) \n\t\t\t\t\tmind=dis[y[j]],c[u]=j;\n\t\t\t\tdis[u]=mind+1;\n\t\t\t\tgap[dis[u]]++;\n\t\t\t\tif (u!=S) u=y[pre[u]];\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nconst int M=1010;\nint n,m,k,u[M],v[M],w[M];\nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",u+i,v+i,w+i); --u[i],--v[i];\n\t}\n\tdouble l=1./k,r=1e6;\n\trep(rd,0,60) {\n\t\tdouble md=(l+r)*0.5;\n\t\tflow::init(0,n-1,n);\n\t\trep(i,0,m) {\n\t\t\tflow::add(u[i],v[i],(int)min(w[i]/md,(double)k+1e-10));\n\t\t}\n\t\tif (flow::sap()>=k) l=md; else r=md;\n\t}\n\tprintf(\"%.10f\\n\",r*k);\n}\n"], "input": "", "output": "", "tags": ["binary search", "flows", "graphs"], "dificulty": "2200", "interactive": false}