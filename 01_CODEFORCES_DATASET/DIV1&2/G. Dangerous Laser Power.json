{
    "link": "https://codeforces.com//contest/1740/problem/G",
    "problemId": "1611416",
    "problem_idx": "G",
    "shortId": "1740G",
    "contest_number": "1740",
    "problem_submissions": {
        "H": [
            178379430,
            178389839,
            178370970,
            178389787,
            178394159,
            178405718,
            178393380,
            178400994,
            178473578
        ],
        "G": [
            178363447,
            178373152,
            178390136,
            178380782,
            178380133,
            178366412,
            178381208,
            178372252,
            178364309,
            178377085,
            178379805,
            178389960,
            178394186,
            178390668,
            178429073,
            178399239,
            178398964,
            178398319,
            178393777,
            178389532,
            178457114,
            178457090,
            178457069,
            178456881,
            178456598
        ],
        "F": [
            178342509,
            178355726,
            178353094,
            178359313,
            178375325,
            178347566,
            178343206,
            178355344,
            178419766,
            178363409,
            178364030,
            178360259,
            178371042,
            178378751,
            178405026,
            178404845,
            178404014,
            178403791,
            178403569,
            178376955,
            178368121,
            178355891,
            178355560,
            178363171,
            178364934
        ],
        "E": [
            178337370,
            178346224,
            178348715,
            178344194,
            178352039,
            178338198,
            178335731,
            178340043,
            178343562,
            178350554,
            178352735,
            178349059,
            178343925,
            178345775,
            178364103,
            178352981,
            178344981,
            178359372,
            178346165,
            178350475
        ],
        "D": [
            178334153,
            178339631,
            178345824,
            178338369,
            178344365,
            178352777,
            178346625,
            178336331,
            178336614,
            178338914,
            178339308,
            178344306,
            178335725,
            178354316,
            178351979,
            178370227,
            178339993,
            178338550,
            178340955,
            178340858
        ],
        "C": [
            178329483,
            178334722,
            178336471,
            178331649,
            178333101,
            178332328,
            178330724,
            178331197,
            178330550,
            178331983,
            178331086,
            178337583,
            178330090,
            178335594,
            178335112,
            178340402,
            178335550,
            178333891,
            178336207,
            178332182
        ],
        "B": [
            178326239,
            178328080,
            178333593,
            178327287,
            178329054,
            178327314,
            178327001,
            178329448,
            178327787,
            178327568,
            178327277,
            178328845,
            178326455,
            178328799,
            178328762,
            178333879,
            178327499,
            178329269,
            178328122,
            178330549
        ],
        "A": [
            178322883,
            178322996,
            178323296,
            178323217,
            178323002,
            178322816,
            178327673,
            178322982,
            178323305,
            178322810,
            178323224,
            178323080,
            178322764,
            178323327,
            178324186,
            178325267,
            178322814,
            178324090,
            178323226,
            178322754
        ],
        "I": [
            179538712
        ]
    },
    "name": "G. Dangerous Laser Power",
    "statement": "Pak Chanek has an n\r\ntimes m grid of portals. The portal on the i-th row and j-th column is\r\ndenoted as portal (i,j). The portals (1,1) and (n,m) are on the\r\nnorth-west and south-east corner of the grid respectively.The portal\r\n(i,j) has two settings: t_{i,j}, which is either 0 or 1. s_{i,j}, which\r\nis an integer between 1 and 10^9 inclusive. Each portal has 4 faces\r\nlabelled with integers 0,1,2,3, which correspond to the north, east,\r\nsouth, and west direction respectively. When a laser enters face k of\r\nportal (i, j) with speed x_\r\ntext{in}, it leaves the portal going out of face (k+2+t_{i,j})\r\nbmod 4 with speed x_\r\ntext{out} =\r\nmax(x_\r\ntext{in},s_{i,j}). The portal also has to consume x_\r\ntext{out} - x_\r\ntext{in} units of . Pak Chanek is very bored today. He will shoot 4nm\r\nlasers with an initial speed of 1, one into each face of each portal.\r\nEach laser will travel throughout this grid of portals until it moves\r\noutside the grid or it has passed through 10^{100} portals.At the end,\r\nPak Chanek thinks that a portal is if and only if the total energy\r\nconsumed by that portal modulo 2 is equal to its type. Given the\r\nstrength settings of all portals, find a way to assign the type settings\r\nof each portal such that the number of good portals is maximised.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct SEQ {\n    std::list<std::array<int, 2>> x;\n    int sum;\n    int cnt;\n};\n\nvoid merge(SEQ &a, SEQ &b, int x) {\n    int c = 0;\n    x = std::max(x, b.x.front()[0]);\n    while (!a.x.empty() && a.x.back()[0] <= x) {\n        c ^= a.x.back()[1];\n        a.sum ^= a.x.back()[0] & a.x.back()[1];\n        a.x.pop_back();\n    }\n    b.x.push_front({x, c});\n    b.sum ^= x & c;\n    a.x.splice(a.x.end(), b.x);\n    a.cnt ^= b.cnt;\n    a.sum ^= b.sum;\n}\n\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector a(n + 2, std::vector<int>(m + 2));\n    \n    std::vector<std::array<int, 2>> p;\n    \n    const int N = 4 * (n + 2) * (m + 2);\n    DSU dsu(N);\n    \n    std::vector<SEQ> s(N);\n    for (int i = 0; i < N; i++) {\n        s[i].x.push_back({1, 1});\n        s[i].cnt = s[i].sum = 1;\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            std::cin >> a[i][j];\n            p.push_back({i, j});\n        }\n    }\n    \n    std::sort(p.begin(), p.end(), [&](auto i, auto j) {\n        return a[i[0]][i[1]] < a[j[0]][j[1]];\n    });\n    \n    auto get = [&](int x, int y, int d) {\n        return 4 * (x * (m + 2) + y) + d;\n    };\n    \n    std::vector ans(n + 2, std::vector<int>(m + 2));\n    for (auto [x, y] : p) {\n        int res = 0;\n        for (int i = 0; i < 4; i++) {\n            int u = get(x, y, i);\n            u = dsu.leader(u);\n            res ^= s[u].sum ^ (s[u].cnt & a[x][y]);\n        }\n        ans[x][y] = res;\n        for (int i = 0; i < 4; i++) {\n            int ni = (i + res) & 3;\n            if (!dsu.same(get(x, y, i), get(x + dx[ni], y + dy[ni], ni))) {\n                int u = dsu.leader(get(x, y, i));\n                int v = dsu.leader(get(x + dx[ni], y + dy[ni], ni));\n                merge(s[u], s[v], a[x][y]);\n                dsu.merge(u, v);\n            }\n        }\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            std::cout << ans[i][j];\n        }\n        std::cout << \"\\n\";\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dsu",
        "sortings"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Dangerous Laser Power.json",
    "editorial_link": "https://codeforces.com//blog/entry/108567",
    "editorial": "Claim: There is a construction where all portals are good.We will\r\nproceed with the construction.The key observation of the problem is that\r\nfor a portal to consume energy, the laser must not enter a portal with a\r\nstrength greater than or equal to before going through portal .Letâs say\r\nwe already have the type settings of all lasers. Consider all possible\r\nlasers that at some point enters a certain face of portal . We can find\r\nthe paths of those lasers before entering portal by backtracking in that\r\ndirection from portal .Consider the first portal in that backtracking\r\npath that has a strength greater than or equal to . Notice that all\r\nlasers that starts from portals that are located after that portal in\r\nthe backtracking path must go through that portal before entering portal\r\n. Therefore, those lasers cannot make portal use energy, which means\r\nthey can be ignored.Using the observation above, we can see that we must\r\nonly backtrack until we find a portal with a strength greater than or\r\nequal to . Observe that to get the path up to that point, the type\r\nsettings we should know are only the type settings of portals with\r\nstrengths smaller than .Therefore, the construction can be generated by\r\ncalculating the type settings of the portals from the smallest to the\r\nlargest strengths. In each iteration, we use the type settings of the\r\nprevious portals to find the backtracking paths of the current portal.\r\nIf we already know the backtracking paths for each of the directions of\r\nthat portal, we can find the total energy that portal will consume in\r\nthe end, which means we can find the type setting for that portal that\r\nmakes it a good portal.The naive implementation of this has a time\r\ncomplexity of . Notice that each backtracking path of the portals are\r\njust the merging of smaller paths. We can maintain a disjoint set data\r\nstructure to handle this while maintaining the essential values needed\r\nin the calculation of the total energy consumed for each path.Time\r\ncomplexity:\r\n",
    "hint": []
}