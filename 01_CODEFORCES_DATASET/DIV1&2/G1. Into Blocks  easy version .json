{
    "link": "https://codeforces.com//contest/1209/problem/G1",
    "problemId": "411984",
    "problem_idx": "G1",
    "shortId": "1209G1",
    "contest_number": "1209",
    "problem_submissions": {
        "H": [
            60570135,
            60593253,
            60571964,
            60573026,
            60725224,
            60568078
        ],
        "G1": [
            60556287,
            60555918,
            60560660,
            60545193,
            60554924,
            60565714,
            60564847,
            60552798,
            60544388,
            60543295,
            60556776,
            60547912,
            60548472,
            60548343,
            60554445,
            60552013,
            60553528,
            60550140
        ],
        "F": [
            60551951,
            60559474,
            60551041,
            60555531,
            60550649,
            60550897,
            60556467,
            60559990,
            60548723,
            60548870,
            60575790,
            60552616,
            60555309,
            60557639,
            60553869,
            60548929,
            60549043,
            60560725
        ],
        "E1": [
            60550756,
            60549748,
            60556687,
            60542418,
            60544279,
            60546177,
            60548542,
            60550504,
            60541823,
            60540929,
            60549430,
            60545745,
            60545737,
            60545738,
            60546288,
            60556058,
            60558038,
            60546083
        ],
        "E2": [
            60550484,
            60549405,
            60556943,
            60542599,
            60544405,
            60546112,
            60548494,
            60550663,
            60542010,
            60541156,
            60549544,
            60546078,
            60546087,
            60546121,
            60546350,
            60556107,
            60589552,
            60589526,
            60589450,
            60589386,
            60588908,
            60588877,
            60579849,
            60579734,
            60579573,
            60558088,
            60546300
        ],
        "D": [
            60539597,
            60542953,
            60544285,
            60538671,
            60541008,
            60541094,
            60543213,
            60542943,
            60537333,
            60538028,
            60540579,
            60538998,
            60541063,
            60539296,
            60540559,
            60539902,
            60539449,
            60540533
        ],
        "C": [
            60538071,
            60541013,
            60542624,
            60537384,
            60538008,
            60539883,
            60540890,
            60540668,
            60537787,
            60537103,
            60538560,
            60537646,
            60538820,
            60541917,
            60538555,
            60538406,
            60537838,
            60538612
        ],
        "B": [
            60534755,
            60535450,
            60536787,
            60534226,
            60534529,
            60537069,
            60535685,
            60535878,
            60534260,
            60533467,
            60534967,
            60535176,
            60536131,
            60536594,
            60535887,
            60533931,
            60532807,
            60535219
        ],
        "A": [
            60532612,
            60532698,
            60532910,
            60532511,
            60532605,
            60536220,
            60532574,
            60532833,
            60532652,
            60532527,
            60532568,
            60532602,
            60532828,
            60533109,
            60532549,
            60532535,
            60534221,
            60532564
        ],
        "G2": [
            60566672,
            60567960,
            60565628,
            60564728,
            60572926,
            60607969,
            60701078,
            60577013,
            60576902,
            60576886
        ]
    },
    "name": "G1. Into Blocks  easy version ",
    "statement": ".A sequence of integers is called if its elements are arranged in blocks\r\nlike in [3, 3, 3, 4, 1, 1]. Formally, if two elements are equal,\r\neverything in between must also be equal.Let\u2019s define of a sequence as a\r\nminimum possible number of elements to change to get a nice sequence.\r\nHowever, if you change at least one element of value x to value y, you\r\nmust also change all other elements of value x into y as well. For\r\nexample, for [3, 3, 1, 3, 2, 1, 2] it isn\u2019t allowed to change first 1 to\r\n3 and second 1 to 2. You need to leave 1\u2019s untouched or change them to\r\nthe same value.You are given a sequence of integers a_1, a_2,\r\nldots, a_n and q updates.Each update is of form \"i x\" change a_i to x.\r\nUpdates are not independent (the change stays for the future).Print the\r\ndifficulty of the initial sequence and of the sequence after every\r\nupdate.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000,M=200000;\nint n,l[N],r[N],cnt[N],gor[N],a[N],f[N],ans;\n\nint main() {\n\tscanf(\"%d%*d\",&n);\n\trep(i,1,M+1) l[i]=n+1,r[i]=0;\n\trep(i,1,n+1) {\n\t\tscanf(\"%d\",a+i);\n\t\tl[a[i]]=min(l[a[i]],i);\n\t\tr[a[i]]=max(r[a[i]],i);\n\t\tcnt[a[i]]++;\n\t}\n\trep(i,1,n+1) gor[i]=r[a[i]];\n\tint p=1;\n\twhile (p<=n) {\n\t\tint mr=gor[p];\n\t\tint md=0;\n\t\twhile (p<=mr) {\n\t\t\tmd=max(md,cnt[a[p]]);\n\t\t\tmr=max(mr,gor[p]);\n\t\t\tp++;\n\t\t}\n\t\tans+=md;\n\t}\n\tprintf(\"%d\\n\",n-ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G1. Into Blocks  easy version .json",
    "editorial_link": "https://codeforces.com/blog/entry/69791",
    "editorial": "Let's solve easier version first (we will reuse core ideas in hard version as well).\n\nClearly, if some two integers are ``hooked'' like in 1\u00852\u00851\u00852\n, then they will end up being turned into the same integer.\n\nSo when we see integer x\n with first occurrence at a\n and last at b\n, let's mark segment [a;b]\n as blocked. E.g. for array [3,3,1,2,1,2]\n we have not blocked only the bar between 3\n and 1\n, that is we have |3,3|1,2,1,2|\n.\n\nNow for every such segment we have to change all elements into a common element. So the answer for a segment is segment length minus the number of occurrences of the most frequent element.\n\nOne easy implementation is as follows: blocking is \"+= 1 on segment\" (can be done easily in O(n+operations)\n in offline, then for an element x\n, put the number of it's occurrences in the position of first occurrences.\n\nNow we only need to compute max on disjoint segments, so it can be done in a naive way."
}