{
    "link": "https://codeforces.com//contest/1987/problem/F1",
    "problemId": "2726565",
    "problem_idx": "F1",
    "shortId": "1987F1",
    "contest_number": "1987",
    "problem_submissions": {
        "E": [
            268229906,
            268158602,
            268423905,
            268422817,
            268157857,
            268152628,
            268233241,
            268233207,
            268156681,
            268158666,
            268162964,
            268158456,
            268163362,
            268156782,
            268165522,
            268170420,
            268158686,
            268162341,
            268233753,
            268228306,
            268160955,
            268160065,
            268161194,
            268164320,
            268163376,
            268166928,
            268264962,
            268164535
        ],
        "H": [
            268205560,
            268243575,
            268242763,
            268242753,
            268226875,
            268226200,
            286117872,
            286117361,
            268621342,
            270559507
        ],
        "G2": [
            268199327,
            268183184,
            268209905,
            268197988,
            268210865,
            268209119,
            268201265,
            268217291,
            268203603,
            268206936,
            268211532,
            268216966,
            268392569
        ],
        "G1": [
            268197008,
            268183589,
            268183559,
            268192970,
            268191020,
            268190335,
            268201091,
            268194194,
            268192954,
            268200485,
            268201459,
            268210583,
            268191184,
            268204488,
            268195197,
            268205593,
            268203056,
            268392539,
            268196879,
            268201576,
            268201255
        ],
        "F2": [
            268174418,
            268166457,
            268162505,
            268182920,
            268168846,
            268174436,
            268185759,
            268178301,
            268181565,
            268191599,
            268193415,
            268177500,
            268170902,
            268180818,
            268174520,
            268182719,
            268178817,
            268190336,
            268190071
        ],
        "F1": [
            268173831,
            268166694,
            268162641,
            268178377,
            268169399,
            268174193,
            268185332,
            268177979,
            268170897,
            268181978,
            268191481,
            268193293,
            268177600,
            268169616,
            268180668,
            268173797,
            268182414,
            268176479,
            268181249,
            268189979
        ],
        "D": [
            268149772,
            268151878,
            268147683,
            268147422,
            268149471,
            268152924,
            268151963,
            268155962,
            268148798,
            268153037,
            268153285,
            268152472,
            268152498,
            268151784,
            268149550,
            268150424,
            268156633,
            268151156,
            268159183,
            268155639
        ],
        "C": [
            268144323,
            268147501,
            268383290,
            268143974,
            268142997,
            268142336,
            268156117,
            268145345,
            268149662,
            268144034,
            268146014,
            268146306,
            268146500,
            268154494,
            268145000,
            268144648,
            268146061,
            268146320,
            268145299,
            268148183,
            268146033
        ],
        "B": [
            268142097,
            268138793,
            268136942,
            268137419,
            268137014,
            268140558,
            268141012,
            268143732,
            268140016,
            268142374,
            268143256,
            268141729,
            268142582,
            268139760,
            268140776,
            268140696,
            268140576,
            268139314,
            268141992,
            268141951
        ],
        "A": [
            268135899,
            268135441,
            268135342,
            268135356,
            268135339,
            268135852,
            268135895,
            268139203,
            268135363,
            268137561,
            268136567,
            268135744,
            268136590,
            268135768,
            268135350,
            268135764,
            268135555,
            268135575,
            268136024,
            268138028
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131053",
    "editorial": "Suppose there is a way to remove the entire array. Let\u00e2\u0080\u0099s look at the\r\nprocess in reverse. Then, we are effectively inserting pairs of adjacent\r\nelements into an array until we get the original one. Let\u00e2\u0080\u0099s look at a\r\nmirror process, where instead we keep inserting pairs of brackets to get\r\na balanced bracket sequence.For example, consider the array . Then, one\r\npossible way to delete it is . If we now build our bracket sequence, we\r\nget .Note that such a bracket sequence doesn\u00e2\u0080\u0099t tell us in which order\r\nthe operation needs to be performed, only on which indices.Let\u00e2\u0080\u0099s go back\r\nto the original problem. Suppose we want to eventually perform the\r\noperation on index (in the indexation of the original array). Then, two\r\nconditions must be met: must hold, since the operation does not change\r\nthe parity of indices. Exactly operations must be made to the left of\r\nbefore we apply the operation on it. This, together with the bracket\r\nanalogy, leads to a pretty natural dynamic programming solution: min\r\nnumber of operations that need to be performed to the left of to be able\r\nto remove the subsegment . If , initialize , else initialize .Similar to\r\ndps on balanced bracket sequences, for , we will iterate over the other\r\nelement with which we will perform the operation, : If is greater than ,\r\nit is impossible to apply the operation on the pair , so we do not\r\nupdate . Else, it will take at least operations to the left of to delete\r\nthis subsegment if we want to perform the operation on . So we update as\r\nfollows: . Suppose we have calculated all the values of . Let\u00e2\u0080\u0099s\r\nintroduce the maximum number of times that we can perform the operation\r\non the prefix , initially for all . Then, for some , the transitions are\r\nto iterate over all and update if holds. The answer to the problem is\r\n.It takes time to calculate the values of , and time for . Complexity:\r\nNote: to solve F1, you can calculate the values of the maximum number of\r\noperations that you can perform on the subsegment if exactly operations\r\nwere performed to the left of , which can be done similar to the way\r\nabove in . The answer will be .\r\n",
    "name": "F1. Interesting Problem  Easy Version ",
    "statement": "You are given an array of integers a of length n. In one operation, you\r\nwill perform the following two-step process: Choose an index i such that\r\n1\r\nle i < |a| and a_i = i. Remove a_i and a_{i+1} from the array and\r\nconcatenate the remaining parts. Find the maximum number of times that\r\nyou can perform the operation above.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, \"/stack:200000000\")#pragma GCC optimize(\"O3\")//~ #pragma GCC target (\"avx2\")//~ #pragma GCC optimize(\"Ofast\")//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")//~ #pragma GCC optimize(\"unroll-loops\")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>\u00a0using namespace __gnu_pbds;using namespace std;\u00a0template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\u00a0#define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << \"(\" << d.first << \", \" << d.second << \")\";}sim dor(rge<c> d) {  *this << \"[\";  for (auto it = d.b; it != d.e; ++it)    *this << \", \" + 2 * (it == d.b) << *it;  ris << \"]\";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\u00a0#define shandom_ruffle random_shuffle\u00a0using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=807;const int inf=1e9;\u00a0int n;\u00a0int tab[nax];\u00a0int dp[nax][nax];\u00a0int pref[nax];\u00a0void mini(int &a, int b){\ta=min(a, b);}\u00a0void maxi(int &a, int b){\ta=max(a, b);}\u00a0void test(){\tscanf(\"%d\", &n);\tfor (int i=1; i<=n; i++)\t\tscanf(\"%d\", &tab[i]);\tfor (int i=0; i<=n+1; i++)\t\tfor (int j=0; j<=n+1; j++)\t\t\tdp[i][j]=inf;\tfor (int p=1; p<=n; p++)\t{\t\tfor (int l=p-1; l>=1; l-=2)\t\t{\t\t\tfor (int i=l+1; i<p; i+=2)\t\t\t\tmini(dp[l][p], max(dp[l][i], dp[i+1][p]-(i-l+1)/2));\t\t\tif ((tab[l]&1)!=(l&1) || tab[l]>l)\t\t\t\tcontinue;\t\t\tif (l+1==p)\t\t\t{\t\t\t\tmini(dp[l][p], (l-tab[l])/2);\t\t\t\tcontinue;\t\t\t}\t\t\tint x=(l-tab[l])/2;\t\t\tif (dp[l+1][p-1]<=x)\t\t\t\tmini(dp[l][p], x);\t\t}\t}\t//~ for (int i=1; i<=n; i++)\t\t//~ for (int j=i; j<=n; j++)\t\t\t//~ if (dp[i][j]<inf)\t\t\t\t//~ debug() << i << \" \" << j << \" \" << dp[i][j];\tfor (int i=0; i<=n+1; i++)\t\tpref[i]=-inf;\tpref[0]=0;\tfor (int i=0; i<n; i++)\t{\t\tmaxi(pref[i+1], pref[i]);\t\tfor (int j=i+1; j<=n; j++)\t\t{\t\t\tif (dp[i+1][j]<=pref[i])\t\t\t\tmaxi(pref[j], pref[i]+(j-i)/2);\t\t}\t}\tprintf(\"%d\\n\", pref[n]);}\u00a0int main(){\tint t;\tscanf(\"%d\", &t);\twhile(t--)\t\ttest();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F1. Interesting Problem  Easy Version .json"
}