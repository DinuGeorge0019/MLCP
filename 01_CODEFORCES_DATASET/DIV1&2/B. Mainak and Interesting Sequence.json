{
    "link": "https://codeforces.com//contest/1726/problem/B",
    "problemId": "1532134",
    "problem_idx": "B",
    "shortId": "1726B",
    "contest_number": "1726",
    "problem_submissions": {
        "H": [
            171166152,
            173790631,
            203781522
        ],
        "G": [
            171127286,
            171123945,
            171187552,
            171141010,
            171140722,
            171664786,
            171144226,
            171145348,
            171099465,
            171201134,
            171130848,
            171158116,
            171157860,
            171157000,
            171126442,
            171148861,
            171157096,
            171154938,
            171734872,
            171170680,
            171137702,
            171157236,
            171205955
        ],
        "F": [
            171108903,
            171111157,
            171113439,
            171121881,
            171130813,
            171124755,
            171146710,
            171185756,
            171127747,
            171154469,
            171132548,
            171129760,
            171128679,
            171131869,
            171129630,
            171127886,
            171131493,
            171128356
        ],
        "E": [
            171094108,
            171082776,
            171092673,
            171103228,
            171099685,
            171107510,
            171130522,
            171086219,
            171098373,
            171093064,
            171087566,
            171101329,
            171097980,
            171106309,
            171103049,
            171115448,
            171104715,
            171104412,
            171103731,
            171103976
        ],
        "D": [
            171086407,
            171094193,
            171085018,
            171163183,
            171095551,
            171089125,
            171099036,
            171122521,
            171096908,
            171110181,
            171221601,
            171081072,
            171080401,
            171083405,
            171092300,
            171088283,
            171088398,
            171090938,
            171088918,
            171097824,
            171093263,
            171092066
        ],
        "C": [
            171077821,
            171073174,
            171072071,
            171078629,
            171077517,
            171086726,
            171108612,
            171075141,
            171072509,
            171072364,
            171070939,
            171070414,
            171078452,
            171075783,
            171074035,
            171078333,
            171078838,
            171087703,
            171078897,
            171079488
        ],
        "B": [
            171071571,
            171066055,
            171068756,
            171072172,
            171073247,
            171082438,
            171105681,
            171070428,
            171069384,
            171068782,
            171068043,
            171068503,
            171068633,
            171073450,
            171069653,
            171069194,
            171074033,
            171074318,
            171074355,
            171074835
        ],
        "A": [
            171065811,
            171064612,
            171065880,
            171065721,
            171066103,
            171072016,
            171102188,
            171066260,
            171065726,
            171065055,
            171065128,
            171065050,
            171064937,
            171065648,
            171066070,
            171065533,
            171067186,
            171069008,
            171074050,
            171065687
        ]
    },
    "name": "B. Mainak and Interesting Sequence",
    "statement": "Mainak has two positive integers n and m.Mainak finds a sequence a_1,\r\na_2,\r\nldots, a_n of n positive integers , if integers i (1\r\nle i\r\nle n), the bitwise XOR of all elements in a which are than a_i is 0.\r\nFormally if p_i is the bitwise XOR of all elements in a which are\r\nstrictly less than a_i, then a is an sequence if p_1 = p_2 =\r\nldots = p_n = 0.For example, sequences [1,3,2,3,1,2,3], [4,4,4,4], [25]\r\nare , whereas [1,2,3,4] (p_2 = 1\r\nne 0), [4,1,1,2,4] (p_1 = 1\r\noplus 1\r\noplus 2 = 2\r\nne 0), [29,30,30] (p_2 = 29\r\nne 0) arenâ€™t interesting.Here a\r\noplus b denotes bitwise XOR of integers a and b.Find any sequence a_1,\r\na_2,\r\nldots, a_n (or report that there exists no such sequence) such that the\r\nsum of the elements in the sequence a is equal to m, i.e. a_1 + a_2\r\nldots + a_n = m.As a reminder, the bitwise XOR of an empty sequence is\r\nconsidered to be 0.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tints(N,M);\n\tif (M < N) {\n\t\tps(\"No\");\n\t\treturn;\n\t}\n\tvi ans;\n\tif (N&1) {\n\t\tFOR(i,1,N) ans.pb(1);\n\t\tans.pb(M-(N-1));\n\t} else {\n\t\tif (M&1) {\n\t\t\tps(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tFOR(i,1,N-1) ans.pb(1);\n\t\tans.pb((M-(N-2))/2);\n\t\tans.pb((M-(N-2))/2);\n\t}\n\tps(\"Yes\");\n\tps(ts_sep(ans, \" \"));\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Mainak and Interesting Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/106675",
    "editorial": ": In an sequence , every element other than the largest must have even\r\noccurrences.: For the sake of contradiction, assume that for some (),\r\nsuch than , appears an odd number of times. Let denote the bitwise XOR\r\nof all elements in that are less than . By assumption . Now, since is\r\nnot maximum of the sequence , there exists in , such that and there are\r\nno other elements such that (in other words, is the immediate larger\r\nelement of in ). Again, as well by assumption. However, since appears an\r\nodd number of times, we have: , which is a contradiction as must be\r\npositive.This gives us an solution as follows: : If It is clearly\r\nimpossible to construct an interesting sequence with sum equal to (as\r\nintegers must be positive). : is odd Create occurrences of , and a\r\nsingle occurrence of . : is even, is even Create occurrences of and two\r\noccurrences of . : is even, is odd No such interesting sequences exist.\r\n: For the sake of contradiction assume that such an interesting\r\nsequence, , exists. Since is odd, there must be an odd number that\r\noccurs an odd number of times in . Again since is even there must be\r\nanother integer (different from ) that occurs an also odd number of\r\ntimes. Hence either or (whichever is lower) violates the lemma.\r\n",
    "hint": [
        "Hint 1 Which cases of and are easy to come up with a solution? Which cases is it easy to show that no solution exist?",
        "Hint 2 What happens when is even but is odd?"
    ]
}