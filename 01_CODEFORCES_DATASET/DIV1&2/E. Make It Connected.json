{"link": "https://codeforces.com//contest/1761/problem/E", "problemId": "1651705", "problem_idx": "E", "shortId": "1761E", "contest_number": "1761", "problem_submissions": {"F1": [181783681, 181789408, 181787826, 181807817, 181793725, 181798874, 181812117, 181796851, 181792193, 181797286, 181792466, 181800291, 181799120, 181798951, 181797538, 181796549, 181801616, 181795934, 181802212, 181805577, 181795481], "E": [181767412, 181775228, 181773318, 181773199, 181776029, 181768641, 181774177, 181773946, 181778599, 181783359, 181770606, 181780149, 181779791, 181784860, 181784163, 181786738, 181799018, 181784766, 181805355, 181777139], "B": [181758217, 181754631, 181753022, 181750562, 181750818, 181752710, 181752904, 181761535, 181751867, 181753244, 181749713, 181752562, 181752197, 181751335, 181785787, 181754006, 181756438, 181751473, 181751400, 181750387], "C": [181757137, 181757883, 181756839, 181754860, 181753609, 181755220, 181756960, 181758423, 181755837, 181756467, 181755169, 181757040, 181757304, 181769451, 181757169, 181757887, 181761524, 181755570, 181754021, 181753237], "D": [181754215, 181780914, 181764059, 181764559, 181763628, 181762248, 181763698, 181768454, 181766485, 181764872, 181761188, 181770079, 181765691, 181765764, 181766812, 181780108, 181774890, 181778415, 181762397, 181766534], "A": [181747969, 181747996, 181753999, 181748106, 181748091, 181748074, 181748126, 181748232, 181748177, 181750270, 181748024, 181748492, 181748221, 181748149, 181749212, 181750341, 181748955, 181748081, 181748111, 181748040], "G": [181798925, 181813421], "F2": [181809122, 181811738, 181814199, 181819747, 181813452, 181813278, 181812897, 181812682, 181812626, 181812463, 181811716, 181806789]}, "name": "E. Make It Connected", "statement": "You are given a simple undirected graph consisting of n vertices. The\r\ngraph doesn\u2019t contain self-loops, there is at most one edge between each\r\npair of vertices. Your task is simple: make the graph connected.You can\r\ndo the following operation any number of times (possibly zero): Choose a\r\nvertex u arbitrarily. For each vertex v satisfying v\r\nne u in the graph individually, if v is adjacent to u, remove the edge\r\nbetween u and v, otherwise add an edge between u and v. Find the minimum\r\nnumber of operations required to make the graph connected. Also, find\r\nany sequence of operations with the minimum length that makes the graph\r\nconnected.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 20.11.2022 19:01:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    vector<int> deg(n);\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n      for (int j = 0; j < n; j++) {\n        if (s[i][j] == '1') {\n          deg[i] += 1;\n        }\n      }\n    }\n    vector<bool> was(n, false);\n    vector<vector<int>> all;\n    for (int st = 0; st < n; st++) {\n      if (was[st]) {\n        continue;\n      }\n      vector<int> que(1, st);\n      was[st] = true;\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int i = 0; i < n; i++) {\n          if (!was[i] && s[que[b]][i] == '1') {\n            was[i] = true;\n            que.push_back(i);\n          }\n        }\n      }\n      all.push_back(que);\n    }\n    if (all.size() == 1) {\n      cout << 0 << '\\n';\n      continue;\n    }\n    int one = -1;\n    for (auto& v : all) {\n      int sz = (int) v.size();\n      if (sz == 1) {\n        one = v[0];\n        break;\n      }\n      int cnt = 0;\n      for (int x : v) {\n        if (deg[x] == sz - 1) {\n          cnt += 1;\n        }\n      }\n      if (cnt == sz) {\n        continue;\n      }\n      if (cnt == 0) {\n        one = v.back();\n        break;\n      }\n      for (int x : v) {\n        if (deg[x] < sz - 1) {\n          one = x;\n          break;\n        }\n      }\n      break;\n    }\n    if (one != -1) {\n      cout << 1 << '\\n';\n      cout << one + 1 << '\\n';\n      continue;\n    }\n    if (all.size() > 2) {\n      cout << 2 << '\\n';\n      cout << all[0][0] + 1 << \" \" << all[1][0] + 1 << '\\n';\n      continue;\n    }\n    auto& v = (all[0].size() < all[1].size() ? all[0] : all[1]);\n    cout << v.size() << '\\n';\n    for (int i = 0; i < (int) v.size(); i++) {\n      cout << v[i] + 1 << \" \\n\"[i == (int) v.size() - 1];\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "constructive algorithms", "dsu", "graphs", "greedy", "matrices", "trees", "two pointers"], "dificulty": "2400", "interactive": false}