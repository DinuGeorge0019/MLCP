{
    "link": "https://codeforces.com//contest/1975/problem/E",
    "problemId": "2665476",
    "problem_idx": "E",
    "shortId": "1975E",
    "contest_number": "1975",
    "problem_submissions": {
        "H": [
            262631844,
            262612241,
            262600659,
            262612635,
            263096548
        ],
        "G": [
            262620370,
            262584629,
            262630306,
            262578664,
            262622745,
            262588918,
            262593694,
            262594206,
            262595918,
            262599422,
            262708940,
            262706456,
            262598241,
            262653444,
            262620831,
            262602673,
            262607334,
            262630272,
            262607273,
            262706071,
            262602704,
            262606536,
            262606903,
            262607812,
            263091775,
            263089587,
            263088604,
            263088409,
            263086834,
            263086045,
            262606154,
            264861303,
            262776553,
            262774627,
            262774590,
            262661298,
            262661024,
            262660704,
            262660316,
            262660273,
            262649420,
            262647737,
            262637294,
            262637274,
            262636778,
            262636749,
            262636610,
            262628729,
            262609429
        ],
        "E": [
            262558741,
            262555523,
            262542791,
            262569978,
            262560342,
            262572286,
            262561563,
            262558869,
            262555295,
            262569100,
            262560726,
            262553867,
            262556464,
            262558648,
            262561133,
            262565554,
            262576529,
            262575502,
            262635435,
            262635401,
            262635086,
            262635019,
            262630627,
            262630590,
            262570080
        ],
        "F": [
            262544594,
            262562050,
            262557811,
            262552279,
            262571108,
            262585701,
            262572669,
            262581085,
            262582375,
            262578636,
            262570215,
            262564737,
            262572783,
            262580057,
            262586122,
            262583527,
            262590488,
            262590492,
            262629974,
            262593633
        ],
        "D": [
            262526751,
            262533906,
            262549799,
            262548001,
            262535765,
            262555432,
            262532809,
            262542647,
            262536556,
            262547635,
            262538823,
            262574019,
            262544846,
            262547400,
            262544181,
            262539052,
            262538393,
            262538893,
            262629935,
            262543856
        ],
        "A": [
            262522755,
            262521103,
            262521181,
            262521345,
            262530553,
            262521158,
            262521224,
            262521209,
            262523388,
            262521604,
            262521957,
            262521117,
            262521171,
            262521739,
            262524060,
            262521821,
            262521219,
            262521958
        ],
        "C": [
            262522159,
            262524942,
            262525029,
            262526905,
            262542130,
            262526806,
            262529464,
            262528086,
            262531414,
            262526373,
            262530226,
            262525393,
            262531728,
            262530061,
            262528640,
            262528306,
            262542306,
            262526711
        ],
        "B": [
            262521205,
            262521505,
            262522451,
            262522658,
            262534024,
            262523709,
            262523854,
            262522613,
            262526293,
            262523579,
            262524186,
            262521924,
            262522192,
            262523093,
            262522741,
            262523954,
            262521898,
            262521340
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129801",
    "editorial": "We can maintain the number of black vertices with\nblack child vertices in . When we flip the color of one vertex, only it\nand its parent node are affected.If the black vertices form a chain: -\nno black vertex that has three or more black child vertices and there is\nat most one black vertex that has two black child vertices. - there is\nat most one black vertex whose parent vertex is white. - if there is one\nblack vertex that has two black child vertices, its parent vertex must\nbe white.\n",
    "name": "E. Chain Queries",
    "statement": "You are given a tree of n vertices numbered from 1 to n. Initially, all\r\nvertices are colored white or black.You are asked to perform q queries:\r\n\"\" toggle the color of vertex u (if it was white, change it to black and\r\nvice versa). After each query, you should answer whether all the black\r\nvertices form a chain. That is, there exist two black vertices such that\r\nthe simple path between them passes through all the black vertices and\r\nonly the black vertices. Specifically, if there is only one black\r\nvertex, they form a chain. If there are no black vertices, they do form\r\na chain.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 25.05.2024 10:44:51**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };\u00a0  vector<edge> edges;  vector<vector<int>> g;  int n;\u00a0  graph(int _n) : n(_n) {    g.resize(n);  }\u00a0  virtual int add(int from, int to, T cost) = 0;};\u00a0template <typename T>class forest : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;\u00a0  forest(int _n) : graph<T>(_n) {  }\u00a0  int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    assert(id < n - 1);    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }};\u00a0template <typename T>class dfs_forest : public forest<T> { public:  using forest<T>::edges;  using forest<T>::g;  using forest<T>::n;\u00a0  vector<int> pv;  vector<int> pe;  vector<int> order;  vector<int> pos;  vector<int> end;  vector<int> sz;  vector<int> root;  vector<int> depth;  vector<T> dist;\u00a0  dfs_forest(int _n) : forest<T>(_n) {  }\u00a0  void init() {    pv = vector<int>(n, -1);    pe = vector<int>(n, -1);    order.clear();    pos = vector<int>(n, -1);    end = vector<int>(n, -1);    sz = vector<int>(n, 0);    root = vector<int>(n, -1);    depth = vector<int>(n, -1);    dist = vector<T>(n);  }\u00a0  void clear() {    pv.clear();    pe.clear();    order.clear();    pos.clear();    end.clear();    sz.clear();    root.clear();    depth.clear();    dist.clear();  }\u00a0 private:  void do_dfs(int v) {    pos[v] = (int) order.size();    order.push_back(v);    sz[v] = 1;    for (int id : g[v]) {      if (id == pe[v]) {        continue;      }      auto &e = edges[id];      int to = e.from ^ e.to ^ v;      depth[to] = depth[v] + 1;      dist[to] = dist[v] + e.cost;      pv[to] = v;      pe[to] = id;      root[to] = (root[v] != -1 ? root[v] : to);      do_dfs(to);      sz[v] += sz[to];    }    end[v] = (int) order.size() - 1;  }\u00a0  void do_dfs_from(int v) {    depth[v] = 0;    dist[v] = T{};    root[v] = v;    pv[v] = pe[v] = -1;    do_dfs(v);  }\u00a0 public:  void dfs(int v, bool clear_order = true) {    if (pv.empty()) {      init();    } else {      if (clear_order) {        order.clear();      }    }    do_dfs_from(v);  }\u00a0  void dfs_all() {    init();    for (int v = 0; v < n; v++) {      if (depth[v] == -1) {        do_dfs_from(v);      }    }    assert((int) order.size() == n);  }};\u00a0template <typename T>class lca_forest : public dfs_forest<T> { public:  using dfs_forest<T>::edges;  using dfs_forest<T>::g;  using dfs_forest<T>::n;  using dfs_forest<T>::pv;  using dfs_forest<T>::pos;  using dfs_forest<T>::end;  using dfs_forest<T>::depth;\u00a0  int h;  vector<vector<int>> pr;\u00a0  lca_forest(int _n) : dfs_forest<T>(_n) {  }\u00a0  inline void build_lca() {    assert(!pv.empty());    int max_depth = 0;    for (int i = 0; i < n; i++) {      max_depth = max(max_depth, depth[i]);    }    h = 1;    while ((1 << h) <= max_depth) {      h++;    }    pr.resize(n);    for (int i = 0; i < n; i++) {      pr[i].resize(h);      pr[i][0] = pv[i];    }    for (int j = 1; j < h; j++) {      for (int i = 0; i < n; i++) {        pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);      }    }  }\u00a0  inline bool anc(int x, int y) {    return (pos[x] <= pos[y] && end[y] <= end[x]);  }\u00a0  inline int go_up(int x, int up) {    assert(!pr.empty());    up = min(up, (1 << h) - 1);    for (int j = h - 1; j >= 0; j--) {      if (up & (1 << j)) {        x = pr[x][j];        if (x == -1) {          break;        }      }    }    return x;  }\u00a0  inline int lca(int x, int y) {    assert(!pr.empty());    if (anc(x, y)) {      return x;    }    if (anc(y, x)) {      return y;    }    for (int j = h - 1; j >= 0; j--) {      if (pr[x][j] != -1 && !anc(pr[x][j], y)) {        x = pr[x][j];      }    }    return pr[x][0];  }};\u00a0const int inf = int(1e9);\u00a0class segtree { public:  struct node {    int mx = -1;    int mn = inf;    int mx_id = -1;    int mn_id = -1;\u00a0    void apply(int l, int r, int v, int vv) {      mx = v;      mx_id = l;      mn = vv;      mn_id = l;    }  };\u00a0  node unite(const node &a, const node &b) const {    node res;    res.mx = max(a.mx, b.mx);    res.mx_id = (res.mx == a.mx ? a.mx_id : b.mx_id);    res.mn = min(a.mn, b.mn);    res.mn_id = (res.mn == a.mn ? a.mn_id : b.mn_id);    return res;  }\u00a0  inline void push(int x, int l, int r) {  }\u00a0  inline void pull(int x, int z) {    tree[x] = unite(tree[x + 1], tree[z]);  }\u00a0  int n;  vector<node> tree;\u00a0  void build(int x, int l, int r) {    if (l == r) {      return;    }    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    build(x + 1, l, y);    build(z, y + 1, r);    pull(x, z);  }\u00a0  template <typename M>  void build(int x, int l, int r, const vector<M> &v) {    if (l == r) {      tree[x].apply(l, r, v[l]);      return;    }    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    build(x + 1, l, y, v);    build(z, y + 1, r, v);    pull(x, z);  }\u00a0  node get(int x, int l, int r, int ll, int rr) {    if (ll <= l && r <= rr) {      return tree[x];    }    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    push(x, l, r);    node res{};    if (rr <= y) {      res = get(x + 1, l, y, ll, rr);    } else {      if (ll > y) {        res = get(z, y + 1, r, ll, rr);      } else {        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));      }    }    pull(x, z);    return res;  }\u00a0  template <typename... M>  void modify(int x, int l, int r, int ll, int rr, const M&... v) {    if (ll <= l && r <= rr) {      tree[x].apply(l, r, v...);      return;    }    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    push(x, l, r);    if (ll <= y) {      modify(x + 1, l, y, ll, rr, v...);    }    if (rr > y) {      modify(z, y + 1, r, ll, rr, v...);    }    pull(x, z);  }\u00a0  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {    if (l == r) {      return l;    }    push(x, l, r);    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    int res;    if (f(tree[x + 1])) {      res = find_first_knowingly(x + 1, l, y, f);    } else {      res = find_first_knowingly(z, y + 1, r, f);    }    pull(x, z);    return res;  }\u00a0  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {    if (ll <= l && r <= rr) {      if (!f(tree[x])) {        return -1;      }      return find_first_knowingly(x, l, r, f);    }    push(x, l, r);    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    int res = -1;    if (ll <= y) {      res = find_first(x + 1, l, y, ll, rr, f);    }    if (rr > y && res == -1) {      res = find_first(z, y + 1, r, ll, rr, f);    }    pull(x, z);    return res;  }\u00a0  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {    if (l == r) {      return l;    }    push(x, l, r);    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    int res;    if (f(tree[z])) {      res = find_last_knowingly(z, y + 1, r, f);    } else {      res = find_last_knowingly(x + 1, l, y, f);    }    pull(x, z);    return res;  }\u00a0  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {    if (ll <= l && r <= rr) {      if (!f(tree[x])) {        return -1;      }      return find_last_knowingly(x, l, r, f);    }    push(x, l, r);    int y = (l + r) >> 1;    int z = x + ((y - l + 1) << 1);    int res = -1;    if (rr > y) {      res = find_last(z, y + 1, r, ll, rr, f);    }    if (ll <= y && res == -1) {      res = find_last(x + 1, l, y, ll, rr, f);    }    pull(x, z);    return res;  }\u00a0  segtree(int _n) : n(_n) {    assert(n > 0);    tree.resize(2 * n - 1);    build(0, 0, n - 1);  }\u00a0  template <typename M>  segtree(const vector<M> &v) {    n = v.size();    assert(n > 0);    tree.resize(2 * n - 1);    build(0, 0, n - 1, v);  }\u00a0  node get(int ll, int rr) {    assert(0 <= ll && ll <= rr && rr <= n - 1);    return get(0, 0, n - 1, ll, rr);  }\u00a0  node get(int p) {    assert(0 <= p && p <= n - 1);    return get(0, 0, n - 1, p, p);  }\u00a0  template <typename... M>  void modify(int ll, int rr, const M&... v) {    assert(0 <= ll && ll <= rr && rr <= n - 1);    modify(0, 0, n - 1, ll, rr, v...);  }\u00a0  // find_first and find_last call all FALSE elements  // to the left (right) of the sought position exactly once\u00a0  int find_first(int ll, int rr, const function<bool(const node&)> &f) {    assert(0 <= ll && ll <= rr && rr <= n - 1);    return find_first(0, 0, n - 1, ll, rr, f);  }\u00a0  int find_last(int ll, int rr, const function<bool(const node&)> &f) {    assert(0 <= ll && ll <= rr && rr <= n - 1);    return find_last(0, 0, n - 1, ll, rr, f);  }};\u00a0template <typename T>class fenwick { public:  vector<T> fenw;  int n;\u00a0  fenwick(int _n) : n(_n) {    fenw.resize(n);  }\u00a0  void modify(int x, T v) {    while (x < n) {      fenw[x] += v;      x |= (x + 1);    }  }\u00a0  T get(int x) {    T v{};    while (x >= 0) {      v += fenw[x];      x = (x & (x + 1)) - 1;    }    return v;  }};\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, q;    cin >> n >> q;    vector<int> c(n);    for (int i = 0; i < n; i++) {      cin >> c[i];    }    lca_forest<int> g(n);    for (int i = 0; i < n - 1; i++) {      int x, y;      cin >> x >> y;      --x; --y;      g.add(x, y);    }    g.dfs(0);    g.build_lca();    segtree st(n);    for (int it = 0; it < n; it++) {      int v = g.order[it];      st.modify(it, it, c[v] == 1 ? g.depth[v] : -1, c[v] == 1 ? g.depth[v] : inf);    }    int cnt = accumulate(c.begin(), c.end(), 0);    fenwick<int> fenw(n);    for (int i = 0; i < n; i++) {      if (c[i] == 1) {        fenw.modify(g.pos[i], +1);        fenw.modify(g.end[i] + 1, -1);      }    }    while (q--) {      int u;      cin >> u;      --u;      if (c[u] == 0) {        c[u] = 1;        cnt += 1;        fenw.modify(g.pos[u], +1);        fenw.modify(g.end[u] + 1, -1);        st.modify(g.pos[u], g.pos[u], g.depth[u], g.depth[u]);      } else {        c[u] = 0;        cnt -= 1;        fenw.modify(g.pos[u], -1);        fenw.modify(g.end[u] + 1, +1);        st.modify(g.pos[u], g.pos[u], -1, inf);      }      if (cnt == 0) {        cout << \"No\" << '\\n';        continue;      }      auto nd = st.get(0, n - 1);      assert(nd.mx >= 0 && nd.mn != inf);      int x = g.order[nd.mx_id];      int w = g.order[nd.mn_id];      if (!g.anc(w, x)) {        cout << \"No\" << '\\n';        continue;      }      if (w == x) {        cout << (cnt == 1 ? \"Yes\" : \"No\") << '\\n';        continue;      }      int q = g.go_up(x, g.depth[x] - g.depth[w] - 1);      int mx = -1;      int y = -1;      {        assert(g.pos[q] > 0);        auto nd2 = st.get(0, g.pos[q] - 1);        if (nd2.mx > mx) {          mx = nd2.mx;          y = g.order[nd2.mx_id];        }      }      if (g.end[q] < n - 1) {        auto nd2 = st.get(g.end[q] + 1, n - 1);        if (nd2.mx > mx) {          mx = nd2.mx;          y = g.order[nd2.mx_id];        }      }      assert(mx >= 0 && y != -1);      if (g.lca(x, y) != w) {        cout << \"No\" << '\\n';        continue;      }      int sum = fenw.get(g.pos[x]) + fenw.get(g.pos[y]) - fenw.get(g.pos[w]);      if (w != 0) {        sum -= fenw.get(g.pos[g.pv[w]]);      }      int dist = g.depth[x] + g.depth[y] - 2 * g.depth[w];      cout << (sum == cnt && cnt == dist + 1 ? \"Yes\" : \"No\") << '\\n';    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "implementation",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Chain Queries.json"
}