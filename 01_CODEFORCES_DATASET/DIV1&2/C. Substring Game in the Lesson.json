{
    "link": "https://codeforces.com//contest/1220/problem/C",
    "problemId": "415030",
    "problem_idx": "C",
    "shortId": "1220C",
    "contest_number": "1220",
    "problem_submissions": {
        "F": [
            60794655,
            60795420,
            60798012,
            60796211,
            60799458,
            60799042,
            60800694,
            60802837,
            60802344,
            60801389,
            60840886,
            60840780,
            60840626,
            60840499,
            60816071,
            60802432,
            60804302,
            60803333,
            60805888,
            60807155,
            60806082,
            60806528,
            60805639,
            60807120,
            60805696
        ],
        "E": [
            60790215,
            60792421,
            60792651,
            60792239,
            60793143,
            60792840,
            60795721,
            60794580,
            60796658,
            60794976,
            60796781,
            60798760,
            60797350,
            60797489,
            60796246,
            60798051,
            60800665,
            60797651,
            60800039,
            60800893
        ],
        "D": [
            60786802,
            60786831,
            60788316,
            60786890,
            60789386,
            60786761,
            60791950,
            60790977,
            60790845,
            60791802,
            60790799,
            60791826,
            60794564,
            60792553,
            60792010,
            60792977,
            60788272,
            60792327,
            60792666,
            60788893
        ],
        "C": [
            60784461,
            60784654,
            60786011,
            60784793,
            60786790,
            60784487,
            60788242,
            60786432,
            60786611,
            60789040,
            60786867,
            60788037,
            60788357,
            60788969,
            60787866,
            60789945,
            60786608,
            60789677,
            60787852,
            60786166
        ],
        "B": [
            60781859,
            60783053,
            60783409,
            60782430,
            60783345,
            60782386,
            60782468,
            60784465,
            60785209,
            60786375,
            60784225,
            60785909,
            60785762,
            60785740,
            60785272,
            60786460,
            60783349,
            60784859,
            60785464,
            60782087
        ],
        "A": [
            60780482,
            60780507,
            60780481,
            60782646,
            62687701,
            60784803,
            60780490,
            60784397,
            60781094,
            60781294,
            60786801,
            60780787,
            60780645,
            60785632,
            60782015,
            60781702,
            60780484,
            60780455,
            60781879,
            60780860,
            60783535
        ],
        "G": [
            76800366
        ]
    },
    "name": "C. Substring Game in the Lesson",
    "statement": "Mike and Ann are sitting in the classroom. The lesson is boring, so they\r\ndecided to play an interesting game. Fortunately, all they need to play\r\nthis game is a string s and a number k (0\r\nle k < |s|).At the beginning of the game, players are given a substring\r\nof s with left border l and right border r, both equal to k (i.e.\r\ninitially l=r=k). Then players start to make moves one by one, according\r\nto the following rules: A player chooses l^{\r\nprime} and r^{\r\nprime} so that l^{\r\nprime}\r\nle l, r^{\r\nprime}\r\nge r and s[l^{\r\nprime}, r^{\r\nprime}] is lexicographically less than s[l, r]. Then the player changes\r\nl and r in this way: l := l^{\r\nprime}, r := r^{\r\nprime}. Ann moves first. The player, that can’t make a move loses.Recall\r\nthat a substring s[l, r] (l\r\nle r) of a string s is a continuous segment of letters from s that\r\nstarts at position l and ends at position r. For example, \"\" is a\r\nsubstring (s[3, 5]) of \"\" and \"\" is not.Mike and Ann were playing so\r\nenthusiastically that they did not notice the teacher approached them.\r\nSurprisingly, the teacher didn’t scold them, instead of that he said,\r\nthat he can figure out the winner of the game before it starts, even if\r\nhe knows only s and k.Unfortunately, Mike and Ann are not so keen in the\r\ngame theory, so they ask you to write a program, that takes s and\r\ndetermines the winner for all possible k.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tstring s;\n\tcin >> s;\n\t\n\tchar minch = 'z' + 1;\n\tfor (char ch : s) {\n\t\tif (ch > minch) {\n\t\t\tcout << \"Ann\\n\";\n\t\t} else {\n\t\t\tcout << \"Mike\\n\";\n\t\t\tminch = ch;\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Substring Game in the Lesson.json",
    "editorial_link": "https://codeforces.com//blog/entry/69899",
    "editorial": "The main idea of this task is that Mike never moves. Lets fix , there\r\ntwo cases:1) for all , in this case for all , so Ann canât make her\r\nfirst move (Mike wins).2) There is such that . In this case Ann can move\r\nwith substring . If we choose the least possible such that is minimal,\r\nwe will deprive Misha of the opportunity to make a move (Ann wins)Final\r\nsolution: for all we should check whether is the least on substring . It\r\ncan be done with one for in wich we should maintain a minimum on prefix.\r\nComplexity .\r\n",
    "hint": []
}