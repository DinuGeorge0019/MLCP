{
    "link": "https://codeforces.com//contest/1844/problem/G",
    "problemId": "2009578",
    "problem_idx": "G",
    "shortId": "1844G",
    "contest_number": "1844",
    "problem_submissions": {
        "H": [
            213401907,
            214586788,
            213482546,
            213575600
        ],
        "G": [
            213373899,
            213364706,
            213372549,
            213373590,
            213384164,
            213383282,
            213393963,
            213384409,
            213418393,
            213387981,
            213389348,
            213398375,
            213371949,
            213387199,
            213394165,
            213377360,
            213395667,
            213402058,
            213381593,
            213560869
        ],
        "F2": [
            213365751,
            213352374,
            213361750,
            213357168,
            213362030,
            213488425,
            213373147,
            213364872,
            213370323,
            213418391,
            213375744,
            213375673,
            213376380,
            213391972,
            213386286,
            213388069,
            230986552,
            216997553,
            213356538
        ],
        "F1": [
            213360737,
            213346552,
            213355844,
            213353769,
            213356474,
            213367301,
            213365016,
            213370233,
            213418390,
            213370693,
            213375568,
            213369192,
            213377984,
            213354083,
            213383020,
            213393303,
            213372669,
            213376461,
            213401679,
            213346392
        ],
        "E": [
            213337513,
            213326176,
            213327168,
            213328291,
            213335991,
            213344387,
            213331287,
            213347379,
            213418389,
            213352955,
            213345144,
            213334554,
            213382252,
            213336241,
            213360028,
            213342150,
            213401053,
            213350691,
            213367633,
            213327950
        ],
        "D": [
            213318341,
            213311325,
            213318771,
            213314733,
            213318035,
            213321179,
            213319226,
            213340653,
            213317181,
            213324442,
            213316839,
            213340146,
            213326482,
            213318777,
            213944519,
            213330783,
            213332314,
            213324111,
            213326152,
            213309266
        ],
        "C": [
            213311934,
            213315167,
            213312751,
            213311291,
            213312791,
            213313574,
            213311190,
            213319880,
            213418387,
            213328281,
            213316222,
            213310956,
            213328279,
            213320887,
            213311937,
            213944332,
            213316739,
            213317975,
            213317491,
            213320348,
            213316455
        ],
        "B": [
            213305232,
            213307651,
            213304802,
            213304382,
            213303223,
            213306708,
            213313221,
            213310598,
            213305162,
            213310610,
            213305169,
            213311924,
            213315219,
            213307143,
            213944329,
            213309459,
            213321407,
            213309510,
            213312105,
            213303380
        ],
        "A": [
            213298732,
            213301327,
            213298427,
            213298307,
            213298687,
            213299071,
            213298742,
            213299374,
            213298849,
            213300343,
            213298392,
            213301468,
            213298430,
            213298466,
            213944301,
            213301546,
            213298332,
            213298535,
            213305461,
            213298274
        ]
    },
    "name": "G. Tree Weights",
    "statement": "You are given a tree with n nodes labelled 1,2,\r\ndots,n. The i-th edge connects nodes u_i and v_i and has an unknown\r\npositive integer weight w_i. To help you figure out these weights, you\r\nare also given the distance d_i between the nodes i and i+1 for all 1\r\nle i\r\nle n-1 (the sum of the weights of the edges on the simple path between\r\nthe nodes i and i+1 in the tree).Find the weight of each edge. If there\r\nare multiple solutions, print any of them. If there are no weights w_i\r\nconsistent with the information, print a single integer -1.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(\"1.in\",\"r\",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\ninline void read(i64 &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,lc[100005],px[100005],py[100005];\ni64 d[100005],ans[100005],a[100005],c[100005];\nvector<int> bi[100005];\nvector<int> bi2[100005];\nvoid dfs0(int x,int fa)\n{\n\tff(bi2[x],it)if(*it!=fa){\n\t\tint y=px[*it]^py[*it]^x;dfs0(y,*it);\n\t\tans[*it]=d[y]-d[x];\n\t}\n}\nnamespace slpf\n{\n\tint fa[100005],sz[100005],tp[100005],son[100005],dfn[100005],ti,mp[100005],dep[100005];\n\tvoid dfs1(int x,int fa){son[x]=0;slpf::fa[x]=fa;sz[x]=1;ff(bi[x],it)if(*it!=fa){dep[*it]=dep[x]+1;dfs1(*it,x);sz[x]+=sz[*it];if(!son[x]||sz[son[x]]<sz[*it]){son[x]=*it;}}}\n\tvoid dfs2(int x,int t){mp[dfn[x]=++ti]=x;tp[x]=t;if(son[x])dfs2(son[x],t);ff(bi[x],it)if(*it!=fa[x]&&*it!=son[x]){dfs2(*it,*it);} }\n\tint lca(int x,int y){while(tp[x]!=tp[y]){if(dep[tp[x]]<dep[tp[y]])swap(x,y);x=fa[tp[x]];}return mp[min(dfn[x],dfn[y])];}\n};\nvoid solve()\n{\n\tread(n);fz1(i,n-1){int x,y;read(x);read(y);bi[x].push_back(y);bi[y].push_back(x);px[i]=x;py[i]=y;bi2[x].push_back(i);bi2[y].push_back(i);}\n\tslpf::dfs1(1,0);slpf::dfs2(1,1);fz1(i,n-1)read(a[i]),lc[i]=slpf::lca(i,i+1);\n\tfz0k(i,62){\n\t\ti64 lst=0;\n\t\tfz(j,2,n){\n\t\t\ti64 t=a[j-1]-(d[j-1]+d[j]-d[lc[j-1]]*2);\n\t\t\tif(t<0||(t&((1ll<<i)-1))){puts(\"-1\");return;}\n\t\t\tt>>=i;\n\t\t\tlst^=(t&1);\n\t\t\tc[j]=(lst<<i);\n\t\t}\n\t\tfz(j,2,n)d[j]+=c[j];\n\t}\n\tfz1(i,n-1)if(d[i]+d[i+1]-2*d[lc[i]]!=a[i]){\n\t\tputs(\"-1\");return;\n\t}\n\tdfs0(1,0);\n\tfz1(i,n-1)if(ans[i]<=0){puts(\"-1\");return;}\n\tfz1(i,n-1)printf(\"%lld\\n\",ans[i]);\n}\nint main()\n{\n\tint t;t=1;//read(t);\n\twhile(t--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "implementation",
        "math",
        "matrices",
        "number theory",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Tree Weights.json",
    "editorial_link": "https://codeforces.com//blog/entry/118128",
    "editorial": "Let be the sum of the weights of the edges on the path from node to node\r\n. We know that and for all . This is a system of linear equations in\r\nvariables.As should be integers, letâs first solve this system modulo .\r\nThe term disappears, so we just have . Starting from , this uniquely\r\ndetermines , then , and so on.Now that we know , write where is the\r\nfirst bit of . We can rewrite our system of equations as which has the\r\nsame form as the original system. Thus we can repeat this process to\r\nfind (giving ), then , and so on. Note that each bit of is uniquely\r\ndetermined.If a solution exists, it satisfies for all , so it suffices\r\nto repeat this process until we have found the first bits of . Finally,\r\nwe check that these bits correspond to a valid solution where all the\r\noriginal weights are positive.The time complexity is , if the are\r\nprecomputed.Remark: This idea is related to the method of Hensel\r\nLifting.\r\n",
    "hint": [
        "Hint 1 Model the problem as a system of linear equations.",
        "Hint 2 Let be the sum of the weights of the edges on the path from node to node . The equations are of the form .",
        "Hint 3 The intended solution does not do anything like attempt to maintain paths/virtual trees of known weight. One easily overlooked detail that is essential to the solution is that are integers.",
        "Hint 4 Solve the equations modulo first, so that the term disappears.",
        "Hint 5 After solving the equations modulo , we can similarly solve modulo , , etc."
    ]
}