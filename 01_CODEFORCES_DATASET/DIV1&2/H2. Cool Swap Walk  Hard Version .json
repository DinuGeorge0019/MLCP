{
    "link": "https://codeforces.com//contest/2039/problem/H2",
    "problemId": "3044250",
    "problem_idx": "H2",
    "shortId": "2039H2",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "TutorialFirst, read the editorial of the easy version. We can see that\r\nthe bottleneck lies in the fact that after every round of odd-even\r\nsorting, we need to perform a walk operation to ensure that .The\r\nfollowing method can break through this bottleneck: for simplicity,\r\nletâs assume is even. Define the numbers smaller than or equal to as ,\r\nand the numbers bigger than as . If we have , we can repeatedly perform\r\nkey path operations to get the following sequence: In this process, we\r\nonly perform odd-even sorting for the subarray . In this process, we\r\nonly perform odd-even sorting for the subarray . After that, the array\r\nis sorted.Finally, the only remaining problem is how to arrange .Assume\r\nwe have positions such that . Consider what the following operations are\r\ndoing:If we ignore the other numbers these operations correspond\r\nto:Then, we can take any path from to .At first, we perform one\r\noperation to set , then choose positions to obtain .For being odd, we\r\nneed two additional operations for some little adjustments.Overall, we\r\nobtained a sorted array using walks.\r\n",
    "name": "H2. Cool Swap Walk  Hard Version ",
    "statement": "You are given an array a of size n.A is the following process: In an n\r\ntimes n grid, we note the cells in row i and column j as (i, j). You\r\nneed to walk from (1,1) to (n,n), taking only steps to the right or\r\ndown. Formally, if you are in (x,y) currently, you can step to either\r\n(x+1,y) or (x,y+1), but you can not step beyond the boundaries of the\r\ngrid. When you step in (i,j), you swap a_i and a_j when i\r\nneq j.You can perform at most n+4 . Sort the array a_1, a_2,\r\nldots, a_n in non-decreasing order. We can show that it’s always\r\npossible to do so.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;int n;int a[N];int id[N];int b[N];mt19937 rng;void Main() {\t// n = 11;\t// L(i, 1, n) a[i] = i;\t// shuffle(a + 1, a + n + 1, rng);\tcin >> n;\tL(i, 1, n) cin >> a[i];\tL(i, 1, n) id[i] = i;\tsort(id + 1, id + n + 1, [&] (int x, int y) {\t\treturn a[x] < a[y];\t});\tL(i, 1, n) a[id[i]] = i;\tif(n == 2) {\t\tif(a[1] == 1) {\t\t\tcout << \"0\\n\";\t\t} else {\t\t\tcout << \"1\\nRD\\n\";\t\t}\t\treturn;\t}\tint turn = n + 4;\t// int turn = 3;\tcout << turn << '\\n';\tL(i, 1, n) {\t\tb[i] = a[(i + turn - 1) % n + 1];\t}\tR(j, turn, 1) {\t\tint tak = j % 2;\t\tint pos = (-j % n + 1 + n) % n;\t\tif(!pos)pos += n;\t\tstring ans;\t\tL(j, pos + 1, n) {\t\t\tif(j < n && b[j] > b[j + 1] && (n <= 4 || (j - tak) % 2 == 0)) {\t\t\t\tans += \"RRDD\";\t\t\t\tswap(b[j], b[j + 1]);\t\t\t\t++j;\t\t\t} else {\t\t\t\tans += \"RD\";\t\t\t}\t\t}\t\tL(j, 1, pos - 1) {\t\t\tif(j < pos - 1 && b[j] > b[j + 1] && (n <= 4 || (j - tak) % 2 == 0)) {\t\t\t\tans += \"RRDD\";\t\t\t\tswap(b[j], b[j + 1]);\t\t\t\t++j;\t\t\t} else {\t\t\t\tans += \"RD\";\t\t\t}\t\t}\t\tcout << ans << '\\n';\t\tint x = 1, y = 1;\t\tfor(auto c : ans) {\t\t\tif(c == 'R') ++y;\t\t\telse ++x;\t\t\tswap(a[x], a[y]);\t\t}\t\t// L(i, 1, n) {\t\t// \tcout << b[i] << ' ';\t\t// }\t\t// cout << endl;\t\t// L(i, 1, n)\t\t// \tcout << a[i] << ' ';\t\t// cout << endl;\t\t// L(i, 1, n) {\t\t// \tcout << a[(i + j - 2 + n) % n + 1] << ' ';\t\t// }\t\t// cout << endl << endl;\t}\tL(i, 1, n) assert(a[i] == i);\t// L(i, 1, n) {\t// \tcout << a[i] << ' ';\t// }\t// cout << endl;}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "constructive algorithms",
        "constructive algorithms",
        "implementation",
        "sortings"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H2. Cool Swap Walk  Hard Version .json",
    "hint": []
}