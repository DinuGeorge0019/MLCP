{
    "link": "https://codeforces.com//contest/1017/problem/G",
    "problemId": "205997",
    "problem_idx": "G",
    "shortId": "1017G",
    "contest_number": "1017",
    "problem_submissions": {
        "D": [
            213438615,
            41349796,
            41350791,
            41348185,
            41349812,
            41350101,
            41348724,
            41347389,
            41349904,
            41347605,
            41349745,
            41349033,
            41348833,
            41350403,
            41348388,
            41346916,
            41354063,
            41351152,
            41351165,
            41350393
        ],
        "G": [
            41374563,
            41365956,
            41365630,
            41370631,
            41581755
        ],
        "E": [
            41372644,
            41354131,
            41370166,
            41371119,
            41372376,
            41372311,
            41372287,
            41351667,
            41351074,
            41355101,
            41350783,
            41352192,
            41358773,
            41351309,
            41350915,
            41353764,
            41670429,
            41352396,
            41371198,
            41367467,
            41359456,
            41372423,
            41372409,
            41364755,
            41352601,
            41351865,
            41355587
        ],
        "H": [
            41367702,
            41388366,
            41626780
        ],
        "F": [
            41355954,
            41350751,
            41350606,
            41351910,
            41355898,
            41353364,
            41356617,
            41361175,
            41354830,
            41361644,
            41363928,
            41363246,
            41362644,
            41355024,
            41364885,
            41350456,
            41363913,
            41365213,
            41366266
        ],
        "C": [
            41344757,
            41346763,
            41343411,
            41343517,
            41344074,
            41345347,
            41344535,
            41344681,
            41344025,
            41345552,
            41345435,
            41344114,
            41346166,
            41344588,
            41343025,
            41345381,
            41348981,
            41347870,
            41345665
        ],
        "B": [
            41341663,
            41342076,
            41341369,
            41340402,
            41341632,
            41341916,
            41341844,
            41341458,
            41340722,
            41342695,
            41342729,
            41341507,
            41343151,
            41342641,
            41340890,
            41341644,
            41344184,
            41342297,
            41342415
        ],
        "A": [
            41338985,
            41339200,
            41339204,
            41344352,
            41339618,
            41339017,
            41339766,
            41339115,
            41339233,
            41339235,
            41340222,
            41339363,
            41338992,
            41339153,
            41339052,
            41339096,
            41339145,
            41339283,
            41339775
        ]
    },
    "name": "G. The Tree",
    "statement": "Abendsen assigned a mission to Juliana. In this mission, Juliana has a\r\nrooted tree with n vertices. Vertex number 1 is the root of this tree.\r\nEach vertex can be either black or white. At first, all vertices are\r\nwhite. Juliana is asked to process q queries. Each query is one of three\r\ntypes: If vertex v is white, mark it as black; otherwise, perform this\r\noperation on all direct sons of v instead. Mark all vertices in the\r\nsubtree of v (including v) as white. Find the color of the i-th vertex.\r\nCan you help Juliana to process all these queries?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n,q;\nvi c[MX];\nvector<array<int,3>> c2[MX];\nvpi todo;\nbool use[MX], col[MX], clear[MX];\nint push[MX];\n\nvoid dfs1(int x, int p = 0, int white = 0, int dis = 0) {\n    if (use[x]) {\n        if (p) c2[p].pb({x,white,dis});\n        for (int y: c[x]) dfs1(y,x,0,0);\n    } else {\n        if (!col[x]) white ++;\n        for (int y: c[x]) dfs1(y,p,white,dis+1);\n    }\n}\n\nvoid dfs2(int x, int _push = 0, int _clear = 0) {\n    if (use[x]) {\n        _push = push[x];\n        _clear |= clear[x];\n    } else {\n        if (_clear) col[x] = 0;\n        if (_push && !col[x]) col[x] = 1, _push --;\n    }\n    for (int y: c[x]) dfs2(y,_push,_clear);\n}\n\nvoid ad(int x) {\n    if (!col[x]) { col[x] = 1; return; }\n    push[x] ++;\n    for (auto a: c2[x]) if (a[1] < push[x]) ad(a[0]);\n}\n\nvoid clr(int x) {\n    col[x] = 0; push[x] = 0; clear[x] = 1;\n    for (auto& a: c2[x]) { a[1] = a[2]; clr(a[0]); }\n}\n\nvoid process() {\n    FOR(i,1,n+1) {\n        use[i] = 0;\n        clear[i] = 0;\n        push[i] = 0;\n        c2[i].clear();\n    }\n    for (auto a: todo) use[a.s] = 1;\n    dfs1(1);\n    for (auto a: todo) {\n        if (a.f == 1) ad(a.s);\n        else if (a.f == 2) clr(a.s);\n        else cout << (col[a.s]?\"black\":\"white\") << \"\\n\";\n    }\n    dfs2(1);\n    todo.clear();\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> q;\n    FOR(i,2,n+1) {\n        int p; cin >> p;\n        c[p].pb(i);\n    }\n    F0R(i,q) {\n        int t,v; cin >> t >> v;\n        todo.pb({t,v});\n        if (sz(todo) >= 600) process();\n    }\n    process();\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. The Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/61081",
    "editorial": "The problem can be solved using HLD or sqrt-decomposition on queries.\r\nHere, I will explain to you the second solution.Let be a constant.Letâs\r\nsplit all queries on blocks. Each block will contain queries. In each\r\nblock, since we have queries, we will have at most different vertices\r\nthere. Therefore, we can the tree using only those different vertices.\r\nThere will be a directed edge from to if they are both in that set of\r\ndifferent vertices and is an ancestor of in the original tree. A weight\r\nof such edge will be the number of white vertices on the way between\r\nthose two vertices (exclusively and ).If we want to find answers for the\r\nqueries in the black, we need to make every operation in . In each\r\nvertex, we will have the number of operations of the first type that\r\nneed to be processed on that vertex. Also, each vertex will have the\r\nboolean variable that means that we need to clear the subtree.\r\nObviously, when we are doing the second operation, we need to clear\r\nevery in that subtree.After we answer the queries of the -th block, we\r\nneed to update the full graph. So, the complexity will be . If you make\r\n, the complexity will be .For better understanding, you can check the\r\ncode below.\r\n",
    "hint": []
}