{"link": "https://codeforces.com//contest/1684/problem/C", "problemId": "1404373", "problem_idx": "C", "shortId": "1684C", "contest_number": "1684", "problem_submissions": {"H": [157720671, 157721062, 157737875, 157719283, 157728267, 157723148, 157726010, 157736069, 157792151, 157760208, 157735749, 157733310, 157739555, 157762123, 157758402, 157757414], "G": [157708800, 157705200, 157707312, 157718616, 157706754, 157714488, 157707640, 157712978, 157718288, 157710983, 157717212, 157716133, 157711996, 157713632, 157715613, 157714692, 157708417, 157712457, 157717126], "F": [157703000, 157698430, 157700853, 157708707, 157699813, 157705688, 157700819, 157704615, 157713662, 157705196, 157701872, 157704273, 157706345, 157707380, 157707253, 157706734, 157720973, 157723693, 157711135], "E": [157687824, 157689230, 157686803, 157694670, 157693301, 157693626, 157692297, 157688860, 157691406, 157698450, 157692770, 157697303, 157697857, 157695549, 157699844, 157698604, 157694457, 157697019, 157700499], "D": [157681158, 157683410, 157690778, 157683407, 157688074, 157688564, 157683855, 157682485, 157678956, 157684552, 157688505, 157689349, 157690936, 157696580, 157687171, 157693792, 157688577, 157691760, 157692016], "C": [157676125, 157679761, 157680827, 157678864, 157733908, 157680852, 157679175, 157675870, 157680982, 157722992, 157680866, 157688681, 157680491, 157680374, 157689989, 157710336, 157680413, 157683798], "B": [157669712, 157671031, 157673644, 157673851, 157673406, 157672145, 157673363, 157673187, 157671551, 157673379, 157675976, 157675416, 157675741, 157672916, 157673228, 157675698, 157678091, 157671319, 157673490], "A": [157669088, 157669275, 157669176, 157669141, 157669362, 157669203, 157669522, 157669224, 157669098, 157669297, 157671508, 157669642, 157676097, 157669933, 157669278, 157670146, 157669180, 157669153, 157669255]}, "name": "C. Column Swapping", "statement": "You are given a grid with n rows and m columns, where each cell has a\r\npositive integer written on it. Let\u2019s call a grid , if in each row the\r\nsequence of numbers is sorted in a non-decreasing order. It means, that\r\nfor each 1\r\nle i\r\nle n and 2\r\nle j\r\nle m the following holds: a_{i,j}\r\nge a_{i, j-1}.You have to to do the following operation exactly once:\r\nchoose two columns with indexes i and j (), 1\r\nle i, j\r\nle m, and swap them.You are asked to determine whether it is possible to\r\nmake the grid good after the swap and, if it is, find the columns that\r\nneed to be swapped.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 19.05.2022 18:38:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> a(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> a[i][j];\n      }\n    }\n    int x = -1;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        if (a[i][j] > a[i][j + 1]) {\n          x = j;\n        }\n      }\n    }\n    if (x == -1) {\n      cout << \"1 1\" << endl;\n      continue;\n    }\n    auto Flag = [&](int i, int j) {\n      if (i >= 0 && j >= 0 && i < h && j < w - 1 && a[i][j] > a[i][j + 1]) {\n        return 1;\n      }\n      return 0;\n    };\n    vector<int> cnt(h);\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w - 1; j++) {\n        cnt[i] += Flag(i, j);\n      }\n    }\n    int a0 = -1, a1 = -1;\n    for (int j0 = x; j0 <= x + 1; j0++) {\n      for (int j1 = 0; j1 < w; j1++) {\n        if (j0 == j1) {\n          continue;\n        }\n        bool inv = false;\n        if (j0 > j1) {\n          swap(j0, j1);\n          inv = true;\n        }\n        bool ok = true;\n        for (int i = 0; i < h; i++) {\n          int cc = cnt[i];\n          if (j0 + 1 == j1) {\n            cc -= Flag(i, j0 - 1);\n            cc -= Flag(i, j0);\n            cc -= Flag(i, j0 + 1);\n            swap(a[i][j0], a[i][j1]);\n            cc += Flag(i, j0 - 1);\n            cc += Flag(i, j0);\n            cc += Flag(i, j0 + 1);\n            swap(a[i][j0], a[i][j1]);\n          } else {\n            cc -= Flag(i, j0 - 1);\n            cc -= Flag(i, j0);\n            cc -= Flag(i, j1 - 1);\n            cc -= Flag(i, j1);\n            swap(a[i][j0], a[i][j1]);\n            cc += Flag(i, j0 - 1);\n            cc += Flag(i, j0);\n            cc += Flag(i, j1 - 1);\n            cc += Flag(i, j1);\n            swap(a[i][j0], a[i][j1]);\n          }\n          assert(cc >= 0);\n          if (cc > 0) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) {\n          a0 = j0;\n          a1 = j1;\n        }\n        if (inv) {\n          swap(j0, j1);\n        }\n      }\n    }\n    if (a0 == -1) {\n      cout << -1 << '\\n';\n    } else {\n      cout << a0 + 1 << \" \" << a1 + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "greedy", "implementation", "sortings"], "dificulty": "1400", "interactive": false}