{
    "link": "https://codeforces.com//contest/1208/problem/G",
    "problemId": "395882",
    "problem_idx": "G",
    "shortId": "1208G",
    "contest_number": "1208",
    "problem_submissions": {
        "H": [
            59484058,
            59502734,
            76052313
        ],
        "G": [
            59465495,
            59473655,
            59462360,
            59469582,
            59476496,
            59467194,
            59474332,
            59471219,
            59476758,
            59478641,
            59474463,
            59471571,
            59487164,
            59486904,
            59486576,
            59482130,
            59477683,
            59476449,
            59473994,
            59479017,
            59477708,
            59480546
        ],
        "F": [
            59463879,
            59465198,
            59467560,
            59476238,
            59468730,
            59478991,
            59464681,
            59477905,
            59488265,
            59473195,
            59472737,
            59472853,
            59477583,
            59487223,
            59467058,
            59472365,
            59474724,
            59482091,
            59473763,
            59474219,
            59475026
        ],
        "E": [
            59458500,
            59460001,
            59471123,
            59460976,
            59465221,
            59464240,
            59471956,
            59467792,
            59468080,
            59468210,
            59467089,
            59468111,
            59463881,
            59468884,
            59466520,
            59466354,
            59469354,
            59470023,
            59470503
        ],
        "C": [
            59454101,
            59453008,
            59450929,
            59452783,
            59454696,
            59455218,
            59454973,
            59451236,
            59458825,
            59456015,
            59453250,
            59456008,
            59453716,
            59453732,
            59453888,
            59456639,
            59456258,
            59457694,
            59458473
        ],
        "D": [
            59453338,
            59455109,
            59457439,
            59466058,
            59460513,
            59457371,
            59457830,
            59458661,
            59462381,
            59461784,
            59460829,
            59462458,
            59456674,
            59462814,
            59457263,
            59459344,
            59458893,
            59462907,
            59461567
        ],
        "B": [
            59451380,
            59451457,
            59455342,
            59451327,
            59452833,
            59452235,
            59452686,
            59455049,
            59452214,
            59453318,
            59450989,
            59453232,
            59451916,
            59457683,
            59451681,
            59453837,
            59452400,
            59452282,
            59455051
        ],
        "A": [
            59449116,
            59449294,
            59449254,
            59449364,
            59450306,
            59449785,
            59449160,
            59452256,
            59449743,
            59449309,
            59449227,
            59449840,
            59449173,
            59458690,
            59449209,
            59449159,
            59450221,
            59449398,
            59450162
        ]
    },
    "name": "G. Polygons",
    "statement": "You are given two integers n and k.You need to construct k regular\r\npolygons having same circumcircle, with number of sides l between 3 and\r\nn. You can rotate them to minimize the total number of distinct points\r\non the circle. Find the minimum number of such points.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 25.08.2019 18:13:14       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  long long ans = (long long) 9e18;\n  for (int take2 = 0; take2 < 2; take2++) {\n    vector<int> phi(n + 1);\n    for (int i = 1; i <= n; i++) {\n      phi[i] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n      for (int j = i + i; j <= n; j += i) {\n        phi[j] -= phi[i];\n      }\n    }\n    if (!take2) {\n      for (int i = 4; i <= n; i += 2) {\n        phi[i] = (int) 1e9;\n      }\n    }\n    sort(phi.begin() + 3, phi.end());\n    long long cur = 1 + take2;\n    for (int i = 3; i <= k + 2; i++) {\n      cur += phi[i];\n    }\n    ans = min(ans, cur);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Polygons.json",
    "editorial_link": "https://codeforces.com/blog/entry/69357",
    "editorial": "Transform queries into two types: \"change color of a leaf\", and \"answer\r\ncolor of some vertex if k is given\". Note that when all internal\r\nvertices are red. When increasing , each vertex will change its color\r\nexactly once, letâs call this value of as boundary value for this\r\nvertex. If we can keep boundary values for all vertices, answering\r\nqueries is easy. Letâs do sqrt decomposition on queries: group them in\r\nblocks and process in blocks of size . When starting a block, compress\r\nthe tree so that there are interesting vertices: vertices involved in\r\nqueries and LCAs of them. Letâs call subtrees without interesting\r\nvertices as outer subtrees. We can compute the boundary values for all\r\nvertices in outer subtrees once for each block since the colors of\r\nleaves do not change. Now we should compress the paths between the\r\ninteresting vertices. Note that the boundary values on a path only\r\ndepend on the color of the vertex in the bottom end of the path. So for\r\neach such path compute two boundary values: if the vertex in the bottom\r\nend is red or blue. Now we can process queries by using the\r\ncorresponding values of boundary values, going down-up. Straightforward\r\nimplementation leads to preprocessing of each block and query time,\r\nmeaning the overall complexity is . The logarithms are from sorting and\r\nbinary search, respectively, so this solution is already fast enough to\r\nget AC. To implement compression in you need to go from lowest to\r\nhighest possible and maintain which vertices are red in outer subtrees.\r\nNote that the number of different boundary values is , so you can store\r\nfor each the list of vertices having this boundary value. To implement\r\nqueries in , you need to precompute binary search outcomes for the given\r\nvalues while computing the boundary values. This way the overall\r\ncomplexity becomes .\r\n",
    "hint": []
}