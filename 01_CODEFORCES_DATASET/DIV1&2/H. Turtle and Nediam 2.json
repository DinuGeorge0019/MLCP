{
    "link": "https://codeforces.com//contest/2084/problem/H",
    "problemId": "3311137",
    "problem_idx": "H",
    "shortId": "2084H",
    "contest_number": "2084",
    "problem_submissions": {
        "H": [
            314145269,
            314152641,
            314144885,
            314182408,
            314161253,
            314160492,
            314159109,
            314336819,
            315779937
        ],
        "G2": [
            314127203,
            314160979,
            314119099,
            314173756,
            314142893,
            314147799,
            314151130,
            314224010
        ],
        "G1": [
            314118414,
            314131726,
            314153985,
            314109590,
            314130088,
            314137970,
            314137514,
            314122753,
            314126112,
            314121248,
            314130892,
            314132033,
            314119541,
            314121030,
            314132824,
            314120399,
            314110237,
            314140572,
            314142526,
            314121707
        ],
        "F": [
            314111540,
            314121924,
            314125756,
            314134963,
            314116023,
            314127619,
            314126955,
            314113301,
            314113508,
            314112491,
            314118412,
            314115812,
            314130696,
            314134248,
            314124898,
            314139906,
            314148255,
            314122476,
            314118124,
            314136680
        ],
        "E": [
            314096933,
            314100998,
            314106034,
            314097464,
            314098060,
            314098397,
            314100089,
            314096655,
            314098774,
            314103821,
            314098080,
            314100694,
            314097651,
            314097020,
            314098501,
            314106285,
            314091026,
            314103056,
            314104301,
            314104189
        ],
        "D": [
            314089308,
            314084108,
            314093835,
            314087875,
            314090629,
            314088628,
            314087990,
            314086450,
            314087578,
            314093466,
            314087381,
            314087993,
            314088809,
            314087808,
            314089647,
            314085680,
            314097166,
            314093234,
            314095090,
            314092873
        ],
        "C": [
            314088884,
            314079194,
            314084706,
            314078405,
            314080677,
            314082894,
            314084690,
            314079232,
            314080138,
            314078936,
            314078924,
            314080521,
            314081145,
            314083479,
            314082189,
            314078479,
            314078402,
            314080517,
            314081011,
            314085360
        ],
        "B": [
            314071844,
            314073131,
            314077666,
            314072689,
            314074212,
            314075241,
            314071920,
            314070221,
            314072945,
            314073818,
            314072825,
            314073490,
            314072379,
            314074081,
            314073148,
            314071408,
            314071968,
            314072681,
            314074070,
            314073432
        ],
        "A": [
            314070266,
            314070800,
            314074592,
            314070792,
            314070309,
            314073560,
            314069924,
            314069578,
            314070160,
            314071820,
            314069982,
            314069845,
            314070406,
            314070963,
            314070638,
            314069585,
            314069908,
            314069724,
            314069695,
            314070813
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141155",
    "editorial": "First, extract the longest contiguous segments in where the values\r\nremain the same. Suppose there are such segments with lengths . Then,\r\nthe operations can be described as follows: Choose an index such that\r\nand decrease by 1. Choose an index such that . Remove . If , then merge\r\nwith and remove . First handle the corner case when . It can be observed\r\nthat the length of the last segment never increases, and it is\r\nindependent of the preceding segments. Thus, we only need to consider\r\nthe strings that can be generated from , and the final answer is\r\nmultiplied by .Now, consider counting the strings that begin with the\r\nsame character as . For a generated sequence of contiguous segments , we\r\ngreedily find the shortest prefix in that can generate .Define as the\r\nnumber of strings that can match .For the transition when adding a new\r\nsegment , iterate over indices such that . Let be the maximum value of\r\nthat can be generated by the previous . Then, the maximum value that can\r\ngenerate for is . Thus, if is matched at position , we have , which\r\ngives possible values for .Thus, the transition is as follows:The\r\ninitial values are given by . The final answer is .Next, consider\r\ncounting the strings whose first character is different from . It turns\r\nout that if the resulting string starts with a different character, then\r\nin order to delete the first contiguous segment, the second segment can\r\nbe at most of length . Therefore, after removing and setting to , we can\r\nrepeat the above process.Next, we optimize the above DP.Define as the\r\nsmallest such that .For a given , the transition works as follows:\r\nMaintain a variable initialized as . Perform a special transition at .\r\nFor such that , update by adding (which can be implemented using a\r\ndifference array). Set and repeat the process. By directly simulating\r\nthe transition process, it can be shown that the complexity is , since\r\neach is only jumped to at most times.We can further optimize the DP\r\nprocess to . Define as the sum of -values of all positions that can jump\r\nto . Then, the transition is . Additionally, for such that , update by\r\nadding , and then perform a special transition for .: per test case.\r\n",
    "name": "H. Turtle and Nediam 2",
    "statement": "You are given a binary sequence s of length n which only consists of 0\r\nand 1.You can do the following operation (possibly zero): Let m denote\r\nthe current length of s. Choose an integer i such that 1\r\nle i\r\nle m - 2. Let the median^{\r\ntext{ }} of the subarray [s_i, s_{i + 1}, s_{i + 2}] be x, and let j be\r\nthe smallest integer such that j\r\nge i and s_j = x. Remove s_j from the sequence and concatenate the\r\nremaining parts. In other words, replace s with [s_1, s_2,\r\nldots, s_{j - 1}, s_{j + 1}, s_{j + 2},\r\nldots, s_m]. Note that after every operation, the length of s decreases\r\nby 1.Find how many different binary sequences can be obtained after\r\nperforming the operation, modulo 10^9 + 7.^{\r\ntext{ }}The median of an array of odd length k is the\r\nfrac{k + 1}{2}-th element when sorted.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Turtle and Nediam 2.json",
    "hint": [
        "Hint 1 Extract the longest contiguous segments in where the values remain the same.",
        "Hint 2 According to greedy matching, an DP can be obtained.",
        "Hint 3 Optimize the DP from to ."
    ]
}