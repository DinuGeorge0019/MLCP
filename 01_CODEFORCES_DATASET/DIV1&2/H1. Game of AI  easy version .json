{
    "link": "https://codeforces.com//contest/1704/problem/H1",
    "problemId": "1489131",
    "problem_idx": "H1",
    "shortId": "1704H1",
    "contest_number": "1704",
    "problem_submissions": {
        "G": [
            166399832,
            166392509,
            166397270,
            166638387,
            166637822,
            166637785,
            166398104,
            166405958,
            166752775
        ],
        "H1": [
            166382413,
            166388635,
            166396747,
            166390624,
            166393948,
            166394968,
            166395394,
            166395219,
            166399131,
            166395533,
            167610683,
            166399678,
            166398389,
            166393517,
            166397144,
            166394482,
            166410457,
            166410434,
            166410387,
            166397758,
            166388826
        ],
        "F": [
            166375942,
            166373341,
            166380920,
            166379078,
            166375083,
            166374406,
            166381370,
            166374889,
            166379414,
            166377998,
            166381484,
            166382056,
            166383687,
            167610801,
            167610658,
            166377446,
            166386899,
            166386972,
            166382080,
            166385431,
            166386767,
            166397839
        ],
        "E": [
            166364243,
            166366722,
            166377362,
            166370668,
            166369471,
            166363533,
            166365063,
            166369098,
            166371591,
            166372062,
            166371621,
            166363068,
            166369922,
            167610979,
            166372272,
            166368343,
            166370920,
            166372137,
            166377343,
            166374205,
            166366243
        ],
        "D": [
            166356732,
            166359032,
            166354225,
            166361715,
            166364424,
            166358723,
            166360532,
            166363384,
            166359682,
            166359426,
            166360174,
            166357237,
            166358099,
            167610772,
            167610622,
            166360647,
            166358359,
            166360520,
            166363303,
            166368469,
            166361316,
            166360453
        ],
        "C": [
            166354884,
            166355766,
            166368189,
            166358588,
            166361497,
            166354947,
            166356916,
            166357737,
            166356376,
            166355591,
            166357410,
            166354410,
            166354789,
            167610761,
            167610600,
            166356402,
            166355566,
            166357431,
            166360930,
            166363594,
            166359066,
            166357566
        ],
        "B": [
            166350601,
            166350801,
            166351510,
            166352475,
            166352194,
            166351471,
            166350940,
            166351732,
            166351784,
            166352133,
            166351498,
            166351569,
            166351237,
            167610589,
            166351144,
            166351469,
            166352214,
            166353113,
            166355462,
            166352514,
            166351316
        ],
        "A": [
            166350367,
            166350415,
            166350414,
            166351113,
            166350822,
            166350510,
            166350405,
            166350518,
            166350539,
            166350824,
            166350499,
            166350452,
            166350409,
            167610545,
            166350456,
            166350502,
            166350981,
            166354346,
            166351283,
            166350461,
            166350432
        ],
        "H2": [
            166808527
        ]
    },
    "name": "H1. Game of AI  easy version ",
    "statement": "Cirno is playing a war simulator game with n towers (numbered from 1 to\r\nn) and n bots (numbered from 1 to n). The i-th tower is initially\r\noccupied by the i-th bot for 1\r\nle i\r\nle n.Before the game, Cirno first chooses a permutation p = [p_1, p_2,\r\nldots, p_n] of length n (A permutation of length n is an array of length\r\nn where each integer between 1 and n appears exactly once). After that,\r\nshe can choose a sequence a = [a_1, a_2,\r\nldots, a_n] (1\r\nle a_i\r\nle n and a_i\r\nne i for all 1\r\nle i\r\nle n).The game has n rounds of attacks. In the i-th round, if the p_i-th\r\nbot is still in the game, it will begin its attack, and as the result\r\nthe a_{p_i}-th tower becomes occupied by the p_i-th bot; the bot that\r\npreviously occupied the a_{p_i}-th tower will no longer occupy it. If\r\nthe p_i-th bot is not in the game, nothing will happen in this\r\nround.After each round, if a bot doesn\u2019t occupy any towers, it will be\r\neliminated and leave the game. Please note that no tower can be occupied\r\nby more than one bot, but one bot can occupy more than one tower during\r\nthe game.At the end of the game, Cirno will record the result as a\r\nsequence b = [b_1, b_2,\r\nldots, b_n], where b_i is the number of the bot that occupies the i-th\r\ntower at the end of the game.However, as a mathematics master, she wants\r\nyou to solve the following counting problem instead of playing\r\ngames:Count the number of different pairs of sequences a and b that we\r\ncan get from all possible choices of sequence a and permutation p.Since\r\nthis number may be large, output it modulo M.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 31.07.2022 18:10:18       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nvector<Mint> fact;\nvector<Mint> inv_fact;\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n >> md;\n  fact = inv_fact = {1};\n  C(2 * n + 1, 0);\n  Mint ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; 2 * j <= i; j++) {\n      Mint dp = fact[i] * C(i - j - 1, j - 1) * inv_fact[j];\n      int ones = n - i;\n      Mint add = dp * C(n, i) * power(Mint(n - 1), j) * power(Mint(n - j - ones), ones);\n      ans += add;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H1. Game of AI  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/105464",
    "editorial": "Consider calculate the number of possible sequences for a fixed sequence\r\n.We can find that if , that means is occupied by finally, so we have =i.\r\nIf , that means for all that , is occupied before it begins its attack.\r\nAs a result, we must have .The sequences which satisfies the above\r\nconditions is also possible to match a valid . The attacking order can\r\nbe arranged easily.Now for how to count, we can build a graph according\r\nto the information given by . We can see that the graph will in the form\r\nof some chains. Also, we can find that for a graph which consists of\r\nsome chains, we can find the unique which satisfies the graph. Then some\r\npositions of array is also fixed, except the top of each chain. As for\r\nhow to decide the these ( is the top of some chain), we need to divide\r\ninto two situations: one is the chain\u00e2\u0080\u0099s length is greater than , we can\r\nsee that this can take any number between and except ; The other one is\r\nthe chain\u00e2\u0080\u0099s length is one, so cannot be any bottom of each chain. Then\r\nwe can easily calculate the number of arrays by product the possible\r\nnumber of values of each .In conclusion, we can enumerate the number of\r\nchains, and the number of chains with length , then use combination\r\nnumber to calculate. Time complexity is .\r\n"
}