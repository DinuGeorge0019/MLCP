{
    "link": "https://codeforces.com//contest/1428/problem/B",
    "problemId": "762864",
    "problem_idx": "B",
    "shortId": "1428B",
    "contest_number": "1428",
    "problem_submissions": {
        "H": [
            95798388,
            96079889,
            95822989,
            95819273
        ],
        "G2": [
            95777265,
            95779066,
            95783656,
            95782002,
            95792200,
            95787701,
            95792987,
            95787809,
            95792595,
            95788941,
            95788283,
            95789699,
            95792016,
            95786243,
            95795577,
            95795657,
            95796576,
            95798040,
            95805912,
            95794416
        ],
        "G1": [
            95777192,
            95778996,
            95783550,
            95782076,
            95787327,
            95787607,
            95787264,
            95787896,
            95792632,
            95789001,
            95788384,
            95789621,
            95791835,
            95786301,
            95795432,
            95795591,
            95796478,
            95795620,
            95794276,
            95794356
        ],
        "F": [
            95765157,
            95765965,
            95771166,
            95767388,
            95768274,
            95768695,
            95770215,
            95759208,
            95832501,
            95832498,
            95832480,
            95831607,
            95831604,
            95831342,
            95763101,
            95777757,
            95779436,
            95770353,
            95771012,
            95772923,
            95779700,
            95776557,
            95778129,
            95776549,
            95775700,
            95779883
        ],
        "E": [
            95758700,
            95760055,
            95763026,
            95762658,
            95754707,
            95762381,
            95764564,
            95752105,
            95754040,
            95762344,
            95751508,
            95766331,
            95750653,
            95764708,
            95767437,
            95759986,
            95764850,
            95764733,
            95758532,
            95759950
        ],
        "D": [
            95754864,
            95756381,
            95758710,
            95758367,
            95764528,
            95758021,
            95759449,
            95765541,
            95774991,
            95758395,
            95775675,
            95762065,
            95777703,
            95760640,
            95762966,
            95770799,
            95762173,
            95759561,
            95760180,
            95767247
        ],
        "B": [
            95745661,
            95741583,
            95746087,
            95741923,
            95743557,
            95741471,
            95742126,
            95742079,
            95743874,
            95742788,
            95744560,
            95742620,
            95745128,
            95748044,
            95745202,
            95746759,
            95741532,
            95741702,
            95742488,
            95749798
        ],
        "C": [
            95742981,
            95744852,
            95748437,
            95744808,
            95746831,
            95743810,
            95745097,
            95745356,
            95741031,
            95745159,
            95747546,
            95747612,
            95742323,
            95747442,
            95747895,
            95749106,
            95744992,
            95747455,
            95745170,
            95751867
        ],
        "A": [
            95740482,
            95739860,
            95740501,
            95739845,
            95741896,
            95739795,
            95739865,
            95739838,
            95739950,
            95739997,
            95739893,
            95739847,
            95740138,
            95852510,
            95844045,
            95839237,
            95838793,
            95838769,
            95838754,
            95838446,
            95824867,
            95812004,
            95742639,
            95740471,
            95741183,
            95739807,
            95739826,
            95740061,
            95740497
        ]
    },
    "name": "B. Belted Rooms",
    "statement": "In the snake exhibition, there are n rooms (numbered 0 to n - 1)\r\narranged in a circle, with a snake in each room. The rooms are connected\r\nby n conveyor belts, and the i-th conveyor belt connects the rooms i and\r\n(i+1)\r\nbmod n. In the other words, rooms 0 and 1, 1 and 2,\r\nldots, n-2 and n-1, n-1 and 0 are connected with conveyor belts.The i-th\r\nconveyor belt is in one of three states: If it is clockwise, snakes can\r\nonly go from room i to (i+1)\r\nbmod n. If it is anticlockwise, snakes can only go from room (i+1)\r\nbmod n to i. If it is off, snakes can travel in either direction. Above\r\nis an example with 4 rooms, where belts 0 and 3 are off, 1 is clockwise,\r\nand 2 is anticlockwise.Each snake wants to leave its room and come back\r\nto it later. A room is if the snake there can leave the room, and later\r\ncome back to it using the conveyor belts. How many such rooms are there?\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nchar wcz[nax];\n\nint ile;\n\nint lew, pra;\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz);\n\tile=0;\n\tfor (int i=0; i<n; i++)\n\t\tif (wcz[i]=='-' || wcz[(i+1)%n]=='-')\n\t\t\tile++;\n\tlew=pra=0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (wcz[i]=='<')\n\t\t\tlew=1;\n\t\tif (wcz[i]=='>')\n\t\t\tpra=1;\n\t}\n\tif (!lew || !pra)\n\t\tile=n;\n\tprintf(\"%d\\n\", ile);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Belted Rooms.json",
    "editorial_link": "https://codeforces.com//blog/entry/83771",
    "editorial": "Let\u00e2\u0080\u0099s consider two ways to\nreturn to the start point. The first is to go one big round around the\ncircle. The second is to move 1 step to the side, and return back\nimmediately.Going one big round is only possible if and only if: There\nare no clockwise belts OR There are no anticlockwise belts If we can go\none big round, all rooms are returnable.If there are both clockwise and\nanticlockwise belts, then we can\u00e2\u0080\u0099t go one big round. For any room to be\nreturnable, it must have an off belt to the left or to the right. In\nsummary, check if clockwise belts are absent or if anticlockwise belts\nare absent. If either is absent, the answer is . Otherwise, we have to\ncount the number of rooms with an off belt to the left or to the right.\n"
}