{"link": "https://codeforces.com//contest/1517/problem/H", "problemId": "965878", "problem_idx": "H", "shortId": "1517H", "contest_number": "1517", "problem_submissions": {"H": [114124079], "G": [114025193, 114025453, 114036917, 114041033, 120816591, 114039616, 114040728, 114039927, 114032359, 114070041, 114035064, 114033289, 114027246, 114034514, 114039178], "F": [114020736, 114030530, 114031555, 114030260, 114028344, 114033849, 114034020, 114018937, 114029544, 114031878, 114032269, 114081756, 114032270, 114064223, 114063627, 114035709, 114033913, 114011444], "E": [114008455, 114016598, 114020187, 114012041, 114018819, 114010909, 114015500, 114005326, 114018769, 114013314, 114020062, 114017004, 114020744, 114019236, 114016487, 114039583, 114022320, 114026617, 114029372, 114033166], "D": [113994855, 114002285, 113999931, 113998145, 114001241, 113997280, 114006046, 113995707, 114045880, 114001753, 113998952, 113996449, 114003893, 113997337, 114003553, 113997528, 114023776, 114004856, 114002724, 114015602], "C": [113990530, 113993399, 113992809, 113995080, 113997177, 113991979, 113994818, 113991013, 113995164, 113995388, 114003260, 113990649, 113998059, 113993447, 113997532, 113994037, 113993505, 113998635, 113997064, 114020381], "B": [113987399, 113989246, 113990561, 113990842, 113994206, 113989103, 113990699, 113988130, 113992221, 113990490, 113991945, 113987962, 113992832, 113988946, 113993066, 113990201, 113991322, 113993920, 113991184, 114017898], "A": [113984711, 113984860, 113985166, 113986320, 113989984, 113984723, 113984834, 113984709, 113984737, 113984977, 113984884, 113984721, 113985551, 113984722, 113984905, 113985815, 113985646, 113989342, 113986198, 114012398]}, "name": "H. Fly Around the World", "statement": "After hearing the story of Dr. Zhang, Wowo decides to plan his own\r\nflight around the world. He already chose n checkpoints in the world\r\nmap. Due to the landform and the clouds, he cannot fly too high or too\r\nlow. Formally, let b_i be the height of Wowo\u2019s aircraft at checkpoint i,\r\nx_i^-\r\nle b_i\r\nle x_i^+ should be satisfied for all integers i between 1 and n, where\r\nx_i^- and x_i^+ are given integers.The angle of Wowo\u2019s aircraft is also\r\nlimited. For example, it cannot make a 90-degree climb. Formally, y_i^-\r\nle b_i-b_{i-1}\r\nle y_i^+ should be satisfied for all integers i between 2 and n, where\r\ny_i^- and y_i^+ are given integers.The final limitation is the speed of\r\nangling up or angling down. An aircraft should change its angle slowly\r\nfor safety concerns. Formally, z_i^-\r\nle (b_i - b_{i-1}) - (b_{i-1} - b_{i-2})\r\nle z_i^+ should be satisfied for all integers i between 3 and n, where\r\nz_i^- and z_i^+ are given integers.Taking all these into consideration,\r\nWowo finds that the heights at checkpoints are too hard for him to\r\nchoose. Please help Wowo decide whether there exists a sequence of\r\nnumbers b_1,\r\nldots, b_n satisfying all the contraints above.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\n// mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \nmt19937 rng(0);\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << \"\\n\"; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n// ll abs(ll x) {\n// \tif (x < 0) x *= -1;\n// \treturn x;\n// }\n\n// ll __gcd(ll a, ll b) {\n// \tif (a == 0) return b;\n// \treturn __gcd(b%a,a);\n// }\n\n// str ts(ll x) { return ts((long long)x); }\n\nstruct frac {\n\tll n,d;\n\tfrac(ll _n, ll _d) {\n\t\tn = _n, d = _d;\n\t\tll g = __gcd(n,d); n /= g, d /= g;\n\t\tif (d < 0 || (d == 0 && n == -1)) n *= -1, d *= -1;\n\t}\n\tfrac(ll _n) : frac(_n,1) {}\n\tfrac() : frac(0) {}\n\tfriend frac abs(frac F) { return frac(abs(F.n),F.d); }\n\tfriend str ts(const frac& a) { return ts(a.n)+\"/\"+ts(a.d); }\n \n\tfriend bool operator<(const frac& l, const frac& r) { \n\t\tassert(l.d == 1 || r.d == 1);\n\t\treturn l.n*r.d < r.n*l.d; }\n\tfriend bool operator>(const frac& l, const frac& r) { \n\t\tassert(l.d == 1 || r.d == 1);\n\t\treturn l.n*r.d > r.n*l.d; }\n\tfriend bool operator==(const frac& l, const frac& r) { return l.n == r.n && l.d == r.d; }\n\tfriend bool operator!=(const frac& l, const frac& r) { return !(l == r); }\n \n\tfrac operator-() const { return frac(-n,d); }\n\tfriend frac operator+(const frac& l, const frac& r) { return frac(l.n*r.d+r.n*l.d,l.d*r.d); }\n\tfriend frac operator-(const frac& l, const frac& r) { return frac(l.n*r.d-r.n*l.d,l.d*r.d); }\n\tfriend frac operator*(const frac& l, const frac& r) { return frac(l.n*r.n,l.d*r.d); }\n\tfriend frac operator*(const frac& l, int r) { return l*frac(r,1); }\n\tfriend frac operator*(int r, const frac& l) { return l*r; }\n\tfriend frac operator/(const frac& l, const frac& r) { return l*frac(r.d,r.n); }\n\tfriend frac operator/(const frac& l, const int& r) { return l/frac(r,1); }\n\tfriend frac operator/(const int& l, const frac& r) { return frac(l,1)/r; }\n \n\tfriend frac& operator+=(frac& l, const frac& r) { return l = l+r; }\n\tfriend frac& operator-=(frac& l, const frac& r) { return l = l-r; }\n\ttemplate<class T> friend frac& operator*=(frac& l, const T& r) { return l = l*r; }\n\ttemplate<class T> friend frac& operator/=(frac& l, const T& r) { return l = l/r; }\n};\n\n\nbool flag;\n\nnamespace mine {\n/**\n * Description: Operations with fractions\n * Source: https://martin-thoma.com/fractions-in-cpp/\n * Verification: TopCoder MinimizeAbsoluteDifferenceDiv1\n */\n\n// https://codeforces.com/blog/entry/89968\n\nstruct Tag {\n\tll c, delta_x, delta_y;\n\t// transformation:\n\t// {x,y} -> {x+c*y+delta_x,y+delta_y}\n\n\t// this + t -> {(x+c*y+delta_x)+t.c*(y+delta_y)+t.delta_x,(y+delta_y)+t.delta_y}\n\tTag with_tag(Tag t) { // OK\n\t\treturn {c+t.c,delta_x+t.c*delta_y+t.delta_x,delta_y+t.delta_y};\n\t}\n\tTag inv() { // OK\n\t\treturn {-c,c*delta_y-delta_x,-delta_y};\n\t}\n\tfriend str ts(const Tag& t) { \n\t\treturn \"{c: \"+ts(t.c)+\", delta_x:\"+ts(t.delta_x)+ts(\", delta_y:\")+ts(t.delta_y)+\"}\"; \n\t}\n};\n\nTag undo_front(Tag a, Tag result) { // OK\n\tll t_c = result.c-a.c;\n\treturn {t_c,result.delta_x-a.delta_x-t_c*a.delta_y,result.delta_y-a.delta_y};\n}\n\n// a.delta_x+t.c*a.delta_y+t.delta_x = result.delta_x\n// a.delta_y+t.delta_y = result.delta_y\n// a.c+t.c = result.c\n\n// result.c-a.c, result.delta_x-a.delta_x-(result.c-a.c)*a.delta_y, result.delta_y-a.delta_y\n\nconst Tag ID{0,0,0};\nTag tag_x_plus_y() { return {1,0,0}; }\nTag tag_z(int z) { return {0,z,z}; }\n\nint N;\n\nstruct Vertex {\n\tll x,y,k;\n\tVertex(ll _x, ll _y, ll _k) {\n\t\tassert(_k > 0);\n\t\tll g = __gcd(__gcd(abs(_x),abs(_y)),_k);\n\t\tx = _x/g;\n\t\ty = _y/g;\n\t\tk = _k/g;\n\t\t// if (!(k <= N)) dbg(\"HUH\",_x,_y,_k,x,y,k);\n\t\t// assert(k <= N);\n\t\tassert(abs(x) <= (ll)1e14);\n\t\tassert(abs(y) <= (ll)1e14);\n\t}\n\tVertex(ll _x, frac _y) : Vertex(_x*_y.d,_y.n,_y.d) {}\n\tVertex(frac _x, ll _y) : Vertex(_x.n,_y*_x.d,_x.d) {}\n\tVertex(ll _x, ll _y) : Vertex(_x,_y,1) {}\n\tVertex with_tag(Tag t) { return Vertex(x+t.c*y+t.delta_x*k,y+t.delta_y*k,k); }\n\tbool operator==(const Vertex& o) { return x == o.x && y == o.y && k == o.k; }\n\tfrac get_x() const { return frac(x,k); }\n\tfrac get_y() const { return frac(y,k); }\n\tfriend str ts(const Vertex& v) { \n\t\tV<frac> fracs{v.get_x(),v.get_y()};\n\t\treturn ts(fracs);\n\t}\n};\n\nfrac slope_between (Vertex a, Vertex b) {\n\t// (a.y/a.k-b.y/b.k)/(a.x/a.k-b.x/b.k)\n\tll num = a.y*b.k-b.y*a.k;\n\tll den = a.x*b.k-b.x*a.k;\n\tfrac res = frac(num,den);\n\t// dbg(res);\n\tassert(res.n == 1 || res.n == 0);\n\treturn res;\n}\n\nbool flag;\n\nVertex isect_x(Vertex a, Vertex b, int x) {\n\tif (flag) dbg(\"ISECT X\",a,b,x);\n\tVertex result2{0,0,1};\n\tfrac _slope = slope_between(a,b);\n\tif (_slope.n == 0) {\n\t\treturn Vertex(x*a.k,a.y,a.k);\n\t}\n\tll slope = _slope.d;\n\treturn Vertex(x*a.k*slope,x*a.k+a.y*slope-a.x,a.k*slope);\n}\n\nVertex isect_y(Vertex a, Vertex b, int y) {\n\tfrac _slope = slope_between(a,b); \n\tll slope = _slope.d;\n\tll x_intercept = a.x-slope*a.y; // over a.k\n\tVertex result = Vertex(slope*y*a.k+x_intercept,y*a.k,a.k);\n\treturn result;\n}\n\nvoid apply_tag(Tag& a, Tag b) {\n\ta = a.with_tag(b);\n}\n\n\nbool collinear(Vertex a, Vertex b, Vertex c) {\n\tfrac f = (b.get_y()-a.get_y())*(c.get_x()-a.get_x())-(b.get_x()-a.get_x())*(c.get_y()-a.get_y());\n\treturn f.n == 0;\n}\n\nstruct Hull {\n\tdeque<pair<Vertex,Tag>> verts;\n\t// tag should be applied to vertex and everything before it\n\tTag prod = ID;\n\tHull() {}\n\tHull(V<Vertex> _verts) { // OK\n\t\tfor (Vertex v: _verts) add_back(v);\n\t}\n\tVertex get_back() { // OK\n\t\tassert(!verts.empty());\n\t\treturn verts.bk.f.with_tag(verts.bk.s);\n\t}\n\tVertex get_front() { // OK\n\t\tassert(!verts.empty());\n\t\treturn verts.ft.f.with_tag(prod);\n\t}\n\tvoid apply_back(Tag t) { // OK\n\t\tassert(!verts.empty());\n\t\tapply_tag(verts.bk.s,t);\n\t\tapply_tag(prod,t);\n\t}\n\tvoid x_plus_y() { // OK\n\t\tapply_back(tag_x_plus_y());\n\t}\n\tvoid advance_z(int z) { // OK\n\t\tapply_back(tag_z(z));\n\t}\n\tVertex poll_front() { // OK\n\t\tVertex v = get_front();\n\t\tprod = undo_front(verts.ft.s,prod);\n\t\tverts.pop_front();\n\t\tassert(sz(verts));\n\t\treturn v;\n\t}\n\tVertex poll_back() { // OK\n\t\tVertex v = get_back();\n\t\tTag last_tag = verts.bk.s;\n\t\tverts.pop_back(); assert(sz(verts));\n\t\tapply_tag(verts.bk.s,last_tag);\n\t\treturn v;\n\t}\n\tfrac get_front_x() { return get_front().get_x(); }\n\tfrac get_front_y() { return get_front().get_y(); }\n\tfrac get_back_x() { return get_back().get_x(); }\n\tfrac get_back_y() { return get_back().get_y(); }\n\tvoid add_front(Vertex v) {\n\t\tif (!verts.empty() && v == get_front()) return;\n\t\tverts.push_front({v,prod.inv()}); prod = ID;\n\t}\n\tvoid add_back(Vertex v) {\n\t\tif (!verts.empty() && v == get_back()) return;\n\t\tverts.pb({v,ID});\n\t}\n\tvoid cut_y_lower(int yl) {\n\t\twhile (get_front_y() < yl) {\n\t\t\tVertex v = poll_front();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_front_y() > yl)\n\t\t\t\tadd_front(isect_y(v,get_front(),yl));\n\t\t}\n\t}\n\tvoid cut_y_upper(int yu) {\n\t\twhile (get_back_y() > yu) {\n\t\t\tVertex v = poll_back();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_back_y() < yu)\n\t\t\t\tadd_back(isect_y(v,get_back(),yu));\n\t\t}\n\t}\n\tvoid cut_x_lower(int xl) {\n\t\twhile (get_front_x() < xl) {\n\t\t\tVertex v = poll_front();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_front_x() > xl)\n\t\t\t\tadd_front(isect_x(v,get_front(),xl));\n\t\t}\n\t}\n\tvoid cut_x_upper(int xu) {\n\t\twhile (get_back_x() > xu) {\n\t\t\tVertex v = poll_back(); \n\t\t\tassert(!verts.empty());\n\t\t\tif (get_back_x() < xu)\n\t\t\t\tadd_back(isect_x(v,get_back(),xu));\n\t\t}\n\t}\n\tfriend str ts(const Hull& h) {\n\t\tV<Vertex> converted;\n\t\tset<int> cands;\n\t\tcands.ins(0);\n\t\tcands.ins(sz(h.verts)-1);\n\t\tfor (int i: cands) {\n\t\t\tVertex v = h.verts[i].f;\n\t\t\tif (i == 0) {\n\t\t\t\tv = v.with_tag(h.prod);\n\t\t\t} else {\n\t\t\t\tFOR(j,i,sz(h.verts)) v = v.with_tag(h.verts[j].s);\n\t\t\t}\n\t\t\tconverted.pb(v);\n\t\t\t// while (sz(converted) > 2 && collinear(converted[sz(converted)-3],converted[sz(converted)-2],converted.bk)) {\n\t\t\t// \tconverted.erase(begin(converted)+sz(converted)-2);\n\t\t\t// }\n\t\t}\n\t\t// F0R(i,sz(converted)-1) {\n\t\t// \tfrac f = slope_between(converted[i],converted[i+1]);\n\t\t// \tfrac y_intercept = converted[i].get_y()-converted[i].get_x()*f;\n\t\t// \t// if (y_intercept.d) if (f.d%y_intercept.d != 0) {\n\t\t// \t// \tdbg(\"FAILED\",converted[i],converted[i+1]);\n\t\t// \t// }\n\t\t// }\n\t\treturn ts(converted);\n\t}\n};\n\nvpi X,Y,Z;\nHull lower, upper;\n// if single point, both have it\n\nbool hull_empty() {\n\treturn lower.verts.empty();\n}\n\nvoid x_plus_y() {\n\tif (hull_empty()) return;\n\tlower.x_plus_y(); upper.x_plus_y();\n}\n\nvoid advance_z(int zl, int zu) {\n\tif (hull_empty()) return;\n\tlower.advance_z(zl); upper.advance_z(zu);\n\tupper.add_front(lower.get_front());\n\tlower.add_back(upper.get_back());\n}\n\nvoid clear() {\n\tupper.verts = lower.verts = {};\n}\n\nvoid cut_y_lower(int yl) {\n\tif (hull_empty()) return;\n\tif (lower.get_back_y() < yl) return clear();\n\tupper.cut_y_lower(yl);\n\tlower.cut_y_lower(yl);\n\tlower.add_front(upper.get_front());\n}\n\nvoid cut_y_upper(int yu) {\n\tif (hull_empty()) return;\n\tif (lower.get_front_y() > yu) return clear();\n\tupper.cut_y_upper(yu);\n\tlower.cut_y_upper(yu);\n\tupper.add_back(lower.get_back());\n}\n\nvoid cut_x_lower(int xl) {\n\tif (hull_empty()) return;\n\tif (lower.get_back_x() < xl) return clear();\n\tupper.cut_x_lower(xl);\n\tlower.cut_x_lower(xl);\n\tupper.add_front(lower.get_front());\n}\n\nvoid cut_x_upper(int xu) {\n\tif (hull_empty()) return;\n\tif (lower.get_front_x() > xu) return clear();\n\tupper.cut_x_upper(xu);\n\tlower.cut_x_upper(xu);\n\tlower.add_back(upper.get_back());\n}\n\n\nvoid print_hulls() {\n\t// if (flag) {\n\tdbg(\"HULLS\");\n\tdbg(lower);\n\tdbg(upper);\n\tdbg(\"----\");\n\t// }\n\t// dbg(lower);\n\t// dbg(upper);\n}\n\npi rand_pair() {\n\tint a = rng()%21-10;\n\tint b = rng()%21-10;\n\tif (a > b) swap(a,b);\n\treturn {a,b};\n}\n\nint rng_int(int l, int r) { return uniform_int_distribution<int>(l,r)(rng); }\n\npi rand_around(int x) {\n\tint a = rng_int(-1e8,1e8), b = rng_int(1e8,1e8);\n\tif (a > b) swap(a,b);\n\treturn {a,b};\n\t// return {rng_int(-1e8,x),rng_int(x,1e8)};\n\t// return {rng_int(max(-(int)1e8,x-5),x),rng_int(x,min((int)1e8,x+5))};\n}\n\npair<bool,vs> solve(int tc, int N, vpi X, vpi Y, vpi Z) {\n\tdbg(tc);\n\t// N = 3; \n\n\t// if (tc == 6649) {\n\t// \tps(N);\n\t// \teach(t,X) ps(t.f,t.s);\n\t// \teach(t,Y) ps(t.f,t.s);\n\t// \teach(t,Z) ps(t.f,t.s);\n\t// \t// ps(ts_sep(X,\"\\n\"));\n\t// \t// ps(ts_sep(Y,\"\\n\"));\n\t// \t// ps(ts_sep(Z,\"\\n\"));\n\t// }\n\n\t// dbg(N);\n\t// dbg(X);\n\t// dbg(Y);\n\t// dbg(Z);\n\n\tVertex lower_left(X[1].f,X[1].f-X[0].s);\n\tVertex upper_left(X[1].f,X[1].f-X[0].f);\n\tVertex upper_right(X[1].s,X[1].s-X[0].f);\n\tVertex lower_right(X[1].s,X[1].s-X[0].s);\n\tupper = Hull({lower_left,upper_left,upper_right});\n\tlower = Hull({lower_left,lower_right,upper_right});\n\tcut_y_lower(Y[0].f); cut_y_upper(Y[0].s);\n\t// dbg(\"SOLUTION 1\");\n\tvs rec;\n\tif (!hull_empty()) {\n\t\trec.pb(\"UPPER: \"+ts(upper));\n\t\trec.pb(\"LOWER: \"+ts(lower));\n\t}\n\t// ps(\"UPPER\",upper);\n\t// ps(\"LOWER\",lower);\n\tFOR(i,2,N) {\n\t\t// dbg(\"IT\",i);\n\t\t// dbg(sz(lower.verts),sz(upper.verts));\n\t\t// assert(!hull_empty());\n\t\t// flag = tc == 6649;\n\t\t// flag = N == 100000 && tc == 2 && i == 99999;\n\t\t// if (N == 100000 && tc == 2 && i == 99999) {\n\t\t// \tps(\"HULL EMPTY BEFORE\",i);\n\t\t// \tps(X[i]);\n\t\t// \tps(Y[i-1]);\n\t\t// \tps(Z[i-2]);\n\t\t// if (tc == 6649) {\n\t\t// \tdbg(\"ITERATION\",i);\n\t\t// \tdbg(upper);\n\t\t// \tdbg(lower);\n\t\t// }\n\t\t// \tps(upper);\n\t\t// \tps(lower);\n\t\t// }\n\t\t// if (flag) ps(\"BEFORE ITERATION\",i,X[i],Y[i-1],Z[i-2]);\n\t\t// print_hulls();\n\n\t\tx_plus_y();\n\n\t\t// if (flag) dbg(\"AFTER X PLUS Y\",i);\n\t\t// print_hulls();\n\n\t\tadvance_z(Z[i-2].f,Z[i-2].s);\n\n\t\t// if (flag) dbg(\"AFTER Z\",i,Z[i-2]);\n\t\t// print_hulls();\n\n\t\tcut_x_lower(X[i].f); \n\n\t\t// if (flag) \n\t\t// \tdbg(\"AFTER X LOWER\",i,X[i].f);\n\t\t// print_hulls();\n\n\t\tcut_x_upper(X[i].s);\n\n\t\t// if (flag) \n\t\t// \tdbg(\"AFTER X HIGHER\",i,X[i].s);\n\t\t// print_hulls();\n\n\t\tcut_y_lower(Y[i-1].f); \n\n\t\t// if (flag) \n\t\t\t// dbg(\"AFTER Y LOWER\",i,Y[i-1].f);\n\t\t// print_hulls();\n\n\t\tcut_y_upper(Y[i-1].s);\n\n\t\t// dbg(\"AFTER Y HIGHER\",i,Y[i-1].s);\n\t\t// print_hulls();\n\t\t// if (N == 100000 && tc == 2 && hull_empty()) {\n\t\t// \tps(\"HULL EMPTY AFTER\",i);\n\t\t// }\n\t\tif (!hull_empty()) {\n\t\t\trec.pb(\"UPPER: \"+ts(upper));\n\t\t\trec.pb(\"LOWER: \"+ts(lower));\n\t\t}\n\t\t// ps(\"UPPER\",upper);\n\t\t// ps(\"LOWER\",lower);\n\t}\n\tdbg(rec);\n\t// assert(!hull_empty());\n\tif (hull_empty()) return {0,rec};\n\telse return {1,rec};\n}\n\n}\n\nnamespace model {\n\nusing LL = long long;\n\ninline char GET_CHAR(){\n    const int maxn = 131072;\n    static char buf[maxn],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n    int res(0);\n    char c = getchar();\n    while(c < '0') c = getchar();\n    while(c >= '0') {\n        res = res * 10 + (c - '0');\n        c = getchar();\n    }\n    return res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n    LL res(1);\n    while(n) {\n        if(n & 1) {\n            res = res * (LL)x % mod;\n        }\n        x = x * (LL) x % mod;\n        n /= 2;\n    }\n    return res;\n}\nLL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }\n\ninline string itoa(int x, int width = 0) {\n    string res;\n    if(x == 0) res.push_back('0');\n    while(x) {\n        res.push_back('0' + x % 10);\n        x /= 10;\n    }\n    while((int)res.size() < width) res.push_back('0');\n    reverse(res.begin(), res.end());\n    return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n    fwrite(buf, 1, _bl, stdout);\n    _bl = 0;\n}\n__inline void _putchar(char c) {\n    if(_bl == _B) flush();\n    buf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n    static char tmp[20];\n    int l = 0;\n    if(!x) tmp[l++] = '0';\n    else {\n        while(x) {\n            tmp[l++] = x % 10 + '0';\n            x /= 10;\n        }\n    }\n    for(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n    _putchar(c);\n}\nconst int N = 100011;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid no() {\n    printf(\"NO\\n\");\n}\nvoid yes() {\n    printf(\"YES\\n\");\n}\nconst int L = 1e9;\nstruct Frac {\n    LL x, y;\n    Frac() {\n        y = 1;\n        x = 0;\n    }\n    Frac(LL _x, LL _y) : x(_x), y(_y){\n        if(y < 0) {\n            y = -y; x = -x;\n        }\n        LL d = gcd(abs(x), y);\n        x /= d; y /= d;\n    }\n    Frac(LL a) {\n        x = a; y = 1;\n    }\n    Frac operator + (const Frac & b) const {\n        return Frac(x * b.y + y * b.x, y * b.y);\n    }\n    Frac operator - (const Frac & b) const {\n        return Frac(x * b.y - y * b.x, y * b.y);\n    }\n    Frac operator * (const Frac & b) const {\n        return Frac(x * b.x, y * b.y);\n    }\n    Frac operator / (const Frac & b) const {\n        LL dx = gcd(x, b.x);\n        LL dy = gcd(y, b.y);\n        return Frac(x / dx * (b.y / dy), (y / dy) * (b.x / dx));\n    }\n    bool operator == (const Frac & b) const {\n        return x * b.y == y * b.x;\n    }\n    bool operator != (const Frac & b) const {\n        return x * b.y != y * b.x;\n    }\n    bool operator < (const Frac & b) const {\n        return x * b.y < y * b.x;\n    }\n    bool operator > (const Frac & b) const {\n        return x * b.y > y * b.x;\n    }\n    bool operator <= (const Frac & b) const {\n        return x * b.y <= y * b.x;\n    }\n    bool operator >= (const Frac & b) const {\n        return x * b.y >= y * b.x;\n    }\n    Frac operator - () const {\n        return Frac(-x, y);\n    }\n\n    friend str ts(Frac f) {\n    \treturn ts(frac(f.x,f.y));\n    \t// return\n    \t// return ts(x)+\"/\"+ts(y)+c;\n    }\n};\nLL xmin[N], ymin[N], zmin[N], xmax[N], ymax[N], zmax[N];\nstruct P {\n    Frac x, y;\n    bool operator == (const P & b) const {\n        return x == b.x && y == b.y;\n    }\n    bool operator != (const P & b) const {\n        return x != b.x || y != b.y;\n    }\n    friend str ts(const P& p) {\n    \tV<Frac> v{p.x,p.y};\n    \treturn ts(v);\n    }\n    // void print(char c = '\\n') {\n    //     putchar('(');\n    //     x.print(',');\n    //     y.print(')');\n    //     putchar(c);\n    // }\n    // void check() {\n    // }\n};\nstruct Op {\n    LL c, dx, dy;\n    //x -> x + c * y + dx, y -> y + dy\n    //x + c * y + dx - (y + dy) * c - dx + c * dy = x\n    Op() {\n        c = dx = dy = 0;\n    }\n    Op(LL z) {\n        c = 1;\n        dx = dy = z;\n    }\n    Op(const LL & c, const LL & dx, const LL & dy) : c(c), dx(dx), dy(dy) {\n    }\n    Op operator * (const Op & b) const {\n        return Op{c + b.c, dx + c * b.dy + b.dx, dy + b.dy};\n    }\n    Op inv() const {\n        return Op{-c, -dx + c * dy, -dy};\n    }\n    P operator * (const P & b) const {\n        return P{b.x + (Frac)c * b.y + dx, b.y + dy};\n    }\n    bool operator == (const Op & b) const {\n        return c == b.c && dx == b.dx && dy == b.dy;\n    }\n    void print() const {\n        printf(\"op: %lld %lld %lld\\n\", c, dx, dy);\n    }\n    void check() {\n    }\n};\n\nbool collinear(P a, P b, P c) {\n\tFrac f = (b.y-a.y)*(c.x-a.x)-(b.x-a.x)*(c.y-a.y);\n\treturn f.x == 0;\n}\n\nstruct Deq {\n    deque<P> v;\n    deque<Op> op;\n    Op u;\n    bool empty() {\n        return v.empty();\n    }\n    int size() {\n        return v.size();\n    }\n    P back() {\n        return op.back() * v.back();\n    }\n    P front() {\n        return u * v.front();\n    }\n    P bac() {\n        return op.back() * op[size() - 2] * v[size() - 2];\n    }\n    P fron() {\n        return u * op.front().inv() * v[1];\n    }\n    void push_back(const P & x) {\n        v.push_back(x);\n        op.push_back(Op());\n    }\n    void push_front(const P & x) {\n        if(!v.empty()) {\n            op.push_front(u.inv());\n        }else {\n            op.push_front(Op());\n        }\n        u = Op();\n        v.push_front(x);\n    }\n    void pop_back() {\n        if(v.size() == 1) {\n            v.pop_back(); op.pop_back(); u = Op();\n        }else {\n            op[v.size() - 2] = op.back() * op[v.size() - 2];\n            v.pop_back(); op.pop_back();\n        }\n    }\n    void pop_front() {\n        if(v.size() == 1) {\n            v.pop_back(); op.pop_back(); u = Op();\n        }else {\n            u = u * op.front().inv();\n            v.pop_front();\n            op.pop_front();\n        }\n    }\n\n    void setback(const P & x) {\n        pop_back();\n        push_back(x);\n/*        if(v.size() >= 2) {\n            \n            op[v.size() - 2] = op.back() * op[v.size() - 2];\n        }else {\n            u = Op();\n        }\n        v.back() = x;\n        op.back() = Op();*/\n    }\n    void setfront(const P & x) {\n        pop_front();\n        push_front(x);\n/*        op.front() = u.inv() * op.front();\n        u = Op();\n        v.front() = x;*/\n    }\n    void apply(const Op & z) {        \n        if(!op.empty()) {\n            u = z * u;\n            op.back() = z * op.back();\n        }\n    }\n\n    friend str ts(const Deq& d) {\n\t\tV<P> converted;\n\t\tset<int> cands;\n\t\tcands.ins(0);\n\t\tcands.ins(d.op.size()-1);\n\n\t\tfor (int i: cands) {\n            P p = d.v[i];\n            if (i == 0) p = d.u*p;\n            else {\n\t            for (int j = i; j < d.op.size(); ++j) {\n\t                p = d.op[j]*p;\n\t            }\n            }\n            if (sz(converted) && converted.bk == p) continue;\n            // while (sz(converted) > 1 && collinear(converted[sz(converted)-2],converted.bk,p)) \n            // \tconverted.pop_back();\n            converted.pb(p);\n        }\n\t\treturn ts(converted);\n    }\n};\n\npair<bool,vs> solve(int N, vpi X, vpi Y, vpi Z) {\n\t// dbg(\"SOLUTION 2\");\n\tn = N;\n\tFOR(i,1,n+1) {\n\t\txmin[i] = X[i-1].f;\n\t\txmax[i] = X[i-1].s;\n\t}\n\tFOR(i,2,n+1) {\n\t\tymin[i] = Y[i-2].f;\n\t\tymax[i] = Y[i-2].s;\n\t}\n\tFOR(i,3,n+1) {\n\t\tzmin[i] = Z[i-3].f;\n\t\tzmax[i] = Z[i-3].s;\n\t}\n    ymin[1] = -L;\n    ymax[1] = L;\n    zmin[2] = -L;\n    zmax[2] = L;\n\n    Deq v[2];\n    v[0].v.pb(P{xmin[1], -L});\n    v[0].v.pb(P{xmin[1], L});\n    v[0].v.pb(P{xmax[1], L});\n    v[1].v.pb(P{xmin[1], -L});\n    v[1].v.pb(P{xmax[1], -L});\n    v[1].v.pb(P{xmax[1], L});\n\n    for(int i = 0; i < 2; i++) {\n        v[i].op.resize(v[i].v.size());\n    }\n    vs rec;\n    for(int i = 2; i <= n + 1; i++) {\n        if(i == n + 1) break;\n        v[0].apply(Op(zmax[i]));\n        v[1].apply(Op(zmin[i]));\n        if(zmin[i] != zmax[i]) {\n            v[0].push_front(v[1].front());\n            v[1].push_back(v[0].back());\n        }\n\n        for(int d = 0; d < 2; d++) {\n            P t1, t2;\n            while(!v[d].empty() && (t1 = v[d].back()).y > ymax[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].bac()).y <= ymax[i]) {\n                    Frac c = (t1.x - t2.x) / (t1.y - t2.y);\n                    Frac delta = t1.x - t1.y * c;\n                    v[d].setback(P{(Frac)ymax[i] * c + delta, ymax[i]});\n                    if(d == 0) {\n                        v[d].push_back(P{L, ymax[i]});\n                    }\n                    break;\n                }else {\n                    v[d].pop_back();\n                }\n            }\n            while(!v[d].empty() && (t1 = v[d].back()).x > xmax[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].bac()).x <= xmax[i]) {\n                    Frac c = (t1.y - t2.y) / (t1.x - t2.x);\n                    Frac delta = t1.y - t1.x * c;\n                    v[d].setback(P{xmax[i], (Frac)xmax[i] * c + delta});\n                    if(d == 1) {\n                        v[d].push_back(P{xmax[i], L});   \n                    }\n                    break;\n                }else {\n                    v[d].pop_back();\n                }\n            }\n            while(!v[d].empty() && (t1 = v[d].front()).y < ymin[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].fron()).y >= ymin[i]) {\n                    Frac c = (t1.x - t2.x) / (t1.y - t2.y);\n                    Frac delta = t1.x - t1.y * c;\n                    v[d].setfront(P{(Frac)ymin[i] * c + delta, ymin[i]});\n                    if(d == 1) v[d].push_front(P{-L, ymin[i]});\n                    break;\n                }else {\n                    v[d].pop_front();\n                }\n            }\n\n            while(!v[d].empty() && (t1 = v[d].front()).x < xmin[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].fron()).x >= xmin[i]) {\n                    Frac c = (t1.y - t2.y) / (t1.x - t2.x);\n                    Frac delta = t1.y - t1.x * c;\n                    v[d].setfront(P{xmin[i], (Frac)xmin[i] * c + delta});\n                    if(d == 0) v[d].push_front(P{xmin[i], -L});\n                    break;\n                }else {\n                    v[d].pop_front();\n                }\n            }\n        }\n        if(v[0].empty() || v[1].empty()) {\n        \treturn {0,rec};\n        }\n\n        P t[2];\n        for(int d = 0; d < 2; d++) {\n            t[d] = v[d].back();\n        }\n        if(t[0].x > t[1].x) t[0].x = t[1].x;\n        if(t[1].y > t[0].y) t[1].y = t[0].y;\n\n\n        /*        tmp = Op();\n                  for(int j = v[0].size() - 1; j >= 0; j--) {\n                  tmp = tmp * v[0].op[j];\n                  }\n                  if(i == 9998) {\n                  printf(\"!!%d\\n\", v[0].size());\n                  printf(\"%lld %lld %lld %lld \\n\", xmin[i - 1], xmax[i - 1], ymin[i - 1], ymax[i - 1]);\n                  printf(\"%lld %lld %lld %lld \\n\", xmin[i], xmax[i], ymin[i], ymax[i]);\n                  printf(\"%d %d\\n\", i, v[0].size());\n                  v[0].op.back().print();\n                  v[0].op[v[0].size() - 2].print();\n                  tmp.print();\n                  v[0].u.print();\n                  }*/\n\n\n        v[0].pop_back();\n\n        /*tmp = Op();\n          for(int j = v[0].size() - 1; j >= 0; j--) {\n            tmp = tmp * v[0].op[j];\n        }\n        if(i == 9998) {\n            printf(\"!!%d\\n\", v[0].size());\n            printf(\"%lld %lld %lld %lld \\n\", xmin[i - 1], xmax[i - 1], ymin[i - 1], ymax[i - 1]);\n            printf(\"%lld %lld %lld %lld \\n\", xmin[i], xmax[i], ymin[i], ymax[i]);\n            printf(\"%d %d\\n\", i, v[0].size());\n            v[0].op.back().print();\n            \n            tmp.print();\n            v[0].u.print();\n        }*/\n\n\n        v[0].push_back(t[0]);\n        v[1].setback(t[1]);\n        \n        if(t[0] != t[1]) {\n            if(t[0].x == t[1].x) {\n                v[1].push_back(v[0].back());\n            }else if(t[1].y == t[0].y) {\n                v[0].push_back(v[1].back());\n            }else {\n                v[0].push_back(P{t[1].x, t[0].y});\n                v[1].push_back(P{t[1].x, t[0].y});\n            }\n        }\n        \n        for(int d = 0; d < 2; d++) {\n            t[d] = v[d].front();\n        }\n        if(t[0].y < t[1].y) t[0].y = t[1].y;\n        if(t[1].x < t[0].x) t[1].x = t[0].x;\n        v[0].setfront(t[0]);\n        v[1].setfront(t[1]);\n        if(t[0] != t[1]) {\n            if(t[0].x == t[1].x) {\n                v[0].push_front(v[1].front());\n            }else if(t[1].y == t[0].y) {\n                v[1].push_front(v[0].front());\n            }else {\n                v[0].push_front(P{t[0].x, t[1].y});\n                v[1].push_front(P{t[0].x, t[1].y});\n            }\n        }\n        // if (flag && (i-1)%1000 == 0) {\n    \t// rec.pb(\"UPPER: \"+ts(v[0]));\n    \t// rec.pb(\"LOWER: \"+ts(v[1]));\n        // }\n        // v[1].print();\n        // v[0].print();\n    }\n    return {1,rec};\n}\n}\n\nint main() {\n\tsetIO();\n\n\t// while (1) {\n\n\t// }\n\n\t// Tag x{3,4,5}, y{6,7,8};\n\t// Tag z = x.with_tag(y);\n\t// dbg(z);\n\t// dbg(z.with_tag(y.inv())); // {c: 3, delta_x:4, delta_y:5}\n\t// dbg(z.with_tag(x.inv())); \n\t// dbg(undo_front(x,z)); // {c: 6, delta_x:7, delta_y:8}\n\t// exit(0);\n\n\tint TC; re(TC);\n\t// int TC = 1000000;\n\tFOR(it,1,TC+1) {\n\t\t// dbg(\"GOING\",it);\n\n\t\tint N = mine::rng_int(3,10);\n\t\tre(N); \n\n\t\tvpi X(N), Y(N-1), Z(N-2);\n\t\tvi sol(N);\n\t\tF0R(i,N) sol[i] = mine::rng_int(-1e7,1e7);\n\t\t// X.rsz(N), Y.rsz(N-1), Z.rsz(N-2); \n\t\tF0R(i,N) X[i] = mine::rand_around(sol[i]);\n\t\tF0R(i,N-1) Y[i] = mine::rand_around(sol[i+1]-sol[i]);\n\t\tF0R(i,N-2) Z[i] = mine::rand_around(sol[i+2]-2*sol[i+1]+sol[i]);\n\n\t\tre(X,Y,Z);\n\n\t\tflag = it == 2 && N == 100000;\n\n\t\tauto a = mine::solve(it,N,X,Y,Z);\n\t\t// ps();\n\t\tauto b = model::solve(N,X,Y,Z);\n\t\t// assert(sz(a.s) == sz(b.s));\n\t\t// F0R(i,min(sz(a.s),sz(b.s))) if (a.s[i] != b.s[i]) {\n\t\t// \tps(\"FAILED\",it,i);\n\t\t// \tps(a.s[i]);\n\t\t// \tps(b.s[i]);\n\t\t// \texit(0);\n\t\t// }\n\t\t// F0R(i,sz(a.rec))\n\t\tdbg(a);\n\t\tdbg(b);\n\n\t\t// ps();\n\n\t\t// assert(a == b);\n\t\tif (a.f) ps(\"YES\");\n\t\telse ps(\"NO\");\n\t}\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"], "input": "", "output": "", "tags": ["dp", "geometry"], "dificulty": "3500", "interactive": false}