{
    "link": "https://codeforces.com//contest/2002/problem/G",
    "problemId": "2809245",
    "problem_idx": "G",
    "shortId": "2002G",
    "contest_number": "2002",
    "problem_submissions": {
        "H": [
            275883821,
            276030000,
            276029533,
            276718944,
            276718931,
            276716412,
            276716121,
            276379907
        ],
        "G": [
            275814532,
            275831532,
            275862936,
            275862868,
            275857045,
            275856914,
            275852957,
            275835244,
            275830497,
            275836895,
            275844798,
            275836685,
            275839620,
            275876408,
            275835680,
            276384839,
            275855186,
            275854807,
            275854377,
            275854233,
            275853273,
            275853001,
            277160193,
            275873413
        ],
        "F2": [
            275803261,
            275805293,
            275815511,
            275803726,
            275821855,
            275826602,
            275804715,
            275817099,
            275812698,
            275821433,
            275820135,
            275822519,
            275814615,
            275832819,
            275821881,
            275820944,
            275827250
        ],
        "F1": [
            275803106,
            275797405,
            275810054,
            275805934,
            275822144,
            275821908,
            275808780,
            275842679,
            275842498,
            275804501,
            275809897,
            275810999,
            275804801,
            275820307,
            275807320,
            275814303,
            275818257,
            275821104,
            275812786,
            275819730
        ],
        "E": [
            275776266,
            275785744,
            275852219,
            275788914,
            275771707,
            275802566,
            275795962,
            275769983,
            275789286,
            275807515,
            275787919,
            275785680,
            275785359,
            275786354,
            275779961,
            275794439,
            275802251,
            275789750,
            275800998,
            275803752,
            275804830
        ],
        "D2": [
            275767991,
            275777830,
            275771186,
            275817652,
            275793116,
            275788319,
            275778566,
            275781543,
            275797706,
            275776037,
            275778290,
            275777713,
            275779770,
            275786761,
            275779192,
            275790952,
            275773357,
            275786731,
            275789591,
            275775563
        ],
        "D1": [
            275767248,
            275777327,
            275771493,
            275817851,
            275793580,
            275790111,
            275778728,
            275771118,
            275797900,
            275776414,
            275778256,
            275777934,
            275780036,
            275787162,
            275779917,
            275791115,
            275772837,
            275787063,
            275789991,
            275776578
        ],
        "C": [
            275759851,
            275761703,
            275759373,
            275759241,
            275760994,
            275777407,
            275759928,
            275758928,
            275788566,
            275759503,
            275761991,
            275762069,
            275758442,
            275761405,
            275763148,
            275760323,
            275761934,
            275768403,
            275764562,
            275765401
        ],
        "B": [
            275757139,
            275757734,
            275756638,
            275756387,
            275757424,
            275758576,
            275756620,
            275756121,
            275770304,
            275762131,
            275757965,
            275758270,
            275756051,
            275757393,
            275759268,
            275756663,
            275757687,
            275761514,
            275758840,
            275756832
        ],
        "A": [
            275755167,
            275755315,
            275754910,
            275755027,
            275755132,
            275755590,
            275754949,
            275754911,
            275767431,
            275754975,
            275755752,
            275755110,
            275754896,
            275755382,
            275755090,
            275755155,
            275754903,
            275755222,
            275756059,
            275754981
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132569",
    "editorial": "We apologize for unintended solutions passing,\nand intended solutions failing with large constants. Brute force runs\nvery fast on , which forced us to increase constraints. TutorialThe\nproblem hints strongly at meet in the middle, at each side, there will\nbe paths. The twist is on merging: we are given two sequence of sets and\n, we have to find the maximum . If we enumerate over the maximum MEX ,\nwe only need to check whether there exists two sets such that .Instead\nof meeting at , we perform meet in the middle at the partition of and .\nFor each , we put all its subsets into a hashmap. When checking MEX , we\niterate over all , and check whether is in the hashmap. This gives us a\nsolution, which is optimal at , where the complexity is .We can\nsubstitute enumerating with binary search, yielding , or checking\nwhether can be increased each time, yielding .Instead of hashmaps, you\ncan also insert all and âs into a trie, and run a brute force dfs to\nsearch for MEX . It can be proven that the complexity is also .The\nintended solution is , however solutions that have slightly higher\ncomplexity can pass with good optimizations.Time complexity: .\n",
    "name": "G. Lattice Optimizing",
    "statement": "Consider a grid graph with n rows and n columns. Let the cell in row x\r\nand column y be (x,y). There exists a directed edge from (x,y) to\r\n(x+1,y), with non-negative integer value d_{x,y}, for all 1\r\nle x < n, 1\r\nle y\r\nle n, and there also exists a directed edge from (x,y) to (x,y+1), with\r\nnon-negative integer value r_{x,y}, for all 1\r\nle x\r\nle n, 1\r\nle y < n.Initially, you are at (1,1), with an empty set S. You need to\r\nwalk along the edges and eventually reach (n,n). Whenever you pass an\r\nedge, its value will be inserted into S. Please maximize the MEX^{\r\ntext{ }} of S when you reach (n,n).^{\r\ntext{ }}The MEX (minimum excluded) of an array is the smallest\r\nnon-negative integer that does not belong to the array. For instance:\r\nThe MEX of [2,2,1] is 0, because 0 does not belong to the array. The MEX\r\nof [3,1,0,1] is 2, because 0 and 1 belong to the array, but 2 does not.\r\nThe MEX of [0,3,1,2] is 4, because 0, 1, 2, and 3 belong to the array,\r\nbut 4 does not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using u32 = unsigned;using i64 = long long;using u64 = unsigned long long; void solve() {    int n;    std::cin >> n;        std::vector d(n - 1, std::vector<int>(n));    std::mt19937 rng;    for (int i = 0; i < n - 1; i++) {        for (int j = 0; j < n; j++) {            std::cin >> d[i][j];        }    }    std::vector r(n, std::vector<int>(n - 1));    for (int i = 0; i < n; i++) {        for (int j = 0; j < n - 1; j++) {            std::cin >> r[i][j];        }    }        const int h = 2 * (n - 1) / 3;    int ans = 0;    std::vector<std::vector<i64>> f(n);    auto dfs1 = [&](auto self, int x, int y, i64 mask) -> void {        if (x + y == h) {            f[x].push_back(mask);            return;        }        if (x + 1 < n) {            self(self, x + 1, y, mask);            if (~mask >> d[x][y] & 1) {                self(self, x + 1, y, mask | 1LL << d[x][y]);            }        }        if (y + 1 < n) {            self(self, x, y + 1, mask);            if (~mask >> r[x][y] & 1) {                self(self, x, y + 1, mask | 1LL << r[x][y]);            }        }    };    dfs1(dfs1, 0, 0, 0LL);        for (int x = 0; x < n; x++) {        std::sort(f[x].begin(), f[x].end());        f[x].erase(std::unique(f[x].begin(), f[x].end()), f[x].end());    }        auto dfs2 = [&](auto self, int x, int y, i64 mask) -> void {        if (x + y == h) {            for (int s = ans + 1; s <= 2 * n - 2; s++) {                i64 need = ((1LL << s) - 1) & ~mask;                if (std::binary_search(f[x].begin(), f[x].end(), need)) {                    ans = s;                } else {                    break;                }            }            return;        }        if (x > 0) {            self(self, x - 1, y, mask | 1LL << d[x - 1][y]);        }        if (y > 0) {            self(self, x, y - 1, mask | 1LL << r[x][y - 1]);        }    };    dfs2(dfs2, n - 1, n - 1, 0LL);        std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "hashing",
        "meet-in-the-middle"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Lattice Optimizing.json",
    "hint": [
        "Hint 1 Meet in the middle with a twist.",
        "Hint 2 Union of sets is hard. Disjoint union of sets is easy."
    ]
}