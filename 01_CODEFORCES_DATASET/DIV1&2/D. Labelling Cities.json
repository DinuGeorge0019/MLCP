{
    "link": "https://codeforces.com//contest/794/problem/D",
    "problemId": "106233",
    "problem_idx": "D",
    "shortId": "794D",
    "contest_number": "794",
    "problem_submissions": {
        "F": [
            27081873,
            27083526,
            27083046,
            27085017,
            27081983,
            27082510,
            27086006,
            27083949,
            27080179,
            27086715,
            27082966,
            27079645,
            27084337,
            27084766,
            27081869,
            27081966,
            27084662
        ],
        "E": [
            27079377,
            27080585,
            27080375,
            27082137,
            27084820,
            27086075,
            27082614,
            27085336,
            27086070,
            27082160,
            27085721,
            27085903,
            27085376,
            27087205,
            27084980,
            27082950,
            27083172,
            27085134
        ],
        "D": [
            27077745,
            27078665,
            27078681,
            27079267,
            27079635,
            27079737,
            27080740,
            27079081,
            27083788,
            27079987,
            27082339,
            27082247,
            27082529,
            27080107,
            27094240,
            27094236,
            27094226,
            27094219,
            27094212,
            27094182,
            27094168,
            27094131,
            27094066,
            27080763,
            27081677,
            27089971,
            27089903,
            27087542,
            27080778
        ],
        "C": [
            27075178,
            27076116,
            27076013,
            27076437,
            27076459,
            27075605,
            27076203,
            27075986,
            27076793,
            27077625,
            27078065,
            27084041,
            27076700,
            27077790,
            27078769,
            27077244,
            27075390,
            27082931,
            27077078
        ],
        "B": [
            27072873,
            27073613,
            27072949,
            27073965,
            27073074,
            27073568,
            27073477,
            27073304,
            27073689,
            27073228,
            27073014,
            27073894,
            27072703,
            27074273,
            27072442,
            27074226,
            27073723,
            27073830,
            27073779
        ],
        "A": [
            27072392,
            27072471,
            27072465,
            27072459,
            27072555,
            27072760,
            27072661,
            27072604,
            27072817,
            27072481,
            27072447,
            27072409,
            27072476,
            27072463,
            27072773,
            27072976,
            27072422,
            27074544,
            27072598
        ],
        "G": [
            27216394,
            27227867
        ]
    },
    "name": "D. Labelling Cities",
    "statement": "Oleg the bank client lives in Bankopolia. There are cities in Bankopolia\r\nand some pair of cities are connected directly by bi-directional roads.\r\nThe cities are numbered from to . There are a total of roads in\r\nBankopolia, the -th road connects cities and . It is guaranteed that\r\nfrom each city it is possible to travel to any other city using some of\r\nthe roads.Oleg wants to give a label to each city. Suppose the label of\r\ncity is equal to . Then, it must hold that for all pairs of cities the\r\ncondition holds if and only if there is a road connecting and .Oleg\r\nwonders if such a labeling is possible. Find an example of such labeling\r\nif the task is possible and state that it is impossible otherwise.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 300001;\nvector <int> e[MAXN];\npair <ll, int> a[MAXN];\nint g[MAXN];\nint sz[MAXN];\n\nll gethash(const vector<int>& x) {\n\tll cur = 0;\n\tfor (int u : x) {\n\t\tcur = (cur * ll(MAXN) + u);\n\t}\n\tcur = (cur * ll(MAXN) + x.size());\n\treturn cur;\n}\n\nvector<int> e2[MAXN];\nint x[MAXN];\n\nvoid no() {\n\tcout << \"NO\" << endl;\n\texit(0);\n}\n\nvoid ad(vector<int>& where, int x) {\n\tfor (int u : where)\n\t\tif (x == u) return;\n\tif (where.size() == 2) no();\n\twhere.push_back(x);\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\te[i].push_back(i);\n\t\tsort(e[i].begin(), e[i].end());\n\t\ta[i] = make_pair(gethash(e[i]), i);\n\t}\n\tsort(a + 1, a + n + 1);\n\tint lc = 0, rc;\n\tint k = 0;\n\tfor (lc = 1; lc <= n; lc = rc) {\n\t\trc = lc;\n\t\twhile ((rc <= n) && (a[rc].first == a[lc].first)) rc++;\n\t\tfor (int j = lc; j < rc; j++)\n\t\t\tg[a[j].second] = k;\t\n\t\tsz[k] = rc - lc;\n\t\tk++;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint same = 0;\n\t\tfor (int u : e[i]) {\n\t\t\tif (g[i] != g[u])\n\t\t\t\tad(e2[g[i]], g[u]);\n\t\t\telse\n\t\t\t\tsame++;\n\t\t}\n\t\tif (same != sz[g[i]]) no();\n\t}\n\tint cx = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (x[i] != 0) continue;\n\t\tif (e2[i].size() == 0) {\n\t\t\tx[i] = cx + 2;\n\t\t\tcx += 5;\n\t\t\tcontinue;\n\t\t}\n\t\tif (e2[i].size() > 1) continue;\n\t\tcx += 2;\n\t\tx[i] = cx++;\n\t\tint nx = e2[i][0], pv = i;\n\t\twhile (e2[nx].size() != 1) {\n\t\t\tx[nx] = cx++;\n\t\t\tint nnx = e2[nx][0] + e2[nx][1] - pv;\n\t\t\tpv = nx;\n\t\t\tnx = nnx;\n\t\t}\n\t\tx[nx] = cx;\n\t\tcx += 2;\n\t}\n\n\tfor (int i = 0; i < k; i++)\n\t\tif (x[i] == 0) no();\n\n\tcout << \"YES\\n\";\n\tfor (int i = 1; i <= n; i++) {\n\t\tcout << x[g[i]] << \" \";\n\t}\n\tcout << \"\\n\";\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "hashing"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Labelling Cities.json",
    "editorial_link": "https://codeforces.com/blog/entry/51962",
    "editorial": "Add each vertex to its own adjacency list. Now, we claim that if it is possible to label the cities to satisfy the problem conditions, then it is possible to do so so that for every two cities with the same adjacency list, they're labelled with the same number.\n\nIndeed, if they have the same adjacency list, they must be neighbours. Thus, the difference between their labels is at most 1. Suppose we label the first vertex u with number i and the second vertex v with the number i?+?1. Note that since their adjacency lists are equal, a vertex x is a neighbour of u iff it's a neighbour of v. Thus, u and v can't have neighbours with labels i?-?1 or i?+?2, or else it will contradict the condition. Thus, all neighbours of u and v have labels i or i?+?1. Thus, we can safely change the label of the second vertex v to i and the conditions will still hold.\n\nThus, we can sort the set of adjacency lists of each vertex, and then group the vertices with the same adjacency list together. Suppose there are k such groups. For simplicity, we can create a new graph where each group represent a vertex of the new graph. Connect two groups i and j if and only if there exist some vertex in group i that connects to a vertex in group j. Note that the graph will have at most O(m) edges. Now, if a vertex has degree ???3, we can't assign a number to that vertex properly, as one of its neighbours will not have a label which have a difference ???1 from it. Thus, all vertices in the new graph must have degree ???2. Since it's connected, it must be either a cycle or a path. However, it can be easily seen that there is no labelling if it's a cycle. Thus, it must be a path. Now, we can just assign the labels to the graph from one end of the path to the other end by the numbers 1 to k. Finally, the label of a vertex is simply the label of its group."
}