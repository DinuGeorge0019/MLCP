{"link": "https://codeforces.com//contest/914/problem/H", "problemId": "148494", "problem_idx": "H", "shortId": "914H", "contest_number": "914", "problem_submissions": {"E": [34383567, 34380688, 34384037, 34379971, 34385853, 34381341, 34377061, 34385471, 34377068, 34383097, 34381216, 34377930, 34393845, 34378590, 34386380, 34381164], "C": [34382803, 34382793, 34364057, 34365651, 34386486, 34396063, 34363721, 34365741, 34364774, 34366702, 34391506, 34365007, 34367351, 34382826, 34374119, 34384464, 34372151, 34370073], "G": [34376415, 34377275, 34377412, 34382707, 34380896, 34376017, 34382091, 34379406, 34377065, 34381510, 34378767, 34384171, 34382760, 34380461, 34386445, 34380566, 34388276, 34376347, 34387872, 34388821], "F": [34372924, 34364964, 34388114, 34388527, 34377465, 34383969, 34384849, 34382075, 34408585, 34427444, 34427415, 34427411, 34427369, 34426234, 34426219, 34426204, 34426181, 34395428, 34395305, 34393742, 34393096, 34392685, 34377829, 34381405, 34389663, 34384026], "D": [34370762, 34371655, 34369773, 34368591, 34374188, 34367037, 34369044, 34372797, 34370541, 34371781, 34370647, 34370823, 34372317, 34370221, 34393812, 34371853, 34371865, 34370930, 34372046, 34375276, 34374115], "B": [34360667, 34360722, 34374939, 34362210, 34374843, 34362983, 34377719, 34363222, 34359679, 34359608, 34366166, 34384598, 34360320, 34360372, 34361647, 34362020, 34368128, 34362137, 34362752, 34361533], "A": [34357760, 34358042, 34374626, 34357833, 34358764, 34358376, 34358219, 34358285, 34357836, 34357713, 34358130, 34358072, 34357931, 34391604, 34358333, 34358022, 34358632, 34358260, 34359117, 34357845], "H": [34391572, 34389095]}, "name": "H. Ember and Storm's Tree Game", "statement": "Ember and Storm play a game. First, Ember picks a labelled tree of\r\nvertices, such that the degree of every vertex is at most . Then, Storm\r\npicks two distinct vertices and in this tree and writes down the labels\r\nof the vertices in the path from to in a sequence . Finally, Ember picks\r\nany index () in the array. Now he performs one of the following two\r\noperations exactly once: flip the subrange and add to it. After this,\r\nthe sequence becomes negate the subrange and add to it. i.e., the array\r\nbecomes Ember wins if the array is monotonically increasing or\r\ndecreasing after this. Otherwise Storm wins.The game can be described by\r\nthe tuple where is flip or negate depending on the action Ember chose in\r\nthe last turn. Find the number of tuples that can occur if Ember and\r\nStorm play optimally. When they play optimally, if there are multiple\r\nmoves by which they are guaranteed to win, then they may play any of the\r\nwinning moves. Otherwise, if someone loses no matter what they play,\r\nthen they may play any of the possible moves.Report the answer modulo .\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint n,D,mo;\nlong long C[210][210],T[210][210],f[210][210],g[210][210],fpre[210][210],gpre[210][210];\nstruct atom{\n\tlong long way,tot;\n};\natom operator + (atom k1,atom k2){\n\treturn (atom){(k1.way+k2.way)%mo,(k1.tot+k2.tot)%mo};\n}\natom calc1(){\n\tlong long way=0,tot=0;\n\tfor (int d=2;d<=D;d++){\n\t\tway=(way+f[n][d])%mo;\n\t\ttot=(tot+g[n][d])%mo;\n\t}\n\treturn (atom){way,tot};\n}\natom calc2(){\n\tlong long way=0,tot=0;\n\tfor (int d1=1;d1<=D;d1++)\n\t\tfor (int d2=2;d1+d2<=D;d2++)\n\t\t\tfor (int i=1;i<=n;i++){\n\t\t\t\tint rem=n-i+1;\n\t\t\t\tlong long num=1ll*f[i][d1]*f[rem][d2]%mo;\n\t\t\t\tway=(way+num)%mo;\n\t\t\t\ttot=(tot+1ll*f[i][d1]*g[rem][d2]%mo+1ll*f[rem][d2]*g[i][d1])%mo;\t\n\t\t\t}\n\treturn (atom){way,tot};\n}\natom calcrem(){\n\tlong long way=0,tot=0;\n\tfor (int d=1;d<=D;d++){\n\t\tway=(way+f[n][d])%mo;\n\t\ttot=(tot+g[n][d])%mo;\n\t}\n\treturn (atom){way,tot};\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&D,&mo);\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(1ll*C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tmemset(f,0x00,sizeof f);\n\tmemset(g,0x00,sizeof g);\n\tf[1][0]=1; \n\tfor (int i=0;i<=n;i++) fpre[1][i]=1;\n\tfor (int i=2;i<=n;i++){\n\t\tfor (int d=1;d<=n;d++)\n\t\t\tfor (int j=1;j<i;j++){\n\t\t\t\tf[i][d]=(f[i][d]+1ll*f[i-j][d-1]*C[i-2][j-1]%mo*fpre[j][D-1])%mo;\n\t\t\t\tg[i][d]=(g[i][d]+1ll*g[i-j][d-1]*C[i-2][j-1]%mo*fpre[j][D-1]%mo+1ll*gpre[j][D-1]*C[i-2][j-1]%mo*f[i-j][d-1]%mo+1ll*j*f[i-j][d-1]%mo*C[i-2][j-1]%mo*fpre[j][D-1])%mo;\n\t\t\t//\tif (i==3&&d==2) cout<<\"fa \"<<j<<\" \"<<g[i-j][d-1]<<\" \"<<f[i-j][d-1]<<\" \"<<g[i][d]<<endl;\n\t\t\t}\n\t\tfor (int d=1;d<=n;d++){\n\t\t\tfpre[i][d]=(f[i][d]+fpre[i][d-1])%mo;\n\t\t\tgpre[i][d]=(g[i][d]+gpre[i][d-1])%mo;\n\t\t}\n\t\t//for (int d=0;d<=n;d++) cout<<g[i][d]<<\" \"; cout<<endl;\n\t}\n\t/*for (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<f[i][j]<<\" \"; cout<<endl;} cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<g[i][j]<<\" \"; cout<<endl;} cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<fpre[i][j]<<\" \"; cout<<endl;}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<gpre[i][j]<<\" \"; cout<<endl;}*/\n\tatom ans=calc1();\n\t//cout<<ans.way<<\" \"<<ans.tot<<endl;\n\tans=ans+calc2();\n\t//cout<<ans.way<<\" \"<<ans.tot<<endl;\n\tans=ans+calcrem();\n\t//cout<<ans.way<<\" \"<<ans.tot<<endl;\n\tans.tot=(ans.tot-1ll*ans.way*(n-1))%mo;\n\tans.tot=0;\n\tlong long tot=n*(n-1)*2*ans.way%mo;\n\ttot=(tot-ans.tot*2)%mo;\n\ttot=(tot+mo)%mo;\n\tcout<<tot<<endl;\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "games", "trees"], "dificulty": "3400", "interactive": false}