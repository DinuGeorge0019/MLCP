{
    "link": "https://codeforces.com//contest/914/problem/H",
    "problemId": "148494",
    "problem_idx": "H",
    "shortId": "914H",
    "contest_number": "914",
    "problem_submissions": {
        "E": [
            34383567,
            34380688,
            34384037,
            34379971,
            34385853,
            34381341,
            34377061,
            34385471,
            34377068,
            34383097,
            34381216,
            34377930,
            34393845,
            34378590,
            34386380,
            34381164
        ],
        "C": [
            34382803,
            34382793,
            34364057,
            34365651,
            34386486,
            34396063,
            34363721,
            34365741,
            34364774,
            34366702,
            34391506,
            34365007,
            34367351,
            34382826,
            34374119,
            34384464,
            34372151,
            34370073
        ],
        "G": [
            34376415,
            34377275,
            34377412,
            34382707,
            34380896,
            34376017,
            34382091,
            34379406,
            34377065,
            34381510,
            34378767,
            34384171,
            34382760,
            34380461,
            34386445,
            34380566,
            34388276,
            34376347,
            34387872,
            34388821
        ],
        "F": [
            34372924,
            34364964,
            34388114,
            34388527,
            34377465,
            34383969,
            34384849,
            34382075,
            34408585,
            34427444,
            34427415,
            34427411,
            34427369,
            34426234,
            34426219,
            34426204,
            34426181,
            34395428,
            34395305,
            34393742,
            34393096,
            34392685,
            34377829,
            34381405,
            34389663,
            34384026
        ],
        "D": [
            34370762,
            34371655,
            34369773,
            34368591,
            34374188,
            34367037,
            34369044,
            34372797,
            34370541,
            34371781,
            34370647,
            34370823,
            34372317,
            34370221,
            34393812,
            34371853,
            34371865,
            34370930,
            34372046,
            34375276,
            34374115
        ],
        "B": [
            34360667,
            34360722,
            34374939,
            34362210,
            34374843,
            34362983,
            34377719,
            34363222,
            34359679,
            34359608,
            34366166,
            34384598,
            34360320,
            34360372,
            34361647,
            34362020,
            34368128,
            34362137,
            34362752,
            34361533
        ],
        "A": [
            34357760,
            34358042,
            34374626,
            34357833,
            34358764,
            34358376,
            34358219,
            34358285,
            34357836,
            34357713,
            34358130,
            34358072,
            34357931,
            34391604,
            34358333,
            34358022,
            34358632,
            34358260,
            34359117,
            34357845
        ],
        "H": [
            34391572,
            34389095
        ]
    },
    "name": "H. Ember and Storm's Tree Game",
    "statement": "Ember and Storm play a game. First, Ember picks a labelled tree of\r\nvertices, such that the degree of every vertex is at most . Then, Storm\r\npicks two distinct vertices and in this tree and writes down the labels\r\nof the vertices in the path from to in a sequence . Finally, Ember picks\r\nany index () in the array. Now he performs one of the following two\r\noperations exactly once: flip the subrange and add to it. After this,\r\nthe sequence becomes negate the subrange and add to it. i.e., the array\r\nbecomes Ember wins if the array is monotonically increasing or\r\ndecreasing after this. Otherwise Storm wins.The game can be described by\r\nthe tuple where is flip or negate depending on the action Ember chose in\r\nthe last turn. Find the number of tuples that can occur if Ember and\r\nStorm play optimally. When they play optimally, if there are multiple\r\nmoves by which they are guaranteed to win, then they may play any of the\r\nwinning moves. Otherwise, if someone loses no matter what they play,\r\nthen they may play any of the possible moves.Report the answer modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint n,D,mo;\nlong long C[210][210],T[210][210],f[210][210],g[210][210],fpre[210][210],gpre[210][210];\nstruct atom{\n\tlong long way,tot;\n};\natom operator + (atom k1,atom k2){\n\treturn (atom){(k1.way+k2.way)%mo,(k1.tot+k2.tot)%mo};\n}\natom calc1(){\n\tlong long way=0,tot=0;\n\tfor (int d=2;d<=D;d++){\n\t\tway=(way+f[n][d])%mo;\n\t\ttot=(tot+g[n][d])%mo;\n\t}\n\treturn (atom){way,tot};\n}\natom calc2(){\n\tlong long way=0,tot=0;\n\tfor (int d1=1;d1<=D;d1++)\n\t\tfor (int d2=2;d1+d2<=D;d2++)\n\t\t\tfor (int i=1;i<=n;i++){\n\t\t\t\tint rem=n-i+1;\n\t\t\t\tlong long num=1ll*f[i][d1]*f[rem][d2]%mo;\n\t\t\t\tway=(way+num)%mo;\n\t\t\t\ttot=(tot+1ll*f[i][d1]*g[rem][d2]%mo+1ll*f[rem][d2]*g[i][d1])%mo;\t\n\t\t\t}\n\treturn (atom){way,tot};\n}\natom calcrem(){\n\tlong long way=0,tot=0;\n\tfor (int d=1;d<=D;d++){\n\t\tway=(way+f[n][d])%mo;\n\t\ttot=(tot+g[n][d])%mo;\n\t}\n\treturn (atom){way,tot};\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&D,&mo);\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(1ll*C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tmemset(f,0x00,sizeof f);\n\tmemset(g,0x00,sizeof g);\n\tf[1][0]=1; \n\tfor (int i=0;i<=n;i++) fpre[1][i]=1;\n\tfor (int i=2;i<=n;i++){\n\t\tfor (int d=1;d<=n;d++)\n\t\t\tfor (int j=1;j<i;j++){\n\t\t\t\tf[i][d]=(f[i][d]+1ll*f[i-j][d-1]*C[i-2][j-1]%mo*fpre[j][D-1])%mo;\n\t\t\t\tg[i][d]=(g[i][d]+1ll*g[i-j][d-1]*C[i-2][j-1]%mo*fpre[j][D-1]%mo+1ll*gpre[j][D-1]*C[i-2][j-1]%mo*f[i-j][d-1]%mo+1ll*j*f[i-j][d-1]%mo*C[i-2][j-1]%mo*fpre[j][D-1])%mo;\n\t\t\t//\tif (i==3&&d==2) cout<<\"fa \"<<j<<\" \"<<g[i-j][d-1]<<\" \"<<f[i-j][d-1]<<\" \"<<g[i][d]<<endl;\n\t\t\t}\n\t\tfor (int d=1;d<=n;d++){\n\t\t\tfpre[i][d]=(f[i][d]+fpre[i][d-1])%mo;\n\t\t\tgpre[i][d]=(g[i][d]+gpre[i][d-1])%mo;\n\t\t}\n\t\t//for (int d=0;d<=n;d++) cout<<g[i][d]<<\" \"; cout<<endl;\n\t}\n\t/*for (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<f[i][j]<<\" \"; cout<<endl;} cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<g[i][j]<<\" \"; cout<<endl;} cout<<endl;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<fpre[i][j]<<\" \"; cout<<endl;}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=n;j++) cout<<gpre[i][j]<<\" \"; cout<<endl;}*/\n\tatom ans=calc1();\n\t//cout<<ans.way<<\" \"<<ans.tot<<endl;\n\tans=ans+calc2();\n\t//cout<<ans.way<<\" \"<<ans.tot<<endl;\n\tans=ans+calcrem();\n\t//cout<<ans.way<<\" \"<<ans.tot<<endl;\n\tans.tot=(ans.tot-1ll*ans.way*(n-1))%mo;\n\tans.tot=0;\n\tlong long tot=n*(n-1)*2*ans.way%mo;\n\ttot=(tot-ans.tot*2)%mo;\n\ttot=(tot+mo)%mo;\n\tcout<<tot<<endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "games",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Ember and Storm's Tree Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/57250",
    "editorial": "Ember wins if the path chosen by Storm is monotonic or bitonic. In this\r\ncase, there can be two pairs.Let be the set of trees having vertices in\r\nwhich all paths are bitonic or monotonic. We need to find .For every\r\ntree in , there exists at least one vertex such that every path starting\r\nor ending at that vertex is monotonically increasing or\r\ndecreasing.First, letâs count the number of rooted trees such that all\r\npaths starting at the root are increasing. Later weâll combine this with\r\ntrees having decreasing paths.Let be the number of trees having vertices\r\nand maximum degree such that all paths starting at vertex are\r\nmonotonically increasing and the degree of the vertex is . We can find\r\nthis quantity by a kind of knapsack DP in , as follows.We can construct\r\na tree of vertices and degree of root by taking a tree of vertices\r\nhaving root degree and attaching trees of vertices each to its root. Let\r\nthe set of vertices be . Initially we remove vertices from and use these\r\nvertices to construct the tree of vertices. Let be the set of remaining\r\nvertices. We partition into subsets of vertices each. Sort these subsets\r\nby their minimum element. Now we make trees of vertices each, and use\r\nthe -th set of vertices to construct the -th tree. Therefore, the number\r\nof ways to do this is: where is the number of trees of vertices with any\r\nroot degree from to .Note that there is a bijection from trees in which\r\nall paths from root are increasing and trees in which all paths from\r\nroot are decreasing. ()Note that is the number of trees such that all\r\npaths starting at the root are monotonic, and there are vertices lying\r\non the increasing paths and there are vertices lying on the decreasing\r\npaths, and the degree of the root is Therefore the quantityis the number\r\nof rooted trees of vertices such that all paths starting at the root are\r\nmonotonically increasing or decreasing. However, we want to count\r\nunrooted trees.Note that if a tree in has possible roots, then these\r\nroots form a chain of consecutive numbers with an increasing tree of\r\nsize on the larger end of the chain and a decreasing tree of size on the\r\nsmaller end of the chain. Such a tree gets counted times in . But for\r\nall of these roots except one, there is exactly one child of the root\r\nsmaller than it. Therefore the total number of unrooted trees isTime\r\nComplexity:\r\n",
    "hint": []
}