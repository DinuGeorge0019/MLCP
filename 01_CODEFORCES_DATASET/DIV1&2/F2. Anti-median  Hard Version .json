{
    "link": "https://codeforces.com//contest/1761/problem/F2",
    "problemId": "1651707",
    "problem_idx": "F2",
    "shortId": "1761F2",
    "contest_number": "1761",
    "problem_submissions": {
        "F1": [
            181783681,
            181789408,
            181787826,
            181807817,
            181793725,
            181798874,
            181812117,
            181796851,
            181792193,
            181797286,
            181792466,
            181800291,
            181799120,
            181798951,
            181797538,
            181796549,
            181801616,
            181795934,
            181802212,
            181805577,
            181795481
        ],
        "E": [
            181767412,
            181775228,
            181773318,
            181773199,
            181776029,
            181768641,
            181774177,
            181773946,
            181778599,
            181783359,
            181770606,
            181780149,
            181779791,
            181784860,
            181784163,
            181786738,
            181799018,
            181784766,
            181805355,
            181777139
        ],
        "B": [
            181758217,
            181754631,
            181753022,
            181750562,
            181750818,
            181752710,
            181752904,
            181761535,
            181751867,
            181753244,
            181749713,
            181752562,
            181752197,
            181751335,
            181785787,
            181754006,
            181756438,
            181751473,
            181751400,
            181750387
        ],
        "C": [
            181757137,
            181757883,
            181756839,
            181754860,
            181753609,
            181755220,
            181756960,
            181758423,
            181755837,
            181756467,
            181755169,
            181757040,
            181757304,
            181769451,
            181757169,
            181757887,
            181761524,
            181755570,
            181754021,
            181753237
        ],
        "D": [
            181754215,
            181780914,
            181764059,
            181764559,
            181763628,
            181762248,
            181763698,
            181768454,
            181766485,
            181764872,
            181761188,
            181770079,
            181765691,
            181765764,
            181766812,
            181780108,
            181774890,
            181778415,
            181762397,
            181766534
        ],
        "A": [
            181747969,
            181747996,
            181753999,
            181748106,
            181748091,
            181748074,
            181748126,
            181748232,
            181748177,
            181750270,
            181748024,
            181748492,
            181748221,
            181748149,
            181749212,
            181750341,
            181748955,
            181748081,
            181748111,
            181748040
        ],
        "G": [
            181798925,
            181813421
        ],
        "F2": [
            181809122,
            181811738,
            181814199,
            181819747,
            181813452,
            181813278,
            181812897,
            181812682,
            181812626,
            181812463,
            181811716,
            181806789
        ]
    },
    "name": "F2. Anti-median  Hard Version ",
    "statement": "Let’s call an array a of odd length 2m+1 (with m\r\nge 1) , if element a_{m+1} is equal to the median of this array. In\r\nother words, the array is bad if, after sorting it, the element at\r\nm+1-st position remains the same.Let’s call a permutation p of integers\r\nfrom 1 to n , if every its subarray of odd length\r\nge 3 is not bad.You are already given values of some elements of the\r\npermutation. Find the number of ways to set unknown values to obtain an\r\npermutation. As this number can be very large, find it modulo 10^9+7.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string;\t\t// yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = (int)1e9 + 7; // 998244353;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1}; // for every grid problem!!\nmt19937 rng(0);\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(\n\tint x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n} // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n} // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n} // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n} // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n} // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) { // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void erase(T &t, const U &u) { // don't erase\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n} // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class... U\n\ninline namespace Helpers {\n//////////// is_iterable\n// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n// this gets used only when we can call begin() and end() on that type\ntcT, class = void > struct is_iterable : false_type {};\ntcT > struct is_iterable<\n\t\t  T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>>\n\t: true_type {};\ntcT > constexpr bool is_iterable_v = is_iterable<T>::value;\n\n//////////// is_readable\ntcT, class = void > struct is_readable : false_type {};\ntcT > struct is_readable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\tdecltype(cin >> declval<T &>()), istream &>>>\n\t: true_type {};\ntcT > constexpr bool is_readable_v = is_readable<T>::value;\n\n//////////// is_printable\n// // https://nafe.es/posts/2020-02-29-is-printable/\ntcT, class = void > struct is_printable : false_type {};\ntcT > struct is_printable<T, typename std::enable_if_t<is_same_v<\n\t\t\t\t\t\t\t\t decltype(cout << declval<T>()), ostream &>>>\n\t: true_type {};\ntcT > constexpr bool is_printable_v = is_printable<T>::value;\n} // namespace Helpers\n\ninline namespace Input {\ntcT > constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\ntcTUU > void re(T &t, U &...u);\ntcTU > void re(pair<T, U> &p); // pairs\n\n// re: read\ntcT > typename enable_if<is_readable_v<T>, void>::type re(T &x) {\n\tcin >> x;\n} // default\ntcT > void re(complex<T> &c) {\n\tT a, b;\n\tre(a, b);\n\tc = {a, b};\n} // complex\ntcT > typename enable_if<needs_input_v<T>, void>::type\n\t  re(T &i); // ex. vectors, arrays\ntcTU > void re(pair<T, U> &p) { re(p.f, p.s); }\ntcT > typename enable_if<needs_input_v<T>, void>::type re(T &i) {\n\teach(x, i) re(x);\n}\ntcTUU > void re(T &t, U &...u) {\n\tre(t);\n\tre(u...);\n} // read multiple\n\n// rv: resize and read vectors\nvoid rv(size_t) {}\ntcTUU > void rv(size_t N, V<T> &t, U &...u);\ntemplate <class... U> void rv(size_t, size_t N2, U &...u);\ntcTUU > void rv(size_t N, V<T> &t, U &...u) {\n\tt.rsz(N);\n\tre(t);\n\trv(N, u...);\n}\ntemplate <class... U> void rv(size_t, size_t N2, U &...u) { rv(N2, u...); }\n\n// dumb shortcuts to read in ints\nvoid decrement() {} // subtract one from each\ntcTUU > void decrement(T &t, U &...u) {\n\t--t;\n\tdecrement(u...);\n}\n#define ints(...)                                                              \\\n\tint __VA_ARGS__;                                                           \\\n\tre(__VA_ARGS__);\n#define int1(...)                                                              \\\n\tints(__VA_ARGS__);                                                         \\\n\tdecrement(__VA_ARGS__);\n} // namespace Input\n\ninline namespace ToString {\ntcT > constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n// ts: string representation to print\ntcT > typename enable_if<is_printable_v<T>, str>::type ts(T v) {\n\tstringstream ss;\n\tss << fixed << setprecision(15) << v;\n\treturn ss.str();\n} // default\ntcT > str bit_vec(T t) { // bit vector to string\n\tstr res = \"{\";\n\tF0R(i, sz(t)) res += ts(t[i]);\n\tres += \"}\";\n\treturn res;\n}\nstr ts(V<bool> v) { return bit_vec(v); }\ntemplate <size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\ntcTU > str ts(pair<T, U> p);\t\t\t\t\t\t\t\t\t // pairs\ntcT >\n\ttypename enable_if<needs_output_v<T>, str>::type ts(T v); // vectors, arrays\ntcTU > str ts(pair<T, U> p) { return \"(\" + ts(p.f) + \", \" + ts(p.s) + \")\"; }\ntcT > typename enable_if<is_iterable_v<T>, str>::type ts_sep(T v, str sep) {\n\t// convert container to string w/ separator sep\n\tbool fst = 1;\n\tstr res = \"\";\n\tfor (const auto &x : v) {\n\t\tif (!fst) res += sep;\n\t\tfst = 0;\n\t\tres += ts(x);\n\t}\n\treturn res;\n}\ntcT > typename enable_if<needs_output_v<T>, str>::type ts(T v) {\n\treturn \"{\" + ts_sep(v, \", \") + \"}\";\n}\n\n// for nested DS\ntemplate <int, class T>\ntypename enable_if<!needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\treturn {ts(v)};\n}\ntemplate <int lev, class T>\ntypename enable_if<needs_output_v<T>, vs>::type ts_lev(const T &v) {\n\tif (lev == 0 || !sz(v)) return {ts(v)};\n\tvs res;\n\tfor (const auto &t : v) {\n\t\tif (sz(res)) res.bk += \",\";\n\t\tvs tmp = ts_lev<lev - 1>(t);\n\t\tres.ins(end(res), all(tmp));\n\t}\n\tF0R(i, sz(res)) {\n\t\tstr bef = \" \";\n\t\tif (i == 0) bef = \"{\";\n\t\tres[i] = bef + res[i];\n\t}\n\tres.bk += \"}\";\n\treturn res;\n}\n} // namespace ToString\n\ninline namespace Output {\ntemplate <class T> void pr_sep(ostream &os, str, const T &t) { os << ts(t); }\ntemplate <class T, class... U>\nvoid pr_sep(ostream &os, str sep, const T &t, const U &...u) {\n\tpr_sep(os, sep, t);\n\tos << sep;\n\tpr_sep(os, sep, u...);\n}\n// print w/ no spaces\ntemplate <class... T> void pr(const T &...t) { pr_sep(cout, \"\", t...); }\n// print w/ spaces, end with newline\nvoid ps() { cout << \"\\n\"; }\ntemplate <class... T> void ps(const T &...t) {\n\tpr_sep(cout, \" \", t...);\n\tps();\n}\n// debug to cerr\ntemplate <class... T> void dbg_out(const T &...t) {\n\tpr_sep(cerr, \" | \", t...);\n\tcerr << endl;\n}\nvoid loc_info(int line, str names) {\n\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \";\n}\ntemplate <int lev, class T> void dbgl_out(const T &t) {\n\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t), \"\\n\") << \"\\n\" << endl;\n}\n#ifdef LOCAL\n#define dbg(...) loc_info(__LINE__, #__VA_ARGS__), dbg_out(__VA_ARGS__)\n#define dbgl(lev, x) loc_info(__LINE__, #x), dbgl_out<lev>(x)\n#else // don't actually submit with this\n#define dbg(...) 0\n#define dbgl(lev, x) 0\n#endif\n\nconst clock_t beg = clock();\n#define dbg_time() dbg((db)(clock() - beg) / CLOCKS_PER_SEC)\n} // namespace Output\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\"); // for old USACO\n}\n} // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t} // explicit -> don't silently convert to int\n\tmint() : v(0) {}\n\tmint(ll _v) {\n\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD;\n\t}\n\tbool operator==(const mint &o) const { return v == o.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend void re(mint &a) {\n\t\tll x;\n\t\tre(x);\n\t\ta = mint(x);\n\t}\n\tfriend str ts(mint a) { return ts(a.v); }\n\n\tmint &operator+=(const mint &o) {\n\t\tif ((v += o.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &o) {\n\t\tif ((v -= o.v) < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &o) {\n\t\tv = int((ll)v * o.v % MOD);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\n\nusing mi = mint<MOD, 5>; // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi, mi>;\nusing vpmi = V<pmi>;\n\nV<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, vmi(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\n/**\n * Description: Combinations modulo a prime $MOD$. Assumes $2\\le N \\le MOD$.\n * Time: O(N)\n * Source: KACTL\n * Verification: https://dmoj.ca/problem/tle17c4p5\n * Usage: Factorials F; F.init(10); F.C(6, 4); // 15\n */\n\nstruct Factorials {\n\tvmi invs, fac, ifac;\n\tvoid init(int N) { // idempotent\n\t\tinvs.rsz(N), fac.rsz(N), ifac.rsz(N);\n\t\tinvs[1] = fac[0] = ifac[0] = 1;\n\t\tFOR(i, 2, N) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);\n\t\tFOR(i, 1, N) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];\n\t}\n\tmi C(int a, int b) {\n\t\tif (a < b || b < 0) return 0;\n\t\treturn fac[a] * ifac[b] * ifac[a - b];\n\t}\n};\n\nbool ok(vi P) {\n\tF0R(i, sz(P)) {\n\t\tfor (int j = 1; i >= j && i + j < sz(P); ++j) {\n\t\t\tvi Q(begin(P) + i - j, begin(P) + i + j + 1);\n\t\t\tsor(Q);\n\t\t\tif (Q[j] == P[i]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nbool ok2(vi P) {\n\tF0R(i, sz(P)) {\n\t\tfor (int j = 1; i >= j && i + j < sz(P) && j <= 2; ++j) {\n\t\t\tvi Q(begin(P) + i - j, begin(P) + i + j + 1);\n\t\t\tsor(Q);\n\t\t\tif (Q[j] == P[i]) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nnamespace Slower {\n\nmap<AR<int, 4>, mi> stor;\nvi P;\nint N;\n\nbool compat(int x, int v) { return P.at(x) == -1 || P.at(x) == v; }\n\nmi dp(int lo_l, int lo_r, int hi_l, int hi_r) {\n\t// if (hi_l > lo_r || hi_r < lo_l) return 0;\n\tauto it = stor.find({lo_l, lo_r, hi_l, hi_r});\n\tif (it != end(stor)) return it->s;\n\tint placed = 0;\n\tplaced += (lo_r - lo_l) / 2 + 1;\n\tplaced += cdiv(hi_l + 1, 2);\n\tplaced += cdiv(N - hi_r, 2);\n\tif (placed == N - 1) {\n\t\tassert(hi_l + 4 == hi_r);\n\t\treturn compat(hi_l + 2, N);\n\t}\n\tmi ret = 0;\n\tif (lo_l - 2 >= 0) {\n\t\tif (compat(lo_l - 2, placed + 1)) ret += dp(lo_l - 2, lo_r, hi_l, hi_r);\n\t} else if (hi_l + 2 <= lo_r) {\n\t\tif (compat(hi_l + 2, placed + 1)) ret += dp(lo_l, lo_r, hi_l + 2, hi_r);\n\t}\n\tif (lo_r + 2 < N) {\n\t\tif (compat(lo_r + 2, placed + 1)) ret += dp(lo_l, lo_r + 2, hi_l, hi_r);\n\t} else if (hi_r - 2 >= lo_l) {\n\t\tif (compat(hi_r - 2, placed + 1)) ret += dp(lo_l, lo_r, hi_l, hi_r - 2);\n\t}\n\treturn stor[{lo_l, lo_r, hi_l, hi_r}] = ret;\n}\n\nmi solve(vi _P) {\n\tP = _P;\n\tN = sz(P);\n\tstor.clear();\n\tmi ans = 0;\n\tF0R(i, N) if (compat(i, 1)) {\n\t\tint hi_l = i - 1;\n\t\twhile (hi_l >= 0) hi_l -= 2;\n\t\tint hi_r = i + 1;\n\t\twhile (hi_r < N) hi_r += 2;\n\t\tans += dp(i, i, hi_l, hi_r);\n\t}\n\treturn ans;\n}\n\n} // namespace Slower\n\nnamespace Faster {\n\nFactorials F;\n\nbool compat(vi P, vi Q) {\n\tF0R(i, sz(P)) if (P[i] != -1 && P[i] != Q[i]) return 0;\n\treturn 1;\n}\n\nmi solve_lo_hi_brute(vi P) {\n\tvi Q(sz(P));\n\tiota(all(Q), 1);\n\tint ret = 0;\n\tdo {\n\t\tif (Q[0] < Q[1] && ok(Q) && compat(P, Q)) ++ret;\n\t} while (next_permutation(all(Q)));\n\treturn ret;\n}\n\nmi solve_lo_hi(vi P) {\n\tconst int N = sz(P);\n\t// dbg(\"SOLVE LO HI\", P);\n\tvpi positions;\n\tF0R(i, N) if (P[i] != -1) positions.pb({P[i], i});\n\tauto dif = [&](pi p) { return p.s - p.f; };\n\tauto valid = [&](pi p) {\n\t\treturn dif(p) <= N / 2 && dif(p) >= -((N - 1) / 2);\n\t};\n\tauto paths_xy = [&](int x, int y) { return F.C(x + y, x); };\n\tauto paths_isect = [&](int x, int y, int d) {\n\t\treturn paths_xy(x + d, y - d);\n\t};\n\tauto path = [&](pi s, pi t) -> mi {\n\t\tif (!valid(s) || !valid(t)) return 0;\n\t\tif (!(s.f <= t.f && s.s <= t.s)) return 0;\n\t\tmi ret = paths_xy(t.f - s.f, t.s - s.s);\n\t\tret -= paths_isect(t.f - s.f, t.s - s.s, (N) / 2 + 1 - dif(s));\n\t\tret -= paths_isect(t.f - s.f, t.s - s.s, -((N - 1) / 2) - 1 - dif(s));\n\t\treturn ret;\n\t};\n\tif (!sz(positions)) {\n\t\t// dbg(\"SHORT CIRCUIT\");\n\t\tvmi cum(N);\n\t\tauto update_cum = [&](int l, int r, mi mul, int offset = 0) {\n\t\t\tl += offset, r += offset;\n\t\t\tckmax(l, 0), ckmin(r, N - 2);\n\t\t\tif (l > r) return;\n\t\t\tcum.at(l) += mul;\n\t\t\tcum.at(r + 1) -= mul;\n\t\t};\n\t\tfor (int i = 0; 2 * i < N; ++i) {\n\t\t\tpi st{i, N / 2 - i};\n\t\t\tint x_lo = 0, x_hi = N - 2;\n\t\t\tckmax(x_lo, (int)cdiv(dif(st) + N - 2 - N / 2, 2));\n\t\t\tckmin(x_hi, (int)fdiv(dif(st) + N - 2 + ((N - 1) / 2), 2));\n\t\t\tupdate_cum(x_lo, x_hi, 1);\n\t\t\tupdate_cum(x_lo, x_hi, -1, N / 2 + 1 - dif(st));\n\t\t\tupdate_cum(x_lo, x_hi, -1, -((N - 1) / 2) - 1 - dif(st));\n\t\t\t// FOR(x, x_lo, x_hi + 1) {\n\t\t\t// \t// if (dif(st) + N - 2 - N / 2 <= 2 * x &&\n\t\t\t// \t// \tdif(st) + N - 2 + ((N - 1) / 2) >= 2 * x) {\n\t\t\t// \tret += paths_xy(x, N - 2 - x);\n\t\t\t// \t{\n\t\t\t// \t\tint d = N / 2 + 1 - dif(st);\n\t\t\t// \t\tret -= paths_xy(x + d, N - 2 - x - d);\n\t\t\t// \t}\n\t\t\t// \t{\n\t\t\t// \t\tint d = -((N - 1) / 2) - 1 - dif(st);\n\t\t\t// \t\tret -= paths_xy(x + d, N - 2 - x - d);\n\t\t\t// \t}\n\t\t\t// \t// }\n\t\t\t// }\n\t\t}\n\t\tmi ret = 0;\n\t\tF0R(i, N - 1) {\n\t\t\tif (i) cum[i] += cum[i - 1];\n\t\t\tret += cum[i] * F.C(N - 2, i);\n\t\t}\n\t\treturn ret;\n\t}\n\tsor(positions);\n\tif (!sz(positions) || positions.bk.f != N) positions.pb({N, -1});\n\t// dbg(positions);\n\tauto make_start = [&](int x) -> pi { return {x, N / 2 - x}; };\n\tauto num_odds = [&](int x, int y) {\n\t\tif (!(x & 1)) ++x;\n\t\tif (!(y & 1)) --y;\n\t\tassert(x <= y);\n\t\treturn (y - x) / 2 + 1;\n\t};\n\tauto get_valid_transitions = [&](int val, int pos) {\n\t\t// dbg(\"GET VALID TRANSITIONS\", val, pos);\n\t\tV<pair<pi, pi>> ret;\n\t\tif (pos % 2 == 0) {\n\t\t\t{ // right means up\n\t\t\t\tpi end = make_start(pos / 2);\n\t\t\t\tend.s += val - 1;\n\t\t\t\t// dbg(\"END\", end);\n\t\t\t\tret.pb({{end.f - 1, end.s}, end});\n\t\t\t}\n\t\t\t{ // left means up\n\t\t\t\tpi end = make_start(pos / 2);\n\t\t\t\tend.f += val - 1;\n\t\t\t\tret.pb({{end.f, end.s - 1}, end});\n\t\t\t}\n\t\t} else {\n\t\t\t{\n\t\t\t\tint x = (N - 1) / 2;\n\t\t\t\tx += num_odds(pos, N - 1);\n\t\t\t\tpi end = make_start(x);\n\t\t\t\tend.s += val - 1;\n\t\t\t\tret.pb({{end.f - 1, end.s}, end});\n\t\t\t}\n\t\t\t{\n\t\t\t\tint x = 0;\n\t\t\t\tx -= num_odds(1, pos);\n\t\t\t\tpi end = make_start(x);\n\t\t\t\tend.f += val - 1;\n\t\t\t\tret.pb({{end.f, end.s - 1}, end});\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t};\n\tauto get_end_states = [&]() {\n\t\t// dbg(\"GET END STATES\");\n\t\t// (N+1)/2 -> 1\n\t\t// -> N-1\n\t\tint sum = (N - 2) + N / 2;\n\t\tvpi res;\n\t\tfor (int x = 0;; ++x) {\n\t\t\tpi p{x, sum - x};\n\t\t\t// dbg(p);\n\t\t\tif (valid(p)) res.pb(p);\n\t\t\telse if (dif(p) < 0) break;\n\t\t}\n\t\t// dbg(\"GOT\", res);\n\t\treturn res;\n\t};\n\tauto missing = [&](pi p) {\n\t\t++p.f;\n\t\tassert(p.f > (N - 1) / 2);\n\t\tint last_odd = N - 1;\n\t\tif (!(last_odd & 1)) --last_odd;\n\t\tlast_odd -= 2 * (p.f - (N - 1) / 2 - 1);\n\t\tassert(last_odd >= 0);\n\t\treturn last_odd;\n\t};\n\tV<pair<pi, mi>> start;\n\tauto tran = [&](V<pair<pi, pi>> valid_transitions) {\n\t\tV<pair<pi, mi>> nstart;\n\t\tfor (auto [s, t] : valid_transitions) {\n\t\t\tmi ret = 0;\n\t\t\tfor (auto [p, ways] : start) { ret += ways * path(p, s); }\n\t\t\tnstart.pb({t, ret});\n\t\t}\n\t\tswap(start, nstart);\n\t};\n\tauto transition_end = [&](int pos) {\n\t\tauto states = get_end_states();\n\t\tV<pair<pi, pi>> trans;\n\t\tfor (auto state : states)\n\t\t\tif (pos == -1 || missing(state) == pos) trans.pb({state, state});\n\t\ttran(trans);\n\t};\n\tfor (int i = 0; 2 * i < N; ++i) { start.pb({make_start(i), 1}); }\n\teach(p, start) assert(valid(p.f));\n\tfor (auto [val, pos] : positions) {\n\t\tif (val == 1) {\n\t\t\tif (pos & 1) return 0;\n\t\t\tstart = {{make_start(pos / 2), 1}};\n\t\t} else if (val == N) {\n\t\t\ttransition_end(pos);\n\t\t\tmi ans = 0;\n\t\t\tfor (auto [p, ways] : start) { ans += ways; }\n\t\t\treturn ans;\n\t\t} else {\n\t\t\tV<pair<pi, pi>> trans = get_valid_transitions(val, pos);\n\t\t\ttran(trans);\n\t\t}\n\t}\n\tassert(false);\n}\n\nmi solve(vi P) {\n\tint N = sz(P);\n\tF.init(N + 1);\n\tmi ans = solve_lo_hi(P);\n\teach(t, P) if (t != -1) t = N + 1 - t;\n\tans += solve_lo_hi(P);\n\treturn ans;\n}\n\n} // namespace Faster\n\nvoid solve(int tc) {\n\tints(N);\n\tvi P(N);\n\tre(P);\n\tps(Faster::solve(P));\n\t// ps(Slower::solve(P));\n\t// dbg_time();\n}\n\nint main() {\n\tsetIO();\n\t// rep(100000) {\n\t// \tint N = 5;\n\t// \tvi P(N);\n\t// \tiota(all(P), 1);\n\t// \tshuffle(all(P), rng);\n\t// \teach(t, P) if (rng() & 1) t = -1;\n\t// \tauto a1 = Faster::solve(P);\n\t// \tauto a2 = Slower::solve(P);\n\t// \tif (a1 != a2) {\n\t// \t\tdbg(\"OOPS\", P, a1, a2);\n\t// \t\texit(0);\n\t// \t}\n\t// }\n\t// dbg(\"OK\");\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F2. Anti-median  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/109256",
    "editorial": "For this version, we have to analyze our dp a bit more.Once again, how\r\ndo anti-median permutations look? We consider the order of positions on\r\nthe cycle, as in F1. We choose the position of , and then, for from to ,\r\nwe choose a position of number among two options: right to the right of\r\nthe current segment or right to the left.If we fill this way, do we\r\nalways get an anti-median permutation? Not really. This way makes sure\r\nthat elements at even positions are first increasing, then decreasing,\r\nand at odd positions, first decreasing, then increasing, but it doesnât\r\nmake sure that the element at the even position is larger than its\r\nneighbors. How do we guarantee that? Well, some segments are just not\r\nallowed: those, which contain a prefix of odd positions, prefix of even\r\npositions, and the prefix of odd positions is larger (off by , depending\r\non the parity of ), and same for suffixes.Another observation is that if\r\nwe know where is, we only have to options for where can the segment of\r\nnumbers from to be (to the right or to the left of ). This reduces our\r\nproblem to the following subproblem: we start from some segment and have\r\nto end in another segment by expanding the current segment by to the\r\nright or to the left without ever entering \"bad segments.\" Turns out\r\nthat we can solve this in ! Indeed, represent expanding segment to the\r\nright by a move up in a coordinate plane and to the left by a move to\r\nthe right. Then, we have to get from point to some point by moving up or\r\nto the right without ever crossing some line of form . This is a\r\nwell-known counting problem.\r\n",
    "hint": []
}