{
    "link": "https://codeforces.com//contest/1017/problem/D",
    "problemId": "205994",
    "problem_idx": "D",
    "shortId": "1017D",
    "contest_number": "1017",
    "problem_submissions": {
        "D": [
            213438615,
            41349796,
            41350791,
            41348185,
            41349812,
            41350101,
            41348724,
            41347389,
            41349904,
            41347605,
            41349745,
            41349033,
            41348833,
            41350403,
            41348388,
            41346916,
            41354063,
            41351152,
            41351165,
            41350393
        ],
        "G": [
            41374563,
            41365956,
            41365630,
            41370631,
            41581755
        ],
        "E": [
            41372644,
            41354131,
            41370166,
            41371119,
            41372376,
            41372311,
            41372287,
            41351667,
            41351074,
            41355101,
            41350783,
            41352192,
            41358773,
            41351309,
            41350915,
            41353764,
            41670429,
            41352396,
            41371198,
            41367467,
            41359456,
            41372423,
            41372409,
            41364755,
            41352601,
            41351865,
            41355587
        ],
        "H": [
            41367702,
            41388366,
            41626780
        ],
        "F": [
            41355954,
            41350751,
            41350606,
            41351910,
            41355898,
            41353364,
            41356617,
            41361175,
            41354830,
            41361644,
            41363928,
            41363246,
            41362644,
            41355024,
            41364885,
            41350456,
            41363913,
            41365213,
            41366266
        ],
        "C": [
            41344757,
            41346763,
            41343411,
            41343517,
            41344074,
            41345347,
            41344535,
            41344681,
            41344025,
            41345552,
            41345435,
            41344114,
            41346166,
            41344588,
            41343025,
            41345381,
            41348981,
            41347870,
            41345665
        ],
        "B": [
            41341663,
            41342076,
            41341369,
            41340402,
            41341632,
            41341916,
            41341844,
            41341458,
            41340722,
            41342695,
            41342729,
            41341507,
            41343151,
            41342641,
            41340890,
            41341644,
            41344184,
            41342297,
            41342415
        ],
        "A": [
            41338985,
            41339200,
            41339204,
            41344352,
            41339618,
            41339017,
            41339766,
            41339115,
            41339233,
            41339235,
            41340222,
            41339363,
            41338992,
            41339153,
            41339052,
            41339096,
            41339145,
            41339283,
            41339775
        ]
    },
    "name": "D. The Wu",
    "statement": "Childan is making up a legendary story and trying to sell his forgery a\r\nnecklace with a strong sense of \"\" to the Kasouras. But Mr. Kasoura is\r\nchallenging the truth of Childan\u2019s story. So he is going to ask a few\r\nquestions about Childan\u2019s so-called \"personal treasure\" necklace.This\r\n\"personal treasure\" is a multiset S of m \"\".A \"\" is a string that\r\ncontains n characters \"\" and \"\". For example, if n=4, strings \"\", \"\",\r\nand \"\" are \"\", but \"\" (there are 5 characters, not 4) and \"\" (unallowed\r\ncharacters) are not.Frequently, Mr. Kasoura will provide a \"\" t and ask\r\nChildan how many strings s are in the multiset S such that the \"\" value\r\nof the pair (s, t) is than k. Mrs. Kasoura and Mr. Kasoura think that if\r\ns_i = t_i (1\r\nleq i\r\nleq n) then the \"\" value of the character pair equals to w_i, otherwise\r\n0. The \"\" value of the \"\" pair is the sum of the \"\" values of every\r\ncharacter pair. Note that the length of every \"\" is equal to n.For\r\nexample, if w=[4, 5, 3, 6], \"\" of (\"\", \"\") is 7 because these strings\r\nhave equal characters only on the first and third positions, so\r\nw_1+w_3=4+3=7.You need to help Childan to answer Mr. Kasoura\u2019s queries.\r\nThat is to find the number of strings in the multiset S such that the \"\"\r\nvalue of the pair is not greater than k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\tvector<int> w(n);\n\tfor (int &i : w) { cin >> i; }\n\n\t// precompute wu value for every subset\n\tvector<int> wu(1 << n);\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i & (1 << j)) { wu[i] += w[j]; }\n\t\t}\n\t}\n\n\t// convert all strings to integers and store count\n\tvector<int> str_count(1 << n);\n\tfor (int i = 0; i < m; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint val = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[j] == '1') { val += 1 << j; }\n\t\t}\n\t\tstr_count[val]++;\n\t}\n\n\t/*\n\t * precompute wu value between every pair of possible strings\n\t * .first stores the actual value, .second stores prefix of count\n\t */\n\tvector<vector<pair<int, int>>> pref_wu(1 << n,\n\t                                       vector<pair<int, int>>(1 << n));\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tfor (int j = 0; j < (1 << n); j++) {\n\t\t\tpref_wu[i][j] = {wu.back() - wu[i ^ j], str_count[j]};\n\t\t}\n\t\tsort(pref_wu[i].begin(), pref_wu[i].end());\n\t\t// accumulate prefix sums of count\n\t\tfor (int j = 1; j < (1 << n); j++) {\n\t\t\tpref_wu[i][j].second += pref_wu[i][j - 1].second;\n\t\t}\n\t}\n\n\tfor (int query = 0; query < q; query++) {\n\t\tstring t;\n\t\tint k;\n\t\tcin >> t >> k;\n\t\tint val = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (t[i] == '1') { val += 1 << i; }\n\t\t}\n\t\t// binary search for the least element with wu greater than k\n\t\tauto it = upper_bound(pref_wu[val].begin(), pref_wu[val].end(),\n\t\t                      make_pair(k, INT32_MAX));\n\t\tif (it == pref_wu[val].begin()) {\n\t\t\tcout << 0 << \"\\n\";\n\t\t} else {\n\t\t\tcout << prev(it)->second << \"\\n\";\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "data structures"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. The Wu.json",
    "editorial_link": "https://codeforces.com/blog/entry/61081",
    "editorial": "We can regard a as a binary number. where is bit-wise XOR and we can\r\npreprocess .Notice that , so , so we can do something like\r\nmeet-in-the-middle, split the numbers into higher bits and lower bits:\r\ncount the number of binary numbers with higher bits equal to and .Then\r\none can easily get stores the answer and then answer queries in time.If\r\nyou don\u00e2\u0080\u0099t understand, see the code.Complexity: .\r\n"
}