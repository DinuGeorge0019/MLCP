{"link": "https://codeforces.com//contest/1863/problem/E", "problemId": "2186456", "problem_idx": "E", "shortId": "1863E", "contest_number": "1863", "problem_submissions": {"G": [221136551, 221139848, 221147121, 221150406, 221156272, 221151276, 221147870, 221157045, 221150654, 221158033, 221156995, 221150405, 221155989, 221155038, 221160627, 221149999, 221166719, 221155326, 221159641, 221165396], "F": [221121590, 221127771, 221128307, 221138108, 221130805, 221136021, 221136737, 221129060, 221140638, 221137056, 221128211, 221139417, 221137699, 221127026, 221139802, 221154849, 221135761, 221144061, 221150102, 221217304, 221142638], "E": [221110018, 221117203, 221116712, 221116632, 221114627, 221123945, 221125852, 221119344, 221123994, 221117191, 221120648, 221126771, 221126517, 221139461, 221119939, 221121938, 221123387, 221126376, 221121543, 221217383, 221127296], "D": [221102414, 221109581, 221105244, 221107918, 221106665, 221103992, 221113320, 221110649, 221111108, 221103919, 221112047, 221112174, 221110753, 221112715, 221104010, 221113678, 221110048, 221113375, 221110273, 221109100], "C": [221098267, 221102354, 221100311, 221098509, 221100896, 221098602, 221107809, 221105183, 221098239, 221098225, 221102929, 221105006, 221102283, 221103582, 221098969, 221099286, 221102760, 221106477, 221099714, 221101657], "A": [221096643, 221096074, 221096129, 221096043, 221095975, 221096016, 221096907, 221096642, 221101230, 221095943, 221096347, 221097350, 221096423, 221097791, 221095953, 221096058, 221096941, 221096889, 221096069, 221097073], "B": [221096498, 221097225, 221097260, 221096607, 221096286, 221096471, 221098534, 221098779, 221102915, 221096280, 221097328, 221098778, 221097955, 221099465, 221096389, 221096664, 221099499, 221099302, 221096756, 221098284], "I": [221276607, 221276430, 221275617, 221825420, 221197104], "H": [221188380, 221214363, 221182970, 221376731, 221376708, 221376397, 221187887]}, "name": "E. Speedrun", "statement": "You are playing a video game. The game has n quests that need to be\r\ncompleted. However, the j-th quest can only be completed at the\r\nbeginning of hour h_j of a game day. The game day is k hours long. The\r\nhours of each game day are numbered 0, 1,\r\nldots, k - 1. After the first day ends, a new one starts, and so\r\non.Also, there are dependencies between the quests, that is, for some\r\npairs (a_i, b_i) the b_i-th quest can only be completed after the a_i-th\r\nquest. It is guaranteed that there are , as otherwise the game would be\r\nunbeatable and nobody would play it.You are skilled enough to complete\r\nany number of quests in a negligible amount of time (i. e. you can\r\ncomplete any number of quests at the beginning of the same hour, even if\r\nthere are dependencies between them). You want to complete all quests as\r\nfast as possible. To do this, you can complete the quests in any valid\r\norder. The completion time is equal to the difference between the time\r\nof completing the last quest and the time of completing the first quest\r\nin this order.Find the least amount of time you need to complete the\r\ngame.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 30.08.2023 10:46:21       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n      cin >> h[i];\n    }\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n    }\n    vector<int> order(n);\n    iota(order.begin(), order.end(), 0);\n    sort(order.begin(), order.end(), [&](int i, int j) {\n      return h[i] < h[j];\n    });\n    vector<int> d(n);\n    for (int i = 0; i < n; i++) {\n      for (int j : g[i]) {\n        int v = d[i] + (h[i] > h[j]);\n        d[j] = max(d[j], v);\n      }\n    }\n    long long mx = 0;\n    for (int i = 0; i < n; i++) {\n      mx = max(mx, (long long) d[i] * k + h[i]);\n    }\n    long long ans = mx - h[order[0]];\n    for (int it = 0; it < n - 1; it++) {\n      vector<int> que;\n      auto Update = [&](int i, int v) {\n        if (v > d[i]) {\n          d[i] = v;\n          que.push_back(i);\n          mx = max(mx, (long long) d[i] * k + h[i]);\n        }\n      };\n      Update(order[it], 1);\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int j : g[que[b]]) {\n          int v = d[que[b]] + (h[que[b]] > h[j]);\n          Update(j, v);\n        }\n      }\n      ans = min(ans, mx - h[order[it + 1]]);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "dp", "graphs", "greedy", "math", "sortings", "two pointers"], "dificulty": "2100", "interactive": false}