{
    "link": "https://codeforces.com//contest/2034/problem/D",
    "problemId": "3057438",
    "problem_idx": "D",
    "shortId": "2034D",
    "contest_number": "2034",
    "problem_submissions": {
        "G2": [
            294090902,
            294102835,
            294091710
        ],
        "H": [
            294074360,
            294061476,
            294070650,
            294080097,
            294083247,
            294085834,
            294087678,
            294090336,
            294084822,
            294087654,
            294090587,
            294104472,
            294104397,
            294104185,
            294103049,
            294058057,
            294072183,
            294081941,
            294086147,
            294091448
        ],
        "G1": [
            294068700,
            294089598,
            294090555,
            294512628,
            294279844,
            294078743,
            294092614,
            294083324,
            294137051,
            298736856
        ],
        "F2": [
            294044355,
            294048880,
            294057967,
            294058547,
            294044212,
            294052710,
            294062635,
            294059190,
            294064262,
            294068869,
            294068913,
            294056682,
            294087439,
            294054148,
            294055470,
            294067548,
            294048518,
            294098694,
            297729208
        ],
        "F1": [
            294044201,
            294045676,
            294057746,
            294058488,
            294044581,
            294052242,
            294063014,
            294059348,
            294064621,
            294068676,
            294069032,
            294056298,
            294079209,
            294055715,
            294050068,
            294055587,
            294059717,
            294048439,
            294065367,
            294063971
        ],
        "E": [
            294039732,
            294035256,
            294043120,
            294044445,
            294061596,
            294042263,
            294051208,
            294051638,
            294059206,
            294057047,
            294047623,
            294072917,
            294043657,
            294040686,
            294046402,
            294070560,
            294044216,
            294048932,
            294047270
        ],
        "D": [
            294029209,
            294029423,
            294031077,
            294032177,
            294053262,
            294029511,
            294040505,
            294041118,
            294048071,
            294036073,
            294034324,
            294064606,
            294034084,
            294023836,
            294028591,
            294031360,
            294038809,
            294039055
        ],
        "C": [
            294019511,
            294017117,
            294018450,
            294020877,
            294023563,
            294033582,
            294025662,
            294021753,
            294020563,
            294027112,
            294020897,
            294016537,
            294062723,
            294021341,
            294029864,
            294018381,
            294021917,
            294017733,
            294050791,
            294028560
        ],
        "B": [
            294013321,
            294006563,
            294009984,
            294010387,
            294010473,
            294013337,
            294026398,
            294010402,
            294011621,
            294010156,
            294007642,
            294050334,
            294011602,
            294008120,
            294012362,
            294012172,
            294084096,
            294006809,
            294008731
        ],
        "A": [
            294004839,
            294004703,
            294005425,
            294005031,
            294006081,
            294004631,
            294006317,
            294005105,
            294006032,
            294005086,
            294004777,
            294047604,
            294005991,
            294004926,
            294006968,
            294005489,
            294006094,
            294004648,
            294005025
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136579",
    "editorial": " Step 1: Using\ntwo moves, we can move an element to any arbitrary position in the\narray. Thus, we can place all \u00e2\u0080\u0099s in their correct positions with at most\nmoves. Step 2: After placing all \u00e2\u0080\u0099s, the rest of the array will contain\nonly \u00e2\u0080\u0099s and \u00e2\u0080\u0099s. To sort this part of the array, we need at most moves.\nStep 3: The first step takes at most moves, and the second step takes at\nmost moves. However, it can be proven that the total number of moves is\nat most . Step 4: We can assume without loss of generality (Why?). So,\nthe maximum number of moves are: Better approach: Step 1: Since we are\nallowed to perform moves, assign each index one \"move\" as its \"specified\ncost\". Step 2: While there exists an index with a value of or that can\nbe fixed with just one move, fix it using its assigned cost. Step 3:\nAfter fixing all \u00e2\u0080\u0099s, \u00e2\u0080\u0099s, and all \u00e2\u0080\u0099s except one, the remaining array will\nhave the following structure and we are now allowed to use moves: Step\n4: First, swap the with a random element (denote it as ). Then, for\nmoves, swap the index with the value with any index where the correct\nvalue must be placed, except . Finally, swap and .\n",
    "name": "D. Darius  Wisdom",
    "statement": "Darius the Great is constructing n stone columns, each consisting of a\r\nbase and between 0, 1, or 2 inscription pieces stacked on top.In each\r\nmove, Darius can choose two columns u and v such that the difference in\r\nthe number of inscriptions between these columns is exactly 1, and\r\ntransfer one inscription from the column with more inscriptions to the\r\nother one. It is guaranteed that at least one column contains exactly 1\r\ninscription. Since beauty is the main pillar of historical buildings,\r\nDarius wants the columns to have ascending heights. To avoid excessive\r\nworkers\u2019 efforts, he asks you to plan a sequence of moves to arrange the\r\ncolumns in non-decreasing order based on the number of inscriptions.\r\nMinimizing the number of moves is .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7;int n, m;set<int>s[3];int a[N];vector<pair<int,int>>ans;void move(int x, int y) {\t// cout << \"move \" << x << ' ' << y <<  endl;\tans.pb(x, y);\tassert(abs(a[x] - a[y]) == 1);\ts[a[x]].erase(x);\ts[a[y]].erase(y);\tswap(a[x],a[y]);\ts[a[x]].insert(x);\ts[a[y]].insert(y);}void Main() {\tans.clear();\tcin >> n;\tL(i, 1, n) {\t\tcin >> a[i];\t\ts[a[i]].insert(i);\t}\tif(sz(s[0]) < sz(s[2])) {\t\tint cur = 0;\t\twhile(sz(s[0])) {\t\t\t++cur;\t\t\tif(*s[0].begin() == cur) {\u00a0\t\t\t} else if(*s[1].begin() == cur) {\t\t\t\tmove(*s[1].begin(), *s[0].begin());\t\t\t} else {\t\t\t\tmove(*s[1].begin(), *s[2].begin());\t\t\t\tmove(*s[1].begin(), *s[0].begin());\t\t\t}\t\t\ts[0].erase(s[0].begin());\t\t}\t\twhile(sz(s[1])) {\t\t\t++cur;\t\t\tif(*s[1].begin() == cur) {\u00a0\t\t\t} else {\t\t\t\tmove(*s[2].begin(), *s[1].begin());\t\t\t} \t\t\ts[1].erase(s[1].begin());\t\t}\t} else {\t\tint cur = n + 1;\t\twhile(sz(s[2])) {\t\t\t--cur;\t\t\tif(*--s[2].end() == cur) {\u00a0\t\t\t} else if(*--s[1].end() == cur) {\t\t\t\tmove(*--s[1].end(), *--s[2].end());\t\t\t} else {\t\t\t\tmove(*--s[1].end(), *--s[0].end());\t\t\t\tmove(*--s[1].end(), *--s[2].end());\t\t\t}\t\t\ts[2].erase(--s[2].end());\t\t}\t\twhile(sz(s[1])) {\t\t\t--cur;\t\t\tif(*--s[1].end() == cur) {\u00a0\t\t\t} else {\t\t\t\tmove(*--s[0].end(), *--s[1].end());\t\t\t} \t\t\ts[1].erase(--s[1].end());\t\t}\t}\tcout << sz(ans) << '\\n';\tfor(auto u : ans)\t\tcout << u.first << ' ' << u.second << '\\n';\t// L(i, 1, n) cout << a[i] << ' ';\t// cout << endl;\tL(i, 0, 2) s[i].clear();}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Darius  Wisdom.json"
}