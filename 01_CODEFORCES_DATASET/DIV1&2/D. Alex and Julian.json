{
    "link": "https://codeforces.com//contest/1220/problem/D",
    "problemId": "415036",
    "problem_idx": "D",
    "shortId": "1220D",
    "contest_number": "1220",
    "problem_submissions": {
        "F": [
            60794655,
            60795420,
            60798012,
            60796211,
            60799458,
            60799042,
            60800694,
            60802837,
            60802344,
            60801389,
            60840886,
            60840780,
            60840626,
            60840499,
            60816071,
            60802432,
            60804302,
            60803333,
            60805888,
            60807155,
            60806082,
            60806528,
            60805639,
            60807120,
            60805696
        ],
        "E": [
            60790215,
            60792421,
            60792651,
            60792239,
            60793143,
            60792840,
            60795721,
            60794580,
            60796658,
            60794976,
            60796781,
            60798760,
            60797350,
            60797489,
            60796246,
            60798051,
            60800665,
            60797651,
            60800039,
            60800893
        ],
        "D": [
            60786802,
            60786831,
            60788316,
            60786890,
            60789386,
            60786761,
            60791950,
            60790977,
            60790845,
            60791802,
            60790799,
            60791826,
            60794564,
            60792553,
            60792010,
            60792977,
            60788272,
            60792327,
            60792666,
            60788893
        ],
        "C": [
            60784461,
            60784654,
            60786011,
            60784793,
            60786790,
            60784487,
            60788242,
            60786432,
            60786611,
            60789040,
            60786867,
            60788037,
            60788357,
            60788969,
            60787866,
            60789945,
            60786608,
            60789677,
            60787852,
            60786166
        ],
        "B": [
            60781859,
            60783053,
            60783409,
            60782430,
            60783345,
            60782386,
            60782468,
            60784465,
            60785209,
            60786375,
            60784225,
            60785909,
            60785762,
            60785740,
            60785272,
            60786460,
            60783349,
            60784859,
            60785464,
            60782087
        ],
        "A": [
            60780482,
            60780507,
            60780481,
            60782646,
            62687701,
            60784803,
            60780490,
            60784397,
            60781094,
            60781294,
            60786801,
            60780787,
            60780645,
            60785632,
            60782015,
            60781702,
            60780484,
            60780455,
            60781879,
            60780860,
            60783535
        ],
        "G": [
            76800366
        ]
    },
    "name": "D. Alex and Julian",
    "statement": "Boy Dima gave Julian a birthday present set B consisting of positive\r\nintegers. However, he didn’t know, that Julian hates sets, but enjoys\r\nbipartite graphs more than anything else!Julian was almost upset, but\r\nher friend Alex said, that he can build an undirected graph using this\r\nset in such a way: let all integer numbers be vertices, then connect any\r\ntwo i and j with an edge if |i - j| belongs to B.Unfortunately, Julian\r\ndoesn’t like the graph, that was built using B. Alex decided to rectify\r\nthe situation, so he wants to erase some numbers from B, so that graph\r\nbuilt using the new set is bipartite. The difficulty of this task is\r\nthat the graph, Alex has to work with, has an infinite number of\r\nvertices and edges! It is impossible to solve this task alone, so Alex\r\nasks you for help. Write a program that erases a subset of size from B\r\nso that graph constructed on the new set is bipartite.Recall, that graph\r\nis bipartite if all its vertices can be divided into two disjoint sets\r\nsuch that every edge connects a vertex from different sets.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tint n; cin >> n;\n\tvll nums(n);\n\tfor (ll &x : nums) { cin >> x; }\n\t\n\tvector<vi> v2(64);\n\tfor (int i = 0; i < n; ++i) {\n\t\tll x = nums[i];\n\t\tint p = 0;\n\t\twhile (x % 2 == 0) {\n\t\t\tx /= 2;\n\t\t\t++p;\n\t\t}\n\t\tv2[p].push_back(i);\n\t}\n\t\n\tvector<int> best;\n\t\n\tfor (int i = 0; i < 64; ++i) {\n\t\tif (SZ(v2[i]) > SZ(best)) {\n\t\t\tbest = v2[i];\n\t\t}\n\t}\n\t\n\tcout << n - SZ(best) << \"\\n\";\n\tvector<bool> erase(n, true);\n\tfor (int x : best) { erase[x] = false; }\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (erase[i]) {\n\t\t\tcout << nums[i] << \" \";\n\t\t}\n\t}\n\tcout << \"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Alex and Julian.json",
    "editorial_link": "https://codeforces.com//blog/entry/69899",
    "editorial": "Let all numbers in be odd. If two vertices and are connected, then they\r\nhave different parity, hence our graph is already bipartite (first part\r\nis even vertices, second odd vertices).Now letâs see that if we choose\r\nan integer , multiply all elements of the set by and build a new graph\r\non this set, our new graph will also be bipartite. Proof: consider -th\r\nbit. An edge connects only vertices with different -th bit, so partition\r\nis clear.So, we found out that if all elements in have equal power of in\r\ntheir factorization, then this set builds a bipartite graph. What about\r\nother cases? Let . They form a cycle with . Itâs easy to see that is odd\r\niff and contain different powers of in their factorization, so we just\r\nproved that there is no other cases.Finally, the solution is to find\r\nmaximum power of that divides for all , find the largest subset with\r\nequal power of and drop . Complexity .\r\n",
    "hint": []
}