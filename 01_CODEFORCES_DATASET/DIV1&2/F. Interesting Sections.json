{"link": "https://codeforces.com//contest/1609/problem/F", "problemId": "1205814", "problem_idx": "F", "shortId": "1609F", "contest_number": "1609", "problem_submissions": {"H": [137263072, 140966657, 137541381, 137373776, 137353707, 137353217], "G": [137246775, 137257898, 137258174, 137261032, 137258429, 137256905, 137250571, 137257690, 137251480, 137263274, 137259638, 137276051, 137269427, 137261135, 137260806, 137259792, 137262185, 137263614, 137264862, 137254900, 137261420, 137264154], "F": [137240106, 137246731, 137244466, 137246785, 137246316, 137246745, 137260178, 137270360, 137247766, 137257633, 137249504, 137249777, 137249032, 137252722, 137252015, 137251624, 137252333, 137250283, 137261839, 137252294, 137249612], "E": [137234780, 137235959, 137233979, 137232935, 137235656, 137237935, 137233267, 137237781, 137236310, 137235301, 137237711, 137241732, 137237330, 137241596, 137235797, 137236926, 137239464, 137239281, 137241206, 137238999], "D": [137226570, 137230215, 137231182, 137228712, 137232181, 137231416, 137229857, 137231314, 137233347, 137230846, 137231581, 137229849, 137233415, 137234328, 137231105, 137231235, 137232699, 137231119, 137233860, 137235117], "C": [137224003, 137226381, 137228113, 137226088, 137228622, 137227880, 137227092, 137227813, 137229692, 137227035, 137228022, 137226433, 137228702, 137230474, 137231768, 137227164, 137229482, 137228456, 137229353, 137230487], "B": [137222196, 137223090, 137224802, 137223100, 137224371, 137223720, 137223346, 137224383, 137222999, 137223539, 137224162, 137223482, 137224120, 137224040, 137223954, 137223074, 137224144, 137224291, 137224533, 137224451], "A": [137221600, 137221784, 137221681, 137221800, 137221985, 137221740, 137221875, 137222467, 137221786, 137221979, 137222676, 137221642, 137222045, 137222137, 137226851, 137224172, 137221659, 137222130, 137222631, 137222150]}, "name": "F. Interesting Sections", "statement": "William has an array of non-negative numbers a_1, a_2,\r\ndots, a_n. He wants you to find out how many segments l\r\nle r pass the check. The check is performed in the following manner: The\r\nminimum and maximum numbers are found on the segment of the array\r\nstarting at l and ending at r. The check is considered to be passed if\r\nthe binary representation of the minimum and maximum numbers have the\r\nsame number of bits equal to 1.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 28.11.2021 18:07:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n\n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n\n  inline explicit operator bool() {\n    return cur != -1;\n  }\n\n  inline static bool is_blank(char c) {\n    return c <= ' ';\n  }\n\n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn't check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == '-') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - '0';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), \"%lf\", &n);\n    }\n    return *this;\n  }\n} fast_input;\n\n#define cin fast_input\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> pc(n);\n  for (int i = 0; i < n; i++) {\n    pc[i] = __builtin_popcountll(a[i]);\n  }\n  const int M = 62;\n  vector<vector<tuple<int, int, int>>> segs_min(M);\n  vector<vector<tuple<int, int, int>>> segs_max(M);\n  vector<int> st_min(1, -1);\n  vector<int> st_max(1, -1);\n  auto CountOne = [&](const vector<tuple<int, int, int>>& v, int up) {\n    auto it = lower_bound(v.begin(), v.end(), make_tuple(up + 1, -1, -1));\n    int res = (it == v.begin() ? 0 : get<2>(*prev(it)));\n    if (it != v.end() && up >= get<1>(*it)) {\n      res += up - get<1>(*it) + 1;\n    }\n    return res;\n  };\n  auto Count = [&](const vector<tuple<int, int, int>>& v, int L, int R) {\n    return CountOne(v, R) - CountOne(v, L - 1);\n  };\n  int cc = 0;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    while (st_min.size() > 1 && a[st_min.back()] > a[i]) {\n      cc -= Count(segs_max[pc[st_min.back()]], st_min[st_min.size() - 2] + 1, st_min.back());\n      segs_min[pc[st_min.back()]].pop_back();\n      st_min.pop_back();\n    }\n    cc += Count(segs_max[pc[i]], st_min.back() + 1, i);\n    segs_min[pc[i]].emplace_back(i, st_min.back() + 1, (i - st_min.back()) + (segs_min[pc[i]].empty() ? 0 : get<2>(segs_min[pc[i]].back())));\n    st_min.push_back(i);\n\n    while (st_max.size() > 1 && a[st_max.back()] < a[i]) {\n      cc -= Count(segs_min[pc[st_max.back()]], st_max[st_max.size() - 2] + 1, st_max.back());\n      segs_max[pc[st_max.back()]].pop_back();\n      st_max.pop_back();\n    }\n    cc += Count(segs_min[pc[i]], st_max.back() + 1, i);\n    segs_max[pc[i]].emplace_back(i, st_max.back() + 1, (i - st_max.back()) + (segs_max[pc[i]].empty() ? 0 : get<2>(segs_max[pc[i]].back())));\n    st_max.push_back(i);\n\n    ans += cc;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "meet-in-the-middle", "two pointers"], "dificulty": "2800", "interactive": false}