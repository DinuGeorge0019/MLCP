{
    "link": "https://codeforces.com//contest/2039/problem/E",
    "problemId": "3044245",
    "problem_idx": "E",
    "shortId": "2039E",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "Itâs hard to track the array when we insert new inversions as the\r\ninversion number can quickly become very large.The key observation here\r\nis to notice what happens when the inversion count becomes more than .\r\nAs the initial array has only and as elements when we insert an\r\ninversion count that is more than , the inversion count will be larger\r\nthan any element of the array. And this gives us a way to control\r\neverything!Let be the number of final arrays of length we can get from\r\nthe current array of length if the current number of inversions in it is\r\nlarger than any element of the array.Let be the number of inversions in\r\nthe current array and . Then If we insert not in the end, then the new\r\ninversion count will be more than , so we get the same situation for Or\r\nif we insert in the end then the number of inversions will still be . So\r\nif we inserted it times in the end and once somewhere else ( ways to do\r\nso) then we will get the situation for So , here is added as we can end\r\nthe sequence here by inserting in the end times.This can be computed\r\nwith simple dp in time using suffix sums.Now we just need to deal with\r\nthe starting array when it starts to have more than inversion.There are\r\nways to finish the sequence having inversion. And they are of the form\r\nthis is because we first insert at the beginning for some time and then\r\nwe get inversion count when we insert at the end for the first time and\r\nthen we will have to insert at the end every time after that.And to\r\ncount the ways to get the starting array of length with more than\r\ninversion, we can notice that itâs just the sum of ways where we insert\r\nbefore the first in any sequence of the form like above . And if the\r\nposition of the first is then we have ways to do so. So total ways is So\r\nthe answer is just Note that there are ways to write the dp so that you\r\ndonât have to handle the starting array separately. Also in this\r\nproblem, we have limited the total sum of over all test cases. But there\r\nexists solutions where the solution works even without the limit but we\r\ndecided to let both solutions pass.Also, I am extremely sorry that\r\nduring the contest we found out that some people found the second\r\ndifference/derivative of the sequence on OEIS. We searched on OEIS\r\nbefore but couldnât find it, otherwise we would have modified the\r\nproblem. Again, sorry for this issue.\r\n",
    "name": "E. Shohag Loves Inversions",
    "statement": "Shohag has an array a of integers. Initially a = [0, 1]. He can\r\nrepeatedly perform the following operation any number of times: Let k be\r\nthe number of inversions^{\r\ntext{ }} in the current array a. Insert k at any position in a,\r\nincluding the beginning or the end. For example, if a = [4, 6, 2, 4],\r\nthen the number of inversions is k = 3. So Shohag can obtain the\r\nfollowing arrays after the operation: [\r\ntextbf{3}, 4, 6, 2, 4], [4,\r\ntextbf{3}, 6, 2, 4], [4, 6,\r\ntextbf{3}, 2, 4], [4, 6, 2,\r\ntextbf{3}, 4], and [4, 6, 2, 4,\r\ntextbf{3}].Given an integer n, help Shohag count, modulo 998\r\n,244\r\n,353, the number of distinct arrays of length n that can be obtained\r\nafter performing the operations.^{\r\ntext{ }}The number of inversions in an array a is the number of pairs of\r\nindices (i, j) such that i < j and a_i > a_j.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353, inv2 = (mod + 1) / 2;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n;mint dp[N], ans[N];void Main() {\tcin >> n;\tL(i, 0, n) dp[i] = 0;\tmint ans = n - 1;\tL(s, 4, n) {\t\tdp[s] += (mint) (s - 2) * (s - 1) * inv2;\t\tdp[s] -= 1;\t}\tmint pre = 0;\tL(i, 1, n) {\t\tdp[i] += pre;\t\tpre += dp[i] * i;\t\tans += dp[i];\t}\tcout << ans.x << '\\n';}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\t\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Shohag Loves Inversions.json",
    "hint": []
}