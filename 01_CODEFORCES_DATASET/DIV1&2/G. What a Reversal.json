{"link": "https://codeforces.com//contest/1530/problem/G", "problemId": "1049174", "problem_idx": "G", "shortId": "1530G", "contest_number": "1530", "problem_submissions": {"H": [122851665, 122838743, 122844195, 122849012, 122871696, 122848567, 122889728], "G": [122840209, 122852256, 122900209, 122846129, 122844934, 122847648, 122853646, 122874899, 122880351, 122921209], "F": [122810446, 122819713, 122812617, 122825773, 122868869, 122809297, 122821188, 122827035, 122824965, 122821818, 122829815, 122826847, 122822005, 122826789, 122826175, 122826918, 122836373, 122830797, 122814894, 122838442, 122834199], "E": [122803663, 122805810, 122805166, 122812311, 122817063, 122814296, 122807127, 122808379, 122800583, 122808253, 122808203, 122811232, 122807495, 122807208, 122811521, 122828022, 122805125, 122810921], "D": [122791676, 122796247, 122793005, 122795921, 122795213, 122793368, 122796651, 122796980, 122803859, 122791210, 122799331, 122796501, 122797048, 122796533, 122791355, 122798720, 122801973, 122792843, 122800740], "C": [122785861, 122787673, 122786660, 122785034, 122784856, 122787839, 122786985, 122784250, 122795439, 122782668, 122786465, 122789088, 122786999, 122788656, 122784366, 122787966, 122789017, 122785054, 122790340], "B": [122781549, 122782427, 122782526, 122782097, 122782078, 122780831, 122781690, 122789087, 122786285, 122785455, 122781801, 122781479, 122782615, 122783296, 122794583, 122783767, 122783971, 122780469, 122782275], "A": [122775440, 122775417, 122775273, 122775738, 122775580, 122775190, 122775752, 122790605, 122781313, 122775806, 122775746, 122775311, 122776001, 122775468, 122776055, 122775938, 122777214, 122775025, 122775038]}, "name": "G. What a Reversal", "statement": "You have two strings a and b of equal length n consisting of characters\r\nand , and an integer k.You need to make strings a and b equal.In one\r\nstep, you can choose any substring of a containing exactly k characters\r\n(and arbitrary number of characters ) and reverse it. Formally, if a =\r\na_1 a_2\r\nldots a_n, you can choose any integers l and r (1\r\nle l\r\nle r\r\nle n) such that there are exactly k ones among characters a_l, a_{l+1},\r\nldots, a_r, and set a to a_1 a_2\r\nldots a_{l-1} a_r a_{r-1}\r\nldots a_l a_{r+1} a_{r+2}\r\nldots a_n.Find a way to make a equal to b using at most 4n reversals of\r\nthe above kind, or determine that such a way doesn\u2019t exist. The number\r\nof reversals doesn\u2019t have to be minimized.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    std::string a, b;\n    std::cin >> a >> b;\n    \n    if (a == b) {\n        std::cout << \"0\\n\";\n        return;\n    }\n    \n    int cnt = std::count(a.begin(), a.end(), '1');\n    if (std::count(b.begin(), b.end(), '1') != cnt) {\n        std::cout << \"-1\\n\";\n        return;\n    }\n    \n    if (k == 0 || k > cnt) {\n        std::cout << \"-1\\n\";\n        return;\n    }\n    \n    auto solve = [&](std::string &s) {\n        std::vector<std::pair<int, int>> ans;\n        \n        auto reverse = [&](int l, int r) {\n            ans.emplace_back(l, r);\n            std::reverse(s.begin() + l, s.begin() + r);\n        };\n        \n        std::vector<int> a, pos;\n        auto get = [&]() {\n            a.clear();\n            pos = {-1};\n            int lst = -1;\n            for (int i = 0; i < n; i++) {\n                if (s[i] == '1') {\n                    pos.push_back(i);\n                    a.push_back(i - lst - 1);\n                    lst = i;\n                }\n            }\n            a.push_back(n - lst - 1);\n            pos.push_back(n);\n        };\n        get();\n        \n        for (int i = cnt; i >= k; i--) {\n            if (a[i] > 0) {\n                reverse(pos[i - k + 1], pos[i + 1]);\n                get();\n                assert(a[i] == 0);\n            }\n        }\n        \n        if (k == cnt) {\n            auto b = a;\n            std::reverse(b.begin() + 1, b.end() - 1);\n            if (b < a) {\n                reverse(pos[1], pos[k] + 1);\n            }\n            return ans;\n        }\n        \n        if (k % 2 == 1) {\n            for (int i = 0; i < k - 1; i++) {\n                reverse(pos[2], pos[k + 1] + 1);\n                get();\n                reverse(pos[1], pos[k + 1]);\n                get();\n            }\n        } else {\n            for (int i = 0; i < k - 1; i++) {\n                reverse(pos[1] + 1, pos[k + 1] + 1);\n                get();\n                reverse(pos[1], pos[k + 1]);\n                get();\n            }\n        }\n        \n        return ans;\n    };\n    \n    auto ans1 = solve(a);\n    auto ans2 = solve(b);\n    \n    if (a != b) {\n        std::cout << \"-1\\n\";\n        return;\n    }\n    \n    std::reverse(ans2.begin(), ans2.end());\n    ans1.insert(ans1.end(), ans2.begin(), ans2.end());\n    \n    std::cout << ans1.size() << \"\\n\";\n    for (auto [x, y] : ans1) {\n        std::cout << x + 1 << \" \" << y << \"\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "3300", "interactive": false}