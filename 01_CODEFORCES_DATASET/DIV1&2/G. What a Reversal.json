{
    "link": "https://codeforces.com//contest/1530/problem/G",
    "problemId": "1049174",
    "problem_idx": "G",
    "shortId": "1530G",
    "contest_number": "1530",
    "problem_submissions": {
        "H": [
            122851665,
            122838743,
            122844195,
            122849012,
            122871696,
            122848567,
            122889728
        ],
        "G": [
            122840209,
            122852256,
            122900209,
            122846129,
            122844934,
            122847648,
            122853646,
            122874899,
            122880351,
            122921209
        ],
        "F": [
            122810446,
            122819713,
            122812617,
            122825773,
            122868869,
            122809297,
            122821188,
            122827035,
            122824965,
            122821818,
            122829815,
            122826847,
            122822005,
            122826789,
            122826175,
            122826918,
            122836373,
            122830797,
            122814894,
            122838442,
            122834199
        ],
        "E": [
            122803663,
            122805810,
            122805166,
            122812311,
            122817063,
            122814296,
            122807127,
            122808379,
            122800583,
            122808253,
            122808203,
            122811232,
            122807495,
            122807208,
            122811521,
            122828022,
            122805125,
            122810921
        ],
        "D": [
            122791676,
            122796247,
            122793005,
            122795921,
            122795213,
            122793368,
            122796651,
            122796980,
            122803859,
            122791210,
            122799331,
            122796501,
            122797048,
            122796533,
            122791355,
            122798720,
            122801973,
            122792843,
            122800740
        ],
        "C": [
            122785861,
            122787673,
            122786660,
            122785034,
            122784856,
            122787839,
            122786985,
            122784250,
            122795439,
            122782668,
            122786465,
            122789088,
            122786999,
            122788656,
            122784366,
            122787966,
            122789017,
            122785054,
            122790340
        ],
        "B": [
            122781549,
            122782427,
            122782526,
            122782097,
            122782078,
            122780831,
            122781690,
            122789087,
            122786285,
            122785455,
            122781801,
            122781479,
            122782615,
            122783296,
            122794583,
            122783767,
            122783971,
            122780469,
            122782275
        ],
        "A": [
            122775440,
            122775417,
            122775273,
            122775738,
            122775580,
            122775190,
            122775752,
            122790605,
            122781313,
            122775806,
            122775746,
            122775311,
            122776001,
            122775468,
            122776055,
            122775938,
            122777214,
            122775025,
            122775038
        ]
    },
    "name": "G. What a Reversal",
    "statement": "You have two strings a and b of equal length n consisting of characters\r\nand , and an integer k.You need to make strings a and b equal.In one\r\nstep, you can choose any substring of a containing exactly k characters\r\n(and arbitrary number of characters ) and reverse it. Formally, if a =\r\na_1 a_2\r\nldots a_n, you can choose any integers l and r (1\r\nle l\r\nle r\r\nle n) such that there are exactly k ones among characters a_l, a_{l+1},\r\nldots, a_r, and set a to a_1 a_2\r\nldots a_{l-1} a_r a_{r-1}\r\nldots a_l a_{r+1} a_{r+2}\r\nldots a_n.Find a way to make a equal to b using at most 4n reversals of\r\nthe above kind, or determine that such a way doesn’t exist. The number\r\nof reversals doesn’t have to be minimized.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    std::string a, b;\n    std::cin >> a >> b;\n    \n    if (a == b) {\n        std::cout << \"0\\n\";\n        return;\n    }\n    \n    int cnt = std::count(a.begin(), a.end(), '1');\n    if (std::count(b.begin(), b.end(), '1') != cnt) {\n        std::cout << \"-1\\n\";\n        return;\n    }\n    \n    if (k == 0 || k > cnt) {\n        std::cout << \"-1\\n\";\n        return;\n    }\n    \n    auto solve = [&](std::string &s) {\n        std::vector<std::pair<int, int>> ans;\n        \n        auto reverse = [&](int l, int r) {\n            ans.emplace_back(l, r);\n            std::reverse(s.begin() + l, s.begin() + r);\n        };\n        \n        std::vector<int> a, pos;\n        auto get = [&]() {\n            a.clear();\n            pos = {-1};\n            int lst = -1;\n            for (int i = 0; i < n; i++) {\n                if (s[i] == '1') {\n                    pos.push_back(i);\n                    a.push_back(i - lst - 1);\n                    lst = i;\n                }\n            }\n            a.push_back(n - lst - 1);\n            pos.push_back(n);\n        };\n        get();\n        \n        for (int i = cnt; i >= k; i--) {\n            if (a[i] > 0) {\n                reverse(pos[i - k + 1], pos[i + 1]);\n                get();\n                assert(a[i] == 0);\n            }\n        }\n        \n        if (k == cnt) {\n            auto b = a;\n            std::reverse(b.begin() + 1, b.end() - 1);\n            if (b < a) {\n                reverse(pos[1], pos[k] + 1);\n            }\n            return ans;\n        }\n        \n        if (k % 2 == 1) {\n            for (int i = 0; i < k - 1; i++) {\n                reverse(pos[2], pos[k + 1] + 1);\n                get();\n                reverse(pos[1], pos[k + 1]);\n                get();\n            }\n        } else {\n            for (int i = 0; i < k - 1; i++) {\n                reverse(pos[1] + 1, pos[k + 1] + 1);\n                get();\n                reverse(pos[1], pos[k + 1]);\n                get();\n            }\n        }\n        \n        return ans;\n    };\n    \n    auto ans1 = solve(a);\n    auto ans2 = solve(b);\n    \n    if (a != b) {\n        std::cout << \"-1\\n\";\n        return;\n    }\n    \n    std::reverse(ans2.begin(), ans2.end());\n    ans1.insert(ans1.end(), ans2.begin(), ans2.end());\n    \n    std::cout << ans1.size() << \"\\n\";\n    for (auto [x, y] : ans1) {\n        std::cout << x + 1 << \" \" << y << \"\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. What a Reversal.json",
    "editorial_link": "https://codeforces.com//blog/entry/92951",
    "editorial": "First of all, the number of âs in and must match. Let be the number of\r\nâs in .If or , we can not do a meaningful reversal, so we just check if\r\n.If , we can not change the contents of between the leftmost and the\r\nrightmost âs, we can only reverse it and shift with regard to the\r\noutside âs. Itâs easy to check whether can become equal to then, and at\r\nmost steps are required if so.Otherwise, suppose . Since our operations\r\nare reversible, weâll apply a usual trick: weâll transform both strings\r\ninto some canonical representations in at most steps each. If âs and âs\r\ncanonical representations donât match, weâll prove that there is no\r\nsolution. Otherwise, we can transform into in at most steps: transform\r\ninto the canonical representation, and then perform the steps\r\ntransforming into the canonical representation, but in reverse order.\r\nWhat representation is canonical is for us to determine later.Weâll\r\nfocus on one string now. Letâs write down the lengths of blocks of\r\nconsecutive âs in the string. Formally, let be the sequence consisting\r\nof the number of âs: before the first , between the first and the second\r\nâs, , after the last . Note that some might be equal to .What does a\r\nsingle reversal do to the sequence of blocks? consecutive blocks get\r\nreversed, and additionally, the âs in the leftmost and the rightmost\r\nblock of these blocks can be redistributed arbitrarily.It turns out that\r\nwe donât need more than blocks to achieve our goal (weâll see that\r\nlater), so letâs start with the following. Let be the rightmost block\r\nsuch that . If , stop. Otherwise, perform two reversals of blocks ,\r\nmoving all the âs from to in the process, effectively making zero, and\r\nrepeat. After this process, only can still be non-zero.Now, consider\r\nwhat happens if we reverse , and then reverse without changing any\r\nvalues: sequence will change to , that is, will cyclically shift by two\r\npositions to the right.Suppose we repeat this pair of reversals times.\r\nThe -th (-indexed) position initially contains , after the first pair it\r\nwill contain , then and so on. Assume that is odd. Then every block will\r\nreach the -th position at some point!Now, during the first reversal in\r\nthe pair, letâs move all âs from the -th block to the -th block, and\r\nkeep the second reversal in the pair as is, without changing the values.\r\nThen, after pairs of reversals, all the âs will move to the -th block,\r\nthat is, all will become zero.We can for sure call this representation\r\nwith all of zeroed out, and equal to the number of âs in the original\r\nstring canonical. It follows that if the number of âs in and is equal to\r\n, and is odd, a solution always exists.Letâs move on to the case when is\r\neven. In this case, since a pair of reversals makes a cyclic shift by ,\r\nonly even-numbered blocks will appear at the -th position. However,\r\nnotice that this is not a coincidence: when is even, whatever reversal\r\nwe perform, even-numbered blocks only interact with even-numbered\r\nblocks, and odd-numbered blocks interact with odd-numbered blocks. In\r\nparticular, the sum of can never change, and the sum of can never change\r\neither.Thus, when is even, letâs call the following representation\r\ncanonical: contains the sum of all initial values of ; contains the sum\r\nof all initial values of ; and all the other âs are zeros.We can reach\r\nthis representation in a similar way to the odd case, using pairs of\r\nreversals.Note that similar to the -th position which contains blocks\r\nduring the process, the -st position contains blocks during the\r\nprocess.During the first reversal in each pair, as in the previous case,\r\nweâll move all the âs from the -th block to the -th block. During the\r\nsecond reversal in each pair, weâll move all the âs from the -st block\r\nto the -th block. After pairs of reversals (actually just pairs are\r\nenough), weâll zero out all the values except for and .All in all, we\r\nhave found a way to reach the canonical representation in steps, as\r\ndesired.\r\n",
    "hint": []
}