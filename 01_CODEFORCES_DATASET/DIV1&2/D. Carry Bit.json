{
    "link": "https://codeforces.com//contest/1761/problem/D",
    "problemId": "1651704",
    "problem_idx": "D",
    "shortId": "1761D",
    "contest_number": "1761",
    "problem_submissions": {
        "F1": [
            181783681,
            181789408,
            181787826,
            181807817,
            181793725,
            181798874,
            181812117,
            181796851,
            181792193,
            181797286,
            181792466,
            181800291,
            181799120,
            181798951,
            181797538,
            181796549,
            181801616,
            181795934,
            181802212,
            181805577,
            181795481
        ],
        "E": [
            181767412,
            181775228,
            181773318,
            181773199,
            181776029,
            181768641,
            181774177,
            181773946,
            181778599,
            181783359,
            181770606,
            181780149,
            181779791,
            181784860,
            181784163,
            181786738,
            181799018,
            181784766,
            181805355,
            181777139
        ],
        "B": [
            181758217,
            181754631,
            181753022,
            181750562,
            181750818,
            181752710,
            181752904,
            181761535,
            181751867,
            181753244,
            181749713,
            181752562,
            181752197,
            181751335,
            181785787,
            181754006,
            181756438,
            181751473,
            181751400,
            181750387
        ],
        "C": [
            181757137,
            181757883,
            181756839,
            181754860,
            181753609,
            181755220,
            181756960,
            181758423,
            181755837,
            181756467,
            181755169,
            181757040,
            181757304,
            181769451,
            181757169,
            181757887,
            181761524,
            181755570,
            181754021,
            181753237
        ],
        "D": [
            181754215,
            181780914,
            181764059,
            181764559,
            181763628,
            181762248,
            181763698,
            181768454,
            181766485,
            181764872,
            181761188,
            181770079,
            181765691,
            181765764,
            181766812,
            181780108,
            181774890,
            181778415,
            181762397,
            181766534
        ],
        "A": [
            181747969,
            181747996,
            181753999,
            181748106,
            181748091,
            181748074,
            181748126,
            181748232,
            181748177,
            181750270,
            181748024,
            181748492,
            181748221,
            181748149,
            181749212,
            181750341,
            181748955,
            181748081,
            181748111,
            181748040
        ],
        "G": [
            181798925,
            181813421
        ],
        "F2": [
            181809122,
            181811738,
            181814199,
            181819747,
            181813452,
            181813278,
            181812897,
            181812682,
            181812626,
            181812463,
            181811716,
            181806789
        ]
    },
    "name": "D. Carry Bit",
    "statement": "Let f(x,y) be the number of of x+y in binary (i. e.\r\nf(x,y)=g(x)+g(y)-g(x+y), where g(x) is the number of ones in the binary\r\nrepresentation of x).Given two integers n and k, find the number of\r\nordered pairs (a,b) such that 0\r\nleq a,b < 2^n, and f(a,b) equals k. Note that for a\r\nne b, (a,b) and (b,a) are considered as two different pairs. As this\r\nnumber may be large, output it modulo 10^9+7.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 20.11.2022 18:39:36       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  Mint ans = 0;\n  for (int vf = 0; vf <= 1; vf++) {\n    for (int p = 1; p <= n; p++) {\n      int k0 = p / 2;\n      int k1 = p / 2;\n      if (p % 2 == 1) {\n        k0 += (vf == 0);\n        k1 += (vf == 1);\n      }\n      int vb = (p % 2 == 1 ? vf : 1 - vf);\n      if (k >= k1 && n - k >= k0) {\n        if (k > 0 && k1 == 0) {\n          continue;\n        }\n        if (n - k > 0 && k0 == 0) {\n          continue;\n        }\n        Mint ways = (k1 == 0 ? 1 : C((k - k1) + (k1 - 1), k1 - 1));\n        ways *= (k0 == 0 ? 1 : C((n - k - k0) + (k0 - 1), k0 - 1));\n        ways *= power(Mint(3), n - p + (vf == 0));\n        ans += ways;\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Carry Bit.json",
    "editorial_link": "https://codeforces.com//blog/entry/109256",
    "editorial": "Hint 1: Try to solve the problem in using DP.Hint 2: There is no need\r\nfor DP.Hint 3: You can consider enumerating the bits to carry, and then\r\ncounting.Let represents the -th bit of in binary representation (that\r\nis, ) and define similarly.If you decide which bits to carry ahead, you\r\nwill find that every bit of is independent (because whether the previous\r\nbit carries or not is decided), so you can use the multiplication\r\nprinciple to count. Therefore, in the remaining tutorial, we should\r\ndetermine the carries first and then count the number of options of\r\nmeeting the constraints of carries.Define array as our decided carry\r\nplan, indicates that the -th bit is carried, and define as .Notice that\r\n.Ponder each bit, we will notice that if , can be . , can be . and ,\r\nmust be . and , must be . That means that pair has options if , and pair\r\nhas options if .So if array has positions that ( , remember we define as\r\n), the count of pair is .Now we can enumerate , and count the number of\r\nhas positions that .The new problem equals a typical binomial\r\nproblem.Notice that for every , a valid should have segment of\r\nconsecutive s and segment of consecutive s if we seen as a normal bit\r\n(so that we have zeros).The number of solutions that divide elements\r\ninto segments is . Therefore the answer of each is , and we can\r\ncalculate it in .Add them all and you can find the answer in .\r\n"
}