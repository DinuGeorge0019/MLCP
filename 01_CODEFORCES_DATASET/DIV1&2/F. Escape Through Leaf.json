{"link": "https://codeforces.com//contest/932/problem/F", "problemId": "156999", "problem_idx": "F", "shortId": "932F", "contest_number": "932", "problem_submissions": {"G": [51774341, 35308371, 35309948, 35309510, 35328593, 35312755, 35340195, 35324025, 38386676, 35314606], "F": [35314668, 35310572, 35468380, 35310269, 35309416, 35312292, 35310748, 35546358, 35310551, 35314451, 35994490, 35310830, 35314597, 35313005, 35315153, 35311414, 35314861], "E": [35305602, 35300676, 35303983, 35302322, 35304627, 35307360, 35305500, 35300979, 35304741, 35308375, 35305972, 35304083, 35308467, 35308589, 35308504, 35313014, 35308160, 35300247], "D": [35304182, 35304652, 35301520, 35312731, 35302822, 35304942, 35303273, 35308561, 35309596, 35306303, 35302532, 35308788, 35304471, 35304933, 35304868, 35308529, 35306123, 35312012], "C": [35298412, 35298036, 35296739, 35298645, 35298179, 35298553, 35299152, 35297891, 35299526, 35299903, 35298326, 35305061, 35298463, 35300385, 35298472, 35299312, 35300289, 35313442], "B": [35297094, 35297006, 35297939, 35296994, 35296930, 35296422, 35297855, 35301880, 35297864, 35297983, 35297247, 35296879, 35297467, 35297739, 35296808, 35297547, 35298510, 35302031], "A": [35295015, 35294909, 35298217, 35294978, 35294827, 35294828, 35295219, 35296140, 35296578, 35294771, 35294859, 35294967, 35294941, 35294775, 35295820, 35295673, 35300844]}, "name": "F. Escape Through Leaf", "statement": "You are given a tree with nodes (numbered from to ) rooted at node .\r\nAlso, each node has two values associated with it. The values for -th\r\nnode are and .You can jump from a node to any node in its subtree. The\r\ncost of one jump from node to node is the product of and . The total\r\ncost of a path formed by one or more jumps is sum of costs of individual\r\njumps. For every node, calculate the minimum total cost to reach any\r\nleaf from that node. Pay attention, that root can never be leaf, even if\r\nit has degree .Note that you cannot jump from a node to itself.\r\n", "solutions": ["//while (clock()<=69*CLOCKS_PER_SEC)\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing zbio=ordered_set < pair <ll,ll> >;\nconst int nax=100*1007;\nusing mag=long double;\n\nint n;\n\nll a[nax];\nll b[nax];\n\nvector <int> graf[nax];\n\nzbio otocz[nax];\nzbio otoczmin[nax];\n\nll dp[nax];\n\nzbio::iterator it, jt, kt;\n\nmag ilowek(pair <ll,ll> s, pair <ll,ll> a, pair <ll,ll> b)\n{\n\ta.first-=s.first;\n\ta.second-=s.second;\n\tb.first-=s.first;\n\tb.second-=s.second;\n\treturn ((mag)a.first)*b.second-((mag)a.second)*b.first;\n}\n\nvoid dorzuc(zbio &v, pair <ll,ll> w)\n{\n\tit=v.lower_bound(w);\n\t//~ if (it!=v.end())\n\t\t//~ debug() << w << \" widzi \" << *it; \n\t//~ else\n\t\t//~ debug() << w << \" slepe \";\n\twhile(it!=v.end() && (*it).second>=w.second)\n\t{\n\t\tjt=it;\n\t\tit++;\n\t\tv.erase(jt);\n\t}\n\tif (it!=v.begin())\n\t{\n\t\tit--;\n\t\tif ((*it).second<=w.second)\n\t\t\treturn;\n\t}\n\tit=v.lower_bound(w);\n\tif (it!=v.end() && it!=v.begin())\n\t{\n\t\tjt=it;\n\t\tjt--;\n\t\tif (ilowek(*it, *jt, w)<=0)\n\t\t\treturn;\n\t}\n\tv.insert(w);\n\tjt=it;\n\tjt--;\n\twhile(it!=v.end())\n\t{\n\t\tkt=it;\n\t\tkt++;\n\t\tif (kt==v.end())\n\t\t\tbreak;\n\t\tif (ilowek(*kt, w, *it)<=0)\n\t\t{\n\t\t\tv.erase(it);\n\t\t\tit=kt;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (jt!=v.begin())\n\t{\n\t\tjt--;\n\t\twhile(jt!=v.begin())\n\t\t{\n\t\t\tkt=jt;\n\t\t\tkt--;\n\t\t\tif (ilowek(w, *kt, *jt)<=0)\n\t\t\t{\n\t\t\t\tv.erase(jt);\n\t\t\t\tjt=kt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//~ debug() << \"chuj \";\n\t//~ assert(0);\n}\n\nvoid dopisz(zbio &v, zbio &u)\n{\n\tif ((int)v.size()<(int)u.size())\n\t\tv.swap(u);\n\tfor (auto i : u)\n\t\tdorzuc(v, i);\n}\n\nvoid znajdzopt(int v)\n{\n\tint k=otocz[v].size();\n\tint tsa=0;\n\tint tsb=k-1;\n\tint ts1, ts2;\n\tpair <ll,ll> raz, dwa;\n\twhile(tsa<tsb)\n\t{\n\t\tts1=(tsa+tsb)/2;\n\t\tts2=ts1+1;\n\t\tit=otocz[v].find_by_order(ts1);\n\t\traz=*it;\n\t\tit++;\n\t\tdwa=*it;\n\t\tif (raz.first+raz.second*a[v]<dwa.first+dwa.second*a[v])\n\t\t\ttsb=ts1;\n\t\telse\n\t\t\ttsa=ts2;\n\t}\n\traz=*otocz[v].find_by_order(tsa);\n\tdp[v]=raz.first+raz.second*a[v];\n\t\n\t\n\tk=otoczmin[v].size();\n\ttsa=0;\n\ttsb=k-1;\n\tts1, ts2;\n\twhile(tsa<tsb)\n\t{\n\t\tts1=(tsa+tsb)/2;\n\t\tts2=ts1+1;\n\t\tit=otoczmin[v].find_by_order(ts1);\n\t\traz=*it;\n\t\tit++;\n\t\tdwa=*it;\n\t\tif (raz.first-raz.second*a[v]<dwa.first-dwa.second*a[v])\n\t\t\ttsb=ts1;\n\t\telse\n\t\t\ttsa=ts2;\n\t}\n\traz=*otoczmin[v].find_by_order(tsa);\n\tdp[v]=min(dp[v], raz.first-raz.second*a[v]);\n}\n\nvoid dfs(int v, int oj)\n{\n\tint lis=1;\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs(i, v);\n\t\tdopisz(otocz[v], otocz[i]);\n\t\tdopisz(otoczmin[v], otoczmin[i]);\n\t\tlis=0;\n\t}\n\t//~ debug() << v << \" widzi \" << otocz[v];\n\tif (!lis)\n\t\tznajdzopt(v);\n\t//~ debug() << v << \" to \" << dp[v];\n\tdorzuc(otocz[v], {dp[v], b[v]});\n\tdorzuc(otoczmin[v], {dp[v], -b[v]});\n\t//~ debug() << v << \" zostawia \" << otocz[v];\n}\n\nint main()\n{\n\t//~ debug() << ilowek({0, 0}, {0, 1}, {-1, 1});\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &b[i]);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tgraf[v].push_back(u);\n\t\tgraf[u].push_back(v);\n\t}\n\tdfs(1, 0);\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(\"%lld \", dp[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "geometry"], "dificulty": "2700", "interactive": false}