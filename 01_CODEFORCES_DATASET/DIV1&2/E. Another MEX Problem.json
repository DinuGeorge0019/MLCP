{
    "link": "https://codeforces.com//contest/1870/problem/E",
    "problemId": "2216418",
    "problem_idx": "E",
    "shortId": "1870E",
    "contest_number": "1870",
    "problem_submissions": {
        "G": [
            225207978,
            225118072,
            225116519,
            225114767,
            225113735,
            225113326,
            223895142,
            223905506,
            223908839,
            223914354,
            223924067,
            223915464,
            224102694,
            224102570,
            224101929,
            224101915,
            224101882,
            223930185,
            223922526,
            223898384,
            223902193
        ],
        "H": [
            223910262,
            223971766,
            225204927,
            223912817
        ],
        "F": [
            223881664,
            223880000,
            223885884,
            223900845,
            223885822,
            223925076,
            223908747,
            223887023,
            223881416,
            223893441,
            223967145,
            223892630,
            223898214,
            223897234,
            223895227,
            223893254,
            223897195,
            223887464,
            223885585,
            223897533
        ],
        "E": [
            223869750,
            223870667,
            223875420,
            223879930,
            223894576,
            223875622,
            223877104,
            223888049,
            223879090,
            223876643,
            223870896,
            223878535,
            223873841,
            223880057,
            223880667,
            223881985,
            223871304,
            223980583,
            223900716,
            223895756,
            223883035
        ],
        "D": [
            223864393,
            223860234,
            223865660,
            223863718,
            223865473,
            223859881,
            223865206,
            223867969,
            223868314,
            223865007,
            223866155,
            223863717,
            223863491,
            223869388,
            223869302,
            223866987,
            223863771,
            223868821,
            223873483,
            223869884
        ],
        "C": [
            223858926,
            223856692,
            223860376,
            223856772,
            223861967,
            223857013,
            223862311,
            223860027,
            223860530,
            223857444,
            223858871,
            223859210,
            223859070,
            223862641,
            223864669,
            223860558,
            223859030,
            223856443,
            223870325,
            223863825
        ],
        "B": [
            223855786,
            223853418,
            223854541,
            223852626,
            223857522,
            223852531,
            223856711,
            223853615,
            223855334,
            223852785,
            223853742,
            223853640,
            223854539,
            223856641,
            223856452,
            223856337,
            223854108,
            223864851,
            223860995,
            223858101
        ],
        "A": [
            223852532,
            223851971,
            223852416,
            223851983,
            223854260,
            223851952,
            223853042,
            223852087,
            223852502,
            223853463,
            223852096,
            223852189,
            223852238,
            223852875,
            223853328,
            223852660,
            223852270,
            223860422,
            223858579,
            223854841
        ]
    },
    "name": "E. Another MEX Problem",
    "statement": "You are given an array of integers a of size n. You can choose a set of\r\nnon-overlapping subarrays of the given array (note that some elements\r\nmay be not included in any subarray, this is allowed). For each selected\r\nsubarray, calculate the MEX of its elements, and then calculate the\r\nbitwise XOR of all the obtained MEX values. What is the maximum bitwise\r\nXOR that can be obtained?The MEX (minimum excluded) of an array is the\r\nsmallest non-negative integer that does not belong to the array. For\r\ninstance: The MEX of [2,2,1] is 0, because 0 does not belong to the\r\narray. The MEX of [3,1,0,1] is 2, because 0 and 1 belong to the array,\r\nbut 2 does not. The MEX of [0,3,1,2] is 4, because 0, 1, 2 and 3 belong\r\nto the array, but 4 does not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 5007, S = 8300, M = 8192;\nint n, k;\nbitset < S > dp[N];\nint mex[N][N];\nint cnt[N]; \nint a[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tL(l, 1, n) {\n\t\tL(i, 0, n) cnt[i] = 0;\n\t\tint ans = 0;\n\t\tL(r, l, n) {\n\t\t\tcnt[a[r]] += 1;\n\t\t\twhile(cnt[ans]) ++ans;\n\t\t\tmex[l][r] = ans;\n\t\t}\n\t}\n\t\n\tdp[0].set(0);\n\tL(i, 1, n) {\n\t\tdp[i] = dp[i - 1];\n\t\tL(j, 1, i) {\n\t\t\tif(i == j || (mex[j][i] != mex[j + 1][i] && mex[j][i] != mex[j][i - 1])) {\n\t\t\t\tL(k, 0, M - 1) \n\t\t\t\t\tif(dp[j - 1][k]) \n\t\t\t\t\t\tdp[i].set(k ^ mex[j][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tL(i, 0, M - 1) {\n\t\tif(dp[n][i]) {\n\t\t\tans = i;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\t\n\tL(i, 0, n) {\n\t\tdp[i].reset();\n\t}\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Another MEX Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/120524",
    "editorial": "TutorialLet\u00e2\u0080\u0099s solve the problem using dynamic programming, let\u00e2\u0080\u0099s store\r\nsuch that if it is possible to obtain an of values from the prefix up to\r\n(excluding ) equal to , and otherwise. Notice that the answer cannot be\r\ngreater than . Therefore, the size of this two-dimensional array is\r\n.Let\u00e2\u0080\u0099s learn how to solve this in :We iterate over from to , and inside\r\nthat, we iterate over from to , maintaining the value . Then, for all\r\nfrom to , we update if . This way, we update based on the case when the\r\nresulting set includes the set .We also need to update if , we assign .\r\nThis accounts for the case when we do not include in the answer.Let\u00e2\u0080\u0099s\r\ndefine , this will make the following text clearer.Let\u00e2\u0080\u0099s consider the\r\nsegment . Notice that if there exist and () such that or and , then we\r\ncan take the segment instead of the segment in the set of values, and\r\nthe answer will remain the same. If, however, there is no such segment\r\nfor the segment , then we call this segment irreplaceable.Now let\u00e2\u0080\u0099s\r\nprove that there are no more than irreplaceable segments. For each\r\nirreplaceable segment, let\u00e2\u0080\u0099s look at the larger element of the pair ,\r\nlet\u00e2\u0080\u0099s assume is larger (the other case is symmetric). Now, let\u00e2\u0080\u0099s prove\r\nthat there is at most one segment where is the left element and , by\r\ncontradiction:Suppose there are at least 2 such segments, let\u00e2\u0080\u0099s call\r\ntheir right boundaries (). Notice that , otherwise the segment would not\r\nbe irreplaceable (we could remove ). Since , then . It is obvious that\r\nappears among the elements , and therefore , which means that the\r\nsegment is not irreplaceable, contradiction.For each , there is at most\r\none irreplaceable segment where it is the smaller of the two extremes,\r\nand at most one where it is the larger. Therefore, the total number of\r\nirreplaceable segments is no more than .Let\u00e2\u0080\u0099s update the DP only through\r\nthe irreplaceable segments, then the solution works in time, where is\r\nthe number of irreplaceable segments. However, we have already proven\r\nthat , so the overall time complexity is .\r\n"
}