{
    "link": "https://codeforces.com//contest/1994/problem/F",
    "problemId": "2760786",
    "problem_idx": "F",
    "shortId": "1994F",
    "contest_number": "1994",
    "problem_submissions": {
        "H": [
            271268810,
            271261236,
            271268610,
            271257398,
            271256333,
            271267520,
            271313433,
            271274176,
            271248306,
            271287210,
            271283377,
            271283359,
            271282520
        ],
        "G": [
            271229872,
            271233816,
            271238208,
            271227356,
            271235437,
            271226550,
            271234367,
            271234742,
            271238779,
            271238270,
            271225091,
            271234935,
            271238841,
            271240257,
            271243721,
            271243649,
            271233908,
            271244521,
            271244063
        ],
        "F": [
            271214789,
            271228871,
            271233459,
            271220149,
            271228791,
            271236762,
            271228615,
            271226473,
            271231018,
            271229788,
            271213472,
            271228121,
            271232218,
            271232892,
            271232972,
            271231186,
            271267486,
            271243051,
            271234735,
            271231874
        ],
        "E": [
            271208462,
            271218792,
            271225076,
            271214384,
            271214472,
            271215377,
            271220481,
            271220501,
            271217729,
            271220075,
            271230923,
            271220200,
            271221333,
            271221570,
            271219993,
            271222653,
            271267440,
            271226341,
            271222083,
            271220365
        ],
        "D": [
            271202405,
            271212139,
            271218875,
            271208005,
            271207650,
            271208685,
            271211312,
            271203391,
            271211524,
            271212286,
            271234069,
            271211646,
            271213596,
            271214194,
            271209598,
            271213200,
            271211604,
            271209945,
            271214556
        ],
        "C": [
            271199233,
            271206203,
            271213680,
            271202592,
            271203860,
            271204743,
            271205070,
            271213462,
            271205158,
            271207577,
            271204749,
            271209599,
            271203078,
            271203590,
            271209662,
            271268293,
            271268187,
            271204900,
            271203748,
            271208451
        ],
        "B": [
            271196298,
            271197883,
            271199651,
            271199362,
            271196300,
            271198662,
            271198429,
            271197282,
            271197595,
            271196709,
            271198001,
            271201728,
            271198447,
            271198638,
            271200600,
            271198424,
            271197818,
            271196402
        ],
        "A": [
            271195365,
            271195316,
            271196075,
            271196307,
            271195291,
            271195470,
            271195498,
            271195546,
            271195401,
            271195293,
            271195685,
            271195898,
            271195396,
            271195975,
            271195344,
            271195348,
            271195380,
            271195303
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131666",
    "editorial": "The edges with on them will be called black, the other edges will be\r\ncalled white.To find such a route, we need the graph to be Eulerian\r\n(degree of each vertex is even). To achieve this, we can remove some\r\nblack edges.Let\u00e2\u0080\u0099s calculate the degree of each vertex (further we will\r\nkeep this degree in mind) and leave only black edges. Solve the problem\r\nindependently for each component. If a component has an odd number of\r\nvertices with odd degree, we cannot remove edges so that all degrees\r\nbecome even (since removing an edge does not change the parity of the\r\nsum of degrees), so in this case the answer is NO. Otherwise, such a\r\nroute exists. Leave only the spanning tree and run dfs on it. If we\r\nleave a vertex and it has an odd degree, we remove an edge to its\r\nancestor. This will work since the sum of the degrees in the component\r\nis even.Finally, we need to find the Eulerian cycle in the resulting\r\ngraph and print it.\r\n",
    "name": "F. Stardew Valley",
    "statement": "Pelican Town represents n houses connected by m bidirectional roads.\r\nSome roads have standing on them. Farmer Buba needs to walk on each road\r\nwith an NPC and talk to them.Help the farmer find a route satisfying the\r\nfollowing properties: The route starts at some house, follows the roads,\r\nand ends at the same house. The route does not follow any road more than\r\nonce (in both directions together). The route follows each road with an\r\nNPC exactly once. Note that the route can follow roads without NPCs, and\r\nyou do need to minimize the length of the route.It is that you can reach\r\nany house from any other by walking on the roads with NPCs only.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 18.07.2024 23:50:37**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };\u00a0  vector<edge> edges;  vector<vector<int>> g;  int n;\u00a0  graph(int _n) : n(_n) {    g.resize(n);  }\u00a0  virtual int add(int from, int to, T cost) = 0;};\u00a0template <typename T>class undigraph : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;\u00a0  undigraph(int _n) : graph<T>(_n) {  }\u00a0  int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }};\u00a0template <typename T>vector<int> find_eulerian_path(const graph<T> &g, int &root) {  vector<int> in_deg(g.n, 0);  vector<int> out_deg(g.n, 0);  int cnt_edges = 0;  for (int id = 0; id < (int) g.edges.size(); id++) {    cnt_edges++;    auto &e = g.edges[id];    out_deg[e.from]++;    in_deg[e.to]++;  }  root = -1;  int odd = 0;  for (int i = 0; i < g.n; i++) {    if ((in_deg[i] + out_deg[i]) % 2 == 1) {      odd++;      if (root == -1 || out_deg[i] - in_deg[i] > out_deg[root] - in_deg[root]) {        root = i;      }    }  }  if (odd > 2) {    root = -1;    return vector<int>();  }  if (root == -1) {    root = 0;    while (root < g.n && in_deg[root] + out_deg[root] == 0) {      root++;    }    if (root == g.n) {      // an empty path      root = 0;      return vector<int>();    }  }  vector<bool> used(g.edges.size(), false);  vector<int> ptr(g.n, 0);  vector<int> balance(g.n, 0);  vector<int> res(cnt_edges);  int stack_ptr = 0;  int write_ptr = cnt_edges;  int v = root;  while (true) {    bool found = false;    while (ptr[v] < (int) g.g[v].size()) {      int id = g.g[v][ptr[v]++];      if (used[id]) {        continue;      }      used[id] = true;      res[stack_ptr++] = id;      auto &e = g.edges[id];      balance[v]++;      v ^= e.from ^ e.to;      balance[v]--;      found = true;      break;    }    if (!found) {      if (stack_ptr == 0) {        break;      }      int id = res[--stack_ptr];      res[--write_ptr] = id;      auto &e = g.edges[id];      v ^= e.from ^ e.to;    }  }  int disbalance = 0;  for (int i = 0; i < g.n; i++) {    disbalance += abs(balance[i]);  }  if (write_ptr != 0 || disbalance > 2) {    root = -1;    return vector<int>();  }  return res;}\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, m;    cin >> n >> m;    vector<int> deg(n);    undigraph<int> g(n);    vector<vector<int>> f(n);    for (int i = 0; i < m; i++) {      int a, b, c;      cin >> a >> b >> c;      --a; --b;      if (c == 1) {        g.add(a, b);        deg[a] ^= 1;        deg[b] ^= 1;      } else {        f[a].push_back(b);        f[b].push_back(a);      }    }    vector<bool> was(n, false);    auto Dfs = [&](auto&& self, int v) -> int {      was[v] = true;      int sum = deg[v];      for (int u : f[v]) {        if (was[u]) {          continue;        }        auto got = self(self, u);        if (got == 1) {          sum ^= 1;          g.add(u, v);        }      }      return sum;    };    bool fail = false;    for (int i = 0; i < n; i++) {      if (!was[i]) {        int got = Dfs(Dfs, i);        if (got == 1) {          fail = true;          break;        }      }    }    if (fail) {      cout << \"NO\" << '\\n';    } else {      cout << \"YES\" << '\\n';      int root = -1;      auto p = find_eulerian_path(g, root);      assert(!p.empty());      cout << p.size() << '\\n';      int v = root;      cout << v + 1;      for (int eid : p) {        auto& e = g.edges[eid];        v ^= e.from ^ e.to;        cout << \" \" << v + 1;      }      cout << '\\n';    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Stardew Valley.json"
}