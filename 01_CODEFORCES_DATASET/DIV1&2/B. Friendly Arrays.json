{
    "link": "https://codeforces.com//contest/1870/problem/B",
    "problemId": "2216415",
    "problem_idx": "B",
    "shortId": "1870B",
    "contest_number": "1870",
    "problem_submissions": {
        "G": [
            225207978,
            225118072,
            225116519,
            225114767,
            225113735,
            225113326,
            223895142,
            223905506,
            223908839,
            223914354,
            223924067,
            223915464,
            224102694,
            224102570,
            224101929,
            224101915,
            224101882,
            223930185,
            223922526,
            223898384,
            223902193
        ],
        "H": [
            223910262,
            223971766,
            225204927,
            223912817
        ],
        "F": [
            223881664,
            223880000,
            223885884,
            223900845,
            223885822,
            223925076,
            223908747,
            223887023,
            223881416,
            223893441,
            223967145,
            223892630,
            223898214,
            223897234,
            223895227,
            223893254,
            223897195,
            223887464,
            223885585,
            223897533
        ],
        "E": [
            223869750,
            223870667,
            223875420,
            223879930,
            223894576,
            223875622,
            223877104,
            223888049,
            223879090,
            223876643,
            223870896,
            223878535,
            223873841,
            223880057,
            223880667,
            223881985,
            223871304,
            223980583,
            223900716,
            223895756,
            223883035
        ],
        "D": [
            223864393,
            223860234,
            223865660,
            223863718,
            223865473,
            223859881,
            223865206,
            223867969,
            223868314,
            223865007,
            223866155,
            223863717,
            223863491,
            223869388,
            223869302,
            223866987,
            223863771,
            223868821,
            223873483,
            223869884
        ],
        "C": [
            223858926,
            223856692,
            223860376,
            223856772,
            223861967,
            223857013,
            223862311,
            223860027,
            223860530,
            223857444,
            223858871,
            223859210,
            223859070,
            223862641,
            223864669,
            223860558,
            223859030,
            223856443,
            223870325,
            223863825
        ],
        "B": [
            223855786,
            223853418,
            223854541,
            223852626,
            223857522,
            223852531,
            223856711,
            223853615,
            223855334,
            223852785,
            223853742,
            223853640,
            223854539,
            223856641,
            223856452,
            223856337,
            223854108,
            223864851,
            223860995,
            223858101
        ],
        "A": [
            223852532,
            223851971,
            223852416,
            223851983,
            223854260,
            223851952,
            223853042,
            223852087,
            223852502,
            223853463,
            223852096,
            223852189,
            223852238,
            223852875,
            223853328,
            223852660,
            223852270,
            223860422,
            223858579,
            223854841
        ]
    },
    "name": "B. Friendly Arrays",
    "statement": "You are given two arrays of integers a_1,\r\nldots, a_n of length n, and b_1,\r\nldots, b_m of length m. You can choose any element b_j from array b (1\r\nleq j\r\nleq m), and for 1\r\nleq i\r\nleq n perform a_i = a_i | b_j. You can perform any number of such\r\noperations.After all the operations, the value of x = a_1\r\noplus a_2\r\noplus\r\nldots\r\noplus a_n will be calculated. Find the minimum and maximum values of x\r\nthat could be obtained after performing any set of operations.Above, |\r\nis the bitwise OR operation, and\r\noplus is the bitwise XOR operation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint a[N], b[N];\nint n, m;\nvoid Main() {\n\tcin >> m >> n;\n\tL(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tint op = 0;\n\tL(i, 1, m) {\n\t\top ^= b[i];\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tif(m & 1) {\n\t\tans1 = op;\n\t\tL(i, 1, n) {\n\t\t\top |= a[i];\n\t\t}\n\t\tans2 = op;\n\t} else {\n\t\tans2 = op;\n\t\tL(i, 1, n) {\n\t\t\top &= ~a[i];\n\t\t}\n\t\tans1 = op;\n\t}\n\tcout << ans1 << ' ' << ans2 << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Friendly Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/120524",
    "editorial": "TutorialNote that after performing the operation on , which has some bit\r\nset to 1, this bit will become 1 for all numbers in (and will remain so,\r\nas a bit cannot change from 1 to 0 in the result of an OR operation). If\r\nis even, then in the final XOR, this bit will become 0, as it will be\r\nequal to the XOR of an even number of ones. If is odd, then this bit\r\nwill be 1 in the final XOR.Therefore, if is even, by performing the\r\noperation on , we set all the bits that are 1 in to 0 in the final XOR.\r\nIf is odd, we do the opposite and set these bits to 1. So, if is even,\r\nthe XOR does not increase when applying the operation, which means that\r\nto obtain the minimum possible XOR, we need to apply the operation to\r\nall the numbers in , and the maximum XOR will be the original XOR. For\r\nodd , it is the opposite: the minimum is the original XOR, and the\r\nmaximum is obtained after applying the operation to all elements in .To\r\napply the operation to all elements in , it is sufficient to calculate\r\ntheir bitwise OR and apply the operation to the array with it.\r\n"
}