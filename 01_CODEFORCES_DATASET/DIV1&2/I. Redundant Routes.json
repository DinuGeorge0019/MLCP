{"link": "https://codeforces.com//contest/1863/problem/I", "problemId": "2186460", "problem_idx": "I", "shortId": "1863I", "contest_number": "1863", "problem_submissions": {"G": [221136551, 221139848, 221147121, 221150406, 221156272, 221151276, 221147870, 221157045, 221150654, 221158033, 221156995, 221150405, 221155989, 221155038, 221160627, 221149999, 221166719, 221155326, 221159641, 221165396], "F": [221121590, 221127771, 221128307, 221138108, 221130805, 221136021, 221136737, 221129060, 221140638, 221137056, 221128211, 221139417, 221137699, 221127026, 221139802, 221154849, 221135761, 221144061, 221150102, 221217304, 221142638], "E": [221110018, 221117203, 221116712, 221116632, 221114627, 221123945, 221125852, 221119344, 221123994, 221117191, 221120648, 221126771, 221126517, 221139461, 221119939, 221121938, 221123387, 221126376, 221121543, 221217383, 221127296], "D": [221102414, 221109581, 221105244, 221107918, 221106665, 221103992, 221113320, 221110649, 221111108, 221103919, 221112047, 221112174, 221110753, 221112715, 221104010, 221113678, 221110048, 221113375, 221110273, 221109100], "C": [221098267, 221102354, 221100311, 221098509, 221100896, 221098602, 221107809, 221105183, 221098239, 221098225, 221102929, 221105006, 221102283, 221103582, 221098969, 221099286, 221102760, 221106477, 221099714, 221101657], "A": [221096643, 221096074, 221096129, 221096043, 221095975, 221096016, 221096907, 221096642, 221101230, 221095943, 221096347, 221097350, 221096423, 221097791, 221095953, 221096058, 221096941, 221096889, 221096069, 221097073], "B": [221096498, 221097225, 221097260, 221096607, 221096286, 221096471, 221098534, 221098779, 221102915, 221096280, 221097328, 221098778, 221097955, 221099465, 221096389, 221096664, 221099499, 221099302, 221096756, 221098284], "I": [221276607, 221276430, 221275617, 221825420, 221197104], "H": [221188380, 221214363, 221182970, 221376731, 221376708, 221376397, 221187887]}, "name": "I. Redundant Routes", "statement": "You are given a tree with n vertices labeled 1, 2,\r\nldots, n. The length of a simple path in the tree is the number of\r\nvertices in it.You are to select a set of simple paths of length at\r\nleast 2 each, but you cannot simultaneously select two distinct paths\r\ncontained one in another. Find the largest possible size of such a\r\nset.Formally, a set S of vertices is called a if it contains and\r\ncoincides with the set of vertices of a simple path in the tree. A\r\ncollection of distinct routes is called a . A route S in a timetable T\r\nis called if there is a different route S\u2019\r\nin T such that S\r\nsubset S\u2019. A timetable is called if it contains no redundant routes.\r\nFind the largest possible number of routes in an efficient timetable.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nconst int nax=3007;\nconst int vax=nax*nax/2;\n\nint n;\n\nvi graf[nax];\n\nint k;\nint num[nax][nax];\n\nint ojf[vax];\nint roz[vax];\n\nint wstro[nax][nax];\n\nint korz;\n\nvi drz[vax];\n\nint fin(int v)\n{\n\tif (ojf[v]!=v)\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nvoid dfs1(int v, int c)\n{\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==wstro[c][v])\n\t\t\tcontinue;\n\t\twstro[c][i]=v;\n\t\tdfs1(i, c);\n\t}\n}\n\nint dfs2(int v)\n{\n\tint ret=0;\n\tfor (int i : drz[v])\n\t\tret+=dfs2(i);\n\treturn max(ret, roz[v]);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tk++;\n\t\t\tnum[i][j]=k;\n\t\t\tnum[j][i]=k;\n\t\t\tojf[k]=k;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tdfs1(i, i);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (wstro[i][j]!=i)\n\t\t\t\tuni(num[i][wstro[i][j]], num[j][wstro[j][i]]);\n\tfor (int i=1; i<=k; i++)\n\t\troz[fin(i)]++;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (wstro[i][j]==i)\n\t\t\t\tkorz=fin(num[i][j]);\n\tvector<pii> kra;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tif (wstro[i][j]==i)\n\t\t\t\tcontinue;\n\t\t\tint x=fin(num[i][j]);\n\t\t\tint y=fin(num[i][wstro[i][j]]);\n\t\t\tkra.push_back({y, x});\n\t\t}\n\t}\n\tsort(kra.begin(), kra.end());\n\tkra.resize(unique(kra.begin(), kra.end())-kra.begin());\n\tfor (pii i : kra)\n\t\tdrz[i.first].push_back(i.second);\n\tprintf(\"%d\\n\", dfs2(korz));\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "trees"], "dificulty": "3500", "interactive": false}