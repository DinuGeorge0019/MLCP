{
    "link": "https://codeforces.com//contest/1863/problem/I",
    "problemId": "2186460",
    "problem_idx": "I",
    "shortId": "1863I",
    "contest_number": "1863",
    "problem_submissions": {
        "G": [
            221136551,
            221139848,
            221147121,
            221150406,
            221156272,
            221151276,
            221147870,
            221157045,
            221150654,
            221158033,
            221156995,
            221150405,
            221155989,
            221155038,
            221160627,
            221149999,
            221166719,
            221155326,
            221159641,
            221165396
        ],
        "F": [
            221121590,
            221127771,
            221128307,
            221138108,
            221130805,
            221136021,
            221136737,
            221129060,
            221140638,
            221137056,
            221128211,
            221139417,
            221137699,
            221127026,
            221139802,
            221154849,
            221135761,
            221144061,
            221150102,
            221217304,
            221142638
        ],
        "E": [
            221110018,
            221117203,
            221116712,
            221116632,
            221114627,
            221123945,
            221125852,
            221119344,
            221123994,
            221117191,
            221120648,
            221126771,
            221126517,
            221139461,
            221119939,
            221121938,
            221123387,
            221126376,
            221121543,
            221217383,
            221127296
        ],
        "D": [
            221102414,
            221109581,
            221105244,
            221107918,
            221106665,
            221103992,
            221113320,
            221110649,
            221111108,
            221103919,
            221112047,
            221112174,
            221110753,
            221112715,
            221104010,
            221113678,
            221110048,
            221113375,
            221110273,
            221109100
        ],
        "C": [
            221098267,
            221102354,
            221100311,
            221098509,
            221100896,
            221098602,
            221107809,
            221105183,
            221098239,
            221098225,
            221102929,
            221105006,
            221102283,
            221103582,
            221098969,
            221099286,
            221102760,
            221106477,
            221099714,
            221101657
        ],
        "A": [
            221096643,
            221096074,
            221096129,
            221096043,
            221095975,
            221096016,
            221096907,
            221096642,
            221101230,
            221095943,
            221096347,
            221097350,
            221096423,
            221097791,
            221095953,
            221096058,
            221096941,
            221096889,
            221096069,
            221097073
        ],
        "B": [
            221096498,
            221097225,
            221097260,
            221096607,
            221096286,
            221096471,
            221098534,
            221098779,
            221102915,
            221096280,
            221097328,
            221098778,
            221097955,
            221099465,
            221096389,
            221096664,
            221099499,
            221099302,
            221096756,
            221098284
        ],
        "I": [
            221276607,
            221276430,
            221275617,
            221825420,
            221197104
        ],
        "H": [
            221188380,
            221214363,
            221182970,
            221376731,
            221376708,
            221376397,
            221187887
        ]
    },
    "name": "I. Redundant Routes",
    "statement": "You are given a tree with n vertices labeled 1, 2,\r\nldots, n. The length of a simple path in the tree is the number of\r\nvertices in it.You are to select a set of simple paths of length at\r\nleast 2 each, but you cannot simultaneously select two distinct paths\r\ncontained one in another. Find the largest possible size of such a\r\nset.Formally, a set S of vertices is called a if it contains and\r\ncoincides with the set of vertices of a simple path in the tree. A\r\ncollection of distinct routes is called a . A route S in a timetable T\r\nis called if there is a different route S’\r\nin T such that S\r\nsubset S’. A timetable is called if it contains no redundant routes.\r\nFind the largest possible number of routes in an efficient timetable.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nconst int nax=3007;\nconst int vax=nax*nax/2;\n\nint n;\n\nvi graf[nax];\n\nint k;\nint num[nax][nax];\n\nint ojf[vax];\nint roz[vax];\n\nint wstro[nax][nax];\n\nint korz;\n\nvi drz[vax];\n\nint fin(int v)\n{\n\tif (ojf[v]!=v)\n\t\tojf[v]=fin(ojf[v]);\n\treturn ojf[v];\n}\n\nvoid uni(int a, int b)\n{\n\tojf[fin(a)]=fin(b);\n}\n\nvoid dfs1(int v, int c)\n{\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==wstro[c][v])\n\t\t\tcontinue;\n\t\twstro[c][i]=v;\n\t\tdfs1(i, c);\n\t}\n}\n\nint dfs2(int v)\n{\n\tint ret=0;\n\tfor (int i : drz[v])\n\t\tret+=dfs2(i);\n\treturn max(ret, roz[v]);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tk++;\n\t\t\tnum[i][j]=k;\n\t\t\tnum[j][i]=k;\n\t\t\tojf[k]=k;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tdfs1(i, i);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (wstro[i][j]!=i)\n\t\t\t\tuni(num[i][wstro[i][j]], num[j][wstro[j][i]]);\n\tfor (int i=1; i<=k; i++)\n\t\troz[fin(i)]++;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (wstro[i][j]==i)\n\t\t\t\tkorz=fin(num[i][j]);\n\tvector<pii> kra;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tif (wstro[i][j]==i)\n\t\t\t\tcontinue;\n\t\t\tint x=fin(num[i][j]);\n\t\t\tint y=fin(num[i][wstro[i][j]]);\n\t\t\tkra.push_back({y, x});\n\t\t}\n\t}\n\tsort(kra.begin(), kra.end());\n\tkra.resize(unique(kra.begin(), kra.end())-kra.begin());\n\tfor (pii i : kra)\n\t\tdrz[i.first].push_back(i.second);\n\tprintf(\"%d\\n\", dfs2(korz));\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Redundant Routes.json",
    "editorial_link": "https://codeforces.com//blog/entry/119902",
    "editorial": "Letâs call two paths adjacent if one can be obtained from the other by\r\nadding an edge to one end and removing an edge from the other end. There\r\nexists an optimal solution in which each pair of adjacent paths is\r\neither simultaneously chosen or simultaneously not chosen. Consider an\r\noptimal solution that maximizes the total length of paths in it. Letâs\r\nassume that in such a solution, we have taken some path , but its\r\nadjacent path is not included (here, assume and ). Why canât we add ? If\r\ncontains a shorter path, it must end at (since all other paths are also\r\ncontained in ). In that case, we can extend the shorter path to , which\r\ncontradicts the maximization of the sum of lengths. If is contained\r\nwithin a longer path, it must start at (since all other paths are also\r\ncontained in ). In this case, we can extend . We will refer to classes\r\nof adjacent paths as simply classes. Each class will either be taken in\r\nits entirety or not taken at all, and according to the proposition\r\nabove, an optimal solution can always be found.In the rooted tree, weâll\r\ncall a class if it contains at least one vertical path. To reduce the\r\nnumber of vertical classes, weâll root the tree by the midpoint of its\r\ndiameter (if the diameter is of odd length, consider the root as an\r\nedge). Now, all vertical paths of the same length are equivalent (since\r\na vertical path can always be moved to another subtree of the root).\r\nThus, for each length, there is at most one vertical class.How do we\r\ndetermine if a path belongs to some vertical class? Weâll attempt to\r\ngreedily pull the path: first lower one end of the path to the deepest\r\navailable vertex, then the other end, and so on. In the end, either the\r\npath becomes vertical or we encounter an obstacle of the following form:\r\nthe endpoints are in non-intersecting subtrees of the same depth , whose\r\nroots are at distance apart, and the path length is . Moreover, any such\r\npair of subtrees describes a non-vertical class of paths, and no other\r\nclasses exist, as paths from a non-vertical class must hit such an\r\nobstacle. A class doesnât necessarily consist of all paths between\r\nsubtrees of length . This is because an obstacle might exist lower down\r\nfor some of these paths. Nonetheless, at least one representative for\r\nany pair of subtrees will definitely exist (for instance, the root of\r\none subtree and the deepest leaf of the other).Letâs define non-vertical\r\nclasses with a pair of root vertices of subtrees (with the convention ),\r\nand define the class length as . Weâll introduce a forest structure on\r\nnon-vertical classes: a pair is an ancestor of if is an ancestor of and\r\nis an ancestor of . All classes, together with this forest, can be\r\nconstructed using DFS in time, simultaneously traversing and . Moreover,\r\nwe can quickly compute the size of each such class. Let denote the\r\nnumber of paths of length between subtrees and . Then, the size of class\r\nis , where the summation is over all classes that are proper descendants\r\nof such that . Thus, we need to compute all . If we compute this for\r\neach class in time, the total time will be (exercise for the\r\nreader).Which non-vertical classes canât be taken simultaneously? If\r\nbetween classes and neither is an ancestor of the other, then nested\r\npaths canât exist in them (due to the construction of the forest,\r\nthereâs a branching somewhere thatâs common to all paths). Let class be\r\nan ancestor of class . Then, a pair of nested paths between them can\r\nexist if and only if for all classes on the path between and (including\r\nbut excluding ), . Paths within cannot come out of subtrees . If , then\r\na path of length containing something from must also go between subtrees\r\n, but it canât extend beyond subtrees (since shorter paths from canât).\r\nThus, it canât belong to . Otherwise, if we attempt to pull a path of\r\nlength nested within upwards until encountering an obstacle at , this\r\ncan only happen if is the first significant obstacle.How do we include\r\nvertical classes? Clearly, we can take at most one vertical class. Using\r\nsimilar reasoning as above, if is a non-vertical class and is the length\r\nof a vertical class, then can be taken with a vertical class if there\r\nare no classes among the ancestors of (including ) with . Constructing a\r\nbamboo structure out of all vertical classes (shorter classes on top)\r\nand attaching the roots from the forest of non-vertical classes at the\r\nbottom of this bamboo, the criterion remains the same as in the\r\nproposition. Now we can forget about the original problem and solve a\r\nnew one: given a rooted tree, with numbers and assigned to each vertex,\r\nwe need to select a set of vertices to maximize the sum of , while\r\nsatisfying the criterion.Consider the vertex with the minimum among all\r\nvertices (considering the deepest among such vertices, if there are\r\nseveral options). Itâs easy to see that: Vertices outside the subtree\r\nrooted at cannot prevent us from choosing vertices within the subtree\r\nrooted at . If we choose , we canât choose anything else in its subtree.\r\nDivide the set of all vertices into and , where is the subtree rooted at\r\n, and solve the problem independently for them. The final answer will be\r\n.This process can be conveniently done in reverse, for instance, using\r\nDSU. Itâs also possible to carefully determine, during the forest\r\nconstruction, which components will merge, and solve the problem in time\r\nusing just bucket sort without any additional data structures or\r\nsorting.\r\n",
    "hint": []
}