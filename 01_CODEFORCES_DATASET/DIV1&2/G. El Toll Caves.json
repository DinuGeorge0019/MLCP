{"link": "https://codeforces.com//contest/868/problem/G", "problemId": "126222", "problem_idx": "G", "shortId": "868G", "contest_number": "868", "problem_submissions": {"E": [31023051, 31024523, 31024148, 31025167, 31018209, 31025864, 31026369, 31028260, 31026372, 31044397, 31026066, 31027557, 31023308, 31023861, 31019541, 31162068, 31021787], "F": [31020755, 31020638, 33743391, 31021116, 31022470, 31023238, 31022737, 31023926, 31023102, 31028638, 31028134, 31020706, 31027648, 31019840, 31023078, 31023660, 31027919], "D": [31018151, 31017707, 31016713, 31018303, 31025757, 31018243, 31018489, 31024010, 31018691, 31020147, 31017621, 31017612, 31016732, 31017515, 31015826, 31017997, 31021417], "C": [31014273, 31014407, 31012209, 31014307, 31013815, 31013945, 31015314, 31013335, 31014790, 31016275, 31030598, 31013440, 31030706, 31066551, 31014026, 31012823, 31014457, 31014258, 31016540], "B": [31013104, 31012812, 31013438, 31013042, 31012539, 31026919, 31016195, 31015461, 31013166, 31014218, 31022627, 31012140, 31012861, 31016249, 31011794, 31012575, 31013032, 31014544], "A": [31010698, 31010763, 31010903, 31010896, 31010747, 31010833, 31010957, 31012028, 31010858, 31021512, 31010696, 31010727, 31012054, 31010635, 31010757, 31011798, 31010661], "G": [31179602]}, "name": "G. El Toll Caves", "statement": "The prehistoric caves of El Toll are located in Moi (Barcelona). You\r\nhave heard that there is a treasure hidden in one of possible spots in\r\nthe caves. You assume that each of the spots has probability to contain\r\na treasure.You cannot get into the caves yourself, so you have\r\nconstructed a robot that can search the caves for treasure. Each day you\r\ncan instruct the robot to visit exactly distinct spots in the caves. If\r\nnone of these spots contain treasure, then the robot will obviously\r\nreturn with empty hands. However, the caves are dark, and the robot may\r\nmiss the treasure even when visiting the right spot. Formally, if one of\r\nthe visited spots does contain a treasure, the robot will obtain it with\r\nprobability , otherwise it will return empty. Each time the robot\r\nsearches the spot with the treasure, his success probability is\r\nindependent of all previous tries (that is, the probability to miss the\r\ntreasure after searching the right spot times is ).What is the expected\r\nnumber of days it will take to obtain the treasure if you choose optimal\r\nscheduling for the robot? Output the answer as a rational number modulo\r\n. Formally, let the answer be an irreducible fraction , then you have to\r\noutput . It is guaranteed that is not divisible by .\r\n", "solutions": ["#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int mod = 1e9 + 7;\n\ninline int Qow(int x, int y)\n{\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % mod)\n\t\tif (y & 1)\n\t\t\tr = 1LL * r * x % mod;\n\treturn r;\n}\n\ninline int F(int a, int q)\n{\n\tif (q <= 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn q;\n\treturn 1LL * (Qow(a, q) - 1) * Qow(a - 1, mod - 2) % mod;\n}\n\ninline int G(int a, int q)\n{\n\tif (q <= 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn (1LL * q * (q + 1) >> 1) % mod;\n\tint v = Qow(a - 1, mod - 2);\n\treturn 1LL * (1LL * (Qow(a, q) - 1) * a % mod * v % mod + mod - q) * v % mod;\n}\n\ninline int Solve(int n, int k, int A_1, int A_0, int B_1, int B_0, int S1_1, int S2_1, int S_0)\n{\n\tif (n == 1)\n\t\treturn (1LL * S1_1 * B_0 % mod * Qow(mod + 1 - B_1, mod - 2) + S_0) % mod;\n\t\n\tint q = (n - 1) / k, r = n - q * k, A__1, A__0, B__1, B__0, S1__1, S2__1, S__0, x, y;\n\t\n\tx = 1LL * B_1 * Qow(A_1, q - 1) % mod, y = (1LL * A_0 * B_1 % mod * F(A_1, q - 1) % mod + B_0) % mod;\n\tA__1 = Qow(x, mod - 2), A__0 = (mod - 1LL * y * A__1 % mod) % mod;\n\t\n\tx = 1LL * B_1 * Qow(A_1, q) % mod, y = (1LL * A_0 * B_1 % mod * F(A_1, q) % mod + B_0) % mod;\n\tB__1 = Qow(x, mod - 2), B__0 = (mod - 1LL * y * B__1 % mod) % mod;\n\n\tS1__1 = (1LL * S2_1 * A_1 % mod * F(A_1, q) + S1_1) % mod;\n\tS2__1 = (1LL * S2_1 * A_1 % mod * F(A_1, q - 1) + S1_1) % mod;\n\n\tS__0 = (1LL * S2_1 * A_0 % mod * (1LL * r * F(A_1, q) % mod + 1LL * k * G(A_1, q - 1) % mod) + S_0) % mod;\n\t\n\treturn Solve(k, r, A__1, A__0, B__1, B__0, S1__1, S2__1, S__0);\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tfor (int T = Read(); T; T --)\n\t{\n\t\tint n = Read(), k = Read(), d = __gcd(n, k);\n\t\tn /= d, k /= d;\n\t\tprintf(\"%d\\n\", 1LL * Solve(n, k, 1, 1, mod + 1 >> 1, 1, 1, 1, 0) * Qow(n, mod - 2) % mod);\n\t}\n}\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "3300", "interactive": false}