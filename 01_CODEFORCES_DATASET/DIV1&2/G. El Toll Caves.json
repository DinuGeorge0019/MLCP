{
    "link": "https://codeforces.com//contest/868/problem/G",
    "problemId": "126222",
    "problem_idx": "G",
    "shortId": "868G",
    "contest_number": "868",
    "problem_submissions": {
        "E": [
            31023051,
            31024523,
            31024148,
            31025167,
            31018209,
            31025864,
            31026369,
            31028260,
            31026372,
            31044397,
            31026066,
            31027557,
            31023308,
            31023861,
            31019541,
            31162068,
            31021787
        ],
        "F": [
            31020755,
            31020638,
            33743391,
            31021116,
            31022470,
            31023238,
            31022737,
            31023926,
            31023102,
            31028638,
            31028134,
            31020706,
            31027648,
            31019840,
            31023078,
            31023660,
            31027919
        ],
        "D": [
            31018151,
            31017707,
            31016713,
            31018303,
            31025757,
            31018243,
            31018489,
            31024010,
            31018691,
            31020147,
            31017621,
            31017612,
            31016732,
            31017515,
            31015826,
            31017997,
            31021417
        ],
        "C": [
            31014273,
            31014407,
            31012209,
            31014307,
            31013815,
            31013945,
            31015314,
            31013335,
            31014790,
            31016275,
            31030598,
            31013440,
            31030706,
            31066551,
            31014026,
            31012823,
            31014457,
            31014258,
            31016540
        ],
        "B": [
            31013104,
            31012812,
            31013438,
            31013042,
            31012539,
            31026919,
            31016195,
            31015461,
            31013166,
            31014218,
            31022627,
            31012140,
            31012861,
            31016249,
            31011794,
            31012575,
            31013032,
            31014544
        ],
        "A": [
            31010698,
            31010763,
            31010903,
            31010896,
            31010747,
            31010833,
            31010957,
            31012028,
            31010858,
            31021512,
            31010696,
            31010727,
            31012054,
            31010635,
            31010757,
            31011798,
            31010661
        ],
        "G": [
            31179602
        ]
    },
    "name": "G. El Toll Caves",
    "statement": "The prehistoric caves of El Toll are located in Moi (Barcelona). You\r\nhave heard that there is a treasure hidden in one of possible spots in\r\nthe caves. You assume that each of the spots has probability to contain\r\na treasure.You cannot get into the caves yourself, so you have\r\nconstructed a robot that can search the caves for treasure. Each day you\r\ncan instruct the robot to visit exactly distinct spots in the caves. If\r\nnone of these spots contain treasure, then the robot will obviously\r\nreturn with empty hands. However, the caves are dark, and the robot may\r\nmiss the treasure even when visiting the right spot. Formally, if one of\r\nthe visited spots does contain a treasure, the robot will obtain it with\r\nprobability , otherwise it will return empty. Each time the robot\r\nsearches the spot with the treasure, his success probability is\r\nindependent of all previous tries (that is, the probability to miss the\r\ntreasure after searching the right spot times is ).What is the expected\r\nnumber of days it will take to obtain the treasure if you choose optimal\r\nscheduling for the robot? Output the answer as a rational number modulo\r\n. Formally, let the answer be an irreducible fraction , then you have to\r\noutput . It is guaranteed that is not divisible by .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int mod = 1e9 + 7;\n\ninline int Qow(int x, int y)\n{\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % mod)\n\t\tif (y & 1)\n\t\t\tr = 1LL * r * x % mod;\n\treturn r;\n}\n\ninline int F(int a, int q)\n{\n\tif (q <= 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn q;\n\treturn 1LL * (Qow(a, q) - 1) * Qow(a - 1, mod - 2) % mod;\n}\n\ninline int G(int a, int q)\n{\n\tif (q <= 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn (1LL * q * (q + 1) >> 1) % mod;\n\tint v = Qow(a - 1, mod - 2);\n\treturn 1LL * (1LL * (Qow(a, q) - 1) * a % mod * v % mod + mod - q) * v % mod;\n}\n\ninline int Solve(int n, int k, int A_1, int A_0, int B_1, int B_0, int S1_1, int S2_1, int S_0)\n{\n\tif (n == 1)\n\t\treturn (1LL * S1_1 * B_0 % mod * Qow(mod + 1 - B_1, mod - 2) + S_0) % mod;\n\t\n\tint q = (n - 1) / k, r = n - q * k, A__1, A__0, B__1, B__0, S1__1, S2__1, S__0, x, y;\n\t\n\tx = 1LL * B_1 * Qow(A_1, q - 1) % mod, y = (1LL * A_0 * B_1 % mod * F(A_1, q - 1) % mod + B_0) % mod;\n\tA__1 = Qow(x, mod - 2), A__0 = (mod - 1LL * y * A__1 % mod) % mod;\n\t\n\tx = 1LL * B_1 * Qow(A_1, q) % mod, y = (1LL * A_0 * B_1 % mod * F(A_1, q) % mod + B_0) % mod;\n\tB__1 = Qow(x, mod - 2), B__0 = (mod - 1LL * y * B__1 % mod) % mod;\n\n\tS1__1 = (1LL * S2_1 * A_1 % mod * F(A_1, q) + S1_1) % mod;\n\tS2__1 = (1LL * S2_1 * A_1 % mod * F(A_1, q - 1) + S1_1) % mod;\n\n\tS__0 = (1LL * S2_1 * A_0 % mod * (1LL * r * F(A_1, q) % mod + 1LL * k * G(A_1, q - 1) % mod) + S_0) % mod;\n\t\n\treturn Solve(k, r, A__1, A__0, B__1, B__0, S1__1, S2__1, S__0);\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tfor (int T = Read(); T; T --)\n\t{\n\t\tint n = Read(), k = Read(), d = __gcd(n, k);\n\t\tn /= d, k /= d;\n\t\tprintf(\"%d\\n\", 1LL * Solve(n, k, 1, 1, mod + 1 >> 1, 1, 1, 1, 0) * Qow(n, mod - 2) % mod);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. El Toll Caves.json",
    "editorial_link": "https://codeforces.com/blog/entry/55046",
    "editorial": "Let be the number of times we have checked spot after days. Assuming\r\nthat the spot contains the treasure, we can see that the expected number\r\nof days to find the treasure is . Hence the unconditional expectation of\r\nthe answer is . This formula implies that the optimal strategy is to\r\nkeep the visiting frequencies for all spots as close as possible, since\r\nthe sum is minimized under when is the smoothest partition of . One\r\nimplementation of this strategy is to visit spots on day . Note further\r\nthat this strategy always visits spots in batches of size , hence we can\r\ndivide both and by their GCD.Let us now consider an example of , . Let\r\nbe the expected number of days to find the treasure in spot according to\r\nthe optimal strategy above. We can see that , , , , because a cell is\r\nvisited on day iff the cell was visited on day . We also have for the\r\nsame reason except for that the cell was visited on the first day. This\r\nargument allows to express, say, as a linear expression of itself, and\r\nfind the answer in time. Another approach is to substitute the\r\nexpressions until we cross the end of the sequence once: , also , but .\r\nWe have obtained a similar set of linear relations of three spots with\r\ndifference 2. To reduce to , let us group by : , , . We can see that the\r\ntotal contribution of all for is a linear function in , with\r\ncoefficients depending on whether . The main idea is that we continue\r\nthis process with a different set of linear equations, effectively\r\nobtaining Euclidâs algorithm that stores some additional data.Let us now\r\ndescribe the general solution. Assume that we have a set of variables\r\nsatisfying for , and for . Assume further that the answer . Let . For ,\r\nby applying relations and successively we obtain , hence for .\r\nSimilarly, for . Also, , where , . It follows that the transformation ,\r\n, , , , produces the same answer .In the end of this process we have , ,\r\nhence we have a linear equation . After finding , the answer is . The\r\nnumber of reductions of the above type is , with each transformation\r\npossible to do in time, ( and require fast matrix exponentation). The\r\ntotal number of operations is per test.\r\n",
    "hint": []
}