{
    "link": "https://codeforces.com//contest/1975/problem/D",
    "problemId": "2665475",
    "problem_idx": "D",
    "shortId": "1975D",
    "contest_number": "1975",
    "problem_submissions": {
        "H": [
            262631844,
            262612241,
            262600659,
            262612635,
            263096548
        ],
        "G": [
            262620370,
            262584629,
            262630306,
            262578664,
            262622745,
            262588918,
            262593694,
            262594206,
            262595918,
            262599422,
            262708940,
            262706456,
            262598241,
            262653444,
            262620831,
            262602673,
            262607334,
            262630272,
            262607273,
            262706071,
            262602704,
            262606536,
            262606903,
            262607812,
            263091775,
            263089587,
            263088604,
            263088409,
            263086834,
            263086045,
            262606154,
            264861303,
            262776553,
            262774627,
            262774590,
            262661298,
            262661024,
            262660704,
            262660316,
            262660273,
            262649420,
            262647737,
            262637294,
            262637274,
            262636778,
            262636749,
            262636610,
            262628729,
            262609429
        ],
        "E": [
            262558741,
            262555523,
            262542791,
            262569978,
            262560342,
            262572286,
            262561563,
            262558869,
            262555295,
            262569100,
            262560726,
            262553867,
            262556464,
            262558648,
            262561133,
            262565554,
            262576529,
            262575502,
            262635435,
            262635401,
            262635086,
            262635019,
            262630627,
            262630590,
            262570080
        ],
        "F": [
            262544594,
            262562050,
            262557811,
            262552279,
            262571108,
            262585701,
            262572669,
            262581085,
            262582375,
            262578636,
            262570215,
            262564737,
            262572783,
            262580057,
            262586122,
            262583527,
            262590488,
            262590492,
            262629974,
            262593633
        ],
        "D": [
            262526751,
            262533906,
            262549799,
            262548001,
            262535765,
            262555432,
            262532809,
            262542647,
            262536556,
            262547635,
            262538823,
            262574019,
            262544846,
            262547400,
            262544181,
            262539052,
            262538393,
            262538893,
            262629935,
            262543856
        ],
        "A": [
            262522755,
            262521103,
            262521181,
            262521345,
            262530553,
            262521158,
            262521224,
            262521209,
            262523388,
            262521604,
            262521957,
            262521117,
            262521171,
            262521739,
            262524060,
            262521821,
            262521219,
            262521958
        ],
        "C": [
            262522159,
            262524942,
            262525029,
            262526905,
            262542130,
            262526806,
            262529464,
            262528086,
            262531414,
            262526373,
            262530226,
            262525393,
            262531728,
            262530061,
            262528640,
            262528306,
            262542306,
            262526711
        ],
        "B": [
            262521205,
            262521505,
            262522451,
            262522658,
            262534024,
            262523709,
            262523854,
            262522613,
            262526293,
            262523579,
            262524186,
            262521924,
            262522192,
            262523093,
            262522741,
            262523954,
            262521898,
            262521340
        ],
        "I": []
    },
    "editorial_link": "https://codeforces.com//blog/entry/129801",
    "editorial": "SolutionRead the hints.In subsequent movements after the first time a\r\nvertex is painted blue, we can ignore the process of painting vertices\r\nred and then painting them blue.We call the first vertex painted blue .\r\nThen it is not difficult to find that arrived at this vertex earlier\r\nthan . Considering all subsequent movements of , can restore these\r\nmovements one by one after reaching , then will pass through all\r\nvertices have been painted red.If we know which vertex is , this will be\r\na classic problem, assuming the distance between the farthest vertex on\r\nthe tree from and is , then the answer is . Then we consider the\r\nstrategies of and at this time. The two must be close to each other, and\r\nthen until the first vertex is painted blue. If another vertex is ,\r\nalthough the value of may increase, every time the value of increases by\r\n, the time when and meet will also increase by at least , so the answer\r\nwill not decrease.\r\n",
    "name": "D. Paint the Tree",
    "statement": "378QAQ has a tree with n vertices. Initially, all vertices are white.\r\nThere are two chess pieces called P_A and P_B on the tree. P_A and P_B\r\nare initially located on vertices a and b respectively. In one step,\r\n378QAQ will do the following in order: Move P_A to a neighboring vertex.\r\nIf the target vertex is white, this vertex will be painted red. Move P_B\r\nto a neighboring vertex. If the target vertex is colored in red, this\r\nvertex will be painted blue. Initially, the vertex a is painted red. If\r\na=b, the vertex a is painted blue instead. Note that both the chess\r\npieces be moved in each step. Two pieces can be on the same vertex at\r\nany given time.378QAQ wants to know the minimum number of steps to paint\r\nall vertices blue.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 25.05.2024 10:41:49**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0template <typename T>class graph { public:  struct edge {    int from;    int to;    T cost;  };\u00a0  vector<edge> edges;  vector<vector<int>> g;  int n;\u00a0  graph(int _n) : n(_n) {    g.resize(n);  }\u00a0  virtual int add(int from, int to, T cost) = 0;};\u00a0template <typename T>class forest : public graph<T> { public:  using graph<T>::edges;  using graph<T>::g;  using graph<T>::n;\u00a0  forest(int _n) : graph<T>(_n) {  }\u00a0  int add(int from, int to, T cost = 1) {    assert(0 <= from && from < n && 0 <= to && to < n);    int id = (int) edges.size();    assert(id < n - 1);    g[from].push_back(id);    g[to].push_back(id);    edges.push_back({from, to, cost});    return id;  }};\u00a0template <typename T>class dfs_forest : public forest<T> { public:  using forest<T>::edges;  using forest<T>::g;  using forest<T>::n;\u00a0  vector<int> pv;  vector<int> pe;  vector<int> order;  vector<int> pos;  vector<int> end;  vector<int> sz;  vector<int> root;  vector<int> depth;  vector<T> dist;\u00a0  dfs_forest(int _n) : forest<T>(_n) {  }\u00a0  void init() {    pv = vector<int>(n, -1);    pe = vector<int>(n, -1);    order.clear();    pos = vector<int>(n, -1);    end = vector<int>(n, -1);    sz = vector<int>(n, 0);    root = vector<int>(n, -1);    depth = vector<int>(n, -1);    dist = vector<T>(n);  }\u00a0  void clear() {    pv.clear();    pe.clear();    order.clear();    pos.clear();    end.clear();    sz.clear();    root.clear();    depth.clear();    dist.clear();  }\u00a0 private:  void do_dfs(int v) {    pos[v] = (int) order.size();    order.push_back(v);    sz[v] = 1;    for (int id : g[v]) {      if (id == pe[v]) {        continue;      }      auto &e = edges[id];      int to = e.from ^ e.to ^ v;      depth[to] = depth[v] + 1;      dist[to] = dist[v] + e.cost;      pv[to] = v;      pe[to] = id;      root[to] = (root[v] != -1 ? root[v] : to);      do_dfs(to);      sz[v] += sz[to];    }    end[v] = (int) order.size() - 1;  }\u00a0  void do_dfs_from(int v) {    depth[v] = 0;    dist[v] = T{};    root[v] = v;    pv[v] = pe[v] = -1;    do_dfs(v);  }\u00a0 public:  void dfs(int v, bool clear_order = true) {    if (pv.empty()) {      init();    } else {      if (clear_order) {        order.clear();      }    }    do_dfs_from(v);  }\u00a0  void dfs_all() {    init();    for (int v = 0; v < n; v++) {      if (depth[v] == -1) {        do_dfs_from(v);      }    }    assert((int) order.size() == n);  }};\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    int a, b;    cin >> a >> b;    --a; --b;    dfs_forest<int> g(n);    for (int i = 0; i < n - 1; i++) {      int x, y;      cin >> x >> y;      --x; --y;      g.add(x, y);    }    g.dfs(a);    int ans = 0;    int steps = (g.depth[b] + 1) / 2;    while (steps > 0) {      b = g.pv[b];      ans += 1;      steps -= 1;    }    ans += 2 * (n - 1);    g.dfs(b);    int mx = *max_element(g.depth.begin(), g.depth.end());    cout << ans - mx << '\\n';  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "greedy",
        "shortest paths",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Paint the Tree.json"
}