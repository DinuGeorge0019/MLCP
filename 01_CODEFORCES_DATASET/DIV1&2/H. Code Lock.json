{
    "link": "https://codeforces.com//contest/1804/problem/H",
    "problemId": "1824147",
    "problem_idx": "H",
    "shortId": "1804H",
    "contest_number": "1804",
    "problem_submissions": {
        "H": [
            197133699,
            197211600
        ],
        "G": [
            197106837,
            197116479,
            197124948,
            197127592,
            197122958,
            197137640,
            197134544,
            197138362
        ],
        "F": [
            197093293,
            197105349,
            197095528,
            197104786,
            197106624,
            197098643,
            197101524,
            197103930,
            197102162,
            197105107,
            197108552,
            197108666,
            197107628,
            197142671,
            197140184,
            197139967,
            197139883,
            197139641,
            197111482,
            197111626,
            197113675,
            197111909,
            197110044,
            197110987,
            197113933
        ],
        "E": [
            197089405,
            197085286,
            197090524,
            197097633,
            197097337,
            197091345,
            197092803,
            197096473,
            197096893,
            197095376,
            197096756,
            197096855,
            197096490,
            197096936,
            197101267,
            197098474,
            197101399,
            197096360,
            197103528,
            197097046
        ],
        "D": [
            197081706,
            197080440,
            197082836,
            197086161,
            197088893,
            197081349,
            197083999,
            197084952,
            197086950,
            197076993,
            197086858,
            197086874,
            197084897,
            197084889,
            197084721,
            197084970,
            197089163,
            197084662,
            197086535,
            197082927
        ],
        "C": [
            197078079,
            197076920,
            197078785,
            197081523,
            197083238,
            197076107,
            197077574,
            197078670,
            197077463,
            197082879,
            197080775,
            197081089,
            197078608,
            197079622,
            197080414,
            197078487,
            197079270,
            197080239,
            197080507,
            197079932
        ],
        "B": [
            197075523,
            197075248,
            197075383,
            197077168,
            197080868,
            197074547,
            197074457,
            197076648,
            197075635,
            197080800,
            197077487,
            197076188,
            197075795,
            197076995,
            197076635,
            197075839,
            197076655,
            197076988,
            197077650,
            197075789
        ],
        "A": [
            197073420,
            197073942,
            197073446,
            197073814,
            197078430,
            197073370,
            197073351,
            197073646,
            197073456,
            197078319,
            197074505,
            197073977,
            197073328,
            197073488,
            197073501,
            197073461,
            197073950,
            197074331,
            197075653,
            197073687
        ]
    },
    "name": "H. Code Lock",
    "statement": "Lara has a safe that is locked with a circle-shaped code lock that\r\nconsists of a rotating arrow, a static circumference around the arrow,\r\nan input screen, and an input button.The circumference of the lock is\r\nsplit into k equal sections numbered from 1 to k in clockwise order.\r\nArrow always points to one of the sections. Each section is marked with\r\none of the first k letters of the English alphabet. No two sections are\r\nmarked with the same letter.Due to the lock limitations, the safe’s\r\npassword is a string of length n that consists of first k letters of the\r\nEnglish alphabet only. Lara enters the password by rotating the lock’s\r\narrow and pressing the input button. Initially, the lock’s arrow points\r\nto section 1 and the input screen is empty. In one second she can do one\r\nof the following actions. Rotate the arrow one section clockwise. If the\r\narrow was pointing at section x < k it will now point at section x + 1.\r\nIf the arrow was pointing at section k it will now point at section 1.\r\nRotate the arrow one section counter-clockwise. If the arrow was\r\npointing at section x > 1 it will now point at section x - 1. If the\r\narrow was pointing at section 1 it will now point at section k. Press\r\nthe input button. The letter marked on the section that the arrow points\r\nto will be added to the content of the input screen. As soon as the\r\ncontent of the input screen matches the password, the safe will open.\r\nLara always enters her password in the minimum possible time.Lara has\r\nrecently found out that the safe can be re-programmed. She can take the\r\nfirst k letters of the English alphabet and assign them to the sectors\r\nin any order she likes. Now she wants to re-arrange the letters in a way\r\nthat will minimize the number of seconds it takes her to input the\r\npassword. Compute this minimum number of seconds and the number of ways\r\nto assign letters, for which this minimum number of seconds is\r\nachieved.Two ways to assign letters to sectors are considered to be\r\ndistinct if there exists at least one sector i that is assigned\r\ndifferent letters.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int inf = 1E9;\n\nstruct Info {\n    int min = inf;\n    i64 cnt = 0;\n};\n\nInfo operator+(Info a, Info b) {\n    if (a.min < b.min) {\n        return a;\n    } else if (b.min < a.min) {\n        return b;\n    } else {\n        return {a.min, a.cnt + b.cnt};\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int k, n;\n    std::cin >> k >> n;\n    \n    std::string S;\n    std::cin >> S;\n    \n    std::vector cnt(k, std::vector<int>(k));\n    for (int i = 1; i < n; i++) {\n        cnt[S[i - 1] - 'a'][S[i] - 'a'] += 1;\n        cnt[S[i] - 'a'][S[i - 1] - 'a'] += 1;\n    }\n    for (int i = 0; i < k; i++) {\n        cnt[i][i] = 0;\n    }\n    \n    int half = (k + 1) / 2;\n    \n    std::vector<int> p;\n    for (int i = 0; i < half; i++) {\n        p.push_back(i);\n        if (i + half < k) {\n            p.push_back(i + half);\n        }\n    }\n    \n    std::vector<int> pw(k + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= k; i++) {\n        pw[i] = pw[i - 1] * 3;\n    }\n    \n    std::vector<Info> dp(1 << k);\n    std::vector<int> tm(1 << k, -1);\n    std::vector sum(k, std::vector<int>(1 << k));\n    for (int a = 0; a < k; a++) {\n        for (int s = 1; s < (1 << k); s++) {\n            int b = __builtin_ctz(s);\n            sum[a][s] = sum[a][s ^ (1 << b)] + cnt[a][b];\n        }\n    }\n    \n    // i64 tot = 0;\n    Info ans;\n    std::vector<int> q;\n    for (int s = 0; s < (1 << k); s++) {\n        if (~s >> (S[0] - 'a') & 1) {\n            continue;\n        }\n        if (__builtin_popcount(s) == half) {\n            q.clear();\n            q.push_back(0);\n            tm[0] = s;\n            dp[0] = {0, 1};\n            \n            for (int _ = 0; _ < q.size(); _++) {\n                int t = q[_];\n                \n                int c = __builtin_popcount(t);\n                int pos = p[c];\n                if (c % 2 == 0) {\n                    for (int C = ~t & s; C > 0; C &= (C - 1)) {\n                        int i = __builtin_ctz(C);\n                        if (c == 0 && i != S[0] - 'a') {\n                            continue;\n                        }\n                        auto val = dp[t];\n                        val.min += (sum[i][(1 << k) - 1 - (s ^ t)] - sum[i][s ^ t]) * pos;\n                        int nt = t | 1 << i;\n                        if (tm[nt] == s) {\n                            dp[nt] = dp[nt] + val;\n                        } else {\n                            dp[nt] = val;\n                            tm[nt] = s;\n                            q.push_back(nt);\n                        }\n                    }\n                } else {\n                    for (int C = ~t & ~s & ((1 << k) - 1); C > 0; C &= (C - 1)) {\n                        int i = __builtin_ctz(C);\n                        auto val = dp[t];\n                        val.min += (sum[i][s ^ t] - sum[i][(1 << k) - 1 - (s ^ t)]) * pos;\n                        val.min += sum[i][t & s] * k;\n                        int nt = t | 1 << i;\n                        if (tm[nt] == s) {\n                            dp[nt] = dp[nt] + val;\n                        } else {\n                            dp[nt] = val;\n                            tm[nt] = s;\n                            q.push_back(nt);\n                        }\n                    }\n                }\n            }\n            \n            ans = ans + dp[(1 << k) - 1];\n        }\n    }\n    \n    ans.min += n;\n    std::cout << ans.min << \"\\n\";\n    std::cout << ans.cnt << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Code Lock.json",
    "editorial_link": "https://codeforces.com//blog/entry/113830",
    "editorial": "First, letâs solve the task for the case of linear arrangement of\r\nletters instead of a circle. Then we will upgrade the solution.Let c(x,\r\ny) be the number of positions i of the password string s such that s_i =\r\nx and s_{i + 1} = y. In other words, c(x, y) is the number of times Lara\r\nhas to enter letter y after entering letter x. We need to find any\r\npermutation of letters p_0, p_1, p_2,\r\nldots, p_{k-1} of minimum cost. Integer p_i stands for the index of the\r\nletter that will be placed at position i. The cost of a permutation is\r\ncomputed as w(p) =\r\nsum_{0\r\nleq i, j < k, i\r\nne j} c(p_i, p_j)\r\ncdot |i - j|.Pointwise weights are much more convenient to use rather\r\nthan pairwise weights. Re-write the cost function as follows. w(p) =\r\nsum_{0\r\nleq i, j < k, i\r\nne j} c(p_i, p_j)\r\ncdot |i - j| =\r\nsum_{0\r\nleq i < j < k} (c(p_i, p_j) + c(p_j, p_i))\r\ncdot (j - i) =\r\nsum_{i = 0}^{i < k} i\r\ncdot (\r\nsum_{j = 0}^{j < i} (c(p_j, p_i) + c(p_i, p_j)) -\r\nsum_{j = i + 1}^{j < k} (c(p_j, p_i) + c(p_i, p_j)))Usage of pointwise\r\nweights allows us to obtain the permutation step by step from left to\r\nright. When we place the new element x we only need to know the subset\r\nof all already placed elements and the optimal cost of the prefix.Define\r\nd(mask) as the minimum total cost of a permutation prefix containing\r\nfirst |mask| elements. The update function looks as follows. d(mask) =\r\nmin_{x\r\nin mask} (d(mask - x) + |mask|\r\ncdot (\r\nsum_{y\r\nin mask, y\r\nne x} (c(y, x) + c(x, y)) -\r\nsum_{y\r\nnot\r\nin mask} (c(y, x) + c(x, y))))The above solution works in O(2^n\r\ncdot n). However, in can be updated to O(2^n\r\ncdot n) with some precomputations of the sums in the formula above.Now\r\nwe need to learn how to apply the similar idea for a positioning on a\r\ncircle. The cost function now looks as follows. w(p) =\r\nsum_{0\r\nleq i, j < k, i\r\nne j} c(p_i, p_j)\r\ncdot\r\nmin(|i - j|, k - |i - j|) =\r\nsum_{i = 0}^{k - 1} pw(p, i)In order to write the cost function using\r\npointwise weights we need to distinguish between two halves. The\r\npointwise cost of an element in the first half is: pw(p, i) = i\r\ncdot\r\nsum_{j = 0}^{j < i} (c(p_i, p_j) + c(p_j, p_i)) - i\r\ncdot\r\nsum_{j = i + 1}^{j\r\nleq i +\r\nlfloor\r\nfrac{k}{2}\r\nrfloor} (c(p_i, p_j) + c(p_j, p_i)) + (i + n)\r\ncdot\r\nsum_{j = i +\r\nlfloor\r\nfrac{k}{2}\r\nrfloor + 1}^{k - 1} (c(p_i, p_j) + c(p_j, p_i))Similarly, the poinwise\r\ncost of an element in the second half is: pw(p, i) = -i\r\ncdot\r\nsum_{j = 0}^{j < i -\r\nlfloor\r\nfrac{k}{2}\r\nrfloor} (c(p_i, p_j) + c(p_j, p_i)) + i\r\ncdot\r\nsum_{j = i -\r\nlfloor\r\nfrac{k}{2}\r\nrfloor}^{j < i} (c(p_i, p_j) + c(p_j, p_i)) - i\r\ncdot\r\nsum_{j = i + 1}^{k - 1} (c(p_i, p_j) + c(p_j, p_i))The above formulas\r\nshow that it makes sense to first split all elements in two parts: left\r\nand right halves of the circle. Then we will alternate steps in adding\r\none element to the first unoccupied position of the left part, then to\r\nthe first unoccupied position of the right part. This way we will always\r\nbe able to compute the value of a pointwise cost function.So we compute\r\nthe dynamic programming d(S, M), where S is the subset identifying the\r\nway to split the set of all letters in two equal (or almost equal for\r\nthe case of odd size) parts, and M is the subset of already added\r\nelements. Elements S\r\ncap M are placed at the beginning of the first half and elements\r\noverline{S}\r\ncap M are placed at the beginning of the second half.The simpliest\r\ncomplexity estimation is O(4^n\r\ncdot n). However, we should consider the following optimizations. We\r\nonly use |S| =\r\nlceil\r\nfrac{k}{2}\r\nrceil. We only use states such that |S\r\ncap M| = |\r\noverline{S}\r\ncap M| or |S\r\ncap M| = |\r\noverline{S}\r\ncap M| + 1. The character s_0 is always located at the first sector of\r\nthe code lock, so Lara doesnât have to make any moves to enter the first\r\ncharacter of her password. Thus, we only consider s_0\r\nin S and s_0\r\nin M. Considering all the above optimizations we end up with only\r\n82818450\r\napprox 83\r\ncdot 10^6 states. The problem statement asks you to compute the number\r\nof permutations as well. That doesnât add anything to the difficulty of\r\nthis dynamic programming solution and is just used to cut away all the\r\nheuristic optimizations like annealing simulation.\r\n",
    "hint": []
}