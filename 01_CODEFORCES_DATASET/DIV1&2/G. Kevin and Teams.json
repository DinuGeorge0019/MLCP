{
    "link": "https://codeforces.com//contest/2061/problem/G",
    "problemId": "3155961",
    "problem_idx": "G",
    "shortId": "2061G",
    "contest_number": "2061",
    "problem_submissions": {
        "F2": [
            302127475,
            302092403,
            302114656,
            302114350,
            302118052,
            302128136,
            302099327,
            302127501,
            302105569,
            302158287,
            302158231,
            302158981,
            302158740,
            302158593,
            302155955
        ],
        "H1": [
            302102508,
            302123846,
            302123275,
            302120307,
            302128240,
            302113263,
            302214973,
            302214838,
            302492170,
            302128311,
            302150853
        ],
        "G": [
            302087277,
            302104836,
            302092310,
            302101290,
            302098614,
            302099751,
            302090244,
            302079497,
            302107342,
            302102846,
            302118471,
            302119832,
            302088828,
            302085801,
            302097252,
            302107147,
            302100360,
            302104471
        ],
        "F1": [
            302070705,
            302068249,
            302076903,
            302139304,
            302085853,
            302085964,
            302087951,
            302076823,
            302099111,
            302088499,
            302088697,
            302106078,
            302076066,
            302095307,
            302083979,
            302077009,
            302082649,
            302158914,
            302081283
        ],
        "E": [
            302060766,
            302059898,
            302064375,
            302146780,
            302146561,
            302146204,
            302145996,
            302145832,
            302145821,
            302145812,
            302060519,
            302071650,
            302062756,
            302067337,
            302066558,
            302071373,
            302078018,
            302075359,
            302069841,
            302067118,
            302063628,
            302073608,
            302071649,
            302075889,
            302072748
        ],
        "D": [
            302057147,
            302056206,
            302056876,
            302056600,
            302064486,
            302056648,
            302061458,
            302060302,
            302063595,
            302065433,
            302068805,
            302064352,
            302061742,
            302059104,
            302069059,
            302065232,
            302069194,
            302062940
        ],
        "C": [
            302053893,
            302052972,
            302060290,
            302053477,
            302058781,
            302053556,
            302058513,
            302056661,
            302060439,
            302057971,
            302066087,
            302059912,
            302059144,
            302055184,
            302066070,
            302060621,
            302062953,
            302059461
        ],
        "B": [
            302048946,
            302050832,
            302052328,
            302049723,
            302053638,
            302049221,
            302054664,
            302052475,
            302055824,
            302052997,
            302059041,
            302057352,
            302051579,
            302051983,
            302056196,
            302056129,
            302055478,
            302054565
        ],
        "A": [
            302047037,
            302049009,
            302047309,
            302047023,
            302047283,
            302047053,
            302047177,
            302047108,
            302047316,
            302047521,
            302047571,
            302047610,
            302047369,
            302048738,
            302047337,
            302048364,
            302049028,
            302047123
        ],
        "H2": [
            302541217
        ],
        "I": [
            302144176,
            302142123,
            302142064,
            302141919,
            302124920,
            302518298,
            302518173,
            302517883
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138620",
    "editorial": "Using graph theory terminology, let edges labeled as be represented in\r\nred and edges labeled as be represented in blue. We can prove that if a\r\ngraph has vertices, the maximum matching will be at most . To see this,\r\nyou can construct a blue clique of size , with all other edges colored\r\nred. It is not hard to verify that the maximum matching in both colors\r\nis .So the maximum matching you can find is . To construct a matching,\r\nwe can maintain a chain of edges of the same color. Suppose we currently\r\nhave a red chain . Now, we want to add a new vertex . We check the color\r\nof the edge between and : If the edge is red, we add to the chain. If\r\nthe edge is blue, will form a \"mixed-color triplet.\" In this case, we\r\nremove and from the chain. After at most queries, the graph will be\r\ndivided into several \"mixed-color triplets\" and one chain of edges of\r\nthe same color.For the chain of length , we can find matchings. For each\r\n\"mixed-color triplet\", we can always find one matching corresponding to\r\nthe color.We can construct a matching of size .\r\n",
    "name": "G. Kevin and Teams",
    "statement": "Kevin has n classmates, numbered 1, 2,\r\nldots, n. Any two of them may either be friends or not friends.Kevin\r\nwants to select 2k classmates to form k teams, where each team contains\r\nexactly 2 people. Each person can belong to at most one team.Let u_i and\r\nv_i be two people in the i-th team. To avoid potential conflicts during\r\nteam formation, the team members must satisfy one of the following two\r\nconditions: For all i (1\r\nleq i\r\nleq k), classmate u_i and v_i are friends. For all i (1\r\nleq i\r\nleq k), classmate u_i and v_i are not friends. Kevin wants to determine\r\nthe maximum k such that, regardless of the friendship relationships\r\namong the n people, he can always find 2k people to form the teams.\r\nAfter that, he needs to form k teams. But asking whether two classmates\r\nare friends is awkward, so Kevin wants to achieve this while asking\r\nabout the friendship status of no more than n pairs of classmates.The\r\ninteractor is . It means that the hidden relationship between classmates\r\nis not fixed before the interaction and will change during the\r\ninteraction.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;using u128 = unsigned __int128; int query(int a, int b) {    std::cout << \"? \" << a << \" \" << b << std::endl;    int ans;    std::cin >> ans;    return ans;} void solve() {    int n;    std::cin >> n;        int k = (n + 1) / 3;    std::cout << k << std::endl;        std::vector<std::array<int, 3>> tp;    std::vector<std::array<int, 2>> pr[2];    std::queue<int> q;    for (int i = 1; i <= n; i++) {        q.push(i);    }        while (true) {        if (!pr[0].empty() && !pr[1].empty()) {            auto [a, b] = pr[0].back();            auto [c, d] = pr[1].back();            pr[0].pop_back();            pr[1].pop_back();                        if (query(b, c)) {                tp.push_back({a, b, c});                q.push(d);            } else {                tp.push_back({b, c, d});                q.push(a);            }        } else if (q.size() >= 2) {            int a = q.front();            q.pop();            int b = q.front();            q.pop();                        pr[query(a, b)].push_back({a, b});        } else {            break;        }    }        int t = pr[0].size() > pr[1].size() ? 0 : 1;        auto ans = pr[t];    for (auto [a, b, c] : tp) {        if (t == 0) {            ans.push_back({a, b});        } else {            ans.push_back({b, c});        }    }    assert(ans.size() >= k);    ans.resize(k);    std::cout << \"!\";    for (auto [a, b] : ans) {        std::cout << \" \" << a << \" \" << b;    }    std::cout << std::endl;} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Kevin and Teams.json",
    "hint": [
        "Hint 1 What is the size of the maximum possible matching? What can be the \"most dense\" graph with maximum matching ?",
        "Hint 2 Mixed-color triplet( with edge and with edge ) is a flexible structure to find a matching for both types.",
        "Hint 3 Add vertices one by one. Try to get a \"mixed-color triple\" or a larger set of the same color."
    ]
}