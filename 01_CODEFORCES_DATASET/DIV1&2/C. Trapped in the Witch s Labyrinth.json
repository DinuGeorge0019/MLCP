{
    "link": "https://codeforces.com//contest/2034/problem/C",
    "problemId": "3057437",
    "problem_idx": "C",
    "shortId": "2034C",
    "contest_number": "2034",
    "problem_submissions": {
        "G2": [
            294090902,
            294102835,
            294091710
        ],
        "H": [
            294074360,
            294061476,
            294070650,
            294080097,
            294083247,
            294085834,
            294087678,
            294090336,
            294084822,
            294087654,
            294090587,
            294104472,
            294104397,
            294104185,
            294103049,
            294058057,
            294072183,
            294081941,
            294086147,
            294091448
        ],
        "G1": [
            294068700,
            294089598,
            294090555,
            294512628,
            294279844,
            294078743,
            294092614,
            294083324,
            294137051,
            298736856
        ],
        "F2": [
            294044355,
            294048880,
            294057967,
            294058547,
            294044212,
            294052710,
            294062635,
            294059190,
            294064262,
            294068869,
            294068913,
            294056682,
            294087439,
            294054148,
            294055470,
            294067548,
            294048518,
            294098694,
            297729208
        ],
        "F1": [
            294044201,
            294045676,
            294057746,
            294058488,
            294044581,
            294052242,
            294063014,
            294059348,
            294064621,
            294068676,
            294069032,
            294056298,
            294079209,
            294055715,
            294050068,
            294055587,
            294059717,
            294048439,
            294065367,
            294063971
        ],
        "E": [
            294039732,
            294035256,
            294043120,
            294044445,
            294061596,
            294042263,
            294051208,
            294051638,
            294059206,
            294057047,
            294047623,
            294072917,
            294043657,
            294040686,
            294046402,
            294070560,
            294044216,
            294048932,
            294047270
        ],
        "D": [
            294029209,
            294029423,
            294031077,
            294032177,
            294053262,
            294029511,
            294040505,
            294041118,
            294048071,
            294036073,
            294034324,
            294064606,
            294034084,
            294023836,
            294028591,
            294031360,
            294038809,
            294039055
        ],
        "C": [
            294019511,
            294017117,
            294018450,
            294020877,
            294023563,
            294033582,
            294025662,
            294021753,
            294020563,
            294027112,
            294020897,
            294016537,
            294062723,
            294021341,
            294029864,
            294018381,
            294021917,
            294017733,
            294050791,
            294028560
        ],
        "B": [
            294013321,
            294006563,
            294009984,
            294010387,
            294010473,
            294013337,
            294026398,
            294010402,
            294011621,
            294010156,
            294007642,
            294050334,
            294011602,
            294008120,
            294012362,
            294012172,
            294084096,
            294006809,
            294008731
        ],
        "A": [
            294004839,
            294004703,
            294005425,
            294005031,
            294006081,
            294004631,
            294006317,
            294005105,
            294006032,
            294005086,
            294004777,
            294047604,
            294005991,
            294004926,
            294006968,
            294005489,
            294006094,
            294004648,
            294005025
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136579",
    "editorial": "Solution If a cell has a fixed direction (i.e., it points to another\r\ncell), and following that direction leads outside the maze, it must\r\neventually exit the maze. Such cells cannot be part of any loop. We can\r\nanalyze the remaining cells once we identify cells that lead out of the\r\nmaze. Any undirected cell or cell might either lead to the exit or form\r\npart of a loop. If all neighboring cells of a cell can eventually lead\r\nout of the maze, then this cell will also lead out of the maze. The\r\nstate of such cells can be determined based on their surroundings. For\r\nany remaining cells (directed cells that do not lead out of the maze, or\r\nother cells that cannot be determined to lead to an exit), we can assign\r\ndirections such that starting from those cells will eventually lead to a\r\nloop. These cells will form the loops. To find how many cells will\r\neventually lead to a loop, we can use a Depth-First Search (DFS) on the\r\nreversed graph, where all directions are reversed. By performing DFS\r\nstarting from the \"out-of-maze\" cells, we can identify all cells that\r\nare reachable from the outside and thus will eventually lead out of the\r\nmaze. Count the number of cells that can reach the exit. Subtract this\r\nnumber from the total number of cells in the maze to determine how many\r\nare part of loops (i.e., cells that cannot reach the exit).\r\n",
    "name": "C. Trapped in the Witch s Labyrinth",
    "statement": "In the fourth labor of Rostam, the legendary hero from the Shahnameh, an\r\nold witch has created a magical maze to trap him. The maze is a\r\nrectangular grid consisting of n rows and m columns. Each cell in the\r\nmaze points in a specific direction: up, down, left, or right. The witch\r\nhas enchanted Rostam so that whenever he is in a cell, he will move to\r\nthe next cell in the direction indicated by that cell. If Rostam\r\neventually exits the maze, he will be freed from the witch\u2019s enchantment\r\nand will defeat her. However, if he remains trapped within the maze\r\nforever, he will never escape.The witch has not yet determined the\r\ndirections for all the cells. She wants to assign directions to the\r\nunspecified cells in such a way that the number of starting cells from\r\nwhich Rostam will be trapped forever is maximized. Your task is to find\r\nthe maximum number of starting cells which make Rostam trapped.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7;int n, m;string s[N];int P(int x, int y) {\treturn (x - 1) * m + y;}int dt[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};map<char,int>mp;int go[N];vi e[N];int vis[N];void dfs(int x) {\tfor(auto v : e[x]) {\t\tvis[v] = 1;\t\tdfs(v);\t}}void Main() {\tcin >> n >> m;\tL(i, 1, n) {\t\tcin >> s[i];\t\ts[i].insert(s[i].begin(), ' ');\t}\tL(i, 1, n * m) vis[i] = 0;\tL(i, 1, n) {\t\tL(j, 1, m) {\t\t\tgo[P(i, j)] = -1;\t\t\tif(s[i][j] != '?') {\t\t\t\tint d = mp[s[i][j]];\t\t\t\tint ni = i + dt[d][0];\t\t\t\tint nj = j + dt[d][1];\t\t\t\tif(1 <= ni && ni <= n && 1 <= nj && nj <= m) {\t\t\t\t\tgo[P(i, j)] = P(ni, nj);\t\t\t\t} else {\t\t\t\t\tgo[P(i, j)] = 0;\t\t\t\t}\t\t\t\te[go[P(i, j)]].pb(P(i, j));\t\t\t}\t\t}\t}\tdfs(0);\tint ans = 0;\tL(i, 1, n) L(j, 1, m) {\t\tif(s[i][j] != '?') {\t\t\tans += !vis[P(i, j)];\t\t} else {\t\t\tint win = 1;\t\t\tL(d, 0, 3) {\t\t\t\tint ni = i + dt[d][0];\t\t\t\tint nj = j + dt[d][1];\t\t\t\tif(1 <= ni && ni <= n && 1 <= nj && nj <= m) {\t\t\t\t\twin &= vis[P(ni, nj)];\t\t\t\t} \t\t\t}\t\t\tif(!win) ans += 1;\t\t}\t}\tcout << ans << '\\n';\tL(i, 0, n * m) e[i].clear();}int main() {\tmp['D']=0;\tmp['U']=1;\tmp['R']=2;\tmp['L']=3;\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Trapped in the Witch s Labyrinth.json"
}