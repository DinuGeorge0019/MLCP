{
    "link": "https://codeforces.com//contest/2039/problem/B",
    "problemId": "3044241",
    "problem_idx": "B",
    "shortId": "2039B",
    "contest_number": "2039",
    "problem_submissions": {
        "H2": [
            293022173,
            292975899,
            293009720,
            293009629,
            292979841,
            293060454,
            293060194,
            293060105,
            293059569,
            293059499,
            293058593,
            293057719,
            293055409,
            292974404,
            293573537,
            293836671
        ],
        "H1": [
            292982631,
            292972228,
            292979607,
            292982502,
            292974164,
            293573469,
            293059467,
            293059363,
            293211380
        ],
        "G": [
            292969247,
            293681826,
            292993324,
            293010834,
            293010553,
            293010471,
            293010340,
            293010120,
            293010018,
            293009701,
            293009655,
            293003224,
            297799435
        ],
        "F2": [
            292946923,
            292955967,
            293005214,
            292960338,
            292999416,
            292955000,
            292958916,
            292967655,
            292970902,
            292961947,
            292966290,
            292963989,
            292967412,
            292973184,
            292993481,
            292993311,
            292976407,
            292966983,
            292978513,
            292976694,
            293022589,
            292967640,
            292984216
        ],
        "F1": [
            292945412,
            292942851,
            292958378,
            292949546,
            292951422,
            292955834,
            292959947,
            292954803,
            292957707,
            292958754,
            292957596,
            292962769,
            292956864,
            292955257,
            292964681,
            292964473,
            292964765,
            292965768,
            292968761
        ],
        "E": [
            292932028,
            292929645,
            292933355,
            292963892,
            292940034,
            292936413,
            292941966,
            292931255,
            292936422,
            292938671,
            292940624,
            292940752,
            292940961,
            292940869,
            292938393,
            292948055,
            292943772,
            292946396,
            292946184,
            292939977
        ],
        "D": [
            292923683,
            292921484,
            292926110,
            292929028,
            292926266,
            292927350,
            292921466,
            292925183,
            292925904,
            292928764,
            292926685,
            292933204,
            292929931,
            292932758,
            292931129,
            292932616,
            292934202,
            292934805,
            292935631,
            292930017
        ],
        "C2": [
            292919330,
            292917998,
            292939842,
            292926003,
            292922842,
            292923169,
            292918086,
            292921831,
            292922028,
            292924806,
            292921211,
            292927506,
            292924788,
            292928147,
            292925335,
            292930053,
            292929498,
            292927637,
            292921966,
            292924642
        ],
        "C1": [
            292915259,
            292911645,
            292917236,
            292921770,
            292918116,
            292914284,
            292911251,
            292913523,
            292917485,
            292916296,
            292914031,
            292919002,
            292919462,
            292912804,
            292917736,
            292919161,
            292917158,
            292914034,
            292915590,
            292918639
        ],
        "B": [
            292913457,
            292908262,
            292913960,
            292910847,
            292913438,
            292910350,
            292908336,
            292908529,
            292912517,
            292910482,
            292911010,
            292915701,
            292913529,
            292909516,
            292913081,
            292913634,
            292911345,
            292910794,
            292912642,
            292914438
        ],
        "A": [
            292905585,
            292905540,
            292908032,
            292905695,
            292905934,
            292906422,
            292905668,
            292905623,
            292906025,
            292905951,
            292906103,
            292906968,
            292906118,
            292905657,
            292906384,
            292906200,
            292906172,
            292905930,
            292907356,
            292905826
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136523",
    "editorial": "The condition seems hard to track. So a good way is to play around with\r\nsmaller cases and see if we can make some observations. Letâs start with\r\nthe smallest string. When , the number of unique substrings , so itâs\r\nodd and not valid. No one length strings are valid. Letâs try the next\r\nsmallest strings. When , , so itâs even and valid. When , , so itâs odd\r\nand not valid. Two length strings are valid if the adjacent characters\r\nare same. So if contains two consecutive same characters, we can print\r\nit right away. All that remains is to consider strings without two\r\nconsecutive same characters. Letâs try the next smallest strings with\r\nadjacent different characters. When , , so itâs odd and not valid. When\r\n, , so itâs even and valid. Three length strings are valid if all\r\ncharacters are different. So if contains three consecutive different\r\ncharacters, we can print it right away. All that remains is to consider\r\nstrings without two adjacent same characters but no three consecutive\r\ndifferent characters.So all the remaining strings are of the form Letâs\r\ntry to see if we can make some observations about these strings. Letâs\r\ntry to calculate the number of unique substrings for a string of the\r\nform There are exactly unique substrings of length : and . There are\r\nexactly unique substrings of length : and . There are exactly unique\r\nsubstrings of length : and . There are exactly unique substrings of\r\nlength . However, the length substring occurs exactly once. The number\r\nof unique substrings of any length is . But only the length substring\r\noccurs exactly once. So total number of unique substrings is . And this\r\nis always odd! So there is no solution for these strings. We have\r\ncovered all the cases. If there are adjacent same characters, we can\r\nprint it right away. If there are three consecutive different\r\ncharacters, we can print it right away. Otherwise there is no solution.\r\n.\r\n",
    "name": "B. Shohag Loves Strings",
    "statement": "For a string p, let f(p) be the number of distinct non-empty\r\nsubstrings^{\r\ntext{ }} of p.Shohag has a string s. Help him find a non-empty string p\r\nsuch that p is a substring of s and f(p) is even or state that no such\r\nstring exists.^{\r\ntext{ }}A string a is a substring of a string b if a can be obtained\r\nfrom b by deletion of several (possibly, zero or all) characters from\r\nthe beginning and several (possibly, zero or all) characters from the\r\nend.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;int n;string s;void Main() {\tcin >> s;\tL(i, 0, sz(s) - 2) {\t\tif(s[i] == s[i + 1]) {\t\t\tcout << s[i] << s[i + 1] << '\\n';\t\t\treturn;\t\t}\t}\tL(i, 0, sz(s) - 3) {\t\tif(s[i] != s[i + 2]) {\t\t\tcout << s[i] << s[i + 1] << s[i + 2] << '\\n';\t\t\treturn;\t\t}\t}\tcout << \"-1\\n\";}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Shohag Loves Strings.json",
    "hint": []
}