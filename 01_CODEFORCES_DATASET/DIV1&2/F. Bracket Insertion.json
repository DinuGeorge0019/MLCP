{
    "link": "https://codeforces.com//contest/1782/problem/F",
    "problemId": "1738312",
    "problem_idx": "F",
    "shortId": "1782F",
    "contest_number": "1782",
    "problem_submissions": {
        "G": [
            189352903,
            189354160,
            189342529,
            189347964,
            189346429,
            189415258,
            189347317,
            189738607,
            189347232,
            189347696,
            189403021,
            189438204,
            189354810,
            189338967,
            189344949
        ],
        "H1": [
            189341567,
            189339761,
            189349634,
            189355935,
            189355012,
            189341367,
            189348685,
            189366896,
            189384259,
            189345985,
            189353203,
            189354256,
            189356712
        ],
        "F": [
            189325657,
            189363621,
            189331442,
            189327188,
            189334558,
            189331825,
            189332228,
            189332897,
            189335481,
            189328585,
            189328764,
            189334100,
            189338796,
            189342861,
            189333278,
            189345646,
            189348301,
            189336716,
            189329952,
            189336813
        ],
        "E": [
            189322203,
            189324476,
            189336013,
            189324984,
            189327367,
            189324941,
            189325259,
            189324742,
            189325043,
            189324750,
            189330839,
            189330033,
            189340117,
            189340110,
            189356727,
            189364874,
            189338107,
            189329882
        ],
        "D": [
            189315553,
            189316553,
            189320757,
            189315522,
            189321240,
            189315774,
            189315356,
            189317449,
            189316444,
            189318717,
            189318855,
            189319485,
            189321217,
            189322258,
            189322561,
            189316855,
            189317394,
            189318806,
            189319611
        ],
        "C": [
            189312571,
            189313515,
            189317007,
            189313044,
            189315685,
            189312570,
            189312443,
            189313938,
            189314521,
            189313780,
            189316398,
            189315035,
            189318312,
            189317410,
            189321818,
            189314789,
            189315093,
            189314367
        ],
        "B": [
            189309405,
            189309603,
            189311019,
            189308821,
            189310918,
            189309246,
            189308942,
            189310194,
            189308126,
            189309056,
            189311263,
            189310085,
            189312839,
            189309172,
            189329674,
            189309853,
            189310568,
            189309470
        ],
        "A": [
            189307515,
            189306919,
            189307198,
            189307124,
            189307391,
            189307301,
            189307111,
            189307534,
            189306943,
            189307353,
            189307056,
            189307424,
            189308244,
            189319051,
            189308061,
            189307499,
            189307060,
            189307053
        ],
        "H2": [
            189361277,
            189352155,
            189886586,
            189749780,
            189366917,
            189362146
        ]
    },
    "name": "F. Bracket Insertion",
    "statement": "Vika likes playing with bracket sequences. Today she wants to create a\r\nnew bracket sequence using the following algorithm. Initially, Vika\u2019s\r\nsequence is an empty string, and then she will repeat the following\r\nactions n times: Choose a place in the current bracket sequence to\r\ninsert new brackets uniformly at random. If the length of the current\r\nsequence is k, then there are k+1 such places: before the first bracket,\r\nbetween the first and the second brackets,\r\nldots, after the k-th bracket. In particular, there is one such place in\r\nan empty bracket sequence. Choose string \"\" with probability p or string\r\n\"\" with probability 1 - p and insert it into the chosen place. The\r\nlength of the bracket sequence will increase by 2. A bracket sequence is\r\ncalled if it is possible to obtain a correct arithmetic expression by\r\ninserting characters \u201d and \u201d into it. For example, sequences \"\", \"\", and\r\n\"\" are regular, while \"\", \"\", and \"\" are not.Vika wants to know the\r\nprobability that her bracket sequence will be a regular one at the end.\r\nHelp her and find this probability modulo 998\r\n,244\r\n,353 (see Output section).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1007, mod = 998244353;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) (mod - mod / i) * inv[mod % i] % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n} \nint C(int x, int y) {\n\treturn x < y || y < 0 ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\n\nint n, p, dp[N][N], f[N][N];\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> p;\n\tinit(n * 2);\n\tp = (ll) p * qpow(10000) % mod;\n\tL(i, 0, n) dp[i][0] = 1, f[i][0] = 1;\n\tL(len, 1, n) {\n\t\tL(h, 0, n) { \n\t\t\tL(i, 0, len - 1) \n\t\t\t\t(dp[h][len] += (ll) f[h][i] * \n\t\t\t\t\t((ll) p * dp[h + 1][len - i - 1] % mod + \n\t\t\t\t\t(h == 0 ? 0 : (ll) (mod + 1 - p) * dp[h - 1][len - i - 1] % mod)) % mod\n\t\t\t\t\t* C(len - 1, i) % mod) %= mod;\n//\t\t\tL(i, 0, len - 1) {\n//\t\t\t\tL(j, 0, len - 1 - i) {\n//\t\t\t\t\t(dp[h][len] += (ll) dp[h][i] * dp[h][j] % mod * \n//\t\t\t\t\t\t((ll) p * dp[h + 1][len - i - j - 1] % mod + \n//\t\t\t\t\t\t(h == 0 ? 0 : (ll) (mod + 1 - p) * dp[h - 1][len - i - j - 1] % mod)) % mod\n//\t\t\t\t\t\t* C(len - 1, i + j) % mod * C(i + j, i) % mod) %= mod;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tL(i, 0, len)\n\t\t\t\t(f[h][len] += (ll) dp[h][i] * dp[h][len - i] % mod * C(len, i) % mod) %= mod;\n\t\t}\n\t}\n\tint ns = dp[0][n];\n\tL(i, 1, n) \n\t\tns = (ll) ns * inv[i * 2 - 1] % mod;\n\tcout << ns << '\\n';\n\treturn 0;\n} "
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "probabilities",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Bracket Insertion.json",
    "editorial_link": "https://codeforces.com//blog/entry/111783",
    "editorial": "Instead of looking at a probabilistic process, we can consider all\r\npossible ways of inserting brackets. There are ways of choosing places,\r\nand ways of choosing \"\" or \"\" at every point. Let be the sum of over all\r\nsuch ways that lead to a regular bracket sequence, where is the number\r\nof strings \"\" inserted during the process (and is then the number of\r\nstrings \"\" inserted). Then, is the answer to the problem.Consider the\r\nsequence of \"prefix balances\" of the bracket sequence. The first (empty)\r\nprefix balance is , and each successive balance is larger than the\r\nprevious one if the next bracket is \u00e2\u0080\u009d, and smaller if the bracket is\r\n\u00e2\u0080\u009d.Initially, when the bracket sequence is empty, the sequence of prefix\r\nbalances is . Whenever we insert \"\" into the bracket sequence in a place\r\nwith prefix balance , essentially we are replacing with in the sequence\r\nof prefix balances. Whenever we insert \"\" instead, that\u00e2\u0080\u0099s equivalent to\r\nreplacing with .A bracket sequence is regular if and only if its\r\ncorresponding sequence of prefix balances does not have any negative\r\nintegers (and ends with ; however, this is guaranteed in our\r\nsetting).Thus, we can reformulate the problem as follows: Initially, we\r\nhave an integer array . times, we choose an integer from the array\r\nuniformly at random. Say this integer is , then we replace with with\r\nprobability , and with with probability . What is the probability that\r\nthe sequence will not contain negative integers at any point? Let be the\r\nsought probability multiplied by if we start with Here, we multiply by\r\nto simplify the formulas, and to keep thinking about \"numbers of ways\"\r\ninstead of \"probabilities\", as described in the first paragraph of this\r\ntutorial.The base cases are if , and otherwise. When : . What does this\r\nformula mean? Essentially, since we start with an array of a single\r\ninteger , the first operation has to be applied to . After that, once\r\ngets replaced with , operations will be applied to the left (including\r\neverything produced from it), operations will be applied to (again,\r\ntogether with its production), and operations will be applied to the\r\nright (and to its production).Thus, we can find the sum over and of the\r\nproduct of the corresponding values of and the binomial coefficients:\r\nsince the sequences of , , and operations can be interleaved\r\narbitrarily, we have ways to choose the positions of operations applied\r\nto the left in the global sequence of operations, and then ways to\r\nchoose the positions of operations applied to out of the remaining\r\npositions in the global sequence.This results in an solution, since\r\nthere are values of to calculate, and each of them is calculated in .To\r\noptimize it, let\u00e2\u0080\u0099s rewrite the formula a little bit by moving the loop\r\nover outside: . Now, let\u00e2\u0080\u0099s introduce an auxiliary function: . Now, let\u00e2\u0080\u0099s\r\nrewrite the formula for using : . Now, both and can be computed in time,\r\nresulting in an solution.\r\n"
}