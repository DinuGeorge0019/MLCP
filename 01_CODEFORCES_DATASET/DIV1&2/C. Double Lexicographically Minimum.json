{
    "link": "https://codeforces.com//contest/1799/problem/C",
    "problemId": "1800599",
    "problem_idx": "C",
    "shortId": "1799C",
    "contest_number": "1799",
    "problem_submissions": {
        "H": [
            195172140,
            195179948,
            195176943,
            195177627,
            195177612,
            195187046,
            195170243,
            195186163,
            195181900,
            195178648,
            195187740,
            195188641,
            195181162,
            195197683,
            195197622,
            195197452,
            195197330,
            195195992,
            195195702,
            195195592,
            195189428,
            222390709,
            195183885,
            195192378
        ],
        "G": [
            195165805,
            195168765,
            195163877,
            195170080,
            195166062,
            195173874,
            195159286,
            195167233,
            195175284,
            195171112,
            195175174,
            195176292,
            195166497,
            195167039,
            195174540,
            195165113,
            195172643,
            195174992,
            195179660
        ],
        "F": [
            195162556,
            195161415,
            195167047,
            195167029,
            195169902,
            195165660,
            195176867,
            195177074,
            195171218,
            195182224,
            195179445,
            195181473,
            195185750,
            195200279,
            195171757,
            195192151,
            195177698,
            195192345,
            195178905,
            195177004
        ],
        "E": [
            195155464,
            195155926,
            195160608,
            195157188,
            195161547,
            195155405,
            195184653,
            195161068,
            195166323,
            195173130,
            195168387,
            195173064,
            195218892,
            195198896,
            195162114,
            195161002,
            195160161,
            195165268,
            195163227,
            195160677
        ],
        "D2": [
            195149687,
            195148531,
            195151569,
            195149401,
            195152435,
            195149320,
            195159443,
            195154372,
            195157592,
            195155987,
            195161428,
            195244200,
            195161041,
            195153968,
            195155870,
            195151311,
            195155278,
            195159787,
            195153371,
            195151855
        ],
        "D1": [
            195149644,
            195148457,
            195150430,
            195149466,
            195152497,
            195149250,
            195150661,
            195154425,
            195157658,
            195153741,
            195161504,
            195150409,
            195152774,
            195155970,
            195151278,
            195153482,
            195159732,
            195149352,
            195149899
        ],
        "C": [
            195146230,
            195145019,
            195147190,
            195145539,
            195148295,
            195145217,
            195148636,
            195146815,
            195151203,
            195151265,
            195151601,
            195146561,
            195147507,
            195149080,
            195145370,
            195151542,
            195158458,
            195147153,
            195147120
        ],
        "B": [
            195140902,
            195141064,
            195140888,
            195140956,
            195140810,
            195141011,
            195142268,
            195146249,
            195143844,
            195142681,
            195143326,
            195142296,
            195140849,
            195142634,
            195140165,
            195142125,
            195141309,
            195141669,
            195140680
        ],
        "A": [
            195139293,
            195139594,
            195139424,
            195139401,
            195139388,
            195139558,
            195139905,
            195143164,
            195139695,
            195139287,
            195140212,
            195139506,
            195139370,
            195139520,
            195139228,
            195140320,
            195142809,
            195139497,
            195139286
        ]
    },
    "name": "C. Double Lexicographically Minimum",
    "statement": "You are given a string s. You can reorder the characters to form a\r\nstring t. Define t_{\r\nmathrm{max}} to be the lexicographical maximum of t and t in reverse\r\norder.Given s determine the lexicographically minimum value of t_{\r\nmathrm{max}} over all reorderings t of s.A string a is lexicographically\r\nsmaller than a string b if and only if one of the following holds: a is\r\na prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    std::string t(n, '?');\n    \n    int cnt[26] {};\n    for (auto c : s) {\n        cnt[c - 'a']++;\n    }\n    \n    int l = 0, r = n - 1;\n    for (int c = 0; c < 26; c++) {\n        while (cnt[c] >= 2) {\n            cnt[c] -= 2;\n            t[l++] = t[r--] = 'a' + c;\n        }\n        if (cnt[c] == 1) {\n            cnt[c] -= 1;\n            if (l == r) {\n                t[l] = 'a' + c;\n            } else {\n                int x = c + 1;\n                while (cnt[x] == 0) {\n                    x++;\n                }\n                if (cnt[x] == r - l) {\n                    while (cnt[x] >= 2) {\n                        cnt[x] -= 2;\n                        t[l++] = t[r--] = 'a' + x;\n                    }\n                    if (cnt[x] == 1) {\n                        cnt[x] -= 1;\n                        t[l++] = 'a' + x;\n                    }\n                    t[r] = 'a' + c;\n                } else {\n                    for (; x < 26; x++) {\n                        while (cnt[x] > 0) {\n                            cnt[x] -= 1;\n                            t[l++] = 'a' + x;\n                        }\n                    }\n                    t[r] = 'a' + c;\n                }\n            }\n            break;\n        }\n    }\n    \n    std::cout << t << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Double Lexicographically Minimum.json",
    "editorial_link": "https://codeforces.com//blog/entry/113321",
    "editorial": "Let\u00e2\u0080\u0099s iterate all symbols of in order from smallest to largest and\r\nconstruct an answer .Let the current symbol be . If there are at least\r\nremaining symbols equal to , we should add them to the current prefix\r\nand suffix of and continue. If there are at most one other symbol is\r\nleft (there are and times left in ) we should add symbols , symbol and\r\nsymbols to the prefix of and break. Otherwise we should add all\r\nremaining symbols of (excluding ) to prefix of in the sorted order and\r\nafter it symbol . Time complexity: , where .\r\n"
}