{
    "link": "https://codeforces.com//contest/1028/problem/D",
    "problemId": "212302",
    "problem_idx": "D",
    "shortId": "1028D",
    "contest_number": "1028",
    "problem_submissions": {
        "F": [
            42179553,
            42173574,
            42172126,
            42183823,
            42179375,
            42177929,
            42176646,
            42176739,
            42168545,
            42174904,
            42175563,
            42187810,
            42177441,
            42180538,
            42178358,
            42178178
        ],
        "H": [
            42177022,
            42177937,
            42197383,
            42174346,
            42178267,
            42180853,
            42180364,
            42179125,
            42178613,
            42177685,
            42188074
        ],
        "G": [
            42174235,
            42180921,
            42179342,
            42179278,
            42183838,
            42181415,
            42188299,
            42175088,
            42183699,
            42177809,
            42199769,
            42180709
        ],
        "E": [
            42168417,
            42169350,
            42169465,
            42168142,
            42175311,
            42172346,
            42172643,
            42173588,
            42169997,
            42170922,
            42170783,
            42169728,
            42172341,
            42172392,
            42174203,
            42173993,
            42169247
        ],
        "D": [
            42165714,
            42166524,
            42166821,
            42171266,
            42167648,
            42168290,
            42168039,
            42170991,
            42171075,
            42166522,
            42165185,
            42167753,
            42167327,
            42166990,
            42167859,
            42166718,
            42169672,
            42169316,
            42172369
        ],
        "C": [
            42162420,
            42161280,
            42164158,
            42159623,
            42162254,
            42163150,
            42163507,
            42162131,
            42163347,
            42161576,
            42161023,
            42164637,
            42163616,
            42161801,
            42163884,
            42163193,
            42164354,
            42165199,
            42162360
        ],
        "B": [
            42159958,
            42159146,
            42159962,
            42160148,
            42160038,
            42161126,
            42160845,
            42163792,
            42159144,
            42162163,
            42159196,
            42160477,
            42160541,
            42159094,
            42160870,
            42160007,
            42160216,
            42160794,
            42159231
        ],
        "A": [
            42158947,
            42158816,
            42158953,
            42161141,
            42158802,
            42159721,
            42159618,
            42163119,
            42158831,
            42163007,
            42158820,
            42158811,
            42158901,
            42158777,
            42159186,
            42158929,
            42158806,
            42159328,
            42158825
        ]
    },
    "name": "D. Order book",
    "statement": "Let’s consider a simplified version of order book of some stock. The\r\norder book is a list of orders (offers) from people that want to buy or\r\nsell one unit of the stock, each order is described by ( or ) and\r\nprice.At every moment of time, every offer has higher price than every\r\noffer. The lowest-price order and the highest-price order are called the\r\n, marked with black frames on the picture below. There are two possible\r\nactions in this orderbook: Somebody adds a new order of some direction\r\nwith some price. Somebody accepts the best possible or offer (makes a\r\ndeal). It’s impossible to accept not the best or offer (to make a deal\r\nat worse price). After someone accepts the offer, it is removed from the\r\norderbook forever.It is allowed to add new order only with prices less\r\nthan the best offer (if you want to buy stock for higher price, then\r\ninstead of adding an order you should accept the best offer). Similarly,\r\none couldn’t add a new order with price less or equal to the best offer.\r\nFor example, you can’t add a new offer \" 20\" if there is already an\r\noffer \" 20\" or \" 25\" in this case you just accept the best offer.You\r\nhave a damaged order book log (in the beginning the are no orders in\r\nbook). Every action has one of the two types: \" p\" denotes adding a new\r\norder with price p and unknown direction. The order must not contradict\r\nwith orders still not removed from the order book. \" p\" denotes\r\naccepting an existing best offer with price p and unknown direction.The\r\ndirections of all actions are lost. Information from the log isn’t\r\nalways enough to determine these directions. Count the number of ways to\r\ncorrectly restore all action directions so that all the described\r\nconditions are satisfied at any moment. Since the answer could be large,\r\noutput it modulo 10^9 + 7. If it is impossible to correctly restore\r\ndirections, then output 0.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst ll MOD = 1e9 + 7;\n\nint n;\nset<int> ss;\n\nset<int> buy;\nset<int> sell;\n\nvoid no() {\n\tcout << 0 << \"\\n\";\n\texit(0);\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tll ans = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring s;\n\t\tint p;\n\t\tcin >> s >> p;\n\t\tif (s.size() == 3) {\n\t\t\tif (!buy.empty() && *buy.rbegin() >= p) {\n\t\t\t\tbuy.insert(p);\n\t\t\t}\n\t\t\telse if (!sell.empty() && *sell.begin() <= p) {\n\t\t\t\tsell.insert(p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tss.insert(p);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!buy.empty() && *buy.rbegin() > p)\n\t\t\t\tno();\n\t\t\tif (!sell.empty() && *sell.begin() < p)\n\t\t\t\tno();\n\t\t\tif (buy.count(p)) {\n\t\t\t\tbuy.erase(p);\n\t\t\t\tfor (int x: ss)\n\t\t\t\t\tsell.insert(x);\n\t\t\t\tss.clear();\n\t\t\t}\n\t\t\telse if (sell.count(p)) {\n\t\t\t\tsell.erase(p);\n\t\t\t\tfor (int x: ss)\n\t\t\t\t\tbuy.insert(x);\n\t\t\t\tss.clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tss.erase(p);\n\t\t\t\tans = (ans * 2) % MOD;\n\t\t\t\tfor (int x: ss) {\n\t\t\t\t\tif (x < p)\n\t\t\t\t\t\tbuy.insert(x);\n\t\t\t\t\telse\n\t\t\t\t\t\tsell.insert(x);\n\t\t\t\t}\n\t\t\t\tss.clear();\n\t\t\t}\n\t\t}\n\t}\n\tans = (ans * (ss.size() + 1)) % MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Order book.json",
    "editorial_link": "https://codeforces.com/blog/entry/61493",
    "editorial": "Keep track of a lower bound for the best sell and an upper bound for the\r\nbest buy in the order book. If we have ACCEPT with or , itâs a\r\ncontradiction and the answer does not exist. If either or , then the\r\nanswer stay the same, and if , the answer is multiplied by , because the\r\nremoved order couldâve had any direction. After an ACCEPT , the price of\r\nthe order above it is the new and the price of the order below it is the\r\nnew . If in the end there are orders with undetermined direction, the\r\nanswer is multiplied by . To maintain sets of orders with determined\r\ndirection (i.e. with prices or ) one can use std::set or\r\nstd::priority_queue in C++ or TreeSet or PriorityQueue in Java.\r\n",
    "hint": []
}