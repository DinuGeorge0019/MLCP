{
    "link": "https://codeforces.com//contest/1209/problem/F",
    "problemId": "411983",
    "problem_idx": "F",
    "shortId": "1209F",
    "contest_number": "1209",
    "problem_submissions": {
        "H": [
            60570135,
            60593253,
            60571964,
            60573026,
            60725224,
            60568078
        ],
        "G1": [
            60556287,
            60555918,
            60560660,
            60545193,
            60554924,
            60565714,
            60564847,
            60552798,
            60544388,
            60543295,
            60556776,
            60547912,
            60548472,
            60548343,
            60554445,
            60552013,
            60553528,
            60550140
        ],
        "F": [
            60551951,
            60559474,
            60551041,
            60555531,
            60550649,
            60550897,
            60556467,
            60559990,
            60548723,
            60548870,
            60575790,
            60552616,
            60555309,
            60557639,
            60553869,
            60548929,
            60549043,
            60560725
        ],
        "E1": [
            60550756,
            60549748,
            60556687,
            60542418,
            60544279,
            60546177,
            60548542,
            60550504,
            60541823,
            60540929,
            60549430,
            60545745,
            60545737,
            60545738,
            60546288,
            60556058,
            60558038,
            60546083
        ],
        "E2": [
            60550484,
            60549405,
            60556943,
            60542599,
            60544405,
            60546112,
            60548494,
            60550663,
            60542010,
            60541156,
            60549544,
            60546078,
            60546087,
            60546121,
            60546350,
            60556107,
            60589552,
            60589526,
            60589450,
            60589386,
            60588908,
            60588877,
            60579849,
            60579734,
            60579573,
            60558088,
            60546300
        ],
        "D": [
            60539597,
            60542953,
            60544285,
            60538671,
            60541008,
            60541094,
            60543213,
            60542943,
            60537333,
            60538028,
            60540579,
            60538998,
            60541063,
            60539296,
            60540559,
            60539902,
            60539449,
            60540533
        ],
        "C": [
            60538071,
            60541013,
            60542624,
            60537384,
            60538008,
            60539883,
            60540890,
            60540668,
            60537787,
            60537103,
            60538560,
            60537646,
            60538820,
            60541917,
            60538555,
            60538406,
            60537838,
            60538612
        ],
        "B": [
            60534755,
            60535450,
            60536787,
            60534226,
            60534529,
            60537069,
            60535685,
            60535878,
            60534260,
            60533467,
            60534967,
            60535176,
            60536131,
            60536594,
            60535887,
            60533931,
            60532807,
            60535219
        ],
        "A": [
            60532612,
            60532698,
            60532910,
            60532511,
            60532605,
            60536220,
            60532574,
            60532833,
            60532652,
            60532527,
            60532568,
            60532602,
            60532828,
            60533109,
            60532549,
            60532535,
            60534221,
            60532564
        ],
        "G2": [
            60566672,
            60567960,
            60565628,
            60564728,
            60572926,
            60607969,
            60701078,
            60577013,
            60576902,
            60576886
        ]
    },
    "name": "F. Koala and Notebook",
    "statement": "Koala Land consists of m bidirectional roads connecting n cities. The\r\nroads are numbered from 1 to m by order in input. It is guaranteed, that\r\none can reach any city from every other city.Koala starts traveling from\r\ncity 1. Whenever he travels on a road, he writes its number down in his\r\nnotebook. He doesn\u2019t put spaces between the numbers, so they all get\r\nconcatenated into a single number.Before embarking on his trip, Koala is\r\ncurious about the resulting number for all possible destinations. For\r\neach possible destination, what is the smallest number he could have\r\nwritten for it?Since these numbers may be quite large, print their\r\nremainders modulo 10^9+7. Please note, that you need to compute the\r\nremainder of the minimum possible number, the minimum possible\r\nremainder.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int M=1010000,N=101000;\nint n,m;\nVI dg[N];\nVI e[M][10],q[M];\nint vis[M],t;\nll dp[M];\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,m+1) {\n\t\tint x=i;\n\t\twhile (x) dg[i].pb(x%10),x/=10;\n\t\treverse(all(dg[i]));\n\t}\n\tint cc=n;\n\trep(i,1,m+1) {\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tauto add=[&](int u,int v,int id) {\n\t\t\tint pre=u;\n\t\t\trep(i,0,SZ(dg[id])) {\n\t\t\t\tint np=(i==SZ(dg[id])-1)?v:++cc;\n\t\t\t\te[pre][dg[id][i]].pb(np);\n\t\t\t\tpre=np;\n\t\t\t}\n\t\t};\n\t\tadd(u,v,i);\n\t\tadd(v,u,i);\n\t}\n\tq[t++].pb(1);\n\tdp[1]=0;\n\tvis[1]=1;\n\trep(i,0,t) {\n\t\trep(j,0,10) {\n\t\t\tbool ex=0;\n\t\t\tfor (auto u:q[i]) for (auto v:e[u][j]) {\n\t\t\t\tif (!vis[v]) {\n\t\t\t\t\tvis[v]=1;\n\t\t\t\t\tex=1;\n\t\t\t\t\tq[t].pb(v);\n\t\t\t\t\tdp[v]=(dp[u]*10+j)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ex) t++;\n\t\t}\n\t}\n\trep(i,2,n+1) printf(\"%lld\\n\",dp[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "shortest paths",
        "strings",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Koala and Notebook.json",
    "editorial_link": "https://codeforces.com/blog/entry/69791",
    "editorial": "First split all edges into directed edges with single digit labels, creating O(mlogm)\n dummy vertices if necessary.\n\nSince the first edge will not be zero (no leading zeros), longer paths are always greater. With a BFS, this reduces the problem to finding lexicographical minimal paths in a DAG.\n\nTo avoid needing to compare long sequences, we will instead visit all the vertices in order by their lexicographical minimal path. This can be done efficiently by something like BFS/DFS.\n\nThe main idea is to visit sets of vertices at a time. If we have a set of vertices whose minimal paths are P\n, we can find the set of vertices whose minimal paths are P0\n by following all outgoing 0\n edges. Then, we find the set of vertices whose minimal paths are P1\n by following all outgoing 1\n edges, and so on for all digits. Since we ignore vertices once they are visited, this is O(mlogm)"
}