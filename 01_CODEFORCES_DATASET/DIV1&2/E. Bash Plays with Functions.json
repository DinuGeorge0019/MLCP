{"link": "https://codeforces.com//contest/757/problem/E", "problemId": "88532", "problem_idx": "E", "shortId": "757E", "contest_number": "757", "problem_submissions": {"F": [32228238, 32220657, 32216667, 32216552, 30180757, 24068926, 24068888, 24068798, 24068629, 24068020, 23762892, 23760952, 23776891, 23764568, 23762696, 23763271, 23761197, 23764419, 23761836, 23846483, 23765505, 23762407, 23766587, 23766646, 23767253, 23767207, 23767008, 23767913, 23761400], "G": [23782048, 23772049, 23771661, 23771463], "D": [23749937, 23749579, 23748811, 23749322, 23755716, 23754682, 23757768, 23754805, 23755156, 23752956, 23758947, 23752935, 23758202, 23754949, 23757044, 23760439, 23761231, 23760141, 23748525], "C": [23747486, 23744300, 23743556, 23745034, 23746542, 23748856, 23755316, 23748726, 23749207, 23747491, 23752146, 23747894, 23750245, 23746080, 23751561, 23747227, 23747661, 23744168], "E": [23746626, 23754640, 23751784, 23751547, 23750068, 23759139, 23752714, 23760482, 23759055, 23761627, 23755834, 23761719, 23760932, 23763128, 23759765, 23757483, 23764011, 23741658, 23752894], "B": [23740589, 23741483, 23740480, 23740520, 23742781, 23741337, 23746337, 23742823, 23741509, 23741548, 23745601, 23743745, 23742092, 23740912, 23741886, 23742317, 23743047, 23746203, 23741743], "A": [23740335, 23739759, 23739764, 23739789, 23739801, 23739786, 23739911, 23740392, 23739871, 23740001, 23740128, 23739744, 23740216, 23765002, 23754212, 23766705, 23742440, 23748544, 23739773]}, "name": "E. Bash Plays with Functions", "statement": "Bash got tired on his journey to become the greatest Pokemon master. So\r\nhe decides to take a break and play with functions.Bash defines a\r\nfunction , which denotes the number of ways of factoring into two\r\nfactors and such that . In other words, is the number of ordered pairs\r\nof positive integers such that and .But Bash felt that it was too easy\r\nto calculate this function. So he defined a series of functions, where\r\nis defined as:Where is any ordered pair of positive integers, they need\r\nnot to be co-prime.Now Bash wants to know the value of for different and\r\n. Since the value could be huge, he would like to know the value modulo\r\n. Help him!\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\nconst int N = 1010101;\nconst int ALPHA = 21;\n\nint f[N][ALPHA];\nint p[N];\nint a[N];\nint dp[777][777];\n\nint main() {\n  for (int j = 0; j < ALPHA; j++) {\n    f[0][j] = (j == 0);\n  }\n  for (int i = 1; i < N; i++) {\n    int sum = 0;\n    for (int j = 0; j < ALPHA; j++) {\n      add(sum, f[i - 1][j]);\n      f[i][j] = sum;\n    }\n  }\n  for (int i = 1; i < N; i++) {\n    p[i] = i;\n  }\n  for (int i = 2; i < N; i++) {\n    if (p[i] == i) {\n      for (int j = i + i; j < N; j += i) {\n        if (p[j] == j) {\n          p[j] = i;\n        }\n      }\n    }\n  }\n  int tt;\n  scanf(\"%d\", &tt);\n  while (tt--) {\n    int r, n;\n    scanf(\"%d %d\", &r, &n);\n    int cnt = 0;\n    int tmp = n;\n    while (tmp > 1) {\n      int d = p[tmp];\n      a[cnt] = 0;\n      while (tmp % d == 0) {\n        a[cnt]++;\n        tmp /= d;\n      }\n      cnt++;\n    }\n    for (int i = 0; i <= cnt; i++) {\n      for (int j = 0; j <= i; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i < cnt; i++) {\n      for (int j = 0; j <= i; j++) {\n        add(dp[i + 1][j], mul(dp[i][j], f[r][a[i]]));\n        add(dp[i + 1][j + 1], mul(dp[i][j], f[r + 1][a[i] - 1]));\n      }\n    }\n    int ans = 0;\n    for (int j = cnt; j >= 0; j--) {\n      add(ans, ans);\n      add(ans, dp[cnt][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "dp", "number theory"], "dificulty": "2500", "interactive": false}