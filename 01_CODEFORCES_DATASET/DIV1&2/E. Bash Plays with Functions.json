{
    "link": "https://codeforces.com//contest/757/problem/E",
    "problemId": "88532",
    "problem_idx": "E",
    "shortId": "757E",
    "contest_number": "757",
    "problem_submissions": {
        "F": [
            32228238,
            32220657,
            32216667,
            32216552,
            30180757,
            24068926,
            24068888,
            24068798,
            24068629,
            24068020,
            23762892,
            23760952,
            23776891,
            23764568,
            23762696,
            23763271,
            23761197,
            23764419,
            23761836,
            23846483,
            23765505,
            23762407,
            23766587,
            23766646,
            23767253,
            23767207,
            23767008,
            23767913,
            23761400
        ],
        "G": [
            23782048,
            23772049,
            23771661,
            23771463
        ],
        "D": [
            23749937,
            23749579,
            23748811,
            23749322,
            23755716,
            23754682,
            23757768,
            23754805,
            23755156,
            23752956,
            23758947,
            23752935,
            23758202,
            23754949,
            23757044,
            23760439,
            23761231,
            23760141,
            23748525
        ],
        "C": [
            23747486,
            23744300,
            23743556,
            23745034,
            23746542,
            23748856,
            23755316,
            23748726,
            23749207,
            23747491,
            23752146,
            23747894,
            23750245,
            23746080,
            23751561,
            23747227,
            23747661,
            23744168
        ],
        "E": [
            23746626,
            23754640,
            23751784,
            23751547,
            23750068,
            23759139,
            23752714,
            23760482,
            23759055,
            23761627,
            23755834,
            23761719,
            23760932,
            23763128,
            23759765,
            23757483,
            23764011,
            23741658,
            23752894
        ],
        "B": [
            23740589,
            23741483,
            23740480,
            23740520,
            23742781,
            23741337,
            23746337,
            23742823,
            23741509,
            23741548,
            23745601,
            23743745,
            23742092,
            23740912,
            23741886,
            23742317,
            23743047,
            23746203,
            23741743
        ],
        "A": [
            23740335,
            23739759,
            23739764,
            23739789,
            23739801,
            23739786,
            23739911,
            23740392,
            23739871,
            23740001,
            23740128,
            23739744,
            23740216,
            23765002,
            23754212,
            23766705,
            23742440,
            23748544,
            23739773
        ]
    },
    "name": "E. Bash Plays with Functions",
    "statement": "Bash got tired on his journey to become the greatest Pokemon master. So\r\nhe decides to take a break and play with functions.Bash defines a\r\nfunction , which denotes the number of ways of factoring into two\r\nfactors and such that . In other words, is the number of ordered pairs\r\nof positive integers such that and .But Bash felt that it was too easy\r\nto calculate this function. So he defined a series of functions, where\r\nis defined as:Where is any ordered pair of positive integers, they need\r\nnot to be co-prime.Now Bash wants to know the value of for different and\r\n. Since the value could be huge, he would like to know the value modulo\r\n. Help him!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\nconst int N = 1010101;\nconst int ALPHA = 21;\n\nint f[N][ALPHA];\nint p[N];\nint a[N];\nint dp[777][777];\n\nint main() {\n  for (int j = 0; j < ALPHA; j++) {\n    f[0][j] = (j == 0);\n  }\n  for (int i = 1; i < N; i++) {\n    int sum = 0;\n    for (int j = 0; j < ALPHA; j++) {\n      add(sum, f[i - 1][j]);\n      f[i][j] = sum;\n    }\n  }\n  for (int i = 1; i < N; i++) {\n    p[i] = i;\n  }\n  for (int i = 2; i < N; i++) {\n    if (p[i] == i) {\n      for (int j = i + i; j < N; j += i) {\n        if (p[j] == j) {\n          p[j] = i;\n        }\n      }\n    }\n  }\n  int tt;\n  scanf(\"%d\", &tt);\n  while (tt--) {\n    int r, n;\n    scanf(\"%d %d\", &r, &n);\n    int cnt = 0;\n    int tmp = n;\n    while (tmp > 1) {\n      int d = p[tmp];\n      a[cnt] = 0;\n      while (tmp % d == 0) {\n        a[cnt]++;\n        tmp /= d;\n      }\n      cnt++;\n    }\n    for (int i = 0; i <= cnt; i++) {\n      for (int j = 0; j <= i; j++) {\n        dp[i][j] = 0;\n      }\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i < cnt; i++) {\n      for (int j = 0; j <= i; j++) {\n        add(dp[i + 1][j], mul(dp[i][j], f[r][a[i]]));\n        add(dp[i + 1][j + 1], mul(dp[i][j], f[r + 1][a[i] - 1]));\n      }\n    }\n    int ans = 0;\n    for (int j = cnt; j >= 0; j--) {\n      add(ans, ans);\n      add(ans, dp[cnt][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "number theory"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Bash Plays with Functions.json",
    "editorial_link": "https://codeforces.com//blog/entry/49743",
    "editorial": "Main idea: Multiplicative Functions.\n\nWe can easily see that f0 = 2(number of distinct prime factors of n). We can also see that it is a multiplicative function.\n\nWe can also simplify the definition of fr?+?1 as:\n\n\nSince f0 is a multiplicative function, fr?+?1 is also a multiplicative function. (by property of multiplicative functions)\n\nFor each query, factorize n.\n\nNow, since fr is a multiplicative function, if n can be written as:\n\nn?=?p1e1p2e2 ... pqeq\nThen fr(n) can be computed as:\n\nfr(n)?=?fr(p1e1)?*?fr(p2e2)?*?...?*?fr(pqeq)\nNow observe that the value of fr(pn) is independent of p, as f0(pn)?=?2. It is dependent only on n. So we calculate fr(2x) for all r and x using a simple R?*?20 DP as follows:\n\n\nAnd now we can quickly compute fr(n) for each query as:\n\nfr(n)?=?dp[r][e1]?*?dp[r][e2]?*?...?*?dp[r][eq]"
}