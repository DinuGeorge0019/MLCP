{
    "link": "https://codeforces.com//contest/1774/problem/E",
    "problemId": "1697945",
    "problem_idx": "E",
    "shortId": "1774E",
    "contest_number": "1774",
    "problem_submissions": {
        "G": [
            185692788,
            185688701,
            185709786,
            185704068,
            185700930,
            185701804,
            185702434,
            185710209,
            185706872,
            185904256,
            185795210,
            185793397,
            185819250
        ],
        "F2": [
            185676745,
            185670281,
            185675729,
            185668671,
            185681524,
            185686567,
            185677180,
            185669013,
            185668157,
            185689966,
            185688723,
            185695825,
            185693474,
            185692885,
            185688234,
            185691854,
            185681271,
            185694474,
            185685579
        ],
        "F1": [
            185676593,
            185670463,
            185663684,
            185668833,
            185681601,
            185716882,
            185686479,
            185674297,
            185669194,
            185668049,
            185679440,
            185670075,
            185683714,
            185693266,
            185692482,
            185683082,
            185681999,
            185681061,
            185687683,
            185683570
        ],
        "E": [
            185655499,
            185660825,
            185651479,
            185656124,
            185655058,
            185662458,
            185662357,
            185652494,
            185657012,
            185662649,
            185653972,
            185662778,
            185664782,
            185668838,
            185669645,
            185656956,
            185667038,
            185672369,
            185663098
        ],
        "D": [
            185649610,
            185653248,
            185643125,
            185650993,
            185649142,
            185653531,
            185657439,
            185657348,
            185650869,
            185657200,
            185661330,
            185657425,
            185655644,
            185661084,
            185663734,
            185649769,
            185662028,
            185662351,
            185658693
        ],
        "A": [
            185644231,
            185636102,
            185635462,
            185635619,
            185635678,
            185635790,
            185637888,
            185635854,
            185636970,
            185636959,
            185635664,
            185635988,
            185635613,
            185637777,
            185636615,
            185635469,
            185636037,
            185640093,
            185635898
        ],
        "B": [
            185642990,
            185641490,
            185645977,
            185640363,
            185639666,
            185641314,
            185642797,
            185639691,
            185640833,
            185692584,
            185643672,
            185638403,
            185645169,
            185646911,
            185640445,
            185643451,
            185646071,
            185642995
        ],
        "C": [
            185639008,
            185648162,
            185647183,
            185644645,
            185643844,
            185645738,
            185648229,
            185644184,
            185645698,
            185650776,
            185648822,
            185648683,
            185646713,
            185653638,
            185655962,
            185643940,
            185653656,
            185654108,
            185651616
        ]
    },
    "name": "E. Two Chess Pieces",
    "statement": "Cirno_9baka has a tree with n nodes. He is willing to share it with you,\r\nwhich means you can operate on it.Initially, there are two chess pieces\r\non the node 1 of the tree. In one step, you can choose any piece, and\r\nmove it to the neighboring node. You are also given an integer d. You\r\nneed to ensure that the distance between the two pieces doesn\u2019t exceed\r\nd.Each of these two pieces has a sequence of nodes which they need to\r\npass , and eventually, they have to return to the root. As a curious\r\nboy, he wants to know the minimum steps you need to take.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nvector<int> g[N];\nbool a[2][N];\nint st[N];\nint sz;\nint n, d;\n\nvoid dfs(int v, int par) {\n\tif (sz >= d) {\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\ta[k ^ 1][st[sz - d]] |= a[k][v];\n\t}\n\tst[sz++] = v;\n\tfor (int u : g[v]) if (u != par)\n\t\tdfs(u, v);\n\tif (par != 0) {\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\ta[k][par] |= a[k][v];\n\t}\n\tsz--;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &d);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\ta[0][1] = a[1][1] = 1;\n\tfor (int k = 0; k < 2; k++) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\twhile(m--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\ta[k][v] = 1;\n\t\t}\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tans += a[0][i];\n\t\tans += a[1][i];\n\t}\n\tprintf(\"%d\\n\", 2 * ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Two Chess Pieces.json",
    "editorial_link": "https://codeforces.com//blog/entry/110184",
    "editorial": "SolutionWe can find that for any -th ancestor of some , the first piece\r\nmust pass it some time. Otherwise, we will violate the distance limit.\r\nThe second piece must pass the -th ancestor of each as well. Then we can\r\nadd the -th ancestor of each to the array , and add the -th ancestor of\r\neach to the array .Then we can find now we can find a solution that each\r\npiece only needs to visit its nodes using the shortest route, without\r\nconsidering the limit of , and the total length can be easily computed.\r\nWe can find that if we adopt the strategy that we visit these nodes\r\naccording to their DFS order(we merge the array of and , and sort them\r\naccording to the DFS order, if the first one is from , we try to move\r\nthe first piece to this position, otherwise use the second piece), and\r\nmove the other piece one step closer to the present piece only if the\r\nnext step of the present piece will violate the distance limit, then we\r\ncan ensure the movement exactly just let each piece visit its necessary\r\nnode without extra operations.\r\n"
}