{
    "link": "https://codeforces.com//contest/724/problem/B",
    "problemId": "74851",
    "problem_idx": "B",
    "shortId": "724B",
    "contest_number": "724",
    "problem_submissions": {
        "G": [
            21292263,
            21289389,
            21296363,
            21288425,
            21294631,
            21287775,
            21293574,
            21292770,
            21291944,
            21288934,
            21292172,
            21288247,
            21292559,
            21295809,
            21290880,
            21290578,
            21290415,
            21293943
        ],
        "E": [
            21288925,
            21292133,
            21297352,
            21291033,
            21288200,
            23659645,
            21290576,
            21290313,
            21292937,
            21296159,
            21294663,
            21290237,
            21296769,
            21292864,
            21297544,
            23608572
        ],
        "F": [
            21288190,
            21295097,
            21291428,
            21408768,
            21292926,
            21298468,
            145553208,
            21294689
        ],
        "D": [
            21285401,
            21285608,
            21286235,
            21283645,
            21284412,
            21288117,
            21285995,
            21287478,
            21286772,
            21286376,
            21289028,
            21285265,
            21288845,
            21286726,
            21290761,
            21285673,
            21284100,
            21286467,
            21288075
        ],
        "B": [
            21284134,
            21280714,
            21282752,
            21281462,
            21280744,
            21282751,
            21280902,
            21282004,
            21281773,
            21281431,
            21281779,
            21284722,
            21286664,
            21280972,
            21281353,
            21282957,
            21282648
        ],
        "C": [
            21283255,
            21284495,
            21288232,
            21285743,
            21285969,
            21285870,
            21284787,
            21286083,
            21285861,
            21284725,
            21286899,
            21284034,
            21287013,
            21285582,
            21297034,
            21283106,
            21286310,
            21285066,
            21286458
        ],
        "A": [
            21280305,
            21279735,
            21280413,
            21279914,
            21280000,
            21280810,
            21279870,
            21279953,
            21279966,
            21279817,
            21280008,
            21279884,
            21281495,
            21279783,
            21281061,
            21279908,
            21279971,
            21280674,
            21280506
        ]
    },
    "name": "B. Batch Sort",
    "statement": "You are given a table consisting of rows and columns.Numbers in each row\r\nform a permutation of integers from to .You are allowed to pick two\r\nelements in one row and swap them, but for each row. Also, you are\r\nallowed to pick two columns and swap them. Thus, you are allowed to\r\nperform from to actions in total. .You have to check whether itâ€™s\r\npossible to obtain the identity permutation in each row. In other words,\r\ncheck if one can perform some of the operation following the given rules\r\nand make each row sorted in increasing order.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint p[30][30],n,m;\nbool check() {\n\trep(i,0,n) {\n\t\tint cnt=0;\n\t\trep(j,0,m) cnt+=p[i][j]!=j+1;\n\t\tif (cnt>2) return 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,n) rep(j,0,m) scanf(\"%d\",&p[i][j]);\n\trep(a,0,m) rep(b,a,m) {\n\t\trep(i,0,n) swap(p[i][a],p[i][b]);\n\t\tif (check()) {\n\t\t\tputs(\"YES\");\n\t\t\treturn 0;\n\t\t}\n\t\trep(i,0,n) swap(p[i][a],p[i][b]);\n\t}\n\tputs(\"NO\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Batch Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/47644",
    "editorial": "Order of swaps of numbers in each row is not important. In fact, the\r\norder is not important even when we will swap the entire columns\r\n(because we can always change the swaps in the rows so that the result\r\nwill remain the same).Therefore we can choose columns which we will swap\r\n(or choose not to swap them at all), and then for each row check if we\r\ncan arrange the numbers in ascending order using only one swap.This can\r\nbe done by checking that all the numbers, except for maybe two of them,\r\nare already standing in their places.\r\n",
    "hint": []
}