{
    "link": "https://codeforces.com//contest/1209/problem/G2",
    "problemId": "411985",
    "problem_idx": "G2",
    "shortId": "1209G2",
    "contest_number": "1209",
    "problem_submissions": {
        "H": [
            60570135,
            60593253,
            60571964,
            60573026,
            60725224,
            60568078
        ],
        "G1": [
            60556287,
            60555918,
            60560660,
            60545193,
            60554924,
            60565714,
            60564847,
            60552798,
            60544388,
            60543295,
            60556776,
            60547912,
            60548472,
            60548343,
            60554445,
            60552013,
            60553528,
            60550140
        ],
        "F": [
            60551951,
            60559474,
            60551041,
            60555531,
            60550649,
            60550897,
            60556467,
            60559990,
            60548723,
            60548870,
            60575790,
            60552616,
            60555309,
            60557639,
            60553869,
            60548929,
            60549043,
            60560725
        ],
        "E1": [
            60550756,
            60549748,
            60556687,
            60542418,
            60544279,
            60546177,
            60548542,
            60550504,
            60541823,
            60540929,
            60549430,
            60545745,
            60545737,
            60545738,
            60546288,
            60556058,
            60558038,
            60546083
        ],
        "E2": [
            60550484,
            60549405,
            60556943,
            60542599,
            60544405,
            60546112,
            60548494,
            60550663,
            60542010,
            60541156,
            60549544,
            60546078,
            60546087,
            60546121,
            60546350,
            60556107,
            60589552,
            60589526,
            60589450,
            60589386,
            60588908,
            60588877,
            60579849,
            60579734,
            60579573,
            60558088,
            60546300
        ],
        "D": [
            60539597,
            60542953,
            60544285,
            60538671,
            60541008,
            60541094,
            60543213,
            60542943,
            60537333,
            60538028,
            60540579,
            60538998,
            60541063,
            60539296,
            60540559,
            60539902,
            60539449,
            60540533
        ],
        "C": [
            60538071,
            60541013,
            60542624,
            60537384,
            60538008,
            60539883,
            60540890,
            60540668,
            60537787,
            60537103,
            60538560,
            60537646,
            60538820,
            60541917,
            60538555,
            60538406,
            60537838,
            60538612
        ],
        "B": [
            60534755,
            60535450,
            60536787,
            60534226,
            60534529,
            60537069,
            60535685,
            60535878,
            60534260,
            60533467,
            60534967,
            60535176,
            60536131,
            60536594,
            60535887,
            60533931,
            60532807,
            60535219
        ],
        "A": [
            60532612,
            60532698,
            60532910,
            60532511,
            60532605,
            60536220,
            60532574,
            60532833,
            60532652,
            60532527,
            60532568,
            60532602,
            60532828,
            60533109,
            60532549,
            60532535,
            60534221,
            60532564
        ],
        "G2": [
            60566672,
            60567960,
            60565628,
            60564728,
            60572926,
            60607969,
            60701078,
            60577013,
            60576902,
            60576886
        ]
    },
    "name": "G2. Into Blocks  hard version ",
    "statement": "A sequence of integers is called if its elements are arranged in blocks\r\nlike in [3, 3, 3, 4, 1, 1]. Formally, if two elements are equal,\r\neverything in between must also be equal.Let\u2019s define of a sequence as a\r\nminimum possible number of elements to change to get a nice sequence.\r\nHowever, if you change at least one element of value x to value y, you\r\nmust also change all other elements of value x into y as well. For\r\nexample, for [3, 3, 1, 3, 2, 1, 2] it isn\u2019t allowed to change first 1 to\r\n3 and second 1 to 2. You need to leave 1\u2019s untouched or change them to\r\nthe same value.You are given a sequence of integers a_1, a_2,\r\nldots, a_n and q updates.Each update is of form \"i x\" change a_i to x.\r\nUpdates are not independent (the change stays for the future).Print the\r\ndifficulty of the initial sequence and of the sequence after every\r\nupdate.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 3e5 + 7;\n\nint a[N];\nset <int> q[N];\nint cnt[N];\n\nstruct segm {\n  int l, r, x;\n};\n\nset <segm> e;\n\nbool operator < (const segm &a, const segm &b) {\n  return a.l < b.l;\n}\n\nconst int B = 300;\nconst int BL = B;\n\nint suf[N];\nint max_x[N];\nint jump_r[N];\nint cnt_here[N];\nint sum_here[N];\n\nvector <segm> orz[N];\n\nint w[N];\nint tr[N];\nbool vis[N];\n\nvoid rebuild_block(int l) {\n  l -= l % B;\n  static vector <segm> p;\n  p.clear();\n  for (int i = l; i < l + B && i < N; i++) {\n    if (vis[i]) {\n      p.push_back({i, tr[i], w[i]});\n    }\n  }\n  segm ret;\n  ret.l = 0;\n  ret.r = -1;\n  ret.x = 0;\n  static vector <segm> ans;\n  ans.clear();\n  for (auto c : p) {\n    if (c.l > ret.r) {\n      if (ret.r != -1) {\n        ans.push_back(ret);\n      }\n      ret = c;\n    } else {\n      ret.r = max(ret.r, c.r);\n      ret.x = max(ret.x, c.x);\n    }\n  }\n  if (ret.r != -1) {\n    ans.push_back(ret);\n  }\n  orz[l] = ans;\n  int j = -1;\n  int mx = 0;\n  int r = -1;\n  int sum = 0;\n  for (int i = l; i < l + B && i < N; i++) {\n    while (j + 1 < (int) ans.size() && ans[j + 1].l <= i) {\n      j++;\n      mx = max(mx, ans[j].x);\n      r = max(r, ans[j].r);\n      sum += ans[j].x;\n    }\n    sum_here[i] = sum;\n    cnt_here[i] = j + 1;\n    max_x[i] = mx;\n    jump_r[i] = r;\n  }\n}\n\nvoid del(int x, int i) {\n  int l = *q[x].begin(), r = *prev(q[x].end());\n  vis[l] = false;\n  e.erase({l, r, cnt[x]});\n  cnt[x]--;\n  q[x].erase(i);\n  rebuild_block(l);\n  if (cnt[x]) {\n    int l = *q[x].begin(), r = *prev(q[x].end());\n    vis[l] = true;\n    w[l] = cnt[x];\n    tr[l] = r;\n    e.insert({l, r, cnt[x]});\n    rebuild_block(l);\n  }\n}\n\nvoid add(int x, int i) {\n  if (cnt[x]) {\n    int l = *q[x].begin(), r = *prev(q[x].end());\n    vis[l] = false;\n    e.erase({l, r, cnt[x]});\n    rebuild_block(l);\n  }\n  cnt[x]++;\n  q[x].insert(i);\n  int l = *q[x].begin(), r = *prev(q[x].end());\n  vis[l] = true;\n  w[l] = cnt[x];\n  tr[l] = r;\n  e.insert({l, r, cnt[x]});\n  rebuild_block(l);\n}\n\nint ans() {\n  int vr = -1;\n  int tot = 0;\n  int gao = 0;\n  for (int i = 0; i < 200000; i += B) {\n    if (orz[i].empty()) continue;\n    if (vr <= i) {\n      tot += gao;\n      tot += sum_here[i + BL - 1] - orz[i].back().x;\n      gao = orz[i].back().x;\n      vr = orz[i].back().r;\n    } else {\n      int value = min(vr, i + BL - 1);\n      gao = max(gao, max_x[value]);\n      vr = max(vr, jump_r[value]);\n      if (cnt_here[value] != cnt_here[i + BL - 1]) {\n        tot += gao;\n        tot += sum_here[i + BL - 1] - sum_here[value] - orz[i].back().x;\n        gao = orz[i].back().x;\n        vr = orz[i].back().r;\n      }\n    }\n  }\n  return tot + gao;\n}\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n = 200000, tq = 200000;\n  cin >> n >> tq;\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n    q[a[i]].insert(i);\n    cnt[a[i]]++;\n    //add(a[i], i);\n  }\n  for (int i = 0; i < N; i++)  {\n    if (!q[i].empty()) {\n      vis[*q[i].begin()] = true;\n      w[*q[i].begin()] = cnt[i];\n      tr[*q[i].begin()] = *q[i].rbegin();\n      e.insert({*q[i].begin(), *q[i].rbegin(), cnt[i]});\n    }\n  }\n  for (int i = 0; i < N; i += BL) {\n    rebuild_block(i);\n  }\n  cout << n - ans() << '\\n';\n  for (int j = 0; j < tq; j++) {\n    int i, x;\n    cin >> i >> x;\n    i--, x--;\n    del(a[i], i);\n    a[i] = x;\n    add(a[i], i);\n    cout << n - ans() << '\\n';\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G2. Into Blocks  hard version .json",
    "editorial_link": "https://codeforces.com/blog/entry/69791",
    "editorial": "To adjust the solution for many queries we need to create some\r\nsophisticated data structure. E.g. we all know that mentioned above \"+=\r\n1 on a segment\" is easily done with a segtree. If we maintain for every\r\nvalue the corresponding set of occurrences, it\u00e2\u0080\u0099s easy to update\r\nmentioned above \u00e2\u0080\u009cnumber of occurrences in the first position\u00e2\u0080\u009d. So what\r\nwe need to do now? We need to dynamically recalculate the sum of\r\nminimums (and the set segments to calculate minimum can change quite\r\nmuch due to updates). You probably also now that we can design a segtree\r\nwhich supports range increments and query (minimum, number of minimums)\r\non the segment. In a similar way we can build a structure which returns\r\n(minimum, number of minimums, the sum of largest stored counts between\r\nminimums). Just maintain a few values in each node and do lazy\r\npropagation. Complexity . Code\r\n"
}