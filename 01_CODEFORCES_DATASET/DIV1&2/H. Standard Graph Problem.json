{
    "link": "https://codeforces.com//contest/1870/problem/H",
    "problemId": "2216421",
    "problem_idx": "H",
    "shortId": "1870H",
    "contest_number": "1870",
    "problem_submissions": {
        "G": [
            225207978,
            225118072,
            225116519,
            225114767,
            225113735,
            225113326,
            223895142,
            223905506,
            223908839,
            223914354,
            223924067,
            223915464,
            224102694,
            224102570,
            224101929,
            224101915,
            224101882,
            223930185,
            223922526,
            223898384,
            223902193
        ],
        "H": [
            223910262,
            223971766,
            225204927,
            223912817
        ],
        "F": [
            223881664,
            223880000,
            223885884,
            223900845,
            223885822,
            223925076,
            223908747,
            223887023,
            223881416,
            223893441,
            223967145,
            223892630,
            223898214,
            223897234,
            223895227,
            223893254,
            223897195,
            223887464,
            223885585,
            223897533
        ],
        "E": [
            223869750,
            223870667,
            223875420,
            223879930,
            223894576,
            223875622,
            223877104,
            223888049,
            223879090,
            223876643,
            223870896,
            223878535,
            223873841,
            223880057,
            223880667,
            223881985,
            223871304,
            223980583,
            223900716,
            223895756,
            223883035
        ],
        "D": [
            223864393,
            223860234,
            223865660,
            223863718,
            223865473,
            223859881,
            223865206,
            223867969,
            223868314,
            223865007,
            223866155,
            223863717,
            223863491,
            223869388,
            223869302,
            223866987,
            223863771,
            223868821,
            223873483,
            223869884
        ],
        "C": [
            223858926,
            223856692,
            223860376,
            223856772,
            223861967,
            223857013,
            223862311,
            223860027,
            223860530,
            223857444,
            223858871,
            223859210,
            223859070,
            223862641,
            223864669,
            223860558,
            223859030,
            223856443,
            223870325,
            223863825
        ],
        "B": [
            223855786,
            223853418,
            223854541,
            223852626,
            223857522,
            223852531,
            223856711,
            223853615,
            223855334,
            223852785,
            223853742,
            223853640,
            223854539,
            223856641,
            223856452,
            223856337,
            223854108,
            223864851,
            223860995,
            223858101
        ],
        "A": [
            223852532,
            223851971,
            223852416,
            223851983,
            223854260,
            223851952,
            223853042,
            223852087,
            223852502,
            223853463,
            223852096,
            223852189,
            223852238,
            223852875,
            223853328,
            223852660,
            223852270,
            223860422,
            223858579,
            223854841
        ]
    },
    "name": "H. Standard Graph Problem",
    "statement": "You are given a weighted directed graph with n vertices and m edges.\r\nEach vertex in the graph can be either highlighted or normal. Initially,\r\nall vertices are normal. The cost of the graph is defined as the minimum\r\nsum of edge weights that need to be selected so that from each normal\r\nvertex one can reach at least one highlighted vertex using the selected\r\nedges only. If it is not possible to select the edges, the cost is -1\r\ninstead.Your task is to compute the cost of the graph after each of the\r\nq queries. The queries can be of two types: +\r\n;v_i makes vertex v_i highlighted; it is guaranteed that the vertex is\r\nnormal before the query. -\r\n;v_i makes vertex v_i normal; it is guaranteed that the vertex is\r\nhighlighted before the query. Output the cost of the graph after each of\r\nthe q queries.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \n#define int long long \nusing namespace std;\nconst int N = 1 << 20;\n\n#define INF 1000000001\nint q; \nint pts[N];\nvi e[N];\n\nll val[N];\n\nnamespace lsq { // https://www.cnblogs.com/lsq147/p/17029129.html\n\nint n, m;\nconst int maxn=200005,maxm=400005;\nstruct Val{\n\tint u,v,w;\n\tVal(int u=0,int v=0,int w=0):\n\t\tu(u),v(v),w(w){}\n\tVal operator += (const int o){\n\t\tthis->w=this->w+o;return *this;\n\t}\n\tbool operator < (const Val o)const{\n\t\treturn w<o.w;\n\t}\n};\nstruct Node{\n\tint l,r,dis,laz;Val v;\n\tNode(int l=0,int r=0,int dis=0,int laz=0,Val v=Val()):\n\t\tl(l),r(r),dis(dis),laz(laz),v(v){}\n}P[maxm];\nint tot;\nvoid push(int x,int laz){\n\tP[x].laz+=laz;\n\tP[x].v+=laz;\n}\nvoid pushdown(int x){\n\tif(!P[x].laz)return;\n\tpush(P[x].l,P[x].laz);\n\tpush(P[x].r,P[x].laz);\n\tP[x].laz=0;\n}\nvoid pushup(int x){\n\tif(P[P[x].l].dis<P[P[x].r].dis)\n\t\tstd::swap(P[x].l,P[x].r);\n\tP[x].dis=P[P[x].r].dis+1;\n}\nint newnode(Val v){\n\tP[++tot]=Node(0,0,1,0,v);\n\treturn tot;\n}\nvoid merge(int&x,int l,int r){\n\tif(!l||!r)return x=l|r,void();\n\tpushdown(l);pushdown(r);\n\tif(P[r].v<P[l].v)l^=r^=l^=r;\n\tx=l;merge(P[x].r,P[l].r,r);\n\treturn pushup(x);\n}\nvoid pop(int&x){\n\tpushdown(x);\n\tmerge(x,P[x].l,P[x].r);\n}\nint rt[maxn*2];\nint fa[maxn*2];\nint vis[maxn*2],cnt;\nint st[maxn],tp;\nint rn;\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nint val[maxn*2];\nint son[maxn*2],bro[maxn*2],pa[maxn*2];\nvoid ade(int u,int v){\n//\tprintf(\"ade %d %d %lld\\n\",u,v,val[v]);\n\tbro[v]=son[u],son[u]=v;pa[v]=u;\n}\nvoid dfs(int u){\n\tif(vis[u]&&vis[u]<cnt)return void();\n\tif(vis[u]==cnt){\n\t\t++rn;\n\t\twhile(st[tp+1]!=u){\n\t\t\tfa[st[tp]]=rn;ade(rn,st[tp]);\n\t\t\tmerge(rt[rn],rt[rn],rt[st[tp]]);\n\t\t\t--tp;\n\t\t}\n\t\tu=rn;\n\t}\n\tvis[u]=cnt,st[++tp]=u;\n\twhile(rt[u]&&find(P[rt[u]].v.v)==u)pop(rt[u]);\n\tif(!rt[u])return val[u]=INF,ade(0,u);\n\tVal tmp=P[rt[u]].v;val[u]=tmp.w;\n\tpop(rt[u]);push(rt[u],-tmp.w);\n\tdfs(find(tmp.v));\n\tif(find(u)==u)ade(0,u);\n\treturn;\n}\nconst int mod=998244353;\nint iac[maxn],fac[maxn];\nint getans(int u){\n\tint sz=(son[u]==0);\n\tfor(int v=son[u];v;v=bro[v]){\n\t\te[u].emplace_back(v);\n\t\tint o=getans(v);\n\t\tsz+=o;\n\t}\n\treturn sz;\n}\nvoid solve(void){\n\tcin >> n >> m >> q;\n\trn=n;\n\tfac[0]=fac[1]=iac[0]=iac[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t\tiac[i]=1ll*(mod-mod/i)*iac[mod%i]%mod;\n\tfor(int i=2;i<=n;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod,iac[i]=1ll*iac[i-1]*iac[i]%mod;\n\tfor(int i=1;i<=n*2;++i)fa[i]=i;\n\tfor(int i=1;i<=m;++i){\n\t\tint u,v,w;\n\t\tcin >> u >> v >> w;\n\t\tmerge(rt[u],rt[u],newnode(Val(u,v,w)));\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\t++cnt;dfs(i);tp=0;\n\t\t}\n\t}\n\tgetans(0);\n}\nint Main(){\n\tsolve();\n\treturn 0;\n}\n\n}\n\nint siz[N], dfn[N], en[N], mp[N], dep[N], hv[N], top[N], idt;\nint fa[N], total;\n \nvoid dfs1(int x) {\n\tsiz[x] = 1;\n\tfor(auto &v : e[x]) if(v != fa[x]) {\n\t\tfa[v] = x, dep[v] = dep[x] + 1, dfs1(v);\n\t\tsiz[x] += siz[v];\n\t\tif(siz[v] > siz[hv[x]]) \n\t\t\thv[x] = v;\n\t}\n}\n \nvoid dfs2(int x) {\n\tdfn[x] = ++idt;\n\tmp[idt] = x;\n\tif(hv[x]) {\n\t\ttop[hv[x]] = top[x];\n\t\tdfs2(hv[x]);\n\t}\n\tfor(auto&v : e[x]) if(v != fa[x] && v != hv[x]) {\n\t\ttop[v] = v, dfs2(v);\n\t}\n\ten[x] = idt;\n}\n\nvoid dfs(int x) {\n\ttotal = max(total, x);\n\tfor(auto &v : e[x]) {\n\t\tfa[v] = x;\n\t\tdfs(v); \n\t}\n}\n\nint mn[N], tag[N];\nll sum[N][2];\nvoid adt(int x, int w) {\n\ttag[x] += w;\n\tmn[x] += w; \n}\nvoid upd(int x) {\n\tmn[x] = min(mn[x * 2], mn[x * 2 + 1]);\n\tsum[x][0] = sum[x][1] = 0;\n\tL(o, 0, 1) {\n\t\tif(mn[x * 2] == mn[x]) sum[x][o] += sum[x * 2][o];\n\t\tif(mn[x * 2 + 1] == mn[x]) sum[x][o] += sum[x * 2 + 1][o];\n\t}\n}\nvoid push(int x) {\n\tif(tag[x]) adt(x * 2, tag[x]), adt(x * 2 + 1, tag[x]), tag[x] = 0;\n}\n \nvoid add(int x, int L, int R, int l, int r, int w) {\n\tif(l <= L && R <= r) {\n\t\tadt(x, w);\n\t\treturn ;\n\t}\n\tpush(x);\n\tint mid = (L + R) >> 1;\n\tif(l <= mid) add(x * 2, L, mid, l, r, w);\n\tif(r > mid) add(x * 2 + 1, mid + 1, R, l, r, w);\n\tupd(x);\n}\n \nvoid build(int x, int L, int R) {\n\tif(L == R) {\n\t\tsum[x][0] = val[L];\n\t\tsum[x][1] = val[L] == INF;\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tbuild(x * 2, L, mid);\n\tbuild(x * 2 + 1, mid + 1, R);\n\tupd(x);\n}\n\nint vis[N];\n\nint cnt[N];\nsigned main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tlsq :: Main();\n\tdfs(0);\n\t++total;\n\tdfs1(0);\n\tdfs2(0);\n\tL(i, 1, total) {\n\t\tval[i] = lsq :: val[mp[i]];\n\t}\n\tfa[0] = -1;\n\t\n\tbuild(1, 1, total);\n\tint scnt = 0;\n\twhile(q--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint pos;\n\t\tcin >> pos;\n\t\tint add = 0;\n\t\tif(s == \"+\") {\n\t\t\tadd = 1;\n\t\t\tvis[pos] = 1;\n\t\t} else {\n\t\t\tadd = -1;\n\t\t\tvis[pos] = 0;\n\t\t}\n\t\tscnt += add;\n\t\tfor(int x = pos; x != -1; x = fa[top[x]]) {\n\t\t\t::add(1, 1, total, dfn[top[x]], dfn[x], add);\n//\t\t\tL(i, dfn[top[x]], dfn[x]) {\n//\t\t\t\tcnt[i] += add;\n//\t\t\t}\n\t\t}\n\t\t\n//\t\tif(scnt == 0) {\n//\t\t\tcout << -1 << '\\n';\n//\t\t}\n\t\t\n\t\tif(mn[1] > 0) {\n\t\t\tcout << 0 << '\\n';\n\t\t} else if(sum[1][1]) {\n\t\t\tcout << -1 << '\\n';\n\t\t} else {\n\t\t\tcout << ::sum[1][0] << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Standard Graph Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/120524",
    "editorial": "TutorialLet\u00e2\u0080\u0099s unfold all the edges, now we need to ensure that all\r\nregular vertices are reachable from the selected vertices.First, you\r\nshould familiarize yourself with the algorithm for finding the ordered\r\nminimum spanning tree, also known as the Edmonds\u00e2\u0080\u0099 algorithm (I will\r\nrefer to his work here and without knowledge of it, the solution cannot\r\nbe understood). Next, it is worth noting that the compressions in the\r\nprocess of this algorithm (almost) do not depend on the root, and all\r\ncompressions can be performed as if there is no root (previously\r\ncreating dummy edges from to for from to and from vertex to vertex with\r\na cost of ). Then, after all the compressions, only one vertex will\r\nremain. Note that the difference from Edmonds\u00e2\u0080\u0099 algorithm is that if at\r\nany step of the algorithm the minimum edge from a vertex leads to the\r\nroot, compression is not necessary.So, let\u00e2\u0080\u0099s maintain a tree in which\r\neach vertex corresponds to its corresponding compressed vertex or to the\r\noriginal vertex, and the children of vertex are all the vertices that we\r\ncompressed to obtain vertex . It is implied that with each compression,\r\nwe create a new vertex.Let\u00e2\u0080\u0099s call the cost of vertex the minimum cost of\r\nan edge leaving vertex in the process of Edmonds\u00e2\u0080\u0099 algorithm (taking into\r\naccount changes in edge costs during compression in Edmonds\u00e2\u0080\u0099\r\nalgorithm).Then we need to maintain the sum of the costs of the vertices\r\nin the tree, in the subtrees of which there are no selected vertices\r\n(where the selected vertices can only be leaves). This can be easily\r\ndone using a segment tree.\r\n"
}