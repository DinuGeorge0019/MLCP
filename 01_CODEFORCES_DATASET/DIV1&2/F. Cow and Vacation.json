{"link": "https://codeforces.com//contest/1307/problem/F", "problemId": "542682", "problem_idx": "F", "shortId": "1307F", "contest_number": "1307", "problem_submissions": {"D": [71334675, 71329379, 71297375, 71300630, 71300597, 71296525, 71299736, 71299787, 71299649, 71294218, 71299266, 71353437, 71301135, 71298819, 71297533, 71302173, 71301113, 71306340, 71311289, 71303681, 71296481], "F": [71318320, 71328004, 71328410, 71313540, 71342732, 71342701, 71342679, 71342641, 71378556, 71386768, 71330817, 71353605, 71341156, 71340667, 71331133, 71325872, 71974189], "E": [71311504, 71318452, 71321704, 71329781, 71312470, 71310373, 71310234, 71311741, 71326064, 71325657, 71312968, 71315289, 71309289, 71345858, 71345831, 71345723, 71345591, 71345520, 71345206, 71344772, 71344661, 71308214, 71331493, 71309218, 71315974, 71328300, 71317669, 71329605], "G": [71303096, 71336439, 71307493, 71308346, 71320475, 71303320, 71313925, 71322572, 71322223, 71309226, 71311369, 71356337, 71319400, 71321748, 71313979, 71354003, 71316843, 71327328, 71316390, 71329594, 71321365], "C": [71291268, 71289526, 71293976, 71293545, 71288006, 71294250, 71293163, 71291197, 71300886, 71294829, 71291105, 71294718, 71292675, 71291425, 71296070, 71290915, 71292479, 71297176, 71298646, 71291499], "B": [71289205, 71287726, 71290885, 71290721, 71289353, 71290602, 71289374, 71288121, 71299427, 71291607, 71289046, 71290292, 71334215, 71288723, 71290619, 71288909, 71289266, 71289248, 71288946, 71288924], "A": [71287300, 71287160, 71287363, 71290273, 71290150, 71287273, 71287420, 71292915, 71295372, 71287966, 71287342, 71287721, 71287194, 71287212, 71288221, 71287271, 71287331, 71287368, 71290172, 71287362]}, "name": "F. Cow and Vacation", "statement": "Bessie is planning a vacation! In Cow-lifornia, there are n cities, with\r\nn-1 bidirectional roads connecting them. It is guaranteed that one can\r\nreach any city from any other city. Bessie is considering v possible\r\nvacation plans, with the i-th one consisting of a start city a_i and\r\ndestination city b_i.It is known that only r of the cities have rest\r\nstops. Bessie gets tired easily, and cannot travel across more than k\r\nconsecutive roads without resting. In fact, she is so desperate to rest\r\nthat she may travel through the same city multiple times in order to do\r\nso.For each of the vacation plans, does there exist a way for Bessie to\r\ntravel from the starting city to the destination city?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nconst int inf=1<<30;\n\nint p[N][22],dep[N],ddep[N],n,u,v,qq,k,r,mark[N],mdep;\nPII fv[N],pp[N],val[N];\nVI e[N];\n\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tp[u][0]=f;\n\tif (mark[u]) val[u]=mp(dep[u],u);\n\telse val[u]=mp(inf,-1);\n\tfor (auto v:e[u]) {\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t}\n}\n\n#define LOGN 19\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) v=p[v][i];\n\tif (u==v) return u;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) u=p[u][i],v=p[v][i];\n\treturn p[u][0];\n}\n\nint q[N],f[N],vis[N],sz[N],ms[N];\nint findd(int u) {\n\tint t=1;q[0]=u;f[u]=-1;\n\trep(i,0,t) {\n\t\tu=q[i];\n\t\trep(j,0,e[u].size()) {\n\t\t\tint v=e[u][j];\n\t\t\tif (!vis[v]&&v!=f[u]) f[q[t++]=v]=u;\n\t\t}\n\t\tms[q[i]]=0;\n\t\tsz[q[i]]=1;\n\t}\n\tfor (int i=t-1;i>=0;i--) {\n\t\tms[q[i]]=max(ms[q[i]],t-sz[q[i]]);\n\t\tif (ms[q[i]]*2<=t) return q[i];\n\t\tsz[f[q[i]]]+=sz[q[i]];\n\t\tms[f[q[i]]]=max(ms[f[q[i]]],sz[q[i]]);\n\t}\n\treturn 0;\n}\n\nVI vec;\n\nvoid dfs2(int u,int f,int dep) {\n\tif (dep>mdep) pp[dep]=mp(inf,-1),mdep=dep;\n\tpp[dep]=min(pp[dep],val[u]);\n\tddep[u]=dep;\n\tvec.pb(u);\n\tfor (auto v:e[u]) {\n\t\tif (v==f||vis[v]) continue;\n\t\tdfs2(v,u,dep+1);\n\t}\n}\n\nvoid gao(int u) {\n\tu=findd(u);\n\tvec.clear();\n\tmdep=0; pp[0]=mp(inf,-1);\n\tdfs2(u,-1,0);\n\trep(i,1,mdep+1) pp[i]=min(pp[i-1],pp[i]);\n\tfor (auto x:vec) if (ddep[x]<=k) fv[x]=min(fv[x],pp[min(mdep,k-ddep[x])]);\n\tvis[u]=1;\n\tfor (auto v:e[u]) if (!vis[v]) gao(v);\n}\n\nint dis(int u,int v) {\n\tint w=lca(u,v);\n\treturn dep[u]+dep[v]-2*dep[w];\n}\n\nint find(int x) {\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\n\nbool check(int u,int v) {\n\tif (dis(u,v)<=k) return 1;\n\tint pu=-1,pv=-1;\n\tif (fv[u].se!=-1) pu=find(fv[u].se);\n\tif (fv[v].se!=-1) pv=find(fv[v].se);\n\tif (pu!=-1&&pv!=-1&&pu==pv) return 1;\n\tif (pu!=-1&&dis(pu,v)<=k) return 1;\n\tif (pv!=-1&&dis(pv,u)<=k) return 1;\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&k,&r);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\trep(i,0,r) {\n\t\tscanf(\"%d\",&u);\n\t\tmark[u]=1;\n\t}\n\tdfs(1,0);\n\trep(j,1,LOGN) rep(i,1,n+1) p[i][j]=p[p[i][j-1]][j-1];\n\trep(i,1,n+1) fv[i]=mp(inf,-1);\n\tgao(1);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,1,n+1) if (mark[i]) {\n\t\tassert(fv[i].se!=-1);\n\t\tint u=find(i),v=find(fv[i].se);\n\t\tif (dep[u]>dep[v]) swap(u,v);\n\t\tf[v]=u;\n\t}\n\t//rep(i,1,n+1) printf(\"%d %d\\n\",fv[i].fi,fv[i].se);\n\tfor (scanf(\"%d\",&qq);qq;qq--) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tputs(check(u,v)?\"YES\":\"NO\");\n\t}\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dsu", "trees"], "dificulty": "3300", "interactive": false}