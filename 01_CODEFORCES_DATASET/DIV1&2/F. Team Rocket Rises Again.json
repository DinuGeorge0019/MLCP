{
    "link": "https://codeforces.com//contest/757/problem/F",
    "problemId": "88533",
    "problem_idx": "F",
    "shortId": "757F",
    "contest_number": "757",
    "problem_submissions": {
        "F": [
            32228238,
            32220657,
            32216667,
            32216552,
            30180757,
            24068926,
            24068888,
            24068798,
            24068629,
            24068020,
            23762892,
            23760952,
            23776891,
            23764568,
            23762696,
            23763271,
            23761197,
            23764419,
            23761836,
            23846483,
            23765505,
            23762407,
            23766587,
            23766646,
            23767253,
            23767207,
            23767008,
            23767913,
            23761400
        ],
        "G": [
            23782048,
            23772049,
            23771661,
            23771463
        ],
        "D": [
            23749937,
            23749579,
            23748811,
            23749322,
            23755716,
            23754682,
            23757768,
            23754805,
            23755156,
            23752956,
            23758947,
            23752935,
            23758202,
            23754949,
            23757044,
            23760439,
            23761231,
            23760141,
            23748525
        ],
        "C": [
            23747486,
            23744300,
            23743556,
            23745034,
            23746542,
            23748856,
            23755316,
            23748726,
            23749207,
            23747491,
            23752146,
            23747894,
            23750245,
            23746080,
            23751561,
            23747227,
            23747661,
            23744168
        ],
        "E": [
            23746626,
            23754640,
            23751784,
            23751547,
            23750068,
            23759139,
            23752714,
            23760482,
            23759055,
            23761627,
            23755834,
            23761719,
            23760932,
            23763128,
            23759765,
            23757483,
            23764011,
            23741658,
            23752894
        ],
        "B": [
            23740589,
            23741483,
            23740480,
            23740520,
            23742781,
            23741337,
            23746337,
            23742823,
            23741509,
            23741548,
            23745601,
            23743745,
            23742092,
            23740912,
            23741886,
            23742317,
            23743047,
            23746203,
            23741743
        ],
        "A": [
            23740335,
            23739759,
            23739764,
            23739789,
            23739801,
            23739786,
            23739911,
            23740392,
            23739871,
            23740001,
            23740128,
            23739744,
            23740216,
            23765002,
            23754212,
            23766705,
            23742440,
            23748544,
            23739773
        ]
    },
    "name": "F. Team Rocket Rises Again",
    "statement": "It’s the turn of the year, so Bash wants to send presents to his\r\nfriends. There are cities in the Himalayan region and they are connected\r\nby bidirectional roads. Bash is living in city . Bash has exactly one\r\nfriend in each of the other cities. Since Bash wants to surprise his\r\nfriends, he decides to send a Pikachu to each of them. . He also wants\r\nto send it to them as soon as possible.He finds out the minimum time for\r\neach of his Pikachus to reach its destination city. Since he is a\r\nperfectionist, he informs all his friends with the time their gift will\r\nreach them. A Pikachu travels at a speed of meters per second. His\r\nfriends were excited to hear this and would be unhappy if their presents\r\ngot delayed. Unfortunately Team Rocket is on the loose and they came to\r\nknow of Bash’s plan. They want to maximize the number of friends who are\r\nunhappy with Bash.They do this by destroying exactly one of the other\r\ncities. This implies that .Note that .Since Bash is already a legend,\r\ncan you help Team Rocket this time and find out the maximum number of\r\nBash’s friends who can be made unhappy by destroying exactly one city.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 07.09.2017 15:04:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n  public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector< vector<int> > g;\n  int n;\n\n  function<bool(int)> ignore;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n    ignore = nullptr;\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n\n  virtual void set_ignore_edge_rule(const function<bool(int)> &f) {\n    ignore = f;\n  }\n\n  virtual void unset_ignore_edge_rule() {\n    ignore = nullptr;\n  }\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n  public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n  using graph<T>::ignore;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    if (ignore != nullptr) {\n      rev.set_ignore_edge_rule([&](int id) {\n        return ignore(id);\n      });\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nclass undigraph : public graph<T> {\n  public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undigraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nvector <T> dijkstra(const graph<T> &g, int start) {\n  assert(0 <= start && start < g.n);\n  vector<T> dist(g.n, numeric_limits<T>::max());\n  priority_queue<pair<T, int>, vector<pair<T, int> >, greater<pair<T, int> > > s;\n  dist[start] = 0;\n  s.emplace(dist[start], start);\n  while (!s.empty()) {\n    T expected = s.top().first;\n    int i = s.top().second;\n    s.pop();\n    if (dist[i] != expected) {\n      continue;\n    }\n    for (int id : g.g[i]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.from ^ e.to ^ i;\n      if (dist[i] + e.cost < dist[to]) {\n        dist[to] = dist[i] + e.cost;\n        s.emplace(dist[to], to);\n      }\n    }\n  }\n  return dist;\n  // returns numeric_limits<T>::max() if there's no path\n}\n\ntemplate <typename T>\nvector<int> dominators(digraph<T> &g, int root) {\n  int n = g.n;\n  vector<int> pos(n, -1);\n  vector<int> order;\n  vector<int> parent(n, -1);\n  function<void(int)> dfs = [&](int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    for (int id : g.g[v]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int u = e.to;\n      if (pos[u] == -1) {\n        parent[u] = v;\n        dfs(u);\n      }\n    }\n  };\n  dfs(root);\n  vector<int> p(n), best(n);\n  iota(p.begin(), p.end(), 0);\n  iota(best.begin(), best.end(), 0);\n  vector<int> sdom = pos;\n  function<int(int)> find_best = [&](int x) {\n    if (p[x] != x) {\n      int u = find_best(p[x]);\n      if (sdom[u] < sdom[best[x]]) {\n        best[x] = u;\n      }\n      p[x] = p[p[x]];\n    }\n    if (sdom[best[p[x]]] < sdom[best[x]]) {\n      best[x] = best[p[x]];\n    }\n    return best[x];\n  };\n  digraph<int> g_rev = g.reverse();\n  vector<int> idom(n, -1);\n  vector<int> link(n, 0);\n  vector< vector<int> > bucket(n);\n  for (int it = (int) order.size() - 1; it >= 0; it--) {\n    int w = order[it];\n    for (int id : g_rev.g[w]) {\n      if (g_rev.ignore != nullptr && g_rev.ignore(id)) {\n        continue;\n      }\n      auto &e = g_rev.edges[id];\n      int u = e.to;\n      sdom[w] = min(sdom[w], sdom[find_best(u)]);\n    }\n    idom[w] = order[sdom[w]];\n    for (int u : bucket[w]) {\n      link[u] = find_best(u);\n    }\n    for (int id : g.g[w]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int u = e.to;\n      if (parent[u] == w) {\n        p[u] = w;\n      }\n    }\n    bucket[order[sdom[w]]].push_back(w);\n  }\n  for (int it = 1; it < (int) order.size(); it++) {\n    int w = order[it];\n    idom[w] = idom[link[w]];\n  }\n  return idom;\n  // idom[i] -- immediate dominator for vertex i\n}\n\ntemplate <typename T>\nvector<int> find_topsort(const digraph<T> &g) {\n  vector<int> deg(g.n, 0);\n  for (int id = 0; id < (int) g.edges.size(); id++) {\n    if (g.ignore != nullptr && g.ignore(id)) {\n      continue;\n    }\n    deg[g.edges[id].to]++;\n  }\n  vector<int> x;\n  for (int i = 0; i < g.n; i++) {\n    if (deg[i] == 0) {\n      x.push_back(i);\n    }\n  }\n  for (int ptr = 0; ptr < (int) x.size(); ptr++) {\n    int i = x[ptr];\n    for (int id : g.g[i]) {\n      if (g.ignore != nullptr && g.ignore(id)) {\n        continue;\n      }\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (--deg[to] == 0) {\n        x.push_back(to);\n      }\n    }\n  }\n  if ((int) x.size() != g.n) {\n    return vector<int>();\n  }\n  return x;\n}\n\nint main() {\n  int n, m, st;\n  scanf(\"%d %d %d\", &n, &m, &st);\n  st--;\n  undigraph<long long> gd(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    scanf(\"%d %d %d\", &x, &y, &z);\n    x--; y--;\n    gd.add(x, y, z);\n  }\n  vector<long long> d = dijkstra(gd, st);\n  digraph<int> g(n);\n  const long long inf = numeric_limits<long long>::max();\n  for (int i = 0; i < n; i++) {\n    for (int id : gd.g[i]) {\n      auto &e = gd.edges[id];\n      int to = i ^ e.from ^ e.to;\n      if (d[to] != inf && d[i] != inf && d[i] + e.cost == d[to]) {\n        g.add(i, to);\n      }\n    }\n  }\n  vector<int> dom = dominators(g, st);\n  vector<int> order = find_topsort(g);\n  vector<int> who(n), dcnt(n);\n  for (int i : order) {\n    if (i == st || dom[i] == -1) {\n      continue;\n    }\n    if (dom[i] == st) {\n      who[i] = i;\n    } else {\n      who[i] = who[dom[i]];\n    }\n    dcnt[who[i]]++;\n  }\n  int mx = 0;\n  for (int x : dcnt) {\n    mx = max(mx, x);\n  }\n  printf(\"%d\\n\", mx);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Team Rocket Rises Again.json",
    "editorial_link": "https://codeforces.com//blog/entry/49743",
    "editorial": "Main idea: Building Dominator tree on shortest path DAG.\n\nFirst of all, we run Dijkstra's shortest path algorithm from s as the source vertex and construct the shortest path DAG of the given graph. Note that in the shortest path DAG, the length of any path from s to any other node x is equal to the length of the shortest path from s to x in the given graph.\n\nNow, let us analyze what the function f(s,?x) means. It will be equal to the number of nodes u such that every path from s to u passes through node x in the shortest path DAG, such that on removing node x from the DAG, there will be no path from s to u.\n\nIn other words, we want to find the number of nodes u that are dominated by node x considering s as the sources vertex in the shortest path DAG. This can be calculated by building dominator tree of the shortest path DAG considering s as the source vertex.\nA node u is said to dominate a node w wrt source vertex s if all the paths from s to w in the graph must pass through node u.\nYou can read more about dominator tree here.\n\nOnce the dominator tree is formed, the answer for any node x is equal to the number of nodes in the subtree of x in the tree formed.\n\nAuthor's code:\nAnother approach for forming dominator tree is by observing that the shortest path directed graph formed is a DAG i.e. acyclic. So suppose we process the nodes of the shortest path dag in topological order and have a dominator tree of all nodes from which we can reach x already formed. Now, for the node x, we look at all the parents p of x in the DAG, and compute their LCA in the dominator tree built till now. We can now attach the node x as a child of the LCA in the tree.",
    "hint": []
}