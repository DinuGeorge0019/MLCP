{
    "link": "https://codeforces.com//contest/722/problem/F",
    "problemId": "74004",
    "problem_idx": "F",
    "shortId": "722F",
    "contest_number": "722",
    "problem_submissions": {
        "F": [
            21091512,
            21085594,
            21089803,
            21092021,
            21091925,
            21091406,
            21083741,
            21089867,
            21089611,
            21086397,
            21088088,
            21089823,
            21086418,
            21090125,
            21089647,
            21089044,
            21089230,
            21089273
        ],
        "E": [
            21088023,
            21107688,
            21106067,
            21087044,
            21088852,
            21116611,
            21251507,
            21091238,
            21126451
        ],
        "D": [
            21080172,
            21076258,
            21078404,
            21076583,
            21076470,
            21078997,
            21077617,
            21080800,
            21077359,
            21076406,
            21076609,
            21078412,
            21075627,
            21078861,
            21077229,
            21077815,
            21082146,
            21079311,
            21080176,
            21080301
        ],
        "C": [
            21074766,
            21074143,
            21079601,
            21075184,
            21074110,
            21076772,
            21073504,
            21077447,
            21074819,
            21079500,
            21074909,
            21079654,
            21072018,
            21074306,
            21075294,
            21074312,
            21076102,
            21076830,
            21075898,
            21075171
        ],
        "A": [
            21071362,
            21070972,
            21070997,
            21070865,
            21070901,
            21080897,
            21070869,
            21071371,
            21070926,
            21071044,
            21070971,
            21074578,
            21078981,
            21070900,
            21072665,
            21071359,
            21071666,
            21071148,
            21070986,
            21070908
        ],
        "B": [
            21071955,
            21071959,
            21071961,
            21072182,
            21071953,
            21073607,
            21072621,
            21072656,
            21072545,
            21073995,
            21077019,
            21071668,
            21072069,
            21072511,
            21073331,
            21073657,
            21072159,
            21071949
        ]
    },
    "name": "F. Cyclic Cipher",
    "statement": "You are given sequences. Each sequence consists of positive integers,\r\nnot exceeding . All integers in one sequence are distinct, but the same\r\ninteger may appear in multiple sequences. The length of the -th sequence\r\nis .Each second integers in each of the sequences are shifted by one to\r\nthe left, i.e. integers at positions go to positions , while the first\r\nintegers becomes the last.Each second we take the first integer of each\r\nsequence and write it down to a new array. Then, for each value from to\r\nwe compute the longest of the array consisting of element only.The above\r\noperation is performed for seconds. For each integer from to find out\r\nthe longest segment found at this time.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct info\n{\n    int i, c, m;\n};\n\nint N, M;\nvector<info> A[100001];\nint cnt[41];\nint which[41];\nint g[41][41];\n\nbool check()\n{\n    for(int i=1; i<=40; i++) if(cnt[i])\n        for(int j=i+1; j<=40; j++) if(cnt[j])\n            if(which[i]%g[i][j]!=which[j]%g[i][j])\n                return false;\n    return true;\n}\n\nint subsolve(info *V, int n)\n{\n    for(int i=1; i<=40; i++)\n        cnt[i]=0;\n    int ret=0;\n    for(int i=0, j=0; j<n; j++)\n    {\n        while(cnt[V[j].m]>0 && which[V[j].m]!=V[j].c)\n        {\n            cnt[V[i].m]--;\n            i++;\n        }\n        cnt[V[j].m]++;\n        which[V[j].m]=V[j].c;\n        while(!check())\n        {\n            cnt[V[i].m]--;\n            i++;\n        }\n        ret=max(ret, j-i+1);\n    }\n    return ret;\n}\n\nint solve(vector<info>& V)\n{\n    int ret=0;\n    for(int i=0, j; i<(int)V.size(); i=j)\n    {\n        for(j=i; j<(int)V.size() && j-i==V[j].i-V[i].i; j++);\n        ret=max(ret, subsolve((info*)(V.data()+i), j-i));\n    }\n    return ret;\n}\n\nint main()\n{\n    for(int i=1; i<=40; i++)\n        for(int j=1; j<=40; j++)\n            g[i][j]=__gcd(i, j);\n    scanf(\"%d%d\", &N, &M);\n    for(int i=0; i<N; i++)\n    {\n        int K;\n        scanf(\"%d\", &K);\n        for(int j=0; j<K; j++)\n        {\n            int a;\n            scanf(\"%d\", &a);\n            A[a].push_back((info){i, j, K});\n        }\n    }\n    for(int i=1; i<=M; i++)\n        printf(\"%d\\n\", solve(A[i]));\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "data structures",
        "implementation",
        "number theory",
        "two pointers"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Cyclic Cipher.json",
    "editorial_link": "https://codeforces.com//blog/entry/47497",
    "editorial": "Letâs solve the problem for a particular number . Without loss of\r\ngenerality, we assume that appeared in each sequence. If not, then the\r\nwhole sequence is divided into contigous subsegments, for which above\r\nstatement is true, and the answer for the number is equal to the maximum\r\nof the answers for these subsegments.Letâs denote as the position (from\r\nto - 1) of in the -th sequence. Then the number occures in the new array\r\nat position in the seconds equal to . This condition can be rewritten as\r\nfollows: the number occures at position on the -th second, if . Thus, to\r\ndetermine whether the number occurs at some point in all positions from\r\nto , you need to determine whether there is a solution for a system of\r\nequations: Suppose that we are able to quickly answer to such queries\r\nfor arbitrary and .Then the problem can be solved, for example, using\r\ntwo pointers. We will move the left boundary of the subsegment, and for\r\nfixed left boundary, we will move the right boundary as far as possible,\r\nuntil the solution of the corresponding system still exists.We can solve\r\na system of equations for any subsegment in time per query using\r\nprecalculation in the following way:To begin with, we note that the set\r\nof solutions of this system is either empty or it itself can be\r\nrepresented in the same form , where . We will find the solutions of the\r\nsystems for the following subsegments: for each and for each , we will\r\ntake subsegment .For each such subsegment we can find the solution of\r\nthe corresponding system using time by solving a system consisting of\r\ntwo equations obtained from each of the halves of this subsegment. We\r\ncan solve a system consisting of two equations using the Chinese\r\nremainder theorem.Now, to find a solution for any subsegment, it is\r\nenough to take two subsegments presented above, that their union is\r\nequal to the initial subsegment, and again solve a system of two\r\nequations.The resulting complexity of the solution is . Since the\r\nlengths of the sequences does not exceed 40, the resulting LCM can be\r\nupper bounded by 10^16.Since the total length of all sequences is , the\r\ntotal complexity of the solution for all the numbers remains the same.\r\n",
    "hint": []
}