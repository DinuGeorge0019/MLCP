{
    "link": "https://codeforces.com//contest/1740/problem/H",
    "problemId": "1611417",
    "problem_idx": "H",
    "shortId": "1740H",
    "contest_number": "1740",
    "problem_submissions": {
        "H": [
            178379430,
            178389839,
            178370970,
            178389787,
            178394159,
            178405718,
            178393380,
            178400994,
            178473578
        ],
        "G": [
            178363447,
            178373152,
            178390136,
            178380782,
            178380133,
            178366412,
            178381208,
            178372252,
            178364309,
            178377085,
            178379805,
            178389960,
            178394186,
            178390668,
            178429073,
            178399239,
            178398964,
            178398319,
            178393777,
            178389532,
            178457114,
            178457090,
            178457069,
            178456881,
            178456598
        ],
        "F": [
            178342509,
            178355726,
            178353094,
            178359313,
            178375325,
            178347566,
            178343206,
            178355344,
            178419766,
            178363409,
            178364030,
            178360259,
            178371042,
            178378751,
            178405026,
            178404845,
            178404014,
            178403791,
            178403569,
            178376955,
            178368121,
            178355891,
            178355560,
            178363171,
            178364934
        ],
        "E": [
            178337370,
            178346224,
            178348715,
            178344194,
            178352039,
            178338198,
            178335731,
            178340043,
            178343562,
            178350554,
            178352735,
            178349059,
            178343925,
            178345775,
            178364103,
            178352981,
            178344981,
            178359372,
            178346165,
            178350475
        ],
        "D": [
            178334153,
            178339631,
            178345824,
            178338369,
            178344365,
            178352777,
            178346625,
            178336331,
            178336614,
            178338914,
            178339308,
            178344306,
            178335725,
            178354316,
            178351979,
            178370227,
            178339993,
            178338550,
            178340955,
            178340858
        ],
        "C": [
            178329483,
            178334722,
            178336471,
            178331649,
            178333101,
            178332328,
            178330724,
            178331197,
            178330550,
            178331983,
            178331086,
            178337583,
            178330090,
            178335594,
            178335112,
            178340402,
            178335550,
            178333891,
            178336207,
            178332182
        ],
        "B": [
            178326239,
            178328080,
            178333593,
            178327287,
            178329054,
            178327314,
            178327001,
            178329448,
            178327787,
            178327568,
            178327277,
            178328845,
            178326455,
            178328799,
            178328762,
            178333879,
            178327499,
            178329269,
            178328122,
            178330549
        ],
        "A": [
            178322883,
            178322996,
            178323296,
            178323217,
            178323002,
            178322816,
            178327673,
            178322982,
            178323305,
            178322810,
            178323224,
            178323080,
            178322764,
            178323327,
            178324186,
            178325267,
            178322814,
            178324090,
            178323226,
            178322754
        ],
        "I": [
            179538712
        ]
    },
    "name": "H. MEX Tree Manipulation",
    "statement": "Given a rooted tree, define the value of vertex u in the tree\r\nrecursively as the MEX^\r\ndagger of the . Note that it is only the children, not all of its\r\ndescendants. In particular, the value of a leaf is 0.Pak Chanek has a\r\nrooted tree that initially only contains a single vertex with index 1,\r\nwhich is the root. Pak Chanek is going to do q queries. In the i-th\r\nquery, Pak Chanek is given an integer x_i. Pak Chanek needs to add a new\r\nvertex with index i+1 as the child of vertex x_i. After adding the new\r\nvertex, Pak Chanek needs to recalculate the values of all vertices and\r\nreport the sum of the values of all vertices in the current tree.^\r\ndagger The MEX (minimum excluded) of an array is the smallest\r\nnon-negative integer that does not belong to the array. For example, the\r\nMEX of [0,1,1,2,6,7] is 3 and the MEX of [6,9] is 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct Info {\n    int in;\n    int out[2];\n    int sum[2];\n    Info() : in(-1), out{-1, -1}, sum{0, 0} {}\n    Info(int x, int eq, int neq, int l) : in(x), out{neq, eq}, sum{neq + l, eq + l} {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.in = a.in;\n    if (a.out[1] == b.in) {\n        c.out[1] = b.out[1];\n        c.sum[1] = a.sum[1] + b.sum[1];\n    } else {\n        c.out[1] = b.out[0];\n        c.sum[1] = a.sum[1] + b.sum[0];\n    }\n    if (a.out[0] == b.in) {\n        c.out[0] = b.out[1];\n        c.sum[0] = a.sum[0] + b.sum[1];\n    } else {\n        c.out[0] = b.out[0];\n        c.sum[0] = a.sum[0] + b.sum[0];\n    }\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    n++;\n    std::vector<int> p(n * 2, -1), parent(n, -1);\n    for (int i = 1; i < n; i++) {\n        std::cin >> parent[i];\n        parent[i]--;\n    }\n    \n    std::vector<int> ch1(2 * n), ch2(2 * n);\n    \n    std::vector<std::array<int, 20>> cnt(n);\n    std::vector<int> ans(2 * n, -1), sum(2 * n), lsum(2 * n);\n    std::vector<Info> info(2 * n);\n    std::function<int(int)> update = [&](int x) {\n        int in = 0;\n        while (cnt[x][in]) {\n            in++;\n        }\n        int out = in + 1;\n        while (cnt[x][out]) {\n            out++;\n        }\n        info[x] = Info(in, out, in, lsum[x]);\n        int t = x;\n        while (p[t] >= n) {\n            t = p[t];\n            info[t] = info[ch1[t]] + info[ch2[t]];\n        }\n        if (p[t] >= 0 && ans[t] != -1) {\n            lsum[p[t]] -= sum[t];\n            cnt[p[t]][ans[t]]--;\n        }\n        ans[t] = info[t].out[0];\n        sum[t] = info[t].sum[0];\n        if (p[t] >= 0) {\n            lsum[p[t]] += sum[t];\n            cnt[p[t]][ans[t]]++;\n            return update(p[t]);\n        }\n        return sum[t];\n    };\n    \n    int cur = n;\n    \n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        adj[parent[i]].push_back(i);\n    }\n    \n    std::vector<int> siz(n);\n    std::function<void(int)> dfs1 = [&](int x) {\n        siz[x] = 1;\n        for (auto &y : adj[x]) {\n            dfs1(y);\n            siz[x] += siz[y];\n            if (siz[y] > siz[adj[x][0]]) {\n                std::swap(y, adj[x][0]);\n            }\n        }\n    };\n    dfs1(0);\n    \n    std::function<int(int, int)> work = [&](int l, int r) {\n        if (r == (adj[l].empty() ? -1 : adj[l][0])) {\n            for (auto x : adj[l]) {\n                if (x != adj[l][0]) {\n                    p[work(x, -1)] = l;\n                }\n            }\n            return l;\n        }\n        int x = l;\n        while (r != (adj[x].empty() ? -1 : adj[x][0]) && siz[x] * 2 >= siz[l] + (r >= 0 ? siz[r] : 0)) {\n            x = adj[x][0];\n        }\n        int a = work(l, x);\n        int b = work(x, r);\n        int c = cur++;\n        ch1[c] = b;\n        ch2[c] = a;\n        p[a] = p[b] = c;\n        return c;\n    };\n    \n    work(0, -1);\n    \n    update(0);\n    for (int i = 1; i < n; i++) {\n        std::cout << update(i) << \"\\n\";\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. MEX Tree Manipulation.json",
    "editorial_link": "https://codeforces.com//blog/entry/108567",
    "editorial": "Define of a certain array as the -th smallest non-negative integer that\r\ndoes not belong to the array.Let\u00e2\u0080\u0099s solve a simpler problem. Imagine that\r\nyou are given an array , you are asked to append a new element to the\r\narray, and you need to calculate the MEX of the array after the\r\noperation. It is easy to see that the new value of MEX is either if or\r\nif where is the array before the operation.Let define a relationship\r\nbetween input and output which means: If the input is not , then the\r\noutput is . If the input is , then the output is . This means the\r\nrelationship between the new element to be appended to and the new value\r\nof MEX can be expressed as . Define that triple as .Define the heavy\r\nchild of vertex as the child with the largest subtree size. If there are\r\nchildren with the same subtree size, choose one of them. Let\u00e2\u0080\u0099s call each\r\nchild other than the heavy child as a light child. In particular, the\r\nedge that connects a vertex to its heavy child is called a heavy\r\nedge.Let be the array that contains the values of the light children of\r\nvertex . We can see that if we maintain we can get the relationship\r\nbetween the value of the heavy child and the value of vertex .Let\u00e2\u0080\u0099s\r\nconsider a path in the tree that traverses through parents while only\r\nusing heavy edges. Consider the relationship between the value of the\r\nvertex at the beginning of the path and the end of the path. Let\u00e2\u0080\u0099s\r\ncalculate the for each vertex in the path other than the first one. We\r\ncan see that we can get the relationship between the vertex in the\r\nbeginning of the path and the end of the path using those values. In\r\nfact, that relationship can also be expressed as a triple defined\r\nabove.Let\u00e2\u0080\u0099s decompose the tree into chains of heavy edges. For each\r\nchain, construct a segment tree with each node in the segment tree\r\ncalculating the relationship triple for a segment of the chain.Suppose\r\nwe want to add a new vertex. The vertices that have their values changed\r\nare the ones that lie on the path from the new vertex to the root.\r\nObserve that that path only traverses through at most different heavy\r\nedge chains. For each chain, we can get the value of the vertex at the\r\nend of the chain by doing a point update on the chain\u00e2\u0080\u0099s segment tree.\r\nWhen we move between two different chains, we update the for a vertex\r\nand recalculate it\u00e2\u0080\u0099s in time complexity using a set or another segment\r\ntree. We repeat this process until we reach the root. We can calculate\r\nthat the total complexity of a single query is .To get the sum of the\r\nvalues of the entire tree after an operation, we can store two new\r\nvariables in each node of the segment tree of each chain that represents\r\nthe sum of the chain segment for the two possible cases of the\r\ninput.Time complexity:\r\n"
}