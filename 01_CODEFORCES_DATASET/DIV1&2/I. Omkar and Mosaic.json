{
    "link": "https://codeforces.com//contest/1586/problem/I",
    "problemId": "1147389",
    "problem_idx": "I",
    "shortId": "1586I",
    "contest_number": "1586",
    "problem_submissions": {
        "I": [
            132349267,
            132252923,
            132320064,
            132673395,
            132289506,
            132263256
        ],
        "H": [
            132247560,
            132253721,
            134930470,
            132350321,
            132254025,
            132660661,
            132275048,
            132253966,
            132270155
        ],
        "G": [
            132239647,
            132244340,
            132241119,
            135794866,
            135794713,
            132234650,
            132248115,
            132244256,
            132257761,
            132255193,
            132256199,
            132255919,
            132258648,
            132257515,
            132250742,
            132255333,
            132257553,
            132255311
        ],
        "F": [
            132231955,
            132236161,
            132234366,
            132240633,
            132243967,
            132235859,
            132234337,
            132237395,
            132239493,
            132241376,
            132248866,
            132245654,
            132241416,
            132246161,
            132245018,
            132259456,
            132244979,
            132249686,
            132260019,
            132238761
        ],
        "E": [
            132228491,
            132224206,
            132228693,
            132232413,
            132231532,
            132229745,
            132230672,
            132232315,
            132218494,
            132235319,
            132232020,
            132237413,
            132239524,
            132237023,
            132236410,
            132236319,
            132238669,
            132240928,
            132230421,
            132229492
        ],
        "D": [
            132225001,
            132227375,
            132224444,
            132226879,
            132227724,
            132226231,
            132226626,
            132227371,
            132224235,
            132227654,
            132224635,
            132229641,
            132234990,
            132231067,
            132230536,
            132228432,
            132234258,
            132232998,
            132241147,
            132223955
        ],
        "C": [
            132221243,
            132218519,
            132219460,
            132219748,
            132219799,
            132222571,
            132220819,
            132219850,
            132232802,
            132223481,
            132218757,
            132219927,
            132230956,
            132218216,
            132224263,
            132222192,
            132227273,
            132228072,
            132226595,
            132220025
        ],
        "B": [
            132214722,
            132213701,
            132215490,
            132214516,
            132214317,
            132214601,
            132215162,
            132222197,
            132229955,
            132216968,
            132214347,
            132216468,
            132226751,
            132220812,
            132216772,
            132216742,
            132216324,
            132213579,
            132217316,
            132213929
        ],
        "A": [
            132213139,
            132213078,
            132214020,
            132213141,
            132213243,
            132213267,
            132213377,
            132220659,
            132228179,
            132218691,
            132213234,
            132214356,
            132213033,
            132224973,
            132214120,
            132214349,
            132213337,
            132213011,
            132242338,
            132213128
        ]
    },
    "name": "I. Omkar and Mosaic",
    "statement": "Omkar is creating a mosaic using colored square tiles, which he places\r\nin an n\r\ntimes n grid. When the mosaic is complete, each cell in the grid will\r\nhave either a glaucous or sinoper tile. However, currently he has only\r\nplaced tiles in some cells. A completed mosaic will be a if and only if\r\neach tile is adjacent to exactly 2 tiles of the same color (2 tiles are\r\nadjacent if they share a side.) Omkar wants to fill the rest of the\r\ntiles so that the mosaic becomes a . Now he is wondering, is the way to\r\ndo this unique, and if it is, what is it?\r\n",
    "solutions": [
        "//an awesome problem.\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint absv(int x)\n{\n\treturn x < 0 ? -x : x;\n}\nint n, x[2005], G[2005][2005];\nchar S[2005][2005];\nbool dfs(int v, int c)\n{\n\tif(x[v] == !c) return false;\n\telse if(x[v] == c) return true;\n\tx[v] = c;\n\trep(i, n + 1) if(G[v][i] != -1 && !dfs(i, c ^ G[v][i])) return false;\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) scanf(\"%s\", S[i]);\n\tif(n & 1) {\n\t\tprintf(\"NONE\\n\"); return 0;\n\t}\n\t\n\trep(i, n + 1) rep(j, n + 1) G[i][j] = -1;\n\tfor(int i = 0; i < n; i += 2) G[i][i + 2] = G[i + 2][i] = 1;\n\trep(i, n) rep(j, n) if(S[i][j] != '.') {\n\t\tint val = (S[i][j] == 'S') ^ (i & 1) ^ (j & 1);\n\t\tint d0 = absv(i - j), d1 = absv(i + j - n + 1);\n\t\tif(G[d0][n - d1] == !val) {\n\t\t\tprintf(\"NONE\\n\"); return 0;\n\t\t}\n\t\tG[d0][n - d1] = G[n - d1][d0] = val; \n\t}\n\t\n\trep(i, n + 1) x[i] = -1;\n\tint cnt = 0;\n\trep(i, n + 1) if(x[i] == -1) {\n\t\tcnt ++;\n\t\tif(!dfs(i, 0)) {\n\t\t\tprintf(\"NONE\\n\"); return 0;\n\t\t}\n\t}\n\tif(cnt >= 2) printf(\"MULTIPLE\\n\");\n\telse {\n\t\trep(i, n) rep(j, n) S[i][j] = (i & 1) ^ (j & 1) ^ x[absv(i - j)] ^ x[n - absv(i + j - n + 1)] ? 'S' : 'G';\n\t\tprintf(\"UNIQUE\\n\");\n\t\trep(i, n) printf(\"%s\\n\", S[i]);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Omkar and Mosaic.json",
    "editorial_link": "https://codeforces.com//blog/entry/96072",
    "editorial": "The first main observation to make is that the possible mastapeeces\r\ndon\u00e2\u0080\u0099t just have square \"loops\" of the same color. A counterexample to\r\nthis is shown below: Instead, observe that, in a mastapeece: a) The two\r\ncells adjacent to corner cells must be the same color as the corner. b)\r\nAny cell not on the border must be adjacent to two sinoper tiles and two\r\nglaucous tiles If we then start at two cells adjacent to some corner and\r\nkeep applying b) to cells on the long diagonal with the corner, we find\r\nthat the long diagonals starting at the adjacent cells must be identical\r\nand tiled alternately with glaucous and sinoper tiles, like so: From\r\nhere, we can show that no mastapeece exists for odd . Note that the two\r\nsets of such diagonals, for odd , intersect in cells like so: But then\r\nthis forces us two have two consecutive diagonals of the same color on\r\nthe untiled set of diagonals, which is impossible given that we\u00e2\u0080\u0099ve shown\r\nthey must alternate. From here, if we apply b) to the red diagonals, we\r\nfind that the yellow diagonals must alternate in a similar fashion: and\r\nif we keep applying this argument, we find that each diagonal where\r\nevery cell is the same color in the image below must alternate between\r\nglaucous and sinoper in a similar way: From here, consider the following\r\nyellow diagonal: We know its cells must alternate, so due to parity we\r\nhave that the ending cells of the diagonal must be the same color. Since\r\nwe know each cell must be surrounded by two of the same color, this also\r\nfixes the following red cells: which must also be the same color. This\r\ngives that the following yellow diagonals must be identical (as they\r\nmust alternate): repeating this kind of argument shows that a mastapeece\r\nmust be symmetric about both of its main diagonals. Finally, note that\r\nsince the yellow diagonal alternates, and each cell must be adjacent to\r\nof the same color, the red cells must be the same color: Repeating this\r\nkind of argument gives that the cells in each pair of adjacent red cells\r\nand each pair of adjacent yellow cells must be the same color: Finally,\r\napplying the symmetry, alternating diagonals, and the pairs of same\r\ncolored cells gives that in the following grid, fixing a cell of one\r\ncolor fixes all of the cells of that color: Finally, due to our\r\nconditions on alternating diagonals, each cell in the middle of the grid\r\nwill be adjacent to two cells of the same color, and due to our\r\nconditions on the pairs of cells on the diagonal that must be the same\r\ncolor, each border cell will be adjacent to two cells of the same color.\r\nIn other words, if we pair up the cells on the leftmost column and color\r\neach pair arbitrarily, there will be exactly one mastapeece that has the\r\ncolumn colored this way. For example, if we color the leftmost column\r\nlike so: then if we go down and color in the cells fixed by each pair in\r\nthe left most column, we find that the final mastapeece will look like\r\nso: From here, it\u00e2\u0080\u0099s pretty easy to figure out how to implement the\r\nproblem.Some examples of what mastapeeces look like are shown below:\r\n"
}