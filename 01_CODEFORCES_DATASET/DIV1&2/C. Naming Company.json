{
    "link": "https://codeforces.com//contest/794/problem/C",
    "problemId": "106232",
    "problem_idx": "C",
    "shortId": "794C",
    "contest_number": "794",
    "problem_submissions": {
        "F": [
            27081873,
            27083526,
            27083046,
            27085017,
            27081983,
            27082510,
            27086006,
            27083949,
            27080179,
            27086715,
            27082966,
            27079645,
            27084337,
            27084766,
            27081869,
            27081966,
            27084662
        ],
        "E": [
            27079377,
            27080585,
            27080375,
            27082137,
            27084820,
            27086075,
            27082614,
            27085336,
            27086070,
            27082160,
            27085721,
            27085903,
            27085376,
            27087205,
            27084980,
            27082950,
            27083172,
            27085134
        ],
        "D": [
            27077745,
            27078665,
            27078681,
            27079267,
            27079635,
            27079737,
            27080740,
            27079081,
            27083788,
            27079987,
            27082339,
            27082247,
            27082529,
            27080107,
            27094240,
            27094236,
            27094226,
            27094219,
            27094212,
            27094182,
            27094168,
            27094131,
            27094066,
            27080763,
            27081677,
            27089971,
            27089903,
            27087542,
            27080778
        ],
        "C": [
            27075178,
            27076116,
            27076013,
            27076437,
            27076459,
            27075605,
            27076203,
            27075986,
            27076793,
            27077625,
            27078065,
            27084041,
            27076700,
            27077790,
            27078769,
            27077244,
            27075390,
            27082931,
            27077078
        ],
        "B": [
            27072873,
            27073613,
            27072949,
            27073965,
            27073074,
            27073568,
            27073477,
            27073304,
            27073689,
            27073228,
            27073014,
            27073894,
            27072703,
            27074273,
            27072442,
            27074226,
            27073723,
            27073830,
            27073779
        ],
        "A": [
            27072392,
            27072471,
            27072465,
            27072459,
            27072555,
            27072760,
            27072661,
            27072604,
            27072817,
            27072481,
            27072447,
            27072409,
            27072476,
            27072463,
            27072773,
            27072976,
            27072422,
            27074544,
            27072598
        ],
        "G": [
            27216394,
            27227867
        ]
    },
    "name": "C. Naming Company",
    "statement": "Oleg the client and Igor the analyst are good friends. However,\r\nsometimes they argue over little things. Recently, they started a new\r\ncompany, but they are having trouble finding a name for the company.To\r\nsettle this problem, they\u2019ve decided to play a game. The company name\r\nwill consist of letters. Oleg and Igor each have a set of letters (which\r\nmight contain multiple copies of the same letter, the sets can be\r\ndifferent). Initially, the company name is denoted by question marks.\r\nOleg and Igor takes turns to play the game, Oleg moves first. In each\r\nturn, a player can choose one of the letters in his set and replace any\r\nof the question marks with . Then, a copy of the letter is removed from\r\nhis set. The game ends when all the question marks has been replaced by\r\nsome letter.For example, suppose Oleg has the set of letters and Igor\r\nhas the set of letters . One possible game is as follows :Initially, the\r\ncompany name is .Oleg replaces the second question mark with . The\r\ncompany name becomes . The set of letters Oleg have now is .Igor\r\nreplaces the third question mark with . The company name becomes . The\r\nset of letters Igor have now is .Finally, Oleg replaces the first\r\nquestion mark with . The company name becomes . The set of letters Oleg\r\nhave now is .In the end, the company name is .Oleg wants the company\r\nname to be as lexicographically small as possible while Igor wants the\r\ncompany name to be as lexicographically large as possible. What will be\r\nthe company name if Oleg and Igor always play optimally?A string is\r\ncalled lexicographically smaller than a string (where ) if where is the\r\nsmallest index such that . (so for all )\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\n\nint n;\nstring s;\n\nvoid parse(int* arr) {\n\tcin >> s;\n\tfor (int i = 0; i < 26; i++) arr[i] = 0;\n\tn = s.length();\n\tfor (int i = 0; i < n; i++)\n\t\tarr[s[i] - 'a']++;\n}\n\nint a[26];\nint b[26];\n\nint pa, pb;\n\nvoid calc() {\n\tpa = 0;\n\twhile (a[pa] == 0) pa++;\n\tpb = 25;\n\twhile (b[pb] == 0) pb--;\n}\n\nstring ans;\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\t\n\tparse(a);\n\tparse(b);\n\tans.resize(n);\n\tint pl = 0, pr = n - 1;\n\tfor (int iter = 1; iter <= n; iter++) {\n\t\tcalc();\n\t\tif (pa < pb) {\n\t\t\tif (iter & 1) {\n\t\t\t\ta[pa]--;\n\t\t\t\tans[pl++] = 'a' + pa;\n\t\t\t} else {\n\t\t\t\tb[pb]--;\n\t\t\t\tans[pl++] = 'a' + pb;\n\t\t\t}\n\t\t} else {\n\t\t\tint sa = pr;\n\t\t\twhile (sa - 2 >= pl) sa -= 2;\n\t\t\tint sb = pr + 1;\n\t\t\twhile (sb - 2 >= pl) sb -= 2;\n\t\t\tif (iter & 1) {\n\t\t\t\tfor (int i = sa; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = 'a' + pa;\n\t\t\t\t\ta[pa]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = sb; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = 'a' + pb;\n\t\t\t\t\tb[pb]--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = sa; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = 'a' + pb;\n\t\t\t\t\tb[pb]--;\n\t\t\t\t}\n\t\t\t\tfor (int i = sb; i <= pr; i += 2) {\n\t\t\t\t\tcalc();\n\t\t\t\t\tans[i] = 'a' + pa;\n\t\t\t\t\ta[pa]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Naming Company.json",
    "editorial_link": "https://codeforces.com/blog/entry/51962",
    "editorial": "First, it is clear that Oleg will place  letters and Igor will place  letters. Next, it is clear that Oleg and Igor will both choose their smallest and biggest letters respectively to place in the final string. Thus, we now consider that Oleg places his smallest  letters and Igor places his largest  letters.\n\nConsider the following greedy strategy. When it's Oleg's turn, he will replace the frontmost question mark with his smallest letter. When it's Igor's turn, he will replace the frontmost question mark with his largest letter. At first glance, you might think that this works. However, there's another case that we haven't considered.\n\nSuppose Oleg has the letters {x,?y,?z} and Igor has the letters {a,?b,?c}. According to our previous strategy, Oleg will place x as the first letter. However, that's not optimal. He can place his letters at the back and force Igor to place the first letter. The reason is because the largest letter of Igor is not larger than the smallest letter of Oleg. Thus, it is beneficial for Oleg to place his letters at the back and force Igor to place his letters in front.\n\nSo, what exactly will the final string look like? We'll look at the moves one by one. If at some point Oleg's smallest letter is still strictly smaller than Igor's largest letter, then both player must put their smallest (largest if it's Igor) letter as the frontmost letter. Why? Suppose not, then on the next turn the other player will occupy that spot with their best (smallest if Oleg, largest if Igor) letter, and the resulting string will be worse for the current player. This proves that greedy is correct in this case.\n\nNow, what if Oleg's smallest letter is not smaller than Igor's largest letter. In this case, both players will want to force the other player to place their own letter at the beginning of the string. It can be proven that in this case, each person will place their current worst (largest if Oleg, smallest if Igor) letter at the back of the string in the optimal strategy. Thus, we can calculate the final string starting from this point and after that reverse this part and combine it with the first part of the string where both players greedily place their best letters in the beginning.\n\nTime Complexity : O(n)\n\nMany people failed on pretest 6 initially because they didn't consider the second case."
}