{
    "link": "https://codeforces.com//contest/1987/problem/G1",
    "problemId": "2726567",
    "problem_idx": "G1",
    "shortId": "1987G1",
    "contest_number": "1987",
    "problem_submissions": {
        "E": [
            268229906,
            268158602,
            268423905,
            268422817,
            268157857,
            268152628,
            268233241,
            268233207,
            268156681,
            268158666,
            268162964,
            268158456,
            268163362,
            268156782,
            268165522,
            268170420,
            268158686,
            268162341,
            268233753,
            268228306,
            268160955,
            268160065,
            268161194,
            268164320,
            268163376,
            268166928,
            268264962,
            268164535
        ],
        "H": [
            268205560,
            268243575,
            268242763,
            268242753,
            268226875,
            268226200,
            286117872,
            286117361,
            268621342,
            270559507
        ],
        "G2": [
            268199327,
            268183184,
            268209905,
            268197988,
            268210865,
            268209119,
            268201265,
            268217291,
            268203603,
            268206936,
            268211532,
            268216966,
            268392569
        ],
        "G1": [
            268197008,
            268183589,
            268183559,
            268192970,
            268191020,
            268190335,
            268201091,
            268194194,
            268192954,
            268200485,
            268201459,
            268210583,
            268191184,
            268204488,
            268195197,
            268205593,
            268203056,
            268392539,
            268196879,
            268201576,
            268201255
        ],
        "F2": [
            268174418,
            268166457,
            268162505,
            268182920,
            268168846,
            268174436,
            268185759,
            268178301,
            268181565,
            268191599,
            268193415,
            268177500,
            268170902,
            268180818,
            268174520,
            268182719,
            268178817,
            268190336,
            268190071
        ],
        "F1": [
            268173831,
            268166694,
            268162641,
            268178377,
            268169399,
            268174193,
            268185332,
            268177979,
            268170897,
            268181978,
            268191481,
            268193293,
            268177600,
            268169616,
            268180668,
            268173797,
            268182414,
            268176479,
            268181249,
            268189979
        ],
        "D": [
            268149772,
            268151878,
            268147683,
            268147422,
            268149471,
            268152924,
            268151963,
            268155962,
            268148798,
            268153037,
            268153285,
            268152472,
            268152498,
            268151784,
            268149550,
            268150424,
            268156633,
            268151156,
            268159183,
            268155639
        ],
        "C": [
            268144323,
            268147501,
            268383290,
            268143974,
            268142997,
            268142336,
            268156117,
            268145345,
            268149662,
            268144034,
            268146014,
            268146306,
            268146500,
            268154494,
            268145000,
            268144648,
            268146061,
            268146320,
            268145299,
            268148183,
            268146033
        ],
        "B": [
            268142097,
            268138793,
            268136942,
            268137419,
            268137014,
            268140558,
            268141012,
            268143732,
            268140016,
            268142374,
            268143256,
            268141729,
            268142582,
            268139760,
            268140776,
            268140696,
            268140576,
            268139314,
            268141992,
            268141951
        ],
        "A": [
            268135899,
            268135441,
            268135342,
            268135356,
            268135339,
            268135852,
            268135895,
            268139203,
            268135363,
            268137561,
            268136567,
            268135744,
            268136590,
            268135768,
            268135350,
            268135764,
            268135555,
            268135575,
            268136024,
            268138028
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131053",
    "editorial": "For simplicity, let , and letâs recalculate the values of and . Then,\r\nthe answer is not if for all and : . . or . Let store some set of pairs\r\n, where for some valid graph: is a possible depth of a path that starts\r\nat index and passes only through indices . is a possible depth of a path\r\nthat starts at index and passes only through indices . The paths do not\r\nintersect. We are only interested in the values of and where and for\r\nsome . Initialize .Letâs iterate over all in order of increasing . For\r\neach ( and ), we will iterate over all pairs in and in : If and , we can\r\nadd the edge , so: Update the answer with . Add the pairs , , and to .\r\nIf and , we can add the edge , so: Update the answer with . Add the\r\npairs , , and to . Turns out, it is enough to store at most three pairs\r\nfor each . Specifically, it is enough to store: One pair with the\r\nmaximum possible . One pair with the maximum possible . One pair with\r\nthe maximum possible . If true, this leads to an or solution, albeit\r\nwith a large constant factor.We will proceed with a proof by induction.:\r\nit is enough to store the three pairs described above.: for with and ,\r\nonly the pairs , and are possible.: For some , let and only store the\r\nthree pairs described above.First of all, we update the answer with the\r\nsame value: When adding the left edge: If the answer came from , we\r\nmaximize . If the answer came from , we maximize and . When adding the\r\nright edge: If the answer came from , we maximize and . If the answer\r\ncame from , we maximize . Secondly, will store the pairs with the same\r\nvalues of , , and ; as in the case when all pairs are stored on all\r\nprevious stages: When adding the left edge, it is clearly not less\r\noptimal to add only the pair : When maximizing , we maximize , which we\r\ndo by maximizing , , or . When maximizing , we maximize . When\r\nmaximizing , we maximize , , or , which we do by induction. When adding\r\nthe right edge, we can only add the pair : When maximizing , we maximize\r\n. When maximizing , we maximize , which we do by maximizing , , or .\r\nWhen maximizing , we maximize , , or , which we do by induction. Thus,\r\nwe achieve the same answer by only storing these pairs, which concludes\r\nour proof.Complexity: or Note: there are a number of other possible\r\nsolutions, please refer to the comments below.\r\n",
    "name": "G1. Spinning Round  Easy Version ",
    "statement": "You are given a permutation p of length n. You are also given a string s\r\nof length n, consisting only of the character .For each i from 1 to n:\r\nDefine l_i as the largest index j < i such that p_j > p_i. If there is\r\nno such index, l_i := i. Define r_i as the smallest index j > i such\r\nthat p_j > p_i. If there is no such index, r_i := i. Initially, you have\r\nan undirected graph with n vertices (numbered from 1 to n) and no edges.\r\nThen, for each i from 1 to n, add one edge to the graph: If s_i = , add\r\nthe edge (i, l_i) to the graph. If s_i = , add the edge (i, r_i) to the\r\ngraph. If s_i = , either add the edge (i, l_i) or the edge (i, r_i) to\r\nthe graph at your choice. Find the maximum possible diameter^{\r\ntext{ }} over all graphs that you can form. Output -1 if it is not\r\npossible to form any connected graphs.^{\r\ntext{ }} Let d(s, t) denote the smallest number of edges on any path\r\nbetween s and t.The diameter of the graph is defined as the maximum\r\nvalue of d(s, t) over all pairs of vertices s and t.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, \"/stack:200000000\")#pragma GCC optimize(\"O3\")//~ #pragma GCC target (\"avx2\")//~ #pragma GCC optimize(\"Ofast\")//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")//~ #pragma GCC optimize(\"unroll-loops\")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds;using namespace std; template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; #define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << \"(\" << d.first << \", \" << d.second << \")\";}sim dor(rge<c> d) {  *this << \"[\";  for (auto it = d.b; it != d.e; ++it)    *this << \", \" + 2 * (it == d.b) << *it;  ris << \"]\";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \" #define shandom_ruffle random_shuffle using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=1600*1007;int n1;const int inf=1e9; int n; int tab[nax];char wcz[nax]; int wyn; pii drz[2*nax]; void maxi(int &a, int b){\ta=max(a, b);} pii operator +(pii a, pii b){\treturn {a.first+b.first, a.second+b.second};} pii operator -(pii a, pii b){\treturn {a.first-b.first, a.second-b.second};} struct info{\tset<pii> setel;\tpii offset={0, 0};\tint maxapb=0;\tinfo()\t{\t\tsetel.insert({0, 0});\t}\tint roz()\t{\t\treturn setel.size();\t}\tvoid wrzuc(pii v)\t{\t\tv=v-offset;\t\t//~ debug() << \"do \" << setel << \" dorzucam \" << v;\t\tauto it=setel.lower_bound(v);\t\tif (it!=setel.end() && (*it).second>=v.second)\t\t{\t\t\t//~ debug() << \"nie czeba\";\t\t\treturn;\t\t}\t\twhile(1)\t\t{\t\t\tauto jt=it;\t\t\tif (jt==setel.begin())\t\t\t\tbreak;\t\t\tjt--;\t\t\tif ((*jt).second<=v.second)\t\t\t\tsetel.erase(jt);\t\t\telse\t\t\t\tbreak;\t\t}\t\tsetel.insert(v);\t\tmaxapb=max(maxapb, v.first+v.second);\t\t//~ debug() << \"jusz \" << setel;\t}\tint max1()\t{\t\tauto it=setel.end();\t\tit--;\t\treturn (*it).first+offset.first;\t}\tint max2()\t{\t\tauto it=setel.begin();\t\treturn (*it).second+offset.second;\t}\tint maxwsz()\t{\t\treturn max(max1(), max2());\t}\tint maxsum()\t{\t\treturn maxapb+offset.first+offset.second;\t}\tvoid przesun(pii v)\t{\t\toffset=offset+v;\t}\tvoid wypisz()\t{\t\tdebug() << imie(offset) << imie(setel);\t}}; void zam(info &a, info &b){\ta.setel.swap(b.setel);\tswap(a.offset, b.offset);\tswap(a.maxapb, b.maxapb);} pii czyt(int v, int a, int b, int graa, int grab){\tif (a>=graa && b<=grab)\t{\t\treturn drz[v];\t}\tif (a>grab || b<graa)\t{\t\treturn {0, 0};\t}\treturn max(\t\tczyt((v<<1), a, (a+b)>>1, graa, grab),\t\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\t);} info dp[nax];int puste; int rek(int a, int b){\t//~ debug() << imie(a) << imie(b);\tif (a>b)\t{\t\tpuste++;\t\tdp[puste]=info();\t\treturn puste;\t}\tint s=czyt(1, 1, n1, a, b).second;\tdp[s]=info();\t\tint lew=rek(a, s-1);\tint pra=rek(s+1, b);\t\t//~ debug() << \"robie \" << a << \" \" << b << \" \" << s;\t\twyn=max(wyn, dp[lew].max2()+dp[pra].max1());\tif (a!=1)\t{\t\twyn=max(wyn, dp[lew].max1()+dp[pra].maxwsz()+1);\t\twyn=max(wyn, dp[lew].maxsum()+1);\t}\tif (b!=n)\t{\t\twyn=max(wyn, dp[lew].maxwsz()+dp[pra].max2()+1);\t\twyn=max(wyn, dp[pra].maxsum()+1);\t}\t\tvector<pii> nowe;\tnowe.push_back({max(dp[lew].max1(), dp[lew].max2()+1), dp[pra].max2()});\tnowe.push_back({dp[lew].max1(), max(dp[pra].max1()+1, dp[pra].max2())});\t\tdp[lew].przesun({0, 1});\tdp[pra].przesun({1, 0});\t\tif (dp[lew].roz()>dp[pra].roz())\t{\t\tzam(dp[s], dp[lew]);\t\tfor (auto i : dp[pra].setel)\t\t\tdp[s].wrzuc(i+dp[pra].offset);\t}\telse\t{\t\tzam(dp[s], dp[pra]);\t\tfor (auto i : dp[lew].setel)\t\t\tdp[s].wrzuc(i+dp[lew].offset);\t}\tfor (pii i : nowe)\t\tdp[s].wrzuc(i);\t\t//~ dp[s].wypisz();\t//~ debug();\treturn s;} void test(){\tscanf(\"%d\", &n);\tfor (int i=1; i<=n; i++)\t\tscanf(\"%d\", &tab[i]);\tscanf(\"%s\", wcz+1);\twyn=0;\tn1=1;\twhile(n1<=n)\t\tn1<<=1;\tfor (int i=1; i<=n; i++)\t\tdrz[n1-1+i]={tab[i], i};\tfor (int i=n1-1; i; i--)\t\tdrz[i]=max(drz[2*i], drz[2*i+1]);\t\tpuste=n;\t\tint korz=rek(1, n);\tassert(wyn<n);\tprintf(\"%d\\n\", wyn);} int main(){\tint t;\tscanf(\"%d\", &t);\twhile(t--)\t\ttest();\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G1. Spinning Round  Easy Version .json",
    "hint": []
}