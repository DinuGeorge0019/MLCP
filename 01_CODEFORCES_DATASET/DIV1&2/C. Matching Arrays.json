{
    "link": "https://codeforces.com//contest/1896/problem/C",
    "problemId": "2346407",
    "problem_idx": "C",
    "shortId": "1896C",
    "contest_number": "1896",
    "problem_submissions": {
        "H2": [
            234305435,
            234294276,
            234316807,
            234293989,
            234307453,
            234313145,
            234308430,
            234674727,
            234674461,
            234674412,
            234348461,
            234317754,
            234317500
        ],
        "H1": [
            234300435,
            234288752,
            234294076,
            234304469,
            234296832,
            234303366,
            234305063,
            234305336,
            234301810,
            234292381
        ],
        "G": [
            234290728,
            234312960,
            234419627,
            234295328,
            234299457,
            234326268,
            234302972,
            234306994,
            234344999,
            234302897,
            234304455,
            234306035,
            234296895,
            234525586
        ],
        "F": [
            234279344,
            234262280,
            234278356,
            234281909,
            234284183,
            234288595,
            234278118,
            234284621,
            234280975,
            234283777,
            234307968,
            234293096,
            234293697,
            234294644,
            234304686,
            234282511,
            234279944,
            234277321
        ],
        "E": [
            234266080,
            234275828,
            234270895,
            234263950,
            234269369,
            234263464,
            234267763,
            234270201,
            234272007,
            234268761,
            234270245,
            234285745,
            234275911,
            234277731,
            234273316,
            234269329,
            234260178,
            234268619,
            234263914
        ],
        "D": [
            234260515,
            234269507,
            234266479,
            234257220,
            234264143,
            234256547,
            234261136,
            234260603,
            234265661,
            234261124,
            234261787,
            234269263,
            234266704,
            234265834,
            234268166,
            234280921,
            234253907,
            234259650,
            234255630
        ],
        "C": [
            234253899,
            234266056,
            234253267,
            234251911,
            234261130,
            234253006,
            234255721,
            234254779,
            234258245,
            234287578,
            234255535,
            234262815,
            234255118,
            234261416,
            234262126,
            234255695,
            234249255,
            234253498,
            234251351
        ],
        "B": [
            234249421,
            234247262,
            234248984,
            234247486,
            234250283,
            234247863,
            234248979,
            234248837,
            234302894,
            234248804,
            234248842,
            234247845,
            234248167,
            234249751,
            234253337,
            234249856,
            234245662,
            234248853,
            234246737
        ],
        "A": [
            234245828,
            234244872,
            234245833,
            234244939,
            234247553,
            234244853,
            234245867,
            234245696,
            234303768,
            234246110,
            234245020,
            234245161,
            234244947,
            234245703,
            234249430,
            234244871,
            234244771,
            234245709,
            234244767
        ]
    },
    "name": "C. Matching Arrays",
    "statement": "You are given two arrays a and b of size n. The of the arrays a and b is\r\nthe number of indices i such that a_i > b_i.You are also given an\r\ninteger x. Determine whether it is possible to rearrange the elements of\r\nb such that the beauty of the arrays becomes x. If it is possible,\r\noutput one valid rearrangement of b.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nint ta[nax];\nint tb[nax];\n\nint wyn[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n}\n\nvoid test()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &ta[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tb[i]);\n\tvector<pii> pos;\n\tfor (int i=1; i<=n; i++)\n\t\tpos.push_back({ta[i], i});\n\tsort(pos.begin(), pos.end());\n\tvi dwa;\n\tfor (int i=1; i<=n; i++)\n\t\tdwa.push_back(tb[i]);\n\tsort(dwa.begin(), dwa.end());\n\tfor (int i=0; i<n; i++)\n\t{\n\t\twyn[pos[i].second]=dwa[(i+k)%n];\n\t}\n\tint li=0;\n\tfor (int i=1; i<=n; i++)\n\t\tli+=(ta[i]>wyn[i]);\n\tif (li!=k)\n\t{\n\t\tans(0);\n\t}\n\telse\n\t{\n\t\tans(1);\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tprintf(\"%d \", wyn[i]);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Matching Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/122172",
    "editorial": "SolutionFor simplicity, assume that both arrays and are sorted in\r\nincreasing order. The final answer can be obtained by permuting the\r\nanswer array using the same permutation to permute sorted array to the\r\noriginal array .Claim: If the rearrangement does not have beauty , it is\r\nnot possible to rearrange to make the beauty equals to .Proof: Suppose\r\nthere exists an alternative rearrangement different from above\r\nrepresented by permutation where results in a beauty of . Let array\r\nrepresent the indices where in increasing order. In other words, and .\r\nLet be the largest index where ( also holds due to strict inequality\r\nabove). We know that and . Since is sorted and , we have , and hence,\r\nand . This means that we can swap with without changing the beauty of\r\nthe array, while allowing . Hence, by doing the swapping repeatedly, we\r\nwill get for all between 1 and .An alternative interpretation to the\r\nresult above is that we managed to obtain a solution where for all\r\nbetween and , we have . On the other hand, for all between and , we have\r\n. Let be the largest index between and where ( due to maximality). Then,\r\nlet be the index where . Consider two cases: . Since is the largest\r\nindex where , this means that and hence . We have and . Hence, we can\r\nswap and without changing the beauty of the array, while allowing . . We\r\nhave and . Hence, we can swap and without changing the beauty of the\r\narray, while allowing . By repeating the above repeatedly, we can obtain\r\na solution where for all between and . Let be the smallest index between\r\nand where ( by minimality). Then, let be the index where . Note that as\r\nwell since for all between and . Since is the smallest index where ,\r\nthis means that and hence . We have and . Hence, we can swap and without\r\nchanging the beauty of the array, while allowing . By doing this\r\nrepeatedly, we can obtain a solution where for all between and . Now, ,\r\nwhich matches the rearrangement in our claim.\r\n"
}