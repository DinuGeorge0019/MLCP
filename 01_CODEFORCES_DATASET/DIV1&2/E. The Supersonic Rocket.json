{
    "link": "https://codeforces.com//contest/1017/problem/E",
    "problemId": "205995",
    "problem_idx": "E",
    "shortId": "1017E",
    "contest_number": "1017",
    "problem_submissions": {
        "D": [
            213438615,
            41349796,
            41350791,
            41348185,
            41349812,
            41350101,
            41348724,
            41347389,
            41349904,
            41347605,
            41349745,
            41349033,
            41348833,
            41350403,
            41348388,
            41346916,
            41354063,
            41351152,
            41351165,
            41350393
        ],
        "G": [
            41374563,
            41365956,
            41365630,
            41370631,
            41581755
        ],
        "E": [
            41372644,
            41354131,
            41370166,
            41371119,
            41372376,
            41372311,
            41372287,
            41351667,
            41351074,
            41355101,
            41350783,
            41352192,
            41358773,
            41351309,
            41350915,
            41353764,
            41670429,
            41352396,
            41371198,
            41367467,
            41359456,
            41372423,
            41372409,
            41364755,
            41352601,
            41351865,
            41355587
        ],
        "H": [
            41367702,
            41388366,
            41626780
        ],
        "F": [
            41355954,
            41350751,
            41350606,
            41351910,
            41355898,
            41353364,
            41356617,
            41361175,
            41354830,
            41361644,
            41363928,
            41363246,
            41362644,
            41355024,
            41364885,
            41350456,
            41363913,
            41365213,
            41366266
        ],
        "C": [
            41344757,
            41346763,
            41343411,
            41343517,
            41344074,
            41345347,
            41344535,
            41344681,
            41344025,
            41345552,
            41345435,
            41344114,
            41346166,
            41344588,
            41343025,
            41345381,
            41348981,
            41347870,
            41345665
        ],
        "B": [
            41341663,
            41342076,
            41341369,
            41340402,
            41341632,
            41341916,
            41341844,
            41341458,
            41340722,
            41342695,
            41342729,
            41341507,
            41343151,
            41342641,
            41340890,
            41341644,
            41344184,
            41342297,
            41342415
        ],
        "A": [
            41338985,
            41339200,
            41339204,
            41344352,
            41339618,
            41339017,
            41339766,
            41339115,
            41339233,
            41339235,
            41340222,
            41339363,
            41338992,
            41339153,
            41339052,
            41339096,
            41339145,
            41339283,
            41339775
        ]
    },
    "name": "E. The Supersonic Rocket",
    "statement": "After the war, the supersonic rocket became the most common public\r\ntransportation.Each supersonic rocket consists of \"\". Each engine is a\r\nset of \"\". The first engine has n power sources, and the second one has\r\nm power sources. A power source can be described as a point (x_i, y_i)\r\non a 2-D plane. All points in each engine are different.You can\r\nmanipulate each engine . There are two operations that you can do with\r\neach engine. You can do each operation as many times as you want. For\r\nevery power source as a whole in that engine: (x_i, y_i) becomes (x_i+a,\r\ny_i+b), a and b can be any real numbers. In other words, all power\r\nsources will be shifted. For every power source as a whole in that\r\nengine: (x_i, y_i) becomes (x_i\r\ncos\r\ntheta - y_i\r\nsin\r\ntheta, x_i\r\nsin\r\ntheta + y_i\r\ncos\r\ntheta),\r\ntheta can be any real number. In other words, all power sources will be\r\nrotated.The engines work as follows: after the two engines are powered,\r\ntheir power sources are being combined (here power sources of different\r\nengines may coincide). If two power sources A(x_a, y_a) and B(x_b, y_b)\r\nexist, then for all real number k that 0\r\nlt k\r\nlt 1, a new power source will be created\r\nC_k(kx_a+(1-k)x_b,ky_a+(1-k)y_b). . After that, the \"\" from all power\r\nsources will be generated (can be considered as an infinite set of all\r\npower sources occurred).A supersonic rocket is \"\" if and only if after\r\nyou manipulate the engines, destroying any power source and then power\r\nthe engine, the power field generated wonâ€™t be changed (comparing to the\r\nsituation where no power source erased). Two power fields are considered\r\nthe same if and only if any power source in one field belongs to the\r\nother one as well.Given a supersonic rocket, check whether it is safe or\r\nnot.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n,m;\n\nll dist(pi A, pi B) {\n    A.f -= B.f, A.s -= B.s;\n    return (ll)A.f*A.f+(ll)A.s*A.s;\n}\n\nll dot(pi O, pi A, pi B) {\n    return (ll)(A.f-O.f)*(B.f-O.f)+(ll)(A.s-O.s)*(B.s-O.s);\n}\n\nll cross(pi O, pi A, pi B) {\n    return (ll)(A.f-O.f)*(B.s-O.s)\n            -(ll)(A.s-O.s)*(B.f-O.f);\n}\n\nvpi convex_hull(vpi P) {\n    sort(all(P)); P.erase(unique(all(P)),P.end());\n    int n = sz(P);\n    if (n == 1) return P;\n    \n    vpi bot = {P[0]};\n    FOR(i,1,n) {\n        while (sz(bot) > 1 && cross(bot[sz(bot)-2], bot.back(), P[i]) <= 0) bot.pop_back();\n        bot.pb(P[i]);\n    }\n    bot.pop_back();\n    \n    vpi up = {P[n-1]};\n    F0Rd(i,n-1) {\n        while (sz(up) > 1 && cross(up[sz(up)-2], up.back(), P[i]) <= 0) up.pop_back();\n        up.pb(P[i]);\n    }\n    up.pop_back();\n    \n    bot.insert(bot.end(),all(up));\n    return bot;\n}\n\nint min_rotation(vl s) {\n\tint a=0, N=sz(s); \n\ts.insert(s.end(),all(s));\n\tF0R(b,N) F0R(i,N) {\n\t\tif (a+i == b || s[a+i] < s[b+i]) {b += max(0, i-1); break;}\n\t\tif (s[a+i] > s[b+i]) { a = b; break; }\n\t}\n\treturn a;\n}\n\nvl rot_min(vl v) {\n    int x = min_rotation(v);\n    rotate(v.begin(),v.begin()+x,v.end());\n    return v;\n}\n\nvl hsh(vpi x) {\n    vl v;\n    F0R(i,sz(x)) {\n        v.pb(dist(x[i],x[(i+1)%sz(x)]));\n        v.pb(4*INF+dot(x[i],x[(i+1)%sz(x)],x[(i+2)%sz(x)]));\n    }\n    return v;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    vpi x(n), y(m);\n    F0R(i,n) cin >> x[i].f >> x[i].s;\n    F0R(i,m) cin >> y[i].f >> y[i].s;\n    x = convex_hull(x), y = convex_hull(y);\n    vl X = hsh(x), Y = hsh(y);\n    X = rot_min(X);\n    Y = rot_min(Y);\n    //for (auto a: X) cout << a << \" \";\n    //cout << \"\\n\";\n    if (X == Y) cout << \"YES\";\n    else cout << \"NO\";\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "hashing",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. The Supersonic Rocket.json",
    "editorial_link": "https://codeforces.com/blog/entry/61081",
    "editorial": "The statement is complicated, it is actually:Given two sets of points,\r\ncheck whether their convex hulls are isomorphic.The standard solution\r\nis: get the convex hulls, make it into a string of traversal:\r\n\"edge-angle-edge-angle-edge-...\". Then double the first string and KMP\r\nthem.There can be other ways to solve this problem, because there is a\r\nuseful condition: all coordinates are integers.Complexity: .\r\n",
    "hint": []
}