{
    "link": "https://codeforces.com//contest/1523/problem/A",
    "problemId": "1000211",
    "problem_idx": "A",
    "shortId": "1523A",
    "contest_number": "1523",
    "problem_submissions": {
        "F": [
            117916146,
            117914065,
            117905350,
            117900425,
            117909780,
            117912951,
            117923029,
            117905457,
            117920531,
            117920496,
            117911483,
            117908634,
            117907048,
            117936734,
            117936707,
            117936638,
            117936633,
            117936625,
            117936608,
            117905940,
            117911622,
            117911227,
            117910828,
            117920430,
            117916378,
            117911950,
            117912347,
            117936103,
            117935723
        ],
        "G": [
            117899863,
            117912955,
            117908386,
            117915802,
            117906341,
            117903204,
            117907803,
            117932659,
            117932628,
            117911801,
            118597582,
            117989759,
            117915684,
            117936837,
            117918793,
            117916945,
            117917431
        ],
        "D": [
            117881477,
            117886244,
            117886334,
            117887661,
            118167966,
            117918101,
            117929591,
            117890786,
            117890676,
            117893739,
            118119250,
            117887458,
            117887290,
            117893940,
            117890382,
            118081143,
            117890914,
            117883607,
            117887959,
            117895275,
            117888883,
            117902109,
            117889374
        ],
        "E": [
            117878219,
            117881962,
            117910641,
            117881787,
            117884807,
            117893823,
            117886171,
            117885405,
            117882043,
            117890552,
            117888754,
            117897027,
            117898439,
            117887443,
            117893294,
            117903524,
            117892701,
            117896279,
            117896129
        ],
        "C": [
            117876664,
            117878149,
            117877887,
            117879093,
            117889641,
            117882853,
            117877348,
            117879069,
            117877404,
            117877723,
            117880898,
            117876222,
            117880296,
            117876946,
            117880601,
            117879874,
            117879926,
            117880242,
            117902829
        ],
        "B": [
            117875490,
            117875567,
            117880589,
            117875816,
            117876680,
            117877360,
            117875700,
            117876723,
            117878349,
            117876280,
            117877999,
            117880072,
            117876899,
            117875787,
            117877756,
            117876654,
            117875833,
            117878179,
            117879465
        ],
        "A": [
            117874746,
            117874821,
            117882081,
            117874974,
            117874835,
            117874828,
            117874778,
            117874933,
            117874911,
            117874900,
            117876005,
            117883186,
            117874918,
            117874908,
            117875902,
            117874738,
            117874753,
            117874913,
            117876371
        ],
        "H": [
            117981868,
            117981132,
            118023855,
            118349130,
            117933591,
            118312467,
            118312428,
            119224810
        ]
    },
    "name": "A. Game of Life",
    "statement": "William really likes the cellular automaton called \"Game of Life\" so he\r\ndecided to make his own version. For simplicity, William decided to\r\ndefine his cellular automaton on an array containing n cells, with each\r\ncell either being alive or dead.Evolution of the array in William’s\r\ncellular automaton occurs iteratively in the following way: If the\r\nelement is dead and it has 1 alive neighbor , then on the next iteration\r\nit will become alive. For an element at index i the neighbors would be\r\nelements with indices i - 1 and i + 1. If there is no element at that\r\nindex, it is considered to be a dead neighbor. William is a humane\r\nperson so all alive elements stay alive. Check the note section for\r\nexamples of the evolution.You are given some initial state of all\r\nelements and you need to help William find the state of the array after\r\nm iterations of evolution.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.05.2021 17:34:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int beg = 0;\n    while (beg < n) {\n      if (s[beg] == '1') {\n        ++beg;\n        continue;\n      }\n      int end = beg;\n      while (end + 1 < n && s[end + 1] == '0') {\n        ++end;\n      }\n      if (beg == 0 && end == n - 1) {\n      } else {\n        if (beg == 0) {\n          for (int j = end; j >= beg && j >= end - m + 1; j--) {\n            s[j] = '1';\n          }\n        } else {\n          if (end == n - 1) {\n            for (int j = beg; j <= end && j <= beg + m - 1; j++) {\n              s[j] = '1';\n            }\n          } else {\n            int i = beg;\n            int j = end;\n            for (int it = 0; i < j && it < m; it++) {\n              s[i] = s[j] = '1';\n              i += 1;\n              j -= 1;\n            }\n          }\n        }\n      }\n      beg = end + 1;\n    }\n    cout << s << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\A. Game of Life.json",
    "editorial_link": "https://codeforces.com//blog/entry/91271",
    "editorial": "Notice that evolution will go on for no more than iterations, since on\r\neach iteration at least one new living cell will appear, and if it\r\ndoesnât this would mean that we remain in the same state as on the\r\nprevious step and the simulation is over. Knowing this we can write a\r\nsimple simulation of the process described in the problem statement,\r\nwhich would process each iteration in .Final complexity: .\r\n",
    "hint": []
}