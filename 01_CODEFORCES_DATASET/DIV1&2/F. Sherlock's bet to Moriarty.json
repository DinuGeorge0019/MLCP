{
    "link": "https://codeforces.com//contest/776/problem/F",
    "problemId": "95210",
    "problem_idx": "F",
    "shortId": "776F",
    "contest_number": "776",
    "problem_submissions": {
        "G": [
            24939347,
            24933167,
            24937192,
            24938688,
            24939300,
            24936369,
            24933254,
            24936389,
            24938260,
            50496579,
            24939610,
            24974394,
            24937125,
            24938166,
            24937440
        ],
        "F": [
            24931137,
            24940601,
            24934717,
            24935180,
            24936216,
            24930744,
            24935991,
            24934536,
            24933196,
            24934631,
            25009829,
            24934356,
            24935407,
            25145968,
            24938938
        ],
        "E": [
            24926469,
            24922427,
            24928701,
            24929827,
            24927281,
            24926330,
            24922998,
            24928645,
            24928568,
            24927117,
            24927967,
            24932026,
            24926259,
            24928494,
            24925814,
            24933222,
            24929687,
            24929132
        ],
        "D": [
            24923588,
            24926240,
            24925398,
            24926362,
            24924696,
            24942987,
            24926743,
            24925181,
            24923636,
            24922793,
            24927891,
            24924422,
            24923885,
            24928078,
            25388280,
            24929601,
            24924674,
            24952921,
            24926279
        ],
        "A": [
            24920848,
            24918716,
            24917411,
            24917501,
            24928258,
            24917338,
            24918133,
            24917381,
            24917351,
            24917379,
            24917385,
            24917553,
            24917364,
            24918205,
            24917450,
            24917668,
            24918624
        ],
        "C": [
            24919677,
            24924230,
            24922174,
            24922015,
            24918784,
            24920506,
            24921334,
            24921898,
            24920669,
            24950107,
            24929487,
            24921634,
            24921526,
            24921083,
            24921835,
            25114288,
            24921821,
            24922186,
            24923226
        ],
        "B": [
            24917670,
            24919248,
            24918919,
            24919261,
            24920428,
            24918897,
            24919671,
            24919894,
            24918987,
            24918567,
            24918525,
            24922327,
            24918984,
            24918395,
            24919865,
            24919010,
            24920231,
            24920427
        ]
    },
    "name": "F. Sherlock's bet to Moriarty",
    "statement": "Sherlock met Moriarty for a final battle of wits. He gave him a regular\r\nsided convex polygon. In addition to it, he gave him certain diagonals\r\nto form regions on the polygon. It was guaranteed that the diagonals did\r\nnot intersect in interior points.He took each of the region and\r\ncalculated its importance value. Importance value for a region formed by\r\nvertices of the polygon will be given by . Then, he sorted these regions\r\non the basis of their importance value in ascending order. After that he\r\nassigned each region an index from to , where is the number of regions,\r\nand index of region is its position in the sorted array calculated\r\nabove.He wants Moriarty to color the regions using not more than colors,\r\nsuch that two regions have same color only if all the simple paths\r\nbetween these two regions have at least one region with color value less\r\nthan the color value assigned to these regions. Simple path between two\r\nregions and is a sequence of regions such that , , for each regions and\r\nshare an edge, and if and only if .Moriarty couldn\u2019t answer and asks\r\nSherlock to solve it himself. Help Sherlock in doing so.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define pii pair<int,int>\nusing namespace std;\nint n, m, cc, cnt, AL;\nvector<pii>E[101000];\nvector<int>G[201000], F[201000];\nint Num[501000], Col[201000];\nvoid Go(int b, int e){\n    G[cnt].push_back(e);\n    int t = lower_bound(E[e].begin(),E[e].end(), pii(b,0)) - E[e].begin();\n    pii tp = E[e][(t+1)%E[e].size()];\n    if(Num[tp.second])return;\n    Num[tp.second] = cnt;\n    Go(e, tp.first);\n}\nint chk[201000], C[201000];\nvoid DFS(int a, int pp){\n    int i, x;\n    C[a] = 1;\n    for(i=0;i<F[a].size();i++){\n        x = F[a][i];\n        if(chk[x] || x==pp)continue;\n        DFS(x, a);\n        C[a] += C[x];\n    }\n}\nint DFS2(int a, int pp, int MM){\n    int i, x;\n    for(i=0;i<F[a].size();i++){\n        x = F[a][i];\n        if(chk[x] || x==pp)continue;\n        if(C[x] * 2 > MM)return DFS2(x, a, MM);\n    }\n    return a;\n}\nint get_mid(int a){\n    DFS(a,0);\n    if(C[a]==1)return 0;\n    return DFS2(a,0,C[a]);\n}\nvoid Do(int a, int dep){\n    int mid = get_mid(a);\n    if(!mid){\n        Col[a] = dep;\n        return;\n    }\n    Col[mid] = dep;\n    int i;\n    chk[mid] = 1;\n    for(i=0;i<F[mid].size();i++){\n        if(!chk[F[mid][i]]) Do(F[mid][i], dep+1);\n    }\n    chk[mid] = 0;\n}\nstruct AA{\n    long long g;\n    int num;\n    bool operator<(const AA &p)const{\n        return g<p.g;\n    }\n}ord[201000];\nint main(){\n    int i, a, b, j;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d\",&a,&b);\n        E[a].push_back(pii(b,cc++));\n        E[b].push_back(pii(a,cc++));\n    }\n    for(i=1;i<=n;i++){\n        E[i].push_back(pii(i%n+1,cc++));\n        E[i%n+1].push_back(pii(i,cc++));\n    }\n    for(i=1;i<=n;i++){\n        sort(E[i].begin(),E[i].end());\n    }\n    for(i=1;i<=n;i++){\n        for(j=0;j<E[i].size();j++){\n            if(!Num[E[i][j].second]){\n                cnt++;\n                Num[E[i][j].second] = cnt;\n                Go(i,E[i][j].first);\n            }\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(G[i].size() == n && !AL)AL = i;\n    }\n    for(i=0;i<cc;i++){\n        if(Num[i]!=AL && Num[i^1]!=AL)F[Num[i]].push_back(Num[i^1]);\n    }\n    int rt = 1;\n    if(AL==1)rt++;\n    Do(rt, 1);\n    int ccc = 0;\n    for(i=1;i<=cnt;i++){\n        if(i==AL)continue;\n        sort(G[i].begin(),G[i].end());\n        long long ss = 0;\n        for(j=0;j<2;j++){\n            ss *= 1000000;\n            ss += G[i][G[i].size()-j-1];\n        }\n        ord[ccc++]={ss,i};\n    }\n    sort(ord,ord+ccc);\n    for(i=0;i<ccc;i++){\n        printf(\"%d \",Col[ord[i].num]);\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "divide and conquer",
        "geometry",
        "graphs",
        "implementation",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Sherlock's bet to Moriarty.json",
    "editorial_link": "https://codeforces.com//blog/entry/50622",
    "editorial": ": Observe that if we consider all regions as nodes for a graph and\r\nconnect two regions if they share an edge (in the form of sharing a\r\ndiagonal), we will get a tree.: Use a greedy approach to form a tree\r\nfrom the given polygon. Let us take one diagonal between vertex and .\r\nLet us define a value as minimum of two values and . Sort all the\r\ndiagonals on the basis of this value . This value is the minimum number\r\nof nodes between and . Remove the diagonals one by one. We can see that\r\na new region will be formed each time which cannot be divided further,\r\nand this region will be formed on the side from where we got the value\r\nof . Thus we can get the nodes in each region and form a tree. Then,\r\nthis problem reduces to coloring the tree such that two regions have\r\nsame color only if atleast one node between the two nodes with same\r\ncolor has a color with lesser value. This can be done by using the\r\ndivide and conquer technique of centroid decomposition. Give each height\r\nin centroid tree a different color in increasing order.:\r\n"
}