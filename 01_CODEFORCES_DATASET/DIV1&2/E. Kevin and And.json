{
    "link": "https://codeforces.com//contest/2061/problem/E",
    "problemId": "3155958",
    "problem_idx": "E",
    "shortId": "2061E",
    "contest_number": "2061",
    "problem_submissions": {
        "F2": [
            302127475,
            302092403,
            302114656,
            302114350,
            302118052,
            302128136,
            302099327,
            302127501,
            302105569,
            302158287,
            302158231,
            302158981,
            302158740,
            302158593,
            302155955
        ],
        "H1": [
            302102508,
            302123846,
            302123275,
            302120307,
            302128240,
            302113263,
            302214973,
            302214838,
            302492170,
            302128311,
            302150853
        ],
        "G": [
            302087277,
            302104836,
            302092310,
            302101290,
            302098614,
            302099751,
            302090244,
            302079497,
            302107342,
            302102846,
            302118471,
            302119832,
            302088828,
            302085801,
            302097252,
            302107147,
            302100360,
            302104471
        ],
        "F1": [
            302070705,
            302068249,
            302076903,
            302139304,
            302085853,
            302085964,
            302087951,
            302076823,
            302099111,
            302088499,
            302088697,
            302106078,
            302076066,
            302095307,
            302083979,
            302077009,
            302082649,
            302158914,
            302081283
        ],
        "E": [
            302060766,
            302059898,
            302064375,
            302146780,
            302146561,
            302146204,
            302145996,
            302145832,
            302145821,
            302145812,
            302060519,
            302071650,
            302062756,
            302067337,
            302066558,
            302071373,
            302078018,
            302075359,
            302069841,
            302067118,
            302063628,
            302073608,
            302071649,
            302075889,
            302072748
        ],
        "D": [
            302057147,
            302056206,
            302056876,
            302056600,
            302064486,
            302056648,
            302061458,
            302060302,
            302063595,
            302065433,
            302068805,
            302064352,
            302061742,
            302059104,
            302069059,
            302065232,
            302069194,
            302062940
        ],
        "C": [
            302053893,
            302052972,
            302060290,
            302053477,
            302058781,
            302053556,
            302058513,
            302056661,
            302060439,
            302057971,
            302066087,
            302059912,
            302059144,
            302055184,
            302066070,
            302060621,
            302062953,
            302059461
        ],
        "B": [
            302048946,
            302050832,
            302052328,
            302049723,
            302053638,
            302049221,
            302054664,
            302052475,
            302055824,
            302052997,
            302059041,
            302057352,
            302051579,
            302051983,
            302056196,
            302056129,
            302055478,
            302054565
        ],
        "A": [
            302047037,
            302049009,
            302047309,
            302047023,
            302047283,
            302047053,
            302047177,
            302047108,
            302047316,
            302047521,
            302047571,
            302047610,
            302047369,
            302048738,
            302047337,
            302048364,
            302049028,
            302047123
        ],
        "H2": [
            302541217
        ],
        "I": [
            302144176,
            302142123,
            302142064,
            302141919,
            302124920,
            302518298,
            302518173,
            302517883
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138620",
    "editorial": "For a fixed , let represent the number obtained after applying the\r\noperations in set to . Define as the minimum value of for all subsets\r\nwith , i.e., . : The function is convex, that is for all (), the\r\ninequality holds.: Let be the value corresponding to the minimum of ,\r\nand let correspond to the minimum of . Suppose the -th bit is the\r\nhighest bit where and differ.We can always find an operation that turns\r\nthe -th bit in into . In this case, we have: Moreover, since the highest\r\nbit where and differ is no greater than , we have: Combining these\r\ninequalities gives: proving the convexity of . For each number , we can\r\nuse brute force to compute the minimum value obtained after applying\r\noperations, denoted as . From the lemma, we know that the difference is\r\nnon-increasing.Thus, when performing operations on this number, the\r\nreductions in value are:You need to perform operations in total. To\r\nminimize the result, you can choose the largest reductions from all\r\npossible operations. This can be done by sorting all operations by their\r\ncost or by using std::nth_element.Time complexity:\r\n",
    "name": "E. Kevin and And",
    "statement": "Kevin has an integer sequence a of length n. At the same time, Kevin has\r\nm types of magic, where the i-th type of magic can be represented by an\r\ninteger b_i.Kevin can perform at most k (possibly zero) magic\r\noperations. In each operation, Kevin can do the following: Choose two\r\nindices i (1\r\nleq i\r\nleq n) and j (1\r\nleq j\r\nleq m), and then update a_i to a_i\r\n&\r\nb_j. Here,\r\n& denotes the bitwise AND operation. Find the minimum possible sum of\r\nall numbers in the sequence a after performing at most k operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;using u128 = unsigned __int128; void solve() {    int n, m, k;    std::cin >> n >> m >> k;        std::vector<int> a(n), b(m);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    for (int i = 0; i < m; i++) {        std::cin >> b[i];    }        i64 ans = std::accumulate(a.begin(), a.end(), 0LL);        std::vector<int> f(1 << m);    f[0] = (1 << 30) - 1;    for (int s = 1; s < (1 << m); s++) {        int u = __builtin_ctz(s);        f[s] = f[s ^ (1 << u)] & b[u];    }        std::vector<int> h;    h.reserve(n * m);    for (int i = 0; i < n; i++) {        std::vector<int> g(m + 1);        for (int s = 0; s < (1 << m); s++) {            int c = __builtin_popcount(s);            g[c] = std::max(g[c], a[i] - (a[i] & f[s]));        }        for (int j = 1; j <= m; j++) {            h.push_back(g[j] - g[j - 1]);        }    }    std::sort(h.begin(), h.end(), std::greater());        for (int i = 0; i < h.size() && i < k; i++) {        ans -= h[i];    }        std::cout << ans << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Kevin and And.json"
}