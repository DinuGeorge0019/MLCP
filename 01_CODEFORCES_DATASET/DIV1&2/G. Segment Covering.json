{"link": "https://codeforces.com//contest/1774/problem/G", "problemId": "1697948", "problem_idx": "G", "shortId": "1774G", "contest_number": "1774", "problem_submissions": {"G": [185692788, 185688701, 185709786, 185704068, 185700930, 185701804, 185702434, 185710209, 185706872, 185904256, 185795210, 185793397, 185819250], "F2": [185676745, 185670281, 185675729, 185668671, 185681524, 185686567, 185677180, 185669013, 185668157, 185689966, 185688723, 185695825, 185693474, 185692885, 185688234, 185691854, 185681271, 185694474, 185685579], "F1": [185676593, 185670463, 185663684, 185668833, 185681601, 185716882, 185686479, 185674297, 185669194, 185668049, 185679440, 185670075, 185683714, 185693266, 185692482, 185683082, 185681999, 185681061, 185687683, 185683570], "E": [185655499, 185660825, 185651479, 185656124, 185655058, 185662458, 185662357, 185652494, 185657012, 185662649, 185653972, 185662778, 185664782, 185668838, 185669645, 185656956, 185667038, 185672369, 185663098], "D": [185649610, 185653248, 185643125, 185650993, 185649142, 185653531, 185657439, 185657348, 185650869, 185657200, 185661330, 185657425, 185655644, 185661084, 185663734, 185649769, 185662028, 185662351, 185658693], "A": [185644231, 185636102, 185635462, 185635619, 185635678, 185635790, 185637888, 185635854, 185636970, 185636959, 185635664, 185635988, 185635613, 185637777, 185636615, 185635469, 185636037, 185640093, 185635898], "B": [185642990, 185641490, 185645977, 185640363, 185639666, 185641314, 185642797, 185639691, 185640833, 185692584, 185643672, 185638403, 185645169, 185646911, 185640445, 185643451, 185646071, 185642995], "C": [185639008, 185648162, 185647183, 185644645, 185643844, 185645738, 185648229, 185644184, 185645698, 185650776, 185648822, 185648683, 185646713, 185653638, 185655962, 185643940, 185653656, 185654108, 185651616]}, "name": "G. Segment Covering", "statement": "ChthollyNotaSeniorious gives DataStructures a number axis with m\r\ndistinct segments on it. Let f(l,r) be the number of ways to choose an\r\neven number of segments such that the union of them is exactly [l,r],\r\nand g(l,r) be the number of ways to choose an odd number of segments\r\nsuch that the union of them is exactly [l,r].ChthollyNotaSeniorious\r\nasked DataStructures q questions. In each query, ChthollyNotaSeniorious\r\nwill give DataStructures two numbers l, r, and now he wishes that you\r\ncan help him find the value f(l,r)-g(l,r) modulo 998\r\n,244\r\n,353 so that he wouldn\u2019t let her down.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint n, m;\npii a[N];\npii b[N];\nint cntBad[N];\nint par[N][LOG];\nint h[N];\n\nint up(int v, int dh) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((dh >> k) & 1)\n\t\t\tv = par[v][k];\n\treturn v;\n}\nint LCA(int v, int u) {\n\tif (h[v] > h[u]) swap(v, u);\n\tu = up(u, h[u] - h[v]);\n\tif (v == u) return v;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (par[v][k] != par[u][k]) {\n\t\t\tv = par[v][k];\n\t\t\tu = par[u][k];\n\t\t}\n\t}\n\treturn par[v][0];\n}\nbool isPar(int v, int u) {\n\treturn h[v] <= h[u] && up(u, h[u] - h[v]) == v;\n}\n\nint solve(int l, int r) {\n\tint v = lower_bound(a, a + n, mp(l, -1)) - a;\n\tif (v == n || a[v].first != l) return 0;\n\tint u = lower_bound(b, b + n, mp(r, -1)) - b;\n\tif (u == n || b[u].first != r) return 0;\n\teprintf(\"go %d %d\\n\", v, u);\n\tif (cntBad[v] != cntBad[u]) return 0;\n\tif (u < v) return 0;\n\tif (v == u) return -1;\n\tif (LCA(v, v + 1) <= u) return 0;\n\tif (isPar(u, v)) return -1;\n\tif (isPar(u, v + 1)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint q;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &a[i].first, &a[i].second);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (m > 0 && a[i].first == b[m - 1].first) continue;\n\t\twhile(m > 0 && a[i].second <= b[m - 1].second) m--;\n\t\tb[m++] = a[i];\n\t}\n\tn = m;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = b[i];\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(\"(%d %d)\\n\", a[i].first, a[i].second);\n\tfor (int i = 1; i < n; i++) {\n\t\tassert(a[i - 1].first < a[i].first);\n\t\tassert(a[i - 1].second < a[i].second);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = mp(a[i].second, a[i].first);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tcntBad[i] = cntBad[i - 1];\n\t\tif (a[i].first > a[i - 1].second) cntBad[i]++;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tpar[i][k] = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = lower_bound(a, a + n, mp(a[i].second + 1, -1)) - a;\n\t\tif (v == n) continue;\n\t\tif (cntBad[v] != cntBad[i]) continue;\n\t\teprintf(\"par[%d] = %d\\n\", i, v);\n\t\tpar[i][0] = v;\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t\th[i] = h[par[i][0]] + 1;\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tpar[v][k + 1] = par[par[v][k]][k];\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tint ans = solve(l, r);\n\t\tif (ans < 0) ans += 998244353;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "constructive algorithms", "data structures", "dp", "trees"], "dificulty": "3200", "interactive": false}