{"link": "https://codeforces.com//contest/799/problem/F", "problemId": "105988", "problem_idx": "F", "shortId": "799F", "contest_number": "799", "problem_submissions": {"E": [27057040, 27057010, 27056967, 27026697, 27023753, 27025405, 27024865, 27030424, 27025641, 27029307, 27027415, 27027135, 27026445, 27030147, 27029255, 27030374, 27031127, 27029721, 27029453, 27032096], "G": [27036616], "F": [27030563, 27037422, 27034476, 27039260, 27041363, 27040801, 27291324], "D": [27022631, 27022286, 27020681, 27021344, 27021554, 27023148, 27022862, 27020910, 27023070, 27022767, 27023676, 27022207, 27023905, 27022671, 27022391, 27023340, 27022748, 27022866], "B": [27019416, 27017594, 27035489, 27019723, 27017243, 27017666, 27017468, 27016992, 27017464, 27018383, 27017219, 27017196, 27017940, 27020412, 27017770, 27018390, 27017823, 27017563], "C": [27018858, 27019675, 27018439, 27017585, 27019861, 27019164, 27019715, 27019543, 27019587, 27021111, 27021089, 27019694, 27020343, 27018899, 27020067, 27020926, 27019896, 27020090], "A": [27018375, 27016569, 27037894, 27018311, 27016502, 27016795, 27016557, 27016497, 27016519, 27016617, 27016531, 27016564, 27016580, 27016596, 27016533, 27016606, 27016598, 27016653]}, "name": "F. Beautiful fountains rows", "statement": "Butler Ostin wants to show Arkady that rows of odd number of fountains\r\nare beautiful, while rows of even number of fountains are not.The butler\r\nwants to show Arkady gardens. Each garden is a row of cells, the -th\r\ngarden has one fountain in each of the cells between and inclusive, and\r\nthere are no more fountains in that garden. The issue is that some of\r\nthe gardens contain even number of fountains, it is wrong to show them\r\nto Arkady.Ostin wants to choose two integers and show only part of each\r\nof the gardens that starts at cell and ends at cell . Of course, only\r\nsuch segments suit Ostin that each garden has either zero or odd number\r\nof fountains on this segment. Also, it is necessary that at least one\r\ngarden has at least one fountain on the segment from to .Help Ostin to\r\nfind the total length of all such segments, i.e. sum up the value for\r\neach suitable pair .\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200010;\n\nstruct fenwick {\n  long long fenw[2][N];\n\n  fenwick() {\n    for (int i = 0; i < N; i++) {\n      fenw[0][i] = fenw[1][i] = 0;\n    }\n  }\n\n  void modify(int q, int x, int v) {\n    while (x < N) {\n      fenw[q][x] += v;\n      x = (x | (x - 1)) + 1;\n    }\n  }\n\n  long long find_sum(int q, int x) {\n    long long v = 0;\n    while (x > 0) {\n      v += fenw[q][x];\n      x &= x - 1;\n    }\n    return v;\n  }\n\n  long long find_sum(int q, int ll, int rr) {\n    return find_sum(q, rr) - find_sum(q, ll - 1);\n  }\n} tree[2];\n\nvector <int> ev_l[N], ev_r[N];\nbool none[N];\nint l[N], r[N];\n\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", l + i, r + i);\n    ev_l[l[i]].push_back(i);\n    ev_r[r[i]].push_back(i);\n  }\n  set <int> all[2];\n  for (int i = 1; i <= m; i++) {\n    tree[i % 2].modify(0, (i + 1) / 2, 1);\n    tree[i % 2].modify(1, (i + 1) / 2, i);\n    all[i % 2].insert(i);\n  }\n  long long ans = 0;\n  multiset <int> open_l[2];\n  int global = 1;\n  for (int rg = 1; rg <= m; rg++) {\n    for (int i : ev_l[rg]) {\n      // add to open\n      open_l[l[i] % 2].insert(l[i]);\n    }\n    int lg = global;\n    if (!open_l[1 - rg % 2].empty()) {\n      lg = max(lg, (*(--open_l[1 - rg % 2].end())) + 1);\n    }\n    int up_bad_parity = rg - 1;\n    for (int par = 0; par < 2; par++) {\n      if (!open_l[par].empty()) {\n        int ll = (*(open_l[par].begin()));\n        if (ll % 2 == rg % 2) {\n          up_bad_parity = min(up_bad_parity, ll - 1);\n        } else {\n          up_bad_parity = min(up_bad_parity, -1);\n        }\n      }\n    }\n    for (int par = 0; par < 2; par++) {\n      int from = lg;\n      int to = rg;\n      if (par != rg % 2) {\n        to = min(to, up_bad_parity);\n      }\n      while (from <= to && from % 2 != par) {\n        from++;\n      }\n      while (from <= to && to % 2 != par) {\n        to--;\n      }\n      if (from <= to) {\n        long long cnt = tree[par].find_sum(0, (from + 1) / 2, (to + 1) / 2);\n        long long sum = tree[par].find_sum(1, (from + 1) / 2, (to + 1) / 2);\n        ans += (rg + 1) * cnt - sum;\n      }\n    }\n    for (int i : ev_r[rg]) {\n      // add to close\n      open_l[l[i] % 2].erase(open_l[l[i] % 2].find(l[i]));\n      if ((r[i] - l[i] + 1) % 2 == 0) {\n        global = max(global, l[i] + 1);\n      }\n      while (true) {\n        auto it = all[1 - rg % 2].lower_bound(l[i]);\n        if (it == all[1 - rg % 2].end()) {\n          break;\n        }\n        if ((*it) > r[i]) {\n          break;\n        }\n        int v = (*it);\n        tree[v % 2].modify(0, (v + 1) / 2, -1);\n        tree[v % 2].modify(1, (v + 1) / 2, -v);\n        all[1 - rg % 2].erase(it);\n      }\n    }\n  }\n  set <int> help;\n  for (int i = 1; i <= m; i++) {\n    for (int j : ev_l[i]) {\n      help.insert(j);\n    }\n    none[i] = (help.empty());\n    for (int j : ev_r[i]) {\n      help.erase(j);\n    }\n  }\n  int cc = 0;\n  for (int i = 1; i <= m; i++) {\n    if (none[i]) {\n      cc++;\n      ans -= (long long) cc * (cc + 1) / 2;\n    } else {\n      cc = 0;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3500", "interactive": false}