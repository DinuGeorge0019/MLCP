{
    "link": "https://codeforces.com//contest/799/problem/F",
    "problemId": "105988",
    "problem_idx": "F",
    "shortId": "799F",
    "contest_number": "799",
    "problem_submissions": {
        "E": [
            27057040,
            27057010,
            27056967,
            27026697,
            27023753,
            27025405,
            27024865,
            27030424,
            27025641,
            27029307,
            27027415,
            27027135,
            27026445,
            27030147,
            27029255,
            27030374,
            27031127,
            27029721,
            27029453,
            27032096
        ],
        "G": [
            27036616
        ],
        "F": [
            27030563,
            27037422,
            27034476,
            27039260,
            27041363,
            27040801,
            27291324
        ],
        "D": [
            27022631,
            27022286,
            27020681,
            27021344,
            27021554,
            27023148,
            27022862,
            27020910,
            27023070,
            27022767,
            27023676,
            27022207,
            27023905,
            27022671,
            27022391,
            27023340,
            27022748,
            27022866
        ],
        "B": [
            27019416,
            27017594,
            27035489,
            27019723,
            27017243,
            27017666,
            27017468,
            27016992,
            27017464,
            27018383,
            27017219,
            27017196,
            27017940,
            27020412,
            27017770,
            27018390,
            27017823,
            27017563
        ],
        "C": [
            27018858,
            27019675,
            27018439,
            27017585,
            27019861,
            27019164,
            27019715,
            27019543,
            27019587,
            27021111,
            27021089,
            27019694,
            27020343,
            27018899,
            27020067,
            27020926,
            27019896,
            27020090
        ],
        "A": [
            27018375,
            27016569,
            27037894,
            27018311,
            27016502,
            27016795,
            27016557,
            27016497,
            27016519,
            27016617,
            27016531,
            27016564,
            27016580,
            27016596,
            27016533,
            27016606,
            27016598,
            27016653
        ]
    },
    "name": "F. Beautiful fountains rows",
    "statement": "Butler Ostin wants to show Arkady that rows of odd number of fountains\r\nare beautiful, while rows of even number of fountains are not.The butler\r\nwants to show Arkady gardens. Each garden is a row of cells, the -th\r\ngarden has one fountain in each of the cells between and inclusive, and\r\nthere are no more fountains in that garden. The issue is that some of\r\nthe gardens contain even number of fountains, it is wrong to show them\r\nto Arkady.Ostin wants to choose two integers and show only part of each\r\nof the gardens that starts at cell and ends at cell . Of course, only\r\nsuch segments suit Ostin that each garden has either zero or odd number\r\nof fountains on this segment. Also, it is necessary that at least one\r\ngarden has at least one fountain on the segment from to .Help Ostin to\r\nfind the total length of all such segments, i.e. sum up the value for\r\neach suitable pair .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200010;\n\nstruct fenwick {\n  long long fenw[2][N];\n\n  fenwick() {\n    for (int i = 0; i < N; i++) {\n      fenw[0][i] = fenw[1][i] = 0;\n    }\n  }\n\n  void modify(int q, int x, int v) {\n    while (x < N) {\n      fenw[q][x] += v;\n      x = (x | (x - 1)) + 1;\n    }\n  }\n\n  long long find_sum(int q, int x) {\n    long long v = 0;\n    while (x > 0) {\n      v += fenw[q][x];\n      x &= x - 1;\n    }\n    return v;\n  }\n\n  long long find_sum(int q, int ll, int rr) {\n    return find_sum(q, rr) - find_sum(q, ll - 1);\n  }\n} tree[2];\n\nvector <int> ev_l[N], ev_r[N];\nbool none[N];\nint l[N], r[N];\n\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", l + i, r + i);\n    ev_l[l[i]].push_back(i);\n    ev_r[r[i]].push_back(i);\n  }\n  set <int> all[2];\n  for (int i = 1; i <= m; i++) {\n    tree[i % 2].modify(0, (i + 1) / 2, 1);\n    tree[i % 2].modify(1, (i + 1) / 2, i);\n    all[i % 2].insert(i);\n  }\n  long long ans = 0;\n  multiset <int> open_l[2];\n  int global = 1;\n  for (int rg = 1; rg <= m; rg++) {\n    for (int i : ev_l[rg]) {\n      // add to open\n      open_l[l[i] % 2].insert(l[i]);\n    }\n    int lg = global;\n    if (!open_l[1 - rg % 2].empty()) {\n      lg = max(lg, (*(--open_l[1 - rg % 2].end())) + 1);\n    }\n    int up_bad_parity = rg - 1;\n    for (int par = 0; par < 2; par++) {\n      if (!open_l[par].empty()) {\n        int ll = (*(open_l[par].begin()));\n        if (ll % 2 == rg % 2) {\n          up_bad_parity = min(up_bad_parity, ll - 1);\n        } else {\n          up_bad_parity = min(up_bad_parity, -1);\n        }\n      }\n    }\n    for (int par = 0; par < 2; par++) {\n      int from = lg;\n      int to = rg;\n      if (par != rg % 2) {\n        to = min(to, up_bad_parity);\n      }\n      while (from <= to && from % 2 != par) {\n        from++;\n      }\n      while (from <= to && to % 2 != par) {\n        to--;\n      }\n      if (from <= to) {\n        long long cnt = tree[par].find_sum(0, (from + 1) / 2, (to + 1) / 2);\n        long long sum = tree[par].find_sum(1, (from + 1) / 2, (to + 1) / 2);\n        ans += (rg + 1) * cnt - sum;\n      }\n    }\n    for (int i : ev_r[rg]) {\n      // add to close\n      open_l[l[i] % 2].erase(open_l[l[i] % 2].find(l[i]));\n      if ((r[i] - l[i] + 1) % 2 == 0) {\n        global = max(global, l[i] + 1);\n      }\n      while (true) {\n        auto it = all[1 - rg % 2].lower_bound(l[i]);\n        if (it == all[1 - rg % 2].end()) {\n          break;\n        }\n        if ((*it) > r[i]) {\n          break;\n        }\n        int v = (*it);\n        tree[v % 2].modify(0, (v + 1) / 2, -1);\n        tree[v % 2].modify(1, (v + 1) / 2, -v);\n        all[1 - rg % 2].erase(it);\n      }\n    }\n  }\n  set <int> help;\n  for (int i = 1; i <= m; i++) {\n    for (int j : ev_l[i]) {\n      help.insert(j);\n    }\n    none[i] = (help.empty());\n    for (int j : ev_r[i]) {\n      help.erase(j);\n    }\n  }\n  int cc = 0;\n  for (int i = 1; i <= m; i++) {\n    if (none[i]) {\n      cc++;\n      ans -= (long long) cc * (cc + 1) / 2;\n    } else {\n      cc = 0;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F. Beautiful fountains rows.json",
    "editorial_link": "https://codeforces.com/blog/entry/51947",
    "editorial": "Let\u00e2\u0080\u0099s describe an solution first. Let\u00e2\u0080\u0099s try all possible pairs and check\r\nif they suit us. Let\u00e2\u0080\u0099s try all values of from to .Let garden denote a\r\ngarden with fountains from to , and let\u00e2\u0080\u0099s say that a garden a position\r\nfor a fixed if there is non-zero even number of fountains on the segment\r\n, i.e. the pair doesn\u00e2\u0080\u0099t suit Ostin due to this garden.Now there are two\r\ntypes of gardens we want consider: gardens of the first type start have\r\nform where , , and gardens of the second type have form where .The\r\ngardens of the second type ban such positions equal to , and maybe if is\r\neven. These positions do not depend on , we can keep an array that tells\r\nus how many gardens ban each position of . Initially, we add to all such\r\npositions for each garden, and we remove that when the passes beyond the\r\nleft bound of that garden.Let be the set of right ends of all gardens of\r\nthe first type. These gardens ban positions , where is bounded by the\r\nmaximum element in . Also, if there is a value in such that is even,\r\nthen all positions are banned as well. We\u00e2\u0080\u0099re interested in the minimum\r\nvalue of such that is even, so, we can keep two separate sets and for\r\neven and odd values, and look for the minimum in one of them.So, it\u00e2\u0080\u0099s\r\neasy now to determine if a pair is suitable or not. We can try all ,\r\ncheck is there is at least one fountain on and add to the answer if the\r\npair is suitable.Let\u00e2\u0080\u0099s improve the solution to . We can note that each\r\noperation that changes banned positions for the second type gardens is a\r\nrange query over odd or even numbers. So we can handle it with segment\r\ntree with range queries. Similarly, the gardens of the first type reduce\r\nnon-banned positions of each parity to some segment, so we can do a\r\nrange query to count the number of non-banned positions in the two trees\r\ndescribed. The overall complexity is .\r\n"
}