{
    "link": "https://codeforces.com//contest/1037/problem/C",
    "problemId": "214572",
    "problem_idx": "C",
    "shortId": "1037C",
    "contest_number": "1037",
    "problem_submissions": {
        "G": [
            42400284,
            42399505,
            42393700,
            42391956,
            42395688,
            49109531,
            42416815,
            42416802,
            42408231,
            42478375,
            42723385,
            42723256
        ],
        "H": [
            42390789,
            42393047,
            42400959,
            42399660,
            42398441,
            42399087,
            42414998,
            42453023,
            42876495,
            42876025,
            42875988,
            42875931
        ],
        "E": [
            42383633,
            42376516,
            42374024,
            42375460,
            42374374,
            42376325,
            42382856,
            42374364,
            42376990,
            42377973,
            42378251,
            42378271,
            42378643,
            42380819,
            42380647,
            42383308,
            42382412,
            42381355
        ],
        "F": [
            42381395,
            42382506,
            42383872,
            42380708,
            42386216,
            42379786,
            42391156,
            42378290,
            42387714,
            42379959,
            42384150,
            42386649,
            42388704,
            42386435,
            42387614,
            42390065,
            42389970,
            42390483
        ],
        "D": [
            42369087,
            42370798,
            42380041,
            42371136,
            42379827,
            42374961,
            42370290,
            42370315,
            42380263,
            42370259,
            42374008,
            42373176,
            42374905,
            42371349,
            42379998,
            42373150,
            42374030
        ],
        "C": [
            42367060,
            42368485,
            42368461,
            42367940,
            42368563,
            42368341,
            42378567,
            42367842,
            42367459,
            42369272,
            42375102,
            42369783,
            42370363,
            42370761,
            42367752,
            42376902,
            42370198,
            42370636
        ],
        "B": [
            42366092,
            42367373,
            42367083,
            42366507,
            42366793,
            42366735,
            42367983,
            42366366,
            42366278,
            42367057,
            42372146,
            42367428,
            42368851,
            42367360,
            42366696,
            42366630,
            42368278,
            42367696
        ],
        "A": [
            42365839,
            42365922,
            42366199,
            42365850,
            42365879,
            42366070,
            42366134,
            42365823,
            42365810,
            42366029,
            42366879,
            43951943,
            42366275,
            42367664,
            42365933,
            42365869,
            42365891,
            42366540,
            42366060
        ]
    },
    "name": "C. Equalize",
    "statement": "You are given two binary strings a and b of the same length. You can\r\nperform the following two operations on the string a: Swap any two bits\r\nat indices i and j respectively (1\r\nle i, j\r\nle n), the cost of this operation is |i - j|, that is, the absolute\r\ndifference between i and j. Select any arbitrary index i (1\r\nle i\r\nle n) and flip (change 0 to 1 or 1 to 0) the bit at this index. The cost\r\nof this operation is 1. Find the minimum cost to make the string a equal\r\nto b. It is not allowed to modify string b.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 02.09.2018 17:38:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string a, b;\n  cin >> a;\n  cin >> b;\n  vector<int> dp(n + 1, 0);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + (a[i - 1] != b[i - 1]);\n    if (i >= 2 && a[i - 2] == b[i - 1] && a[i - 1] == b[i - 2]) {\n      dp[i] = min(dp[i], dp[i - 2] + 1);\n    }\n  }\n  cout << dp[n] << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Equalize.json",
    "editorial_link": "https://codeforces.com/blog/entry/61606",
    "editorial": "This can be seen that to minimize the cost, we should use the swap\r\noperation only when there are two consecutive positions(and with\r\nopposite values) to fix. For all other positions to fix, we can use the\r\nflip operation.\r\n",
    "hint": []
}