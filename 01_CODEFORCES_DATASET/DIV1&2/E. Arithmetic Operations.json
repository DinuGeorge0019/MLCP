{
    "link": "https://codeforces.com//contest/1654/problem/E",
    "problemId": "1337002",
    "problem_idx": "E",
    "shortId": "1654E",
    "contest_number": "1654",
    "problem_submissions": {
        "G": [
            150299206,
            150291434,
            150262682,
            150264693,
            150279932,
            150262802,
            150264575,
            150265515,
            150270995,
            150269889,
            150268570,
            150658744,
            150262050,
            150410744
        ],
        "F": [
            150251411,
            150252834,
            150256351,
            150258591,
            150257352,
            150258765,
            150260950,
            150260548,
            150253390,
            155820292,
            150253676,
            150260302,
            150259236,
            150258476,
            150253068,
            150258272,
            150260151,
            150258857,
            150253870
        ],
        "E": [
            150249388,
            150250832,
            150247329,
            150252856,
            150255337,
            150250196,
            150255012,
            150258473,
            150245581,
            150250984,
            150250253,
            150246690,
            150250591,
            150243463,
            150281667,
            150281018,
            150257789,
            150252457,
            150252381,
            150254404,
            150260615
        ],
        "D": [
            150242905,
            150248369,
            150245387,
            150248435,
            150250315,
            150245874,
            150249516,
            150253299,
            150250969,
            150245477,
            150245136,
            150243688,
            150246539,
            150254801,
            150249615,
            150245204,
            150245282,
            150246887,
            150243365
        ],
        "C": [
            150236387,
            150236280,
            150236050,
            150237265,
            150241937,
            150237951,
            150242839,
            150238439,
            150239664,
            150239447,
            150236298,
            150237311,
            150240477,
            150246874,
            150236567,
            150236644,
            150238032,
            150240021,
            150238619
        ],
        "B": [
            150233906,
            150232250,
            150249236,
            150233827,
            150235226,
            150232832,
            150239572,
            150233210,
            150235633,
            150231291,
            150231026,
            150232476,
            150233263,
            150235368,
            150231705,
            150232694,
            150231566,
            150233122,
            150232190
        ],
        "A": [
            150228234,
            150228426,
            150228045,
            150228869,
            150232031,
            150228616,
            150230908,
            150228192,
            150232849,
            150228032,
            150227955,
            150228792,
            150228208,
            150229654,
            223450681,
            150228295,
            150228644,
            150228162,
            150228813,
            150228169
        ],
        "H": [
            150278254,
            150276173,
            150276315,
            150560549
        ]
    },
    "name": "E. Arithmetic Operations",
    "statement": "You are given an array of integers a_1, a_2,\r\nldots, a_n.You can do the following operation any number of times\r\n(possibly zero): Choose any index i and set a_i to any integer\r\n(positive, negative or 0). What is the minimum number of operations\r\nneeded to turn a into an arithmetic progression? The array a is an\r\narithmetic progression if a_{i+1}-a_i=a_i-a_{i-1} for any 2\r\nleq i\r\nleq n-1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int K = 60;\n\nvoid remax(int& x, int y) {\n\tx = (x > y) ? x : y;\n}\n\nconst int N = 101'111;\nint last[N * 2];\nint cnt[N * 2];\nint timer = 0;\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\n\tint ans = 0;\n\tauto check_step = [&](int step) {\n\t\tunordered_map<long long, int> M;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong long x = a[i] - 1ll * step * i;\n\t\t\tremax(ans, ++M[x]);\n\t\t}\n\t};\n\n\tauto add = [&](int pos) {\n\t\tpos += N;\n\t\tif (last[pos] != timer) {\n\t\t\tlast[pos] = timer;\n\t\t\tcnt[pos] = 1;\n\t\t}\n\t\tremax(ans, ++cnt[pos]);\n\t};\n\n\tfor (int i = -K; i <= K; ++i) {\n\t\tcheck_step(i);\n\t\t// cerr << \"checked \" << i << \", \";\n\t}\n\tconst int len = 1e5 / K + 10;\n\tfor (int i = 0; i < n; ++i) {\n\t\t++timer;\n\t\tfor (int j = 1; j <= len && i + j < n; ++j) {\n\t\t\tif ((a[i + j] - a[i]) % j == 0) {\n\t\t\t\tadd((a[i + j] - a[i]) / j);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << n - ans << \"\\n\";\n}\n\nint main() {\n\tint t = 1; // nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "graphs",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Arithmetic Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/100127",
    "editorial": "SolutionAs explained in the hints, instead of computing the fewest\r\nnumber of operations, we will compute the largest number of elements\r\nthat don\u00e2\u0080\u0099t have an operation on them, and we will create a piecewise\r\nalgorithm with final complexity , where is the upper bound on .Let be\r\nthe common difference between elements in our final sequence. First of\r\nall, I will assume that , since solving the problem for negative is as\r\nsimple as reversing the array and running the solution again. If is\r\nfixed beforehand, we can solve the problem in by putting element into\r\nbucket and returning minus the size of the biggest bucket.For , we can\r\nuse the above algorithm to handle all of these in time. We can keep a\r\nhashmap from bucket index number of elements in the bucket, or we can\r\njust keep an array since the bucket indices have a range of at most\r\nwhich is not enough to exceed the memory limit.For , we observe that if\r\nwe have two indices such that , then at least one of them definitely has\r\nto have an operation performed on it, because the difference between\r\nthem would have to be which is not possible. In other words, if we\r\nconsider the set of elements which are not edited, that set will have\r\ngaps between pairs of elements of size at most .So, we can build a graph\r\nbetween indices with an edge with label if and . This graph has at most\r\nedges. Then we just have to find the longest path in the graph where all\r\nedges have the same label. You can do this with dynamic programming \u00e2\u0080\u0093\r\nlet be the length of the longest path ending at index , where all edges\r\nhave label . For each , we only need to check edges to where . This\r\nmeans the time complexity is . To store the values sparsely, we can use\r\neither a hash map or a rotating buffer (where we only store for in a\r\nsliding window of width ).Complexity:\r\n"
}