{"link": "https://codeforces.com//contest/653/problem/C", "problemId": "52168", "problem_idx": "C", "shortId": "653C", "contest_number": "653", "problem_submissions": {"D": [16882408, 16811537, 16810665, 16808469, 16808880, 16810169, 16810193, 16817835, 16817684, 16809816, 16810008, 16809541, 16810009, 16809483, 16815488, 16815467, 16809743, 16815857, 16810399, 16830307, 16830297, 16830295, 16809555], "C": [16814329, 16808201, 16807277, 16809824, 16809484, 16809237, 16808970, 16808978, 16808649, 16810747, 16824380, 16810982, 16808580, 16808306, 16809772, 16808759, 16815412, 16808885, 16810588], "F": [16813454, 16812764, 16813359, 16811313, 16812655, 16813981, 16813203, 16812204, 16812853, 16813207, 16813077, 16811759, 16813557, 16817070, 16813698, 16812540, 16812526], "E": [16812212, 16809858, 16810442, 16814020, 16811168, 16811817, 16811727, 16814449, 16814876, 16813977, 16814689, 16810991, 16810903, 16815613, 16810612, 16812105, 16811842], "B": [16811122, 16806823, 16808941, 16806712, 16806895, 16807172, 16806271, 16807190, 16807288, 16809090, 16808193, 16806845, 16806473, 16807895, 16806798, 16807486, 16808397, 16806933], "A": [16810886, 16805361, 16805416, 16805408, 16805395, 16805730, 16805338, 16805605, 16805967, 16806396, 16807313, 16805370, 16805342, 16805498, 16805369, 16805701, 16806883, 16805397], "G": [16810637, 16830434, 16849997, 16871778, 16820127, 16813576, 16863345, 16813594, 16830285]}, "name": "C. Bear and Up-Down", "statement": "The life goes up and down, just like nice sequences. Sequence is called\r\nif the following two conditions are satisfied: for each odd ; for each\r\neven . For example, sequences , and are nice, while , and are not.Bear\r\nLimak has a sequence of positive integers . This sequence now and Limak\r\nwants to fix it by a single swap. He is going to choose two indices and\r\nswap elements and in order to get a nice sequence. Count the number of\r\nways to do so. Two ways are considered different if indices of elements\r\nchosen for a swap are different.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=151000;\nint n,t[N],ans,s,val[N];\nset<PII> ret;\nVI pos;\nbool valid(int x) {\n\tif (x%2==0) {\n\t\treturn (x==n-1||t[x]<t[x+1])&&(x==0||t[x]<t[x-1]);\n\t} else {\n\t\treturn (x==n-1||t[x]>t[x+1])&&(x==0||t[x]>t[x-1]);\n\t}\n}\nvoid upd(int x) {\n\tif (x<0||x>=n) return;\n\ts-=val[x];\n\tval[x]=valid(x);\n\ts+=val[x];\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,0,n) scanf(\"%d\",t+i);\n\trep(i,0,n) {\n\t\tval[i]=valid(i);\n\t\tif (!val[i]) pos.pb(i);\n\t\ts+=val[i];\n\t}\n\tif (SZ(pos)>=10) {\n\t\tputs(\"0\"); return 0;\n\t}\n\tfor (auto u:pos) rep(v,0,n) {\n\t\tswap(t[u],t[v]);\n\t\tupd(u-1); upd(u); upd(u+1); upd(v-1); upd(v); upd(v+1);\n\t\tif (s==n) {\n\t\t\tret.insert(mp(min(u,v),max(u,v)));\n\t\t}\n\t\tswap(t[u],t[v]);\n\t\tupd(u-1); upd(u); upd(u+1); upd(v-1); upd(v); upd(v+1);\n\t}\n\tprintf(\"%d\\n\",SZ(ret));\n}\n"], "input": "", "output": "", "tags": ["brute force", "implementation"], "dificulty": "1900", "interactive": false}