{
    "link": "https://codeforces.com//contest/1656/problem/G",
    "problemId": "1341210",
    "problem_idx": "G",
    "shortId": "1656G",
    "contest_number": "1656",
    "problem_submissions": {
        "H": [
            150787257,
            150834092,
            150833898,
            150779624,
            150791810,
            150792367,
            150793746,
            150802821,
            150793244,
            150784328,
            150836239,
            150786830,
            150787392,
            150775313,
            150792322,
            150812291,
            150837917,
            150835814,
            150835788,
            150835748,
            150835735,
            150835565,
            150835404,
            150835313,
            150835295,
            150835202,
            150835140,
            150813121
        ],
        "G": [
            150769137,
            150790740,
            150776335,
            150781798,
            150778878,
            150781350,
            150783120,
            150789415,
            150791824,
            150790309,
            150773559,
            150791984,
            150793946,
            150800739,
            150800780
        ],
        "F": [
            150759585,
            150758819,
            150757088,
            150759741,
            150768307,
            150764851,
            150771817,
            150759499,
            150756577,
            150773688,
            150782772,
            150774145,
            150769570,
            150765258,
            150764625,
            150756214,
            150776414,
            150776503,
            150774655,
            150777047
        ],
        "E": [
            150751361,
            150745742,
            150744206,
            150750256,
            150757531,
            150753091,
            150760157,
            150764520,
            150764445,
            150756529,
            150749400,
            150762413,
            150747229,
            150753617,
            150756813,
            150745115,
            150752324,
            150758442,
            150759352,
            150761061
        ],
        "D": [
            150742723,
            150736825,
            150739691,
            150737309,
            150752373,
            150748905,
            150751158,
            150737577,
            150743318,
            150744109,
            150743943,
            150742795,
            150742345,
            150737178,
            150746671,
            150740470,
            150742866,
            150748659,
            150752013,
            150752792
        ],
        "C": [
            150733096,
            150732015,
            150737243,
            150731632,
            150734197,
            150741651,
            150741487,
            150729270,
            150734650,
            150732482,
            150734630,
            150733212,
            150733482,
            150730538,
            150732987,
            150735181,
            150734697,
            150735222,
            150738885,
            150734495
        ],
        "B": [
            150727707,
            150727564,
            150729524,
            150727729,
            150727957,
            150730109,
            150730045,
            150725120,
            150728043,
            150726472,
            150725778,
            150727111,
            150726454,
            150727018,
            150729221,
            150817665,
            150730058,
            150728199,
            150728859,
            150727704
        ],
        "A": [
            150725204,
            150724798,
            150724946,
            150724479,
            150724835,
            150724855,
            150724694,
            150724426,
            150724692,
            150724405,
            150724424,
            150724740,
            150724465,
            150724564,
            150725589,
            150725242,
            150725512,
            150724576,
            150724789,
            150724666
        ],
        "I": [
            150839781,
            150825396
        ]
    },
    "name": "G. Cycle Palindrome",
    "statement": "We say that a sequence of n integers a_1, a_2,\r\nldots, a_n is a palindrome if for all 1\r\nleq i\r\nleq n, a_i = a_{n-i+1}. You are given a sequence of n integers a_1, a_2,\r\nldots, a_n and you have to find, if it exists, a\r\nsigma so that the sequence a_{\r\nsigma(1)}, a_{\r\nsigma(2)},\r\nldots, a_{\r\nsigma(n)} is a palindrome. A permutation of 1, 2,\r\nldots, n is a bijective function from\r\n{1, 2,\r\nldots, n\r\n} to\r\n{1, 2,\r\nldots, n\r\n}. We say that a permutation\r\nsigma is a cycle permutation if 1,\r\nsigma(1),\r\nsigma^2(1),\r\nldots,\r\nsigma^{n-1}(1) are pairwise different numbers. Here\r\nsigma^m(1) denotes\r\nunderbrace{\r\nsigma(\r\nsigma(\r\nldots\r\nsigma}_{m\r\ntext{ times}}(1)\r\nldots)).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    std::vector<int> cnt(n);\n    std::vector<std::vector<int>> pos(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        cnt[a[i]]++;\n        pos[a[i]].push_back(i);\n    }\n    \n    int odd = 0;\n    for (int i = 0; i < n; i++) {\n        odd += cnt[i] % 2;\n    }\n    if (odd > 1) {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    if (n % 2 == 1 && cnt[a[(n - 1) / 2]] == 1) {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    std::cout << \"YES\\n\";\n    \n    std::vector<int> p(n), q(n);\n    \n    DSU g(n);\n    for (int x = 0, L = 0, R = n; x < 2; x++) {\n        for (int i = 0; i < n; i++) {\n            if (int(pos[i].size()) % 2 == x) {\n                for (auto j : pos[i]) {\n                    if (L < n - R) {\n                        p[L++] = j;\n                    } else {\n                        p[--R] = j;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        q[p[i]] = i;\n        g.merge(i, p[i]);\n    }\n    \n    auto swap = [&](int x, int y) {\n        std::swap(q[p[x]], q[p[y]]);\n        std::swap(p[x], p[y]);\n    };\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j < int(pos[i].size()); j++) {\n            int x = pos[i][j];\n            int y = pos[i][j - 1];\n            if (g.leader(x) != g.leader(y)) {\n                swap(q[x], q[y]);\n                g.merge(x, y);\n            }\n        }\n    }\n    \n    int lst = -1;\n    for (int i = 0; i < n; i++) {\n        if (int(pos[i].size()) <= 1) {\n            continue;\n        }\n        if (lst != -1 && !g.same(pos[i][0], pos[lst][0])) {\n            int x = pos[lst][0];\n            if (q[x] * 2 + 1 == n) {\n                x = pos[lst][1];\n            }\n            int u = q[x];\n            int v = n - 1 - q[x];\n            swap(u, v);\n            int y = pos[i][0];\n            if (q[y] * 2 + 1 == n) {\n                y = pos[i][1];\n            }\n            int a = q[y];\n            int b = n - 1 - q[y];\n            swap(u, a);\n            swap(v, b);\n            g.merge(pos[i][0], pos[lst][0]);\n        }\n        lst = i;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << p[i] + 1 << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "math"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Cycle Palindrome.json",
    "editorial_link": "https://codeforces.com//blog/entry/101211",
    "editorial": "We clearly see that the following two conditions are necessary: Each\r\nnumber must be repeated an even number of time except possibly one of\r\nthe numbers. (This is necessary to find any permutation that results in\r\na palindrome, not just a cycle). If is odd, it can not be that the\r\nnumber appears only one time. (Otherwise, the permutation would need to\r\nhave one fixed point). We will see that those two conditions are\r\nsufficient. First, let\u00e2\u0080\u0099s focus on the even case. Find any permutation so\r\nthat applying it results in a palindrome. This permutation will have a\r\ncycle decomposition. We are going to merge all those cycles in one big\r\ncycle. To do so, we will first merge the cycles so that indices and are\r\nin the same cycle for all . Note that, since we can define a new\r\npermutation with and and the permutation will still generate a\r\npalindrome and and will be in the same cycle. We iterate over all the s\r\nand merge all such cycles. Note that we need to keep track efficiently\r\nof which indices are in the same cycle, so we should use union-find data\r\nstructure.Now we have disjoint cycles which are symmetric, that is and\r\nare in the same cycle. If we\u00e2\u0080\u0099ve won. Otherwise, let be indices belonging\r\nto each of the cycles and let be our current permutation. Note that if\r\nwe define and for and , , we have another permutation which results in a\r\npalindrome and consists of only one cycle, so we\u00e2\u0080\u0099re done.There are\r\ndifferent ways of handling the case when is odd, the one that requires\r\nleast casework for this solution is noticing that in the odd case we can\r\nstill merge symmetric cycles with no issues, and that the only thing\r\nthat could make the last step fail would be to choose some index so that\r\n. So we have to be careful not to choose , and in particular this means\r\nthat the cycle that contains the middle element can not be a fixed\r\npoint. If the second condition is satisfied, this can be achieved easily\r\nin the initial permutation we choose. Alternative solution:Notice that\r\nthe above solution has complexity because of union-find. Actually, a\r\ncomplexity can be achieved, we describe briefly an alternative solution\r\nwith that complexity. We focus on the case when is even. The idea is to\r\nstart with a permutation whose cycles are already symmetric. In order to\r\ndo so, we construct a graph whose vertices are the numbers that appear\r\nin the sequence and for each we add an edge between and . Now note that\r\nfor each of the connected components of the graph we can obtain a\r\nsymmetric cycle resulting in a palindrome from an Eulerian tour of the\r\ngraph.\r\n"
}