{"link": "https://codeforces.com//contest/1656/problem/G", "problemId": "1341210", "problem_idx": "G", "shortId": "1656G", "contest_number": "1656", "problem_submissions": {"H": [150787257, 150834092, 150833898, 150779624, 150791810, 150792367, 150793746, 150802821, 150793244, 150784328, 150836239, 150786830, 150787392, 150775313, 150792322, 150812291, 150837917, 150835814, 150835788, 150835748, 150835735, 150835565, 150835404, 150835313, 150835295, 150835202, 150835140, 150813121], "G": [150769137, 150790740, 150776335, 150781798, 150778878, 150781350, 150783120, 150789415, 150791824, 150790309, 150773559, 150791984, 150793946, 150800739, 150800780], "F": [150759585, 150758819, 150757088, 150759741, 150768307, 150764851, 150771817, 150759499, 150756577, 150773688, 150782772, 150774145, 150769570, 150765258, 150764625, 150756214, 150776414, 150776503, 150774655, 150777047], "E": [150751361, 150745742, 150744206, 150750256, 150757531, 150753091, 150760157, 150764520, 150764445, 150756529, 150749400, 150762413, 150747229, 150753617, 150756813, 150745115, 150752324, 150758442, 150759352, 150761061], "D": [150742723, 150736825, 150739691, 150737309, 150752373, 150748905, 150751158, 150737577, 150743318, 150744109, 150743943, 150742795, 150742345, 150737178, 150746671, 150740470, 150742866, 150748659, 150752013, 150752792], "C": [150733096, 150732015, 150737243, 150731632, 150734197, 150741651, 150741487, 150729270, 150734650, 150732482, 150734630, 150733212, 150733482, 150730538, 150732987, 150735181, 150734697, 150735222, 150738885, 150734495], "B": [150727707, 150727564, 150729524, 150727729, 150727957, 150730109, 150730045, 150725120, 150728043, 150726472, 150725778, 150727111, 150726454, 150727018, 150729221, 150817665, 150730058, 150728199, 150728859, 150727704], "A": [150725204, 150724798, 150724946, 150724479, 150724835, 150724855, 150724694, 150724426, 150724692, 150724405, 150724424, 150724740, 150724465, 150724564, 150725589, 150725242, 150725512, 150724576, 150724789, 150724666], "I": [150839781, 150825396]}, "name": "G. Cycle Palindrome", "statement": "We say that a sequence of n integers a_1, a_2,\r\nldots, a_n is a palindrome if for all 1\r\nleq i\r\nleq n, a_i = a_{n-i+1}. You are given a sequence of n integers a_1, a_2,\r\nldots, a_n and you have to find, if it exists, a\r\nsigma so that the sequence a_{\r\nsigma(1)}, a_{\r\nsigma(2)},\r\nldots, a_{\r\nsigma(n)} is a palindrome. A permutation of 1, 2,\r\nldots, n is a bijective function from\r\n{1, 2,\r\nldots, n\r\n} to\r\n{1, 2,\r\nldots, n\r\n}. We say that a permutation\r\nsigma is a cycle permutation if 1,\r\nsigma(1),\r\nsigma^2(1),\r\nldots,\r\nsigma^{n-1}(1) are pairwise different numbers. Here\r\nsigma^m(1) denotes\r\nunderbrace{\r\nsigma(\r\nsigma(\r\nldots\r\nsigma}_{m\r\ntext{ times}}(1)\r\nldots)).\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    std::vector<int> cnt(n);\n    std::vector<std::vector<int>> pos(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        cnt[a[i]]++;\n        pos[a[i]].push_back(i);\n    }\n    \n    int odd = 0;\n    for (int i = 0; i < n; i++) {\n        odd += cnt[i] % 2;\n    }\n    if (odd > 1) {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    if (n % 2 == 1 && cnt[a[(n - 1) / 2]] == 1) {\n        std::cout << \"NO\\n\";\n        return;\n    }\n    std::cout << \"YES\\n\";\n    \n    std::vector<int> p(n), q(n);\n    \n    DSU g(n);\n    for (int x = 0, L = 0, R = n; x < 2; x++) {\n        for (int i = 0; i < n; i++) {\n            if (int(pos[i].size()) % 2 == x) {\n                for (auto j : pos[i]) {\n                    if (L < n - R) {\n                        p[L++] = j;\n                    } else {\n                        p[--R] = j;\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        q[p[i]] = i;\n        g.merge(i, p[i]);\n    }\n    \n    auto swap = [&](int x, int y) {\n        std::swap(q[p[x]], q[p[y]]);\n        std::swap(p[x], p[y]);\n    };\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j < int(pos[i].size()); j++) {\n            int x = pos[i][j];\n            int y = pos[i][j - 1];\n            if (g.leader(x) != g.leader(y)) {\n                swap(q[x], q[y]);\n                g.merge(x, y);\n            }\n        }\n    }\n    \n    int lst = -1;\n    for (int i = 0; i < n; i++) {\n        if (int(pos[i].size()) <= 1) {\n            continue;\n        }\n        if (lst != -1 && !g.same(pos[i][0], pos[lst][0])) {\n            int x = pos[lst][0];\n            if (q[x] * 2 + 1 == n) {\n                x = pos[lst][1];\n            }\n            int u = q[x];\n            int v = n - 1 - q[x];\n            swap(u, v);\n            int y = pos[i][0];\n            if (q[y] * 2 + 1 == n) {\n                y = pos[i][1];\n            }\n            int a = q[y];\n            int b = n - 1 - q[y];\n            swap(u, a);\n            swap(v, b);\n            g.merge(pos[i][0], pos[lst][0]);\n        }\n        lst = i;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << p[i] + 1 << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "graphs", "math"], "dificulty": "3200", "interactive": false}