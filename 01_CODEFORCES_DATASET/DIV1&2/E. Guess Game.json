{
    "link": "https://codeforces.com//contest/1864/problem/E",
    "problemId": "2181268",
    "problem_idx": "E",
    "shortId": "1864E",
    "contest_number": "1864",
    "problem_submissions": {
        "I": [
            220596748,
            220625703,
            220625365,
            220625093
        ],
        "H": [
            220568821,
            220567695,
            220569504,
            220765807,
            220735033,
            220733694,
            220582422,
            220590968,
            220584872,
            220585832,
            220586273,
            220588653,
            220869529,
            220592706,
            220587781,
            220596085,
            222139412,
            220596294
        ],
        "G": [
            220562227,
            220575493,
            220588511,
            220576272,
            220574639,
            220576772,
            220595506,
            220568659,
            220611309,
            221223033,
            220575904,
            220585515,
            220590419,
            220591092,
            220590354,
            220590686
        ],
        "F": [
            220551620,
            220555802,
            220557675,
            220718976,
            220558576,
            220553574,
            220558951,
            220567707,
            220555900,
            220612295,
            220564492,
            220564273,
            220565836,
            220560759,
            220571802,
            220564441,
            220571627,
            220556155,
            220556855,
            220560337,
            220568919,
            220567748
        ],
        "E": [
            220545674,
            220547229,
            220549551,
            220553761,
            220544098,
            220550014,
            220550285,
            220550294,
            220555536,
            220557391,
            220559164,
            220553118,
            220556990,
            220555427,
            220553548,
            220549618,
            220563369,
            220552727,
            220558630,
            220553863
        ],
        "D": [
            220537006,
            220537255,
            220535722,
            220536129,
            220534069,
            220542850,
            220539341,
            220538198,
            220541287,
            220542463,
            220545447,
            220548373,
            220544205,
            220540271,
            220536187,
            220541552,
            220541368,
            220545083,
            220544975
        ],
        "C": [
            220533606,
            220528455,
            220528101,
            220528155,
            220527489,
            220537748,
            220525134,
            220530359,
            220532079,
            220533694,
            220541070,
            220542060,
            220535618,
            220533106,
            220530771,
            220535184,
            220536493,
            220534865,
            220537384
        ],
        "B": [
            220524699,
            220524727,
            220525716,
            220524082,
            220524572,
            220524039,
            220522756,
            220522640,
            220528173,
            220525137,
            220528062,
            220531552,
            220524275,
            220526451,
            220524531,
            220529349,
            220526226,
            220525961,
            220525118
        ],
        "A": [
            220521618,
            220521580,
            220521747,
            220521485,
            220521753,
            220521570,
            220521442,
            220521465,
            220524365,
            220521707,
            220524695,
            220522808,
            220521703,
            220522789,
            220521679,
            220521789,
            220521663,
            220522116,
            220521966
        ]
    },
    "name": "E. Guess Game",
    "statement": "Carol has a sequence s of n non-negative integers. She wants to play the\r\n\"Guess Game\" with Alice and Bob.To play the game, Carol will select two\r\ninteger indices i_a and i_b within the range [1, n], and set a=s_{i_a},\r\nb=s_{i_b}. Please note that i_a and i_b may coincide.Carol will tell:\r\nthe value of a to Alice; the value of b to Bob; the value of a\r\nmid b to both Alice and Bob, where | denotes the bitwise OR operation.\r\nPlease note that Carol will tell any information about s to either Alice\r\nor Bob.Then the guessing starts. The two players take turns making\r\nguesses, with Alice starting first. The goal of both players is to\r\nestablish which of the following is true: a < b, a > b, or a = b.In\r\ntheir turn, a player can do one of the following two things: say \"I\r\ndon’t know\", and pass the turn to the other player; say \"I know\",\r\nfollowed by the answer \"a<b\", \"a>b\", or \"a=b\"; then the game ends. Alice\r\nand Bob hear what each other says, and can use this information to\r\ndeduce the answer. Both Alice and Bob are smart enough and only say \"I\r\nknow\" when they are completely sure.You need to calculate the expected\r\nvalue of the number of turns taken by players in the game. Output the\r\nanswer modulo 998\r\n,244\r\n,353.Formally, let M = 998\r\n,244\r\n,353. It can be shown that the answer can be expressed as an irreducible\r\nfraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, output such an integer x that 0\r\nle x < M and x\r\ncdot q\r\nequiv p\r\npmod{M}.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst int d=30;\n\nint n;\nll tab[nax];\n\nll wyn=0;\n\nll inv(ll v)\n{\n\tif (v<=1)\n\t\treturn v;\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nvoid rek(vll wek)\n{\n\tif (wek[0]==wek.back())\n\t{\n\t\twyn+=wek.size()*(ll)wek.size()*(ll)(__builtin_popcountll(wek[0])+1);\n\t\treturn;\n\t}\n\tll r=wek[0]^wek.back();\n\tint x=63-__builtin_clzll(r);\n\tvll a, b;\n\tfor (ll i : wek)\n\t{\n\t\tif (i&(1LL<<x))\n\t\t\ta.push_back(i);\n\t\telse\n\t\t\tb.push_back(i);\n\t}\n\tll kejsy=a.size()*(ll)b.size();\n\tll resz=wek.size()*(ll)wek.size()-kejsy;\n\tll wyz=0;\n\t{\n\t\tll p=wek[0]&(wek[0]^((1LL<<x)-1));\n\t\tp=__builtin_popcountll(p);\n\t\twyz=p+1;\n\t}\n\t//~ debug() << imie(wek) << imie(kejsy) << imie(resz);\n\twyn+=kejsy*(2*wyz+1);\n\twyn%=mod;\n\t//~ wyn+=resz;\n\t//~ wyn%=mod;\n\trek(a);\n\trek(b);\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tsort(tab+1, tab+1+n);\n\twyn=0;\n\t//~ map<ll,ll> mapa;\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ mapa[tab[i]]++;\n\t//~ wyn=0;\n\t//~ for (auto i : mapa)\n\t//~ {\n\t\t//~ wyn+=i.second*i.second*(__builtin_popcountll(i.first)+1);\n\t\t//~ wyn%=mod;\n\t//~ }\n\tvll wek;\n\tfor (int i=1; i<=n; i++)\n\t\twek.push_back(tab[i]);\n\trek(wek);\n\t\n\twyn*=inv(n*(ll)n%mod);\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\tprintf(\"%lld\\n\", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "games",
        "math",
        "probabilities",
        "sortings",
        "strings",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Guess Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/119772",
    "editorial": "TutorialFirst, letâs analize a single game for fixed , , and how many\r\nturns it takes.Consider the binary representation of . We consider bits\r\nfrom highest to lowest. For bits with a value of , we can ignore it\r\nbecause it firmly tells us that both bits of and are . For convenience,\r\nwe assume that all bits of are . In the first round, if the highest bit\r\nof is , then Alice can immediately say that . Otherwise, in the second\r\nround of the game, Bob knows that the highest bit of is not . If the\r\nhighest or the second highest bit of b is , then Bob can immediately say\r\nthat . Otherwise, in the third round of the game, Alice knows that the\r\nhighest and the second highest bits of are not , and so on.Consider only\r\nset bits in . Letâs enumerate these bits from highest to lowest. After\r\nsome observation, we can conclude that: If and the -th bit in is zero,\r\nthen the answer is ; If , then the answer is , where is the number of\r\nset bits in ; If and the -th bit in is zero, then the answer is . Now\r\nthat we have a brute force algorithm for , how can we optimize it? We\r\ncan build a bit trie and traverse all nodes. We can easily calculate the\r\nnumber of s that pass from a node to the root node, as well as the\r\nnumber of numbers prefixed with it and followed by (or ). Use this\r\ninformation to calculate the answer.\r\n",
    "hint": []
}