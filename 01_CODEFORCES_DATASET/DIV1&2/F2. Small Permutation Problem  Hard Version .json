{
    "link": "https://codeforces.com//contest/1909/problem/F2",
    "problemId": "2393927",
    "problem_idx": "F2",
    "shortId": "1909F2",
    "contest_number": "1909",
    "problem_submissions": {
        "I": [
            238594787,
            238734499,
            238612798,
            238982716
        ],
        "H": [
            238580264,
            238589602,
            238607786
        ],
        "G": [
            238560293,
            238550526,
            238559517,
            238558313,
            238557833,
            238566652,
            238564686,
            239556259,
            239556209,
            238565636,
            238574025,
            238573859,
            238568809,
            238573884,
            238566593,
            238571787,
            238574691,
            238625821,
            238572617,
            238570324,
            238573276,
            238570764
        ],
        "F2": [
            238542796,
            238534294,
            238538777,
            238545730,
            238548819,
            238528922,
            238534725,
            239556236,
            238553039,
            238545071,
            238550570,
            238542799,
            238606902,
            238606875,
            238606473,
            238542884,
            238576806,
            238557484,
            238548076,
            238559797,
            238553161,
            238552651,
            238578812
        ],
        "F1": [
            238533850,
            238534241,
            238512806,
            238545552,
            238548346,
            238522831,
            238522246,
            238532074,
            238540188,
            238535569,
            238526516,
            238529202,
            238537091,
            238538307,
            238535161,
            238536954,
            238545258,
            238549880
        ],
        "E": [
            238530140,
            238527503,
            238531786,
            238531780,
            238539031,
            238540384,
            238546944,
            238541376,
            238626199,
            238528618,
            238544549,
            238554302,
            238543453,
            238607205,
            238546967,
            238534529,
            238544188,
            238547677,
            238537800,
            238539073
        ],
        "D": [
            238516247,
            238515473,
            238516693,
            238517435,
            238518596,
            238517877,
            238511801,
            238522012,
            238519439,
            238520615,
            238515978,
            238520501,
            238524874,
            238519711,
            238522426,
            238527869,
            238523778,
            238525554
        ],
        "C": [
            238510258,
            238508905,
            238507888,
            238511857,
            238511447,
            238510244,
            238508948,
            238513299,
            238512833,
            238512815,
            238510300,
            238510166,
            238511071,
            238510194,
            238514731,
            238515535,
            238515115,
            238514740
        ],
        "B": [
            238506344,
            238505616,
            238505050,
            238507671,
            238507930,
            238506022,
            238507400,
            238508743,
            238507281,
            238507154,
            238506618,
            238505579,
            238506319,
            238511922,
            238508811,
            238507261,
            238508313,
            238507211
        ],
        "A": [
            238504593,
            238504553,
            238504448,
            238504666,
            238505213,
            238504543,
            238504461,
            238504436,
            238504858,
            238504739,
            238504679,
            238504538,
            238504584,
            238504729,
            238504462,
            238505151,
            238506675,
            238504829
        ]
    },
    "name": "F2. Small Permutation Problem  Hard Version ",
    "statement": "You are given an integer n and an array a_1, a_2,\r\ndots, a_n of integers in the range [-1, n].A permutation p_1, p_2,\r\ndots, p_n of [1, 2,\r\ndots, n] is good if, for each i, the following condition is true: if a_i\r\nneq -1, the number of values\r\nleq i in [p_1, p_2,\r\ndots, p_i] is exactly a_i. Count the good permutations of [1, 2,\r\ndots, n], modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic constexpr int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\n//size of input must be a power of 2\n//output elements are in the range [0,mod*4)\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\n#ifdef USE_GOOD_MOD\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tstatic vc<mint> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\ntemplate<class mint>\nvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint s=si(x);\n\tassert(ispow2(s));\n\tassert(si(y));\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tstatic vc<mint> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);\n\treturn x;\n}\n\n#else\n\n//59501818244292734739283969-1=5.95*10^25 までの値を正しく計算\n//最終的な列の大きさが 2^24 までなら動く\n//最終的な列の大きさが 2^20 以下のときは，下の 3 つの素数を使ったほうが速い（は？）\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\tconstexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\tconstexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\tconstexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\t//extern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\t//extern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class t,class mint>\n\tvc<t>&sub_givenlength(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint s=si(x);\n\t\tassert(ispow2(s));\n\t\tassert(si(y)==s);\n\t\tstatic vc<t> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tstatic vc<t> w;\n\t\t\tw.clear();w.resize(s);\n\t\t\trep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\t\tauto&d0=sub_givenlength<mint0>(x,y,same);\n\t\tauto&d1=sub_givenlength<mint1>(x,y,same);\n\t\tauto&d2=sub_givenlength<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tx.resize(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tx[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn x;\n\t}\n}\nusing arbitrary_convolution::multiply;\nusing arbitrary_convolution::multiply_givenlength;\n\n#endif\n\n//UTPC2021 C\nnamespace integer_convolution{\n\textern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\textern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base0{469762049,3};//2^26 * 7 + 1\n\t//extern constexpr modinfo base1{754974721,11};//2^24 * 45 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\ttemplate<class t>\n\tvc<t> sub(const vi&x,const vi&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i];\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i];\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\tvi multiply(const vi&x,const vi&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tconst mint1 r=mint1(mint0::mod).inv();\n\t\tconst ll v=ll(mint0::mod)*mint1::mod;\n\t\tint n=si(d0);\n\t\tvi res(n);\n\t\trep(i,n){\n\t\t\tres[i]=d0[i].v+(r*(d1[i]-d0[i].v)).v*(ull)mint0::mod;\n\t\t\tif(res[i]>v/2)res[i]-=v;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n//最大で 1<<mx のサイズの fft が登場！\ntemplate<class mint>\nvc<mint> large_convolution(const vc<mint>&a,const vc<mint>&b,int mx){\n\tint n=si(a),m=si(b);\n\tvc<mint> c(n+m-1);\n\tint len=1<<(mx-1);\n\tfor(int i=0;i<n;i+=len){\n\t\tfor(int j=0;j<n;j+=len){\n\t\t\tint x=min(len,n-i),y=min(len,m-j);\n\t\t\tauto d=multiply(vc<mint>(a.bg+i,a.bg+i+x),vc<mint>(b.bg+j,b.bg+j+y));\n\t\t\trep(k,si(d))\n\t\t\t\tc[i+j+k]+=d[k];\n\t\t}\n\t}\n\treturn c;\n}\n\n//input A: N 次,B ?,M\n//output D: M 次多項式\n//C を M 次多項式として\n//[x^N] A*B*C = [x^M] D*C\n//となるような D を返す\n//CF796F\ntemplate<class mint>\nvc<mint> transpose_advance(const vc<mint>&a,const vc<mint>&b,int m){\n\tint n=si(a)-1;\n\tauto d=multiply(a,b);\n\tvc<mint> res(m+1);\n\tif(n>=m){\n\t\trep(i,m+1)res[i]=d[i+n-m];\n\t}else{\n\t\trng(i,m-n,m+1)res[i]=d[i+n-m];\n\t}\n\treturn res;\n}\n\n//Yukicoder 2166\ntemplate<class mint>\nvoid chmult(vc<mint>&x,const vc<mint>&y,int s){\n\tx=multiply(move(x),y);\n\tx.resize(s);\n}\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//対角線を超えず (x,y) に至る方法の数\nmint catalan(int x,int y){\n\tassert(y<=x);\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n//y=x+c を超えず (x,y) に至る方法の数\nmint catalan(int x,int y,int c){\n\tassert(y<=x+c);\n\treturn binom(x,y)-binom(x+c+1,y-c-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nbool dbg=false;\n\nmint sub(int h,int w,int k){\n\treturn choose(h,k)*choose(w,k)*fact[k];\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> ls;\n\tls.eb(0,0);\n\tvi raw=readvi(n);\n\trng(i,1,n+1){\n\t\tint v=raw[i-1];\n\t\tif(i==n){\n\t\t\tif(v!=-1&&v!=n)\n\t\t\t\treturn print(0);\n\t\t\tv=n;\n\t\t}\n\t\tif(v==-1)continue;\n\t\tif(ls.back().b>v)return print(0);\n\t\tif(v!=-1)ls.eb(i,v);\n\t}\n\t//dmp(ls);\n\tmint ans=1;\n\trep(step,si(ls)-1){\n\t\tint s=ls[step+1].a-ls[step].a;\n\t\tint t=ls[step].a-ls[step].b;\n\t\tint k=ls[step+1].b-ls[step].b;\n\t\tvc<mint> a(k+1);\n\t\trep(x,k+1)a[x]=choose(t,x)*choose(s,k-x)*fact[k-x];\n\t\tauto b=multiply(a,a,true);\n\t\tmint w=0;\n\t\trep(xy,k+1){\n\t\t\tw+=b[xy]*finv[k-xy];\n\t\t}\n\t\t//dmp2(s,t,k,w);\n\t\tans*=w;\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\F2. Small Permutation Problem  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/123584",
    "editorial": "SolutionDraw a grid, with tokens in .Consider any and the nearest on the\r\nleft (if it does not exist, letâs set ). Then, there must be tokens in\r\nthe subgrid . We can suppose we have already inserted the tokens in ,\r\nand we have to insert tokens in the remaining cells of (they make an \"L\"\r\nshape).WLOG, the tokens in are in the cells . Then, we can put tokens in\r\nthe blue cells in the picture. PictureThe blue shape can be further\r\nsplit into these two rectangles: PictureIterate over , the number of\r\ntokens in the first rectangle (). Then, you have to insert tokens into a\r\nrectangle, and the remaining tokens into a rectangle.The number of ways\r\nto insert tokens into a rectangle is equal to the product of the number\r\nof ways to choose rows, the number of ways to choose columns, and the\r\nnumber of ways to fill the resulting subgrid: the result is .\r\nautomatically (if and , the answer is ). If the non-negative are\r\nnon-decreasing, the sum of the (i.e., the over which you have to\r\niterate) is , so the algorithm is efficient enough. Otherwise, the\r\nanswer is .Complexity:\r\n",
    "hint": [
        "Hint 1 Find a clean way to visualize the problem.",
        "Hint 2 Draw a grid, with tokens in . Which constraints on the tokens do you have?"
    ]
}