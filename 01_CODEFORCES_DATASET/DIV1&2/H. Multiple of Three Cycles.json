{
    "link": "https://codeforces.com//contest/1844/problem/H",
    "problemId": "2009579",
    "problem_idx": "H",
    "shortId": "1844H",
    "contest_number": "1844",
    "problem_submissions": {
        "H": [
            213401907,
            214586788,
            213482546,
            213575600
        ],
        "G": [
            213373899,
            213364706,
            213372549,
            213373590,
            213384164,
            213383282,
            213393963,
            213384409,
            213418393,
            213387981,
            213389348,
            213398375,
            213371949,
            213387199,
            213394165,
            213377360,
            213395667,
            213402058,
            213381593,
            213560869
        ],
        "F2": [
            213365751,
            213352374,
            213361750,
            213357168,
            213362030,
            213488425,
            213373147,
            213364872,
            213370323,
            213418391,
            213375744,
            213375673,
            213376380,
            213391972,
            213386286,
            213388069,
            230986552,
            216997553,
            213356538
        ],
        "F1": [
            213360737,
            213346552,
            213355844,
            213353769,
            213356474,
            213367301,
            213365016,
            213370233,
            213418390,
            213370693,
            213375568,
            213369192,
            213377984,
            213354083,
            213383020,
            213393303,
            213372669,
            213376461,
            213401679,
            213346392
        ],
        "E": [
            213337513,
            213326176,
            213327168,
            213328291,
            213335991,
            213344387,
            213331287,
            213347379,
            213418389,
            213352955,
            213345144,
            213334554,
            213382252,
            213336241,
            213360028,
            213342150,
            213401053,
            213350691,
            213367633,
            213327950
        ],
        "D": [
            213318341,
            213311325,
            213318771,
            213314733,
            213318035,
            213321179,
            213319226,
            213340653,
            213317181,
            213324442,
            213316839,
            213340146,
            213326482,
            213318777,
            213944519,
            213330783,
            213332314,
            213324111,
            213326152,
            213309266
        ],
        "C": [
            213311934,
            213315167,
            213312751,
            213311291,
            213312791,
            213313574,
            213311190,
            213319880,
            213418387,
            213328281,
            213316222,
            213310956,
            213328279,
            213320887,
            213311937,
            213944332,
            213316739,
            213317975,
            213317491,
            213320348,
            213316455
        ],
        "B": [
            213305232,
            213307651,
            213304802,
            213304382,
            213303223,
            213306708,
            213313221,
            213310598,
            213305162,
            213310610,
            213305169,
            213311924,
            213315219,
            213307143,
            213944329,
            213309459,
            213321407,
            213309510,
            213312105,
            213303380
        ],
        "A": [
            213298732,
            213301327,
            213298427,
            213298307,
            213298687,
            213299071,
            213298742,
            213299374,
            213298849,
            213300343,
            213298392,
            213301468,
            213298430,
            213298466,
            213944301,
            213301546,
            213298332,
            213298535,
            213305461,
            213298274
        ]
    },
    "name": "H. Multiple of Three Cycles",
    "statement": "An array a_1,\r\ndots,a_n of length n is initially all blank. There are n updates where\r\none entry of a is updated to some number, such that a becomes a\r\npermutation of 1,2,\r\ndots,n after all the updates.After each update, find the number of ways\r\n(modulo 998\r\n,244\r\n,353) to fill in the remaining blank entries of a so that a becomes a\r\npermutation of 1,2,\r\ndots,n and all cycle lengths in a are multiples of 3.A permutation of\r\n1,2,\r\ndots,n is an array of length n consisting of n distinct integers from 1\r\nto n in arbitrary order. A in a permutation a is a sequence of pairwise\r\ndistinct integers (i_1,\r\ndots,i_k) such that i_2 = a_{i_1},i_3 = a_{i_2},\r\ndots,i_k = a_{i_{k-1}},i_1 = a_{i_k}. The length of this cycle is the\r\nnumber k, which is a multiple of 3 if and only if k\r\nequiv 0\r\npmod 3.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(\"1.in\",\"r\",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\n//------------------polynomial begin------------------\nconst int maxn=1048576;\nconst int mod=998244353,_k=119,_b=23,_g=3;\ninline void inc(int &x,int y){x+=y;if (x>=mod) x-=mod;}\ninline void dec(int &x,int y){x-=y;if (x<0) x+=mod;}\ninline int qp(int x,int y){int z=1;while(y){if(y&1)z=1ll*z*x%mod;y>>=1;x=1ll*x*x%mod;}return z;}\nnamespace polynomial\n{\n    namespace basic\n    {\n        int fac[maxn+5],inv[maxn+5],fi[maxn+5],lg[maxn+5],pw[maxn+5],w[maxn+5],iw[maxn+5];\n        bool tag=0;\n        inline void init()\n        {\n            tag=1;int i;fz(i,2,maxn) lg[i]=lg[i>>1]+1;pw[0]=1;fz1(i,lg[maxn]) pw[i]=pw[i-1]*2; \n            fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,maxn){\n                fac[i]=1ll*fac[i-1]*i%mod;inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;\n            }\n            w[0]=1;w[1]=qp(_g,(mod-1)/maxn);fz(i,2,maxn) w[i]=1ll*w[i-1]*w[1]%mod;\n            iw[maxn]=qp(w[maxn],mod-2);fd0k(i,maxn) iw[i]=1ll*iw[i+1]*w[1]%mod;\n            if (iw[0]!=1){puts(\"wrong iw!!!!!!!!!!!!!!!!!\");exit(-1);}\n        }\n        int rev[maxn+5],a[maxn+5],b[maxn+5];\n        inline int getrev(int x)\n        {\n            if (!tag) init();int i,s=1;while (s<x) s*=2;rev[0]=0;fz1(i,s-1) rev[i]=((rev[i>>1]>>1)|((i&1)<<(lg[s]-1)));return s;\n        }\n        inline void ntt(int *a,int n,int *w)\n        {\n            if (!tag) init();int i,j,k;\n            fz0k(i,n) if (rev[i]<i) swap(a[i],a[rev[i]]);\n            for (i=1;i<n;i<<=1){int ys=maxn/i/2;\n                for (j=0;j<n;j+=i+i){\n                    int *t=w;\n                    fz0k(k,i){\n                        int x=a[j+k],y=1ll*a[j+k+i]*(*t)%mod;\n                        a[j+k]=x+y;if (a[j+k]>=mod) a[j+k]-=mod;\n                        a[j+k+i]=x-y;if (a[j+k+i]<0) a[j+k+i]+=mod;\n                        t+=ys;\n                    }\n                }\n            }\n        }\n        inline vector<int> mul(const vector<int> &aa,const vector<int> &bb) //aa*bb\n        {\n            vector<int> ans;long long br=1ll*aa.size()*bb.size(),ft=1ll*(aa.size()+bb.size())*lg[aa.size()+bb.size()]*10+100;\n            if (br<ft){\n                while (ans.size()+1<aa.size()+bb.size()) ans.push_back(0);\n                int i,j;fz0k(i,aa.size()) fz0k(j,bb.size()) inc(ans[i+j],1ll*aa[i]*bb[j]%mod);\n            }\n            else{\n                int len=getrev(aa.size()+bb.size()),i;\n                fz0k(i,len) a[i]=b[i]=0;\n                fz0k(i,aa.size()) a[i]=aa[i];\n                fz0k(i,bb.size()) b[i]=bb[i];\n                ntt(a,len,w);ntt(b,len,w);\n                fz0k(i,len) a[i]=1ll*a[i]*b[i]%mod;\n                ntt(a,len,iw);int inv=qp(len,mod-2);\n                fz0k(i,len) ans.push_back(1ll*a[i]*inv%mod);\n            }\n            while (!ans.empty()&&!ans.back()) ans.pop_back();\n            return ans;\n        }\n        inline vector<int> mul2(const vector<int> &aa,const vector<int> &bb) //aa^2*bb\n        {\n            int len=getrev(aa.size()+aa.size()+bb.size()),i;\n            fz0k(i,len) a[i]=b[i]=0;fz0k(i,aa.size()) a[i]=aa[i];fz0k(i,bb.size()) b[i]=bb[i];\n            ntt(a,len,w);ntt(b,len,w);fz0k(i,len) a[i]=1ll*a[i]*b[i]%mod*a[i]%mod;ntt(a,len,iw);\n            vector<int> ans;int inv=qp(len,mod-2);fz0k(i,len) ans.push_back(1ll*a[i]*inv%mod);while (!ans.empty()&&!ans.back()) ans.pop_back();\n            return ans;\n        }\n    };\n    struct poly\n    {\n        vector<int> v;\n        inline void clear(){v.clear();}\n        inline int size(){return v.size();}\n        inline bool empty(){return v.empty();}\n        inline int back(){return v.back();}\n        inline void pop_back(){v.pop_back();}\n        inline void push_back(int x){v.push_back(x);}\n        inline void read(int n){clear();while (n--){int x;scanf(\"%d\",&x);v.push_back(x);}}\n        inline void print(){ff(v,it) printf(\"%d \",*it);puts(\"\");} \n        inline void print(int n){int i;for(i=0;i<n;i++)if(i<v.size())printf(\"%d \",v[i]);else printf(\"0 \");puts(\"\");}\n        inline poly operator+(const poly &x)const{vector<int> s;int i;for (i=0;i<x.v.size()||i<v.size();i++){int t=0;if(i<v.size())inc(t,v[i]);if(i<x.v.size())inc(t,x.v[i]);s.push_back(t);}return(poly){s};}\n        inline poly operator-(const poly &x)const{vector<int> s;int i;for (i=0;i<x.v.size()||i<v.size();i++){int t=0;if(i<v.size())inc(t,v[i]);if(i<x.v.size())dec(t,x.v[i]);s.push_back(t);}return(poly){s};}\n        inline poly operator*(const int &x)const{vector<int> s;int i;for (i=0;i<v.size();i++)s.push_back(1ll*x*v[i]%mod);return(poly){s};}\n        inline poly operator*(const poly &x)const{return (poly){basic::mul(v,x.v)};}\n        inline void mul_x(){int i;v.push_back(0);fd1(i,v.size()-1)v[i]=v[i-1];v[0]=0;} // this*=x\n        inline void divi_x(){int i;fz0k(i,((int)v.size())-1)v[i]=v[i+1];v.pop_back();} // this/=x\n        inline void derivation(){int i;fz0k(i,((int)v.size())-1)v[i]=1ll*v[i+1]*(i+1)%mod;v.pop_back();} // this=this的导数\n        inline void integral(){int i;v.push_back(0);fd1(i,v.size()-1)v[i]=1ll*v[i-1]*basic::inv[i]%mod;v[0]=0;} // this=this的积分 \n        inline void size_down(int x){while (v.size()>x)v.pop_back();}\n        inline void size_up(int x){while (v.size()<x)v.push_back(0);}\n        inline void resize(int x){size_down(x);size_up(x);}\n        inline int &operator[](const int &x){if (v.size()<=x)size_up(x+1);return v[x];}\n    };\n    inline poly derivation(poly a){a.derivation();return a;}\n    inline poly integral(poly a){a.integral();return a;}\n    inline poly mul_x(poly a){a.mul_x();return a;}\n    inline poly divi_x(poly a){a.divi_x();return a;}\n    inline poly poly_inv(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){fprintf(stderr,\"wrong poly_inv(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;}\n    \tpoly ta,tb;ta.push_back(a[0]);tb.push_back(qp(a[0],mod-2));int i,j;\n    \tfor (i=1;i<n;i<<=1){\n    \t\tfor (j=i;j<(i<<1)&&j<n;j++){\n    \t\t\tta.push_back(a[j]);\n    \t\t}\n    \t\ttb=tb*2-((poly){basic::mul2(tb.v,ta.v)});\n    \t\ttb.size_down(min((i<<1),n));\n    \t}\n    \treturn tb;\n    }\n    inline poly poly_ln(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){fprintf(stderr,\"wrong poly_ln(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;}\n    \tif (a[0]!=1){\n    \t\tfprintf(stderr,\"bad template poly_ln a[0]!=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;\n    \t}\n    \ta=integral(derivation(a)*poly_inv(a,n));a.size_down(n);\n    \treturn a;\n    }\n    inline poly poly_exp(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){a.push_back(1);return a;}\n    \tif (a[0]!=0){\n    \t\tfprintf(stderr,\"bad template poly_exp a[0]!=0 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;\n    \t}\n    \tpoly ta,tb,uit;uit.push_back(1);ta.push_back(a[0]);tb.push_back(1);int i,j;\n    \tfor (i=1;i<n;i<<=1){\n    \t\tfor (j=i;j<n&&j<(i<<1);j++){\n    \t\t\tta.push_back(a[j]);\n    \t\t}\n    \t\ttb=tb*(uit-poly_ln(tb,(i<<1))+ta);\n    \t\ttb.size_down(min((i<<1),n));\n    \t}\n    \treturn tb;\n    }\n    inline poly poly_sqrt(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){return a;}\n    \tpoly ta,tb;ta.push_back(a[0]);\n    \tif (a[0]==1){\n    \t\ttb.push_back(1);\n    \t}\n    \telse{\n    \t\tfprintf(stderr,\"bad template in poly_sqrt a[0]!=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");return a;\n    \t}\n    \tint i,inv2=qp(2,mod-2),j;for (i=1;i<n;i<<=1){\n    \t\tfor (j=i;j<(i<<1)&&j<n;j++) ta.push_back(a[j]);\n    \t\ttb=(tb+(ta*poly_inv(tb,(i<<1))))*inv2;\n    \t\ttb.size_down(min((i<<1),n));\n    \t}\n    \tif (tb[0]>mod-tb[0]) tb=tb*(mod-1); \n    \treturn tb;\n    }\n    inline poly poly_pow(poly a,int n,int k) // a^k mod (x^n) \n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){return a;}\n    \tint k0=0;while (k0<a.size()&&a.v[k0]==0) k0++;int i;\n    \tpoly b;for (i=k0;i<a.size();i++) b.v.push_back(a.v[i]);\n    \tint t=b.v[0];b=b*(qp(t,mod-2));t=qp(t,k);\n    \tk0=min(1ll*k0*k,1ll*n);b=poly_exp(poly_ln(b,n)*k,n)*t;\n    \ta.clear();while (k0--) a.v.push_back(0);\n    \tint idx=0;while (a.v.size()<n) a.v.push_back(b[idx++]);\n    \treturn a;\n    }\n    inline poly operator/(poly a,poly b)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \twhile (!b.empty()&&!b.back()) b.pop_back();\n    \tif (b.empty()){fprintf(stderr,\"wrong poly_div(a,0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");exit(-1);}\n    \treverse(a.v.begin(),a.v.end());reverse(b.v.begin(),b.v.end());\n    \tint n=a.size(),m=b.size(),k=n-m+1;if (k<=0){poly ans;ans.push_back(0);return ans;}\n    \ta.size_down(k);b.size_down(k);a=a*poly_inv(b,k);a.size_down(k);\n    \treverse(a.v.begin(),a.v.end());return a;\n    }\n    inline poly operator%(poly a,poly b)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \twhile (!b.empty()&&!b.back()) b.pop_back();\n    \tif (b.empty()){fprintf(stderr,\"wrong poly_mod(a,0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");exit(-1);}\n    \tint m=b.size();a=a-a/b*b;\n        a.size_down(m-1);return a;\n    }\n    inline void poly_divmod(poly a,poly b,poly &s1,poly &s2) // a/b=s1......s2\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();s1.clear();\n    \twhile (!b.empty()&&!b.back()) b.pop_back();s2.clear();\n    \tif (b.empty()){fprintf(stderr,\"wrong poly_divmod(a,0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");exit(-1);}\n    \tpoly c=a,d=b;reverse(a.v.begin(),a.v.end());reverse(b.v.begin(),b.v.end());\n    \tint n=a.size(),m=b.size(),k=n-m+1;if (k<0){s1.push_back(0);s2=a;return;}\n    \ta.size_down(k);b.size_down(k);s1=a*poly_inv(b,k);s1.size_down(k);\n    \treverse(s1.v.begin(),s1.v.end());s2=c-s1*d;\n        s2.size_down(m-1);\n    }\n    inline int poly_fuhe_inv(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a[0]!=0){fprintf(stderr,\"wrong poly_fuhe_inv(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");exit(-1);}\n    \tint i;for (i=0;i+1<a.size();i++) a[i]=a[i+1];a.pop_back();\n    \tif (!basic::tag) basic::init();return 1ll*(poly_pow(poly_inv(a,n),n,n)[n-1])*basic::inv[n]%mod;\n    }\n};using namespace polynomial;\n//------------------polynomial end------------------\nusing basic::fac;\nusing basic::inv;\nusing basic::fi;\nint binom(int x,int y)\n{\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint n,m,i,j,fa[300005],sz[300005],c[3],f[3005][3005];\nint ans1[300005],ans2[300005];\nint fnd(int x){if(fa[x]==x)return x;return fa[x]=fnd(fa[x]);}\nvoid init_f()\n{\n\tint n=10;\n\tf[0][0]=1;int i,j,k;\n\tfz1(k,n)fd0g(i,k*3/2){\n\t\tj=k-i;\n\t\tif(!i){\n\t\t\tif(i) f[k][i]=(f[k][i]+1ll*i*f[k-1][i-1]%mod*(k*3-i-1))%mod;\n\t\t\tf[k][i]=(f[k][i]+1ll*(k*3-i-i-1)*f[k][i+1])%mod;\n\t\t}\n\t\telse{\n\t\t\tif(i>1) f[k][i]=(f[k][i]+1ll*(i-1)*f[k-1][i-2])%mod;\n\t\t\tif(i)f[k][i]=(f[k][i]+1ll*(k*3-i-i)*f[k-1][i-1]%mod*(k*3-i-1))%mod;\n\t\t}\n\t}\n/*\tfz0g(k,n){\n\t\tfz0g(i,k*3/2){\n\t\t\tprintf(\"%10d\",f[k][i]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n}\nstruct ii\n{\n\tint k,i,id;\n};\nvector<ii> vq;\nvoid solve(int id)\n{\n\tif((c[2]+c[2]+c[1])/3<=2){\n\t\tans1[id]=f[(c[2]+c[2]+c[1])/3][c[2]];\n\t}\n\telse{\n\t\tvq.push_back((ii){(c[2]+c[2]+c[1])/3,c[2],id});\n\t}\n\tans2[id]=1ll*fac[c[1]+c[2]+c[0]]%mod*fi[c[1]+c[2]]%mod;\n}\nint pk,pi;\nint v1,v2;\nint v3,v4;\nint calc1(int k,int i,int v1,int v2)\n{\n\tint ans=0;\n\tans=(ans+1ll*(i-1)*v1)%mod;\n\tans=(ans+1ll*(k*3-i-i)*v2%mod*(k*3-i-1))%mod;\n\treturn ans;\n}\nint calc1r(int k,int i,int v1,int ans)\n{\n\tans=(ans-1ll*(i-1)*v1)%mod;ans=(ans+mod)%mod;\n\treturn 1ll*ans*qp((k*3-i-i),mod-2)%mod*qp(k*3-i-1,mod-2)%mod;\n}\nint calc1l(int k,int i,int v2,int ans)\n{\n\tans=(ans-1ll*(k*3-i-i)*v2%mod*(k*3-i-1))%mod;ans=(ans+mod)%mod;\n\tint v1=1ll*ans*qp(i-1,mod-2)%mod;\n\treturn v1;\n}\nint calc2(int k,int i,int v1,int v2)\n{\n\tint ans=0;\n\tans=(ans+1ll*i*v1%mod*(k*3-i-1))%mod;\n\tans=(ans+1ll*(k*3-i-i-1)*v2)%mod;\n\treturn ans;\n}\nint calc2r(int k,int i,int v1,int ans)\n{\n\tans=(ans-1ll*i*v1%mod*(k*3-i-1))%mod;ans=(ans+mod)%mod;\n\tint v2=1ll*qp(k*3-i-i-1,mod-2)*ans%mod;\n\treturn v2;\n}\nint main()\n{\n\tbasic::init();\n\tread(n);fz1(i,n)fa[i]=i,sz[i]=1;c[1]=n;\n\tinit_f();\n\tint _;bool flg=0;fz1(_,n){\n\t\tint x,y;read(x);read(y);x=fnd(x);y=fnd(y);\n\t\tif(x!=y){\n\t\t\tc[sz[x]%3]--;c[sz[y]%3]--;\n\t\t\tsz[y]+=sz[x];fa[x]=y;\n\t\t\tc[sz[y]%3]++;\n\t\t}\n\t\telse{\n\t\t\tif(sz[x]%3==0) c[0]--;\n\t\t\telse break;\n\t\t}\n\t\tsolve(_);\n\t}\n\treverse(vq.begin(),vq.end());\n\tfor(i=0;i+1<vq.size();i++)assert(vq[i].k<=vq[i+1].k);\n\tpk=2;pi=0;\n\tv1=f[pk][pi];v2=f[pk][pi+1];\n\tv3=f[pk+1][pi];v4=f[pk+1][pi+1];\n\tff(vq,it){\n\t\tfor(;;){\n\t\t\tif(pk==it->k&&pi==it->i){ans1[it->id]=v1;break;}\n\t\t\tif(pk==it->k&&pi+1==it->i){ans1[it->id]=v2;break;}\n\t\t\tif(pk+1==it->k&&pi==it->i){ans1[it->id]=v3;break;}\n\t\t\tif(pk+1==it->k&&pi+1==it->i){ans1[it->id]=v4;break;}\n\t\t\tif(pk<it->k){\n\t\t\t\tint dr=calc1(pk+2,pi+2,v3,v4);\n\t\t\t\tint nv4=calc2(pk+2,pi+1,v3,dr);\n\t\t\t\tint l=calc1l(pk+2,pi+1,v3,nv4);\n\t\t\t\tint nv3=calc2(pk+2,pi,l,nv4);\n\t\t\t\tv1=v3;v2=v4;v3=nv3;v4=nv4;\n\t\t\t\tpk++;continue;\n\t\t\t}\n\t\t\tif(pi<it->i){\n\t\t\t\tint dr=calc1(pk+2,pi+2,v3,v4);\n\t\t\t\tint nv1=calc1(pk+1,pi+2,v1,v2);\n\t\t\t\tint nv2=calc2r(pk+1,pi+2,v2,nv1);\n\t\t\t\tint nv4=calc1(pk+2,pi+3,v4,nv1);\n\t\t\t\tv1=v2;\n\t\t\t\tv2=calc1r(pk+1,pi+3,v2,nv2);\n\t\t\t\tv3=v4;v4=nv1;\n\t\t\t\tpi++;continue;\n\t\t\t}\n\t\t\tif(pi>it->i){\n\t\t\t\tint dr=calc1(pk+2,pi+2,v3,v4);\n\t\t\t\tint nv4=calc2(pk+2,pi+1,v3,dr);\n\t\t\t\tint nv3=calc1l(pk+2,pi+1,v3,nv4);\n\t\t\t\tint nv1=calc1l(pk+1,pi+1,v1,v4);\n\t\t\t\tv2=v1;v4=v3;v1=nv1;v3=nv3;\n\t\t\t\tpi--;continue;\n\t\t\t}\n\t\t}\n\t}\n\tfz1(i,n) printf(\"%lld\\n\",1ll*ans1[i]*ans2[i]%mod);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dp",
        "dsu",
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Multiple of Three Cycles.json",
    "editorial_link": "https://codeforces.com//blog/entry/118128",
    "editorial": "The partially formed permutation is composed of several paths and\r\ncycles, and only the length of each path/cycle modulo matters. We can\r\nuse a DSU to track the number of paths/cycles of each length . If at any\r\npoint a cycle whose length is not is formed, the answer is .Thus, the\r\nproblem reduces to the following: Given s, s, and s, how many ways are\r\nthere to build a permutation on these objects so that each cycle sums to\r\na multiple of ? Let be the answer to this problem. Note that for , as\r\nthere are ways to choose the next object of any , and after merging this\r\nwith its next object, there are ways to build a permutation on the\r\nremaining objects. Repeatedly applying this recurrence gives , so we can\r\neliminate the parameter and multiply the answer by a factorial and\r\ninverse factorial in the end.Now let . We have not one, but two\r\nrecurrence relations satisfies: when (consider the next object of any )\r\nwhen (consider the next object of any ) The key idea now is that because\r\nwe have two equations relating the four values , given any two of these\r\nvalues, we can solve for the other two. For example, if we know and , we\r\ncan calculate . Also note that the queried pairs can be visualized as a\r\nwalk in the plane, where each pair does not differ from the previous\r\npair by much. By using these recurrences carefully, it is possible to\r\ncalculate for all queries while calculating only values of .The details\r\ncan be tricky. The authorâs solution does the following: First, reverse\r\nthe order of the updates, possibly adding dummy updates if a cycle whose\r\nlength is not is created early. Then we need to find for a sequence of\r\npairs where and is one of , , , or for all . We loop through in order,\r\nmaintaining two values and at all times. Whenever we need a transition\r\nof the form , we use the recurrence to solve for (the new value of ),\r\nthen use the recurrence to find (the new value of ). The transition is\r\nsimilar. For transitions, do both of the previous types of transitions\r\nonce.The time complexity of the main part of the problem is . The\r\noverall time complexity is , dominated by the DSU operations.Remark 1:\r\nSince s and s behave symmetrically, .Remark 2: The exponential\r\ngenerating function for is .\r\n",
    "hint": [
        "Hint 1 The partially formed permutation is composed of several paths and cycles. Only the length of each path/cycle modulo matters.",
        "Hint 2 The problem reduces to the following: Given s, s, and s, how many ways are there to build a permutation on these objects so that each cycle sums to a multiple of ? Let be the answer. Write some dynamic programming recurrences for .",
        "Hint 3 Note that (choose the next object of any and merge them). Why is this useful? This allows us to eliminate the parameter, multiplying the answer by a factorial and inverse factorial.",
        "Hint 4 Let . Write down not one, but two recurrence relations satisfies. What are the recurrences? We have when (choose the next object of any and merge them) and also when (choose the next object of any and merge them).",
        "Hint 5 These recurrences mean that given any two of , we can solve for the other two.",
        "Hint 6 Consider the pairs that arise from the queries. These pairs can be visualized as a walk in the plane, where each each pair does not differ from the previous pair by much. If we carefully use the recurrences to solve for values of from values we already know, we can answer all queries on this walk while calculating only values of ."
    ]
}