{
    "link": "https://codeforces.com//contest/1609/problem/G",
    "problemId": "1205815",
    "problem_idx": "G",
    "shortId": "1609G",
    "contest_number": "1609",
    "problem_submissions": {
        "H": [
            137263072,
            140966657,
            137541381,
            137373776,
            137353707,
            137353217
        ],
        "G": [
            137246775,
            137257898,
            137258174,
            137261032,
            137258429,
            137256905,
            137250571,
            137257690,
            137251480,
            137263274,
            137259638,
            137276051,
            137269427,
            137261135,
            137260806,
            137259792,
            137262185,
            137263614,
            137264862,
            137254900,
            137261420,
            137264154
        ],
        "F": [
            137240106,
            137246731,
            137244466,
            137246785,
            137246316,
            137246745,
            137260178,
            137270360,
            137247766,
            137257633,
            137249504,
            137249777,
            137249032,
            137252722,
            137252015,
            137251624,
            137252333,
            137250283,
            137261839,
            137252294,
            137249612
        ],
        "E": [
            137234780,
            137235959,
            137233979,
            137232935,
            137235656,
            137237935,
            137233267,
            137237781,
            137236310,
            137235301,
            137237711,
            137241732,
            137237330,
            137241596,
            137235797,
            137236926,
            137239464,
            137239281,
            137241206,
            137238999
        ],
        "D": [
            137226570,
            137230215,
            137231182,
            137228712,
            137232181,
            137231416,
            137229857,
            137231314,
            137233347,
            137230846,
            137231581,
            137229849,
            137233415,
            137234328,
            137231105,
            137231235,
            137232699,
            137231119,
            137233860,
            137235117
        ],
        "C": [
            137224003,
            137226381,
            137228113,
            137226088,
            137228622,
            137227880,
            137227092,
            137227813,
            137229692,
            137227035,
            137228022,
            137226433,
            137228702,
            137230474,
            137231768,
            137227164,
            137229482,
            137228456,
            137229353,
            137230487
        ],
        "B": [
            137222196,
            137223090,
            137224802,
            137223100,
            137224371,
            137223720,
            137223346,
            137224383,
            137222999,
            137223539,
            137224162,
            137223482,
            137224120,
            137224040,
            137223954,
            137223074,
            137224144,
            137224291,
            137224533,
            137224451
        ],
        "A": [
            137221600,
            137221784,
            137221681,
            137221800,
            137221985,
            137221740,
            137221875,
            137222467,
            137221786,
            137221979,
            137222676,
            137221642,
            137222045,
            137222137,
            137226851,
            137224172,
            137221659,
            137222130,
            137222631,
            137222150
        ]
    },
    "name": "G. A Stroll Around the Matrix",
    "statement": "William has two arrays of numbers a_1, a_2,\r\ndots, a_n and b_1, b_2,\r\ndots, b_m. The arrays satisfy the conditions of being convex. Formally\r\nan array c of length k is considered convex if c_i - c_{i - 1} < c_{i +\r\n1} - c_i for all i from 2 to k - 1 and c_1 < c_2.Throughout William’s\r\nlife he observed q changes of two types happening to the arrays: Add the\r\narithmetic progression d, d\r\ncdot 2, d\r\ncdot 3,\r\ndots, d\r\ncdot k to the suffix of the array a of length k. The array after the\r\nchange looks like this: [a_1, a_2,\r\ndots, a_{n - k}, a_{n - k + 1} + d, a_{n - k + 2} + d\r\ncdot 2,\r\ndots, a_n + d\r\ncdot k]. The same operation, but for array b. After each change a matrix\r\nd is created from arrays a and b, of size n\r\ntimes m, where d_{i, j}=a_i + b_j. William wants to get from cell (1, 1)\r\nto cell (n, m) of this matrix. From cell (x, y) he can only move to\r\ncells (x + 1, y) and (x, y + 1). The length of a path is calculated as\r\nthe sum of numbers in cells visited by William, including the first and\r\nthe last cells.After each change William wants you to help find out the\r\nminimal length of the path he could take.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 28.11.2021 18:24:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  auto init_b = b;\n  vector<long long> da(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    da[i] = a[i + 1] - a[i];\n  }\n  vector<long long> db(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    db[i] = b[i + 1] - b[i];\n  }\n  fenwick<int> fenw(m - 1);\n  fenwick<long long> fenw2(m - 1);\n  long long ans = 0;\n  for (int i = 0; i < m - 1; i++) {\n    ans += db[i] * (m - 1 - i);\n  }\n  while (q--) {\n    int type, k, d;\n    cin >> type >> k >> d;\n    if (type == 1) {\n      if (k == n) {\n        a[0] += d;\n        k -= 1;\n      }\n      for (int i = 0; i < k; i++) {\n        a[n - k + i] += d * (i + 1);\n        da[n - k + i - 1] += d;\n      }\n    } else {\n      if (k == m) {\n        b[0] += d;\n        k -= 1;\n      }\n      fenw.modify(m - k - 1, d);\n      fenw2.modify(m - k - 1, ((long long) -d) * (m - k - 2));\n      ans += ((long long) d) * k * (k + 1LL) / 2;\n    }\n    long long res = ans;\n    res += (a[0] + b[0]) * (n + m - 1);\n    for (int i = 0; i < n - 1; i++) {\n      int low = 0, high = m - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        if (db[mid] + fenw.get(mid) > da[i]) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      int my_id = (n - 2 - i) + (m - 1 - low) + 1;\n      res += da[i] * my_id;\n      res += init_b[low] - init_b[0];\n      res += fenw.get(low - 1) * (long long) (low - 1) + fenw2.get(low - 1);\n    }\n    cout << res << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. A Stroll Around the Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/97350",
    "editorial": "First of all, it should be noted, that one iteration of the described\r\nalgorithm of robotsâ movements can be implemented in time. For example,\r\nusing stack.Letâs consider moments of time that are multiple of . And\r\nsegments of time between such two consecutive moments of time. Consider\r\ntwo adjacent robots. It can be proved that if these two robots touched\r\neach other during a segment of time (), then they will touch each other\r\nduring any succeeding segment of time (). One thing that may change in\r\nthe future is that the left robot will be blocked from moving to the\r\nleft, or the right robot will be blocked from moving to the right.\r\nRobots just will become closer to each other after such a change. Itâs\r\nalso possible that the left robot will be blocked from moving to the\r\nright, or the right robot from moving to the left. But then they are\r\ntouching.Similarly, if after seconds distance between two robots\r\ndecreases, then it will continue decreasing until they touch during some\r\nsegment of time. And if two robots touch during a segment of time, then\r\nthe distance between them after this segment of time will be less than\r\nor equal to the distance between them before this segment.Letâs simulate\r\nthe first seconds, and then another seconds. Letâs look at pairs of\r\nadjacent robots. If the distance between two robots increased or didnât\r\nchange, skip this pair. If the distance between two robots decreased. If\r\nthe distance is , then robots may touch during the next segment. So,\r\nletâs simulate the next seconds again. Otherwise, let distance be and it\r\ndecreased by during the last segment of time. Then, during the next\r\nsegments of time it will continue decreasing with the same speed ( units\r\nper seconds). So we can skip these segments of time, and simulate the\r\nnext after them. Letâs choose the minimum segment of time that should be\r\nsimulated. Letâs skip all till this segment of time, and simulate it.\r\nThen again choose the minimum segment of time till which we can skip\r\nsimulation.It can be proved that there will be simulated segments of\r\ntime overall. This is due to the fact that thereâre no more than\r\ndecreases of the distance between two adjacent robots, after which we\r\nwill do the simulation.In order to answer questions, letâs also simulate\r\nsegments of time that contain moments of time of questions.Total time\r\ncomplexity is .\r\n",
    "hint": []
}