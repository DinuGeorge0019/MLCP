{
    "link": "https://codeforces.com//contest/794/problem/G",
    "problemId": "106236",
    "problem_idx": "G",
    "shortId": "794G",
    "contest_number": "794",
    "problem_submissions": {
        "F": [
            27081873,
            27083526,
            27083046,
            27085017,
            27081983,
            27082510,
            27086006,
            27083949,
            27080179,
            27086715,
            27082966,
            27079645,
            27084337,
            27084766,
            27081869,
            27081966,
            27084662
        ],
        "E": [
            27079377,
            27080585,
            27080375,
            27082137,
            27084820,
            27086075,
            27082614,
            27085336,
            27086070,
            27082160,
            27085721,
            27085903,
            27085376,
            27087205,
            27084980,
            27082950,
            27083172,
            27085134
        ],
        "D": [
            27077745,
            27078665,
            27078681,
            27079267,
            27079635,
            27079737,
            27080740,
            27079081,
            27083788,
            27079987,
            27082339,
            27082247,
            27082529,
            27080107,
            27094240,
            27094236,
            27094226,
            27094219,
            27094212,
            27094182,
            27094168,
            27094131,
            27094066,
            27080763,
            27081677,
            27089971,
            27089903,
            27087542,
            27080778
        ],
        "C": [
            27075178,
            27076116,
            27076013,
            27076437,
            27076459,
            27075605,
            27076203,
            27075986,
            27076793,
            27077625,
            27078065,
            27084041,
            27076700,
            27077790,
            27078769,
            27077244,
            27075390,
            27082931,
            27077078
        ],
        "B": [
            27072873,
            27073613,
            27072949,
            27073965,
            27073074,
            27073568,
            27073477,
            27073304,
            27073689,
            27073228,
            27073014,
            27073894,
            27072703,
            27074273,
            27072442,
            27074226,
            27073723,
            27073830,
            27073779
        ],
        "A": [
            27072392,
            27072471,
            27072465,
            27072459,
            27072555,
            27072760,
            27072661,
            27072604,
            27072817,
            27072481,
            27072447,
            27072409,
            27072476,
            27072463,
            27072773,
            27072976,
            27072422,
            27074544,
            27072598
        ],
        "G": [
            27216394,
            27227867
        ]
    },
    "name": "G. Replace All",
    "statement": "Igor the analyst is at work. He learned about a feature in his text\r\neditor called \"Replace All\". Igor is too bored at work and thus he came\r\nup with the following problem:Given two strings and which consist of the\r\nEnglish letters \u201d and \u201d only, a pair of strings is called if: and\r\nconsist of the characters \u201d and \u201d only. , where denotes the length of\r\nstring , and is a fixed positive integer. If we replace all occurrences\r\nof \u201d in and with the string , and replace all occurrences of \u201d in and\r\nwith the string , then the two obtained from and strings are equal. For\r\nexample, if , and , then (, ) is one of good pairs of strings, because\r\nboth obtained after replacing strings are \"\".The of a pair of strings\r\nand is the number of pairs of good strings . The pairs are ordered, for\r\nexample the pairs , and , are different.You\u2019re given two strings and .\r\nThey consist of characters \u201d, \u201d and \u201d only. Find the sum of\r\nflexibilities of all possible pairs of strings such that and can be\r\nobtained from and respectively by replacing the question marks with\r\neither \u201d or \u201d, modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nint ex_gcd(const int &a, const int &b, int &x, int &y)\n{\n\tif (!b)\n\t{\n\t\tx = 1, y = 0;\n\t\treturn a;\n\t}\n\tint d = ex_gcd(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nconst int Mod = 1e9 + 7;\n\ninline int fpm(LL b, int e, int m)\n{\n\tb %= m;\n\tLL t = 1;\n\tfor ( ; e; e >>= 1, (b *= b) %= m)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nconst int maxn = 600100;\n\nint fac[maxn + 5], ifac[maxn + 5];\n\nint pw2[maxn + 5];\n\nint mu[maxn + 5], phi[maxn + 5];\n\ninline void prepare()\n{\n\tfac[0] = 1;\n\tREP(i, 0, maxn) fac[i + 1] = (LL)fac[i] * (i + 1) % Mod;\n\tifac[maxn] = fpm(fac[maxn], Mod - 2, Mod);\n\tfor (int i = maxn - 1; i >= 0; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n\tpw2[0] = 1;\n\tREP(i, 0, maxn) pw2[i + 1] = (pw2[i] << 1) % Mod;\n\tmu[1] = 1;\n\tfor (int i = 1; i <= maxn; ++i)\n\t\tfor (int j = (i << 1); j <= maxn; j += i)\n\t\t\tmu[j] -= mu[i];\n\tfor (int i = 1; i <= maxn; ++i)\n\t\tfor (int j = 1; j * i <= maxn; ++j)\n\t\t\tphi[i * j] += mu[i] * j;\n}\n\ninline int getC(int x, int y)\n{\n\treturn (LL)fac[x] * ifac[y] % Mod * ifac[x - y] % Mod;\n}\n\nint n;\nint aa, ab, ae, ba, bb, be;\nint an, bn;\nchar a[maxn + 5], b[maxn + 5];\n\nint ans;\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tprepare();\n\tscanf(\"%s\", a);\n\tscanf(\"%s\", b);\n\tscanf(\"%d\", &n);\n\tan = strlen(a), bn = strlen(b);\n\tREP(i, 0, an) \n\t\tif (a[i] == 'A') ++aa;\n\t\telse if (a[i] == 'B') ++ab;\n\tREP(i, 0, bn) \n\t\tif (b[i] == 'A') ++ba;\n\t\telse if (b[i] == 'B') ++bb;\n\tae = an - aa - ab;\n\tbe = bn - ba - bb;\n\tint orix = aa - ba;\n\tREP(i, 0, ae + be + 1)\n\t{\n\t\tint tmp = getC(ae + be, i);\n\t\tint delta = i - be;\n\t\tint coex = orix + delta, coey = (an - bn) - coex;\n\t\tint val = 0;\n\t\tif (!coex && !coey) \n\t\t{\n\t\t\tassert(an == bn);\n\t\t\tval = (LL)(pw2[n + 1] - 2) * (pw2[n + 1] - 2) % Mod;\n\t\t\tint ways = 1;\n\t\t\tREP(j, 0, an) \n\t\t\t\tif (a[j] != '?' && b[j] != '?')\n\t\t\t\t{\n\t\t\t\t\tif (a[j] != b[j]) { ways = 0; break; }\n\t\t\t\t}\n\t\t\t\telse if (a[j] == '?' && b[j] == '?') (ways <<= 1) %= Mod;\n\t\t\t(ans += (LL)ways * val % Mod) %= Mod;\n\t\t\tval = 0;\n\t\t\tREP(j, 1, n + 1)\n\t\t\t{\n\t\t\t\tint tmp0 = phi[j];\n\t\t\t\tif (j > 1) (tmp0 <<= 1) %= Mod;\n\t\t\t\t(val += (LL)tmp0 * (pw2[n / j + 1] - 2) % Mod) %= Mod;\n\t\t\t}\n\t\t\t(ans += (LL)(tmp - ways) * val % Mod) %= Mod;\n\t\t}\n\t\telse if (coex && coey)\n\t\t{\n\t\t\tif (coex < 0) coex = -coex;\n\t\t\telse coey = -coey;\n\t\t\tif (coey < 0) continue;\n\t\t\tint d = __gcd(coex, coey);\n\t\t\tcoex /= d, coey /= d;\n\t\t\tval = pw2[n / max(coex, coey) + 1] - 2;\n\t\t\t(ans += (LL)tmp * val % Mod) %= Mod;\n\t\t}\n\t}\n\t(ans += Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Replace All.json",
    "editorial_link": "https://codeforces.com/blog/entry/51962",
    "editorial": "First, we solve the problem when there're no question marks, i.e. we find a way to calculate the number of good pairs of strings fast for a constant pair of strings A and B.\n\nCall a pair of strings (S,?T) where |S|???|T| coprime if S?=?T or S is a prefix of T, and if T?=?S?+?X, then (X,?S) is also coprime. (S,?T) where |S|?>?|T| is coprime iff (T,?S) is coprime.\n\nIf A?=?B, then all possible strings work. Thus, we assume A???B from now on. We remove the longest common prefix of A and B. Thus, we can assume A[0]???B[0]. Thus, either S is a prefix of T or T is a prefix of S. WLOG, S is a prefix of T. Let T?=?S?+?X. Now, A and B consists of only S and X. Using this, we can prove by induction on |S|?+?|T| that S and T must be coprime.\n\nOne important property of coprime strings is that S?+?T?=?T?+?S holds. (again induction works here)\n\nNow, since the strings S and T needs to be coprime, we have S?+?T?=?T?+?S. This allows us to swap any neighbouring Ss and Ts (or 'A's and 'B's) in A and B, as the resulting strings will still be equal. Thus, swapping repeatedly allows us to sort the strings A and B. (the 'A's appear in front and 'B's appear at the back) Let xA,?xB,?yA,?yB denote the number of As and Bs in the first string and second string respectively. If (xA,?xB)?>?(yA,?yB), then the answer is 0. We'll handle the case (xA,?xB)?=?(yA,?yB) later. Now, assume xA?>?yA,?xB?<?yB. Thus, we have to solve the equation (xA?-?yA) copies of S = (yB?-?xB) copies of T.\n\nNow, let x?=?xA?-?yA,?y?=?yB?-?xB. If x?=?y, then the solution is S?=?T. Otherwise, assume x?>?y. Then, |S|?<?|T|. So, by comparing, we again have T?=?S?+?X, for some nonempty binary string X. Note that S and X must be coprime too, so we can sort the second string as well. We cancel off the Ss on both sides to get (x?-?y)S?=?yX. Thus, this means that if (S,?T) is a solution for (x,?y), then (S,?X) is a solution for (x?-?y,?y). Note that repeating this process will eventually lead us to (1,?1). (this process is similar to Euclidean Algorithm)\n\nThe answer for (1,?1) is the number of solutions to S?=?T. Let's denote the solution here as X. Doing some backtracking, we realize that the answer for (x,?y) is equal to (X....X (y times), X...X (x times)). Note that we still have the condition |S|,?|T|???N, so we can translate this to an appropriate condition on the length of X and the answer is simply the number of binary strings of length not exceeding the maximum possible length of X.\n\nThe only case that remains is that (xA,?xB)?=?(yA,?yB). In this case, any pair of coprime strings S and T will work. Thus, our task reduces to calculating the number of coprime pair of strings with length not exceeding N.\n\nWe claim that the number of coprime pair of strings (S,?T) with |S|?=?p,?|T|?=?q is .\n\nIf p?=?q the claim is obviously true. Otherwise, we can induct on p?+?q agin. If q?>?p, we can write T?=?S?+?X and then the number of coprime pairs of (S,?T) is equal to the number of coprime pairs of (S,?X), which by induction is equal to . This proves the claim.\n\nThus, we just need to compute the sum of  for all 1???p,?q???N.\n\nIndeed, since N???3\u00b7105, it is enough to count the number of pairs (p,?q) with gcd?=?g for all g.\n\nHowever, this is quite easy. Let cnt[i] denote the number of pairs (p,?q) such that p and q are both divisible by i. Let ans[i] denote the number of pairs (p,?q) with gcd?=?i. Then, . Thus, this can be computed in .\n\nNow, we need to find out how to calculate the sum of all these values on two strings X and Y with question marks. Handle the case when the two strings become equal separately.\n\nLet's first make a summary of the number of good pairs of strings for constant strings A and B. In fact, note that the formulaes above only depends on (dA,?dB), the difference between the number of As in A and B, and the difference between the number of Bs in A and B (note that dA,?dB can be negative)\n\nIf dA?=?dB?=?0, then the answer is the sum of  for all 1???p,?q???N, which as we have just saw can be precomputed in time.\n\nOtherwise, if dA,?dB???0 or dA,?dB???0, then there are no good pair of strings.\n\nFinally, in other cases, let p?=?|dA|,?q?=?|dB|. Then, the answer is .\n\nThis also means that we can compute the answer if we know dA and dB very fast. (worst case is )\n\nNow, suppose in the strings X and Y, we have a and b question marks respectively. Additionally, suppose the current difference between the number of As and Bs of these strings is (p,?q).\n\nIf we choose x and y of the question marks from X and Y to be replaced with As, then the difference between As and Bs in the strings become (p?+?x?-?y,?q?+?(a?-?b)?-?(x?-?y)). Let's denote q as q?+?a?-?b for simplicity. Thus, the difference is now written as (p?+?(x?-?y),?q?-?(x?-?y)). The values of x and y can be any integer in the range [0,?a] and [0,?b] respectively. Suppose for all ?-?b???d???a, we know how many ways to assign the question marks have x?-?y?=?d. Then, we can iterate through all the ds one by one and compute the answer fast for each d.\n\nThus, the final hurdle is to calculate the number of ways to obtain x?-?y?=?d for all possible d so that 0???x???a,?0???y???b. This is just the sum of  for all 0???x???a. However, this is equal to , as the number of ways to choose b?+?d objects from a?+?b objects is the same as the sum of the product of the number of ways to choose x objects from the first a objects and the number of ways to choose b?+?d?-?x objects from the first b objects for all 0???a???x. Thus, this value can be computed in O(1) with precomputed factorials and inverse factorials (or you can maintain this value when we iterate through all d).\n\nFinally, don't forget to take care of the cases where it is possible for both strings to be equal."
}