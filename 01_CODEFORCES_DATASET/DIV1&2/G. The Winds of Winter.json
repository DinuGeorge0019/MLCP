{
    "link": "https://codeforces.com//contest/768/problem/G",
    "problemId": "94878",
    "problem_idx": "G",
    "shortId": "768G",
    "contest_number": "768",
    "problem_submissions": {
        "F": [
            24840431,
            24838480,
            24834630,
            24841891,
            24838353,
            24840717,
            24837763,
            24842282,
            24838721,
            24833873,
            24842120,
            24844145,
            24842096,
            24840981,
            24845191,
            24842247,
            24840284,
            24847109,
            24843919
        ],
        "E": [
            24834774,
            24835983,
            24832451,
            24837828,
            24833805,
            24837182,
            24833920,
            24836646,
            24835033,
            24838913,
            24837846,
            24833547,
            24837106,
            24837362,
            24839266,
            24837276,
            24838051,
            24835972,
            24836022
        ],
        "D": [
            24832202,
            24833876,
            24835915,
            24835246,
            24832704,
            24834168,
            24832774,
            24838949,
            24833061,
            24836615,
            24839525,
            24834336,
            24833791,
            24835394,
            24835786,
            24835146,
            24835911,
            24837569,
            24837832
        ],
        "C": [
            24830784,
            24831935,
            24846692,
            24833492,
            24831356,
            24831859,
            24830894,
            24833465,
            24831521,
            24835038,
            24835013,
            24830101,
            24832003,
            24831977,
            24833696,
            24832023,
            24832927,
            24833660,
            24834203
        ],
        "B": [
            24828716,
            24830642,
            24828869,
            24830153,
            24830045,
            24829484,
            24830872,
            24829643,
            24837759,
            24831145,
            24828453,
            24830132,
            24829454,
            24830410,
            24829830,
            24830884,
            24831500,
            24831921
        ],
        "A": [
            24825770,
            24826388,
            24825799,
            24826247,
            24825814,
            24825782,
            24825775,
            24825815,
            24827152,
            24827361,
            24826212,
            24825822,
            24826382,
            24826002,
            24825750,
            24826264,
            24826016,
            24825780,
            24828293
        ],
        "G": [
            24850234,
            25339793,
            24854056,
            24855563,
            24855744
        ]
    },
    "name": "G. The Winds of Winter",
    "statement": "Given a rooted tree with nodes. The Night King removes exactly one node\r\nfrom the tree and all the edges associated with it. Doing this splits\r\nthe tree and forms a forest. The node which is removed is not a part of\r\nthe forest.The root of a tree in the forest is the node in that tree\r\nwhich does not have a parent. We define the strength of the forest as\r\nthe size of largest tree in forest.Jon Snow wants to minimize the\r\nstrength of the forest. To do this he can perform the following\r\noperation at most once.For each node you need to find the minimum value\r\nof strength of the forest formed when node is removed.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n#define tm tm1\n#define y1 y11\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define NAME \"\"\n\nusing namespace std;\n\t\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\n\nstruct node\n{\n\tnode *l;\n\tnode *r;\n\tint sm;\n};\n\ntypedef node* pnode;\n\n\nconst int MAXN = 600020;\n\nint sz[MAXN];\t\nvector <int> e[MAXN];\nint p[MAXN];\nint l[MAXN], r[MAXN];\nint tm = 0;\npnode root[MAXN];\nint n;\nint ans[MAXN];\n\npnode create_rmq(int cn)\n{\n\tpnode cur = new node();\n\tcur->sm = 0;\n\tif (cn == 1)\n\t{\n\t\tcur->l = cur->r = NULL;\n\t}\n\telse cur->l = create_rmq((cn + 1) / 2), cur->r = create_rmq(cn / 2);\n\treturn cur;\n}\n\nint lv, rv = 1;\n\npnode modify_rmq(pnode t, int l, int r)\n{\n\tpnode an = new node();\n\tan->sm = t->sm + rv;\n\tif (l == r)\n\t{\n\t\tan->l = an->r = NULL;\n\t}\n\telse\n\t{\n\t\tint md = (l + r) / 2;\n\t\tif (lv <= md) an->l = modify_rmq(t->l, l, md), an->r = t->r;\n\t\telse an->l = t->l, an->r = modify_rmq(t->r, md + 1, r);\n\t}\n\treturn an;\n}\n\nvoid modify_rmq2(pnode t, int l, int r)\n{\n\tt->sm += rv;\n\tif (l != r)\n\t{\n\t\tint md = (l + r) / 2;\n\t\tif (lv <= md) modify_rmq2(t->l, l, md);\n\t\telse modify_rmq2(t->r, md + 1, r);\n\t}\n}\n\ntypedef vector <pair <pnode, int> > vectt;\n\n\nvectt vts[MAXN];\n\nbool go_rmq(int l, int r, int level = 0)\n{\n\tint vc = vts[0].size();\n\tif ((lv <= l) && (r <= rv))\n\t{\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < vc; i++)\n\t\t\tcur += (vts[level][i].first -> sm) * vts[level][i].second;\n\t\treturn (cur > 0);\n\t}\n\tint md = (l + r) / 2;\n\tvts[level + 1] = vts[level];\n\tif (lv <= md)\n\t{\n\t\tfor (int i = 0; i < vc; i++)\n\t\t{\n\t\t\tvts[level + 1][i].first = vts[level][i].first -> l;\n\t\t}\n\t\tif (go_rmq(l, md, level + 1)) return true;\n\t}\n\tif (md < rv)\n\t{\n\t\tfor (int i = 0; i < vc; i++)\n\t\t{\n\t\t\tvts[level + 1][i].first = vts[level][i].first -> r;\n\t\t}\n\t\tif (go_rmq(md + 1, r, level + 1)) return true;\n\t}\n\treturn false;\n}\n\nvoid dfs1(int v)\n{\n\tl[v] = tm;\n\tsz[v] = 1;\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tdfs1(e[v][i]);\n\t\tsz[v] += sz[e[v][i]];\n\t}\n\tr[v] = ++tm;\n\tlv = sz[v];\n\trv = 1;\n\troot[tm] = modify_rmq(root[tm - 1], 0, n);\n}\n\npnode del;\n\nint rt;\n\nvector <pair <int, int> > cur;\n\nvoid dfs2(int v)\n{\n\tcur.clear();\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tcur.push_back(mp(sz[e[v][i]], e[v][i]));\n\t}\n\tif (v != rt) cur.push_back(mp(n - sz[v], 0));\n\tsort(cur.begin(), cur.end());\n\tint cs = cur.size();\n\tif (cs == 1) ans[v] = n - 1;\n\telse\n\t{\n\t\tvectt vt;\n\t\tvt.clear();\n\t\tvectt vt2;\n\t\tvt2.clear();\n\t\tvt2.push_back(mp(del, 1));\n\t\tint ls = cur[cs - 1].second;\n\t\tif (ls == 0)\n\t\t{\n\t\t\tvt.push_back(mp(root[l[v]], 1));\n\t\t\tvt.push_back(mp(root[r[v]], -1));\n\t\t\tvt.push_back(mp(root[n], 1));\n\t\t\tvt.push_back(mp(del, -1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvt.push_back(mp(root[l[ls]], -1));\n\t\t\tvt.push_back(mp(root[r[ls]], 1));\n\t\t}\n\t\tint lg = cur[cs - 2].first, rg = cur[cs - 1].first;\n\t\twhile (lg < rg)\n\t\t{\n\t\t\tint md = (lg + rg) / 2;\n\t\t\tlv = cur[cs - 1].first - md;\n\t\t\trv = md - cur[0].first;\n\t\t\tif (lv > rv)\n\t\t\t{\n\t\t\t\tlg = md + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvts[0] = vt;\n\t\t\tbool ok = go_rmq(0, n);\n\t\t\tif (ls == 0)\n\t\t\t{\n\t\t\t\tlv += sz[v];\n\t\t\t\trv += sz[v];\n\t\t\t\trv = min(rv, n);\n\t\t\t\tif (lv <= rv)\n\t\t\t\t{\n\t\t\t\t\tvts[0] = vt2;\n\t\t\t\t\tok |= go_rmq(0, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) rg= md;\n\t\t\telse lg = md + 1;\n\t\t}\n\t\tans[v] = lg;\n\t}\n\tlv = sz[v], rv = 1;\n\tmodify_rmq2(del, 0, n);\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tdfs2(e[v][i]);\n\t}\n\tlv = sz[v], rv = -1;\n\tmodify_rmq2(del, 0, n);\n}\n\n\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\t\n\tcin >> n;\n\tif (n == 1)\n\t{\n\t\tcout << 0;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <=  n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tif (u == 0)\n\t\t{\n\t\t\tp[v] = v;\n\t\t\trt = v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp[v] = u;\n\t\t\te[u].push_back(v);\n\t\t}\n\t}\n\troot[0] = create_rmq(n + 1);\n\tdel = create_rmq(n + 1);\n\tdfs1(rt);\n\tdfs2(rt);\n\tfor (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. The Winds of Winter.json",
    "editorial_link": "https://codeforces.com//blog/entry/50550",
    "editorial": "Set and Editorial by: apoorv_kulsh We are given a tree. We remove one\r\nnode from this tree to form a forest. Strength of forest is defined as\r\nthe size of largest tree in forest. We need to minimize the strength by\r\nchanging the parent of atmost one node to some other node such that\r\nnumber of components remain same. To find the minimum value of strength\r\nwe do a binary search on strength. It is possible to attain Strength\r\nif 1. There is less than one component with size greater than . 2. There\r\nexists a node in maximum component with subtree size such that, (Here is\r\nsize of maximum component and m is size of minimum component) . Then we\r\ncan change the parent of this node to some node in smallest component.\r\nThe problem now is to store Subtree_size of all nodes in the maximum\r\ncomponent and perform binary search on them. We can use Stl Map for\r\nthis. Let be the node which is removed and be its subtree size There are\r\ntwo cases now -: 1. When max size tree is child of . 2. When max size\r\ntree is the tree which remains when we remove subtree of from original\r\ntree.(We refer to this as outer tree of ). In the second case the\r\nsubtree sizes of nodes on path from root to will change when is removed.\r\nInfact their subtree size will decrease exactly by . While performing\r\nbinary search on these nodes there will be an offset of . So we store\r\nthem seperately. Now we need to maintain Maps, where : Stores the\r\nSubtree_size of all nodes present in heaviest child of . : Stores the\r\nSubtree_size of all nodes on the path from root to . : Stores the\r\nSubtree_size of all nodes in outer tree which are not on path from root\r\nto . Go through this blog post before reading further\r\n(http://codeforces.com/blog/entry/44351). Maintaining the Maps and are\r\ninitialised to empty while contains Subtree_size of all nodes in the\r\ntree. : This can be easily maintained by inserting the Subtree_size of\r\nnode in map when we enter a node in dfs and remove it when we exit it. :\r\ncan be maintained by using the dsu on tree trick mentioned in blogpost.\r\n: When we insert a nodeâs subtree_size in or we can remove the same from\r\nand similarly when we insert a nodeâs Subtree_size in or we can remove\r\nthe same from . Refer to HLD style implementation in blogpost for\r\neasiest way of maintaining . Refer to code below for exact point of\r\ninsertions and deletions into above mentioned maps. Code\r\n",
    "hint": []
}