{
    "link": "https://codeforces.com//contest/1994/problem/D",
    "problemId": "2760784",
    "problem_idx": "D",
    "shortId": "1994D",
    "contest_number": "1994",
    "problem_submissions": {
        "H": [
            271268810,
            271261236,
            271268610,
            271257398,
            271256333,
            271267520,
            271313433,
            271274176,
            271248306,
            271287210,
            271283377,
            271283359,
            271282520
        ],
        "G": [
            271229872,
            271233816,
            271238208,
            271227356,
            271235437,
            271226550,
            271234367,
            271234742,
            271238779,
            271238270,
            271225091,
            271234935,
            271238841,
            271240257,
            271243721,
            271243649,
            271233908,
            271244521,
            271244063
        ],
        "F": [
            271214789,
            271228871,
            271233459,
            271220149,
            271228791,
            271236762,
            271228615,
            271226473,
            271231018,
            271229788,
            271213472,
            271228121,
            271232218,
            271232892,
            271232972,
            271231186,
            271267486,
            271243051,
            271234735,
            271231874
        ],
        "E": [
            271208462,
            271218792,
            271225076,
            271214384,
            271214472,
            271215377,
            271220481,
            271220501,
            271217729,
            271220075,
            271230923,
            271220200,
            271221333,
            271221570,
            271219993,
            271222653,
            271267440,
            271226341,
            271222083,
            271220365
        ],
        "D": [
            271202405,
            271212139,
            271218875,
            271208005,
            271207650,
            271208685,
            271211312,
            271203391,
            271211524,
            271212286,
            271234069,
            271211646,
            271213596,
            271214194,
            271209598,
            271213200,
            271211604,
            271209945,
            271214556
        ],
        "C": [
            271199233,
            271206203,
            271213680,
            271202592,
            271203860,
            271204743,
            271205070,
            271213462,
            271205158,
            271207577,
            271204749,
            271209599,
            271203078,
            271203590,
            271209662,
            271268293,
            271268187,
            271204900,
            271203748,
            271208451
        ],
        "B": [
            271196298,
            271197883,
            271199651,
            271199362,
            271196300,
            271198662,
            271198429,
            271197282,
            271197595,
            271196709,
            271198001,
            271201728,
            271198447,
            271198638,
            271200600,
            271198424,
            271197818,
            271196402
        ],
        "A": [
            271195365,
            271195316,
            271196075,
            271196307,
            271195291,
            271195470,
            271195498,
            271195546,
            271195401,
            271195293,
            271195685,
            271195898,
            271195396,
            271195975,
            271195344,
            271195348,
            271195380,
            271195303
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131666",
    "editorial": "Note that we have only edges, so after each operation, the number of\r\nconnectivity components must decrease by .Since the order of operations\r\nis not important, we will perform the operations in reverse order. Then\r\nafter the operation with number , there will be connectivity components\r\nin the graph. For each component, let\u00e2\u0080\u0099s take any of its vertices and\r\nlook at the number that corresponds to it. Note that we have chosen\r\nnumbers, so by the pigeonhole principle, some two numbers will be equal\r\nmodulo . This means that we find two vertices and from different\r\ncomponents such that is a multiple of . By drawing an edge between and ,\r\nwe will achieve what we want the number of connectivity components will\r\nbecome less.Now it remains to go through the operations in reverse order\r\nand print the answer.\r\n",
    "name": "D. Funny Game",
    "statement": "Vanya has a graph with n vertices (numbered from 1 to n) and an array a\r\nof n integers; initially, there are no edges in the graph. Vanya got\r\nbored, and to have fun, he decided to perform n - 1 operations.Operation\r\nnumber x (operations are numbered in order starting from 1) is as\r\nfollows: Choose 2 different numbers 1\r\nleq u,v\r\nleq n, such that |a_u - a_v| is divisible by x. Add an undirected edge\r\nbetween vertices u and v to the graph. Help Vanya get a connected^{\r\ntext{ }} graph using the n - 1 operations, or determine that it is\r\nimpossible.^{\r\ntext{ }}A graph is called connected if it is possible to reach any\r\nvertex from any other by moving along the edges.\r\n",
    "solutions": [
        "/** *    author:  tourist *    created: 18.07.2024 23:42:16**/#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#ifdef LOCAL#include \"algo/debug.h\"#else#define debug(...) 42#endif\u00a0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n;    cin >> n;    vector<int> a(n);    for (int i = 0; i < n; i++) {      cin >> a[i];    }    vector<bool> alive(n, true);    vector<pair<int, int>> ops(n - 1);    for (int x = n - 1; x >= 1; x--) {      vector<int> who(x, -1);      for (int i = 0; i < n; i++) {        if (!alive[i]) {          continue;        }        int t = a[i] % x;        if (who[t] == -1) {          who[t] = i;        } else {          ops[x - 1] = {i, who[t]};          alive[i] = false;          break;        }      }    }    cout << \"YES\" << '\\n';    for (auto& [u, v] : ops) {      cout << u + 1 << \" \" << v + 1 << '\\n';    }  }  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dsu",
        "graphs",
        "greedy",
        "math",
        "number theory",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\D. Funny Game.json"
}