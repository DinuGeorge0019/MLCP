{
    "link": "https://codeforces.com//contest/1428/problem/G2",
    "problemId": "762870",
    "problem_idx": "G2",
    "shortId": "1428G2",
    "contest_number": "1428",
    "problem_submissions": {
        "H": [
            95798388,
            96079889,
            95822989,
            95819273
        ],
        "G2": [
            95777265,
            95779066,
            95783656,
            95782002,
            95792200,
            95787701,
            95792987,
            95787809,
            95792595,
            95788941,
            95788283,
            95789699,
            95792016,
            95786243,
            95795577,
            95795657,
            95796576,
            95798040,
            95805912,
            95794416
        ],
        "G1": [
            95777192,
            95778996,
            95783550,
            95782076,
            95787327,
            95787607,
            95787264,
            95787896,
            95792632,
            95789001,
            95788384,
            95789621,
            95791835,
            95786301,
            95795432,
            95795591,
            95796478,
            95795620,
            95794276,
            95794356
        ],
        "F": [
            95765157,
            95765965,
            95771166,
            95767388,
            95768274,
            95768695,
            95770215,
            95759208,
            95832501,
            95832498,
            95832480,
            95831607,
            95831604,
            95831342,
            95763101,
            95777757,
            95779436,
            95770353,
            95771012,
            95772923,
            95779700,
            95776557,
            95778129,
            95776549,
            95775700,
            95779883
        ],
        "E": [
            95758700,
            95760055,
            95763026,
            95762658,
            95754707,
            95762381,
            95764564,
            95752105,
            95754040,
            95762344,
            95751508,
            95766331,
            95750653,
            95764708,
            95767437,
            95759986,
            95764850,
            95764733,
            95758532,
            95759950
        ],
        "D": [
            95754864,
            95756381,
            95758710,
            95758367,
            95764528,
            95758021,
            95759449,
            95765541,
            95774991,
            95758395,
            95775675,
            95762065,
            95777703,
            95760640,
            95762966,
            95770799,
            95762173,
            95759561,
            95760180,
            95767247
        ],
        "B": [
            95745661,
            95741583,
            95746087,
            95741923,
            95743557,
            95741471,
            95742126,
            95742079,
            95743874,
            95742788,
            95744560,
            95742620,
            95745128,
            95748044,
            95745202,
            95746759,
            95741532,
            95741702,
            95742488,
            95749798
        ],
        "C": [
            95742981,
            95744852,
            95748437,
            95744808,
            95746831,
            95743810,
            95745097,
            95745356,
            95741031,
            95745159,
            95747546,
            95747612,
            95742323,
            95747442,
            95747895,
            95749106,
            95744992,
            95747455,
            95745170,
            95751867
        ],
        "A": [
            95740482,
            95739860,
            95740501,
            95739845,
            95741896,
            95739795,
            95739865,
            95739838,
            95739950,
            95739997,
            95739893,
            95739847,
            95740138,
            95852510,
            95844045,
            95839237,
            95838793,
            95838769,
            95838754,
            95838446,
            95824867,
            95812004,
            95742639,
            95740471,
            95741183,
            95739807,
            95739826,
            95740061,
            95740497
        ]
    },
    "name": "G2. Lucky Numbers  Hard Version ",
    "statement": "Zookeeper has been teaching his q sheep how to write and how to add. The\r\ni-th sheep has to write exactly k with the sum n_i.Strangely, sheep have\r\nsuperstitions about digits and believe that the digits 3, 6, and 9 are\r\nlucky. To them, the fortune of a number depends on the decimal\r\nrepresentation of the number; the fortune of a number is equal to the\r\nsum of fortunes of its digits, and the fortune of a digit depends on its\r\nvalue and position and can be described by the following table. For\r\nexample, the number 319 has fortune F_{2} + 3F_{0}. Each sheep wants to\r\nmaximize the among all its k written integers. Can you help them?\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int vax=9;\nconst ll inf=1e18;\nconst int d=6;\nconst int m=1000*1000;\n\nint k;\nll fort[vax];\n\nll dp[vax][nax];\n\nll pom[nax];\n\ndeque<int> kol[3];\n\nint przej(int v)\n{\n\tif (v<=(k-1)*9)\n\t\treturn (v/3);\n\tif (v%3)\n\t\treturn (k-1)*3;\n\treturn v/3;\n}\n\nvoid przejscia(int v)\n{\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tif (!(i%10))\n\t\t\tpom[i]=dp[v+1][i/10];\n\t\telse\n\t\t\tpom[i]=-inf;\n\t}\n\t//~ for (int i=0; i<m; i++)\n\t//~ {\n\t\t//~ dp[v][i]=-inf;\n\t\t//~ for (int j=i-k*9; j<=i; j++)\n\t\t\t//~ if (j>=0)\n\t\t\t\t//~ dp[v][i]=max(dp[v][i], pom[j]+przej(i-j)*fort[v]);\n\t//~ }\n\t//~ debug() << v << \" \" << range(dp[v], dp[v]+60) << \" \" << imie(pom[30]) << imie(przej(27));\n\tfor (int i=0; i<3; i++)\n\t\tkol[i].clear();\n\tll f=fort[v];\n\tconst int lim=(k-1)*9;\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tint p=i%3;\n\t\tif (!kol[p].empty() && kol[p].front()<i-lim)\n\t\t\tkol[p].pop_front();\n\t\twhile(!kol[p].empty() && pom[i]-(i/3)*f>=pom[kol[p].back()]-(kol[p].back()/3)*f)\n\t\t\tkol[p].pop_back();\n\t\tkol[p].push_back(i);\n\t\tdp[v][i]=-inf;\n\t\tfor (int j=0; j<3; j++)\n\t\t\tif (!kol[j].empty())\n\t\t\t\tdp[v][i]=max(dp[v][i], pom[kol[j].front()]+przej(i-kol[j].front())*f);\n\t\tfor (int j=i-k*9; j<=i-lim; j++)\n\t\t\tif (j>=0)\n\t\t\t\tdp[v][i]=max(dp[v][i], pom[j]+przej(i-j)*f);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &k);\n\tfor (int i=0; i<d; i++)\n\t\tscanf(\"%lld\", &fort[i]);\n\tif (k>1)\n\t{\n\t\tfor (int i=0; i<=d; i++)\n\t\t\tfor (int j=0; j<m; j++)\n\t\t\t\tdp[i][j]=-inf;\n\t\tdp[d][0]=0;\n\t\tfor (int h=d-1; h>=0; h--)\n\t\t\tprzejscia(h);\n\t}\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (k==1)\n\t\t{\n\t\t\tll w=0;\n\t\t\tfor (int i=0; i<d; i++)\n\t\t\t{\n\t\t\t\tint p=x%10;\n\t\t\t\tx/=10;\n\t\t\t\tif (!(p%3))\n\t\t\t\t\tw+=fort[i]*(p/3);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", w);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%lld\\n\", dp[0][x]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G2. Lucky Numbers  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/83771",
    "editorial": "Suppose in our final\nsolution, there is a certain position (ones, tens...) that has two\ndigits which are not , , , or . Let these two digits are and . If , we\ncan replace these two digits with , and . Otherwise, we can replace\nthese two digits with and . By doing this, our solution is still valid\nas the sum remains the same, and the total fortune will not decrease\nsince and are not , or .As such, in the optimal solution, there should\nbe at most one number that consists of digits that are not , , or .\nLetâs call this number that has other digits .Easy VersionSince thereâs\nonly one query, we can try all possibilities of . The question reduces\nto finding the maximum sum of fortune among numbers containing the\ndigits , , and that sum up to exactly . We can model this as a 0-1\nknapsack problem, where the knapsack capacity is .For the ones position,\nthe value (fortune) can be increased by for a weight of a total of\ntimes, so we can create objects of weight and value . For tens itâs for\na weight of , and so on. Since there are many duplicate objects, we can\ngroup these duplicate objects in powers of . For example, objects can be\ngrouped into groups of , , , , .This runs in where is the number of\ndigits (6 in this case) Hard VersionIn the hard version, we are not able\nto search all possibilities for the last number as there are many\nqueries.Using the 0-1 knapsack with duplicates, we have computed the dp\ntable for the first numbers. The rest is incorporating the last number\ninto the dp table. We can do this by considering each digit separately.\nThen, we can update the dp table by considering all possible transitions\nfor all digits from to .\n",
    "hint": [
        "Hint 1 0 is a lucky number as well.",
        "Hint 2 There is at most one number whose digits is not entirely 0, 3, 6, 9.",
        "Hint 3 Knapsack.",
        "Hint 4 Group same items."
    ]
}