{
    "link": "https://codeforces.com//contest/1864/problem/G",
    "problemId": "2181270",
    "problem_idx": "G",
    "shortId": "1864G",
    "contest_number": "1864",
    "problem_submissions": {
        "I": [
            220596748,
            220625703,
            220625365,
            220625093
        ],
        "H": [
            220568821,
            220567695,
            220569504,
            220765807,
            220735033,
            220733694,
            220582422,
            220590968,
            220584872,
            220585832,
            220586273,
            220588653,
            220869529,
            220592706,
            220587781,
            220596085,
            222139412,
            220596294
        ],
        "G": [
            220562227,
            220575493,
            220588511,
            220576272,
            220574639,
            220576772,
            220595506,
            220568659,
            220611309,
            221223033,
            220575904,
            220585515,
            220590419,
            220591092,
            220590354,
            220590686
        ],
        "F": [
            220551620,
            220555802,
            220557675,
            220718976,
            220558576,
            220553574,
            220558951,
            220567707,
            220555900,
            220612295,
            220564492,
            220564273,
            220565836,
            220560759,
            220571802,
            220564441,
            220571627,
            220556155,
            220556855,
            220560337,
            220568919,
            220567748
        ],
        "E": [
            220545674,
            220547229,
            220549551,
            220553761,
            220544098,
            220550014,
            220550285,
            220550294,
            220555536,
            220557391,
            220559164,
            220553118,
            220556990,
            220555427,
            220553548,
            220549618,
            220563369,
            220552727,
            220558630,
            220553863
        ],
        "D": [
            220537006,
            220537255,
            220535722,
            220536129,
            220534069,
            220542850,
            220539341,
            220538198,
            220541287,
            220542463,
            220545447,
            220548373,
            220544205,
            220540271,
            220536187,
            220541552,
            220541368,
            220545083,
            220544975
        ],
        "C": [
            220533606,
            220528455,
            220528101,
            220528155,
            220527489,
            220537748,
            220525134,
            220530359,
            220532079,
            220533694,
            220541070,
            220542060,
            220535618,
            220533106,
            220530771,
            220535184,
            220536493,
            220534865,
            220537384
        ],
        "B": [
            220524699,
            220524727,
            220525716,
            220524082,
            220524572,
            220524039,
            220522756,
            220522640,
            220528173,
            220525137,
            220528062,
            220531552,
            220524275,
            220526451,
            220524531,
            220529349,
            220526226,
            220525961,
            220525118
        ],
        "A": [
            220521618,
            220521580,
            220521747,
            220521485,
            220521753,
            220521570,
            220521442,
            220521465,
            220524365,
            220521707,
            220524695,
            220522808,
            220521703,
            220522789,
            220521679,
            220521789,
            220521663,
            220522116,
            220521966
        ]
    },
    "name": "G. Magic Square",
    "statement": "Aquamoon has a Rubik\u2019s Square which can be seen as an n\r\ntimes n matrix, the elements of the matrix constitute a permutation of\r\nnumbers 1,\r\nldots, n^2.Aquamoon can perform two operations on the matrix: Row shift,\r\ni.e. shift an entire row of the matrix several positions (at least 1 and\r\nat most n-1) to the right. The elements that come out of the right\r\nborder of the matrix are moved to the beginning of the row. For example,\r\nshifting a row\r\nbegin{pmatrix} a & b & c\r\nend{pmatrix} by 2 positions would result in\r\nbegin{pmatrix} b & c & a\r\nend{pmatrix}; Column shift, i.e. shift an entire column of the matrix\r\nseveral positions (at least 1 and at most n-1) downwards. The elements\r\nthat come out of the lower border of the matrix are moved to the\r\nbeginning of the column. For example, shifting a column\r\nbegin{pmatrix} a\r\nb\r\nc\r\nend{pmatrix} by 2 positions would result in\r\nbegin{pmatrix} b\r\nc\r\na\r\nend{pmatrix}. The rows are numbered from 1 to n from top to bottom, the\r\ncolumns are numbered from 1 to n from left to right. The cell at the\r\nintersection of the x-th row and the y-th column is denoted as (x,\r\ny).Aquamoon can perform several (possibly, zero) operations, but she has\r\nto obey the following restrictions: each row and each column can be\r\nshifted at most once; each integer of the matrix can be moved at most\r\ntwice; the offsets of any two integers moved twice cannot be the same.\r\nFormally, if integers a and b have been moved twice, assuming a has\r\nchanged its position from (x_1,y_1) to (x_2,y_2), and b has changed its\r\nposition from (x_3,y_3) to (x_4,y_4), then x_2-x_1\r\nnot\r\nequiv x_4-x_3\r\npmod{n} or y_2-y_1\r\nnot\r\nequiv y_4-y_3\r\npmod{n}.Aquamoon wonders in how many ways she can transform the Rubik\u2019s\r\nSquare from the given initial state to a given target state. Two ways\r\nare considered different if the sequences of applied operations are\r\ndifferent. Since the answer can be very large, print the result modulo\r\n998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst int vax=nax*nax;\nconst ll mod=998244353;\n\nint n;\nint a[nax][nax];\nint b[nax][nax];\n\npii ga[vax];\npii gb[vax];\n\nvoid ans(ll v)\n{\n\tv%=mod;\n\tv+=mod;\n\tv%=mod;\n\tprintf(\"%lld\\n\", v);\n}\n\nint juzr[nax];\nint juzk[nax];\n\nll wyn;\nll sil[nax];\n\nint czyr(int v)\n{\n\tint kto=a[v][0];\n\tint chce=gb[kto].second;\n\tif (!chce)\n\t\treturn 0;\n\tfor (int i=1; i<n; i++)\n\t\tif (gb[a[v][i]].second!=(i+chce)%n)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint czyk(int v)\n{\n\tint kto=a[0][v];\n\tint chce=gb[kto].first;\n\tif (!chce)\n\t\treturn 0;\n\tfor (int i=1; i<n; i++)\n\t\tif (gb[a[i][v]].first!=(i+chce)%n)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint pom[nax];\n\nvoid szift_row(int v)\n{\n\tint kto=a[v][0];\n\tint ile=gb[kto].second;\n\tfor (int i=0; i<n; i++)\n\t\tpom[(i+ile)%n]=a[v][i];\n\tfor (int i=0; i<n; i++)\n\t\ta[v][i]=pom[i];\n}\n\nvoid szift_kol(int v)\n{\n\tint kto=a[0][v];\n\tint ile=gb[kto].first;\n\tfor (int i=0; i<n; i++)\n\t\tpom[(i+ile)%n]=a[i][v];\n\tfor (int i=0; i<n; i++)\n\t\ta[i][v]=pom[i];\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\ta[i][j]--;\n\t\t\tga[a[i][j]]={i, j};\n\t\t}\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tb[i][j]--;\n\t\t\tgb[b[i][j]]={i, j};\n\t\t}\n\t}\n\t{\n\t\tvector<pii> ruchy;\n\t\tfor (int i=0; i<n*n; i++)\n\t\t{\n\t\t\tpii r={ga[i].first-gb[i].first, ga[i].second-gb[i].second};\n\t\t\tr.first+=n;\n\t\t\tr.second+=n;\n\t\t\tr.first%=n;\n\t\t\tr.second%=n;\n\t\t\tif (r.first && r.second)\n\t\t\t\truchy.push_back(r);\n\t\t}\n\t\tsort(ruchy.begin(), ruchy.end());\n\t\tfor (int i=1; i<(int)ruchy.size(); i++)\n\t\t{\n\t\t\tif (ruchy[i]==ruchy[i-1])\n\t\t\t{\n\t\t\t\tans(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<n; i++)\n\t\tjuzr[i]=juzk[i]=0;\n\twyn=1;\n\twhile(1)\n\t{\n\t\tvi rzo, kol;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tif (!juzr[i] && czyr(i))\n\t\t\t\trzo.push_back(i);\n\t\tfor (int i=0; i<n && rzo.empty(); i++)\n\t\t\tif (!juzk[i] && czyk(i))\n\t\t\t\tkol.push_back(i);\n\t\tif (rzo.empty() && kol.empty())\n\t\t\tbreak;\n\t\tdebug() << imie(rzo) << imie(kol);\n\t\tif (!rzo.empty())\n\t\t{\n\t\t\twyn=(wyn*sil[rzo.size()])%mod;\n\t\t\tfor (int i : rzo)\n\t\t\t{\n\t\t\t\tszift_row(i);\n\t\t\t\tjuzr[i]=1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twyn=(wyn*sil[kol.size()])%mod;\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tjuzk[i]=1;\n\t\t\t\tszift_kol(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tif (a[i][j]!=b[i][j])\n\t\t\t{\n\t\t\t\tans(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tans(wyn);\n}\n\nint main()\n{\n\tsil[0]=1;\n\tfor (int i=1; i<nax; i++)\n\t\tsil[i]=sil[i-1]*i%mod;\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Magic Square.json",
    "editorial_link": "https://codeforces.com//blog/entry/119772",
    "editorial": "TutorialWe can use the following method to solve this problem:For each\r\nrow and each column, check if it is available.If there are both\r\navailable rows and available columns, there is no solution.If no rows or\r\ncolumns are available, the matrix is already equal to the target one, or\r\nthere is no solution.If there are only available rows or available\r\ncolumns, their order doesn\u00e2\u0080\u0099t matter, so if there choices, the answer\r\nshould be multiplied by . Apply all available operations and check\r\nagain.Total complexity: or if maintaining row/column offsets in each\r\nrow/column.\r\n"
}