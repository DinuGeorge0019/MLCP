{
    "link": "https://codeforces.com//contest/1842/problem/G",
    "problemId": "1978971",
    "problem_idx": "G",
    "shortId": "1842G",
    "contest_number": "1842",
    "problem_submissions": {
        "H": [
            210909272,
            210915649,
            210920105,
            210920155,
            210922877,
            210917228,
            210922837,
            210930795,
            210943236,
            210937664,
            210940497,
            210923705,
            210946319,
            210934622,
            210945105,
            210899880,
            210946698,
            210939780,
            210945932
        ],
        "F": [
            210904139,
            210906080,
            210912565,
            210912372,
            210898025,
            210899929,
            210907320,
            210916813,
            210914105,
            210920055,
            210921458,
            210913885,
            210930158,
            210926455,
            210915591,
            210926376,
            210920616,
            210915480,
            210926627
        ],
        "E": [
            210900474,
            210894310,
            210898608,
            210904065,
            210915135,
            210928274,
            210898671,
            210908613,
            210902774,
            210908660,
            210907798,
            210940198,
            210905531,
            210907005,
            210910569,
            210945488,
            210908738,
            210905745,
            210907496
        ],
        "D": [
            210896488,
            210888362,
            210895704,
            210886302,
            210889254,
            210887549,
            210895428,
            210893212,
            210903157,
            210896694,
            210890657,
            210891182,
            210892762,
            210896576,
            210915222,
            210891979,
            210892349,
            210897573
        ],
        "G": [
            210891898,
            210900879,
            210908657,
            210918356,
            210923373,
            210939093,
            210921066,
            210918175,
            210911260,
            210924814,
            210932494,
            210913130,
            210941401,
            210927457,
            210933616,
            210927314,
            210931000,
            210936010
        ],
        "C": [
            210877958,
            210881836,
            210878997,
            210877037,
            210879744,
            210878770,
            210882382,
            210884108,
            210887371,
            210884900,
            210892630,
            210896219,
            210883482,
            210884636,
            210910637,
            210882729,
            210933971,
            210885406
        ],
        "A": [
            210875095,
            210875812,
            210874424,
            210888796,
            210874470,
            210876122,
            210874664,
            210877287,
            210875659,
            210882217,
            210874539,
            210875197,
            210874805,
            210874426,
            210902716,
            210874934,
            210945780,
            210885821
        ],
        "B": [
            210874375,
            210878347,
            210876059,
            210890061,
            210876166,
            210875757,
            210877955,
            210879984,
            210877325,
            210880724,
            210876899,
            210877184,
            210877441,
            210885377,
            210916237,
            210877578,
            210940672,
            210885692
        ],
        "I": [
            210953525,
            211184344,
            211107115
        ]
    },
    "name": "G. Tenzing and Random Operations",
    "statement": "Tenzing has an array a of length n and an integer v.Tenzing will perform\r\nthe following operation m times: Choose an integer i such that 1\r\nleq i\r\nleq n uniformly at random. For all j such that i\r\nleq j\r\nleq n, set a_j := a_j + v. Tenzing wants to know the expected value of\r\nprod_{i=1}^n a_i after performing the m operations, modulo\r\n10^9+7.Formally, let M = 10^9+7. It can be shown that the answer can be\r\nexpressed as an irreducible fraction\r\nfrac{p}{q}, where p and q are integers and q\r\nnot\r\nequiv 0\r\npmod{M}. Output the integer equal to p\r\ncdot q^{-1}\r\nbmod M. In other words, output the integer x that 0\r\nle x < M and x\r\ncdot q\r\nequiv p\r\npmod{M}.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.06.2023 10:22:44       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, v;\n  cin >> n >> m >> v;\n  vector<Mint> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<Mint> f(n + 1, 0);\n  f[0] = 1;\n  for (int i = 0; i < n; i++) {\n    vector<Mint> nf(n + 1, 0);\n    for (int j = 0; j <= min(m, i); j++) {\n      nf[j] += f[j] * a[i];\n      nf[j] += f[j] * v * j;\n      nf[j + 1] += f[j] * v * (m - j) * (i + 1);\n    }\n    swap(f, nf);\n  }\n  Mint ans = 0;\n  for (int j = 0; j <= min(m, n); j++) {\n    ans += f[j] * power(Mint(n), m - j);\n  }\n  ans /= power(Mint(n), m);\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Tenzing and Random Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/117606",
    "editorial": "TutorialBefore starting to solve this problem, let\u00e2\u0080\u0099s establish two basic\r\nproperties: For two completely independent random variables , we have .\r\nFor , we have . Returning to this problem, let be a random variable: its\r\nvalue is when the -th operation sets to , otherwise it is .Then note\r\nthat the answer is the expected value of .Applying the second property\r\nabove to split the product, each term is a product of some and\r\n.Specifically, each term has factors, and for each , either is one of\r\nits factors, or some is one of its factors.Let\u00e2\u0080\u0099s investigate the\r\nexpectation of a specific term. Note that if , then , that is, if is\r\nthen the whole product is , and if is then must be .Therefore, for all\r\nthe factors in a term, we categorize them by the first index, i.e. we\r\ngroup all into category . For each category, we only need to focus on\r\nthe first variable. If it\u00e2\u0080\u0099s , then the remaining variables take value ,\r\notherwise the result is . Note that the variables in different\r\ncategories are completely independent (because their values are\r\ndetermined by operations in two different rounds), so the expected\r\nproduct of the variables in two categories can be split into the product\r\nof the expected products of the variables within each category.Our goal\r\nis to compute the expected sum of all the terms, which can be nicely\r\ncombined with DP:Let be the value that we have determined the first\r\nfactors of each term and there are categories that have appeared at\r\nleast once (if adding the variable at position brings contribution ,\r\notherwise the contribution is ). The transition can be easily calculated\r\nwith , depending on whether to append or to each term, and if it\u00e2\u0080\u0099s the\r\nlatter, we discuss whether the variable belongs to one of the categories\r\nthat have appeared or the other categories. The time complexity is .\r\n"
}