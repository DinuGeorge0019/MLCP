{
    "link": "https://codeforces.com//contest/768/problem/E",
    "problemId": "94876",
    "problem_idx": "E",
    "shortId": "768E",
    "contest_number": "768",
    "problem_submissions": {
        "F": [
            24840431,
            24838480,
            24834630,
            24841891,
            24838353,
            24840717,
            24837763,
            24842282,
            24838721,
            24833873,
            24842120,
            24844145,
            24842096,
            24840981,
            24845191,
            24842247,
            24840284,
            24847109,
            24843919
        ],
        "E": [
            24834774,
            24835983,
            24832451,
            24837828,
            24833805,
            24837182,
            24833920,
            24836646,
            24835033,
            24838913,
            24837846,
            24833547,
            24837106,
            24837362,
            24839266,
            24837276,
            24838051,
            24835972,
            24836022
        ],
        "D": [
            24832202,
            24833876,
            24835915,
            24835246,
            24832704,
            24834168,
            24832774,
            24838949,
            24833061,
            24836615,
            24839525,
            24834336,
            24833791,
            24835394,
            24835786,
            24835146,
            24835911,
            24837569,
            24837832
        ],
        "C": [
            24830784,
            24831935,
            24846692,
            24833492,
            24831356,
            24831859,
            24830894,
            24833465,
            24831521,
            24835038,
            24835013,
            24830101,
            24832003,
            24831977,
            24833696,
            24832023,
            24832927,
            24833660,
            24834203
        ],
        "B": [
            24828716,
            24830642,
            24828869,
            24830153,
            24830045,
            24829484,
            24830872,
            24829643,
            24837759,
            24831145,
            24828453,
            24830132,
            24829454,
            24830410,
            24829830,
            24830884,
            24831500,
            24831921
        ],
        "A": [
            24825770,
            24826388,
            24825799,
            24826247,
            24825814,
            24825782,
            24825775,
            24825815,
            24827152,
            24827361,
            24826212,
            24825822,
            24826382,
            24826002,
            24825750,
            24826264,
            24826016,
            24825780,
            24828293
        ],
        "G": [
            24850234,
            25339793,
            24854056,
            24855563,
            24855744
        ]
    },
    "name": "E. Game of Stones",
    "statement": "Sam has been teaching Jon the to sharpen his mind and help him devise a\r\nstrategy to fight the white walkers. The rules of this game are quite\r\nsimple: The game starts with piles of stones indexed from to . The -th\r\npile contains stones. The players make their moves alternatively. A move\r\nis considered as removal of some number of stones from a pile. Removal\r\nof stones does not count as a move. The player who is unable to make a\r\nmove loses.Now Jon believes that he is ready for battle, but Sam does\r\nnot think so. To prove his argument, Sam suggested that they play a\r\nmodified version of the game.In this modified version, no move can be\r\nmade more than once on a pile. For example, if stones are removed from a\r\npile, stones cannot be removed from that pile again.Sam sets up the game\r\nand makes the first move. Jon believes that Sam is just trying to\r\nprevent him from going to battle. Jon wants to know if he can win if\r\nboth play optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nconst ld TAU=2*acos(-1);\nconst ld eps=1e-7;\nconst int inf=1e9+99;\nconst ll linf=1e18+88;\n\nunordered_map<ull,int> dp[70];\nint nim_val(int x,ull m=0) {\n\tif(!x) return 0;\n\t++x;\n\t// cerr<<\"m first \"<<m<<endl;\n\tm &= ~((m>>x)<<x);\n\t// cerr<<\"m after \"<<m<<endl;\n\t--x;\n\tif(dp[x].count(m)) return dp[x][m];\n\tint &ans=dp[x][m];\n\n\tvector<int> recs;\n\tfor(int i=1;i<=x;i++) {\n\t\tif((m>>i)&1) continue;\n\t\trecs.pb(nim_val(x-i, m|(1<<i)));\n\t}\n\tsort(recs.begin(),recs.end());\n\trecs.resize(unique(recs.begin(),recs.end())-recs.begin());\n\trecs.pb(-1);\n\tfor(int y=0;;y++) {\n\t\tif(recs[y]!=y) return ans=y;\n\t}\n\tassert(0);\n}\n\nint32_t main() {\n\tint n; scanf(\"%d\",&n);\n\tint Z=0;\n\tfor(;n--;) {\n\t\tint s; scanf(\"%d\",&s);\n\t\tint y=nim_val(s);\n\t\t// cerr<<s<<\": \"<<y<<endl;\n\t\tZ^=y;\n\t}\n\tcout<<(Z ? \"NO\":\"YES\")<<endl;\n\t// cerr<<dp.size()<<endl;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "games"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Game of Stones.json",
    "editorial_link": "https://codeforces.com//blog/entry/50550",
    "editorial": "Set and Editorial by: AakashHanda This problem can be solved using DP\r\nwith Bitmasks to calculate the grundy value of piles. Let us have a\r\n2-dimensional dp table, , where the first dimension is for number of\r\nstones in the pile and second dimension is for bitmask. The bitmask has\r\n-th bit set if we are allowed to remove stones from the pile. Now, to\r\ncalculate we need to iterate over all possible moves allowed and find\r\nthe mex. Code\r\n",
    "hint": []
}