{
    "link": "https://codeforces.com//contest/868/problem/E",
    "problemId": "126220",
    "problem_idx": "E",
    "shortId": "868E",
    "contest_number": "868",
    "problem_submissions": {
        "E": [
            31023051,
            31024523,
            31024148,
            31025167,
            31018209,
            31025864,
            31026369,
            31028260,
            31026372,
            31044397,
            31026066,
            31027557,
            31023308,
            31023861,
            31019541,
            31162068,
            31021787
        ],
        "F": [
            31020755,
            31020638,
            33743391,
            31021116,
            31022470,
            31023238,
            31022737,
            31023926,
            31023102,
            31028638,
            31028134,
            31020706,
            31027648,
            31019840,
            31023078,
            31023660,
            31027919
        ],
        "D": [
            31018151,
            31017707,
            31016713,
            31018303,
            31025757,
            31018243,
            31018489,
            31024010,
            31018691,
            31020147,
            31017621,
            31017612,
            31016732,
            31017515,
            31015826,
            31017997,
            31021417
        ],
        "C": [
            31014273,
            31014407,
            31012209,
            31014307,
            31013815,
            31013945,
            31015314,
            31013335,
            31014790,
            31016275,
            31030598,
            31013440,
            31030706,
            31066551,
            31014026,
            31012823,
            31014457,
            31014258,
            31016540
        ],
        "B": [
            31013104,
            31012812,
            31013438,
            31013042,
            31012539,
            31026919,
            31016195,
            31015461,
            31013166,
            31014218,
            31022627,
            31012140,
            31012861,
            31016249,
            31011794,
            31012575,
            31013032,
            31014544
        ],
        "A": [
            31010698,
            31010763,
            31010903,
            31010896,
            31010747,
            31010833,
            31010957,
            31012028,
            31010858,
            31021512,
            31010696,
            31010727,
            31012054,
            31010635,
            31010757,
            31011798,
            31010661
        ],
        "G": [
            31179602
        ]
    },
    "name": "E. Policeman and a Tree",
    "statement": "You are given a tree (a connected non-oriented graph without cycles)\r\nwith vertices numbered from to , and the length of the -th edge is . In\r\nthe vertex there is a policeman, in the vertices () criminals are\r\nlocated.The policeman can walk along the edges with speed , the\r\ncriminals can move with arbitrary large speed. If a criminal at some\r\nmoment is at the same point as the policeman, he instantly gets caught\r\nby the policeman. Determine the time needed for the policeman to catch\r\nall criminals, assuming everybody behaves optimally (i.e. the criminals\r\nmaximize that time, the policeman minimizes that time). Everybody knows\r\npositions of everybody else at any moment of time.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint d[55][55];\nint a[55];\nint c[55][55];\n\nint ss[55], ee[55];\n\nint p[55], q[55], tt[55];\n\nint f(int x) {\n\treturn x == p[x] ? x : p[x] = f(p[x]);\n}\n\nint main() {\n\tint L, R, M, S;\n\tint i, j, k, l, n, m, t;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) for (j = 1; j <= n; j++) if (i != j) d[i][j] = 1e9;\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &j, &k, &l);\n\t\tss[i] = j;\n\t\tee[i] = k;\n\t\td[j][k] = d[k][j] = l;\n\t\ta[j]++;\n\t\ta[k]++;\n\t}\n\tscanf(\"%d%d\", &S, &m);\n\tfor (i = 1; i <= n; i++) p[i] = i;\n\tfor (i = 1; i < n; i++) if (ss[i] != S && ee[i] != S) p[f(ss[i])] = f(ee[i]);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &j);\n\t\tq[f(j)]++;\n\t}\n\tfor (k = 1; k <= n; k++) for (i = 1; i <= n; i++) for (j = 1; j <= n; j++) if (d[i][k] + d[k][j] < d[i][j]) d[i][j] = d[i][k] + d[k][j];\n\tfor (i = 1; i <= m; i++) for (j = 1; j <= n; j++) if (a[j] == 1) {\n\t\tL = 0;\n\t\tR = 1e9;\n\t\twhile (L < R) {\n\t\t\tM = L + R + 1 >> 1;\n\t\t\tt = 0;\n\t\t\tfor (k = 1; k <= n; k++) if (a[k] == 1) {\n\t\t\t\tfor (l = 0; l < i && c[l][k] + d[j][k] < M; l++);\n\t\t\t\tt += i - l;\n\t\t\t}\n\t\t\tif (t < i) R = M - 1;\n\t\t\telse L = M;\n\t\t}\n\t\tc[i][j] = L;\n\t}\n\tL = 0;\n\tR = 1e9;\n\twhile (L < R) {\n\t\tM = L + R + 1 >> 1;\n\t\tfor (k = 1; k <= n; k++) tt[k] = 0;\n\t\tfor (k = 1; k <= n; k++) if (a[k] == 1) {\n\t\t\tfor (l = 0; l < m && c[l][k] + d[S][k] < M; l++);\n\t\t\ttt[f(k)] += m - l;\n\t\t}\n\t\tfor (k = 1; k <= n; k++) if (tt[k] < q[k]) break;\n\t\tif (k > n) L = M;\n\t\telse R = M - 1;\n\t}\n\tprintf(\"%d\\n\", L);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Policeman and a Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/55046",
    "editorial": "Suppose that the policeman is moving from to via the tree edge. The\r\ncriminals can now assume any positions in two halves of the tree (but\r\ncannot travel from one half to another). Let be the resulting time to\r\ncatch the criminals if the policeman have just started to travel along a\r\n(directed) edge , there are criminals in total, and of them are in the\r\nhalf tree \"in front\" of the policeman.If the edge leads into a leaf of\r\nthe tree, then the policeman catches everyone in this leaf, and his next\r\nstep is to go back using the same edge. Otherwise, the criminals must\r\nhave distributed optimally in the subtrees starting with edges . The\r\npoliceman cannot win within time if there is a distribution with such\r\nthat for every . The optimal value of can be found with binary search:\r\nfor a particular find the smallest such that , and check if . If this is\r\nthe case, the criminals can distribute so that it will take time to\r\ncatch them.The total complexity of this solution is , since we have DP\r\nstates, with each state having transitions, and the last factor\r\ncorresponding to binary search on the answer (assuming the answer is at\r\nmost ).\r\n",
    "hint": []
}