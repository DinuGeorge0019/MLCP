{
    "link": "https://codeforces.com//contest/1654/problem/H",
    "problemId": "1337005",
    "problem_idx": "H",
    "shortId": "1654H",
    "contest_number": "1654",
    "problem_submissions": {
        "G": [
            150299206,
            150291434,
            150262682,
            150264693,
            150279932,
            150262802,
            150264575,
            150265515,
            150270995,
            150269889,
            150268570,
            150658744,
            150262050,
            150410744
        ],
        "F": [
            150251411,
            150252834,
            150256351,
            150258591,
            150257352,
            150258765,
            150260950,
            150260548,
            150253390,
            155820292,
            150253676,
            150260302,
            150259236,
            150258476,
            150253068,
            150258272,
            150260151,
            150258857,
            150253870
        ],
        "E": [
            150249388,
            150250832,
            150247329,
            150252856,
            150255337,
            150250196,
            150255012,
            150258473,
            150245581,
            150250984,
            150250253,
            150246690,
            150250591,
            150243463,
            150281667,
            150281018,
            150257789,
            150252457,
            150252381,
            150254404,
            150260615
        ],
        "D": [
            150242905,
            150248369,
            150245387,
            150248435,
            150250315,
            150245874,
            150249516,
            150253299,
            150250969,
            150245477,
            150245136,
            150243688,
            150246539,
            150254801,
            150249615,
            150245204,
            150245282,
            150246887,
            150243365
        ],
        "C": [
            150236387,
            150236280,
            150236050,
            150237265,
            150241937,
            150237951,
            150242839,
            150238439,
            150239664,
            150239447,
            150236298,
            150237311,
            150240477,
            150246874,
            150236567,
            150236644,
            150238032,
            150240021,
            150238619
        ],
        "B": [
            150233906,
            150232250,
            150249236,
            150233827,
            150235226,
            150232832,
            150239572,
            150233210,
            150235633,
            150231291,
            150231026,
            150232476,
            150233263,
            150235368,
            150231705,
            150232694,
            150231566,
            150233122,
            150232190
        ],
        "A": [
            150228234,
            150228426,
            150228045,
            150228869,
            150232031,
            150228616,
            150230908,
            150228192,
            150232849,
            150228032,
            150227955,
            150228792,
            150228208,
            150229654,
            223450681,
            150228295,
            150228644,
            150228162,
            150228813,
            150228169
        ],
        "H": [
            150278254,
            150276173,
            150276315,
            150560549
        ]
    },
    "name": "H. Three Minimums",
    "statement": "Given a list of distinct values, we denote with , , and the three\r\nsmallest values (in increasing order).A permutation p_1, p_2,\r\ndots, p_n is if the following statement holds for all pairs (l,r) with 1\r\nle l < l+2\r\nle r\r\nle n. If\r\n{p_l, p_r\r\n} are (not necessarily in this order) the first and second minimum of\r\np_l, p_{l+1},\r\ndots, p_r then the third minimum of p_l, p_{l+1},\r\ndots, p_r is either p_{l+1} or p_{r-1}. You are given an integer n and a\r\nstring s of length m consisting of characters \"\" and \"\".Count the number\r\nof permutations p_1, p_2,\r\ndots, p_n such that, for all 1\r\nle i\r\nle m, p_i < p_{i+1} if s_i = \"\"; p_i > p_{i+1} if s_i = \"\". As the\r\nresult can be very large, you should print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define vi vector <int>\n#define sz(a) ((int) (a).size())\n#define me(f, x) memset(f, x, sizeof(f))\n#define uint unsigned int \nusing namespace std;\nconst int mod = 998244353, _G = 3, N = (1 << 19), inv2 = (mod + 1) / 2;\n#define add(a, b) (a + b >= mod ? a + b - mod : a + b)\n#define dec(a, b) (a < b ? a - b + mod : a - b)\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint fac[N], ifac[N], inv[N];\nvoid init(int x) {\n\tfac[0] = ifac[0] = inv[1] = 1;\n\tL(i, 2, x) inv[i] = (ll) inv[mod % i] * (mod - mod / i) % mod;\n\tL(i, 1, x) fac[i] = (ll) fac[i - 1] * i % mod, ifac[i] = (ll) ifac[i - 1] * inv[i] % mod;\n}\nint C(int x, int y) {\n\treturn y < 0 || x < y ? 0 : (ll) fac[x] * ifac[y] % mod * ifac[x - y] % mod;\n}\nint rt[N], Lim;\nvoid Pinit(int x) {\n\tfor(Lim = 1; Lim <= x; Lim <<= 1) ;\n\tfor(int i = 1; i < Lim; i <<= 1) {\n\t\tint sG = qpow (_G, (mod - 1) / (i << 1));\n\t\trt[i] = 1;\n\t\tL(j, i + 1, i * 2 - 1) rt[j] = (ll) rt[j - 1] * sG % mod;\n\t}\n}\nstruct poly {\n\tvector<int> a;\n\tint size() { return sz(a); }\n\tint & operator [] (int x) { return a[x]; }\n\tint v(int x) { return x < 0 || x >= sz(a) ? 0 : a[x]; }\n\tvoid clear() { vector<int> ().swap(a); }\n\tvoid rs(int x = 0) { a.resize(x); }\n\tpoly (int n = 0) { rs(n); }\n\tpoly (vector<int> o) { a = o; }\n\tpoly (const poly &o) { a = o.a; }\n\tpoly Rs(int x = 0) { vi res = a; res.resize(x); return res; }\n\tinline void dif() {\n\t\tint n = sz(a);\n\t\tfor (int l = n >> 1; l >= 1; l >>= 1) \n\t\t\tfor(int j = 0; j < n; j += l << 1) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint x = a[j + k], y = a[j + k + l];\n\t\t\t\t\ta[j + k] = add(x, y);\n\t\t\t\t\ta[j + k + l] = (ll) * w * dec(x, y) % mod;\n\t\t\t\t}\n\t}\n\tvoid dit () {\n\t\tint n = sz(a);\n\t\tfor(int i = 2; i <= n; i <<= 1) \n\t\t\tfor(int j = 0, l = (i >> 1); j < n; j += i) \n\t\t\t\tfor(int k = 0, *w = rt + l; k < l; k++, w++) {\n\t\t\t\t\tint pa = a[j + k], pb = (ll) a[j + k + l] * *w % mod;\n\t\t\t\t\ta[j + k] = add(pa, pb), a[j + k + l] = dec(pa, pb);\n\t\t\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tfor(int i = 0, iv = qpow(n); i < n; i++) a[i] = (ll) a[i] * iv % mod;\n\t} \n\tfriend poly operator * (poly aa, poly bb) {\n\t\tif(!sz(aa) || !sz(bb)) return {};\n\t\tint lim, all = sz(aa) + sz(bb) - 1;\n\t\tfor(lim = 1; lim < all; lim <<= 1);\n\t\taa.rs(lim), bb.rs(lim), aa.dif(), bb.dif();\n\t\tL(i, 0, lim - 1) aa[i] = (ll) aa[i] * bb[i] % mod;\n\t\taa.dit(), aa.a.resize(all);\n\t\treturn aa;\n\t}\n\tpoly Inv() {\n\t\tpoly res, f, g;\n\t\tres.rs(1), res[0] = qpow(a[0]);\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = m << 1, f = res, g.rs(pn), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (*this).v(i);\n\t\t\tf.dif(), g.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit();\n\t\t\tfor(int i = 0; i < m; i++) g[i] = 0;\n\t\t\tg.dif();\n\t\t\tfor(int i = 0; i < pn; i++) g[i] = (ll) f[i] * g[i] % mod;\n\t\t\tg.dit(), res.rs(pn);\n\t\t\tfor(int i = m; i < min(pn, sz(a)); i++) res[i] = (mod - g[i]) % mod;\n\t\t} \n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly Shift (int x) {\n\t\tpoly zm (sz(a) + x);\n\t\tL(i, 0, sz(a) - 1) zm[i + x] = a[i];\n\t\treturn zm; \n\t}\n\tfriend poly operator * (poly aa, int bb) {\n\t\tpoly res(sz(aa));\n\t\tL(i, 0, sz(aa) - 1) res[i] = (ll) aa[i] * bb % mod;\n\t\treturn res;\n\t}\n\tfriend poly operator + (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = add(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tfriend poly operator - (poly aa, poly bb) {\n\t\tvector<int> res(max(sz(aa), sz(bb)));\n\t\tL(i, 0, sz(res) - 1) res[i] = dec(aa.v(i), bb.v(i));\n\t\treturn poly(res);\n\t}\n\tpoly & operator += (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator -= (poly o) {\n\t\trs(max(sz(a), sz(o)));\n\t\tL(i, 0, sz(a) - 1) (a[i] += mod - o.v(i)) %= mod;\n\t\treturn (*this);\n\t}\n\tpoly & operator *= (poly o) {\n\t\treturn (*this) = (*this) * o;\n\t}\n\tpoly Integ() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) + 1);\n\t\tL(i, 1, sz(a)) res[i] = (ll) a[i - 1] * inv[i] % mod;\n\t\treturn res;\n\t}\n\tpoly Deriv() {\n\t\tif(!sz(a)) return poly();\n\t\tpoly res(sz(a) - 1); \n\t\tL(i, 1, sz(a) - 1) res[i - 1] = (ll) a[i] * i % mod;\n\t\treturn res;\n\t}\n\tpoly Ln() {\n\t\tpoly g = ((*this).Inv() * (*this).Deriv()).Integ();\n\t\treturn g.rs(sz(a)), g;\n\t}\n\tpoly Exp() {\n\t\tpoly res(1), f; \n\t\tres[0] = 1;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf -= res.Ln(), (f[0] += 1) %= mod, res *= f, res.rs(pn); \n\t\t}\n\t\treturn res.rs(sz(a)), res;\n\t}\n\tpoly pow(int x, int rx = -1) { // x : the power % mod; rx : the power % (mod - 1)\n\t\tif(rx == -1) rx = x;\n\t\tint cnt = 0;\n\t\twhile (a[cnt] == 0 && cnt < sz(a)) cnt += 1;\n\t\t\n\t\tpoly res = (*this);\n\t\tL(i, cnt, sz(a) - 1) res[i - cnt] = res[i];\n\t\tL(i, sz(a) - cnt, sz(a) - 1) res[i] = 0;\n\t\tint c = res[0], w = qpow (res[0]);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * w % mod;\n\t\tres = res.Ln();\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * x % mod;\n\t\tres = res.Exp();\n\t\tc = qpow (c, rx);\n\t\tL(i, 0, sz(res) - 1) res[i] = (ll) res[i] * c % mod;\n\t\t\n\t\tif((ll) cnt * x > sz(a)) L(i, 0, sz(a) - 1) res[i] = 0;\n\t\telse if(cnt) {\n\t\t\tR(i, sz(a) - cnt * x - 1, 0) res[i + cnt * x] = res[i];\n\t\t\tL(i, 0, cnt * x - 1) res[i] = 0; \n\t\t}\n\t\treturn res;\n\t}\n\tpoly sqrt(int rt = 1) {\n\t\tpoly res(1), f; \n\t\tres[0] = rt;\n\t\tfor(int m = 1, pn; m < sz(a); m <<= 1) {\n\t\t\tpn = min(m << 1, sz(a)), f.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) f[i] = (*this).v(i);\n\t\t\tf += res * res, f.rs(pn), res.rs(pn), res = f * res.Inv(), res.rs(pn);\n\t\t\tfor(int i = 0; i < pn; i++) res[i] = (ll) res[i] * inv2 % mod;\n\t\t} \n\t\treturn res;\n\t}\n\tvoid Rev() {\n\t\treverse(a.begin(), a.end());\n\t}\n} ;\n\nint n, m, f[N], g[N], ns;\nchar s[N];\n\nint dp[109][N], pw[N]; \nbool vis[109][N];\n\ninline DP(int l, int r) {\n\tif(r - l == 1) return 1;\n\tif(l > m) return pw[r - l - 2];\n\tif(s[l] == '>' || s[r - 1] == '<') return 0;\n\tif(r - l == 2) return 1;\n\tif(vis[l][r]) return dp[l][r];\n\tvis[l][r] = true;\n\treturn dp[l][r] = (DP(l, r - 1) + DP(l + 1, r)) % mod;\n}\n\nint h[N], tc[N]; \n\nvoid divide(int L, int R) {\n\tif(L == R) \n\t\treturn ;\n\tint mid = (L + R) >> 1;\n\tdivide(L, mid);\n\tpoly F(R - L + 1), G(mid - L + 1); \n\tL(i, 0, R - L) F[i] = tc[i];\n\tL(i, L, mid) G[i - L] = (ll) f[i] * ifac[i - 1] % mod;\n\tF *= G;\n\tL(i, mid + 1, R) (f[i] += (ll) F[i - L] * fac[i - 2] % mod) %= mod;\n\tdivide(mid + 1, R);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> (s + 1);\n\tinit(n << 1 | 1);\n\tPinit(n << 1 | 1);\n\t\n\tf[1] = g[n] = 1;\n\tpw[0] = 1;\n\tL(i, 1, n) pw[i] = (ll) pw[i - 1] * 2 % mod;\n\t\n\tpoly h(n + 1);\n\tL(i, 1, n) h[i] = (ll) pw[max(i - 2, 0)] * ifac[i] % mod; \n\th = h.Exp();\n\tL(i, 0, n) h[i] = (ll) h[i] * fac[i] % mod;\n\t\n\tL(i, 1, n) tc[i] = (ll) pw[max(i - 2, 0)] * ifac[i - 1] % mod; \n\tL(i, 2, n) if(s[i - 1] != '<') {\n\t\tint mn = min(i - 1, m);\n\t\tL(j, 1, mn) \n\t\t\t(f[i] += (ll) f[j] * DP(j, i) % mod * C(i - 2, j - 1) % mod) %= mod;\n\t}\n\tdivide(m + 1, n);\n\tR(i, n - 1, 1) if(s[i] != '>') {\n\t\tif(i <= m) {\n\t\t\tL(j, i + 1, n) \n\t\t\t\t(g[i] += (ll) g[j] * DP(i, j) % mod * C(n - i - 1, n - j) % mod) %= mod;\n\t\t} else g[i] = h[n - i];\n\t}\n\t\t\n\tL(i, 1, n) if(s[i - 1] != '<' && s[i] != '>')\n\t\t(ns += (ll) f[i] * g[i] % mod * C(n - 1, i - 1) % mod) %= mod; \n\tcout << ns << '\\n';\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "divide and conquer",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\H. Three Minimums.json",
    "editorial_link": "https://codeforces.com//blog/entry/100127",
    "editorial": "SolutionFirst of all, let us state the following lemma (which is\r\nsufficient to solve the problem in if one ignores the constraints given\r\nby the string ). We omit the proof as it is rather easy compared to the\r\ndifficulty of the problem as a whole.Lemma: The following statements\r\nhold for a permutation . is good if and only if and are good, where . If\r\n, then is good if and only if and are good, where . If and , then is\r\ngood if and only if it is bitonic, i.e., , where . Given , we say that a\r\npermutation of is -consistent if for any : if ; if . Informally\r\nspeaking, a permutation is -consistent if it satisfies the constraints\r\ngiven by when it is written in the positions .For , let , , , , be the\r\nthe number of good permutations which are -consistent and, respectively,\r\nNo additional conditions; Start with ; End with ; Start with and end\r\nwith ; Start with and end with . For and , let . Informally speaking, is\r\nif and only if it can be and is if and only if it can be .Thanks to the\r\nLemma, one has the following relations: . . For , . Analogous formula\r\nfor . and and . For , . Analogous formula for . The problem asks to\r\ncompute . Thanks to the formulas stated above, it is straightforward to\r\nimplement an solution. Now we will tackle the hard task of optimizing it\r\nto .In order to compute , we will compute and for all .We have the\r\nrecurrence relation (for ) Setting , (1) is equivalent to (for , and\r\nalso for !) This looks very similar to an identify between generating\r\nfunctions (a derivative on the left, a product on the right); but for\r\nthe fact that depends on two parameters. To overcome this issue let us\r\nproceed as follows.Notice that, if we set to any of the functions , , ,\r\n, , it holds whenever . Hence, let us define and analogously , , , .With\r\nthese new definitions, (2) becomes (for ) Let and . So, (3) simplifies\r\nto We precompute in the values of and for , . We can also precompute in\r\nthe values of for . In we compute also for all . Thus, in we can\r\ncompute, for all , the values .It is now time to start working with\r\ngenerating functions. Let , , . We know and (at least the first\r\ncoefficients) and we want to compute . Since , we know . Moreover (4) is\r\nequivalent to the ordinary differential equation . This ODE is standard\r\nand its (unique) solution is given by Since the product of generating\r\nfunctions and the exponential of a generating function can be computed\r\nin , we are able to obtain the values of for all and thus the values of\r\n.Now, let us see how to compute . Since for all , let us first compute\r\nfor all . By repeating verbatim the reasoning above, we get that the\r\ngenerating function , where , is given by ( in this case) . So, it\r\nremains only to compute for . This can be done na vely in .The overall\r\ncomplexity is .\r\n"
}