{"link": "https://codeforces.com//contest/1023/problem/E", "problemId": "209193", "problem_idx": "E", "shortId": "1023E", "contest_number": "1023", "problem_submissions": {"F": [41706962, 41711449, 41703443, 41713059, 41716623, 41714553, 41714671, 41707623, 41713235, 41712334, 41728092, 41715075, 41696075, 41713356, 41714801, 41709605, 41719826, 41712664, 41715258, 41716252], "E": [41698618, 41698291, 41699659, 41704092, 41694722, 41704680, 41704917, 41699573, 41705681, 41707263, 41704649, 41710828, 41705364, 41701903, 41705217, 41705636, 41706969, 41702766, 41702871], "D": [41694804, 41690882, 41694456, 41696667, 41700369, 41697794, 41697937, 41696439, 41697953, 41699194, 41695409, 41701962, 41696987, 41693065, 41702154, 41698952, 41700314, 41697292, 41697057], "C": [41689677, 41687726, 41688316, 41690341, 41688011, 41691766, 41691373, 41708581, 41689935, 41688178, 41690416, 41703451, 41690697, 41687815, 41690419, 41689708, 41692238, 41691341, 41691501], "B": [41687853, 41686964, 41687392, 41687955, 41687163, 41687657, 41689074, 41696355, 41687990, 41690278, 41688421, 41705049, 41689143, 41688949, 41689104, 41687914, 41689486, 41689269, 41689603], "A": [41686640, 41686676, 41686712, 41686970, 41686742, 41686759, 41687401, 41696322, 41687071, 41686971, 41706549, 41687626, 41686813, 41686865, 41686818, 41686780, 41686879, 41726126], "G": [55938906, 48502404, 46583960, 42546293, 42609540]}, "name": "E. Down or Right", "statement": "Bob lives in a square grid of size n\r\ntimes n, with rows numbered 1 through n from top to bottom, and columns\r\nnumbered 1 through n from left to right. Every cell is either allowed or\r\nblocked, but you don\u2019t know the exact description of the grid. You are\r\ngiven only an integer n.Bob can move through allowed cells but only in\r\nsome limited directions. When Bob is in an allowed cell in the grid, he\r\ncan move to an adjacent cell, if it is allowed.You can ask at most 4\r\ncdot n queries of form \"r_1 c_1 r_2 c_2\" (1\r\nle r_1\r\nle r_2\r\nle n, 1\r\nle c_1\r\nle c_2\r\nle n). The answer will be \"\" if Bob can get from a cell (r_1, c_1) to a\r\ncell (r_2, c_2), and \"\" otherwise. In particular, if one of the two\r\ncells (or both) is a blocked cell then the answer is \"\" for sure. Since\r\nBob doesn\u2019t like short trips, you can only ask queries with the\r\nmanhattan distance between the two cells at least n - 1, i.e. the\r\nfollowing condition must be satisfied: (r_2 - r_1) + (c_2 - c_1)\r\nge n - 1.It\u2019s guaranteed that Bob can get from the top-left corner\r\n(1, 1) to the bottom-right corner (n, n) and your task is to find a way\r\nto do it. You should print the answer in form \"\" where S is a string of\r\nlength 2\r\ncdot n - 2 consisting of characters \u201d and \u201d, denoting moves down and\r\nright respectively. The down move increases the first coordinate by 1,\r\nthe right move increases the second coordinate by 1. If there are\r\nmultiple solutions, any of them will be accepted. You should terminate\r\nimmediately after printing the solution.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\n\nint query(int sx, int sy, int ex, int ey){\n\tprintf(\"? %d %d %d %d\\n\", sx, sy, ex, ey);\n\tfflush(stdout);\n\tstring s; cin >> s;\n\tif(s == \"YES\") return 1;\n\treturn 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tint sx = 1, sy = 1;\n\tstring l, r;\n\twhile(sx + sy < n + 1){\n\t\tif(sx + 1 <= n && query(sx + 1, sy, n, n)){\n\t\t\tl.push_back('D');\n\t\t\tsx++;\n\t\t}\n\t\telse{\n\t\t\tl.push_back('R');\n\t\t\tsy++;\n\t\t}\n\t}\n\tsx = n, sy = n;\n\twhile(sx + sy > n + 1){\n\t\tif(sy > 1 && query(1, 1, sx, sy - 1)){\n\t\t\tr.push_back('R');\n\t\t\tsy--;\n\t\t}\n\t\telse{\n\t\t\tr.push_back('D');\n\t\t\tsx--;\n\t\t}\n\t}\n\treverse(r.begin(), r.end());\n\tl = l + r;\n\tprintf(\"! %s\\n\", l.c_str());\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "interactive", "matrices"], "dificulty": "2100", "interactive": false}