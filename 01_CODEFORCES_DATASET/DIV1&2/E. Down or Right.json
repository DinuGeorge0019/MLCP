{
    "link": "https://codeforces.com//contest/1023/problem/E",
    "problemId": "209193",
    "problem_idx": "E",
    "shortId": "1023E",
    "contest_number": "1023",
    "problem_submissions": {
        "F": [
            41706962,
            41711449,
            41703443,
            41713059,
            41716623,
            41714553,
            41714671,
            41707623,
            41713235,
            41712334,
            41728092,
            41715075,
            41696075,
            41713356,
            41714801,
            41709605,
            41719826,
            41712664,
            41715258,
            41716252
        ],
        "E": [
            41698618,
            41698291,
            41699659,
            41704092,
            41694722,
            41704680,
            41704917,
            41699573,
            41705681,
            41707263,
            41704649,
            41710828,
            41705364,
            41701903,
            41705217,
            41705636,
            41706969,
            41702766,
            41702871
        ],
        "D": [
            41694804,
            41690882,
            41694456,
            41696667,
            41700369,
            41697794,
            41697937,
            41696439,
            41697953,
            41699194,
            41695409,
            41701962,
            41696987,
            41693065,
            41702154,
            41698952,
            41700314,
            41697292,
            41697057
        ],
        "C": [
            41689677,
            41687726,
            41688316,
            41690341,
            41688011,
            41691766,
            41691373,
            41708581,
            41689935,
            41688178,
            41690416,
            41703451,
            41690697,
            41687815,
            41690419,
            41689708,
            41692238,
            41691341,
            41691501
        ],
        "B": [
            41687853,
            41686964,
            41687392,
            41687955,
            41687163,
            41687657,
            41689074,
            41696355,
            41687990,
            41690278,
            41688421,
            41705049,
            41689143,
            41688949,
            41689104,
            41687914,
            41689486,
            41689269,
            41689603
        ],
        "A": [
            41686640,
            41686676,
            41686712,
            41686970,
            41686742,
            41686759,
            41687401,
            41696322,
            41687071,
            41686971,
            41706549,
            41687626,
            41686813,
            41686865,
            41686818,
            41686780,
            41686879,
            41726126
        ],
        "G": [
            55938906,
            48502404,
            46583960,
            42546293,
            42609540
        ]
    },
    "name": "E. Down or Right",
    "statement": "Bob lives in a square grid of size n\r\ntimes n, with rows numbered 1 through n from top to bottom, and columns\r\nnumbered 1 through n from left to right. Every cell is either allowed or\r\nblocked, but you don\u2019t know the exact description of the grid. You are\r\ngiven only an integer n.Bob can move through allowed cells but only in\r\nsome limited directions. When Bob is in an allowed cell in the grid, he\r\ncan move to an adjacent cell, if it is allowed.You can ask at most 4\r\ncdot n queries of form \"r_1 c_1 r_2 c_2\" (1\r\nle r_1\r\nle r_2\r\nle n, 1\r\nle c_1\r\nle c_2\r\nle n). The answer will be \"\" if Bob can get from a cell (r_1, c_1) to a\r\ncell (r_2, c_2), and \"\" otherwise. In particular, if one of the two\r\ncells (or both) is a blocked cell then the answer is \"\" for sure. Since\r\nBob doesn\u2019t like short trips, you can only ask queries with the\r\nmanhattan distance between the two cells at least n - 1, i.e. the\r\nfollowing condition must be satisfied: (r_2 - r_1) + (c_2 - c_1)\r\nge n - 1.It\u2019s guaranteed that Bob can get from the top-left corner\r\n(1, 1) to the bottom-right corner (n, n) and your task is to find a way\r\nto do it. You should print the answer in form \"\" where S is a string of\r\nlength 2\r\ncdot n - 2 consisting of characters \u201d and \u201d, denoting moves down and\r\nright respectively. The down move increases the first coordinate by 1,\r\nthe right move increases the second coordinate by 1. If there are\r\nmultiple solutions, any of them will be accepted. You should terminate\r\nimmediately after printing the solution.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\n\nint query(int sx, int sy, int ex, int ey){\n\tprintf(\"? %d %d %d %d\\n\", sx, sy, ex, ey);\n\tfflush(stdout);\n\tstring s; cin >> s;\n\tif(s == \"YES\") return 1;\n\treturn 0;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tint sx = 1, sy = 1;\n\tstring l, r;\n\twhile(sx + sy < n + 1){\n\t\tif(sx + 1 <= n && query(sx + 1, sy, n, n)){\n\t\t\tl.push_back('D');\n\t\t\tsx++;\n\t\t}\n\t\telse{\n\t\t\tl.push_back('R');\n\t\t\tsy++;\n\t\t}\n\t}\n\tsx = n, sy = n;\n\twhile(sx + sy > n + 1){\n\t\tif(sy > 1 && query(1, 1, sx, sy - 1)){\n\t\t\tr.push_back('R');\n\t\t\tsy--;\n\t\t}\n\t\telse{\n\t\t\tr.push_back('D');\n\t\t\tsx--;\n\t\t}\n\t}\n\treverse(r.begin(), r.end());\n\tl = l + r;\n\tprintf(\"! %s\\n\", l.c_str());\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "interactive",
        "matrices"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Down or Right.json",
    "editorial_link": "https://codeforces.com//blog/entry/61356",
    "editorial": "Hint: Move from to the middle by asking queries \u00e2\u0080\u0099query(row, col, n, n)\u00e2\u0080\u0099,\r\nstarting with . Similarly, move from to the middle by asking queries\r\n\u00e2\u0080\u0099query(1, 1, row, col)\u00e2\u0080\u0099. How to ensure that we will meet in the same\r\ncell in the middle?The unusual condition in this problem is that must be\r\nsatisfied in every query. Without it, the following simple code would\r\nsolve the problem:int row = 1, col = 1;while(row < n || col < n) {\r\nif(row + 1 <= n && query(row + 1, col, n, n)) row++; // move down else\r\ncol++; // move right}This program starts in and greedily moves down if\r\nafter this move we could still reach the cell . Otherwise, it must move\r\nright.But in this problem, we can only get half the way this method. We\r\nmust stop at the antidiagonal (one of cells: ). So maybe it\u00e2\u0080\u0099s a good\r\nidea to move backward from the same way, and meet at the antidiagonal?\r\nNot really :(We indeed can apply the same algorithm starting from and\r\ngoing towards , but possibly we will end in a different cell in the\r\nmiddle. It\u00e2\u0080\u0099s possible even for an empty grid, without any blocked cells.\r\nWe are very close to a correct solution, but let\u00e2\u0080\u0099s focus on a thought\r\nprocess for a moment. Analyzing some other possible approach might help\r\nwith that.The limitation about the distance at least is just enough to\r\nask a query between and a cell from the antidiagonal, and also that cell\r\nand .for(int row = 1; row <= n; ++row) { int col = n + 1 - row;\r\nif(query(1, 1, row, col) && query(row, col, n, n)) { print(row, col);\r\n}}This pseudocode would print for a middle cell in our path a cell\r\nreachable from and from which the is reachable. But after choosing some\r\ncell like this, it isn\u00e2\u0080\u0099t that easy to find a way to the corner cells.In\r\nour first idea, we were able to get from to one of the and from to one\r\nof the , but maybe a different one. Now a very important observation is:\r\nthe first piece of code in this editorial will reach the leftmost\r\n(equivalently: downmost) , because we always prefer moving down instead\r\nof right. For example, in an empty we would reach the bottom left\r\ncorner. Now we see that we need to guarantee the same when moving from .\r\nSo we should prioritize left direction over the up direction:row = n,\r\ncol = n;while(row + col > n + 1) { if(query(1, 1, row, col - 1)) col -=\r\n1; // move left else row -= 1; // move up}\r\n"
}