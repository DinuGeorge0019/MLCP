{
    "link": "https://codeforces.com//contest/799/problem/E",
    "problemId": "105987",
    "problem_idx": "E",
    "shortId": "799E",
    "contest_number": "799",
    "problem_submissions": {
        "E": [
            27057040,
            27057010,
            27056967,
            27026697,
            27023753,
            27025405,
            27024865,
            27030424,
            27025641,
            27029307,
            27027415,
            27027135,
            27026445,
            27030147,
            27029255,
            27030374,
            27031127,
            27029721,
            27029453,
            27032096
        ],
        "G": [
            27036616
        ],
        "F": [
            27030563,
            27037422,
            27034476,
            27039260,
            27041363,
            27040801,
            27291324
        ],
        "D": [
            27022631,
            27022286,
            27020681,
            27021344,
            27021554,
            27023148,
            27022862,
            27020910,
            27023070,
            27022767,
            27023676,
            27022207,
            27023905,
            27022671,
            27022391,
            27023340,
            27022748,
            27022866
        ],
        "B": [
            27019416,
            27017594,
            27035489,
            27019723,
            27017243,
            27017666,
            27017468,
            27016992,
            27017464,
            27018383,
            27017219,
            27017196,
            27017940,
            27020412,
            27017770,
            27018390,
            27017823,
            27017563
        ],
        "C": [
            27018858,
            27019675,
            27018439,
            27017585,
            27019861,
            27019164,
            27019715,
            27019543,
            27019587,
            27021111,
            27021089,
            27019694,
            27020343,
            27018899,
            27020067,
            27020926,
            27019896,
            27020090
        ],
        "A": [
            27018375,
            27016569,
            27037894,
            27018311,
            27016502,
            27016795,
            27016557,
            27016497,
            27016519,
            27016617,
            27016531,
            27016564,
            27016580,
            27016596,
            27016533,
            27016606,
            27016598,
            27016653
        ]
    },
    "name": "E. Aquarium decoration",
    "statement": "Arkady and Masha want to choose decorations for thier aquarium in\r\nFishdom game. They have decorations to choose from, each of them has\r\nsome cost. To complete a task Arkady and Masha need to choose\r\ndecorations from given, and they want to spend as little money as\r\npossible.There is one difficulty: Masha likes some of the given\r\ndecorations, Arkady likes some of the given decorations. Some\r\ndecorations may be liked by both Arkady and Masha, or not be liked by\r\nboth. The friends want to choose such decorations so that each of them\r\nlikes decorations among the chosen. Help Masha and Arkady find the\r\nminimum sum of money they need to spend.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long inf = (long long) 1e18;\nconst int infint = (int) 2e9;\n\nconst int N = 1234567;\n\nint c[N];\nint mask[N];\n\nvector  <int> s[4];\nint ptr[4];\nint num[4];\n\nint main() {\n  int n, m, k;\n  scanf(\"%d %d %d\", &n, &m, &k);\n  if (k > m) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", c + i);\n    mask[i] = 0;\n  }\n  for (int t = 0; t < 2; t++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    while (foo--) {\n      int bar;\n      scanf(\"%d\", &bar);\n      bar--;\n      mask[bar] |= (1 << t);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    s[mask[i]].push_back(c[i]);\n  }\n  for (int t = 0; t < 4; t++) {\n    sort(s[t].begin(), s[t].end());\n  }\n  ptr[3] = s[3].size();\n  long long ans = inf;\n  long long cur = 0;\n  for (int z : s[3]) {\n    cur += z;\n  }\n  for (int j = 0; j < 3; j++) {\n    ptr[j] = 0;\n  }\n  for (int both = m; both >= 0; both--) {\n    while (ptr[3] > both) {\n      cur -= s[3][--ptr[3]];\n    }\n    while (ptr[0] + ptr[1] + ptr[2] < m - both) {\n      int best = infint;\n      int best_j = -1;\n      for (int j = 0; j < 3; j++) {\n        num[j] = (ptr[j] == (int) s[j].size() ? infint : s[j][ptr[j]]);\n        if (num[j] < best) {\n          best = num[j];\n          best_j = j;\n        }\n      }\n      if (best_j == -1) {\n        break;\n      }\n      cur += s[best_j][ptr[best_j]++];\n    }\n    for (int t = 1; t <= 2; t++) {\n      while (ptr[t] < k - both && ptr[t] != (int) s[t].size()) {\n        if (ptr[0] == 0 && ptr[3 - t] <= k - both) {\n          break;\n        }\n        if (ptr[3 - t] <= k - both || (ptr[0] != 0 && s[0][ptr[0] - 1] > s[3 - t][ptr[3 - t] - 1])) {\n          cur -= s[0][--ptr[0]];\n        } else {\n          cur -= s[3 - t][--ptr[3 - t]];\n        }\n        cur += s[t][ptr[t]++];\n      }\n    }\n    if (ptr[3] == both && ptr[1] + ptr[3] >= k && ptr[2] + ptr[3] >= k && ptr[0] + ptr[1] + ptr[2] + ptr[3] == m) {\n      ans = min(ans, cur);\n    }\n  }\n  cout << (ans == inf ? -1LL : ans) << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Aquarium decoration.json",
    "editorial_link": "https://codeforces.com/blog/entry/51947",
    "editorial": "Letâs divide the decorations in four groups: that arenât liked by\r\nanybody (group 0), that are liked only by Masha (group 1), that are\r\nliked only by Arkady (group 2), that are liked by both (group 3). Sort\r\neach group by the cost. Then, itâs obvious that in optimal solution we\r\nshould take several (or 0) first elements in each group. Take a look at\r\nthe group 3. Itâs easy to see that if we take decorations from it, then\r\nwe should take first decorations from each of the groups 1 and 2. Letâs\r\ncall these decorations ( from the group 3 and from each of the groups 1\r\nand 2) , and letâs call the other decorations . If the number of\r\nobligatory decorations is less than , we need to take several cheapest\r\nfree decorations. Itâs easy to construct an solution then: for each we\r\ncan construct the answer described in linear time and then choose\r\nminimum among these answers.To speed up the algorithm, letâs try all\r\nfrom the minimum possible (itâs easy to get it from integers , and\r\ngroups 1 and 2 sizes), making transfers from to . We should maintain the\r\nset of costs of free decorations, and letâs also keep integer , which is\r\nthe number of free decorations that we should add to the current answer,\r\nand also the sum of the cheapest free decorations. When we increase by\r\n1, in groups 1 and 2 the most expensive obligatory decoration becomes\r\nfree (because the value decreases by one 1). These decorations (if any)\r\nwe should add to our free set. We should also add one obligatory\r\ndecoration from the group 3, so, the number of free decorations could\r\nchange by one. So, we need at most operations of adding an integer to a\r\nset, and an operation that changes with the corresponding change of the\r\nsum. We can perform these operations in , for example, using two objects\r\nin ++ (or its analogues in other languages) one set for the smallest\r\nintegers and one for the others. The overall complexity to change to is\r\nnow , so the overall complexity is .\r\n",
    "hint": []
}