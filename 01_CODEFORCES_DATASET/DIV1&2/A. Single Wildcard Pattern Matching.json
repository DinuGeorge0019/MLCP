{
    "link": "https://codeforces.com//contest/1023/problem/A",
    "problemId": "209189",
    "problem_idx": "A",
    "shortId": "1023A",
    "contest_number": "1023",
    "problem_submissions": {
        "F": [
            41706962,
            41711449,
            41703443,
            41713059,
            41716623,
            41714553,
            41714671,
            41707623,
            41713235,
            41712334,
            41728092,
            41715075,
            41696075,
            41713356,
            41714801,
            41709605,
            41719826,
            41712664,
            41715258,
            41716252
        ],
        "E": [
            41698618,
            41698291,
            41699659,
            41704092,
            41694722,
            41704680,
            41704917,
            41699573,
            41705681,
            41707263,
            41704649,
            41710828,
            41705364,
            41701903,
            41705217,
            41705636,
            41706969,
            41702766,
            41702871
        ],
        "D": [
            41694804,
            41690882,
            41694456,
            41696667,
            41700369,
            41697794,
            41697937,
            41696439,
            41697953,
            41699194,
            41695409,
            41701962,
            41696987,
            41693065,
            41702154,
            41698952,
            41700314,
            41697292,
            41697057
        ],
        "C": [
            41689677,
            41687726,
            41688316,
            41690341,
            41688011,
            41691766,
            41691373,
            41708581,
            41689935,
            41688178,
            41690416,
            41703451,
            41690697,
            41687815,
            41690419,
            41689708,
            41692238,
            41691341,
            41691501
        ],
        "B": [
            41687853,
            41686964,
            41687392,
            41687955,
            41687163,
            41687657,
            41689074,
            41696355,
            41687990,
            41690278,
            41688421,
            41705049,
            41689143,
            41688949,
            41689104,
            41687914,
            41689486,
            41689269,
            41689603
        ],
        "A": [
            41686640,
            41686676,
            41686712,
            41686970,
            41686742,
            41686759,
            41687401,
            41696322,
            41687071,
            41686971,
            41706549,
            41687626,
            41686813,
            41686865,
            41686818,
            41686780,
            41686879,
            41726126
        ],
        "G": [
            55938906,
            48502404,
            46583960,
            42546293,
            42609540
        ]
    },
    "name": "A. Single Wildcard Pattern Matching",
    "statement": "You are given two strings s and t. The string s consists of lowercase\r\nLatin letters and wildcard character ”, the string t consists only of\r\nlowercase Latin letters. The length of the string s equals n, the length\r\nof the string t equals m.The wildcard character ” in the string s (if\r\nany) can be replaced with an arbitrary sequence (possibly empty) of\r\nlowercase Latin letters. No other character of s can be replaced with\r\nanything. If it is possible to replace a wildcard character ” in s to\r\nobtain a string t, then the string t matches the pattern s.For example,\r\nif s=\"\" then the following strings match it \"\", \"\" and \"\", but the\r\nfollowing strings do not match: \"\", \"\", \"\", \"\", \"\".If the given string t\r\nmatches the given string s, print \"\", otherwise print \"\".\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nstring s1, s2;\n\nint main(){\n\tcin >> n >> m;\n\tcin >> s1 >> s2;\n\tint idx = -1;\n\tfor(int i=0; i<n; i++){\n\t\tif(s1[i] == '*') idx = i;\n\t}\n\tif(idx == -1){\n\t\tputs(s1 == s2 ? \"YES\" : \"NO\");\n\t\treturn 0;\n\t}\n\tint rem = m - (n - 1);\n\tif(rem < 0){\n\t\tputs(\"NO\");\n\t\treturn 0;\n\t}\n\ts1 = s1.substr(0, idx) + s2.substr(idx, rem) + s1.substr(idx + 1, n - idx - 1);\n\tputs(s1 == s2 ? \"YES\" : \"NO\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "strings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\A. Single Wildcard Pattern Matching.json",
    "editorial_link": "https://codeforces.com//blog/entry/61356",
    "editorial": "If there is no wildcard character in the string , the answer is \"\" if\r\nand only if strings and are equal. In the other case letâs do the\r\nfollowing thing: while both strings are not empty and their last\r\ncharacters are equal, letâs erase them. Then do the same for the first\r\ncharacters, i.e. while both strings are not empty and their first\r\ncharacters are equal, letâs erase them. Now if is empty or \"\" the answer\r\nis \"\", otherwise the answer is \"\".\r\n",
    "hint": []
}