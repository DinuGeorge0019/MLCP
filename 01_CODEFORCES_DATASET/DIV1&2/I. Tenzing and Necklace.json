{"link": "https://codeforces.com//contest/1842/problem/I", "problemId": "1978973", "problem_idx": "I", "shortId": "1842I", "contest_number": "1842", "problem_submissions": {"H": [210909272, 210915649, 210920105, 210920155, 210922877, 210917228, 210922837, 210930795, 210943236, 210937664, 210940497, 210923705, 210946319, 210934622, 210945105, 210899880, 210946698, 210939780, 210945932], "F": [210904139, 210906080, 210912565, 210912372, 210898025, 210899929, 210907320, 210916813, 210914105, 210920055, 210921458, 210913885, 210930158, 210926455, 210915591, 210926376, 210920616, 210915480, 210926627], "E": [210900474, 210894310, 210898608, 210904065, 210915135, 210928274, 210898671, 210908613, 210902774, 210908660, 210907798, 210940198, 210905531, 210907005, 210910569, 210945488, 210908738, 210905745, 210907496], "D": [210896488, 210888362, 210895704, 210886302, 210889254, 210887549, 210895428, 210893212, 210903157, 210896694, 210890657, 210891182, 210892762, 210896576, 210915222, 210891979, 210892349, 210897573], "G": [210891898, 210900879, 210908657, 210918356, 210923373, 210939093, 210921066, 210918175, 210911260, 210924814, 210932494, 210913130, 210941401, 210927457, 210933616, 210927314, 210931000, 210936010], "C": [210877958, 210881836, 210878997, 210877037, 210879744, 210878770, 210882382, 210884108, 210887371, 210884900, 210892630, 210896219, 210883482, 210884636, 210910637, 210882729, 210933971, 210885406], "A": [210875095, 210875812, 210874424, 210888796, 210874470, 210876122, 210874664, 210877287, 210875659, 210882217, 210874539, 210875197, 210874805, 210874426, 210902716, 210874934, 210945780, 210885821], "B": [210874375, 210878347, 210876059, 210890061, 210876166, 210875757, 210877955, 210879984, 210877325, 210880724, 210876899, 210877184, 210877441, 210885377, 210916237, 210877578, 210940672, 210885692], "I": [210953525, 211184344, 211107115]}, "name": "I. Tenzing and Necklace", "statement": "Tenzing has a beautiful necklace. The necklace consists of n pearls\r\nnumbered from 1 to n with a string connecting pearls i and (i\r\ntext{ mod } n)+1 for all 1\r\nleq i\r\nleq n.One day Tenzing wants to cut the necklace into several parts by\r\ncutting some strings. But for each connected part of the necklace, there\r\nshould not be more than k pearls. The time needed to cut each string may\r\nnot be the same. Tenzing needs to spend a_i minutes cutting the string\r\nbetween pearls i and (i\r\ntext{ mod } n)+1.Tenzing wants to know the minimum time in minutes to\r\ncut the necklace such that each connected part will not have more than k\r\npearls.\r\n", "solutions": ["#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n//fast IO by yosupo\n//sc.read(string) \u3060\u3068 append \u3055\u308c\u308b\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        ref.clear();\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();            \n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(vector<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val;  // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const vector<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n    void write_single(long double d){\n\t\t{\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n\t\twrite_single('.');\n\t\tfor(int _=0;_<8;_++){\n\t\t\td*=10;\n\t\t\tlong long v=d;\n\t\t\twrite_single(v);\n\t\t\td-=v;\n\t\t}\n    }\n};\n\nScanner sc(stdin);\nPrinter pr(stdout);\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT \u3067\u6570\u5217\u3092\u7ba1\u7406\u3059\u308b\u3068\u304d\u306b\u4f7f\u3046 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \u3057\u3066\u306a\u3044\u3084\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//\u30bd\u30fc\u30c8\u3057\u3066 i \u756a\u76ee\u304c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//\u4f8b\u3048\u3070 sortidx \u3067\u5f97\u305f idx \u3092\u4f7f\u3048\u3070\u5358\u306b\u30bd\u30fc\u30c8\u5217\u306b\u306a\u3063\u3066\u8fd4\u3063\u3066\u304f\u308b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS getrev(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\n//f(a,b) \u304c true \u306a\u3089 a \u3092\u524a\u9664\u3059\u308b\n//less \u3092\u308f\u305f\u3059\u3068 slide max \u304c\u53d6\u308c\u308b\ntemplate<class t,class u>\nstruct slide{\n\tvc<t> x;\n\tvi y;\n\tu f;\n\tint s,b,e,c,d;\n\tslide(u ff=u()):f(ff){init();}\n\tvoid init(){s=b=e=c=d=0;}\n\tvoid push(t a){\n\t\ts++;\n\t\twhile(b<e&&f(x[e-1],a))e--;\n\t\tif(e==(int)x.size()){\n\t\t\tx.eb();\n\t\t\ty.eb();\n\t\t}\n\t\tx[e]=a;\n\t\ty[e++]=c++;\n\t}\n\tvoid pop(){s--;if(y[b]==d)b++;d++;}\n\tt get(){assert(s);return x[b];}\n\tbool has(){return b<e;}\n\tint size(){return s;}\n};\n\n//use 0\npair<int,vi> sub(int n,int k,vi a){\n\tvc<pi> dp(n);\n\tslide<pi,greater<pi>> s;\n\trep(i,n){\n\t\tpi val=i==0?pi(0,-1):s.get();\n\t\tval.a+=a[i];\n\t\tdp[i]=val;\n\t\ts.push(pi(dp[i].a,i));\n\t\tif(i>=k)s.pop();\n\t}\n\tauto [cost,x]=s.get();\n\tvi pos;\n\twhile(x!=-1){\n\t\tpos.pb(x);\n\t\tx=dp[x].b;\n\t}\n\treverse(all(pos));\n\treturn mp(cost,pos);\n}\n\nint brute(int n,int k,vi a){\n\tint res=inf;\n\trep(i,n){\n\t\tchmin(res,sub(n,k,a).a);\n\t\trotate(a.bg,a.bg+1,a.ed);\n\t}\n\treturn res;\n}\n\nint work(int n,int k,vi a,vi pos,int over){\n\ta.pb(a[0]);\n\tpos.pb(n);\n\t\n\tvvc<int> cs(si(pos)-1);\n\trep(i,si(pos)-1){\n\t\trng(j,pos[i],pos[i+1]+1)\n\t\t\tcs[i].pb(a[j]);\n\t}\n\tint K=si(cs);\n\tvi common(K-1,1);\n\tif(over){\n\t\tvvc<int> ds(K-1);\n\t\trep(i,K-1){\n\t\t\tds[i]=cs[i];\n\t\t\tds[i].insert(ds[i].ed,1+all(cs[i+1]));\n\t\t}\n\t\tif(over==1){\n\t\t\tcommon.clear();\n\t\t\trng(i,1,K-1)common.pb(si(cs[i]));\n\t\t\tK--;\n\t\t}else if(over==2){\n\t\t\tds.insert(ds.bg,cs[0]);\n\t\t\tds.insert(ds.ed,cs[K-1]);\n\t\t\tcommon.clear();\n\t\t\trep(i,K)common.pb(si(cs[i]));\n\t\t\tK++;\n\t\t}\n\t\tcs.swap(ds);\n\t}\n\tcs.pb(cs[0]);\n\tK++;\n\tcommon.pb(1);\n\t\n\tdmp(cs);\n\tdmp(common);\n\n\tvvc<pi> dp(K);\n\trep(i,K)dp[i].resize(si(cs[i]));\n\tvvc<int> pre(K);\n\trep(i,K)pre[i].resize(si(cs[i]));\n\t\n\tint ans=inf;\n\n\tauto solve_single=[&](int ini,const vi&ls,const vi&rs)->vi{\n\t\tassert(inc(ls[0],ini,rs[0]));\n\t\tassert(inc(ls[K-1],ini,rs[K-1]));\n\t\trep(i,K){\n\t\t\trng(j,ls[i],rs[i]+1){\n\t\t\t\tdp[i][j]=pi(inf,-1);\n\t\t\t\tpre[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tdp[0][ini]=pi(0,ini);\n\t\trng(i,1,K){\n\t\t\tgnr(j,ls[i-1],rs[i-1]){\n\t\t\t\tchmin(dp[i-1][j],dp[i-1][j+1]);\n\t\t\t}\n\t\t\trng(j,ls[i],rs[i]+1){\n\t\t\t\tint x=si(cs[i-1])-common[i-1]+j-k;\n\t\t\t\tchmax(x,ls[i-1]);\n\t\t\t\tif(x<=rs[i-1]){\n\t\t\t\t\tdp[i][j]=pi(min(dp[i-1][x].a+cs[i][j],inf),j);\n\t\t\t\t\tpre[i][j]=dp[i-1][x].b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[K-1][ini].a>=inf){\n\t\t\tvi mid=rs;\n\t\t\tmid[0]=mid[K-1]=ini;\n\t\t\treturn mid;\n\t\t}\n\t\tchmin(ans,dp[K-1][ini].a);\n\t\tvi mid(K);\n\t\tint cur=ini;\n\t\tper(i,K){\n\t\t\tmid[i]=cur;\n\t\t\tcur=pre[i][cur];\n\t\t}\n\t\tassert(mid[0]==ini);\n\t\treturn mid;\n\t};\n\t\n\tauto rec=[&](auto self,const vi&ls,const vi&rs)->void{\n\t\tif(ls[0]>rs[0])return;\n\t\tint ini=(ls[0]+rs[0])/2;\n\t\t//dmp2(ls[0],rs[0],ini);\n\t\t\n\t\tvi mid=solve_single(ini,ls,rs);\n\t\tif(mid.empty())return;\n\t\t\n\t\tmid[0]--;\n\t\tself(self,ls,mid);\n\t\tmid[0]+=2;\n\t\tself(self,mid,rs);\n\t};\n\t\n\tvi ls,rs;\n\trep(i,K){\n\t\tls.pb(0);\n\t\trs.pb(si(cs[i])-1);\n\t}\n\trec(rec,ls,rs);\n\tdmp(ans);\n\t\n\treturn ans;\n}\n\nint fast(int n,int k,vi a){\n\trotate(a.bg,min_element(all(a)),a.ed);\n\tvi pos=sub(n,k,a).b;\n\t\n\tint ans=work(n,k,a,pos,0);\n\tif(si(pos)>2){\n\t\tchmin(ans,work(n,k,a,pos,1));\n\t}\n\tchmin(ans,work(n,k,a,pos,2));\n\treturn ans;\n}\n\nvoid slv(){\n\tint n,k;sc.read(n,k);\n\tvi a(n);rep(i,n)sc.read(a[i]);\n\tprint(fast(n,k,a));\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t/*auto test=[&](int n,int k,vi a){\n\t\tint god=brute(n,k,a);\n\t\tint ans=fast(n,k,a);\n\t\t\n\t\tif(god!=ans){\n\t\t\tcerr<<n<<\" \"<<k<<\" \"<<a<<endl;\n\t\t\tcerr<<god<<\" \"<<ans<<endl;\n\t\t}\n\t\tassert(god==ans);\n\t};\n\t\n\ttest(9,3,{1,1,3,2,1,1,2,3,1,});\n\ttest(3,1,{3,1,3,});\n\ttest(4,2,{2,1,3,1,});\n\ttest(4,2,{3,1,2,1,});\n\n\trng(n,3,20){\n\t\tcerr<<n<<endl;\n\t\trep(_,10000){\n\t\t\tvi a(n);\n\t\t\trep(i,n)a[i]=rand_int(1,20);\n\t\t\t\n\t\t\trng(k,1,n){\n\t\t\t\ttest(n,k,a);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\t/*{\n\t\tint n=5*ten(5);\n\t\tint k=1000;\n\t\tvi a(n);\n\t\trep(i,n)a[i]=rand_int(1,1);\n\t\t\n\t\tprint(fast(n,k,a));\n\t\t//test(n,k,a);\n\t\treturn 0;\n\t}*/\n\t\n\tint t;sc.read(t);rep(_,t)\n\tslv();\n}\n"], "input": "", "output": "", "tags": ["divide and conquer", "dp", "greedy"], "dificulty": "3500", "interactive": false}