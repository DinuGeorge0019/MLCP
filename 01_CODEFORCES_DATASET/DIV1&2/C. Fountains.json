{
    "link": "https://codeforces.com//contest/799/problem/C",
    "problemId": "105985",
    "problem_idx": "C",
    "shortId": "799C",
    "contest_number": "799",
    "problem_submissions": {
        "E": [
            27057040,
            27057010,
            27056967,
            27026697,
            27023753,
            27025405,
            27024865,
            27030424,
            27025641,
            27029307,
            27027415,
            27027135,
            27026445,
            27030147,
            27029255,
            27030374,
            27031127,
            27029721,
            27029453,
            27032096
        ],
        "G": [
            27036616
        ],
        "F": [
            27030563,
            27037422,
            27034476,
            27039260,
            27041363,
            27040801,
            27291324
        ],
        "D": [
            27022631,
            27022286,
            27020681,
            27021344,
            27021554,
            27023148,
            27022862,
            27020910,
            27023070,
            27022767,
            27023676,
            27022207,
            27023905,
            27022671,
            27022391,
            27023340,
            27022748,
            27022866
        ],
        "B": [
            27019416,
            27017594,
            27035489,
            27019723,
            27017243,
            27017666,
            27017468,
            27016992,
            27017464,
            27018383,
            27017219,
            27017196,
            27017940,
            27020412,
            27017770,
            27018390,
            27017823,
            27017563
        ],
        "C": [
            27018858,
            27019675,
            27018439,
            27017585,
            27019861,
            27019164,
            27019715,
            27019543,
            27019587,
            27021111,
            27021089,
            27019694,
            27020343,
            27018899,
            27020067,
            27020926,
            27019896,
            27020090
        ],
        "A": [
            27018375,
            27016569,
            27037894,
            27018311,
            27016502,
            27016795,
            27016557,
            27016497,
            27016519,
            27016617,
            27016531,
            27016564,
            27016580,
            27016596,
            27016533,
            27016606,
            27016598,
            27016653
        ]
    },
    "name": "C. Fountains",
    "statement": "Arkady plays Gardenscapes a lot. Arkady wants to build two new\r\nfountains. There are available fountains, for each fountain its beauty\r\nand cost are known. There are two types of money in the game: coins and\r\ndiamonds, so each fountain cost can be either in coins or diamonds. No\r\nmoney changes between the types are allowed.Help Arkady to find two\r\nfountains with maximum total beauty so that he can buy both at the same\r\ntime.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint pref[N], a[N], b[N];\nchar c[N];\n\nint solve(vector < pair <int, int> > z, int b) {\n  sort(z.begin(), z.end());\n  int cnt = z.size();\n  if (cnt < 2) {\n    return 0;\n  }\n  pref[0] = 0;\n  for (int i = 0; i < cnt; i++) {\n    pref[i + 1] = max(pref[i], z[i].second);\n  }\n  int i = 0;\n  int res = 0;\n  for (int j = cnt - 1; j >= 0; j--) {\n    while (i < j && z[i].first + z[j].first <= b) {\n      i++;\n    }\n    i = min(i, j);\n    if (i > 0) {\n      res = max(res, pref[i] + z[j].second);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n, C, D;\n  scanf(\"%d %d %d\", &n, &C, &D);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", a + i, b + i);\n    c[i] = getchar();\n    while (c[i] != 'C' && c[i] != 'D') {\n      c[i] = getchar();\n    }\n  }\n  int ans = 0;\n  {\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'C' && b[i] <= C) {\n        x = max(x, a[i]);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'D' && b[i] <= D) {\n        y = max(y, a[i]);\n      }\n    }\n    if (x > 0 && y > 0) {\n      ans = max(ans, x + y);\n    }\n  }\n  {\n    vector < pair <int, int> > z;\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'C') {\n        z.push_back(make_pair(b[i], a[i]));\n      }\n    }\n    ans = max(ans, solve(z, C));\n  }\n  {\n    vector < pair <int, int> > z;\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'D') {\n        z.push_back(make_pair(b[i], a[i]));\n      }\n    }\n    ans = max(ans, solve(z, D));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Fountains.json",
    "editorial_link": "https://codeforces.com/blog/entry/51947",
    "editorial": "There are three ways Arkady builds one fountain for coins and other for\r\ndiamonds, Arkady builds both fountains for coins and Arkady builds both\r\nfountains for diamonds. In the end we need to choose a way with maximum\r\ntotal beauty.The first way is simple we need to choose one fountain of\r\neach type with maximum beauty on which is enough coins and diamonds\r\nwhich Arkady has. To make it we can easily iterate though all given\r\nfountains.The other two ways are treated similarly to each other.\r\nConsider the way when Arkady builds both fountains for coins.Letâs write\r\nout all the fountains for a coins in a separate array. We will store\r\nthem as pairs cost and beauty. Then sort the array in ascending order of\r\ncost. Let Arkady will build fountains with cost and coins and and .\r\nAdditionally we need an array , where equals to maximum fountain beauty\r\non the prefix of sorted fountains for coins which ends in position .The\r\noption when equals to should be considered separately. It can be done in\r\none iteration through the fountains from fountains with same cost we\r\nneed to choose two with maximum beauty and update the answer with the\r\nresulting value.It is only left case when . Letâs brute the fountain\r\nwith cost equals to . After that, Arcady will have coins. After that\r\nwith help of binary search we need to find the fountains prefix which\r\nArkay can build for the remaining coins. With help of array we can\r\ndetermine the maximum beauty of fountain which Arkady can\r\nbuild.Similarly, the third way is solved when both fountains will be\r\nbuilt for diamonds.\r\n",
    "hint": []
}