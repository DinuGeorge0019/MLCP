{"link": "https://codeforces.com//contest/799/problem/C", "problemId": "105985", "problem_idx": "C", "shortId": "799C", "contest_number": "799", "problem_submissions": {"E": [27057040, 27057010, 27056967, 27026697, 27023753, 27025405, 27024865, 27030424, 27025641, 27029307, 27027415, 27027135, 27026445, 27030147, 27029255, 27030374, 27031127, 27029721, 27029453, 27032096], "G": [27036616], "F": [27030563, 27037422, 27034476, 27039260, 27041363, 27040801, 27291324], "D": [27022631, 27022286, 27020681, 27021344, 27021554, 27023148, 27022862, 27020910, 27023070, 27022767, 27023676, 27022207, 27023905, 27022671, 27022391, 27023340, 27022748, 27022866], "B": [27019416, 27017594, 27035489, 27019723, 27017243, 27017666, 27017468, 27016992, 27017464, 27018383, 27017219, 27017196, 27017940, 27020412, 27017770, 27018390, 27017823, 27017563], "C": [27018858, 27019675, 27018439, 27017585, 27019861, 27019164, 27019715, 27019543, 27019587, 27021111, 27021089, 27019694, 27020343, 27018899, 27020067, 27020926, 27019896, 27020090], "A": [27018375, 27016569, 27037894, 27018311, 27016502, 27016795, 27016557, 27016497, 27016519, 27016617, 27016531, 27016564, 27016580, 27016596, 27016533, 27016606, 27016598, 27016653]}, "name": "C. Fountains", "statement": "Arkady plays Gardenscapes a lot. Arkady wants to build two new\r\nfountains. There are available fountains, for each fountain its beauty\r\nand cost are known. There are two types of money in the game: coins and\r\ndiamonds, so each fountain cost can be either in coins or diamonds. No\r\nmoney changes between the types are allowed.Help Arkady to find two\r\nfountains with maximum total beauty so that he can buy both at the same\r\ntime.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint pref[N], a[N], b[N];\nchar c[N];\n\nint solve(vector < pair <int, int> > z, int b) {\n  sort(z.begin(), z.end());\n  int cnt = z.size();\n  if (cnt < 2) {\n    return 0;\n  }\n  pref[0] = 0;\n  for (int i = 0; i < cnt; i++) {\n    pref[i + 1] = max(pref[i], z[i].second);\n  }\n  int i = 0;\n  int res = 0;\n  for (int j = cnt - 1; j >= 0; j--) {\n    while (i < j && z[i].first + z[j].first <= b) {\n      i++;\n    }\n    i = min(i, j);\n    if (i > 0) {\n      res = max(res, pref[i] + z[j].second);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n, C, D;\n  scanf(\"%d %d %d\", &n, &C, &D);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", a + i, b + i);\n    c[i] = getchar();\n    while (c[i] != 'C' && c[i] != 'D') {\n      c[i] = getchar();\n    }\n  }\n  int ans = 0;\n  {\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'C' && b[i] <= C) {\n        x = max(x, a[i]);\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'D' && b[i] <= D) {\n        y = max(y, a[i]);\n      }\n    }\n    if (x > 0 && y > 0) {\n      ans = max(ans, x + y);\n    }\n  }\n  {\n    vector < pair <int, int> > z;\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'C') {\n        z.push_back(make_pair(b[i], a[i]));\n      }\n    }\n    ans = max(ans, solve(z, C));\n  }\n  {\n    vector < pair <int, int> > z;\n    for (int i = 0; i < n; i++) {\n      if (c[i] == 'D') {\n        z.push_back(make_pair(b[i], a[i]));\n      }\n    }\n    ans = max(ans, solve(z, D));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "implementation"], "dificulty": "1800", "interactive": false}