{"link": "https://codeforces.com//contest/1799/problem/E", "problemId": "1800602", "problem_idx": "E", "shortId": "1799E", "contest_number": "1799", "problem_submissions": {"H": [195172140, 195179948, 195176943, 195177627, 195177612, 195187046, 195170243, 195186163, 195181900, 195178648, 195187740, 195188641, 195181162, 195197683, 195197622, 195197452, 195197330, 195195992, 195195702, 195195592, 195189428, 222390709, 195183885, 195192378], "G": [195165805, 195168765, 195163877, 195170080, 195166062, 195173874, 195159286, 195167233, 195175284, 195171112, 195175174, 195176292, 195166497, 195167039, 195174540, 195165113, 195172643, 195174992, 195179660], "F": [195162556, 195161415, 195167047, 195167029, 195169902, 195165660, 195176867, 195177074, 195171218, 195182224, 195179445, 195181473, 195185750, 195200279, 195171757, 195192151, 195177698, 195192345, 195178905, 195177004], "E": [195155464, 195155926, 195160608, 195157188, 195161547, 195155405, 195184653, 195161068, 195166323, 195173130, 195168387, 195173064, 195218892, 195198896, 195162114, 195161002, 195160161, 195165268, 195163227, 195160677], "D2": [195149687, 195148531, 195151569, 195149401, 195152435, 195149320, 195159443, 195154372, 195157592, 195155987, 195161428, 195244200, 195161041, 195153968, 195155870, 195151311, 195155278, 195159787, 195153371, 195151855], "D1": [195149644, 195148457, 195150430, 195149466, 195152497, 195149250, 195150661, 195154425, 195157658, 195153741, 195161504, 195150409, 195152774, 195155970, 195151278, 195153482, 195159732, 195149352, 195149899], "C": [195146230, 195145019, 195147190, 195145539, 195148295, 195145217, 195148636, 195146815, 195151203, 195151265, 195151601, 195146561, 195147507, 195149080, 195145370, 195151542, 195158458, 195147153, 195147120], "B": [195140902, 195141064, 195140888, 195140956, 195140810, 195141011, 195142268, 195146249, 195143844, 195142681, 195143326, 195142296, 195140849, 195142634, 195140165, 195142125, 195141309, 195141669, 195140680], "A": [195139293, 195139594, 195139424, 195139401, 195139388, 195139558, 195139905, 195143164, 195139695, 195139287, 195140212, 195139506, 195139370, 195139520, 195139228, 195140320, 195142809, 195139497, 195139286]}, "name": "E. City Union", "statement": "You are given n\r\ntimes m grid. Some cells are filled and some are empty.A is a maximal\r\n(by inclusion) set of filled cells such that it is possible to get from\r\nany cell in the set to any other cell in the set by moving to adjacent\r\n(by side) cells, without moving into any cells not in the set. In other\r\nwords, a city is a connected component of filled cells with edges\r\nbetween adjacent (by side) cells.Initially, there are on the grid. You\r\nwant to change some empty cells into filled cells so that both of the\r\nfollowing are satisfied: There is on the resulting grid. The shortest\r\npath between any two filled cells, achievable only by moving onto filled\r\ncells, is equal to the Manhattan distance between them. The between two\r\ncells (a, b) and (c, d) is equal to |a - c| + |b - d|.Find a way to add\r\nfilled cells that satisfies these conditions and minimizes the total\r\nnumber of filled cells.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::string> s(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> s[i];\n    }\n    \n    std::vector<int> minr(n, m), maxr(n, -1), minc(m, n), maxc(m, -1);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (s[i][j] == '#') {\n                minr[i] = std::min(minr[i], j);\n                maxr[i] = std::max(maxr[i], j);\n                minc[j] = std::min(minc[j], i);\n                maxc[j] = std::max(maxc[j], i);\n            }\n        }\n    }\n    \n    std::function<void(int, int)> work = [&](int x, int y) -> void {\n        s[x][y] = '#';\n        minr[x] = std::min(minr[x], y);\n        maxr[x] = std::max(maxr[x], y);\n        minc[y] = std::min(minc[y], x);\n        maxc[y] = std::max(maxc[y], x);\n        \n        for (int j = minr[x]; j <= maxr[x]; j++) {\n            if (s[x][j] == '.') {\n                work(x, j);\n            }\n        }\n        for (int i = minc[y]; i <= maxc[y]; i++) {\n            if (s[i][y] == '.') {\n                work(i, y);\n            }\n        }\n    };\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = minr[i]; j <= maxr[i]; j++) {\n            if (s[i][j] == '.') {\n                work(i, j);\n            }\n        }\n    }\n    for (int j = 0; j < m; j++) {\n        for (int i = minc[j]; i <= maxc[j]; i++) {\n            if (s[i][j] == '.') {\n                work(i, j);\n            }\n        }\n    }\n    \n    int u1 = 0;\n    while (minr[u1] > maxr[u1]) {\n        u1++;\n    }\n    int d1 = u1;\n    while (d1 + 1 < n && minr[d1 + 1] <= maxr[d1] && maxr[d1 + 1] >= minr[d1]) {\n        d1++;\n    }\n    int u2 = d1 + 1;\n    while (u2 < n && minr[u2] > maxr[u2]) {\n        u2++;\n    }\n    if (u2 < n) {\n        int d2 = u2;\n        while (d2 + 1 < n && minr[d2 + 1] <= maxr[d2] && maxr[d2 + 1] >= minr[d2]) {\n            d2++;\n        }\n        \n        int r1 = -1, l2 = m;\n        int r2 = -1, l1 = m;\n        for (int i = u1; i <= d1; i++) {\n            r1 = std::max(r1, maxr[i]);\n            l1 = std::min(l1, minr[i]);\n        }\n        for (int i = u2; i <= d2; i++) {\n            r2 = std::max(r2, maxr[i]);\n            l2 = std::min(l2, minr[i]);\n        }\n        if (r1 < l2) {\n            work(d1, r1);\n            work(u2, l2);\n            for (int i = d1 + 1; i <= u2; i++) {\n                work(i, r1);\n            }\n        } else {\n            work(d1, l1);\n            work(u2, r2);\n            for (int i = d1 + 1; i <= u2; i++) {\n                work(i, l1);\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << s[i] << \"\\n\";\n    }\n    std::cout << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "dsu", "geometry", "greedy", "implementation", "math"], "dificulty": "2300", "interactive": false}