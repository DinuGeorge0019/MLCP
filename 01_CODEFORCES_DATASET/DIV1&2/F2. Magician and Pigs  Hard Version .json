{"link": "https://codeforces.com//contest/1774/problem/F2", "problemId": "1697947", "problem_idx": "F2", "shortId": "1774F2", "contest_number": "1774", "problem_submissions": {"G": [185692788, 185688701, 185709786, 185704068, 185700930, 185701804, 185702434, 185710209, 185706872, 185904256, 185795210, 185793397, 185819250], "F2": [185676745, 185670281, 185675729, 185668671, 185681524, 185686567, 185677180, 185669013, 185668157, 185689966, 185688723, 185695825, 185693474, 185692885, 185688234, 185691854, 185681271, 185694474, 185685579], "F1": [185676593, 185670463, 185663684, 185668833, 185681601, 185716882, 185686479, 185674297, 185669194, 185668049, 185679440, 185670075, 185683714, 185693266, 185692482, 185683082, 185681999, 185681061, 185687683, 185683570], "E": [185655499, 185660825, 185651479, 185656124, 185655058, 185662458, 185662357, 185652494, 185657012, 185662649, 185653972, 185662778, 185664782, 185668838, 185669645, 185656956, 185667038, 185672369, 185663098], "D": [185649610, 185653248, 185643125, 185650993, 185649142, 185653531, 185657439, 185657348, 185650869, 185657200, 185661330, 185657425, 185655644, 185661084, 185663734, 185649769, 185662028, 185662351, 185658693], "A": [185644231, 185636102, 185635462, 185635619, 185635678, 185635790, 185637888, 185635854, 185636970, 185636959, 185635664, 185635988, 185635613, 185637777, 185636615, 185635469, 185636037, 185640093, 185635898], "B": [185642990, 185641490, 185645977, 185640363, 185639666, 185641314, 185642797, 185639691, 185640833, 185692584, 185643672, 185638403, 185645169, 185646911, 185640445, 185643451, 185646071, 185642995], "C": [185639008, 185648162, 185647183, 185644645, 185643844, 185645738, 185648229, 185644184, 185645698, 185650776, 185648822, 185648683, 185646713, 185653638, 185655962, 185643940, 185653656, 185654108, 185651616]}, "name": "F2. Magician and Pigs  Hard Version ", "statement": "Little09 has been interested in magic for a long time, and it\u2019s so lucky\r\nthat he meets a magician! The magician will perform n operations, each\r\nof them is one of the following three: 1\r\nx: Create a pig with x Health Points. 2\r\nx: Reduce the Health Point of all living pigs by x. 3: Repeat all\r\nprevious operations. Formally, assuming that this is the i-th operation\r\nin the operation sequence, perform the first i-1 operations (including\r\n\"Repeat\" operations involved) in turn.A pig will die when its Health\r\nPoint is less than or equal to 0. Little09 wants to know how many living\r\npigs there are after all the operations. Please, print the answer modulo\r\n998\r\n,244\r\n,353.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst ll INF = (ll)1e10;\nconst int N = 800800;\nPowers P2 = Powers(N, Mint(2));\nvector<int> allDoubles;\nint cntDoubles[N];\nll sumDamage[N];\nll sumDamageDoulbed[N];\nint a[N][2];\nint n;\nMint ANS;\nll b[100];\nll c[100];\nint m;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcntDoubles[i + 1] = cntDoubles[i];\n\t\tsumDamage[i + 1] = sumDamage[i];\n\t\tsumDamageDoulbed[i + 1] = sumDamageDoulbed[i];\n\t\tscanf(\"%d\", &a[i][0]);\n\t\tif (a[i][0] == 1) {\n\t\t\tscanf(\"%d\", &a[i][1]);\n\t\t} else if (a[i][0] == 2) {\n\t\t\tscanf(\"%d\", &a[i][1]);\n\t\t\tsumDamage[i + 1] += a[i][1];\n\t\t\tsumDamageDoulbed[i + 1] = min(INF, sumDamageDoulbed[i + 1] + a[i][1]);\n\t\t} else {\n\t\t\tcntDoubles[i + 1] += 1;\n\t\t\tsumDamageDoulbed[i + 1] = min(INF, sumDamageDoulbed[i + 1] * 2);\n\t\t\tif (sumDamage[i] > 0) allDoubles.push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (a[i][0] == 1) {\n\t\tll x = a[i][1];\n\t\tx -= sumDamage[n] - sumDamage[i];\n\t\tif (x <= 0) continue;\n\t\tm = 0;\n\t\tint p = lower_bound(all(allDoubles), i) - allDoubles.begin();\n\t\tif (p == (int)allDoubles.size()) {\n\t\t\tANS += P2.pow(cntDoubles[n] - cntDoubles[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tint q = p;\n\t\tint pw = cntDoubles[allDoubles[p]] - cntDoubles[i];\n\t\tassert(pw >= 0);\n\t\twhile(m < 32 && p < (int)allDoubles.size()) {\n\t\t\tb[m] = sumDamage[allDoubles[p]];\n\t\t\tif (b[m] >= x) break;\n\t\t\tm++;\n\t\t\tp++;\n\t\t}\n\t\tif (m == 0) {\n\t\t\tANS += P2.pow(pw);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = m - 1; i > 0; i--)\n\t\t\tb[i] -= b[i - 1];\n\t\tb[0] = sumDamageDoulbed[allDoubles[q]];\n\t\tc[0] = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tc[i + 1] = min(x + 1, 2 * c[i] + b[i]);\n\t\teprintf(\"x = %lld\\n\", x);\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\teprintf(\"%lld \", c[i]);\n\t\teprintf(\"\\n\");\n\t\tll res = 1;\n\t\tfor (int i = m; i > 0; i--) {\n\t\t\tif (x <= c[i]) continue;\n\t\t\tres += 1LL << (i - 1);\n\t\t\tx -= c[i];\n\t\t}\n\t\tANS += Mint(res) * P2.pow(pw);\n\t}\n\tprintf(\"%u\\n\", ANS.x);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures", "implementation"], "dificulty": "2700", "interactive": false}