{
    "link": "https://codeforces.com//contest/2061/problem/I",
    "problemId": "3155964",
    "problem_idx": "I",
    "shortId": "2061I",
    "contest_number": "2061",
    "problem_submissions": {
        "F2": [
            302127475,
            302092403,
            302114656,
            302114350,
            302118052,
            302128136,
            302099327,
            302127501,
            302105569,
            302158287,
            302158231,
            302158981,
            302158740,
            302158593,
            302155955
        ],
        "H1": [
            302102508,
            302123846,
            302123275,
            302120307,
            302128240,
            302113263,
            302214973,
            302214838,
            302492170,
            302128311,
            302150853
        ],
        "G": [
            302087277,
            302104836,
            302092310,
            302101290,
            302098614,
            302099751,
            302090244,
            302079497,
            302107342,
            302102846,
            302118471,
            302119832,
            302088828,
            302085801,
            302097252,
            302107147,
            302100360,
            302104471
        ],
        "F1": [
            302070705,
            302068249,
            302076903,
            302139304,
            302085853,
            302085964,
            302087951,
            302076823,
            302099111,
            302088499,
            302088697,
            302106078,
            302076066,
            302095307,
            302083979,
            302077009,
            302082649,
            302158914,
            302081283
        ],
        "E": [
            302060766,
            302059898,
            302064375,
            302146780,
            302146561,
            302146204,
            302145996,
            302145832,
            302145821,
            302145812,
            302060519,
            302071650,
            302062756,
            302067337,
            302066558,
            302071373,
            302078018,
            302075359,
            302069841,
            302067118,
            302063628,
            302073608,
            302071649,
            302075889,
            302072748
        ],
        "D": [
            302057147,
            302056206,
            302056876,
            302056600,
            302064486,
            302056648,
            302061458,
            302060302,
            302063595,
            302065433,
            302068805,
            302064352,
            302061742,
            302059104,
            302069059,
            302065232,
            302069194,
            302062940
        ],
        "C": [
            302053893,
            302052972,
            302060290,
            302053477,
            302058781,
            302053556,
            302058513,
            302056661,
            302060439,
            302057971,
            302066087,
            302059912,
            302059144,
            302055184,
            302066070,
            302060621,
            302062953,
            302059461
        ],
        "B": [
            302048946,
            302050832,
            302052328,
            302049723,
            302053638,
            302049221,
            302054664,
            302052475,
            302055824,
            302052997,
            302059041,
            302057352,
            302051579,
            302051983,
            302056196,
            302056129,
            302055478,
            302054565
        ],
        "A": [
            302047037,
            302049009,
            302047309,
            302047023,
            302047283,
            302047053,
            302047177,
            302047108,
            302047316,
            302047521,
            302047571,
            302047610,
            302047369,
            302048738,
            302047337,
            302048364,
            302049028,
            302047123
        ],
        "H2": [
            302541217
        ],
        "I": [
            302144176,
            302142123,
            302142064,
            302141919,
            302124920,
            302518298,
            302518173,
            302517883
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138620",
    "editorial": "First, there is a straightforward dynamic programming solution with a\r\ntime complexity of .Let represent the minimum cost for Kevin to achieve\r\nvictories in the first games. However, optimizing this dynamic\r\nprogramming solution directly is difficult because it lacks\r\nconvexity.Therefore, we use a divide-and-conquer approach to solve it\r\n(which is more commonly seen in certain counting problems). Key Idea: To\r\ncompute from efficiently, the following observations are used:At time ,\r\nif the difference between Kevin’s and Nivek’s number of victories\r\nexceeds , then: For Type 2 matches, Kevin will either always win or\r\nalways lose. For Type 1 matches, Kevin should prioritize matches with\r\nthe smallest cost in ascending order. Let denote the minimum cost of\r\nselecting matches in this range, and let represent the number of Type 2\r\nmatches in the interval.When , the following transition applies:\r\nSimilarly, when , a similar transition is used.Since is convex, the best\r\ntransition point is monotonic. This property allows us to optimize this\r\npart using divide-and-conquer, achieving a time complexity of .For the\r\ncase where , brute force is used to compute the transitions explicitly,\r\nwith a time complexity of .By dividing the sequence into blocks of size\r\n, the overall time complexity can be reduced to . To further optimize\r\nthe problem, a more refined strategy is applied. Specifically, for the\r\ncase where , instead of computing transitions explicitly with brute\r\nforce, we recursively divide the problem into smaller subproblems. The\r\ngoal in each subproblem is to compute the transitions from a segment of\r\nto , ensuring that the segment length in does not exceed .Let . First,\r\ncompute the transitions from to . Then, use the results from to compute\r\nthe transitions from to . For each subinterval, the strategy remains the\r\nsame: For differences in the number of victories that exceed the\r\ninterval length, apply monotonicity to handle the transitions\r\nefficiently. For the remaining part, recursively compute transitions\r\nusing the same divide-and-conquer approach. The recurrence relation for\r\nthis approach is: So the time complexity is .\r\n",
    "name": "I. Kevin and Nivek",
    "statement": "Kevin and Nivek are competing for the title of \"The Best Kevin\". They\r\naim to determine the winner through n matches.The i-th match can be one\r\nof two types: : Kevin needs to spend a_i time to defeat Nivek and win\r\nthe match. If Kevin doesn’t spend a_i time on it, Nivek will win the\r\nmatch. : The outcome of this match depends on their historical records.\r\nIf Kevin’s number of wins is greater than or equal to Nivek’s up to this\r\nmatch, then Kevin wins. Otherwise, Nivek wins. Kevin wants to know the\r\nminimum amount of time he needs to spend to ensure he wins at least k\r\nmatches.Output the answers for k = 0, 1,\r\nldots, n.\r\n",
    "solutions": [
        "#include <algorithm>#include <array>#include <bitset>#include <cassert>#include <chrono>#include <climits>#include <cmath>#include <complex>#include <cstring>#include <functional>#include <iomanip>#include <iostream>#include <map>#include <numeric>#include <queue>#include <random>#include <set>#include <vector>using namespace std; using ll = long long;using db = long double;  // or double, if TL is tightusing str = string;      // yay python! // pairsusing pi = pair<int, int>;using pl = pair<ll, ll>;using pd = pair<db, db>;#define mp make_pair#define f first#define s second #define tcT template <class T#define tcTU tcT, class U// ^ lol this makes everything look weird but I'll try ittcT > using V = vector<T>;tcT, size_t SZ > using AR = array<T, SZ>;using vi = V<int>;using vb = V<bool>;using vl = V<ll>;using vd = V<db>;using vs = V<str>;using vpi = V<pi>;using vpl = V<pl>;using vpd = V<pd>; // vectors#define sz(x) int(size(x))#define bg(x) begin(x)#define all(x) bg(x), end(x)#define rall(x) rbegin(x), rend(x)#define sor(x) sort(all(x))#define rsz resize#define ins insert#define pb push_back#define eb emplace_back#define ft front()#define bk back() #define lb lower_bound#define ub upper_boundtcT > int lwb(const V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }tcT > int upb(const V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); } // loops#define FOR(i, a, b) for (int i = (a); i < (b); ++i)#define F0R(i, a) FOR(i, 0, a)#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)#define R0F(i, a) ROF(i, 0, a)#define rep(a) F0R(_, a)#define each(a, x) for (auto &a : x) const int MOD = 998244353;  // 1e9+7;const int MX = (int)2e5 + 5;const ll BIG = 1e18;  // not too close to LLONG_MAXconst db PI = acos((db)-1);const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());template <class T> using pqg = priority_queue<T, vector<T>, greater<T>>; // bitwise ops// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.htmlconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits setconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\t                         // USACO updates ...\treturn x == 0 ? 0 : 31 - __builtin_clz(x);}  // floor(log2(x))constexpr int p2(int x) { return 1 << x; }constexpr int msk2(int x) { return p2(x) - 1; } ll cdiv(ll a, ll b) {\treturn a / b + ((a ^ b) > 0 && a % b);}  // divide a by b rounded upll fdiv(ll a, ll b) {\treturn a / b - ((a ^ b) < 0 && a % b);}  // divide a by b rounded down tcT > bool ckmin(T &a, const T &b) {\treturn b < a ? a = b, 1 : 0;}  // set a = min(a,b)tcT > bool ckmax(T &a, const T &b) {\treturn a < b ? a = b, 1 : 0;}  // set a = max(a,b) tcTU > T fstTrue(T lo, T hi, U f) {\t++hi;\tassert(lo <= hi);  // assuming f is increasing\twhile (lo < hi) {  // find first index such that f is true\t\tT mid = lo + (hi - lo) / 2;\t\tf(mid) ? hi = mid : lo = mid + 1;\t}\treturn lo;}tcTU > T lstTrue(T lo, T hi, U f) {\t--lo;\tassert(lo <= hi);  // assuming f is decreasing\twhile (lo < hi) {  // find first index such that f is true\t\tT mid = lo + (hi - lo + 1) / 2;\t\tf(mid) ? lo = mid : hi = mid - 1;\t}\treturn lo;}tcT > void remDup(vector<T> &v) {  // sort and remove duplicates\tsort(all(v));\tv.erase(unique(all(v)), end(v));}tcTU > void safeErase(T &t, const U &u) {\tauto it = t.find(u);\tassert(it != end(t));\tt.erase(it);} inline namespace IO {#define SFINAE(x, ...)                                                         \\\ttemplate <class, class = void> struct x : std::false_type {};              \\\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {} SFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));SFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));SFINAE(IsTuple, typename std::tuple_size<T>::type);SFINAE(Iterable, decltype(std::begin(std::declval<T>()))); template <auto &is> struct Reader {\ttemplate <class T> void Impl(T &t) {\t\tif constexpr (DefaultI<T>::value) is >> t;\t\telse if constexpr (Iterable<T>::value) {\t\t\tfor (auto &x : t) Impl(x);\t\t} else if constexpr (IsTuple<T>::value) {\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\t}\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }}; template <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }#define def(t, args...)                                                        \\\tt args;                                                                    \\\tre(args); template <auto &os, bool debug, bool print_nd> struct Writer {\tstring comma() const { return debug ? \",\" : \"\"; }\ttemplate <class T> constexpr char Space(const T &) const {\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\t\t                                                             : ' ';\t}\ttemplate <class T> void Impl(T const &t) const {\t\tif constexpr (DefaultO<T>::value) os << t;\t\telse if constexpr (Iterable<T>::value) {\t\t\tif (debug) os << '{';\t\t\tint i = 0;\t\t\tfor (auto &&x : t)\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\t\t\tif (debug) os << '}';\t\t} else if constexpr (IsTuple<T>::value) {\t\t\tif (debug) os << '(';\t\t\tstd::apply(\t\t\t    [this](auto const &...args) {\t\t\t\t    int i = 0;\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\t\t\t\t     ...);\t\t\t    },\t\t\t    t);\t\t\tif (debug) os << ')';\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\t}\ttemplate <class T> void ImplWrapper(T const &t) const {\t\tif (debug) os << \"\\033[0;31m\";\t\tImpl(t);\t\tif (debug) os << \"\\033[0m\";\t}\ttemplate <class... Ts> void print(Ts const &...ts) const {\t\t((Impl(ts)), ...);\t}\ttemplate <class F, class... Ts>\tvoid print_with_sep(const std::string &sep, F const &f,\t                    Ts const &...ts) const {\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\t}\tvoid print_with_sep(const std::string &) const { os << '\\n'; }}; template <class... Ts> void pr(Ts const &...ts) {\tWriter<cout, false, true>{}.print(ts...);}template <class... Ts> void ps(Ts const &...ts) {\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);}}  // namespace IO inline namespace Debug {template <typename... Args> void err(Args... args) {\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);}template <typename... Args> void errn(Args... args) {\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);} void err_prefix(str func, int line, string args) {\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\t     << \" | \"\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\t     << \":\"\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\t     << \" - \"\t     << \"[\" << args << \"] = \";} #ifdef LOCAL#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)#else#define dbg(...)#define dbgn(args...)#endif const auto beg_time = std::chrono::high_resolution_clock::now();// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1double time_elapsed() {\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\t                                beg_time)\t    .count();}}  // namespace Debug inline namespace FileIO {void setIn(str s) { freopen(s.c_str(), \"r\", stdin); }void setOut(str s) { freopen(s.c_str(), \"w\", stdout); }void setIO(str s = \"\") {\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\tcout << fixed << setprecision(12);\t// cin.exceptions(cin.failbit);\t// throws exception when do smth illegal\t// ex. try to read letter into int\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO}}  // namespace FileIO // make sure to intialize ALL GLOBAL VARS between tcs! vl solve_brute(vi A) {\tassert(false);\tvl ans{0};\tfor (int x : A) {\t\tint games_so_far = sz(ans) - 1;\t\tans.pb(BIG);\t\tif (x == -1) {\t\t\tROF(i, (games_so_far + 1) / 2, sz(ans) - 1)\t\t\tans.at(i + 1) = ans.at(i);\t\t} else {\t\t\tR0F(i, sz(ans) - 1) ckmin(ans.at(i + 1), ans.at(i) + x);\t\t}\t}\treturn ans;} /** * Description: wraps a lambda so it can call itself * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html */ namespace std { template <class Fun> class y_combinator_result {\tFun fun_;   public:\ttemplate <class T>\texplicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {} \ttemplate <class... Args> decltype(auto) operator()(Args &&...args) {\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\t}}; template <class Fun> decltype(auto) y_combinator(Fun &&fun) {\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));} }  // namespace std void y_comb_demo() {\tcout << y_combinator([](auto gcd, int a, int b) -> int {\t\treturn b == 0 ? a : gcd(b, a % b);\t})(20, 30)\t     << \"\\n\";  // outputs 10} vl d_and_c(vl v, vi sorted_vals) {\t// dbg(\"HI\", v, sorted_vals);\tassert(sz(v));\tvl prefs{0};\teach(t, sorted_vals) prefs.pb(prefs.bk + t);\tvl nv(sz(v) + sz(sorted_vals), BIG);\ty_combinator([&](auto fill_ans, int l, int r, int cl, int cr) -> void {\t\tif (l > r) return;\t\tint m = (l + r) / 2;\t\tint cl_adjust = max(cl, m - sz(prefs) + 1);\t\tint cr_adjust = min(cr, m);\t\tassert(cl_adjust <= cr_adjust);\t\tint best = cl_adjust;\t\tFOR(i, cl_adjust, cr_adjust + 1) {\t\t\tif (ckmin(nv[m], v[i] + prefs[m - i])) best = i;\t\t}\t\tassert(best != -1);\t\tfill_ans(l, m - 1, cl, best);\t\tfill_ans(m + 1, r, best, cr);\t})(0, sz(nv) - 1, 0, sz(v) - 1);\treturn nv;} vl transition(int cur, int ncur, int start, vl orig, vi vals) {\tassert(sz(orig));\tassert(ncur - cur == sz(vals));\tpi special_range{ncur / 2 - sz(vals) + 1, ncur / 2 - 1};\tvi sorted_vals;\teach(t, vals) if (t != -1) sorted_vals.pb(t);\tsor(sorted_vals);\tvl ret(sz(orig) + sz(vals), BIG);\tint num_el_start = 0, num_el_end = 0;\t// dbg(\"START\", cur, ncur, start, orig, vals);\tif (start < special_range.f) {\t\tnum_el_start = min(sz(orig), special_range.f - start);\t\tauto cand =\t\t    d_and_c(vl(begin(orig), begin(orig) + num_el_start), sorted_vals);\t\tF0R(i, sz(cand)) ckmin(ret.at(i), cand.at(i));\t\t// dbg(\"CASE A\");\t}\tif (special_range.s < start + sz(orig) - 1) {\t\tnum_el_end = min(sz(orig), start + sz(orig) - 1 - special_range.s);\t\tauto cand = d_and_c(vl(end(orig) - num_el_end, end(orig)), sorted_vals);\t\tint offset = sz(orig) - num_el_end + sz(vals) - sz(sorted_vals);\t\tF0R(i, sz(cand)) ckmin(ret.at(i + offset), cand.at(i));\t\tR0F(i, sz(ret) - 1) ckmin(ret.at(i), ret.at(i + 1));\t\t// dbg(\"CASE B\");\t}\tassert(num_el_start + num_el_end <= sz(orig));\tif (num_el_start + num_el_end < sz(orig)) {\t\tassert(cur + 1 < ncur);\t\tvl orig_mid(num_el_start + all(orig) - num_el_end);\t\tint half = (ncur - cur) / 2;\t\tint mcur = cur + half;\t\tint mstart = start + num_el_start;\t\torig_mid = transition(cur, mcur, mstart, orig_mid,\t\t                      vi(begin(vals), begin(vals) + half));\t\torig_mid =\t\t    transition(mcur, ncur, mstart, orig_mid, vi(half + all(vals)));\t\tF0R(i, sz(orig_mid)) ckmin(ret.at(i + num_el_start), orig_mid.at(i));\t\t// dbg(\"CASE C\");\t}\t// dbg(\"TRANSITION\", cur, ncur, start, orig, vals, ret);\treturn ret;} vl solve_smart(vi A) {\tint N = sz(A);\tauto ans = transition(0, N, 0, {0}, A);\treturn ans;} void solve(int tc) {\tdef(int, N);\tvi A(N);\tre(A);\tauto ans = solve_smart(A);\tps(ans);} int main() {\tsetIO();\tint TC;\tre(TC);\tFOR(i, 1, TC + 1) solve(i);} /* stuff you should look for * int overflow, array bounds * special cases (n=1?) * do smth instead of nothing and stay organized * WRITE STUFF DOWN * DON'T GET STUCK ON ONE APPROACH */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\I. Kevin and Nivek.json",
    "hint": [
        "Hint 1 Can you compute from efficiently?",
        "Hint 2 If the difference between the number of victories is large, he will either always win or always lose for type 2 matches.",
        "Hint 3 We can speed up this part to .",
        "Hint 4 For the part that the difference between the number of victories is not large, solve it recursively."
    ]
}