{
    "link": "https://codeforces.com//contest/1586/problem/G",
    "problemId": "1147387",
    "problem_idx": "G",
    "shortId": "1586G",
    "contest_number": "1586",
    "problem_submissions": {
        "I": [
            132349267,
            132252923,
            132320064,
            132673395,
            132289506,
            132263256
        ],
        "H": [
            132247560,
            132253721,
            134930470,
            132350321,
            132254025,
            132660661,
            132275048,
            132253966,
            132270155
        ],
        "G": [
            132239647,
            132244340,
            132241119,
            135794866,
            135794713,
            132234650,
            132248115,
            132244256,
            132257761,
            132255193,
            132256199,
            132255919,
            132258648,
            132257515,
            132250742,
            132255333,
            132257553,
            132255311
        ],
        "F": [
            132231955,
            132236161,
            132234366,
            132240633,
            132243967,
            132235859,
            132234337,
            132237395,
            132239493,
            132241376,
            132248866,
            132245654,
            132241416,
            132246161,
            132245018,
            132259456,
            132244979,
            132249686,
            132260019,
            132238761
        ],
        "E": [
            132228491,
            132224206,
            132228693,
            132232413,
            132231532,
            132229745,
            132230672,
            132232315,
            132218494,
            132235319,
            132232020,
            132237413,
            132239524,
            132237023,
            132236410,
            132236319,
            132238669,
            132240928,
            132230421,
            132229492
        ],
        "D": [
            132225001,
            132227375,
            132224444,
            132226879,
            132227724,
            132226231,
            132226626,
            132227371,
            132224235,
            132227654,
            132224635,
            132229641,
            132234990,
            132231067,
            132230536,
            132228432,
            132234258,
            132232998,
            132241147,
            132223955
        ],
        "C": [
            132221243,
            132218519,
            132219460,
            132219748,
            132219799,
            132222571,
            132220819,
            132219850,
            132232802,
            132223481,
            132218757,
            132219927,
            132230956,
            132218216,
            132224263,
            132222192,
            132227273,
            132228072,
            132226595,
            132220025
        ],
        "B": [
            132214722,
            132213701,
            132215490,
            132214516,
            132214317,
            132214601,
            132215162,
            132222197,
            132229955,
            132216968,
            132214347,
            132216468,
            132226751,
            132220812,
            132216772,
            132216742,
            132216324,
            132213579,
            132217316,
            132213929
        ],
        "A": [
            132213139,
            132213078,
            132214020,
            132213141,
            132213243,
            132213267,
            132213377,
            132220659,
            132228179,
            132218691,
            132213234,
            132214356,
            132213033,
            132224973,
            132214120,
            132214349,
            132213337,
            132213011,
            132242338,
            132213128
        ]
    },
    "name": "G. Omkar and Time Travel",
    "statement": "Omkar is watching .In , Okabe Rintarou needs to complete n tasks (1\r\nleq n\r\nleq 2\r\ncdot 10^5). Unfortunately, he doesn\u2019t know when he needs to complete the\r\ntasks.Initially, the time is 0. Time travel will now happen according to\r\nthe following rules:For each k = 1, 2,\r\nldots, n, Okabe will realize at time b_k that he was supposed to\r\ncomplete the k-th task at time a_k (a_k < b_k). When he realizes this,\r\nif k-th task was already completed at time a_k, Okabe keeps the usual\r\nflow of time. Otherwise, he time travels to time a_k then immediately\r\ncompletes the task.If Okabe time travels to time a_k, all tasks\r\ncompleted after this time will become incomplete again. That is, for\r\nevery j, if a_j>a_k, the j-th task will become incomplete, if it was\r\ncomplete (if it was incomplete, nothing will change).Okabe has bad\r\nmemory, so he can time travel to time a_k getting to time b_k and\r\nlearning that he was supposed to complete the k-th task at time a_k.\r\nThat is, even if Okabe already had to perform k-th task before, he\r\nwouldn\u2019t remember it before stumbling on the info about this task at\r\ntime b_k again.Please refer to the notes for an example of time\r\ntravelling.There is a certain set s of tasks such that the first moment\r\nthat all of the tasks in s are simultaneously completed (regardless of\r\nwhether any other tasks are currently completed), a funny scene will\r\ntake place. Omkar loves this scene and wants to know how many times\r\nOkabe will time travel before this scene takes place. Find this number\r\nmodulo 10^9 + 7. It can be proven that eventually all n tasks will be\r\ncompleted and so the answer always exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nstruct fwt\n{\n\tint dat[400005];\n\tvoid add(int id, int val)\n\t{\n\t\tfor(; id > 0; id -= id & -id) dat[id] = (dat[id] + val) % MOD;\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\tfor(; id <= 400000; id += id & -id) ret = (ret + dat[id]) % MOD;\n\t\treturn ret;\n\t}\n}tre;\nint n, t, b[200005], dp[200005];\nPII dat[200005];\nbool nd[200005];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &dat[i].second, &dat[i].first); b[i] = dat[i].first;\n\t}\n\tsort(dat, dat + n);\n\tscanf(\"%d\", &t);\n\trep(i, t) {\n\t\tint x; scanf(\"%d\", &x);\n\t\tnd[lower_bound(dat, dat + n, MP(b[x - 1], 0)) - dat] = true;\n\t}\n\t\n\ttre.add(2 * n, 1);\n\trep(i, n) {\n\t\tdp[i] = tre.query(dat[i].second);\n\t\ttre.add(dat[i].second, dp[i]);\n\t}\n\t\n\tint pv = 1, ans = 0;\n\tfor(int i = n - 1; i >= 0; i --) {\n\t\ttre.add(dat[i].second, (MOD - dp[i]) % MOD);\n\t\tif(nd[i] && dat[i].second >= pv) {\n\t\t\tans = (ans + tre.query(pv)) % MOD;\n\t\t\tpv = dat[i].second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\G. Omkar and Time Travel.json",
    "editorial_link": "https://codeforces.com//blog/entry/96072",
    "editorial": "Each time travel that Okabe performs creates a new set of completed\r\ntasks. We will take this as given, but it can be proven using ideas from\r\nthe rest of the proof.It thus suffices to count the number of distinct\r\nsets of task that come before the first one that contains as a subset.\r\nWe should first figure out what kinds of sets will ever appear as a set\r\nof completed tasks at all; we will call these sets valid.We will\r\nrepresent tasks below as intervals .First note that clearly not all sets\r\nare valid. If you have the intervals and , clearly the set is not a\r\nvalid set. You can actually see that the same is true for the intervals\r\nand ( is not a valid set) by working through Okabe\u00e2\u0080\u0099s activities.This\r\ngeneralizes in a very important way: if there are two intervals and with\r\nand , then any valid set that contains must also contain . This is\r\nbecause if is reached to complete the task , then will already have been\r\nreached to complete the task (since ), and any time travel that undoes\r\nmust also undo (since ).The above property is actually equivalent to\r\nbeing a valid set; we have already seen that it is necessary, and from\r\nthe next part of the tutorial we will have way to prove that it is\r\nsufficient, but you should have some intuition for why this is true.In\r\norder to solve the problem, we want to think about how to determine,\r\ngiven two valid sets, which one Okabe will encounter first. First, for\r\nany two valid sets, consider their last interval (i. e. interval with\r\ngreatest value of ). If these are different, then the one with largest\r\ninterval having greater will come later.This is because for any valid\r\nset, the largest value of in any interval in that set is equal to the\r\nlargest value of that Okabe has ever encountered. You can see this by\r\nnoticing that the only way to undo a task is to perform a task with\r\ngreater value of ; any task with smaller is either contained inside the\r\nfirst task, in which case it won\u00e2\u0080\u0099t undo it, or also has a smaller value\r\nof , in which case by the above property of valid sets it must already\r\nbe completed.Since the maximum value of that Okabe has ever encountered\r\nwill only get larger as his activities continue, it follows that the\r\nvalid set with larger maximum value of must occur later.We can further\r\nsee that for any two valid sets where the interval with largest is\r\nequal, we can discard that interval and consider the next largest\r\ninterval from both valid sets.This gives us an ordering of the valid\r\nsets. We can prove that the aformentioned property is sufficient for\r\nbeing a valid set by showing that at any valid set, the next valid set\r\nencountered is the immediately next one in the ordering. The details are\r\nleft to the reader.In order to use this to finally solve the problem, it\r\nis useful to represent valid sets in a different way. Specifically, we\r\ncan represent a valid set as the set of intervals that aren\u00e2\u0080\u0099t implied to\r\nbe in by any other element of . By thinking about the above property,\r\nyou can see that is actually a set of recursively containing intervals;\r\ni. e. it contains an interval, then another interval inside that one,\r\nthen another interval inside one, etc.We will consider the above\r\nrepresentation to be ordered, so that the last interval is the one that\r\ncontains all the others, and the first interval is the one inside of all\r\nthe others.We can now solve the problem. For the given set , first\r\ndetermine its above representation; this can be done easily using\r\nsorting, discarding any redundant interval. The valid sets, also in\r\ntheir above representation, that come before are thus the ones that,\r\nexcluding their common suffix with , have a last interval whose is\r\nsmaller than the for the last interval in excluding the common suffix.We\r\ncan therefore solve this as follows. We will count the number of above\r\nsets for each possible common suffix. For each suffix, let the last\r\ninterval in not included in the suffix be , and let the first interval\r\nin the suffix be . The amount of sets for this suffix is equal to the\r\namount of recursively containing sets that have a largest interval that\r\nis contained in whose value of is less than the value of for .We can\r\ncompute this follows. We will maintain a range sum query data structure\r\nsuch as binary index tree. The data structure will have at each , the\r\nnumber of recursively containing subsets whose largest interval is the\r\none with that (once that interval has been processed). We will process\r\nthe intervals in increasing order of .For each interval , to put it into\r\nthe data structure, we can simply perform a range query of literally the\r\ninterval , and add to the result. That will be equal to the number of\r\nrecursively containing sets with as the largest interval, so we simply\r\ninsert that into the data structure at the value of of .Before putting\r\ninto the data structure, if it is in the representation of , then we can\r\nfind the answer for the suffix of that contains all intervals to the\r\nright of as follows. Since the intervals currently in the data structure\r\nare precisely the ones with value of less than , the answer for that\r\nsuffix is simply the range query of where is the immediately next\r\ninterval after in . We therefore perform this range query then add it to\r\nour answer.Note that all of this computation doesn\u00e2\u0080\u0099t count itself, but\r\nit does count the empty set which doesn\u00e2\u0080\u0099t need to be counted, so our\r\nanswer is correct.The runtime of this solution is .\r\n"
}