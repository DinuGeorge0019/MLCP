{"link": "https://codeforces.com//contest/1586/problem/G", "problemId": "1147387", "problem_idx": "G", "shortId": "1586G", "contest_number": "1586", "problem_submissions": {"I": [132349267, 132252923, 132320064, 132673395, 132289506, 132263256], "H": [132247560, 132253721, 134930470, 132350321, 132254025, 132660661, 132275048, 132253966, 132270155], "G": [132239647, 132244340, 132241119, 135794866, 135794713, 132234650, 132248115, 132244256, 132257761, 132255193, 132256199, 132255919, 132258648, 132257515, 132250742, 132255333, 132257553, 132255311], "F": [132231955, 132236161, 132234366, 132240633, 132243967, 132235859, 132234337, 132237395, 132239493, 132241376, 132248866, 132245654, 132241416, 132246161, 132245018, 132259456, 132244979, 132249686, 132260019, 132238761], "E": [132228491, 132224206, 132228693, 132232413, 132231532, 132229745, 132230672, 132232315, 132218494, 132235319, 132232020, 132237413, 132239524, 132237023, 132236410, 132236319, 132238669, 132240928, 132230421, 132229492], "D": [132225001, 132227375, 132224444, 132226879, 132227724, 132226231, 132226626, 132227371, 132224235, 132227654, 132224635, 132229641, 132234990, 132231067, 132230536, 132228432, 132234258, 132232998, 132241147, 132223955], "C": [132221243, 132218519, 132219460, 132219748, 132219799, 132222571, 132220819, 132219850, 132232802, 132223481, 132218757, 132219927, 132230956, 132218216, 132224263, 132222192, 132227273, 132228072, 132226595, 132220025], "B": [132214722, 132213701, 132215490, 132214516, 132214317, 132214601, 132215162, 132222197, 132229955, 132216968, 132214347, 132216468, 132226751, 132220812, 132216772, 132216742, 132216324, 132213579, 132217316, 132213929], "A": [132213139, 132213078, 132214020, 132213141, 132213243, 132213267, 132213377, 132220659, 132228179, 132218691, 132213234, 132214356, 132213033, 132224973, 132214120, 132214349, 132213337, 132213011, 132242338, 132213128]}, "name": "G. Omkar and Time Travel", "statement": "Omkar is watching .In , Okabe Rintarou needs to complete n tasks (1\r\nleq n\r\nleq 2\r\ncdot 10^5). Unfortunately, he doesn\u2019t know when he needs to complete the\r\ntasks.Initially, the time is 0. Time travel will now happen according to\r\nthe following rules:For each k = 1, 2,\r\nldots, n, Okabe will realize at time b_k that he was supposed to\r\ncomplete the k-th task at time a_k (a_k < b_k). When he realizes this,\r\nif k-th task was already completed at time a_k, Okabe keeps the usual\r\nflow of time. Otherwise, he time travels to time a_k then immediately\r\ncompletes the task.If Okabe time travels to time a_k, all tasks\r\ncompleted after this time will become incomplete again. That is, for\r\nevery j, if a_j>a_k, the j-th task will become incomplete, if it was\r\ncomplete (if it was incomplete, nothing will change).Okabe has bad\r\nmemory, so he can time travel to time a_k getting to time b_k and\r\nlearning that he was supposed to complete the k-th task at time a_k.\r\nThat is, even if Okabe already had to perform k-th task before, he\r\nwouldn\u2019t remember it before stumbling on the info about this task at\r\ntime b_k again.Please refer to the notes for an example of time\r\ntravelling.There is a certain set s of tasks such that the first moment\r\nthat all of the tasks in s are simultaneously completed (regardless of\r\nwhether any other tasks are currently completed), a funny scene will\r\ntake place. Omkar loves this scene and wants to know how many times\r\nOkabe will time travel before this scene takes place. Find this number\r\nmodulo 10^9 + 7. It can be proven that eventually all n tasks will be\r\ncompleted and so the answer always exists.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nstruct fwt\n{\n\tint dat[400005];\n\tvoid add(int id, int val)\n\t{\n\t\tfor(; id > 0; id -= id & -id) dat[id] = (dat[id] + val) % MOD;\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\tfor(; id <= 400000; id += id & -id) ret = (ret + dat[id]) % MOD;\n\t\treturn ret;\n\t}\n}tre;\nint n, t, b[200005], dp[200005];\nPII dat[200005];\nbool nd[200005];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &dat[i].second, &dat[i].first); b[i] = dat[i].first;\n\t}\n\tsort(dat, dat + n);\n\tscanf(\"%d\", &t);\n\trep(i, t) {\n\t\tint x; scanf(\"%d\", &x);\n\t\tnd[lower_bound(dat, dat + n, MP(b[x - 1], 0)) - dat] = true;\n\t}\n\t\n\ttre.add(2 * n, 1);\n\trep(i, n) {\n\t\tdp[i] = tre.query(dat[i].second);\n\t\ttre.add(dat[i].second, dp[i]);\n\t}\n\t\n\tint pv = 1, ans = 0;\n\tfor(int i = n - 1; i >= 0; i --) {\n\t\ttre.add(dat[i].second, (MOD - dp[i]) % MOD);\n\t\tif(nd[i] && dat[i].second >= pv) {\n\t\t\tans = (ans + tre.query(pv)) % MOD;\n\t\t\tpv = dat[i].second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "math"], "dificulty": "3000", "interactive": false}