{
    "link": "https://codeforces.com//contest/1942/problem/E",
    "problemId": "2562662",
    "problem_idx": "E",
    "shortId": "1942E",
    "contest_number": "1942",
    "problem_submissions": {
        "H": [
            254183902,
            254188108,
            254201851,
            254183582,
            254190002,
            254198277,
            254202464,
            254201777
        ],
        "G": [
            254162531,
            254164622,
            254151822,
            254172554,
            254170602,
            254147291,
            254169050,
            254165219,
            254167927,
            254162501,
            254160773,
            254158971,
            254158358,
            254162939,
            254174812,
            254166519,
            254160779,
            254190901,
            254172694
        ],
        "F": [
            254158172,
            254152768,
            254191293,
            254157909,
            254159055,
            254161327,
            254156776,
            254157963,
            254160983,
            254169304,
            254173612,
            254173846,
            254172970,
            254168440,
            254167804,
            254178450,
            254203408,
            254180148,
            254161110,
            254162666
        ],
        "E": [
            254144668,
            254141645,
            254144010,
            254144661,
            254150949,
            254131679,
            254143965,
            254147690,
            254143510,
            254152706,
            254144759,
            254152214,
            254138579,
            254146127,
            254149515,
            254151573,
            254147613,
            254146631,
            254149743
        ],
        "D": [
            254140034,
            254136242,
            254134735,
            254138534,
            254140561,
            254139068,
            254133778,
            254140913,
            254137432,
            254142449,
            254137105,
            254142252,
            254145710,
            254140092,
            254138595,
            254139592,
            254140216,
            254137967,
            254143121
        ],
        "C1": [
            254131817,
            254128192,
            254204108,
            254125718,
            254128016,
            254124090,
            254123140,
            254122427,
            254125306,
            254127382,
            254129295,
            254126939,
            254129179,
            254122148,
            254134385,
            254126328,
            254132572,
            254129060,
            254125449,
            254134104
        ],
        "C2": [
            254131346,
            254132277,
            254203957,
            254203739,
            254128200,
            254133096,
            254129236,
            254126373,
            254125814,
            254128450,
            254131487,
            254132145,
            254131700,
            254133377,
            254130111,
            254134317,
            254129340,
            254132361,
            254129276,
            254129577,
            254134556
        ],
        "B": [
            254123310,
            254123064,
            254120037,
            254123258,
            254119059,
            254120381,
            254119896,
            254118664,
            254120410,
            254124572,
            254120489,
            254125154,
            254128773,
            254119724,
            254122914,
            254121539,
            254119687,
            254120045,
            254122462
        ],
        "A": [
            254117704,
            254118878,
            254117338,
            254117275,
            254117327,
            254117266,
            254117244,
            254117366,
            254117469,
            254117281,
            254117396,
            254117230,
            254117295,
            254117454,
            254117450,
            254117301,
            254117455,
            254117981
        ]
    },
    "name": "E. Farm Game",
    "statement": "Farmer Nhoj has brought his cows over to Farmer John’s farm to play a\r\ngame! FJ’s farm can be modeled by a number line with walls at points 0\r\nand l + 1. On the farm, there are 2n cows, with n of the cows belonging\r\nto FJ and the other n belonging to FN. They place each of their cows at\r\na distinct point, and no two FJ’s cows nor FN’s cows are adjacent. Two\r\ncows are adjacent if there are no other cows between them. Formally, if\r\na_1, a_2,\r\nldots, a_n represents the positions of FJ’s cows and b_1, b_2,\r\nldots, b_n represents the positions of FN’s cows, then either 0 < a_1 <\r\nb_1 < a_2 < b_2 <\r\nldots < a_n < b_n < l + 1 or 0 < b_1 < a_1 < b_2 < a_2 <\r\nldots < b_n < a_n < l + 1.In one move, a farmer chooses a number k (1\r\nleq k\r\nleq n) and a direction (left or right). Then, that farmer chooses k of\r\nhis cows and moves them one position towards the chosen direction. A\r\nfarmer cannot move any of his cows onto the walls or onto another\r\nfarmer’s cow. If a farmer cannot move any cows, then that farmer loses.\r\nFJ starts the game, making the first turn.Given l and n, find the number\r\nof possible game configurations for Farmer John to win if both farmers\r\nplay optimally. It may be the case that the game will continue\r\nindefinitely, in which no farmer wins. A configuration is different from\r\nanother if there is any i such that a_i or b_i is different. Output the\r\nanswer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\nbool dbg=false;\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\nusing vvi=vc<vc<int>>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\nstring rand_string(int n,char lw,char up){\n\tstring s(n,'?');\n\trep(i,n)s[i]=rand_int(lw,up);\n\treturn s;\n}\n\nint current_run_id,run_batch_size=1000;\nint calc_random_limit(){\n\treturn current_run_id/run_batch_size+1;\n}\ntemplate<class t>\nvoid generate_single(t&a){\n\ta=rand_int(1,calc_random_limit());\n}\nvoid generate_single(string&a){\n\tint n;generate_single(n);\n\ta=rand_string(n,'a','b');\n}\ntemplate<class t,class u>\nvoid generate_single(pair<t,u>&a){\n\tgenerate_single(a.a);\n\tgenerate_single(a.b);\n}\n//https://trap.jp/post/1224/\ntemplate<class... Args>\nvoid input(Args&... a){\n\tif(dbg){\n\t\t(generate_single(a),...);\n\t}else{\n\t\t(cin >> ... >> a);\n\t}\n}\n#define INT(...) int __VA_ARGS__;input(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;input(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;input(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;input(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;input(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;input(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;input(__VA_ARGS__)\n#define overload3(a,b,c,d,...) d\n#define VI2(name,size) vi name(size);rep(i_##name,size)input(name[i_##name]);\n#define VI3(name,size,offset) vi name(size);rep(i_##name,size)input(name[i_##name]),name[i_##name]+=offset;\n#define VI(...) overload3(__VA_ARGS__,VI3,VI2)(__VA_ARGS__)\n#define VPI(name,size) vc<pi> name(size);rep(i_##name,size)input(name[i_##name]);\n#define VVI(name,sizeN,sizeM) vvi name(sizeN,vi(sizeM));\\\nrep(i_##name,sizeN)rep(j_##name,sizeM)input(name[i_##name][j_##name]);\n\n#define VVT(type,name,sizeN,sizeM) vvc<type> name(sizeN,vc<type>(sizeM));\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1){\n\t\tif(dbg)cout<<endl;\n\t\telse cout<<\"\\n\";\n\t}\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\ntemplate<class T>\nvoid printvv(const vvc<T>&vs){\n\tfor(const auto&row:vs)print(row);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class S> void mkuni(S&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t> bool isuni(vc<t> v){\n\tint s=si(v);\n\tmkuni(v);\n\treturn si(v)==s;\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class S,class u>\nint lwb(const S&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\n//VERIFY: yosupo\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tvoid clear(){\n\t\tfill(all(p),-1);\n\t\tfill(all(s),1);\n\t\tc=si(p);\n\t}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\tif(dbg){\n\t\tvvc<int> t(n);\n\t\tunionfind uf(n);\n\t\twhile(uf.c>1){\n\t\t\tint a=rand_int(n);\n\t\t\tint b=rand_int(n);\n\t\t\tif(uf.unite(a,b)){\n\t\t\t\tt[a].pb(b);\n\t\t\t\tt[b].pb(a);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}else{\n\t\treturn readGraph(n,n-1);\n\t}\n}\n\nvoid printTree(const vvc<int> t){\n\tint n=si(t);\n\tint degsum=0;\n\trep(i,n)degsum+=si(t[i]);\n\tif(degsum==n-1){\n\t\t//directed\n\t\trep(i,si(t))for(auto j:t[i]){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else if(degsum==2*(n-1)){\n\t\t//undirected\n\t\trep(i,si(t))for(auto j:t[i])if(i<j){\n\t\t\tprint(i+1,j+1);\n\t\t}\n\t}else{\n\t\tassert(false);\n\t}\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\ntemplate<class t,class u,class v>\npair<t,u>&operator*=(pair<t,u>&a,v b){\n\ta.a*=b;a.b*=b;return a;}\ntemplate<class t,class u,class v>\npair<t,u> operator*(pair<t,u> a,v b){return a*=b;}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a){return mp(-a.a,-a.b);}\nnamespace std{\ntemplate<class t,class u>\nistream&operator>>(istream&is,pair<t,u>&a){\n\treturn is>>a.a>>a.b;\n}\n}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator*=(vc<t>&a,u x){\n\tfor(auto&v:a)v*=x;\n\treturn a;\n}\ntemplate<class t,class u>\nvc<t>& operator*(vc<t> a,u x){\n\treturn a*=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n//消した要素の個数を返してくれる\n//UCUP 2-8-F\ntemplate<class t,class F>\nint remif(vc<t>&a,F f){\n\tauto itr=remove_if(all(a),f);\n\tint res=a.ed-itr;\n\ta.erase(itr,a.ed);\n\treturn res;\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//Multiuni2023-8 C\n//f(lw)=false,...,f(n-1)=false,f(n)=true,...,f(up)=true,\n//のときに n を返す\ntemplate<class F>\nint find_min_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))up=mid;\n\t\telse lw=mid;\n\t}\n\treturn up;\n}\n//f(lw)=true,f(up)=false\ntemplate<class F>\nint find_max_true(int lw,int up,F f){\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(f(mid))lw=mid;\n\t\telse up=mid;\n\t}\n\treturn lw;\n}\n\ntemplate<class t> using pqmin=priority_queue<t,vc<t>,greater<t>>;\ntemplate<class t> using pqmax=priority_queue<t>;\nusing T=tuple<int,int,int>;\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,1689685080};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//対角線を超えず (x,y) に至る方法の数\nmint catalan(int x,int y){\n\tassert(y<=x);\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n//y=x+c を超えず (x,y) に至る方法の数\nmint catalan(int x,int y,int c){\n\tassert(y<=x+c);\n\treturn binom(x,y)-binom(x+c+1,y-c-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nvoid slv(){\n\tINT(l,n);\n\tl++;\n\tl-=2*n+1;\n\t\n\tmint ans=0;\n\trep(u,l/2+1){\n\t\tans+=binom(u,n-1)*binom(l-u*2,n);\n\t}\n\tans=binom(l,2*n)-ans;\n\tprint(ans*2);\n}\n\nsigned main(signed argc,char*argv[]){\n\tif(argc>1&&strcmp(argv[1],\"D\")==0)dbg=true;\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tif(dbg){\n\t\twhile(1){\n\t\t\tif(current_run_id%run_batch_size==0){\n\t\t\t\tcerr<<\"Current Run \"<<current_run_id<<endl;\n\t\t\t}\n\t\t\tslv();\n\t\t\tcurrent_run_id++;\n\t\t}\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "games",
        "math"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\E. Farm Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/126942",
    "editorial": "Problem Credits: cry Analysis: sum SolutionConsider the gaps between .\r\nIn the example below, ” represents FJ’s cow, ” represents FN’s cow, and\r\n” represents an empty space. The gaps are . Consider the gaps . When a\r\nfarmer moves, they choose some non-empty subset of non-zero and add or\r\nsubtract from every element in the subset (so long such move is\r\npossible). The game ends when some farmer cannot move (which implies\r\nthat all must be when the game ends).WLOG let the first cow be FJ’s cow.\r\nThe winner of the game is determined as follows:1) If all are even, then\r\nFN wins. If FJ pushes the cows corresponding to gaps some direction in a\r\nmove, then will change by and become odd. FN can then push the cows\r\ncorresponding to gaps left so that will become even again. Therefore,\r\nall will be even when it’s FJ’s turn and at least one will be odd when\r\nit’s FN’s turn. Since the game ends when all are (which is even), then\r\nFJ will lose. Note that the game will always end. This is since the sum\r\nof positions of FN’s cows will always be decreasing since FN will always\r\npush some cow left.2) Otherwise, FJ wins since he can subtract to all\r\nodd in his first move to make all elements even. Then it’s FN’s turn and\r\nall are even so by the reasoning above, FJ wins.Let’s use complementary\r\ncounting and determine the number of ways FN wins (which is when all are\r\neven). We can iterate over the sum, ( is even), of all . At each , we\r\ncan use stars and bars to find how many such (all are even) sum to .\r\nSpecifically, the number of ways are . The number of ways to place the\r\ncows in the available positions given the gaps will be . We multiply by\r\nsince we can alternate starting with either FJ’s cow or FN’s cow.\r\nFinally, we subtract this result from the total number of\r\nconfigurations, , to get the number of ways FJ wins. This runs in time.\r\n",
    "hint": [
        "Hint 1 Think about the gaps between . Let the gaps be . What effect do the moves have on the gaps?",
        "Hint 2 WLOG let the first cow be FJ's cow. FN wins if all are even. Otherwise FJ wins. Note that the game will always end.",
        "Hint 3 Try to count the number of ways FN wins. We can iterate over the sum of and use stars and bars as well as other counting techniques."
    ]
}