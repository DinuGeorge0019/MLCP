{
    "link": "https://codeforces.com//contest/1530/problem/C",
    "problemId": "1049170",
    "problem_idx": "C",
    "shortId": "1530C",
    "contest_number": "1530",
    "problem_submissions": {
        "H": [
            122851665,
            122838743,
            122844195,
            122849012,
            122871696,
            122848567,
            122889728
        ],
        "G": [
            122840209,
            122852256,
            122900209,
            122846129,
            122844934,
            122847648,
            122853646,
            122874899,
            122880351,
            122921209
        ],
        "F": [
            122810446,
            122819713,
            122812617,
            122825773,
            122868869,
            122809297,
            122821188,
            122827035,
            122824965,
            122821818,
            122829815,
            122826847,
            122822005,
            122826789,
            122826175,
            122826918,
            122836373,
            122830797,
            122814894,
            122838442,
            122834199
        ],
        "E": [
            122803663,
            122805810,
            122805166,
            122812311,
            122817063,
            122814296,
            122807127,
            122808379,
            122800583,
            122808253,
            122808203,
            122811232,
            122807495,
            122807208,
            122811521,
            122828022,
            122805125,
            122810921
        ],
        "D": [
            122791676,
            122796247,
            122793005,
            122795921,
            122795213,
            122793368,
            122796651,
            122796980,
            122803859,
            122791210,
            122799331,
            122796501,
            122797048,
            122796533,
            122791355,
            122798720,
            122801973,
            122792843,
            122800740
        ],
        "C": [
            122785861,
            122787673,
            122786660,
            122785034,
            122784856,
            122787839,
            122786985,
            122784250,
            122795439,
            122782668,
            122786465,
            122789088,
            122786999,
            122788656,
            122784366,
            122787966,
            122789017,
            122785054,
            122790340
        ],
        "B": [
            122781549,
            122782427,
            122782526,
            122782097,
            122782078,
            122780831,
            122781690,
            122789087,
            122786285,
            122785455,
            122781801,
            122781479,
            122782615,
            122783296,
            122794583,
            122783767,
            122783971,
            122780469,
            122782275
        ],
        "A": [
            122775440,
            122775417,
            122775273,
            122775738,
            122775580,
            122775190,
            122775752,
            122790605,
            122781313,
            122775806,
            122775746,
            122775311,
            122776001,
            122775468,
            122776055,
            122775938,
            122777214,
            122775025,
            122775038
        ]
    },
    "name": "C. Pursuit",
    "statement": "You and your friend Ilya are participating in an individual programming\r\ncontest consisting of multiple stages. A contestant can get between 0\r\nand 100 points, inclusive, for each stage, independently of other\r\ncontestants.Points received by contestants in different stages are used\r\nfor forming overall contest results. Suppose that k stages of the\r\ncontest are completed. For each contestant, k -\r\nlfloor\r\nfrac{k}{4}\r\nrfloor stages with the highest scores are selected, and these scores are\r\nadded up. This sum is the overall result of the contestant. (Here\r\nlfloor t\r\nrfloor denotes rounding t down.)For example, suppose 9 stages are\r\ncompleted, and your scores are 50, 30, 50, 50, 100, 10, 30, 100, 50.\r\nFirst, 7 stages with the highest scores are chosen for example, all\r\nstages except for the 2-nd and the 6-th can be chosen. Then your overall\r\nresult is equal to 50 + 50 + 50 + 100 + 30 + 100 + 50 = 430.As of now, n\r\nstages are completed, and you know the points you and Ilya got for these\r\nstages. However, it is unknown how many more stages will be held. You\r\nwonder what the smallest number of additional stages is, after which\r\nyour result might become greater than or equal to Ilya’s result, at\r\nleast in theory. Find this number!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        std::vector<int> a(n), b(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n        for (int i = 0; i < n; i++) {\n            std::cin >> b[i];\n        }\n        std::sort(a.begin(), a.end(), std::greater<>());\n        std::sort(b.begin(), b.end(), std::greater<>());\n        \n        std::vector<i64> sa(n + 1), sb(n + 1);\n        for (int i = 0; i < n; i++) {\n            sa[i + 1] = sa[i] + a[i];\n            sb[i + 1] = sb[i] + b[i];\n        }\n        \n        int lo = 0, hi = 1e7;\n        while (lo < hi) {\n            int k = (lo + hi) / 2;\n            \n            int m = (n + k) - (n + k) / 4;\n            int ca, cb;\n            if (m <= k) {\n                ca = 100 * m;\n            } else {\n                ca = 100 * k + sa[m - k];\n            }\n            cb = sb[std::min(n, m)];\n            \n            if (ca >= cb) {\n                hi = k;\n            } else {\n                lo = k + 1;\n            }\n        }\n        \n        std::cout << lo << \"\\n\";\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\C. Pursuit.json",
    "editorial_link": "https://codeforces.com//blog/entry/92951",
    "editorial": "The first thing to notice is that since weâre chasing Ilya and we want\r\nto reach his score as soon as possible, it only makes sense to add âs to\r\nour scores and âs to his.We can also notice that the answer never\r\nexceeds . No matter how bad a stage is for us in terms of points, adding\r\na single stage where we score and Ilya scores \"compensates\" it. In\r\nparticular, in the worst case, when all and all , the answer is exactly\r\n.However, if we just add the stages one-by-one and calculate the overall\r\nresults from scratch every time, our solution will have complexity and\r\nthatâs too much.There are many ways to optimize the solution.One of them\r\nis to transform the given and arrays into arrays of length , containing\r\nthe count of each score (since we are not interested in the order of the\r\nscores). Let be the maximum achievable score in a stage. Using the\r\ntransformed arrays, we can calculate the overall scores in instead of ,\r\nto lower the final complexity to .Alternatively, notice that when we add\r\nto our scores, it just adds to our overall score except for the case\r\nwhen the total number of completed stages becomes divisible by , when we\r\nalso need to subtract the score of the worst currently included stage\r\nfrom the sum. We can similarly handle adding to Ilyaâs scores. If we\r\nsort all our and Ilyaâs scores at the beginning and maintain a pointer\r\nto the current worst included stage in both scoresheets, we can add a\r\nnew stage and recalculate the totals in .Finally, we can also notice\r\nthat whenever adding stages works for us, adding stages will work too.\r\nThus, we can use binary search on . We can easily check a single value\r\nof in or , resulting in or time complexity.\r\n",
    "hint": []
}