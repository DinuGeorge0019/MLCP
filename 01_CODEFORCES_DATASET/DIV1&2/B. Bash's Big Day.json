{
    "link": "https://codeforces.com//contest/757/problem/B",
    "problemId": "88529",
    "problem_idx": "B",
    "shortId": "757B",
    "contest_number": "757",
    "problem_submissions": {
        "F": [
            32228238,
            32220657,
            32216667,
            32216552,
            30180757,
            24068926,
            24068888,
            24068798,
            24068629,
            24068020,
            23762892,
            23760952,
            23776891,
            23764568,
            23762696,
            23763271,
            23761197,
            23764419,
            23761836,
            23846483,
            23765505,
            23762407,
            23766587,
            23766646,
            23767253,
            23767207,
            23767008,
            23767913,
            23761400
        ],
        "G": [
            23782048,
            23772049,
            23771661,
            23771463
        ],
        "D": [
            23749937,
            23749579,
            23748811,
            23749322,
            23755716,
            23754682,
            23757768,
            23754805,
            23755156,
            23752956,
            23758947,
            23752935,
            23758202,
            23754949,
            23757044,
            23760439,
            23761231,
            23760141,
            23748525
        ],
        "C": [
            23747486,
            23744300,
            23743556,
            23745034,
            23746542,
            23748856,
            23755316,
            23748726,
            23749207,
            23747491,
            23752146,
            23747894,
            23750245,
            23746080,
            23751561,
            23747227,
            23747661,
            23744168
        ],
        "E": [
            23746626,
            23754640,
            23751784,
            23751547,
            23750068,
            23759139,
            23752714,
            23760482,
            23759055,
            23761627,
            23755834,
            23761719,
            23760932,
            23763128,
            23759765,
            23757483,
            23764011,
            23741658,
            23752894
        ],
        "B": [
            23740589,
            23741483,
            23740480,
            23740520,
            23742781,
            23741337,
            23746337,
            23742823,
            23741509,
            23741548,
            23745601,
            23743745,
            23742092,
            23740912,
            23741886,
            23742317,
            23743047,
            23746203,
            23741743
        ],
        "A": [
            23740335,
            23739759,
            23739764,
            23739789,
            23739801,
            23739786,
            23739911,
            23740392,
            23739871,
            23740001,
            23740128,
            23739744,
            23740216,
            23765002,
            23754212,
            23766705,
            23742440,
            23748544,
            23739773
        ]
    },
    "name": "B. Bash's Big Day",
    "statement": "Bash has set out on a journey to become the greatest Pokemon master. To\r\nget his first Pokemon, he went to Professor Zulu\u2019s Lab. Since Bash is\r\nProfessor Zulu\u2019s favourite student, Zulu allows him to take as many\r\nPokemon from his lab as he pleases.But Zulu warns him that a group of\r\nPokemon with strengths tend to fight among each other if (see notes for\r\ndefinition).Bash, being smart, does not want his Pokemon to fight among\r\neach other. However, he also wants to maximize the number of Pokemon he\r\ntakes from the lab. Can you help Bash find out the maximum number of\r\nPokemon he can take? : A Pokemon cannot fight with itself.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint cnt[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    cnt[foo]++;\n  }\n  int ans = 1;\n  for (int i = 2; i < N; i++) {\n    int cur = 0;\n    for (int j = i; j < N; j += i) {\n      cur += cnt[j];\n    }\n    ans = max(ans, cur);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1&2\\B. Bash's Big Day.json",
    "editorial_link": "https://codeforces.com//blog/entry/49743",
    "editorial": "Main idea: Square-root factorization and keeping count of prime factors.\n\nThe problem can be simplified to finding a group of Pokemons such that their strengths have a common factor other that 1. We can do this by marking just the prime factors, and the answer will be the maximum count of a prime factor occurring some number of times. The prime numbers of each number can be found out using pre-computed sieve or square-root factorization.\n\nCorner Cases : Since a Pokemon cannot fight with itself (as mentioned in the note), the minimum answer is 1. Thus, even in cases where every subset of the input has gcd equal to 1, the answer will be 1."
}