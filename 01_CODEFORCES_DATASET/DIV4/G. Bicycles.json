{
    "link": "https://codeforces.com//contest/1915/problem/G",
    "problemId": "2402118",
    "problem_idx": "G",
    "shortId": "1915G",
    "contest_number": "1915",
    "problem_submissions": {
        "G": [
            239324603,
            239298351,
            239291102,
            239327463,
            239315080,
            239298429,
            239331435,
            239358831,
            239338223,
            239314225,
            239331510,
            239346542,
            239337633,
            239370168,
            239369180,
            239346160,
            239559103,
            239363546,
            239366749,
            239350512,
            239369322
        ],
        "F": [
            239261781,
            239274034,
            239280013,
            239277963,
            239293339,
            239315714,
            239301552,
            239299242,
            239313346,
            239255585,
            239307013,
            239309817,
            239320406,
            239305928,
            239311152,
            239289443,
            239306361,
            239321545,
            239304709
        ],
        "E": [
            239252852,
            239258994,
            239296056,
            239261417,
            239262022,
            239235807,
            239267335,
            239276554,
            239285923,
            239294542,
            239293476,
            239282605,
            239281481,
            239274431,
            239270230,
            239292535,
            239277557,
            239285105,
            239263650
        ],
        "D": [
            239241155,
            239247992,
            239248670,
            239253126,
            239253995,
            239265657,
            239256680,
            239258090,
            239261104,
            239300303,
            239269518,
            239270520,
            239276544,
            239257868,
            239261471,
            239248761,
            239266865,
            239256141,
            239279955
        ],
        "C": [
            239228990,
            239226480,
            239224069,
            239236359,
            239238727,
            239222422,
            239239617,
            239236963,
            239233571,
            239295826,
            239252410,
            239245816,
            239244426,
            239235233,
            239238862,
            239256492,
            239238732,
            239259700,
            239238830
        ],
        "B": [
            239224409,
            239251414,
            239218293,
            239226511,
            239233979,
            239239693,
            239258634,
            239229667,
            239227054,
            239241984,
            239243810,
            239239053,
            239236365,
            239228576,
            239232683,
            239242403,
            239227250,
            239227149,
            239231560
        ],
        "A": [
            239213502,
            239213532,
            239213467,
            239216520,
            239220630,
            239778066,
            239214629,
            239216014,
            239213684,
            239216469,
            239222519,
            239229063,
            239219211,
            239218084,
            239214816,
            239220861,
            239217466,
            239213553,
            239214366,
            239215372
        ]
    },
    "name": "G. Bicycles",
    "statement": "All of Slavic’s friends are planning to travel from the place where they\r\nlive to a party using their bikes. And they all have a bike except\r\nSlavic. There are n cities through which they can travel. They all live\r\nin the city 1 and want to go to the party located in the city n. The map\r\nof cities can be seen as an undirected graph with n nodes and m edges.\r\nEdge i connects cities u_i and v_i and has a length of w_i.Slavic\r\ndoesn’t have a bike, but what he has is money. Every city has exactly\r\none bike for sale. The bike in the i-th city has a slowness factor of\r\ns_{i}. Once Slavic buys a bike, he can use it to travel from the city he\r\nis currently in to any neighboring city, by taking w_i\r\ncdot s_j time, considering he is traversing edge i using a bike j he\r\nowns.Slavic can buy as many bikes as he wants as money isn’t a problem\r\nfor him. Since Slavic hates traveling by bike, he wants to get from his\r\nplace to the party in the shortest amount of time possible. And, since\r\nhis informatics skills are quite rusty, he asks you for help.What’s the\r\nshortest amount of time required for Slavic to travel from city 1 to\r\ncity n? Slavic can’t travel without a bike. It is guaranteed that it is\r\npossible for Slavic to travel from city 1 to any other city.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;       \n\n// #pragma comment(linker, \"/stack:200000000\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\nusing ll = long long;\nusing ld = long double;\n#define pb push_back\n#define ff first\n#define ss second\n#define sz(x) (ll)(x).size()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nvoid freopen(string s) { freopen((s+\".in\").c_str(), \"r\", stdin); freopen((s+\".out\").c_str(), \"w\", stdout); }\nvoid IOIGold2024_InshAllah() { ios_base::sync_with_stdio(false); cin.tie(NULL); }\nll binmul(ll a, ll b, ll c) { ll res = 0; while(b) { if(b&1) (res += a) %= c; (a += a) %= c; b >>= 1; } return res; }\nll binpow(ll a, ll b, ll c) { ll res = 1; while(b) { if(b&1) (res *= a) %= c; (a *= a) %= c; b >>= 1; } return res; }\ntemplate<typename T> T gcd(T a, T b) { if(b==0) return a; return gcd(b, a%b); }\ntemplate<typename T> T lcm(T a, T b) { return a/gcd(a, b)*b; }\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nld rnd() { return rng()%INT_MAX*1.0/INT_MAX; }\n\nconst ll inf = 1e18+7, MX = LLONG_MAX, MN = LLONG_MIN;\nconst ll mod = 1e9+7, N = 1e3+5;\nll s[N], d[N][N];\nvector<pair<ll, ll>> g[N];\n\nvoid kigash() {\n    ll n, m;\n    cin>>n>>m;\n    for(ll i=1; i<=n; i++) {\n        g[i].clear();\n        s[i] = 0;\n        for(ll j=1; j<=1000; j++) d[i][j] = inf;\n    }\n    for(ll i=1; i<=m; i++) {\n        ll u, v, w;\n        cin>>u>>v>>w;\n        g[u].pb({v, w});\n        g[v].pb({u, w});\n    }\n    for(ll i=1; i<=n; i++) cin>>s[i];\n    set<vector<ll>> st;\n    st.insert({0, 1, s[1]}), d[1][s[1]] = 0;\n    while(!st.empty()) {\n        ll v = (*st.begin())[1], a = (*st.begin())[2];\n        st.erase(st.begin());\n        for(auto [to, w]: g[v]) {\n            if(d[to][a]>d[v][a]+a*w) {\n                st.erase({d[to][a], to, a});\n                d[to][a] = d[v][a]+a*w;\n                st.insert({d[to][a], to, a});\n            }\n            if(s[to]<a && d[to][s[to]]>d[v][a]+a*w) {\n                st.erase({d[to][s[to]], to, s[to]});\n                d[to][s[to]] = d[v][a]+a*w;\n                st.insert({d[to][s[to]], to, s[to]});\n            }\n        }\n    }\n    ll mn = MX;\n    for(ll i=1; i<=1000; i++) mn = min(mn, d[n][i]);\n    cout<<mn<<\"\\n\";\n    return;\n}\n\nsigned main(/*Kigash Amir*/) {\n    // freopen(\"\");\n    IOIGold2024_InshAllah();\n    ll tt = 1;\n    cin>>tt;\n    for(ll i=1; i<=tt; i++) {\n        kigash();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "implementation",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\G. Bicycles.json",
    "editorial_link": "https://codeforces.com//blog/entry/123952",
    "editorial": "We can build a graph with nodes, where each node is responsible for the\r\npair , where is the index of the city and is the speed we have when we\r\nare at this city. Then, we can use Dijkstraâs algorithm to compute the\r\nshortest path on this graph by considering all edges of node (when we\r\nare at a pair which has as the city), and the new would be the minimum\r\nvalue of and where is the neighboring city we are considering.After\r\ncomputing all shortest paths from node , we just find the minimum value\r\nof for all from to , and that will be our answer.\r\n",
    "hint": []
}