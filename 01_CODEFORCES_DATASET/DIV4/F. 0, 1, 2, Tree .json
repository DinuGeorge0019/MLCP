{
    "link": "https://codeforces.com//contest/1950/problem/F",
    "problemId": "2558687",
    "problem_idx": "F",
    "shortId": "1950F",
    "contest_number": "1950",
    "problem_submissions": {
        "G": [
            253752808,
            253791090,
            253792008,
            253764902,
            253795589,
            253769074,
            253798975,
            253810097,
            253794272,
            253806572,
            253813747,
            253817544,
            253814202,
            253820188,
            253820718,
            253701692,
            253694242,
            253726954,
            253792725,
            253718355
        ],
        "E": [
            253730988,
            253727783,
            253735577,
            253792087,
            253719212,
            253895656,
            253750540,
            253762185,
            253739498,
            253800957,
            253757755,
            253752930,
            253767006,
            253801529,
            253796303,
            253779059,
            253809431,
            253784597,
            253786784,
            253792918
        ],
        "F": [
            253716265,
            253756464,
            253746198,
            253848623,
            253757177,
            253795775,
            253775127,
            253790779,
            253735759,
            253790063,
            253778217,
            253795618,
            253777001,
            253808966,
            253809890,
            253750694,
            253768469,
            253787295,
            253772046
        ],
        "D": [
            253705197,
            253693713,
            253712924,
            253751781,
            253734348,
            253699707,
            253753088,
            253692073,
            253733558,
            253726765,
            253750400,
            253763569,
            253732867,
            253761387,
            253761597,
            253792055,
            253785952,
            253817703
        ],
        "C": [
            253676736,
            253709228,
            253688733,
            253683884,
            253710826,
            253702025,
            253688277,
            253692812,
            253687570,
            253701456,
            253687791,
            253700929,
            253695724,
            253682026,
            253784794,
            253798795,
            253798170,
            253797860,
            253824205
        ],
        "B": [
            253657996,
            253671803,
            253670916,
            253669157,
            253704746,
            253674410,
            253676969,
            253678023,
            253688393,
            253673296,
            253673178,
            253675511,
            253706337,
            253667871,
            253770768,
            253802339,
            253794136,
            253800371
        ],
        "A": [
            253646923,
            253671091,
            253650433,
            253650458,
            253649919,
            253656018,
            253663176,
            253648214,
            253648172,
            253672711,
            253656568,
            253658223,
            253654413,
            253650536,
            253773310,
            253803285,
            253782783,
            253796569
        ]
    },
    "name": "F. 0, 1, 2, Tree ",
    "statement": "Find the minimum height of a rooted tree^{\r\ndagger} with a+b+c vertices that satisfies the following conditions: a\r\nvertices have exactly 2 children, b vertices have exactly 1 child, and c\r\nvertices have exactly 0 children. If no such tree exists, you should\r\nreport it. ^{\r\ndagger} A is a connected graph without cycles, with a special vertex\r\ncalled the . In a rooted tree, among any two vertices connected by an\r\nedge, one vertex is a parent (the one closer to the root), and the other\r\none is a child. The between two vertices in a tree is the number of\r\nedges in the shortest path between them. The of a rooted tree is the\r\nmaximum distance from a vertex to the root.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        int a, b, c;\n        cin >> a >> b >> c;\n        int numEdges = a * 2 + b * 1 + c * 0;\n        numEdges++;\n        if(numEdges != (a + b + c)){\n            cout << -1 << \"\\n\";\n        }\n        else{\n            int cur = c;\n            int ans =0 ;\n            while(a != 0 || b != 0){\n                if(cur <= b){\n                    b -= cur;\n                    ans++;\n                }\n                else{\n                    int thing = cur - b;\n                    if(thing % 2 == 0){\n                        ans++;\n                        a -= thing/2;\n                        b = 0;\n                        cur -= thing/2;\n                    }\n                    else{\n                        b = 1;\n                        a -= (thing/2 + 1);\n                        ans++;\n                        cur -= (thing/2 + 1);\n                    }\n                }\n            }\n            cout << ans << \"\\n\";\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. 0, 1, 2, Tree .json",
    "editorial_link": "https://codeforces.com//blog/entry/127664",
    "editorial": "Note that since the tree has vertices, all vertices have , , or\r\nchildren. Call a vertex a if it has no children.The idea is to \"grow\"\r\nthe tree from the root by adding one or two vertices at a time.\r\nFormally: Start with a root (which is initially a leaf). Repeatedly add\r\nor children to a leaf. In total, add children times and child times. It\r\nturns out that at the end of this process, the number of leaves is\r\npredetermined: Every time we grow by adding child, the number of leaves\r\ndoes not change (since we lose one and gain one). Every time we grow by\r\nadding children, the number of leaves increases by one (since we lose\r\none and gain two). Initially, there is one leaf. Thus, at the end of the\r\nprocess, we need for the tree to be valid. If it’s not, then the answer\r\nis .Otherwise we need to minimize the height. The idea is greedy: note\r\nthat we should always grow by instead of when we have a choice, because\r\nit’s clear that it will strictly decrease the height. Similarly, we\r\nshould always grow the node closest to the root to minimize the\r\nheight.Thus we can just simulate the process described above growing by\r\nfirst and afterwards, which takes time.Bonus: can you solve the problem\r\nin time? Or even better? You can store the number of \"free\" nodes on the\r\ncurrent level and the next level in two variables, i.e. you don’t need\r\nto store a whole tree at all. As you iterate through the current level,\r\nstore the number of nodes in the next level.\r\n",
    "hint": []
}