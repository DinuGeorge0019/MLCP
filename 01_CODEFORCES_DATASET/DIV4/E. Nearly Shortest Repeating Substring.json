{
    "link": "https://codeforces.com//contest/1950/problem/E",
    "problemId": "2558685",
    "problem_idx": "E",
    "shortId": "1950E",
    "contest_number": "1950",
    "problem_submissions": {
        "G": [
            253752808,
            253791090,
            253792008,
            253764902,
            253795589,
            253769074,
            253798975,
            253810097,
            253794272,
            253806572,
            253813747,
            253817544,
            253814202,
            253820188,
            253820718,
            253701692,
            253694242,
            253726954,
            253792725,
            253718355
        ],
        "E": [
            253730988,
            253727783,
            253735577,
            253792087,
            253719212,
            253895656,
            253750540,
            253762185,
            253739498,
            253800957,
            253757755,
            253752930,
            253767006,
            253801529,
            253796303,
            253779059,
            253809431,
            253784597,
            253786784,
            253792918
        ],
        "F": [
            253716265,
            253756464,
            253746198,
            253848623,
            253757177,
            253795775,
            253775127,
            253790779,
            253735759,
            253790063,
            253778217,
            253795618,
            253777001,
            253808966,
            253809890,
            253750694,
            253768469,
            253787295,
            253772046
        ],
        "D": [
            253705197,
            253693713,
            253712924,
            253751781,
            253734348,
            253699707,
            253753088,
            253692073,
            253733558,
            253726765,
            253750400,
            253763569,
            253732867,
            253761387,
            253761597,
            253792055,
            253785952,
            253817703
        ],
        "C": [
            253676736,
            253709228,
            253688733,
            253683884,
            253710826,
            253702025,
            253688277,
            253692812,
            253687570,
            253701456,
            253687791,
            253700929,
            253695724,
            253682026,
            253784794,
            253798795,
            253798170,
            253797860,
            253824205
        ],
        "B": [
            253657996,
            253671803,
            253670916,
            253669157,
            253704746,
            253674410,
            253676969,
            253678023,
            253688393,
            253673296,
            253673178,
            253675511,
            253706337,
            253667871,
            253770768,
            253802339,
            253794136,
            253800371
        ],
        "A": [
            253646923,
            253671091,
            253650433,
            253650458,
            253649919,
            253656018,
            253663176,
            253648214,
            253648172,
            253672711,
            253656568,
            253658223,
            253654413,
            253650536,
            253773310,
            253803285,
            253782783,
            253796569
        ]
    },
    "name": "E. Nearly Shortest Repeating Substring",
    "statement": "You are given a string s of length n consisting of lowercase Latin\r\ncharacters. Find the length of the shortest string k such that several\r\n(possibly one) copies of k can be concatenated together to form a string\r\nwith the same length as s and, at most, one different character.More\r\nformally, find the length of the shortest string k such that c =\r\nunderbrace{k +\r\ncdots + k}_{x\r\nrm\r\ntext{times}} for some x, strings s and c has the same length and c_i\r\nneq s_i for at most one i (i.e. there exist 0 or 1 such positions).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        int ans = n;\n        for(int j = 1; j < n; j++){\n            if(n % j == 0){\n                string s2 = \"\";\n                for(int k = 0; k < j; k++){\n                    s2 += s[k];\n                }\n                int thing = 0;\n                for(int k = 0; k < n/j; k++){\n                    for(int l = k * j; l < (k + 1) * j; l++){\n                        if(s[l] != s2[l % j]){\n                            thing++;\n                        }\n                    }\n                }\n                if(thing <= 1){\n                    ans = min(ans, j);\n                }\n                s2 = \"\";\n                for(int k = (n/j - 1) * j; k < n; k++){\n                    s2 += s[k];\n                }\n                thing = 0;\n                for(int k = 0; k < n/j; k++){\n                    for(int l = k * j; l < (k + 1) * j; l++){\n                        if(s[l] != s2[l % j]){\n                            thing++;\n                        }\n                    }\n                }\n                if(thing <= 1){\n                    ans = min(ans, j);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "number theory",
        "strings"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\E. Nearly Shortest Repeating Substring.json",
    "editorial_link": "https://codeforces.com//blog/entry/127664",
    "editorial": "Let’s call a string a if it can be multiplied to the same length as What\r\nare the possibilities for the lengths of the period? Clearly, it must be\r\na divisor of . So the solution is to check all divisors of and see the\r\nsmallest one that works.To check if length works, multiply the prefix of\r\nlength until it’s the same length as and check how many differences\r\nthere are. However, the different letter can be in the prefix(for\r\nexample, and ), so we also check the same for the suffix of length . If\r\neither of them is true, output .All numbers at most have at most\r\ndivisors, so this will take operations, which is fast enough.\r\n",
    "hint": []
}