{
    "link": "https://codeforces.com//contest/1873/problem/G",
    "problemId": "2221685",
    "problem_idx": "G",
    "shortId": "1873G",
    "contest_number": "1873",
    "problem_submissions": {
        "H": [
            224421005,
            224434092,
            224442548,
            224444884,
            224429353,
            224447629,
            224472578,
            224490336,
            224458760,
            224430156,
            224460036,
            224462926,
            224435033,
            224472482,
            224481019,
            224449100,
            224483491,
            224433014,
            224471630,
            224479428,
            224475403
        ],
        "G": [
            224398181,
            224401164,
            224406254,
            224419325,
            224390522,
            224417167,
            224412361,
            224491010,
            224422915,
            224393328,
            224420921,
            224431335,
            224428005,
            224461695,
            224433846,
            224414175,
            224421807,
            224419744,
            224467586,
            224447652,
            224433855,
            224437230
        ],
        "F": [
            224372046,
            224373122,
            224369498,
            224376246,
            224381924,
            224384518,
            224380906,
            224491225,
            224481536,
            224395224,
            224381572,
            224389323,
            224371276,
            224387884,
            224382851,
            224393366,
            224366956,
            224396140,
            224366592,
            224366858,
            224395356,
            224377385
        ],
        "E": [
            224351156,
            224353080,
            224351100,
            224360822,
            224403130,
            224369607,
            224358415,
            224491425,
            224480694,
            224357946,
            224402533,
            224366854,
            224602579,
            224359354,
            224365737,
            224362005,
            224365741,
            224361557,
            224362119,
            224348462,
            224348889,
            224364484,
            224357405
        ],
        "D": [
            224343671,
            224346367,
            224341008,
            224347817,
            224351861,
            225552572,
            224357522,
            224350305,
            224491613,
            224346294,
            224350871,
            224349059,
            224351191,
            224335809,
            224349390,
            224353266,
            224340309,
            224353771,
            224342181,
            224337374,
            224355000,
            224348839
        ],
        "C": [
            224337317,
            224347812,
            224333882,
            224342868,
            224346028,
            224353403,
            224341122,
            224491794,
            224473860,
            224340219,
            224345973,
            224343076,
            224341381,
            224328086,
            224345135,
            224347766,
            224333608,
            224342383,
            224333130,
            224326218,
            224346669,
            224342595
        ],
        "B": [
            224326298,
            224314681,
            224323874,
            224324627,
            224340005,
            224323358,
            224320429,
            224491990,
            224472953,
            224328963,
            224341975,
            224350409,
            224325787,
            224320523,
            224331239,
            236759133,
            224330676,
            224329098,
            224328659,
            224318318,
            224316431,
            224328354,
            224330230
        ],
        "A": [
            224318982,
            224312408,
            224314383,
            224315684,
            224321438,
            224315171,
            224314404,
            224492113,
            224312687,
            224319303,
            224318527,
            224317026,
            224317557,
            224312751,
            224317923,
            224324437,
            224315252,
            224312917,
            224312520,
            224316486,
            224314729
        ]
    },
    "name": "G. ABBC or BACB",
    "statement": "You are given a string s made up of characters\r\ntexttt{A} and\r\ntexttt{B}. Initially you have no coins. You can perform two types of\r\noperations: Pick a substring^\r\ndagger\r\ntexttt{AB}, change it to\r\ntexttt{BC}, and get a coin. Pick a substring^\r\ndagger\r\ntexttt{BA}, change it to\r\ntexttt{CB}, and get a coin. What is the most number of coins you can\r\nobtain?^\r\ndagger A of length 2 is a sequence of two adjacent characters of a\r\nstring.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << \"\\n\";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << \" \" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? \"YES\": \"NO\") << \"\\n\"; }\n\n\nvoid solve(){\n    str s; cin >> s;\n    int n = len(s);\n    int cnt = count(all(s), 'A');\n    int bc = n - cnt;\n    if(s[0] == 'B' or s.back() == 'B'){\n        cout << cnt << \"\\n\";\n        return;\n    }\n    int mn = inf;\n    int cur = 0;\n    int sc = 0;\n    s += 'B';\n    for(int j = 0; j <= n; ++j){\n        char i = s[j];\n        if(i == 'B'){\n            if(j > 0 and s[j] == s[j - 1]){\n                cout << cnt << \"\\n\";\n                return;\n            }\n            if(cur != 0){\n                mn = min(mn, cur);\n                sc++;\n            }\n            cur = 0;\n        }else{\n            cur++;\n        }\n    }\n    cout << cnt - mn << \"\\n\";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\G. ABBC or BACB.json",
    "editorial_link": "https://codeforces.com//blog/entry/120634",
    "editorial": "Before we get into the editorial, I want to make a note that this type\r\nof problem is not traditional for Div. 4 on purpose, and is a lot more\r\nad-hoc than usual. My goal was to make a sort of \"introductory\" ad-hoc\r\nproblem, and I hope you enjoyed it. The editorial is a bit long, mainly\r\nbecause I want to go into a lot of detail regarding how to approach such\r\nad-hoc problems, since usually most Div. 4 problems are unlike this, and\r\ninstead focused on noticing and implementing the correct algorithm. I\r\ndonât think anyone solving the problem will actually go through all this\r\ndetail explicitly, but I wanted to provide a very explicit walk-through\r\nfor anyone not knowing how to start.But I think ad-hoc skills are\r\nimportant for Codeforces especially, hence this problem. Maybe youâll\r\nsee more soon. ;) Letâs think about how we can repeatedly use the\r\noperations first. If we have a string , then we can do the operations .\r\nSimilarly, if we have a string , then we can do the operations .In a\r\nsense, itâs useful to think of the as \"eating\" the s in a sense:\r\nwhenever a is next to an , it eats covers it and eats it, and then it\r\nmoves on. Note that cannot eat s.Letâs replace the characters as\r\nfollows: replace with and with . Then, itâs much clear what is going on.\r\nHere is a series of moves on the string , which becomes after the\r\nreplacing: Now you can see how each is eating all the dots in one\r\ndirection (it canât travel over blank spaces represented by ). Okay, we\r\nhave this intuition, how to solve the problem now? We need to eat the\r\nmaximum number of dots (s in the original string), since s cannot eat\r\nanything else. Note that for each , it can eat all the s to its left or\r\nto its right, but ; one it leaves its original spot, it is stuck on that\r\nside: but the cannot reach the rightmost dot ever. This small example\r\nactually gives us a clue: for each , letâs count the number of s on\r\neither side, and pick the largest one. This might work, but note that\r\nmultiple s may be able to reach the same dot.This is where our original\r\nstring comes into play. Suppose our original string starts with , so it\r\nmust be of the form Then each can simply eat all the s after it, and so\r\nour answer is just the total number of s. Similarly, if our string ends\r\nwith , then it must be of the form Then each can simply eat all the s\r\nbefore it, and so our answer is just the total number of s.So we only\r\nhave to look at the case where our string starts and ends with , meaning\r\nour string looks something like: If any of the s are next to each other,\r\nlike then note that we can split the string into two strings, both of\r\nwhich either start or end with , and so we can eat all the s. So in this\r\ncase, too, it is possible to get all the s.Whatâs the only other case?\r\nStart and end with , and there are no two s next to each other. In this\r\ncase, you can see there is one more \"group\" of s than there are s, but\r\neach can only get one group of s. So we wonât be able to get all of\r\nthem.Whatâs the best we can do? Note that each can only get one group,\r\nif it goes left or right, so we can get all s except one group. Now the\r\nanswer is simply greedy: it is the total number of s, minus the smallest\r\ngroup (since we want to get the most number of coins, we will take\r\ngroups as large as possible).You can also envision this as a sort of\r\ngreedy: each takes the largest group available, and we stop once no more\r\ns are free.The time complexity for finding groups is , so the whole\r\nsolution runs in that time as well.\r\n",
    "hint": []
}