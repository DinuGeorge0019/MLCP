{
    "link": "https://codeforces.com//contest/2009/problem/G1",
    "problemId": "2852157",
    "problem_idx": "G1",
    "shortId": "2009G1",
    "contest_number": "2009",
    "problem_submissions": {
        "G3": [
            279769452,
            279768632,
            279768293,
            279634016
        ],
        "G2": [
            279623507,
            279826246
        ],
        "G1": [
            279587563,
            279636106,
            279609767,
            279612959,
            279609227,
            279608763,
            279609285,
            279611833,
            279624668,
            279639153,
            279638461,
            279635081,
            279635668,
            279621773,
            279633270,
            279633684,
            279636753,
            279730650,
            279662759,
            279656445,
            279655663,
            279631130,
            279639017,
            279552989,
            279637280
        ],
        "F": [
            279547213,
            279564027,
            279559926,
            279582719,
            279583635,
            279613621,
            279577030,
            279594617,
            279621002,
            279590457,
            279608835,
            279603151,
            279614857,
            279626998,
            279613197,
            279621646,
            279597606,
            279601727,
            279569426
        ],
        "E": [
            279533616,
            279526687,
            279525143,
            279563806,
            279568079,
            279557530,
            279568309,
            279554596,
            279562319,
            279532877,
            279566258,
            280040026,
            279574760,
            279576830,
            279569963,
            279593338,
            279623467,
            279604028,
            279620362,
            279559627
        ],
        "D": [
            279533481,
            279557169,
            279569552,
            279571388,
            279553891,
            279540841,
            279541654,
            279543146,
            279532771,
            279609111,
            279548630,
            279584666,
            279578933,
            279553297,
            279551555,
            279565043,
            279612797,
            279573047,
            279527024
        ],
        "C": [
            279500445,
            279536680,
            279503360,
            279514834,
            279545156,
            279521416,
            279528596,
            279528820,
            279537845,
            279521228,
            279569591,
            279558031,
            279545403,
            286087129,
            279516214,
            279555897,
            279529719,
            279601758,
            279552170,
            279523006
        ],
        "B": [
            279496402,
            279511490,
            279496624,
            279497398,
            279513790,
            279507712,
            279513891,
            279508370,
            279503498,
            279497302,
            279514475,
            279523682,
            279500707,
            279500657,
            279545377,
            279514768,
            279554375,
            279500128,
            279509479
        ],
        "A": [
            279487493,
            279493652,
            279488106,
            279487346,
            279488818,
            279497706,
            279494564,
            279502386,
            279489427,
            279489773,
            279499517,
            279489734,
            279491016,
            279488760,
            279487942,
            279488254,
            279492954,
            279543689,
            279488083,
            279491184
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133296",
    "editorial": "Problem Credits: cry, Proof_by_QED Analysis: Proof_by_QED Solution We\r\nfirst make the sequence for all . Now, if , then and are in correct\r\nrelative order.Now, to solve the problem, we precompute the answer for\r\nevery window of , and then each query is a lookup. We use a sliding\r\nwindow, maintaining a multiset of frequencies of values of in the\r\ncurrent window. To move from the window to , we lower the frequency of\r\nby , and increase the frequency of by .\r\n",
    "name": "G1. Yunli s Subarray Queries  easy version ",
    "statement": "For an arbitrary array b, Yunli can perform the following operation any\r\nnumber of times: Select an index i. Set b_i = x where x is any integer\r\nshe desires (x is not limited to the interval [1,n]). Denote f(b) as the\r\nminimum number of operations she needs to perform until there exists a\r\nconsecutive subarray^{\r\ntext{ }} of length at least k in b.Yunli is given an array a of size n\r\nand asks you q queries. In each query, you must output\r\nsum_{j=l+k-1}^{r} f([a_l, a_{l+1},\r\nldots, a_j]). Note that in this version, you are only required to output\r\nf([a_l, a_{l+1},\r\nldots, a_{l+k-1}]).^{\r\ntext{ }}If there exists a consecutive subarray of length k that starts\r\nat index i (1\r\nleq i\r\nleq |b|-k+1), then b_j = b_{j-1} + 1 for all i < j\r\nleq i+k-1.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;using ll=long long;using i128=__int128;using ull=unsigned long long;using ld=long double;using pii=pair<int,int>;using pll=pair<ll,ll>;clock_t a;const int M=998244353;const ll inf=1e17;const ld eps=1e-10;void oT(char c='.'){cout<<c<<\"Time:\"<<double(clock()-a)<<'\\n';}struct Solution{\t\tint n,k,q;vector<int>a,cnt,res;\tpriority_queue<pii>Q;\tvoid Init()\t{\t\tcin>>n>>k>>q;a.resize(n+1,0);cnt=res=a;map<int,int>mp;\t\tfor(int i=1;i<=n;i++)cin>>a[i],a[i]-=i,mp[a[i]]=1;\t\t//for(int i=1;i<=n;i++)cout<<a[i]<<\".\\n\"[i==n];\t\tint cc=0;for(auto&k:mp)k.second=++cc;\t\tfor(int i=1;i<=n;i++)a[i]=mp[a[i]];\t\t//reverse(a.begin()+1,a.end());\t\t//for(int i=1;i<=n;i++)cout<<a[i]<<\".\\n\"[i==n];\t}\tvoid Solve()\t{\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tint x=a[i];cnt[x]++;Q.push({cnt[x],x});\t\t\tif(i>=k)\t\t\t{\t\t\t\tint y=a[i-k];cnt[y]--;Q.push({cnt[y],y});\t\t\t}\t\t\twhile(1)\t\t\t{\t\t\t\tauto [c,id]=Q.top();if(cnt[id]^c){Q.pop();continue;}\t\t\t\tbreak;\t\t\t}\t\t\tauto [c,id]=Q.top();res[i]=k-c;\t\t}\t\tfor(int i=1,l,r;i<=q;i++)\t\t{\t\t\tcin>>l>>r;cout<<res[r]<<\"\\n\";\t\t}\t}};void precal(){}signed main() {    ios::sync_with_stdio(0);cin.tie(0);precal();    int t=1;cin>>t;while(t--){Solution sol;sol.Init();sol.Solve();}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\G1. Yunli s Subarray Queries  easy version .json",
    "hint": []
}