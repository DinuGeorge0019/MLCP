{
    "link": "https://codeforces.com//contest/1985/problem/H2",
    "problemId": "2693245",
    "problem_idx": "H2",
    "shortId": "1985H2",
    "contest_number": "1985",
    "problem_submissions": {
        "H2": [
            265333958,
            265329942,
            265374762,
            265463376,
            265409850,
            265351075
        ],
        "H1": [
            265304421,
            265299704,
            265357822,
            265323224,
            265337141,
            265317283,
            265460730,
            265316153,
            265348936,
            265366976,
            265339269,
            265346344,
            265357275,
            265361186,
            265337987,
            265334505,
            265306082,
            265333344,
            265334310,
            265354855,
            265343925,
            265371157
        ],
        "G": [
            265288874,
            265285319,
            265308921,
            265294504,
            265294389,
            265349930,
            265333888,
            265302787,
            265321226,
            265321550,
            265314648,
            265319240,
            265320919,
            265319004,
            265351809,
            265347102,
            265363396,
            265321287,
            265334515
        ],
        "F": [
            265257998,
            265258336,
            265333805,
            265266191,
            265268417,
            265271517,
            265282573,
            265284015,
            265291933,
            265287030,
            265294216,
            265292426,
            265308217,
            265434837,
            265263951,
            265284551,
            265298432,
            265310548,
            265350787,
            265303880
        ],
        "E": [
            265247823,
            265268762,
            265279707,
            265250320,
            265260021,
            265260461,
            265269987,
            265268916,
            265276148,
            265277202,
            265271686,
            265278947,
            265288365,
            265270779,
            265321070,
            265309211,
            265281402,
            265290891,
            265283574
        ],
        "D": [
            265235702,
            265239453,
            265240274,
            265240512,
            265241523,
            265246501,
            265258934,
            265252788,
            265235638,
            265251750,
            265255373,
            265255903,
            265267987,
            265248169,
            265284904,
            265257354,
            265249745,
            265271001,
            265260658
        ],
        "C": [
            265224906,
            265231755,
            265230963,
            265229487,
            265231546,
            265231239,
            265250492,
            265242728,
            265240303,
            265242396,
            265240944,
            265239306,
            265248406,
            265232912,
            265250913,
            265243972,
            265239446,
            265242638,
            265248246,
            265243103
        ],
        "B": [
            265217781,
            265226807,
            265225301,
            265218520,
            265227661,
            265222521,
            265233641,
            265228462,
            265227301,
            265231808,
            265227127,
            265229582,
            265225549,
            265222424,
            265237127,
            265233502,
            265228316,
            265225179,
            265231906
        ],
        "A": [
            265211682,
            265215627,
            265211806,
            265211700,
            265213517,
            265214069,
            265212496,
            265216202,
            265212886,
            265212184,
            265216504,
            265214755,
            265214870,
            265213138,
            265212889,
            265220571,
            265212383,
            265212109,
            265213889
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129620",
    "editorial": "For each row r\n and column c\n, we need to find the size of the component formed by filling both row r\n and column c\n (i.e. the size of the component containing row r\n and column c\n if we set all cells in both row r\n and column c\n to be #\n).\n\nExtending the reasoning in H1, for some row r\n and column c\n, consider the sum of:\n\nThe number of .\n in row r\n or column c\n since these cells will be set to #\n. Let Fr,c\n denote this value for some row r\n and column c\n.\nThe sum of sizes of components containing a cell in either row r?1\n, r\n, or r+1\n (i.e. components that are touching row r\n). This is since these components will be part of the component containing row r\n and column c\n. Let Rr\n denote this value for some row r\n.\nThe sum of sizes of components containing a cell in either column c?1\n, c\n, or c+1\n (i.e. components that are touching column c\n). This is since these components will be part of the component containing row r\n and column c\n. Let Cc\n denote this value for some column c\n.\nHowever, components that contain a cell in either row r?1\n, r\n, or r+1\n as well as in either column c?1\n, c\n, or c+1\n will be overcounted (since it will be counted in both terms 2\n and 3\n) (you can think of it as components touching both row r\n and column c\n). Thus, we need to subtract the sum of sizes of components that contain a cell in either row r?1\n, r\n, or r+1\n as well as in either column c?1\n, c\n, or c+1\n. Let Br,c\n denote this for some row r\n and column c\n.\n\nThen the size of the component formed by filling both row r\n and column c\n will be Fr,c+Rr+Cc?Br,c\n and we want to find the maximum value of this.\n\nLet's try to calculate these values efficiently. Consider some component.\n\nLet s\n be its size.\nLet rmin\n and rmax\n denote the minimum and maximum row of a cell in the component. This means that the component contains cells with rows rmin,rmin+1,...,rmax\n.\nLet cmin\n and cmax\n denote the minimum and maximum column of a cell in the component. This means that the component contains cells with columns cmin,cmin+1,...,cmax\n.\nAll these values can be found with a dfs. We then do the following updates:\n\nAdd s\n to Rrmin?1,Rrmin,\u0085,Rrmax+1\n. This can be done naively or with prefix sums.\nAdd s\n to Ccmin?1,Ccmin,\u0085,Ccmax+1\n. This can be done naively or with prefix sums.\nAdd s\n to the subrectangle of B\n with top left at (rmin?1,cmin?1\n) and bottom right at (rmax+1,cmax+1\n). This can be done with 2D prefix sums. (Note that doing this naively will pass because of low constant factor and the fact that we could not cut this solution without cutting slow correct solutions.)\nWe do this for each component. Also, calculating Fr,c\n can be done by looking at the number of .\n in row r\n, column c\n, and checking whether we overcounted a .\n at (r,c\n). In all, this solution runs in O(nm)\n time.",
    "name": "H2. Maximize the Largest Component  Hard Version ",
    "statement": "Alex has a grid with n rows and m columns consisting of \u201d and \u201d\r\ncharacters. A set of \u201d cells forms a connected component if from any\r\ncell in this set, it is possible to reach any other cell in this set by\r\nonly moving to another cell in the set that shares a . The size of a\r\nconnected component is the number of cells in the set.In one operation,\r\nAlex selects any row r (1\r\nle r\r\nle n) any column c (1\r\nle c\r\nle m), then sets every cell in row r column c to be \u201d. Help Alex find\r\nthe maximum possible size of the largest connected component of \u201d cells\r\nthat he can achieve after performing the operation .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\u00a0struct SegTree{\tvector<int> st;\tvoid init(int n)\t{\t\tst.assign((n + 1) << 2, 0);\t}\tvoid add(int l, int r, int x, int lx, int rx, int val)\t{\t\tif (l > rx || r < lx) return;\t\tif (l >= lx && r <= rx)\t\t{\t\t\tst[x] += val;\t\t\treturn;\t\t}\t\tint mid = (l + r) >> 1;\t\tadd(l, mid, 2*x, lx, rx, val);\t\tadd(mid + 1, r, 2*x + 1, lx, rx, val);\t}\tint get(int l, int r, int x, int ind)\t{\t\tif (l == r) return st[x];\t\tint mid = (l + r) >> 1;\t\tif (ind <= mid) return st[x] + get(l, mid, 2*x, ind);\t\telse return st[x] + get(mid + 1, r, 2*x + 1, ind);\t}};\u00a0struct DSU{\tvector<int> e;\tvector<vector<int>> id;\tvoid init(int n)\t{\t\te.assign(n, -1);\t\tid.clear();\t\tid.resize(n);\t\tfor (int i = 0; i < n; i++) id[i].push_back(i);\t}\tint get(int x)\t{\t\tif (e[x] < 0) return x;\t\treturn e[x] = get(e[x]);\t}\tvoid unite(int x, int y)\t{\t\tx = get(x), y = get(y);\t\tif (x == y) return;\t\tif (e[x] > e[y]) swap(x, y);\t\tfor (int z : id[y]) id[x].push_back(z);\t\tid[y].clear();\t\te[x] += e[y];\t\te[y] = x;\t}};\u00a0const int MXN = 1e6 + 5;const int mod = 1e9 + 7;\u00a0int A[4] = {0, 0, -1, 1};int B[4] = {-1, 1, 0, 0};vector<array<int, 3>> ad[MXN], del[MXN];int used[MXN], X[MXN], Y[MXN];\u00a0void _(){\tint n, m;\tcin >> n >> m;\tfor (int i = 0; i < n; i++) ad[i].clear(), del[i].clear();\tvector<vector<int>> f(n, vector<int> (m, 0));\tDSU dsu;\tdsu.init(n * m);\tstring s[n];\tSegTree st;\tst.init(m);\tfor (int i = 0; i < n; i++) cin >> s[i];\tfor (int i = 0; i < n; i++)\t{\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m) \t\t\t\t{\t\t\t\t\tif (s[i][j] == '#' && s[x][y] == '#') dsu.unite(i * m + j, x * m + y);\t\t\t\t}\t\t\t}\t\t}\t}\tfor (int i = 0; i < n; i++)\t{\t\tvector<int> v;\t\tint sum = 0;\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tif (s[i][j] == '.') sum++;\t\t\telse if (!used[dsu.get(i * m + j)]) \t\t\t{\t\t\t\tsum += -dsu.e[dsu.get(i * m + j)];\t\t\t\tused[dsu.get(i * m + j)] = 1;\t\t\t\tv.push_back(dsu.get(i * m + j));\t\t\t}\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m)\t\t\t\t{\t\t\t\t\tif (s[x][y] == '#') \t\t\t\t\t{\t\t\t\t\t\tif (!used[dsu.get(x * m + y)])\t\t\t\t\t\t{\t\t\t\t\t\t\tsum += -dsu.e[dsu.get(x * m + y)];\t\t\t\t\t\t\tused[dsu.get(x * m + y)] = 1;\t\t\t\t\t\t\tv.push_back(dsu.get(x * m + y));\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tX[i] = sum;\t\tfor (int i : v) used[i] = 0;\t}\tfor (int j = 0; j < m; j++)\t{\t\tvector<int> v;\t\tint sum = 0;\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\tif (s[i][j] == '.') sum++;\t\t\telse if (!used[dsu.get(i * m + j)]) \t\t\t{\t\t\t\tsum += -dsu.e[dsu.get(i * m + j)];\t\t\t\tused[dsu.get(i * m + j)] = 1;\t\t\t\tv.push_back(dsu.get(i * m + j));\t\t\t}\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m)\t\t\t\t{\t\t\t\t\tif (s[x][y] == '#') \t\t\t\t\t{\t\t\t\t\t\tif (!used[dsu.get(x * m + y)])\t\t\t\t\t\t{\t\t\t\t\t\t\tsum += -dsu.e[dsu.get(x * m + y)];\t\t\t\t\t\t\tused[dsu.get(x * m + y)] = 1;\t\t\t\t\t\t\tv.push_back(dsu.get(x * m + y));\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tY[j] = sum;\t\tfor (int i : v) used[i] = 0;\t}\tfor (int i = 0; i < n; i++)\t{\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tif (s[i][j] == '.') continue;\t\t\tif (dsu.get(i * m + j) != i * m + j) continue;\t\t\t\tint mni = n, mxi = -1, mnj = m, mxj = -1;\t\t\tfor (int k : dsu.id[i * m + j])\t\t\t{\t\t\t\tint x1 = k / m, y1 = k % m;\t\t\t\tmni = min(mni, max(0LL, x1 - 1));\t\t\t\tmxi = max(mxi, min(n - 1, x1 + 1));\t\t\t\tmnj = min(mnj, max(0LL, y1 - 1));\t\t\t\tmxj = max(mxj, min(m - 1, y1 + 1));\t\t\t}\t\t\tad[mni].push_back({mnj, mxj, -dsu.e[i * m + j]});\t\t\tdel[mxi].push_back({mnj, mxj, -dsu.e[i * m + j]});\t\t}\t}\tint mx = n + m - 1;\tfor (int i = 0; i < n; i++)\t{\t\tfor (array<int, 3> &x : ad[i])\t\t{\t\t\tst.add(1, m, 1, x[0] + 1, x[1] + 1, x[2]);\t\t}\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tint sum = X[i] + Y[j] - (s[i][j] == '.');\t\t\tsum -= st.get(1, m, 1, j + 1);\t\t\tmx = max(mx, sum);\t\t}\t\tfor (array<int, 3> &x : del[i])\t\t{\t\t\tst.add(1, m, 1, x[0] + 1, x[1] + 1, -x[2]);\t\t}\t}\tcout << mx << '\\n';}\u00a0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\tfor (int tt = 1; tt <= t; tt++)\t{\t\t_();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "dsu",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\H2. Maximize the Largest Component  Hard Version .json"
}