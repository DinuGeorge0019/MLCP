{
    "link": "https://codeforces.com//contest/1926/problem/G",
    "problemId": "2485157",
    "problem_idx": "G",
    "shortId": "1926G",
    "contest_number": "1926",
    "problem_submissions": {
        "G": [
            247563054,
            247320239,
            247350085,
            247352042,
            247335994,
            247324443,
            247354190,
            247343635,
            247343020,
            247361344,
            247364979,
            247352637,
            247358922,
            247365060,
            247361705,
            247335567,
            247361664,
            247363695,
            251544705,
            247357523,
            247364451
        ],
        "E": [
            247469870,
            247283178,
            247284072,
            247331325,
            247283022,
            247304643,
            247852629,
            247286675,
            247298689,
            247310427,
            247305094,
            247280999,
            247256640,
            247276246,
            247310244,
            247304899,
            247318176,
            247321426,
            247323263,
            251544548,
            247340094,
            247322326
        ],
        "D": [
            247426241,
            247263556,
            247421972,
            247278704,
            247339663,
            247271030,
            247272297,
            247843708,
            247274387,
            247287606,
            247268858,
            247276561,
            247270174,
            247312112,
            247330586,
            247287651,
            247258518,
            247306283,
            247265573,
            247299995,
            251545025,
            247267115,
            247289554
        ],
        "C": [
            247423997,
            247243871,
            247421569,
            247273658,
            252912334,
            247276036,
            247252892,
            247246007,
            247677422,
            247256159,
            247247059,
            247257359,
            247252723,
            247250177,
            247286681,
            247248462,
            247270959,
            247272136,
            247287839,
            247242436,
            247261191,
            251544976,
            247253706,
            247269016
        ],
        "B": [
            247423300,
            247238516,
            247244552,
            247285931,
            247246391,
            247234479,
            247655111,
            247237025,
            247257539,
            247250357,
            247235220,
            247246309,
            247261185,
            247239462,
            247243969,
            247244466,
            247253077,
            247236058,
            247250084,
            251545137,
            247244629,
            247257551
        ],
        "A": [
            247422269,
            247225900,
            247221565,
            247226674,
            247231661,
            247220620,
            247222897,
            247230070,
            247232373,
            247222228,
            247222168,
            247223439,
            247225539,
            247227948,
            247228394,
            247233059,
            247221337,
            247227237,
            251545212,
            247231544,
            247251666
        ],
        "F": [
            247339181,
            247336558,
            247364869,
            247371524,
            250524281,
            247428628
        ]
    },
    "name": "G. Vlad and Trouble at MIT",
    "statement": "Vladislav has a son who really wanted to go to MIT. The college\r\ndormitory at MIT (Moldova Institute of Technology) can be represented as\r\na tree with n vertices, each vertex being a room with exactly one\r\nstudent. A is a connected undirected graph with n vertices and n-1\r\nedges.Tonight, there are three types of students: students who want to\r\nparty and play music (marked with\r\ntexttt{P}), students who wish to sleep and enjoy silence (marked with\r\ntexttt{S}), and students who don’t care (marked with\r\ntexttt{C}). Initially, all the edges are walls which allow music to pass\r\nthrough, so when a partying student puts music on, it will be heard in\r\nevery room. However, we can place some walls on any edges thick walls\r\ndon’t allow music to pass through them.The university wants to install\r\nsome thick walls so that every partying student can play music, and no\r\nsleepy student can hear it.Because the university lost a lot of money in\r\na naming rights lawsuit, they ask you to find the minimum number of\r\nthick walls they will need to use.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nchar s[N];\nint f[N][2];\nvector<int>g[N];\nconst int INF=0x3f3f3f3f;\nvoid dfs(int u)\n{\n\t//u 0 作为S\n\tf[u][1]=f[u][0]=0;\n\tif(s[u-1]=='S')f[u][1]=INF;\n\tif(s[u-1]=='P')f[u][0]=INF;\n\tfor(auto v:g[u])\n\t{\n\t\tdfs(v);\n\t\tf[u][0]+=min(f[v][0],f[v][1]+1);\n\t\tf[u][1]+=min(f[v][1],f[v][0]+1);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++)g[i].clear();\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tcin>>s;\n\t\tdfs(1);\n\t\tcout<<min(f[1][0],f[1][1])<<\"\\n\";\n\t}\n\t\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "flows",
        "graphs",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\G. Vlad and Trouble at MIT.json",
    "editorial_link": "https://codeforces.com//blog/entry/126132",
    "editorial": "Letâs think of the problem as trying to separate some rooms(with and\r\npossibly some ) that will hear music and the other ones(with and\r\npossibly some ) that will not hear music. Imagine red \"water\" from the\r\nnodes and blue \"water\" flowing from the nodes flowing freely until\r\nhitting a thick wall. We donât want these two \"waters\" to mix.Letâs\r\nrotate the tree upside down so that on top are all the leaves and end\r\nwith the root node at the bottom and start letting blue and red water\r\nflow down. We want to check so that, at any point, these waters donât\r\nmix. Letâs go through them layer by layer and do dynamic programming\r\nwhere for each node , we remember the minimum number of walls we have to\r\nadd such that only red water flows there, only blue water flows, or no\r\nwater flows, ensuring there is no mixing in nodes above. Using the\r\nvalues for the nodes above, we can calculate the value of the node\r\nbelow. Of course, the value for the \"pumping\" nodes ( or ) will have the\r\nof other colors infinite. The final answer will be the minimum of , , ,\r\nthe minimum number of walls needed for the root to not reach \"water\"(and\r\nno mixing above), to reach only red \"water\"(and no mixing above) or\r\nreach only blue \"water\"(and no mixing above).Final complexity is\r\n",
    "hint": []
}