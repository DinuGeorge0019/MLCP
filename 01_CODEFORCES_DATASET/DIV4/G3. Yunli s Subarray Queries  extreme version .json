{
    "link": "https://codeforces.com//contest/2009/problem/G3",
    "problemId": "2852159",
    "problem_idx": "G3",
    "shortId": "2009G3",
    "contest_number": "2009",
    "problem_submissions": {
        "G3": [
            279769452,
            279768632,
            279768293,
            279634016
        ],
        "G2": [
            279623507,
            279826246
        ],
        "G1": [
            279587563,
            279636106,
            279609767,
            279612959,
            279609227,
            279608763,
            279609285,
            279611833,
            279624668,
            279639153,
            279638461,
            279635081,
            279635668,
            279621773,
            279633270,
            279633684,
            279636753,
            279730650,
            279662759,
            279656445,
            279655663,
            279631130,
            279639017,
            279552989,
            279637280
        ],
        "F": [
            279547213,
            279564027,
            279559926,
            279582719,
            279583635,
            279613621,
            279577030,
            279594617,
            279621002,
            279590457,
            279608835,
            279603151,
            279614857,
            279626998,
            279613197,
            279621646,
            279597606,
            279601727,
            279569426
        ],
        "E": [
            279533616,
            279526687,
            279525143,
            279563806,
            279568079,
            279557530,
            279568309,
            279554596,
            279562319,
            279532877,
            279566258,
            280040026,
            279574760,
            279576830,
            279569963,
            279593338,
            279623467,
            279604028,
            279620362,
            279559627
        ],
        "D": [
            279533481,
            279557169,
            279569552,
            279571388,
            279553891,
            279540841,
            279541654,
            279543146,
            279532771,
            279609111,
            279548630,
            279584666,
            279578933,
            279553297,
            279551555,
            279565043,
            279612797,
            279573047,
            279527024
        ],
        "C": [
            279500445,
            279536680,
            279503360,
            279514834,
            279545156,
            279521416,
            279528596,
            279528820,
            279537845,
            279521228,
            279569591,
            279558031,
            279545403,
            286087129,
            279516214,
            279555897,
            279529719,
            279601758,
            279552170,
            279523006
        ],
        "B": [
            279496402,
            279511490,
            279496624,
            279497398,
            279513790,
            279507712,
            279513891,
            279508370,
            279503498,
            279497302,
            279514475,
            279523682,
            279500707,
            279500657,
            279545377,
            279514768,
            279554375,
            279500128,
            279509479
        ],
        "A": [
            279487493,
            279493652,
            279488106,
            279487346,
            279488818,
            279497706,
            279494564,
            279502386,
            279489427,
            279489773,
            279499517,
            279489734,
            279491016,
            279488760,
            279487942,
            279488254,
            279492954,
            279543689,
            279488083,
            279491184
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133296",
    "editorial": "Analysis: Dominater069 Solution I decided to write the Editorial for\r\nthis problem in a step-by-step manner. Some of the steps are really\r\nshort and meant to be used as hints but i decided to have a uniform\r\nnaming for everything. Step 1Continuing from the easier versions of the\r\nproblem, we know we need to compute sum of min of subarrays, and answer\r\nsubarray queries on this. Consider the standard approach of finding sum\r\nof min over all subarrays. Step 2Sum of min of all subarrays for a fixed\r\narray is a well known problem. Here is how you can solve it, given an\r\narray of length .Let denote the smallest integer such that holds, or if\r\nno such integer exists. Similarly, define denote the largest integer\r\nsuch that holds, or if no such integer exists.The answer is simply .\r\nCalculating and can be done with Monotonic Stack. Step 3Given a query ,\r\ndivide all indices () into groups depending on the existence of and\r\nwithin the interval , i.e. : Case : Case : Case : Case : Try to\r\ncalculate the contributions of each of these categories separately. Step\r\n4Case can be reduced to rectangle queries. Case is simple to handle as\r\nthere is atmost element which satisfies that condition, which (if\r\nexists) is the minimum element in the range which can be found using any\r\nRMQ data structure like Sparse Table or Segment Tree. What is Rectangle\r\nQueries?Given a list of tuples and queries you have to add to answer of\r\nthe -th query if . This can be solved in using Fenwick Tree and\r\nSweepline. Iterate from to . For every tuple with left end at say , add\r\nto a range query sum data structure at position . Then, for every query\r\nwith left end at , we can simply query the range sum from to to get the\r\nrequired answer. How to reduce Case 1 to Rectangle Queries?For every\r\nindex from to , generate a tuple as . Then, solve the Rectangle Queries\r\nproblem with this list of tuples. The answer will be the required\r\ncontribution of all indices belonging to Case . Step 5This leaves us\r\nwith Case and , which are symmetric, so we discuss only case .Let us\r\nsweepline from to , maintaining a Monotonic Stack of elements, popping\r\nelements when we find a smaller element, similar to how we find . The\r\nindices belonging to Case are precisely the elements present in the\r\nMonotonic Stack (obviously ignore any element ) when we have swept till\r\n, with the possible exception of the minimum in the range (that might\r\nbelong to Case ). Step 6Letâs analyze the contribution of the indices in\r\nCase . It is .Take a look at what happens when we go from to , how do\r\nall the contributions of elements belonging to Case change. Step 7Some\r\nelements get popped from the Monotonic Stack because . We need to reset\r\nthe contribution of all these elements to .The elements that do not get\r\npopped have their contribution increased by exactly . element gets added\r\nto the Monotonic Stack, which is , so we need to initiliatize its\r\ncontribution to Step 8Resetting and Initiliazing Contribution is simple\r\nenough with most data structures, so let us focus on adding to the\r\nelements present in the Monotonic Stack.We can keep a Lazy Segment Tree\r\nwith parameters, sum of all contributions in this segment tree node, and\r\nsum of of all \"non-popped\" elements in this node. The lazy tag will\r\ndenote how many contribution increases I have to do. We can simply do\r\nfor the lazy updates.Then, we can query the range sum from to to get the\r\nsum of contributions of all elements belonging to Case . Case can be\r\nsolved in a symmetric way. Adding up the answers over Case , , and will\r\ngive us the required answer. Minor DetailWe need to be quite careful\r\nwith the Case element, as we might double count its contribution in Case\r\nand . I handle this in the model solution by querying the sum of\r\ncontribution in where is the largest element present in the monostack\r\nwhich is , and handling separately. You can easily note that is the only\r\nelement belonging to Case (if any at all).\r\n",
    "name": "G3. Yunli s Subarray Queries  extreme version ",
    "statement": "For an arbitrary array b, Yunli can perform the following operation any\r\nnumber of times: Select an index i. Set b_i = x where x is any integer\r\nshe desires (x is not limited to the interval [1,n]). Denote f(b) as the\r\nminimum number of operations she needs to perform until there exists a\r\nconsecutive subarray^{\r\ntext{ }} of length at least k in b.Yunli is given an array a of size n\r\nand asks you q queries. In each query, you must output\r\nsum_{i=l}^{r-k+1}\r\nsum_{j=i+k-1}^{r} f([a_i, a_{i+1},\r\nldots, a_j]).^{\r\ntext{ }}If there exists a consecutive subarray of length k that starts\r\nat index i (1\r\nleq i\r\nleq |b|-k+1), then b_j = b_{j-1} + 1 for all i < j\r\nleq i+k-1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>   using namespace std;using ll=long long;using pii=pair<int,int>;struct Smt_hissum{\tint n,t=0;\tstruct node{ll lk=0,lb=0,vk=0,vb=0;};//v:real l:lazy/ans=k*t+b\tvector<node>Tr;int ql,qr;\tvoid ini(int _n){n=_n+1;Tr.resize(n<<2,node());}\tvoid d_upd(int p,int l,int r,ll v1,ll v2)\t{\t\tTr[p].vk+=v1*(r-l+1);Tr[p].lk+=v1;\t\tTr[p].vb+=v2*(r-l+1);Tr[p].lb+=v2;\t}\tvoid push(int p,int l,int r)\t{\t\tint mid=l+r>>1;//ll&x=Tr[p].lk,&y=Tr[p].lb;\t\td_upd(p<<1,l,mid,Tr[p].lk,Tr[p].lb);d_upd(p<<1|1,mid+1,r,Tr[p].lk,Tr[p].lb);\t\tTr[p].lk=Tr[p].lb=0;\t}\tvoid pull(int p){Tr[p].vk=Tr[p<<1].vk+Tr[p<<1|1].vk;Tr[p].vb=Tr[p<<1].vb+Tr[p<<1|1].vb;}\tvoid add(int p,int l,int r,ll v1,ll v2)\t{\t\tif(ql>r||qr<l)return;if(ql<=l&&r<=qr){d_upd(p,l,r,v1,v2);return;}push(p,l,r);\t\tint mid=l+r>>1;add(p<<1,l,mid,v1,v2);add(p<<1|1,mid+1,r,v1,v2);pull(p);\t}\tvoid Add(int l,int r,ll v){ql=l,qr=r;add(1,1,n,v,-v*t);}\tll qry(int p,int l,int r)\t{\t\tif(qr<l||r<ql)return 0;if(ql<=l&&r<=qr)return Tr[p].vk*t+Tr[p].vb;push(p,l,r);\t\tint mid=l+r>>1;return qry(p<<1,l,mid)+qry(p<<1|1,mid+1,r);\t}\tll Qry(int l,int r){ql=l,qr=r;return qry(1,1,n);}\tvoid upd(){++t;}//先操作再更新};struct Solution{\t\tint n,k,q;vector<int>b;Smt_hissum B;\tvoid Init()\t{\t\tcin>>n>>k>>q;vector<int>a(n+1,0);b=a;for(int i=1;i<=n;i++)cin>>a[i],a[i]+=n-i;\t\tvector<int>cnt(n*2+1,0),rv(n+1,0);int mx=0;\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tint x=a[i];rv[cnt[x]]--;cnt[x]++;rv[cnt[x]]++;if(cnt[x]>mx)mx=cnt[x];\t\t\tif(i>k){int y=a[i-k];rv[cnt[y]]--;cnt[y]--;rv[cnt[y]]++;if(!rv[mx])mx--;}\t\t\tif(i>=k)b[i-k+1]=k-mx;\t\t\t}\t\tn-=k-1;B.ini(n);\t}\t\tstruct node{int L,R,h;ll pre;};\tvoid Solve()\t{\t\t\tvector<vector<pii>>A(n+1);vector<ll>resr(q+1,-1);\t\tfor(int i=1,l,r;i<=q;i++){cin>>l>>r;r-=k-1;A[r].push_back({i,l});}\t\t\t\tvector<node>v;v.push_back({0,0,-1,0});//(l,h)\t\tfor(int z=1;z<=n;z++)\t\t{\t\t\t\t\t\tint l=z,h=b[z];\t\t\twhile(1)\t\t\t{\t\t\t\tauto&nd=v.back();if(nd.h<h)break;\t\t\t\tB.Add(nd.L,nd.R,-nd.h);v.pop_back();\t\t\t}\t\t\t{\t\t\t\tauto&nd=v.back();int L=nd.R+1,R=z;\t\t\t\tv.push_back({L,R,h,nd.pre+ll(R-L+1)*h});B.Add(L,R,h);\t\t\t}\t\t\tB.upd();for(auto&[qid,L]:A[z])resr[qid]=B.Qry(L,z);\t\t\t\t\t}\t\tfor(int i=1;i<=q;i++)cout<<resr[i]<<\"\\n\";//[i==q];\t}};void precal(){}signed main() {    ios::sync_with_stdio(0);cin.tie(0);precal();    int t=1;cin>>t;while(t--){Solution sol;sol.Init();sol.Solve();}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\G3. Yunli s Subarray Queries  extreme version .json",
    "hint": []
}