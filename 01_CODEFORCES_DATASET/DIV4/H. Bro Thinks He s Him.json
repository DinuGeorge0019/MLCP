{
    "link": "https://codeforces.com//contest/2065/problem/H",
    "problemId": "3192587",
    "problem_idx": "H",
    "shortId": "2065H",
    "contest_number": "2065",
    "problem_submissions": {
        "E": [
            305312354,
            305194637,
            305291861,
            305309920,
            305191466,
            305278591,
            305269404,
            305338868,
            305236207,
            305244718,
            305249851,
            305252901,
            305349934,
            305269590,
            305273100,
            305259568
        ],
        "H": [
            305281397,
            305277196,
            305224889,
            305409482,
            305298450
        ],
        "G": [
            305270269,
            305243226,
            305283571,
            305303347,
            305246836,
            305290460,
            305288465,
            305291691,
            305285379,
            305320630,
            305316576,
            305330919,
            305297977
        ],
        "F": [
            305207005,
            305224958,
            305268816,
            305205600,
            305222883,
            305216507,
            305222057,
            305260089,
            305263894,
            305280050,
            305293362,
            305295319,
            305317233
        ],
        "C2": [
            305180569,
            305175163,
            305195198,
            305161534,
            305164762,
            305196151,
            305168272,
            305203417,
            305207903,
            305224173,
            305208149,
            305192948,
            305194564,
            305189082
        ],
        "D": [
            305170929,
            305192657,
            305245769,
            305169854,
            305167651,
            305189554,
            305177158,
            305214051,
            305194947,
            305233657,
            305228720,
            305230467,
            305236708,
            305231361
        ],
        "C1": [
            305166664,
            305175397,
            305194143,
            305170322,
            305170303,
            305159411,
            305196219,
            305205049,
            305201974,
            305189516,
            305173737,
            305175472,
            305190744
        ],
        "B": [
            305156321,
            305139860,
            305165371,
            305145780,
            305145036,
            305176896,
            305147932,
            305189102,
            305149733,
            305181688,
            305181612,
            305177814,
            305157221,
            305200290
        ],
        "A": [
            305141292,
            305137241,
            305159681,
            305138394,
            305141442,
            305138107,
            305171143,
            305138752,
            305155403,
            305142146,
            305137327,
            305142353,
            305157006
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139178",
    "editorial": "Problem Credits: Proof_by_QED Analysis: efishel SolutionA brute attempt\r\nat a solution would be to go through each non-empty subset of and, for\r\nevery pair of adjacent indices in the subset, increase if In other\r\nwords, increase ans every time and create a new borderThis is extremely\r\nslow at ; however, we can notice that every adjacent pair is independent\r\nfrom the rest in the subset. We may ask ourselves: for a fixed , how\r\nmany subsets increase ans through that ? The conditions are that: and\r\nare in the subset and are adjacent in the subset (there’s no other\r\nincluded value in between) Which leaves us free to choose the prefix and\r\nthe suffix. .An solution is: The rest of the solution will try to\r\noptimize how to compute that sum, and then how to maintain the answer\r\nthrough updates. We may notice we can pull out the factor and rewrite\r\nthe loops as: Since the second for loop only cares about what is\r\n(nothing else about ), we can again easily optimize it as: In other\r\nwords, we don’t need to recalculate each new . Instead, we can maintain\r\nits possible values () as we increase (since cares about ())We can run\r\nthis solution once before any updates, but not after each update because\r\nis too slow. Instead, we can make the minimal adjustments needed to\r\nmaintain ans correctly. Let’s call the toggled index : How much does\r\ncontribute to ans in the first place? We can partition ’s contribution\r\nto the answer in cases: - When , - After , every time is used to\r\nincrease ansAs for the first case, we can calculate the value of at\r\nusing the sum of for and . As for the second case, it’s only slightly\r\ntrickier, but along the same general idea. It can be calculated using\r\nthe sum of for and .Fenwick (or segment) tree solves both cases, which\r\nare essentially dynamically calculating range sums on an array. Since\r\nfor both cases we may consider when or , a total of different fenwick\r\ntrees will be needed. when otherwise); ( when otherwise); when\r\notherwise); when otherwise)The procedure is thus: before toggling a bit,\r\nsubtract its contribution from ans. After toggling the bit, add its new\r\ncontribution to ans. Also, update the fenwick trees accordingly. This\r\ncorrectly maintains ans in per update.So, the final complexity is\r\n",
    "name": "H. Bro Thinks He s Him",
    "statement": "Given a binary string^{\r\ntext{ }} t, f(t) is defined as the minimum number of contiguous\r\nsubstrings, each consisting of identical characters, into which t can be\r\npartitioned. For example, f(\r\ntexttt{00110001}) = 4 because t can be partitioned as\r\ntexttt{[00][11][000][1]} where each bracketed segment consists of\r\nidentical characters.Skibidus gives you a binary string s and q queries.\r\nIn each query, a single character of the string is flipped (i.e.\r\ntexttt{0} changes to\r\ntexttt{1} and\r\ntexttt{1} changes to\r\ntexttt{0}); changes are saved after the query is processed. After each\r\nquery, output the sum over all f(b) where b is a non-empty subsequence^{\r\ntext{ }} of s, modulo 998\r\n,244\r\n,353.^{\r\ntext{ }}A binary string consists of only characters\r\ntexttt{0} and\r\ntexttt{1}.^{\r\ntext{ }}A subsequence of a string is a string which can be obtained by\r\nremoving several (possibly zero) characters from the original string.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "divide and conquer",
        "dp",
        "math",
        "matrices"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\H. Bro Thinks He s Him.json",
    "hint": []
}