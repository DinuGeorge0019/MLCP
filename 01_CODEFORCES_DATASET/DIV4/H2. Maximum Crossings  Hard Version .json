{"link": "https://codeforces.com//contest/1676/problem/H2", "problemId": "1394661", "problem_idx": "H2", "shortId": "1676H2", "contest_number": "1676", "problem_submissions": {"H1": [156663309, 156671035, 156676406, 156677707, 156687383, 156685420, 156683017, 156685580, 156680845, 156671307, 156687981, 156692199, 156657699, 156687504, 156687346, 156669994, 156692215, 156690772, 156699306, 156674281], "F": [156662637, 156656235, 156665211, 156662718, 156672962, 156670420, 156669171, 156672700, 156689970, 156701445, 156668704, 156670980, 156692969, 156667724, 156672833, 156697894, 156674219, 156675205, 156671046, 156695991], "H2": [156662559, 156672919, 156681840, 156677592, 156687173, 156685234, 156690935, 156688441, 156684282, 156671711, 156695356, 156692679, 156656052, 156687092, 156691243, 156679289, 156697513, 156691027, 156699563, 156671734], "G": [156653552, 156661675, 156671235, 156675609, 156680563, 156678234, 156674526, 156681628, 156674365, 156683892, 156676420, 156679729, 156701067, 156674224, 156680025, 156686261, 156680343, 156680683, 156677057, 156684128], "D": [156645060, 156650467, 156648808, 156663990, 156656243, 156654084, 156654738, 156653252, 156652931, 156720716, 156654408, 156652941, 156637656, 156666271, 156684420, 156652544, 156655842, 156653648, 156661131, 156659068, 156666840], "E": [156637739, 156656814, 156654288, 156651298, 156645000, 156661246, 156659306, 156663832, 156658669, 156662700, 156660368, 156647103, 156671327, 156659242, 156657789, 156660550, 156665251, 156665346, 156657650, 156676846], "C": [156635303, 156637333, 156640687, 156644760, 156634239, 156639390, 156648512, 156642440, 156638160, 156643703, 156638666, 156653980, 156643726, 156635835, 156643174, 156650355, 156639499, 156649527, 156641083, 156646143], "B": [156625015, 156622909, 156630747, 156623442, 156623221, 156628681, 156623121, 156628287, 156626048, 156630150, 156624457, 156631684, 156634804, 156625307, 156634457, 156622363, 156628178, 156624635, 156624141, 156627356], "A": [156619295, 156618687, 156622372, 156618765, 156618606, 156621261, 156618635, 156621495, 156621071, 156622861, 156618818, 156619301, 156623952, 156618523, 156619829, 156618483, 156619228, 156619089, 156618766, 156619486]}, "name": "H2. Maximum Crossings  Hard Version ", "statement": "n\r\nleq 2\r\ncdot 10^5 and the sum of n over all test cases does not exceed 2\r\ncdot 10^5A is a row of n equal segments numbered 1 to n in order. There\r\nare two terminals, one above the other. You are given an array a of\r\nlength n. For all i = 1, 2,\r\ndots, n, there should be a straight wire from some point on segment i of\r\nthe top terminal to some point on segment a_i of the bottom terminal.\r\nYou can\u2019t select the endpoints of a segment. For example, the following\r\npictures show two possible wirings if n=7 and a=[4,1,4,6,7,7,5]. A\r\noccurs when two wires share a point in common. In the picture above,\r\ncrossings are circled in red.What is the number of crossings there can\r\nbe if you place the wires optimally?\r\n", "solutions": ["#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,x,y,k,tot=0;\nstruct tree{\n\tint l,r,num,lazy;\n\ttree *lson,*rson;\n}t[400001];\nvoid push_up(tree *rt)\n{\n\trt->num=rt->lson->num+rt->rson->num;\n}\nvoid push_down(tree *rt)\n{\n\tif(rt->l==rt->r) return;\n\telse if(rt->lazy)\n\t{\n\t\trt->lson->lazy+=rt->lazy;\n\t\trt->rson->lazy+=rt->lazy;\n\t\trt->lson->num+=rt->lazy*(rt->lson->r-rt->lson->l+1);\n\t\trt->rson->num+=rt->lazy*(rt->rson->r-rt->rson->l+1);\n\t\trt->lazy=0;\n\t}\n}\nvoid build(tree *rt,int l,int r)\n{\n\trt->l=l;\n\trt->r=r;\n\trt->lazy=0;\n\tif(l==r)\n\t{\n\t\trt->num=0;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\trt->lson=&t[++tot];\n\trt->rson=&t[++tot];\n\tbuild(rt->lson,l,m);\n\tbuild(rt->rson,m+1,r);\n\tpush_up(rt);\n}\nvoid xiugai(tree *rt,int l,int r,int x)\n{\n\tif(rt->l>=l&&rt->r<=r)\n\t{\n\t\trt->lazy+=x;\n\t\trt->num+=(rt->r-rt->l+1)*x;\n\t\treturn;\n\t}\n\tpush_down(rt);\n\tint m=(rt->l+rt->r)>>1;\n\tif(l<=m) xiugai(rt->lson,l,r,x);\n\tif(r>m) xiugai(rt->rson,l,r,x);\n\tpush_up(rt);\n}\nint query(tree *rt,int l,int r)\n{\n\tif(rt->l>=l&&rt->r<=r)\n\t{\n\t\treturn rt->num;\n\t}\n\tpush_down(rt);\n\tint m=(rt->l+rt->r)>>1,sum=0;\n\tif(l<=m) sum+=query(rt->lson,l,r);\n\tif(r>m) sum+=query(rt->rson,l,r);\n\tpush_up(rt);\n\treturn sum;\n}\nsigned main()\n{\n\tint n;\n\tint T,q;\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\ttot=0;\n\t\tcin>>n;\n\t\tbuild(t,1,n);\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tans+=query(t,x,n);\n\t\t\txiugai(t,x,x,1);\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tmemset(t,0,n);\n\t }\n }\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "sortings"], "dificulty": "1500", "interactive": false}