{"link": "https://codeforces.com//contest/1760/problem/E", "problemId": "1654042", "problem_idx": "E", "shortId": "1760E", "contest_number": "1760", "problem_submissions": {"F": [181970958, 181950281, 181958213, 181965757, 181944948, 181970759, 182137619, 181978710, 181975200, 182010196, 181966682, 181975500, 181975570, 182068449, 181971980, 181969952, 181982261, 181977736, 182001597, 182004425, 181959044, 181960815], "G": [181957910, 181964483, 181962348, 181994157, 181968737, 181984162, 181970230, 181984643, 181974424, 181996148, 181999866, 182000308, 182002923, 181998982, 182001075, 182008221, 181988981, 181982666, 181982848, 182019928], "D": [181925187, 181924159, 181926165, 181933690, 181961790, 181933549, 181948303, 181930557, 181924578, 181929764, 181933444, 181924258, 181934676, 181927528, 181934490, 181940229, 181930678, 181939059, 181941298, 181931472], "E": [181912280, 181936624, 181953534, 181942834, 181931986, 181946510, 181941618, 181954737, 181941455, 181949963, 181949921, 181956622, 181950008, 181945918, 181949626, 181947544, 181961711, 181955020, 181938685, 181941972], "C": [181906916, 181917198, 181915993, 181915337, 181922253, 181919151, 181912080, 181916644, 181911070, 181912168, 181914772, 181914699, 181915083, 181911256, 181917814, 181906724, 181913420, 181922501, 181911904, 181915134], "B": [181898180, 181911813, 181909417, 181906573, 181914704, 181908082, 181902374, 181901695, 181899205, 181901224, 181903533, 181905511, 181900583, 181898635, 181905113, 181899276, 181901539, 181906560, 181913258, 181900918], "A": [181894497, 181906833, 181903456, 181901896, 181908348, 181897559, 181894901, 181894647, 181894426, 181894493, 181895542, 181896483, 181894727, 181894560, 181895964, 181894478, 181895400, 181897142, 181898165, 181894344]}, "name": "E. Binary Inversions", "statement": "You are given a binary array^{\r\ndagger} of length n. You are allowed to perform one operation on it . In\r\nan operation, you can choose any element and flip it: turn a 0 into a 1\r\nor vice-versa.What is the maximum number of inversions^{\r\nddagger} the array can have after performing operation?^\r\ndagger A binary array is an array that contains only zeroes and ones.^\r\nddagger The number of inversions in an array is the number of pairs of\r\nindices i,j such that i<j and a_i > a_j.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define ios ios::sync_with_stdio(false); cin.tie(NULL);\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define fr first\n#define sc second\n#define int long long\n#define endl '\\n'\nvoid fopn(string name){\n  freopen((name+\".in\").c_str(),\"r\",stdin);\n  freopen((name+\".out\").c_str(),\"w\",stdout);\n}\nconst int INF=1e18,mod=1e9+7;\nint binpow(int a,int b){\n  int cur=1;\n  while(b){\n    if(b&1)\n      cur=(cur*a)%mod;\n    a*=a;\n    a%=mod;\n    b/=2;\n  }\n  return cur;\n}\nint n;\nint cnt(vector<int> vec){\n  int c=0,res=0;\n  for(int i=0;i<n;i++){\n    if(vec[i]) c++;\n    else res+=c;\n  }\n  return res;\n}\nvoid solve(){\n  cin>>n;\n  vector<int> vec(n),tmp;\n  for(int i=0;i<n;i++)\n    cin>>vec[i];\n  tmp=vec;\n  int res=cnt(vec);\n  for(int i=n-1;i>=0;i--)\n    if(tmp[i]==1){\n      tmp[i]=0;\n      break;\n    }\n  res=max(res,cnt(tmp));\n  tmp=vec;\n  for(int i=0;i<n;i++){\n    if(tmp[i]==0){\n      tmp[i]=1;\n      break;\n    }\n  }\n  res=max(res,cnt(tmp));\n  cout<<res<<endl;\n}\nmain(){\n  //fopn(\"balance\");\n  ios;\n  int T=1;\n  cin>>T;\n  while(T--){\n    solve();\n  }\n}"], "input": "", "output": "", "tags": ["data structures", "greedy", "math"], "dificulty": "1100", "interactive": false}