{
    "link": "https://codeforces.com//contest/1926/problem/F",
    "problemId": "2485156",
    "problem_idx": "F",
    "shortId": "1926F",
    "contest_number": "1926",
    "problem_submissions": {
        "G": [
            247563054,
            247320239,
            247350085,
            247352042,
            247335994,
            247324443,
            247354190,
            247343635,
            247343020,
            247361344,
            247364979,
            247352637,
            247358922,
            247365060,
            247361705,
            247335567,
            247361664,
            247363695,
            251544705,
            247357523,
            247364451
        ],
        "E": [
            247469870,
            247283178,
            247284072,
            247331325,
            247283022,
            247304643,
            247852629,
            247286675,
            247298689,
            247310427,
            247305094,
            247280999,
            247256640,
            247276246,
            247310244,
            247304899,
            247318176,
            247321426,
            247323263,
            251544548,
            247340094,
            247322326
        ],
        "D": [
            247426241,
            247263556,
            247421972,
            247278704,
            247339663,
            247271030,
            247272297,
            247843708,
            247274387,
            247287606,
            247268858,
            247276561,
            247270174,
            247312112,
            247330586,
            247287651,
            247258518,
            247306283,
            247265573,
            247299995,
            251545025,
            247267115,
            247289554
        ],
        "C": [
            247423997,
            247243871,
            247421569,
            247273658,
            252912334,
            247276036,
            247252892,
            247246007,
            247677422,
            247256159,
            247247059,
            247257359,
            247252723,
            247250177,
            247286681,
            247248462,
            247270959,
            247272136,
            247287839,
            247242436,
            247261191,
            251544976,
            247253706,
            247269016
        ],
        "B": [
            247423300,
            247238516,
            247244552,
            247285931,
            247246391,
            247234479,
            247655111,
            247237025,
            247257539,
            247250357,
            247235220,
            247246309,
            247261185,
            247239462,
            247243969,
            247244466,
            247253077,
            247236058,
            247250084,
            251545137,
            247244629,
            247257551
        ],
        "A": [
            247422269,
            247225900,
            247221565,
            247226674,
            247231661,
            247220620,
            247222897,
            247230070,
            247232373,
            247222228,
            247222168,
            247223439,
            247225539,
            247227948,
            247228394,
            247233059,
            247221337,
            247227237,
            251545212,
            247231544,
            247251666
        ],
        "F": [
            247339181,
            247336558,
            247364869,
            247371524,
            250524281,
            247428628
        ]
    },
    "name": "F. Vlad and Avoiding X",
    "statement": "Vladislav has a grid of size 7\r\ntimes 7, where each cell is colored black or white. In one operation, he\r\ncan choose any cell and change its color (black\r\nleftrightarrow white).Find the minimum number of operations required to\r\nensure that there are no black cells with four diagonal neighbors also\r\nbeing black.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x;scanf(\"%d\",&x);return x;\n}\nint f[8][2200],g[8],p3[10],dis[2200][2200],nxt[2200][200],chk[2200][200];\nchar s[10][10];\nvoid work()\n{\n    memset(f,0x3f,sizeof(f));\n    for(int i=1;i<=7;i++)\n    {\n        scanf(\"%s\",s[i]);\n        g[i]=0;\n        for(int j=0;j<7;j++)\n            g[i]=g[i]+((s[i][j]=='B')*p3[j]);//\u521d\u59cb2\u8fdb\u5236\u72b6\u6001\n    }\n    for(int j=0;j<p3[7];j++)\n        f[1][j]=dis[g[1]][j];\n    for(int i=1;i<7;i++)\n    {\n        for(int j=0;j<p3[7];j++)\n        {\n            if(f[i][j]==0x3f3f3f3f)\n                continue;\n            for(int k=0;k<128;k++)\n            {\n                if(chk[j][k]==0)//i\u548cj\u4e0d\u548c\n                    continue;\n                int nxtt=nxt[j][k];\n                f[i+1][nxtt]=min(f[i+1][nxtt],f[i][j]+dis[g[i+1]][nxtt]);\n            }\n        }\n    }\n    int ans=f[7][0];\n    for(int i=0;i<p3[7];i++)\n        ans=min(ans,f[7][i]);\n    cout<<ans<<'\\n';\n}\nint ask3(int x,int y)\n{\n    int sum=0;\n    while(x||y)\n    {\n        if(x%3==0&&y%3)\n            return 0x3f3f3f3f;\n        if(x%3&&y%3==0)\n            sum++;\n        x=x/3;\n        y=y/3;\n    }\n    return sum;\n}\nint check(int x,int y)\n{\n    int a[10],b[10];\n    for(int i=1;i<=7;i++)\n    {\n        a[i]=x%3;\n        b[i]=y%2;\n        x=x/3;\n        y=y/2;\n    }\n    for(int i=2;i<7;i++)\n        if(a[i]==2&&b[i-1]&&b[i+1])\n            return 0;\n    return 1;\n}\nint asknxt(int x,int y)\n{\n    int a[10],b[10];\n    for(int i=1;i<=7;i++)\n    {\n        a[i]=x%3;\n        b[i]=y%2;\n        x=x/3;\n        y=y/2;\n    }\n    int t=0;\n    for(int i=1;i<=7;i++)\n    {\n        if(i==1||i==7)\n            t=t+b[i]*p3[i-1];\n        else if(b[i]==1&&a[i-1]&&a[i+1])\n            t=t+2*p3[i-1];\n        else if(b[i])\n            t=t+p3[i-1];\n    }\n    return t;\n}\nint main() \n{\n    // freopen(\"1.in\",\"r\",stdin);\n    p3[0]=1;\n    for(int i=1;i<=7;i++)\n        p3[i]=p3[i-1]*3;\n    for(int i=0;i<p3[7];i++)\n        for(int j=0;j<128;j++)\n        {\n            chk[i][j]=check(i,j);\n            nxt[i][j]=asknxt(i,j);\n        }\n    for(int i=0;i<p3[7];i++)\n        for(int j=0;j<p3[7];j++)\n            dis[i][j]=ask3(i,j);\n    for(int t=read();t;t--)\n        work();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar",
        "dp",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. Vlad and Avoiding X.json",
    "editorial_link": "https://codeforces.com//blog/entry/126132",
    "editorial": "Notice that we can split the grid into two parts, red and blue, in a\r\nchessboard coloring fashion as shown, and that Xs from one color only\r\ninfluence cells of that color. This means that we can solve the problem\r\nfor the red and blue parts independently, and combine them at the end.\r\nLet\u00e2\u0080\u0099s brute force the number of cells in the blue part that we need to\r\nflip using backtracking (i.e. let\u00e2\u0080\u0099s brute force all ways we can flip\r\ncells and see if all the black cells work, then try flipping , then ,\r\nand so on). In fact, it can be shown that this number does not exceed ,\r\nby running this algorithm on an all-black grid. Similarly, we see that\r\nthe number of cells in the red part that we need to flip is also not\r\nmore than .The backtracking will try flips, and each takes around\r\noperations to check the whole grid, which not more than . This is not\r\nvery big, and even with test cases, it does not take more than 140\r\nmilliseconds. You can run the worst-case locally to check. Can this\r\nproblem be solved in polynomial time?\r\n"
}