{
    "link": "https://codeforces.com//contest/2044/problem/F",
    "problemId": "3086858",
    "problem_idx": "F",
    "shortId": "2044F",
    "contest_number": "2044",
    "problem_submissions": {
        "F": [
            296933150,
            296655063,
            296674411,
            296677763,
            296669954,
            296737361,
            296736034,
            296677816,
            296696398,
            296687386,
            296699481,
            296685099,
            296683886,
            296731517,
            296707787,
            296654373,
            296909091,
            296715340,
            296702594,
            296696190
        ],
        "G2": [
            296699390,
            296704280,
            296704818,
            298531131,
            296733068,
            296720698,
            296741262,
            296739720,
            296746308,
            296911444,
            296724382
        ],
        "H": [
            296697535,
            296733580,
            296740491,
            296722038,
            296725052,
            296682267,
            297077288,
            296716701,
            296694010,
            296739316,
            296709869
        ],
        "G1": [
            296659278,
            296653404,
            296691524,
            296692154,
            296687763,
            296690954,
            296714485,
            296708514,
            296694498,
            296722350,
            296692196,
            296714994,
            296716472,
            296675871,
            296678021,
            296689324,
            296711355,
            296718740,
            296717970
        ],
        "C": [
            296648915,
            296601876,
            296603677,
            296620266,
            296604632,
            296657618,
            296599716,
            296615593,
            296628687,
            296619240,
            296670537,
            297235105,
            296605830,
            296636731,
            296609140,
            296608950,
            296601490,
            296614087,
            296616894,
            296625117
        ],
        "E": [
            296623207,
            296640913,
            296636063,
            296663200,
            296642784,
            296664551,
            296656718,
            296657876,
            296674393,
            296649940,
            296693263,
            296657969,
            296721389,
            296645567,
            296630574,
            296667579,
            296641163,
            296648307,
            296683859
        ],
        "D": [
            296600718,
            296615344,
            296619619,
            296653987,
            296656132,
            296660646,
            296617887,
            302243346,
            296634501,
            296657055,
            296633273,
            296682986,
            296625109,
            296724190,
            296673253,
            296639245,
            296646292,
            296630851,
            296634818,
            296656565
        ],
        "B": [
            296590822,
            296591602,
            296590194,
            296602338,
            296593446,
            296653034,
            296591762,
            296620268,
            296615058,
            296600993,
            296669880,
            297230228,
            296596906,
            296631957,
            296596806,
            296598863,
            296591614,
            296604776,
            296608256,
            296609998
        ],
        "A": [
            296584122,
            296592381,
            296592956,
            296589246,
            296585131,
            296651916,
            296584578,
            296583609,
            296596837,
            296592612,
            296669080,
            297228403,
            296585930,
            296627664,
            296585567,
            296590101,
            296585364,
            296594212,
            296600836,
            296587924
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137306",
    "editorial": "Problem Credits: chromate00, Proof_by_QED Analysis: DivinePunishment Are\r\nyou a python user and failing test 12?This is an anti-hash test for\r\npython sets and dictionaries. Before you call us evil, we saved you from\r\ngetting hacked in open hack phase. Beware!\r\n",
    "name": "F. Easy Demon Problem",
    "statement": "For an arbitrary grid, Robot defines its to be the sum of elements in\r\nthe grid. Robot gives you an array a of length n and an array b of\r\nlength m. You construct a n by m grid M such that M_{i,j}=a_i\r\ncdot b_j for all 1\r\nleq i\r\nleq n and 1\r\nleq j\r\nleq m.Then, Robot gives you q queries, each consisting of a single\r\ninteger x. For each query, determine whether or not it is possible to\r\nperform the following operation once so that M has a of x: Choose\r\nintegers r and c such that 1\r\nleq r\r\nleq n and 1\r\nleq c\r\nleq m Set M_{i,j} to be 0 for all ordered pairs (i,j) such that i=r,\r\nj=c, or both. Note that queries are , meaning that you do not actually\r\nset any elements to 0 in the process you are only required to output if\r\nit is possible to find r and c such that if the above operation is\r\nperformed, the of the grid will be x. Also, note that you must perform\r\nthe operation for each query, even if the beauty of the original grid is\r\nalready x.\r\n",
    "solutions": [
        "/// YVKNTD#include <bits/stdc++.h>#define int long long#define ld long double#define f(i, a, b) for(int i = a; i <= b; i++)#define fr(i, a, b) for(int i = a; i >= b; i--)#define pii pair <int, int>#define fi first#define se second#define pb push_back#define eb emplace_back#define in insert#define arr(x) array <int, x>#define vvec vector<vector<int>>#define Keiiiii ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0); using namespace std; const int N = 2e5 + 5;const int mod = 1e9 + 7;const int inf = 1e16;int n, m, q, a[N], b[N], c[N], d[N];vector <int> g[N]; void READ(){    cin >> n >> m >> q;    f(i, 1, n) cin >> a[i];    f(i, 1, m) cin >> b[i];} bool mp[2*N],mp2[2*N]; //int Cal(int i, int j)//{//    int w = (b[j] - b[j - 1]);//    return a[i - 1] * b[m] + (a[n] - a[i]) * b[m] - (w * a[i - 1] + w * (a[n] - a[i]));////    a[i - 1] * (b[m] - w) + (a[n] - a[i]) * (b[m] - w)//    (b[m] - w) * (a[n] - a[i] + a[i - 1])////    (b[m] - Bj) * (a[n] - Ai)////} int dx[4][N]; int base=200000;void SOLVE(){    f(i, 1, n) c[i] = c[i - 1] + a[i];    f(i, 1, m) d[i] = d[i - 1] + b[i]; //    map <int, int> mp, mp2;    f(i, 1, n) {        if(c[n]-a[i]>200000||c[n]-a[i]<-200000)continue;        mp[c[n] - a[i]+base] = 1;    }    f(i, 1, m){        if(d[m]-b[i]>200000||d[m]-b[i]<-200000)continue;        mp2[d[m] - b[i]+base] = 1;    }     f(i, 1, 200000)        for(int j = i; j <= 200000; j += i) g[j].eb(i);     while(q--)    {        int x, ok = 0; cin >> x;        if(x < 0)        {            x = abs(x);            for(auto y : g[x])                if((mp[y+base] && mp2[-x / y+base]) || (mp[-y+base] && mp2[x / y+base]))                {                    cout << \"YES\\n\";                    ok = 1; break;                }        }        else        {            for(auto y : g[x])                if((mp[y+base] && mp2[x / y+base]) || (mp[-y+base] && mp2[-x / y+base]))                {                    cout << \"YES\\n\";                    ok = 1; break;                }        }        if(!ok) cout << \"NO\\n\";    }} signed main(){    Keiiiii    if(fopen(\"TASK.INP\", \"r\"))    {        freopen(\"TASK.INP\", \"r\", stdin);        freopen(\"TASK.OUT\", \"w\", stdout);    }    #define TASK \"C\"    if(fopen(TASK \".INP\", \"r\"))    {        freopen(TASK \".INP\", \"r\", stdin);        freopen(TASK \".OUT\", \"w\", stdout);    }    int TEST = 1;    while(TEST--)    {        READ();        SOLVE();    }    cerr << \"\\nTime elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s\\n\";    return 0;} ///    /\\_/\\///   (= ._.)///   / >  \\>"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. Easy Demon Problem.json",
    "hint": []
}