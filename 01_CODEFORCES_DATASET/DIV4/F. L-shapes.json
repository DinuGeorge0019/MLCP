{
    "link": "https://codeforces.com//contest/1722/problem/F",
    "problemId": "1524438",
    "problem_idx": "F",
    "shortId": "1722F",
    "contest_number": "1722",
    "problem_submissions": {
        "F": [
            170228432,
            170238760,
            170238447,
            170210010,
            170244311,
            170249847,
            170248990,
            170242753,
            170253987,
            170258155,
            170276802,
            170261239,
            170275384,
            170277690,
            170282251,
            170270200,
            170259586,
            170262035,
            170269336
        ],
        "G": [
            170201112,
            170239449,
            170242558,
            170231194,
            170252747,
            170261353,
            170265362,
            170245859,
            170241143,
            170270513,
            170254138,
            170230903,
            170246195,
            170265008,
            170257046,
            170286329,
            170267206,
            170289304,
            170253883
        ],
        "E": [
            170193046,
            170214495,
            170222070,
            170186508,
            170214137,
            170237586,
            170233277,
            170270766,
            170263452,
            170259315,
            170236844,
            170358200,
            170246843,
            170283220,
            170249250,
            170244656,
            170245016,
            170419946,
            170419889,
            170419820,
            170419722,
            170404871,
            170404830,
            170404803,
            170251944,
            170235689,
            170243907,
            170288376
        ],
        "B": [
            170184199,
            170175987,
            170182860,
            170222795,
            170174365,
            170177381,
            170174290,
            170175147,
            170180988,
            170176801,
            170176996,
            170185025,
            170178862,
            170179975,
            170177572,
            170174442,
            170196613,
            170178351,
            170176426
        ],
        "D": [
            170183156,
            170200419,
            170184918,
            170213538,
            170201758,
            170199636,
            170199991,
            170191578,
            170207198,
            170225091,
            170208494,
            170210667,
            170213605,
            170217491,
            170221636,
            170192639,
            170223864,
            170205720,
            170207316
        ],
        "C": [
            170177096,
            170190052,
            170201001,
            170214549,
            170180461,
            170183783,
            170184985,
            170181654,
            170191714,
            170190466,
            170186277,
            170194039,
            170659608,
            170191919,
            170201222,
            170193920,
            170181146,
            170213055,
            170187645,
            170193080
        ],
        "A": [
            170175728,
            170174285,
            170175641,
            170177482,
            170172907,
            170174547,
            170172857,
            170173111,
            170175353,
            170173745,
            170174044,
            170177681,
            170172889,
            170175006,
            170172831,
            170173065,
            170200391,
            170175631,
            170172819
        ]
    },
    "name": "F. L-shapes",
    "statement": "An L-shape is a figure on gridded paper that looks like the first four\r\npictures below. An L-shape contains exactly three shaded cells (denoted\r\nby ), which can be rotated in any way. You are given a rectangular grid.\r\nDetermine if it contains L-shapes only, where L-shapes can’t touch an\r\nedge or corner. More formally: Each shaded cell in the grid is part of\r\nexactly one L-shape, and no two L-shapes are adjacent by edge or corner.\r\nFor example, the last two grids in the picture above satisfy the\r\ncondition because the two L-shapes touch by corner and edge,\r\nrespectively.\r\n",
    "solutions": [
        "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define md(a) a=(a%mod+mod)%mod\n#define file(a) freopen(#a\".in\",\"r\",stdin);freopen(#a\".out\",\"w\",stdout)\nint T;\nint n,m,tot;\nint a[55][55],v[55][55];\nint dx[8]={-1,-1,-1,0,0,1,1,1},dy[8]={-1,0,1,-1,1,-1,0,1};\nint check(int x,int y)\n{\n\tint ans=a[x][y]+a[x+1][y]+a[x][y+1]+a[x+1][y+1];\n\tif(ans==4)return 2;\n\tif(ans<3)return 0;\n\ttot++;\n\tif(a[x][y]&&v[x][y])return 2;\n\tif(a[x+1][y]&&v[x+1][y])return 2;\n\tif(a[x][y+1]&&v[x][y+1])return 2;\n\tif(a[x+1][y+1]&&v[x+1][y+1])return 2;\n\t\n\tif(a[x][y])v[x][y]=tot;\n\tif(a[x+1][y])v[x+1][y]=tot;\n\tif(a[x][y+1])v[x][y+1]=tot;\n\tif(a[x+1][y+1])v[x+1][y+1]=tot;\n\treturn 1;\n}\nbool chk(int x,int y)\n{\n\tfor(int i=0;i<=7;i++)\n\t{\n\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\tif(tx<1||ty<1||tx>n||ty>m)continue;\n\t\tif(v[tx][ty]>0&&v[tx][ty]!=v[x][y])return false;\n\t}\n\treturn true;\n}\nvoid solve()\n{\n\tscanf(\"%d%d\",&n,&m);tot=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tchar c;cin>>c;v[i][j]=0;\n\t\t\tif(c=='.')a[i][j]=0;\n\t\t\telse a[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=1;j<=m-1;j++)\n\t\t{\n\t\t\tbool r=check(i,j);\n\t\t\tif(r==2)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(a[i][j]&&v[i][j]==0)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(!v[i][j])continue;\n\t\t\tif(chk(i,j)==false)\n\t\t\t{\n\t\t\t\tputs(\"NO\");\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"YES\");\n\treturn ;\n}\nsigned main()\n{\n\tscanf(\"%d\",&T);\n\twhile(T--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. L-shapes.json",
    "editorial_link": "https://codeforces.com//blog/entry/106478",
    "editorial": "The problem is mainly a tricky implementation problem. Letâs denote the\r\nof an L-shape as the square in the middle (the one that is side-adjacent\r\nto two other squares). Every elbow is part of exactly one L-shape, and\r\nevery L-shape has exactly one elbow.Iterate through the grid and count\r\nthe number of side-adjacent neighbors they have. If there is a cell with\r\nmore than 2, or if there is a cell with exactly two neighbors on\r\nopposite sides, then the answer is . Otherwise, if there are exactly 2\r\nneighbors, this cell is an elbow. Mark all three cells of this L-shape\r\nwith a unique number (say, mark the first one you find with , the second\r\nwith , and so on.) If you ever remark a cell that already has a number,\r\nthen two elbows are adjacent, and you can output .After all elbows are\r\nmarked, check if all shaded cells have a number. If some donât, then\r\nthey are not part of an L-shape, so you can output .Finally, we should\r\ncheck that L-shapes donât share edge or corner. Just check, for each\r\nnumber, if it is only diagonally adjacent to other numbers equal to it\r\nor unshaded cells. If it is diagonally adjacent to other unequal\r\nnumbers, then the answer is , because two L-shapes share an edge or\r\ncorner then.Otherwise the answer is .There are many other solutions, all\r\nof which are various ways to check the conditions. The complexity is per\r\ntestcase.\r\n",
    "hint": []
}