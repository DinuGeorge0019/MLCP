{
    "link": "https://codeforces.com//contest/1703/problem/F",
    "problemId": "1459220",
    "problem_idx": "F",
    "shortId": "1703F",
    "contest_number": "1703",
    "problem_submissions": {
        "G": [
            163879354,
            163876701,
            163880552,
            163887554,
            163881906,
            163893756,
            164072213,
            163895080,
            163898333,
            163903459,
            163892881,
            163905274,
            163897275,
            163901266,
            163873117,
            163892493,
            163905636,
            163901566,
            163923296,
            163907786
        ],
        "F": [
            163850998,
            163858977,
            163853177,
            163846137,
            163922692,
            163855752,
            163876304,
            163853951,
            163874504,
            163871177,
            163873109,
            163859383,
            163873709,
            163873018,
            163856287,
            163879014,
            163887365,
            163879906,
            163862907,
            163875738
        ],
        "E": [
            163848798,
            163850755,
            163868103,
            163869552,
            163867675,
            163862143,
            163872743,
            163857154,
            163830638,
            163880434,
            163870578,
            163865786,
            163867906,
            163915635,
            163866711,
            163863745,
            163871687,
            163844531,
            163865925
        ],
        "D": [
            163827889,
            163832881,
            163833809,
            163835348,
            163842692,
            163839970,
            163839327,
            163847394,
            163853863,
            163832997,
            163851832,
            163851452,
            163835633,
            163842486,
            163871782,
            163837033,
            163852428,
            163846440,
            163842230
        ],
        "C": [
            163817923,
            163823865,
            163824885,
            163813762,
            164128413,
            163827461,
            163825229,
            163824848,
            163834560,
            163829456,
            163822136,
            163825218,
            163840368,
            163823674,
            163824378,
            163823979,
            163825333,
            163830007,
            163824841,
            163830416
        ],
        "B": [
            163811054,
            163815361,
            163814856,
            163807606,
            163816423,
            163812311,
            163813269,
            163818089,
            163841436,
            163811359,
            163816169,
            163825648,
            163813873,
            163814791,
            163816214,
            163817003,
            163814838,
            163815021,
            163816164
        ],
        "A": [
            163806945,
            163807884,
            163806991,
            163805874,
            163808042,
            163806851,
            163807428,
            163808801,
            163823605,
            163807286,
            163806888,
            163816037,
            163805969,
            163807627,
            163807835,
            163808519,
            163807784
        ]
    },
    "name": "F. Yet Another Problem About Pairs Satisfying an Inequality",
    "statement": "You are given an array a_1, a_2,\r\ndots a_n. Count the number of pairs of indices 1\r\nleq i, j\r\nleq n such that a_i < i < a_j < j.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include \"../debug.h\"\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(\"../input.txt\")\n#define finish cout << \"\\ntime: \" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n\tfstart;\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n; cin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto& x : a) {\n\t\t\tcin >> x;\n\t\t\tx--;\n\t\t}\n\n\t\tvector<int> lessThanI(n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] < i) {\n\t\t\t\tlessThanI[i] = 1;\n\t\t\t}\n\t\t\tif (i)\n\t\t\t\tlessThanI[i] += lessThanI[i - 1];\n\t\t}\n\t\t\n\t\tll res = 0;\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tif (a[j] >= j)\n\t\t\t\tcontinue;\n\t\t\tif (a[j] - 1 >= 0)\n\t\t\t\tres += lessThanI[a[j] - 1];\n\t\t}\n\n\t\tcout << res << \"\\n\";\n\t}\n\n\n\tfinish;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. Yet Another Problem About Pairs Satisfying an Inequality.json",
    "editorial_link": "https://codeforces.com//blog/entry/104786",
    "editorial": "Call a pair if it satisfies the condition. Letâs split the inequality\r\ninto three parts: , , .Note that if for any , then it canât be an\r\nelement of a good pair, because it fails the first and third conditions.\r\nSo we can throw out all elements of the array satisfying .For the\r\nremaining elements, the first and third inequalities are already\r\nsatisfied, so we only have to count the number of pairs with . Letâs\r\niterate through the array from the left to the right, and make a list\r\nstoring all that appear before . Then for each , count the number of\r\nless than by binary searching on the number of elements in the list less\r\nthan . Afterwards, add to the end of the list.Since we iterate from left\r\nto right, the list will always remain sorted (we insert the indices of\r\nelements, which are increasing from left to right), so the binary search\r\nwill always work.The time complexity is .\r\n",
    "hint": []
}