{
    "link": "https://codeforces.com//contest/1950/problem/D",
    "problemId": "2558686",
    "problem_idx": "D",
    "shortId": "1950D",
    "contest_number": "1950",
    "problem_submissions": {
        "G": [
            253752808,
            253791090,
            253792008,
            253764902,
            253795589,
            253769074,
            253798975,
            253810097,
            253794272,
            253806572,
            253813747,
            253817544,
            253814202,
            253820188,
            253820718,
            253701692,
            253694242,
            253726954,
            253792725,
            253718355
        ],
        "E": [
            253730988,
            253727783,
            253735577,
            253792087,
            253719212,
            253895656,
            253750540,
            253762185,
            253739498,
            253800957,
            253757755,
            253752930,
            253767006,
            253801529,
            253796303,
            253779059,
            253809431,
            253784597,
            253786784,
            253792918
        ],
        "F": [
            253716265,
            253756464,
            253746198,
            253848623,
            253757177,
            253795775,
            253775127,
            253790779,
            253735759,
            253790063,
            253778217,
            253795618,
            253777001,
            253808966,
            253809890,
            253750694,
            253768469,
            253787295,
            253772046
        ],
        "D": [
            253705197,
            253693713,
            253712924,
            253751781,
            253734348,
            253699707,
            253753088,
            253692073,
            253733558,
            253726765,
            253750400,
            253763569,
            253732867,
            253761387,
            253761597,
            253792055,
            253785952,
            253817703
        ],
        "C": [
            253676736,
            253709228,
            253688733,
            253683884,
            253710826,
            253702025,
            253688277,
            253692812,
            253687570,
            253701456,
            253687791,
            253700929,
            253695724,
            253682026,
            253784794,
            253798795,
            253798170,
            253797860,
            253824205
        ],
        "B": [
            253657996,
            253671803,
            253670916,
            253669157,
            253704746,
            253674410,
            253676969,
            253678023,
            253688393,
            253673296,
            253673178,
            253675511,
            253706337,
            253667871,
            253770768,
            253802339,
            253794136,
            253800371
        ],
        "A": [
            253646923,
            253671091,
            253650433,
            253650458,
            253649919,
            253656018,
            253663176,
            253648214,
            253648172,
            253672711,
            253656568,
            253658223,
            253654413,
            253650536,
            253773310,
            253803285,
            253782783,
            253796569
        ]
    },
    "name": "D. Product of Binary Decimals",
    "statement": "Let’s call a number a if it is a positive integer and all digits in its\r\ndecimal notation are either 0 or 1. For example, 1\r\n,010\r\n,111 is a binary decimal, while 10\r\n,201 and 787\r\n,788 are not.Given a number n, you are asked whether or not it is\r\npossible to represent n as a product of some (not necessarily distinct)\r\nbinary decimals.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin >> t;\n    vector<int> pos;\n    for(int i = 0; i < (1 << 6); i++){\n        string s;\n        for(int j = 0; j < 6; j++){\n            if(i & (1 << j)){\n                s += '1';\n            }\n            else{\n                s += '0';\n            }\n        }\n        if(s == \"000000\"){\n            continue;\n        }\n        pos.push_back(atoi(s.c_str()));\n    }\n    vector<bool> dp(100001, false);\n    dp[1] = true;\n    for(int i = 2; i <= 100000; i++){\n        for(int j : pos){\n            if(i % j == 0){\n                dp[i] = (dp[i] | dp[i/j]);\n                if(dp[i]){\n                    break;\n                }\n            }\n        }\n    }\n    while(t--){\n        int n;\n        cin >> n;\n        if(dp[n]){\n            cout << \"YES\\n\";\n        }\n        else{\n            cout << \"NO\\n\";\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation",
        "number theory"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\D. Product of Binary Decimals.json",
    "editorial_link": "https://codeforces.com//blog/entry/127664",
    "editorial": "First, let’s make precompute list of all binary decimals at most . You\r\ncan do it in many ways, for example iterating through all numbers up to\r\nand checking if each is a binary decimal.Let’s call a number if it can\r\nbe represented as the product of binary decimals. For each test case, we\r\nwill write a simple recursive function. is good if: , or is good, for\r\nsome binary decimal . We can check by hand (or code) that the number of\r\nbinary decimals is not more than , so the solution should not take too\r\nlong in practice even without memoization. You can test it locally on\r\nall inputs to check. This is enough to solve the problem; see the\r\nimplementation for more details.Even if your implementation is slightly\r\ntoo slow, there are not many good numbers; you can simply precompute\r\nthem all locally and hardcode them to get a solution that works in . we\r\nwill compute an upper bound on the complexity, given by the (rather\r\nloose) recurrence By the Akra-Bazzi method, where is the (unique) real\r\nnumber satisfying . This is probably fast enough, and this is still a\r\nvery large overestimate.A more accurate estimate can be made by picking\r\nthe solution to , which gives a bound .\r\n",
    "hint": []
}