{
    "link": "https://codeforces.com//contest/1669/problem/H",
    "problemId": "1375145",
    "problem_idx": "H",
    "shortId": "1669H",
    "contest_number": "1669",
    "problem_submissions": {
        "G": [
            154338818,
            154338717,
            154337757,
            154347239,
            154330463,
            154358615,
            154344991,
            154342734,
            154343427,
            154345997,
            154348528,
            154339221,
            154350435,
            154348936,
            154352650,
            154348973,
            154344667,
            154352809,
            154336273
        ],
        "H": [
            154331237,
            154345510,
            154346497,
            154331204,
            154335233,
            154339134,
            154340438,
            154353755,
            154348422,
            154352485,
            154359777,
            154327486,
            154363645,
            154353057,
            154360024,
            154352195,
            154320401,
            154364197,
            154347849
        ],
        "F": [
            154326611,
            154329913,
            154332429,
            154337655,
            154392121,
            154390664,
            154319576,
            154333879,
            154333441,
            154337277,
            154337756,
            154338882,
            154338830,
            154337237,
            154339275,
            154344124,
            154341576,
            154343153,
            155263505,
            154351950,
            154345352,
            154352516
        ],
        "E": [
            154321071,
            154318987,
            154325315,
            154326268,
            154308179,
            154321973,
            154333738,
            154331065,
            154331572,
            154332028,
            154326905,
            154331804,
            154329919,
            154333767,
            154329024,
            154337762,
            154361103,
            154333067,
            154320761
        ],
        "D": [
            154308627,
            154314076,
            154319392,
            154318723,
            154344171,
            154313281,
            154320255,
            154318829,
            154324313,
            154318456,
            154317854,
            154354990,
            154313571,
            154324214,
            154320094,
            154324716,
            154333520,
            154315781,
            154315288
        ],
        "C": [
            154296991,
            154301080,
            154302713,
            154304165,
            154324147,
            154314217,
            154293254,
            154298772,
            154304074,
            154306415,
            154304598,
            154300492,
            154301916,
            154299882,
            154304832,
            154301287,
            154300146,
            154302144,
            154300936
        ],
        "B": [
            154290688,
            154292351,
            154293527,
            154297221,
            154311833,
            154293953,
            154288332,
            154290033,
            154293504,
            154297685,
            154295630,
            154290642,
            154294501,
            154290966,
            154291078,
            154291641,
            154291379,
            154291165,
            154293202
        ],
        "A": [
            154287096,
            154287966,
            154287366,
            154290324,
            154288950,
            154288119,
            154286901,
            154287272,
            154287157,
            154287426,
            154288579,
            154287301,
            154287929,
            154287457,
            154287452,
            154287569,
            154287308,
            154287228,
            154288852
        ]
    },
    "name": "H. Maximal AND",
    "statement": "Let\r\nmathsf{AND} denote the bitwise AND operation, and\r\nmathsf{OR} denote the bitwise OR operation.You are given an array a of\r\nlength n and a non-negative integer k. You can perform k operations on\r\nthe array of the following type: Select an index i (1\r\nleq i\r\nleq n) and replace a_i with a_i\r\nmathsf{OR} 2^j where j is any integer between 0 and 30 . In other words,\r\nin an operation you can choose an index i (1\r\nleq i\r\nleq n) and set the j-th bit of a_i to 1 (0\r\nleq j\r\nleq 30). Output the maximum possible value of a_1\r\nmathsf{AND} a_2\r\nmathsf{AND}\r\ndots\r\nmathsf{AND} a_n after performing k operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n, k;\n  cin >> n >> k;\n  int a[n];\n  vector<int> cnt(31);\n  rep(i, n){\n    cin >> a[i];\n\n    for(int j = 0; j <= 30; ++j){\n      if(a[i] & (1 << j)) cnt[j]++;\n    }\n  }\n  int res = 0;\n  for(int i = 30; i >= 0; --i){\n    int t = n - cnt[i];\n    if(t <= k) {\n      k -= t;\n      res += (1 << i);\n    }\n  }\n  cout << res << '\\n';\n}\n\n\nint main()\n{\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << \"Case #\" << i << \": \";\n      solve();\n    }\n    return 0;\n}   "
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\H. Maximal AND.json",
    "editorial_link": "https://codeforces.com//blog/entry/102101",
    "editorial": "The optimal strategy is to greedily take the highest bit we have enough\r\noperations to set in every array element. To do this, we maintain a\r\ncount for each bit with the number of elements that have it set already.\r\nThe cost to set the -th bit will be . We go from the highest bit to the\r\nlowest: If we have enough operations left, we set the bit, subtract its\r\ncost from the operations and move to the next lower bit. If we donât\r\nhave enough operations, we move on to the next lower bit and donât\r\nmodify the operations. We stop once we processed bit .The time\r\ncomplexity is .\r\n",
    "hint": []
}