{
    "link": "https://codeforces.com//contest/1807/problem/F",
    "problemId": "1838166",
    "problem_idx": "F",
    "shortId": "1807F",
    "contest_number": "1807",
    "problem_submissions": {
        "F": [
            198180616,
            198186190,
            198173908,
            198171005,
            198219904,
            198227866,
            198217508,
            198214833,
            198204632,
            198200151,
            198214050,
            198189193,
            198185762,
            198231970,
            198235896,
            198228554,
            198239515,
            198209832,
            198220721
        ],
        "E": [
            198163239,
            198186188,
            198149936,
            198201671,
            198171057,
            198193404,
            198177128,
            198162416,
            198182729,
            198179440,
            198203385,
            198195116,
            198366866,
            198157434,
            198167075,
            198178694,
            198189166,
            198158428,
            198165846,
            198162136,
            198158251
        ],
        "G2": [
            198145015,
            198137148,
            198195227,
            198182421,
            198178727,
            198158742,
            198185869,
            198169755,
            198175371,
            198176448,
            198178249,
            198206149,
            198207584,
            198189902,
            198168732,
            198178571,
            198181264,
            198198169,
            198185162
        ],
        "B": [
            198143870,
            198138728,
            198120221,
            198130226,
            198126207,
            198130685,
            198126856,
            198135177,
            198139105,
            198122438,
            198125411,
            198126062,
            198128046,
            198121277,
            198121825,
            198130142,
            198124129,
            198132199,
            198137528
        ],
        "C": [
            198133948,
            198146211,
            198132638,
            198137869,
            198139227,
            198143163,
            198136231,
            198148066,
            198130077,
            198135106,
            198133973,
            198134982,
            198136576,
            198131022,
            198135217,
            198139552,
            198137513,
            198141347,
            198131804
        ],
        "G1": [
            198133059,
            198150338,
            198182849,
            198183462,
            198175914,
            198147239,
            198178480,
            198168437,
            198173855,
            198176599,
            198168261,
            198206516,
            198197738,
            198173520,
            198161260,
            198169179,
            198182940,
            198185108,
            198185266
        ],
        "A": [
            198122998,
            198125805,
            198110843,
            198112403,
            198113641,
            198115780,
            198114548,
            198114635,
            198110722,
            198110785,
            198111172,
            198116447,
            198110883,
            198111058,
            198110866,
            198116237,
            198114064,
            198122835,
            198110735
        ],
        "D": [
            198122742,
            198156287,
            198129356,
            198145081,
            198138349,
            198158337,
            198148123,
            198154214,
            198156828,
            198147860,
            198147020,
            198142203,
            198146687,
            198137100,
            198147269,
            198146571,
            198144778,
            198146944,
            198142568
        ]
    },
    "name": "F. Bouncy Ball",
    "statement": "You are given a room that can be represented by a n\r\ntimes m grid. There is a ball at position (i_1, j_1) (the intersection\r\nof row i_1 and column j_1), and it starts going diagonally in one of the\r\nfour directions: The ball is going down and right, denoted by\r\ntexttt{DR}; it means that after a step, the ball\u2019s location goes from\r\n(i, j) to (i+1, j+1). The ball is going down and left, denoted by\r\ntexttt{DL}; it means that after a step, the ball\u2019s location goes from\r\n(i, j) to (i+1, j-1). The ball is going up and right, denoted by\r\ntexttt{UR}; it means that after a step, the ball\u2019s location goes from\r\n(i, j) to (i-1, j+1). The ball is going up and left, denoted by\r\ntexttt{UL}; it means that after a step, the ball\u2019s location goes from\r\n(i, j) to (i-1, j-1). After each step, the ball maintains its direction\r\nunless it hits a wall (that is, the direction takes it out of the room\u2019s\r\nbounds in the next step). In this case, the ball\u2019s direction gets\r\nflipped along the axis of the wall; if the ball hits a corner, both\r\ndirections get flipped. Any instance of this is called a . The ball\r\nnever stops moving. In the above example, the ball starts at (1, 7) and\r\ngoes\r\ntexttt{DL} until it reaches the bottom wall, then it bounces and\r\ncontinues in the direction\r\ntexttt{UL}. After reaching the left wall, the ball bounces and continues\r\nto go in the direction\r\ntexttt{UR}. When the ball reaches the upper wall, it bounces and\r\ncontinues in the direction\r\ntexttt{DR}. After reaching the bottom-right corner, it bounces and\r\ncontinues in direction\r\ntexttt{UL}, and so on.Your task is to find how many bounces the ball\r\nwill go through until it reaches cell (i_2, j_2) in the room, or report\r\nthat it never reaches cell (i_2, j_2) by printing -1.Note that the ball\r\nfirst goes in a cell and only after that bounces if it needs to.\r\n",
    "solutions": [
        "#include \"iostream\"\n#include \"vector\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"bitset\"\n#include \"set\"\n#include \"numeric\"\n#include \"iomanip\"\n#include \"random\"\n\n#define sz(x) (int)(x.size())\n#define ll long long\n#define int long long\n#define pii pair <int, int>\n#define x first\n#define y second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\nusing namespace std;\n\nvoid solve() {\n    ll n, m, x1, y1, y2, x2;\n    cin >> n >> m >> y1 >> x1 >> y2 >> x2;\n    vector <vector <int> > v(n + 1, vector <int> (m + 1, 1e9));\n    vector <vector <vector <bool> > > f(n + 1, vector <vector <bool> > (m + 1, vector <bool> (5)));\n    map <string, pii> mp;\n    map <string, int> mp1;\n    map <char, char> rev;\n    rev['D'] = 'U';\n    rev['U'] = 'D';\n    rev['R'] = 'L';\n    rev['L'] = 'R';\n    mp[\"DR\"] = {1, 1};\n    mp1[\"DR\"] = 0;\n    mp[\"DL\"] = {1, -1};\n    mp1[\"DL\"] = 1;\n    mp[\"UR\"] = {-1, 1};\n    mp1[\"UR\"] = 2;\n    mp[\"UL\"] = {-1, -1};\n    mp1[\"UL\"] = 3;\n    string s;\n    cin >> s;\n    int cnt = 0;\n\n    while (true) {\n        auto p = mp[s];\n        int ff = 0;\n        if (y1 + p.x == 0 || y1 + p.x == n + 1) {\n            s[0] = rev[s[0]];\n            ff = 1;\n        }\n        if (x1 + p.y == 0 || x1 + p.y == m + 1) {\n//            cout << x1 + p.y << \" \" << m + 1 << \"\\n\";\n            s[1] = rev[s[1]];\n            ff = 1;\n        }\n//        cout << y1 << \" \" << x1 << \" \" << ff << \" \" << s << \"\\n\";\n        v[y1][x1] = min(v[y1][x1], cnt);\n        cnt += ff;\n        if (ff) {\n            if (f[y1][x1][mp1[s]]) break;\n        }\n\n//        cout << \"oih u \\n\";\n        f[y1][x1][mp1[s]] = true;\n        p = mp[s];\n        x1 += p.y;\n        y1 += p.x;\n//        cout << y1 << \" \" << x1 << \"\\n\";\n        if (f[y1][x1][mp1[s]]) break;\n        f[y1][x1][mp1[s]] = true;\n        v[y1][x1] = min(v[y1][x1], cnt);\n    }\n    if (v[y2][x2] == 1e9) {\n        cout << \"-1\\n\";\n    } else {\n        cout << v[y2][x2] << \"\\n\";\n    }\n//    cout << endl;\n}\n\n\nsigned main() {\n//    freopen(\"monument.in\", \"r\", stdin);\n//    freopen(\"monument.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. Bouncy Ball.json",
    "editorial_link": "https://codeforces.com//blog/entry/114143",
    "editorial": "We can see that there are at most states the ball can be in, because\r\nthere are cells and states of direction. We can simulate the bouncing\r\nprocess, keeping count of the bounces until we arrive at the finish cell\r\nwhen we can output the answer, or we arrive at a previously visited\r\nstate and end up in a loop, then we can output -1.Bonus: Can you prove\r\nthere are at most states for any given starting position?\r\n"
}