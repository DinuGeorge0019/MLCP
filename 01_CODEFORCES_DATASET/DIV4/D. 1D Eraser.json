{
    "link": "https://codeforces.com//contest/1873/problem/D",
    "problemId": "2221682",
    "problem_idx": "D",
    "shortId": "1873D",
    "contest_number": "1873",
    "problem_submissions": {
        "H": [
            224421005,
            224434092,
            224442548,
            224444884,
            224429353,
            224447629,
            224472578,
            224490336,
            224458760,
            224430156,
            224460036,
            224462926,
            224435033,
            224472482,
            224481019,
            224449100,
            224483491,
            224433014,
            224471630,
            224479428,
            224475403
        ],
        "G": [
            224398181,
            224401164,
            224406254,
            224419325,
            224390522,
            224417167,
            224412361,
            224491010,
            224422915,
            224393328,
            224420921,
            224431335,
            224428005,
            224461695,
            224433846,
            224414175,
            224421807,
            224419744,
            224467586,
            224447652,
            224433855,
            224437230
        ],
        "F": [
            224372046,
            224373122,
            224369498,
            224376246,
            224381924,
            224384518,
            224380906,
            224491225,
            224481536,
            224395224,
            224381572,
            224389323,
            224371276,
            224387884,
            224382851,
            224393366,
            224366956,
            224396140,
            224366592,
            224366858,
            224395356,
            224377385
        ],
        "E": [
            224351156,
            224353080,
            224351100,
            224360822,
            224403130,
            224369607,
            224358415,
            224491425,
            224480694,
            224357946,
            224402533,
            224366854,
            224602579,
            224359354,
            224365737,
            224362005,
            224365741,
            224361557,
            224362119,
            224348462,
            224348889,
            224364484,
            224357405
        ],
        "D": [
            224343671,
            224346367,
            224341008,
            224347817,
            224351861,
            225552572,
            224357522,
            224350305,
            224491613,
            224346294,
            224350871,
            224349059,
            224351191,
            224335809,
            224349390,
            224353266,
            224340309,
            224353771,
            224342181,
            224337374,
            224355000,
            224348839
        ],
        "C": [
            224337317,
            224347812,
            224333882,
            224342868,
            224346028,
            224353403,
            224341122,
            224491794,
            224473860,
            224340219,
            224345973,
            224343076,
            224341381,
            224328086,
            224345135,
            224347766,
            224333608,
            224342383,
            224333130,
            224326218,
            224346669,
            224342595
        ],
        "B": [
            224326298,
            224314681,
            224323874,
            224324627,
            224340005,
            224323358,
            224320429,
            224491990,
            224472953,
            224328963,
            224341975,
            224350409,
            224325787,
            224320523,
            224331239,
            236759133,
            224330676,
            224329098,
            224328659,
            224318318,
            224316431,
            224328354,
            224330230
        ],
        "A": [
            224318982,
            224312408,
            224314383,
            224315684,
            224321438,
            224315171,
            224314404,
            224492113,
            224312687,
            224319303,
            224318527,
            224317026,
            224317557,
            224312751,
            224317923,
            224324437,
            224315252,
            224312917,
            224312520,
            224316486,
            224314729
        ]
    },
    "name": "D. 1D Eraser",
    "statement": "You are given a strip of paper s that is n cells long. Each cell is\r\neither black or white. In an operation you can take any k consecutive\r\ncells and make them all white.Find the minimum number of operations\r\nneeded to remove all black cells.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << \"\\n\";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << \" \" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? \"YES\": \"NO\") << \"\\n\"; }\n\n\nvoid solve(){\n    int n, k; cin >> n >> k;\n    str s; cin >> s;\n    int it = 0, ans = 0;\n    while(it < n){\n        if(s[it] == 'W'){\n            it++;\n            continue;\n        }\n        ans++;\n        for(int i = 0; i < k and it + i < n; ++i)\n            s[it + i] = 'W';\n    }\n    cout << ans << \"\\n\";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\D. 1D Eraser.json",
    "editorial_link": "https://codeforces.com//blog/entry/120634",
    "editorial": "The key idea is greedy. Let\u00e2\u0080\u0099s go from the left to the right, and if the\r\ncurrent cell is black, we should use the operation starting at this cell\r\n(it may go off the strip, but that\u00e2\u0080\u0099s okay, we can always shift it\r\nleftwards to contain all the cells we need it to).We can implement this\r\nin : iterate from left to right with a variable , and when you see a\r\nblack cell, you should skip the next cells (because the eraser will take\r\ncare of them) and increase the number of operations by . The answer is\r\nthe total number of operations.Why does it work? Notice the order of\r\noperations doesn\u00e2\u0080\u0099t matter. Consider the leftmost black cell we erase. It\r\nmeans none of the cells to its right are black. So it doesn\u00e2\u0080\u0099t make sense\r\nto use the operation on any of the cells to its right, since they are\r\nalready white. It is at least as good to use the operation starting at\r\nthis cell and to the cells on the left, since we may or may not hit\r\nanother black cell.\r\n"
}