{"link": "https://codeforces.com//contest/1807/problem/C", "problemId": "1838163", "problem_idx": "C", "shortId": "1807C", "contest_number": "1807", "problem_submissions": {"F": [198180616, 198186190, 198173908, 198171005, 198219904, 198227866, 198217508, 198214833, 198204632, 198200151, 198214050, 198189193, 198185762, 198231970, 198235896, 198228554, 198239515, 198209832, 198220721], "E": [198163239, 198186188, 198149936, 198201671, 198171057, 198193404, 198177128, 198162416, 198182729, 198179440, 198203385, 198195116, 198366866, 198157434, 198167075, 198178694, 198189166, 198158428, 198165846, 198162136, 198158251], "G2": [198145015, 198137148, 198195227, 198182421, 198178727, 198158742, 198185869, 198169755, 198175371, 198176448, 198178249, 198206149, 198207584, 198189902, 198168732, 198178571, 198181264, 198198169, 198185162], "B": [198143870, 198138728, 198120221, 198130226, 198126207, 198130685, 198126856, 198135177, 198139105, 198122438, 198125411, 198126062, 198128046, 198121277, 198121825, 198130142, 198124129, 198132199, 198137528], "C": [198133948, 198146211, 198132638, 198137869, 198139227, 198143163, 198136231, 198148066, 198130077, 198135106, 198133973, 198134982, 198136576, 198131022, 198135217, 198139552, 198137513, 198141347, 198131804], "G1": [198133059, 198150338, 198182849, 198183462, 198175914, 198147239, 198178480, 198168437, 198173855, 198176599, 198168261, 198206516, 198197738, 198173520, 198161260, 198169179, 198182940, 198185108, 198185266], "A": [198122998, 198125805, 198110843, 198112403, 198113641, 198115780, 198114548, 198114635, 198110722, 198110785, 198111172, 198116447, 198110883, 198111058, 198110866, 198116237, 198114064, 198122835, 198110735], "D": [198122742, 198156287, 198129356, 198145081, 198138349, 198158337, 198148123, 198154214, 198156828, 198147860, 198147020, 198142203, 198146687, 198137100, 198147269, 198146571, 198144778, 198146944, 198142568]}, "name": "C. Find and Replace", "statement": "You are given a string s consisting of lowercase Latin characters. In an\r\noperation, you can take a character and replace occurrences of this\r\ncharacter with\r\ntexttt{0} or replace occurrences of this character with\r\ntexttt{1}.Is it possible to perform some number of moves so that the\r\nresulting string is an alternating binary string^{\r\ndagger}? For example, consider the string\r\ntexttt{abacaba}. You can perform the following moves: Replace\r\ntexttt{a} with\r\ntexttt{0}. Now the string is\r\ncolor{red}{\r\ntexttt{0}}\r\ntexttt{b}\r\ncolor{red}{\r\ntexttt{0}}\r\ntexttt{c}\r\ncolor{red}{\r\ntexttt{0}}\r\ntexttt{b}\r\ncolor{red}{\r\ntexttt{0}}. Replace\r\ntexttt{b} with\r\ntexttt{1}. Now the string is {\r\ntexttt{0}}\r\ncolor{red}{\r\ntexttt{1}}{\r\ntexttt{0}}\r\ntexttt{c}{\r\ntexttt{0}}\r\ncolor{red}{\r\ntexttt{1}}{\r\ntexttt{0}}. Replace\r\ntexttt{c} with\r\ntexttt{1}. Now the string is {\r\ntexttt{0}}{\r\ntexttt{1}}{\r\ntexttt{0}}\r\ncolor{red}{\r\ntexttt{1}}{\r\ntexttt{0}}{\r\ntexttt{1}}{\r\ntexttt{0}}. This is an alternating binary string. ^{\r\ndagger}An is a string of\r\ntexttt{0}s and\r\ntexttt{1}s such that no two adjacent bits are equal. For example,\r\ntexttt{01010101},\r\ntexttt{101},\r\ntexttt{1} are alternating binary strings, but\r\ntexttt{0110},\r\ntexttt{0a0a0},\r\ntexttt{10100} are not.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ld double\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define line cout << '\\n'\n\n#define sz(v) ((int)(v).size())\nconst double pi = 3.1415926535897932384626433832795;\n\nconst long long mod = 998244353;\nconst long long inf = 9099999999999999999;\nconst long long nmax = 4e5 + 100;\nconst long double eps = 1e-9;\n\nrandom_device rd;\nmt19937 rnd(rd());\n//rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n//int MAGIC = rnd();\n\nvoid runtimeerror() {\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector <int> d(27, -1);\n  for (int i = 0; i < n; i++) {\n    if (i % 2 == 0) {\n      if (d[s[i] - 'a'] == -1 || d[s[i] - 'a'] == 0) {\n        d[s[i] - 'a'] = 0;\n      }\n      else {\n        cout << \"NO\" << '\\n';\n        return;\n      }\n    }\n    else {\n      if (d[s[i] - 'a'] == -1 || d[s[i] - 'a'] == 1) {\n        d[s[i] - 'a'] = 1;\n      }\n      else {\n        cout << \"NO\" << '\\n';\n        return;\n      }\n    }\n  }\n\n  cout << \"YES\" << '\\n';\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n\n  //  freopen(\"input.txt\", \"r\", stdin);\n  //  freopen(\"output.txt\", \"w\", stdout);\n\n  ll t = 1;\n    cin >> t;\n  while (t--)\n    runtimeerror();\n\n  //  cout << \"WINNER\";\n  // i'm stupid man\n}"], "input": "", "output": "", "tags": ["greedy", "implementation", "strings"], "dificulty": "800", "interactive": false}