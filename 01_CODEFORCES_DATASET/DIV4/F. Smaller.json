{"link": "https://codeforces.com//contest/1742/problem/F", "problemId": "1584061", "problem_idx": "F", "shortId": "1742F", "contest_number": "1742", "problem_submissions": {"F": [176088434, 175953044, 175949290, 175945773, 175971876, 175956188, 175957305, 175965256, 175956666, 175986547, 175967228, 175990142, 175973277, 175995491, 175965274, 175965118, 175981574, 175999797, 175962842, 175951834], "G": [176088369, 175967459, 175958531, 175962640, 175942664, 175961452, 175978946, 175980978, 175996879, 175961906, 175978933, 175980234, 175974556, 175962390, 175992279, 176006662, 175998640, 175988444, 175973867, 176011912], "E": [175929743, 175927916, 175936666, 175943925, 175935324, 175941784, 175923888, 175943247, 175943495, 175938334, 175943285, 175964043, 175940442, 175952017, 175952132, 175946109, 175938097, 175944046, 175930209], "D": [175922448, 175917700, 175931114, 175925762, 175903264, 175930423, 175912934, 175931204, 175933934, 175950019, 175928370, 175923385, 175918999, 175933942, 175925951, 175937215, 175924390, 175931438, 175917485], "C": [175911573, 175932064, 175915066, 175911109, 175944918, 175919477, 175930954, 175917347, 175913405, 175915900, 175916495, 175915920, 175929840, 175935658, 175910930, 175920672, 175928041, 175977210, 175909445], "B": [175896747, 175892645, 175906800, 175897939, 175914560, 175901372, 175894798, 175901141, 175900477, 175897511, 175903643, 175902169, 175897218, 175901587, 175895073, 175910023, 175914406, 175902476, 175898799], "A": [175891011, 175890670, 175898330, 175892580, 175898679, 175893875, 175890834, 175893408, 175892512, 175891126, 175892054, 175894976, 175891245, 175892986, 175890956, 175896962, 175898765, 175893870, 175893102]}, "name": "F. Smaller", "statement": "Alperen has two strings, s and t which are both initially equal to \"\".\r\nHe will perform q operations of two types on the given strings: 1\r\n;\r\n; k\r\n;\r\n; x Append the string x exactly k times at the end of string s. In other\r\nwords, s := s +\r\nunderbrace{x +\r\ndots + x}_{k\r\ntext{ times}}. 2\r\n;\r\n; k\r\n;\r\n; x Append the string x exactly k times at the end of string t. In other\r\nwords, t := t +\r\nunderbrace{x +\r\ndots + x}_{k\r\ntext{ times}}. After each operation, determine if it is possible to the\r\ncharacters of s and t such that s is lexicographically smaller^{\r\ndagger} than t.Note that the strings change after performing each\r\noperation and go back to their initial states.^{\r\ndagger} Simply speaking, the lexicographical order is the order in which\r\nwords are listed in a dictionary. A formal definition is as follows:\r\nstring p is lexicographically smaller than string q if there exists a\r\nposition i such that p_i < q_i, and for all j < i, p_j = q_j. If no such\r\ni exists, then p is lexicographically smaller than q if the length of p\r\nis less than the length of q. For example,\r\ntexttt{abdc} <\r\ntexttt{abe} and\r\ntexttt{abc} <\r\ntexttt{abcd}, where we write p < q if p is lexicographically smaller\r\nthan q.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\n#define vi vector<int>\n\nvoid solve()\n{\n\tmap<char,int> m1,m2;\n\tm1['a']++;\n\tm2['a']++;\n\n\tint q;\n\tcin>>q;\n     int len1=1,len2=1;\n\twhile(q--)\n\t{\n\t\tint p;\n\t\tcin>>p;\n\n\t\t int k;\n\t\t cin>>k;\n\t\t string a;\n\t\t cin>>a;\n\n\t\t map<char,int> temp;\n\t\t for(int i=0;i<a.size();i++)\n\t\t \t temp[a[i]]++;\n\n\t\t for(auto x:temp)\n\t\t {\n\t\t \t if(p==1)\n\t\t \t {\n\t\t \t \t m1[x.first]+=(x.second*k);\n\t\t \t \t len1+=(x.second*k);\n\t\t \t }\n\t\t \t else\n\t\t \t {\n\t\t \t \tlen2+=(x.second*k);\n\t\t \t \tm2[x.first]+=(x.second*k);\n\t\t \t }\n\t\t }\n       bool ans=false;\n\n         char first='a';\n         while(m1[first]==0)\n         {\n         \t first++;\n         }\n\n         for(char a1=first+1;a1<='z';a1++)\n         {\n         \t if(m2[a1])\n         \t {\n         \t \t ans=true;\n         \t \t break;\n         \t }\n         }\n\n       //cout<<first<<endl;\n          if((len1==m1[first]) and (m2[first]>len1))\n          {\n          \t ans=true;\n          }\n\n          if(ans)\n          \t cout<<\"YES\"<<endl;\n          \telse\n          \t\tcout<<\"NO\"<<endl;\n\n\n\n        \n\n\t}\n}\n\nint32_t main()\n{\n\t int t=1;\n\n\t cin>>t;\n\n\t while(t--)\n\t {\n\t \t solve();\n\t }\n\t return 0;\n}                                    "], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "strings"], "dificulty": "1500", "interactive": false}