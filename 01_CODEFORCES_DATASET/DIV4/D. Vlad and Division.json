{
    "link": "https://codeforces.com//contest/1926/problem/D",
    "problemId": "2485154",
    "problem_idx": "D",
    "shortId": "1926D",
    "contest_number": "1926",
    "problem_submissions": {
        "G": [
            247563054,
            247320239,
            247350085,
            247352042,
            247335994,
            247324443,
            247354190,
            247343635,
            247343020,
            247361344,
            247364979,
            247352637,
            247358922,
            247365060,
            247361705,
            247335567,
            247361664,
            247363695,
            251544705,
            247357523,
            247364451
        ],
        "E": [
            247469870,
            247283178,
            247284072,
            247331325,
            247283022,
            247304643,
            247852629,
            247286675,
            247298689,
            247310427,
            247305094,
            247280999,
            247256640,
            247276246,
            247310244,
            247304899,
            247318176,
            247321426,
            247323263,
            251544548,
            247340094,
            247322326
        ],
        "D": [
            247426241,
            247263556,
            247421972,
            247278704,
            247339663,
            247271030,
            247272297,
            247843708,
            247274387,
            247287606,
            247268858,
            247276561,
            247270174,
            247312112,
            247330586,
            247287651,
            247258518,
            247306283,
            247265573,
            247299995,
            251545025,
            247267115,
            247289554
        ],
        "C": [
            247423997,
            247243871,
            247421569,
            247273658,
            252912334,
            247276036,
            247252892,
            247246007,
            247677422,
            247256159,
            247247059,
            247257359,
            247252723,
            247250177,
            247286681,
            247248462,
            247270959,
            247272136,
            247287839,
            247242436,
            247261191,
            251544976,
            247253706,
            247269016
        ],
        "B": [
            247423300,
            247238516,
            247244552,
            247285931,
            247246391,
            247234479,
            247655111,
            247237025,
            247257539,
            247250357,
            247235220,
            247246309,
            247261185,
            247239462,
            247243969,
            247244466,
            247253077,
            247236058,
            247250084,
            251545137,
            247244629,
            247257551
        ],
        "A": [
            247422269,
            247225900,
            247221565,
            247226674,
            247231661,
            247220620,
            247222897,
            247230070,
            247232373,
            247222228,
            247222168,
            247223439,
            247225539,
            247227948,
            247228394,
            247233059,
            247221337,
            247227237,
            251545212,
            247231544,
            247251666
        ],
        "F": [
            247339181,
            247336558,
            247364869,
            247371524,
            250524281,
            247428628
        ]
    },
    "name": "D. Vlad and Division",
    "statement": "Vladislav has n non-negative integers, and he wants to divide of them\r\ninto several groups so that in any group, any pair of numbers does not\r\nhave matching bit values among bits from 1-st to 31-st bit (i.e.,\r\nconsidering the 31 least significant bits of the binary\r\nrepresentation).For an integer k, let k_2(i) denote the i-th bit in its\r\nbinary representation (from right to left, indexing from 1). For\r\nexample, if k=43, since 43=101011_2, then 43_2(1)=1, 43_2(2)=1,\r\n43_2(3)=0, 43_2(4)=1, 43_2(5)=0, 43_2(6)=1, 43_2(7)=0, 43_2(8)=0,\r\ndots, 43_2(31)=0.What is the minimum number of groups Vlad needs to\r\nachieve his goal? Each number must fall into exactly one group.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve()\n{\n\tint n;\n\tcin>>n;\n\tint ans=0;\n\tmap<int,int>cnt;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tif(!cnt[x])\n\t\t{\n\t\t\tans++,cnt[((1<<31)-1)^x]++;\n\t\t//\tcnt[x]++;\n\t\t}\n\t\telse cnt[x]--;\n\t\t//if(!cnt[x]) ++ans, ++cnt[((1 << 31) - 1) ^ x];\n\t}\n\tcout<<ans<<\"\\n\";\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\D. Vlad and Division.json",
    "editorial_link": "https://codeforces.com//blog/entry/126132",
    "editorial": "We can notice that a group contains either one or two numbers. Now, we\r\ncheck how many numbers we can pair together. The condition that all bits\r\nin a pair differ is equivalent to the pair resulting in a number which\r\nhas all bits set as when we XOR the numbers. So, we need to see the\r\nnumber of pairs for which their XOR is equal to (As this is the number\r\nwith all bits set). Now, we iterate through the numbers in order from\r\nleft to right, we check if we can pair the current number with some\r\nexisting previous one. We can check if the number can be paired with\r\nsome previous one if we encountered the value of XOR in the past. If we\r\nhave, we mark that value and the current value as taken, and donât start\r\na new group, otherwise we start a new group and continue the process.\r\n",
    "hint": []
}