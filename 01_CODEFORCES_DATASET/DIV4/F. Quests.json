{
    "link": "https://codeforces.com//contest/1760/problem/F",
    "problemId": "1654043",
    "problem_idx": "F",
    "shortId": "1760F",
    "contest_number": "1760",
    "problem_submissions": {
        "F": [
            181970958,
            181950281,
            181958213,
            181965757,
            181944948,
            181970759,
            182137619,
            181978710,
            181975200,
            182010196,
            181966682,
            181975500,
            181975570,
            182068449,
            181971980,
            181969952,
            181982261,
            181977736,
            182001597,
            182004425,
            181959044,
            181960815
        ],
        "G": [
            181957910,
            181964483,
            181962348,
            181994157,
            181968737,
            181984162,
            181970230,
            181984643,
            181974424,
            181996148,
            181999866,
            182000308,
            182002923,
            181998982,
            182001075,
            182008221,
            181988981,
            181982666,
            181982848,
            182019928
        ],
        "D": [
            181925187,
            181924159,
            181926165,
            181933690,
            181961790,
            181933549,
            181948303,
            181930557,
            181924578,
            181929764,
            181933444,
            181924258,
            181934676,
            181927528,
            181934490,
            181940229,
            181930678,
            181939059,
            181941298,
            181931472
        ],
        "E": [
            181912280,
            181936624,
            181953534,
            181942834,
            181931986,
            181946510,
            181941618,
            181954737,
            181941455,
            181949963,
            181949921,
            181956622,
            181950008,
            181945918,
            181949626,
            181947544,
            181961711,
            181955020,
            181938685,
            181941972
        ],
        "C": [
            181906916,
            181917198,
            181915993,
            181915337,
            181922253,
            181919151,
            181912080,
            181916644,
            181911070,
            181912168,
            181914772,
            181914699,
            181915083,
            181911256,
            181917814,
            181906724,
            181913420,
            181922501,
            181911904,
            181915134
        ],
        "B": [
            181898180,
            181911813,
            181909417,
            181906573,
            181914704,
            181908082,
            181902374,
            181901695,
            181899205,
            181901224,
            181903533,
            181905511,
            181900583,
            181898635,
            181905113,
            181899276,
            181901539,
            181906560,
            181913258,
            181900918
        ],
        "A": [
            181894497,
            181906833,
            181903456,
            181901896,
            181908348,
            181897559,
            181894901,
            181894647,
            181894426,
            181894493,
            181895542,
            181896483,
            181894727,
            181894560,
            181895964,
            181894478,
            181895400,
            181897142,
            181898165,
            181894344
        ]
    },
    "name": "F. Quests",
    "statement": "There are n quests. If you complete the i-th quest, you will gain a_i\r\ncoins. You can only complete at most one quest per day. However, once\r\nyou complete a quest, you cannot do the same quest again for k days.\r\n(For example, if k=2 and you do quest 1 on day 1, then you cannot do it\r\non day 2 or 3, but you can do it again on day 4.)You are given two\r\nintegers c and d. Find the maximum value of k such that you can gain at\r\nleast c coins over d days. If no such k exists, output . If k can be\r\narbitrarily large, output .\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#define endl \"\\n\"\n#define ll long long\n#define int long long\n#define ld long double\n#define fr first\n#define sc second\n#define pb push_back\n#define pf push_front\n#define mpa make_pair\nusing namespace std;\nusing namespace __gnu_pbds;\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\nvoid fre(string s){freopen((s+\".in\").c_str(),\"r\",stdin);freopen((s+\".out\").c_str(),\"w\",stdout);}\nvoid start(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n}\nconst ll N = 3e5+7;\nconst ll inf=1e9+7;\nvector <ll> v;\nll pr[N];\nll m,c=0,d,ans=0,mn=inf,mxx=-1;\nll n,k;\nbool check(ll a){\n    ll sum=0;\n    for(ll i=0;i<=a;i++){\n        if(i>=n) break;\n        sum+=((d/(a+1))*v[i]);\n        if(d%(a+1)>i) sum+=v[i];\n    }\n    if(sum>=c) return true;\n    else return false;\n}\nvoid solve(){\n    v.clear();\n    ll i,j,y,x;\n    ll a,b=0,up,l,r,i1=-1;\n    cin>>n>>c>>d;\n    for(i=0;i<n;i++){\n        pr[i]=0;\n        cin>>b;\n        v.pb(b);\n    }\n    sort(v.rbegin(),v.rend());\n    for(i=0;i<n;i++){\n        if(i==0){\n            pr[i]=v[i];\n        }\n        else pr[i]=v[i]+pr[i-1];\n    }\n    i=0;\n    if((pr[0]*d)<c) {cout<<\"Impossible\"<<endl;return;}\n    if(pr[min(d-1,n-1)]>=c) {cout<<\"Infinity\"<<endl;return;}\n    l=0;\n    r=d+1;\n    while(l<r){\n        ll mid=(l+r)/2;\n        if(check(mid)){\n            l=mid;\n        }\n        else r=mid;\n        if(l+1 == r) break;\n    }\n    cout<<l<<endl;\n}\nmain(){\n    //fre(\"pump\");\n    start();\n    ll t=1;\n    cin>>t;\n    while(t--)solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\F. Quests.json",
    "editorial_link": "https://codeforces.com//blog/entry/109348",
    "editorial": "Letâs fix and find the maximum number of coins we can get. Here we can\r\ndo a greedy solution: at every step, we should always take the most\r\nrewarding quest. (Intuitively, it makes sense, since doing more\r\nrewarding quests earlier allows us to do them again later.) If no quests\r\nare available, we do nothing. To implement this, sort the quests in\r\ndecreasing order, and -index them. On day we should do quest , provided\r\nthat this value is less than . This is because after every days, we\r\ncycle back to the first quest. Thus we solved the problem for a fixed in\r\nwith precomputation to sort the array.Now to solve the problem, we can\r\nbinary search on the answer, since if some works, then all smaller work.\r\nThe minimum value of is , and the maximum value is (for larger , we\r\nwonât be able to do the same quest multiple times anyways, so itâs\r\nuseless to consider them). If we find that always goes towards the\r\nsmaller end of our binary search and still fails, we output . If we find\r\nthat always goes towards the larger end of our binary search and still\r\nfails, we output . Otherwise, just output .The overall time complexity\r\nis . It is not hard to improve the solution to . Originally, I proposed\r\nthe problem this way, but we ended up removing this part of the problem\r\nbecause the implementation of this solution was tricky enough.\r\n",
    "hint": []
}