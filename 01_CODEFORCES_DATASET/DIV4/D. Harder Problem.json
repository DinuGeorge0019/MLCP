{
    "link": "https://codeforces.com//contest/2044/problem/D",
    "problemId": "3086855",
    "problem_idx": "D",
    "shortId": "2044D",
    "contest_number": "2044",
    "problem_submissions": {
        "F": [
            296933150,
            296655063,
            296674411,
            296677763,
            296669954,
            296737361,
            296736034,
            296677816,
            296696398,
            296687386,
            296699481,
            296685099,
            296683886,
            296731517,
            296707787,
            296654373,
            296909091,
            296715340,
            296702594,
            296696190
        ],
        "G2": [
            296699390,
            296704280,
            296704818,
            298531131,
            296733068,
            296720698,
            296741262,
            296739720,
            296746308,
            296911444,
            296724382
        ],
        "H": [
            296697535,
            296733580,
            296740491,
            296722038,
            296725052,
            296682267,
            297077288,
            296716701,
            296694010,
            296739316,
            296709869
        ],
        "G1": [
            296659278,
            296653404,
            296691524,
            296692154,
            296687763,
            296690954,
            296714485,
            296708514,
            296694498,
            296722350,
            296692196,
            296714994,
            296716472,
            296675871,
            296678021,
            296689324,
            296711355,
            296718740,
            296717970
        ],
        "C": [
            296648915,
            296601876,
            296603677,
            296620266,
            296604632,
            296657618,
            296599716,
            296615593,
            296628687,
            296619240,
            296670537,
            297235105,
            296605830,
            296636731,
            296609140,
            296608950,
            296601490,
            296614087,
            296616894,
            296625117
        ],
        "E": [
            296623207,
            296640913,
            296636063,
            296663200,
            296642784,
            296664551,
            296656718,
            296657876,
            296674393,
            296649940,
            296693263,
            296657969,
            296721389,
            296645567,
            296630574,
            296667579,
            296641163,
            296648307,
            296683859
        ],
        "D": [
            296600718,
            296615344,
            296619619,
            296653987,
            296656132,
            296660646,
            296617887,
            302243346,
            296634501,
            296657055,
            296633273,
            296682986,
            296625109,
            296724190,
            296673253,
            296639245,
            296646292,
            296630851,
            296634818,
            296656565
        ],
        "B": [
            296590822,
            296591602,
            296590194,
            296602338,
            296593446,
            296653034,
            296591762,
            296620268,
            296615058,
            296600993,
            296669880,
            297230228,
            296596906,
            296631957,
            296596806,
            296598863,
            296591614,
            296604776,
            296608256,
            296609998
        ],
        "A": [
            296584122,
            296592381,
            296592956,
            296589246,
            296585131,
            296651916,
            296584578,
            296583609,
            296596837,
            296592612,
            296669080,
            297228403,
            296585930,
            296627664,
            296585567,
            296590101,
            296585364,
            296594212,
            296600836,
            296587924
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137306",
    "editorial": "Problem Credits: cry, Proof_by_QED Analysis: macaquedev Solution Observe\r\nthat if you have an array where all elements are unique, they will all\r\nhave frequency , therefore they can all be classified as the mode.\r\nTherefore, it follows that the strategy for the construction is to just\r\nconstruct an array where for each prefix, the last element of this\r\nprefix appears in the array at least once. An easy way of doing is this\r\nis such:For each element , if this value has appeared previously in the\r\narray (you can use a set to check this), set equal to some random\r\ninteger that isnât used elsewhere in the list , and keep going.\r\nOtherwise, set .\r\n",
    "name": "D. Harder Problem",
    "statement": "Given a sequence of positive integers, a positive integer is called a of\r\nthe sequence if it occurs the maximum number of times that any positive\r\ninteger occurs. For example, the mode of [2,2,3] is 2. Any of 9, 8, or 7\r\ncan be considered to be a mode of the sequence [9,9,8,8,7,7]. You gave\r\nUFO an array a of length n. To thank you, UFO decides to construct\r\nanother array b of length n such that a_i is a mode of the sequence\r\n[b_1, b_2,\r\nldots, b_i] for all 1\r\nleq i\r\nleq n. However, UFO doesn’t know how to construct array b, so you must\r\nhelp her. Note that 1\r\nleq b_i\r\nleq n must hold for your array for all 1\r\nleq i\r\nleq n.\r\n",
    "solutions": [
        "/// YVKNTD#include <bits/stdc++.h>#define int long long#define ld long double#define f(i, a, b) for(int i = a; i <= b; i++)#define fr(i, a, b) for(int i = a; i >= b; i--)#define pii pair <int, int>#define fi first#define se second#define pb push_back#define eb emplace_back#define in insert#define arr(x) array <int, x>#define vvec vector<vector<int>>#define Keiiiii ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0); using namespace std; const int N = 2e5 + 5;const int mod = 1e9 + 7;const int inf = 1e16;int n, a[N]; void READ(){    cin >> n;    f(i, 1, n) cin >> a[i];} void SOLVE(){    set <int> s;    f(i, 1, n) s.in(i);    f(i, 1, n)    {        if(s.find(a[i]) != s.end()) cout << a[i] << \" \", s.erase(a[i]);        else cout << *s.begin() << \" \", s.erase(s.begin());    }    cout << \"\\n\";} signed main(){    Keiiiii    if(fopen(\"TASK.INP\", \"r\"))    {        freopen(\"TASK.INP\", \"r\", stdin);        freopen(\"TASK.OUT\", \"w\", stdout);    }    #define TASK \"C\"    if(fopen(TASK \".INP\", \"r\"))    {        freopen(TASK \".INP\", \"r\", stdin);        freopen(TASK \".OUT\", \"w\", stdout);    }    int TEST = 1; cin >> TEST;    while(TEST--)    {        READ();        SOLVE();    }    cerr << \"\\nTime elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s\\n\";    return 0;} ///    /\\_/\\///   (= ._.)///   / >  \\>"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\D. Harder Problem.json",
    "hint": []
}