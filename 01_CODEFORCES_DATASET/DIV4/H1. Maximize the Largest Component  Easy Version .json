{
    "link": "https://codeforces.com//contest/1985/problem/H1",
    "problemId": "2693244",
    "problem_idx": "H1",
    "shortId": "1985H1",
    "contest_number": "1985",
    "problem_submissions": {
        "H2": [
            265333958,
            265329942,
            265374762,
            265463376,
            265409850,
            265351075
        ],
        "H1": [
            265304421,
            265299704,
            265357822,
            265323224,
            265337141,
            265317283,
            265460730,
            265316153,
            265348936,
            265366976,
            265339269,
            265346344,
            265357275,
            265361186,
            265337987,
            265334505,
            265306082,
            265333344,
            265334310,
            265354855,
            265343925,
            265371157
        ],
        "G": [
            265288874,
            265285319,
            265308921,
            265294504,
            265294389,
            265349930,
            265333888,
            265302787,
            265321226,
            265321550,
            265314648,
            265319240,
            265320919,
            265319004,
            265351809,
            265347102,
            265363396,
            265321287,
            265334515
        ],
        "F": [
            265257998,
            265258336,
            265333805,
            265266191,
            265268417,
            265271517,
            265282573,
            265284015,
            265291933,
            265287030,
            265294216,
            265292426,
            265308217,
            265434837,
            265263951,
            265284551,
            265298432,
            265310548,
            265350787,
            265303880
        ],
        "E": [
            265247823,
            265268762,
            265279707,
            265250320,
            265260021,
            265260461,
            265269987,
            265268916,
            265276148,
            265277202,
            265271686,
            265278947,
            265288365,
            265270779,
            265321070,
            265309211,
            265281402,
            265290891,
            265283574
        ],
        "D": [
            265235702,
            265239453,
            265240274,
            265240512,
            265241523,
            265246501,
            265258934,
            265252788,
            265235638,
            265251750,
            265255373,
            265255903,
            265267987,
            265248169,
            265284904,
            265257354,
            265249745,
            265271001,
            265260658
        ],
        "C": [
            265224906,
            265231755,
            265230963,
            265229487,
            265231546,
            265231239,
            265250492,
            265242728,
            265240303,
            265242396,
            265240944,
            265239306,
            265248406,
            265232912,
            265250913,
            265243972,
            265239446,
            265242638,
            265248246,
            265243103
        ],
        "B": [
            265217781,
            265226807,
            265225301,
            265218520,
            265227661,
            265222521,
            265233641,
            265228462,
            265227301,
            265231808,
            265227127,
            265229582,
            265225549,
            265222424,
            265237127,
            265233502,
            265228316,
            265225179,
            265231906
        ],
        "A": [
            265211682,
            265215627,
            265211806,
            265211700,
            265213517,
            265214069,
            265212496,
            265216202,
            265212886,
            265212184,
            265216504,
            265214755,
            265214870,
            265213138,
            265212889,
            265220571,
            265212383,
            265212109,
            265213889
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129620",
    "editorial": "Let's first solve the problem if we can only select and fill rows. Columns can be handled in the exact same way.\n\nFor each row r\n, we need to find the size of the component formed by filling row r\n (i.e. the size of the component containing row r\n if we set all cells in row r\n to be #\n).\n\nThe size of the component containing row r\n if we set all cells in row r\n to be #\n will be the sum of:\n\nThe number of .\n in row r\n since these cells will be set to #\n. Let Fr\n denote this value for some row r\n.\nThe sum of sizes of components containing a cell in either row r?1\n, r\n, or r+1\n (i.e. components that are touching row r\n). This is since these components will be part of the component containing row r\n. Let Rr\n denote this value for some row r\n.\nThe challenge is computing the second term quickly. For some component, let s\n be the size of the component and let rmin\n and rmax\n denote the minimum and maximum row of a cell in the component. This means that the component will contain cells with rows rmin,rmin+1,...,rmax\n. Note that we can find these values with a dfs. Since the component will contribute s\n to rows in [rmin?1,rmin,\u0085rmax+1]\n, we add s\n to Rrmin?1,Rrmin,\u0085,Rrmax+1\n. This can be done naively or with prefix sums.\n\nWe find the maximum Fr+Rr\n and then handle columns in the same way. This solution runs in O(nm)\n time.",
    "name": "H1. Maximize the Largest Component  Easy Version ",
    "statement": "Alex has a grid with n rows and m columns consisting of \u201d and \u201d\r\ncharacters. A set of \u201d cells forms a connected component if from any\r\ncell in this set, it is possible to reach any other cell in this set by\r\nonly moving to another cell in the set that shares a . The size of a\r\nconnected component is the number of cells in the set.In one operation,\r\nAlex selects any row r (1\r\nle r\r\nle n) any column c (1\r\nle c\r\nle m), then sets every cell in row r column c to be \u201d. Help Alex find\r\nthe maximum possible size of the largest connected component of \u201d cells\r\nthat he can achieve after performing the operation .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\u00a0struct DSU{\tvector<int> e;\tvoid init(int n)\t{\t\te.assign(n, -1);\t}\tint get(int x)\t{\t\tif (e[x] < 0) return x;\t\treturn e[x] = get(e[x]);\t}\tvoid unite(int x, int y)\t{\t\tx = get(x), y = get(y);\t\tif (x == y) return;\t\tif (e[x] > e[y]) swap(x, y);\t\te[x] += e[y];\t\te[y] = x;\t}};\u00a0const int MXN = 1e6 + 5;const int mod = 1e9 + 7;\u00a0int A[4] = {0, 0, -1, 1};int B[4] = {-1, 1, 0, 0};int used[MXN];\u00a0void _(){\tint n, m;\tcin >> n >> m;\tDSU dsu;\tdsu.init(n * m);\tstring s[n];\tfor (int i = 0; i < n; i++) cin >> s[i];\tfor (int i = 0; i < n; i++)\t{\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m) \t\t\t\t{\t\t\t\t\tif (s[i][j] == '#' && s[x][y] == '#') dsu.unite(i * m + j, x * m + y);\t\t\t\t}\t\t\t}\t\t}\t}\tint mx = max(n, m);\tfor (int i = 0; i < n * m; i++) mx = max(mx, -dsu.e[dsu.get(i)]);\tfor (int i = 0; i < n; i++)\t{\t\tvector<int> v;\t\tint sum = 0;\t\tfor (int j = 0; j < m; j++)\t\t{\t\t\tif (s[i][j] == '.') sum++;\t\t\telse if (!used[dsu.get(i * m + j)]) \t\t\t{\t\t\t\tsum += -dsu.e[dsu.get(i * m + j)];\t\t\t\tused[dsu.get(i * m + j)] = 1;\t\t\t\tv.push_back(dsu.get(i * m + j));\t\t\t}\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m)\t\t\t\t{\t\t\t\t\tif (s[x][y] == '#') \t\t\t\t\t{\t\t\t\t\t\tif (!used[dsu.get(x * m + y)])\t\t\t\t\t\t{\t\t\t\t\t\t\tsum += -dsu.e[dsu.get(x * m + y)];\t\t\t\t\t\t\tused[dsu.get(x * m + y)] = 1;\t\t\t\t\t\t\tv.push_back(dsu.get(x * m + y));\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tmx = max(mx, sum);\t\tfor (int i : v) used[i] = 0;\t}\tfor (int j = 0; j < m; j++)\t{\t\tvector<int> v;\t\tint sum = 0;\t\tfor (int i = 0; i < n; i++)\t\t{\t\t\tif (s[i][j] == '.') sum++;\t\t\telse if (!used[dsu.get(i * m + j)]) \t\t\t{\t\t\t\tsum += -dsu.e[dsu.get(i * m + j)];\t\t\t\tused[dsu.get(i * m + j)] = 1;\t\t\t\tv.push_back(dsu.get(i * m + j));\t\t\t}\t\t\tfor (int k = 0; k < 4; k++)\t\t\t{\t\t\t\tint x = i + A[k], y = j + B[k];\t\t\t\tif (x >= 0 && x < n && y >= 0 && y < m)\t\t\t\t{\t\t\t\t\tif (s[x][y] == '#') \t\t\t\t\t{\t\t\t\t\t\tif (!used[dsu.get(x * m + y)])\t\t\t\t\t\t{\t\t\t\t\t\t\tsum += -dsu.e[dsu.get(x * m + y)];\t\t\t\t\t\t\tused[dsu.get(x * m + y)] = 1;\t\t\t\t\t\t\tv.push_back(dsu.get(x * m + y));\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tmx = max(mx, sum);\t\tfor (int i : v) used[i] = 0;\t}\tcout << mx << '\\n';}\u00a0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\tfor (int tt = 1; tt <= t; tt++)\t{\t\t_();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\H1. Maximize the Largest Component  Easy Version .json"
}