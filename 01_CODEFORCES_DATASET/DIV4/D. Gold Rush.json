{
    "link": "https://codeforces.com//contest/1829/problem/D",
    "problemId": "1910848",
    "problem_idx": "D",
    "shortId": "1829D",
    "contest_number": "1829",
    "problem_submissions": {
        "H": [
            204823379,
            204818792,
            204824435,
            204813179,
            204829782,
            204824942,
            204824891,
            204831475,
            204829116,
            204812904,
            204820548,
            204813548,
            204853253,
            204828645,
            204819513,
            204862189,
            205152847,
            205152752,
            204813060,
            204833324,
            204856160
        ],
        "G": [
            204812415,
            204813072,
            204810737,
            204879903,
            204839324,
            204821300,
            204841768,
            204857522,
            204849840,
            204855874,
            204857412,
            204830495,
            204842991,
            204871081,
            204827619,
            204848652,
            204850787,
            204810246,
            204848842,
            204865545,
            204844410
        ],
        "F": [
            204795243,
            204797952,
            204799327,
            204802021,
            204800634,
            204808672,
            204802889,
            204801401,
            204800071,
            204801746,
            204812847,
            204814366,
            204820676,
            204827118,
            204799702,
            204893918,
            204852930,
            204810147,
            204811532
        ],
        "E": [
            204786697,
            204777053,
            204782830,
            204792056,
            204789229,
            204792045,
            204785911,
            204789109,
            204791218,
            204784445,
            204807615,
            204797187,
            204801035,
            204803562,
            204786341,
            204786937,
            204794944,
            204788261
        ],
        "D": [
            204781736,
            204798820,
            204773405,
            204783612,
            204777255,
            204783304,
            204777409,
            204779547,
            204782415,
            204783282,
            204775953,
            204790781,
            204784060,
            204790345,
            204792489,
            204794503,
            205414060,
            204778870,
            204783934,
            204793712
        ],
        "C": [
            204773988,
            204765804,
            204766404,
            204774510,
            204770221,
            204771018,
            204768526,
            204767918,
            204770763,
            204769787,
            204782101,
            204773789,
            204770871,
            204776634,
            204772786,
            204772890,
            204774161,
            204774203
        ],
        "B": [
            204757299,
            204752820,
            204757449,
            204757921,
            204757841,
            204763094,
            204755414,
            204756116,
            204756282,
            204756481,
            204771921,
            204758336,
            204757819,
            204765627,
            204777479,
            204755801,
            204764288,
            204760239
        ],
        "A": [
            204751190,
            204753835,
            204751237,
            204751978,
            204752622,
            204755727,
            204750673,
            204750589,
            204750742,
            204752279,
            204758952,
            204750800,
            204751415,
            204751397,
            204755067,
            204750777,
            204751807
        ]
    },
    "name": "D. Gold Rush",
    "statement": "Initially you have a single pile with n gold nuggets. In an operation\r\nyou can do the following: Take any pile and split it into two piles, so\r\nthat one of the resulting piles has exactly twice as many gold nuggets\r\nas the other. (All piles should have an integer number of nuggets.) Can\r\nyou make a pile with m gold nuggets using zero or more operations?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n#define fi first\n#define se second\n\nint n, m;\n\nvoid solve() {\n    cin >> n >> m;\n    queue<int> q;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        if (u == m) {\n            cout << \"YES\\n\";\n            return;\n        }\n        if (u % 3 == 0) {\n            q.push(u / 3);\n            q.push(2*(u / 3));\n        }\n    }\n    cout << \"NO\\n\";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(\"testing.txt\", \"r\", stdin);\n//    freopen(\"outputing.txt\", \"w\", stdout);\n    #define task \"\"\n//    freopen(task\".inp\", \"r\", stdin);\n//    freopen(task\".out\", \"w\", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << \"\\n=====\" << \"\\nUsed: \" << duration << \" ms\\n\";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\D. Gold Rush.json",
    "editorial_link": "https://codeforces.com//blog/entry/116108",
    "editorial": "We can solve this problem recursively. Let the current pile have gold\r\nnuggets. If , then we can make a pile with exactly gold nuggets by not\r\ndoing any operations. If is not a multiple of , then it is not possible\r\nto make a move, because after a move we split into and , so for some\r\ninteger , meaning has to be a multiple of . Finally, if is a multiple of\r\n, then we can split the pile into two piles with and gold nuggets, and\r\nwe can recursively check if we can make a pile with exactly gold\r\nnuggets. See the implementation for more details.By the Master Theorem,\r\nthe time complexity is . Most compilers and languages optimize the\r\nrecursion enough for this to pass comfortably. (The model solution in\r\nC++ runs in 15 milliseconds.)\r\n"
}