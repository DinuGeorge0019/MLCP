{
    "link": "https://codeforces.com//contest/1971/problem/H",
    "problemId": "2639207",
    "problem_idx": "H",
    "shortId": "1971H",
    "contest_number": "1971",
    "problem_submissions": {
        "H": [
            260362535,
            260822765,
            260371666,
            260397740,
            260572480
        ],
        "D": [
            260332793,
            260619164,
            260293834,
            260318943,
            260285866,
            260297223,
            260297493,
            260303962,
            260298800,
            260317833,
            260300621,
            260298969,
            260323296,
            260301330,
            260299938,
            260296348,
            260312172,
            260322602,
            260329709,
            260315708,
            260305548
        ],
        "G": [
            260318101,
            260346461,
            260370299,
            260338789,
            260349494,
            260332463,
            260365537,
            260357744,
            260381741,
            260380369,
            260379573,
            260352747,
            260352107,
            260384902,
            260374792,
            260378065,
            260370763,
            260387279,
            260388583,
            260387982,
            260407205
        ],
        "F": [
            260311914,
            260326795,
            260360111,
            260329968,
            260317275,
            260354916,
            260350423,
            260349119,
            260336202,
            260364676,
            260362498,
            260375270,
            260375077,
            260363942,
            260349196,
            260367191,
            260362817,
            260359755,
            260377835,
            260359255,
            260371639
        ],
        "E": [
            260296226,
            260351050,
            260341223,
            260311677,
            260340083,
            260316423,
            260323335,
            260314737,
            260293250,
            260315133,
            260326824,
            260311919,
            260316640,
            260321913,
            260370561,
            260332549,
            260341765,
            260316401,
            260330894,
            260329726
        ],
        "C": [
            260278529,
            260284360,
            260290560,
            260279843,
            260286479,
            260285484,
            260287457,
            260287187,
            260300025,
            260288268,
            260288121,
            260292046,
            260286067,
            260290066,
            260284121,
            260301524,
            260296295,
            260291452,
            260307122,
            260298071
        ],
        "B": [
            260270392,
            260278408,
            260278588,
            260271129,
            260279256,
            260286648,
            260272716,
            260276541,
            260281282,
            260277131,
            260275088,
            260277607,
            260304678,
            260302390,
            260274653,
            260305537,
            260293089,
            260279287,
            260277350,
            260280496
        ],
        "A": [
            260263134,
            260263036,
            260264613,
            260265354,
            260266308,
            260268227,
            260263320,
            260263681,
            260264134,
            260265189,
            260267586,
            260268682,
            260263966,
            260267644,
            260265934,
            260268360,
            260268497,
            260264950,
            260263900,
            260268651
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129364",
    "editorial": "The problem statement is somewhat reminiscent of SAT. Indeed, treating\r\nas true and as false, we have clauses of length , and we need at least\r\nof the variables to be true.We can reduce this to 2-SAT with the\r\nfollowing observation: at least of are true at least one of is true, at\r\nleast one of is true, and at least one of is true. That is, for each\r\ncolumn of the grid, we make three 2-SAT clauses. Then we just run 2-SAT\r\non these clauses, and output if there is a solution. The time complexity\r\nis per test case.It might be time-consuming to code 2-SAT during the\r\ncontest, so we recommend using some standard library (for example, our\r\nsolution uses AtCoder library).\r\n",
    "name": "H. ±1",
    "statement": "Bob has a grid with 3 rows and n columns, each of which contains either\r\na_i or -a_i for some integer 1\r\nleq i\r\nleq n. For example, one possible grid for n=4 is shown below:\r\nbegin{bmatrix} a_1 & -a_2 & -a_3 & -a_2\r\n-a_4 & a_4 & -a_1 & -a_3\r\na_1 & a_2 & -a_2 & a_4\r\nend{bmatrix}Alice and Bob play a game as follows: Bob shows Alice his\r\ngrid. Alice gives Bob an array a_1, a_2,\r\ndots, a_n of her choosing, . Bob substitutes these values into his grid\r\nto make a grid of -1s and 1s. Bob the elements of each column in\r\nnon-decreasing order. Alice wins if all the elements in the middle row\r\nare 1; otherwise, Bob wins. For example, suppose Alice gives Bob the\r\narray [1, -1, -1, 1] for the grid above. Then the following will happen\r\n(colors are added for clarity):\r\nbegin{bmatrix}\r\ncolor{red}{a_1} &\r\ncolor{green}{-a_2} &\r\ncolor{blue}{-a_3} &\r\ncolor{green}{-a_2}\r\n-a_4 & a_4 &\r\ncolor{red}{-a_1} &\r\ncolor{blue}{-a_3}\r\ncolor{red}{a_1} &\r\ncolor{green}{a_2} &\r\ncolor{green}{-a_2} & a_4\r\nend{bmatrix}\r\nxrightarrow{[\r\ncolor{red}{1},\r\ncolor{green}{-1},\r\ncolor{blue}{-1},1]}\r\nbegin{bmatrix}\r\ncolor{red}{1} &\r\ncolor{green}{1} &\r\ncolor{blue}{1} &\r\ncolor{green}{1}\r\n-1 & 1 &\r\ncolor{red}{-1} &\r\ncolor{blue}{1}\r\ncolor{red}{1} &\r\ncolor{green}{-1} &\r\ncolor{green}{1} & 1\r\nend{bmatrix}\r\nxrightarrow{\r\ntext{sort each column}}\r\nbegin{bmatrix} -1 & -1 & -1 & 1\r\nmathbf{1} &\r\nmathbf{1} &\r\nmathbf{1} &\r\nmathbf{1}\r\n1 & 1 & 1 & 1\r\nend{bmatrix}\r\n,. Since the middle row is all 1, Alice wins.Given Bob’s grid, determine\r\nwhether or not Alice can choose the array a to win the game.\r\n",
    "solutions": [
        "#include <iostream>#include <set>#include <map>#include <vector>#include <algorithm>#include <cmath>using namespace std;typedef long long ll;const int N = 5e2 + 10;int a[N][5];bool used[2 * N];int comp[2 * N];bool zero[2 * N];int cmp = 0;vector <vector<int>> G, T;vector <int> order;vector <vector<int>> scc;void dfs1(int v) {\tused[v] = true;\tfor (auto it : G[v]) {\t\tif (!used[it]) {\t\t\tdfs1(it);\t\t}\t}\torder.push_back(v);}void dfs2(int v) {\tcomp[v] = cmp;\tfor (auto it : T[v]) {\t\tif (!comp[it]) dfs2(it);\t}}void solve() {\tcmp = 0;\tint n;\tcin >> n;\tfor (int j = 1; j <= 3; j++) {\t\tfor (int i = 1; i <= n; i++) {\t\t\tcin >> a[i][j];\t\t\tif (a[i][j] > 0) {\t\t\t\ta[i][j]--;\t\t\t}\t\t\telse {\t\t\t\ta[i][j] = n - a[i][j] - 1;\t\t\t}\t\t}\t}\tG.clear();\tT.clear();\torder.clear();\tG.resize(2 * n);\tT.resize(2 * n);\tfor (int i = 1; i <= n; i++) {\t\tG[(a[i][1] + n) % (2 * n)].push_back(a[i][2]);\t\tG[(a[i][1] + n) % (2 * n)].push_back(a[i][3]);\t\tG[(a[i][2] + n) % (2 * n)].push_back(a[i][1]);\t\tG[(a[i][2] + n) % (2 * n)].push_back(a[i][3]);\t\tG[(a[i][3] + n) % (2 * n)].push_back(a[i][1]);\t\tG[(a[i][3] + n) % (2 * n)].push_back(a[i][2]);\t\tT[a[i][1]].push_back((a[i][2] + n) % (2 * n));\t\tT[a[i][1]].push_back((a[i][3] + n) % (2 * n));\t\tT[a[i][2]].push_back((a[i][1] + n) % (2 * n));\t\tT[a[i][2]].push_back((a[i][3] + n) % (2 * n));\t\tT[a[i][3]].push_back((a[i][1] + n) % (2 * n));\t\tT[a[i][3]].push_back((a[i][2] + n) % (2 * n));\t}\tfor (int i = 0; i < 2 * n; i++) {\t\tused[i] = false;\t\tcomp[i] = 0;\t}\tfor (int i = 0; i < 2 * n; i++) {\t\tif (!used[i]) {\t\t\tdfs1(i);\t\t}\t}\treverse(order.begin(), order.end());\tfor (int i = 0; i < (int)order.size(); i++) {\t\tif (!comp[order[i]]) {\t\t\tcmp++;\t\t\tdfs2(order[i]);\t\t}\t}\tfor (int i = 0; i < n; i++) {\t\tif (comp[i] == comp[i + n]) {\t\t\tcout << \"NO\\n\";\t\t\treturn;\t\t}\t}\tcout << \"YES\\n\";}int main() {\tint t = 1;\tcin >> t;\twhile (t--) {\t\tsolve();\t} }"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\H. ±1.json",
    "hint": []
}