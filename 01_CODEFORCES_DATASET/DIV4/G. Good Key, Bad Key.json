{"link": "https://codeforces.com//contest/1703/problem/G", "problemId": "1459221", "problem_idx": "G", "shortId": "1703G", "contest_number": "1703", "problem_submissions": {"G": [163879354, 163876701, 163880552, 163887554, 163881906, 163893756, 164072213, 163895080, 163898333, 163903459, 163892881, 163905274, 163897275, 163901266, 163873117, 163892493, 163905636, 163901566, 163923296, 163907786], "F": [163850998, 163858977, 163853177, 163846137, 163922692, 163855752, 163876304, 163853951, 163874504, 163871177, 163873109, 163859383, 163873709, 163873018, 163856287, 163879014, 163887365, 163879906, 163862907, 163875738], "E": [163848798, 163850755, 163868103, 163869552, 163867675, 163862143, 163872743, 163857154, 163830638, 163880434, 163870578, 163865786, 163867906, 163915635, 163866711, 163863745, 163871687, 163844531, 163865925], "D": [163827889, 163832881, 163833809, 163835348, 163842692, 163839970, 163839327, 163847394, 163853863, 163832997, 163851832, 163851452, 163835633, 163842486, 163871782, 163837033, 163852428, 163846440, 163842230], "C": [163817923, 163823865, 163824885, 163813762, 164128413, 163827461, 163825229, 163824848, 163834560, 163829456, 163822136, 163825218, 163840368, 163823674, 163824378, 163823979, 163825333, 163830007, 163824841, 163830416], "B": [163811054, 163815361, 163814856, 163807606, 163816423, 163812311, 163813269, 163818089, 163841436, 163811359, 163816169, 163825648, 163813873, 163814791, 163816214, 163817003, 163814838, 163815021, 163816164], "A": [163806945, 163807884, 163806991, 163805874, 163808042, 163806851, 163807428, 163808801, 163823605, 163807286, 163806888, 163816037, 163805969, 163807627, 163807835, 163808519, 163807784]}, "name": "G. Good Key, Bad Key", "statement": "There are n chests. The i-th chest contains a_i coins. You need to open\r\nall n chests 1n.There are two types of keys you can use to open a chest:\r\na good key, which costs k coins to use; a bad key, which does not cost\r\nany coins, but will halve all the coins in each unopened chest, . The\r\nhalving operation to the nearest integer for each chest halved. In other\r\nwords using a bad key to open chest i will do a_i =\r\nlfloor{\r\nfrac{a_i}{2}\r\nrfloor}, a_{i+1} =\r\nlfloor\r\nfrac{a_{i+1}}{2}\r\nrfloor,\r\ndots, a_n =\r\nlfloor\r\nfrac{a_n}{2}\r\nrfloor; any key (both good and bad) breaks after a usage, that is, it is\r\na one-time use. You need to use in total n keys, one for each chest.\r\nInitially, you have no coins and no keys. If you want to use a good key,\r\nthen you need to buy it.During the process, you are allowed to go into\r\ndebt; for example, if you have 1 coin, you are allowed to buy a good key\r\nworth k=3 coins, and your balance will become -2 coins.Find the maximum\r\nnumber of coins you can have after opening all n chests in order from\r\nchest 1 to chest n.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include \"../debug.h\"\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(\"../input.txt\")\n#define finish cout << \"\\ntime: \" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\nstruct segtree {\n\n\tstruct node {\n\t\tll set, sum;\n\t};\n\n\tvector<node> t;\n\tint size;\n\tll NEUTRAL_ELEMENT = 0;\n\tll NO_OPERATION = 0; \n\n\n\tll op_modify(ll a, ll b, ll length) {\n\t\tif (b == NO_OPERATION)\n\t\t\treturn a;\n\t\treturn b * length + a; \n\t}\n\tll op_sum(ll a, ll b) {\n\t\treturn a + b;\n\t}\n\n\tsegtree(int n) {\n\t\tsize = 1;\n\t\twhile (size < n)\n\t\t\tsize *= 2;\n\t\tt.resize(2 * size, { NO_OPERATION, 0 });\n\t}\n\n\tvoid propagate(int x, int lx, int rx) {\n\t\tif (lx == rx || t[x].set == NO_OPERATION)\n\t\t\treturn;\n\t\tint mx = (lx + rx) / 2;\n\t\tt[2 * x].set = op_modify(t[2 * x].set, t[x].set, 1);\n\t\tt[2 * x].sum = op_modify(t[2 * x].sum, t[x].set, mx - lx + 1);\n\t\tt[2 * x + 1].set = op_modify(t[2 * x + 1].set, t[x].set, 1);\n\t\tt[2 * x + 1].sum = op_modify(t[2 * x + 1].sum, t[x].set, rx - (mx + 1) + 1);\n\t\tt[x].set = NO_OPERATION;\n\t}\n\n\n\n\tvoid modify(int l, int r, int v, int x, int lx, int rx) {\n\t\tpropagate(x, lx, rx);\n\t\tif (l > rx || r < lx) {\n\t\t\treturn;\n\t\t}\n\t\tif (l <= lx && rx <= r) {\n\t\t\tt[x].set = op_modify(t[x].set, v, 1);\n\t\t\tt[x].sum = op_modify(t[x].sum, v, rx - lx + 1);\n\t\t\treturn;\n\t\t}\n\t\tint mx = (lx + rx) / 2;\n\t\tmodify(l, r, v, 2 * x, lx, mx);\n\t\tmodify(l, r, v, 2 * x + 1, mx + 1, rx);\n\t\tt[x].sum = op_sum(t[2 * x].sum, t[2 * x + 1].sum);\n\t}\n\tvoid modify(int l, int r, int v) {\n\t\tmodify(l, r, v, 1, 0, size - 1);\n\t}\n\n\tll sum(int l, int r, int x, int lx, int rx) {\n\t\tpropagate(x, lx, rx);\n\t\tif (l > rx || r < lx) {\n\t\t\treturn NEUTRAL_ELEMENT;\n\t\t}\n\t\tif (l <= lx && rx <= r) {\n\t\t\treturn t[x].sum;\n\t\t}\n\t\tint mx = (lx + rx) / 2;\n\t\tll s1 = sum(l, r, 2 * x, lx, mx);\n\t\tll s2 = sum(l, r, 2 * x + 1, mx + 1, rx);\n\t\treturn op_sum(s1, s2);\n\t}\n\tll sum(int l, int r) {\n\t\treturn sum(l, r, 1, 0, size - 1);\n\t}\n};\n\n\n\nsigned main() {\n\tfstart;\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, k; cin >> n >> k;\n\t\tvector<int> a(n);\n\t\tfor (auto& x : a)\n\t\t\tcin >> x;\n\n\t\tvector<ll> p(n + 1, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tp[i + 1] = p[i] + a[i];\n\n\t\tvector<ll> backP(n + 1, 0);\n\t\t/*for (int i = n - 1; i >= 0; i--)\n\t\t\tbackP[i] = (backP[i + 1]) / 2 + a[i] / 2;*/\n\t\t//segtree st(n + 1);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t//for (int j = 0; j < 31; j++) {\n\t\t\t//\tif (i - j < 0)\n\t\t\t//\t\tbreak;\n\t\t\t//\t//st.modify(max(0, i - j), i, a[i]);\n\t\t\t//\tbackP[i - j] += a[i];\n\t\t\t//\ta[i] /= 2;\n\t\t\t//}\n\n\t\t\tfor (int j = i; j >= 0 && a[i]; j--) {\n\t\t\t\ta[i] /= 2;\n\t\t\t\tbackP[j] += a[i];\n\t\t\t}\n\t\t}\n\n\n\t\tll bestRes = backP[0];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// \u043e\u0442 0 \u0434\u043e i \u043f\u043e\u043a\u0443\u043f\u0430\u0435\u043c \u0437\u0430 k, \u043f\u043e\u0442\u043e\u043c \u0437\u0430 \n\t\t\tll nowRes = p[i + 1] - (ll)k * ((ll)i + 1);\n\t\t\tnowRes += backP[i + 1];\n\t\t\t//nowRes += st.sum(i + 1, i + 1);\n\t\t\tbestRes = max(bestRes, nowRes);\n\t\t}\n\n\t\tcout << bestRes << \"\\n\";\n\t}\n\n\n\tfinish;\n}\n\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "dp", "greedy", "math"], "dificulty": "1600", "interactive": false}