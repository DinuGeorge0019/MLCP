{"link": "https://codeforces.com//contest/1352/problem/D", "problemId": "616896", "problem_idx": "D", "shortId": "1352D", "contest_number": "1352", "problem_submissions": {"F": [79519824, 79501899, 79508349, 79516237, 79506001, 79518696, 79523931, 79522749, 79483374, 79531674, 79537014, 79535573, 79524146, 79555211, 79561303], "G": [79504466, 79502943, 79532774, 79495765, 79544513, 79506723, 79542393, 79531344, 79510893, 79543566, 79546643, 79551234, 79538383, 79529159, 79529270], "E": [79499837, 79510559, 79500279, 79502777, 79499957, 79521311, 79498277, 79498269, 79508383, 79522598, 79517137, 79514677, 79515124, 79516881, 79536338, 79518155], "D": [79490796, 79507180, 79492758, 79507592, 79490945, 79501213, 79506138, 79501463, 79536636, 79509984, 79508108, 79508294, 79510176, 79506745, 79499572], "C": [79486074, 79480411, 79484795, 79474929, 79484699, 79485552, 79489387, 79492925, 79514110, 79492840, 79498250, 79488969, 79497059, 79489417, 79480049], "B": [79475380, 79486583, 79480176, 79484075, 79479831, 79480077, 79512493, 79485299, 79484046, 79486297, 79488494, 79485859, 79481804, 79499936, 79483390, 79489564], "A": [79473627, 79474594, 79473761, 79489909, 79473724, 79475259, 79473858, 79474663, 79474493, 79476206, 79474153, 79474833, 79475651, 79474141, 79474705]}, "name": "D. Alice, Bob and Candies", "statement": "There are n candies in a row, they are numbered from left to right from\r\n1 to n. The size of the i-th candy is a_i.Alice and Bob play an\r\ninteresting and tasty game: they eat candy. Alice will eat candy , and\r\nBob . The game ends if all the candies are eaten.The process consists of\r\nmoves. During a move, the player eats one or more sweets from her/his\r\nside (Alice eats from the left, Bob from the right).Alice makes the\r\nfirst move. During the first move, she will eat 1 candy (its size is\r\na_1). Then, each successive move the players alternate that is, Bob\r\nmakes the second move, then Alice, then again Bob and so on.On each\r\nmove, a player counts the total size of candies eaten during the current\r\nmove. Once this number becomes strictly greater than the total size of\r\ncandies eaten by the other player on their previous move, the current\r\nplayer stops eating and the move ends. In other words, on a move, a\r\nplayer eats the smallest possible number of candies such that the sum of\r\nthe sizes of candies eaten on this move is than the sum of the sizes of\r\ncandies that the other player ate on the move. If there are not enough\r\ncandies to make a move this way, then the player eats up all the\r\nremaining candies and the game ends.For example, if n=11 and\r\na=[3,1,4,1,5,9,2,6,5,3,5], then: move 1: Alice eats one candy of size 3\r\nand the sequence of candies becomes [1,4,1,5,9,2,6,5,3,5]. move 2: Alice\r\nate 3 on the previous move, which means Bob must eat 4 or more. Bob eats\r\none candy of size 5 and the sequence of candies becomes\r\n[1,4,1,5,9,2,6,5,3]. move 3: Bob ate 5 on the previous move, which means\r\nAlice must eat 6 or more. Alice eats three candies with the total size\r\nof 1+4+1=6 and the sequence of candies becomes [5,9,2,6,5,3]. move 4:\r\nAlice ate 6 on the previous move, which means Bob must eat 7 or more.\r\nBob eats two candies with the total size of 3+5=8 and the sequence of\r\ncandies becomes [5,9,2,6]. move 5: Bob ate 8 on the previous move, which\r\nmeans Alice must eat 9 or more. Alice eats two candies with the total\r\nsize of 5+9=14 and the sequence of candies becomes [2,6]. move 6 (the\r\nlast): Alice ate 14 on the previous move, which means Bob must eat 15 or\r\nmore. It is impossible, so Bob eats the two remaining candies and the\r\ngame ends. Print the number of moves in the game and two numbers: a the\r\ntotal size of all sweets eaten by Alice during the game; b the total\r\nsize of all sweets eaten by Bob during the game.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - \u043f\u0440\u043e\u0441\u0442\u043e\u0435\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n    void solve () {\n       \n       \n         /* --------- */\n       \n    int a;\n    cin>>a;\n    int m[a];\n    for (int i=0;i<a;i++) cin>>m[i];\n    int l=0;\n    int r=a-1;\n    int turn=0;\n    int last=0; \n    int p1=0;\n    int p2=0; \n    while (l<=r) {\n        if (turn%2==0) { int cur=0; \n        while (l<=r && cur<=last) {\n            cur+=m[l]; l++; \n        }\n        p1+=cur; last=cur;  \n        } else {\n            int cur=0; \n        while (l<=r && cur<=last) {\n            cur+=m[r]; r--; \n        }\n        p2+=cur; last=cur;  \n        } \n        turn++; \n    }\n    cout<<turn<<\" \"<<p1<<\" \"<<p2<<\"\\n\"; \n        /* --------- */   \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(false);\n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n       \n        cin>>tututu; // \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432, \u0442\u043e \u0437\u0430\u043a\u043e\u043c\u0435\u043d\u0442\u0438\u0442\u044c\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "1300", "interactive": false}