{
    "link": "https://codeforces.com//contest/1669/problem/D",
    "problemId": "1375141",
    "problem_idx": "D",
    "shortId": "1669D",
    "contest_number": "1669",
    "problem_submissions": {
        "G": [
            154338818,
            154338717,
            154337757,
            154347239,
            154330463,
            154358615,
            154344991,
            154342734,
            154343427,
            154345997,
            154348528,
            154339221,
            154350435,
            154348936,
            154352650,
            154348973,
            154344667,
            154352809,
            154336273
        ],
        "H": [
            154331237,
            154345510,
            154346497,
            154331204,
            154335233,
            154339134,
            154340438,
            154353755,
            154348422,
            154352485,
            154359777,
            154327486,
            154363645,
            154353057,
            154360024,
            154352195,
            154320401,
            154364197,
            154347849
        ],
        "F": [
            154326611,
            154329913,
            154332429,
            154337655,
            154392121,
            154390664,
            154319576,
            154333879,
            154333441,
            154337277,
            154337756,
            154338882,
            154338830,
            154337237,
            154339275,
            154344124,
            154341576,
            154343153,
            155263505,
            154351950,
            154345352,
            154352516
        ],
        "E": [
            154321071,
            154318987,
            154325315,
            154326268,
            154308179,
            154321973,
            154333738,
            154331065,
            154331572,
            154332028,
            154326905,
            154331804,
            154329919,
            154333767,
            154329024,
            154337762,
            154361103,
            154333067,
            154320761
        ],
        "D": [
            154308627,
            154314076,
            154319392,
            154318723,
            154344171,
            154313281,
            154320255,
            154318829,
            154324313,
            154318456,
            154317854,
            154354990,
            154313571,
            154324214,
            154320094,
            154324716,
            154333520,
            154315781,
            154315288
        ],
        "C": [
            154296991,
            154301080,
            154302713,
            154304165,
            154324147,
            154314217,
            154293254,
            154298772,
            154304074,
            154306415,
            154304598,
            154300492,
            154301916,
            154299882,
            154304832,
            154301287,
            154300146,
            154302144,
            154300936
        ],
        "B": [
            154290688,
            154292351,
            154293527,
            154297221,
            154311833,
            154293953,
            154288332,
            154290033,
            154293504,
            154297685,
            154295630,
            154290642,
            154294501,
            154290966,
            154291078,
            154291641,
            154291379,
            154291165,
            154293202
        ],
        "A": [
            154287096,
            154287966,
            154287366,
            154290324,
            154288950,
            154288119,
            154286901,
            154287272,
            154287157,
            154287426,
            154288579,
            154287301,
            154287929,
            154287457,
            154287452,
            154287569,
            154287308,
            154287228,
            154288852
        ]
    },
    "name": "D. Colorful Stamp",
    "statement": "A row of n cells is given, all initially white. Using a stamp, you can\r\nstamp any two neighboring cells such that one becomes red and the other\r\nbecomes blue. A stamp can be rotated, i.e. it can be used in both ways:\r\nas\r\ncolor{blue}{\r\ntexttt{B}}\r\ncolor{red}{\r\ntexttt{R}} and as\r\ncolor{red}{\r\ntexttt{R}}\r\ncolor{blue}{\r\ntexttt{B}}.During use, the stamp must completely fit on the given n\r\ncells (it cannot be partially outside the cells). The stamp can be\r\napplied multiple times to the same cell. Each usage of the stamp\r\nrecolors both cells that are under the stamp.For example, one possible\r\nsequence of stamps to make the picture\r\ncolor{blue}{\r\ntexttt{B}}\r\ncolor{red}{\r\ntexttt{R}}\r\ncolor{blue}{\r\ntexttt{B}}\r\ncolor{blue}{\r\ntexttt{B}}\r\ntexttt{W} could be\r\ntexttt{WWWWW}\r\nto\r\ntexttt{WW}\r\ncolor{brown}{\r\nunderline{\r\ncolor{red}{\r\ntexttt{R}}\r\ncolor{blue}{\r\ntexttt{B}}}}\r\ntexttt{W}\r\nto\r\ncolor{brown}{\r\nunderline{\r\ncolor{blue}{\r\ntexttt{B}}\r\ncolor{red}{\r\ntexttt{R}}}}\r\ncolor{red}{\r\ntexttt{R}}\r\ncolor{blue}{\r\ntexttt{B}}\r\ntexttt{W}\r\nto\r\ncolor{blue}{\r\ntexttt{B}}\r\ncolor{brown}{\r\nunderline{\r\ncolor{red}{\r\ntexttt{R}}\r\ncolor{blue}{\r\ntexttt{B}}}}\r\ncolor{blue}{\r\ntexttt{B}}\r\ntexttt{W}. Here\r\ntexttt{W},\r\ncolor{red}{\r\ntexttt{R}}, and\r\ncolor{blue}{\r\ntexttt{B}} represent a white, red, or blue cell, respectively, and the\r\ncells that the stamp is used on are marked with an underline.Given a\r\nfinal picture, is it possible to make it using the stamp zero or more\r\ntimes?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  bool ok1 = 0, ok2 = 0;\n  for(int i = 0; i < s.size(); ++i){\n    if(s[i] == 'R') ok1 = 1;\n    else if(s[i] == 'B') ok2 = 1;\n  \n    if(i == sz(s) - 1 || s[i] == 'W'){\n      if(ok1 != ok2){\n        cout << \"NO\\n\";\n        return;\n      }\n      ok1 = ok2 = 0;\n    }\n  }\n  cout << \"YES\\n\";\n}\n\n\nint main()\n{\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << \"Case #\" << i << \": \";\n      solve();\n    }\n    return 0;\n}   "
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\D. Colorful Stamp.json",
    "editorial_link": "https://codeforces.com//blog/entry/102101",
    "editorial": "First note that parts of the picture separated by are independent. That\r\nis, any stamps used on one part doesn\u00e2\u0080\u0099t have any impact on the other,\r\nsince a character means no stamp has been placed on that cell. So let\u00e2\u0080\u0099s\r\nsplit the string by s (for example, with method in Python), and consider\r\nthe resulting strings containing only and . Call one of these parts .In\r\nthe final stamp we place on , we must have placed , so it should have\r\nboth the characters and . Therefore, if the string has only or only ,\r\nthe answer is .Otherwise, the answer is . Let\u00e2\u0080\u0099s show it. As we have just\r\nshown, we must have next to for the string to be possible. Consider the\r\nway to make . The final stamp can be . For the rest of the cells, we can\r\nmake them one by one as below. so now we have made the prefix of the\r\nstring before the final stamp. Similarly: Now we have made the prefix\r\nand the suffix by stamping \"one character\" at a time (actually, we stamp\r\ntwo characters, but then cover it up with another stamp).Finally, we can\r\nput the final stamp to make the whole string. This method easily\r\ngeneralizes to any string. We can find the final stamp and then make the\r\nprefix and suffix one by one. The solution runs in .\r\n"
}