{
    "link": "https://codeforces.com//contest/1676/problem/E",
    "problemId": "1394657",
    "problem_idx": "E",
    "shortId": "1676E",
    "contest_number": "1676",
    "problem_submissions": {
        "H1": [
            156663309,
            156671035,
            156676406,
            156677707,
            156687383,
            156685420,
            156683017,
            156685580,
            156680845,
            156671307,
            156687981,
            156692199,
            156657699,
            156687504,
            156687346,
            156669994,
            156692215,
            156690772,
            156699306,
            156674281
        ],
        "F": [
            156662637,
            156656235,
            156665211,
            156662718,
            156672962,
            156670420,
            156669171,
            156672700,
            156689970,
            156701445,
            156668704,
            156670980,
            156692969,
            156667724,
            156672833,
            156697894,
            156674219,
            156675205,
            156671046,
            156695991
        ],
        "H2": [
            156662559,
            156672919,
            156681840,
            156677592,
            156687173,
            156685234,
            156690935,
            156688441,
            156684282,
            156671711,
            156695356,
            156692679,
            156656052,
            156687092,
            156691243,
            156679289,
            156697513,
            156691027,
            156699563,
            156671734
        ],
        "G": [
            156653552,
            156661675,
            156671235,
            156675609,
            156680563,
            156678234,
            156674526,
            156681628,
            156674365,
            156683892,
            156676420,
            156679729,
            156701067,
            156674224,
            156680025,
            156686261,
            156680343,
            156680683,
            156677057,
            156684128
        ],
        "D": [
            156645060,
            156650467,
            156648808,
            156663990,
            156656243,
            156654084,
            156654738,
            156653252,
            156652931,
            156720716,
            156654408,
            156652941,
            156637656,
            156666271,
            156684420,
            156652544,
            156655842,
            156653648,
            156661131,
            156659068,
            156666840
        ],
        "E": [
            156637739,
            156656814,
            156654288,
            156651298,
            156645000,
            156661246,
            156659306,
            156663832,
            156658669,
            156662700,
            156660368,
            156647103,
            156671327,
            156659242,
            156657789,
            156660550,
            156665251,
            156665346,
            156657650,
            156676846
        ],
        "C": [
            156635303,
            156637333,
            156640687,
            156644760,
            156634239,
            156639390,
            156648512,
            156642440,
            156638160,
            156643703,
            156638666,
            156653980,
            156643726,
            156635835,
            156643174,
            156650355,
            156639499,
            156649527,
            156641083,
            156646143
        ],
        "B": [
            156625015,
            156622909,
            156630747,
            156623442,
            156623221,
            156628681,
            156623121,
            156628287,
            156626048,
            156630150,
            156624457,
            156631684,
            156634804,
            156625307,
            156634457,
            156622363,
            156628178,
            156624635,
            156624141,
            156627356
        ],
        "A": [
            156619295,
            156618687,
            156622372,
            156618765,
            156618606,
            156621261,
            156618635,
            156621495,
            156621071,
            156622861,
            156618818,
            156619301,
            156623952,
            156618523,
            156619829,
            156618483,
            156619228,
            156619089,
            156618766,
            156619486
        ]
    },
    "name": "E. Eating Queries",
    "statement": "Timur has n candies. The i-th candy has a quantity of sugar equal to\r\na_i. So, by eating the i-th candy, Timur consumes a quantity of sugar\r\nequal to a_i.Timur will ask you q queries regarding his candies. For the\r\nj-th query you have to answer what is the number of candies he needs to\r\neat in order to reach a quantity of sugar x_j or print if it\u2019s not\r\npossible to obtain such a quantity. In other words, you should print the\r\nminimum possible k such that after eating k candies, Timur consumes a\r\nquantity of sugar of at least x_j or say that no possible k exists.Note\r\nthat he can\u2019t eat the same candy twice and queries are independent of\r\neach other (Timur can use the same candy in different queries).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=2e5+5;\n\nint T,n,q;\nint a[N],sum[N];\n\nbool cmp(int x,int y){\n    return x>y;\n}\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"sample.in\",\"r\",stdin);\n    freopen(\"sample.out\",\"w\",stdout);\n    #endif\n    cin>>T;\n    while(T--){\n        cin>>n>>q;\n        for(int i=1;i<=n;++i) cin>>a[i];\n        sort(a+1,a+n+1,cmp);\n        for(int i=1;i<=n;++i) sum[i]=sum[i-1]+a[i];\n        while(q--){\n            int x;\n            cin>>x;\n            int pos=lower_bound(sum+1,sum+n+1,x)-sum;\n            if(pos==n+1) cout<<-1<<endl;\n            else cout<<pos<<endl;\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\E. Eating Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/102710",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem with just one query. Greedily, we should pick\r\nthe candies with the most sugar first, since there is no benefit to\r\npicking a candy with less sugar.So the solution is as follows: sort the\r\ncandies in descending order, and then find the prefix whose sum is .\r\nThis is per query, which is too slow for us.To speed it up, notice that\r\nwe just need to find a prefix sum at least . So if we compute the prefix\r\nsums of the reverse-sorted array, we need to find the first element that\r\nis at least .Since all elements of are positive, the array of prefix\r\nsums is increasing. Therefore, you can binary search the first element .\r\nThis solves the problem in per query.Total time complexity: .\r\n"
}