{
    "link": "https://codeforces.com//contest/1692/problem/H",
    "problemId": "1429122",
    "problem_idx": "H",
    "shortId": "1692H",
    "contest_number": "1692",
    "problem_submissions": {
        "H": [
            160580859,
            160583343,
            160584024,
            160591427,
            160604329,
            160601660,
            160602770,
            160591772,
            160608130,
            160611041,
            160620364,
            160621319,
            160619381,
            160618233,
            160622294,
            160613918,
            160628107,
            160617962,
            160614609,
            160643082
        ],
        "G": [
            160562460,
            160570594,
            160559507,
            160575861,
            160575576,
            160581343,
            160579924,
            160562724,
            160590526,
            160575936,
            160585349,
            160592700,
            160560569,
            160593274,
            160587766,
            160595936,
            160599240,
            160597677,
            160598172,
            160599850
        ],
        "F": [
            160558944,
            160560903,
            160554913,
            160569954,
            160569726,
            160576576,
            160569448,
            160552626,
            160711327,
            160565447,
            160552495,
            160570386,
            160577679,
            160554842,
            160583969,
            160582875,
            160587537,
            160572488,
            160592240,
            160593057,
            160581747
        ],
        "E": [
            160555875,
            160564426,
            160548685,
            160564880,
            160559917,
            160572392,
            160565478,
            160577943,
            160712616,
            160548747,
            160545596,
            160581064,
            160560503,
            160600870,
            160571478,
            160575070,
            160580660,
            160559141,
            160571957,
            160581322,
            160567665
        ],
        "C": [
            160545506,
            160538919,
            160535266,
            160535003,
            160543492,
            160536935,
            160542321,
            160553726,
            160713621,
            160539285,
            160614357,
            160536964,
            160538313,
            160541667,
            160540495,
            160545824,
            160548840,
            160541701,
            160548074,
            160550180,
            160541364
        ],
        "D": [
            160544926,
            160550827,
            160592866,
            160546020,
            160554626,
            160555449,
            160554106,
            160593306,
            160579624,
            160592312,
            160553091,
            160562496,
            160556860,
            160565854,
            160567737,
            160593173,
            160565369,
            160568337,
            160554700
        ],
        "B": [
            160530169,
            160535271,
            160528395,
            160529425,
            160536550,
            160528956,
            160535713,
            160541091,
            160546587,
            160573845,
            160541194,
            160574218,
            160533557,
            160534102,
            160539459,
            160535203,
            160535317,
            160537940,
            160535614
        ],
        "A": [
            160521818,
            160525799,
            160521041,
            160521228,
            160523912,
            160521038,
            160524330,
            160542524,
            160525231,
            160521582,
            160522402,
            160527508,
            160521394,
            160522965,
            160525213,
            160523749,
            160523544,
            160525247,
            160523625
        ]
    },
    "name": "H. Gambling",
    "statement": "Marian is at a casino. The game at the casino works like this.Before\r\neach round, the player selects a number between 1 and 10^9. After that,\r\na dice with 10^9 faces is rolled so that a random number between 1 and\r\n10^9 appears. If the player guesses the number correctly their total\r\nmoney is doubled, else their total money is halved. Marian predicted the\r\nfuture and knows all the numbers x_1, x_2,\r\ndots, x_n that the dice will show in the next n rounds. He will pick\r\nthree integers a, l and r (l\r\nleq r). He will play r-l+1 rounds (rounds between l and r inclusive). In\r\neach of these rounds, he will guess the same number a. At the start\r\n(before the round l) he has 1 dollar.Marian asks you to determine the\r\nintegers a, l and r (1\r\nleq a\r\nleq 10^9, 1\r\nleq l\r\nleq r\r\nleq n) such that he makes the most money at the end.Note that during\r\nhalving and multiplying there is no rounding and there are no precision\r\nerrors. So, for example during a game, Marian could have money equal to\r\ndfrac{1}{1024},\r\ndfrac{1}{128},\r\ndfrac{1}{2}, 1, 2, 4, etc. (any value of 2^t, where t is an integer of\r\nany sign).\r\n",
    "solutions": [
        "//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << ' ' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << ' ';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << ' ';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << '\\n';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << ' ' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK \"H\"\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK \".in\", \"r\", stdin);\n    freopen(TASK \".out\", \"w\", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        cin >> a;\n        map<int, vector<int>> pos;\n        for(int i = 0; i < n; ++i)\n            pos[a[i]].push_back(i);\n        int bal = -n - 1, left = 0, right = 0, ans = 0;\n        for(auto [c, v] : pos) {\n            int cur = 0, mn = n + 1, mx = -n - 1, prev = 0, curl = 0, l = 0, r = 0;\n            for(auto i : v) {\n                cur += prev - i;\n                prev = i;\n                if (cur < mn) {\n                    mn = cur;\n                    curl = i;\n                }\n                cur++;\n                if (mx < cur - mn) {\n                    mx = cur - mn;\n                    l = curl;\n                    r = i;\n                }\n                prev = i + 1;\n            }\n            if (mx > bal) {\n                left = l;\n                right = r;\n                ans = c;\n                bal = mx;\n            }\n        }\n        cout << ans << ' ' << left + 1 << ' ' << right + 1 << endl;\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\H. Gambling.json",
    "editorial_link": "https://codeforces.com//blog/entry/103883",
    "editorial": "There are several solutions. Here is one.If we fix the value of , then\r\nlet\u00e2\u0080\u0099s make a new array as follows: if , and otherwise. Then the total\r\namount of money earned will just be , so we only need to maximize . In\r\nother words, we need to find the maximum sum of a subarray. This is a\r\nstandard problem that can be solved using segment tree.Note that we need\r\nto iterate over all values of , of which there are possibilities. So we\r\nhave to update elements of the segment tree times and query once for\r\neach , which means overall the solution runs in .\r\n"
}