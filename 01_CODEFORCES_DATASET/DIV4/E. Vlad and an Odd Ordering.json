{
    "link": "https://codeforces.com//contest/1926/problem/E",
    "problemId": "2485155",
    "problem_idx": "E",
    "shortId": "1926E",
    "contest_number": "1926",
    "problem_submissions": {
        "G": [
            247563054,
            247320239,
            247350085,
            247352042,
            247335994,
            247324443,
            247354190,
            247343635,
            247343020,
            247361344,
            247364979,
            247352637,
            247358922,
            247365060,
            247361705,
            247335567,
            247361664,
            247363695,
            251544705,
            247357523,
            247364451
        ],
        "E": [
            247469870,
            247283178,
            247284072,
            247331325,
            247283022,
            247304643,
            247852629,
            247286675,
            247298689,
            247310427,
            247305094,
            247280999,
            247256640,
            247276246,
            247310244,
            247304899,
            247318176,
            247321426,
            247323263,
            251544548,
            247340094,
            247322326
        ],
        "D": [
            247426241,
            247263556,
            247421972,
            247278704,
            247339663,
            247271030,
            247272297,
            247843708,
            247274387,
            247287606,
            247268858,
            247276561,
            247270174,
            247312112,
            247330586,
            247287651,
            247258518,
            247306283,
            247265573,
            247299995,
            251545025,
            247267115,
            247289554
        ],
        "C": [
            247423997,
            247243871,
            247421569,
            247273658,
            252912334,
            247276036,
            247252892,
            247246007,
            247677422,
            247256159,
            247247059,
            247257359,
            247252723,
            247250177,
            247286681,
            247248462,
            247270959,
            247272136,
            247287839,
            247242436,
            247261191,
            251544976,
            247253706,
            247269016
        ],
        "B": [
            247423300,
            247238516,
            247244552,
            247285931,
            247246391,
            247234479,
            247655111,
            247237025,
            247257539,
            247250357,
            247235220,
            247246309,
            247261185,
            247239462,
            247243969,
            247244466,
            247253077,
            247236058,
            247250084,
            251545137,
            247244629,
            247257551
        ],
        "A": [
            247422269,
            247225900,
            247221565,
            247226674,
            247231661,
            247220620,
            247222897,
            247230070,
            247232373,
            247222228,
            247222168,
            247223439,
            247225539,
            247227948,
            247228394,
            247233059,
            247221337,
            247227237,
            251545212,
            247231544,
            247251666
        ],
        "F": [
            247339181,
            247336558,
            247364869,
            247371524,
            250524281,
            247428628
        ]
    },
    "name": "E. Vlad and an Odd Ordering",
    "statement": "Vladislav has n cards numbered 1, 2,\r\ndots, n. He wants to lay them down in a row as follows: First, he lays\r\ndown all the odd-numbered cards from smallest to largest. Next, he lays\r\ndown all cards that are twice an odd number from smallest to largest\r\n(i.e. 2 multiplied by an odd number). Next, he lays down all cards that\r\nare 3 times an odd number from smallest to largest (i.e. 3 multiplied by\r\nan odd number). Next, he lays down all cards that are 4 times an odd\r\nnumber from smallest to largest (i.e. 4 multiplied by an odd number).\r\nAnd so on, until all cards are laid down. What is the k-th card he lays\r\ndown in this process? Once Vladislav puts a card down, he cannot use\r\nthat card again.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tvector<int>v;\n\twhile(n)\n\t{\n\t\tv.push_back((n+1)/2);\n\t\tn/=2;\n\t}\n\tint now=0,mpow=1;\n\tfor(auto i:v)\n\t{\n\t\tif(now<k&&k<=now+i)\n\t\t{\n\t\t\tcout<<mpow*(2*(k-now)-1)<<\"\\n\";\n\t\t\treturn;\n\t\t}\n\t\tnow+=i;\n\t\tmpow*=2;\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "dp",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\E. Vlad and an Odd Ordering.json",
    "editorial_link": "https://codeforces.com//blog/entry/126132",
    "editorial": "The problem is very recursive; after we lay all the odd cards down, we\r\nhave the same problem as we started with, but every card is multiplied\r\nby . Can you solve the problem from here?We present two different\r\nsolutions, which are actually the same idea, but presented a little\r\ndifferently, so you can understand the problem better ;). Note that we\r\nwill never lay cards down on moves that are not powers of . Why? Well,\r\nfor example, if a number is , then this number is also , and similarly\r\nfor , , . This same logic shows that numbers will be laid down in the\r\nstep, etc.This means that all our cards are divided into \"blocks\":\r\nnumbers (odd numbers), numbers (multiples of but not ), numbers\r\n(multiples of but not ), numbers (multiples of but not ), and so on. We\r\ncan see that the number of cards in the first group is , and there are\r\ncards left. Call this number . Then in the second group, there are\r\ncards, and so on.This leads to the solution. We can find the number of\r\ncards in each of these groups by repeatedly finding the number of odd\r\ncards, removing them, and continuing the process on the remaining deck.\r\nSo to find the -th card, we find the first prefix sum that exceeds , and\r\nfind the -th card in this block. Let\u00e2\u0080\u0099s make some observations: Of the\r\ncards , there are odd ones. The even-numbered cards cannot be laid down\r\non an odd-numbered step (, , , ), because all those values are odd. In\r\nother words, even-numbered cards can only be laid down at even-numbered\r\nsteps , , , . This means that we can do the following: if , then output\r\nthe -th odd number. Otherwise, once we are finished laying down all the\r\nodd numbers, turns have passed, and our remaining cards are the numbers\r\nand we will only lay down cards in the steps , , , . Since all the\r\nremaining numbers have a factor of , we will divide it out and get the\r\nfollowing equivalent problem: and our remaining cards are the numbers\r\nand we will only lay down cards in the steps , , , . But this is exactly\r\nthe same as the original problem! Thus we can solve this problem\r\nrecursively.More formally, let the answer be . Then if , output the -th\r\nodd number; otherwise, output . This works in per test case.\r\n"
}