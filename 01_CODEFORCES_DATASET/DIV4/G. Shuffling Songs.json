{
    "link": "https://codeforces.com//contest/1950/problem/G",
    "problemId": "2558688",
    "problem_idx": "G",
    "shortId": "1950G",
    "contest_number": "1950",
    "problem_submissions": {
        "G": [
            253752808,
            253791090,
            253792008,
            253764902,
            253795589,
            253769074,
            253798975,
            253810097,
            253794272,
            253806572,
            253813747,
            253817544,
            253814202,
            253820188,
            253820718,
            253701692,
            253694242,
            253726954,
            253792725,
            253718355
        ],
        "E": [
            253730988,
            253727783,
            253735577,
            253792087,
            253719212,
            253895656,
            253750540,
            253762185,
            253739498,
            253800957,
            253757755,
            253752930,
            253767006,
            253801529,
            253796303,
            253779059,
            253809431,
            253784597,
            253786784,
            253792918
        ],
        "F": [
            253716265,
            253756464,
            253746198,
            253848623,
            253757177,
            253795775,
            253775127,
            253790779,
            253735759,
            253790063,
            253778217,
            253795618,
            253777001,
            253808966,
            253809890,
            253750694,
            253768469,
            253787295,
            253772046
        ],
        "D": [
            253705197,
            253693713,
            253712924,
            253751781,
            253734348,
            253699707,
            253753088,
            253692073,
            253733558,
            253726765,
            253750400,
            253763569,
            253732867,
            253761387,
            253761597,
            253792055,
            253785952,
            253817703
        ],
        "C": [
            253676736,
            253709228,
            253688733,
            253683884,
            253710826,
            253702025,
            253688277,
            253692812,
            253687570,
            253701456,
            253687791,
            253700929,
            253695724,
            253682026,
            253784794,
            253798795,
            253798170,
            253797860,
            253824205
        ],
        "B": [
            253657996,
            253671803,
            253670916,
            253669157,
            253704746,
            253674410,
            253676969,
            253678023,
            253688393,
            253673296,
            253673178,
            253675511,
            253706337,
            253667871,
            253770768,
            253802339,
            253794136,
            253800371
        ],
        "A": [
            253646923,
            253671091,
            253650433,
            253650458,
            253649919,
            253656018,
            253663176,
            253648214,
            253648172,
            253672711,
            253656568,
            253658223,
            253654413,
            253650536,
            253773310,
            253803285,
            253782783,
            253796569
        ]
    },
    "name": "G. Shuffling Songs",
    "statement": "Vladislav has a playlist consisting of n songs, numbered from 1 to n.\r\nSong i has genre g_i and writer w_i. He wants to make a playlist in such\r\na way that every pair of adjacent songs either have the same writer or\r\nare from the same genre (or both). He calls such a playlist . Both g_i\r\nand w_i are strings of length no more than 10^4.It might not always be\r\npossible to make an exciting playlist using all the songs, so the\r\nshuffling process occurs in two steps. First, some amount (possibly\r\nzero) of the songs are removed, and then the remaining songs in the\r\nplaylist are rearranged to make it exciting.Since Vladislav doesn’t like\r\nwhen songs get removed from his playlist, he wants the making playlist\r\nto perform as few removals as possible. Help him find the minimum number\r\nof removals that need to be performed in order to be able to rearrange\r\nthe rest of the songs to make the playlist exciting.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<pair<string, string> > v;\n        for(int i = 0; i < n; i++){\n            string a, b;\n            cin >> a >> b;\n            v.push_back(make_pair(a, b));\n        }\n        vector<vector<bool> > adj(n, vector<bool>(n, false));\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if(v[i].first == v[j].first){\n                    adj[i][j] = true;\n                    adj[j][i] = true;\n                }\n                else if(v[i].second == v[j].second){\n                    adj[i][j] = true;\n                    adj[j][i] = true;\n                }\n            }\n        }\n        vector<vector<bool> > dp(n, vector<bool>(1 << n, false));\n        for(int i = 0; i < n; i++){\n            dp[i][1 << i] = true;\n        }\n        for(int i = 0; i < (1 << n); i++){\n            for(int j = 0; j < n; j++){\n                if(i & (1 << j)){\n                    for(int k = 0; k < n; k++){\n                        if(k == j){\n                            continue;\n                        }\n                        if(i & (1 << k) && adj[k][j] && dp[k][i ^ (1 << j)]){\n                            dp[j][i] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < (1 << n); i++){\n            int val = 0;\n            for(int j = 0; j < n; j++){\n                if(i & (1 << j)){\n                    val++;\n                }\n            }\n            for(int j = 0; j < n; j++){\n                if(i & (1 << j)){\n                    if(dp[j][i]){\n                        ans = max(ans, val);\n                    }\n                }\n            }\n        }\n        cout << n - ans << \"\\n\";\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dp",
        "graphs",
        "hashing",
        "implementation",
        "strings"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV4\\G. Shuffling Songs.json",
    "editorial_link": "https://codeforces.com//blog/entry/127664",
    "editorial": "First of all, always comparing strings takes quite a long time, so,\r\nlet’s map the strings to integers. We can do that by keeping all strings\r\nin some array, sorting the array, and mapping each string to its\r\nposition in the array. This process is called \"Normalization\" or\r\n\"Coordinate Compression\".Now, we can do a dynamic programming solution\r\nover subsets.We denote mask as our current bit-mask and we say it has\r\nthe value of all elements we include. For example, if our mask is equal\r\nto 7, in binary it looks like ...000111, so we can say that we included\r\nelements 0, 1 and 2. Each power of two set in our mask, implies we\r\ninclude that element.So now, if we iterate over masks and the last\r\nincluded element, we can mark as a boolean which tells whether it is\r\npossible to get to this state. We transition from a state to another by\r\nusing the current mask and trying to include all non-included elements\r\none-by-one, and checking out if it is possible to include them. If it\r\nis, we update our new mask.After calculating for each state whether we\r\ncan get to it, using previously calculated states, we update our answer\r\nas the maximum number of included elements (bits set) in a mask which is\r\nobtainable.\r\n"
}