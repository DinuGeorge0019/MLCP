{
    "link": "https://codeforces.com//contest/1980/problem/G",
    "problemId": "2679080",
    "problem_idx": "G",
    "shortId": "1980G",
    "contest_number": "1980",
    "problem_submissions": {
        "F2": [
            264034665,
            264025304,
            264247676,
            264019993,
            264024427,
            264029852,
            264023188,
            264027216,
            297729485,
            297729442,
            297728361,
            297728328
        ],
        "G": [
            264011385,
            263992122,
            268025366,
            264215525,
            264011872,
            264084430,
            264264232,
            264263765,
            264069123,
            264079559,
            264078668
        ],
        "F1": [
            263976190,
            263977123,
            263986480,
            263993424,
            264008757,
            263990594,
            264002101,
            263997926,
            264028649,
            263987133,
            263983649,
            263982394,
            264008279,
            263992416,
            264001050,
            263982241,
            263973003,
            297724971,
            263994302,
            263989092,
            263991078
        ],
        "E": [
            263949022,
            263952956,
            263961437,
            263972191,
            263952206,
            263972111,
            263965559,
            263972356,
            263979958,
            263960816,
            263958713,
            263958124,
            263952216,
            263968394,
            263952644,
            263960173,
            263957033,
            263960055,
            263959465,
            263968735
        ],
        "D": [
            263937338,
            263941014,
            263940806,
            263951978,
            263959721,
            263955612,
            263952654,
            263955258,
            263970236,
            263929153,
            263938177,
            263937870,
            263931692,
            263943850,
            263942483,
            263952145,
            263949853,
            263944438,
            263947463,
            263956473
        ],
        "C": [
            263918738,
            263918609,
            263924884,
            263925019,
            263927010,
            263934895,
            263950793,
            263933470,
            263946468,
            263911344,
            263918263,
            263919725,
            263911878,
            263921063,
            263925590,
            263921654,
            263927275,
            263926350,
            263931913,
            263931664
        ],
        "B": [
            263905986,
            263904943,
            263911595,
            263912040,
            263903286,
            263919041,
            263916463,
            263913479,
            263919564,
            263901644,
            263907263,
            263909074,
            263903306,
            263904343,
            263907275,
            263910981,
            263913905,
            263915385,
            263916132,
            263900094
        ],
        "A": [
            263898827,
            263896737,
            263896710,
            263899946,
            263896564,
            263900183,
            263902852,
            263902771,
            263905894,
            263896600,
            263896618,
            263897271,
            263897395,
            263896553,
            263899202,
            263896419,
            263897066,
            263897350,
            263900369,
            263899316,
            263897377
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130135",
    "editorial": "We will hang the tree on the vertex and count for each vertex on the\r\npath from it to the root. This can be done by depth-first traversal in\r\n.Now letâs learn how to solve the problem in for each query. The first\r\ntype of query can be executed straightforwardly. Notice that due to the\r\nproperties of the operation, the values will only change for vertices at\r\nodd depth (the depth of the root is ). At the same time, they will\r\nchange trivially: they will be xored with . To answer the second query,\r\nit is necessary to realize that the xor on a simple cycle is equal to .\r\nIndeed, the path from to the root will be counted twice, so it will turn\r\ninto , and no other extra edges will be included in this xor. With due\r\nskill, you can try to speed up such a solution with instructions, but\r\nthe time constraints were chosen strictly.For a complete solution to the\r\nproblem, you can use the data structure prefix tree (trie). With its\r\nhelp, you can find in for the number such a in the set, that is maximal.\r\nSince change differently, you will have to use two tries for vertices at\r\neven and odd heights. Operations of the first type can be accumulated in\r\nthe variable and added to the xor expression. In addition, you must not\r\nforget to remove from the necessary trie when answering the second\r\nquery, and then insert it back. To do this, you can maintain a counter\r\nof terminal leaves in each vertex and use this information during\r\ndescent.Thus, the final asymptotic is .\r\n",
    "name": "G. Yasya and the Mysterious Tree",
    "statement": "Yasya was walking in the forest and accidentally found a tree with n\r\nvertices. A tree is a connected undirected graph with no cycles.Next to\r\nthe tree, the girl found an ancient manuscript with m queries written on\r\nit. The queries can be of two types.The first type of query is described\r\nby the integer y. The weight of edge in the tree is replaced by the\r\nbitwise exclusive OR of the weight of that edge and the integer y.The\r\nsecond type is described by the vertex v and the integer x. Yasya\r\nchooses a vertex u (1\r\nle u\r\nle n, u\r\nneq v) and mentally draws a bidirectional edge of weight x from v to u\r\nin the tree.Then Yasya finds a simple cycle in the resulting graph and\r\ncalculates the bitwise exclusive OR of all the edges in it. She wants to\r\nchoose a vertex u such that the calculated value is . This calculated\r\nvalue will be the answer to the query. It can be shown that such a cycle\r\nexists and is unique under the given constraints (independent of the\r\nchoice of u). If an edge between v and u already existed, a simple cycle\r\nis the path v\r\nto u\r\nto v.Note that the second type of query is performed , meaning the tree\r\ndoes change in any way after it.Help Yasya answer all the queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;using i64 = int64_t; struct Trie {    vector<array<int, 2>> tr;    vector<int> cnt;    Trie() {        tr.push_back({0, 0});        cnt.push_back(0);    }    void insert(int x) {        int now = 0;        cnt[now]++;        for (int b = 29; b >= 0; b--) {            int d = x >> b & 1;            if (!tr[now][d]) {                tr[now][d] = tr.size();                tr.push_back({0, 0});                cnt.push_back(0);            }            now = tr[now][d];            cnt[now]++;        }    }    int query(int x, int ban) {        int now = 0, res = 0;        if (!cnt[now]) return 0;        for (int b = 29; b >= 0; b--) {            int d = (x >> b & 1) ^ 1;            if (!tr[now][d]) d ^= 1;            else res += 1 << b;            now = tr[now][d];        }        if (res != ban || cnt[now] > 1) return res;        else {            int fr = -1;            function<void(int, int, int)> dfs = [&](int u, int ans, int b) {                if (fr != -1) return;                if (b == -1) return void(fr = (ans == ban ? -1: ans));                int d = (x >> b & 1) ^ 1;                if (tr[u][d]) {                    dfs(tr[u][d], ans + (1 << b), b - 1);                }                if (tr[u][d ^ 1]) dfs(tr[u][d ^ 1], ans, b - 1);            };            dfs(0, 0, 29);            return fr;        }    }}; void Cerulean() {    int n, m; cin >> n >> m;    array<Trie, 2> tr;    vector<vector<pair<int, int>>> adj(n);    for (int e = 1; e < n; e++) {        int u, v, w; cin >> u >> v >> w;        u--, v--;        adj[u].push_back({v, w});        adj[v].push_back({u, w});    }    vector<int> ps(n), oe(n);    function<void(int, int)> dfs = [&](int u, int fa) {        for (auto [v, w]: adj[u]) {            if (v != fa) {                ps[v] = ps[u] ^ w;                oe[v] = oe[u] ^ 1;                dfs(v, u);            }        }    };    dfs(0, 0);    for (int i = 0; i < n; i++) {        tr[oe[i]].insert(ps[i]);    }    int glb = 0;    while (m--) {        char c; cin >> c;        if (c == '^') {            int x; cin >> x;            glb ^= x;        } else {            int v, x; cin >> v >> x;            v--;            cout << max(tr[oe[v]].query(ps[v] ^ x, x), tr[oe[v] ^ 1].query(ps[v] ^ glb ^ x, -1)) << \"\\n\";        }    }} int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) Cerulean();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "strings",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Yasya and the Mysterious Tree.json",
    "hint": []
}