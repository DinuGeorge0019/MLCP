{
    "link": "https://codeforces.com//contest/1921/problem/F",
    "problemId": "2427796",
    "problem_idx": "F",
    "shortId": "1921F",
    "contest_number": "1921",
    "problem_submissions": {
        "G": [
            241831050,
            241827837,
            241810477,
            242123235,
            241856864,
            241856757,
            241846360,
            241844808,
            241871322
        ],
        "F": [
            241783186,
            241781250,
            241816532,
            241785583,
            241791384,
            241804903,
            241794317,
            241794393,
            241798773,
            241768039,
            241794044,
            241853387,
            241797954,
            241801360,
            241966488,
            241966437,
            241795377,
            241807485,
            241804479,
            241771769,
            241809604
        ],
        "E": [
            241757922,
            241820604,
            241803155,
            241764773,
            241760055,
            241766238,
            241761128,
            241758418,
            241762380,
            241791042,
            241765829,
            241852718,
            241852234,
            241772377,
            241777235,
            241766546,
            241773883,
            241777362,
            241799105,
            241776065
        ],
        "C": [
            241743872,
            241738511,
            241782285,
            241713771,
            241731802,
            241722543,
            241723479,
            241721384,
            241731073,
            241731927,
            241733665,
            241724987,
            241731027,
            241724748,
            241725203,
            241727491,
            241738163,
            241730878
        ],
        "D": [
            241740026,
            241755677,
            241822282,
            241733413,
            241740126,
            241836675,
            241730048,
            241743437,
            241739467,
            241740332,
            241741717,
            241747196,
            241850173,
            241850099,
            241755029,
            241745422,
            241752838,
            241742872,
            241743137,
            241722134,
            241753020
        ],
        "B": [
            241716338,
            241724504,
            241779126,
            241723511,
            241712900,
            241714033,
            241714226,
            241710825,
            241717515,
            241711138,
            241719732,
            241714246,
            241713725,
            241711911,
            241715371,
            241717975,
            241730046,
            241720842
        ],
        "A": [
            241704520,
            241709611,
            241777552,
            241704978,
            241704766,
            241705020,
            241706153,
            241705013,
            241708070,
            241704538,
            241706951,
            241707445,
            241704678,
            241705172,
            241707810,
            241705881,
            241707544,
            241704527
        ]
    },
    "name": "F. Sum of Progression",
    "statement": "You are given an array a of n numbers. There are also q queries of the\r\nform s, d, k.For each query q, find the sum of elements a_s + a_{s+d}\r\ncdot 2 +\r\ndots + a_{s + d\r\ncdot (k - 1)}\r\ncdot k. In other words, for each query, it is necessary to find the sum\r\nof k elements of the array with indices starting from the s-th, taking\r\nsteps of size d, multiplying it by the serial number of the element in\r\nthe resulting sequence.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nll a[N],sm[317][N],dp[317][N];\nvoid solve(/**/){\n    ll n,q,sq;\n    cin>>n>>q;\n    sq=sqrt(n);\n    for(ll i=1;i<=n;i++) cin>>a[i];\n    for(ll d=1;d<=sq;d++){\n        for(ll i=n;i>=1;i--){\n            if(i+d>n) dp[d][i]=sm[d][i]=a[i];\n            else{\n                ll j=i+d;\n                sm[d][i]=sm[d][j]+a[i];\n                dp[d][i]=dp[d][j]+sm[d][i];\n            }\n        }\n    }\n    while(q--){\n        ll s,d,k;\n        cin>>s>>d>>k;\n        if(d<=sq){\n            ll j=s+d*k;\n            ll ans=dp[d][s];\n            if(j<=n){\n                ans-=dp[d][j];\n                ans-=sm[d][j]*k;\n            }\n            cout<<ans<<' ';\n        }else{\n            ll ans=0;\n            for(ll i=0;i<k;i++) ans+=a[s+d*i]*(i+1);\n            cout<<ans<<' ';\n        }\n    }\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<\"Case #\"<<i<<\": \";\n        solve();\n        cout<<'\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Sum of Progression.json",
    "editorial_link": "https://codeforces.com//blog/entry/124757",
    "editorial": "The key idea is that we know how to calculate the sum for fast we need\r\nto calculate all prefix sums and for , then take the difference between\r\nthe -th and -th of and subtract the difference between the -th and -th\r\nmultiplied by . This way queries with step will be processed in time,\r\nwhere is the total amount of queries with step 1. But this idea can be\r\ngeneralized to the following: we can precalculate all the prefix sums\r\nand all the prefix sums with multiplication by index for every in time,\r\nand then process all queries with step in time. However, for all other\r\nqueries we can process a single query in time, because the difference\r\nbetween consecutive elements in the resulting sequence is greater than .\r\nCombining these two ideas, we get a solution with a time complexity .\r\nSetting , we get a solution with a time complexity . The model solution\r\nfixes the value of , which is equal to .Interestingly, this solution can\r\nbe generalized to calculate the sums .\r\n",
    "hint": []
}