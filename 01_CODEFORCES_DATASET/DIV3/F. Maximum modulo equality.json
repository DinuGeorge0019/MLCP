{
    "link": "https://codeforces.com//contest/2050/problem/F",
    "problemId": "3070031",
    "problem_idx": "F",
    "shortId": "2050F",
    "contest_number": "2050",
    "problem_submissions": {
        "G": [
            295020039,
            295012969,
            295024810,
            295026123,
            295231485,
            295230757,
            295027068,
            295011107,
            295020886,
            295043604,
            295023074,
            295040334,
            295040501,
            295044199,
            295042105,
            295035503,
            295046172,
            295069369,
            295055294,
            295058073
        ],
        "D": [
            295023542,
            295007735,
            295022150,
            295015640,
            295022096,
            295027211,
            295005995,
            295007532,
            295010040,
            295008211,
            295013052,
            295007075,
            295014360,
            295012052,
            295012580,
            295012327,
            295010790
        ],
        "F": [
            295009915,
            295016605,
            295015909,
            295021788,
            295023146,
            295035635,
            295031460,
            295012371,
            295027547,
            295033629,
            295028476,
            295029305,
            295012244,
            295027355,
            299441454,
            295024166,
            295024859,
            295021290
        ],
        "E": [
            295006159,
            295012248,
            295006655,
            295358340,
            294991246,
            295015587,
            295010009,
            295016041,
            295017979,
            295016907,
            295021107,
            295017866,
            295008404,
            295002349,
            295018392,
            295017130,
            295019301,
            295028396
        ],
        "C": [
            295000545,
            295002243,
            294997256,
            295011626,
            295006375,
            295000328,
            295001562,
            295020525,
            295004225,
            295001544,
            295003470,
            294999298,
            295008085,
            295003035,
            295005025,
            295008622,
            295001249
        ],
        "B": [
            294992701,
            294994611,
            294990329,
            295007113,
            294997489,
            294992969,
            294992993,
            295002206,
            294997468,
            294994758,
            294991989,
            294994433,
            294994702,
            294998118,
            294998487,
            295000433,
            294997971
        ],
        "A": [
            294987570,
            294988254,
            294987535,
            294987637,
            294990076,
            294987812,
            294987751,
            294999699,
            294989420,
            294988260,
            294987843,
            294987612,
            294989111,
            294989647,
            294989965,
            294992026,
            294994133
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137018",
    "editorial": "Let\u00e2\u0080\u0099s look at two arbitrary integers and . Now we want to find the\r\nmaximum , which satisfies . We know that , then , because they have the\r\nsame remainder by . That means that any which is a divisor of will\r\nsatisfy the required condition.Now let\u00e2\u0080\u0099s generalize the idea we\u00e2\u0080\u0099ve\r\nobtained to the segment: means that , and , and ..., and . So, must be a\r\ndivisor of , , ..., at the same time. That means that should be GCD(, ,\r\n..., ), where GCD is the greatest common divisor. , when all the\r\nelements on the segment [] are equal.Let\u00e2\u0080\u0099s build an array consisting of\r\ndifferences of adjacent elements; now we can use sparse table to find\r\nGCD on the segments efficiently.\r\n",
    "name": "F. Maximum modulo equality",
    "statement": "You are given an array a of length n and q queries l, r.For each query,\r\nfind the maximum possible m, such that all elements a_l, a_{l+1}, ...,\r\na_r are equal modulo m. In other words, a_l\r\nbmod m = a_{l+1}\r\nbmod m =\r\ndots = a_r\r\nbmod m, where a\r\nbmod b is the remainder of division a by b. In particular, when m can be\r\ninfinite, print 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0typedef long long ll;\u00a0vector<int> build_log_table(int max_n) {    vector<int> log_table(max_n + 1, 0);    for(int i = 2; i <= max_n; ++i){        log_table[i] = log_table[i/2] + 1;    }    return log_table;}\u00a0int main(){    ios::sync_with_stdio(false);    cin.tie(0);    int MAX_N = 200000;    vector<int> log_table = build_log_table(MAX_N);        int t;    cin >> t;    while(t--){        int n, q;        cin >> n >> q;        vector<int> a(n);        for(auto &x: a) cin >> x;        if(n >=2){            vector<int> d(n-1);            for(int i=0;i<n-1;i++) d[i] = a[i+1] - a[i];            int LOG = log_table[n-1] +1;            vector<vector<int>> st(log_table[n-1]+1, vector<int>(n-1));            for(int i=0;i<n-1;i++) st[0][i] = d[i];            for(int k=1; (1<<k) <= n-1; k++){                for(int i=0; i + (1<<k) <= n-1; i++){                    st[k][i] = gcd(st[k-1][i], st[k-1][i + (1 << (k-1))]);                }            }            while(q--){                int l, r;                cin >> l >> r;                if(l == r){                    cout << \"0\\n\";                }                else{                    int L = l-1;                    int R = r-2;                    int length = R - L +1;                    int k = log_table[length];                    int g = gcd(st[k][L], st[k][R - (1<<k) +1]);                    if(g == 0){                        cout << \"0\\n\";                    }                    else{                        cout << g << \"\\n\";                    }                }            }        }        else{            while(q--){                int l, r;                cin >> l >> r;                cout << \"0\\n\";            }        }    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Maximum modulo equality.json"
}