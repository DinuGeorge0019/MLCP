{"link": "https://codeforces.com//contest/1520/problem/C", "problemId": "976798", "problem_idx": "C", "shortId": "1520C", "contest_number": "1520", "problem_submissions": {"F2": [115377397, 115305590, 115287040, 115299425, 115275998, 115291100, 115279060, 115289661, 115284382, 115289848, 115308377, 115278701, 115306155, 115291190, 115265089, 115307538, 115303936, 115461761, 115294385, 115296101], "G": [115377372, 115262775, 115288422, 115284069, 115289230, 115326140, 115318505, 115305519, 115310728, 115306048, 115310484, 115283392, 115286859, 115490380, 115494255, 115428029, 115418593, 115335990, 115630972, 115630383], "F1": [115377349, 115249032, 115270195, 115243368, 115263879, 115260580, 115273435, 115261038, 115280609, 115277317, 115293876, 115256261, 115254859, 115241348, 115257133, 115247327, 115256409, 115278650, 115271950, 115272669], "E": [115377332, 115237334, 115239791, 115237430, 115247171, 115242404, 115248291, 115250125, 115252428, 115257556, 115318354, 115247364, 115240877, 115248360, 115247935, 115237440, 115241805, 115254530, 115253830, 115256564], "C": [115377311, 115225774, 115221824, 115221195, 115232319, 115227403, 115230041, 115230111, 115234657, 115232187, 115315640, 115223231, 115228100, 115217322, 115228063, 115296150, 115228425, 115221440, 115236900, 115240483], "D": [115377293, 115218646, 115225866, 115229634, 115238178, 115231535, 115237704, 115234502, 115238902, 115239693, 115238815, 115228744, 115221564, 115219392, 115231781, 115227386, 115230454, 115232684, 115243890, 115245632], "B": [115377281, 115214791, 115214878, 115216679, 115235400, 115218148, 115218189, 115225076, 115218800, 115220311, 115284747, 115217692, 115219291, 115213196, 115216288, 115215912, 115223513, 115214573, 115226157, 115226244], "A": [115377268, 115212622, 115212991, 115213371, 115214493, 115214137, 115213480, 115215360, 115213972, 115213655, 115216180, 115212784, 115213313, 115212547, 115212731, 115213509, 115217879, 115212709, 115218109, 115218897]}, "name": "C. Not Adjacent Matrix", "statement": "We will consider the numbers a and b as adjacent if they differ by\r\nexactly one, that is, |a-b|=1.We will consider cells of a square matrix\r\nn\r\ntimes n as adjacent if they have a common side, that is, for cell (r, c)\r\ncells (r, c-1), (r, c+1), (r-1, c) and (r+1, c) are adjacent to it.For a\r\ngiven number n, construct a square matrix n\r\ntimes n such that: Each integer from 1 to n^2 occurs in this matrix\r\nexactly once; If (r_1, c_1) and (r_2, c_2) are adjacent cells, then the\r\nnumbers written in them .\r\n", "solutions": ["#include \"bits/extc++.h\"\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << \"L\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"]\" << \": \";       \\\nsep(cerr, \" | \", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl \"\\n\"\n\n#define sz(x) int((x).size())\n\nmt19937 cowng(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<int> gen(int n) {\n\twhile(true) {\n\t\tvector<int> arr(n);\n\t\tiota(begin(arr), end(arr), 0);\n\t\tshuffle(begin(arr), end(arr), cowng);\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tif(abs(arr[i] - arr[i + 1]) <= 1) {\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t\tloop:;\n\t}\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tif(n == 1) {\n\t\tcout << 1 << endl;\n\t}else if(n == 2) {\n\t\tcout << -1 << endl;\n\t}else if(n == 3) {\n\t\tcout << \"2 9 7\\n\"\n\t\t\t\t\"4 6 3\\n\"\n\t\t\t\t\"1 8 5\" << endl;\n\t}else {\n\t\tvector<int> cur = gen(n);\n\t\tfor(int i = 0; i < n * n; i += n) {\n\t\t\tvector<int> v;\n\t\t\tfor(int j = i + 1; j <= i + n; j++) {\n\t\t\t\tv.push_back(j);\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcout << v[cur[j]] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << \"Case #\" << _ << \": \";\n\t\tsolve();\n\t}\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1000", "interactive": false}