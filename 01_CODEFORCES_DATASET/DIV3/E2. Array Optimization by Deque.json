{"link": "https://codeforces.com//contest/1579/problem/E2", "problemId": "1123871", "problem_idx": "E2", "shortId": "1579E2", "contest_number": "1579", "problem_submissions": {"G": [130137274, 130120638, 130155046, 130156225, 130163836, 130179545, 130168337, 130158927, 130165156, 130198303, 130191623, 130244137, 130192656], "E2": [130129123, 130137578, 130134268, 130135000, 130132286, 130127123, 130146290, 130145108, 130149289, 130140257, 130139480, 130140744, 130135527, 130143398, 130123582, 130147751, 130139094, 130145725, 130136545, 130146933], "F": [130125518, 130115413, 130143625, 130141220, 130143971, 130167063, 130157787, 130168199, 130155796, 130152120, 130146742, 130149015, 130150286, 130148427, 130153717, 130166412, 130156991, 130153655, 130149578, 130134036], "E1": [130117970, 130121669, 130119905, 130127812, 130120295, 130128369, 130136696, 130129561, 130139968, 130118319, 130116344, 130126763, 130130246, 130132247, 130119799, 130120223, 130117670, 130134770, 130118389, 130133123], "D": [130114825, 130131006, 130115575, 130122918, 130116396, 130116584, 130127769, 130136071, 130142472, 130116682, 130121234, 130122150, 130126027, 130120420, 130116268, 130113854, 130122134, 130132072, 130125736, 130128217], "C": [130111875, 130134780, 130127605, 130118045, 130126486, 130136003, 130133755, 130153746, 130136597, 130126873, 130133654, 130133053, 130123204, 130126284, 130128738, 130132948, 130148452, 130128270, 130158049, 130155693], "B": [130106161, 130116908, 130108929, 130112526, 130111768, 130114142, 130116092, 130125486, 130125850, 130111350, 130113414, 130109874, 130116163, 130111654, 130112328, 130107695, 130114784, 130116681, 130114568, 130117978], "A": [130098440, 130100824, 130100944, 130103654, 130098460, 130102451, 130102139, 130101021, 130117992, 130105259, 130098578, 130098425, 130098461, 130105623, 130098680, 130098458, 130101628, 130099346, 130098971, 130099307]}, "name": "E2. Array Optimization by Deque", "statement": "You are given an integer array a[1\r\nldots n] = [a_1, a_2,\r\nldots, a_n].Let us consider an empty deque (double-ended queue). A deque\r\nis a data structure that supports adding elements to both the beginning\r\nand the end. So, if there are elements [3, 4, 4] currently in the deque,\r\nadding an element 1 to the beginning will produce the sequence [\r\ncolor{red}{1}, 3, 4, 4], and adding the same element to the end will\r\nproduce [3, 4, 4,\r\ncolor{red}{1}].The elements of the array are sequentially added to the\r\ninitially empty deque, starting with a_1 and finishing with a_n. Before\r\nadding each element to the deque, you may choose whether to add it to\r\nthe beginning or to the end.For example, if we consider an array a = [3,\r\n7, 5, 5], one of the possible sequences of actions looks like this:\r\nquad 1.add 3 to the beginning of the deque:deque has a sequence [\r\ncolor{red}{3}] in it;\r\nquad 2.add 7 to the end of the deque:deque has a sequence [3,\r\ncolor{red}{7}] in it;\r\nquad 3.add 5 to the end of the deque:deque has a sequence [3, 7,\r\ncolor{red}{5}] in it;\r\nquad 4.add 5 to the beginning of the deque:deque has a sequence [\r\ncolor{red}{5}, 3, 7, 5] in it;Find the minimal possible number of\r\ninversions in the deque after the whole array is processed. An in\r\nsequence d is a pair of indices (i, j) such that i < j and d_i > d_j.\r\nFor example, the array d = [5, 3, 7, 5] has exactly two inversions (1,\r\n2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005];\nint t[800005];\nint n,m;\n\nvoid update(int x) {\n    for(;x <= m;x += x&-x) t[x]++;\n}\n\nint query(int l,int r) {\n    int ret = 0;\n    for(;r;r -= r&-r) ret += t[r];\n    for(--l;l;l -= l&-l) ret -= t[l];\n    return ret;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        vec rev;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            rev.pb(a[i]);\n        }\n        sort(all(rev)), rev.erase(unique(all(rev)),rev.end());\n        for(int i = 1;i <= n;i++) {\n            a[i] = lower_bound(all(rev),a[i])-rev.begin()+1;\n        }\n        m = rev.size();\n        ll ans = 0;\n        for(int i = 1;i <= n;i++) {\n            int L = query(1,a[i]-1), R = query(a[i]+1,m);\n            ans += min(L,R);\n            update(a[i]);\n        }\n        cout << ans << '\\n';\n        for(int i = 1;i <= m;i++) t[i] = 0;\n    }\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "1700", "interactive": false}