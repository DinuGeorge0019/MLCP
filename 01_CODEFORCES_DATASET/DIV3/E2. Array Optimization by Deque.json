{
    "link": "https://codeforces.com//contest/1579/problem/E2",
    "problemId": "1123871",
    "problem_idx": "E2",
    "shortId": "1579E2",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "E2. Array Optimization by Deque",
    "statement": "You are given an integer array a[1\r\nldots n] = [a_1, a_2,\r\nldots, a_n].Let us consider an empty deque (double-ended queue). A deque\r\nis a data structure that supports adding elements to both the beginning\r\nand the end. So, if there are elements [3, 4, 4] currently in the deque,\r\nadding an element 1 to the beginning will produce the sequence [\r\ncolor{red}{1}, 3, 4, 4], and adding the same element to the end will\r\nproduce [3, 4, 4,\r\ncolor{red}{1}].The elements of the array are sequentially added to the\r\ninitially empty deque, starting with a_1 and finishing with a_n. Before\r\nadding each element to the deque, you may choose whether to add it to\r\nthe beginning or to the end.For example, if we consider an array a = [3,\r\n7, 5, 5], one of the possible sequences of actions looks like this:\r\nquad 1.add 3 to the beginning of the deque:deque has a sequence [\r\ncolor{red}{3}] in it;\r\nquad 2.add 7 to the end of the deque:deque has a sequence [3,\r\ncolor{red}{7}] in it;\r\nquad 3.add 5 to the end of the deque:deque has a sequence [3, 7,\r\ncolor{red}{5}] in it;\r\nquad 4.add 5 to the beginning of the deque:deque has a sequence [\r\ncolor{red}{5}, 3, 7, 5] in it;Find the minimal possible number of\r\ninversions in the deque after the whole array is processed. An in\r\nsequence d is a pair of indices (i, j) such that i < j and d_i > d_j.\r\nFor example, the array d = [5, 3, 7, 5] has exactly two inversions (1,\r\n2) and (3, 4), since d_1 = 5 > 3 = d_2 and d_3 = 7 > 5 = d_4.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005];\nint t[800005];\nint n,m;\n\nvoid update(int x) {\n    for(;x <= m;x += x&-x) t[x]++;\n}\n\nint query(int l,int r) {\n    int ret = 0;\n    for(;r;r -= r&-r) ret += t[r];\n    for(--l;l;l -= l&-l) ret -= t[l];\n    return ret;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        vec rev;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            rev.pb(a[i]);\n        }\n        sort(all(rev)), rev.erase(unique(all(rev)),rev.end());\n        for(int i = 1;i <= n;i++) {\n            a[i] = lower_bound(all(rev),a[i])-rev.begin()+1;\n        }\n        m = rev.size();\n        ll ans = 0;\n        for(int i = 1;i <= n;i++) {\n            int L = query(1,a[i]-1), R = query(a[i]+1,m);\n            ans += min(L,R);\n            update(a[i]);\n        }\n        cout << ans << '\\n';\n        for(int i = 1;i <= m;i++) t[i] = 0;\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Array Optimization by Deque.json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "Let\u00e2\u0080\u0099s process the array elements one by one.For the first element, it\r\ndoesn\u00e2\u0080\u0099t matter which side of the deque we add it to, the result of its\r\naddition will be the same there will be a sequence of one element (equal\r\nto the first array element) in the deque.Now let\u00e2\u0080\u0099s consider adding the\r\nth element of an array into the deck. First will be considered, then ,\r\nand so on up to . Let us describe the general algorithm for choosing the\r\nside of the dec for each step. Note that if the elements now lie in the\r\ndeck, then all final sequences that can be obtained in the deck from the\r\ncurrent state can be broken down into pairs of the form where the\r\nbeginning and the end of the final sequences hidden behind \"\" are\r\nobtained by the same sequences of all the following choices and,\r\nrespectively, coincide.Note that since the prefix and suffix hidden\r\nbehind the dots completely coincide in the two sequences under\r\nconsideration, as well as the set of numbers in the central part\r\ncoincides, the numbers of inversions also coincide: inside the prefix\r\nand inside the suffix; between elements of the prefix and elements of\r\nthe suffix; between elements of the prefix or suffix and elements of the\r\ncentral part. The difference between the number of inversions in the\r\nfirst and second sequence consists only of the difference between the\r\nnumber of inversions in their central part. So, we can determine at the\r\nstage of adding to the deque, which direction of its addition is\r\nguaranteed not to lead to the optimal answer and choose the opposite\r\none.If is added to the beginning of the deque, the number of inversions\r\nin the central part will increase by the number of elements in the deque\r\nstrictly smaller than , and if we add it to the end of the deque, it\r\nwill increase by the number of elements in the deque strictly larger\r\nthan . Let us make a choice such that the number of inversions increases\r\nby the minimum of these two values.To quickly find the number of\r\nelements smaller or larger than , we will store all already processed\r\narray elements in a structure that supports the element order search\r\noperation, such as . Besides using this structure specifically, you can\r\nwrite any balanced binary search tree (such as a Cartesian tree); sort\r\nall numbers in the input array and compress them to values , preserving\r\nthe \"\" relation, then build a segment tree on them, storing in the node\r\nthe number of array numbers already processed by the deque with values\r\nbetween and . Requests to update and get an order in such structures\r\ntake time, and the construction takes at worst , so the time complexity\r\nof the algorithm is .\r\n"
}