{"link": "https://codeforces.com//contest/1914/problem/G1", "problemId": "2388666", "problem_idx": "G1", "shortId": "1914G1", "contest_number": "1914", "problem_submissions": {"G1": [238018438, 238000852, 238043791, 238031142, 238036163, 238022582, 238087384, 238021948, 238036052, 238042057, 238044748, 238044591, 238050871, 238049279, 238041985, 238041747, 238051023, 238045930, 238048344, 238046536], "G2": [238018282, 238029024, 238043678, 238093831, 238412098, 238148947, 238064785, 238049222, 238126038, 238092486, 238087948, 238046581], "F": [237987101, 237981616, 238101450, 238044891, 238001429, 238000631, 238087366, 238087349, 237994511, 237993999, 238008838, 238002775, 238029366, 238028703, 238047984, 238031007, 238059042, 238016608, 238042673, 238020683, 238033160, 238082942, 238008762, 238014024], "E1": [237976613, 237967906, 237968713, 237979764, 237992475, 238087307, 237986420, 237997495, 237988975, 237985077, 238029878, 238002145, 237999975, 237992524, 237984395, 237997791, 237997737, 237990723, 237990559, 238004571, 238010992, 238032680, 237982405, 237983507], "E2": [237970390, 237967235, 237968505, 237975110, 237992780, 238087324, 238087318, 237984061, 238010057, 237989036, 237983616, 238029826, 238001371, 237999445, 237992650, 237985208, 237997942, 237998156, 237990939, 238005322, 238011620, 238032636, 237982481, 237984584], "D": [237961065, 237957916, 238104889, 237961793, 237958795, 237961367, 238087292, 238087270, 237986240, 237957524, 237975283, 237962518, 238030156, 237976418, 237969884, 237965519, 237971483, 237975166, 237976975, 237983490, 237986064, 237975702, 237967060, 237966732], "C": [237951819, 237950855, 237956944, 237969583, 237951814, 238087237, 237972501, 237951530, 237961828, 237952459, 238030394, 237963594, 237963444, 237965677, 237960539, 237979704, 237972502, 237967766, 237971691, 237960187, 237954042, 237957084], "B": [237947357, 237946623, 237951415, 237946292, 237950077, 238087224, 237953989, 237947273, 237953071, 237947198, 237948581, 237951930, 237944853, 237953412, 237972118, 237952004, 237972737, 237961138, 237948416, 237947616, 237950073], "A": [237944355, 237943313, 237944942, 237948071, 237945058, 238087212, 237948311, 237944114, 237946737, 237943516, 237943664, 237945100, 237964491, 237948297, 237965985, 237946077, 237945584, 237949431, 237943847, 237944147, 237943327]}, "name": "G1. Light Bulbs  Easy Version ", "statement": ".There are 2n light bulbs arranged in a row. Each light bulb has a color\r\nfrom 1 to n ().Initially, all light bulbs are turned off. You choose a\r\nset of light bulbs S that you initially turn on. After that, you can\r\nperform the following operations in any order any number of times:\r\nchoose two light bulbs i and j , exactly one of which is on, and turn on\r\nthe second one; choose three light bulbs i, j, k, such that both light\r\nbulbs i and k , and the light bulb j is between them (i < j < k), and\r\nturn on the light bulb j. You want to choose a set of light bulbs S that\r\nyou initially turn on in such a way that by performing the described\r\noperations, you can ensure that all light bulbs are turned on.Calculate\r\ntwo numbers: the minimum size of the set S that you initially turn on;\r\nthe number of sets S of minimum size (taken modulo 998244353).\r\n", "solutions": ["//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<int,int>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=2e5+5,mod=998244353;\nint gmi[20][2*N],lg[2*N],gma[20][2*N],R[N];\nii pos[N];\nll n,a[2*N],par[N];\nii get (ll l, ll r){\n    ii d;\n    ll g=lg[r-l+1];\n    d.F=min(gmi[g][l],gmi[g][r-(1<<g)+1]);\n    d.S=max(gma[g][l],gma[g][r-(1<<g)+1]);\n    return d;\n}\nll find (ll u){\n    if (u==par[u]) return u;\n    return (par[u]=find(par[u]));\n}\nvoid join (ll u, ll v){\n    ll x=find(u),y=find(v);\n    if (x==y) return;\n    par[x]=y;\n}\nvoid prep(){\n    rep(i,2,2*N-1) lg[i]=lg[i/2]+1;\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) pos[i]={0,0},par[i]=i;\n    rep(i,1,2*n){\n        cin>>a[i];\n        if (pos[a[i]].F==0) pos[a[i]].F=i;\n        else \n        {\n            pos[a[i]].S=i;\n            ll pf=pos[a[i]].F,ps=i;\n            gmi[0][pf]=pf;\n            gmi[0][ps]=pf;\n            gma[0][pf]=ps;\n            gma[0][ps]=ps;\n        }\n    }\n    rep(i,1,19)\n    rep(j,1,2*n) if (j+(1<<i)-1<=2*n) gmi[i][j]=min(gmi[i-1][j],gmi[i-1][j+(1<<(i-1))]);\n    rep(i,1,19)\n    rep(j,1,2*n) if (j+(1<<i)-1<=2*n) gma[i][j]=max(gma[i-1][j],gma[i-1][j+(1<<(i-1))]);\n    rep(i,1,n){\n        ll l=pos[i].F,r=pos[i].S;\n        ii pd=get(l,r);\n        ll x=pd.F,y=pd.S;\n        join(i,a[x]);\n        join(i,a[y]);\n    }\n    sort(pos+1,pos+n+1);\n    ll res=0,mx=0;\n    rep(i,1,n) if (pos[i].F>mx){\n        R[res]=mx;\n        res++;\n        mx=pos[i].S;\n    }\n    else mx=max(mx,(ll)pos[i].S);\n    cout<<res<<\" \";\n    R[res]=2*n;\n    res=1;\n    ll tmp=1;\n    ll cnt=0;\n    rep(i,1,2*n){\n        if (i>R[cnt]){\n            cnt++;\n            (res*=tmp)%=mod;\n            tmp=0;\n        }\n        if (find(a[i])==find(a[R[cnt]])) tmp++;\n    }\n    (res*=tmp)%=mod;\n    cout<<res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "dfs and similar", "dp", "dsu", "graphs", "math", "trees"], "dificulty": "2100", "interactive": false}