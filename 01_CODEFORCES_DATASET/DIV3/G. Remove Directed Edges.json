{
    "link": "https://codeforces.com//contest/1674/problem/G",
    "problemId": "1387203",
    "problem_idx": "G",
    "shortId": "1674G",
    "contest_number": "1674",
    "problem_submissions": {
        "G": [
            155646371,
            155678319,
            155682648,
            155674622,
            155685706,
            155652398,
            155774505,
            155758418,
            155756941,
            155756549,
            155813512,
            155812905,
            155812142,
            155668112,
            155672472,
            155679227
        ],
        "E": [
            155631011,
            155634103,
            155643152,
            155675920,
            155631080,
            155651713,
            155617544,
            155694232,
            155715039,
            155714839,
            155714791,
            155637067,
            155642168,
            155638571,
            155649103,
            155635417,
            155641093,
            155646304,
            155721408,
            155721277,
            155636472,
            155697116,
            155650091,
            155644616
        ],
        "D": [
            155618739,
            155613748,
            155616684,
            155656367,
            155626968,
            155608446,
            155610953,
            155612083,
            155611734,
            155659957,
            155623954,
            155619138,
            155624149,
            155621266,
            155624757,
            155627320,
            155618076,
            155634919,
            155611685,
            155616988
        ],
        "F": [
            155617525,
            155657845,
            155669742,
            155653200,
            155666820,
            155638184,
            155625715,
            155652009,
            155672980,
            155630184,
            155664338,
            155667869,
            155668832,
            155674578,
            155651745,
            155669165,
            155649876,
            155663032,
            155653319,
            155665427
        ],
        "C": [
            155604778,
            155603079,
            155604115,
            155615008,
            155611152,
            155601227,
            155598610,
            155598459,
            155599303,
            155601929,
            155605133,
            155602572,
            155609155,
            155606549,
            155606406,
            155613995,
            155599916,
            155616867,
            155601683,
            155604335
        ],
        "B": [
            155596261,
            155597272,
            155595696,
            155604402,
            155605300,
            155597345,
            155593808,
            155599168,
            155593898,
            155596784,
            155597719,
            155597183,
            155602563,
            155597000,
            155600384,
            155600158,
            155595285,
            155605630,
            155596236,
            155595482
        ],
        "A": [
            155592021,
            155592145,
            155591844,
            155602088,
            155598548,
            155592326,
            155591501,
            155592241,
            155591537,
            155593757,
            155591678,
            155592049,
            155596267,
            155592804,
            155593311,
            155594974,
            155592005,
            155594331,
            155593247,
            155592088
        ]
    },
    "name": "G. Remove Directed Edges",
    "statement": "You are given a directed acyclic graph, consisting of n vertices and m\r\nedges. The vertices are numbered from 1 to n. There are no multiple\r\nedges and self-loops.Let\r\nmathit{in}_v be the number of incoming edges (indegree) and\r\nmathit{out}_v be the number of outgoing edges (outdegree) of vertex\r\nv.You are asked to remove some edges from the graph. Let the new degrees\r\nbe\r\nmathit{in\u2019}_v and\r\nmathit{out\u2019}_v.You are only allowed to remove the edges if the following\r\nconditions hold for every vertex v:\r\nmathit{in\u2019}_v <\r\nmathit{in}_v or\r\nmathit{in\u2019}_v =\r\nmathit{in}_v = 0;\r\nmathit{out\u2019}_v <\r\nmathit{out}_v or\r\nmathit{out\u2019}_v =\r\nmathit{out}_v = 0. Let\u2019s call a set of vertices S if for each pair of\r\nvertices v and u (v\r\nneq u) such that v\r\nin S and u\r\nin S, there exists a path either from v to u or from u to v over the\r\nnon-removed edges.What is the maximum possible size of a set S after you\r\nremove some edges from the graph and both indegrees and outdegrees of\r\nall vertices either decrease or remain equal to 0?\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n\n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n\n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n\n#define pb                          push_back\n\n#define pry                         puts(\"YES\")\n#define prn                         puts(\"NO\")\n#define endl                        '\\n'\n\n#define fst                         first\n#define scn                         second\n\nconst int N = 2e5;\nint in[N], out[N];\n\nvector<int> adj[N];\nbitset<N> c;\nint dp[N];\n\nvoid dfs(int u){\n    if (c[u]) \n        return;\n    dp[u] = 1;\n    c[u] = 1;\n    if (out[u] < 2) \n        return;\n\n    for(auto x : adj[u]){\n        dfs(x);\n        if (in[x] > 1)\n            dp[u] = max(dp[u], 1 + dp[x]);\n    }\n}\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    for(int i = 0; i < m; ++i){\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n\n        out[a]++;\n        in[b]++;\n        adj[a].pb(b);\n    }\n\n    int ans = 0;\n    for(int i = 0; i < n; ++i){\n        dfs(i);\n    }\n\n    for(int i = 0; i < n; ++i){\n        ans = max(ans,dp[i]);\n    }\n\n    cout << ans << endl;\n}\n\nint32_t main(){\n    #ifndef ONPC\n        ios_base::sync_with_stdio(0);cin.tie(0);\n    #else\n        freopen(\"in\", \"r\", stdin);\n    #endif\n    int t = 1;\n    /* cin >> t; */\n    while(t--)\n        solve();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Remove Directed Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/102482",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem in reverse.Imagine we have already removed some\r\nedges, so that the conditions hold. When is some set of vertices\r\nconsidered ? Since the graph is acyclic, we can topologically sort the\r\nvertices in the set. The vertices are reachable from each other, so\r\nthere exists a path from the -th vertex in the set to the -st vertex.\r\nThus, there exists a path that goes through all chosen vertices.However,\r\nwe can make this conclusion even stronger. In the optimal answer, not\r\njust the path goes from the -th vertex to the -st one, but a single\r\nedge. That can be shown by contradiction. Let there be some vertices and\r\nthat are adjacent in the chosen set. There exists a path between them,\r\nbut not a single edge. We want to show that this set is not optimal and\r\ncan be made larger.The vertices on that path don\u00e2\u0080\u0099t belong to the set. If\r\nthey did, they would be between and in the set (because of the\r\ntopological order). We can add them to the set. Every vertex that can\r\nreach , can reach them too, and every vertex that can be reached from ,\r\ncan be reached from them. Thus, it will still be a set. Now every vertex\r\nfrom to has an edge between them and the size of the set is larger.Thus,\r\nwe showed that the maximum set in the answer is always some path in the\r\ngraph.So the task is to choose some path, then remove some edges so that\r\nthis path still exists and the conditions hold. Note that if the\r\nconditions hold for some set of remaining edges, then we can remove any\r\nedge from it, and the conditions will still be met. Thus, we can only\r\nleave this path.Let\u00e2\u0080\u0099s look closer into the conditions. What they\r\nactually tell is the following. If a vertex has incoming edges, then\r\nremove at least one of them. The same for the outgoing edges.Since we\r\nare looking for a path, it\u00e2\u0080\u0099s enough to leave one outgoing edge for all\r\nvertices except the last one and leave one incoming edge for all\r\nvertices except the first one.In order to achieve that, every vertex\r\nexcept the last one should have at least two outgoing edges and every\r\nvertex except the first one should have at least two incoming edges.We\r\ncan see that this condition is not only necessary, but sufficient as\r\nwell. Just remove the outgoing edges which don\u00e2\u0080\u0099t go to the next vertex\r\nand the incoming edges which don\u00e2\u0080\u0099t go from the previous vertex.Now we\r\ncan wrap this up into the dynamic programming. Initialize the answer\r\nwith , since you can always remove all edges, and get a set with one\r\nvertex.Then let be the longest path such that it starts in vertex , all\r\nvertices in it have at least two incoming edges and all vertices except\r\nmaybe the final one have at least two outgoing edges.Initialize the for\r\nthe vertices that can be the final in the path (have at least two\r\nincoming edges) with . Then update for all that can be internal vertices\r\n(have at least two outgoing and two incoming edges) with for all\r\noutgoing edges .Finally, update the answer from the vertices that can be\r\nthe first one in the path. For each vertex that has at least two\r\noutgoing edges, take the value of for all outgoing edges .Overall\r\ncomplexity: .\r\n"
}