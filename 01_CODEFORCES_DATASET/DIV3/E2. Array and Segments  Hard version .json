{
    "link": "https://codeforces.com//contest/1108/problem/E2",
    "problemId": "286772",
    "problem_idx": "E2",
    "shortId": "1108E2",
    "contest_number": "1108",
    "problem_submissions": {
        "F": [
            48844825,
            48862163,
            48848324,
            48848130,
            48852294,
            48850212,
            48838457,
            48838256,
            48836252,
            48909101,
            48845595,
            48850104,
            48843426,
            48844816,
            48883602
        ],
        "E1": [
            48835917,
            48840618,
            48808903,
            48835183,
            48832250,
            48823205,
            48832522,
            48828568,
            48833167,
            48832156,
            48841738,
            48836232,
            48828690,
            48847940,
            48835833,
            48836036,
            48834638,
            48838866,
            48844104
        ],
        "E2": [
            48835709,
            48844109,
            48822818,
            48835022,
            48838613,
            48845982,
            48955072,
            48856736,
            48884776,
            48838175,
            48842079,
            48839961,
            48846288,
            48846487,
            48844520,
            48843523
        ],
        "D": [
            48819956,
            48826572,
            48809346,
            48824842,
            48817280,
            48817540,
            48824822,
            48819948,
            48824552,
            48909120,
            48824055,
            48812013,
            48824784,
            48817759,
            48822110,
            48828365,
            48827975,
            48821821,
            48832316,
            48824776
        ],
        "C": [
            48816726,
            48823616,
            48805698,
            48816182,
            48814495,
            48812589,
            48819587,
            48815831,
            48817913,
            48909136,
            48819613,
            48817733,
            48820640,
            48837755,
            48816702,
            48811230,
            48820437,
            48818121,
            48821557,
            48818894
        ],
        "B": [
            48812488,
            48806606,
            48811060,
            48806723,
            48809336,
            48805383,
            48812792,
            48811800,
            48810047,
            48909150,
            48813994,
            48807942,
            48810147,
            48809048,
            48810769,
            48806352,
            48811586,
            48811107,
            48808604,
            48810570
        ],
        "A": [
            48804415,
            48868180,
            48868032,
            48808820,
            48801772,
            48803106,
            48804293,
            48801670,
            48804786,
            48802995,
            48802478,
            48909143,
            48804883,
            48801594,
            48807139,
            48804067,
            48807170,
            48802448,
            48806432,
            48806874,
            48802749,
            48804777
        ]
    },
    "name": "E2. Array and Segments  Hard version ",
    "statement": ".You are given an array a consisting of n integers. The value of the\r\ni-th element of the array is a_i.You are also given a set of m segments.\r\nThe j-th segment is [l_j; r_j], where 1\r\nle l_j\r\nle r_j\r\nle n.You can choose some subset of the given set of segments and\r\ndecrease values on each of the chosen segments by one (). For example,\r\nif the initial array a = [0, 0, 0, 0, 0] and the given segments are [1;\r\n3] and [2; 4] then you can choose both of them and the array will become\r\nb = [-1, -2, -2, -1, 0].You have to choose some subset of the given\r\nsegments () in such a way that if you apply this subset of segments to\r\nthe array a and obtain the array b then the value\r\nmax\r\nlimits_{i=1}^{n}b_i -\r\nmin\r\nlimits_{i=1}^{n}b_i will be possible.Note that .If there are multiple\r\nanswers, you can print .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fn \"test\"\n#define fn1 \"\"\n\nusing namespace std;\n\nconst int mn = 1 * (int)(1e5) + 10;\nconst int mod = 1 * (int)(1e9) + 7;\nconst int mm = 1 * (int)(1e3) + 10;\nconst int base = 1 * (int)(1e9);\nconst bool aNs = 0;\n\nint tt, ntest = 1;\n\nvoid docfile()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    if (ifstream(fn\".inp\"))\n    {\n        freopen(fn\".inp\", \"r\", stdin);\n        if (!aNs) freopen(fn\".out\", \"w\", stdout);\n\t\telse freopen (fn\".ans\", \"w\", stdout);\n    }else if (ifstream(fn1\".inp\"))\n    {\n        freopen(fn1\".inp\", \"r\", stdin);\n        freopen(fn1\".out\", \"w\", stdout);\n    }\n}\n\ntemplate <typename T>\nvoid read(T& x)\n{\n    x = 0; T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = ch == '-' ? - f : f, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    x *= f;\n}\n\ntemplate <typename T>\nvoid write (T a)\n{\n    if (a < 0)\n    {\n        putchar ('-');\n        write (-a);\n        return;\n    }\n    if (a < 10)\n    {\n        putchar ('0' + a);\n        return;\n    }\n    write (a / 10);\n    putchar ((char)('0' + (a % 10)));\n}\n\nint a[mn], bi[mn], L[mn], R[mn];\nvector<int> v[mn], g[mn];\n\ntemplate<class T>\nclass IT\n{\n    T MAX (T a, T b)\n    {\n        return min (a, b);\n    }\n    void Assign (T& a, T b)\n    {\n        a += b;\n    }\n    public:\n        vector<T> it, la;\n        int n;\n        bool Lazy;\n        IT (int N = mn, bool LazY = 0)\n        {\n            n = N;\n            it.resize(4 * n + 10);\n            la.resize(4 * n + 10);\n            Lazy = LazY;\n            clear();\n        }   \n\n        void resize (int N)\n        {\n            n = N;\n            it.resize (4 * n + 10);\n            la.resize (4 * n + 10);\n        }\n\n        void lazy (int id, T w)\n        {\n            Assign (it[id], w);\n            if (!Lazy) return;\n            Assign (la[id], w);\n        }\n\n        void layd (int id)\n        {\n            if (!Lazy) return;\n            int i = id << 1;\n            lazy (i, la[id]);\n            lazy (i ^ 1, la[id]);\n            la[id] = 0;\n        }\n\n        void clear (int id = 1, int l = 1, int r = - 1)\n        {\n            if (r == - 1) r = n;\n            it[id] = a[l];\n            if (l == r) return;\n            int i = id << 1, m = (l + r) >> 1;\n            clear (i, l, m);\n            clear (i ^ 1, m + 1, r);\n            it[id] = MAX (it[i], it[i ^ 1]);\n        }\n\n        void ud (int a, int b, T w, int id = 1, int l = 1, int r = - 1)\n        {\n            if (r == - 1) r = n;\n            if (l > b || r < a) return;\n            if (l >= a && r <= b)\n            {\n                lazy (id, w);\n                return;\n            }\n            int m = (l + r) >> 1, i = id << 1;\n            layd (id);\n            ud (a, b, w, i, l, m);\n            ud (a, b, w, i ^ 1, m + 1, r);\n            it[id] = MAX (it[i], it[i ^ 1]);\n        }\n\n        T qu (int a, int b, int id = 1, int l = 1, int r = - 1)\n        {\n            return it[1];\n        }\n};\n\nvoid enter()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++ i)\n    {\n        cin >> a[i];\n    }\n    IT<int> it (n, 1);\n    for (int i = 0; i < m; ++ i)\n    {\n        int l, r;\n        cin >> l >> r;\n        L[i] = l; R[i] = r;\n        v[r].emplace_back(l);\n        g[l].emplace_back(r);\n        it.ud (l, r, - 1);\n    }\n    int I;\n    int sol = 0;\n    for (int i = 1; i <= n; ++ i)\n    {\n        for (int j : v[i - 1]) \n        {\n            it.ud (j, i - 1, - 1);\n        }\n        for (int j : g[i])\n        {\n            it.ud (i, j, 1);\n        }\n        int r = a[i] - it.qu (1, n);\n        if (r > sol)\n        {\n            sol = r;\n            I = i;\n        }\n    }\n    cout << sol << \"\\n\";\n    if (!sol)\n    {\n        cout << 0;\n        return;\n    }\n    vector<int> v;\n    for (int i = 0; i < m; ++ i)\n    {\n        if (R[i] < I || L[i] > I) v.emplace_back(i);\n    }\n    cout << v.size() << \"\\n\";\n    for (int i : v)\n    cout << i + 1 << \" \";\n}\n\nvoid solve()\n{\n\n}\n\nvoid print_result()\n{\n\n}\n\nint main()\n{\n    docfile();\n    //cin>>ntest;\n    for (tt = 1; tt <= ntest; ++ tt)\n    {\n        enter();\n        solve();\n        print_result();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Array and Segments  Hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/64751",
    "editorial": "This tutorial is based on the previous problem (easy version)\r\ntutorial.At first, I want to say I know that this problem and this\r\napproach can be implemented in with segment tree.So, we iterate over all\r\nsupposed maximums in the array and trying to apply all segments not\r\ncovering our current element. How do we can calculate the answer for\r\nelement if this element is the supposed maximum?Let\u00e2\u0080\u0099s divide all\r\nsegments we apply into two parts: the first part consists of segments\r\nsuch that their right endpoints is less than the current position and\r\nthe second part consists of segments such that their left endpoints is\r\ngreater than the current position. Then let\u00e2\u0080\u0099s independently calculate\r\nanswers for the left and for the right parts and merge them to obtain\r\nthe answer.I will consider only first part of the solution (first part\r\nof segments) because the second part is absolutely symmetric with\r\nit.Let\u00e2\u0080\u0099s maintain the minimum value on prefix of the array (let it be\r\nand initially it equals to ), maintain the array of length (initially\r\nits values are and means the answer if the -th element of the array will\r\nbe supposed maximum) and the array of length , where will be the value\r\nfor which we decrease the -th element (in other words, the number of\r\nsegments we apply to the -th element).What do we do for the current\r\nposition ? Firstly, let\u00e2\u0080\u0099s update the answer for it with the value (in\r\nother words, set )). Then let\u00e2\u0080\u0099s apply all segments with right endpoints\r\nequals to the current position straight-forward and update the value\r\nwith each new value of covered elements. Just iterate over all positions\r\nof each segment ends in the current position, make and set . And don\u00e2\u0080\u0099t\r\nforget to update the value with the value after all changes (because we\r\nneed to update this value with each element not covered by segments\r\ntoo).So then let\u00e2\u0080\u0099s do the same from right to left and then will mean the\r\nanswer if the -th element is the supposed maximum in the resulting\r\narray. Then we can find any position of the maximum in the array and\r\napply all segments which don\u00e2\u0080\u0099t cover this position.What is time\r\ncomplexity of the solution above? We iterate over all elements in the\r\narray, this is and apply each segment in , so the final time complexity\r\nis .\r\n"
}