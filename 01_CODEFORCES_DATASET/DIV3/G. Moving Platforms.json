{
    "link": "https://codeforces.com//contest/1932/problem/G",
    "problemId": "2483354",
    "problem_idx": "G",
    "shortId": "1932G",
    "contest_number": "1932",
    "problem_submissions": {
        "F": [
            247041710,
            247046104,
            247061921,
            247064848,
            247065969,
            247067691,
            247069162,
            247061542,
            247047981,
            247066270,
            247064434,
            247030399,
            247061453,
            247062334,
            247071817,
            247074345,
            247065688,
            247070314,
            247059158
        ],
        "E": [
            247027158,
            247035724,
            247041508,
            247047392,
            247034566,
            247041281,
            247042901,
            247046269,
            247024107,
            247043959,
            247047309,
            247065699,
            247024211,
            247033451,
            247040047,
            247039052,
            247047772,
            247051378,
            247048000
        ],
        "D": [
            247025048,
            247024422,
            247027652,
            247025385,
            247027600,
            247026819,
            247026306,
            247030155,
            247057812,
            247034591,
            247024028,
            247050558,
            247039827,
            247050562,
            247026148,
            247035436,
            247033238,
            247031618,
            247035376
        ],
        "C": [
            247015841,
            247009093,
            247007805,
            247004912,
            247003665,
            247007946,
            247004168,
            247011243,
            247008047,
            247006061,
            247009525,
            247006826,
            247014290,
            247003444,
            247011933,
            247011062,
            247018803,
            247012040,
            247018641
        ],
        "B": [
            247001265,
            246998420,
            246995287,
            246992797,
            246996723,
            246996283,
            246995886,
            247000182,
            247000282,
            246995830,
            246996405,
            246997168,
            246998810,
            246995354,
            247001435,
            246999756,
            247001109,
            246996459,
            247006888
        ],
        "A": [
            246992414,
            246989927,
            246990007,
            246989302,
            246989500,
            246989572,
            246991281,
            246989684,
            246995787,
            246990634,
            246991174,
            246992575,
            246993925,
            246989365,
            246994593,
            246993034,
            246991641,
            246989247,
            246991878
        ],
        "G": [
            247104441,
            247824611,
            247147433,
            247796255
        ]
    },
    "name": "G. Moving Platforms",
    "statement": "There is a game where you need to move through a labyrinth. The\r\nlabyrinth consists of n platforms, connected by m passages. Each\r\nplatform is at some level l_i, an integer number from 0 to H - 1. In a\r\nsingle step, if you are currently on platform i, you can stay on it, or\r\nmove to another platform j. To move to platform j they have to be\r\nconnected by the passage, and their levels have to be the same, namely\r\nl_i = l_j.After each step, the levels of all platforms change. The new\r\nlevel of platform i is calculated as l’_i = (l_i + s_i)\r\nbmod H, for all i. You start on platform 1. Find the minimum number of\r\nsteps you need to get to platform n.\r\n",
    "solutions": [
        "﻿#include <bits/stdc++.h>\n#define int long long\n#define lcm(a,b) a/__gcd(a,b)*b\nusing namespace std;\nint extended_euclid(int a, int b, int &x, int &y)\n{\n    if (a < 0)\n    {\n        int r = extended_euclid(-a, b, x, y);\n        x *= -1;\n        return r;\n    }\n    if (b < 0)\n    {\n        int r = extended_euclid(a, -b, x, y);\n        y *= -1;\n        return r;\n    }\n    if (b == 0)\n    {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int g = extended_euclid(b, a % b, y, x);\n    y-=(a/b)*x;\n    return g;\n}\nint ldioph(int a, int b, int c, int &x, int &y, bool &found)\n{\n    int g=extended_euclid(a,b,x,y);\n    if( (found = c % g == 0))\n        x*=c/g,y*=c/g;\n    return g;\n}\nstruct edge\n{\n    int v,w;\n    edge(int v,int w):v(v),w(w) {}\n    bool operator<(const edge&other)const\n    {\n        return w>other.w;\n    }\n};\nconst int N=1e5+5;\nvector<int>adj[N];\nint l[N],s[N];\nint n,m,h;\nint dijkstra(int src,int dest)\n{\n    vector<int>dist(n+1,1e18);\n    dist[src]=0;\n    priority_queue<edge>q;\n    q.push(edge(src,0));\n    while(!q.empty())\n    {\n        auto p=q.top();\n        q.pop();\n        if(p.w>dist[p.v])continue;\n        //l[i]+x*s[i]-y*h=l[j]+x*s[j]-z*h\n        //x*(s[i]-s[j])-(y-z)*h=l[j]-l[i]\n        //x=((l[j]-l[i])+(y-z)*h)/(s[i]-s[j])\n        for(auto&it:adj[p.v])\n        {\n            int cost=1e18,x=0,y=0;\n            int rhs=(l[it]-l[p.v]+h)%h;\n            int lhs=(s[p.v]-s[it]+h)%h;\n            bool found=0;\n            int g=ldioph(lhs,h,rhs,x,y,found);\n            if(!found)\n                continue;\n            int inc=h/g;\n            if(x<p.w)\n                x+=(p.w-x+inc)/inc*inc;\n            x-=(x-p.w)/inc*inc;\n            cost=x+1;\n            if(cost<dist[it])\n            {\n                dist[it]=cost;\n                q.push(edge(it,dist[it]));\n            }\n        }\n    }\n    return (dist[dest]>=1e18 ? -1:dist[dest]);\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0) ;\n    cin.tie(0) ;\n    cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        cin>>n>>m>>h;\n        for(int i=1; i<=n; i++)\n        {\n            cin>>l[i];\n        }\n        for(int i=1; i<=n; i++)\n        {\n            cin>>s[i];\n        }\n        while(m--)\n        {\n            int u,v;\n            cin>>u>>v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        cout<<dijkstra(1,n)<<'\\n';\n        for(int i=1; i<=n; i++)\n            adj[i].clear();\n    }\n    return 0 ;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "math",
        "number theory",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Moving Platforms.json",
    "editorial_link": "https://codeforces.com//blog/entry/126196",
    "editorial": "First, note that the event of two platforms being on the same level at a\r\ngiven moment does not depend on your moves. Hence, it is always optimal\r\nto get to any vertex you may need to reach the vertex as soon as\r\npossible. It means that you can simply run Dijkstraâs algorithm to\r\ncalculate the minimal number of moves needed to reach every vertex.The\r\nonly complication is that you need to determine for some vertices , and\r\nmoment what is the next moment when , i.e. find minimal such that and .\r\nThat can be equivalently written as . can be solved in such way: If is\r\nnot divisible by then there is no solution. Otherwise, divide by . Name\r\nthem . Then . can be found using extended Eucledian algorithm. The only\r\nthing remaining is to find minimal such that and .\r\n",
    "hint": []
}