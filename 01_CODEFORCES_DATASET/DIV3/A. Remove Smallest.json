{
    "link": "https://codeforces.com//contest/1399/problem/A",
    "problemId": "691716",
    "problem_idx": "A",
    "shortId": "1399A",
    "contest_number": "1399",
    "problem_submissions": {
        "F": [
            89035173,
            89029933
        ],
        "E2": [
            89011999,
            89030510,
            89080621,
            89039473,
            89040534,
            89201926,
            89050383,
            89034156,
            89084070,
            89049259,
            89035111,
            89052507,
            89050541,
            89057093,
            89080141
        ],
        "E1": [
            88996046,
            89009546,
            89080613,
            89010335,
            89023941,
            89019900,
            89014538,
            89084044,
            89031455,
            89027397,
            89021735,
            89030142,
            89008436,
            89007483,
            89015010,
            89097316,
            89017545,
            89018333,
            89016025,
            89019887,
            89020808
        ],
        "D": [
            88983986,
            88986050,
            89080684,
            89080600,
            88990615,
            88995867,
            88990140,
            88981358,
            89083571,
            89083120,
            88982379,
            89003434,
            89001587,
            89002958,
            88987435,
            88992856,
            88978240,
            88981220,
            89097279,
            88987544,
            88985548,
            88986877,
            88997105
        ],
        "C": [
            88974580,
            88974518,
            89080589,
            88982402,
            88985705,
            88979354,
            88966362,
            89082893,
            88973387,
            88994104,
            88993313,
            88993807,
            88971087,
            88979014,
            88975937,
            88963847,
            89097258,
            88972661,
            88974247,
            88977241,
            88976735,
            88981249
        ],
        "B": [
            88964383,
            88965521,
            89080579,
            88970001,
            88977862,
            88967937,
            88959373,
            89082724,
            88963456,
            88986912,
            88979078,
            88973586,
            88969906,
            88966168,
            88957629,
            88964497,
            89097240,
            88962105,
            88966474,
            88966506,
            88969861
        ],
        "A": [
            88956237,
            88956430,
            89080574,
            88960295,
            88969663,
            88957655,
            88955164,
            89082748,
            88955338,
            88967328,
            88967166,
            88962494,
            88973926,
            88959306,
            88955102,
            88955579,
            89097191,
            88955839,
            88955943,
            88956625,
            88962720
        ]
    },
    "name": "A. Remove Smallest",
    "statement": "You are given the array a consisting of n positive (greater than zero)\r\nintegers.In one move, you can choose two indices i and j (i\r\nne j) such that the absolute difference between a_i and a_j is no more\r\nthan one (|a_i - a_j|\r\nle 1) and remove the smallest of these two elements. If two elements are\r\nequal, you can remove any of them (but exactly one).Your task is to find\r\nif it is possible to obtain the array consisting of using several\r\n(possibly, zero) such moves or not.You have to answer t independent test\r\ncases.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 50+5;\nint a[MAXN],n;\n\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--){\n        scanf(\"%d\",&n);\n        FOR(i,1,n) scanf(\"%d\",a+i);\n        std::sort(a+1,a+n+1);\n        bool flag = 1;\n        FOR(i,1,n-1){\n            if(std::abs(a[i]-a[i+1]) > 1){flag = 0;break;}\n        }\n        puts(flag?\"YES\":\"NO\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Remove Smallest.json",
    "editorial_link": "https://codeforces.com//blog/entry/81082",
    "editorial": "Firstly, letâs sort the initial array. Then itâs obvious that the best\r\nway to remove elements is from smallest to biggest. And if there is at\r\nleast one such that and then the answer is \"\", because we have no way to\r\nremove . Otherwise, the answer is \"\".\r\n",
    "hint": []
}