{
    "link": "https://codeforces.com//contest/1311/problem/E",
    "problemId": "547480",
    "problem_idx": "E",
    "shortId": "1311E",
    "contest_number": "1311",
    "problem_submissions": {
        "E": [
            71808916,
            71808599,
            93123368,
            71844658,
            71866557,
            71838628,
            71799873
        ],
        "F": [
            71796868,
            71806217,
            71793472,
            71796876,
            71799840,
            71794628,
            71797683,
            71798778,
            71801869,
            71798514,
            71800897,
            71799483,
            71790429,
            71801970,
            71792412,
            71808363,
            71786195,
            71809262,
            71804250,
            71795148,
            71802574
        ],
        "D": [
            71789526,
            71792384,
            71787369,
            71788637,
            71807660,
            71784383,
            71788643,
            71785457,
            71791043,
            71788249,
            71788689,
            71786913,
            71784594,
            71790030,
            71782423,
            71790272,
            71801279,
            71813581,
            71789490,
            71790803,
            71785471,
            71796175
        ],
        "C": [
            71780601,
            71787244,
            71778720,
            71777956,
            71779055,
            71778652,
            71779823,
            71780370,
            71778687,
            71783497,
            71778399,
            71780701,
            71778150,
            71779429,
            71783732,
            71786917,
            71780561,
            71786514,
            71779237,
            71783097
        ],
        "B": [
            71777211,
            71782922,
            71775982,
            71774247,
            71774556,
            71775523,
            71776728,
            71774631,
            71774172,
            71777830,
            71773973,
            71777033,
            71796675,
            71772169,
            71780446,
            71783294,
            71775698,
            71782264,
            71797768,
            71775685
        ],
        "A": [
            71772411,
            71773163,
            71770634,
            71770076,
            71770517,
            71771510,
            71769980,
            71769842,
            71770112,
            71771016,
            71769997,
            71771281,
            71773789,
            71770312,
            71772059,
            71777686,
            71771553,
            71771635,
            71774048,
            71770666
        ]
    },
    "name": "E. Construct the Binary Tree",
    "statement": "You are given two integers n and d. You need to construct a rooted\r\nbinary tree consisting of n vertices with a root at the vertex 1 and the\r\nsum of depths of all vertices equals to d.A tree is a connected graph\r\nwithout cycles. A rooted tree has a special vertex called the root. A\r\nparent of a vertex v is the last different from v vertex on the path\r\nfrom the root to the vertex v. The depth of the vertex v is the length\r\nof the path from the root to the vertex v. Children of vertex v are all\r\nvertices for which v is the parent. The binary tree is such a tree that\r\nno vertex has more than 2 children.You have to answer t independent test\r\ncases.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <set>\nusing namespace std;\nint minans[5005];\nint fa[5005];\nint dep[5005];\nmultiset<int> s[5005];\nint main()\n{\n    int t,n,d,tmp,dd,p;\n    minans[1]=0;\n    tmp=0;\n    for(int i=2;i<=5000;i++)\n    {\n        if((i&(-i))==i)\n            tmp++;\n        minans[i]=minans[i-1]+tmp;\n    }\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&d);\n        if(d>n*(n-1)/2)\n        {\n            printf(\"NO\\n\");\n            continue;\n        }\n        if(d<minans[n])\n        {\n            printf(\"NO\\n\");\n            continue;\n        }\n        printf(\"YES\\n\");\n        for(int i=2;i<=n;i++)\n            fa[i]=i-1;\n        dd=n*(n-1)/2-d;\n        p=1;\n        for(int i=0;i<n;i++)\n            s[i].insert(i+1);\n        s[n-1].insert(n);\n        for(int i=1;i<=n;i++)\n            dep[i]=i-1;\n        for(int i=n;i>=2&&dd>0;i--)\n            if(dd>=(i-1)-p)\n            {\n                s[dep[i]].erase(i);\n                s[dep[i]-1].insert(fa[i]);\n                fa[i]=(*s[p-1].begin());\n                s[p-1].erase(s[p-1].begin());\n                s[p].insert(i);\n                s[p].insert(i);\n                dep[i]=p;\n                dd-=(i-1)-p;\n                while(s[p-1].empty())\n                    p++;\n            }\n            else\n            {\n                fa[i]=(*s[(i-1)-dd-1].begin());\n                break;\n            }\n        for(int i=2;i<=n;i++)\n            if(i!=n)\n                printf(\"%d \",fa[i]);\n            else printf(\"%d\\n\",fa[i]);\n        for(int i=0;i<n;i++)\n            s[i].clear();\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Construct the Binary Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/74224",
    "editorial": "This problem has an easy constructive solution. We can find lower and\r\nupper bounds on the value of for the given . If the given does not\r\nbelong to this segment, then the answer is \"\". Otherwise, the answer is\r\n\"\" for any in this segment.How to construct it? Letâs start from the\r\nchain. The answer for the chain is the upper bound of and it is . Then\r\nletâs try to decrease the answer by in one move. Letâs take some leaf\r\n(the vertex without children) with the smallest depth that is not and\r\ntry to move it up. The definition of badness will be below. To do this,\r\nletâs find such vertex that its depth is less than the depth of by and\r\nit has less than children. If we found such vertex then letâs make the\r\nchild of and decrease the answer by one.If we didnât find such vertex ,\r\nI claim that the vertex has the minimum possible depth it can have and\r\nwe should not consider it in the future. Letâs mark this vertex as and\r\ncontinue our algorithm.If at some moment we cannot find any not leaf ,\r\nthen the answer is \"\". Otherwise, the answer is \"\".Time complexity: .\r\n",
    "hint": []
}