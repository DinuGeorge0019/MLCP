{
    "link": "https://codeforces.com//contest/2000/problem/D",
    "problemId": "2814030",
    "problem_idx": "D",
    "shortId": "2000D",
    "contest_number": "2000",
    "problem_submissions": {
        "H": [
            276260761,
            276254307,
            276338511,
            276338125,
            276287387,
            276274340,
            276297740,
            276283267,
            276239793
        ],
        "G": [
            276214295,
            276274205,
            276334839,
            276268681,
            276267752,
            276333913,
            276264214,
            276282487,
            276272917,
            276276698,
            276277916,
            276283043,
            276274434,
            276291075,
            276278976,
            276290903,
            276279110,
            276279777
        ],
        "F": [
            276187296,
            276292316,
            276241660,
            276217578,
            276210913,
            276233999,
            276287795,
            276243858,
            276234274,
            276242694,
            276256602,
            276245569,
            276246137,
            276247924,
            276245207,
            276252538,
            276247124,
            276252754
        ],
        "E": [
            276164357,
            276333842,
            276186649,
            276185811,
            276179141,
            276203373,
            276182533,
            276188814,
            276185638,
            276210532,
            276225686,
            276198909,
            276209550,
            276178261,
            276202986,
            276227179,
            276202989,
            276229818,
            276227160
        ],
        "D": [
            276136722,
            276189642,
            276169653,
            276164982,
            276157636,
            276177807,
            276157222,
            276166197,
            276153213,
            276123696,
            276151555,
            276167672,
            276198896,
            276149967,
            276172892,
            276184459,
            276158053,
            276189336,
            276175071,
            276189558
        ],
        "C": [
            276127716,
            276172717,
            276135515,
            276132005,
            276139984,
            276155253,
            276134367,
            276142615,
            276142046,
            276180920,
            276133384,
            276141737,
            276151150,
            276139308,
            276147822,
            276167768,
            276145316,
            276158457,
            276159660,
            276137717
        ],
        "B": [
            276113898,
            276143388,
            276119169,
            276116606,
            276127808,
            276130717,
            276117856,
            276125745,
            276187672,
            276126451,
            276118391,
            276127646,
            276126167,
            276125801,
            276113780,
            276142176,
            276122501,
            276133620,
            276118200,
            276121342
        ],
        "A": [
            276110192,
            276136464,
            276111783,
            276110916,
            276119966,
            276120191,
            276111146,
            276116630,
            276117760,
            276111077,
            276112237,
            276116291,
            276115237,
            276115760,
            276110510,
            276123000,
            276110417,
            276117261,
            276112340,
            276130762
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132689",
    "editorial": "Note that since all characters of the selected segment of the string are\r\nerased after applying the operation, the segments we choose cannot\r\noverlap. However, they can be nested if we first choose an inner segment\r\nand then an outer one.Since all numbers in the array are positive, it is\r\nalways beneficial to take the largest possible segment in the answer,\r\nthat is, from the first â to the last â. By choosing this segment, we\r\ncan only select segments within it. We will continue to choose such\r\nsegments within the last selected one as long as possible. To quickly\r\nfind the sums of the segments, we will calculate the prefix sums of the\r\narray .\r\n",
    "name": "D. Right Left Wrong",
    "statement": "Vlad found a strip of n cells, numbered from left to right from 1 to n.\r\nIn the i-th cell, there is a positive integer a_i and a letter s_i,\r\nwhere all s_i are either ” or ”.Vlad invites you to try to score the\r\nmaximum possible points by performing any (possibly zero) number of\r\noperations.In one operation, you can choose two indices l and r (1\r\nle l < r\r\nle n) such that s_l = ” and s_r = ” and do the following: add a_l +\r\na_{l + 1} +\r\ndots + a_{r - 1} + a_r points to the current score; replace s_i with ”\r\nfor all l\r\nle i\r\nle r, meaning you can no longer choose these indices. For example,\r\nconsider the following strip: 351432 You can first choose l = 1, r = 2\r\nand add 3 + 5 = 8 to your score. 351432 Then choose l = 3, r = 6 and add\r\n1 + 4 + 3 + 2 = 10 to your score. 351432 As a result, it is impossible\r\nto perform another operation, and the final score is 18.What is the\r\nmaximum score that can be achieved?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include<array>using namespace std;#define ll long long#define int long long#define y1 idfsu#define PII pair<int, int>#define fi first#define se second#define endl \"\\n\"const int MAX = 1e9;const int MAXN = 1e6 + 10;const int mod = 1e9 + 7;const int N = 200010;int aa[200010];void solve(){    int n;    int sum = 0;    cin >> n;    for (int i = 1; i <= n; i++)        cin >> aa[i], aa[i] += aa[i - 1];    string a;    cin >> a;    a = ' ' + a;    int l = 1, r = n;    while (l < r)    {        while (l < r && a[l] == 'R')            l++;        while (l < r && a[r] == 'L')            r--;        if (l < r)        {            sum += aa[r] - aa[l - 1];            r--, l++;        }    }    cout << sum << endl;}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int T = 1;    cin >> T;    while (T--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Right Left Wrong.json",
    "hint": []
}