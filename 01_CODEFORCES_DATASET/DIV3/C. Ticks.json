{
    "link": "https://codeforces.com//contest/1579/problem/C",
    "problemId": "1123868",
    "problem_idx": "C",
    "shortId": "1579C",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "C. Ticks",
    "statement": "Casimir has a rectangular piece of paper with a checkered field of size\r\nn\r\ntimes m. Initially, all cells of the field are white.Let us denote the\r\ncell with coordinates i vertically and j horizontally by (i, j). The\r\nupper left cell will be referred to as (1, 1) and the lower right cell\r\nas (n, m).Casimir draws of different sizes on the field. A tick of size\r\nd (d > 0) with its center in cell (i, j) is drawn as follows: First, the\r\ncenter cell (i, j) is painted black. Then exactly d cells on the\r\ntop-left diagonally to the center and exactly d cells on the top-right\r\ndiagonally to the center are also painted black. That is all the cells\r\nwith coordinates (i - h, j\r\npm h) for all h between 0 and d are painted. In particular, a tick\r\nconsists of 2d + 1 black cells. An already painted cell will remain\r\nblack if painted again. Below you can find an example of the 4\r\ntimes 9 box, with two ticks of sizes 2 and 3. You are given a\r\ndescription of a checkered field of size n\r\ntimes m. Casimir claims that this field came about after he drew some\r\n(possibly 0) ticks on it. The ticks could be of different sizes, but the\r\nsize of each tick is at least k (that is, d\r\nge k for all the ticks).Determine whether this field can indeed be\r\nobtained by drawing some (possibly none) ticks of sizes d\r\nge k or not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n,m,k;\nchar a[25][25];\nchar b[25][25];\n\nvoid Print(int x,int y,int len) {\n    for(int i = 0;i <= len;i++) {\n        if(x-i < 1||y-i < 1||a[x-i][y-i] == '.') return;\n        if(y+i > m||a[x-i][y+i] == '.') return;\n    }\n    for(int i = 0;i <= len;i++) {\n        b[x-i][y-i] = b[x-i][y+i] = '*';\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n >> m >> k;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i]+1;\n            for(int j = 1;j <= m;j++) b[i][j] = '.';\n        }\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= m;j++) {\n                for(int len = k;len <= n;len++) Print(i,j,len);\n            }\n        }\n        int nope = 0;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= m;j++) {\n                if(a[i][j] != b[i][j]) nope = 1;\n            }\n        }\n        if(nope) cout << \"NO\\n\";\n        else cout << \"YES\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Ticks.json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "For each painted cell, we will determine whether it can be part of some\r\ntick of the allowed size. If some of the cells cannot be a part of any\r\ntick, the answer is obviously . Otherwise, letâs match each colored cell\r\nwith an arbitrary valid (entirely contained in the field under\r\nconsideration and of size ) tick containing it. Letâs draw all such\r\nticks, then the following holds: no empty (white) cell of the field will\r\nbe painted, since only ticks that do not contradict the field in\r\nquestion have been considered; every colored cell of the field will be\r\ncovered by at least one drawn tick (at least the one we matched it\r\nwith). Basically, this process gives us a field in which the set of\r\npainted cells matches the data in the input, which means that the field\r\ngiven in the input could have been obtained, in particular, in the way\r\ndescribed above, and the answer is .In order to check that all painted\r\ncells are parts of some ticks, letâs go through all possible ticks of\r\nsize and for each tick mark all the cells included in it. If there is at\r\nleast one unmarked painted cell in the end, it canât be a part of any\r\nvalid tick, and the answer is .To consider all possible ticks, we can\r\niterate through all their possible center cells, that is, all the\r\npainted cells. Since smaller ticks are subsets of larger ticks with the\r\nsame center cell it is sufficient to find the maximal size tick that can\r\nbe constructed from that center cell. So for each painted cell we aim to\r\nfind the maximal possible size of a tick with its center in this very\r\ncell. Let us now consider a painted cell as a possible center of some\r\ntick. By the definition of a tick, this cell can be a center of a tick\r\nof size if for all from to both cells and exist (are not out of bounds)\r\nand are painted. Letâs iterate through from to , and stop when the\r\ndescribed condition is no longer satisfied. The largest for which the\r\ncondition is still satisfied gives us the maximum possible size of a\r\ntick with its center in . Now if , then such a tick is valid, and all\r\nthe cells included in it should be marked. Otherwise, it could not have\r\nbeen drawn, and none of its cells should be marked.After a complete\r\ncheck of all possible ticks in a given field, either there will be no\r\nunchecked painted cells and then the answer is , or at least one painted\r\ncell is not covered by any valid checkbox and then the answer is .The\r\ntime complexity is .\r\n",
    "hint": []
}