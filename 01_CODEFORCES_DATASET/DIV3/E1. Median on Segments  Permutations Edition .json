{
    "link": "https://codeforces.com//contest/1005/problem/E1",
    "problemId": "196329",
    "problem_idx": "E1",
    "shortId": "1005E1",
    "contest_number": "1005",
    "problem_submissions": {
        "F": [
            40138065,
            40147546,
            40139536,
            40144099,
            40139733,
            40144938,
            40143679,
            40171160,
            40146303,
            40189217
        ],
        "E1": [
            40128340,
            40127186,
            40134838,
            40136234,
            40136089,
            40143692,
            40135301,
            40137180,
            40144323,
            40124841,
            40127912,
            40131265,
            40133189,
            40133105,
            40133937,
            40134875,
            40135625,
            40134421,
            40131595,
            40135137
        ],
        "D": [
            40125067,
            40124979,
            40128112,
            40136992,
            40132454,
            40129148,
            40135768,
            40128554,
            40130545,
            40126741,
            40124080,
            40124881,
            40127069,
            40127363,
            40130715,
            40128279,
            40129716,
            40130196,
            40122168,
            40126677
        ],
        "C": [
            40122844,
            40120537,
            40121740,
            40127956,
            40126845,
            40126210,
            40127542,
            40132586,
            40121476,
            40122273,
            40121226,
            40121504,
            40123842,
            40124485,
            40124848,
            40125814,
            40188075,
            40124052,
            40125727,
            40127465,
            71194295,
            40123366
        ],
        "B": [
            40118557,
            40118253,
            40123880,
            40122022,
            40117993,
            40119623,
            40121553,
            40121128,
            40129302,
            40117431,
            40118713,
            40118894,
            40119013,
            40119692,
            40120886,
            40121682,
            40120694,
            40121733,
            40125463,
            40118716
        ],
        "A": [
            40117449,
            40117425,
            40122790,
            40118389,
            40117428,
            40118037,
            40118019,
            40118741,
            40117459,
            40117842,
            40117471,
            40117684,
            40117553,
            40117896,
            40118376,
            40119285,
            40118988,
            40117794,
            40123668,
            40117617
        ],
        "E2": [
            40142192,
            40138140,
            40137960,
            97340051,
            97338094,
            40194804,
            40187840
        ]
    },
    "name": "E1. Median on Segments  Permutations Edition ",
    "statement": "You are given a permutation p_1, p_2,\r\ndots, p_n. A permutation of length n is a sequence such that each\r\ninteger between 1 and n occurs exactly once in the sequence.Find the\r\nnumber of pairs of indices (l, r) (1\r\nle l\r\nle r\r\nle n) such that the value of the median of p_l, p_{l+1},\r\ndots, p_r is exactly the given number m.The median of a sequence is the\r\nvalue of the element which is in the middle of the sequence after\r\nsorting it in non-decreasing order. If the length of the sequence is\r\neven, the left of two middle elements is used.For example, if a=[4, 2,\r\n7, 5] then its median is 4 since after sorting the sequence, it will\r\nlook like [2, 4, 5, 7] and the left of two middle elements is equal to\r\n4. The median of [7, 1, 2, 9, 6] equals 6 since after sorting, the value\r\n6 will be in the middle of the sequence.Write a program to find the\r\nnumber of pairs of indices (l, r) (1\r\nle l\r\nle r\r\nle n) such that the value of the median of p_l, p_{l+1},\r\ndots, p_r is exactly the given number m.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl \"\\n\"\n#define ft first\n#define sd second\n#define openfiles ifstream cin (\"input.txt\"); ofstream cout (\"output.txt\");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, pos;\n    vector<int> A;\n    map<int, int> B;\n    ll sc;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    cin >> n >> m;\n\n    A.assign(n, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        if (A[i] == m) {\n            pos = i;\n        }\n    }\n\n    int cur = 0;\n    B[0]++;\n    for (int i = pos+1; i < n; i++) {\n        if (A[i] > m) {\n            cur++;\n        } else {\n            cur--;\n        }\n        B[cur]++;\n    }\n\n    cur = 0;\n    for (int i = pos-1; i >= 0; i--) {\n        if (A[i] > m) {\n            cur++;\n        } else {\n            cur--;\n        }\n        sc += B[-cur] + B[-cur + 1];\n    }\n\n    sc += B[0];\n    sc += B[1];\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. Median on Segments  Permutations Edition .json",
    "editorial_link": "https://codeforces.com//blog/entry/60511",
    "editorial": "The segment has median equals if and only if belongs to it and or ,\r\nwhere is number of elements in that strictly less than and is number of\r\nelements in that strictly greater than . Here weâve used a fact that is\r\na permutation (on there is exactly one occurrence of ).In other words,\r\nbelongs and the value equals or .Calculate prefix sums , where the value\r\non the prefix of the length (i.e. on the subarray ). For fixed value it\r\nis easy to calculate number of such that is suitable. At first, check\r\nthat met on . Valid values are such indices that: no on and or .Letâs\r\nmaintain number of prefix sums to the left of for each value. We can use\r\njust a map , where is number of such indices that and is to the left of\r\n.So for each that contains do , where is the current value .Time\r\ncomplexity is if a standard map is used or if classical array for is\r\nused (remember about possible negative indices, just use an offset).\r\n",
    "hint": []
}