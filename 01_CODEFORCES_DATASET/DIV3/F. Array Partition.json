{
    "link": "https://codeforces.com//contest/1454/problem/F",
    "problemId": "808365",
    "problem_idx": "F",
    "shortId": "1454F",
    "contest_number": "1454",
    "problem_submissions": {
        "F": [
            99453540,
            99460649,
            99464491,
            99462634,
            99473778,
            99480627,
            99479512,
            99481454,
            99477847,
            99480676,
            99479843,
            99479819,
            99479502,
            99484023,
            99481094,
            99490580,
            99488276,
            99483237,
            99479347,
            99483611,
            99487863
        ],
        "E": [
            99441379,
            99441843,
            99443837,
            99448708,
            99449197,
            99455222,
            99455619,
            99453916,
            99455714,
            99453545,
            99445866,
            99465827,
            99455361,
            99467369,
            99458698,
            99458428,
            99472900,
            99479360,
            99464656,
            99473747
        ],
        "D": [
            99425523,
            99427863,
            99428990,
            99434572,
            99428428,
            99426135,
            99429687,
            99436442,
            99439139,
            99424677,
            99437825,
            99441009,
            99434042,
            99442449,
            99447062,
            99436193,
            99440792,
            99445227,
            99448409,
            99444791
        ],
        "C": [
            99419955,
            99419595,
            99423754,
            99425833,
            99422653,
            99419849,
            99422609,
            99424746,
            99429403,
            99428222,
            99431585,
            99425636,
            99428930,
            99432056,
            99429114,
            99423054,
            99427497,
            99444382,
            99428490
        ],
        "B": [
            99408996,
            99409578,
            99414483,
            99418612,
            99411159,
            99409225,
            99412165,
            99413650,
            99421215,
            99411421,
            99411800,
            99420683,
            99414143,
            99411486,
            99422648,
            99414361,
            99411697,
            99416198,
            99425925,
            99418963
        ],
        "A": [
            99404083,
            99403968,
            99404106,
            99408387,
            99404018,
            99404036,
            99404137,
            99404612,
            99409652,
            99405438,
            99405909,
            99406625,
            99408178,
            99405245,
            99412689,
            99404230,
            99404157,
            99404843,
            99418770,
            99412328
        ]
    },
    "name": "F. Array Partition",
    "statement": "You are given an array a consisting of n integers.Let min(l, r) be the\r\nminimum value among a_l, a_{l + 1},\r\nldots, a_r and max(l, r) be the maximum value among a_l, a_{l + 1},\r\nldots, a_r.Your task is to choose three (greater than 0) integers x, y\r\nand z such that: x + y + z = n; max(1, x) = min(x + 1, x + y) = max(x +\r\ny + 1, n). In other words, you have to split the array a into three\r\nconsecutive non-empty parts that cover the whole array and the maximum\r\nin the first part equals the minimum in the second part and equals the\r\nmaximum in the third part (or determine it is impossible to find such a\r\npartition).Among all such triples (partitions), you can choose any.You\r\nhave to answer t independent test cases.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\", x.f, \", \", x.s, \"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? \", \" : \"\", a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\n    void setOut(string s) { freopen(s.c_str(), \"w\", stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + \".in\"), setOut(s + \".out\"); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nstruct DSU {\n    vector<int> e;\n    void init(int n) {\n        e = vector<int>(n, -1);\n    }\n    int get(int x) {\n        return e[x] < 0 ? x : e[x] = get(e[x]);\n    }\n    bool same_set(int a, int b) {\n        return get(a) == get(b);\n    }\n    int size(int x) {\n        return -e[get(x)];\n    }\n    bool unite(int x, int y) {\n        x = get(x), y = get(y);\n        if (x == y) return false;\n        if (e[x] > e[y]) swap(x, y);\n        e[x] += e[y]; e[y] = x;\n        return true;\n    }\n};\ntemplate<class T> struct RMQ { // floor(log_2(x))\n    int level(int x) { return 31-__builtin_clz(x); } \n    vector<T> v; vector<vi> jmp;\n    int comb(int a, int b) { // index of min\n        return v[a]==v[b]?min(a,b):(v[a]<v[b]?a:b); } \n    void init(const vector<T>& _v) {\n        v = _v; jmp = {vi(sz(v))}; iota(all(jmp[0]),0);\n        for (int j = 1; 1<<j <= sz(v); ++j) {\n            jmp.pb(vi(sz(v)-(1<<j)+1));\n            F0R(i,sz(jmp[j])) jmp[j][i] = comb(jmp[j-1][i],\n                                    jmp[j-1][i+(1<<(j-1))]);\n        }\n    }\n    int index(int l, int r) { // get index of min element\n        assert(l <= r); int d = level(r-l+1);\n        return comb(jmp[d][l],jmp[d][r-(1<<d)+1]); }\n    T query(int l, int r) { return v[index(l,r)]; }\n};\nint main() {\n    setIO(\"\");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        RMQ<int> R;\n        R.init(a);\n        vi pre(n);\n        vi suf(n);\n        f0r(i, n) {\n            if (i == 0) pre[i] = a[i];\n            else pre[i] = max(pre[i-1], a[i]);\n        }\n        for (int i = n-1; i >= 0; i--) {\n            if (i == n-1) suf[i] = a[i];\n            else suf[i] = max(suf[i+1], a[i]);\n        }\n        auto check = [&](int x, int y) -> bool {\n            if (x < 0 || y >= n) return false;\n            if (y - x <= 1) return false;\n            if (suf[y] != pre[x]) return false;\n            if (pre[x] != R.query(x+1, y-1)) return false;\n            return true;\n        };\n        bool ok = false;\n        pi res;\n        f1r(i, 2, n) {\n            int val = suf[i];\n            int lo = 0;\n            int hi = i-1;\n            while (hi - lo > 1) {\n                int mid = (lo + hi) / 2;\n                if (pre[mid] <= val) lo = mid;\n                else hi = mid - 1;\n            }\n            {\n                if (!ok && check(lo, i)) {\n                    ok = true;\n                    res = {lo, i};\n                } \n                if (!ok && check(lo - 1, i)) {\n                    ok = true;\n                    res = {lo - 1, i};\n                }\n                if (!ok && check(hi, i)) {\n                    ok = true;\n                    res = {hi, i};\n                }\n                if (!ok && check(hi - 1, i)) {\n                    ok = true;\n                    res = {hi - 1, i};\n                }\n            }\n            if (ok) break;\n        }\n        if (ok) {\n            ps(\"YES\");\n            int x = res.f + 1;\n            int y = res.s - res.f - 1;\n            int z = n - x - y;\n            ps(x, y, z);\n        } else {\n            ps(\"NO\");\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Array Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/84984",
    "editorial": "Let\u00e2\u0080\u0099s fix the length of the first block (iterate through from to ).\r\nLet\u00e2\u0080\u0099s also try to maximize the length of the third block using the\r\nsecond pointer. So, initially the length of the first block is and the\r\nmaximum in the block is (after that, its length will be and the maximum\r\nwill be , and so on). Let\u00e2\u0080\u0099s move the left border of the third block\r\nwhile and the second block have at least one element.After we expanded\r\nthe third block, consider some cases: if its maximum is less than , then\r\nwe don\u00e2\u0080\u0099t need to consider this partition (we expanded the third block as\r\nmuch as we can but didn\u00e2\u0080\u0099t find the required maximum). Otherwise, its\r\nmaximum fits our conditions. Then let\u00e2\u0080\u0099s find the minimum in the second\r\nblock. Let it be . If , this partition is also bad. If , this partition\r\nis good, and we can just print it. Otherwise, , and we need to fix the\r\nsecond block somehow. I claim that we only need to expand it by at most\r\none element. Let\u00e2\u0080\u0099s see why is it true. Consider we want to expand it to\r\nthe right (the other case just uses the same logic). If we expanded our\r\nblock by one element to the right and the new value in it is less than ,\r\nthen this partition is bad, and we can not use it (this is also the\r\nreason why we are trying to maximize the length of the third block).\r\nOtherwise, this value is always , because the first and the third blocks\r\ndidn\u00e2\u0080\u0099t have values greater than .There are some cases in the\r\nimplementation we need to consider carefully: first, we need to find the\r\nminimum in the second block fast enough. This can be done if we store it\r\nas a multiset (set with repetitions). Second, we can remove the only\r\nmaximum in the third (or the first) block by expanding the second one.\r\nThis can be handled easily if we just store all three blocks (not only\r\nthe second one) as multisets. And the last case is that we sometimes\r\nneed to move the left border of the third block to the right. This\r\nhappens when we expand the first block and the second block becomes\r\nempty. So, this happens only times in total.Total time complexity of\r\nthis solution is .There is also another solution from Gassa:Let us start\r\nsolving by asking the following question: in which segments will the\r\nmaximal values end up?Consider the maximum value in the whole array. If\r\nthere are at least three of them, a valid answer is to pick any maximum\r\nexcept the first and the last as the middle segment. For example, \"\" ()\r\ncan be partitioned as \"\" or as \"\", where the middle segment is marked\r\nwith square brackets. Otherwise, all should end up in the middle\r\nsegment, so that maximums to the left and to the right are less. For\r\nexample, in \"\", we have to put both threes into the middle segment.Let\r\nus now calculate the minimum value on the middle segment, considering\r\nthe numbers between those equal to . For example, in \"\" the value . All\r\nnumbers greater than should also go into the middle segment, and\r\neverything between them, which can result in decreasing even more. We\r\nhave to expand the borders of the middle segment until the minimum value\r\nis such that there are only values not greater than left outside.\r\nContinuing with the example, we see that in \"\", the middle segment\r\nshould be expanded to \"\". Conversely, if the maximum was unique, then ,\r\nand we didn\u00e2\u0080\u0099t have to expand the middle segment at this stage. For\r\nexample, in \"\", the current state is \"\".If the maximums to the left and\r\nto the right are exactly , we found an answer. Otherwise, any possible\r\nmiddle segment contains the middle segment that we now got. So we have\r\nto expand the middle segment, either to the left or to the right. As a\r\nresult, the value may become smaller, which can cause another\r\nexpansion.What\u00e2\u0080\u0099s left is to decide where to expand when we have a\r\nchoice. We would like to do it greedily. Indeed, consider three values:\r\nthe minimum on middle segment , the maximum on left segment and the\r\nmaximum on right segment . When we expand the middle segment, each of\r\nthem can only decrease. And if we find an answer, the equation will be\r\nsatisfied. So, as we make the minimum of these three values smaller, we\r\nhave less and less opportunities to make them equal. Thus we can pick\r\nthe side of expansion after which the value is larger, and if these are\r\nequal, pick any.For example, in the state \"\", we have , , and . If we\r\nexpand to the left, we get \"\" where , , and . If we expand to the right,\r\nwe get \"\" where , , and . Our algorithm will pick expanding to the\r\nright, however, there is no valid answer in this example\r\nanyway.Implementation: let us precalculate the maximums on all prefixes\r\nand all suffixes of the array. Then we can expand the middle segment by\r\none element in , and the total running time is linear.\r\n"
}