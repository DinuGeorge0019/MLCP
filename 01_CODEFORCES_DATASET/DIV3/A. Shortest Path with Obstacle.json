{
    "link": "https://codeforces.com//contest/1547/problem/A",
    "problemId": "1041925",
    "problem_idx": "A",
    "shortId": "1547A",
    "contest_number": "1547",
    "problem_submissions": {
        "G": [
            121944344,
            121945250,
            121969047,
            121966817,
            121967594,
            121972943,
            121975745,
            121977858,
            122032964,
            121981350,
            122056223,
            121979237,
            121981913,
            121981376,
            121980625,
            122155991,
            121975434,
            121991454,
            121995068,
            121976725,
            121981904,
            121989177
        ],
        "F": [
            121935413,
            121935594,
            121941387,
            121951169,
            121954987,
            121958658,
            121946378,
            121960440,
            121957223,
            121947189,
            121953926,
            121961168,
            121956579,
            122155975,
            121957484,
            121963743,
            121963233,
            121983907,
            130067043,
            121967696,
            121964782
        ],
        "E": [
            121927323,
            121930033,
            121934266,
            121934350,
            121934750,
            121950868,
            121938700,
            121947044,
            121939016,
            121918151,
            121943738,
            121951247,
            121943401,
            122155944,
            121929091,
            121938064,
            121948603,
            121929249,
            121954857,
            121951226
        ],
        "D": [
            121920905,
            121925537,
            121926615,
            121928957,
            121929027,
            121935132,
            121933601,
            121938327,
            121930818,
            121951066,
            121937525,
            121939215,
            121938926,
            122155930,
            121923421,
            121931871,
            121939814,
            121923678,
            121938027,
            121939755
        ],
        "C": [
            121917301,
            121919644,
            121922161,
            121925361,
            121925131,
            121930197,
            121927618,
            121931352,
            121926041,
            121941579,
            121930327,
            121931481,
            121932549,
            122155920,
            121946724,
            121926871,
            121930207,
            121920117,
            121930152,
            121928271
        ],
        "B": [
            121913269,
            121913944,
            121915637,
            121917152,
            121916079,
            121921759,
            121916250,
            121921748,
            121918400,
            121932403,
            121917513,
            121922124,
            121917559,
            122155902,
            121918020,
            121915357,
            121920773,
            121914177,
            121922706,
            121919941
        ],
        "A": [
            121912871,
            121922538,
            121912963,
            121913157,
            121913099,
            121914913,
            121913485,
            121917366,
            121913258,
            121918822,
            121913536,
            121914396,
            121913813,
            122155895,
            121942243,
            121912931,
            121913822,
            121912948,
            121914731,
            121913859
        ]
    },
    "name": "A. Shortest Path with Obstacle",
    "statement": "There are three cells on an infinite 2-dimensional grid, labeled A, B,\r\nand F. Find the length of the shortest path from A to B if: in one move\r\nyou can go to any of the four adjacent cells sharing a side; visiting\r\nthe cell F is forbidden (it is an obstacle).\r\n",
    "solutions": [
        "#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        int ans = abs(x1 - x2) + abs(y1 - y2);\n        if (x1 == x2 && x1 == x3 && min(y1, y2) <= y3 && max(y1, y2) >= y3) {\n            ans += 2;\n        }\n        if (y1 == y2 && y1 == y3 && min(x1, x2) <= x3 && max(x1, x2) >= x3) {\n            ans += 2;\n        }\n        cout << ans << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Shortest Path with Obstacle.json",
    "editorial_link": "https://codeforces.com//blog/entry/92715",
    "editorial": "Let\u00e2\u0080\u0099s suppose that the forbidden cell does not affect the shortest path.\r\nIn that case, the answer would be .The forbidden cell blocks the\r\nshortest path if and only if it belongs to every shortest path. In other\r\nwords, if there is only one shortest path and the forbidden cell belongs\r\nto it. So, the answer differs from if and only if and are in one row or\r\ncolumn and is between them. In that case, the answer is (i.e. greater by\r\n).In order to check that point lays between and on a straight line, just\r\ncheck .So, the correct solution looks like this:\r\n"
}