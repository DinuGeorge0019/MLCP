{
    "link": "https://codeforces.com//contest/1374/problem/D",
    "problemId": "659587",
    "problem_idx": "D",
    "shortId": "1374D",
    "contest_number": "1374",
    "problem_submissions": {
        "E2": [
            85382072,
            85375189,
            85438625
        ],
        "F": [
            85353642,
            85415306,
            85383843,
            85383492,
            85387797
        ],
        "E1": [
            85326034,
            85415299,
            85334989,
            85321477,
            85339121,
            85319474,
            85320204,
            85328246,
            85336700,
            85339703,
            85337792,
            85338081,
            85335206,
            85337433,
            85338605,
            85342001,
            85329936,
            85333348,
            85346311
        ],
        "D": [
            85316338,
            85415714,
            85415293,
            85323106,
            85325598,
            85328229,
            85311173,
            85312812,
            85313089,
            85319125,
            85325499,
            85321861,
            85326849,
            85319951,
            85325883,
            85322528,
            85325568,
            85334734,
            85327646,
            85314511
        ],
        "C": [
            85307188,
            85415289,
            85310607,
            85296173,
            85316864,
            85302975,
            85301461,
            85301463,
            85305237,
            85304971,
            85309343,
            85306153,
            85311376,
            85308864,
            85309628,
            85308295,
            85307625,
            85311312,
            85303960
        ],
        "B": [
            85299874,
            85415460,
            85415277,
            85305586,
            85300354,
            85311254,
            85298580,
            85298918,
            85297647,
            85301049,
            85300227,
            85301912,
            85300264,
            85307719,
            85302644,
            85305750,
            85299884,
            85297473,
            85305618,
            85299402
        ],
        "A": [
            85296254,
            85418749,
            85415919,
            85415268,
            85300037,
            85296089,
            85298024,
            85296518,
            245635316,
            85296385,
            85295981,
            85296977,
            85296136,
            85296861,
            85296508,
            85298422,
            85298833,
            85299917,
            85296648,
            85305648,
            85300594,
            85296295
        ]
    },
    "name": "D. Zero Remainder Array",
    "statement": "You are given an array a consisting of n positive integers.Initially,\r\nyou have an integer x = 0. During one move, you can do one of the\r\nfollowing two operations: Choose i from 1 to n and increase a_i by x\r\n(a_i := a_i + x), then increase x by 1 (x := x + 1). Just increase x by\r\n1 (x := x + 1). The first operation can be applied to each i from 1 to\r\nn.Your task is to find the minimum number of moves required to obtain\r\nsuch an array that each its element is k (the value k is given).You have\r\nto answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << \" is \" << x << endl\n#define int ll\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7;\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tmap<int, int> cnt;\n\t\tint mx = -1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint tt;\n\t\t\tcin >> tt;\n\t\t\tif(tt % k == 0) continue;\n\t\t\ttt %= k;\n\t\t\tcnt[tt]++;\n\t\t\tmx = max(mx, cnt[tt] * k - tt);\n\t\t}\n\t\tcout << mx + 1 << endl;\n\t}\n\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Zero Remainder Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/79517",
    "editorial": "Firstly, we can understand that during each full cycle of from to we can\r\nfix each remainder only once. Notice that when we add some then we fix\r\nthe remainder (and we don\u00e2\u0080\u0099t need to fix elements which are already\r\ndivisible by ). So, let be the number of such elements for which the\r\ncondition holds (i.e. the number of such elements that we can fix if we\r\nadd the value to them). We can count this using some logarithmic data\r\nstructure (like in C++).So, what\u00e2\u0080\u0099s the number of full cycles? It equals\r\nto the amount of most frequent element in minus one. So, the answer is\r\nat least . And there can be one last cycle which will be incomplete. So\r\nwhat is the remanining number of moves? It equals to the maximum\r\npossible among all . So if is the maximum such that then the answer is\r\n.Time complexity: .\r\n"
}