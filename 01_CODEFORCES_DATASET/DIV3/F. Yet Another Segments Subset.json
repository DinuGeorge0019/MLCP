{
    "link": "https://codeforces.com//contest/1399/problem/F",
    "problemId": "691722",
    "problem_idx": "F",
    "shortId": "1399F",
    "contest_number": "1399",
    "problem_submissions": {
        "F": [
            89035173,
            89029933
        ],
        "E2": [
            89011999,
            89030510,
            89080621,
            89039473,
            89040534,
            89201926,
            89050383,
            89034156,
            89084070,
            89049259,
            89035111,
            89052507,
            89050541,
            89057093,
            89080141
        ],
        "E1": [
            88996046,
            89009546,
            89080613,
            89010335,
            89023941,
            89019900,
            89014538,
            89084044,
            89031455,
            89027397,
            89021735,
            89030142,
            89008436,
            89007483,
            89015010,
            89097316,
            89017545,
            89018333,
            89016025,
            89019887,
            89020808
        ],
        "D": [
            88983986,
            88986050,
            89080684,
            89080600,
            88990615,
            88995867,
            88990140,
            88981358,
            89083571,
            89083120,
            88982379,
            89003434,
            89001587,
            89002958,
            88987435,
            88992856,
            88978240,
            88981220,
            89097279,
            88987544,
            88985548,
            88986877,
            88997105
        ],
        "C": [
            88974580,
            88974518,
            89080589,
            88982402,
            88985705,
            88979354,
            88966362,
            89082893,
            88973387,
            88994104,
            88993313,
            88993807,
            88971087,
            88979014,
            88975937,
            88963847,
            89097258,
            88972661,
            88974247,
            88977241,
            88976735,
            88981249
        ],
        "B": [
            88964383,
            88965521,
            89080579,
            88970001,
            88977862,
            88967937,
            88959373,
            89082724,
            88963456,
            88986912,
            88979078,
            88973586,
            88969906,
            88966168,
            88957629,
            88964497,
            89097240,
            88962105,
            88966474,
            88966506,
            88969861
        ],
        "A": [
            88956237,
            88956430,
            89080574,
            88960295,
            88969663,
            88957655,
            88955164,
            89082748,
            88955338,
            88967328,
            88967166,
            88962494,
            88973926,
            88959306,
            88955102,
            88955579,
            89097191,
            88955839,
            88955943,
            88956625,
            88962720
        ]
    },
    "name": "F. Yet Another Segments Subset",
    "statement": "You are given n segments on a coordinate axis OX. The i-th segment has\r\nborders [l_i; r_i]. All points x, for which l_i\r\nle x\r\nle r_i holds, belong to the i-th segment.Your task is to choose the by\r\nsize (the number of segments) subset of the given set of segments such\r\nthat each pair of segments in this subset either non-intersecting or one\r\nof them lies inside the other one.Two segments [l_i; r_i] and [l_j; r_j]\r\nare non-intersecting if they have . For example, segments [1; 2] and [3;\r\n4], [1; 3] and [5; 5] are non-intersecting, while segments [1; 2] and\r\n[2; 3], [1; 2] and [2; 2] are intersecting.The segment [l_i; r_i] lies\r\ninside the segment [l_j; r_j] if l_j\r\nle l_i and r_i\r\nle r_j. For example, segments [2; 2], [2, 3], [3; 4] and [2; 4] lie\r\ninside the segment [2; 4], while [2; 5] and [1; 4] are not.You have to\r\nanswer t independent test cases.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 3000+5;\n\nint l[MAXN],r[MAXN];\nint n;\nstd::vector<int> S;\nint f[MAXN*2][MAXN*2];\nbool vis[MAXN*2][MAXN*2];\nstd::vector<int> a[MAXN*2];\n\ninline int dp(int l,int r){\n    if(l > r) return f[l][r] = 0;\n    if(f[l][r] != -1) return f[l][r];\n    int &res = f[l][r];\n    res = dp(l+1,r);\n    for(auto x:a[l]){\n        if(x > r) continue;\n        res = std::max(res,dp(l,x)+dp(x+1,r));\n    }\n    res += vis[l][r];\n    return res;\n}\n\ninline void Solve(){\n    scanf(\"%d\",&n);S.clear();\n    FOR(i,1,n) scanf(\"%d%d\",l+i,r+i),S.pb(l[i]),S.pb(r[i]);\n    std::sort(all(S));S.erase(std::unique(all(S)),S.end());\n    FOR(i,1,n) l[i] = std::lower_bound(all(S),l[i])-S.begin()+1,r[i] = std::lower_bound(all(S),r[i])-S.begin()+1;\n    FOR(i,1,n) a[l[i]].pb(r[i]),vis[l[i]][r[i]] = 1;\n    int M = S.size();\n    FOR(i,0,M+1) FOR(j,0,M+1) f[i][j] = -1;\n    printf(\"%d\\n\",dp(1,M));\n    FOR(i,1,n) vis[l[i]][r[i]] = 0;\n    FOR(i,0,(int)S.size()) a[i].clear();\n}\n\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--) Solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "graphs",
        "sortings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Yet Another Segments Subset.json",
    "editorial_link": "https://codeforces.com//blog/entry/81082",
    "editorial": "Firstly, letâs compress the given borders of segments (just renumerate\r\nthem in such a way that the maximum value is the minimum possible and\r\nthe relative order of integers doesnât change). Pretty standard\r\napproach.Now letâs do recursive dynamic programming . This state stores\r\nthe answer for the segment (not necessarily input segment!). How about\r\ntransitions? Firstly, if there is a segment covering the whole segment ,\r\nwhy donât just take it? It doesnât change anything for us. The first\r\ntransition is just skip the current left border and try to take the\r\nadditional answer from the state . The second transition is the\r\nfollowing: letâs iterate over all possible segments starting at (we can\r\nstore all right borders of such segments in some array ). Let the\r\ncurrent segment be . If , just skip it (if then we canât take this\r\nsegment into the answer because itâs out of , and if then we canât take\r\nit because we considered it already). Then we can take two additional\r\nanswers: from and from . Donât forger about some corner cases, like when\r\nor and something like that.You can get the answer if you run the\r\ncalculation from the whole segment.What is the time complexity of this\r\nsolution? We obviously have states. And the number of transitions is\r\nalso pretty easy to calculate. Letâs fix some right border . For this\r\nright border, we consider segments in total. Summing up, we get\r\ntransitions. So the time complexity is .P.S. I am sorry about pretty\r\ntight ML (yeah, I saw Geothermal got some memory issues because of using\r\nmap). I really wanted to make it 512MB but just forgot to do that.\r\n",
    "hint": []
}