{"link": "https://codeforces.com//contest/1611/problem/F", "problemId": "1202190", "problem_idx": "F", "shortId": "1611F", "contest_number": "1611", "problem_submissions": {"G": [136919698, 136924345, 136928058, 137125236], "D": [136909432, 136888068, 136869096, 136875871, 136873458, 136872703, 136892897, 136874114, 136878310, 136876576, 136982847, 136873530, 136877831, 136975464, 136882777, 136872332, 136878705, 136879548, 136882637, 136884556, 136875995, 136885445], "C": [136904645, 136879235, 136858847, 136855243, 136861532, 136858913, 136876501, 136863657, 136864973, 136856130, 136982821, 136863847, 136868283, 136968820, 136869195, 136914947, 136862897, 136869863, 136862192, 136866525, 136860324, 136867113], "F": [136894434, 136926092, 136925788, 136894423, 136887654, 136898905, 136890793, 136892527, 136897622, 136914432, 136920232, 136982943, 136925360, 136906595, 136919174, 136903703, 136921493, 136918298, 136922728, 136905212, 136914690, 136921349], "E2": [136882323, 136916663, 136883396, 136897153, 136890210, 136911911, 136900593, 136909227, 136895787, 136903952, 136982885, 136896820, 136917983, 136900669, 136888044, 136899257, 136899662, 136904447, 136915639, 136920739, 136912069], "E1": [136879967, 136917077, 136876615, 136879938, 136883345, 136903050, 136866650, 136906813, 136891861, 136885925, 136982868, 136892962, 136889119, 136896344, 136885342, 136893182, 136895321, 136895279, 136895954, 136895593, 136897796], "B": [136853549, 136850019, 136845917, 136846742, 136848311, 136849660, 136855952, 136851245, 136847523, 136844081, 136855128, 136851469, 136843577, 136850258, 136848183, 136852060, 136853372, 136855929, 136847562, 136850988], "A": [136844450, 136846022, 136842097, 136842084, 136843783, 136847130, 136842440, 136842943, 136843633, 136841984, 136846854, 136846415, 136848083, 136843263, 136843590, 136843624, 136845033, 136842923, 136842870, 136846917]}, "name": "F. ATM and Students", "statement": "Polycarp started working at a bank. He was assigned to monitor the ATM.\r\nThe ATM initially contains s rubles.A queue of n students lined up to\r\nhim. Each student wants to either withdraw a certain amount of money or\r\ndeposit it into an account. If a_i is positive, then the student credits\r\nthat amount of money via ATM. Otherwise, the student withdraws |a_i|\r\nrubles.In the beginning, the ATM is turned off and an arbitrary number\r\nof students are not served. At some point, Polycarp turns on the ATM,\r\nwhich has an initial amount of s rubles. Then, the remaining students\r\nstart queueing at the ATM. If at some point in time there is less money\r\nin the ATM than the student wants to withdraw, then the student is not\r\nserved and Polycarp turns off the ATM and does not turn it on\r\nanymore.More formally, the students that are served are forming a\r\n.Polycarp wants the ATM to serve the number of students. Help him in\r\nthis matter. Print the numbers of the first and last student, or\r\ndetermine that he will not be able to serve anyone.In other words, find\r\nsuch a longest continuous segment of students that, starting with the\r\nsum of s at the ATM, all these students will be served. ATM serves\r\nstudents consistently (i.e. one after another in the order of the\r\nqueue).\r\n", "solutions": ["#include <bits/stdc++.h>\n#define MAX 205000\nint N;\nlong long array[MAX];\nlong long tab[MAX*4];\nlong long query(int l,int r,int la=0,int ra=N-1,int pos=1){\n    if(la>r||ra<l){\n        return (1LL<<50LL);\n    }\n    if(la>=l&&ra<=r){\n        return tab[pos];\n    }\n    int m=(la+ra)/2;\n    return std::min(query(l,r,la,m,pos*2),query(l,r,m+1,ra,(pos*2)+1));\n}\nvoid update(int t,long long k,int la=0,int ra=N-1,int pos=1){\n    if(la>t||ra<t){\n        return;\n    }\n    if(la==ra){\n        tab[pos]=k;\n        return;\n    }\n    int m=(la+ra)/2;\n    update(t,k,la,m,pos*2);\n    update(t,k,m+1,ra,(pos*2)+1);\n    tab[pos]=std::min(tab[pos*2],tab[(pos*2)+1]);\n}\nint pode(int sz,long long s){\n    long long som = 0;\n    long long pref[N]={};\n    pref[0]=0;\n    for(int i=0;i!=N;++i){\n        som+=array[i];\n        if(i!=N-1)\n        pref[i+1]=som;\n        update(i,som);\n    }\n    for(int i=0;i!=N;++i){\n        int lim=i+sz-1;\n        if(lim<=N-1){\n            long long menor = query(i,lim);\n            if(menor+s-pref[i]>=0){\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        long long s;\n        std::cin>>N>>s;\n        for(int i=0;i!=N;++i)std::cin>>array[i];\n        int l=1,r=N;\n        while(l<r){\n            int m = (l+r)/2+((l+r)&1);\n            if(pode(m,s)!=-1){\n                l=m;\n            }else r=m-1;\n        }\n        long long b = pode(l,s);\n        if(b==-1){\n            std::cout<<\"-1\\n\";\n        }else {\n            std::cout<<(b+1)<<\" \"<<(b+l)<<\"\\n\";\n        }\n    }\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "two pointers"], "dificulty": "1800", "interactive": false}