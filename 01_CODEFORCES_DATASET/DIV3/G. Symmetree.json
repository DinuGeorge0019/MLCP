{
    "link": "https://codeforces.com//contest/1800/problem/G",
    "problemId": "1805850",
    "problem_idx": "G",
    "shortId": "1800G",
    "contest_number": "1800",
    "problem_submissions": {
        "G": [
            195662820,
            195690940,
            195777313,
            195690603,
            196524855,
            196524658,
            196522076,
            195943836
        ],
        "F": [
            195638235,
            195668644,
            195626028,
            195643554,
            195664067,
            195653332,
            195675061,
            195673007,
            195816880,
            195814809,
            195671424,
            195665257,
            195659551,
            195670175,
            195698092,
            195680883,
            195680676,
            195689427,
            195669351,
            195693466
        ],
        "E2": [
            195612538,
            195639973,
            195612785,
            195633454,
            195608323,
            195629403,
            195623425,
            195629463,
            195626230,
            195629563,
            195651082,
            195630357,
            195636943,
            195619592,
            195639486,
            195641374,
            195638209,
            195651098,
            195639224
        ],
        "E1": [
            195609573,
            195639721,
            195612247,
            195613343,
            195609699,
            195630410,
            195623568,
            195625383,
            195625931,
            195618740,
            195651326,
            195630926,
            195636711,
            195618856,
            195639041,
            195641167,
            195628893,
            195650180,
            195639842
        ],
        "D": [
            195596585,
            195625770,
            195604693,
            195600193,
            195602000,
            195612110,
            195610320,
            195609709,
            195602062,
            195607762,
            195620848,
            195616904,
            195612803,
            195606522,
            195616372,
            195614847,
            195609456,
            195614238,
            195614684
        ],
        "C1": [
            195590954,
            195626345,
            195594910,
            195589947,
            195592829,
            195604029,
            195596848,
            195599696,
            195593933,
            195600094,
            195594609,
            195604030,
            195599932,
            195600191,
            195602733,
            195597615,
            195601757,
            195596127,
            195599897
        ],
        "C2": [
            195590683,
            195596363,
            195594725,
            195589578,
            195592485,
            195603666,
            195596587,
            195600171,
            195594252,
            195601050,
            195594186,
            195603461,
            195599812,
            195600859,
            195603073,
            195597061,
            195601904,
            195595910,
            195599331
        ],
        "A": [
            195587296,
            195585153,
            195582408,
            195584101,
            195582608,
            195583278,
            195583402,
            195582928,
            195582330,
            195583356,
            195582358,
            195587162,
            195585218,
            195584435,
            195584152,
            195585315,
            195585448,
            195583944,
            195583542
        ],
        "B": [
            195584191,
            195590087,
            195587727,
            195584989,
            195586915,
            195590416,
            195592972,
            195589242,
            195592390,
            195586361,
            195594730,
            195594317,
            195594021,
            195589463,
            195590127,
            195591494,
            195591394,
            195590938
        ]
    },
    "name": "G. Symmetree",
    "statement": "Kid was gifted a tree of n vertices with the root in the vertex 1. Since\r\nhe really like objects, Kid wants to find out if this tree is .\r\nFormally, a tree is if there exists an order of children such that: The\r\nsubtree of the leftmost child of the root is a mirror image of the\r\nsubtree of the rightmost child; the subtree of the second-left child of\r\nthe root is a mirror image of the subtree of the second-right child of\r\nthe root; ... if the number of children of the root is odd, then the\r\nsubtree of the middle child should be .\r\n",
    "solutions": [
        "// I am teacher of MakaPakka\n// LOUGI_ID:643723\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define rep(x,y) for(int x=0;x<(y);x++)\ninline int in(){\n  int x;\n  cin >> x;\n  return x;\n}\nconst int N=2e5;\nint n,dt[N+5],h_val[N+5];\nvector<int> g[N+5];\nvoid get_depth(int v,int p=-1){\n  for(int u:g[v])if(u!=p){\n    dt[u]=dt[v]+1;\n    get_depth(u,v);\n  }\n}\nint timer=0;\nmap<vector<int>,int> hsh;\nvoid get_hash(int v,int p=-1){\n  vector<int> c={dt[v]};\n  for(int u:g[v])if(u!=p){\n    get_hash(u,v);\n    c.push_back(h_val[u]);\n  }\n  if(int(c.size())>1)sort(c.begin()+1,c.end());\n  if(hsh.count(c))h_val[v]=hsh[c];\n  else{\n    hsh[c]=timer,h_val[v]=timer;\n    timer++;\n  }\n}\nbool test(int v,int p=-1){\n  vector<array<int,2>> c;\n  for(int u:g[v])if(u!=p){\n    c.pb({h_val[u],u});\n  }\n  sort(c.begin(), c.end());\n  for(int i=0;i+1<int(c.size());i++){\n    if(c[i][0]==c[i+1][0]){\n      c[i]=c[i+1]={-1,-1};\n      i++;continue;\n    }\n  }\n  int badcnt=0,bad=-1;\n  for(int i=0;i<int(c.size());i++){\n    if(c[i]!=array<int,2>({-1,-1}))badcnt++,bad=c[i][1];\n  }\n  if(badcnt>1)return false;\n  else if(badcnt==0)return true;\n  else return test(bad,v);\n  return true;\n}\nvoid solve(){\n  n=in();\n  timer=0,hsh.clear();\n  rep(i,n+5)g[i].clear(),h_val[i]=dt[i]=0;\n  rep(i,n-1){\n    int x=in()-1,y=in()-1;\n    g[x].pb(y),g[y].pb(x);\n  }\n  get_depth(0);\n  get_hash(0);\n  cout<<(test(0)?\"YES\\n\":\"NO\\n\");\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int T = 1;\n  cin >> T;\n  while(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "hashing",
        "implementation",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Symmetree.json",
    "editorial_link": "https://codeforces.com//blog/entry/113477",
    "editorial": "Note that if one subtree is a mirror image of another, then they are\r\nisomorphic (that is, equal without taking into account the vertex\r\nnumbers). To check the subtrees for isomorphism, we use .Now we just\r\nhave to learn how to check trees for symmetry. To do this, let\u00e2\u0080\u0099s\r\ncalculate how many children of each type our vertex has (let\u00e2\u0080\u0099s denote\r\nthe hash of its subtree by the vertex type). In order for the vertex\r\nsubtree to be symmetric, each child must have a pair of the same type,\r\nexcept perhaps one, which must also be symmetric. We can calculate the\r\nsymmetry of the subtrees while counting their hash to simplify this\r\ntask.\r\n"
}