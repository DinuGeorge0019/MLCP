{
    "link": "https://codeforces.com//contest/1881/problem/D",
    "problemId": "2259905",
    "problem_idx": "D",
    "shortId": "1881D",
    "contest_number": "1881",
    "problem_submissions": {
        "G": [
            227881682,
            227890897,
            227853197,
            227853881,
            227975243,
            227899786,
            227901394,
            227911349,
            227907618,
            227893303,
            227897169,
            227918994,
            227917936,
            227914137,
            227899980,
            227912585,
            227907908,
            227897166,
            227915427,
            230763040,
            227916848,
            227913341,
            227920356,
            227867452,
            228095818,
            227915038
        ],
        "F": [
            227862562,
            227861356,
            227870757,
            227856965,
            227974789,
            227875295,
            227869909,
            227878015,
            227879864,
            227885516,
            227883744,
            227872766,
            227871133,
            227860506,
            227889327,
            230763024,
            227881722,
            227900442,
            227886326,
            227835034,
            228095806,
            227892673
        ],
        "E": [
            227850824,
            227843540,
            227942027,
            227858077,
            227874342,
            227854004,
            227852561,
            227851500,
            227864039,
            227865490,
            227859415,
            227863643,
            227846602,
            227918283,
            227845118,
            227881868,
            230762984,
            227865398,
            227875008,
            227858082,
            227872189,
            228095799,
            227883249
        ],
        "D": [
            227844854,
            227839094,
            227848716,
            227843412,
            227838899,
            227847809,
            227840878,
            227858992,
            227854380,
            227853013,
            227858090,
            227884786,
            227839966,
            227871576,
            230762965,
            227859752,
            227867911,
            227861846,
            227874828,
            228095791,
            227866894
        ],
        "C": [
            227838508,
            227835537,
            227842531,
            227866399,
            228637953,
            227849689,
            227840361,
            227848329,
            227855215,
            227848107,
            227840529,
            227850980,
            227881582,
            227837426,
            227868576,
            230762944,
            227849495,
            227862177,
            227853530,
            227898622,
            228095784,
            227862705
        ],
        "B": [
            227831568,
            227831942,
            227835393,
            227838918,
            227835692,
            227835105,
            227836643,
            227839535,
            227838170,
            227834145,
            227842440,
            227842178,
            227832528,
            227844145,
            230762918,
            227842892,
            227850062,
            227840218,
            227885672,
            228095774,
            227845241
        ],
        "A": [
            227829772,
            227829881,
            227830670,
            227836999,
            227830954,
            227830777,
            227830578,
            227833236,
            227838249,
            227829831,
            227837181,
            227833271,
            227908499,
            227830499,
            230762881,
            227836954,
            227841775,
            227831030,
            227889886,
            228095766,
            227839571
        ]
    },
    "name": "D. Divide and Equalize",
    "statement": "You are given an array a consisting of n positive integers. You can\r\nperform the following operation on it: Choose a pair of elements a_i and\r\na_j (1\r\nle i, j\r\nle n and i\r\nneq j); Choose one of the divisors of the integer a_i, i.e., an integer\r\nx such that a_i\r\nbmod x = 0; Replace a_i with\r\nfrac{a_i}{x} and a_j with a_j\r\ncdot x. Determine whether it is possible to make all elements in the\r\narray the same by applying the operation a certain number of times\r\n(possibly zero).For example, let\u2019s consider the array a = [100, 2, 50,\r\n10, 1] with 5 elements. Perform two operations on it: Choose a_3 = 50\r\nand a_2 = 2, x = 5. Replace a_3 with\r\nfrac{a_3}{x} =\r\nfrac{50}{5} = 10, and a_2 with a_2\r\ncdot x = 2\r\ncdot 5 = 10. The resulting array is a = [100, 10, 10, 10, 1]; Choose a_1\r\n= 100 and a_5 = 1, x = 10. Replace a_1 with\r\nfrac{a_1}{x} =\r\nfrac{100}{10} = 10, and a_5 with a_5\r\ncdot x = 1\r\ncdot 10 = 10. The resulting array is a = [10, 10, 10, 10, 10]. After\r\nperforming these operations, all elements in the array a become equal to\r\n10.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,a[N];\nll d[N];\nll cnt;\nvoid sep(ll x){\n    rep(i,2,sqrt(x)) if (x%i==0){\n        while (x%i==0){\n            if (d[i]==0) cnt++;\n            d[i]++;\n            x/=i;\n            if (d[i]==n) d[i]=0,cnt--;\n        }\n    }\n    if (x>1){\n        if (d[x]==0) cnt++;\n        d[x]++;\n        if (d[x]==n) d[x]=0,cnt--;\n    }\n}\nvoid rest(ll x){\n    rep(i,2,sqrt(x)) if (x%i==0){\n        d[i]=0;\n        while (x%i==0) x/=i;\n    }\n    if (x>1){\n        d[x]=0;\n    }\n}\nvoid prep(){\n\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) cin>>a[i],sep(a[i]);\n    if (!cnt) cout<<\"YES\";\n    else cout<<\"NO\";\n    cnt=0;\n    rep(i,1,n) rest(a[i]);\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Divide and Equalize.json",
    "editorial_link": "https://codeforces.com//blog/entry/121327",
    "editorial": "To solve the problem, we need to decompose all numbers in the array into\r\nprime divisors. After that, let\u00e2\u0080\u0099s calculate the number of each divisor,\r\nsummarizing the decompositions of all numbers.If each divisor enters\r\ntimes, where is a natural number, then we can equalize all the numbers\r\nin the array: we will sequentially apply the operation so that each\r\nnumber consists of the same set of prime divisors.If some divisor enters\r\na different number of times, then it will not be possible to equalize\r\nthe numbers in the array.\r\n"
}