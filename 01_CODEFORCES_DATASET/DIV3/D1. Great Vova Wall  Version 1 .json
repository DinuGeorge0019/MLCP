{
    "link": "https://codeforces.com//contest/1092/problem/D1",
    "problemId": "271422",
    "problem_idx": "D1",
    "shortId": "1092D1",
    "contest_number": "1092",
    "problem_submissions": {
        "F": [
            47218597,
            47207874,
            47241634,
            47318477,
            47214615,
            47217604,
            47210093,
            47210748,
            47212691,
            47213985,
            47215066,
            47216141
        ],
        "D1": [
            47215980,
            47227965,
            47212365,
            47220485,
            47215001,
            47223458,
            47225913,
            47226094,
            47209533,
            47227527,
            47227478,
            47227395,
            47227268,
            47226719,
            47216461,
            47213724,
            47334192
        ],
        "D2": [
            47212833,
            47212767,
            47218226,
            47218497,
            47219527,
            47223320,
            47217259,
            47271469,
            47223969,
            47236061,
            47213976,
            47212963,
            47333101
        ],
        "C": [
            47208479,
            47202011,
            47208106,
            47207681,
            47211238,
            47213730,
            47205520,
            47206298,
            47207117,
            47206109,
            47208340,
            47227233,
            47226698,
            47207049,
            47207288,
            47209584,
            47210057,
            47206966,
            47207998
        ],
        "B": [
            47202083,
            47196597,
            47203007,
            47199377,
            47202631,
            47197720,
            47198736,
            47196902,
            47198167,
            47197186,
            47198915,
            47226662,
            47196684,
            47197714,
            47198493,
            47198454,
            47201892,
            47199196
        ],
        "A": [
            47200523,
            47196094,
            47201972,
            47196916,
            47200910,
            47196295,
            47196192,
            47197255,
            47196159,
            47196525,
            47196472,
            47196994,
            47226648,
            47196039,
            47196511,
            47196950,
            47196914,
            47198726,
            47197707
        ],
        "E": [
            47266392,
            47319938,
            47234188,
            47277429,
            47369991
        ]
    },
    "name": "D1. Great Vova Wall  Version 1 ",
    "statement": "Vova’s family is building the Great Vova Wall (named by Vova himself).\r\nVova’s parents, grandparents, grand-grandparents contributed to it. Now\r\nit’s totally up to Vova to put the finishing touches.The current state\r\nof the wall can be respresented by a sequence a of n integers, with a_i\r\nbeing the height of the i-th part of the wall.Vova can only use 2\r\ntimes 1 bricks to put in the wall (he has infinite supply of them,\r\nhowever).Vova can put bricks on the neighboring parts of the wall of\r\nequal height. It means that if for some i the current height of part i\r\nis the same as for part i + 1, then Vova can put a brick there and thus\r\nincrease both heights by 1. Obviously, Vova can’t put bricks in such a\r\nway that its parts turn out to be off the borders (to the left of part 1\r\nof the wall or to the right of part n of it).Vova can also put bricks\r\nvertically. That means increasing height of any part of the wall by\r\n2.Vova is a perfectionist, so he considers the wall completed when: all\r\nparts of the wall has the same height; the wall has no empty spaces\r\ninside it. Can Vova complete the wall using any amount of bricks\r\n(possibly zero)?\r\n",
    "solutions": [
        "#include<cstdio>\nint m;\nint a[200000];\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int v1=0,v2=0;\n    for(int i=0;i<n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        if(x&1){\n            if(i&1)v1++;\n            else v1--;\n        }\n        else{\n            if(i&1)v2++;\n            else v2--;\n        }\n    }\n    puts((v1==0||v2==0)?\"YES\":\"NO\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D1. Great Vova Wall  Version 1 .json",
    "editorial_link": "https://codeforces.com//blog/entry/63961",
    "editorial": "Fairly enough, solutions of both versions of the problem are pretty\r\nsimilar. The major difference between them are the vertical bricks. As\r\nyou arenât required to minimize the total height, you can work not with\r\nthe heights themselves but with their parities instead. Vertical brick\r\nnow does nothing and horizontal brick changes the parity of neighbouring\r\nparts of the same parity.Now imagine the following greedy solution.\r\nWhile you have some segment of the same parities of even length, fill it\r\nwith horizontal bricks. This operation merges this segment with one to\r\nthe left and to the right. If there is a single segment left then the\r\nanswer is \"\". Otherwise itâs \"\". The proof is left to the\r\nreaders.Implementing this as it is will be at best. Youâll need to keep\r\nthe whole set of segments and the set with only even length ones.But\r\nthere exists more fun approach.We donât even need the lengths of the\r\nsegments just the parities of the lengths. Then merging the even segment\r\nwith something will just erase that segment and xor the length of the\r\nleft and right ones. Moreover, you donât even need to erase the whole\r\neven segment, you can do it brick by brick, as this operations are now\r\nthe same. Letâs simulate this with a stack. When the new number comes,\r\npush its parity to the stack. If the topmost two elements of the stack\r\nhave the same parity, pop them both. Now the answer is \"\" if at the end\r\nstack has no more than one element.When I heard of this problem, I\r\nactually had not that stack itself in mind but the correct bracket\r\nsequences. Like letâs define parity 0 as â(â and â)â and parity 1 as â[â\r\nand â]â. Now the operations we perform with stack are \"greedily put the\r\nclosing bracket if the last unclosed bracket was of the same type\" and\r\n\"put opening otherwise\". Then the stack will have like all the brackets\r\nwhich are still to be closed and youâll close them as early as you can.\r\nThis idea helped to both prove the correctness of algo and implement\r\nit.Overall complexity: .\r\n",
    "hint": []
}