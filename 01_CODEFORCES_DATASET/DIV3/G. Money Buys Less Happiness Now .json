{
    "link": "https://codeforces.com//contest/1974/problem/G",
    "problemId": "2657209",
    "problem_idx": "G",
    "shortId": "1974G",
    "contest_number": "1974",
    "problem_submissions": {
        "G": [
            261890876,
            261895242,
            261892104,
            261815844,
            261901397,
            261882110,
            261902942,
            261897196,
            261890302,
            261906925,
            261906633,
            261902994,
            261909128,
            262172085,
            261998366,
            261998046,
            261912311
        ],
        "F": [
            261873832,
            261860163,
            261871347,
            261886083,
            261890598,
            261905275,
            261893342,
            261893849,
            261885670,
            261888292,
            261884408,
            261903255,
            261856931,
            261866178,
            261998302,
            261867572,
            261874550,
            261881230,
            261896095,
            261891848
        ],
        "E": [
            261843511,
            261898684,
            261874046,
            261856295,
            261872971,
            261858650,
            261864336,
            261872189,
            261875499,
            261861733,
            261866981,
            261850233,
            261886170,
            261845363,
            261845593,
            261998691,
            261848135,
            261863399,
            261863179,
            261861452,
            261854564
        ],
        "D": [
            261828744,
            261833579,
            261844887,
            261858347,
            261848070,
            261834943,
            261843848,
            261843125,
            261893971,
            261854059,
            261850835,
            261836444,
            261865680,
            261830266,
            261832171,
            261998550,
            261835226,
            261844678,
            261837286,
            261829368,
            261844070
        ],
        "C": [
            261809458,
            261818269,
            261821670,
            261838680,
            261824893,
            261817516,
            261818307,
            261822342,
            261872865,
            261902570,
            261836543,
            261891689,
            261812999,
            261811999,
            261811344,
            261998621,
            261807237,
            261810379,
            261809093,
            261808251,
            261815953
        ],
        "B": [
            261801251,
            261803139,
            261801216,
            261828779,
            261802058,
            261805873,
            261803693,
            261800515,
            261806010,
            261808108,
            261800732,
            261800673,
            261801484,
            261801347,
            261998221,
            261798953,
            261798594,
            261800683,
            261798231,
            261800035
        ],
        "A": [
            261797694,
            261795610,
            261795288,
            261822724,
            261797136,
            261796736,
            262453696,
            261795629,
            261796165,
            261795943,
            261800077,
            261795571,
            261795380,
            261796034,
            261796954,
            261998187,
            261795311,
            261795243,
            261796139,
            261795603,
            261796608
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129686",
    "editorial": "Let us consider the smallest element (and the rightmost if equal).\r\nSuppose we do not take it. Now, we emulate the decisions from the first\r\nmonth up to month . Note that if we chose some element on the left of we\r\ncould have chosen the smallest one instead. Thus, we can go greedy: go\r\nover the costs in the sorted order and check whether we can take it. To\r\ncheck whether there are enough pounds from the previous months we can\r\nuse the segment tree. When we take the happiness during month we need to\r\nreduce the amount of pounds on the left by .This greedy approach can be\r\nimplemented simpler. We just need to go over the costs from the first\r\nmonth and maintain the heap (or set/priority queue) of chosen costs.\r\nWhen we go over a new cost we check whether we can pay for it and, if\r\npositive, we add it to our answer. Otherwise, we remove the largest\r\nchosen cost from the heap, compare it with the current cost, and put\r\nback the smaller one.\r\n",
    "name": "G. Money Buys Less Happiness Now ",
    "statement": "Being a physicist, Charlie likes to plan his life in simple and precise\r\nterms. For the next m months, starting with no money, Charlie will work\r\nhard and earn x pounds per month. For the i-th month (1\r\nle i\r\nle m), there’ll be a single opportunity of paying cost c_i pounds to\r\nobtain one unit of happiness. You cannot buy more than one unit each\r\nmonth.Borrowing is not allowed. Money earned in the i-th month can only\r\nbe spent in a later j-th month (j>i).Since physicists don’t code, help\r\nCharlie find the maximum reachable units of happiness.\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <algorithm>#include <vector>#include <chrono>#include <random>#include <map>#include <set>using namespace std;typedef long long ll;const int N = 2e5 + 10;int tree[4 * N];int lazy[4 * N];pair<int, int> a[N];int m, x, c;bool cmp(pair<int, int> x, pair<int, int> y) {\tif (x.first != y.first) return x.first < y.first;\treturn x.second > y.second;}void pushh(int v, int tl, int tr) {\tif (!lazy[v]) return;\tif (tl != tr) {\t\tlazy[2 * v] += lazy[v];\t\ttree[2 * v] -= lazy[v];\t\tlazy[2 * v + 1] += lazy[v];\t\ttree[2 * v + 1] -= lazy[v];\t}\tlazy[v] = 0;}void build_tree(int v, int tl, int tr) {\tlazy[v] = 0;\tif (tl == tr) {\t\ttree[v] = ((tl - 1) * 1ll * x);\t}\telse {\t\tint tm = (tl + tr) / 2;\t\tbuild_tree(2 * v, tl, tm);\t\tbuild_tree(2 * v + 1, tm + 1, tr);\t\ttree[v] = min(tree[2 * v], tree[2 * v + 1]);\t}}void update(int v, int tl, int tr, int l, int r, int val) {\tif (tl > r || tr < l) return;\tif (tl >= l && tr <= r) {\t\ttree[v] -= val;\t\tlazy[v] += val;\t\treturn;\t}\tpushh(v, tl, tr);\tint tm = (tl + tr) / 2;\tupdate(2 * v, tl, tm, l, r, val);\tupdate(2 * v + 1, tm + 1, tr, l, r, val);\ttree[v] = min(tree[2 * v], tree[2 * v + 1]);}int Min(int v, int tl, int tr, int l, int r) {\tif (tl > r || tr < l) return 1000000000;\tif (tl >= l && tr <= r) {\t\t//cout << tl << \" \" << tr << \" \" << tree[v] << \"\\n\";\t\treturn tree[v];\t}\tpushh(v, tl, tr);\tint tm = (tl + tr) / 2;\treturn min(Min(2 * v, tl, tm, l, r), \t\tMin(2 * v + 1, tm + 1, tr, l, r));}void solve() {\tcin >> m >> x;\tfor (int i = 1; i <= m; i++) {\t\tcin >> a[i].first;\t\ta[i].second = i;\t}\tbuild_tree(1, 1, m);\tsort(a + 1, a + m + 1, cmp);\tint ans = 0;\tfor (int i = 1; i <= m; i++) {\t\tint w = Min(1, 1, m, a[i].second, m);\t\t//cout << \"? \" << w << \"\\n\";\t\tif (a[i].first <= w) {\t\t\tupdate(1, 1, m, a[i].second, m, a[i].first);\t\t\tans++;\t\t}\t} \tcout << ans << \"\\n\";}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Money Buys Less Happiness Now .json",
    "hint": []
}