{
    "link": "https://codeforces.com//contest/1941/problem/G",
    "problemId": "2523373",
    "problem_idx": "G",
    "shortId": "1941G",
    "contest_number": "1941",
    "problem_submissions": {
        "G": [
            250763025,
            250781286,
            250779945,
            250787489,
            250800958,
            250794874,
            250801570,
            250797693,
            250776624,
            250793138,
            250784955,
            250769475,
            250695343,
            250808638,
            250806485,
            250793977,
            250708131
        ],
        "F": [
            250740820,
            250744438,
            250753388,
            250758018,
            250759651,
            250771923,
            250771468,
            250735055,
            250753949,
            250769805,
            250766080,
            250789658,
            250717637,
            250786906,
            250776029,
            250768573,
            250744006
        ],
        "E": [
            250723876,
            250724169,
            250717230,
            250735746,
            250736815,
            250736521,
            250739262,
            250774240,
            250729758,
            250726588,
            250755686,
            250741893,
            250738588,
            250765034,
            250731744,
            250805659,
            250779683
        ],
        "D": [
            250690549,
            250702231,
            250695593,
            250704272,
            250717031,
            250703063,
            250703013,
            250692270,
            250695895,
            250691168,
            250734836,
            250707874,
            250759962,
            250722745,
            250703516,
            250708254,
            250785215
        ],
        "C": [
            250674251,
            250679685,
            250671012,
            250679783,
            250680400,
            250684218,
            250682169,
            250667218,
            250675740,
            250676966,
            250670249,
            250691797,
            250745426,
            250686871,
            250672532,
            250677895,
            250750876
        ],
        "B": [
            250664239,
            250668411,
            250660791,
            250663325,
            250694386,
            250668961,
            250666921,
            250657383,
            250663605,
            250664885,
            250657026,
            250681860,
            250751771,
            250667298,
            250743798,
            250661438,
            250747374
        ],
        "A": [
            250649602,
            250652993,
            250650152,
            250651488,
            250656171,
            250653697,
            250656300,
            250649271,
            250654624,
            250658642,
            250648031,
            250654646,
            250754293,
            250652956,
            250649094,
            250648520,
            250712266
        ]
    },
    "name": "G. Rudolf and Subway",
    "statement": "Building bridges did not help Bernard, and he continued to be late\r\neverywhere. Then Rudolf decided to teach him how to use the\r\nsubway.Rudolf depicted the subway map as an undirected connected graph,\r\nwithout self-loops, where the vertices represent stations. There is at\r\nmost one edge between any pair of vertices.Two vertices are connected by\r\nan edge if it is possible to travel directly between the corresponding\r\nstations, bypassing other stations. The subway in the city where Rudolf\r\nand Bernard live has a color notation. This means that any edge between\r\nstations has a specific color. Edges of a specific color together form a\r\nsubway line. A subway line contain unconnected edges and forms a\r\nconnected subgraph of the given subway graph.An example of the subway\r\nmap is shown in the figure. Rudolf claims that the route will be optimal\r\nif it passes through the minimum number of subway lines.Help Bernard\r\ndetermine this minimum number for the given departure and destination\r\nstations.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<\"YES\\n\"\n#define NO cout << \"NO\\n\"\n#define debug cout << \"Here Fine\" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\nint n , m , been[ N ] , ben[ N ] ;\nvector < pair < int , int > > v[ N ] ;\nvector < int > col[ N ] ; \n\nint bfs( int s , int d ){\n\tif( s == d ) return 0 ;\n\tqueue < int > qu ;\n\tfor( auto x : v[ s ] ){\n\t\tif( been[ x.s ] == 0 ){\n\t\t\tqu.push( x.s ) ;\n\t\t\tbeen[ x.s ] = 1 ; \n\t\t}\n\t} \n\tben[ s ] = 1 ; \n\twhile( true ){\n\t\tif( qu.size() == 0 ) break ;\n\t\tint cur = qu.front() ; qu.pop() ;\n\t\tfor( auto y : col[ cur ] ){\n\t\t\tif( ben[ y ] == 0 ){\n\t\t\t\tben[ y ] = 1 ; \n\t\t\t\tfor( auto x : v[ y ] ){\n\t\t\t\t\tif( been[ x.s ] != 0 ) continue ;\n\t\t\t\t\tbeen[ x.s ] = been[ cur ] + 1 ;\n\t\t\t\t\tqu.push( x.s ) ;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint mn = INT_MAX ; \n\tfor( auto x : v[ d ] ){\n\t\tmn = min( mn , been[ x.s ] ) ; \n\t}\n\treturn mn ; \n}\n\nvoid solve(){\n    cin >> n >> m ;\n    set < int > se ;\n    FOR( i , m ){\n    \tint a , b ,c ;\n    \tcin >> a >> b >> c ;\n    \tse.insert( c ) ;\n    \tv[ a ].pb( { b , c } ) ;\n    \tv[ b ].pb( { a , c } ) ;\n    \tcol[ c ].pb( a ) ;\n    \tcol[ c ].pb( b ) ;\n\t}\n\tint s , d ;\n\tcin >> s >> d ;\n\tint ans = bfs( s , d ) ;\n\tcout << ans << \"\\n\" ;\n\t\n\t//clear\n    FOR( i , n ){\n    \tv[ i + 1 ].clear() ;\n    \tben[ i + 1 ] = 0 ;\n\t}\n\tfor( auto x : se ){\n\t\tbeen[ x ] = 0 ;\n\t\tcol[ x ].clear() ;\n\t}\n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Rudolf and Subway.json",
    "editorial_link": "https://codeforces.com//blog/entry/127018",
    "editorial": "Letâs construct a bipartite graph, where one part is the vertices of the\r\noriginal graph, i.e., subway stations, and the other part is the subway\r\nlines. We add an edge between a station vertex and a line vertex if in\r\nthe original subway graph, the station is incident to an edge of the\r\ncorresponding subway line. In the new graph, we find the shortest path\r\nbetween the vertices corresponding to the departure and destination\r\nstations (for example, using breadth-first search). The answer to the\r\nproblem will be the shortest path, divided in half.\r\n",
    "hint": []
}