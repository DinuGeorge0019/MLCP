{
    "link": "https://codeforces.com//contest/1102/problem/E",
    "problemId": "280231",
    "problem_idx": "E",
    "shortId": "1102E",
    "contest_number": "1102",
    "problem_submissions": {
        "F": [
            48140951,
            48147190,
            48151952,
            48147273,
            48149693,
            48148209,
            48149357,
            48156228,
            48324719,
            48156492,
            48211275,
            48210647,
            48465963
        ],
        "E": [
            48133168,
            48134978,
            48134782,
            48135856,
            48131616,
            48151765,
            48145873,
            48128235,
            48131297,
            48136054,
            48139969,
            48138178,
            48141535,
            48140000,
            50612473,
            49117474,
            48143805,
            48143096,
            48141761,
            48140639,
            48142040,
            48138664
        ],
        "D": [
            48130363,
            48129370,
            48132705,
            48133131,
            48146366,
            48139447,
            48153130,
            48141036,
            48138860,
            48132737,
            48132907,
            48132415,
            48134717,
            48134475,
            48133518,
            48130113,
            48138869,
            48135563,
            48136818,
            48135753
        ],
        "C": [
            48124610,
            48124428,
            48127226,
            48130117,
            48124395,
            48129801,
            48133951,
            48124097,
            48123397,
            48126329,
            48125852,
            48124992,
            48127428,
            48126645,
            48127128,
            48125282,
            48126002,
            48129026,
            48128077,
            48129849
        ],
        "B": [
            48122561,
            48122504,
            48125142,
            48127847,
            48123165,
            48123788,
            48132434,
            48120816,
            48121994,
            48123399,
            48123616,
            48121594,
            48124256,
            48123685,
            48122759,
            48123296,
            48123050,
            48125935,
            48125539,
            48126168
        ],
        "A": [
            48119616,
            48119377,
            48119214,
            48122772,
            48119115,
            48118984,
            48121381,
            48121124,
            48118971,
            48118958,
            48120635,
            48119936,
            48118948,
            48119353,
            48120109,
            48119913,
            48119534,
            48118997,
            48120967,
            48119662,
            48120313
        ]
    },
    "name": "E. Monotonic Renumeration",
    "statement": "You are given an array a consisting of n integers. Let’s denote of array\r\na as an array b consisting of n integers such that all of the following\r\nconditions are met: b_1 = 0; for every pair of indices i and j such that\r\n1\r\nle i, j\r\nle n, if a_i = a_j, then b_i = b_j (note that if a_i\r\nne a_j, it is still possible that b_i = b_j); for every index i\r\nin [1, n - 1] either b_i = b_{i + 1} or b_i + 1 = b_{i + 1}. For\r\nexample, if a = [1, 2, 1, 2, 3], then two possible monotonic\r\nrenumerations of a are b = [0, 0, 0, 0, 0] and b = [0, 0, 0, 0, 1].Your\r\ntask is to calculate the number of different monotonic renumerations of\r\na. The answer may be large, so print it modulo 998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5;\nconst int M = 998244353;\nint n,a[N];\nmap<int,int>mx;\nint power(int base,int to){\n\tint ret = 1;\n\twhile(to){\n\t\tif(to&1)ret = ret*1LL*base%M;\n\t\tto>>=1;\n\t\tbase = base*1LL*base%M;\n\t}\n\treturn ret;\n}\nint main(){\n// \tfreopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < n;i++){\n\t\tscanf(\"%d\",a + i);\n\t\tmx[a[i]] = i;\n\t}\n\tint to = 0,need = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tto = max(to,mx[a[i]]);\n\t\tif(to == i){\n\t\t\tto++;\n\t\t\tneed++;\n\t\t}\n\t}\n\tassert(need > 0);\n\tprintf(\"%d\\n\",power(2,need - 1));\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Monotonic Renumeration.json",
    "editorial_link": "https://codeforces.com//blog/entry/64439",
    "editorial": "We are interested in such subsegments of the array that for every value\r\nbelonging to this segment all occurences of this value in the array are\r\ninside this segment. Letâs call such segments . For example, if , then ,\r\nand are closed segments.We can see that the result is some partition of\r\nthe given array into several closed segments if for some value all\r\noccurences of in do not form a segment in , then there exists some pair\r\nsuch that (which contradicts the statement); and if the formed segment\r\nis not a closed segment, then for some indices and such that it is not\r\ntrue that (which also contradicts the statement).Okay, letâs try to\r\npartition the array into closed segments greedily: take the first prefix\r\nof the array that is a closed segment, erase it, take the next prefix,\r\nand so on. Let be the number of closed segments we got with this\r\nprocedure.The key fact is that . To prove it, suppose we partitioned the\r\narray in some other way. The intersection of two closed segments, if it\r\nexists, is also a closed segment; so there exists at least one segment\r\nin the partition we picked greedily that can be broken into two but that\r\ncontradicts the algorithm we used to construct this partition.So we may\r\nmerge some of segments to get a valid partition. There are exactly ways\r\nto do so, because for every pair of adjacent segments we may choose\r\nwhether we will merge it.\r\n",
    "hint": []
}