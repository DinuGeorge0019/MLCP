{
    "link": "https://codeforces.com//contest/1296/problem/E1",
    "problemId": "531586",
    "problem_idx": "E1",
    "shortId": "1296E1",
    "contest_number": "1296",
    "problem_submissions": {
        "F": [
            70286253,
            70288122,
            70354438,
            70285370,
            70284169,
            70273160,
            70285348,
            70284069,
            73578212
        ],
        "E2": [
            70268992,
            70280432,
            70276298,
            70288167,
            70281465,
            70297360,
            70276336,
            70279357,
            70275001,
            70289621,
            70284967,
            70279268,
            70267172,
            70283236,
            70277761,
            70279813,
            70288110,
            70291891
        ],
        "E1": [
            70259556,
            70271142,
            70274990,
            70272602,
            70283753,
            70297032,
            70271882,
            70269738,
            70275752,
            70268786,
            70271448,
            70276258,
            70273279,
            70265150,
            70276327,
            70278408,
            70275898,
            70282584,
            70276913
        ],
        "D": [
            70254151,
            70262790,
            70262428,
            70261281,
            70276243,
            70262462,
            70263810,
            70262249,
            70265276,
            70259161,
            70259866,
            70267524,
            70269993,
            70279455,
            70268313,
            70271364,
            70271292,
            70266627,
            70267013
        ],
        "C": [
            70249671,
            70254183,
            70253966,
            70257190,
            70266437,
            70255782,
            70255981,
            70254148,
            70255586,
            70253171,
            70255047,
            70257702,
            70256317,
            70276767,
            70260739,
            70266471,
            70262570,
            70259034,
            70260723
        ],
        "B": [
            70243991,
            70245027,
            70247695,
            70248175,
            70243833,
            70246192,
            70247369,
            70246768,
            70245235,
            70247847,
            70245515,
            70248129,
            70249598,
            70248726,
            70249146,
            70250758,
            70248649,
            70248220
        ],
        "A": [
            70240828,
            70240986,
            70241720,
            70243455,
            70240584,
            70241402,
            70241482,
            70242817,
            70240810,
            70240914,
            70243012,
            70245219,
            70243961,
            70242643,
            70241917,
            70240694,
            70241375,
            70241384
        ]
    },
    "name": "E1. String Coloring  easy version ",
    "statement": ".You are given a string s consisting of n lowercase Latin letters.You\r\nhave to color its characters (each character to exactly one color, the\r\nsame letters can be colored the same or different colors, i.e. you can\r\nchoose exactly one color for each index in s).After coloring, you can\r\nswap two neighboring characters of the string that are colored colors.\r\nYou can perform such an operation arbitrary (possibly, zero) number of\r\ntimes.The goal is to make the string sorted, i.e. all characters should\r\nbe in alphabetical order.Your task is to say if it is possible to color\r\nthe given string so that after coloring it can become sorted by sequence\r\nof swaps. Note that you have to restore only coloring, not the sequence\r\nof swaps.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;\nchar a[N];\nint s[N];\nint main()\n{\n    cin>>n;\n    scanf(\"%s\",a+1);\n    s[1]=0;\n    for(int i=2;i<=n;i++){\n        s[i]=-1;\n        for(int j=1;j<i;j++){\n            if(a[j]>a[i]){\n                if(s[i]==s[j]){\n                    cout<<\"NO\"<<endl;\n                    return 0;\n                }\n                s[i]=!s[j];\n            }\n        }\n        if(s[i]==-1)s[i]=0;\n    }\n    cout<<\"YES\"<<endl;\n    for(int i=1;i<=n;i++)printf(\"%d\",s[i]);\n    return 0;\n}\n/*\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "graphs",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. String Coloring  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/73627",
    "editorial": "Note that the actual problem is to divide the string into two\r\nsubsequences that both of them are non-decreasing. You can note that\r\nthis is true because you cannot the relative order of the elements\r\ncolored in the same color, but you can write down subsequences of\r\ndifferent colors in any order you want.In this problem, you can write\r\nthe following dynamic programming: is if you can split the prefix of the\r\nstring into two non-decreasing sequences such that the first one ends\r\nwith the character and the second one with (characters are numbered from\r\nto ), otherwise is zero. Initially, only , other values are zeros.\r\nTransitions are very easy: if the current value of dp is then we can\r\nmake a transition to if and to if . Then you can restore the answer by\r\ncarrying parent values.But there is another very interesting solution.\r\nLetâs go from left to right and carry two sequences and . If the current\r\ncharacter is not less than the last character of then letâs append it to\r\n, otherwise, if this character is not less than the last character of\r\nthen append it to , otherwise the answer is \"\".If the answer isnât \"\"\r\nthen and are required sequences. The proof and other stuff will be in\r\nthe editorial of the hard version.Time complexity: or or .\r\n",
    "hint": []
}