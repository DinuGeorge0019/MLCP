{
    "link": "https://codeforces.com//contest/1234/problem/E",
    "problemId": "426515",
    "problem_idx": "E",
    "shortId": "1234E",
    "contest_number": "1234",
    "problem_submissions": {
        "F": [
            61647149,
            61645384,
            61650555,
            61651870,
            61667991,
            62194838,
            61712119,
            61666405,
            61729878,
            61729799,
            61664234,
            68329269,
            61680222,
            61752962
        ],
        "E": [
            61637715,
            61643598,
            61648539,
            61642595,
            61643656,
            61651547,
            61650480,
            61652692,
            61641203,
            61649142,
            61659878,
            61650257,
            61653772,
            61654963,
            61657548,
            61649045,
            61654746,
            61657468,
            61654998,
            61655416
        ],
        "C": [
            61632575,
            61627606,
            61654578,
            61628592,
            61630466,
            61624366,
            61638436,
            61629236,
            61652967,
            61631133,
            61636961,
            61642219,
            61643521,
            61637365,
            61636499,
            61632963,
            61634943,
            61633612,
            61629926,
            61640840
        ],
        "B1": [
            61622243,
            61619256,
            61623667,
            61618942,
            61620065,
            61620401,
            61621233,
            61618288,
            61620321,
            61625306,
            61621149,
            61623370,
            61622245,
            61622135,
            61620954,
            61622191,
            61621982,
            61619236,
            61622554,
            61619031
        ],
        "B2": [
            61622177,
            61619354,
            61626675,
            61618859,
            61617735,
            61620174,
            61619049,
            61620082,
            61618293,
            61625056,
            61620210,
            61624129,
            61619541,
            61622218,
            61620837,
            61628084,
            61621947,
            61619088,
            61624726,
            61619187
        ],
        "D": [
            61620922,
            61632151,
            61634663,
            61631934,
            61627516,
            61628612,
            61627461,
            61639106,
            61624471,
            61635660,
            61628357,
            61634636,
            61632191,
            61627962,
            61627805,
            61636954,
            61642587,
            61638100,
            61640694,
            61630321
        ],
        "A": [
            61612861,
            61620182,
            61616933,
            61612804,
            61614828,
            61613376,
            61613863,
            61613458,
            61613474,
            61619474,
            61614252,
            61614656,
            61613262,
            61614503,
            61613228,
            61614047,
            61614323,
            61618981,
            61616841,
            61613092
        ]
    },
    "name": "E. Special Permutations",
    "statement": "Let’s define p_i(n) as the following permutation: [i, 1, 2,\r\ndots, i - 1, i + 1,\r\ndots, n]. This means that the i-th permutation is (i.e. which maps every\r\nelement to itself) permutation but the element i is on the first\r\nposition. Examples: p_1(4) = [1, 2, 3, 4]; p_2(4) = [2, 1, 3, 4]; p_3(4)\r\n= [3, 1, 2, 4]; p_4(4) = [4, 1, 2, 3]. You are given an array x_1, x_2,\r\ndots, x_m (1\r\nle x_i\r\nle n).Let pos(p, val) be the position of the element val in p. So,\r\npos(p_1(4), 3) = 3, pos(p_2(4), 2) = 1, pos(p_4(4), 4) = 1.Let’s define\r\na function f(p) =\r\nsum\r\nlimits_{i=1}^{m - 1} |pos(p, x_i) - pos(p, x_{i + 1})|, where |val| is\r\nthe absolute value of val. This function means the sum of distances\r\nbetween adjacent elements of x in p.Your task is to calculate f(p_1(n)),\r\nf(p_2(n)),\r\ndots, f(p_n(n)).\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int MAX_N = (int)2e5 + 777;\n\nint64 answ[MAX_N], arr[MAX_N];\nint n, m;\n\nvoid add(int l, int r, int64 dx) {\n\tansw[l] += dx;\n\tansw[r + 1] -= dx;\n}\n\nvoid solve() {\n\tcin >> n >> m;\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tcin >> arr[i];\n\t}\n\n\tfor(int i = 0; i < m - 1; ++i) {\n\t\tint64 L = arr[i], R = arr[i + 1];\n\n\t\tif(R < L)\n\t\t\tswap(L, R);\n\n\t\tif(L == R)\n\t\t\tcontinue;\n\n\t\tif(L > 1)\n\t\t\tadd(1, L - 1, R - L);\n\n\t\tif(R < n)\n\t\t\tadd(R + 1, n, R - L);\n\n\t\tif(R - L > 1) {\n\t\t\tadd(L + 1, R - 1, R - L - 1);\n\t\t}\n\n\t\tadd(L, L, R - 1);\n\t\tadd(R, R, L);\n\t}\n\n\tint64 acc = 0;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tacc += answ[i];\n\t\tcout << acc << ' ';\n\t}\n\n\tcout << '\\n';\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Special Permutations.json",
    "editorial_link": "https://codeforces.com//blog/entry/70233",
    "editorial": "Letâs calculate the answer for the first permutation naively in . Then\r\nletâs recalculate the answer somehow and then maybe prove that it works\r\nin linear time.Which summands will change when we try to recalculate the\r\nfunction using ? First of all, letâs notice that each pair of adjacent\r\nelements of is the segment on the permutation. To calculate fast, letâs\r\nfirstly notice that all segments that cover the element (but is not\r\ntheir endpoint) will change their length by minus one after placing at\r\nthe first position (because will be removed from all such segments).This\r\npart can be calculated in . Letâs use the standard trick with prefix\r\nsums and segments. Let be the array of length . For each pair of\r\nadjacent elements and for all from to letâs do the following sequence of\r\nmoves: if then there are no points that covered by this segment not\r\nbeing its endpoints, so letâs just skip this segment. Otherwise letâs\r\nincrease the value of by one and decrease the value of by one. After\r\nthis, letâs build prefix sums on this array (make for all from to ). And\r\nnow equals to the number of segments covering the element .The second\r\npart that will change is such segments that is their endpoint. Letâs\r\nstore the array of arrays of length and will store all elements adjacent\r\nto in the array for all from to . But one important thing: we donât need\r\nto consider such pairs and that (it broke my solution somehow so this\r\npart is important).Knowing these two parts we can easily calculate using\r\n. Firstly, letâs initialize the result as . Then we need to recalculate\r\nlengths of such segments that is their endpoint. Letâs iterate over all\r\nelements in , set (remove the old segment) and set (add the length of\r\nthe segment from to ) and increase by one if (it means that and change\r\ntheir relative order and the length of the segment from to increases by\r\none).Now we can see that after iterating over all from to we make at\r\nmost moves because each pair of adjacent elements in was considered at\r\nmost twice.Total complexity: .\r\n",
    "hint": []
}