{
    "link": "https://codeforces.com//contest/988/problem/E",
    "problemId": "186730",
    "problem_idx": "E",
    "shortId": "988E",
    "contest_number": "988",
    "problem_submissions": {
        "F": [
            38850795,
            38857750,
            38858170,
            38851497,
            38853401,
            38851133,
            38851544,
            38859838,
            38848093,
            38907880,
            38907831
        ],
        "E": [
            38844731,
            38844693,
            38848592,
            38858719,
            45955063,
            38853668,
            38847637,
            38853437,
            38839299,
            38861890,
            38864917,
            38858969,
            38857001,
            38858857,
            38858182,
            38859392,
            38864208,
            38855992,
            38859515
        ],
        "D": [
            38840392,
            38848969,
            38851772,
            38843233,
            38946024,
            38842418,
            38844498,
            38868323,
            38844694,
            44031526,
            44031416,
            38848128,
            38864951,
            38847308,
            38850578,
            38849097,
            38853027,
            38857525,
            38900563,
            38852549,
            38852551,
            38854050
        ],
        "C": [
            38837549,
            38839564,
            38842456,
            38840172,
            38945961,
            38836792,
            38841053,
            38844962,
            38841756,
            38846652,
            38845827,
            38864928,
            38839933,
            38843822,
            38844819,
            38846434,
            38850120,
            38847359,
            38847106,
            38847820,
            38842193
        ],
        "B": [
            38835102,
            38835826,
            38836723,
            38836527,
            38945931,
            38930097,
            38834357,
            38837106,
            38835693,
            38837985,
            38835772,
            38840393,
            38864939,
            38841754,
            38836363,
            38841437,
            38840823,
            38838916,
            38847752,
            38851402,
            38836768
        ],
        "A": [
            38833122,
            38833181,
            38833533,
            38833575,
            38945641,
            38945626,
            38929615,
            38833067,
            38833623,
            38833881,
            38833289,
            38833348,
            38834787,
            38833528,
            38833829,
            38833852,
            38833420,
            38836476,
            38849551,
            38833125,
            38833682
        ]
    },
    "name": "E. Divisibility by 25",
    "statement": "You are given an integer n from 1 to 10^{18} without leading zeroes.In\r\none move you can swap any two adjacent digits in the given number in\r\nsuch a way that the resulting number will not contain leading zeroes. In\r\nother words, the number you have cannot contain any leading zeroes.What\r\nis the minimum number of moves you have to make to obtain a number that\r\nis divisible by 25? Print if it is impossible to obtain a number that is\r\ndivisible by 25.\r\n",
    "solutions": [
        "/// In The Name Of God\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl '\\n'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)5e5 + 7;\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint n;\nint ans = inf;\nchar s[N], t[N];\nint last[10];\n\nvoid go(char x, char y) {\n\tif (!min(last[x], last[y])) return;\n\tint cnt = 0;\n\trep(i, 1, n) t[i] = s[i];\n\tx += '0', y += '0';\n\tper(i, n, 1) {\n\t\tif (t[i] == y) {\n\t\t\twhile (i < n) swap(t[i], t[i + 1]), ++cnt, ++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tper(i, n, 1) {\n\t\tif (t[i] == x) {\n\t\t\twhile (i < (n - 1)) swap(t[i], t[i + 1]), ++cnt, ++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (t[1] == '0') {\n\t\trep(i, 2, n - 2) {\n\t\t\tif (t[i] != '0') {\n\t\t\t\tans = min(ans, cnt + i - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tans = min(ans, cnt);\n}\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (\"in.txt\", \"r\", stdin);\n\t#endif\n\tcin >> (s + 1);\n\tn = strlen(s + 1);\n\tint cnt = 0, cur = 0;\n\tper(i, n, 1) {\n\t\tif (s[i] == '0' && cnt < 2) {\n\t\t\tcur += (n - cnt) - i;\n\t\t\t++cnt;\n\t\t}\n\t\tint x = s[i] - '0';\n\t\tif (!last[x]) last[x] = i;\n\t}\n\tif (cnt == 2) ans = min(ans, cur);\n\t/*\n\tif (last[2] && last[5]) ans = min(ans, (n - last[5]) + (n - 1 - last[2]));\n\tif (last[7] && last[5]) ans = min(ans, (n - last[5]) + (n - 1 - last[7]));*/\n\tgo(2, 5);\n\tgo(5, 0);\n\tgo(7, 5);\n\n\tif (ans == inf) ans = -1;\n\tcout << ans;\n\tioi\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Divisibility by 25.json",
    "editorial_link": "https://codeforces.com/blog/entry/59810",
    "editorial": "Letâs iterate over all pairs of digits in the number. Let the first\r\ndigit in the pair be at position and the second at position . Letâs\r\nplace these digits to the last two positions in the number. The first\r\ngreedily goes to the last position and then the second goes to the\r\nposition next to that. Now the number can contain a leading zero. Find\r\nthe leftmost non-zero digit and move it to the first position. Then if\r\nthe current number is divisible by try to update the answer with the\r\nnumber of swaps. It is easy to show that the number of swaps is minimal\r\nin this algorithm. The only difference we can introduce is the number of\r\ntimes digit , digit and the leftmost non-zero digit swap among\r\nthemselves. And that is minimized. You can also notice that the order of\r\nswaps doesnât matter and you can rearrange them in such a way that no\r\nleading zero appears on any step.This solution has time complexity . You\r\ncan also solve this problem with complexity because you have to check\r\nonly four options of the two last digits (, , , ). It is always optimal\r\nto choose both rightmost occurrences of the corresponding digits. You\r\ncan show that even if you are required to swap the chosen ones, there\r\nwill be no other pair with smaller total amount of moves.\r\n",
    "hint": []
}