{
    "link": "https://codeforces.com//contest/1196/problem/B",
    "problemId": "377791",
    "problem_idx": "B",
    "shortId": "1196B",
    "contest_number": "1196",
    "problem_submissions": {
        "F": [
            57681700,
            57688661,
            57693585,
            57690559,
            57665659,
            57695119,
            57781679,
            83242061,
            57916383,
            68726830,
            82270831
        ],
        "B": [
            57673541,
            57649544,
            57652269,
            57654230,
            57679335,
            57653669,
            57651478,
            57654275,
            57652865,
            57652183,
            103121358,
            59232415,
            57652308,
            57652960,
            57653412,
            57655574,
            58261889,
            57653528,
            57654061,
            57651928,
            57655085,
            57658491,
            57652103
        ],
        "A": [
            57662145,
            57646582,
            57648135,
            57648211,
            57648294,
            57649147,
            57647064,
            57648725,
            57646690,
            57646929,
            57647619,
            57646915,
            57649771,
            57648481,
            58261863,
            57647513,
            57649572,
            57646786,
            57647851,
            57652602,
            57647144
        ],
        "E": [
            57660066,
            57677485,
            57675366,
            57677436,
            57681282,
            57677830,
            57673842,
            57672850,
            57676048,
            57682764,
            57679085,
            57680414,
            57680019,
            57677517,
            58261965,
            57678819,
            57684523,
            57681696,
            57679722,
            57677290,
            57678640
        ],
        "C": [
            57658492,
            57654354,
            57658481,
            57657615,
            57689981,
            57659504,
            57656630,
            57658570,
            57658429,
            57659478,
            57661824,
            57660864,
            57657934,
            57660478,
            58261906,
            57662669,
            57660523,
            57674035,
            57662185,
            57663396,
            57666540
        ],
        "D1": [
            57651996,
            57658879,
            57661770,
            57666118,
            57654079,
            57666561,
            57662530,
            57664730,
            57663635,
            57664913,
            57668860,
            57664436,
            57664910,
            57666776,
            58261921,
            57667464,
            57664679,
            57661598,
            57670813,
            57668128,
            57657381
        ],
        "D2": [
            57650929,
            57658567,
            57664847,
            57665451,
            57654443,
            57666008,
            57663080,
            57665252,
            57667224,
            57664331,
            57668491,
            57667512,
            57669290,
            57667407,
            58261939,
            57671667,
            57668510,
            57661989,
            57670493,
            57667835,
            57657749
        ]
    },
    "name": "B. Odd Sum Segments",
    "statement": "You are given an array a consisting of n integers a_1, a_2,\r\ndots, a_n. You want to split it into exactly k such that each subsegment\r\nhas odd sum (i. e. for each subsegment, the sum of all elements that\r\nbelong to this subsegment is odd). It is impossible to rearrange\r\n(shuffle) the elements of a given array. Each of the n elements of the\r\narray a must belong to exactly one of the k subsegments.Let’s see some\r\nexamples of dividing the array of length 5 into 3 subsegments (not\r\nnecessarily with odd sums): [1, 2, 3, 4, 5] is the initial array, then\r\nall possible ways to divide it into 3 non-empty non-intersecting\r\nsubsegments are described below: [1], [2], [3, 4, 5]; [1], [2, 3], [4,\r\n5]; [1], [2, 3, 4], [5]; [1, 2], [3], [4, 5]; [1, 2], [3, 4], [5]; [1,\r\n2, 3], [4], [5]. Of course, it can be impossible to divide the initial\r\narray into exactly k subsegments in such a way that each of them will\r\nhave odd sum of elements. In this case print \"\". Otherwise, print \"\" and\r\npossible division of the array. See the output format for the detailed\r\nexplanation.You have to answer q independent queries.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline void work()\n{\n    int n,k;vector<int>pos;\n    scanf(\"%d%d\",&n,&k);\n    for (int i=1;i<=n;i++)\n    {\n        int x;scanf(\"%d\",&x);x%=2;\n        if (x)pos.push_back(i);\n    }\n    if(pos.size()%2==k%2)\n    {\n        if (pos.size()>=k)\n        {\n            puts(\"YES\");\n            for (int j=0;j<k-1;j++)printf(\"%d \",pos[j]);\n            printf(\"%d\\n\",n);\n            return;\n        }\n    }\n    puts(\"NO\");\n}\nint main()\n{\n    int T;scanf(\"%d\",&T);\n    while (T--)work();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Odd Sum Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/68655",
    "editorial": "Firstly, let be the number of odd elements in the array. Note that even\r\nelements are donât matter at all because they cannot change the parity\r\nof the sum.If then it is obviously impossible to split the given array\r\ninto subsegments with odd sum. And if then it is impossible to split the\r\narray into subsegments with odd sum also because at least one of\r\nsegments will have even number of odd elements (so will have odd sum).In\r\nother cases the answer is always \"\" and you can print leftmost positions\r\nof odd elements and as right borders of segments (it means that when you\r\nfind one odd element, you end one segment). Because now, the last\r\nsegment will have odd number of odd elements so it will have odd sum\r\nalso.\r\n",
    "hint": []
}