{
    "link": "https://codeforces.com//contest/1593/problem/C",
    "problemId": "1142163",
    "problem_idx": "C",
    "shortId": "1593C",
    "contest_number": "1593",
    "problem_submissions": {
        "G": [
            131796315,
            131809860,
            131836830,
            131839082,
            131841650,
            131846524,
            131852907,
            131782296,
            148479901,
            131828563
        ],
        "D2": [
            131785134,
            131788443,
            131789598,
            131915775,
            131805880,
            131823322,
            131831578,
            131821525,
            131793982,
            131849437,
            131784594,
            131791388,
            131828383,
            131836476,
            131831664,
            131825743,
            131905244,
            131794334
        ],
        "F": [
            131781426,
            131837226,
            131815253,
            131811669,
            131876285,
            131849937,
            131847427,
            131845860,
            131816994,
            131855037,
            131787838,
            131800685,
            131891194
        ],
        "E": [
            131774861,
            131775908,
            131796997,
            131786728,
            131876206,
            131792098,
            131797221,
            131825650,
            131807172,
            131832634,
            131793728,
            131840729,
            131794124,
            131808830,
            131787792,
            131786397,
            131783883,
            131789053,
            223850329,
            131905293,
            131805482
        ],
        "B": [
            131755249,
            131755158,
            131757455,
            131754198,
            131760377,
            131758125,
            131761538,
            131761685,
            131807386,
            131800607,
            131823956,
            131758842,
            131777000,
            131762147,
            131758359,
            131757156,
            131752418,
            131759279,
            131754084,
            131765706
        ],
        "C": [
            131755086,
            131765317,
            131761314,
            131762977,
            131768274,
            131765107,
            131772896,
            131769864,
            131760280,
            131765951,
            131827956,
            131767746,
            131761402,
            131771022,
            131806450,
            131797380,
            131767699,
            131763033,
            131759309,
            131766132,
            131759703,
            131774485
        ],
        "D1": [
            131754873,
            131770215,
            131766394,
            131756595,
            131776207,
            131772281,
            131769846,
            131778601,
            131766158,
            131773159,
            131795293,
            131772976,
            131778104,
            131776921,
            131775662,
            131772715,
            131771125,
            131769653,
            131765142,
            131779945
        ],
        "A": [
            131752757,
            131748062,
            131750155,
            131748058,
            131749835,
            131748696,
            131748309,
            131753208,
            131799940,
            131756190,
            131825544,
            131751230,
            131754683,
            131752419,
            131750607,
            131749631,
            131748206,
            131752432,
            131748594,
            131755250
        ]
    },
    "name": "C. Save More Mice",
    "statement": "There are one cat, k mice, and one hole on a coordinate line. The cat is\r\nlocated at the point 0, the hole is located at the point n. All mice are\r\nlocated between the cat and the hole: the i-th mouse is located at the\r\npoint x_i (0 < x_i < n). At each point, many mice can be located.In one\r\nsecond, the following happens. First, mouse moves to the right by 1. If\r\nthe mouse reaches the hole, it hides (i.e. the mouse will not any more\r\nmove to any point and will not be eaten by the cat). Then ( the mouse\r\nhas finished its move) the cat moves to the right by 1. If at the new\r\ncat’s position, some mice are located, the cat eats them (they will not\r\nbe able to move after that). The actions are performed until any mouse\r\nhasn’t been hidden or isn’t eaten.In other words, the first move is made\r\nby a mouse. If the mouse has reached the hole, it’s saved. Then the cat\r\nmakes a move. The cat eats the mice located at the pointed the cat has\r\nreached (if the cat has reached the hole, it eats nobody).Each second,\r\nyou can select a mouse that will make a move. What is the maximum number\r\nof mice that can reach the hole without being eaten?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=400005;\nint x[N],n,k,t;\nint main() {\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>n>>k;\n        for (int i=1;i<=k;i++) cin>>x[i];\n        sort(x+1,x+k+1);\n        int res=0,pos=0;\n        for (int i=k;i>=1;i--) {\n            if (pos<x[i]) res++,pos+=n-x[i];\n            else break;\n        }\n        cout<<res<<\"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "greedy"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Save More Mice.json",
    "editorial_link": "https://codeforces.com//blog/entry/96034",
    "editorial": "Letâs solve the problem using a linear search. Let be the number of mice\r\nwe are trying to save. Then it is more efficient to save mice such that\r\nthey are the closest ones to the hole. Let be the distance from the -th\r\nmouse to the hole (). Denote . Letâs prove that these mice will be saved\r\nif and only if .The necessary condition. Suppose we can save the mice\r\nand . Since only one mouse can be moved in one second, the following\r\nwill happen: of mice will already be saved and one mouse will have to be\r\nsaved. When itâs been seconds, then the distance from the cat to the\r\nhole will be equal to , and the distance from the mouse to the hole will\r\nbe equal to (since all other mice are already in the hole, their\r\ndistances to the hole are equal to , so the sum of the distances from\r\nall mice to the hole at the current time is exactly equal to the\r\ndistance to the hole from one remaining mouse). Since , the distance\r\nfrom the mouse to the hole is greater than or equal to the distance from\r\nthe cat to the hole. But this cannot be, because both the mice and the\r\ncat move only to the right, and all mice met by the cat are eaten. So,\r\n.Sufficient condition. Suppose . If , then all the mice are already in\r\nthe hole, i.e. they are saved. Suppose . Letâs move any mouse, then the\r\ncat. Suppose the cat ate at least one of the mice. This mouse is\r\ndefinitely not the one that was moved. Then the distance from it to the\r\neaten mouse was equal to , i.e. the distance from it to the hole was\r\nequal to the distance from the eaten mouse to the hole plus . The\r\ndistance from the moved mouse to the hole was at least . So, , where is\r\nthe distance from the eaten mouse to the hole, is the distance from the\r\nmoved mouse to the hole. So, , but itâs false. Therefore, none of the\r\nmice will be eaten on the first move. Then the distance from the cat to\r\nthe hole will be equal to , the total distance from the mice to the hole\r\nwill be equal to . , i.e. now we have to solve a similar problem for\r\nsmaller and . So will be gradually decreased to , while no mouse will be\r\neaten. So, if , all the mice will be saved.Thus, to solve the problem,\r\nwe need to find the maximum such that the sum of the distances from the\r\nnearest mice to the hole is less than .\r\n",
    "hint": []
}