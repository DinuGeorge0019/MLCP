{
    "link": "https://codeforces.com//contest/1551/problem/B2",
    "problemId": "1055221",
    "problem_idx": "B2",
    "shortId": "1551B2",
    "contest_number": "1551",
    "problem_submissions": {
        "D2": [
            123504570,
            123491119,
            123485402,
            123508709,
            123487387,
            123490299,
            123498497,
            123519517,
            123503570,
            123507308,
            123506328,
            123496338,
            123525324,
            123509854,
            123500000,
            123499688,
            123500681,
            123520243,
            123521810,
            123560543,
            123489816
        ],
        "D1": [
            123496540,
            123479404,
            123460900,
            123501007,
            123476769,
            123477339,
            123486676,
            123509110,
            123490131,
            123493249,
            123493173,
            123482125,
            123490880,
            123500902,
            123489510,
            123491442,
            123487788,
            123505201,
            123513198,
            123560527,
            123477927
        ],
        "E": [
            123487760,
            123503517,
            123508061,
            123512161,
            123512376,
            123522062,
            123512340,
            123494473,
            123520187,
            123519199,
            123522642,
            123508385,
            123509676,
            123525566,
            123522562,
            123529567,
            123525043,
            123524224,
            123527690,
            123529206
        ],
        "F": [
            123483346,
            123518773,
            123505149,
            123522554,
            123530029,
            123525813,
            123677834
        ],
        "C": [
            123463062,
            123471764,
            123465961,
            123494616,
            123466015,
            123470689,
            123479667,
            123473982,
            123478387,
            123473235,
            123485341,
            123504214,
            123476344,
            123474463,
            123482794,
            123487070,
            123509871,
            123495332,
            123505971,
            123560511,
            123471519
        ],
        "B1": [
            123458055,
            123450157,
            123447323,
            123480992,
            123471662,
            123459271,
            123448891,
            123453516,
            123457018,
            123473105,
            123465306,
            123457521,
            123473064,
            123450150,
            123457907,
            123454507,
            123450845,
            123454392,
            123459478,
            123486711,
            123560483,
            123451550
        ],
        "B2": [
            123455203,
            123463888,
            123460727,
            123523874,
            123456743,
            123463349,
            123471479,
            123467608,
            123467523,
            123462292,
            123471295,
            123468067,
            123463785,
            123466840,
            123469959,
            123475307,
            123473651,
            123478743,
            123500344,
            123560494,
            123462370
        ],
        "A": [
            123443367,
            123443254,
            123447159,
            123446121,
            123445546,
            123443509,
            123444177,
            123443572,
            123444116,
            123444163,
            123445991,
            123474697,
            123444077,
            123443229,
            123447862,
            123443364,
            123443226,
            123449045,
            123446138,
            123560465,
            123443541
        ]
    },
    "name": "B2. Wonderful Coloring - 2",
    "statement": "Recently, Paul and Mary have found a new favorite sequence of integers\r\na_1, a_2,\r\ndots, a_n. They want to paint it using pieces of chalk of k colors. The\r\ncoloring of a sequence is called if the following conditions are met:\r\neach element of the sequence is either painted in one of k colors or\r\nisn\u2019t painted; each two elements which are painted in the same color are\r\ndifferent (i. e. there\u2019s no two equal values painted in the same color);\r\nlet\u2019s calculate for each of k colors the number of elements painted in\r\nthe color all calculated numbers must be equal; the total number of\r\npainted elements of the sequence is the among all colorings of the\r\nsequence which meet the first three conditions. E. g. consider a\r\nsequence a=[3, 1, 1, 1, 1, 10, 3, 10, 10, 2] and k=3. One of the\r\nwonderful colorings of the sequence is shown in the figure. Help Paul\r\nand Mary to find a wonderful coloring of a given sequence a.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    map<int,vector<int>> mp;\n    vector<int> ans(n+1,0);\n    for(int i=1;i<=n;++i)\n    {\n        int x;\n        cin >> x;\n        mp[x].push_back(i);\n    }\n    vector<int> t;\n    for(auto &[i,v]:mp)\n    {\n        while(sz(v) > k)\n            v.pop_back();\n        for(auto &j:v)\n            t.push_back(j);\n    }\n    while(sz(t) % k != 0)\n        t.pop_back();\n    int cur = 0;\n    for(int i=0;i<sz(t);++i)\n    {\n        ans[t[i]] = cur + 1;\n        cur = (cur + 1) % k;\n    }\n    for(int i=1;i<=n;++i)\n        cout << ans[i] << \" \";\n    cout <<\"\\n\";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B2. Wonderful Coloring - 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/93149",
    "editorial": "Since we must use exactly colors, each element that occurs in the\r\nsequence may have no more than painted occurrences. for each element its\r\noccurrences where is the number of all its occurrences in the\r\nsequence.Let be a sequence of all elements that occur in the sequence ,\r\nbut in the sequence they will occur only once. Let\u00e2\u0080\u0099s create a -indexed\r\narray in which we will add indices of occurrences of in the sequence ,\r\nthen the selected occurrences of , and so on till . Currently, is a set\r\nof occurrences, which wonderful coloring is a wonderful coloring of the\r\nwhole sequence because if we want to paint an occurrence outside , we\r\ncan do it only by selecting an occurrence of the same element in which\r\nwe will not paint so that no more than occurrences will be painted.We\r\nmust use exactly colors and paint for each color an equal number of\r\noccurrences, hence if we want to paint all occurrences from , we must\r\nremove from it the minimum number of occurrences so that the size of the\r\narray will be divided by (i. e. remove the number of occurrences equal\r\nto the remainder of dividing the size of by ). We can remove any\r\noccurrences, for example, let\u00e2\u0080\u0099s delete it from the suffix of .\r\nCurrently, we can paint all occurrences from using the following rule:\r\nthe occurrence we must paint in the color with a number where takes the\r\nremainder of dividing the left operand by the right operand. So all\r\noccurrences from will be painted and all colors will be used. Since all\r\noccurrences of one element belong to one subsegment of and their number\r\nisn\u00e2\u0080\u0099t greater than , they will be painted in different colors.It may be\r\nso that the array before painting will be empty. In this case, the\r\nwonderful coloring of doesn\u00e2\u0080\u0099t contain any painted element.\r\n"
}