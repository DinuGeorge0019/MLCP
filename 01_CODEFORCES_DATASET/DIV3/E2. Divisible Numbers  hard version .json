{
    "link": "https://codeforces.com//contest/1744/problem/E2",
    "problemId": "1588811",
    "problem_idx": "E2",
    "shortId": "1744E2",
    "contest_number": "1744",
    "problem_submissions": {
        "F": [
            176553227,
            176553544,
            176566357,
            176560159,
            176546102,
            176578517,
            176584245,
            176547600,
            176565814,
            176583243,
            176570293,
            176568891,
            176580658,
            176549125,
            176552417
        ],
        "E2": [
            176537039,
            176543155,
            176544098,
            176552866,
            176557487,
            176561438,
            176571338,
            176588976,
            176584430,
            176552304,
            176570770,
            176580914,
            176566759,
            176538612,
            176549104,
            176542275,
            176597567,
            176547159
        ],
        "E1": [
            176523424,
            176527685,
            176528090,
            176524133,
            176549768,
            176542439,
            176540904,
            176551294,
            176537989,
            176588085,
            176549982,
            176562357,
            176580820,
            176565848,
            176529066,
            176530377,
            176532213,
            176534352,
            176532004,
            176541146
        ],
        "D": [
            176517006,
            176523243,
            176521839,
            176520437,
            176527121,
            176527329,
            176532848,
            176530724,
            176509817,
            176532455,
            176530899,
            176528083,
            176525625,
            176540526,
            176519966,
            176526382,
            176517877,
            176524396,
            176521192,
            176681646,
            176520869
        ],
        "C": [
            176513410,
            176510113,
            176517214,
            176516278,
            176522404,
            176518415,
            176520721,
            176522857,
            176528070,
            176508309,
            176517716,
            176518546,
            176530395,
            176509852,
            176512457,
            176513429,
            176518278,
            176517008,
            176516387
        ],
        "B": [
            176508945,
            176505988,
            176509682,
            176510843,
            176515767,
            176510929,
            176512338,
            176516029,
            176510777,
            176510381,
            176514031,
            176513353,
            176516140,
            176505686,
            176508808,
            176509484,
            176509527,
            176511738,
            176510683
        ],
        "A": [
            176504550,
            176503461,
            176503689,
            176506263,
            176508578,
            176504919,
            176506102,
            176511212,
            176505675,
            176504917,
            176508718,
            176507229,
            176505489,
            176503181,
            176503369,
            176503975,
            176503284,
            176505909,
            176504558
        ]
    },
    "name": "E2. Divisible Numbers  hard version ",
    "statement": "You are given 4 positive integers a, b, c, d with a < c and b < d. Find\r\nany pair of numbers x and y that satisfies the following conditions: a <\r\nx\r\nleq c, b < y\r\nleq d, x\r\ncdot y is divisible by a\r\ncdot b.Note that required x and y may not exist.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nint t;\nlong long a,b,c,d,e,g,r,s,p;\nvector<long long> del1,del2;\nbool dali;\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>t;\n    for(int i=1;i<=t;i++){\n        cin>>a>>b>>c>>d;\n        del1.clear(); del2.clear();\n        \n        for(long long f=1;f*f<=a;f++){\n            if(a%f==0){\n                del1.push_back(f);\n                if(f!=a/f)del1.push_back(a/f);\n            }\n        }\n        for(long long f=1;f*f<=b;f++){\n            if(b%f==0){\n                del2.push_back(f);\n                if(f!=b/f)del2.push_back(b/f);\n            }\n        }\n\n        dali=false;\n\n        for(int f=0;f<del1.size();f++){\n            for(int k=0;k<del2.size();k++){\n                s=del1[f]*del2[k];\n                e=a/s+1;\n                if(e*s>c)continue;\n                p=e*s;\n\n                e=s;\n                g=a*b/e;\n                r=b/g+1;\n                if(g*r<=d){\n                    cout<<p<<\" \"<<g*r<<\"\\n\";\n                    dali=true; f=k=1000000;\n                }\n            }\n        }\n\n        if(!dali)cout<<-1<<\" \"<<-1<<\"\\n\";\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Divisible Numbers  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/108101",
    "editorial": "Let\u00e2\u0080\u0099s look at the slow solution first, which will lead us to the full\r\none. Let\u00e2\u0080\u0099s iterate over the number from to .Given a number , we want to\r\nfind a from to such that is divisible by . Since must be divisible by ,\r\nthe following conclusion can be drawn: must be divisible by . Let\u00e2\u0080\u0099s\r\ndenote this number as . Now our task is to check if there is a multiple\r\nof between and . The problem can be solved in many ways, you can simply\r\nconsider the largest multiple of that does not exceed it is equal to We\r\ncompare this number with , and if it matches, then we have found a\r\nsuitable pair.Now let\u00e2\u0080\u0099s note that we do not need to iterate over all the\r\nvalues of , because from the number we are only interested in and this\r\nis one of the divisors of !Even though the product can be large, we can\r\nstill consider all divisors of this number, since and themselves are up\r\nto . Let\u00e2\u0080\u0099s find the divisors of and separately, then notice that any\r\ndivisor of is , where is some divisor , and is some divisor .Let\u00e2\u0080\u0099s\r\ncalculate the running time. We need to factorize the numbers and into\r\nprime factors, this can be done in . Next, you need to iterate over\r\npairs of divisors and . Recall the estimate for the number of divisors\r\nof a number (https://oeis.org/A066150): the number up to has no more\r\nthan divisors. Therefore, we can sort through the pairs for . We learned\r\nhow to find the optimal for . We get that for each test case we have\r\nlearned to solve the problem in .\r\n"
}