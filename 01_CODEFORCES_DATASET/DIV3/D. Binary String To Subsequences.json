{
    "link": "https://codeforces.com//contest/1399/problem/D",
    "problemId": "691719",
    "problem_idx": "D",
    "shortId": "1399D",
    "contest_number": "1399",
    "problem_submissions": {
        "F": [
            89035173,
            89029933
        ],
        "E2": [
            89011999,
            89030510,
            89080621,
            89039473,
            89040534,
            89201926,
            89050383,
            89034156,
            89084070,
            89049259,
            89035111,
            89052507,
            89050541,
            89057093,
            89080141
        ],
        "E1": [
            88996046,
            89009546,
            89080613,
            89010335,
            89023941,
            89019900,
            89014538,
            89084044,
            89031455,
            89027397,
            89021735,
            89030142,
            89008436,
            89007483,
            89015010,
            89097316,
            89017545,
            89018333,
            89016025,
            89019887,
            89020808
        ],
        "D": [
            88983986,
            88986050,
            89080684,
            89080600,
            88990615,
            88995867,
            88990140,
            88981358,
            89083571,
            89083120,
            88982379,
            89003434,
            89001587,
            89002958,
            88987435,
            88992856,
            88978240,
            88981220,
            89097279,
            88987544,
            88985548,
            88986877,
            88997105
        ],
        "C": [
            88974580,
            88974518,
            89080589,
            88982402,
            88985705,
            88979354,
            88966362,
            89082893,
            88973387,
            88994104,
            88993313,
            88993807,
            88971087,
            88979014,
            88975937,
            88963847,
            89097258,
            88972661,
            88974247,
            88977241,
            88976735,
            88981249
        ],
        "B": [
            88964383,
            88965521,
            89080579,
            88970001,
            88977862,
            88967937,
            88959373,
            89082724,
            88963456,
            88986912,
            88979078,
            88973586,
            88969906,
            88966168,
            88957629,
            88964497,
            89097240,
            88962105,
            88966474,
            88966506,
            88969861
        ],
        "A": [
            88956237,
            88956430,
            89080574,
            88960295,
            88969663,
            88957655,
            88955164,
            89082748,
            88955338,
            88967328,
            88967166,
            88962494,
            88973926,
            88959306,
            88955102,
            88955579,
            89097191,
            88955839,
            88955943,
            88956625,
            88962720
        ]
    },
    "name": "D. Binary String To Subsequences",
    "statement": "You are given a binary string s consisting of n zeros and ones.Your task\r\nis to divide the given string into the number of in such a way that of\r\nthe string belongs to exactly and each subsequence looks like \"\" or \"\"\r\n(i.e. the subsequence should not contain two adjacent zeros or\r\nones).Recall that a subsequence is a sequence that can be derived from\r\nthe given sequence by deleting zero or more elements without changing\r\nthe order of the remaining elements. For example, subsequences of \"\" are\r\n\"\", \"\", \"\", \"\", \"\", \"\", but not \"\", \"\" and \"\".You have to answer t\r\nindependent test cases.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 2e5 + 5;\nchar str[MAXN];\nint a[MAXN];\n\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--){\n        int n;scanf(\"%d%s\",&n,str+1);\n        std::vector<int> p0,p1;\n        int now = 0;\n        FOR(i,1,n){\n            if(str[i] == '0'){\n                if(p1.empty()) a[i] = ++now;\n                else a[i] = a[p1.back()],p1.pop_back();\n                p0.pb(i);\n            }\n            else{\n                if(p0.empty()) a[i] = ++now;\n                else a[i] = a[p0.back()],p0.pop_back();\n                p1.pb(i);\n            }\n        }\n        printf(\"%d\\n\",now);\n        FOR(i,1,n) printf(\"%d \",a[i]);puts(\"\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Binary String To Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/81082",
    "editorial": "Letâs iterate over all characters of from left to right, maintaining two\r\narrays and , where stores indices of all subsequences which end with â\r\nand stores indices of all subsequences which end with â. If we met â,\r\nthen the best choice is to append it to some existing subsequence which\r\nends with â. If there are no such sequences, we need to create new one\r\nwhich ends with â. Otherwise we need to convert one of â-sequences to\r\nâ-sequence. The same works with characters â. So, when we donât need to\r\ncreate the new sequence, we try to donât do that. And values in arrays\r\nand help us to determine the number of sequence we assign to each\r\ncharacter.And also, there is a cute proof of this solution from Gassa:\r\nlet be the difference between the number of â and the number of â on the\r\nprefix of of length . We claim that the answer is and letâs show why is\r\nit true. Letâs build a function on a plane with points . Then we can\r\nmatch each between and with some subsequence.\r\n",
    "hint": []
}