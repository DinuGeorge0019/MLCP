{"link": "https://codeforces.com//contest/1118/problem/C", "problemId": "300357", "problem_idx": "C", "shortId": "1118C", "contest_number": "1118", "problem_submissions": {"E": [50187972, 50178585, 50177854, 50187885, 50190255, 50191148, 50185548, 50187581, 50187155, 50189680, 50192489, 50176894, 50191143, 50188012, 50189444, 50186952, 50192839, 50194191, 50192878, 50194811, 50194112], "F1": [50184628, 50182187, 50182069, 50185126, 50186144, 50175246, 50268639, 50268627, 50268547, 50268534, 50268507, 50268495, 50268478, 50177703, 50177673, 50189880, 50187751, 50178618, 50180765, 50182959, 50195988, 50179367, 50193234, 50188527, 50175539, 50191073, 50183885, 50182277], "C": [50180516, 50189313, 50189314, 50174569, 50182199, 50186326, 50196284, 50176517, 50179801, 50190327, 50186281, 50179237, 50179193, 50195343, 50178816, 50179289, 50198041, 50178779, 50215543, 50180475, 50179046], "D1": [50173332, 50175414, 50179356, 50180631, 50185124, 50180428, 50182811, 50183080, 50182930, 50182441, 50190772, 50187897, 50183718, 50184678, 50183560, 50184764, 50183014, 50185852, 50188218, 50190752], "D2": [50173254, 50175301, 50179259, 50186552, 50187970, 50180477, 50182733, 50182917, 50182838, 50182532, 50190661, 50187874, 50183954, 50184600, 50183758, 50184505, 50183208, 50185955, 50185683, 50189545, 50190850], "B": [50171883, 50174314, 50178899, 50169507, 50171162, 50173488, 50172475, 50172202, 50172480, 50172037, 50171388, 50171487, 50171892, 50174620, 50175080, 50173570, 50171467, 50173112, 50174638, 50174514], "A": [50167992, 50168657, 50171109, 50166868, 50167018, 50167896, 50168002, 50167192, 50167986, 50168375, 50170469, 50167469, 50167941, 50167556, 50168146, 50168540, 50168781, 50167258, 50168367, 50169680]}, "name": "C. Palindromic Matrix", "statement": "Let\u2019s call some square matrix with integer values in its cells if it\r\ndoesn\u2019t change after the order of rows is reversed and it doesn\u2019t change\r\nafter the order of columns is reversed.For example, the following\r\nmatrices are : The following matrices are because they change after the\r\norder of rows is reversed: The following matrices are because they\r\nchange after the order of columns is reversed: You are given n^2\r\nintegers. Put them into a matrix of n rows and n columns so that each\r\nnumber is used exactly once, each cell contains exactly one number and\r\nthe resulting matrix is . If there are multiple answers, print any. If\r\nthere is no solution, print \"\".\r\n", "solutions": ["#include<bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\nusing namespace std;\n\n// #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n\nvector <ll> v,d;\nll cnt[1005],mat[22][22];\n\nll fep(ll x, ll y, ll mod)\n{ll res=1;while(y>0){if(y&1)res=(res*x)%mod;\n    y=y>>1;x=(x*x)%mod;}return res%mod;}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\n\tll n,i,j,x,y,a,b,req=0,k;\n\tstring s;\n\t\n\tcin >> n;\n\tfor(i=0;i<n*n;i++)\n\t{\n\t\tcin >> x;\n\t\tcnt[x]++;\n\t\tv.pb(x);\n\t}\n\tif(n==1)\n\t{\n\t\tcout << \"Yes\" << endl << x;\n\t\treturn 0;\n\t}\n\tfor(i=0;i<n;i++)\n\t\tfor(j=0;j<n;j++)\n\t\t\tmat[i][j]=-1;\n\tif(n%2==1)\n\t\tfor(i=1;i<=1000;i++)\n\t\t\tif(cnt[i]%2==1)\n\t\t\t{\n\t\t\t\tcnt[i]--;\n\t\t\t\tmat[n/2][n/2]=i;\n\t\t\t}\n\tfor(i=1;i<=1000;i++)\n\t\tif(cnt[i]>1 && (cnt[i]-2)%4==0)\n\t\t\td.pb(i);\n\tif(n%2==1)\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\ti=n/2;\n\t\t\tif(mat[i][j]!=-1)\n\t\t\t\tcontinue;\n\t\t\tif(d.empty())\n\t\t\t\tfor(k=1;k<=1000;k++)\n\t\t\t\t\tif(cnt[k]>0 && (cnt[k]-2)%4==0)\n\t\t\t\t\t\td.pb(k);\n\t\t\tif(d.empty())\n\t\t\t\tfor(k=1;k<=1000;k++)\n\t\t\t\t\tif(cnt[k]>0 && cnt[k]%2==0)\n\t\t\t\t\t\td.pb(k);\n\t\t\tif(d.empty())\n\t\t\t{\n\t\t\t\tcout << \"No\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmat[n/2][j]=mat[n/2][n-j-1]=d.back();\n\t\t\tcnt[d.back()]-=2;\n\t\t\td.pop_back();\n\t\t\td.clear();\n\t\t}\n\tif(n%2==1)\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\ti=n/2;\n\t\t\tif(mat[j][i]!=-1)\n\t\t\t\tcontinue;\n\t\t\tif(d.empty())\n\t\t\t\tfor(k=1;k<=1000;k++)\n\t\t\t\t\tif(cnt[k]>0 && (cnt[k]-2)%4==0)\n\t\t\t\t\t\td.pb(k);\n\t\t\tif(d.empty())\n\t\t\t\tfor(k=1;k<=1000;k++)\n\t\t\t\t\tif(cnt[k]>0 && cnt[k]%2==0)\n\t\t\t\t\t\td.pb(k);\n\t\t\tif(d.empty())\n\t\t\t{\n\t\t\t\tcout << \"No\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmat[j][n/2]=mat[n-j-1][n/2]=d.back();\n\t\t\tcnt[d.back()]-=2;\n\t\t\td.pop_back();\n\t\t\td.clear();\n\t\t}\n//\tcout << \"er\";\n\td.clear();\n\tfor(k=1;k<=1000;k++)\n\t\tif(cnt[k]>0 && cnt[k]%4==0)\n\t\t\td.pb(k);\n\t\t\t\n//\tfor(i=0;i<d.size();i++)\n//\t\tcout << d[i] << \" \";\n\t\n\tfor(i=0;i<n;i++)\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\tif(mat[i][j]!=-1)\n\t\t\t\tcontinue;\n\t\t\tif(d.empty())\n\t\t\t\tfor(k=1;k<=1000;k++)\n\t\t\t\t\tif(cnt[k]>0 && cnt[k]%4==0)\n\t\t\t\t\t\td.pb(k);\n\t\t\tif(d.empty())\n\t\t\t{\n\t\t\t\tcout << \"No\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmat[i][j]=mat[n-i-1][j]=mat[i][n-j-1]=mat[n-i-1][n-j-1]=d.back();\n\t\t\tcnt[d.back()]-=4;\n\t\t\td.pop_back();\n\t\t}\n//\tcout << cnt[1] << \" \" << cnt[3] << endl;\n\tfor(i=0;i<n;i++)\n\t\tfor(j=0;j<n;j++)\n\t\t\tif(mat[i][j]==-1)\n\t\t\t{\n\t\t\t\tcout << \"No\";\n\t\t\t\treturn 0;\n\t\t\t}\n\tcout << \"Yes\" << endl;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "implementation"], "dificulty": "1700", "interactive": false}