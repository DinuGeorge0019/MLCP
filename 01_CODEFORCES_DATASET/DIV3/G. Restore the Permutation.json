{
    "link": "https://codeforces.com//contest/1759/problem/G",
    "problemId": "1648495",
    "problem_idx": "G",
    "shortId": "1759G",
    "contest_number": "1759",
    "problem_submissions": {
        "F": [
            181486431,
            181479495,
            181489489,
            181466769,
            181483185,
            181500440,
            181479543,
            181508353,
            181496922,
            181508604,
            181502097,
            181497795,
            181503761,
            181501121,
            181501100,
            182192682,
            181496069,
            181511199,
            181495619,
            181501990,
            181512733
        ],
        "G": [
            181470898,
            181483472,
            181480216,
            181488242,
            181502797,
            181484371,
            181507280,
            181493093,
            181484604,
            181488245,
            181490344,
            181510187,
            181485442,
            181512835,
            182192660,
            181500575,
            181492430,
            181509509,
            181504672,
            181446586,
            181490393
        ],
        "E": [
            181450176,
            181453080,
            181473014,
            181457235,
            181548790,
            181548755,
            181473778,
            181464085,
            181473138,
            181449179,
            181478384,
            181476879,
            181463313,
            181471764,
            181473740,
            181474544,
            181476651,
            182192601,
            181478540,
            181483700,
            181477015,
            181481741,
            181472562
        ],
        "D": [
            181443496,
            181444277,
            181441833,
            181437034,
            181457789,
            181451248,
            181439090,
            181453349,
            181472631,
            181466901,
            181447966,
            181451433,
            181466503,
            181456985,
            182192572,
            181463756,
            181472096,
            181464200,
            181477006,
            181465670
        ],
        "C": [
            181435248,
            181438210,
            181438160,
            181482829,
            181440135,
            181444414,
            181434276,
            181441512,
            181453016,
            181445968,
            181476131,
            181438815,
            181451647,
            181444648,
            182192589,
            181451437,
            181447044,
            181435084,
            181471203,
            181450921
        ],
        "B": [
            181429291,
            181432153,
            181430076,
            181428597,
            181432762,
            181432848,
            181428082,
            181432814,
            181439780,
            181430739,
            181437168,
            181430902,
            181432277,
            181435548,
            182192550,
            181441779,
            181435486,
            181429956,
            181463543,
            181435148
        ],
        "A": [
            181427407,
            181427808,
            181427983,
            181427097,
            181427278,
            181428509,
            181430809,
            181428221,
            181434045,
            181429427,
            181427311,
            181428005,
            181429365,
            182192516,
            181435730,
            181429174,
            181427774,
            181455253,
            181429200
        ]
    },
    "name": "G. Restore the Permutation",
    "statement": "A sequence of n numbers is called if it contains all numbers from 1 to n\r\nexactly once. For example, the sequences [3, 1, 4, 2], [1] and [2,1] are\r\npermutations, but [1,2,1], [0,1] and [1,3,4] are not.For a permutation p\r\nof even length n you can make an array b of length\r\nfrac{n}{2} such that: b_i =\r\nmax(p_{2i - 1}, p_{2i}) for 1\r\nle i\r\nle\r\nfrac{n}{2} For example, if p = [2, 4, 3, 1, 5, 6], then: b_1 =\r\nmax(p_1, p_2) =\r\nmax(2, 4) = 4 b_2 =\r\nmax(p_3, p_4) =\r\nmax(3,1)=3 b_3 =\r\nmax(p_5, p_6) =\r\nmax(5,6) = 6 As a result, we made b = [4, 3, 6].For a given array b,\r\nfind the permutation p such that you can make the given array b from\r\nit.If b = [4,3,6], then the lexicographically minimal permutation from\r\nwhich it can be made is p = [1,4,2,3,5,6], since: b_1 =\r\nmax(p_1, p_2) =\r\nmax(1, 4) = 4 b_2 =\r\nmax(p_3, p_4) =\r\nmax(2, 3) = 3 b_3 =\r\nmax(p_5, p_6) =\r\nmax(5, 6) = 6 A permutation x_1, x_2,\r\ndots, x_n is lexicographically smaller than a permutation y_1, y_2\r\ndots, y_n if and only if there exists such i (1\r\nle i\r\nle n) that x_1=y_1, x_2=y_2,\r\ndots, x_{i-1}=y_{i-1} and x_i<y_i.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');\n}\n\nconst int N = 400400;\nint tree[N * 4];\n\nint get_min(int l, int r, int v, int tl, int tr) {\n    //вариант 1\n    if (l <= tl && tr <= r) {\n        return tree[v];\n    }\n\n    //вариант 2\n    if (tr < l || r < tl) {\n        return 0;\n    }\n\n    //вариант 3\n    int tm = (tl + tr) / 2;\n    return max(get_min(l, r, v * 2 + 1,     tl,     tm),    //минимум вместо суммы.\n               get_min(l, r, v * 2 + 2, tm + 1, tr));\n}\n\nvoid update(int idx, int val, int v, int tl, int tr) {\n    //вариант 1\n    if (idx <= tl && tr <= idx) {       //То же, что и idx == tl == tr\n        tree[v] = val;\n        return;\n    }\n    //вариант 2\n    if (tr < idx || idx < tl) {\n        return;\n    }\n\n    int tm = (tl + tr) / 2;\n    update(idx, val, v * 2 + 1,     tl,     tm);\n    update(idx, val, v * 2 + 2, tm + 1, tr);\n    tree[v] = max(tree[v * 2 + 1], tree[v * 2 + 2]);    //минимум вместо суммы.\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    n /= 2;\n    int a[n];\n    vector<bool> bad(2 * n + 2);\n    vector<int> b(2 * n + 1);\n    for(int i = 1; i <= 2 * n; ++i) update(i, 0, 1, 1, 2 * n);\n    rep(i, n) {\n        cin >> a[i];\n        b[i * 2 + 1] = a[i],\n        bad[a[i]] = true;\n        update(a[i], i * 2 + 1, 1, 1, 2 * n);\n    }\n\n\n    for(int i = n * 2; i >= 1; --i) {\n        if(bad[i]) continue;\n        int d = get_min(i, 2 * n, 1, 1, 2 * n);\n        if(d == 0) {\n            cout << -1 << endl;\n            return;\n        }\n        int g = b[d];\n        b[d - 1] = i;\n        update(g, 0, 1, 1, 2 * n);\n    }\n    for(int i = 0; i < 2 * n; ++i) cout << b[i] << ' ';\n    cout << endl;\n}\n\nint main()\n{\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << \"Case #\" << i << \": \";\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Restore the Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/109254",
    "editorial": "First, letâs check the array for correctness, that is, that it has no\r\nrepeating elements.Then letâs look at the following ideas: each number\r\nmust be paired with another permutation element , with by the definition\r\nof array . Then, since we want a lexicographically minimal permutation,\r\nit is always more advantageous to put element before . for the\r\npermutation to be lexicographically minimal, the smallest possible\r\nnumbers must be placed at the beginning. Consequently, the largest\r\nnumbers must be placed at the end. Letâs proceed as follows: Letâs\r\nselect the set of numbers that are not included in the array. For an\r\nelement , find the maximum number of the set such that and put that\r\nnumber in front of the element . moving from the end of the array to its\r\nbeginning, each element will be matched with such an element. If at some\r\npoint can not be matched array is not composed correctly, and the answer\r\nto the query \"\". Otherwise, print \"\" and the resulting permutation .\r\n",
    "hint": []
}