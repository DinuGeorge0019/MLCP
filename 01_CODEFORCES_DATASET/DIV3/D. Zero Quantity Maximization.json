{
    "link": "https://codeforces.com//contest/1133/problem/D",
    "problemId": "308947",
    "problem_idx": "D",
    "shortId": "1133D",
    "contest_number": "1133",
    "problem_submissions": {
        "D": [
            50977706,
            50947355,
            100723482,
            50948843,
            50965152,
            50935620,
            50935134,
            50952860,
            50961383,
            50959922,
            50946976,
            50948619,
            50947073,
            50956907,
            50943195,
            50949460,
            50954635,
            50944647,
            50949611,
            50956624,
            50946681
        ],
        "F2": [
            50968854,
            50972022,
            50971221,
            50968366,
            50974597,
            50974087,
            50943311,
            50962568,
            51093176,
            50963051,
            50977549,
            50968954,
            51769081,
            50977124
        ],
        "F1": [
            50959078,
            50955230,
            50953315,
            50941907,
            50960168,
            50965272,
            50946141,
            50954816,
            50951285,
            50952154,
            50957023,
            50955812,
            50957050,
            50952531,
            50960906,
            50958622,
            50953869,
            50954476
        ],
        "E": [
            50952051,
            50961583,
            50962693,
            50951706,
            50964620,
            50954025,
            50954150,
            51032280,
            50963022,
            50950927,
            50972774,
            50964124,
            50963306,
            50964161,
            50960490,
            50966174
        ],
        "C": [
            50941353,
            50944201,
            50940430,
            50966196,
            50945464,
            50942925,
            50961788,
            50941100,
            50944821,
            50937379,
            50934514,
            50937910,
            50939090,
            50938244,
            50940255,
            50945217,
            50944371,
            50941409
        ],
        "B": [
            50938985,
            50941949,
            50938577,
            50961461,
            50942033,
            50940896,
            50965475,
            50936621,
            50942180,
            50948476,
            50938680,
            50936870,
            50936790,
            50935051,
            50937755,
            50941216,
            50940158,
            50939408
        ],
        "A": [
            50935306,
            50937849,
            50935030,
            50945613,
            51260785,
            50935398,
            50937671,
            50967123,
            50933770,
            50933763,
            50935392,
            50934515,
            50935161,
            50934233,
            50933760,
            50935141,
            50934723,
            50937065,
            50936471
        ]
    },
    "name": "D. Zero Quantity Maximization",
    "statement": "You are given two arrays a and b, each contains n integers.You want to\r\ncreate a new array c as follows: choose some real (i.e. not necessarily\r\ninteger) number d, and then for every i\r\nin [1, n] let c_i := d\r\ncdot a_i + b_i.Your goal is to maximize the number of zeroes in array c.\r\nWhat is the largest possible answer, if you choose d optimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define INF 9223372036854775807\n#define M_PI 3.14159265358979323846\n\nint mod = INF;\n\nint fastPow(int b, int e){int r = 1;while(e){if(e%2 == 1){r*=b;r%=mod;}b*=b;b%=mod;e/=2;}return r;}\nint pgcd(int a, int b){ if(a%b == 0) return b; else return pgcd(b, a%b);}\nint sign(int a){if(a < 0){ return -1;}if(a == 0) {return 0;}return 1;}\nbool isPrime(int a){if(a == 1) {return false;}int f = sqrt(a);for(int i = 2; i<=f; i++){if(a%i == 0){return false;}}return true;}\nint toInt(string s){int tot = 0;for(int i = s.size()-1; i >= 0; i--){tot+=((s[i]-'0')%mod)*fastPow(10,i);tot%=mod;}return tot;}\nstring toString(int a){string s = \"\";while(a){s = (char)('0'+a%10) + s;a/=10;}return s;}\n\npair<int, int> irrect(int a, int b){\n    int c = pgcd(a,b);\n    return make_pair(a/c,b/c);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector< int > a(n);\n    vector< int > b(n);\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < n; i++){\n        cin >> b[i];\n    }\n    map< pair<int, int> , int > occ;\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n        if(a[i] == 0){\n            if(b[i] == 0) ans++;\n            continue;\n        }\n        occ[irrect(b[i],a[i])]++;\n    }\n    int answer = 0;\n    for(auto c : occ){\n        answer = max(answer, c.second);\n    }\n    cout << ans+answer << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "math",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Zero Quantity Maximization.json",
    "editorial_link": "https://codeforces.com//blog/entry/65807",
    "editorial": "For each index letâs try to find which we should use in order to make\r\n-th element of equal to zero.If , then no matter which we choose. So we\r\nshould just ignore this index and add to the answer if .Otherwise, we\r\nshould choose . Letâs calculate the required fraction for each index,\r\nand among all fractions find one that fits most indices (this can be\r\ndone, for example, by storing all fractions in a ).The only thing thatâs\r\nleft to analyze is how to compare the fractions, because floating-point\r\nnumbers may be not precise enough. Letâs store each fraction as a pair\r\nof integers , where is the numenator and is the denominator. We should\r\nnormalize each fraction as follows: firstly, we reduce it by finding the\r\ngreatest common divisor of and , and then dividing both numbers by this\r\ndivisor. Secondly, we should ensure that numenator is non-negative, and\r\nif numenator is zero, then denominator should also be non-negative (this\r\ncan be achieved by multiplying both numbers by ).\r\n",
    "hint": []
}