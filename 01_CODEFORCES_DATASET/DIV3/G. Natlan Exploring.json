{
    "link": "https://codeforces.com//contest/2037/problem/G",
    "problemId": "3030280",
    "problem_idx": "G",
    "shortId": "2037G",
    "contest_number": "2037",
    "problem_submissions": {
        "E": [
            292047075,
            292001485,
            292009292,
            291996476,
            292062011,
            292051813,
            292265678,
            292262203,
            292192703,
            292071302,
            292070663,
            291999780,
            292064784,
            292052672,
            292050626,
            292052922,
            292071828,
            291992209,
            292000170,
            291988756,
            292008406,
            292007324
        ],
        "F": [
            292022218,
            292017907,
            292024969,
            292058791,
            292012459,
            292558370,
            292027964,
            292322779,
            292083202,
            292025710,
            292058305,
            292053924,
            292057524,
            292098039,
            292062013,
            292058405,
            292072247,
            292041262,
            291975958,
            292082628,
            292078164,
            292082635,
            292046600
        ],
        "G": [
            291996486,
            292046822,
            292051239,
            292033736,
            292022807,
            292088543,
            292046321,
            292046301,
            292015442,
            292027681,
            292033325,
            292031649,
            292030485,
            292058022,
            292068187,
            292049914,
            292058005,
            292018113,
            291981788,
            292025943,
            292032506,
            292023447,
            292184893
        ],
        "D": [
            291973736,
            291988212,
            291992996,
            291979703,
            291998834,
            291983903,
            292002713,
            292029295,
            291999646,
            291984954,
            292024081,
            292031106,
            291991931,
            291978485,
            292010279,
            291980815,
            291970955,
            291981313,
            291985613
        ],
        "C": [
            291961505,
            291975167,
            291974207,
            291964672,
            291977153,
            291965604,
            291972603,
            291985859,
            291958605,
            291975659,
            291971736,
            292051709,
            291965196,
            293681954,
            291964838,
            291966108,
            291957366,
            291965128,
            291970402
        ],
        "B": [
            291956714,
            291952988,
            291957798,
            291954795,
            291952360,
            291952928,
            291957139,
            291960930,
            291959780,
            291972890,
            291956311,
            291964398,
            291952930,
            291955364,
            291953325,
            291955467,
            291951893,
            291958231,
            291957803
        ],
        "A": [
            291948750,
            291945793,
            291946764,
            291946202,
            291945511,
            291946198,
            291946444,
            291950431,
            291945465,
            291953437,
            291945736,
            291948815,
            291947311,
            291946698,
            291949011,
            291949226,
            291946064,
            291945840,
            291951387
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136334",
    "editorial": "Denote dp[i]=\n the number of ways to get to city i\n. Brute-forcing all possible previous cities is out of the question, as this solution will take O(n2?log(maxai))\n time complexity. What else can we do?\n\nInstead, consider caseworking on what the greatest common factor can be. Let's keep track of an array count\n which for index i\n keeps track of the sum of dp\n values of all previous cities who has a factor of i\n. Say the current city has attractiveness ai\n. We can almost recover dp[i]\n by adding up the count\n values of all factors of ai\n. Unfortunately, this fails as it overcounts many instances. For example, if gcd(ai,aj)=12\n the dp\n state from i\n will be counted five times: 2,3,4,6,12\n.\n\nNote that we don't actually care what the greatest common factor is, since the only requirement is that the greatest common factor is not 1\n. This also means that repeat appearances of the same prime number in the factorization of ai\n doesn't matter at all \u0097 we can assume each prime factor occurs exactly once. Now, if gcd(ai,aj)=12\n, it is only counted three times: 2,3,6\n. Now, instead of blindly adding the count\n values from all previous states, let's instead apply the Principle of Inclusion-Exclusion on the prime factors. Let's first add the count\n values from all prime factors, then subtract the count\n values from all factors with two prime factors, then add the count\n values from all factors with three prime factors, and so on. It can be seen that actually, the value is only counted one time now.\n\nSo what's the time complexity of this solution? Precomputing the set of all prime number takes O(max(ai)log(max(ai)))\n time (by the harmonic series n1+n2+\u0085+nn?nlog(n)\n). For each number ai\n, we have to consider all 2f(ai)\n subsets of prime factors, where f(ai)\n is the number of prime factors of ai\n. The number with the most distinct prime factors is 510510=2?3?5?7?11?13?17\n, so worst case 27=128\n operations are needed per number. This goes to a total operation count of approximately 128?n\n which will pass in the time limit.\n\nNote that we may also use the Mobius function to compute the answer. The Mobius function's properties makes it utilize the Principle of Inclusion-Exclusion efficiently. The time complexity of this solution is O(max(ai)log(max(ai))+nmax(d(ai)))\n where d(ai)\n is the maximum number of factors of ai\n. This time complexity can be shown to be the same as the above time complexity.",
    "name": "G. Natlan Exploring",
    "statement": "You are exploring the stunning region of Natlan! This region consists of\r\nn cities, and each city is rated with an attractiveness a_i. A directed\r\nedge exists from City i to City j if and only if i < j and\r\ngcd(a_i,a_j)\r\nneq 1, where\r\ngcd(x, y) denotes the greatest common divisor (GCD) of integers x and\r\ny.Starting from City 1, your task is to determine the total number of\r\ndistinct paths you can take to reach City n, modulo 998\r\n,244\r\n,353. Two paths are different if and only if the set of cities visited\r\nis different.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0#define int long long#define fi first#define se second\u00a0const int N = 1e6 + 5;const int K = 1e2 + 5;const int mod = 998244353;\u00a0#define all(v) (v).begin(), (v).end()#define pii pair<int, int> \u00a0using namespace std;\u00a0mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());\u00a0int n;int d[N];long long dp[N], f[N];vector<int> v;\u00a0signed main() {    ios_base::sync_with_stdio(0);    cin.tie(0);        if(ifstream(\"file.inp\")){    \tfreopen(\"file.inp\", \"r\", stdin);    \tfreopen(\"file.out\", \"w\", stdout);    }        cin >> n;    for(int i = 1; i <= 1e6; i++) d[i] = i;    for(int i = 2; i * i <= 1e6; i++) {    \tif(d[i] == i) {    \t\tfor(int j = i * i; j <= 1e6; j += i) {    \t\t\td[j] = i;    \t\t}    \t}    }    dp[1] = 1;    for(int i = 1; i <= n; i++) {    \tint x;    \tcin >> x;    \tv.clear();    \twhile(x > 1) {    \t\tint y = d[x];    \t\twhile(x % y == 0) x /= y;    \t\tv.push_back(y);    \t}    \tfor(int m = 1; m < (1 << (int)v.size()); m++) {    \t\tint prod = 1;    \t\tfor(int j = 0; j < v.size(); j++) {    \t\t\tif(m >> j & 1) prod *= v[j];    \t\t}    \t\tdp[i] = (dp[i] + (__builtin_popcount(m) % 2 == 0 ? -1 : 1) * f[prod] + mod) % mod;    \t}    \tfor(int m = 1; m < (1 << (int)v.size()); m++) {    \t\tint prod = 1;    \t\tfor(int j = 0; j < v.size(); j++) {    \t\t\tif(m >> j & 1) prod *= v[j];    \t\t}    \t\tf[prod] = (f[prod] + dp[i]) % mod;    \t}    }    cout << dp[n] << '\\n';        return 0;}\u00a0// tuntun"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "data structures",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Natlan Exploring.json"
}