{
    "link": "https://codeforces.com//contest/2033/problem/B",
    "problemId": "2975318",
    "problem_idx": "B",
    "shortId": "2033B",
    "contest_number": "2033",
    "problem_submissions": {
        "G": [
            287783597,
            287787317,
            287795296,
            287783544,
            287803395,
            287748588
        ],
        "F": [
            287734852,
            287757040,
            287770540,
            287746378,
            287737617,
            287721257,
            287731364,
            287728898,
            287736216,
            287726597,
            287760471,
            287735582,
            287745631,
            287765424,
            287758074,
            287757377
        ],
        "E": [
            287718822,
            287738936,
            287751473,
            287738616,
            287715701,
            287703053,
            287722294,
            287724450,
            287723369,
            287719082,
            287731217,
            287727237,
            287801474,
            287714838,
            287735421,
            287716075,
            287729261,
            287727022
        ],
        "D": [
            287714983,
            287722085,
            287725450,
            287786370,
            287704734,
            287697239,
            287717412,
            287703434,
            287716864,
            287711396,
            287716556,
            287711480,
            292117815,
            287700070,
            287697469,
            287708922,
            287710949,
            287714668
        ],
        "C": [
            287710403,
            287713243,
            287708606,
            287801241,
            287699249,
            287754903,
            287711963,
            287742947,
            287707327,
            287728851,
            287705447,
            287701326,
            287753754,
            287722810,
            287701449,
            287701636,
            287702465
        ],
        "B": [
            287685440,
            287691876,
            287694502,
            287793205,
            287688586,
            287691395,
            287699888,
            287686533,
            287697947,
            287689283,
            287692659,
            287694883,
            287690951,
            287686973,
            287695322,
            287690158,
            287695612
        ],
        "A": [
            287681823,
            287680676,
            287682117,
            287787767,
            287680966,
            287680751,
            287692822,
            287680041,
            287683508,
            287679831,
            287683966,
            287684935,
            287683948,
            287680083,
            287685508,
            287682640,
            287681996
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135520",
    "editorial": "In this task we were supposed to find the minimal possible amount of\r\nmoves that Sakurako needs to make in order to make all elements in the\r\nmatrix non-negative. The key observation is to notice that Sakurako can\r\nonly add simultaneously to elements that lay on one diagonal. For cell ,\r\nlet the \"index\" of diagonal which it is placed on is equal to . This is\r\nproven by the fact that for and the equation holds.We are able to add to\r\na pair of elements and simultaneously if and only if .From this we can\r\nreduce our problem to finding the amount of times that we need to add 1\r\nto this diagonal in order for all of its elements to become\r\nnon-negative.For each diagonal we find the minimal element in it and\r\nthere will be two cases: 1. The minimal element is non-negative: we\r\ndon\u00e2\u0080\u0099t need to add anything to that diagonal.2. The minimal element is\r\nnegative and equal to : we will need to add one at least times (remember\r\nthat is negative). After that, the answer for our task is the sum of\r\nanswers for each individual diagonal.Total time complexity\r\n",
    "name": "B. Sakurako and Water",
    "statement": "During her journey with Kosuke, Sakurako and Kosuke found a valley that\r\ncan be represented as a matrix of size n\r\ntimes n, where at the intersection of the i-th row and the j-th column\r\nis a mountain with a height of a_{i,j}. If a_{i,j} < 0, then there is a\r\nlake there.Kosuke is very afraid of water, so Sakurako needs to help\r\nhim: With her magic, she can select a square area of mountains and\r\nincrease the height of each mountain on the main diagonal of that area\r\nby exactly one. More formally, she can choose a submatrix with the upper\r\nleft corner located at (i, j) and the lower right corner at (p, q), such\r\nthat p-i=q-j. She can then add one to each element at the intersection\r\nof the (i + k)-th row and the (j + k)-th column, for all k such that 0\r\nle k\r\nle p-i.Determine the minimum number of times Sakurako must use her magic\r\nso that there are no lakes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/rope>\u00a0using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;\u00a0// /*//                                                //////////**DEFINES - START**//////////\u00a0#define ret return#define fi first#define se second#define mp make_pair#define all(x) x.begin(), x.end()#define be(x) x.begin()#define en(x) x.end()#define sz(x) ll(x.size())#define for0(i, n) for (ll   i = 0; i < (n); ++i)#define for1(i, n) for (ll   i = 1; i < (n); ++i)#define rfor0(i, n) for (ll   i = (n) - 1; i >= 0; --i)#define rfor1(i, n) for (ll   i = (n) - 1; i >= 1; --i)#define rep(i, a, n) for (ll   i = a; i < ll(n); ++i)#define rrep(i, a, n) for (ll   i = a - 1; i >= ll(n); --i)#define popcount __builtin_popcount#define popcountll __builtin_popcountll#define fastIO() ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);#define con continue#define pb push_back#define pob pop_back#define deb(x) cout << (#x) << \" is \" << (x) << endl#define ins insert#define len(s) (s).length()#define gi greater<int>()#define gll greater<ll  >()#define gstr greater<string>()#define gpll greater<pair<ll  , ll  >>()#define rast(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))#define rev reverse#define ub upper_bound#define lb lower_bound#define bs binary_search#define rs resize#define last(a) a.back()#define co count#define ba(a) a.back()#define um unordered_map#define rsun(a) a.resize(unique(a.begin(), a.end())-a.begin())#define endl '\\n'#ifdef OG_Matveychick1bool local = true;#elsebool local = false;#endif\u00a0//                                                \\\\\\\\\\\\\\\\\\\\**DEFINES - END**\\\\\\\\\\\\\\\\\\\\// */\u00a0// /*//                                                //////////**TYPEDEFS - START**//////////\u00a0typedef vector<int> vi;typedef vector<vi> vvi;typedef vector<char> vc;typedef pair<int, int> pii;typedef vector<pii> vpii;typedef vector<string> vs;typedef long long ll;typedef unsigned long long ull;typedef vector<ull> vull;typedef pair<ll, ll> pll;typedef vector<ll> vll;typedef vector<pll> vpll;typedef pair<double, double> pdd;typedef double ld;typedef double D;typedef vector<ld> vld;typedef vector<pair<ld, ld>>        vpld;typedef string str;typedef set<ll> sll;typedef set<int> si;typedef set<str> ss;typedef set<pii> spii;typedef multiset<int> msi;typedef multiset<ll> msll;typedef multiset<str> mss;typedef multiset<pii> mspii;typedef multiset<pll> mspll;typedef map<str, str> mps;typedef map<int, int> mpi;typedef map<ll, ll> mpll;typedef map<int, vi> mpvi;typedef map<int, vll> mpvll;typedef map<char, int> mpci;typedef multimap<ll, ll> mmpll;typedef multimap<str, str> mmps;typedef multimap<int, int> mmpi;typedef vector<vector<int>> vvi;typedef vector<vector<ll>> vvll;typedef vector<vector<long double>> vvld;typedef vector<vvi> vvvi;typedef vector<vector<char>> vvc;typedef vector<vs> vvs;typedef vector<D> vD;typedef set<pair<ll, ll>>        spll;typedef pair<ull, ull> pull;typedef vector<pull> vpull;typedef vector<bool> vb;typedef vector<vb> vvb;typedef set<char> sc;typedef queue<int> qi;typedef queue<ll> qll;typedef queue<bool> qb;typedef vector<sll> vsll;typedef queue<pair<ll, ll>>        qpll;typedef vector<vector<pair<int, int>>>        vvpii;typedef vector<vector<pair<ll, ll>>>        vvpll;typedef vector<spll> vspll;typedef multiset<char> msc;typedef queue<str> qs;typedef vector<set<int>> vsi;typedef priority_queue<ll> pqll;typedef vector<vsll> vvsll;typedef pair<ld, ld> pld;typedef vector<vvll> vvvll;typedef set<ld> sld;typedef vector<vpld> vvpld;typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_set;typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_multiset;\u00a0//                                                \\\\\\\\\\\\\\\\\\\\**TYPEDEFS - END**\\\\\\\\\\\\\\\\\\\\// */\u00a0\u00a0// /*//                                                //////////**CONSTANTS - START**//////////\u00a0constexpr long double pi = 3.141592653589793238462643383279;const ll mod1 = 1e9 + 7;const ll mod2 = 998244353;const ll MAXLL = 9223372036854775807;//const ll MAXINT = 2147483647;const long double eps = 1e-9;\u00a0//                                                \\\\\\\\\\\\\\\\\\\\**CONSTANTS - END**\\\\\\\\\\\\\\\\\\\\// */\u00a0\u00a0// /*//                                                //////////**TEMPLATES - START**//////////\u00a0\u00a0template<typename T>istream &operator>>(istream &in, vector<T> &a) {    for (T &i : a) in >> i;    return in;}\u00a0template<typename T1, typename T2>istream &operator>>(istream &in, pair<T1, T2> &a) {    in >> a.fi >> a.se;    return in;}\u00a0template<typename T1, typename T2>ostream &operator<<(ostream &out, pair<T1, T2> &a) {    out << a.fi << \" \" << a.se;    return out;}\u00a0template<typename T1, typename T2>istream &operator>>(istream &in, vector<pair<T1, T2>>\u00a0&a) {    for (        pair<T1, T2> &i            : a)        in >> i.fi >> i.                se;    return            in;}\u00a0template<typename T>ostream &operator<<(ostream &out, const vector<T> &a) {    for (auto i : a) {        out << i << \" \";    }    return out;}\u00a0template<typename T1, typename T2>ostream &operator<<(ostream &out, vector<pair<T1, T2>>\u00a0&a) {    for (        pair<T1, T2> i            : a)        out << i.fi << \" \" << i.se <<            endl;    return            out;}\u00a0template<typename T1>ostream &operator<<(ostream &out, vector<vector<T1>> &a) {    for (vector<T1> i : a) {        for (T1 j : i) out << j << \" \";        out << endl;    }    return out;}\u00a0template<typename T1, typename T2>inline T1 min(T1 a, T2 b) {    b = (T1) b;    return a > b ? b : a;}\u00a0template<typename T1, typename T2>inline T1 max(T1 a, T2 b) {    b = (T1) b;    return a > b ? a : b;}\u00a0template<typename T1, typename T2>inline void amin(T1 &a, T2 b) {    a = min(a, b);}\u00a0template<typename T1, typename T2>inline void amax(T1 &a, T2 b) {    a = max(a, b);}\u00a0\u00a0//                                                \\\\\\\\\\\\\\\\\\\\**TEMPLATES - END**\\\\\\\\\\\\\\\\\\\\// */\u00a0\u00a0// This bear is a good alternative to duck!!!/*    ????      ??????  ??????????????????? ????????????????  ??????   ???????????  ??????  ???????????? ?? ??????????????????   ??????????????? ?   ?????????????????   ???????   ???    ??    ????  ??????????     ????     ?? ???   ???????????? ?????  ???????????????????? ????????   ??  ??????? ???????         ????? */\u00a0\u00a0double getTime() {    return clock() / (double) CLOCKS_PER_SEC;}\u00a0\u00a0mt19937_64 rn(chrono::steady_clock::now().time_since_epoch().count());//mt19937_64 rn(4);\u00a0ll rnd(ll l, ll r) {    ll a = rn() % (r - l + 1) + l;    return a;}\u00a0void solve();\u00a0ll T = 1;\u00a0signed main(int argc, char **argv) {    setlocale(LC_ALL, \"RUS\");    fastIO()    cout.precision(12);    cout << fixed;    if (local && argc == 1) {        freopen(\"input.txt\", \"r\", stdin);//        freopen(\"002.out\", \"w\", stdout);    }    cin >> T;    while (T--) {        solve();    }    if (local && argc == 1) {        cout << endl << fixed << \"time = \" << getTime();    }    return 0;}\u00a0\u00a0/*    ___        __              __   ______          __        _____ __             __          __  __   /   | _____/ /___  ______ _/ /  / ____/___  ____/ /__     / ___// /_____ ______/ /______   / / / /__  ________  / /| |/ ___/ __/ / / / __ `/ /  / /   / __ \\/ __  / _ \\    \\__ \\/ __/ __ `/ ___/ __/ ___/  / /_/ / _ \\/ ___/ _ \\ / ___ / /__/ /_/ /_/ / /_/ / /  / /___/ /_/ / /_/ /  __/   ___/ / /_/ /_/ / /  / /_(__  )  / __  /  __/ /  /  __//_/  |_\\___/\\__/\\__,_/\\__,_/_/   \\____/\\____/\\__,_/\\___/   /____/\\__/\\__,_/_/   \\__/____/  /_/ /_/\\___/_/   \\___/*/\u00a0\u00a0\u00a0\u00a0void solve() {    ll n;    cin >> n;    vvll a(n, vll(n));    cin >> a;    map<ll, ll> ma;    for0(i, n)for0(j, n) amin(ma[i - j], a[i][j]);    ll ans = 0;    for (auto [xxx, x] : ma)ans -= x;    cout << ans << endl;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Sakurako and Water.json"
}