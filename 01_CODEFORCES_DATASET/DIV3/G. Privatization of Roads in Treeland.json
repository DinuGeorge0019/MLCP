{
    "link": "https://codeforces.com//contest/1141/problem/G",
    "problemId": "316177",
    "problem_idx": "G",
    "shortId": "1141G",
    "contest_number": "1141",
    "problem_submissions": {
        "G": [
            52739588,
            51536187,
            51534299,
            51525036,
            55748640,
            98770872,
            51606575,
            51605903,
            51550288,
            51562985
        ],
        "E": [
            51521056,
            51509494,
            51514700,
            51509864,
            51515343,
            51512067,
            51514136,
            51516742,
            51515279,
            51513645,
            51514418,
            51515657,
            51529830,
            51518938,
            51520757,
            51514193,
            51518496,
            51519253
        ],
        "F2": [
            51512804,
            51520813,
            51519468,
            51520462,
            51524714,
            51522819,
            51524615,
            51526867,
            51526388,
            51528287,
            51528610,
            51526942,
            51526833,
            51528921,
            51567579,
            51529733,
            51520266,
            51530585,
            51528159
        ],
        "F1": [
            51512586,
            51519520,
            51520037,
            51530962,
            51520861,
            51524235,
            51522340,
            51524194,
            51526191,
            51525945,
            51527775,
            51528063,
            51527052,
            51527343,
            51520158,
            51528384,
            51528375,
            51520780,
            51530653,
            51527810
        ],
        "D": [
            51504077,
            51500288,
            51507602,
            51497021,
            51498993,
            51505660,
            51501736,
            51504542,
            51504450,
            51505517,
            51507648,
            51506380,
            51507813,
            51509739,
            51507965,
            51506483,
            51503583,
            51507577,
            51514228
        ],
        "C": [
            51496498,
            51493212,
            51499078,
            51492880,
            51502608,
            51499584,
            51495627,
            51495976,
            51499494,
            51500075,
            51499041,
            51503297,
            51499022,
            51497246,
            51497075,
            51529270,
            51499224,
            51506668
        ],
        "B": [
            51489707,
            51490678,
            51493680,
            51489601,
            51492373,
            51494463,
            51492484,
            51490578,
            51491799,
            51494772,
            51492508,
            51496543,
            51490227,
            51491876,
            51492884,
            51490276,
            51493813,
            51493209
        ],
        "A": [
            51488460,
            51488637,
            51489458,
            51488560,
            51490651,
            51489465,
            51489640,
            51488837,
            51490105,
            51489577,
            51489271,
            51494436,
            51488528,
            51488619,
            51489959,
            51488566,
            51490539
        ]
    },
    "name": "G. Privatization of Roads in Treeland",
    "statement": "Treeland consists of n cities and n-1 roads. Each road is bidirectional\r\nand connects two distinct cities. From any city you can get to any other\r\ncity by roads. Yes, you are right the country\u2019s topology is an\r\nundirected tree.There are some private road companies in Treeland. The\r\ngovernment decided to sell roads to the companies. Each road will belong\r\nto one company and a company can own multiple roads.The government is\r\nafraid to look unfair. They think that people in a city can consider\r\nthem unfair if there is one company which owns two or more roads\r\nentering the city. The government wants to make such privatization that\r\nthe number of such cities doesn\u2019t exceed k and the number of companies\r\ntaking part in the privatization is minimal.Choose the number of\r\ncompanies r such that it is possible to assign each road to one company\r\nin such a way that the number of cities that have two or more roads of\r\none company is at most k. In other words, if for a city all the roads\r\nbelong to the different companies then the city is . Your task is to\r\nfind the minimal r that there is such assignment to companies from 1 to\r\nr that the number of cities which are not doesn\u2019t exceed k.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC optimize(\"section-anchors\")\n#pragma GCC optimize(\"profile-values,profile-reorder-functions,tracer\")\n#pragma GCC optimize(\"vpt\")\n#pragma GCC optimize(\"rename-registers\")\n#pragma GCC optimize(\"move-loop-invariants\")\n#pragma GCC optimize(\"unswitch-loops\")\n#pragma GCC optimize(\"function-sections\")\n#pragma GCC optimize(\"data-sections\")\n#pragma GCC optimize(\"branch-target-load-optimize\")\n#pragma GCC optimize(\"branch-target-load-optimize2\")\n#pragma GCC optimize(\"btr-bb-exclusive\")\n\n#include <bits/stdc++.h>\n\n#define ll int\n#define pb push_back\n\nusing namespace std;\n\nconst ll MAXN = 2e5 + 200;\n\nll n, k, kol;\nvector< vector<ll> > g(MAXN);\nll used[MAXN], bunt[MAXN];\nmap<pair<ll, ll>, ll> mp;\npair<ll, ll> num[MAXN];\n\nvoid bfs(ll v, ll color){\n    queue<pair<ll, ll> > q;\n    q.push({v, 0});\n    used[v] = 1;\n    ll clr;\n    while(!q.empty()){\n        v = q.front().first, clr = q.front().second;\n        q.pop();\n        ll cur = 1;\n        for(int i = 0; i < g[v].size(); ++i){\n            if(cur == clr) cur++;\n            ll to = g[v][i];\n            pair<ll, ll> p = {min(to, v), max(to, v)};\n            if(bunt[v] == 1 && mp[p] == 0){\n                mp[p] = 1;\n                if(!used[to]){\n                    used[to] = 1;\n                    q.push({to, 1});\n                }\n                continue;\n            }\n            if(mp[p] == 0){\n                mp[p] = cur;\n                if(!used[to]){\n                    used[to] = 1;\n                    q.push({to, cur});\n                }\n                cur++;\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n >> k;\n    for(int i = 0; i < n - 1; ++i){\n        ll u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n        num[i + 1] = {u, v};\n    }\n\n    vector<pair<ll, ll> > del;\n\n    for(int i = 1; i <= n; ++i){\n        del.pb({g[i].size(), i});\n    }\n\n    sort(del.begin(), del.end());\n    reverse(del.begin(), del.end());\n    for(int i = 0; i < k; ++i){\n        bunt[del[i].second] = 1;\n    }\n\n    kol = (k == n - 1 ? 1 : del[k].first);\n\n    bfs(1, 0);\n\n    cout << kol << '\\n';\n\n    for(int i = 1; i < n; ++i){\n        pair<ll, ll> p = {min(num[i].first, num[i].second), max(num[i].first, num[i].second)};\n        cout << mp[p] << ' ';\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Privatization of Roads in Treeland.json",
    "editorial_link": "https://codeforces.com//blog/entry/66062",
    "editorial": "Formally, the problem is to paint tree edges in minimal number of colors\r\nin such a way, the the number of improper vertices doesn\u00e2\u0080\u0099t exceed . A\r\nvertex is improper if it has at least two incident edges of the same\r\ncolor.It is easy to show that colors is always enough to paint a tree in\r\nsuch a way that all the vertices are proper, where is the maximum vertex\r\ndegree. Actually, it is always the truth do any bipartite graph.Indeed,\r\nif number of colors is less than the maximum degree, such vertices will\r\nhave at least two edges of the same color (Dirichlet\u00e2\u0080\u0099s principle). If\r\nequals the maximum degree, you can use just depth first search tree\r\ntraversal to paint edges in different colors.In this problem you can\r\nhave up to improper vertices, so just choose such minimal that number of\r\nvertices of degree greater than is at most . In an alternative solution,\r\nyou can use a binary search to find such , but it makes the\r\nimplementation harder and the solution becomes slower by factor.After it\r\npaint edges with colors, each time choosing the next color (skip color\r\nif it equals with the color of the traversal incoming edge).\r\n"
}