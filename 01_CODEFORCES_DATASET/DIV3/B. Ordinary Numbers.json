{
    "link": "https://codeforces.com//contest/1520/problem/B",
    "problemId": "976797",
    "problem_idx": "B",
    "shortId": "1520B",
    "contest_number": "1520",
    "problem_submissions": {
        "F2": [
            115377397,
            115305590,
            115287040,
            115299425,
            115275998,
            115291100,
            115279060,
            115289661,
            115284382,
            115289848,
            115308377,
            115278701,
            115306155,
            115291190,
            115265089,
            115307538,
            115303936,
            115461761,
            115294385,
            115296101
        ],
        "G": [
            115377372,
            115262775,
            115288422,
            115284069,
            115289230,
            115326140,
            115318505,
            115305519,
            115310728,
            115306048,
            115310484,
            115283392,
            115286859,
            115490380,
            115494255,
            115428029,
            115418593,
            115335990,
            115630972,
            115630383
        ],
        "F1": [
            115377349,
            115249032,
            115270195,
            115243368,
            115263879,
            115260580,
            115273435,
            115261038,
            115280609,
            115277317,
            115293876,
            115256261,
            115254859,
            115241348,
            115257133,
            115247327,
            115256409,
            115278650,
            115271950,
            115272669
        ],
        "E": [
            115377332,
            115237334,
            115239791,
            115237430,
            115247171,
            115242404,
            115248291,
            115250125,
            115252428,
            115257556,
            115318354,
            115247364,
            115240877,
            115248360,
            115247935,
            115237440,
            115241805,
            115254530,
            115253830,
            115256564
        ],
        "C": [
            115377311,
            115225774,
            115221824,
            115221195,
            115232319,
            115227403,
            115230041,
            115230111,
            115234657,
            115232187,
            115315640,
            115223231,
            115228100,
            115217322,
            115228063,
            115296150,
            115228425,
            115221440,
            115236900,
            115240483
        ],
        "D": [
            115377293,
            115218646,
            115225866,
            115229634,
            115238178,
            115231535,
            115237704,
            115234502,
            115238902,
            115239693,
            115238815,
            115228744,
            115221564,
            115219392,
            115231781,
            115227386,
            115230454,
            115232684,
            115243890,
            115245632
        ],
        "B": [
            115377281,
            115214791,
            115214878,
            115216679,
            115235400,
            115218148,
            115218189,
            115225076,
            115218800,
            115220311,
            115284747,
            115217692,
            115219291,
            115213196,
            115216288,
            115215912,
            115223513,
            115214573,
            115226157,
            115226244
        ],
        "A": [
            115377268,
            115212622,
            115212991,
            115213371,
            115214493,
            115214137,
            115213480,
            115215360,
            115213972,
            115213655,
            115216180,
            115212784,
            115213313,
            115212547,
            115212731,
            115213509,
            115217879,
            115212709,
            115218109,
            115218897
        ]
    },
    "name": "B. Ordinary Numbers",
    "statement": "Letâ€™s call a positive integer n ordinary if in the decimal notation all\r\nits digits are the same. For example, 1, 2 and 99 are ordinary numbers,\r\nbut 719 and 2021 are not ordinary numbers.For a given number n, find the\r\nnumber of ordinary numbers among the numbers from 1 to n.\r\n",
    "solutions": [
        "#include \"bits/extc++.h\"\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << \"L\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"]\" << \": \";       \\\nsep(cerr, \" | \", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl \"\\n\"\n\n#define sz(x) int((x).size())\n\nvector<int> ans;\n\nvoid pcomp() {\n\tfor(int i = 1; i < 10; i++) {\n\t\tstring s;\n\t\tfor(int j = 0; j < 9; j++) {\n\t\t\ts += to_string(i);\n\t\t\tans.push_back(stoi(s));\n\t\t}\n\t}\n\tsort(begin(ans), end(ans));\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tcout << upper_bound(begin(ans), end(ans), n) - ans.begin() << endl;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tpcomp();\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << \"Case #\" << _ << \": \";\n\t\tsolve();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Ordinary Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/90342",
    "editorial": "Note that every ordinary number can be represented as . Therefore, to\r\ncount all ordinary numbers among the numbers from to , it is enough to\r\ncount the number of pairs such that . In the given constraints, it is\r\nenough to iterate over from to and from to .\r\n",
    "hint": []
}