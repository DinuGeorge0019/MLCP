{
    "link": "https://codeforces.com//contest/999/problem/E",
    "problemId": "192344",
    "problem_idx": "E",
    "shortId": "999E",
    "contest_number": "999",
    "problem_submissions": {
        "E": [
            39482525,
            39480258,
            39480681,
            39472815,
            39481171,
            39483804,
            39482822,
            39487988,
            39486311,
            39488255,
            39483434,
            39476369,
            39475874,
            39475323,
            39478090,
            39485416,
            39483552,
            39485842,
            39478651
        ],
        "D": [
            39476985,
            39482714,
            39477867,
            39487661,
            39478808,
            39479957,
            39478688,
            39480079,
            39484369,
            39488043,
            39682317,
            39484150,
            39479480,
            39479981,
            39480905,
            39490327
        ],
        "F": [
            39474187,
            39476396,
            39486159,
            39480138,
            39488092,
            39484785,
            39487824,
            39489626,
            39479920,
            39488254,
            39490520,
            39472516,
            39481714,
            39495126,
            39494491,
            39484965,
            39486979,
            39528460,
            39528455,
            39509111
        ],
        "C": [
            39468293,
            39473877,
            39471032,
            39469713,
            39469003,
            39471817,
            39471185,
            39471833,
            39473032,
            39481734,
            39489064,
            39465485,
            39469355,
            39469432,
            39471841,
            39471812,
            39470774,
            39471323,
            39471302
        ],
        "B": [
            39466151,
            39472359,
            39467106,
            39467712,
            39466498,
            39469904,
            39468165,
            39469498,
            39470396,
            39480507,
            39490594,
            39469417,
            39466615,
            39467515,
            39469262,
            39469175,
            39469263,
            39468726
        ],
        "A": [
            39465278,
            39470703,
            39465116,
            39466655,
            39465297,
            39465892,
            39465427,
            39466410,
            39468368,
            39479548,
            39467417,
            39471284,
            39465152,
            39465656,
            39465454,
            39466984,
            39465563,
            39467221
        ]
    },
    "name": "E. Reachability from the Capital",
    "statement": "There are n cities and m roads in Berland. Each road connects a pair of\r\ncities. The roads in Berland are one-way.What is the minimum number of\r\nnew roads that need to be built to make all the cities reachable from\r\nthe capital?New roads will also be one-way.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl '\\n'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, m, s;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint cnt[MAXN], comp[MAXN];\nbool used[MAXN];\n\nbool read() {\n    if (!(cin >> n >> m >> s))\n        return false;\n\n    forn (i, m) {\n        int u, v;\n        cin >> u >> v;\n        g1[u - 1].push_back(v - 1);\n        g2[v - 1].push_back(u - 1);\n    }\n\n    return true;\n}\n\nvector<int> order, vv;\n\nvoid dfs1(int v) {\n    used[v] = true;\n\n    for (auto to : g1[v])\n        if (!used[to])\n            dfs1(to);\n\n    order.push_back(v);\n}\n\nvoid dfs2(int v) {\n    vv.push_back(v);\n    used[v] = true;\n\n    for (auto to : g2[v])\n        if (!used[to])\n            dfs2(to);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n\n    for (auto to : g3[v])\n        if (!used[to])\n            dfs(to);\n}\n\nvoid solve() {\n    --s;\n\n    forn (i, n)\n        if (!used[i])\n            dfs1(i);\n\n    fill(used, used + n, false);\n    reverse(order.begin(), order.end());\n    int cur = 0;\n\n    for (auto v : order)\n        if (!used[v]) {\n            vv.clear();\n            dfs2(v);\n\n            for (auto i : vv)\n                comp[i] = cur;\n\n            ++cur;\n        }\n\n    s = comp[s];\n\n    for (int i = 0; i < n; ++i)\n        for (auto to : g1[i])\n            if (comp[i] != comp[to]) {\n                g3[comp[i]].push_back(comp[to]);\n                ++cnt[comp[to]];\n            }\n\n    fill(used, used + cur, false);\n    dfs(s);\n    int ans = 0;\n\n    forn (i, cur)\n        if (cnt[i] == 0 && !used[i])\n            dfs(i), ++ans;\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n\n#ifdef SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Reachability from the Capital.json",
    "editorial_link": "https://codeforces.com/blog/entry/60138",
    "editorial": "This problem is (almost) equivalent to the following: count the number\r\nof sources (the vertices with indegree equal to ) in the given graph\u00e2\u0080\u0099s\r\ncondensation. Thus, there exist solutions with complexity . However, the\r\nconstraints in the problem are small, so solutions with complexity also\r\npass.One of these solutions is the following: first, let\u00e2\u0080\u0099s mark all the\r\nvertices reachable from as , using a simple DFS. Then, for each bad\r\nvertex , count the number of vertices reachable from (it also can be\r\ndone by simple DFS). Let this number be . Now, iterate over all bad\r\nvertices in non-increasing order of . For the current bad vertex , if it\r\nis still not marked as , run a DFS from it, marking all the reachable\r\nvertices as , and increase the answer by (in fact, we are implicitly\r\nadding the edge ). It can be proved that this solution gives an optimal\r\nanswer.\r\n"
}