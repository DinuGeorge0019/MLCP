{
    "link": "https://codeforces.com//contest/1611/problem/D",
    "problemId": "1202187",
    "problem_idx": "D",
    "shortId": "1611D",
    "contest_number": "1611",
    "problem_submissions": {
        "G": [
            136919698,
            136924345,
            136928058,
            137125236
        ],
        "D": [
            136909432,
            136888068,
            136869096,
            136875871,
            136873458,
            136872703,
            136892897,
            136874114,
            136878310,
            136876576,
            136982847,
            136873530,
            136877831,
            136975464,
            136882777,
            136872332,
            136878705,
            136879548,
            136882637,
            136884556,
            136875995,
            136885445
        ],
        "C": [
            136904645,
            136879235,
            136858847,
            136855243,
            136861532,
            136858913,
            136876501,
            136863657,
            136864973,
            136856130,
            136982821,
            136863847,
            136868283,
            136968820,
            136869195,
            136914947,
            136862897,
            136869863,
            136862192,
            136866525,
            136860324,
            136867113
        ],
        "F": [
            136894434,
            136926092,
            136925788,
            136894423,
            136887654,
            136898905,
            136890793,
            136892527,
            136897622,
            136914432,
            136920232,
            136982943,
            136925360,
            136906595,
            136919174,
            136903703,
            136921493,
            136918298,
            136922728,
            136905212,
            136914690,
            136921349
        ],
        "E2": [
            136882323,
            136916663,
            136883396,
            136897153,
            136890210,
            136911911,
            136900593,
            136909227,
            136895787,
            136903952,
            136982885,
            136896820,
            136917983,
            136900669,
            136888044,
            136899257,
            136899662,
            136904447,
            136915639,
            136920739,
            136912069
        ],
        "E1": [
            136879967,
            136917077,
            136876615,
            136879938,
            136883345,
            136903050,
            136866650,
            136906813,
            136891861,
            136885925,
            136982868,
            136892962,
            136889119,
            136896344,
            136885342,
            136893182,
            136895321,
            136895279,
            136895954,
            136895593,
            136897796
        ],
        "B": [
            136853549,
            136850019,
            136845917,
            136846742,
            136848311,
            136849660,
            136855952,
            136851245,
            136847523,
            136844081,
            136855128,
            136851469,
            136843577,
            136850258,
            136848183,
            136852060,
            136853372,
            136855929,
            136847562,
            136850988
        ],
        "A": [
            136844450,
            136846022,
            136842097,
            136842084,
            136843783,
            136847130,
            136842440,
            136842943,
            136843633,
            136841984,
            136846854,
            136846415,
            136848083,
            136843263,
            136843590,
            136843624,
            136845033,
            136842923,
            136842870,
            136846917
        ]
    },
    "name": "D. Weights Assignment For Tree Edges",
    "statement": "You are given a rooted tree consisting of n vertices. Vertices are\r\nnumbered from 1 to n. Any vertex can be the root of a tree.A is a\r\nconnected undirected graph without cycles. A is a tree with a selected\r\nvertex, which is called the .The tree is specified by an array of\r\nancestors b containing n numbers: b_i is an ancestor of the vertex with\r\nthe number i. The of a vertex u is a vertex that is the next vertex on a\r\nsimple path from u to the root. For example, on the simple path from 5\r\nto 3 (the root), the next vertex would be 1, so the ancestor of 5 is\r\n1.The root has no ancestor, so for it, the value of b_i is i (the root\r\nis the only vertex for which b_i=i).For example, if n=5 and b=[3, 1, 3,\r\n3, 1], then the tree looks like this. You are given an array p a\r\npermutation of the vertices of the tree. If it is possible, assign any\r\ninteger weights on the edges, so that the vertices sorted by distance\r\nfrom the root would form the given permutation p.In other words, for a\r\ngiven permutation of vertices p, it is necessary to choose such edge\r\nweights so that the condition dist[p_i]<dist[p_{i+1}] is true for each i\r\nfrom 1 to n-1. dist[u] is a sum of the weights of the edges on the path\r\nfrom the root to u. In particular, dist[u]=0 if the vertex u is the root\r\nof the tree.For example, assume that p=[3, 1, 2, 5, 4]. In this case,\r\nthe following edge weights satisfy this permutation: the edge (3, 4) has\r\na weight of 102; the edge (3, 1) has weight of 1; the edge (1, 2) has a\r\nweight of 10; the edge (1, 5) has a weight of 100. The array of\r\ndistances from the root looks like: dist=[1,11,0,102,101]. The vertices\r\nsorted by increasing the distance from the root form the given\r\npermutation p.Print the required edge weights or determine that there is\r\nno suitable way to assign weights. If there are several solutions, then\r\nprint any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n///Weights Assignment For Tree Edges\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        int N;\n        std::cin>>N;\n        std::vector<int> con[N]={};\n        int root=0;\n        for(int i=0;i!=N;++i){\n            int b;\n            std::cin>>b;--b;\n            if(b==i){\n                root=i;\n                continue;\n            }\n            con[b].push_back(i);\n        }\n        bool pah_visitar[N]={};\n        pah_visitar[root]=true;\n        int ps[N]={};for(auto&x:ps){std::cin>>x;--x;}\n        int peso_minimo=-1;\n        int peso_cada[N]={};\n        int dist[N]={};\n        for(int i=0;i!=N;++i){\n            if(!pah_visitar[ps[i]]){\n                printf(\"-1\\n\");\n                goto prox;\n            }\n            pah_visitar[ps[i]]=false;\n            ++peso_minimo;\n            assert(peso_minimo>=dist[ps[i]]);\n            int aresta=peso_minimo-dist[ps[i]];\n            peso_cada[ps[i]]=aresta;\n            peso_minimo=dist[ps[i]]+aresta;\n            for(auto&x:con[ps[i]]){\n                dist[x]=dist[ps[i]]+aresta;\n                pah_visitar[x]=true;\n            }\n        }\n        for(int i=0;i!=N;++i){\n            std::cout<<peso_cada[i]<<\" \";\n        }\n        std::cout<<\"\\n\";\n        prox:{}\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Weights Assignment For Tree Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/97288",
    "editorial": "Consider the cases when it is impossible to form a given permutation :1.\r\n. For root it is true that . For any other vertex the value of will be\r\npositive, since there is at least one edge of positive weight on the\r\npath to it.2. . In a rooted tree there is exactly one path from the root\r\nto any vertex , and it goes through its parent , so it must always be\r\ntrue .Let us start filling the array , where . Consider a vertex , ().\r\nThe vertex whose distance at the current time is maximal is . Then is at\r\nleast . We assign a value to , remembering to check that has already\r\nbeen counted.After counting all values, we can output the lengths of the\r\nedges: .\r\n",
    "hint": []
}