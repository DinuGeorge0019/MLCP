{
    "link": "https://codeforces.com//contest/2037/problem/D",
    "problemId": "3030272",
    "problem_idx": "D",
    "shortId": "2037D",
    "contest_number": "2037",
    "problem_submissions": {
        "E": [
            292047075,
            292001485,
            292009292,
            291996476,
            292062011,
            292051813,
            292265678,
            292262203,
            292192703,
            292071302,
            292070663,
            291999780,
            292064784,
            292052672,
            292050626,
            292052922,
            292071828,
            291992209,
            292000170,
            291988756,
            292008406,
            292007324
        ],
        "F": [
            292022218,
            292017907,
            292024969,
            292058791,
            292012459,
            292558370,
            292027964,
            292322779,
            292083202,
            292025710,
            292058305,
            292053924,
            292057524,
            292098039,
            292062013,
            292058405,
            292072247,
            292041262,
            291975958,
            292082628,
            292078164,
            292082635,
            292046600
        ],
        "G": [
            291996486,
            292046822,
            292051239,
            292033736,
            292022807,
            292088543,
            292046321,
            292046301,
            292015442,
            292027681,
            292033325,
            292031649,
            292030485,
            292058022,
            292068187,
            292049914,
            292058005,
            292018113,
            291981788,
            292025943,
            292032506,
            292023447,
            292184893
        ],
        "D": [
            291973736,
            291988212,
            291992996,
            291979703,
            291998834,
            291983903,
            292002713,
            292029295,
            291999646,
            291984954,
            292024081,
            292031106,
            291991931,
            291978485,
            292010279,
            291980815,
            291970955,
            291981313,
            291985613
        ],
        "C": [
            291961505,
            291975167,
            291974207,
            291964672,
            291977153,
            291965604,
            291972603,
            291985859,
            291958605,
            291975659,
            291971736,
            292051709,
            291965196,
            293681954,
            291964838,
            291966108,
            291957366,
            291965128,
            291970402
        ],
        "B": [
            291956714,
            291952988,
            291957798,
            291954795,
            291952360,
            291952928,
            291957139,
            291960930,
            291959780,
            291972890,
            291956311,
            291964398,
            291952930,
            291955364,
            291953325,
            291955467,
            291951893,
            291958231,
            291957803
        ],
        "A": [
            291948750,
            291945793,
            291946764,
            291946202,
            291945511,
            291946198,
            291946444,
            291950431,
            291945465,
            291953437,
            291945736,
            291948815,
            291947311,
            291946698,
            291949011,
            291949226,
            291946064,
            291945840,
            291951387
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136334",
    "editorial": "Process from earliest to latest. Maintain a priority queue of power-ups left so far. If Mualani meets a power-up, add it to the priority queue. Otherwise (Mualani meets a hurdle), take power-ups in the priority queue from strongest to weakest until you can jump over the hurdle. This guarantees that each time Mualani jumps over a hurdle, she takes the minimum number of power-ups necessary. Time complexity is O((n+m)logm)\n, where O(logm)\n is from the priority queue.\n\nNote that the hurdle intervals are inclusive. If there is a hurdle at [l,r]\n, she must jump from position l?1\n to r+1\n.",
    "name": "D. Sharky Surfing",
    "statement": "Mualani’s surf path can be modeled by a number line. She starts at\r\nposition 1, and the path ends at position L. When she is at position x\r\nwith a jump power of k, she can jump to any position in the interval [x,\r\nx+k]. Initially, her jump power is 1. However, her surf path isn’t\r\ncompletely smooth. There are n hurdles on her path. Each hurdle is\r\nrepresented by an interval [l, r], meaning she cannot jump to any\r\nposition in the interval [l, r]. There are also m power-ups at certain\r\npositions on the path. Power-up i is located at position x_i and has a\r\nvalue of v_i. When Mualani is at position x_i, she has the option to\r\ncollect the power-up to increase her jump power by v_i. There may be\r\nmultiple power-ups at the same position. When she is at a position with\r\nsome power-ups, she may choose to take or ignore each individual\r\npower-up. No power-up is in the interval of any hurdle.What is the\r\nminimum number of power-ups she must collect to reach position L to\r\nfinish the path? If it is not possible to finish the surf path, output\r\n-1.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> #define int long long#define fi first#define se second const int N = 2e5 + 5;const int K = 1e2 + 5;const int mod = 1e9 + 7;const int inf = 1e18 + 7; #define all(v) (v).begin(), (v).end()#define pii pair<int, int>  using namespace std; mt19937 rd(chrono::steady_clock::now().time_since_epoch().count()); int t, n, m, L;int l[N], r[N];int x[N], v[N];priority_queue<int> q; signed main() {    ios_base::sync_with_stdio(0);    cin.tie(0);        if(ifstream(\"file.inp\")){    \tfreopen(\"file.inp\", \"r\", stdin);    \tfreopen(\"file.out\", \"w\", stdout);    }        cin >> t;    while(t--) {    \tcin >> n >> m >> L;    \tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i];    \tfor(int i = 1; i <= m; i++) cin >> x[i] >> v[i];    \twhile(q.size()) q.pop();    \tint j = 1, sum = 1, cnt = 0;    \tbool check = 1;    \tfor(int i = 1; i <= n; i++) {    \t\twhile(j <= m && x[j] <= l[i]) q.push(v[j++]);    \t\twhile(q.size() && sum < r[i] - l[i] + 2) {    \t\t\tsum += q.top();    \t\t\tcnt++;    \t\t\tq.pop();    \t\t}    \t\tif(sum < r[i] - l[i] + 2) {    \t\t\tcheck = 0;    \t\t\tbreak;    \t\t}    \t}    \tcout << (check ? cnt : -1) << '\\n';    }        return 0;} // tuntun"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Sharky Surfing.json",
    "hint": []
}