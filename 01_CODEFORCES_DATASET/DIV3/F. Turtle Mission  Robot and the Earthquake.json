{
    "link": "https://codeforces.com//contest/1933/problem/F",
    "problemId": "2499502",
    "problem_idx": "F",
    "shortId": "1933F",
    "contest_number": "1933",
    "problem_submissions": {
        "F": [
            248591555,
            248583197,
            248612069,
            248598539,
            248597755,
            248643416,
            248594242,
            248617583,
            248616936,
            248585168,
            248614930,
            248616674,
            248602103,
            248594258,
            248595945,
            248611877,
            248611178,
            248616575,
            248616309,
            248622503,
            248617674
        ],
        "E": [
            248548292,
            248552431,
            248546385,
            248561374,
            248556960,
            248652019,
            248551455,
            248552418,
            248555156,
            248564471,
            248563614,
            248548908,
            248551471,
            248562111,
            248581222,
            248571134,
            248569128,
            248568252,
            248572929,
            248557480,
            248572070
        ],
        "D": [
            248528452,
            248534682,
            248520947,
            248525201,
            248536025,
            248654461,
            248561233,
            248528372,
            248531274,
            248536504,
            248531753,
            248522180,
            248521565,
            248548476,
            248549982,
            248534397,
            248534785,
            248540283,
            248533460,
            248533936,
            248522543
        ],
        "C": [
            248516161,
            248524318,
            248516570,
            248527729,
            248522314,
            248522710,
            248519907,
            248542337,
            248516141,
            248527195,
            248558597,
            248543262,
            248520926,
            248522993,
            248519350,
            248521925,
            248526364,
            248527609,
            248534164
        ],
        "B": [
            248505336,
            248503901,
            248517888,
            248511472,
            248507016,
            248507736,
            248508836,
            248511885,
            248506077,
            248516238,
            248525805,
            248512121,
            248503633,
            248509962,
            248507053,
            248512665,
            248511061,
            248506937,
            248515209
        ],
        "A": [
            248494249,
            248494304,
            248494559,
            248496663,
            248496909,
            248500497,
            248494197,
            248494587,
            248497967,
            248494007,
            248495080,
            248494500,
            248498090,
            248639683,
            248493804,
            248494937,
            248495858,
            248498778,
            248497100,
            248494989,
            248499649
        ],
        "G": [
            248742272,
            248790545,
            248713826,
            248773615,
            248759515
        ]
    },
    "name": "F. Turtle Mission  Robot and the Earthquake",
    "statement": "The world is a grid with n rows and m columns. The rows are numbered 0,\r\n1,\r\nldots, n-1, while the columns are numbered 0, 1,\r\nldots, m-1. In this world, the columns are (i.e. the top and the bottom\r\ncells in each column are adjacent). The cell on the i-th row and the\r\nj-th column (0\r\nle i < n, 0\r\nle j < m) is denoted as (i,j). , the cell (i,j) (where 0\r\nle i < n, 0\r\nle j < m) contains either a or . The state of cell (i,j) can be\r\ndescribed using the integer a_{i,j}: If a_{i,j} = 1, there is a rock at\r\n(i,j). If a_{i,j} = 0, there is nothing at (i,j). As a result of\r\naftershocks from the earthquake, the columns follow tectonic plate\r\nmovements: each column moves cyclically at a velocity of 1 cell per unit\r\nof time. Formally, for some 0\r\nle i < n, 0\r\nle j < m, if (i,j) contains a rock at the moment, it will move from (i,\r\nj) to (i - 1, j) (or to (n - 1, j) if i=0). The robot called RT is\r\ninitially positioned at (0,0). It has to go to (n-1,m-1) to carry out an\r\nearthquake rescue operation (to the bottom rightmost cell). The\r\nearthquake doesn\u2019t change the position of the robot, they only change\r\nthe position of rocks in the world.Let RT\u2019s current position be (x,y) (0\r\nle x < n, 0\r\nle y < m), it can perform the following operations: Go one cell\r\ncyclically upwards, i.e. from (x,y) to ((x+n-1)\r\nbmod n, y) using 1 unit of time. Go one cell cyclically downwards, i.e.\r\n(x,y) to ((x+1)\r\nbmod n, y) using 1 unit of time. Go one cell to the right, i.e. (x,y) to\r\n(x, y+1) using 1 unit of time. (RT may perform this operation only if y\r\n< m-1.) Unfortunately, RT will explode upon colliding with a rock. As\r\nsuch, when RT is at (x,y) and there is a rock at ((x+1)\r\nbmod n, y) or ((x+2)\r\nbmod n, y), RT cannot move down or it will be hit by the rock.\r\nSimilarly, if y+1 < m and there is a rock at ((x+1)\r\nbmod n, y+1), RT cannot move right or it will be hit by the rock.\r\nHowever, it is worth noting that if there is a rock at (x\r\nbmod n, y+1) and ((x+1)\r\nbmod n, y), RT can still move right safely. Find the minimum amount of\r\ntime RT needs to reach (n-1,m-1) without colliding with any rocks. If it\r\nis impossible to do so, output -1.\r\n",
    "solutions": [
        "/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e3+10;\nint n,m;\nint a[N][N],dp[N][N];\nvoid leeminhduc2()\n{\n    cin >> n >> m;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<m;j++)\n            {\n                cin >> a[i][j];\n                dp[i][j]=-1;\n            }\n    dp[0][0]=0ll;\n    queue<ii> q;\n    q.push({0,0});\n    while (sz(q))\n    {\n        \n        auto [u,v]=q.front(); q.pop();\n        \n        if (dp[(u+2)%n][v]==-1&&a[(u+1)%n][v]==0&&a[(u+2)%n][v]==0)\n        {\n            dp[(u+2)%n][v]=dp[u][v]+1;\n            q.push({(u+2)%n,v});\n        }\n        if (v<m-1&&dp[(u+1)%n][(v+1)]==-1&&a[(u+1)%n][(v+1)]==0)\n        {\n            dp[(u+1)%n][(v+1)]=dp[u][v]+1;\n            q.push({(u+1)%n,(v+1)});\n        }\n    }\n    \n     \n    int res=1e9;\n    for (int i=0;i<n;i++) if (dp[i][m-1]!=-1)\n    {\n        int cur=(i-dp[i][m-1]%n+n)%n;\n       \n        if (cur==n-1) res=min(res,dp[i][m-1]);\n        else res=min(res,dp[i][m-1]+cur+1);\n    }\n    if (res==1e9) cout << \"-1\\n\";\n    else cout << res << \"\\n\";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Turtle Mission  Robot and the Earthquake.json",
    "editorial_link": "https://codeforces.com//blog/entry/126560",
    "editorial": "By viewing the robot\u00e2\u0080\u0099s movement relative to the rocks, Robot RT\u00e2\u0080\u0099s three\r\nmoves become as follows: Up: Stationary Down, to Right, to As staying\r\nstationary is not necessary now when we are finding the minimum time, we\r\ncan run a bfs/dp from to find the minimum time required to reach every\r\ngrid in the second last column . Finally, choose the best among all n\r\ntiles after waiting for the endpoint to cycle back.\r\n"
}