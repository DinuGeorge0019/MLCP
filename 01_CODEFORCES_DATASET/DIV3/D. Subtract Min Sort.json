{
    "link": "https://codeforces.com//contest/2060/problem/D",
    "problemId": "3147473",
    "problem_idx": "D",
    "shortId": "2060D",
    "contest_number": "2060",
    "problem_submissions": {
        "G": [
            301873530,
            301859046,
            301852803,
            301886996,
            301829945,
            301884074,
            301865362,
            301944483,
            301877663
        ],
        "F": [
            301809977,
            301827952,
            301788384,
            301831904,
            301878286,
            301872767,
            301850953,
            301874252,
            301811774,
            301816800,
            301831940,
            301815743,
            301889712,
            301854030,
            301836262,
            301832755,
            301848647,
            301843962,
            301841616,
            301902407
        ],
        "E": [
            301780977,
            301790293,
            301841004,
            301786821,
            301854824,
            301815095,
            301816295,
            301758990,
            301799665,
            301795284,
            301801086,
            301920235,
            301889573,
            301794741,
            301799175,
            301804483,
            301807413,
            301794652,
            301768541
        ],
        "D": [
            301771562,
            301772155,
            301822748,
            301775745,
            301785461,
            301801939,
            301852011,
            301776457,
            301782878,
            301769755,
            301787487,
            301917787,
            301889434,
            301776569,
            301786371,
            301790878,
            301764610,
            301773754,
            301756989
        ],
        "C": [
            301748633,
            301761322,
            301773736,
            301772188,
            301769620,
            301776760,
            301770890,
            301782439,
            301749719,
            301754417,
            301759048,
            301774305,
            301916945,
            301889316,
            301755362,
            301775118,
            301772704,
            301748352,
            301760800,
            301753236
        ],
        "B": [
            301746021,
            301755202,
            301761527,
            301755925,
            301795537,
            301759408,
            301745641,
            301745397,
            301750029,
            301750098,
            301915984,
            301888995,
            301750358,
            301751304,
            301755984,
            301781169,
            301750274,
            301748735
        ],
        "A": [
            301739564,
            301739279,
            301761253,
            301738865,
            301749974,
            301743163,
            301743222,
            301739250,
            301739375,
            301743095,
            301739024,
            301915381,
            301888689,
            301739666,
            301739726,
            301746215,
            301745343,
            301738637,
            301738767
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138580",
    "editorial": "Video\r\n",
    "name": "D. Subtract Min Sort",
    "statement": "You are given a sequence a consisting of n positive integers.You can\r\nperform the following operation any number of times. Select an index i\r\n(1\r\nle i < n), and subtract\r\nmin(a_i,a_{i+1}) from both a_i and a_{i+1}. Determine if it is possible\r\nto make the sequence by using the operation any number of times.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);     int t;    cin >> t;    while(t--){        int n;         cin >> n;        vector<long long> a(n);        for(int i=0; i<n; i++){            cin >> a[i];        }         bool possible = true;        for(int i=n-1; i>=1; i--){            if(a[i-1] > a[i]){                long long x = a[i-1] - a[i];                int leftIdx = i-2; // 0-based index for a[i-2]                if(leftIdx < 0){                    possible = false;                    break;                }                a[leftIdx] -= x;   // reduce the left neighbor                a[i-1] = a[i];     // fix a[i-1] down to a[i]                if(a[leftIdx] < 0){                    possible = false;                    break;                }            }        }        if(possible){            for(int i=0; i+1<n; i++){                if(a[i] > a[i+1]){                    possible = false;                    break;                }            }        }         cout << (possible ? \"YES\\n\" : \"NO\\n\");    }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Subtract Min Sort.json",
    "hint": []
}