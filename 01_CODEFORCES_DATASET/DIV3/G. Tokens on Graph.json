{"link": "https://codeforces.com//contest/1790/problem/G", "problemId": "1753652", "problem_idx": "G", "shortId": "1790G", "contest_number": "1790", "problem_submissions": {"G": [190854632, 190862960, 190871236, 190852228, 190874097, 190860078, 190864244, 190870017, 190877879, 190877235, 190904434, 190907790, 190907701, 190907675, 190907628, 190907581, 190906892, 190854527, 190922421], "F": [190826149, 190835977, 190846761, 190834910, 190847927, 190872422, 190808806, 190840036, 190828723, 190808476, 190910332, 190837355, 196429864, 190917553, 190917160, 190851135, 190842374, 190851773, 190863031, 190852368, 190851643, 190838344], "E": [190812975, 190818965, 190827893, 190863212, 190836271, 190829765, 190825221, 190876565, 190808314, 190824525, 190821638, 190829372, 190820356, 190812061, 190820330, 190820963, 190806991, 190818524, 190819724, 190846451], "D": [190803665, 190801014, 190809824, 190809927, 190814214, 190816750, 190829094, 190855040, 190798110, 190788994, 190804480, 190888100, 190808920, 190796914, 191055501, 190801526, 190807925, 190805582, 190795106, 190877973, 190877812, 190877739, 190807212, 190809993, 190794263], "C": [190799607, 190794832, 190803346, 190801723, 190802374, 190811887, 190835627, 190842540, 190791067, 190792160, 190797002, 190796740, 190791871, 191053177, 190792454, 190799052, 190800065, 190792126, 190796861, 190801470, 190788102], "B": [190787414, 190782870, 190784109, 190786307, 190786713, 190787527, 190838763, 190837244, 190783518, 190783528, 190787197, 190780535, 190781020, 190992563, 190781621, 190782537, 190779326, 190778124, 190780824, 190788703, 190964430, 190781997], "A": [190775165, 190772612, 190774942, 190772740, 190773567, 190776157, 190841892, 190833157, 190774181, 190772373, 190774417, 190772590, 190773736, 190991523, 190774168, 190774263, 190772401, 190772891, 190774182, 192760356, 190775235, 190774848]}, "name": "G. Tokens on Graph", "statement": "You are given an undirected connected graph, some vertices of which\r\ncontain tokens and/or bonuses. Consider a game involving one player\r\nyou.You can move tokens according to the following rules: At the\r\nbeginning of the game, you can make exactly one turn: move any token to\r\nany adjacent vertex. If the movement of the token ended on the bonus,\r\nthen you are allowed to make another turn with any token. You can use\r\ndifferent bonuses in any order. The same bonus can be used an unlimited\r\nnumber of times. Bonuses do not move during the game.There can be\r\nseveral tokens in one vertex at the same time, but initially there is no\r\nmore than one token in each vertex.The vertex with number 1 is the\r\nfinish vertex, and your task is to determine whether it is possible to\r\nhit it with any token by making turns with the tiles according to the\r\nrules described above. If a token is initially located at the vertex of\r\n1, then the game is considered already won. For example, for a given\r\ngraph, you can reach the finish line with a chip from the 8th vertex by\r\nmaking the following sequence of turns: Move from the 8-th vertex to the\r\n6-th. Move from the 7-th vertex to the 5-th. Move from the 6-th vertex\r\nto the 4-th. Move from the 5-th vertex to the 6-th. Move from the 4-th\r\nvertex to the 2-nd. Move from the 6-th vertex to the 4-th. Move from the\r\n2-nd vertex to the 1-st vertex, which is the finish.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint t;\nint a[200100],b[200100],c[3],st[200100],op[200100],d[200100];\nvector<int> g[200100];\nvoid solve(){\n        int n,i,m,p,h,u,v;cin>>n>>m>>p>>h;\n        for(i=1;i<=n;i++)g[i].clear(),a[i]=b[i]=st[i]=op[i]=0,d[i]=-1;\n        c[0]=c[1]=c[2]=0;\n        for(i=0;i<p;i++)cin>>v,a[v]=1;\n        for(i=0;i<h;i++)cin>>v,b[v]=1;\n        for(i=0;i<m;i++)cin>>u>>v,g[u].emplace_back(v),g[v].emplace_back(u);\n        for(i=1;i<=n;i++)for(int j:g[i])b[i]&b[j]?st[i]=1:1;\n        for(i=1;i<=n;i++)if(a[i]){\n                for(int j:g[i]){\n                        if(b[j])op[i]=1;\n                        if(st[j]){\n                                op[i]=2;break;\n                        }\n                }\n        }\n        queue<int>que;que.emplace(1);d[1]=0;\n        for(;que.size();){\n                int U=que.front();que.pop();\n                for(int V:g[U])if(b[V]&&!~d[V])d[V]=d[U]+1,que.emplace(V);\n        }\n        for(i=1;i<=n;i++)c[op[i]]++;\n        for(i=1;i<=n;i++)if(a[i]){\n                int D=d[i];\n                c[op[i]]--;\n                for(int j:g[i])if(~d[j]&&(D>d[j]+1||!~D))D=d[j]+1;\n                if(~D&&(c[2]||c[1]>D-2))return void(cout<<\"YES\\n\");\n                c[op[i]]++;\n        }\n        cout<<\"NO\\n\";\n}\nsigned main(){\n        ios::sync_with_stdio(false);cin.tie(nullptr);\n        cin>>t;\n        while(t--)solve();\n        return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs", "shortest paths"], "dificulty": "2300", "interactive": false}