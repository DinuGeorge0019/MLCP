{
    "link": "https://codeforces.com//contest/1986/problem/B",
    "problemId": "2714654",
    "problem_idx": "B",
    "shortId": "1986B",
    "contest_number": "1986",
    "problem_submissions": {
        "G2": [
            267051586,
            267098517,
            267207124,
            267227692
        ],
        "G1": [
            267050167,
            267075101,
            267042149,
            267064735,
            267062041,
            267072094,
            267189212,
            267907699,
            267227655
        ],
        "F": [
            267036897,
            267006951,
            267211888,
            267210735,
            267209305,
            267209191,
            267142479,
            267067023,
            267046217,
            267049909,
            267055692,
            267026922,
            267034254,
            267024454,
            267035130,
            267043900,
            267043428,
            267046638,
            267048369,
            267046109,
            267054071,
            267044101,
            267051585,
            267055127
        ],
        "E": [
            267031182,
            267035399,
            267025961,
            267037775,
            267044980,
            267032730,
            267010850,
            267025710,
            267050692,
            267025261,
            267026751,
            267028762,
            267028451,
            267027196,
            267036783,
            267025470,
            267030110,
            267036403,
            267037341
        ],
        "D": [
            267019160,
            267019752,
            267011405,
            267021594,
            267023740,
            267014893,
            267011680,
            267009591,
            267007109,
            267005474,
            267006461,
            267009567,
            267009731,
            267006448,
            267009653,
            267006959,
            267018496,
            267008934,
            267008176
        ],
        "C": [
            266989125,
            266982272,
            266994840,
            267002991,
            266993066,
            267005030,
            266983150,
            266989202,
            266983682,
            267008636,
            266990051,
            266988914,
            266994220,
            266992535,
            266990847,
            266994508,
            266995474,
            266989895,
            266985787
        ],
        "B": [
            266980718,
            266971385,
            266985030,
            266993111,
            266976413,
            266985138,
            266977306,
            266981373,
            266976133,
            266979778,
            266979273,
            266982265,
            266980709,
            266977455,
            266980695,
            266983193,
            266981883,
            266982561,
            266978536
        ],
        "A": [
            266966090,
            266964678,
            266968415,
            266974624,
            270989331,
            266965521,
            266965134,
            266964884,
            266966168,
            266965003,
            266971429,
            266979885,
            266965867,
            266964795,
            266965926,
            266967291,
            266966370,
            266967270,
            266967228,
            266965380
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130783",
    "editorial": "Let's consider any two adjacent cells of the matrix. Notice that our algorithm can change at most one value of these two cells.\n\nIf the values in the cells are equal, then neither of these two adjacent cells will ever change its value.\nIf the values in the cells are not equal, then the value of the larger cell will never become smaller than the value of the smaller cell.\nLet mx\n be the maximum value written in the cells adjacent to (i,j)\n. If mx?aij\n, then the value of the cell (i,j)\n will not change during the execution of the algorithm; otherwise, it will eventually become equal to mx\n.\n",
    "name": "B. Matrix Stabilization",
    "statement": "You are given a matrix of size n\r\ntimes m, where the rows are numbered from 1 to n from top to bottom, and\r\nthe columns are numbered from 1 to m from left to right. The element at\r\nthe intersection of the i-th row and the j-th column is denoted by\r\na_{ij}.Consider the algorithm for stabilizing matrix a: Find the cell\r\n(i, j) such that its value is strictly greater than the values of all\r\nits neighboring cells. If there is no such cell, terminate the\r\nalgorithm. If there are multiple such cells, choose the cell with the\r\nsmallest value of i, and if there are still multiple cells, choose the\r\none with the smallest value of j. Set a_{ij} = a_{ij} - 1. Go to step 1.\r\nIn this problem, cells (a, b) and (c, d) are considered neighbors if\r\nthey share a common side, i.e., |a - c| + |b - d| = 1.Your task is to\r\noutput the matrix a after the stabilization algorithm has been executed.\r\nIt can be shown that this algorithm cannot run for an infinite number of\r\niterations.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\u00a0#define int long long#define pb push_back#define fi first#define se secondusing namespace std;using ll = long long;using ld = long double;using ull = unsigned long long;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int maxN = 1e2 + 5;const int mod = 1e9 + 7;const ll oo = 1e18;int n, m;int a[maxN][maxN];void ReadInput(){    memset(a, 0, sizeof a);    cin >> n >> m;    for(int i=1; i<=n; i++)        for(int j=1; j<=m; j++)            cin >> a[i][j];}bool go(){    for(int i=1; i<=n; i++)        for(int j=1; j<=m; j++)        {            int t = max({a[i - 1][j], a[i][j - 1], a[i + 1][j], a[i][j + 1]});            if(a[i][j] > t)            {                a[i][j] = t;                return true;            }        }    return false;}void Solve(){    while(go());    for(int i=1; i<=n; i++, cout << '\\n')        for(int j=1; j<=m; j++)            cout << a[i][j] << ' ';}#define taskname \"sol\"int32_t main(){    if (fopen(taskname \".inp\", \"r\"))    {        freopen(taskname \".inp\", \"r\", stdin);     //   freopen(taskname \".out\", \"w\", stdout);    }    ios_base::sync_with_stdio(false);    cin.tie(nullptr);    int T = 1;    cin >> T;    for(int itest=1; itest<=T; itest++)    {        ReadInput();        Solve();    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Matrix Stabilization.json"
}