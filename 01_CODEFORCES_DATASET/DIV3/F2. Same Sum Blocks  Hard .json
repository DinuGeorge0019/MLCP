{
    "link": "https://codeforces.com//contest/1141/problem/F2",
    "problemId": "316176",
    "problem_idx": "F2",
    "shortId": "1141F2",
    "contest_number": "1141",
    "problem_submissions": {
        "G": [
            52739588,
            51536187,
            51534299,
            51525036,
            55748640,
            98770872,
            51606575,
            51605903,
            51550288,
            51562985
        ],
        "E": [
            51521056,
            51509494,
            51514700,
            51509864,
            51515343,
            51512067,
            51514136,
            51516742,
            51515279,
            51513645,
            51514418,
            51515657,
            51529830,
            51518938,
            51520757,
            51514193,
            51518496,
            51519253
        ],
        "F2": [
            51512804,
            51520813,
            51519468,
            51520462,
            51524714,
            51522819,
            51524615,
            51526867,
            51526388,
            51528287,
            51528610,
            51526942,
            51526833,
            51528921,
            51567579,
            51529733,
            51520266,
            51530585,
            51528159
        ],
        "F1": [
            51512586,
            51519520,
            51520037,
            51530962,
            51520861,
            51524235,
            51522340,
            51524194,
            51526191,
            51525945,
            51527775,
            51528063,
            51527052,
            51527343,
            51520158,
            51528384,
            51528375,
            51520780,
            51530653,
            51527810
        ],
        "D": [
            51504077,
            51500288,
            51507602,
            51497021,
            51498993,
            51505660,
            51501736,
            51504542,
            51504450,
            51505517,
            51507648,
            51506380,
            51507813,
            51509739,
            51507965,
            51506483,
            51503583,
            51507577,
            51514228
        ],
        "C": [
            51496498,
            51493212,
            51499078,
            51492880,
            51502608,
            51499584,
            51495627,
            51495976,
            51499494,
            51500075,
            51499041,
            51503297,
            51499022,
            51497246,
            51497075,
            51529270,
            51499224,
            51506668
        ],
        "B": [
            51489707,
            51490678,
            51493680,
            51489601,
            51492373,
            51494463,
            51492484,
            51490578,
            51491799,
            51494772,
            51492508,
            51496543,
            51490227,
            51491876,
            51492884,
            51490276,
            51493813,
            51493209
        ],
        "A": [
            51488460,
            51488637,
            51489458,
            51488560,
            51490651,
            51489465,
            51489640,
            51488837,
            51490105,
            51489577,
            51489271,
            51494436,
            51488528,
            51488619,
            51489959,
            51488566,
            51490539
        ]
    },
    "name": "F2. Same Sum Blocks  Hard ",
    "statement": "You are given an array of integers a[1], a[2],\r\ndots, a[n]. A is a sequence of contiguous (consecutive) elements a[l],\r\na[l+1],\r\ndots, a[r] (1\r\nle l\r\nle r\r\nle n). Thus, a block is defined by a pair of indices (l, r).Find a set\r\nof blocks (l_1, r_1), (l_2, r_2),\r\ndots, (l_k, r_k) such that: They do not intersect (i.e. they are\r\ndisjoint). Formally, for each pair of blocks (l_i, r_i) and (l_j, r_j)\r\nwhere i\r\nneq j either r_i < l_j or r_j < l_i. For each block the sum of its\r\nelements is the same. Formally, a[l_1]+a[l_1+1]+\r\ndots+a[r_1]=a[l_2]+a[l_2+1]+\r\ndots+a[r_2]=\r\ndots = a[l_k]+a[l_k+1]+\r\ndots+a[r_k]. The number of the blocks in the set is maximum. Formally,\r\nthere does not exist a set of blocks (l_1’, r_1’), (l_2’, r_2’),\r\ndots, (l_{k’}’, r_{k’}’) satisfying the above two requirements with k’ >\r\nk. Write a program to find such a set of blocks.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nconst ll MAXN = 2000;\n\nll n, a[MAXN], pr[MAXN];\nmap<ll, vector< pair<ll, ll> >  > mp;\n\nbool cmp(pair<ll, ll> a, pair<ll, ll> b){\n    return a.second < b.second;\n}\n\nvector<pair<ll, ll> > get_ans(vector<pair<ll, ll> > & v){\n    sort(v.begin(), v.end(), cmp);\n    vector<pair<ll, ll> > ans;\n    ll len = -20;\n\n    for(int i = 0; i < v.size(); ++i){\n        if(v[i].first > len){\n            len = v[i].second;\n            ans.pb(v[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n        pr[i] = pr[i-1] + a[i];\n    }\n\n    for(int i = 1; i <= n; ++i){\n        for(int j = i; j <= n; ++j){\n            mp[pr[j] - pr[i-1]].pb({i, j});\n        }\n    }\n\n    ll ans = 0;\n    vector<pair<ll, ll> > vans;\n\n    for(auto i : mp){\n        vector<pair<ll, ll> > v = (i).second;\n        vector<pair<ll, ll> > cur = get_ans(v);\n        if(cur.size() > ans){\n            ans = cur.size();\n            vans = cur;\n        }\n    }\n\n    cout << ans << '\\n';\n    for(auto i : vans){\n        cout << i.first << ' ' << i.second << '\\n';\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F2. Same Sum Blocks  Hard .json",
    "editorial_link": "https://codeforces.com//blog/entry/66062",
    "editorial": "Letâs the same sum of blocks in the answer. Obviously, can be\r\nrepresented as a sum of some adjacent elements of , i.e. for some and\r\n.Iterate over all possible blocks in and for each sum store all the\r\nblocks. You can use âmap<int, vector<pair<int,int >â to store blocks\r\ngrouped by a sum. You can do it with the following code:map<int,\r\nvector<pair<int,int>>> segs;for (int r = 0; r < n; r++) { int sum = 0;\r\nfor (int l = r; l >= 0; l ) { sum += a[l]; segs[sum].push_back({l, r});\r\n}}Note, that blocks are sorted by the right end in each group.After it\r\nyou can independently try each group (there are of them) and find the\r\nmaximal disjoint set of blocks of a group. You can do it greedily, each\r\ntime taking into the answer segment with the smallest right end. Since\r\nin each group they are ordered by the right end, you can find the\r\nrequired maximal disjoint block set with one pass. Letâs assume is the\r\ncurrent group of blocks (they are ordered by the right end), then the\r\nfollowing code constructs the maximal disjoint set:int cur = 0;int r =\r\n-1;vector<pair<int,int>> now;for (auto seg: pp) if (seg.first > r) {\r\ncur++; now.push_back(seg); r = seg.second; }Choose the maximum among\r\nmaximal disjoint sets for the groups.\r\n",
    "hint": []
}