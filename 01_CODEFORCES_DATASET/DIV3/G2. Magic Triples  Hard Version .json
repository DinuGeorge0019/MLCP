{
    "link": "https://codeforces.com//contest/1822/problem/G2",
    "problemId": "1892793",
    "problem_idx": "G2",
    "shortId": "1822G2",
    "contest_number": "1822",
    "problem_submissions": {
        "G2": [
            203329589,
            203339263,
            203381498,
            203399783,
            203865362,
            203330305
        ],
        "G1": [
            203318956,
            203330193,
            203276966,
            203287325,
            203308786,
            203296983,
            203323825,
            203307123,
            203320850,
            203332700,
            203865002,
            203359496,
            203359463,
            203330685,
            204446172,
            203310290,
            203339354,
            203315428,
            203302676,
            203310873,
            203329569,
            203321024,
            203330750,
            203305233,
            203303556
        ],
        "F": [
            203311377,
            203304349,
            203289463,
            203315957,
            203293214,
            203321886,
            203310253,
            203289053,
            203315427,
            203322934,
            203309509,
            204446123,
            203336692,
            203316452,
            203330323,
            203318231,
            203332802,
            203314466,
            203335914,
            203292219,
            203326849
        ],
        "E": [
            203296483,
            203294918,
            203301869,
            203305615,
            203281331,
            203304282,
            203300144,
            203335324,
            203301320,
            203299094,
            203465042,
            203300212,
            204446093,
            203301112,
            203312462,
            203305245,
            203327828,
            203302228,
            203303478,
            203300745,
            203330969
        ],
        "D": [
            203286878,
            203281525,
            203307926,
            203293337,
            203328547,
            203299454,
            203293051,
            203279640,
            203292208,
            203282510,
            203460577,
            204446071,
            203291302,
            203284222,
            203296451,
            203281700,
            203294137,
            203283859,
            203282850,
            203323951,
            203292506
        ],
        "C": [
            203269093,
            203263336,
            203271435,
            203263663,
            203261370,
            203266562,
            203266457,
            203274387,
            203281914,
            203267451,
            203280043,
            204446050,
            203273380,
            203263600,
            203280452,
            203287125,
            203279715,
            203274210,
            203276492,
            203269231,
            203271656
        ],
        "B": [
            203260372,
            203258321,
            203263757,
            203259490,
            203258126,
            203261555,
            203264790,
            203259112,
            203258912,
            203260590,
            203267860,
            204445992,
            203266382,
            203260815,
            203264197,
            203259428,
            203281421,
            203266504,
            203265983,
            203265142,
            203265405
        ],
        "A": [
            203258554,
            203260901,
            203261112,
            203258337,
            203257932,
            203258591,
            203260388,
            203259429,
            203267599,
            203258710,
            203270958,
            204446004,
            203259390,
            203258512,
            203258527,
            203257933,
            203263156,
            203262719,
            203260859,
            203258150,
            203261484
        ]
    },
    "name": "G2. Magic Triples  Hard Version ",
    "statement": "For a given sequence of n integers a, a triple (i, j, k) is called if: 1\r\nle i, j, k\r\nle n. i, j, k are pairwise distinct. there exists a positive integer b\r\nsuch that a_i\r\ncdot b = a_j and a_j\r\ncdot b = a_k. Kolya received a sequence of integers a as a gift and now\r\nwants to count the number of triples for it. Help him with this\r\ntask!Note that there are no constraints on the order of integers i, j\r\nand k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define lli long long int\n#define fr(i, k, n) for (lli i = k; i < n; i++)\n#define rf(i, n, k) for (lli i = n; i > k; i--)\n#define pb push_back\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n\n// #define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n\nvector<lli> adj[1000005];\n\nvoid sieve()\n{\n    for (lli i = 1; i < 1000005; i++)\n    {\n        for (lli j = i; j < 1000005; j += i)\n        {\n            if ((i * j) <= 1e9)\n            {\n                adj[j].pb(i);\n            }\n        }\n    }\n}\n\nlli power(lli a, lli n)\n{\n    lli res = 1;\n    while (n)\n    {\n        if (n % 2)\n        {\n            res *= a;\n            // res %= mod;\n        }\n        a *= a;\n        // a %= mod;\n        n /= 2;\n    }\n    return res;\n}\n\nlli gcd(lli a, lli b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\nlli lcm(lli v, lli b)\n{\n    return (v * b) / gcd(v, b);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    // freopen(\"error.txt\", \"w\", stderr);\n#endif\n    lli t = 1;\n    cin >> t;\n    sieve();\n    while (t--)\n    {\n        lli n;\n        cin >> n;\n        lli arr[n];\n        map<lli, lli> mp;\n        fr(i, 0, n)\n        {\n            cin >> arr[i];\n            mp[arr[i]]++;\n        }\n        lli ans = 0;\n        lli mini = mp.begin()->first, maxi = mp.rbegin()->first;\n        for (auto it : mp)\n        {\n            if (it.first <= 1000000)\n            {\n                for (auto bt : adj[it.first])\n                {\n                    if (it.first * bt > maxi)\n                    {\n                        break;\n                    }\n                    if (bt == 1)\n                    {\n                        if (it.second > 2)\n                        {\n                            ans += (it.second) * (it.second - 1) * (it.second - 2);\n                        }\n                    }\n                    else\n                    {\n                        lli first = it.first / bt, second = it.first * bt;\n                        if (mp.find(first) == mp.end() || mp.find(second) == mp.end())\n                        {\n                            continue;\n                        }\n                        else\n                        {\n                            ans += (mp[first] * it.second * mp[second]);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                for (lli i = 1; i <= 1000; i++)\n                {\n                    if (it.first * i > maxi)\n                    {\n                        break;\n                    }\n                    if (it.first % i == 0)\n                    {\n                        if (i == 1)\n                        {\n                            if (it.second > 2)\n                            {\n                                ans += (it.second) * (it.second - 1) * (it.second - 2);\n                            }\n                        }\n                        else\n                        {\n                            lli first = it.first / i, second = it.first * i;\n                            if (mp.find(first) == mp.end() || mp.find(second) == mp.end())\n                            {\n                                continue;\n                            }\n                            else\n                            {\n                                ans += (mp[first] * it.second * mp[second]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << ans << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G2. Magic Triples  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/115409",
    "editorial": "Let , obviously , the number of occurrences of the number in the array\r\n.Separately, letâs count the number of triples for . The total number of\r\nsuch triples will be . Next, we will count . We will iterate over , if ,\r\nthen , then . Otherwise, , since , then is a divisor of , which means it\r\nis enough to iterate as the divisors of the number , the divisors of\r\nsuch the numbers can be found for , which means the total complexity\r\nwill be if you use the hash table , or if you use std::map.\r\n",
    "hint": []
}