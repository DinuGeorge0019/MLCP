{
    "link": "https://codeforces.com//contest/1409/problem/C",
    "problemId": "716927",
    "problem_idx": "C",
    "shortId": "1409C",
    "contest_number": "1409",
    "problem_submissions": {
        "F": [
            91841452,
            91841006,
            91847094,
            91849145,
            91853876,
            91853063,
            91844676,
            91826529,
            91863527,
            91862569,
            91861696,
            91867633,
            91863103,
            91860709,
            91861645,
            91851313,
            91859301,
            91874305,
            91863916,
            91868988
        ],
        "E": [
            91827324,
            91839984,
            91836314,
            91835556,
            91831349,
            91852207,
            91886381,
            91857615,
            91843090,
            91845624,
            91838339,
            91851120,
            91837678,
            91852948,
            91866189,
            91853121,
            91849423,
            91856636,
            91853663
        ],
        "D": [
            91824220,
            91828702,
            91829052,
            91826254,
            91834063,
            91852756,
            91824308,
            91834176,
            91832475,
            91841859,
            91848714,
            91840119,
            91835288,
            91844671,
            91837282,
            91846495,
            91838632
        ],
        "C": [
            91818297,
            91820814,
            91822012,
            91821252,
            91820474,
            91823540,
            91825047,
            91828813,
            91828605,
            91824227,
            91820725,
            91829115,
            91823214,
            91824095,
            91821560,
            91823224,
            91828004,
            91829526
        ],
        "B": [
            91812965,
            91813416,
            91816401,
            91808485,
            91814835,
            91816697,
            91810019,
            91810994,
            91822185,
            91815944,
            91811525,
            91819746,
            91813210,
            91817451,
            91814034,
            91810729,
            91815998,
            91816789
        ],
        "A": [
            91801654,
            91804481,
            91803475,
            91801145,
            91812176,
            91802127,
            91801025,
            91800872,
            91805502,
            91801293,
            91801197,
            91802135,
            91802754,
            91805435,
            91802071,
            91800716,
            91803654,
            91812308
        ]
    },
    "name": "C. Yet Another Array Restoration",
    "statement": "We have a secret array. You don\u2019t know this array and you have to\r\nrestore it. However, you know some facts about this array: The array\r\nconsists of n (greater than 0) integers. The array contains two elements\r\nx and y (these elements are for you) such that x < y. If you sort the\r\narray in increasing order (such that a_1 < a_2 <\r\nldots < a_n), differences between all adjacent (consecutive) elements\r\nare equal (i.e. a_2 - a_1 = a_3 - a_2 =\r\nldots = a_n - a_{n-1}). It can be proven that such an array always\r\nexists under the constraints given below.Among all possible arrays that\r\nsatisfy the given conditions, we ask you to restore one which has the\r\nmaximum element. In other words, you have to minimize\r\nmax(a_1, a_2,\r\ndots, a_n).You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long lli;\ntypedef pair<int, int> ii;\ntypedef pair<lli, lli> ll;\n\nint main() {\n\tint tc, n, x, y, mini, a, b, temp;\n\tbool xx, yy;\n\tscanf(\"%d\", &tc);\n\twhile (tc--) {\n\t\tscanf(\"%d %d %d\", &n, &x, &y);\n\t\tmini = 100000000;\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tfor (int j = 1; j < 50; j++) {\n\t\t\t\txx = yy = false;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\ttemp = i + (j * k);\n\t\t\t\t\tif (temp == x)\n\t\t\t\t\t\txx = true;\n\t\t\t\t\telse if (temp == y)\n\t\t\t\t\t\tyy = true;\n\t\t\t\t}\n\t\t\t\tif ((xx && yy) && (temp < mini)) {\n\t\t\t\t\tmini = temp;\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d%c\", a + (i * b), (i < n - 1) ? ' ' : '\\n');\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Yet Another Array Restoration.json",
    "editorial_link": "https://codeforces.com//blog/entry/82284",
    "editorial": "The only fact required to solve this problem is just to notice that the\r\nanswer array is just an arithmetic progression. After that, we can fix\r\nthe first element , fix the difference , construct the array , check if\r\nand are in this array and, if yes, update the answer with . This is\r\nsolution.There are faster solutions, though. Other author\u00e2\u0080\u0099s solution is\r\nbut I didn\u00e2\u0080\u0099t want to make this problem harder, so I allowed solutions.It\r\nis obvious that the difference of the progression is some divisor of .\r\nLet it be . Let\u00e2\u0080\u0099s add some elements starting from \"to the left\" ( and so\r\non) and stop if we reach elements or the next element is less than . If\r\nwe didn\u00e2\u0080\u0099t find among these elements, just skip this difference, it is\r\nuseless for us. Otherwise, if we have less than elements, let\u00e2\u0080\u0099s add and\r\nso on until we get elements. And then update the answer with the maximum\r\nelement of the array.There is also a solution in with some greedy\r\nobservations :)\r\n"
}