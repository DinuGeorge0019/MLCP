{"link": "https://codeforces.com//contest/1914/problem/F", "problemId": "2388665", "problem_idx": "F", "shortId": "1914F", "contest_number": "1914", "problem_submissions": {"G1": [238018438, 238000852, 238043791, 238031142, 238036163, 238022582, 238087384, 238021948, 238036052, 238042057, 238044748, 238044591, 238050871, 238049279, 238041985, 238041747, 238051023, 238045930, 238048344, 238046536], "G2": [238018282, 238029024, 238043678, 238093831, 238412098, 238148947, 238064785, 238049222, 238126038, 238092486, 238087948, 238046581], "F": [237987101, 237981616, 238101450, 238044891, 238001429, 238000631, 238087366, 238087349, 237994511, 237993999, 238008838, 238002775, 238029366, 238028703, 238047984, 238031007, 238059042, 238016608, 238042673, 238020683, 238033160, 238082942, 238008762, 238014024], "E1": [237976613, 237967906, 237968713, 237979764, 237992475, 238087307, 237986420, 237997495, 237988975, 237985077, 238029878, 238002145, 237999975, 237992524, 237984395, 237997791, 237997737, 237990723, 237990559, 238004571, 238010992, 238032680, 237982405, 237983507], "E2": [237970390, 237967235, 237968505, 237975110, 237992780, 238087324, 238087318, 237984061, 238010057, 237989036, 237983616, 238029826, 238001371, 237999445, 237992650, 237985208, 237997942, 237998156, 237990939, 238005322, 238011620, 238032636, 237982481, 237984584], "D": [237961065, 237957916, 238104889, 237961793, 237958795, 237961367, 238087292, 238087270, 237986240, 237957524, 237975283, 237962518, 238030156, 237976418, 237969884, 237965519, 237971483, 237975166, 237976975, 237983490, 237986064, 237975702, 237967060, 237966732], "C": [237951819, 237950855, 237956944, 237969583, 237951814, 238087237, 237972501, 237951530, 237961828, 237952459, 238030394, 237963594, 237963444, 237965677, 237960539, 237979704, 237972502, 237967766, 237971691, 237960187, 237954042, 237957084], "B": [237947357, 237946623, 237951415, 237946292, 237950077, 238087224, 237953989, 237947273, 237953071, 237947198, 237948581, 237951930, 237944853, 237953412, 237972118, 237952004, 237972737, 237961138, 237948416, 237947616, 237950073], "A": [237944355, 237943313, 237944942, 237948071, 237945058, 238087212, 237948311, 237944114, 237946737, 237943516, 237943664, 237945100, 237964491, 237948297, 237965985, 237946077, 237945584, 237949431, 237943847, 237944147, 237943327]}, "name": "F. Programming Competition", "statement": "BerSoft is the biggest IT corporation in Berland. There are n employees\r\nat BerSoft company, numbered from 1 to n. The first employee is the head\r\nof the company, and he does not have any superiors. Every other employee\r\ni has exactly one direct superior p_i.Employee x is considered to be a\r\nsuperior (direct or indirect) of employee y if one of the following\r\nconditions holds: employee x is the direct superior of employee y;\r\nemployee x is a superior of the direct superior of employee y. The\r\nstructure of BerSoft is organized in such a way that the head of the\r\ncompany is superior of every employee.A programming competition is going\r\nto be held soon. Two-person teams should be created for this purpose.\r\nHowever, if one employee in a team is the superior of another, they are\r\nuncomfortable together. So, teams of two people should be created so\r\nthat no one is the superior of the other. Note that no employee can\r\nparticipate in more than one team.Your task is to calculate the maximum\r\npossible number of teams according to the aforementioned rules.\r\n", "solutions": ["//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=2e5+5,mod=1e9+7;\nll n,k,dect[N],sz[N];\nvector<ll> ke[N];\nvoid dfs (ll u){\n    sz[u]=1;\n    ll mx=0,pos=0;\n    rv(v,ke[u]){\n        dfs(v);\n        sz[u]+=sz[v];\n        if (mx<sz[v]) mx=sz[v],pos=v;\n    }\n    if (pos==0) dect[u]=sz[u];\n    else if (dect[pos]<=(sz[u]-1-mx)) dect[u]=1+(sz[u]+1)%2;\n    else dect[u]=1+(dect[pos]-(sz[u]-1-mx));\n}\nvoid prep(){\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) ke[i].clear();\n    rep(i,2,n){\n        cin>>k;\n        ke[k].pb(i);\n    }\n    dfs(1);\n    cout<<(n-dect[1])/2;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graph matchings", "greedy", "trees"], "dificulty": "1900", "interactive": false}