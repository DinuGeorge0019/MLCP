{
    "link": "https://codeforces.com//contest/1941/problem/E",
    "problemId": "2523371",
    "problem_idx": "E",
    "shortId": "1941E",
    "contest_number": "1941",
    "problem_submissions": {
        "G": [
            250763025,
            250781286,
            250779945,
            250787489,
            250800958,
            250794874,
            250801570,
            250797693,
            250776624,
            250793138,
            250784955,
            250769475,
            250695343,
            250808638,
            250806485,
            250793977,
            250708131
        ],
        "F": [
            250740820,
            250744438,
            250753388,
            250758018,
            250759651,
            250771923,
            250771468,
            250735055,
            250753949,
            250769805,
            250766080,
            250789658,
            250717637,
            250786906,
            250776029,
            250768573,
            250744006
        ],
        "E": [
            250723876,
            250724169,
            250717230,
            250735746,
            250736815,
            250736521,
            250739262,
            250774240,
            250729758,
            250726588,
            250755686,
            250741893,
            250738588,
            250765034,
            250731744,
            250805659,
            250779683
        ],
        "D": [
            250690549,
            250702231,
            250695593,
            250704272,
            250717031,
            250703063,
            250703013,
            250692270,
            250695895,
            250691168,
            250734836,
            250707874,
            250759962,
            250722745,
            250703516,
            250708254,
            250785215
        ],
        "C": [
            250674251,
            250679685,
            250671012,
            250679783,
            250680400,
            250684218,
            250682169,
            250667218,
            250675740,
            250676966,
            250670249,
            250691797,
            250745426,
            250686871,
            250672532,
            250677895,
            250750876
        ],
        "B": [
            250664239,
            250668411,
            250660791,
            250663325,
            250694386,
            250668961,
            250666921,
            250657383,
            250663605,
            250664885,
            250657026,
            250681860,
            250751771,
            250667298,
            250743798,
            250661438,
            250747374
        ],
        "A": [
            250649602,
            250652993,
            250650152,
            250651488,
            250656171,
            250653697,
            250656300,
            250649271,
            250654624,
            250658642,
            250648031,
            250654646,
            250754293,
            250652956,
            250649094,
            250648520,
            250712266
        ]
    },
    "name": "E. Rudolf and k Bridges",
    "statement": "Bernard loves visiting Rudolf, but he is always running late. The\r\nproblem is that Bernard has to cross the river on a ferry. Rudolf\r\ndecided to help his friend solve this problem.The river is a grid of n\r\nrows and m columns. The intersection of the i-th row and the j-th column\r\ncontains the number a_{i,j} the depth in the corresponding cell. All\r\ncells in the and columns correspond to the river banks, so the depth for\r\nthem is 0. Rudolf can choose the row (i,1), (i,2),\r\nldots, (i,m) and build a bridge over it. In each cell of the row, he can\r\ninstall a support for the bridge. The cost of installing a support in\r\nthe cell (i,j) is a_{i,j}+1. Supports must be installed so that the\r\nfollowing conditions are met: A support must be installed in cell (i,1);\r\nA support must be installed in cell (i,m); The distance between any pair\r\nof adjacent supports must be d. The distance between supports (i, j_1)\r\nand (i, j_2) is |j_1 - j_2| - 1. Building just one bridge is boring.\r\nTherefore, Rudolf decided to build k bridges on rows of the river, that\r\nis, to choose some i (1\r\nle i\r\nle n - k + 1) and independently build a bridge on each of the rows i,\r\ni + 1,\r\nldots, i + k - 1. Help Rudolf the total cost of installing supports.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<\"YES\\n\"\n#define NO cout << \"NO\\n\"\n#define debug cout << \"Here Fine\" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\nint dp[ 2015 ] , nx_dp[ 1015 ] ;\n\nint pp[ N ] ; \nvector < int > ans ;\nmultiset < int > se ;  \nvoid solve(){\n    int n , m , k , d ;\n    cin >> n >> m >> k >> d ;\n    ans.clear() ; se.clear() ;\n    int pas = inf , sm = 0 , l = 0 ; \n    FOR( i , n ){\n    \tse.clear() ;\n    \tint lst = 0 ;\n    \tFOR( j , m ){\n    \t\tint x ; cin >> x ;\n    \t\tif( j == 0 ){\n    \t\t\tse.insert( 1 ) ;\n    \t\t\tpp[ 0 ] = 1 ; \n    \t\t\tcontinue ;\n\t\t\t}\n\t\t\tint bf = *se.begin() ;\n\t\t\tx = x + bf + 1 ;\n\t\t\tse.insert( x ) ;\n\t\t\tpp[ j ] = x ; \n\t\t\tif( j - d - 1 >= 0 ){\n\t\t\t\tse.erase( se.find( { pp[ j - d - 1 ] } ) ) ;\n\t\t\t}\n\t\t}\n\t\tans.pb( pp[ m - 1 ] ) ;\n\t\tsm += pp[ m - 1 ] ; \n\t\tif( ans.size() > k ){\n\t\t\tsm = sm - ans[ l ] ;\n\t\t\tl ++ ;  \n\t\t}\n\t\tif( ans.size() >= k )\n\t\tpas = min( pas , sm ) ;\n\t}\n    cout << pas << \"\\n\"; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Rudolf and k Bridges.json",
    "editorial_link": "https://codeforces.com//blog/entry/127018",
    "editorial": "First, for each string separately, we will calculate the minimum total\r\ncost of supports and write it to an array. This can be done, for\r\nexample, using dynamic programming as follows. We will go through the\r\nstring and maintain the last minimum total costs in a multiset. Then the\r\nanswer for the current position will be the sum of the cost of the\r\nsupport at this position and the minimum element from the multiset. When\r\nmoving to the next element of the string, it is important to remember to\r\nupdate the multiset.After that, from the array of minimum total costs,\r\nwe choose a segment of length with the minimum sum, which will be the\r\nanswer.The algorithm\u00e2\u0080\u0099s asymptotic complexity is of the order .\r\n"
}