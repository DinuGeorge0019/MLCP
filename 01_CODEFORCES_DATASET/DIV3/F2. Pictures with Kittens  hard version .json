{
    "link": "https://codeforces.com//contest/1077/problem/F2",
    "problemId": "256066",
    "problem_idx": "F2",
    "shortId": "1077F2",
    "contest_number": "1077",
    "problem_submissions": {
        "F2": [
            45821914,
            45824097,
            45827727,
            45823038,
            45823838,
            45831345,
            45823658,
            45828538,
            45826654,
            45843367,
            45837244,
            45831421,
            45827068,
            75760321,
            46030227,
            46029209,
            46029112,
            45866424
        ],
        "F1": [
            45820450,
            45824142,
            45824461,
            45823167,
            76966420,
            45824019,
            45831648,
            45823900,
            45828343,
            45824802,
            45841509,
            45837306,
            45831567,
            45823097,
            45829985,
            45827347,
            75757082,
            45830229,
            45831957,
            45830358,
            45833935,
            45833332,
            45828687
        ],
        "E": [
            45816542,
            52239741,
            45818548,
            45816950,
            45819025,
            45815405,
            45821116,
            45817502,
            45823078,
            45808470,
            45827222,
            45833695,
            45822673,
            45820795,
            45823659,
            45825654,
            45825672,
            45828447,
            45825663,
            45830728
        ],
        "D": [
            45811969,
            52239759,
            45814314,
            45814285,
            45816755,
            45819154,
            45813076,
            45811883,
            45822278,
            45831158,
            45821016,
            45816579,
            45818656,
            45997108,
            45818703,
            45817324,
            45818247,
            45816683,
            45819278,
            45822009
        ],
        "C": [
            45807748,
            45809528,
            45808767,
            45809925,
            45807121,
            45806385,
            45818022,
            45810371,
            45804988,
            45857981,
            45852142,
            45840511,
            45811255,
            45820919,
            45810760,
            45809427,
            45810396,
            45809829,
            45812965,
            45808768,
            45810632,
            45815038,
            45809663
        ],
        "B": [
            45805407,
            45806822,
            45804781,
            45807614,
            45805828,
            45804425,
            45810429,
            45806291,
            45806153,
            45852010,
            45812539,
            45824293,
            45806882,
            45806701,
            45807779,
            45807759,
            45805186,
            45806900,
            45808256,
            45805906
        ],
        "A": [
            45803595,
            45803585,
            45803761,
            45803589,
            45806737,
            45803510,
            45815244,
            45803641,
            45804397,
            45851969,
            45805595,
            45822873,
            45804956,
            45804923,
            45805008,
            45804110,
            45803730,
            45804318,
            45804436,
            45803752
        ]
    },
    "name": "F2. Pictures with Kittens  hard version ",
    "statement": "Vova likes pictures with kittens. The news feed in the social network he\r\nuses can be represented as an array of n consecutive pictures (with\r\nkittens, of course). Vova likes all these pictures, but some are more\r\nbeautiful than the others: the i-th picture has beauty a_i.Vova wants to\r\nrepost exactly x pictures in such a way that: each segment of the news\r\nfeed of at least k consecutive pictures has at least one picture\r\nreposted by Vova; the sum of beauty values of reposted pictures is\r\nmaximum possible. For example, if k=1 then Vova has to repost all the\r\npictures in the news feed. If k=2 then Vova can skip some pictures, but\r\nbetween every pair of consecutive pictures Vova has to repost at least\r\none of them.Your task is to calculate the maximum possible sum of values\r\nof reposted pictures if Vova follows conditions described above, or say\r\nthat there is no way to satisfy all conditions.\r\n",
    "solutions": [
        "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 5010\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,k,a[N],q[N],head,tail;\nll f[N][N];\nint main()\n{\n\tn=read(),k=read(),m=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tmemset(f,200,sizeof(f));\n\tf[0][0]=0;\n\tfor (int j=1;j<=m;j++)\n\t{\n\t\thead=1,tail=1;q[1]=0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\twhile (head<tail&&q[head]<i-k) head++;\n\t\t\tf[i][j]=f[q[head]][j-1]+a[i];\n\t\t\twhile (head<=tail&&f[q[tail]][j-1]<=f[i][j-1]) tail--;\n\t\t\tq[++tail]=i;\n\t\t\t//for (int x=i-1;x>=max(0,i-k);x--)\n\t\t\t//f[i][j]=max(f[i][j],f[x][j-1]+a[i]);\n\t\t}\n\t}\n\tfor (int i=n-1;i>=max(0,n-k+1);i--) f[n][m]=max(f[n][m],f[i][m]);\n\tif (f[n][m]<0) cout<<-1;\n\telse cout<<f[n][m];\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F2. Pictures with Kittens  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/63274",
    "editorial": "Let\u00e2\u0080\u0099s use dynamic programming described in the previous tutorial to\r\nsolve this problem too. But its complexity is so we have to improve some\r\npart of the solution.Let\u00e2\u0080\u0099s see how we do transitions in this dp: for .\r\nWhat can we do to optimize it? is the constant and we have to take the\r\nmaximum value among . You will say \"segment tree\"! I say no. Not a\r\nsegment tree. Not a sparse table. Not a cartesian tree or some other\r\nlogarithmic data structures. If you want to spend a lot of time to fit\r\nsuch solution in time and memory limits okay, it is your choice. I\r\nprefer the queue with supporting the maximum on it.The last part of this\r\ntutorial will be a small guide about how to write and use the queue with\r\nsupporting the maximum on it.The first part of understanding this data\r\nstructure is the stack with the maximum. How do we support the stack\r\nwith the maximum on it? That\u00e2\u0080\u0099s pretty easy: let\u00e2\u0080\u0099s maintain the stack of\r\npairs, when the first value of pair is the value in the stack and the\r\nsecond one is the maximum on the stack if this element will be the\r\ntopmost. Then when we push some value in it, the first element of pair\r\nwill be and the second one will be (if is our stack and is the topmost\r\nelement). When we pop the element we don\u00e2\u0080\u0099t need any special hacks to do\r\nit. Just pop it. And the maximum on the stack is always .Okay, the\r\nsecond part of understanding this data structure is the queue on two\r\nstacks. Let\u00e2\u0080\u0099s maintain two stacks and and try to implement the queue\r\nusing it. We will push elements only to and pop elements only from .\r\nThen how to maintain the queue using such stacks? The push is pretty\r\neasy just push it in . The main problem is pop. If is not empty then we\r\nhave to pop it from . But what do we do if is empty? No problems: let\u00e2\u0080\u0099s\r\njust transfer elements of to (pop from , push to ) in order from top to\r\nbottom. And don\u00e2\u0080\u0099t forget to pop the element after this transfer!Okay, if\r\nwe will join these two data structures, we can see that we obtain\r\nexactly what we want! Just two stacks with maximums! That\u00e2\u0080\u0099s pretty easy\r\nto understand and implement it.The last part of the initial solution is\r\npretty easy just apply this data structure (in fact, data structures) to\r\ndo transitions in our dynamic programming. The implementation of this\r\nstructure can be found in the authors solution.Total complexity of the\r\nsolution is .\r\n"
}