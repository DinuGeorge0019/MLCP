{
    "link": "https://codeforces.com//contest/1374/problem/E2",
    "problemId": "659589",
    "problem_idx": "E2",
    "shortId": "1374E2",
    "contest_number": "1374",
    "problem_submissions": {
        "E2": [
            85382072,
            85375189,
            85438625
        ],
        "F": [
            85353642,
            85415306,
            85383843,
            85383492,
            85387797
        ],
        "E1": [
            85326034,
            85415299,
            85334989,
            85321477,
            85339121,
            85319474,
            85320204,
            85328246,
            85336700,
            85339703,
            85337792,
            85338081,
            85335206,
            85337433,
            85338605,
            85342001,
            85329936,
            85333348,
            85346311
        ],
        "D": [
            85316338,
            85415714,
            85415293,
            85323106,
            85325598,
            85328229,
            85311173,
            85312812,
            85313089,
            85319125,
            85325499,
            85321861,
            85326849,
            85319951,
            85325883,
            85322528,
            85325568,
            85334734,
            85327646,
            85314511
        ],
        "C": [
            85307188,
            85415289,
            85310607,
            85296173,
            85316864,
            85302975,
            85301461,
            85301463,
            85305237,
            85304971,
            85309343,
            85306153,
            85311376,
            85308864,
            85309628,
            85308295,
            85307625,
            85311312,
            85303960
        ],
        "B": [
            85299874,
            85415460,
            85415277,
            85305586,
            85300354,
            85311254,
            85298580,
            85298918,
            85297647,
            85301049,
            85300227,
            85301912,
            85300264,
            85307719,
            85302644,
            85305750,
            85299884,
            85297473,
            85305618,
            85299402
        ],
        "A": [
            85296254,
            85418749,
            85415919,
            85415268,
            85300037,
            85296089,
            85298024,
            85296518,
            245635316,
            85296385,
            85295981,
            85296977,
            85296136,
            85296861,
            85296508,
            85298422,
            85298833,
            85299917,
            85296648,
            85305648,
            85300594,
            85296295
        ]
    },
    "name": "E2. Reading Books  hard version ",
    "statement": ".Summer vacation has started so Alice and Bob want to play and joy,\r\nbut... Their mom doesn’t think so. She says that they have to read m\r\nbooks before all entertainments. Alice and Bob will read each book to\r\nend this exercise faster.There are n books in the family library. The\r\ni-th book is described by three integers: t_i the amount of time Alice\r\nand Bob need to spend to read it, a_i (equals 1 if Alice likes the i-th\r\nbook and 0 if not), and b_i (equals 1 if Bob likes the i-th book and 0\r\nif not).So they need to choose m books from the given n books in such a\r\nway that: Alice likes k books from the chosen set and Bob likes k books\r\nfrom the chosen set; the total reading time of these m books is (they\r\nare children and want to play and joy as soon a possible). The set they\r\nchoose is for both Alice an Bob (it’s shared between them) and they read\r\nall books , so the total reading time is the sum of t_i over all books\r\nthat are in the chosen set.Your task is to help them and find any\r\nsuitable set of books or determine that it is impossible to find such a\r\nset.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << \" is \" << x << endl\n#define int ll\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7, C = 2e5 + 7;\n\nstruct BIT{\n\tint bit[C];\n\tint lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid add(int i, int d) {\n\t\twhile(i < C) {\n\t\t\tbit[i] += d;\n\t\t\ti += lowbit(i);\n\t\t}\n\t}\n\tint qry(int i) {\n\t\ti = min(i, C - 1);\n\t\tint res = 0;\n\t\twhile(i) {\n\t\t\tres += bit[i];\n\t\t\ti -= lowbit(i);\n\t\t}\n\t\treturn res;\n\t}\n} cnt, sum;\n\nint qry(int need) {\n\tif(need == 0) return 0;\n\tint cur_cnt = 0, pos = 0;\n\tfor(int j = 14; j >= 0; j--) {\n\t\tif(cur_cnt + cnt.bit[pos | (1 << j)] < need) {\n\t\t\tcur_cnt += cnt.bit[pos | (1 << j)];\n\t\t\tpos |= 1 << j;\n\t\t}\n\t}\n\tpos++;\n\tint real_cnt = cnt.qry(pos);\n\tif(real_cnt < need) return INT_MAX;\n\tint ans = sum.qry(pos) - (real_cnt - need) * pos;\n\treturn ans;\n}\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tvi x, y, z, tt;\n\tV<pi> px, py, pz, pt;\n\tfor(int i = 0; i < n; i++) {\n\t\tint t, a, b;\n\t\tcin >> t >> a >> b;\n\t\tif(a == 0 && b == 0) tt.PB(t), pt.EB(t, i);\n\t\telse if(a == 1 && b == 1) z.PB(t), pz.EB(t, i);\n\t\telse if(a == 1) x.PB(t), px.EB(t, i);\n\t\telse y.PB(t), py.EB(t, i);\n\t}\n\tsort(ALL(x)), sort(ALL(y)), sort(ALL(z));\n\tsort(ALL(px)), sort(ALL(py)), sort(ALL(pz));\n\tvi xx = x, yy = y;\n\tfor(int i:xx) {\n\t\tcnt.add(i, 1);\n\t\tsum.add(i, i);\n\t}\n\tfor(int i:yy) {\n\t\tcnt.add(i, 1);\n\t\tsum.add(i, i);\n\t}\n\tfor(int i:tt) {\n\t\tcnt.add(i, 1);\n\t\tsum.add(i, i);\n\t}\n\tfor(int i = 1; i < x.size(); i++) x[i] += x[i - 1];\n\tfor(int i = 1; i < y.size(); i++) y[i] += y[i - 1];\n\tfor(int i = 1; i < z.size(); i++) z[i] += z[i - 1];\n\tint ans = INT_MAX;\n\tint ptr = 0;\n\tint mxi = 0;\n\tfor(int i = z.size(); i >= 0; i--) {\n\t\tint cur = 0;\n\t\tif(i) cur += z[i - 1];\n\t\tint rem = k - i;\n\t\trem--;\n\t\tif(rem >= (int) x.size() || rem >= (int)y.size()) continue;\n\t\tif(rem < 0) rem = -1;\n\t\tif(rem >= 0) cur += x[rem] + y[rem];\n\t\tint so_far = i + (rem + 1) * 2;\n\t\tif(so_far > m) continue;\n\t\tint need = m - so_far;\n\t\tif((int)x.size() - (rem + 1) + (int)y.size() - (rem + 1) + tt.size() < need) continue;\n\t\twhile(ptr <= rem){\n\t\t\tcnt.add(xx[ptr], -1);\n\t\t\tcnt.add(yy[ptr], -1);\n\t\t\tsum.add(xx[ptr], -xx[ptr]);\n\t\t\tsum.add(yy[ptr], -yy[ptr]);\n\t\t\tptr++;\n\t\t}\n\t\tcur += qry(need);\n\t\tif(cur < ans) {\n\t\t\tans = cur;\n\t\t\tmxi = i;\n\t\t}\n\t}\n\tif(ans == INT_MAX) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\tvi an;\n\t{\n\t\tint i = mxi;\n\t\tfor(int j = 0; j < i; j++) an.PB(pz[j].S);\n\t\tint rem = k - i;\n\t\trem--;\n\t\tif(rem < 0) rem = -1;\n\t\tfor(int j = 0; j <= rem; j++) {\n\t\t\tan.PB(px[j].S);\n\t\t\tan.PB(py[j].S);\n\t\t}\n\t\tint so_far = i + (rem + 1) * 2;\n\t\tint need = m - so_far;\n\t\tV<pi> ch;\n\t\tfor(int j = rem + 1; j < px.size(); j++) ch.PB(px[j]);\n\t\tfor(int j = rem + 1; j < py.size(); j++) ch.PB(py[j]);\n\t\tfor(pi j:pt) ch.PB(j);\n\t\tsort(ALL(ch));\n\t\tfor(int j = 0; j < need; j++) an.PB(ch[j].S);\n\t}\n\tassert(an.size() == m);\n\tsort(ALL(an));\n\tfor(int i:an) cout << i + 1 << \" \";\n\tcout << endl;\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation",
        "sortings",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Reading Books  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/79517",
    "editorial": "A little explanation: this editorial will be based on the easy version\r\neditorial so Iâll use some definitions from it.Here we go, the most\r\nbeautiful problem of the contest is waiting us.Well, the key idea of\r\nthis problem almost the same with the easy version idea. Letâs iterate\r\nover the number of elements in -group, we need to take the cheapest ones\r\nagain. If the number of elements we take from -group is then we need to\r\ntake elements from and -groups. But one more thing: letâs iterate over\r\nnot from zero but from the smallest possible number which can give us\r\nany correct set of books (the numeric value of the answer doesnât\r\nmatter) . The value of can be calculated using and sizes of groups by\r\nformula or even simple loop. If we canât find any suitable value of ,\r\nthe answer is .Letâs call elements from -group and elements from and\r\n-groups we take . Other elements of the whole set of books are (but - ).\r\nLetâs create the set which contains all free elements (and fill it\r\nbeforehand). So, now we took some necessary elements, but we need to\r\ntake some free elements to complete our set. Letâs create the other set\r\nwhich contains free elements we take to the answer (and maintain the\r\nvariable describing the sum of elements of ). How do we recalculate ?\r\nBefore the start of the first iteration our set is already filled with\r\nsome elements, letâs update using them.Update is such an operation\r\n(function) that tosses the elements between and . It will do the\r\nfollowing things (repeatedly, and stop when it cannot do anything):\r\nWhile the size of is greater than needed (so we take more than books in\r\ntotal), letâs remove the most expensive element from and add it to ;\r\nwhile the size of is less than needed (so we take less than books in\r\ntotal), letâs remove the cheapest element from and add it to ; while the\r\ncheapest element from is cheaper than the most expensive element form ,\r\nletâs swap them. Note that during updates you need to recalculate as\r\nwell.So, we go over all possible values , updating before the first\r\niteration and after each iteration. The size of both sets changes pretty\r\nsmooth: if we go from to , we need to remove at most one element from\r\n(because we take one element from -group during each iteration) and we\r\nneed to add at most two elements to and (because we remove at most two\r\nelements from and -groups during one iteration).To restore the answer,\r\nletâs save such a value that the answer is minimum with this value (let\r\nit be ). Then letâs just run the same simulation once more from the\r\nbeginning but stop when we reach . Then will contain free elements we\r\nneed to take to the answer, describes the number of elements we need to\r\ntake from -group and describes which elements from and -groups we need\r\nto take.Of course, there are some really tough technical things like\r\ncase-handling (there is a lot of cases, for example, the size of can be\r\nnegative at some moment and you need to carefully handle that, and can\r\nbe negative after some number of iterations and there are other cases\r\nbecause of that, and so on).Time complexity: .\r\n",
    "hint": []
}