{
    "link": "https://codeforces.com//contest/1714/problem/G",
    "problemId": "1490433",
    "problem_idx": "G",
    "shortId": "1714G",
    "contest_number": "1714",
    "problem_submissions": {
        "F": [
            166579305,
            166565691,
            166580443,
            166573014,
            166573474,
            166592525,
            166595105,
            166548029,
            166593205,
            166686575,
            166579941,
            166590847,
            166638992,
            167603752
        ],
        "D": [
            166555174,
            166529424,
            166533941,
            166553024,
            166532466,
            166537534,
            166569263,
            166563818,
            166546107,
            166686361,
            166550012,
            166577360,
            166525263,
            166545147,
            166538583,
            166541251,
            166536599,
            166539458,
            166766162,
            166567140,
            166550628,
            166541107
        ],
        "G": [
            166545336,
            166572008,
            166558804,
            166581190,
            166549499,
            166568428,
            166563357,
            166570492,
            166570829,
            166686732,
            166586648,
            166587656,
            166562027,
            166554683,
            166566856,
            166569305,
            166581306,
            166572830,
            166766125,
            166554830,
            166567931,
            166573074
        ],
        "E": [
            166529226,
            166550151,
            166552214,
            166540138,
            166557091,
            166551342,
            166540892,
            166583808,
            166558113,
            166686473,
            166559850,
            203226761,
            166572711,
            166543154,
            166563505,
            166554394,
            166558430,
            166551333,
            166551809,
            166536566,
            166532529,
            166559461
        ],
        "C": [
            166508236,
            166513547,
            166511820,
            166514654,
            166516790,
            166512293,
            166728853,
            166510608,
            166524319,
            166522144,
            166686237,
            166521175,
            166545986,
            166510036,
            166508148,
            166522114,
            166515443,
            166510078,
            166516228,
            166524460,
            166519794,
            166509906
        ],
        "B": [
            166507200,
            166510494,
            166509013,
            166507825,
            166510367,
            166509254,
            166728113,
            166507901,
            166516960,
            166518989,
            166685849,
            166514261,
            166539890,
            166507950,
            166506803,
            166510018,
            166509016,
            166508114,
            166511943,
            166508752,
            166512719,
            166508756
        ],
        "A": [
            166506659,
            166508343,
            166507357,
            166506909,
            166560580,
            166507658,
            166727935,
            166506862,
            166512344,
            166510563,
            166511944,
            166685755,
            166510846,
            166535694,
            166506790,
            166510397,
            166508153,
            166507023,
            166506968,
            166508973,
            166507229,
            166507722,
            166506864
        ]
    },
    "name": "G. Path Prefixes",
    "statement": "You are given a rooted tree. It contains n vertices, which are numbered\r\nfrom 1 to n. The root is the vertex 1.Each edge has two positive integer\r\nvalues. Thus, two positive integers a_j and b_j are given for each\r\nedge.Output n-1 numbers r_2, r_3,\r\ndots, r_n, where r_i is defined as follows.Consider the path from the\r\nroot (vertex 1) to i (2\r\nle i\r\nle n). Let the sum of the costs of a_j along this path be A_i. Then r_i\r\nis equal to the length of the maximum prefix of this path such that the\r\nsum of b_j along this prefix does not exceed A_i. Consider an example.\r\nIn this case: r_2=0, since the path to 2 has an amount of a_j equal to\r\n5, only the prefix of this path of length 0 has a smaller or equal\r\namount of b_j; r_3=3, since the path to 3 has an amount of a_j equal to\r\n5+9+5=19, the prefix of length 3 of this path has a sum of b_j equal to\r\n6+10+1=17 ( the number is 17\r\nle 19); r_4=1, since the path to 4 has an amount of a_j equal to 5+9=14,\r\nthe prefix of length 1 of this path has an amount of b_j equal to 6\r\n(this is the longest suitable prefix, since the prefix of length 2\r\nalready has an amount of b_j equal to 6+10=16, which is more than 14);\r\nr_5=2, since the path to 5 has an amount of a_j equal to 5+9+2=16, the\r\nprefix of length 2 of this path has a sum of b_j equal to 6+10=16 (this\r\nis the longest suitable prefix, since the prefix of length 3 already has\r\nan amount of b_j equal to 6+10+1=17, what is more than 16); r_6=1, since\r\nthe path up to 6 has an amount of a_j equal to 2, the prefix of length 1\r\nof this path has an amount of b_j equal to 1; r_7=1, since the path to 7\r\nhas an amount of a_j equal to 5+3=8, the prefix of length 1 of this path\r\nhas an amount of b_j equal to 6 (this is the longest suitable prefix,\r\nsince the prefix of length 2 already has an amount of b_j equal to\r\n6+3=9, which is more than 8); r_8=2, since the path up to 8 has an\r\namount of a_j equal to 2+4=6, the prefix of length 2 of this path has an\r\namount of b_j equal to 1+3=4; r_9=3, since the path to 9 has an amount\r\nof a_j equal to 2+4+1=7, the prefix of length 3 of this path has a sum\r\nof b_j equal to 1+3+3=7.\r\n",
    "solutions": [
        "/*\nDiv 3, I literally don't care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=2e5+5,mod=1e9+7;\nll n,c,k,a[N],b[N],g[N][21],p[N],h[N];\nll s[N],t[N];\nvector<ll> ke[N];\nvoid dfs (ll u){\n    rv(v,ke[u]){\n        h[v]=h[u]+1;\n        s[v]=s[u]+a[v];\n        t[v]=t[u]+b[v];\n        dfs(v);\n    }\n}\nvoid prep(){\n    rep(i,1,19)\n    rep(j,1,n) g[j][i]=g[g[j][i-1]][i-1];\n}\nll par (ll u, ll h){\n    rep(i,0,19) if (h&(1<<i)) u=g[u][i];\n    return u;\n}\nvoid solo()\n{\n   cin>>n;\n   rep(i,2,n){\n       cin>>p[i]>>a[i]>>b[i];\n       ke[p[i]].pb(i);\n       g[i][0]=p[i];\n   }\n   prep();\n   dfs(1);\n   rep(i,2,n){\n       ll l=0,r=h[i],res=0;\n       while (l<=r){\n           ll mid=(l+r)/2;\n           if (t[par(i,mid)]<=s[i]) res=mid,r=mid-1;\n           else l=mid+1;\n       }\n       res=h[i]-res;\n       cout<<res<<\" \";\n   }\n   rep(i,0,n)\n   rep(j,0,20) g[i][j]=0;\n   rep(i,1,n) ke[i].clear(),h[i]=0;\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Path Prefixes.json",
    "editorial_link": "https://codeforces.com//blog/entry/105549",
    "editorial": "Note that all are positive, which means that the amount on the prefix\r\nonly increases. This allows us to use binary search to find the answer\r\nfor the vertex. It remains only to learn how to quickly find the sum of\r\non the path prefix. Letâs run a depth-first search and store the prefix\r\nsums of the current path in stack: going to the vertex, add the sum to\r\nthe end of the path and delete it when exiting.\r\n",
    "hint": []
}