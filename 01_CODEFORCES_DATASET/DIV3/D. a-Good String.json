{
    "link": "https://codeforces.com//contest/1385/problem/D",
    "problemId": "675201",
    "problem_idx": "D",
    "shortId": "1385D",
    "contest_number": "1385",
    "problem_submissions": {
        "G": [
            87146925,
            87130516,
            87130073,
            87149307,
            87139436,
            87145109,
            87113469,
            87137001,
            87178119,
            87121112
        ],
        "F": [
            87133863,
            87148212,
            87150419,
            87133069,
            87155521,
            87156261,
            87129136,
            87201006,
            87199143,
            87198211,
            87198141,
            87197991,
            87133163,
            87135084,
            87147650,
            87153475,
            87157087,
            87159161,
            87143942,
            87140750,
            87158980
        ],
        "E": [
            87121743,
            87094311,
            87150777,
            87112227,
            87117131,
            87137692,
            87154530,
            87109484,
            87118031,
            87151551,
            87126695,
            87130754,
            87122234,
            87145112,
            87156780,
            87154434,
            87141435,
            87122925,
            87129785
        ],
        "D": [
            87114357,
            87136398,
            87136307,
            87098537,
            87103655,
            87133732,
            87148068,
            87097110,
            87107447,
            87106449,
            87137139,
            87106363,
            87103887,
            87118780,
            87124754,
            87090612,
            87122982,
            87110063,
            87101408,
            87100549
        ],
        "C": [
            87087119,
            87083714,
            87087183,
            87094082,
            87125584,
            87140844,
            87089726,
            87089545,
            87092040,
            87111442,
            87085820,
            87088762,
            87103769,
            87110798,
            87107696,
            87084280,
            87087235,
            87089175,
            87090633
        ],
        "B": [
            87082211,
            87084609,
            87082372,
            87086099,
            87118271,
            87134332,
            87085669,
            87082094,
            87085708,
            87097473,
            87081944,
            87080519,
            87090484,
            87088911,
            87082077,
            87081415,
            87081680,
            87080910,
            87083097
        ],
        "A": [
            87080978,
            87081308,
            87080529,
            87081521,
            87116439,
            87133004,
            87083295,
            87081194,
            87080773,
            87082296,
            87080859,
            87090051,
            87086698,
            87082297,
            87102822,
            87093275,
            87080753,
            87080503,
            87081225
        ]
    },
    "name": "D. a-Good String",
    "statement": "You are given a string s[1\r\ndots n] consisting of lowercase Latin letters. It is guaranteed that n =\r\n2^k for some integer k\r\nge 0.The string s[1\r\ndots n] is called if of the following three conditions is satisfied: The\r\nlength of s is 1, and it consists of the character c (i.e. s_1=c); The\r\nlength of s is greater than 1, the first half of the string consists of\r\nonly the character c (i.e. s_1=s_2=\r\ndots=s_{\r\nfrac{n}{2}}=c) and the second half of the string (i.e. the string s_{\r\nfrac{n}{2} + 1}s_{\r\nfrac{n}{2} + 2}\r\ndots s_n) is a string; The length of s is greater than 1, the second\r\nhalf of the string consists of only the character c (i.e. s_{\r\nfrac{n}{2} + 1}=s_{\r\nfrac{n}{2} + 2}=\r\ndots=s_n=c) and the first half of the string (i.e. the string s_1s_2\r\ndots s_{\r\nfrac{n}{2}}) is a string. For example: \"\" is , \"\" is .In one move, you\r\ncan choose one index i from 1 to n and replace s_i with any lowercase\r\nLatin letter (any character from \u201d to \u201d).Your task is to find the\r\nminimum number of moves required to obtain an string from s (i.e. for c=\r\n\u201d). It is guaranteed that the answer always exists.You have to answer t\r\nindependent test cases.Another example of an string is as follows.\r\nConsider the string s = \"\". It is an string, because: the second half of\r\nthe string (\"\") consists of only the character \u201d; the first half of the\r\nstring (\"\") is string, because: the second half of the string (\"\")\r\nconsists of only the character \u201d; the first half of the string (\"\") is\r\nstring, because: the first half of the string (\"\") consists of only the\r\ncharacter \u201d; the second half of the string (\"\") is string.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 800010;\nconst int INF = 1e7 + 5;\n\nchar s[N];\nint t, n, tr[N][20], cntL[30], cntR[30]; \n\nvoid get (int u, int l, int r) {\n  if (l == r) {\n    for (int i = 0; i < 20; ++i) tr[u][i] = 1;\n    tr[u][s[l] - 'a'] = 0;\n    return;\n  }\n  int mid = l + r >> 1;\n  get(u << 1, l, mid), get(u << 1 | 1, mid + 1, r);\n  for (int i = 0; i < 30; ++i) cntL[i] = cntR[i] = 0;\n  for (int i = l; i <= r; ++i) {\n    if (i <= mid) ++cntL[s[i] - 'a'];\n    else ++cntR[s[i] - 'a'];\n  }\n  int half = (r - l + 1) >> 1;\n  for (int i = 0; i < 19; ++i) {\n    tr[u][i] = min(half - cntL[i] + tr[u << 1 | 1][i + 1], half - cntR[i] + tr[u << 1][i + 1]);\n    tr[u][i] = min(tr[u][i], INF);\n  }\n}\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d %s\", &n, s + 1);\n    get(1, 1, n);\n    printf(\"%d\\n\", tr[1][0]);\n  }\n  return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "divide and conquer",
        "dp",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. a-Good String.json",
    "editorial_link": "https://codeforces.com//blog/entry/80257",
    "editorial": "Consider the problem in -indexation. Define the function which finds the\r\nminimum number of changes to make the string . Let . Then let and ,\r\nwhere is the number of occurrences of the character in . We can see that\r\ndescribes the second condition from the statement and describes the\r\nthird one. So, returns except one case. When , we need to return if and\r\notherwise. This function works in (each element of belongs to exactly\r\nsegments, like segment tree). You can get the answer if you run .\r\n"
}