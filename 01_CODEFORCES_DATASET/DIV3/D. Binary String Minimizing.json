{
    "link": "https://codeforces.com//contest/1256/problem/D",
    "problemId": "459827",
    "problem_idx": "D",
    "shortId": "1256D",
    "contest_number": "1256",
    "problem_submissions": {
        "C": [
            64235233,
            64227620,
            64227351,
            64236152,
            64252052,
            64225352,
            64226667,
            64237109,
            64249877,
            64222625,
            64278670,
            64233886,
            64252797,
            64233119,
            64246491,
            64253891
        ],
        "F": [
            64233031,
            64241980,
            64252827,
            64253934,
            64245116,
            64253899,
            64232381,
            64237354,
            64239968,
            64313496,
            64235709,
            64249337
        ],
        "E": [
            64221946,
            64223976,
            64247117,
            64244704,
            64224516,
            64249242,
            64227415,
            64227683,
            64231825,
            64236214,
            64243137,
            64237104,
            64247426,
            64247032,
            64250549,
            64247147,
            64241890,
            64239099,
            64237754
        ],
        "B": [
            64221631,
            64212047,
            64218399,
            64317159,
            64218926,
            64240089,
            64228311,
            64210409,
            64218403,
            64212202,
            64219328,
            64218836,
            64219933,
            64225452,
            64221378,
            64217229,
            64214632,
            64216240,
            64215942
        ],
        "D": [
            64215172,
            64216393,
            64233882,
            64227241,
            64227346,
            64251438,
            64216967,
            64223705,
            64223794,
            64230378,
            64223867,
            64223333,
            64232043,
            64229490,
            64228441,
            64222986,
            64234141,
            64223821,
            64223652
        ],
        "A": [
            64212957,
            64209179,
            64210635,
            64210231,
            64209282,
            64209523,
            64209181,
            64209149,
            64208937,
            64208806,
            64214758,
            64212460,
            64209582,
            64215325,
            64209661,
            64209581,
            64209733,
            64208776,
            64209184,
            64209129
        ]
    },
    "name": "D. Binary String Minimizing",
    "statement": "You are given a binary string of length n (i. e. a string consisting of\r\nn characters \u201d and \u201d).In one move you can swap two adjacent characters\r\nof the string. What is the lexicographically minimum possible string you\r\ncan obtain from the given one if you can perform than k moves? It is\r\npossible that you do not perform any moves at all.Note that you can swap\r\nthe same pair of adjacent characters with indices i and i+1 arbitrary\r\n(possibly, zero) number of times. Each such swap is considered a\r\nseparate move.You have to answer q independent test cases.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXA=2e6;\nlong long sum,k;\nchar s[MAXA];\nint n,j;\nvoid solve(){\n    sum=0;\n    scanf(\"%d%lld\",&n,&k);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;i++){\n\tif(s[i]=='1'){\n\t    sum++;\n\t}else{\n\t    if(k>=sum) k-=sum;\n\t    else{\n\t\tsum-=k;\n\t\tfor(j=i;k;j--)\n\t\t    if(k>0)\n\t\t\tk--,s[j]='1';\n\t\tif(j) s[j--]='0';\n\t\tfor(;j;j--)\n\t\t    if(sum>0) sum--,s[j]='1';\n\t\t    else s[j]='0';\n\t\tk=-1;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if(k>=0)\n\tfor(int i=n;i;i--)\n\t    if(sum>0) sum--,s[i]='1';\n\t    else s[i]='0';\n    for(int i=1;i<=n;i++) printf(\"%c\",s[i]);\n    printf(\"\\n\");\n}\nint main(){\n    int T;\n    scanf(\"%d\",&T);\n    while(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Binary String Minimizing.json",
    "editorial_link": "https://codeforces.com//blog/entry/71184",
    "editorial": "This problem has a very standard solution: let\u00e2\u0080\u0099s take the leftmost zero,\r\nplace it as left as possible, and solve the problem without this zero\r\nand all operations we spent.But we should do it fast. Let\u00e2\u0080\u0099s go from left\r\nto right and carry the number of ones on the prefix . If we meet , let\u00e2\u0080\u0099s\r\njust increase and continue the algorithm. It is obvious that if we meet\r\nwe need to make exactly swaps to place it before all ones. If we can do\r\nit, let\u00e2\u0080\u0099s just add to the answer, decrease by and continue. Otherwise,\r\nthis zero will be between some of these ones and we can place it\r\nnaively. In this case, the suffix of the string will not change. If\r\nafter all operations we didn\u00e2\u0080\u0099t meet the case above, let\u00e2\u0080\u0099s add all ones\r\nto the suffix of the resulting string.Time complexity: .\r\n"
}