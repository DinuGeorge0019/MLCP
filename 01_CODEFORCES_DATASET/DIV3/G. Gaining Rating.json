{
    "link": "https://codeforces.com//contest/1772/problem/G",
    "problemId": "1699974",
    "problem_idx": "G",
    "shortId": "1772G",
    "contest_number": "1772",
    "problem_submissions": {
        "G": [
            185866908,
            185868804,
            185873335,
            185913962,
            185953726,
            185952520,
            186850297,
            186850227
        ],
        "F": [
            185855303,
            185865062,
            185861633,
            185852805,
            185857933,
            185851728,
            185860856,
            185855787,
            185864352,
            185856328,
            185859258,
            185858451,
            185854822,
            185861128,
            185859138,
            185859632,
            185864434,
            185848000
        ],
        "E": [
            185833320,
            185824865,
            185853135,
            185836538,
            185842386,
            185826244,
            185841572,
            185838582,
            185836735,
            185840815,
            185835557,
            185845402,
            185841206,
            185838785,
            185849100,
            185834339,
            185850985,
            185860647
        ],
        "D": [
            185819090,
            185847079,
            185843120,
            185824661,
            185823461,
            185842011,
            185826918,
            185829038,
            185828215,
            185825456,
            185830337,
            185829367,
            185832845,
            185833254,
            185834612,
            216833286,
            185829200,
            185833219,
            185836837
        ],
        "C": [
            185812558,
            185814879,
            185826142,
            185808094,
            185813274,
            185814811,
            185816864,
            185820487,
            185822215,
            185810534,
            185819302,
            185820777,
            185825870,
            185828411,
            185818012,
            185822938,
            185815452,
            185822870
        ],
        "B": [
            185806303,
            185808530,
            185810358,
            185820249,
            185807477,
            185807452,
            185807615,
            185812963,
            185808450,
            185814127,
            185808442,
            185811020,
            185818101,
            185811312,
            185806644,
            185817751,
            185807928,
            185811595
        ],
        "A": [
            185798273,
            185798668,
            185799351,
            185798230,
            185798228,
            185798156,
            185800228,
            185799343,
            185809092,
            185800941,
            185802793,
            185811122,
            185800618,
            185798345,
            185801366,
            185799187,
            185805016
        ]
    },
    "name": "G. Gaining Rating",
    "statement": "Monocarp is playing chess on one popular website. He has n opponents he\r\ncan play with. The i-th opponent has rating equal to a_i. Monocarp’s\r\ninitial rating is x. Monocarp wants to raise his rating to the value y\r\n(y > x).When Monocarp is playing against one of the opponents, he will\r\nwin if his rating is bigger or equal to the opponent’s rating. If\r\nMonocarp wins, his rating is increased by 1, otherwise it is decreased\r\nby 1. The rating of his opponent does not change.Monocarp wants to gain\r\nrating y playing as few games as possible. But he can’t just grind it,\r\nplaying against weak opponents. The website has a rule that you should\r\nplay against all opponents as evenly as possible. Speaking formally, if\r\nMonocarp wants to play against an opponent i, there should be no other\r\nopponent j such that Monocarp has played more games against i than\r\nagainst j.Calculate the minimum possible number of games Monocarp needs\r\nto gain rating y or say it’s impossible. Note that ratings of Monocarp’s\r\nopponents change, while Monocarp’s rating does change.\r\n",
    "solutions": [
        "/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=3e5+5,mod=1e9+7;\nll n,m,k,a[N];\nvoid elixprep(){\n    \n}\nll climb (ll f, ll s, ll a, ll d){\n    return (s-f+a-d-1)/(a-d);\n}\nvoid elix()\n{\n    cin>>n>>m>>k;\n    rep(i,1,n) cin>>a[i];\n    sort(a+1,a+n+1);\n    ll tmp=m;\n    ll cnt=0,id=0;\n    rep(i,1,n) if (a[i]<=tmp){\n        cnt++;\n        tmp++;\n        id=i;\n        if (tmp==k){\n            cout<<cnt;\n            return;\n        }\n    }\n    else  tmp--;\n    if (tmp<=m){\n        cout<<-1;\n        return;\n    }\n    n++;\n    a[n]=k;\n    sort(a+1,a+n+1);\n    ll height=m+id-1;\n    ll res=id-1;\n    while (height<=k){\n        if (height>=a[id]){\n            id++;\n            height++;\n            res++;\n        }\n        else{\n            ll add=id-1,rem=n-id;\n            if (add==rem){\n                cout<<-1;\n                return;\n            }\n            tmp=climb(height,a[id],add,rem);\n            height+=tmp*(add-rem);\n            res+=tmp*(n-1);\n            res++;\n            id++;\n            height++;\n        }\n    }\n    cout<<res-height+k;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}\n//listen to trap music. it won't help"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Gaining Rating.json",
    "editorial_link": "https://codeforces.com//blog/entry/110313",
    "editorial": "After parsing the statement, you can understand that Monocarp plays\r\ncyclically: in one cycle, he chooses some order of opponents and play\r\nwith them in that order. Then repeats again and again, until he gains\r\ndesired rating at some moment.So, firstly, letâs prove that (in one\r\ncycle) itâs optimal to play against opponents in . Suppose you play with\r\nopponents in some order and there is a position where , if you swap and\r\nyou wonât lose anything and may even gain extra wins. It means that the\r\ntotal gain after playing one cycle in increasing order in greater or\r\nequal than playing in any other order.In other words, we can sort array\r\nand play against them cyclically in that order. Monocarpâs list of games\r\nwill look like several full cycles and some prefix. The problem is that\r\nthere can be many cycles, and we need to skip them in a fast way.How one\r\ncycle looks? Monocarp starts with some wins first games and then loses\r\nall other games ( games where ). The maximum rating he gains is and the\r\nresulting rating after all games is .We can already find several\r\nconditions of leaving a cycle: if then Monocarp gets what he wants and\r\nstops; otherwise, if (or ) he will never gain the desired rating, since\r\nin the next cycle the number of wins , since his starting rating\r\n.Otherwise, if and , he will start one more cycle with rating and will\r\ngain the desired rating , eventually. So, how to find the number of\r\ngames he will win for a starting rating ?Letâs calculate two values for\r\na given sorted skill array : for each letâs calculate the minimum rating\r\nMonocarp need to win opponent (and all opponent before) and the rating\r\nheâll get after winning the -th opponent.We can calculate these values\r\nin one iteration (weâll use -indexation): , ; then for each if then and\r\n, otherwise and .Now, knowing values itâs easy to find the number of\r\nwins for a starting rating : is equal to minimum such that (donât\r\nforget, -indexation). Or the first position in array with value strictly\r\ngreater than . We can search it with standard function, since array is\r\nsorted.Okay, we found the number of wins for the current . Letâs just\r\ncalculate how many cycles Monocarp will make with exactly wins. There\r\nare only two conditions that should be met in order to break this cycle:\r\neither Monocarp reaches rating it can be written as inequality , or the\r\nnumber of wins increases (starting rating becomes greater or equal than\r\n), i.e. .From the first inequality, we get minimum and from the second\r\none . As a result, we can claim that Monocarp will repeat the current\r\ncycle exactly times and either finish in the next turn or the number of\r\nwins will change.So, we can skip these equal cycles: we can increase\r\nanswer by and current rating by . Since we skip equal cycles, then at\r\neach step we either finish (with success or ), or the number of wins\r\nincreases. Since is bounded by , we will make no more than skips, and\r\ntotal complexity is because of initial sorting and calls of .\r\n",
    "hint": []
}