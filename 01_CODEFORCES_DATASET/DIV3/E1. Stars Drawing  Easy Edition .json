{
    "link": "https://codeforces.com//contest/1015/problem/E1",
    "problemId": "203550",
    "problem_idx": "E1",
    "shortId": "1015E1",
    "contest_number": "1015",
    "problem_submissions": {
        "F": [
            41046686,
            41089036,
            41088828,
            41088337,
            41096109,
            41155137
        ],
        "E2": [
            41044021,
            41044614,
            41045819,
            41046151,
            41041339,
            41120563,
            41047819,
            41049335,
            41046653,
            41047315,
            41056482,
            41049017,
            41046489,
            41053390,
            41052850,
            41051286,
            41054981,
            41057931,
            41047714,
            41052649,
            41063809,
            41051282
        ],
        "E1": [
            41043653,
            41042567,
            41045757,
            41045539,
            41040702,
            41045081,
            41043696,
            41046746,
            41047236,
            41044065,
            41048961,
            41046210,
            41043883,
            41050998,
            41051221,
            41044932,
            41048477,
            41047379,
            41051531,
            41047009
        ],
        "D": [
            41031342,
            41034646,
            41036110,
            41039331,
            41043349,
            41037861,
            41039026,
            41038448,
            41038110,
            41038683,
            41037715,
            41040743,
            41035875,
            41037945,
            41039903,
            41039757,
            41039527,
            41041117,
            41039970,
            41063782,
            41038156
        ],
        "B": [
            41028759,
            41027947,
            41029953,
            41029847,
            41027873,
            41030296,
            41030110,
            41028724,
            41031028,
            41029894,
            41029543,
            41031067,
            41030593,
            41029154,
            41029321,
            41029551,
            41029148,
            41033439,
            41031881,
            41028034
        ],
        "C": [
            41027720,
            41029992,
            41031722,
            41032867,
            41029608,
            41033310,
            41032299,
            41030539,
            41033426,
            41032047,
            41032615,
            41033736,
            41032226,
            41030814,
            41031207,
            41031359,
            41030973,
            41035988,
            41034551,
            41029776
        ],
        "A": [
            41025375,
            41025426,
            41026820,
            41025657,
            41025347,
            41026304,
            41026166,
            41025506,
            41029303,
            41025595,
            41025554,
            41027421,
            41025393,
            41025748,
            41025855,
            41025912,
            41025550,
            41026111,
            41026923,
            41025435
        ]
    },
    "name": "E1. Stars Drawing  Easy Edition ",
    "statement": "A is a figure of the following type: an asterisk character \u201d in the\r\ncenter of the figure and four rays (to the left, right, top, bottom) of\r\nthe same positive length. The size of a is the length of its rays. The\r\nsize of a star must be a positive number (i.e. rays of length 0 are not\r\nallowed).Let\u2019s consider empty cells are denoted by \u201d, then the following\r\nfigures are : You are given a rectangular grid of size n\r\ntimes m consisting only of asterisks \u201d and periods (dots) \u201d. Rows are\r\nnumbered from 1 to n, columns are numbered from 1 to m. Your task is to\r\ndraw this grid using number of or find out that it is impossible. can\r\nintersect, overlap or even coincide with each other. The number of in\r\nthe output can\u2019t exceed n\r\ncdot m. Each star should be completely inside the grid. You can use\r\nstars of same and arbitrary sizes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define p_b push_back\n#define endl \"\\n\"\n#define m_p make_pair\n#define fi first\n#define se second\n#define pll pair <ll,ll>\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\ntypedef long long ll;\n\nll binpow(ll a,ll n)\n{\n    ll res = 1;\n    while(n)\n    {\n        if(n % 2)res *= a;\n        a *= a;\n        n /= 2;\n    }\n    return res;\n}\n\ntemplate <typename T>\nT sqr(T x)\n{\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s)\n{\n    cout << s << endl;\n    exit(0);\n}\n\nll log(ll a,ll b){\n    ll res = 0;\n    while(a){\n        a /= b;\n        res++;\n    }\n    return res;\n}\n\nconst ll MAXN = 1123456;\n\nint n, m;\nll pref[1001][1001], prefu[1001][1001];\nchar a[1001][1001];\n\nll z[1003][1003], zu[1003][1003];\nll b[1003][1003];\n\nvector<pair<pll,ll> > ans;\n\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"1.in\",\"r\",stdin);\n    //freopen(\"1.out\",\"w\",stdout);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i){\n        for (int j = 1; j <= m; ++j){\n            cin >> a[i][j];\n            pref[i][j] = pref[i][j - 1] + (a[i][j] == '*');\n            prefu[i][j] = prefu[i - 1][j] + (a[i][j] == '*');\n        }\n    }\n\n    for (int i = 1; i <= n; ++i){\n        for (int j = 1; j <= m; ++j){\n            if (a[i][j] == '*'){\n                ll l = 0, r = min(m - j, min(i - 1, min(n - i, j - 1)));\n                ll p = r;\n\n\n//                if (i == 3 && j == 5) cout << pref[i][j + r] << \" \" <<  pref[i][j - r - 1] << \"+\" << endl;\n//                if (i == 3 && j == 5) cout << prefu[i + r][j] << \" \" <<  prefu[i - r - 1][j] << \"+\" << endl;\n\n                while (l + 1 < r){\n                    ll c = (l + r) / 2;\n                    if ((prefu[i + c][j] - prefu[i - c - 1][j] == (i + c) - (i - c) + 1)\n                     && (pref[i][j + c] - pref[i][j - c -1] == (i + c) - (i - c) + 1 )) l = c; else r = c - 1;\n                }\n                ll c = l + 1;\n                while (l != p && (prefu[i + c][j] - prefu[i - c - 1][j] == (i + c) - (i - c) + 1)\n                     && (pref[i][j + c] - pref[i][j - c -1] == (i + c) - (i - c) + 1 )) {\n                    l = c;\n                    c = l + 1;\n                     }\n//                if (i == 3 && j == 5) {\n//                    cout << l << \"___\" << endl;\n//                }\n\n                if (l != 0) {\n                    ans.p_b({{i, j}, l});\n                    zu[i - l][j] += 1;\n                    zu[i + l + 1][j] += -1;\n                    z[i][j - l] += 1;\n                    z[i][j + l + 1] += -1;\n                }\n            }\n        }\n    }\n\n\n    for (int i = 1; i <= n; i++) {\n        ll o = 0;\n        for (int j = 1; j <= m; j++) {\n            o += z[i][j];\n            b[i][j] += o;\n        }\n    }\n\n\n    for (int j = 1; j <= m; j++) {\n        ll o = 0;\n        for (int i = 1; i <= n; i++) {\n            o += zu[i][j];\n            b[i][j] += o;\n        }\n    }\n\n//    for (int i = 1; i <= n; i++) {\n//        for (int j = 1; j <= m; j++) cout << b[i][j] << \" \";\n//        cout << endl;\n//    }\n\n\n\n    for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n        if (a[i][j] == '*' && b[i][j] != 0) continue;\n        if (a[i][j] != '*' && b[i][j] == 0) continue;\n        cout << -1;\n        return 0;\n    }\n\n\n    cout << ans.size() << endl;\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i].fi.fi << \" \" << ans[i].fi.se << \" \" << ans[i].se << endl;\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. Stars Drawing  Easy Edition .json",
    "editorial_link": "https://codeforces.com/blog/entry/60949",
    "editorial": "Since we are almost unlimited in the number of in the answer, the\r\nfollowing solution will works. We iterate over all possible centers and\r\ntry to extend rays of the current as large as possible. It can be done\r\nby the simple iterating and checking in . If the size of the current is\r\nnon-zero, let\u00e2\u0080\u0099s add it to the answer. It is obvious that the number of\r\nin such answer will not exceed . Then let\u00e2\u0080\u0099s try to draw all these on the\r\nempty grid. Drawing of each is also can be done in . If after drawing\r\nour grid equals to the input grid, the answer is \"\" and our set of is\r\nthe correct answer. Otherwise the answer is \"\".Time complexity: .\r\n"
}