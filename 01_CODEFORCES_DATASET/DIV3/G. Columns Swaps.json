{
    "link": "https://codeforces.com//contest/1385/problem/G",
    "problemId": "675204",
    "problem_idx": "G",
    "shortId": "1385G",
    "contest_number": "1385",
    "problem_submissions": {
        "G": [
            87146925,
            87130516,
            87130073,
            87149307,
            87139436,
            87145109,
            87113469,
            87137001,
            87178119,
            87121112
        ],
        "F": [
            87133863,
            87148212,
            87150419,
            87133069,
            87155521,
            87156261,
            87129136,
            87201006,
            87199143,
            87198211,
            87198141,
            87197991,
            87133163,
            87135084,
            87147650,
            87153475,
            87157087,
            87159161,
            87143942,
            87140750,
            87158980
        ],
        "E": [
            87121743,
            87094311,
            87150777,
            87112227,
            87117131,
            87137692,
            87154530,
            87109484,
            87118031,
            87151551,
            87126695,
            87130754,
            87122234,
            87145112,
            87156780,
            87154434,
            87141435,
            87122925,
            87129785
        ],
        "D": [
            87114357,
            87136398,
            87136307,
            87098537,
            87103655,
            87133732,
            87148068,
            87097110,
            87107447,
            87106449,
            87137139,
            87106363,
            87103887,
            87118780,
            87124754,
            87090612,
            87122982,
            87110063,
            87101408,
            87100549
        ],
        "C": [
            87087119,
            87083714,
            87087183,
            87094082,
            87125584,
            87140844,
            87089726,
            87089545,
            87092040,
            87111442,
            87085820,
            87088762,
            87103769,
            87110798,
            87107696,
            87084280,
            87087235,
            87089175,
            87090633
        ],
        "B": [
            87082211,
            87084609,
            87082372,
            87086099,
            87118271,
            87134332,
            87085669,
            87082094,
            87085708,
            87097473,
            87081944,
            87080519,
            87090484,
            87088911,
            87082077,
            87081415,
            87081680,
            87080910,
            87083097
        ],
        "A": [
            87080978,
            87081308,
            87080529,
            87081521,
            87116439,
            87133004,
            87083295,
            87081194,
            87080773,
            87082296,
            87080859,
            87090051,
            87086698,
            87082297,
            87102822,
            87093275,
            87080753,
            87080503,
            87081225
        ]
    },
    "name": "G. Columns Swaps",
    "statement": "You are given a table a of size 2\r\ntimes n (i.e. two rows and n columns) consisting of integers from 1 to\r\nn.In one move, you can choose some j (1\r\nle j\r\nle n) and swap values a_{1, j} and a_{2, j} in it. Each column can be\r\nchosen .Your task is to find the number of moves required to obtain\r\npermutations of size n in both first and second rows of the table or\r\ndetermine if it is impossible to do that.You have to answer t\r\nindependent test cases.Recall that the permutation of size n is such an\r\narray of size n that contains from 1 to n exactly once (the order of\r\nelements doesn\u2019t matter).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\n#define x first\n#define y second\n\nconst int N = 300010;\n\nbool oddCyc;\nvector <pii> pos[N];\nbitset <N> vis, _fixed, flip;\nvector <int> g[N], nodes[N], cnt[2];\nint t, n, a[5][N], cur, comp[N], color[N];\n\nvoid go (int u) {\n  comp[u] = cur, nodes[cur].emplace_back(u);\n  for (int v : g[u]) if (!comp[v]) go(v); \n}\n\nvoid dfs (int u, int col = 0) {\n  if (oddCyc) return;\n  vis[u] = 1, color[u] = col;\n  for (int x : nodes[u]) cnt[col].emplace_back(x); \n  for (int v : g[u]) {\n    if (!vis[v]) dfs(v, col ^ 1);\n    else if (color[v] == col) {\n      oddCyc = 1;\n      return;\n    }\n  }\n}\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n      comp[i] = vis[i] = flip[i] = 0;\n      pos[i].clear(), g[i].clear(), nodes[i].clear(); \n    }\n    for (int i = 1; i <= 2; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        scanf(\"%d\", a[i] + j);\n        pos[a[i][j]].emplace_back(i, j);\n      }\n    }\n    bool bad = 0;\n    for (int i = 1; i <= n; ++i) {\n      if (pos[i].size() != 2) {\n        bad = 1;\n        break;\n      }\n    }\n    if (bad) {\n      puts(\"-1\");\n      continue;\n    }\n    for (int i = 1; i <= n; ++i) {\n      _fixed[i] = (a[1][i] == a[2][i]);\n    }\n    for (int i = 1; i <= n; ++i) {\n      if (_fixed[i]) continue;\n      int x = a[1][i], y = a[2][i];\n      {\n        if (pos[x][0] == pii(1, i)) {\n          swap(pos[x][0], pos[x][1]);\n        }\n        if (pos[x][0].x != 1) {\n          int j = pos[x][0].y;\n          g[i].emplace_back(j);\n        }\n      } {\n        if (pos[y][0] == pii(2, i)) {\n          swap(pos[y][0], pos[y][1]);\n        }\n        if (pos[y][0].x != 2) {\n          int j = pos[y][0].y;\n          g[i].emplace_back(j);\n        }\n      }\n    }\n    // for (int i = 1; i <= n; ++i) {\n    //   cout << i << \" --> \";\n    //   for (int j : g[i]) cout << j << \" \"; cout << '\\n';\n    // }\n    cur = 0;\n    for (int i = 1; i <= n; ++i) {\n      if (_fixed[i] or comp[i]) continue;\n      ++cur, go(i);\n    }\n    for (int i = 1; i <= n; ++i) {\n      g[i].clear();\n    }\n    for (int i = 1; i <= n; ++i) {\n      if (_fixed[i]) continue;\n      int x = a[1][i], y = a[2][i];\n      {\n        if (pos[x][0] == pii(1, i)) {\n          swap(pos[x][0], pos[x][1]);\n        }\n        if (pos[x][0].x == 1) {\n          int j = pos[x][0].y;\n          if (comp[i] == comp[j]) {\n            bad = 1;\n            break;\n          }\n          g[comp[i]].emplace_back(comp[j]);\n        }\n      } {\n        if (pos[y][0] == pii(2, i)) {\n          swap(pos[y][0], pos[y][1]);\n        }\n        if (pos[y][0].x == 2) {\n          int j = pos[y][0].y;\n          if (comp[i] == comp[j]) {\n            bad = 1;\n            break;\n          }\n          g[comp[i]].emplace_back(comp[j]);\n        }\n      }\n    }\n    if (bad) {\n      puts(\"-1\");\n      continue;\n    }\n    oddCyc = 0;\n    int tot = 0;\n    for (int i = 1; i <= cur; ++i) {\n      if (vis[i]) continue;\n      cnt[0].clear(), cnt[1].clear(), dfs(i);\n      if (oddCyc) break;\n      if (cnt[0].size() < cnt[1].size()) {\n        for (int x : cnt[0]) ++tot, flip[x] = 1;\n      } else {\n        for (int x : cnt[1]) ++tot, flip[x] = 1;\n      }\n    }\n    if (oddCyc) {\n      puts(\"-1\");\n      continue;\n    }\n    printf(\"%d\\n\", tot);\n    for (int i = 1; i <= n; ++i) {\n      if (flip[i]) printf(\"%d \", i);\n    }\n    puts(\"\");\n  }\n  return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Columns Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/80257",
    "editorial": "Firstly, we can determine that the answer is if some number has not two\r\noccurrences. Otherwise, the answer exists (and we actually don\u00e2\u0080\u0099t need to\r\nprove it because we can check it later). Let\u00e2\u0080\u0099s find for each number from\r\nto indices of columns in which it appears and . Consider some number .\r\nIf then let\u00e2\u0080\u0099s just skip it, we can\u00e2\u0080\u0099t change anything by swapping values\r\nin this column. Otherwise, let be the number of row of the number in the\r\ncolumn and is the number of row of the number in the column . If then\r\nit\u00e2\u0080\u0099s obvious that at exactly one of these two columns should be swapped.\r\nThe same, if then it\u00e2\u0080\u0099s obvious that we either swap both of them or don\u00e2\u0080\u0099t\r\nswap both of them. Let\u00e2\u0080\u0099s build a graph consisting of vertices, when the\r\nvertex determines the state of the -th column. If then let\u00e2\u0080\u0099s add edge of\r\ncolor between vertices and . Otherwise, let\u00e2\u0080\u0099s add the edge of color\r\nbetween these vertices.So, we have the graph consisting of several\r\nconnected components and some strange edges. Let\u00e2\u0080\u0099s color it. If the edge\r\nhas the color then the color of the vertex should be different from the\r\ncolor of the vertex . The same, if the edge has the color then the color\r\nof the vertex should be the same as the color of the vertex . This makes\r\nsense, because edges with color mean that exactly one of the columns\r\nconnected by this edge should be swapped (and vice versa).So, after we\r\ncolored the graph, we can ensure that conditions for each edge are\r\nsatisfied. If it isn\u00e2\u0080\u0099t so, the answer is (but this case can\u00e2\u0080\u0099t actually\r\nappear). Otherwise, we need to decide for each component independently,\r\nwhat is the color and the color means for it. The color can mean that\r\nthe column having this color isn\u00e2\u0080\u0099t swapped (and the color means that the\r\ncolumn having this color is swapped in this case) and vice versa. We can\r\nchoose greedily the minimum number of swaps for each component and print\r\nthe answer.Time complexity: .\r\n"
}