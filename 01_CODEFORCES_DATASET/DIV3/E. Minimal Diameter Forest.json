{
    "link": "https://codeforces.com//contest/1092/problem/E",
    "problemId": "271424",
    "problem_idx": "E",
    "shortId": "1092E",
    "contest_number": "1092",
    "problem_submissions": {
        "F": [
            47218597,
            47207874,
            47241634,
            47318477,
            47214615,
            47217604,
            47210093,
            47210748,
            47212691,
            47213985,
            47215066,
            47216141
        ],
        "D1": [
            47215980,
            47227965,
            47212365,
            47220485,
            47215001,
            47223458,
            47225913,
            47226094,
            47209533,
            47227527,
            47227478,
            47227395,
            47227268,
            47226719,
            47216461,
            47213724,
            47334192
        ],
        "D2": [
            47212833,
            47212767,
            47218226,
            47218497,
            47219527,
            47223320,
            47217259,
            47271469,
            47223969,
            47236061,
            47213976,
            47212963,
            47333101
        ],
        "C": [
            47208479,
            47202011,
            47208106,
            47207681,
            47211238,
            47213730,
            47205520,
            47206298,
            47207117,
            47206109,
            47208340,
            47227233,
            47226698,
            47207049,
            47207288,
            47209584,
            47210057,
            47206966,
            47207998
        ],
        "B": [
            47202083,
            47196597,
            47203007,
            47199377,
            47202631,
            47197720,
            47198736,
            47196902,
            47198167,
            47197186,
            47198915,
            47226662,
            47196684,
            47197714,
            47198493,
            47198454,
            47201892,
            47199196
        ],
        "A": [
            47200523,
            47196094,
            47201972,
            47196916,
            47200910,
            47196295,
            47196192,
            47197255,
            47196159,
            47196525,
            47196472,
            47196994,
            47226648,
            47196039,
            47196511,
            47196950,
            47196914,
            47198726,
            47197707
        ],
        "E": [
            47266392,
            47319938,
            47234188,
            47277429,
            47369991
        ]
    },
    "name": "E. Minimal Diameter Forest",
    "statement": "You are given a forest an undirected graph with n vertices such that\r\neach its connected component is a tree.The diameter (aka \"longest\r\nshortest path\") of a connected undirected graph is the maximum number of\r\nedges in the path between any pair of its vertices.You task is to add\r\nsome edges (possibly zero) to the graph so that it becomes a tree and\r\nthe diameter of the tree is minimal possible.If there are multiple\r\ncorrect answers, print any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long   ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii > vpi;\n\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3f\n#define all(x) x.begin(),x.end()\n#define MOD 1000000007LL\n#define endl '\\n'\n#define mdc(a, b) (__gcd((a), (b)))\n#define mmc(a, b) (((a)*(b))/__gcd((a), (b)))\n#define MAXN 110\n\nint n, m;\nbool processado[1010];\nvector<int> adj[1010];\nset<int> componentes[1010];\nint grau[1010];\nint c = 0;\n\nvoid dfs_c(int v, int p){\n\tif(processado[v])\n\t\treturn;\n\t\n\tprocessado[v] = true;\n\tcomponentes[c].insert(v);\n\t\n\tfor(int u: adj[v]){\n\t\tif(u == p)\n\t\t\tcontinue;\n\t\t\t\n\t\tdfs_c(u, v);\n\t}\n}\n\nint dist_ult, ult;\n\nvoid dfs_d(int v, int p, int d){\t\n\tif(d > dist_ult){\n\t\tult = v;\n\t\tdist_ult = d;\t\n\t}\n\t\n\tfor(int u: adj[v]){\n\t\tif(u == p)\n\t\t\tcontinue;\n\t\t\t\n\t\tdfs_d(u, v, d+1);\n\t}\n}\nint central;\nint max_d;\n\nint main(){\n\tcin.tie(0);\n\tcin.sync_with_stdio(0);\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i=0; i<m; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t\t\n\t\tgrau[x]++;\n\t\tgrau[y]++;\n\t}\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tif(!processado[i]){\n\t\t\tdfs_c(i, 0);\n\n\t\t\tult = 0;\n\t\t\tdist_ult = 0;\n\t\t\t\n\t\t\tdfs_d(i, 0, 0);\n\t\t\tdfs_d(ult,0, 0);\n\n\t\t\tif(dist_ult > max_d){\n\t\t\t\tcentral = c;\n\t\t\t\tmax_d = dist_ult;\n\t\t\t}\t\t\t\t\t\t\n\t\t\t\n\t\t\tc++;\n\t\t}\n\t}\n\t\n\tfor(int ic=0; ic<c; ic++){\n\t\tqueue<int> fila;\n\t\t\n\t\tfor(int v: componentes[ic]){\n\t\t\tif(grau[v] == 1)\n\t\t\t\tfila.push(v);\n\t\t}\n\t\t\n\t\twhile(componentes[ic].size() > 2u){\n\t\t\tint qtd = fila.size();\n\t\t\t\n\t\t\tfor(int i=0; i<qtd; i++){\n\t\t\t\tint f = fila.front();\n\t\t\t\tfila.pop();\n\t\t\t\t\n\t\t\t\tfor(int u: adj[f]){\n\t\t\t\t\tif(grau[u] > 0){\n\t\t\t\t\t\tgrau[u]--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(grau[u] == 1)\t\t\t\t\t\n\t\t\t\t\t\tfila.push(u);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcomponentes[ic].erase(f);\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int ic=0; ic < c; ic++){\n\t\tif(ic == central)\n\t\t\tcontinue;\n\t\t\t\n\t\tint x = *(componentes[central].begin());\n\t\tint y = *(componentes[ic].begin());\n\t\t\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\t\t\n\t}\t\t\n\t\n\tult = 0;\n\tdist_ult = 0;\n\t\n\tdfs_d(1, 0, 0);\n\tdfs_d(ult,0, 0);\n\t\n\tcout << dist_ult << endl;\n\t\n\tfor(int ic=0; ic < c; ic++){\n\t\tif(ic == central)\n\t\t\tcontinue;\n\t\t\t\n\t\tint x = *(componentes[central].begin());\n\t\tint y = *(componentes[ic].begin());\n\t\t\n\t\tcout << x << \" \" << y << endl;\n\t}\t\t\n\t\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Minimal Diameter Forest.json",
    "editorial_link": "https://codeforces.com//blog/entry/63961",
    "editorial": "Letâs start with the solution and then proceed to the proof.For each\r\ntree in a forest find such a vertex that the maximal distance from it to\r\nany vertex is minimal possible (a center of a tree). Tree may include\r\ntwo centers, take any of them in that case. Find the the tree with the\r\nmaximum diameter. Connect the centers of other trees with its\r\ncenter.Overall complexity is the complexity of looking for a diameter:\r\nor . The center is the best vertex in a tree to connect to. The diameter\r\nof merging two trees and by in and in with being the maximum shortest\r\npath from to any other vertex in , being the same for in is . Thus\r\nminimizing both and will produce the best result. The most optimal\r\nstructure is a star. The center tree will be connected directly to any\r\nother tree. The other trees will be connected through a single vertex\r\namong each other, which leads to the answer no more than 1 worse than\r\nconnecting them directly. And building the answer the other way will\r\nexceed this difference as some tree will be connected to the center tree\r\nof the star through one vertex as well. The previous fact implies that\r\nthe center tree of the star should have the maximal diameter among all\r\ntrees.\r\n",
    "hint": []
}