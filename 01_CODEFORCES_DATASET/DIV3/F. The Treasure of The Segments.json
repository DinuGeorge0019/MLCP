{
    "link": "https://codeforces.com//contest/1462/problem/F",
    "problemId": "833575",
    "problem_idx": "F",
    "shortId": "1462F",
    "contest_number": "1462",
    "problem_submissions": {
        "F": [
            101312311,
            101295944,
            101308624,
            101308817,
            101304111,
            101280435,
            101305797,
            101310367,
            101305342,
            101311228,
            101404636,
            101403975,
            101311880,
            101300846,
            101321777,
            101323660,
            101322804,
            101312196,
            101317325,
            101337936,
            101324335,
            101318324
        ],
        "E2": [
            101285396,
            101295162,
            101287717,
            101294090,
            101294721,
            101302415,
            101297486,
            101291336,
            101285191,
            101301715,
            101403947,
            101297838,
            101320202,
            101301546,
            101293087,
            101297518,
            101302712,
            101306390,
            101284328,
            101307237,
            101300711
        ],
        "E1": [
            101282369,
            101288225,
            101284658,
            101287780,
            101297537,
            101304897,
            101298622,
            101296342,
            101290668,
            101295792,
            101403926,
            101300370,
            101291439,
            101292410,
            101297049,
            101300114,
            101296216,
            101298222,
            101280004,
            101327539,
            101299484,
            101303183
        ],
        "D": [
            101276901,
            101274657,
            101273346,
            101282814,
            101282205,
            101287581,
            101290967,
            101279699,
            101299600,
            101289409,
            101403847,
            101286604,
            101293181,
            101285967,
            101285140,
            101285937,
            101287608,
            101292000,
            101304911,
            101416082,
            101283715,
            101288370
        ],
        "C": [
            101268521,
            101264616,
            101269281,
            101273876,
            101272004,
            101269250,
            101272117,
            101267115,
            101271243,
            101273829,
            101403759,
            101275279,
            101269069,
            101275015,
            101277128,
            101275423,
            101281795,
            101279889,
            101270679,
            101277574,
            101275915
        ],
        "B": [
            101264269,
            101265842,
            101265325,
            101264865,
            101264553,
            101265746,
            101267507,
            101270770,
            101264118,
            101266219,
            101403739,
            101270231,
            101266677,
            101264816,
            101274093,
            101269885,
            101269868,
            101266304,
            101266579,
            101415580,
            101272178,
            101266529
        ],
        "A": [
            101259376,
            101261449,
            101259287,
            101259205,
            101260758,
            101260150,
            101263911,
            101273333,
            101279124,
            101260299,
            101403717,
            101261323,
            101259580,
            101259586,
            101264162,
            101263539,
            101264411,
            101259503,
            101259664,
            101259533,
            101260523
        ]
    },
    "name": "F. The Treasure of The Segments",
    "statement": "Polycarp found n segments on the street. A segment with the index i is\r\ndescribed by two integers l_i and r_i coordinates of the beginning and\r\nend of the segment, respectively. Polycarp realized that he didn\u2019t need\r\nall the segments, so he wanted to delete some of them.Polycarp believes\r\nthat a set of k segments is good if there is a segment [l_i, r_i] (1\r\nleq i\r\nleq k) from the set, such that it intersects every segment from the set\r\n(the intersection must be a ). For example, a set of 3 segments [[1, 4],\r\n[2, 3], [3, 6]] is good, since the segment [2, 3] intersects each\r\nsegment from the set. Set of 4 segments [[1, 2], [2, 3], [3, 5], [4, 5]]\r\nis not good.Polycarp wonders, what is the minimum number of segments he\r\nhas to delete so that the remaining segments form a good set?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define si short int\n#define speed ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define pill pair<ll,ll>\n#define f first\n#define s second\n#define pilc pair<ll,char>\n#define all(a) (a).begin(),(a).end()\n#define rep(s,e,step) for(int i = (s); i < (e) ; i += step)\n#define vrep(s,e,step) for(int j = (s); j < (e) ; j += step)\n#define ex exit(0) \n#define sz(a) (a).size()\n#define triple pair<pill, ll>\n#define pinode pair<node*, node*>\n#define quadra pair<pill, pill>\n#define ld long double\nusing namespace std;\n \nconst ll N = 7e5 + 10;\nconst ll M = 8e5 + 121;\nconst ll big = 1e18;\nconst ll hsh2 = 1964325029 ;\nconst long long mod = 1e9 + 7;\nconst long double EPS = 1e-14;\nconst ll block = 1e7;\nconst ll shift = 2e3;\nmt19937_64 rofl(chrono::steady_clock::now().time_since_epoch().count());\n\nll t, n;\nll L[N], R[N];\n\n\nvoid solve() {\n\tcin >> n;\t\n\tvector<ll> Ll, Rr;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> L[i] >> R[i];\n\t\tLl.pb(L[i]), Rr.pb(R[i]);\n\t}\n\tsort(all(Ll)), sort(all(Rr));\n\tll sub = big, ans = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t    ans = 0;\n\t\tll z = lower_bound(all(Rr), L[i]) - Rr.begin();\n\t\tans += z + (Rr[z] < L[i]);\n\t\tz = upper_bound(all(Ll), R[i]) - Ll.begin(); \n\t\tans += n - z;\n\t\tsub = min(ans, sub);\t \t\t\n\t}\n\tcout << sub << '\\n';\n\tLl.clear(), Rr.clear();\n}\n\nint main() {\n\tspeed;\n\tcin >> t;\n\twhile(t--)solve(); \t\n}              \n/*\nqiwwqdesw\n1\nd\n \n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. The Treasure of The Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/85594",
    "editorial": "As we know from the problem statement:Polycarp believes that a set of\r\nsegments is good if there is a segment () from the set, such that it\r\nintersects every segment from the set (the intersection must be a\r\n).Let\u00e2\u0080\u0099s iterate over this segment (which intersects all the others) and\r\nconstruct a good set of the remaining segments, maximum in terms of\r\ninclusion. It is easy to understand that this set will include all\r\nsegments that intersect with ours. We must delete all other segments.Two\r\nsegments and intersect if . Then if the segment that we iterate over has\r\ncoordinates , then we must remove all such segments for which or is\r\nsatisfied (that is, the segment ends earlier than ours begins, or vice\r\nversa).Note that these two conditions cannot be fulfilled\r\nsimultaneously, since , and if both conditions are satisfied, then .\r\nThis means that we can count the number of segments suitable for these\r\nconditions independently.Each of these conditions is easy to handle.\r\nLet\u00e2\u0080\u0099s create two arrays all the left boundaries of the segments and all\r\nthe right boundaries of the segments. Let\u00e2\u0080\u0099s sort both arrays. Now we can\r\ncount the required quantities using the binary search or prefix sums\r\n(but in this case, we need to use the coordinate compression\r\ntechnique).Taking at least the number of deleted segments among all the\r\noptions, we will get the answer to the problem.\r\n"
}