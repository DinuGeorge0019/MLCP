{
    "link": "https://codeforces.com//contest/1165/problem/F1",
    "problemId": "344229",
    "problem_idx": "F1",
    "shortId": "1165F1",
    "contest_number": "1165",
    "problem_submissions": {
        "E": [
            74168826,
            54121468,
            54122421,
            54122348,
            54116263,
            54119183,
            54211518,
            54211463,
            54118142,
            54113180,
            54117307,
            54121110,
            54120513,
            54122624,
            54127192,
            54117866,
            54118124,
            54124485,
            54122820
        ],
        "B": [
            63291233,
            54151541,
            54101310,
            54100421,
            54105105,
            54131850,
            54101616,
            54100060,
            54100069,
            54099555,
            54101691,
            54099268,
            54099031,
            54101885,
            54103193,
            54099307,
            54102255,
            54100792,
            54100984
        ],
        "F2": [
            54132403,
            54136514,
            54134718,
            54126842,
            54151618,
            54135465,
            54132023,
            54139391,
            54337431,
            54960943,
            54166271,
            54138472
        ],
        "F1": [
            54131988,
            54136472,
            54134416,
            54126974,
            54135962,
            54135141,
            54132170,
            54140202,
            54960902,
            54166160,
            54138784
        ],
        "D": [
            54109839,
            54117304,
            54105563,
            54135713,
            54113803,
            54110973,
            54108935,
            54107066,
            54111285,
            54106307,
            54112713,
            54115828,
            54113528,
            54113659,
            54110000,
            54111928,
            54118727,
            54112645
        ],
        "C": [
            54104004,
            54104201,
            54114484,
            54122709,
            54107745,
            54103677,
            54101770,
            54102480,
            54107031,
            54103126,
            54104499,
            54106842,
            54107386,
            54107262,
            54106153,
            54107484,
            54116941
        ],
        "A": [
            54099583,
            54099103,
            54099763,
            54117054,
            54101453,
            54099189,
            54099082,
            54100008,
            54100551,
            54108006,
            54100277,
            54100622,
            54098895,
            54099596,
            54099615,
            54099150
        ]
    },
    "name": "F1. Microtransactions  easy version ",
    "statement": ".Ivan plays a computer game that contains some microtransactions to make\r\ncharacters look cooler. Since Ivan wants his character to be really\r\ncool, he wants to use some of these microtransactions and he won’t start\r\nplaying until he gets all of them.Each day (during the ) Ivan earns\r\nexactly one burle.There are n types of microtransactions in the game.\r\nEach microtransaction costs 2 burles usually and 1 burle if it is on\r\nsale. Ivan has to order exactly k_i microtransactions of the i-th type\r\n(he orders microtransactions during the ).Ivan can order (possibly zero)\r\nnumber of microtransactions of types during any day (of course, ). If\r\nthe microtransaction he wants to order is on sale then he can buy it for\r\n1 burle and otherwise he can buy it for 2 burles.There are also m\r\nspecial offers in the game shop. The j-th offer (d_j, t_j) means that\r\nmicrotransactions of the t_j-th type are on sale during the d_j-th\r\nday.Ivan wants to order all microtransactions as soon as possible. Your\r\ntask is to calculate the minimum day when he can buy all\r\nmicrotransactions he want and actually start playing.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl '\\n'\n#define ls x<<1\n#define rs x<<1|1\nconst LL N=4e5+7,mod=998244353,INF=1e9;\nint n,m;\nint a[N],b[N];\nvector<int>v[N];\nint check(int x,int y){\n    int re=x,cnt=0;\n    int flag=0;\n    for(int i=1;i<=n;i++)b[i]=a[i];\n    for(int i=x;i>=1;i--){\n            //cout<<i<<' '<<re<<endl;\n        for(int j=0;j<v[i].size();j++){\n            while(b[v[i][j]]&&re){\n                re--;\n                y--;\n                b[v[i][j]]--;\n            }\n        }\n        if(re>=i)re--,flag++;\n    }\n    return flag/2>=y;\n}\nint main()\n{\n    cin>>n>>m;\n    int cnt=0;\n    for(int i=1;i<=n;i++){\n        scanf(\"%d\",&a[i]);\n        cnt+=a[i];\n    }\n    int x,y;\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\",&x,&y);\n        v[x].PB(y);\n    }\n    int ans=INF;\n    int l=cnt,r=2*cnt;\n    while(l<=r){\n        int mid=l+r>>1;\n        if(check(mid,cnt)){\n            ans=min(ans,mid);\n            r=mid-1;\n        }\n        else l=mid+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F1. Microtransactions  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/67041",
    "editorial": "Letâs iterate over all possible answers. Obviously, this value is always\r\nin the range . The first day when Ivan can order all microtransactions\r\nhe wants will be the answer. How to check if the current day is enough\r\nto order everything Ivan wants?If we had several sale days for some type\r\nof microtransaction (of course, we can use only such days that are not\r\ngreater than the fixed last day ), letâs use the last one, it is always\r\nnot worse than some of the previous days. Then letâs iterate over all\r\ndays from to and do the following: firstly, letâs increase our balance\r\nby one burle. Then letâs try to order all microtransactions for which\r\nthe current day is the last sale day (and pay one burle per copy). If we\r\nare out of money at some moment then just say that we should order all\r\nmicrotransactions that remain in this sale day during the last day for\r\ntwo burles per copy. It is true because it does not matter which types\r\nwill remain because this day is the last sale day for all of these\r\ntypes. So, after all, we had some remaining microtransactions that we\r\ncannot buy during sales, and the current balance. And the current day is\r\ngood if the number of such microtransactions multiplied by two is not\r\ngreater than the remaining balance.\r\n",
    "hint": []
}