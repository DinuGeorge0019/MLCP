{
    "link": "https://codeforces.com//contest/2050/problem/D",
    "problemId": "3070029",
    "problem_idx": "D",
    "shortId": "2050D",
    "contest_number": "2050",
    "problem_submissions": {
        "G": [
            295020039,
            295012969,
            295024810,
            295026123,
            295231485,
            295230757,
            295027068,
            295011107,
            295020886,
            295043604,
            295023074,
            295040334,
            295040501,
            295044199,
            295042105,
            295035503,
            295046172,
            295069369,
            295055294,
            295058073
        ],
        "D": [
            295023542,
            295007735,
            295022150,
            295015640,
            295022096,
            295027211,
            295005995,
            295007532,
            295010040,
            295008211,
            295013052,
            295007075,
            295014360,
            295012052,
            295012580,
            295012327,
            295010790
        ],
        "F": [
            295009915,
            295016605,
            295015909,
            295021788,
            295023146,
            295035635,
            295031460,
            295012371,
            295027547,
            295033629,
            295028476,
            295029305,
            295012244,
            295027355,
            299441454,
            295024166,
            295024859,
            295021290
        ],
        "E": [
            295006159,
            295012248,
            295006655,
            295358340,
            294991246,
            295015587,
            295010009,
            295016041,
            295017979,
            295016907,
            295021107,
            295017866,
            295008404,
            295002349,
            295018392,
            295017130,
            295019301,
            295028396
        ],
        "C": [
            295000545,
            295002243,
            294997256,
            295011626,
            295006375,
            295000328,
            295001562,
            295020525,
            295004225,
            295001544,
            295003470,
            294999298,
            295008085,
            295003035,
            295005025,
            295008622,
            295001249
        ],
        "B": [
            294992701,
            294994611,
            294990329,
            295007113,
            294997489,
            294992969,
            294992993,
            295002206,
            294997468,
            294994758,
            294991989,
            294994433,
            294994702,
            294998118,
            294998487,
            295000433,
            294997971
        ],
        "A": [
            294987570,
            294988254,
            294987535,
            294987637,
            294990076,
            294987812,
            294987751,
            294999699,
            294989420,
            294988260,
            294987843,
            294987612,
            294989111,
            294989647,
            294989965,
            294992026,
            294994133
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137018",
    "editorial": "Let\u00e2\u0080\u0099s look at digit . We can see that we can\u00e2\u0080\u0099t move it to the left more\r\nthan times because it will be after. So, we can say that only digits on\r\nindices from to can stand on index , because the maximum digit can be\r\nmoved to the left no more than times.Thus, for each we can brute force\r\nall digits from to and pick such that is maximum; if we have multiple\r\nmaximum options, we will minimize . After that, we will move to the left\r\nuntil it is on index .\r\n",
    "name": "D. Digital string maximization",
    "statement": "You are given a string s, consisting of digits from 0 to 9. In one\r\noperation, you can pick any digit in this string, except for 0 or the\r\nleftmost digit, decrease it by 1, and then swap it with the digit left\r\nto the picked.For example, in one operation from the string 1023, you\r\ncan get 1103 or 1022.Find the lexicographically maximum string you can\r\nobtain after any number of operations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0int main(){    ios::sync_with_stdio(false);    cin.tie(0);    int t;    cin >> t;    while(t--){        string s;        cin >> s;        int n = s.length();        vector<int> a(n);        for(int i=0;i<n;i++) a[i] = s[i]-'0';        for(int i=0;i<n;i++){            int end = min(i +9, n-1);            int max_val = a[i];            int j =i;            for(int t=i; t<=end; t++){                int current_val = a[t] - (t -i);                if(current_val > max_val){                    max_val = current_val;                    j =t;                }            }            if(j !=i){                int temp = a[j] - (j -i);                for(int k=j; k>i; k--){                    a[k] =a[k-1];                }                a[i] =temp;            }        }        string res = \"\";        for(auto d: a) res += to_string(d);        cout << res << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Digital string maximization.json"
}