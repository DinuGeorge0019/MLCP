{
    "link": "https://codeforces.com//contest/1690/problem/F",
    "problemId": "1423054",
    "problem_idx": "F",
    "shortId": "1690F",
    "contest_number": "1690",
    "problem_submissions": {
        "F": [
            159806986,
            159794535,
            159803560,
            159795356,
            159803611,
            159810003,
            161958741,
            159901379,
            159799120,
            159805990,
            159805447,
            159834670,
            159815479,
            159815758,
            159832304,
            159791660,
            159812232,
            159823656,
            159820324,
            159819489,
            159793231,
            159818514
        ],
        "G": [
            159789082,
            159825164,
            159831504,
            159831419,
            159832391,
            159839709,
            159834673,
            159846076,
            159851606,
            159849999,
            159835741,
            159843351,
            159856244,
            159825213,
            159841650,
            159850090,
            159841330,
            159847201,
            159833351,
            159855753
        ],
        "E": [
            159767819,
            159765301,
            159753624,
            159775193,
            159777984,
            159782869,
            159901400,
            159779470,
            159776567,
            159781160,
            159789988,
            159788967,
            159791938,
            159787307,
            159768121,
            159785541,
            159787298,
            159790761,
            159810098,
            159800474,
            159767523,
            159788062
        ],
        "D": [
            159735426,
            159753255,
            159744844,
            159759311,
            159761856,
            159749129,
            159760845,
            159762141,
            159745073,
            159747365,
            159767078,
            159764956,
            159753841,
            159768103,
            159754604,
            159758954,
            159769246,
            159761854,
            159752872,
            159766823
        ],
        "A": [
            159733481,
            159728723,
            159728980,
            159730869,
            159729579,
            159730292,
            159735804,
            159735374,
            159729478,
            159730047,
            159903613,
            159739525,
            159731331,
            159729145,
            159767995,
            159729359,
            159733585,
            159735989,
            159738194,
            159732884,
            159737457
        ],
        "B": [
            159731273,
            159733842,
            159733916,
            159746458,
            159736988,
            159735973,
            159743542,
            159743382,
            159735141,
            159735777,
            159750550,
            159745379,
            159735239,
            159770854,
            159740998,
            159742110,
            159755056,
            159746312,
            159757832,
            159745537
        ],
        "C": [
            159728882,
            159740086,
            159737931,
            159750746,
            159754739,
            159743933,
            159755874,
            159756762,
            159741517,
            159742259,
            159760507,
            159757905,
            159746715,
            159768067,
            159748475,
            159749851,
            159762561,
            159752246,
            159835353,
            159760474
        ]
    },
    "name": "F. Shifting String",
    "statement": "Polycarp found the string s and the permutation p. Their lengths turned\r\nout to be the same and equal to n.A permutation of n elements is an\r\narray of length n, in which every integer from 1 to n occurs exactly\r\nonce. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but\r\n[1, 2, 4], [4, 3, 2, 1, 2] and [0, 1, 2] are not.In one operation he can\r\nmultiply s by p, so he replaces s with string new, in which for any i\r\nfrom 1 to n it is true that new_i = s_{p_i}. For example, with s=wmbe\r\nand p = [3, 1, 4, 2], after operation the string will turn to s=s_3 s_1\r\ns_4 s_2=bwem.Polycarp wondered after how many operations the string\r\nwould become equal to its initial value for the first time. Since it may\r\ntake too long, he asks for your help in this matter.It can be proved\r\nthat the required number of operations always exists. It can be very\r\nlarge, so use a 64-bit integer type.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1'000'000'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nstring perm(string &s, vector<int> &p){\n    int n = s.size();\n    string t(n, '1');\n    for(int i = 0;i < n;i++){\n        t[p[i]] = s[i];\n    }\n    return t;\n}\nint lcm(int a, int b){\n    return a / __gcd(a, b) * b;\n}\nstring gt(string &s, vector<int> &d){\n    string t = \"\";\n    for(int i = 0;i < d.size();i++){\n        t += s[d[i]];\n    }\n    return t;\n}\nvoid solve(){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> p(n);\n    for(int i = 0;i < n;i++){\n        cin >> p[i];\n        p[i]--;\n    }\n    vector<vector<int>> cycles;\n    vector<bool> used(n, false);\n    for(int i = 0;i < n;i++){\n        if(used[i])continue;\n        vector<int> t;\n        int x = i;\n        while(!used[x]){\n            used[x] = true;\n            t.push_back(x);\n            x = p[x];\n        }\n        //sort(t.begin(), t.end());\n        cycles.push_back(t);\n    }\n    vector<string> d;\n    for(int i = 0;i < n + 1;i++){\n        d.push_back(s);\n        s = perm(s, p);\n    }\n    vector<int> need(cycles.size());\n    for(int i = 0;i < need.size();i++){\n        string t = gt(d[0], cycles[i]);\n        need[i] = 1;\n        for(int j = 1;j < d.size();j++){\n            string p = gt(d[j], cycles[i]);\n            if(p == t){\n                need[i] = j;\n                break;\n            }\n        }\n    }\n    int ans = 1;\n    for(int i = 0;i < need.size();i++){\n        ans = lcm(ans, need[i]);\n    }\n    cout << ans << endl;\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "math",
        "number theory",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Shifting String.json",
    "editorial_link": "https://codeforces.com//blog/entry/103658",
    "editorial": "To begin with, letâs understand why the string will return to its\r\noriginal form. In fact, the graph that the permutation sets consists of\r\nsimple cycles and it turns out that after a certain number of\r\noperations, each character will return to its place.Consider each cycle\r\nas a string that is cyclically shifted every turn. It may seem that the\r\nanswer is (the smallest common multiple) of the cycle lengths, but to\r\nbecome equal to the initial string, it is not necessary to go through\r\nthe entire cycle. The constraints allow us to calculate the length of\r\nthe minimum suitable shift in , where is the length of the cycle, so\r\njust iterate over the desired shift. Note that after operations, the\r\ncycle will return to its original form and this will happen again after\r\noperations.The answer will be of all , since each cycle individually\r\ncomes to its original form after the number of operations is a multiple\r\nof its .\r\n",
    "hint": []
}