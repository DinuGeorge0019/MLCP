{
    "link": "https://codeforces.com//contest/1409/problem/E",
    "problemId": "716928",
    "problem_idx": "E",
    "shortId": "1409E",
    "contest_number": "1409",
    "problem_submissions": {
        "F": [
            91841452,
            91841006,
            91847094,
            91849145,
            91853876,
            91853063,
            91844676,
            91826529,
            91863527,
            91862569,
            91861696,
            91867633,
            91863103,
            91860709,
            91861645,
            91851313,
            91859301,
            91874305,
            91863916,
            91868988
        ],
        "E": [
            91827324,
            91839984,
            91836314,
            91835556,
            91831349,
            91852207,
            91886381,
            91857615,
            91843090,
            91845624,
            91838339,
            91851120,
            91837678,
            91852948,
            91866189,
            91853121,
            91849423,
            91856636,
            91853663
        ],
        "D": [
            91824220,
            91828702,
            91829052,
            91826254,
            91834063,
            91852756,
            91824308,
            91834176,
            91832475,
            91841859,
            91848714,
            91840119,
            91835288,
            91844671,
            91837282,
            91846495,
            91838632
        ],
        "C": [
            91818297,
            91820814,
            91822012,
            91821252,
            91820474,
            91823540,
            91825047,
            91828813,
            91828605,
            91824227,
            91820725,
            91829115,
            91823214,
            91824095,
            91821560,
            91823224,
            91828004,
            91829526
        ],
        "B": [
            91812965,
            91813416,
            91816401,
            91808485,
            91814835,
            91816697,
            91810019,
            91810994,
            91822185,
            91815944,
            91811525,
            91819746,
            91813210,
            91817451,
            91814034,
            91810729,
            91815998,
            91816789
        ],
        "A": [
            91801654,
            91804481,
            91803475,
            91801145,
            91812176,
            91802127,
            91801025,
            91800872,
            91805502,
            91801293,
            91801197,
            91802135,
            91802754,
            91805435,
            91802071,
            91800716,
            91803654,
            91812308
        ]
    },
    "name": "E. Two Platforms",
    "statement": "There are n points on a plane. The i-th point has coordinates (x_i,\r\ny_i). You have two horizontal platforms, both of length k. Each platform\r\ncan be placed anywhere on a plane but it should be placed (on the same\r\ny-coordinate) and have . If the left border of the platform is (x, y)\r\nthen the right border is (x + k, y) and all points between borders\r\n(including borders) belong to the platform.Note that platforms can share\r\ncommon points (overlap) and it is not necessary to place both platforms\r\non the same y-coordinate.When you place both platforms on a plane, all\r\npoints start falling down decreasing their y-coordinate. If a point\r\ncollides with some platform at some moment, the point stops and is .\r\nPoints which never collide with any platform are lost.Your task is to\r\nfind the maximum number of points you can if you place both platforms\r\noptimally.You have to answer t independent test cases.For better\r\nunderstanding, please read the section below to see a picture for the\r\nfirst test case.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long lli;\ntypedef pair<int, int> ii;\ntypedef pair<lli, lli> ll;\n\nint x[200005], len[200005], suff[200005];\n\nint main() {\n\tint tc, n, k, y, r, temp, maxi;\n\tscanf(\"%d\", &tc);\n\twhile (tc--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &x[i]);\n\t\tsort(x, x + n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &y);\n\t\tr = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (r + 1 < n) {\n\t\t\t\tif (x[r + 1] > x[i] + k)\n\t\t\t\t\tbreak;\n\t\t\t\tr++;\n\t\t\t}\n\t\t\tlen[i] = r - i + 1;\n\t\t}\n\t\tsuff[n - 1] = len[n - 1];\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tsuff[i] = max(suff[i + 1], len[i]);\n\t\tmaxi = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttemp = len[i];\n\t\t\tr = i + temp;\n\t\t\tif (r < n)\n\t\t\t\ttemp += suff[r];\n\t\t\tmaxi = max(maxi, temp);\n\t\t}\n\t\tprintf(\"%d\\n\", maxi);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Two Platforms.json",
    "editorial_link": "https://codeforces.com//blog/entry/82284",
    "editorial": "Firstly, we obviously donât need -coordinates at all because we can\r\nplace both platforms at . Letâs sort all -coordinates in non-decreasing\r\norder.Calculate for each point two values and , where is the number of\r\npoints to the left from the point (including ) that are not further than\r\nfrom the -th point (i.e. the number of such points that ). And is the\r\nnumber of points to the right from the point (including ) that are not\r\nfurther than from the -th point. Both these parts can be done in using\r\ntwo pointers.Then letâs build suffix maximum array on and prefix maximum\r\narray on . For , just iterate over all from to and do . For , just\r\niterate over all from to and do .The question is: what? What did we do?\r\nWe did the following thing: the answer always can be represented as two\r\nnon-intersecting segments of length such that at least one endpoint of\r\neach segment is some input point ( ). Now, letâs fix this border between\r\nsegments. Iterate over all from to and update the answer with . So we\r\ntook segment that starts at some point to the left from (including ) and\r\ngoes to the left and took some segment that starts further than\r\n(including ) and goes to the right. With this model, we considered all\r\noptimal answers that can exist.Time complexity: .\r\n",
    "hint": []
}