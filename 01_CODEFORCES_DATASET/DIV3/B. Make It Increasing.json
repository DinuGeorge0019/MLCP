{
    "link": "https://codeforces.com//contest/1675/problem/B",
    "problemId": "1389919",
    "problem_idx": "B",
    "shortId": "1675B",
    "contest_number": "1675",
    "problem_submissions": {
        "G": [
            156006050,
            156007549,
            173914008,
            156574492,
            156062725,
            156044046
        ],
        "F": [
            155975284,
            155982189,
            155975181,
            155974056,
            155981368,
            155963854,
            155982839,
            155978540,
            155977742,
            155982621,
            155974644,
            155983326,
            155979741,
            155983593,
            155987528,
            155986330,
            155979073,
            155983357,
            155982704,
            155980054
        ],
        "B": [
            155956678,
            155933030,
            155935424,
            155929465,
            155930941,
            155933422,
            155931092,
            155933639,
            155934497,
            155933616,
            155938056,
            155932878,
            155937699,
            155932330,
            155932424,
            155935419,
            155934167,
            155935968,
            155938228,
            155943045
        ],
        "E": [
            155952600,
            155969940,
            155962457,
            155964374,
            155963814,
            155983208,
            155966957,
            155966086,
            155964414,
            155966097,
            155967685,
            155966676,
            155968339,
            155969173,
            155968619,
            155969521,
            155968330,
            155970439,
            155974921,
            155969157
        ],
        "D": [
            155947749,
            155955293,
            155954858,
            155948070,
            155952887,
            155947902,
            155952914,
            155950857,
            155960245,
            155955600,
            155958049,
            155956959,
            155958393,
            155952984,
            155959572,
            155957851,
            155953914,
            155962460,
            155960783,
            155957979
        ],
        "C": [
            155940658,
            155941257,
            155944890,
            155941178,
            155942028,
            155946945,
            155940227,
            155941361,
            155945588,
            155943949,
            155946857,
            155944434,
            155950008,
            155942914,
            155943655,
            155945930,
            155959132,
            155949802,
            155946391,
            155951636
        ],
        "A": [
            155928116,
            155927077,
            155928841,
            155925983,
            155926500,
            155932074,
            155926390,
            155927710,
            155930181,
            155927610,
            155931371,
            155927746,
            155927018,
            155927300,
            155927241,
            155926796,
            155928901,
            155928154,
            155927537,
            155926656
        ]
    },
    "name": "B. Make It Increasing",
    "statement": "Given n integers a_1, a_2,\r\ndots, a_n. You can perform the following operation on them: select any\r\nelement a_i (1\r\nle i\r\nle n) and divide it by 2 (round down). In other words, you can replace\r\nany selected element a_i with the value\r\nleft\r\nlfloor\r\nfrac{a_i}{2}\r\nright\r\nrfloor (where\r\nleft\r\nlfloor x\r\nright\r\nrfloor is round down the real number x). Output the minimum number of\r\noperations that must be done for a sequence of integers to become\r\nstrictly increasing (that is, for the condition a_1\r\nlt a_2\r\nlt\r\ndots\r\nlt a_n to be satisfied). Or determine that it is impossible to obtain\r\nsuch a sequence. Note that elements be swapped. The only possible\r\noperation is described above.For example, let n = 3 and a sequence of\r\nnumbers [3, 6, 5] be given. Then it is enough to perform two operations\r\non it: Write the number\r\nleft\r\nlfloor\r\nfrac{6}{2}\r\nright\r\nrfloor = 3 instead of the number a_2=6 and get the sequence [3, 3, 5];\r\nThen replace a_1=3 with\r\nleft\r\nlfloor\r\nfrac{3}{2}\r\nright\r\nrfloor = 1 and get the sequence [1, 3, 5]. The resulting sequence is\r\nstrictly increasing because 1\r\nlt 3\r\nlt 5.\r\n",
    "solutions": [
        "#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == '-') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nconst int N = 50;\nint T,n,ans,inp[N + 1];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tans = 0;\n\t\tn = read();\n\t\tfor (int i = 1;i <= n;i++) inp[i] = read();\n\t\tfor (int i = n - 1;i >= 1;i--){\n\t\t\twhile (inp[i] >= inp[i + 1]){\n\t\t\t\tif (inp[i] == 0) break;\n\t\t\t\t++ans,inp[i] >>= 1;\n\t\t\t}\n\t\t\tif (inp[i] >= inp[i + 1]) {puts(\"-1\");goto AGAIN;}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tAGAIN:;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Make It Increasing.json",
    "editorial_link": "https://codeforces.com//blog/entry/102550",
    "editorial": "We will process the elements of the sequence starting from the end of\r\nthe sequence. Each element () will be divided by until it is less than .\r\nIf at some point it turns out that , it is impossible to obtain the\r\ndesired sequence.\r\n"
}