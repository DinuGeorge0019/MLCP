{
    "link": "https://codeforces.com//contest/1986/problem/G1",
    "problemId": "2714659",
    "problem_idx": "G1",
    "shortId": "1986G1",
    "contest_number": "1986",
    "problem_submissions": {
        "G2": [
            267051586,
            267098517,
            267207124,
            267227692
        ],
        "G1": [
            267050167,
            267075101,
            267042149,
            267064735,
            267062041,
            267072094,
            267189212,
            267907699,
            267227655
        ],
        "F": [
            267036897,
            267006951,
            267211888,
            267210735,
            267209305,
            267209191,
            267142479,
            267067023,
            267046217,
            267049909,
            267055692,
            267026922,
            267034254,
            267024454,
            267035130,
            267043900,
            267043428,
            267046638,
            267048369,
            267046109,
            267054071,
            267044101,
            267051585,
            267055127
        ],
        "E": [
            267031182,
            267035399,
            267025961,
            267037775,
            267044980,
            267032730,
            267010850,
            267025710,
            267050692,
            267025261,
            267026751,
            267028762,
            267028451,
            267027196,
            267036783,
            267025470,
            267030110,
            267036403,
            267037341
        ],
        "D": [
            267019160,
            267019752,
            267011405,
            267021594,
            267023740,
            267014893,
            267011680,
            267009591,
            267007109,
            267005474,
            267006461,
            267009567,
            267009731,
            267006448,
            267009653,
            267006959,
            267018496,
            267008934,
            267008176
        ],
        "C": [
            266989125,
            266982272,
            266994840,
            267002991,
            266993066,
            267005030,
            266983150,
            266989202,
            266983682,
            267008636,
            266990051,
            266988914,
            266994220,
            266992535,
            266990847,
            266994508,
            266995474,
            266989895,
            266985787
        ],
        "B": [
            266980718,
            266971385,
            266985030,
            266993111,
            266976413,
            266985138,
            266977306,
            266981373,
            266976133,
            266979778,
            266979273,
            266982265,
            266980709,
            266977455,
            266980695,
            266983193,
            266981883,
            266982561,
            266978536
        ],
        "A": [
            266966090,
            266964678,
            266968415,
            266974624,
            270989331,
            266965521,
            266965134,
            266964884,
            266966168,
            266965003,
            266971429,
            266979885,
            266965867,
            266964795,
            266965926,
            266967291,
            266966370,
            266967270,
            266967228,
            266965380
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130783",
    "editorial": "Let ai=pigcd(i,pi)\n, bi=igcd(i,pi)\n. Notice that we want to calculate the number of index pairs i<j\n, such that:\n\naj\n is divisible by bi\n.\nai\n is divisible by bj\n.\nLet's iterate through the values of bi\n from 1\n to n\n (note that we are not fixing the element i\n, but rather fixing the value of bi\n). Now we know that we are interested in all aj=bi?k\n, for some positive integer k\n. Let's iterate through all such possible aj\n, and then iterate through all pairs with that value of aj\n. Add all suitable bj\n to the count array.\n\nNow, for a fixed bi\n and the constructed count array for it, iterate through all ai\n that exist with this bi\n. We can iterate through all divisors of ai\n and simply add their count from the count array to the answer, because:\n\nOnly those pairs for which aj\n is divisible by bi\n are considered in the count array, so we have accounted for the first condition.\nWe have accounted for the second condition when iterating through the divisors of ai\n.\nIf the above is implemented correctly, a solution can be obtained in O(nlogn)\n. For this, we will need to pre-calculate all divisors for each i\n from 1\n to n\n. We can iterate through i\n and mark it as a divisor for all numbers of the form k?i\n.\n\nAlso, everything written above works in O(nlogn)\n, because: the array a\n was obtained from a permutation by dividing some elements, so the total number of divisors of all elements in a\n (as well as the array b\n) is no more than the total number of divisors of numbers from 1\n to n\n. And the total number of divisors of numbers from 1\n to n\n is at most ?i=1nni=O(nlogn)\n.",
    "name": "G1. Permutation Problem  Simple Version ",
    "statement": "You are given a permutation p of length n. Calculate the number of index\r\npairs 1\r\nleq i < j\r\nleq n such that p_i\r\ncdot p_j is divisible by i\r\ncdot j without remainder.A permutation is a sequence of n integers,\r\nwhere each integer from 1 to n occurs exactly once. For example, [1],\r\n[3,5,2,1,4], [1,3,2] are permutations, while [2,3,2], [4,3,1], [0] are\r\nnot.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>  #define pb push_back#define fi first#define se secondusing namespace std;using ll = long long;using ld = long double;using ull = unsigned long long;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int maxN = 5e5 + 5;const int mod = 1e9 + 7;const ll oo = 1e18;int n, a[maxN];pair<int, int> b[maxN];vector<int> vc[maxN], vc1[maxN], divs[maxN];int mp[maxN];void prep(){    for(int i=1; i<maxN; i++)        for(int j=i; j<maxN; j+=i)            divs[j].pb(i);}void ReadInput(){    cin >> n;    for(int i=1; i<=n; i++)        cin >> a[i];}void Solve(){    for(int i=1; i<=n; i++)    {        int t = __gcd(a[i], i);        b[i] = {a[i] / t, i / t};    }     sort(b + 1, b + n + 1);    for(int i=1; i<=n; i++)    {        vc[b[i].fi].pb(b[i].se);        vc1[b[i].se].pb(b[i].fi);    }    for(int i=1; i<=n; i++)    {        sort(vc[i].begin(), vc[i].end());        sort(vc1[i].begin(), vc1[i].end());    }    ll res = 0;    for(int i=1; i<=n; i++)    {        if(vc1[i].empty()) continue;        for(int v : vc1[i])        {            for(int x : divs[v])                mp[x]++;        }        for(int j=i; j<=n; j+=i)        {            for(int v : vc[j])                res += mp[v];        }        for(int v : vc1[i])        {            for(int x : divs[v])                mp[x] = 0;        }    }    for(int i=1; i<=n; i++)    {        if(b[i].se == 1) res--;    }    cout << res / 2 << '\\n';    for(int i=1; i<=n; i++)    {        vc[b[i].fi].clear();        vc1[b[i].se].clear();    }}#define taskname \"sol\"int32_t main(){    if (fopen(taskname \".inp\", \"r\"))    {        freopen(taskname \".inp\", \"r\", stdin);       // freopen(taskname \".out\", \"w\", stdout);    }    ios_base::sync_with_stdio(false);    cin.tie(nullptr);    prep();    int T = 1;    cin >> T;    for(int itest=1; itest<=T; itest++)    {        ReadInput();        Solve();    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G1. Permutation Problem  Simple Version .json",
    "hint": []
}