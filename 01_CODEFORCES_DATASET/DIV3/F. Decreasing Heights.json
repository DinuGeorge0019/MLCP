{
    "link": "https://codeforces.com//contest/1353/problem/F",
    "problemId": "620792",
    "problem_idx": "F",
    "shortId": "1353F",
    "contest_number": "1353",
    "problem_submissions": {
        "F": [
            80124393,
            80127683,
            80140343,
            80142966,
            80146411,
            80141780,
            80117292,
            80132406,
            80185189,
            80188504
        ],
        "E": [
            80114098,
            80117275,
            80128499,
            80145539,
            80125005,
            80139306,
            80127975,
            80135984,
            80130531,
            80129427,
            80125620,
            80129245,
            80158858,
            80112124,
            80126450,
            80133527,
            80128884,
            80134345,
            80129651,
            80135076
        ],
        "D": [
            80098108,
            80101755,
            80118374,
            80103972,
            80115994,
            80127815,
            80131082,
            80141865,
            80110266,
            80114346,
            80114023,
            80103850,
            80129182,
            80108992,
            80109025,
            80113948,
            80117006,
            80117268,
            80113177
        ],
        "C": [
            80084355,
            80086625,
            80089665,
            80090748,
            80109095,
            80123682,
            80137480,
            80143026,
            80095516,
            80096983,
            80101362,
            80092320,
            80098872,
            80100063,
            80094720,
            80102804,
            80094807,
            80099168,
            80099321
        ],
        "B": [
            80081560,
            80083037,
            80082947,
            80084540,
            80089013,
            80114962,
            80133140,
            80144863,
            80085266,
            80084702,
            80090165,
            80084822,
            80087571,
            80083864,
            80085636,
            80092945,
            80088539,
            80086038,
            80088726
        ],
        "A": [
            80079491,
            80079524,
            80080015,
            80080262,
            80083439,
            80109672,
            80135612,
            80143748,
            80080163,
            80079971,
            80082828,
            217548820,
            80080548,
            80081468,
            80091988,
            80079985,
            80084451,
            80081999,
            80081124,
            80083012
        ]
    },
    "name": "F. Decreasing Heights",
    "statement": "You are playing one famous sandbox game with the three-dimensional\r\nworld. The map of the world can be represented as a matrix of size n\r\ntimes m, where the height of the cell (i, j) is a_{i, j}.You are in the\r\ncell (1, 1) right now and want to get in the cell (n, m). You can move\r\nonly down (from the cell (i, j) to the cell (i + 1, j)) or right (from\r\nthe cell (i, j) to the cell (i, j + 1)). There is an additional : if the\r\nheight of the current cell is x then you can move only to the cell with\r\nheight x+1. you can perform several operations. During one operation,\r\nyou can decrease the height of cell by one. I.e. you choose some cell\r\n(i, j) and assign (set) a_{i, j} := a_{i, j} - 1. Note that you make\r\nheights . Also note that you decrease the height of the cell (1, 1).Your\r\ntask is to find the number of operations you have to perform to obtain\r\nat least one suitable path from the cell (1, 1) to the cell (n, m). It\r\nis guaranteed that the answer exists.You have to answer t independent\r\ntest cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n          int a,b;\n          cin>>a>>b;\n          int m[a][b];\n          for (int i=0;i<a;i++) {\n              for (int j=0;j<b;j++) cin>>m[i][j]; \n          }\n          int min1=1000000000000000000;\n          int inf=1000000000000000000;\n          for (int i=0;i<a;i++) {\n              for (int j=0;j<b;j++) {\n                  int qq=m[i][j]-i-j; \n                  if (qq<=m[0][0]) { \n                  vector <vector<int>> dp(a,vector <int>(b)); \n                  dp[0][0]=m[0][0]-qq; \n                  for (int x=0;x<a;x++) {\n                      for (int y=0;y<b;y++) if (x+y>0) {\n                          dp[x][y]=inf; \n                          if (x>0) { if (m[x][y]>=qq+x+y) dp[x][y]=min(dp[x][y],dp[x-1][y]+m[x][y]-qq-x-y); } \n                          if (y>0) { if (m[x][y]>=qq+x+y) dp[x][y]=min(dp[x][y],dp[x][y-1]+m[x][y]-qq-x-y); } \n                      }\n                  }\n                  min1=min(min1,dp[a-1][b-1]); \n                  }\n              }\n          }\n   cout<<min1<<\"\\n\"; \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Decreasing Heights.json",
    "editorial_link": "https://codeforces.com//blog/entry/77373",
    "editorial": "Firstly, consider the field in -indexation. Suppose that the cell has\r\nsome fixed height. Let it be . Then we can determine what should be the\r\nheight of the cell as . In fact, it does not matter which way we choose,\r\nwe actually need only the number of moves to reach the cell and the\r\nheight of the cell .Then (when the height of the cell is fixed) we can\r\nsolve the problem with the following dynamic programming: is the minimum\r\nnumber of operations we need to reach the cell from the cell .\r\nInitially, all values except . Then can be calculated as . But one more\r\nthing: if then this value of is incorrect and we cannot use it. We also\r\ncanât update from the incorrect values. The answer for the problem with\r\nthe fixed height of the cell is (only when is correct and ). This part\r\ncan be calculated in .But if we iterate over all possible heights, our\r\nsolution obvious will get time limit exceeded verdict. Now we can notice\r\none important fact: in the optimal answer, the height of some cell\r\nremains unchanged. Let this cell be . Then we can restore the height of\r\nthe cell as and run our quadratic dynamic programming to find the answer\r\nfor this height.Time complexity: .\r\n",
    "hint": []
}