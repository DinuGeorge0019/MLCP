{
    "link": "https://codeforces.com//contest/1490/problem/B",
    "problemId": "898524",
    "problem_idx": "B",
    "shortId": "1490B",
    "contest_number": "1490",
    "problem_submissions": {
        "G": [
            107575670,
            107570582,
            107580395,
            107578386,
            107578722,
            107587817,
            107582372,
            107587644,
            107590224,
            107587234,
            107581021,
            107587494,
            107591578,
            107587278,
            107594584,
            107580527,
            107594840,
            107604479,
            107585353
        ],
        "F": [
            107567259,
            107563218,
            107559121,
            107563180,
            107570162,
            107559715,
            107565176,
            107569965,
            107573956,
            107565331,
            107557975,
            107565094,
            107575477,
            107563453,
            107578839,
            107563945,
            107577436,
            107545806,
            107574260
        ],
        "E": [
            107556406,
            107555209,
            107554466,
            107554504,
            107563766,
            107548069,
            107557392,
            107558375,
            107560045,
            107556903,
            107568704,
            107559054,
            107564526,
            107568622,
            107566562,
            107557990,
            107565929,
            107550803,
            107568788
        ],
        "D": [
            107547185,
            107546416,
            107549582,
            107548987,
            107555867,
            107556006,
            107548279,
            107551082,
            107551588,
            107551655,
            107551977,
            107552563,
            107556439,
            107553824,
            107619966,
            107554583,
            107548604,
            107553073,
            107559705,
            107559541
        ],
        "C": [
            107543774,
            107582544,
            107542780,
            107545198,
            107545514,
            107545604,
            107541435,
            107544848,
            107546219,
            107546179,
            107546602,
            107549060,
            107548247,
            107550636,
            107543227,
            107548011,
            107545321,
            107547310,
            107550641,
            107555122
        ],
        "B": [
            107541208,
            107540999,
            107543105,
            107543215,
            107543363,
            107548411,
            107542386,
            107543350,
            107543787,
            107544607,
            107545190,
            107541258,
            107543035,
            107541260,
            107543659,
            107551661,
            107545377,
            107544997,
            107550231
        ],
        "A": [
            107538772,
            107538836,
            107539535,
            107539200,
            107538915,
            107539471,
            107539499,
            107538905,
            107539830,
            107541268,
            107539601,
            107539113,
            107538995,
            107538895,
            107540166,
            107538768,
            107540499,
            107538751,
            107538933
        ]
    },
    "name": "B. Balanced Remainders",
    "statement": "You are given a number n () and an array a[1\r\ndots n]. In one move, you can increase any of the array elements by one.\r\nFormally, you choose the index i (1\r\nle i\r\nle n) and a_i with a_i + 1. You can choose the same index i multiple\r\ntimes for different moves.Let’s denote by c_0, c_1 and c_2 the number of\r\nnumbers from the array a that have remainders 0, 1 and 2 when divided by\r\nthe number 3, respectively. Let’s say that the array a has balanced\r\nremainders if c_0, c_1 and c_2 are equal.For example, if n = 6 and a =\r\n[0, 2, 5, 5, 4, 8], then the following sequence of moves is possible:\r\ninitially c_0 = 1, c_1 = 1 and c_2 = 4, these values are not equal to\r\neach other. Let’s increase a_3, now the array a = [0, 2, 6, 5, 4, 8];\r\nc_0 = 2, c_1 = 1 and c_2 = 3, these values are not equal. Let’s increase\r\na_6, now the array a = [0, 2, 6, 5, 4, 9]; c_0 = 3, c_1 = 1 and c_2 = 2,\r\nthese values are not equal. Let’s increase a_1, now the array a = [1, 2,\r\n6, 5, 4, 9]; c_0 = 2, c_1 = 2 and c_2 = 2, these values are equal to\r\neach other, which means that the array a has balanced remainders. Find\r\nthe minimum number of moves needed to make the array a have balanced\r\nremainders.\r\n",
    "solutions": [
        "#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tint n;\n\tint div[3];\n\tint i;\n\tint x;\n\tint ans;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\n\t\tfor (i = 0; i < 3; i++) div[i] = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x;\n\n\t\t\tdiv[x % 3]++;\n\t\t}\n\n\t\tans = 0;\n\t\tfor (i = 0; i < 3; i++)\n\t\t{\n\t\t\tif (div[i] > n / 3)\n\t\t\t{\n\t\t\t\tans += div[i] - n / 3;\n\t\t\t\tdiv[(i + 1) % 3] += div[i] - n / 3;\n\t\t\t\tdiv[i] = n / 3;\n\t\t\t}\n\t\t\telse if (div[i] < n / 3)\n\t\t\t{\n\t\t\t\tans += n / 3 - div[i];\n\t\t\t\tdiv[(i + 2) % 3] -= n / 3 - div[i];\n\t\t\t\tdiv[i] = n / 3;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Balanced Remainders.json",
    "editorial_link": "https://codeforces.com//blog/entry/87874",
    "editorial": "Note that the numbers in the array are not important to us, so initially\r\nwe will calculate the values of , , . Now applying a move for the number\r\nis equivalent to: decreasing by ; and increasing by ; We will perform\r\nthe following greedy algorithm: while the array have no balanced\r\nremainders, find any () such that ; we apply the move for , that is,\r\nreplace with , and with . It is easy to prove the correctness of this\r\ngreedy algorithm by cyclically shifting the values , , and so that the\r\nfirst element is equal to the maximum of them.\r\n",
    "hint": []
}