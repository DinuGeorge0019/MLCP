{
    "link": "https://codeforces.com//contest/977/problem/F",
    "problemId": "181257",
    "problem_idx": "F",
    "shortId": "977F",
    "contest_number": "977",
    "problem_submissions": {
        "F": [
            37953040,
            37954853,
            37956923,
            37956444,
            37956668,
            37955836,
            37936561,
            37948514,
            37950875,
            37954682,
            37954155,
            37963825,
            37947599,
            37954392,
            37949871,
            37951784,
            37954414,
            37960538,
            37955846,
            37949841
        ],
        "E": [
            37949370,
            37951257,
            37951081,
            37951485,
            37948712,
            37951230,
            37942528,
            37944878,
            37947562,
            38096112,
            37946372,
            37950654,
            37948745,
            37952883,
            37949399,
            37959345,
            37958962,
            37949557,
            38007916,
            37947057,
            37944768,
            37952160,
            37971056,
            37970300,
            37954498
        ],
        "D": [
            37945678,
            37944291,
            37945496,
            37944981,
            37944238,
            37945846,
            37945470,
            37942551,
            37956640,
            37950668,
            37945626,
            37943157,
            37942510,
            37940098,
            37964266,
            37963856,
            37963743,
            37943936,
            37943935,
            37953517,
            37949143,
            37938125
        ],
        "C": [
            37939418,
            37938533,
            37938833,
            37938453,
            37937230,
            37937332,
            37943206,
            37937093,
            37939874,
            37940598,
            37939826,
            37936805,
            37937760,
            37936881,
            37937722,
            37945760,
            37936821,
            37939453,
            37939008,
            37934533
        ],
        "B": [
            37934918,
            37934879,
            37935006,
            37934743,
            37934120,
            37933912,
            37939150,
            37934910,
            37935223,
            37935851,
            37937416,
            37932759,
            37932271,
            37935451,
            37935231,
            37937590,
            37933409,
            37934080,
            37933977,
            37934387
        ],
        "A": [
            37931506,
            37934128,
            37931332,
            37932430,
            37932516,
            37931234,
            37933447,
            37932411,
            37934760,
            37932666,
            37934427,
            37931097,
            37932757,
            37931225,
            37931938,
            37935268,
            37931464,
            37934315,
            37931090,
            37931415
        ]
    },
    "name": "F. Consecutive Subsequence",
    "statement": "You are given an integer array of length n.You have to choose some\r\nsubsequence of this array of maximum length such that this subsequence\r\nforms a increasing sequence of consecutive integers. In other words the\r\nrequired sequence should be equal to [x, x + 1,\r\ndots, x + k - 1] for some value x and length k.Subsequence of an array\r\ncan be obtained by erasing some (possibly zero) elements from the array.\r\nYou can erase any elements, not necessarily going successively. The\r\nremaining elements preserve their order. For example, for the array [5,\r\n3, 1, 2, 4] the following arrays are subsequences: [3], [5, 3, 1, 2, 4],\r\n[5, 1, 4], but the array [1, 3] is not.\r\n",
    "solutions": [
        "/*input\n7\n3 3 4 7 5 6 8\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define db(a) cerr<<#a<<\" = \"<<a<<'\\n'\nusing namespace std;\n\nconst int maxn = 2e5 + 1000;\nint n, a[maxn];\nint main(){\n\tcin >> n;\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> a[i];\n\t}\n\n\tmap<int, int> m;\n\n\tint dp[maxn] = {};\n\n\tfor(int i=0; i<n; i++){\n\t\tdp[i] = m[a[i]-1] + 1;\n\t\tm[ a[i] ] = dp[i];\n\t}\n\n\tint ans = 0, ind;\n\tfor(int i=0; i<n; i++){\n\t\tans = max(ans, dp[i]);\n\t\tif(ans == dp[i]){\n\t\t\tind = i;\n\t\t}\n\t}\n\tstack<int> s;\n\tint c = a[ind];\n\tfor(int i=ind; i>=0; i--){\n\t\tif(a[i] == c){\n\t\t\ts.push(i);\n\t\t\tc--;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\twhile(s.empty() == false){\n\t\tcout << s.top()+ 1<< \" \";\n\t\ts.pop();\n\t}\n\n}\n\t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Consecutive Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/59281",
    "editorial": "Let be the answer for our problem if the last element of our subsequence\r\nequals to .Then we have an easy solution: let\u00e2\u0080\u0099s store as a \"\" (C++) or\r\n\"\" (Java). Initially for each . Then let\u00e2\u0080\u0099s iterate over all in order of\r\ninput and try to update with a ().Then the maximum element of will be\r\nour answer. Let it be . Then let\u00e2\u0080\u0099s find any such that . Let it be . Then\r\nfor restoring the answer we need to iterate over all elements of our\r\narray in reverse order and if the current element then push to the array\r\nof positions of our subsequence and make .\r\n"
}