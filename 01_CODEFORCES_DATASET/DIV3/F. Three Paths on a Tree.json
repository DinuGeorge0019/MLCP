{"link": "https://codeforces.com//contest/1294/problem/F", "problemId": "521712", "problem_idx": "F", "shortId": "1294F", "contest_number": "1294", "problem_submissions": {"F": [69345723, 69341742, 69353873, 69354168, 69362489, 69359650, 69346353, 69348606, 69346845, 69359883, 69366706, 69362024, 69366917, 69346932, 69357467, 69365166, 69348414, 69365647, 69364629], "E": [69338805, 69351779, 69339037, 69344007, 69344151, 69343043, 69361056, 69360226, 69364740, 69351017, 69346873, 69323356, 69353170, 69364089, 69360143, 69354125, 69351861, 69359421, 69360122, 69354120], "D": [69326821, 69327425, 69329129, 69327902, 69327595, 69331659, 69323447, 69329706, 69328760, 69337985, 69335298, 69329000, 69425046, 69424930, 69331368, 69329469, 69336157, 69331418, 69331535, 69332903, 69334125], "C": [69316704, 69318571, 69324078, 69319609, 69320098, 69321493, 69318537, 69320636, 69318004, 69321999, 69327286, 69331832, 69318703, 69317985, 69329221, 69324244, 69332444, 69322784, 69323291], "B": [69312164, 69313583, 69315904, 69322215, 69312293, 69313735, 69314120, 69311768, 69311366, 69316184, 69310957, 69317833, 69313722, 69313259, 69323626, 69316316, 69314611, 69315633, 69316963], "A": [69304908, 69306368, 69307420, 69304625, 69304112, 69305282, 69304786, 69304157, 69304143, 69307552, 69304615, 69309994, 69304636, 69303953, 69304661, 69308930, 69306713, 69306352, 69305710]}, "name": "F. Three Paths on a Tree", "statement": "You are given an unweighted tree with n vertices. Recall that a tree is\r\na connected undirected graph without cycles.Your task is to choose\r\nvertices a, b, c on this tree such that the number of edges which belong\r\nto one of the simple paths between a and b, b and c, or a and c is the\r\nmaximum possible. See the notes section for a better understanding.The\r\nsimple path is the path that visits each vertex at most once.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nint de[N];\nint fa[N];\nvector<int>G[N];\nint root;\nint ed;\nint vis[N];\nint d[N];\nvoid dfs(int x){\n    for(int i=0;i<G[x].size();i++){\n        int &y=G[x][i];\n        if(!de[y]){\n            fa[y]=x;\n            de[y]=de[x]+1;\n            dfs(y);\n        }\n    }\n}\nqueue<int>q;\nvoid dfs1(int x){\n    vis[x]=1;\n    q.push(x);\n    if(fa[x]<=0)return;\n    dfs1(fa[x]);\n}\nint main()\n{\n    cin>>n;\n    for(int i=1,u,v;i<n;i++){\n        scanf(\"%d%d\",&u,&v);\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n    de[1]=1;\n    dfs(1);\n    for(int i=1;i<=n;i++){\n        if(de[i]>de[root])root=i;\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)de[i]=fa[i]=0;\n    de[root]=1;\n    dfs(root);\n    for(int i=1;i<=n;i++){\n        if(de[i]>de[ed])ed=i;\n    }\n    ans=de[ed]-1;\n    dfs1(ed);\n    while(!q.empty()){\n        int x=q.front();\n        q.pop();\n        for(int i=0;i<G[x].size();i++){\n            int &y=G[x][i];\n            if(!vis[y]){\n                vis[y]=1;\n                d[y]=d[x]+1;\n                q.push(y);\n            }\n        }\n    }\n    int mx=1;\n    while(mx==root||mx==ed)mx++;\n    for(int i=1;i<=n;i++)if(d[i]>d[mx])mx=i;\n    ans+=d[mx];\n    //cout<<root<<' '<<ed<<endl;\n    cout<<ans<<endl;\n    cout<<root<<' '<<mx<<' '<<ed<<endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "trees"], "dificulty": "2000", "interactive": false}