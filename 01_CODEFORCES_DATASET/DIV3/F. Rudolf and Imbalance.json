{
    "link": "https://codeforces.com//contest/1941/problem/F",
    "problemId": "2523372",
    "problem_idx": "F",
    "shortId": "1941F",
    "contest_number": "1941",
    "problem_submissions": {
        "G": [
            250763025,
            250781286,
            250779945,
            250787489,
            250800958,
            250794874,
            250801570,
            250797693,
            250776624,
            250793138,
            250784955,
            250769475,
            250695343,
            250808638,
            250806485,
            250793977,
            250708131
        ],
        "F": [
            250740820,
            250744438,
            250753388,
            250758018,
            250759651,
            250771923,
            250771468,
            250735055,
            250753949,
            250769805,
            250766080,
            250789658,
            250717637,
            250786906,
            250776029,
            250768573,
            250744006
        ],
        "E": [
            250723876,
            250724169,
            250717230,
            250735746,
            250736815,
            250736521,
            250739262,
            250774240,
            250729758,
            250726588,
            250755686,
            250741893,
            250738588,
            250765034,
            250731744,
            250805659,
            250779683
        ],
        "D": [
            250690549,
            250702231,
            250695593,
            250704272,
            250717031,
            250703063,
            250703013,
            250692270,
            250695895,
            250691168,
            250734836,
            250707874,
            250759962,
            250722745,
            250703516,
            250708254,
            250785215
        ],
        "C": [
            250674251,
            250679685,
            250671012,
            250679783,
            250680400,
            250684218,
            250682169,
            250667218,
            250675740,
            250676966,
            250670249,
            250691797,
            250745426,
            250686871,
            250672532,
            250677895,
            250750876
        ],
        "B": [
            250664239,
            250668411,
            250660791,
            250663325,
            250694386,
            250668961,
            250666921,
            250657383,
            250663605,
            250664885,
            250657026,
            250681860,
            250751771,
            250667298,
            250743798,
            250661438,
            250747374
        ],
        "A": [
            250649602,
            250652993,
            250650152,
            250651488,
            250656171,
            250653697,
            250656300,
            250649271,
            250654624,
            250658642,
            250648031,
            250654646,
            250754293,
            250652956,
            250649094,
            250648520,
            250712266
        ]
    },
    "name": "F. Rudolf and Imbalance",
    "statement": "Rudolf has prepared a set of n problems with complexities a_1 < a_2 <\r\na_3 <\r\ndots < a_n. He is not entirely satisfied with the balance, so he wants\r\nto add problem to fix it.For this, Rudolf came up with m models of\r\nproblems and k functions. The complexity of the i-th model is d_i, and\r\nthe complexity of the j-th function is f_j. To create a problem, he\r\nselects values i and j (1\r\nle i\r\nle m, 1\r\nle j\r\nle k) and by combining the i-th model with the j-th function, he obtains\r\na new problem with complexity d_i + f_j (a new element is inserted into\r\nthe array a).To determine the of the set, Rudolf sorts the complexities\r\nof the problems in ascending order and finds the largest value of a_i -\r\na_{i - 1} (i > 1).What is the minimum value of that Rudolf can achieve\r\nby adding at most one problem, created according to the described rules?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<\"YES\\n\"\n#define NO cout << \"NO\\n\"\n#define debug cout << \"Here Fine\" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\nint n , m , k ; \nint a[ N ] , b[ N ] , f[ N ] ;\nset < int > se ;\n\nvoid solve(){\n    cin >> n >> m >> k ;\n    FOR( i , n ) cin >> a[ i ] ;\n    FOR( i , m ) cin >> b[ i ] ;\n    FOR( i , k ) cin >> f[ i ] ;\n    sort( b , b + m ) ;\n    sort( f , f + k ) ;\n    sort( a , a + n ) ;\n    int mx = 0 ;\n    FOR( i , n - 1 ){\n    \tmx = max( mx , a[ i + 1 ] - a[ i ] ) ;\n\t}\n\tint l , r , cnt = 0 , ot = 0 ; \n\tFOR( i , n - 1 ){\n\t\tif( ( a[ i + 1 ] - a[ i ] ) == mx ){\n\t\t\tl = a[ i ] , r = a[ i + 1 ] ;\n\t\t\tcnt ++ ; \n\t\t}\n\t\telse ot = max( ot , a[ i + 1 ] - a[ i ] ) ; \n\t}\n\t\n\tif( cnt != 1 ){\n\t\tcout << mx << \"\\n\" ;\n\t\treturn ; \n\t}\n\tse.clear() ;\n\tFOR( i , m ) se.insert( b[ i ] ) ;\n\t\n//\tdebug ;\n\tint mn = mx ; \n\tFOR( j , k ){\n\t\tint x = f[ j ] ;\n\t\tint mid = ( l + r ) / 2 ; \n\t\tint nd = mid - x ;\n\t\t//if( nd < 0 ) continue ;\n\t\tif( *se.begin() >= nd ){\n\t\t\tint axl = *se.begin() + x ;\n\t\t\tif( axl >= l && axl <= r )\n\t\t\tmn = min( mn , max( axl - l , r - axl ) ) ;\n\t\t}\n\t\telse{\n\t\t\tint axl = *( --se.upper_bound( nd ) ) + x ;\n\t\t\tif( axl >= l && axl <= r )\n\t\t\tmn = min( mn , max( axl - l , r - axl ) ) ;\t\t\t\n\t\t}\n\t\tif( se.lower_bound( nd ) != se.end() ){\n\t\t\tint axl = *se.lower_bound( nd ) + x ;\n\t\t\tif( axl >= l && axl <= r )\n\t\t\tmn = min( mn , max( axl - l , r - axl ) ) ;\t\t\t\t\n\t\t}\n\t}\n    cout << max( mn , ot ) << \"\\n\" ; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Rudolf and Imbalance.json",
    "editorial_link": "https://codeforces.com//blog/entry/127018",
    "editorial": "Let\u00e2\u0080\u0099s consider the differences . Since we can only insert one problem,\r\nwe can reduce the difference in difficulty in only one place. If we\r\ninsert a problem not between the tasks whose difference in difficulty is\r\nmaximum (denote them as and ), then the will not change. The best way to\r\ninsert a problem in this way is to choose the middle between these\r\ntasks, so the larger of the differences and will be minimal.We also\r\ncannot forget about the other tasks. Let\u00e2\u0080\u0099s find the second maximum among\r\nthe values . Since we insert a problem in another place, this difference\r\nwill not decrease, and therefore the answer cannot be less than it.To\r\nunderstand what answer we can achieve, let\u00e2\u0080\u0099s sort the functions and\r\niterate through all the models. For the model , using binary search, we\r\nwill find the maximum index such that . For inserting with the selected\r\nmodel, the best fit will be either a problem of difficulty or a problem\r\nof difficulty (if ) since it is the closest problems to the middle. We\r\nwill check both options and update the answer.\r\n"
}