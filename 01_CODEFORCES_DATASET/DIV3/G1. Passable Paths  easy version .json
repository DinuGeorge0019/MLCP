{
    "link": "https://codeforces.com//contest/1702/problem/G1",
    "problemId": "1456432",
    "problem_idx": "G1",
    "shortId": "1702G1",
    "contest_number": "1702",
    "problem_submissions": {
        "F": [
            163542113,
            163514028,
            163524616,
            163733546,
            163545296,
            163524924,
            163529358,
            163536513,
            163519866,
            163525233,
            163564879,
            163534380,
            163538783,
            163561947,
            163540969,
            163535655,
            163561064,
            163562404,
            163544085,
            163519016
        ],
        "G2": [
            163534991,
            163559407,
            163548172,
            163549996,
            163554176,
            163540379,
            163557182,
            163571429,
            163575000,
            163545502,
            163571447,
            163565952,
            163549470,
            163566226,
            163577860,
            163531079,
            163555250,
            163574346,
            163573572
        ],
        "G1": [
            163534865,
            163559321,
            163548387,
            163550273,
            163555106,
            163540096,
            163557483,
            163571026,
            163549886,
            163545065,
            163540644,
            163566213,
            163549672,
            163557387,
            163546571,
            163531433,
            163554999,
            163574214,
            163573379
        ],
        "E": [
            163505777,
            163504465,
            163513283,
            163513644,
            163510195,
            163546834,
            163520208,
            163505881,
            163516258,
            163517435,
            163526737,
            163516735,
            163506369,
            163532804,
            163528744,
            163567339,
            163567093,
            163519899,
            163524058,
            163508144
        ],
        "D": [
            163487820,
            163493027,
            163495875,
            163501404,
            163498661,
            163506170,
            163499925,
            163492796,
            163488953,
            163500375,
            163495848,
            163492570,
            163483263,
            163496253,
            163491216,
            163495136,
            163508155,
            163491736,
            163485984
        ],
        "C": [
            163479124,
            163482190,
            163488652,
            163621464,
            163492523,
            163493122,
            163498422,
            163492339,
            163483795,
            163482325,
            165952921,
            163494102,
            163486863,
            163484454,
            163478228,
            163483131,
            163484825,
            163489721,
            163494820,
            163481705,
            163480845
        ],
        "B": [
            163471434,
            163474194,
            163479257,
            163481288,
            163480379,
            163488341,
            163485489,
            163475757,
            163474641,
            163485384,
            163491538,
            163474852,
            163473580,
            163475855,
            163477521,
            163484846,
            163484562,
            163474319,
            163475121
        ],
        "A": [
            163468217,
            163469784,
            163473310,
            163468633,
            163472585,
            163470981,
            163470350,
            163469302,
            163470110,
            163473679,
            163468658,
            163468889,
            163468241,
            163490145,
            163470656,
            163480525,
            163486237,
            163468246,
            163469702
        ]
    },
    "name": "G1. Passable Paths  easy version ",
    "statement": "Polycarp grew a tree from n vertices. We remind you that a tree of n\r\nvertices is an undirected connected graph of n vertices and n-1 edges\r\nthat does not contain cycles.He calls a set of vertices if there is such\r\na path in the tree that passes through each vertex of this set without\r\npassing through any edge twice. The path can visit other vertices (not\r\nfrom this set).In other words, a set of vertices is called if there is a\r\nsimple path that passes through all the vertices of this set (and\r\npossibly some other).For example, for a tree below sets\r\n{3, 2, 5\r\n},\r\n{1, 5, 4\r\n},\r\n{1, 4\r\n} are , and\r\n{1, 3, 5\r\n},\r\n{1, 2, 3, 4, 5\r\n} are not. Polycarp asks you to answer q queries. Each query is a set of\r\nvertices. For each query, you need to determine whether the\r\ncorresponding set of vertices is .\r\n",
    "solutions": [
        "/*\nPlaying Div.3, easy edition\n*/\n#include <bits/stdc++.h>\n#define ll int\n#define rep(i,m,n) for (auto i=m;i<=n;i++)\n#define reb(i,m,n) for (auto i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,m,g[21][N],h[N];\nvector<ll> ke[N],have[2];\nvoid dfs (ll u, ll p){\n    rv(v,ke[u]) if (v!=p){\n        h[v]=h[u]+1;\n        g[0][v]=u;\n        for (ll i=1;(1<<i)<=h[v];i++) g[i][v]=g[i-1][g[i-1][v]]; \n        dfs(v,u);\n    }\n}\nll lca (ll u, ll v){\n    if (u==v) return u;\n    if (h[u]<h[v]) swap(u,v);\n    reb(i,20,0) if ((h[u]-(1<<i)>=h[v])) u=g[i][u];\n    if (u==v) return u;\n    reb(i,20,0) if (g[i][u]!=g[i][v]) u=g[i][u],v=g[i][v];\n    return g[0][u]; \n}\nll park (ll u, ll k){\n    ll v=u;\n    reb(i,20,0) if (k&(1<<i)) v=g[i][v];\n    return v;\n}\nbool cmp (ll u, ll v){\n    return (h[u]>h[v]);\n}\nvector<ll> a;\nset<ll> st;\nvoid solo()\n{\n    cin>>n;\n    rep(i,1,n-1){\n        ll u,v;\n        cin>>u>>v;\n        ke[u].pb(v);\n        ke[v].pb(u);\n    }\n    dfs(1,0);\n    cin>>q;\n    while (q--){\n        cin>>m;\n        a.clear();\n        rep(i,1,m){\n            ll x;\n            cin>>x;\n            a.pb(x);\n        }\n        if (m==1){\n            cout<<\"YES\\n\"; continue;\n        }\n        ll all=a[0];\n        rv(i,a) all=lca(all,i);\n        st.clear();\n        rv(i,a) if (all!=i) st.insert(park(i,h[i]-h[all]-1));\n        if (st.size()>2){\n            cout<<\"NO\\n\"; continue;\n        }\n        ll S=*st.begin(),T=*st.rbegin();\n        sort(a.begin(),a.end(),cmp);\n        have[0].clear();\n        have[1].clear();\n        rv(i,a) if (i!=all){\n            if (lca(i,S)==S) have[0].pb(i);\n            else have[1].pb(i);\n        }\n        bool ok=1;\n        rep(i,0,1) if (!have[i].empty()){\n            ll c=have[i][0];\n            rv(u,have[i]) if (lca(u,c)!=u) ok=0;\n        }\n        if (ok) cout<<\"YES\\n\";\n        else cout<<\"NO\\n\";\n    }\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   //cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G1. Passable Paths  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/104763",
    "editorial": "If the answer is , then we can choose a subset of the tree vertices\r\nforming a simple path and containing all the vertices of our set. Letâs\r\nchoose the minimum possible path, its ends vertices from the set. The\r\nconstraints allow us to answer the query in , hang the tree by one of\r\nthe ends and check if it is true that there is only one selected vertex\r\nthat does not have any selected ones in the subtree, if there is one\r\nsuch vertex, then it is the second end. To make it easier to search for\r\none of the ends, we will hang the tree by any vertex before the queries,\r\ncalculate their depths and take the deepest of the set.\r\n",
    "hint": []
}