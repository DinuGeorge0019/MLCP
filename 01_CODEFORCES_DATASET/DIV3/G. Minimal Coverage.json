{
    "link": "https://codeforces.com//contest/1579/problem/G",
    "problemId": "1123873",
    "problem_idx": "G",
    "shortId": "1579G",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "G. Minimal Coverage",
    "statement": "You are given n lengths of segments that need to be placed on an\r\ninfinite axis with coordinates.The first segment is placed on the axis\r\nso that one of its endpoints lies at the point with coordinate 0. Let’s\r\ncall this endpoint the \"\" of the first segment and let’s call its \"\" as\r\nthat endpoint that is not the start. The \"start\" of each following\r\nsegment must coincide with the \"end\" of the previous one. Thus, if the\r\nlength of the next segment is d and the \"end\" of the previous one has\r\nthe coordinate x, the segment can be placed either on the coordinates\r\n[x-d, x], and then the coordinate of its \"end\" is x - d, or on the\r\ncoordinates [x, x+d], in which case its \"end\" coordinate is x + d.The\r\ntotal of the axis by these segments is defined as their overall union\r\nwhich is basically the set of points covered by at least one of the\r\nsegments. It’s easy to show that the coverage will also be a segment on\r\nthe axis. Determine the minimal possible length of the coverage that can\r\nbe obtained by placing all the segments on the axis without changing\r\ntheir order.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n;\nint a[10005];\nint d[10005][2005];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) cin >> a[i];\n        for(int i = 0;i <= 2000;i++) d[0][i] = i;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 0;j <= 2000;j++) {\n                d[i][j] = INF;\n                if(j-a[i] >= 0) d[i][j] = min(d[i][j],max(d[i-1][j-a[i]],j));\n                if(j+a[i] <= 2000) d[i][j] = min(d[i][j],max(d[i-1][j+a[i]],j));\n            }\n        }\n        int ans = INF;\n        for(int i = 0;i <= 2000;i++) ans = min(ans,d[n][i]);\n        cout << ans << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Minimal Coverage.json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "One possible solution involves the method of dynamic programming. As a\r\nstate of DP we will use the number of already placed segments , and the\r\ndistance from the \"end\" of the last segment to the current left boundary\r\nof the coverage, and in the DP we will store the minimal possible\r\ndistance from the \"end\" of the last segment to the current right\r\nboundary of the coverage.We can prove that the answer never exceeds ,\r\nwhere is the maximal length of the segments. To do this, let us define a\r\nregion of length , specifically the segment . If the \"end\" of the last\r\nsegment has a coordinate , we put the next segment to the left,\r\notherwise, we put it to the right. With this algorithm, none of the\r\n\"end\" endpoints of the segments will go beyond the marked boundaries,\r\nbecause to do so, the segment must be placed from the coordinate of one\r\nsign beyond the boundary of the opposite sign, and thus must have a\r\nlength greater than which contradicts how we defined .Using this fact,\r\nwe will consider the DP for and as the minimum distance between the\r\n\"end\" of the -th segment and the right boundary of the axis coverage of\r\nthe first segments when the distance to the left boundary of the\r\ncoverage equals to . The \"end of the -th segment\" here is the\r\n\"beginning\" of the first one, that is, the point .The base of DP is ,\r\nsince when no segments are placed, the coverage boundaries and the\r\ncurrent point are all coincident. Next, we consider the forward dynamic\r\nprogramming relaxation: for every there are two cases to consider, the\r\ncase of the next segment being placed to the left and the case of it\r\nbeing placed to the right (value below refers to the distance to the\r\nright boundary of the coverage and is an alias for ): If a segment of\r\nlength is placed to the left side, then the new distance to the left\r\nboundary will be equal to , and distance to the right boundary will\r\nalways be , which gives us the relaxation formula If a segment of length\r\nis placed to the right side, then the new distance to the right boundary\r\nwill be equal to , and distance to the left boundary will always be ,\r\nwhich gives us the relaxation formula The values in array can be\r\ncalculated in ascending order by . Then the answer for the problem can\r\nbe found as the minimum sum of and in the last row of , that is .The\r\ntime complexity is .\r\n",
    "hint": []
}