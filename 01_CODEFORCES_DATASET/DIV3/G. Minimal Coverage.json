{"link": "https://codeforces.com//contest/1579/problem/G", "problemId": "1123873", "problem_idx": "G", "shortId": "1579G", "contest_number": "1579", "problem_submissions": {"G": [130137274, 130120638, 130155046, 130156225, 130163836, 130179545, 130168337, 130158927, 130165156, 130198303, 130191623, 130244137, 130192656], "E2": [130129123, 130137578, 130134268, 130135000, 130132286, 130127123, 130146290, 130145108, 130149289, 130140257, 130139480, 130140744, 130135527, 130143398, 130123582, 130147751, 130139094, 130145725, 130136545, 130146933], "F": [130125518, 130115413, 130143625, 130141220, 130143971, 130167063, 130157787, 130168199, 130155796, 130152120, 130146742, 130149015, 130150286, 130148427, 130153717, 130166412, 130156991, 130153655, 130149578, 130134036], "E1": [130117970, 130121669, 130119905, 130127812, 130120295, 130128369, 130136696, 130129561, 130139968, 130118319, 130116344, 130126763, 130130246, 130132247, 130119799, 130120223, 130117670, 130134770, 130118389, 130133123], "D": [130114825, 130131006, 130115575, 130122918, 130116396, 130116584, 130127769, 130136071, 130142472, 130116682, 130121234, 130122150, 130126027, 130120420, 130116268, 130113854, 130122134, 130132072, 130125736, 130128217], "C": [130111875, 130134780, 130127605, 130118045, 130126486, 130136003, 130133755, 130153746, 130136597, 130126873, 130133654, 130133053, 130123204, 130126284, 130128738, 130132948, 130148452, 130128270, 130158049, 130155693], "B": [130106161, 130116908, 130108929, 130112526, 130111768, 130114142, 130116092, 130125486, 130125850, 130111350, 130113414, 130109874, 130116163, 130111654, 130112328, 130107695, 130114784, 130116681, 130114568, 130117978], "A": [130098440, 130100824, 130100944, 130103654, 130098460, 130102451, 130102139, 130101021, 130117992, 130105259, 130098578, 130098425, 130098461, 130105623, 130098680, 130098458, 130101628, 130099346, 130098971, 130099307]}, "name": "G. Minimal Coverage", "statement": "You are given n lengths of segments that need to be placed on an\r\ninfinite axis with coordinates.The first segment is placed on the axis\r\nso that one of its endpoints lies at the point with coordinate 0. Let\u2019s\r\ncall this endpoint the \"\" of the first segment and let\u2019s call its \"\" as\r\nthat endpoint that is not the start. The \"start\" of each following\r\nsegment must coincide with the \"end\" of the previous one. Thus, if the\r\nlength of the next segment is d and the \"end\" of the previous one has\r\nthe coordinate x, the segment can be placed either on the coordinates\r\n[x-d, x], and then the coordinate of its \"end\" is x - d, or on the\r\ncoordinates [x, x+d], in which case its \"end\" coordinate is x + d.The\r\ntotal of the axis by these segments is defined as their overall union\r\nwhich is basically the set of points covered by at least one of the\r\nsegments. It\u2019s easy to show that the coverage will also be a segment on\r\nthe axis. Determine the minimal possible length of the coverage that can\r\nbe obtained by placing all the segments on the axis without changing\r\ntheir order.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint n;\nint a[10005];\nint d[10005][2005];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) cin >> a[i];\n        for(int i = 0;i <= 2000;i++) d[0][i] = i;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 0;j <= 2000;j++) {\n                d[i][j] = INF;\n                if(j-a[i] >= 0) d[i][j] = min(d[i][j],max(d[i-1][j-a[i]],j));\n                if(j+a[i] <= 2000) d[i][j] = min(d[i][j],max(d[i-1][j+a[i]],j));\n            }\n        }\n        int ans = INF;\n        for(int i = 0;i <= 2000;i++) ans = min(ans,d[n][i]);\n        cout << ans << '\\n';\n    }\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2200", "interactive": false}