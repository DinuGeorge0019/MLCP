{"link": "https://codeforces.com//contest/1538/problem/E", "problemId": "1011925", "problem_idx": "E", "shortId": "1538E", "contest_number": "1538", "problem_submissions": {"E": [119018264, 119038794, 119046659, 119003625, 119061307, 119064399, 119060278, 119068960, 119062453, 119072155, 119056952, 119069527, 119068076, 119062727, 119052586, 119065637, 119072255], "G": [118999207, 119020225, 119021713, 119024546, 119107544, 119036898, 119028226, 119029451, 119031390, 119029333, 119068653, 119056480, 119036891, 119015600, 119058550, 119027874, 119041084, 119096627, 119043084, 119070277, 119029074, 119028555], "F": [118994094, 119009122, 119011522, 119010675, 119004928, 119011877, 119018391, 119023066, 119014211, 118989351, 119008401, 119000204, 119046720, 119037498, 119005370, 119003036, 119028602, 119029230, 118990749], "D": [118990532, 119001395, 118990526, 118995807, 118995705, 119004937, 119011155, 119067124, 119007327, 119008907, 119005317, 118992117, 119028596, 119008321, 119000602, 119002391, 119020144, 119032689, 119023435, 118984125], "C": [118982217, 119149641, 118992295, 118981240, 118981637, 118988631, 118988597, 118982472, 118986969, 118992547, 118974451, 118982264, 119002368, 118990651, 118982560, 118985014, 119000072, 119149116, 118999633, 118999834, 118978123], "B": [118976645, 118977183, 118975637, 118977101, 118977452, 118979418, 118976574, 118977391, 118980490, 118978931, 118982040, 118985873, 118979131, 118975015, 118996026, 118998239, 118980842, 118992776, 118974355], "A": [118973297, 118973758, 118973272, 118974245, 118974991, 118975654, 118973422, 118973780, 118976143, 118975162, 118974140, 118978811, 118974004, 118973371, 118987598, 118996831, 118976899, 118975174, 118973279]}, "name": "E. Funny Substrings", "statement": "Polycarp came up with a new programming language. There are only two\r\ntypes of statements in it: \"\": assign the variable named the value\r\n(where is a string). For example, the statement assigns the variable\r\nnamed the value . Note that is the value of a string, not the name of a\r\nvariable. Between the variable name, the operator and the string\r\ncontains exactly one space each. \"\": assign the variable named the\r\nconcatenation of values of two variables and . For example, if the\r\nprogram consists of three statements , , , then the variable will\r\ncontain the string . It is guaranteed that the program is correct and\r\nthe variables and were previously defined. There is exactly one space\r\nbetween the variable names and the and operators. All variable names and\r\nstrings only consist of lowercase letters of the English alphabet and do\r\nnot exceed 5 characters.The result of the program is the number of\r\noccurrences of string in the string that was written to the variable in\r\nthe last statement.Polycarp was very tired while inventing that\r\nlanguage. He asks you to implement it. Your task is for given program\r\nstatements calculate the number of occurrences of string in the last\r\nassigned variable.\r\n", "solutions": ["#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie's Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you're not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you're submitting in szkopul.)\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,unroll-loops,tree-vectorize\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n \n//File I/O.\n#define FILE_IN \"cseq.inp\"\n#define FILE_OUT \"cseq.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl \"\\n\"\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nstruct comp\n{\n    ll cnt=0,len=0;\n    string st=\"\",en=\"\";\n    comp(string s)\n    {\n        len=s.length();\n        cnt=0;\n        for (int i=0;i+4<=len;i++) if (s.substr(i,4)==\"haha\") cnt++;\n        if (len<=3) st=en=s;\n        else \n        {\n            st=s.substr(0,3);\n            en=s.substr(len-3,3);\n        }\n    }\n    comp()\n    {}\n    comp operator+(comp oth)\n    {\n        if ((len<=3)and(oth.len<=3)) return comp(st+oth.st);\n        comp res;\n        res.cnt=cnt+oth.cnt;\n        res.len=len+oth.len;\n        string bruh=en+oth.st;\n        for (int i=0;i+4<=bruh.length();i++) if (bruh.substr(i,4)==\"haha\") res.cnt++;\n        res.st=st;\n        int i=0;\n        while(res.st.size()<3)\n        {\n            res.st.push_back(oth.st[i]);\n            i++;\n        }\n        res.en=oth.en;\n        i=en.size()-1;\n        while(res.en.size()<3)\n        {\n            res.en.push_back(en[i]);\n            i--;\n        }\n        return res;\n    }\n};\nvector<int> vec;\nll n,m,i,j,k,t,t1,u,v,a,b;\nll res=0;\nmap<string,comp> var;\nstring sa,sb,sc,sd,se;\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n;\n        var.clear();\n        for (i=0;i<n;i++)\n        {\n            cin>>sa>>sb;\n            if (sb==\":=\")\n            {\n                cin>>sc;\n                var[sa]=comp(sc);\n            }\n            else\n            {\n                cin>>sc>>sd>>se;\n                var[sa]=var[sc]+var[se];\n            }\n        }\n        cout<<var[sa].cnt<<endl;\n    }\n}\n"], "input": "", "output": "", "tags": ["data structures", "hashing", "implementation", "matrices", "strings"], "dificulty": "2100", "interactive": false}