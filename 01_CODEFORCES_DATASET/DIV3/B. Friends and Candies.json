{
    "link": "https://codeforces.com//contest/1538/problem/B",
    "problemId": "1011922",
    "problem_idx": "B",
    "shortId": "1538B",
    "contest_number": "1538",
    "problem_submissions": {
        "E": [
            119018264,
            119038794,
            119046659,
            119003625,
            119061307,
            119064399,
            119060278,
            119068960,
            119062453,
            119072155,
            119056952,
            119069527,
            119068076,
            119062727,
            119052586,
            119065637,
            119072255
        ],
        "G": [
            118999207,
            119020225,
            119021713,
            119024546,
            119107544,
            119036898,
            119028226,
            119029451,
            119031390,
            119029333,
            119068653,
            119056480,
            119036891,
            119015600,
            119058550,
            119027874,
            119041084,
            119096627,
            119043084,
            119070277,
            119029074,
            119028555
        ],
        "F": [
            118994094,
            119009122,
            119011522,
            119010675,
            119004928,
            119011877,
            119018391,
            119023066,
            119014211,
            118989351,
            119008401,
            119000204,
            119046720,
            119037498,
            119005370,
            119003036,
            119028602,
            119029230,
            118990749
        ],
        "D": [
            118990532,
            119001395,
            118990526,
            118995807,
            118995705,
            119004937,
            119011155,
            119067124,
            119007327,
            119008907,
            119005317,
            118992117,
            119028596,
            119008321,
            119000602,
            119002391,
            119020144,
            119032689,
            119023435,
            118984125
        ],
        "C": [
            118982217,
            119149641,
            118992295,
            118981240,
            118981637,
            118988631,
            118988597,
            118982472,
            118986969,
            118992547,
            118974451,
            118982264,
            119002368,
            118990651,
            118982560,
            118985014,
            119000072,
            119149116,
            118999633,
            118999834,
            118978123
        ],
        "B": [
            118976645,
            118977183,
            118975637,
            118977101,
            118977452,
            118979418,
            118976574,
            118977391,
            118980490,
            118978931,
            118982040,
            118985873,
            118979131,
            118975015,
            118996026,
            118998239,
            118980842,
            118992776,
            118974355
        ],
        "A": [
            118973297,
            118973758,
            118973272,
            118974245,
            118974991,
            118975654,
            118973422,
            118973780,
            118976143,
            118975162,
            118974140,
            118978811,
            118974004,
            118973371,
            118987598,
            118996831,
            118976899,
            118975174,
            118973279
        ]
    },
    "name": "B. Friends and Candies",
    "statement": "Polycarp has n friends, the i-th of his friends has a_i candies.\r\nPolycarp\u2019s friends do not like when they have different numbers of\r\ncandies. In other words they want all a_i to be the same. To solve this,\r\nPolycarp performs the following set of actions exactly : Polycarp\r\nchooses k (0\r\nle k\r\nle n) arbitrary friends (let\u2019s say he chooses friends with indices i_1,\r\ni_2,\r\nldots, i_k); Polycarp distributes their a_{i_1} + a_{i_2} +\r\nldots + a_{i_k} candies among all n friends. During distribution for\r\neach of a_{i_1} + a_{i_2} +\r\nldots + a_{i_k} candies he chooses new owner. That can be any of n\r\nfriends. Note, that any candy can be given to the person, who has owned\r\nthat candy before the distribution process. Note that the number k is\r\nnot fixed in advance and can be arbitrary. Your task is to find the\r\nminimum value of k.For example, if n=4 and a=[4, 5, 2, 5], then Polycarp\r\ncould make the following distribution of the candies: Polycarp chooses\r\nk=2 friends with indices i=[2, 4] and distributes a_2 + a_4 = 10 candies\r\nto make a=[4, 4, 4, 4] (two candies go to person 3). Note that in this\r\nexample Polycarp cannot choose k=1 friend so that he can redistribute\r\ncandies so that in the end all a_i are equal.For the data n and a,\r\ndetermine the value k. With this value k, Polycarp should be able to\r\nselect k friends and redistribute their candies so that everyone will\r\nend up with the same number of candies.\r\n",
    "solutions": [
        "#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie's Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you're not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you're submitting in szkopul.)\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,unroll-loops,tree-vectorize\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n \n//File I/O.\n#define FILE_IN \"cseq.inp\"\n#define FILE_OUT \"cseq.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl \"\\n\"\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nll n,m,i,j,k,t,t1,u,v,a,b;\nll arr[200001];\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n;\n        u=0;\n        for (i=1;i<=n;i++)\n        {\n            cin>>arr[i];\n            u+=arr[i];\n        }\n        if (u%n)\n        {\n            cout<<-1<<endl;\n        }\n        else\n        {\n            a=0;\n            for (i=0;i<n;i++) if (arr[i+1]>u/n) a++;\n            cout<<a<<endl;\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Friends and Candies.json",
    "editorial_link": "https://codeforces.com//blog/entry/91637",
    "editorial": "Let\u00e2\u0080\u0099s denote for the number of candies all friends have: . Note that at\r\nthe end, each friend must have of candy. If is not completely divisible\r\nby , then there is no answer.How to get the answer if it exists? If the\r\n-th friend has more candies than , then he must be chosen by Polycarp\r\n(otherwise this friend will have more candies than the others). If the\r\n-th friend has no more than , then Polycarp may not choose it.Then, if\r\nthe answer exists, it is equal to the number of .\r\n"
}