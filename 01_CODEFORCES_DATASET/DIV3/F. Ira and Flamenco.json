{
    "link": "https://codeforces.com//contest/1833/problem/F",
    "problemId": "1929819",
    "problem_idx": "F",
    "shortId": "1833F",
    "contest_number": "1833",
    "problem_submissions": {
        "F": [
            206599548,
            206499044,
            206510645,
            206497958,
            206917535,
            206498356,
            206512969,
            206501833,
            206507754,
            206504303,
            206775083,
            206513772,
            206514120,
            206515332,
            206518320,
            206514205,
            206521502,
            206515630,
            206524274,
            206520741,
            206520948,
            206526178,
            206521131
        ],
        "G": [
            206512331,
            206521465,
            206506545,
            206477170,
            206519573,
            206523410,
            206530322,
            206518526,
            206777759,
            206531078,
            206532207,
            206527389,
            206532553,
            206535240,
            206530738,
            206539901,
            206510414,
            206533541,
            209018213,
            206536054,
            206538842,
            206866462,
            206539276
        ],
        "E": [
            206494444,
            206500619,
            206508800,
            206912480,
            206752261,
            206508820,
            206500946,
            206513913,
            206499318,
            206515052,
            206776677,
            206501077,
            206501029,
            206508081,
            206504803,
            206505276,
            206514758,
            206507981,
            206532142,
            206514436,
            206505945,
            206510447,
            206508190
        ],
        "D": [
            206478490,
            206489393,
            206482509,
            206516497,
            206493139,
            206494430,
            206493405,
            206772261,
            206483249,
            206490999,
            206496792,
            206494490,
            206495499,
            206492096,
            206495671,
            206562276,
            206493504,
            206494409,
            206497119,
            206489160,
            206496422
        ],
        "C": [
            206468900,
            206472444,
            206487689,
            206481281,
            206470369,
            206469924,
            206472556,
            206474926,
            206470601,
            206467341,
            206478011,
            206475881,
            206470693,
            206472518,
            206472870,
            206562261,
            206473668,
            206473209,
            206471774,
            206472820,
            206477277
        ],
        "B": [
            206461337,
            206465386,
            206481088,
            206469699,
            206465480,
            206464242,
            206462159,
            206470246,
            206468314,
            206462993,
            206468820,
            206467031,
            206466013,
            206465802,
            206464804,
            206466201,
            206465451,
            206463520,
            206466366,
            206465332
        ],
        "A": [
            206458073,
            206459090,
            206464738,
            206461735,
            206459482,
            206458188,
            206458127,
            206458669,
            206459064,
            206459476,
            206460428,
            206459198,
            206458554,
            206458909,
            206458986,
            206459453,
            206458429,
            206458492,
            206458602
        ]
    },
    "name": "F. Ira and Flamenco",
    "statement": "Ira loves Spanish flamenco dance very much. She decided to start her own\r\ndance studio and found n students, ith of whom has a_i.Ira can choose\r\nseveral of her students and set a dance with them. So she can set a huge\r\nnumber of dances, but she is only interested in dances. The dance is\r\ncalled if the following is true: m students participate in the dance; of\r\nall dancers are ; of every two dancers have an absolute difference than\r\nm. For example, if m = 3 and a = [4, 2, 2, 3, 6], the following dances\r\nare (students participating in the dance are highlighted in red): [\r\ncolor{red}{4}, 2,\r\ncolor{red}{2},\r\ncolor{red}{3}, 6], [\r\ncolor{red}{4},\r\ncolor{red}{2}, 2,\r\ncolor{red}{3}, 6]. At the same time dances [\r\ncolor{red}{4}, 2, 2,\r\ncolor{red}{3}, 6], [4,\r\ncolor{red}{2},\r\ncolor{red}{2},\r\ncolor{red}{3}, 6], [\r\ncolor{red}{4}, 2, 2,\r\ncolor{red}{3},\r\ncolor{red}{6}] are not .In the dance [\r\ncolor{red}{4}, 2, 2,\r\ncolor{red}{3}, 6] only 2 students participate, although m = 3.The dance\r\n[4,\r\ncolor{red}{2},\r\ncolor{red}{2},\r\ncolor{red}{3}, 6] involves students with 2 and 2, although of all\r\ndancers must be pairwise distinct.In the dance [\r\ncolor{red}{4}, 2, 2,\r\ncolor{red}{3},\r\ncolor{red}{6}] students with 3 and 6 participate, but |3 - 6| = 3,\r\nalthough m = 3.Help Ira count the number of dances that she can set.\r\nSince this number can be very large, count it 10^9 + 7. Two dances are\r\nconsidered different if the sets of students participating in them are\r\ndifferent.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n \ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % P)} {}\n    \n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += P;\n        }\n        if (x >= P) {\n            x -= P;\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(P - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) {\n        x = 1LL * x * rhs.x % P;\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing Z = MInt<MOD>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z C(int m, int k) {\n        if (m < k || k < 0) return 0;\n        return fac(m) * invfac(k) * invfac(m - k);\n    }\n} comb;\n\ntemplate<class Info>\nstruct SegmentTree {\n    int n;\n    std::vector<Info> info;\n\n    SegmentTree() : n(0) {}\n\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n\n    template<class T>\n    SegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        int sz = (1 << (std::__lg(n - 1) + 1));\n        info.assign(sz * 2, Info());\n        std::function<void(int, int, int)> build = [&](int v, int l, int r) {\n            if (l == r) {\n                info[v] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(v + v, l, m);\n            build(v + v + 1, m + 1, r);\n            info[v] = info[v + v] + info[v + v + 1];\n        };\n        build(1, 0, n - 1);\n    }\n\n    Info rangeQuery(int v, int l, int r, int tl, int tr) {\n        if (r < tl || l > tr) {\n            return Info();\n        }\n        if (l >= tl && r <= tr) {\n            return info[v];\n        }\n        int m = (l + r) / 2;\n        return rangeQuery(v + v, l, m, tl, tr) + rangeQuery(v + v + 1, m + 1, r, tl, tr);\n    }\n\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n - 1, l, r);\n    }\n\n    void modify(int v, int l, int r, int i, const Info &x) {\n        if (l == r) {\n            info[v] = x;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            modify(v + v, l, m, i, x);\n        } else {\n            modify(v + v + 1, m + 1, r, i, x);\n        }\n        info[v] = info[v + v] + info[v + v + 1];\n    }\n\n    void modify(int i, const Info &x) {\n        modify(1, 0, n - 1, i, x);\n    }\n\n    Info query(int v, int l, int r, int i) {\n        if (l == r) {\n            return info[v];\n        }\n        int m = (l + r) / 2;\n        if (i <= m) {\n            return query(v + v, l, m, i);\n        } else {\n            return query(v + v + 1, m + 1, r, i);\n        }\n    }\n\n    Info query(int i) {\n        return query(1, 0, n - 1, i);\n    }\n};\n\nstruct Info {\n    Z mul;\n\n    Info() : mul(1) {}\n\n    Info(int x) : mul(x) {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info res;\n    res.mul = a.mul * b.mul;\n    return res;\n}\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    std::sort(a.begin(), a.end());\n    std::vector<std::pair<int, int>> p;\n    p.emplace_back(a[0], 1);\n    for (int i = 1; i < n; i++) {\n        if (a[i] == a[i - 1]) {\n            ++p.back().second;\n        } else {\n            p.emplace_back(a[i], 1);\n        }\n    }\n    Z res = 0;\n    n = (int) p.size();\n    if (m - 1 >= n) {\n        std::cout << 0 << \"\\n\";\n        return;\n    }\n    std::vector<int> cnt(n);\n    for (int i = 0; i < n; i++) {\n        cnt[i] = p[i].second;\n    }\n    SegmentTree<Info> t(cnt);\n    for (int i = m - 1; i < n; i++) {\n        if (p[i].first - p[i - m + 1].first == m - 1) {\n            res += t.rangeQuery(i - m + 1, i).mul;\n        }\n    }\n    std::cout << res << \"\\n\";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "data structures",
        "implementation",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Ira and Flamenco.json",
    "editorial_link": "https://codeforces.com//blog/entry/116636",
    "editorial": "Reformulate the definition of dance. A dance is called if there exists\r\nsuch a non-negative integer that forms a permutation.Letâs build an\r\narray such that it is sorted, all the numbers in it are unique and each\r\nnumber from occurs in . For each element , set as its number of\r\noccurrences in the array . This process is called coordinate\r\ncompression. For example, if , then , .Let the constructed array has\r\nlength . In every dance there is a dancer with a minimum . Letâs fix\r\nthis minimal in the array , let its index be , then the desired dance\r\nexists if and .If the desired dance exists, the number of such dances\r\nmust be added to the answer, which is equal to . How to quickly\r\ncalculate such a number? Letâs build prefix products . Then by Fermatâs\r\nsmall theorem . Time complexity is . Letâs build a segment tree on a\r\nproduct modulo. Time complexity is and we donât use that the module is\r\nprime. We will use the idea of building a queue on two stacks, but we\r\nwill support prefix products modulo in these stacks. Time complexity is\r\nand we donât use that the module is prime.\r\n",
    "hint": []
}