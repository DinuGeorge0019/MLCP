{
    "link": "https://codeforces.com//contest/1986/problem/F",
    "problemId": "2714658",
    "problem_idx": "F",
    "shortId": "1986F",
    "contest_number": "1986",
    "problem_submissions": {
        "G2": [
            267051586,
            267098517,
            267207124,
            267227692
        ],
        "G1": [
            267050167,
            267075101,
            267042149,
            267064735,
            267062041,
            267072094,
            267189212,
            267907699,
            267227655
        ],
        "F": [
            267036897,
            267006951,
            267211888,
            267210735,
            267209305,
            267209191,
            267142479,
            267067023,
            267046217,
            267049909,
            267055692,
            267026922,
            267034254,
            267024454,
            267035130,
            267043900,
            267043428,
            267046638,
            267048369,
            267046109,
            267054071,
            267044101,
            267051585,
            267055127
        ],
        "E": [
            267031182,
            267035399,
            267025961,
            267037775,
            267044980,
            267032730,
            267010850,
            267025710,
            267050692,
            267025261,
            267026751,
            267028762,
            267028451,
            267027196,
            267036783,
            267025470,
            267030110,
            267036403,
            267037341
        ],
        "D": [
            267019160,
            267019752,
            267011405,
            267021594,
            267023740,
            267014893,
            267011680,
            267009591,
            267007109,
            267005474,
            267006461,
            267009567,
            267009731,
            267006448,
            267009653,
            267006959,
            267018496,
            267008934,
            267008176
        ],
        "C": [
            266989125,
            266982272,
            266994840,
            267002991,
            266993066,
            267005030,
            266983150,
            266989202,
            266983682,
            267008636,
            266990051,
            266988914,
            266994220,
            266992535,
            266990847,
            266994508,
            266995474,
            266989895,
            266985787
        ],
        "B": [
            266980718,
            266971385,
            266985030,
            266993111,
            266976413,
            266985138,
            266977306,
            266981373,
            266976133,
            266979778,
            266979273,
            266982265,
            266980709,
            266977455,
            266980695,
            266983193,
            266981883,
            266982561,
            266978536
        ],
        "A": [
            266966090,
            266964678,
            266968415,
            266974624,
            270989331,
            266965521,
            266965134,
            266964884,
            266966168,
            266965003,
            266971429,
            266979885,
            266965867,
            266964795,
            266965926,
            266967291,
            266966370,
            266967270,
            266967228,
            266965380
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130783",
    "editorial": "Notice that if an edge is not a bridge, then after its removal the graph remains connected and all vertices are reachable from each other.\n\nTherefore, we would like to remove some bridge edge (if there are no bridges, the answer is n?(n?1)2\n). After its removal, the graph will split into two connected components, let their sizes be x\n and y\n (note that x+y=n\n). Then the number of pairs of vertices reachable from each other will be equal to x?(x?1)2+y?(y?1)2\n. Let's find all the bridges in the graph, run a dfs\n from an arbitrary vertex and calculate for each vertex the size of its subtree in the dfs\n traversal tree (denote the size of the subtree of vertex v\n as szv\n). Thus, for each bridge, we can find x\n and y\n, knowing the sizes of the subtrees (if the edge (u,v)\n is a bridge, then x=min(szx,szy),y=n?x\n). For all bridges, output the smallest answer.\n",
    "name": "F. Non-academic Problem",
    "statement": "You are given a connected undirected graph, the vertices of which are\r\nnumbered with integers from 1 to n. Your task is to minimize the number\r\nof pairs of vertices 1\r\nleq u < v\r\nleq n between which there exists a path in this graph. To achieve this,\r\nyou can remove exactly one edge from the graph.Find the smallest number\r\nof pairs of vertices!\r\n",
    "solutions": [
        "// + : add edge(u, v)// - : delete add(u, v)// ? : count number components#include<iostream>#include<iomanip>#include<algorithm>#include<stack>#include<queue>#include<string>#include<string.h>#include<cmath>#include<vector>#include<map>#include<unordered_map>#include<set>#include<unordered_set>#include<cstdio>#include<bitset>#include<chrono>#include<random>#include<ext/rope>/* ordered_set#include<ext/pb_ds/assoc_container.hpp>#include<ext/pb_ds/tree_policy.hpp>using namespace __gnu_pbds;#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>*/#define int long long#define pb push_back#define fi first#define se secondusing namespace std;using ll = long long;using ld = long double;using ull = unsigned long long;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int maxN = 1e6 + 5;const int mod = 1e9 + 7;const ll oo = 1e18;int n, m;int lab[maxN];int res[maxN];map<pair<int, int>, int> mp;struct TEdge{    int u, v;} e[maxN];void ReadInput(){    cin >> n >> m;    for(int i=1; i<=m; i++)        cin >> e[i].u >> e[i].v;}vector<pair<int, int>> vc;int ans = 0;int Findset(int u){    return lab[u] < 0 ? u : Findset(lab[u]);}void Unite(int u, int v){    int r = Findset(u), s = Findset(v);    if(r == s) return;    if(lab[r] > lab[s]) swap(r, s);    vc.pb({r, lab[r]});    vc.pb({s, lab[s]});    ans += -lab[r] * -lab[s];    lab[r] += lab[s];    lab[s] = r;}void rollback(int sz){    int cnt = 0;    while(vc.size() > sz)    {        auto v = vc.back();        vc.pop_back();        lab[v.fi] = v.se;        cnt++;    }    ans += cnt / 2;}void DnC(int l, int r){    if(l == r)    {        res[l] = ans;        return;    }    int s = vc.size();    int mid = (l + r) / 2;    int tmp = ans;    for(int i=mid+1; i<=r; i++)    {        Unite(e[i].u, e[i].v);    }    DnC(l, mid);    rollback(s);    ans = tmp;    s = vc.size();    for(int i=l; i<=mid; i++)    {        Unite(e[i].u, e[i].v);    }    DnC(mid + 1, r);}void Solve(){    ans = 0;    fill(lab, lab + n + 1, -1);    fill(res, res + m + 1, oo);    DnC(1, m);    cout << *min_element(res + 1, res + m + 1) << '\\n';}int32_t main(){    //freopen(\"sol.inp\", \"r\", stdin);    ios_base::sync_with_stdio(false);    cin.tie(nullptr);    int test;    cin >> test;    while(test--)    {        ReadInput();        Solve();    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Non-academic Problem.json",
    "hint": []
}