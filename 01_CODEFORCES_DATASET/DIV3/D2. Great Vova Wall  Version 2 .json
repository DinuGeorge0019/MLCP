{
    "link": "https://codeforces.com//contest/1092/problem/D2",
    "problemId": "271423",
    "problem_idx": "D2",
    "shortId": "1092D2",
    "contest_number": "1092",
    "problem_submissions": {
        "F": [
            47218597,
            47207874,
            47241634,
            47318477,
            47214615,
            47217604,
            47210093,
            47210748,
            47212691,
            47213985,
            47215066,
            47216141
        ],
        "D1": [
            47215980,
            47227965,
            47212365,
            47220485,
            47215001,
            47223458,
            47225913,
            47226094,
            47209533,
            47227527,
            47227478,
            47227395,
            47227268,
            47226719,
            47216461,
            47213724,
            47334192
        ],
        "D2": [
            47212833,
            47212767,
            47218226,
            47218497,
            47219527,
            47223320,
            47217259,
            47271469,
            47223969,
            47236061,
            47213976,
            47212963,
            47333101
        ],
        "C": [
            47208479,
            47202011,
            47208106,
            47207681,
            47211238,
            47213730,
            47205520,
            47206298,
            47207117,
            47206109,
            47208340,
            47227233,
            47226698,
            47207049,
            47207288,
            47209584,
            47210057,
            47206966,
            47207998
        ],
        "B": [
            47202083,
            47196597,
            47203007,
            47199377,
            47202631,
            47197720,
            47198736,
            47196902,
            47198167,
            47197186,
            47198915,
            47226662,
            47196684,
            47197714,
            47198493,
            47198454,
            47201892,
            47199196
        ],
        "A": [
            47200523,
            47196094,
            47201972,
            47196916,
            47200910,
            47196295,
            47196192,
            47197255,
            47196159,
            47196525,
            47196472,
            47196994,
            47226648,
            47196039,
            47196511,
            47196950,
            47196914,
            47198726,
            47197707
        ],
        "E": [
            47266392,
            47319938,
            47234188,
            47277429,
            47369991
        ]
    },
    "name": "D2. Great Vova Wall  Version 2 ",
    "statement": "Vova’s family is building the Great Vova Wall (named by Vova himself).\r\nVova’s parents, grandparents, grand-grandparents contributed to it. Now\r\nit’s totally up to Vova to put the finishing touches.The current state\r\nof the wall can be respresented by a sequence a of n integers, with a_i\r\nbeing the height of the i-th part of the wall.Vova can only use 2\r\ntimes 1 bricks to put in the wall (he has infinite supply of them,\r\nhowever).Vova can put bricks on the neighbouring parts of the wall of\r\nequal height. It means that if for some i the current height of part i\r\nis the same as for part i + 1, then Vova can put a brick there and thus\r\nincrease both heights by 1. Obviously, Vova can’t put bricks in such a\r\nway that its parts turn out to be off the borders (to the left of part 1\r\nof the wall or to the right of part n of it).Vova is a perfectionist, so\r\nhe considers the wall completed when: all parts of the wall has the same\r\nheight; the wall has no empty spaces inside it. Can Vova complete the\r\nwall using any amount of bricks (possibly zero)?\r\n",
    "solutions": [
        "#include<cstdio>\nint m;\nint a[200000];\nint cnt[200000];\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        int x;\n        scanf(\"%d\",&x);\n        while(m&&a[m-1]<x){\n            if(cnt[m-1]&1){\n                puts(\"NO\");\n                return 0;\n            }\n            m--;\n        }\n        if(!m||a[m-1]!=x){\n            cnt[m]=1;\n            a[m++]=x;\n        }\n        else{\n            cnt[m-1]++;\n        }\n    }\n    for(int i=1;i<m;i++){\n        if(cnt[i]&1){\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D2. Great Vova Wall  Version 2 .json",
    "editorial_link": "https://codeforces.com//blog/entry/63961",
    "editorial": "Fairly enough, solutions of both versions of the problem are pretty\r\nsimilar.Read the second part of the previous tutorial first.This problem\r\ncan also be implemented in the strightforward manner. The greedy\r\nsolution now is searching for the first minimum in array and putting a\r\nbrick in there. If itâs impossible then the answer is \"\". This can also\r\nbe simulated with sets, a bit more tedious but still ok and also .Now\r\nback to the stack approach. Here you canât go to parities of the numbers\r\n(like tests and lead to different results). You push the number itself.\r\nHowever, you will also need an extra condition on the stack. You canât\r\npush to it the number greater than the current topmost element. The only\r\nproblem with this are maximums of array. Obviously, the resulting wall\r\n(if the answer exists) will be of height equal to the maximum initial\r\nheight. And it means that you shouldnât care about the ability to match\r\nall maximums in stack. They way I suggest to take around the issue is to\r\nprocess separately each segment between two consecutive maximums.One can\r\neasily prove the correctness of it by construction.Overall complexity: .\r\n",
    "hint": []
}