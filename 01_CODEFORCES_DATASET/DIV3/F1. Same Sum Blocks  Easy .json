{"link": "https://codeforces.com//contest/1141/problem/F1", "problemId": "316175", "problem_idx": "F1", "shortId": "1141F1", "contest_number": "1141", "problem_submissions": {"G": [52739588, 51536187, 51534299, 51525036, 55748640, 98770872, 51606575, 51605903, 51550288, 51562985], "E": [51521056, 51509494, 51514700, 51509864, 51515343, 51512067, 51514136, 51516742, 51515279, 51513645, 51514418, 51515657, 51529830, 51518938, 51520757, 51514193, 51518496, 51519253], "F2": [51512804, 51520813, 51519468, 51520462, 51524714, 51522819, 51524615, 51526867, 51526388, 51528287, 51528610, 51526942, 51526833, 51528921, 51567579, 51529733, 51520266, 51530585, 51528159], "F1": [51512586, 51519520, 51520037, 51530962, 51520861, 51524235, 51522340, 51524194, 51526191, 51525945, 51527775, 51528063, 51527052, 51527343, 51520158, 51528384, 51528375, 51520780, 51530653, 51527810], "D": [51504077, 51500288, 51507602, 51497021, 51498993, 51505660, 51501736, 51504542, 51504450, 51505517, 51507648, 51506380, 51507813, 51509739, 51507965, 51506483, 51503583, 51507577, 51514228], "C": [51496498, 51493212, 51499078, 51492880, 51502608, 51499584, 51495627, 51495976, 51499494, 51500075, 51499041, 51503297, 51499022, 51497246, 51497075, 51529270, 51499224, 51506668], "B": [51489707, 51490678, 51493680, 51489601, 51492373, 51494463, 51492484, 51490578, 51491799, 51494772, 51492508, 51496543, 51490227, 51491876, 51492884, 51490276, 51493813, 51493209], "A": [51488460, 51488637, 51489458, 51488560, 51490651, 51489465, 51489640, 51488837, 51490105, 51489577, 51489271, 51494436, 51488528, 51488619, 51489959, 51488566, 51490539]}, "name": "F1. Same Sum Blocks  Easy ", "statement": "You are given an array of integers a[1], a[2],\r\ndots, a[n]. A is a sequence of contiguous (consecutive) elements a[l],\r\na[l+1],\r\ndots, a[r] (1\r\nle l\r\nle r\r\nle n). Thus, a block is defined by a pair of indices (l, r).Find a set\r\nof blocks (l_1, r_1), (l_2, r_2),\r\ndots, (l_k, r_k) such that: They do not intersect (i.e. they are\r\ndisjoint). Formally, for each pair of blocks (l_i, r_i) and (l_j, r_j)\r\nwhere i\r\nneq j either r_i < l_j or r_j < l_i. For each block the sum of its\r\nelements is the same. Formally, a[l_1]+a[l_1+1]+\r\ndots+a[r_1]=a[l_2]+a[l_2+1]+\r\ndots+a[r_2]=\r\ndots = a[l_k]+a[l_k+1]+\r\ndots+a[r_k]. The number of the blocks in the set is maximum. Formally,\r\nthere does not exist a set of blocks (l_1\u2019, r_1\u2019), (l_2\u2019, r_2\u2019),\r\ndots, (l_{k\u2019}\u2019, r_{k\u2019}\u2019) satisfying the above two requirements with k\u2019 >\r\nk. Write a program to find such a set of blocks.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nconst ll MAXN = 2000;\n\nll n, a[MAXN], pr[MAXN];\nmap<ll, vector< pair<ll, ll> >  > mp;\n\nbool cmp(pair<ll, ll> a, pair<ll, ll> b){\n    return a.second < b.second;\n}\n\nvector<pair<ll, ll> > get_ans(vector<pair<ll, ll> > & v){\n    sort(v.begin(), v.end(), cmp);\n    vector<pair<ll, ll> > ans;\n    ll len = -20;\n\n    for(int i = 0; i < v.size(); ++i){\n        if(v[i].first > len){\n            len = v[i].second;\n            ans.pb(v[i]);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1; i <= n; ++i){\n        cin >> a[i];\n        pr[i] = pr[i-1] + a[i];\n    }\n\n    for(int i = 1; i <= n; ++i){\n        for(int j = i; j <= n; ++j){\n            mp[pr[j] - pr[i-1]].pb({i, j});\n        }\n    }\n\n    ll ans = 0;\n    vector<pair<ll, ll> > vans;\n\n    for(auto i : mp){\n        vector<pair<ll, ll> > v = (i).second;\n        vector<pair<ll, ll> > cur = get_ans(v);\n        if(cur.size() > ans){\n            ans = cur.size();\n            vans = cur;\n        }\n    }\n\n    cout << ans << '\\n';\n    for(auto i : vans){\n        cout << i.first << ' ' << i.second << '\\n';\n    }\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["greedy"], "dificulty": "1900", "interactive": false}