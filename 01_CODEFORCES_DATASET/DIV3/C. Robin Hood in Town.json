{
    "link": "https://codeforces.com//contest/2014/problem/C",
    "problemId": "2892475",
    "problem_idx": "C",
    "shortId": "2014C",
    "contest_number": "2014",
    "problem_submissions": {
        "G": [
            282355237,
            282340908,
            282349517,
            282469109,
            282768209
        ],
        "H": [
            282319139,
            282294919,
            282369641,
            282327328,
            282344971,
            282343427,
            282320463,
            282354346,
            282338340,
            282341971,
            282345189,
            282359227,
            282335882,
            282356841,
            282332486,
            282259554,
            282367573,
            282358571,
            282340140,
            282354845,
            282340779
        ],
        "F": [
            282310940,
            282344360,
            282329041,
            282301003,
            282317626,
            282346191,
            282313376,
            282324314,
            282336360,
            282330209,
            282316236,
            282352931,
            282339107,
            282367052,
            282355481,
            282342400,
            282311004,
            282354051,
            282348444,
            282360261
        ],
        "E": [
            282298135,
            282347444,
            282324784,
            282315211,
            282288353,
            282301236,
            282298734,
            282299501,
            282311127,
            282309362,
            282313492,
            282303867,
            282309804,
            282310056,
            282314491,
            282344707,
            282319635,
            282302427,
            282313050,
            282331264,
            282317148
        ],
        "D": [
            282266365,
            282262468,
            282284761,
            282266186,
            282281624,
            282263914,
            282278929,
            282290066,
            282285534,
            282292322,
            282283633,
            282303511,
            282281064,
            282294495,
            282319933,
            282298383,
            282290687,
            282285759,
            282297433,
            282291388
        ],
        "C": [
            282245761,
            282249551,
            282267820,
            282250356,
            282260562,
            282251055,
            282251810,
            282263518,
            282256201,
            282252015,
            282260274,
            282248128,
            282257994,
            282266861,
            282299616,
            282253349,
            282254086,
            282264623,
            282276303,
            282262355
        ],
        "B": [
            282235337,
            282236894,
            282246106,
            282232521,
            282241668,
            282237594,
            282243258,
            282239802,
            282239576,
            282238146,
            282241956,
            282238965,
            282240579,
            282237329,
            282279188,
            282240894,
            282242478,
            282240040,
            282236073,
            282244164,
            282271471
        ],
        "A": [
            282225117,
            282225433,
            282233872,
            282225077,
            282234075,
            282225216,
            282226675,
            282226848,
            282232220,
            282227137,
            282231989,
            282227272,
            282229469,
            282228546,
            282236816,
            282226223,
            282233092,
            282227477,
            282229182,
            282226562
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134210",
    "editorial": "If we sort the wealth in increasing order, then the j\n-th person must be unhappy for Robin to appear, where j=?n/2?+1\n if 1\n-indexing or j=?n/2?\n if 0\n-indexing. We need aj<s+x2?n\n, where s\n is the original total wealth before x\n gold from the pot was added. Rearranging the equation gives x>2?n?aj?s\n. Because x\n is a non-negative integer, we arrive at the answer max(0,2?n?aj?s+1)\n.\n\nOf course, this problem can also be solved by binary search, with two caveats. First, one needs to be careful to avoid comparison between integer and float types, as rounding errors could create issues. You can always avoid division by 2n\n by multiplying it out. Second, one needs to pick the upper limit carefully to ensure it is large enough. Note that 2?n?max(a)\n can serve as the upper limit for the binary search for x\n, because that would push the average to be strictly above 2?max(a)\n and everyone except the one with the pot of gold would be unhappy.\n\nThere are 2\n edge cases, n=1,2\n, where the condition for Robin can never be reached, because the richest person will always be happy (at least in this problem, though perhaps not IRL). ChatGPT struggled to identify these edge cases, so it was tempting to leave at least one hidden. Following testing, we decided to give both in samples to reduce frustration.\n\nNote: Wealth inequality is better measured by the Gini coefficient which is too involved for this problem. Our criterion is a crude approximation for the Gini coefficient, and is equivalent to setting the mean to median ratio (a well known indicator for inequality) to 2\n. For a random distribution, this ratio is close to 1\n. Interestingly, this ratio for UK salary distribution is around 1.2\n, so no Robin yet.",
    "name": "C. Robin Hood in Town",
    "statement": "There are n people living in the town. Just now, the wealth of the i-th\r\nperson was a_i gold. But guess what? The richest person has found an\r\nextra pot of gold! More formally, find an a_j=max(a_1, a_2,\r\ndots, a_n), change a_j to a_j+x, where x is a non-negative integer\r\nnumber of gold found in the pot. If there are multiple maxima, it can be\r\nany one of them.A person is unhappy if their wealth is of the average\r\nwealth^{\r\ntext{ }}. If of the total population n are unhappy, Robin Hood will\r\nappear by popular demand.Determine the minimum value of x for Robin Hood\r\nto appear, or output -1 if it is impossible.^{\r\ntext{ }}The average wealth is defined as the total wealth divided by the\r\ntotal population n, that is,\r\nfrac{\r\nsum a_i}{n}, the result is a real number.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, m, a[N];void solve(){    cin >> n;    for (int i = 1; i <= n; i++)        cin >> a[i];    sort(a + 1, a + 1 + n);    int l = 0, r = 1e18, ans = -1;    auto check = [&](int x)    {        int sum = x;        for (int i = 1; i <= n; i++)            sum += a[i];        a[n] += x;        int cnt = 0;        for (int i = 1; i <= n; i++)            if (a[i] * 2 * n < sum)                cnt++;        a[n] -= x;        return cnt > n / 2;    };    while (l <= r)    {        int mid = l + r >> 1;        if (check(mid))            r = mid - 1, ans = mid;        else            l = mid + 1;    }    cout << ans << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Robin Hood in Town.json",
    "hint": [
        "Hint 1 Answer is impossible if n less than 3.",
        "Hint 2 Lets first find minimum no of people that should be unhappy (say K).",
        "Hint 3 Lets sort A, now average should be more than 2*Ak",
        "Hint 4 Lets say pot has X gold. Let S be the total gold. So X should be max(0,2*N*ak-S+1)"
    ]
}