{
    "link": "https://codeforces.com//contest/1772/problem/B",
    "problemId": "1699969",
    "problem_idx": "B",
    "shortId": "1772B",
    "contest_number": "1772",
    "problem_submissions": {
        "G": [
            185866908,
            185868804,
            185873335,
            185913962,
            185953726,
            185952520,
            186850297,
            186850227
        ],
        "F": [
            185855303,
            185865062,
            185861633,
            185852805,
            185857933,
            185851728,
            185860856,
            185855787,
            185864352,
            185856328,
            185859258,
            185858451,
            185854822,
            185861128,
            185859138,
            185859632,
            185864434,
            185848000
        ],
        "E": [
            185833320,
            185824865,
            185853135,
            185836538,
            185842386,
            185826244,
            185841572,
            185838582,
            185836735,
            185840815,
            185835557,
            185845402,
            185841206,
            185838785,
            185849100,
            185834339,
            185850985,
            185860647
        ],
        "D": [
            185819090,
            185847079,
            185843120,
            185824661,
            185823461,
            185842011,
            185826918,
            185829038,
            185828215,
            185825456,
            185830337,
            185829367,
            185832845,
            185833254,
            185834612,
            216833286,
            185829200,
            185833219,
            185836837
        ],
        "C": [
            185812558,
            185814879,
            185826142,
            185808094,
            185813274,
            185814811,
            185816864,
            185820487,
            185822215,
            185810534,
            185819302,
            185820777,
            185825870,
            185828411,
            185818012,
            185822938,
            185815452,
            185822870
        ],
        "B": [
            185806303,
            185808530,
            185810358,
            185820249,
            185807477,
            185807452,
            185807615,
            185812963,
            185808450,
            185814127,
            185808442,
            185811020,
            185818101,
            185811312,
            185806644,
            185817751,
            185807928,
            185811595
        ],
        "A": [
            185798273,
            185798668,
            185799351,
            185798230,
            185798228,
            185798156,
            185800228,
            185799343,
            185809092,
            185800941,
            185802793,
            185811122,
            185800618,
            185798345,
            185801366,
            185799187,
            185805016
        ]
    },
    "name": "B. Matrix Rotation",
    "statement": "You have a matrix 2\r\ntimes 2 filled with integers. You want your matrix to become beautiful.\r\nThe matrix is beautiful if the following two conditions are satisfied:\r\nin each row, the first element is smaller than the second element; in\r\neach column, the first element is smaller than the second element. You\r\ncan perform the following operation on the matrix any number of times:\r\nrotate it clockwise by 90 degrees, so the top left element shifts to the\r\ntop right cell, the top right element shifts to the bottom right cell,\r\nand so on: Determine if it is possible to make the matrix beautiful by\r\napplying zero or more operations.\r\n",
    "solutions": [
        "/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,a[N],k,res;\nvoid elixprep(){\n    \n}\nll x,y,u,v;\nvoid elix()\n{\n    cin>>x>>u>>v>>y;\n    if (x>u && x>v && u>y && v>y) cout<<\"YES\";\n    else if (u>x && u>y && x>v && y>v) cout<<\"YES\";\n    else if (y>u && y>v && u>x && v>x) cout<<\"YES\";\n    else if (v>x && v>y && x>u && y>u) cout<<\"YES\";\n    else cout<<\"NO\";\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}\n//listen to trap music. it won't help"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Matrix Rotation.json",
    "editorial_link": "https://codeforces.com//blog/entry/110313",
    "editorial": "Sure, you can just implement the rotation operation and check all\r\npossible ways to rotate the matrix, but itâs kinda boring. The model\r\nsolution does the different thing.If a matrix is beautiful, then its\r\nminimum is in the upper left corner, and its maximum is in the lower\r\nright corner (and vice versa). If you rotate it, the element from the\r\nupper left corner goes to the upper right corner, and the element from\r\nthe lower right corner goes to the lower left corner so these elements\r\nare still in the opposite corners. No matter how many times we rotate a\r\nbeautiful matrix, its minimum and maximum elements will be in the\r\nopposite corners and the opposite is true as well; if you have a matrix\r\nwith minimum and maximum elements in opposite corners, it can be rotated\r\nin such a way that it becomes beautiful.So, all we need to check is that\r\nthe minimum and the maximum elements are in the opposite corners. There\r\nare many ways to do it; in my opinion, the most elegant one is to read\r\nall four elements in an array of size ; then the opposite corners of the\r\nmatrix correspond either to positions and , or to positions and in this\r\narray. So, we check that the sum of positions of minimum and maximum is\r\nexactly .\r\n",
    "hint": []
}