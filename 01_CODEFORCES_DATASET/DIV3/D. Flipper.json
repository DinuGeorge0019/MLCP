{
    "link": "https://codeforces.com//contest/1833/problem/D",
    "problemId": "1929817",
    "problem_idx": "D",
    "shortId": "1833D",
    "contest_number": "1833",
    "problem_submissions": {
        "F": [
            206599548,
            206499044,
            206510645,
            206497958,
            206917535,
            206498356,
            206512969,
            206501833,
            206507754,
            206504303,
            206775083,
            206513772,
            206514120,
            206515332,
            206518320,
            206514205,
            206521502,
            206515630,
            206524274,
            206520741,
            206520948,
            206526178,
            206521131
        ],
        "G": [
            206512331,
            206521465,
            206506545,
            206477170,
            206519573,
            206523410,
            206530322,
            206518526,
            206777759,
            206531078,
            206532207,
            206527389,
            206532553,
            206535240,
            206530738,
            206539901,
            206510414,
            206533541,
            209018213,
            206536054,
            206538842,
            206866462,
            206539276
        ],
        "E": [
            206494444,
            206500619,
            206508800,
            206912480,
            206752261,
            206508820,
            206500946,
            206513913,
            206499318,
            206515052,
            206776677,
            206501077,
            206501029,
            206508081,
            206504803,
            206505276,
            206514758,
            206507981,
            206532142,
            206514436,
            206505945,
            206510447,
            206508190
        ],
        "D": [
            206478490,
            206489393,
            206482509,
            206516497,
            206493139,
            206494430,
            206493405,
            206772261,
            206483249,
            206490999,
            206496792,
            206494490,
            206495499,
            206492096,
            206495671,
            206562276,
            206493504,
            206494409,
            206497119,
            206489160,
            206496422
        ],
        "C": [
            206468900,
            206472444,
            206487689,
            206481281,
            206470369,
            206469924,
            206472556,
            206474926,
            206470601,
            206467341,
            206478011,
            206475881,
            206470693,
            206472518,
            206472870,
            206562261,
            206473668,
            206473209,
            206471774,
            206472820,
            206477277
        ],
        "B": [
            206461337,
            206465386,
            206481088,
            206469699,
            206465480,
            206464242,
            206462159,
            206470246,
            206468314,
            206462993,
            206468820,
            206467031,
            206466013,
            206465802,
            206464804,
            206466201,
            206465451,
            206463520,
            206466366,
            206465332
        ],
        "A": [
            206458073,
            206459090,
            206464738,
            206461735,
            206459482,
            206458188,
            206458127,
            206458669,
            206459064,
            206459476,
            206460428,
            206459198,
            206458554,
            206458909,
            206458986,
            206459453,
            206458429,
            206458492,
            206458602
        ]
    },
    "name": "D. Flipper",
    "statement": "You are given a permutation p of length n.A permutation is an array\r\nconsisting of n distinct integers from 1 to n in any order. For example,\r\n{2,3,1,5,4\r\n} is a permutation, while\r\n{1,2,2\r\n} is not (since 2 appears twice), and\r\n{1,3,4\r\n} is also not a permutation (as n=3, but the array contains 4).To the\r\npermutation p, you need to apply the following operation : First you\r\nchoose a segment [l, r] (1\r\nle l\r\nle r\r\nle n, a segment is a continuous sequence of numbers\r\n{p_l, p_{l+1},\r\nldots, p_{r-1}, p_r\r\n}) and reverse it. Reversing a segment means swapping pairs of numbers\r\n(p_l, p_r), (p_{l+1}, p_{r-1}), ..., (p_{l + i}, p_{r - i}) (where l + i\r\nle r - i). Then you swap the prefix and suffix: [r+1, n] and [1, l - 1]\r\n(note that these segments may be empty). For example, given n = 5, p =\r\n{2,\r\ncolor{blue}{3},\r\ncolor{blue}{1}, 5, 4\r\n}, if you choose the segment [l = 2, r = 3], after reversing the segment\r\np =\r\n{\r\ncolor{green}{2},\r\ncolor{blue}{1},\r\ncolor{blue}{3},\r\ncolor{green}{5},\r\ncolor{green}{4}\r\n}, then you swap the segments [4, 5] and [1, 1]. Thus, p =\r\n{\r\ncolor{green}{5},\r\ncolor{green}{4}, 1, 3,\r\ncolor{green}{2}\r\n}. It can be shown that this is the maximum possible result for the\r\ngiven permutation.You need to output the lexicographically permutation\r\nthat can be obtained by applying the operation described .A permutation\r\na is lexicographically greater than permutation b if there exists an i\r\n(1\r\nle i\r\nle n) such that a_j = b_j for 1\r\nle j < i and a_i > b_i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        --a[i];\n    }\n    if (n == 1) {\n        std::cout << a[0] + 1 << \"\\n\";\n        return;\n    }\n    std::vector<int> res(n, -1);\n    auto try_ = [&](int l, int r) {\n        std::vector<int> b;\n        for (int i = r + 1; i < n; i++) {\n            b.emplace_back(a[i]);\n        }\n        for (int i = r; i >= l; i--) {\n            b.emplace_back(a[i]);\n        }\n        for (int i = 0; i < l; i++) {\n            b.emplace_back(a[i]);\n        }\n        if (b > res) {\n            res = b;\n        } \n    };\n    try_(0, 0);\n    if (a[0] == n - 1) {\n        for (int i = 1; i < n; i++) {\n            if (a[i] == n - 2) {\n                try_(i, i);\n                for (int j = 0; j < i; j++) {\n                    try_(j, i);\n                    try_(j, i - 1);\n                }\n                break;\n            }\n        }\n    } else {\n        for (int i = 1; i < n; i++) {\n            if (a[i] == n - 1) {\n                try_(i, i);\n                for (int j = 0; j < i; j++) {\n                    try_(j, i);\n                    try_(j, i - 1);\n                }\n                break;\n            }\n        }\n    }\n    for (auto x : res) {\n        std::cout << x + 1 << \" \";\n    }\n    std::cout << \"\\n\";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Flipper.json",
    "editorial_link": "https://codeforces.com//blog/entry/116636",
    "editorial": "In these constraints we could solve the problem for . Let us note that\r\nthere can be no more than two candidates for the value . Since the first\r\nnumber in the permutation will be either if , or if . Then letâs go\r\nthrough the value of and choose the one in which the first number in the\r\nresulting permutation is as large as possible. Next, if , then we can\r\nhave two candidates for is , but note that it is always advantageous to\r\nput in that case, since it will not spoil the answer. Then we can go\r\nthrough and get the solution by the square, but we can do something\r\nsmarter. Notice now that the answer already contains all the numbers\r\nwhere . And then we write where is still unknown, and then . In that\r\ncase, letâs write as and then write as long as they are larger than .\r\nOtherwise, we immediately determine the value of and finish the answer\r\nto the end. Thus, constructively we construct the maximal permutation.\r\n",
    "hint": []
}