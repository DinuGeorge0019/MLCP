{
    "link": "https://codeforces.com//contest/1360/problem/H",
    "problemId": "629828",
    "problem_idx": "H",
    "shortId": "1360H",
    "contest_number": "1360",
    "problem_submissions": {
        "H": [
            81251920,
            81290028,
            81293330,
            81291112,
            81294740,
            81299062,
            81297186,
            81294484,
            81304607,
            81300361,
            81303070,
            81250599,
            81295409,
            81298287,
            81304237,
            81231948
        ],
        "G": [
            81250908,
            81261609,
            81276322,
            81265591,
            81276387,
            81264433,
            81272613,
            81280948,
            81267380,
            81269754,
            81289390,
            81293762,
            81279290,
            81296348,
            81288695,
            81287798
        ],
        "F": [
            81230412,
            81252303,
            81257057,
            81259404,
            81265576,
            81254763,
            81259977,
            81264927,
            81254624,
            81249372,
            81271302,
            81279300,
            81267710,
            81275581,
            81282413,
            81255521
        ],
        "E": [
            81216064,
            81240455,
            81234957,
            81246045,
            81233772,
            81233068,
            81236233,
            81262156,
            81246598,
            81264349,
            81235887,
            81262591,
            81252163,
            81263497,
            81254477,
            81259978
        ],
        "B": [
            81215775,
            81207436,
            81205722,
            81209946,
            81206365,
            81207859,
            81208440,
            81216311,
            81225212,
            81217601,
            81209275,
            81216781,
            81209546,
            81211074,
            81219408,
            81270897
        ],
        "A": [
            81211901,
            81203807,
            81203057,
            81203650,
            81203478,
            81204406,
            81203639,
            81224692,
            81237119,
            81214495,
            81204306,
            81209285,
            81203552,
            81206909,
            81211432,
            81273150
        ],
        "C": [
            81206744,
            81215880,
            81216577,
            81223025,
            81214552,
            81214398,
            81216644,
            81210331,
            81222555,
            81225820,
            81221447,
            81224269,
            81240900,
            81218199,
            81226927,
            81268532
        ],
        "D": [
            81205489,
            81225350,
            81222950,
            81235831,
            81222076,
            81219822,
            81226333,
            81233523,
            81233797,
            81230395,
            81227841,
            81245779,
            81245445,
            81255431,
            81237048,
            81264054
        ]
    },
    "name": "H. Binary Median",
    "statement": "Consider all binary strings of length m (1\r\nle m\r\nle 60). A binary string is a string that consists of the characters and\r\nonly. For example, is a binary string, and is not. Obviously, there are\r\nexactly 2^m such strings in total.The string s is lexicographically\r\nsmaller than the string t (both have the same length m) if in the first\r\nposition i from the left in which they differ, we have s[i] < t[i]. This\r\nis exactly the way strings are compared in dictionaries and in most\r\nmodern programming languages when comparing them in a standard way. For\r\nexample, the string is lexicographically smaller than the string ,\r\nbecause the first two characters are the same, and the third character\r\nin the first string is less than that in the second.We remove from this\r\nset n (1\r\nle n\r\nle\r\nmin(2^m-1, 100)) binary strings a_1, a_2,\r\nldots, a_n, each of length m. Thus, the set will have k=2^m-n strings.\r\nSort all strings of the resulting set in lexicographical ascending order\r\n(as in the dictionary).We number all the strings after sorting from 0 to\r\nk-1. Print the string whose index is\r\nlfloor\r\nfrac{k-1}{2}\r\nrfloor (such an element is called ), where\r\nlfloor x\r\nrfloor is the rounding of the number down to the nearest integer.For\r\nexample, if n=3, m=3 and a=[, , ], then after removing the strings a_i\r\nand sorting, the result will take the form: [, , , , ]. Thus, the\r\ndesired median is .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 1000 + 5 ;\nint n, m, a[N] ; \nchar s[N] ; \nvoid print( int x ) {\n\tfor( int i = m; i >= 1; -- i ) {\n\t\tif( x & ( 1ll << ( i - 1 ) ) ) printf(\"1\") ;\n\t\telse printf(\"0\") ; \n\t}\n\tputs(\"\") ; \n}\nsigned main()\n{\n\tint T = gi() ; \n\twhile( T-- ) {\n\t\tn = gi(), m = gi() ; \n\t\trep( i, 1, n ) {\n\t\t\tscanf(\"%s\", s + 1 ) ;\n\t\t\tint u = 0 ; \n\t\t\trep( i, 1, m ) u *= 2, u = ( u | ( s[i] - '0' ) ) ;\n\t\t\ta[i] = u ; \n\t\t}\n\t\tsort( a + 1, a + n + 1 ) ;\n\t\tint maxn = ( 1ll << m ) - n, rk = ( maxn + 1 ) / 2 ; \n\t\tint bef = 0, fl = 0 ; \n\t\trep( i, 1, n ) {\n\t\t\tint ty = a[i] - ( i - 1 ) + 1 ;\n\t\t\tint tp = a[i - 1] - ( i - 1 ) + 1 ;\n\t\t\tif( ty > rk ) {\n\t\t\t\tfl = 1, print(a[i - 1] + ( rk - tp )) ; break ; \n\t\t\t}\n\t\t}\n\t\tint ty = ( 1ll << m ) - n + 1 ;\n\t\tint tp = a[n] - n + 1 ;\n\t\tif( !fl ) print(a[n] + ( rk - tp )) ;\n\t}\n\treturn 0 ;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "constructive algorithms"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\H. Binary Median.json",
    "editorial_link": "https://codeforces.com//blog/entry/77846",
    "editorial": "If we did not delete the strings, then the median would be equal to the\r\nbinary notation of . After deleting strings, the median cannot change\r\n(numerically) by more than . Let\u00e2\u0080\u0099s start with the median and each time\r\ndecrease it by one if there are fewer not deleted smaller numbers than\r\nnot deleted large numbers. Similarly, you need to increase the median by\r\none, otherwise. The algorithm stops when the result is the median of the\r\ncurrent set. All these steps will run at most times.\r\n"
}