{
    "link": "https://codeforces.com//contest/1343/problem/C",
    "problemId": "599889",
    "problem_idx": "C",
    "shortId": "1343C",
    "contest_number": "1343",
    "problem_submissions": {
        "E": [
            77544731,
            77547078,
            77818546,
            77553455,
            77526508,
            77551799,
            77553477,
            77557131,
            77551163,
            77562420,
            77564988,
            77565009,
            77544133,
            77577002
        ],
        "D": [
            77525246,
            77528102,
            77748327,
            77524381,
            77567781,
            77531413,
            77529630,
            77539927,
            77535846,
            77538289,
            77534294,
            77537349,
            77562840,
            238605180,
            77507320,
            77510486,
            77513527,
            77513404
        ],
        "C": [
            77490036,
            77493815,
            77742798,
            77501239,
            77495338,
            77513080,
            77498834,
            77511866,
            77514187,
            77507681,
            77513027,
            77522212,
            77558773,
            77490933,
            77486396,
            77494674,
            77493219
        ],
        "B": [
            77481728,
            77486304,
            77493535,
            77484584,
            77496211,
            77506722,
            77497962,
            77502380,
            77499869,
            77502504,
            77507362,
            77557318,
            77482647,
            77482138,
            77485064,
            77486365
        ],
        "A": [
            77479154,
            77479897,
            77482377,
            77479329,
            77483177,
            77511043,
            77480713,
            77493273,
            77481543,
            77493574,
            77490656,
            77562988,
            77478656,
            77478590,
            77479688,
            77479813
        ],
        "F": [
            85928150,
            77633600
        ]
    },
    "name": "C. Alternating Subsequence",
    "statement": "Recall that the sequence b is a a subsequence of the sequence a if b can\r\nbe derived from a by removing zero or more elements without changing the\r\norder of the remaining elements. For example, if a=[1, 2, 1, 3, 1, 2,\r\n1], then possible subsequences are: [1, 1, 1, 1], [3] and [1, 2, 1, 3,\r\n1, 2, 1], but not [3, 2, 3] and [1, 1, 1, 1, 2].You are given a sequence\r\na consisting of n positive and negative elements (there is no zeros in\r\nthe sequence).Your task is to choose (length) subsequence of the given\r\nsequence (i.e. the sign of each next element is the opposite from the\r\nsign of the current element, like positive-negative-positive and so on\r\nor negative-positive-negative and so on). Among all such subsequences,\r\nyou have to choose one which has the of elements.In other words, if the\r\nmaximum length of subsequence is k then your task is to find the of\r\nelements of some subsequence of length k.You have to answer t\r\nindependent test cases.\r\n",
    "solutions": [
        "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nint n,a[200100];\n\nint calc(int x)\n{\n\tif (x>0) return 1;else return -1;\n}\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();\n\t\trep(i,1,n) a[i]=read();\n\t\tll ans=0,sum=0;\n\t\tint pos=1,mx=a[1];\n\t\trep(i,2,n)\n\t\t{\n\t\t\tif (calc(a[i])==calc(a[pos]))\n\t\t\t{\n\t\t\t\tmx=max(mx,a[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//cout << \"range \" << pos << \" \" << i-1 << endl;\n\t\t\t\tans+=mx;pos=i;mx=a[i];\n\t\t\t}\n\t\t}\n\t\tans+=mx;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Alternating Subsequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/76352",
    "editorial": "Firstly, letâs extract maximum by inclusion segments of the array that\r\nconsists of the numbers with the same sign. For example, if the array is\r\nthen these segments are , , and . We can do it with any \"two\r\npointers\"-like algorithm. The number of these segments is the maximum\r\npossible length of the alternating subsequence because we can take only\r\none element from each block. And as we want to maximize the sum, we need\r\nto take the maximum element from each block.Time complexity: .\r\n",
    "hint": []
}