{
    "link": "https://codeforces.com//contest/1015/problem/D",
    "problemId": "203549",
    "problem_idx": "D",
    "shortId": "1015D",
    "contest_number": "1015",
    "problem_submissions": {
        "F": [
            41046686,
            41089036,
            41088828,
            41088337,
            41096109,
            41155137
        ],
        "E2": [
            41044021,
            41044614,
            41045819,
            41046151,
            41041339,
            41120563,
            41047819,
            41049335,
            41046653,
            41047315,
            41056482,
            41049017,
            41046489,
            41053390,
            41052850,
            41051286,
            41054981,
            41057931,
            41047714,
            41052649,
            41063809,
            41051282
        ],
        "E1": [
            41043653,
            41042567,
            41045757,
            41045539,
            41040702,
            41045081,
            41043696,
            41046746,
            41047236,
            41044065,
            41048961,
            41046210,
            41043883,
            41050998,
            41051221,
            41044932,
            41048477,
            41047379,
            41051531,
            41047009
        ],
        "D": [
            41031342,
            41034646,
            41036110,
            41039331,
            41043349,
            41037861,
            41039026,
            41038448,
            41038110,
            41038683,
            41037715,
            41040743,
            41035875,
            41037945,
            41039903,
            41039757,
            41039527,
            41041117,
            41039970,
            41063782,
            41038156
        ],
        "B": [
            41028759,
            41027947,
            41029953,
            41029847,
            41027873,
            41030296,
            41030110,
            41028724,
            41031028,
            41029894,
            41029543,
            41031067,
            41030593,
            41029154,
            41029321,
            41029551,
            41029148,
            41033439,
            41031881,
            41028034
        ],
        "C": [
            41027720,
            41029992,
            41031722,
            41032867,
            41029608,
            41033310,
            41032299,
            41030539,
            41033426,
            41032047,
            41032615,
            41033736,
            41032226,
            41030814,
            41031207,
            41031359,
            41030973,
            41035988,
            41034551,
            41029776
        ],
        "A": [
            41025375,
            41025426,
            41026820,
            41025657,
            41025347,
            41026304,
            41026166,
            41025506,
            41029303,
            41025595,
            41025554,
            41027421,
            41025393,
            41025748,
            41025855,
            41025912,
            41025550,
            41026111,
            41026923,
            41025435
        ]
    },
    "name": "D. Walking Between Houses",
    "statement": "There are n houses in a row. They are numbered from 1 to n in order from\r\nleft to right. Initially you are in the house 1.You have to perform k\r\nmoves to other house. In one move you go from your current house to some\r\nother house. You can’t stay where you are (i.e., in each move the new\r\nhouse differs from the current house). If you go from the house x to the\r\nhouse y, the total distance you walked increases by |x-y| units of\r\ndistance, where |a| is the absolute value of a. It is possible to visit\r\nthe same house multiple times (but you can’t visit the same house in\r\nsequence).Your goal is to walk exactly s units of distance in total.If\r\nit is impossible, print \"\". Otherwise print \"\" and any of the ways to do\r\nthat. Remember that you should do exactly k moves.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define p_b push_back\n#define pll pair<ll,ll>\n#define endl \"\\n\"\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define ld long double\n\nusing namespace std;\ntypedef long long ll;\nconst ll MAXN = 1123456;\n\ntemplate <typename T>\nT sqr(T x){\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s){\n    cout << s << endl;\n    exit(0);\n}\n\nll bp(ll a,ll n){\n    ll res = 1;\n    while(n){\n        if(n % 2)res *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll n, k, s;\n    cin >> n >> k >> s;\n    vector <ll> ans(k);\n    if((n - 1) * k < s)vout(\"NO\");\n    if(s < k)vout(\"NO\");\n    cout << \"YES\\n\";\n    ll pos = 1;\n    for(int i = 0; i < k; i++){\n        ll ost = k - i - 1;\n        ll sum = min(n - 1, s - ost);\n        s -= sum;\n        if(pos + sum <= n)pos += sum; else pos -= sum;\n        ans[i] = pos;\n    }\n    for(auto i : ans)cout << i << \" \";\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Walking Between Houses.json",
    "editorial_link": "https://codeforces.com/blog/entry/60949",
    "editorial": "The solution for this problem is very simple: at first, if or the answer\r\nis \"\". Otherwise letâs do the following thing times: let be (we have to\r\ngreedily decrease the remaining distance but we also should remember\r\nabout the number of moves which we need to perform). We have to walk to\r\npossible house which is located at distance from the current house (also\r\ndonât forget to subtract from ).The proof of the fact that we can always\r\nwalk to the house at distance is very simple: one of the possible\r\nanswers (which is obtained by the algorithm above) will looks like\r\nseveral moves of distance , (possibly) one move of random distance less\r\nthan and several moves of distance . The first part of the answer can be\r\nobtained if we are stay near the leftmost or the rightmost house, second\r\nand third parts always can be obtained because distances we will walk in\r\nevery of such moves is less than .Time complexity is .\r\n",
    "hint": []
}