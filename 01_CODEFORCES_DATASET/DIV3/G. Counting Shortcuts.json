{
    "link": "https://codeforces.com//contest/1650/problem/G",
    "problemId": "1321166",
    "problem_idx": "G",
    "shortId": "1650G",
    "contest_number": "1650",
    "problem_submissions": {
        "F": [
            148879513,
            148986538,
            148986467,
            148954476,
            148898287,
            148901435,
            148899333,
            148905510,
            148917052,
            148904349,
            148961796
        ],
        "E": [
            148849636,
            148864683,
            148963130,
            148875756,
            148872079,
            148878903,
            148875510,
            148901218,
            148892416,
            148888540,
            148898231,
            148888980,
            148883282,
            148898577,
            148883163,
            148907542,
            148907274,
            148906672,
            148906320,
            148893084,
            148887495,
            148892756,
            148872442,
            148863112
        ],
        "D": [
            148826882,
            148840222,
            148845807,
            148854912,
            148854752,
            148856728,
            148840985,
            148865410,
            148852435,
            148848691,
            148844798,
            148864773,
            148844781,
            148864322,
            148875613,
            148870696,
            148859219,
            148920116,
            148876044,
            148839258,
            148838584
        ],
        "C": [
            148820093,
            148831170,
            148831813,
            148836720,
            148830087,
            148836086,
            148827090,
            148852471,
            148837137,
            148831426,
            148825553,
            148845906,
            148830527,
            148848884,
            148845635,
            148848540,
            148844404,
            148859460,
            148825220,
            148833443
        ],
        "B": [
            148812353,
            148815870,
            148817423,
            148824929,
            148816344,
            148818724,
            148809035,
            148821547,
            148823462,
            148821683,
            148815397,
            148837950,
            148818597,
            148837067,
            163337223,
            148830901,
            148832514,
            148848552,
            148825246,
            148813545,
            148824771
        ],
        "A": [
            148807991,
            148808027,
            148809803,
            148809976,
            148810949,
            148808067,
            148809583,
            148816565,
            148811698,
            148808085,
            148807871,
            148819883,
            148808075,
            148829522,
            148809900,
            148814537,
            148809886,
            148812702,
            148807945,
            148820895
        ],
        "G": [
            148891310,
            148885828,
            148904919,
            148896469,
            148883806,
            148899609,
            148903599,
            148896840,
            148894409,
            148919593,
            148886999,
            148901688,
            148905478
        ]
    },
    "name": "G. Counting Shortcuts",
    "statement": "Given an undirected connected graph with n vertices and m edges. The\r\ngraph contains no loops (edges from a vertex to itself) and multiple\r\nedges (i.e. no more than one edge between each pair of vertices). The\r\nvertices of the graph are numbered from 1 to n. Find the number of paths\r\nfrom a vertex s to t whose length differs from the shortest path from s\r\nto t by no more than 1. It is necessary to consider all suitable paths,\r\neven if they pass through the same vertex or edge more than once (i.e.\r\nthey are not simple). For example, let n = 6, m = 8, s = 6 and t = 1,\r\nand let the graph look like the figure above. Then the length of the\r\nshortest path from s to t is 1. Consider all paths whose length is at\r\nmost 1 + 1 = 2. 6\r\nrightarrow 1. The length of the path is 1. 6\r\nrightarrow 4\r\nrightarrow 1. Path length is 2. 6\r\nrightarrow 2\r\nrightarrow 1. Path length is 2. 6\r\nrightarrow 5\r\nrightarrow 1. Path length is 2. There is a total of 4 of matching paths.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O2\")\n#pragma GCC target(\"avx,avx2,fma\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define ll     long long\n#define test   int tt; cin>>tt; while(tt--)\n#define ff     first\n#define ss     second\n#define pb     push_back\n#define ppb    pop_back\n#define pf     push_front\n#define ppf    pop_front\n\ntemplate <typename T> using Ordered_Set_Tree =\n        tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using Ordered_Multiset_Tree =\n        tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n///DEBUG\nvoid _Print(int t) {cerr << t;}\nvoid _Print(string t) {cerr << t;}\nvoid _Print(char t) {cerr << t;}\nvoid _Print(long long t) {cerr << t;}\nvoid _Print(double t) {cerr << t;}\nvoid _Print(unsigned long long t) {cerr << t;}\n\ntemplate <class T, class V> void _Print(pair <T, V> &p);\ntemplate <class T> void _Print(list <T> &v);\ntemplate <class T> void _Print(vector <T> &v);\ntemplate <class T, class V> void _Print(T *v, V sz);\ntemplate <class T, class V, class P> void _Print(T *v, V sz, P sm);\ntemplate <class T> void _Print(set <T> &v);\ntemplate <class T, class V> void _Print(map <T, V> &v);\ntemplate <class T> void _Print(multiset <T> &v);\n\ntemplate <class T, class V> void _Print(pair <T, V> &p) {cerr << \"{\"; _Print(p.ff); cerr << \",\"; _Print(p.ss); cerr << \"}\\n\\n\";}\ntemplate <class T> void _Print(list <T> &v) {cerr << \"[ \"; for (T i : v) {_Print(i); cerr << \" \";} cerr << \"]\\n\\n\";}\ntemplate <class T> void _Print(vector <T> &v) {cerr << \"[ \"; for (T i : v) {_Print(i); cerr << \" \";} cerr << \"]\\n\\n\";}\ntemplate <class T, class V> void _Print(T *v, V sz) {cerr << \"[ \"; for(int i=0; i<sz; i++) {_Print(v[i]); cerr << \" \";} cerr << \"]\\n\\n\";}\ntemplate <class T, class V, class P> void _Print(T *v, V sz, P sm) {cerr << \"[\\n\"; for(int i=0; i<sz; i++) { for(int j=0; j<sm; j++) {_Print(v[i][j]); cerr << \" \";} cerr << \"\\n\";} cerr << \"]\\n\\n\";}\ntemplate <class T> void _Print(set <T> &v) {cerr << \"[ \"; for (T i : v) {_Print(i); cerr << \" \";} cerr << \"]\\n\\n\";}\ntemplate <class T> void _Print(multiset <T>& v) {cerr << \"[ \"; for (T i : v) {_Print(i); cerr << \" \";} cerr << \"]\\n\\n\";}\ntemplate <class T, class V> void _Print(map <T, V> &v) {cerr << \"[ \"; for (auto i : v) {_Print(i); cerr << \" \";} cerr << \"]\\n\\n\";}\n///DEBUG\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int MOD = 1000000007;\n\n    test\n    {\n        int n, m, s, t;\n        cin>>n>>m>>s>>t;\n\n        s--, t--;\n\n        vector<vector<int>> graph(n);\n\n        for(int i=0; i<m; i++)\n        {\n            int u, v;\n            cin>>u>>v;\n\n            u--, v--;\n\n            graph[u].pb(v);\n            graph[v].pb(u);\n        }\n\n        int dist[n] = {0};\n        int vis[n] = {0};\n\n        dist[s] = 0;\n\n        queue<int> que;\n        que.push(s);\n\n        while(que.size())\n        {\n            int u = que.front();\n            que.pop();\n            vis[u] = 1;\n\n            for(auto v: graph[u])\n            {\n                if(vis[v])      continue;\n\n                vis[v] = 1;\n                dist[v] = 1+dist[u];\n                que.push(v);\n            }\n        }\n\n        vector<pair<int, int>> vp;\n\n        for(int i=0; i<n; i++)\n            vp.pb({dist[i], i});\n\n        sort(vp.begin(), vp.end());\n\n        ll int ways0[n] = {0};\n        ll int ways1[n] = {0};\n\n        ways0[s] = 1;\n\n        vector<int> ver;\n\n        for(int k=1; k<vp.size();)\n        {\n            int v = vp[k].ff;\n\n            ver.clear();\n\n            while(k<vp.size() && vp[k].ff==v)\n                ver.pb(vp[k].ss), k++;\n\n            for(auto u: ver)\n            {\n                for(auto v: graph[u])\n                {\n                    if(dist[v]+1 == dist[u])\n                    {\n                        ways0[u] = (ways0[u] + ways0[v])%MOD;\n                        ways1[u] = (ways1[u] + ways1[v])%MOD;\n                    }\n                }\n            }\n\n            for(auto u: ver)\n            {\n                for(auto v: graph[u])\n                {\n                    if(dist[v] == dist[u])\n                        ways1[u] = (ways1[u] + ways0[v])%MOD;\n                }\n            }\n        }\n\n        cout<<(ways0[t] + ways1[t])%MOD<<\"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Counting Shortcuts.json",
    "editorial_link": "https://codeforces.com//blog/entry/100712",
    "editorial": "Note that in any shortest path, we cannot return to the previous vertex.\r\nSince if the current vertex , the previous . The current distance (the\r\nshortest distance to vertex ), the shortest distance to vertex . Then,\r\nif we return to the vertex , the shortest distance from it to is . If we\r\nadd to the current distance, we get: . Thus, we get a path at least\r\nlonger than the shortest one. Thus, our answer consists of only simple\r\npaths.If the answer consists only of simple paths, then we will simply\r\nadd vertices to the queue when traversing bfs twice (on the first visit,\r\nand on the next visit, when the distance to the vertex is equal to the\r\nshortest ). And we will also count the number of ways to get to that\r\nvertex. Then we can output the answer as soon as we get to the vertex\r\nthe second time for processing. After that we can terminate the loop.\r\nThe asymptotic will be since we only need bfs.\r\n",
    "hint": []
}