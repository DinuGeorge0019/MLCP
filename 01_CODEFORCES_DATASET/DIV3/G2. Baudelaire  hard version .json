{
    "link": "https://codeforces.com//contest/2106/problem/G2",
    "problemId": "3350613",
    "problem_idx": "G2",
    "shortId": "2106G2",
    "contest_number": "2106",
    "problem_submissions": {
        "G1": [
            317037524,
            317062262,
            317061590,
            317052941,
            317066213,
            317065911
        ],
        "F": [
            317035761,
            317047729,
            317029292,
            317067306,
            317073415,
            317070219,
            317022800,
            317030307,
            317028689,
            317050113,
            317855906,
            317044171,
            317050574,
            317045837,
            317043135,
            317044827,
            317050773,
            317041440
        ],
        "E": [
            317020313,
            317010744,
            317046134,
            317035937,
            317029339,
            317046150,
            317010414,
            317018526,
            317021744,
            317013609,
            317950136,
            317028070,
            317036331,
            317032678,
            317025857,
            317036190,
            317040887
        ],
        "D": [
            316999946,
            317027974,
            317011069,
            317020862,
            317037534,
            317031860,
            316984555,
            317007925,
            317005998,
            317006604,
            317007086,
            317010692,
            317015300,
            317015795,
            317017807,
            317018294,
            316999673
        ],
        "C": [
            316988591,
            316986472,
            316999853,
            317026133,
            316999286,
            317002344,
            316991443,
            316988219,
            317000196,
            316978313,
            316994740,
            316996215,
            317004560,
            317006037,
            317004240,
            317004181,
            316991883
        ],
        "B": [
            316981000,
            316979542,
            316988448,
            316988900,
            316993570,
            316993687,
            317000718,
            316983017,
            316992142,
            316991120,
            316981211,
            316985408,
            316994310,
            316999518,
            316991380,
            316984785,
            316983692
        ],
        "A": [
            316977086,
            316978937,
            316978575,
            316978826,
            316982345,
            316979125,
            316997396,
            316978412,
            316977215,
            316981299,
            316977127,
            316977164,
            316982363,
            316981149,
            316979807,
            316979304,
            316977212
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142254",
    "editorial": "(Author & Analysis: SpyrosAliv) SolutionRead the solution to the Easy\r\nVersion first.Obviously, if we know the parent of some node, we know\r\nwhich nodes are under that node’s subtree, so we never have to consider\r\nthem as candidates for the root of the tree. Let’s use this to choose\r\nnodes in a way such that each time we eliminate as many candidates as\r\npossible, even in the worst case. Specifically, consider querying for\r\nthe centroid of the tree (a centroid of a tree is a node that if it is\r\ndeleted, every connected component left has size no more than half of\r\nthe original tree). When querying for the centroid, there are two cases:\r\neither it is the root of the tree, in which case we are finished, or we\r\nfind its parent, which eliminates at least half of the current\r\ncandidates. Then, we delete all nodes that could not possibly be the\r\nroot, and query for the new centroid.Since the candidates get halved\r\neach time, we repeat the above process no more than times. In the\r\nabsolute worst case (which is not realistic), we make queries. For ,\r\nthis is about queries. I do want to stress that this case is impossible;\r\nthe queries are pretty loose but I want to allow a lot of different\r\nsolutions (there are some even better ones than the one I described\r\nhere, feel free to describe better solutions in the comments).\r\n",
    "name": "G2. Baudelaire  hard version ",
    "statement": "Baudelaire is very rich, so he bought a tree of size n, rooted at some\r\narbitrary node. Additionally, every node has a value of 1 or -1. Cow the\r\nNerd saw the tree and fell in love with it. However, computer science\r\ndoesn’t pay him enough, so he can’t afford to buy it. Baudelaire decided\r\nto play a game with Cow the Nerd, and if he won, he would gift him the\r\ntree.Cow the Nerd does not know which node is the root, and he doesn’t\r\nknow the values of the nodes either. However, he can ask Baudelaire\r\nqueries of two types: 1 k u_1 u_2 ... u_k: Let f(u) be the sum of the\r\nvalues of all nodes in the path from the root of the tree to node u. Cow\r\nthe Nerd may choose an integer k (1\r\nle k\r\nle n) and k nodes u_1, u_2, ..., u_k, and he will receive the value\r\nf(u_1) + f(u_2) + ... + f(u_k). 2 u: Baudelaire will toggle the value of\r\nnode u. Specifically, if the value of u is 1, it will become -1, and\r\nvice versa. Cow the Nerd wins if he guesses the value of every node\r\ncorrectly (the values of the final tree, performing the queries) within\r\nn + 200 total queries. Can you help him win?\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "divide and conquer",
        "implementation",
        "interactive",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G2. Baudelaire  hard version .json",
    "hint": []
}