{
    "link": "https://codeforces.com//contest/1029/problem/F",
    "problemId": "211261",
    "problem_idx": "F",
    "shortId": "1029F",
    "contest_number": "1029",
    "problem_submissions": {
        "F": [
            42047829,
            42034824,
            42039218,
            42045140,
            42050850,
            42057641,
            42355180,
            42049291,
            42049170,
            42057320,
            42157687,
            42044089,
            42546658,
            42048831,
            42049225,
            42048355,
            42061045,
            42061015
        ],
        "E": [
            42043766,
            42041583,
            42051097,
            42052718,
            42057627,
            42056052,
            42145593,
            42070440,
            42053184,
            42057293
        ],
        "D": [
            42037124,
            55325923,
            42076677,
            42050558,
            42365691,
            42365676,
            42365497,
            42365477,
            42365258,
            42365242,
            42365230,
            42365081,
            42364971,
            42364957,
            42364791,
            42356686,
            42356662,
            42356121,
            42356098,
            42356090,
            42356074,
            42355955,
            42355933,
            42355895,
            42355839,
            42355815,
            42355732,
            42355678,
            42042982,
            42045076,
            42143765,
            42043950,
            42072305,
            42083814,
            42075124,
            42052333,
            42052607,
            42052955
        ],
        "B": [
            42031994,
            42043199,
            42035507,
            42029721,
            42032248,
            42032998,
            42057919,
            42057314,
            42036457,
            42033868,
            42032775,
            42032090,
            42031079,
            42035681,
            42032483,
            42034211,
            53975070,
            42033101,
            42031960,
            42034275,
            42035033,
            42032988
        ],
        "A": [
            42030943,
            42032428,
            42030337,
            42031598,
            42030794,
            42031593,
            42030225,
            42057135,
            42032959,
            42032163,
            42030490,
            42030591,
            42029747,
            42032386,
            42029916,
            42032324,
            42075267,
            42030907,
            42030283,
            42032164,
            42032054,
            42031161
        ],
        "C": [
            42049735,
            42046367,
            42031881,
            42035737,
            42041787,
            42040163,
            42049039,
            42037198,
            42037422,
            42033541,
            42040258,
            42044533,
            42039967,
            42042410,
            42036447,
            42044633,
            42041967,
            42040799
        ]
    },
    "name": "F. Multicolored Markers",
    "statement": "There is an infinite board of square tiles. Initially all tiles are\r\nwhite.Vova has a red marker and a blue marker. Red marker can color a\r\ntiles. Blue marker can color b tiles. If some tile isn’t white then you\r\ncan’t use marker of any color on it. Each marker must be drained\r\ncompletely, so at the end there should be exactly a red tiles and\r\nexactly b blue tiles across the board.Vova wants to color such a set of\r\ntiles that: they would form a , consisting of exactly a+b colored tiles;\r\nall tiles of at least one color would also form a . Here are some\r\nexamples of correct colorings: Here are some examples of incorrect\r\ncolorings: Among all correct colorings Vova wants to choose the one with\r\nthe minimal perimeter. What is the minimal perimeter Vova can obtain?It\r\nis guaranteed that there exists at least one correct coloring.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n\nint p[20000005];\n\nll a,b,ans=LINF;\n\nvector <ll> da,db;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> a >> b;\n    ll s=sqrt(a);\n    for(ll i=1;i<=s;i++){\n        if(a%i==0) da.pb(i),da.pb(a/i);\n    }\n    s=sqrt(b);\n    for(ll i=1;i<=s;i++){\n        if(b%i==0) db.pb(i),db.pb(b/i);\n    }\n    sort(da.begin(),da.end());\n    sort(db.begin(),db.end());\n    s=sqrt(a+b);\n    for(ll x=1;x<=s;x++){\n        if((a+b)%x==0){\n            ll y=(a+b)/x;\n            auto it=upper_bound(da.begin(),da.end(),x);\n            if(it!=da.begin()){\n                it--;\n                ll p=*it;\n                if(p<=x && (a/p)<=y) ans=min(ans,2*(x+y));\n            }\n            it=upper_bound(db.begin(),db.end(),x);\n            if(it!=db.begin()){\n                it--;\n                ll p=*it;\n                if(p<=x && (b/p)<=y) ans=min(ans,2*(x+y));\n            }\n        }\n    }\n    cout << ans;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Multicolored Markers.json",
    "editorial_link": "https://codeforces.com/blog/entry/61439",
    "editorial": "should be area of the outer rectangle. It means that its sides are\r\ndivisors of . The same holds for the inner rectangle. Letâs assume that\r\nred color forms a rectangle, weâll try it and then swap with and solve\r\nthe same problem again. Write down all the divisors of up to , these are\r\nthe possible smaller sides of the inner rectangle. Divisors of up to are\r\npossible smaller sides of the outer rectangle. Letâs put inner rectangle\r\nto the left bottom corner of the outer rectangle and choose smaller\r\nsides of both of them as bottom and top ones. Iterate over the divisors\r\nof , for each of them choose the greatest divisor of smaller or equal to\r\nit and check that . Update the answer with if it holds.You can use both\r\nbinary search or two pointers, both get AC pretty easily.The number of\r\ndivisors of can usually be estimated as .Overall complexity: .\r\n",
    "hint": []
}