{
    "link": "https://codeforces.com//contest/1433/problem/C",
    "problemId": "766658",
    "problem_idx": "C",
    "shortId": "1433C",
    "contest_number": "1433",
    "problem_submissions": {
        "E": [
            96118292,
            96100384,
            96144411,
            96131531,
            96126171,
            96116171,
            96143430,
            96124657,
            96110938,
            96142211,
            96123301,
            96164122,
            96137865,
            96137248,
            96139372,
            96151324,
            96105901,
            96108332,
            96119162
        ],
        "D": [
            96108021,
            96096525,
            96105972,
            96112718,
            96099052,
            96105757,
            96102154,
            96119014,
            96106156,
            96111319,
            96110517,
            96107146,
            96106344,
            96110999,
            96119720,
            96108556,
            96096494,
            96100784,
            96104899
        ],
        "F": [
            96105759,
            96110506,
            96119004,
            96125972,
            96132730,
            96142830,
            96120574,
            96135431,
            96163807,
            96138553,
            96152985,
            96127650,
            96151526,
            96153346,
            96158052,
            96144943,
            96148733,
            96135208
        ],
        "C": [
            96102081,
            96092029,
            96090502,
            96100255,
            96092651,
            96097485,
            96096234,
            96096200,
            96099117,
            96101166,
            96102838,
            96101507,
            96097647,
            96094575,
            96113560,
            96103107,
            96090286,
            96093702,
            96099170
        ],
        "G": [
            96094218,
            96125410,
            96128032,
            96141154,
            96154260,
            96149033,
            96156333,
            96142357,
            96139797,
            96146497,
            96163476,
            96140362,
            96161234,
            96163894,
            96152235,
            96163050,
            96123944,
            96205637
        ],
        "B": [
            96092183,
            96084902,
            96085565,
            96094926,
            96088334,
            96090362,
            96089755,
            96089494,
            96088669,
            96093848,
            96088026,
            96089177,
            96087731,
            96090077,
            96098934,
            96093459,
            96086464,
            96086371,
            96090772
        ],
        "A": [
            96084957,
            96082729,
            96082939,
            96083168,
            96082835,
            96084005,
            96082966,
            96083516,
            96083887,
            96086611,
            96083211,
            96084639,
            96083406,
            96083239,
            96092645,
            96083081,
            96082670,
            96083000,
            96085692
        ]
    },
    "name": "C. Dominant Piranha",
    "statement": "There are n piranhas with sizes a_1, a_2,\r\nldots, a_n in the aquarium. Piranhas are numbered from left to right in\r\norder they live in the aquarium.Scientists of the Berland State\r\nUniversity want to find if there is piranha in the aquarium. The piranha\r\nis called if it can eat all the other piranhas in the aquarium (except\r\nitself, of course). Other piranhas will do nothing while the piranha\r\nwill eat them.Because the aquarium is pretty narrow and long, the\r\npiranha can eat only one of the adjacent piranhas during one move.\r\nPiranha can do as many moves as it needs (or as it can). More precisely:\r\nThe piranha i can eat the piranha i-1 if the piranha i-1 exists and\r\na_{i - 1} < a_i. The piranha i can eat the piranha i+1 if the piranha\r\ni+1 exists and a_{i + 1} < a_i. When the piranha i eats some piranha,\r\nits (a_i becomes a_i + 1).Your task is to find piranha in the aquarium\r\nor determine if there are no such piranhas.Note that you have to find\r\n(exactly one) dominant piranha, you don\u2019t have to find all of them.For\r\nexample, if a = [5, 3, 4, 4, 5], then the third piranha can be .\r\nConsider the sequence of its moves: The piranha eats the second piranha\r\nand a becomes [5,\r\nunderline{5}, 4, 5] (the underlined piranha is our candidate). The\r\npiranha eats the third piranha and a becomes [5,\r\nunderline{6}, 5]. The piranha eats the first piranha and a becomes [\r\nunderline{7}, 5]. The piranha eats the second piranha and a becomes [\r\nunderline{8}]. You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define forinc(i,a,b) for(int i=a;i<=b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forv(i,x) for(auto &i:x)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r)\n{\n    return l+rng()%(r-l+1);\n}\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';n?-x:x;})\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define batbit(i,x) (x|(1ll<<i))\n#define getbit(i,x) ((x>>i)&1)\n\nconst int mn=3e5+10;\nint a[mn];\n\nmain()\n{\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        int ma=0,kq=0,ok=0;\n        forinc(i,1,n)\n        {\n            cin >> a[i];\n            ma=max(ma,a[i]);\n            if(a[i]!=a[i-1]&&i!=1) ok=1;\n        }\n        forinc(i,1,n) if(a[i]==ma)\n        {\n            if(i!=1&&a[i]>a[i-1])\n            {\n                kq=i;\n                break;\n            }\n            if(i!=n&&a[i]>a[i+1])\n            {\n                kq=i;\n                break;\n            }\n        }\n        if(!ok) cout << -1 << \"\\n\";\n        else cout << kq << \"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Dominant Piranha.json",
    "editorial_link": "https://codeforces.com//blog/entry/83903",
    "editorial": "If all the piranhas have the same size then the answer is . Otherwise,\r\nthere are at least two different sizes of piranhas and the answer always\r\nexists. Claim that the answer is such a piranha with the maximum size\r\nthat one of the adjacent piranhas has the size less than a maximum.Why\r\nis it true and why the answer always exists? First, if the piranha with\r\nthe maximum size eats some other piranha, it becomes the only maximum in\r\nthe array and can eat all other piranhas. Why is there always such a\r\npair of piranhas? Let\u00e2\u0080\u0099s change our array a bit: replace every maximum\r\nwith and every non-maximum with . There is always some -pair or -pair in\r\nsuch array because we have at least two different elements.\r\n"
}