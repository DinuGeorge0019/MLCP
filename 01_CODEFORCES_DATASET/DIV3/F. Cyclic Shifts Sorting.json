{
    "link": "https://codeforces.com//contest/1374/problem/F",
    "problemId": "659590",
    "problem_idx": "F",
    "shortId": "1374F",
    "contest_number": "1374",
    "problem_submissions": {
        "E2": [
            85382072,
            85375189,
            85438625
        ],
        "F": [
            85353642,
            85415306,
            85383843,
            85383492,
            85387797
        ],
        "E1": [
            85326034,
            85415299,
            85334989,
            85321477,
            85339121,
            85319474,
            85320204,
            85328246,
            85336700,
            85339703,
            85337792,
            85338081,
            85335206,
            85337433,
            85338605,
            85342001,
            85329936,
            85333348,
            85346311
        ],
        "D": [
            85316338,
            85415714,
            85415293,
            85323106,
            85325598,
            85328229,
            85311173,
            85312812,
            85313089,
            85319125,
            85325499,
            85321861,
            85326849,
            85319951,
            85325883,
            85322528,
            85325568,
            85334734,
            85327646,
            85314511
        ],
        "C": [
            85307188,
            85415289,
            85310607,
            85296173,
            85316864,
            85302975,
            85301461,
            85301463,
            85305237,
            85304971,
            85309343,
            85306153,
            85311376,
            85308864,
            85309628,
            85308295,
            85307625,
            85311312,
            85303960
        ],
        "B": [
            85299874,
            85415460,
            85415277,
            85305586,
            85300354,
            85311254,
            85298580,
            85298918,
            85297647,
            85301049,
            85300227,
            85301912,
            85300264,
            85307719,
            85302644,
            85305750,
            85299884,
            85297473,
            85305618,
            85299402
        ],
        "A": [
            85296254,
            85418749,
            85415919,
            85415268,
            85300037,
            85296089,
            85298024,
            85296518,
            245635316,
            85296385,
            85295981,
            85296977,
            85296136,
            85296861,
            85296508,
            85298422,
            85298833,
            85299917,
            85296648,
            85305648,
            85300594,
            85296295
        ]
    },
    "name": "F. Cyclic Shifts Sorting",
    "statement": "You are given an array a consisting of n integers.In one move, you can\r\nchoose some index i (1\r\nle i\r\nle n - 2) and shift the segment [a_i, a_{i + 1}, a_{i + 2}] cyclically\r\nto the right (i.e. replace the segment [a_i, a_{i + 1}, a_{i + 2}] with\r\n[a_{i + 2}, a_i, a_{i + 1}]). Your task is to sort the initial array by\r\nor say that it is impossible to do that.You have to answer t independent\r\ntest cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << \" is \" << x << endl\n// #define endl '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7, N = 505;\n\nvi ans;\nint a[N], b[N];\n\nvoid go(int i) {\n\tans.PB(i);\n\tint t = a[i];\n\ta[i] = a[i + 2];\n\ta[i + 2] = a[i + 1];\n\ta[i + 1] = t;\n}\n\nvoid solve() {\n\tans.clear();\n\tint n;\n\tcin >> n;\n\tunordered_set<int> s;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ts.insert(a[i]);\n\t}\n\tfor(int i = n - 1; i >= 2; i--) {\n\t\tint pos = max_element(a, a + i + 1) - a;\n\t\tif(pos == 0) {\n\t\t\tgo(pos);\n\t\t\tpos++;\n\t\t}\n\t\twhile(pos != i) {\n\t\t\tgo(pos - 1);\n\t\t\tpos++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) b[i] = a[i];\n\tif(a[0] > a[1]) {\n\t\tif(s.size() == n) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tif(a[i] <= a[i + 1]) continue;\n\t\t\tif(i + 1 == n - 1) break;\n\t\t\tif(a[i + 2] == a[i]) {\n\t\t\t\tgo(i), go(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgo(i + 1);\n\t\t\tgo(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tassert(a[i] <= a[i + 1]);\n\t}\n\tcout << ans.size() << endl;\n\tfor(int i:ans) cout << i + 1 << \" \";\n\tcout << endl;\n}\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tsolve();\n\t}\t\n\t\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Cyclic Shifts Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/79517",
    "editorial": "Firstly, letâs solve the easier version of the problem. Assume we are\r\ngiven a permutation, not an array. Notice that the given operation\r\napplied to some segment of the permutation cannot change the parity of\r\nnumber of inversions (the number of inversions is the number of such\r\npairs of indices that and ). So if the number of inversions in the given\r\npermutation is odd then we canât sort this permutation (we canât obtain\r\nzero inversions).But if the number of inversions is even then we can\r\nalways sort the permutation with the following greedy algorithm: letâs\r\nfind the minimum element and move it to the first position. If its\r\nposition is then we can apply the operation to the segment and our\r\nelement will move by two positions to the left. So, after all, our\r\nelement is either at the first or at the second position. If itâs at the\r\nsecond position, letâs just apply two additional operations to the\r\nsegment . Then letâs just cut off the first element and solve the\r\nproblem without it. At the end we have only two numbers that can be not\r\nsorted and we can check all three possibilities and choose one which is\r\nsuitable for us (itâs always exists because the number of inversions is\r\neven).How do we solve the problem if we are given the array, not the\r\npermutation? First of all, we can prove that if the array contains at\r\nleast two equal elements, we can always sort it (we will prove it by\r\nconstruction). Letâs just renumerate the elements of the given array in\r\na way to obtian the permutation with the even number of inversions.\r\nThus, if then letâs find such a permutation that . We can find this\r\npermutation easily if we sort the array of pairs in increasing order.\r\nBut there can be one problem: this permutation can have odd number of\r\ninversions. Then we need to find two consecutive pairs with the same\r\nfirst values and swap these two elements in the permutation. Because in\r\nfact these two numbers are equal in the array and have consecutive\r\nvalues in the permutation, we guaranteed change the parity of number of\r\ninversions. Then we can apply our algorithm for permutations and solve\r\nthe problem for the array. If we failed then the answer is . Otherwise\r\nthe number of operations always does not exceed (because this sort works\r\nlike a bubble sort) so our answer is suitable.Time complexity: .\r\n",
    "hint": []
}