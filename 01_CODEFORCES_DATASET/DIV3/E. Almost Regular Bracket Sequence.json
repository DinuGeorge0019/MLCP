{
    "link": "https://codeforces.com//contest/1095/problem/E",
    "problemId": "275105",
    "problem_idx": "E",
    "shortId": "1095E",
    "contest_number": "1095",
    "problem_submissions": {
        "E": [
            47572493,
            47577391,
            47577601,
            47571130,
            47573480,
            47573851,
            47579488,
            47579243,
            47583313,
            47572977,
            47576569,
            47582897,
            47574546,
            47577946,
            47581685,
            47573841,
            47582231,
            47584199,
            47573945,
            47583101
        ],
        "F": [
            47566370,
            47573294,
            47562701,
            47573988,
            47579057,
            47581403,
            47572438,
            47566223,
            47578405,
            47576558,
            47583994,
            47577257,
            47570463,
            47582128,
            47586705,
            47807775,
            47807743,
            47807736,
            47807702,
            47586605,
            47608877,
            47573085,
            47580349,
            47588876,
            47585818
        ],
        "D": [
            47563209,
            47614712,
            47567371,
            47571011,
            47564325,
            47567777,
            47568284,
            47567860,
            47577158,
            47566286,
            47577441,
            47568324,
            47562890,
            47577182,
            47571848,
            47568920,
            47581067,
            47574935,
            47575170,
            47568243,
            47568626
        ],
        "C": [
            47559007,
            47560130,
            47566278,
            47559870,
            47560866,
            47562972,
            47564210,
            47560920,
            47562511,
            47560682,
            47563534,
            47559786,
            51809567,
            47573250,
            47561981,
            47566916,
            47564246,
            47565270,
            47562848,
            47563772,
            47565179
        ],
        "B": [
            47555392,
            47555193,
            47564009,
            47556364,
            47556516,
            47555175,
            47555868,
            47555467,
            47557131,
            47554642,
            47557601,
            47555771,
            47557598,
            47556456,
            47555954,
            47558351,
            47557404,
            47558162,
            47559339,
            47556593
        ],
        "A": [
            47554038,
            47554188,
            47553996,
            47553824,
            47555088,
            47553896,
            47554204,
            47554208,
            47554977,
            47553891,
            47554134,
            47554837,
            47554623,
            47554538,
            47554565,
            47555784,
            47555600,
            47554171,
            47557808,
            47555100
        ]
    },
    "name": "E. Almost Regular Bracket Sequence",
    "statement": "You are given a bracket sequence s consisting of n opening ” and closing\r\n” brackets.A bracket sequence is a bracket sequence that can be\r\ntransformed into a correct arithmetic expression by inserting characters\r\n” and ” between the original characters of the sequence. For example,\r\nbracket sequences \"\", \"\" are regular (the resulting expressions are: \"\",\r\n\"\"), and \"\" and \"\" are not.You can change the type of some bracket s_i.\r\nIt means that if s_i = ” then you can change it to ” and vice versa.Your\r\ntask is to calculate the number of positions i such that if you change\r\nthe type of the i-th bracket, then the resulting bracket sequence\r\nbecomes .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<\" \";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl '\\n'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<\" \"<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nconst int N=1e6+10;\n\nint t[4*N];\nvoid build(int a[], int v, int tl, int tr) {\n    if (tl == tr) {\n        t[v] = a[tl];\n    } else {\n        int tm = (tl + tr) / 2;\n        build(a, v*2, tl, tm);\n        build(a, v*2+1, tm+1, tr);\n        t[v] = min(t[v*2],t[v*2+1]);\n        // t[v] = t[v*2] + t[v*2+1];\n    }\n}\nint query(int v, int tl, int tr, int l, int r) {\n    if (l > r) \n        return 1e9;\n    if (l == tl && r == tr) {\n        return t[v];\n    }\n    int tm = (tl + tr) / 2;\n    return min(query(v*2, tl, tm, l, min(r, tm)),query(v*2+1, tm+1, tr, max(l, tm+1), r));\n}\n\n\nint main(){\n\tfast_io;\n\tstring s;\n\tint n;\n\tcin>>n>>s;\n\tint tot=0;\n\tint a[n+1];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif(s[i]=='(') tot++;\n\t\telse tot--;\n\t\ta[i]=tot;\n\t}\n\tbuild(a,1,0,n-1);\n\tint ans=0;\n\tif(n==1){\n\t\tpret(\"0\");\n\t}\n\tif(tot==2){\n\t\tfor (int i = 1; i < n-1; ++i)\n\t\t{\n\t\t\tif(s[i]==')') continue;\n\t\t\tint curr=query(1,0,n-1,0,i-1);\n\t\t\tif(curr<0) continue;\n\t\t\tcurr=query(1,0,n-1,i,n-1);\n\t\t\tif(curr<2) continue;\n\t\t\tans++;\n\t\t}\n\t\tint curr=query(1,0,n-1,0,n-2);\n\t\tif(s[n-1]=='(' and curr>=0) ans++;\n\t}\n\telse if(tot==-2){\n\t\tint curr=query(1,0,n-1,1,n-1);\n\t\tif(s[0]==')' and curr>=-2) ans++; \n\t\tfo(i,1,n-2){\n\t\t\tif(s[i]=='(') continue;\n\t\t\tcurr=query(1,0,n-1,0,i-1);\n\t\t\tif(curr<0) continue;\n\t\t\tcurr=query(1,0,n-1,i,n-1);\n\t\t\tif(curr<-2) continue;\n\t\t\tans++;\n\t\t}\n\t}\n\tshow(ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Almost Regular Bracket Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/64130",
    "editorial": "In this problem we have to calculate the number () of positions such\r\nthat if we change the type of the bracket at this position then the\r\nobtained bracket sequence will become regular.Letâs calculate the\r\nbalance of each prefix of the bracket sequence and store it in the array\r\n. Just iterate from left to right over the string and if the current\r\nbracket is opening then increase the current balance by one, otherwise\r\ndecrease it by one.For each prefix letâs also calculate whether it can\r\nbe a prefix of a regular bracket sequence (RBS) and store it in the\r\narray . The prefix of length can be the prefix of RBS if and only if the\r\nprefix of length can be the prefix of RBS and .Letâs calculate the same\r\narrays for all suffixes (and call they and correspondingly), but now the\r\nclosing bracket will increase the balance by one and the opening will\r\ndecrease it by one and we consider the characters from right to left.Now\r\nif we have these arrays, letâs iterate over all positions in the initial\r\nbracket sequence. If we now at the position then letâs do the following\r\nthings: firstly, if or then skip this position. Otherwise if the current\r\nbracket is opening then we have to increase the answer if and (only in\r\nthis case the bracket sequence will become regular). And if the current\r\nbracket is closing then we have to increase the answer if .\r\n",
    "hint": []
}