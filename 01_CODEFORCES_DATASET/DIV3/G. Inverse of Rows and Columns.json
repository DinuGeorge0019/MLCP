{
    "link": "https://codeforces.com//contest/1157/problem/G",
    "problemId": "336210",
    "problem_idx": "G",
    "shortId": "1157G",
    "contest_number": "1157",
    "problem_submissions": {
        "G": [
            53354096,
            53391965,
            53390867
        ],
        "F": [
            53343664,
            53360675,
            53361624,
            53364566,
            53357704,
            53359903,
            53361988,
            53361938,
            53362589
        ],
        "D": [
            53340379,
            53350471,
            53354170,
            53343980,
            53350301,
            53365956,
            53362535,
            53355323,
            53360133,
            53358327,
            53360447,
            53351641,
            53363339,
            53362459,
            53373877,
            53363141,
            53362698,
            53354329,
            53341889,
            53357655
        ],
        "E": [
            53335726,
            53354513,
            53342966,
            53357089,
            53326973,
            53337039,
            53343435,
            53334056,
            53346417,
            53344822,
            53341358,
            53352604,
            53344787,
            53355380,
            53351750,
            53373916,
            53343916,
            53337525,
            53354885,
            53347360
        ],
        "C2": [
            53332882,
            53338253,
            53340523,
            53360290,
            53337905,
            53344895,
            53348129,
            53339890,
            53350634,
            53347512,
            53397823,
            53341730,
            53345378,
            53373863,
            53335877,
            53380825,
            53366273,
            53365566,
            53365157,
            53364677,
            53340346
        ],
        "C1": [
            53329688,
            53331267,
            53335293,
            53360618,
            53332134,
            53331740,
            53332999,
            53331325,
            53335930,
            53335387,
            53334852,
            53338537,
            53337135,
            53345489,
            53379146,
            53336165,
            53333762,
            53348248,
            53334974
        ],
        "B": [
            53326629,
            53325954,
            53329930,
            53342495,
            53324816,
            53325500,
            53426742,
            53328079,
            53325908,
            53330675,
            53327539,
            53330292,
            53325880,
            53330636,
            53328572,
            53373831,
            53329602,
            53328749,
            53327714
        ],
        "A": [
            53324361,
            53324269,
            53324359,
            53326455,
            53324227,
            53324256,
            53426571,
            53324495,
            53324422,
            53326078,
            53325046,
            53327429,
            53324265,
            53327238,
            53324911,
            53373799,
            53324760,
            53341107,
            53324803,
            53324767
        ]
    },
    "name": "G. Inverse of Rows and Columns",
    "statement": "You are given a binary matrix a of size n\r\ntimes m. A binary matrix is a matrix where each element is either 0 or\r\n1.You may perform some (possibly zero) operations with this matrix.\r\nDuring each operation you can inverse the row of this matrix or a column\r\nof this matrix. Formally, inverting a row is changing all values in this\r\nrow to the opposite (0 to 1, 1 to 0). Inverting a column is changing all\r\nvalues in this column to the opposite.Your task is to sort the initial\r\nmatrix by some sequence of such operations. The matrix is considered if\r\nthe array [a_{1, 1}, a_{1, 2},\r\ndots, a_{1, m}, a_{2, 1}, a_{2, 2},\r\ndots, a_{2, m},\r\ndots, a_{n, m - 1}, a_{n, m}] is sorted .\r\n",
    "solutions": [
        "#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tprintf(\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << x << endl;\n#define O_(x) cerr << #x << \" \" << x << \"  \";\n#define ERR(x) cerr << \"ERR! #\" << x << endl;\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n\n// Optimize\n#define abs(a) ((a)<0?(~(a)+1):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) {a=a^b;b=a^b;a=a^b;}\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define MOD 998244353\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 256\n\nint n,m;\nint a[MAXN][MAXN];\nint totid;\nint rowid[MAXN][2], colid[MAXN][2];\n\nint dsu[1000000], sz[1000000];\nvc<pii> ops;\nvoid Init(){\n\tFor(i,totid){\n\t\tdsu[i] = i;\n\t\tsz[i] = 1;\n\t\tops.clear();\n\t}\n}\nint Findfa( int pos , bool force ){\n\tif(force) return dsu[pos] == pos ? pos : dsu[pos] = Findfa(dsu[pos],1);\n\treturn dsu[pos] == pos ? pos : Findfa(dsu[pos],0);\n}\nil void Unite( int a , int b , bool force ){\n\ta = Findfa(a,force);\n\tb = Findfa(b,force);\n\tif( sz[a] > sz[b] ) swap(a,b);\n\tdsu[a] = b;\n\tsz[b] += sz[a];\n\tif(!force) ops.Pb({a,b});\n}\nil void Undo(){\n\tint a,b;\n\ttie(a,b) = ops.back();\n\tops.pop_back();\n\tdsu[a] = a;\n\tsz[b] -= sz[a];\n}\nil bool Same( int a , int b , bool force ){\n\treturn Findfa(a,force) == Findfa(b,force);\n}\n\nvoid Let( int x , int y , int c , bool force = 0 ){\n\tint isdiff = a[x][y]!=c;\n\tif(isdiff){\n\t\tUnite(rowid[x][0],colid[y][1],force);\n\t\tUnite(rowid[x][1],colid[y][0],force);\n\t}else{\n\t\tUnite(rowid[x][0],colid[y][0],force);\n\t\tUnite(rowid[x][1],colid[y][1],force);\n\t}\n}\nbool Check( bool force = 0 ){\n\tFor(i,n) if(Same(rowid[i][0],rowid[i][1],force)) return 0;\n\tFor(i,m) if(Same(colid[i][0],colid[i][1],force)) return 0;\n\treturn 1;\n}\n\nvc<int> e[1000000];\nvc<int> boss;\nbool sel[1000000];\nvoid Dfs( int pos ){\n\tsel[pos] = 1;\n\tfor( auto v : e[pos] ) Dfs(v);\n}\n\nint main(){\n\tFILEIO();\n\n\tRead(n,m);\n\tFor(i,n)\n\t\tFor(j,m){\n\t\t\tRead(a[i][j]);\n\t\t}\n\tint uid = 0;\n\tFor(i,n){\n\t\trowid[i][1] = ++uid;\n\t\trowid[i][0] = ++uid;\n\t}\n\tFor(j,m){\n\t\tcolid[j][1] = ++uid;\n\t\tcolid[j][0] = ++uid;\n\t}\n\ttotid = uid;\n\n\tFor(irow,n){\n\t\tInit();\n\t\tForx(i,1,irow-1)\n\t\t\tFor(j,m)\n\t\t\t\tLet(i,j,0,1);\n\t\tForx(i,irow+1,n)\n\t\t\tFor(j,m)\n\t\t\t\tLet(i,j,1,1);\n\t\tif(!Check(1)) continue;\n\t\tForx(last0,0,m){\n\t\t\tFor(j,last0){\n\t\t\t\tLet(irow,j,0);\n\t\t\t}\n\t\t\tForx(j,last0+1,m){\n\t\t\t\tLet(irow,j,1);\n\t\t\t}\n\t\t\tif(Check()){\n\t\t\t\tputs(\"YES\");\n\t\t\t\t/*\n\t\t\t\tForx(i,1,irow-1){\n\t\t\t\t\tFor(j,m) putchar('0');\n\t\t\t\t\tputchar(10);\n\t\t\t\t}\n\t\t\t\tFor(i,last0) putchar('0');\n\t\t\t\tForx(j,last0+1,m) putchar('1');\n\t\t\t\tputchar(10);\n\t\t\t\tForx(i,irow+1,n){\n\t\t\t\t\tFor(j,m) putchar('1');\n\t\t\t\t\tputchar(10);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tFor(i,totid){\n\t\t\t\t\tif( dsu[i] != i ) e[dsu[i]].Pb(i);\n\t\t\t\t\telse{\n\t\t\t\t\t\tboss.Pb(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDfs(boss[0]);\n\t\t\t\tFor(i,n) putchar(sel[rowid[i][0]]?'0':'1'); putchar(10);\n\t\t\t\tFor(i,m) putchar(sel[colid[i][0]]?'0':'1'); putchar(10);\n\t\t\t\tEND();\n\t\t\t}\n\t\t\tFor(i,2*m) Undo();\n\t\t}\n\t}\n\tputs(\"NO\");\n\n\tEND();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Inverse of Rows and Columns.json",
    "editorial_link": "https://codeforces.com/blog/entry/66737",
    "editorial": "The first observation: if we have an answer where the first row is\r\ninverted, we can inverse all rows and columns, then the matrix will\r\nremain the same, and the first row is not inverted in the new answer. So\r\nwe can suppose that the first row is never inverted. Note that this will\r\nbe true only for slow solution.The second observation: if we consider a\r\nsorted matrix, its first row either consists only of \u00e2\u0080\u009ds, or has at least\r\none \u00e2\u0080\u009d and then all other rows consist only of \u00e2\u0080\u009ds. This observation can\r\nbe extended to the following (one user wrote a comment about it and I\r\npinned the link to it above) which can improve time complexity of the\r\nsolution a lot: in the sorted matrix either the first row consists only\r\nof \u00e2\u0080\u009ds, or the last row consists only of \u00e2\u0080\u009ds (the corner case is , but for\r\nwe can obtain both answers).So what should we do with these\r\nobservations? I will explain a slow solution, a faster solution can be\r\nobtained by mirroring one of cases of this one. Let\u00e2\u0080\u0099s iterate over the\r\nnumber of \u00e2\u0080\u009ds in the first row. Let it be . Then the first elements of\r\nthe first string should be \u00e2\u0080\u009ds, and all others should be \u00e2\u0080\u009ds. We can do it\r\nby inverting the columns with elements \u00e2\u0080\u009d among first elements of the\r\nfirst row and columns with elements \u00e2\u0080\u009d among remaining elements. So, it\u00e2\u0080\u0099s\r\ncase handling time!The first case (when ) is pretty easy. We have to\r\ncheck if all rows from to that they consist only of \u00e2\u0080\u009ds or only of \u00e2\u0080\u009ds\r\n(and if some row consists of \u00e2\u0080\u009ds then we should invert it). If it is true\r\nthen we found the answer. Otherwise the first row consists only of \u00e2\u0080\u009ds.\r\nSo we have to find the \"transitional\" row (the row with some \u00e2\u0080\u009ds on the\r\nprefix and \u00e2\u0080\u009ds on the suffix or vice versa). If the number of such rows\r\namong all rows from to is greater than then this configuration is bad.\r\nIf the number of such rows is then let be the index of this row. Then we\r\nshould inverse all rows above it consisting only of \u00e2\u0080\u009ds and all rows\r\nconsisting only of \u00e2\u0080\u009ds below it. And we have to check if the current row\r\nis really transitional. We know that its sum is neither nor so there is\r\nat least one \u00e2\u0080\u009d and at least \u00e2\u0080\u009d in it. If the first element is \u00e2\u0080\u009d then\r\nlet\u00e2\u0080\u0099s inverse it. Then we just should check if this row is sorted, and\r\nif it is then we found the answer. And the last case is if there are no\r\ntransitional rows in the matrix. Then we should invert all rows from to\r\nconsisting only of \u00e2\u0080\u009ds (or only of \u00e2\u0080\u009ds, it does not matter).So, we have a\r\nsolution with time complexity . Each number of \u00e2\u0080\u009ds in the first row is\r\nprocessed in and there are such numbers. But we can see that if we apply\r\nthe last case (when the number of \u00e2\u0080\u009d is ) to the first row and then do\r\nthe same, but with the last row consisting of \u00e2\u0080\u009d, we can get a solution\r\nin .\r\n"
}