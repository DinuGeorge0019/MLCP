{
    "link": "https://codeforces.com//contest/2008/problem/E",
    "problemId": "2850010",
    "problem_idx": "E",
    "shortId": "2008E",
    "contest_number": "2008",
    "problem_submissions": {
        "H": [
            279136956,
            279175231,
            279161763,
            279179363,
            279181586,
            279168976,
            279216022,
            279614299,
            279182476,
            279209636,
            279208468,
            279207341,
            279210332,
            279350027,
            279217913,
            279220559,
            279216550,
            279220895,
            279220924,
            279302743
        ],
        "G": [
            279119447,
            279152222,
            279151084,
            279131568,
            279192199,
            279163482,
            279207144,
            279160784,
            279362880,
            279111562,
            279178333,
            279161657,
            279296750,
            279200995,
            279191409,
            279192959,
            279209224,
            279173816,
            279190595,
            279189666,
            279155886,
            279187798
        ],
        "F": [
            279104606,
            279131689,
            279118881,
            279127227,
            279115943,
            279103916,
            279131962,
            279356689,
            279077044,
            279134534,
            279099699,
            279292527,
            279106499,
            279150166,
            279167659,
            279130886,
            279186290,
            279121299,
            279117301,
            279134844
        ],
        "E": [
            279097264,
            279123319,
            279112502,
            279113482,
            279140821,
            279152927,
            279147312,
            279181553,
            279142676,
            279163125,
            279188714,
            279161254,
            279138336,
            279154142,
            279156092,
            279140491,
            279154770,
            279110096,
            279153681,
            279116556
        ],
        "D": [
            279079188,
            279103941,
            279108267,
            279089266,
            279105270,
            279092186,
            279119277,
            279128075,
            279092080,
            279120640,
            279166364,
            279126815,
            279110851,
            279134432,
            279119823,
            279121959,
            279088289,
            279095604,
            279098547
        ],
        "C": [
            279075309,
            279090563,
            279107974,
            279084125,
            279095019,
            279080293,
            279095460,
            279192216,
            279081252,
            279108974,
            279132485,
            279093671,
            279089579,
            279098258,
            279105761,
            279109828,
            279083132,
            279080197,
            279089704
        ],
        "B": [
            279070569,
            279078207,
            279107778,
            279079153,
            279085265,
            279120271,
            279088210,
            279097026,
            279076070,
            279110876,
            279124102,
            279123495,
            279082667,
            279084060,
            279083489,
            279098074,
            279099366,
            279076888,
            279076970,
            279080147
        ],
        "A": [
            279068125,
            279068165,
            279106509,
            279068333,
            279073493,
            279112154,
            279077178,
            279083226,
            279068010,
            279081658,
            279079540,
            279073175,
            279071802,
            279068979,
            279070906,
            279069965,
            279068711,
            279069909,
            279068403
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133509",
    "editorial": "Firstly, since first operation can be used at most 1 time, we need to\r\nuse it only when string has odd length.Let\u00e2\u0080\u0099s assume that the string has\r\neven length, then we can look at characters on odd and even positions\r\nindependently. So, if we change all characters on even positions to the\r\ncharacter that which is occurs the most. Same goes to the characters on\r\nthe odd position.Now, we have case where we need to delete one\r\ncharacter. We can make prefix sum on even positions (let\u00e2\u0080\u0099s call number\r\nof on such even and ), prefix sum on odd position (let\u00e2\u0080\u0099s call it .\r\nDefinition same as for but with odd instead of even), suffix sum on even\r\npositions (let\u00e2\u0080\u0099s call it and definition same as but with instead of )\r\nand suffix sum on odd positions (let\u00e2\u0080\u0099s call it and definition same as\r\nbut with instead of ). If we delete character on index , our string\r\nafter shift right and changes parity for all indeces bigger then , so to\r\nfind how many characters there are on even positions after deleting\r\nindex is . Using this, we can try to delete each character independently\r\nand solve the task as it has even length.\r\n",
    "name": "E. Alternating String",
    "statement": "Sakurako really loves . She calls a string s of lowercase Latin letters\r\nan if characters in the even positions are the same, if characters in\r\nthe odd positions are the same, and the length of the string is .For\r\nexample, the strings \u201d and \u201d are , while the strings \u201d and \u201d are not.As\r\na good friend, you decided to gift such a string, but you couldn\u2019t find\r\none. Luckily, you can perform two types of operations on the string:\r\nChoose an index i and delete the i-th character from the string, which\r\nwill reduce the length of the string by 1. This type of operation can be\r\nperformed ; Choose an index i and replace s_i with any other letter.\r\nSince you are in a hurry, you need to determine the minimum number of\r\noperations required to make the string an one.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0namespace std {\u00a0template <int D, typename T>struct Vec : public vector<Vec<D - 1, T>> {    static_assert(D >= 1);    template <typename... Args>    Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}};\u00a0template <typename T>struct Vec<1, T> : public vector<T> {    Vec(int n = 0, T val = T()) : std::vector<T>(n, val) {}};\u00a0template <class Fun>class y_combinator_result {    Fun fun_;\u00a0   public:    template <class T>    explicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\u00a0    template <class... Args>    decltype(auto) operator()(Args &&...args) {        return fun_(std::ref(*this), std::forward<Args>(args)...);    }};\u00a0template <class Fun>decltype(auto) y_combinator(Fun &&fun) {    return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));}\u00a0}  // namespace std\u00a0class DSU {   public:    DSU(int n) {        prt.resize(n + 1, -1);    }\u00a0    int SZ(int u) {        return -prt[root(u)];    }\u00a0    int root(int u) {        return (prt[u] < 0 ? u : (prt[u] = root(prt[u])));    }\u00a0    bool connected(int u, int v) {        return ((u = root(u)) == (v = root(v)));    }\u00a0    bool unite(int u, int v) {        if ((u = root(u)) == (v = root(v))) {            return 0;        }\u00a0        if (prt[u] > prt[v]) {            u ^= v ^= u ^= v;        }\u00a0        prt[u] += prt[v];        prt[v] = u;        return 1;    }\u00a0   private:    vector<int> prt;};\u00a0int32_t main() {    ios_base::sync_with_stdio(0);    cin.tie(0);\u00a0    int t;    cin >> t;    while (t--) {        int n;        cin >> n;        string s;        cin >> s;        Vec<2, int> cnt(2, 26);        for (int i = 0; i < n; i++) cnt[i & 1][s[i] - 'a']++;        Vec<2, int> cur(2, 26);        int res = n + 1;        if (n & 1) {            for (int i = 0; i < n; i++) {                cur[i & 1][s[i] - 'a']++;                Vec<2, int> c(2, 26);                for (int j = 0; j < 26; j++) {                    c[0][j] = cur[0][j] + cnt[1][j] - cur[1][j];                    c[1][j] = cur[1][j] + cnt[0][j] - cur[0][j];                }                c[i & 1][s[i] - 'a']--;                vector<int> best(2);                for (int z = 0; z < 2; z++) {                    for (int j = 0; j < 26; j++) {                        best[z] = max(best[z], c[z][j]);                    }                }                res = min(res, n - best[0] - best[1]);            }        } else {            vector<int> best(2);            for (int z = 0; z < 2; z++) {                for (int j = 0; j < 26; j++) {                    best[z] = max(best[z], cnt[z][j]);                }            }            res = min(res, n - best[0] - best[1]);        }        cout << res << '\\n';    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Alternating String.json"
}