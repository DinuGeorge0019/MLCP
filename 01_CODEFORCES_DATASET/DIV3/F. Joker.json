{
    "link": "https://codeforces.com//contest/2051/problem/F",
    "problemId": "3099579",
    "problem_idx": "F",
    "shortId": "2051F",
    "contest_number": "2051",
    "problem_submissions": {
        "G": [
            297891656,
            297890696,
            297899138,
            297892259,
            297912620,
            297920714,
            297934708,
            297929892,
            297931851,
            297911736,
            297927208,
            297928317,
            297947772,
            297909767,
            297942983,
            297993500,
            297875875,
            297873133,
            297875271
        ],
        "F": [
            297856552,
            297878644,
            297873030,
            297875253,
            297891474,
            297895628,
            297891515,
            297904684,
            297959623,
            297914765,
            297882921,
            297895179,
            297910575,
            297923862,
            297919187,
            297917128,
            297916364,
            297943956,
            297865687,
            297864877,
            297909911
        ],
        "E": [
            297841786,
            297836575,
            297839584,
            297846936,
            297869096,
            297865734,
            297862813,
            297854892,
            297860094,
            297876823,
            297874225,
            297892538,
            297862291,
            297876371,
            297877246,
            297922331,
            297840776,
            297834266,
            297852254,
            297850894
        ],
        "D": [
            297824998,
            297828255,
            297829120,
            297836876,
            297843401,
            297839448,
            297844425,
            297835789,
            297837071,
            297862412,
            297866230,
            297845487,
            297868513,
            297862250,
            297899798,
            297831894,
            297830585,
            297845610,
            297833477
        ],
        "C": [
            297817405,
            297821512,
            297822005,
            297826169,
            297828699,
            297832899,
            297832376,
            297822832,
            297823992,
            297849370,
            297841820,
            297834151,
            297857822,
            297848820,
            297891200,
            297825348,
            297827127,
            297840542,
            297824191
        ],
        "B": [
            297813648,
            297815534,
            297817642,
            297818888,
            297819929,
            297820049,
            297826062,
            297814904,
            297817786,
            297837190,
            297825933,
            297817655,
            297849719,
            297836185,
            297885765,
            297815546,
            297824155,
            297835551,
            297813164
        ],
        "A": [
            297812430,
            297812527,
            297814260,
            297815468,
            297814137,
            297814651,
            297817327,
            297812582,
            297812492,
            297830581,
            297819762,
            297812887,
            297821437,
            297881803,
            297812726,
            297821513,
            297830979,
            297812442
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137623",
    "editorial": "Letâs represent the positions where the joker can be as a set of\r\nnon-overlapping segments , , .... Letâs consider what happens to the\r\nsegment after applying the -th operation: if , the possible positions\r\nsegment becomes (since moving the -th card to the front does not change\r\nthe jokerâs positions, while moving it to the back shifts the positions\r\nup by ); if , the possible positions segment becomes (since moving the\r\n-th card to the front shifts the positions down by , while moving it to\r\nthe back does not change the jokerâs positions); if , letâs consider\r\nsubsegments where the joker can be located: positions from the\r\nsubsegment moves to (similarly to the case ); positions from the\r\nsubsegment moves to (similarly to the case ); the joker from position\r\nmoves to one of two positions: or . Thus, in this case, the segment\r\nremains, but we need to add two new segments ( and ) to the set. Note\r\nthat when , the current segment disappears.At first glance, it seems\r\nthat this solution works in , since the number of segments can be , and\r\nwe need to update each of them. However, it is not difficult to notice\r\nthat there cannot be more than segments. Specifically: the initial\r\nsegment , which expands to the left and right, the segment , which\r\nexpands only to the right, and the segment , which expands only to the\r\nleft.\r\n",
    "name": "F. Joker",
    "statement": "Consider a deck of n cards. The positions in the deck are numbered from\r\n1 to n from top to bottom. A joker is located at position m.q operations\r\nare applied sequentially to the deck. During the i-th operation, you\r\nneed to take the card at position a_i and move it either to the\r\nbeginning or to the end of the deck. For example, if the deck is [2, 1,\r\n3, 5, 4], and a_i=2, then after the operation the deck will be either\r\n[1, 2, 3, 5, 4] (the card from the second position moved to the\r\nbeginning) or [2, 3, 5, 4, 1] (the card from the second position moved\r\nto the end).Your task is to calculate the number of distinct positions\r\nwhere the joker can be after each operation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ll long longusing namespace std;  static vector<pair<ll,ll>> solve(vector<pair<ll,ll>> &arr) {   vector<pair<ll,ll>> ans;   ans.reserve(arr.size());   for (auto &iv : arr) {       if (ans.empty() || ans.back().second < iv.first - 1) {           ans.push_back(iv);       } else {           ans.back().second = max(ans.back().second, iv.second);       }   }   return ans;} int main(){   ios::sync_with_stdio(false);   cin.tie(nullptr);    int t;   cin >> t;   while(t--){       ll n, m;       int q;       cin >> n >> m >> q;        vector<pair<ll,ll>> arr;       arr.push_back({m,m});        while(q--){           ll a;           cin >> a;            vector<pair<ll,ll>> res;           res.reserve(arr.size()*2 + 2);            for (auto &iv : arr) {               ll l = iv.first, r = iv.second;               if (r < a) {                   res.push_back({l, r});                    ll l2 = l+1, r2 = r+1;                   if (r2 >= 1 && l2 <= n) {                       l2 = max(l2, 1LL);                       r2 = min(r2, n);                       if (l2 <= r2) {                           res.push_back({l2,r2});                       }                   }               }               else if (l > a) {                   res.push_back({l,r});                    ll l2 = l-1, r2 = r-1;                   if (r2 >= 1 && l2 <= n) {                       l2 = max(l2, 1LL);                       r2 = min(r2, n);                       if (l2 <= r2) {                           res.push_back({l2,r2});                       }                   }               }               else {                   if (l <= a-1) {                       ll lsub = l, rsub = a-1;                       res.push_back({lsub, rsub});                       ll l2 = lsub+1, r2 = rsub+1;                       if (l2<=r2 && l2<=n && r2>=1) {                           l2 = max(l2,1LL);                           r2 = min(r2,n);                           if (l2<=r2) {                               res.push_back({l2,r2});                           }                       }                   }                    if (l <= a && a <= r) {                       res.push_back({1,1});                       res.push_back({n,n});                   }                    if (a+1 <= r) {                       ll ls = a+1;                       ll rs = r;                       res.push_back({ls, rs});                       ll l2 = ls-1, r2 = rs-1;                       if (l2<=r2 && l2>=1 && r2<=n) {                           res.push_back({l2,r2});                       }                   }               }           }            sort(res.begin(), res.end());           arr = solve(res);            ll ans = 0;            for (auto &iv : arr) {               ans += (iv.second - iv.first + 1);           }            cout << ans << \" \";       }       cout << \"\\n\";   }    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Joker.json",
    "hint": []
}