{
    "link": "https://codeforces.com//contest/1941/problem/B",
    "problemId": "2523368",
    "problem_idx": "B",
    "shortId": "1941B",
    "contest_number": "1941",
    "problem_submissions": {
        "G": [
            250763025,
            250781286,
            250779945,
            250787489,
            250800958,
            250794874,
            250801570,
            250797693,
            250776624,
            250793138,
            250784955,
            250769475,
            250695343,
            250808638,
            250806485,
            250793977,
            250708131
        ],
        "F": [
            250740820,
            250744438,
            250753388,
            250758018,
            250759651,
            250771923,
            250771468,
            250735055,
            250753949,
            250769805,
            250766080,
            250789658,
            250717637,
            250786906,
            250776029,
            250768573,
            250744006
        ],
        "E": [
            250723876,
            250724169,
            250717230,
            250735746,
            250736815,
            250736521,
            250739262,
            250774240,
            250729758,
            250726588,
            250755686,
            250741893,
            250738588,
            250765034,
            250731744,
            250805659,
            250779683
        ],
        "D": [
            250690549,
            250702231,
            250695593,
            250704272,
            250717031,
            250703063,
            250703013,
            250692270,
            250695895,
            250691168,
            250734836,
            250707874,
            250759962,
            250722745,
            250703516,
            250708254,
            250785215
        ],
        "C": [
            250674251,
            250679685,
            250671012,
            250679783,
            250680400,
            250684218,
            250682169,
            250667218,
            250675740,
            250676966,
            250670249,
            250691797,
            250745426,
            250686871,
            250672532,
            250677895,
            250750876
        ],
        "B": [
            250664239,
            250668411,
            250660791,
            250663325,
            250694386,
            250668961,
            250666921,
            250657383,
            250663605,
            250664885,
            250657026,
            250681860,
            250751771,
            250667298,
            250743798,
            250661438,
            250747374
        ],
        "A": [
            250649602,
            250652993,
            250650152,
            250651488,
            250656171,
            250653697,
            250656300,
            250649271,
            250654624,
            250658642,
            250648031,
            250654646,
            250754293,
            250652956,
            250649094,
            250648520,
            250712266
        ]
    },
    "name": "B. Rudolf and 121",
    "statement": "Rudolf has an array a of n integers, the elements are numbered from 1 to\r\nn.In one operation, he can choose an index i (2\r\nle i\r\nle n - 1) and assign: a_{i - 1} = a_{i - 1} - 1 a_i = a_i - 2 a_{i + 1}\r\n= a_{i + 1} - 1 Rudolf can apply this operation any number of times. Any\r\nindex i can be used zero or more times.Can he make all the elements of\r\nthe array equal to zero using this operation?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<\"YES\\n\"\n#define NO cout << \"NO\\n\"\n#define debug cout << \"Here Fine\" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n ; cin >> n ;\n    int a[ n ] ;\n    FOR( i , n ) cin >> a[ i ] ;\n    for( int i = 0 ; i < n - 2 ; i ++ ){\n    \tif( a[ i ] >= 0 ){\n    \t\ta[ i + 1 ] = ( a[ i + 1 ] - 2 * a[ i ] ) ;\n    \t\ta[ i + 2 ] = a[ i + 2 ] - a[ i ] ;\n    \t\ta[ i ] = 0 ;\n\t\t}\n\t\telse{\n\t\t\tNO ; return ;\n\t\t}\n\t}\n\tif( a[ n - 1 ] == a[ n - 2 ] && a[ n - 1 ] == 0 ){\n\t\tYES ; \n\t} else NO ; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Rudolf and 121.json",
    "editorial_link": "https://codeforces.com//blog/entry/127018",
    "editorial": "Let\u00e2\u0080\u0099s consider the minimum such that . Making this element zero is only\r\npossible by choosing the -th element for the operation (applying the\r\noperation to a more leftward element is either impossible or will make\r\nsome elements less than zero). We will apply operations in this way\r\nuntil we reach the end of the array. If there are non-zero elements left\r\nafter applying the operations, the answer is \"\".\r\n"
}