{"link": "https://codeforces.com//contest/1328/problem/B", "problemId": "573968", "problem_idx": "B", "shortId": "1328B", "contest_number": "1328", "problem_submissions": {"F": [74521514, 74458947, 74467934, 74459743, 74477945, 74479296, 74477976, 74460067, 74479401, 74451936, 74481411, 74517274, 74469162, 74751835, 74484053, 74570676, 75069905], "E": [74521498, 74425897, 74448868, 74469722, 74453344, 74450430, 74451583, 74481242, 74461079, 74480712, 74461492, 74440509, 74433950, 74453485, 74450187, 74455849, 74458845, 74470218, 74462427, 74456809], "D": [74521470, 74418087, 74432049, 74443528, 74433824, 74440013, 74434934, 74442956, 74448606, 74468894, 74434326, 74418253, 74446884, 74422378, 74433135, 74445359, 74444092, 74446810, 74436674, 74439681, 74436955], "C": [74521449, 74427519, 74417294, 74412670, 74418245, 74414924, 74418343, 74430971, 74433882, 74427388, 74419673, 74411543, 74408681, 74418088, 74421292, 74418723, 74414986, 74421425, 74419827, 74417279, 74426221], "B": [74521428, 74410739, 74410669, 74414505, 74408929, 74424040, 74412257, 74445705, 74430405, 74422019, 74402783, 74408301, 74420620, 74406341, 74415300, 74411825, 74407115, 74413788, 74409526, 74409821, 74428748], "A": [74521413, 74399723, 74400111, 74400161, 74407479, 74400948, 74397437, 74397606, 74401496, 74400048, 74407625, 74397552, 74398246, 74403424, 74403420, 74398403, 74402962, 74402324, 74397768, 74400852, 74397419, 74399350, 74399074]}, "name": "B. K-th Beautiful String", "statement": "For the given integer n (n > 2) let\u2019s write down all the strings of\r\nlength n which contain n-2 letters \u201d and two letters \u201d in (alphabetical)\r\norder.Recall that the string s of length n is lexicographically less\r\nthan string t of length n, if there exists such i (1\r\nle i\r\nle n), that s_i < t_i, and for any j (1\r\nle j < i) s_j = t_j. The lexicographic comparison of strings is\r\nimplemented by the operator in modern programming languages.For example,\r\nif n=5 the strings are (the order does matter): It is easy to show that\r\nsuch a list of strings will contain exactly\r\nfrac{n\r\ncdot (n-1)}{2} strings.You are given n (n > 2) and k (1\r\nle k\r\nle\r\nfrac{n\r\ncdot (n-1)}{2}). Print the k-th string from the list.\r\n", "solutions": ["// clang-format off\n// powered by c++11\n// by Isaunoya\n#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i=(x);i<=(y);++i)\n#define Rep(i,x,y) for(register int i=(x);i>=(y);--i)\nusing namespace std;using db=double;using ll=long long;\nusing uint=unsigned int;using ull=unsigned long long;\nusing pii=pair<int,int>;\n#define Tp template\n#define fir first\n#define sec second\nTp<class T>void cmax(T&x,const T&y){if(x<y)x=y;}Tp<class T>void cmin(T&x,const T&y){if(x>y)x=y;}\n#define all(v) v.begin(),v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\nTp<class T>void sort(vector<T>&v){sort(all(v));}Tp<class T>void reverse(vector<T>&v){reverse(all(v));}\nTp<class T>void unique(vector<T>&v){sort(all(v)),v.erase(unique(all(v)),v.end());}inline void reverse(string&s){reverse(s.begin(),s.end());}\nconst int SZ=1<<23|233;\nstruct FILEIN{char qwq[SZ],*S=qwq,*T=qwq,ch;\n#ifdef __WIN64\n#define GETC getchar\n#else\ninline char GETC(){return(S==T)&&(T=(S=qwq)+fread(qwq,1,SZ,stdin),S==T)?EOF:*S++;}\n#endif\ninline FILEIN&operator>>(char&c){while(isspace(c=GETC()));return*this;}inline FILEIN&operator>>(string&s){s.clear();while(isspace(ch=GETC()));if(!~ch)return*this;s=ch;while(!isspace(ch=GETC())&&~ch)s+=ch;return*this;}\ninline FILEIN&operator>>(char*str){char*cur=str;while(*cur)*cur++=0;cur=str;while(isspace(ch=GETC()));if(!~ch)return*this;*cur=ch;while(!isspace(ch=GETC())&&~ch)*++cur=ch;*++cur=0;return*this;}\nTp<class T>inline void read(T&x){bool f=0;while((ch=GETC())<48&&~ch)f^=(ch==45);x=~ch?(ch^48):0;while((ch=GETC())>47)x=x*10+(ch^48);x=f?-x:x;}\ninline FILEIN&operator>>(int&x){return read(x),*this;}inline FILEIN&operator>>(ll&x){return read(x),*this;}inline FILEIN&operator>>(uint&x){return read(x),*this;}inline FILEIN&operator>>(ull&x){return read(x),*this;}\ninline FILEIN&operator>>(double&x){read(x);bool f=x<0;x=f?-x:x;if(ch^'.')return*this;double d=0.1;while((ch=GETC())>47)x+=d*(ch^48),d*=.1;return x=f?-x:x,*this;}\n}in;\nstruct FILEOUT{const static int LIMIT=1<<22;char quq[SZ],ST[233];int sz,O,pw[233];\nFILEOUT(){set(7);rep(i,pw[0]=1,9)pw[i]=pw[i-1]*10;}~FILEOUT(){flush();}\ninline void flush(){fwrite(quq,1,O,stdout),fflush(stdout),O=0;}\ninline FILEOUT&operator<<(char c){return quq[O++]=c,*this;}inline FILEOUT&operator<<(string str){if(O>LIMIT)flush();for(char c:str)quq[O++]=c;return*this;}\ninline FILEOUT&operator<<(char*str){if(O>LIMIT)flush();char*cur=str;while(*cur)quq[O++]=(*cur++);return*this;}\nTp<class T>void write(T x){if(O>LIMIT)flush();if(x<0){quq[O++]=45;x=-x;}do{ST[++sz]=x%10^48;x/=10;}while(x);while(sz)quq[O++]=ST[sz--];}\ninline FILEOUT&operator<<(int x){return write(x),*this;}inline FILEOUT&operator<<(ll x){return write(x),*this;}inline FILEOUT&operator<<(uint x){return write(x),*this;}inline FILEOUT&operator<<(ull x){return write(x),*this;}\nint len,lft,rig;void set(int l){len=l;}inline FILEOUT&operator<<(double x){bool f=x<0;x=f?-x:x,lft=x,rig=1.*(x-lft)*pw[len];return write(f?-lft:lft),quq[O++]='.',write(rig),*this;}\n}out;\n#define int long long\nstruct Math{\nvector<int>fac,inv;int mod;\nvoid set(int n,int Mod){fac.resize(n+1),inv.resize(n+1),mod=Mod;rep(i,fac[0]=1,n)fac[i]=fac[i-1]*i%mod;inv[n]=qpow(fac[n],mod-2);Rep(i,n-1,0)inv[i]=inv[i+1]*(i+1)%mod;}\nint qpow(int x,int y){int ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}int C(int n,int m){if(n<0||m<0||n<m)return 0;return fac[n]*inv[m]%mod*inv[n-m]%mod;}\nint gcd(int x,int y){return!y?x:gcd(y,x%y);}int lcm(int x,int y){return x*y/gcd(x,y);}\n}math;\n// clang-format on\nsigned main(){\n\t//code begin.\n\tint _;\n\tin >> _;\n\twhile(_ --) {\n\t\tint n , k;\n\t\tin >> n >> k;\n\t\tk --;\n\t\tint pos1 = n - 2, pos2 = n - 1, cnt = 1;\n\t\twhile(k) {\n\t\t\tif(k < cnt) {\n\t\t\t\tpos2 -= k;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\tpos1 --;\n\t\t\tk -= cnt;\n\t\t\tcnt ++;\n\t\t}\n\t\trep(i , 0 , n - 1) {\n\t\t\tif(i == pos1 || i == pos2) {\n\t\t\t\tout << 'b' ;\n\t\t\t}\n\t\t\telse \n\t\t\t\tout << 'a' ;\n\t\t}\n\t\tout << '\\n';\n\t}\n\treturn 0;\n\t//code end.\n}\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "combinatorics", "implementation", "math"], "dificulty": "1300", "interactive": false}