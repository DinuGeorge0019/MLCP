{
    "link": "https://codeforces.com//contest/1272/problem/F",
    "problemId": "494358",
    "problem_idx": "F",
    "shortId": "1272F",
    "contest_number": "1272",
    "problem_submissions": {
        "E": [
            66703677,
            66698934,
            66711392,
            66720411,
            66715254,
            66696959,
            66695532,
            66698121,
            66701928,
            66701435,
            66706283,
            66705342,
            66707569,
            66707090,
            66777425,
            66705785,
            66709630,
            66710595,
            66706360,
            66711695
        ],
        "F": [
            66702563,
            66716210,
            66716034,
            66713486,
            66720407,
            66730946,
            66745196,
            66899419,
            66710448,
            69815932
        ],
        "B": [
            66692863,
            66686159,
            66691774,
            66706884,
            66714297,
            66683965,
            66685196,
            66684562,
            66686916,
            66692480,
            66696683,
            66688751,
            66692889,
            66696315,
            66685266,
            66695654,
            66691545,
            66689056,
            66687119,
            66686340
        ],
        "C": [
            66687313,
            66688012,
            66695426,
            66689433,
            66689685,
            66685389,
            66686891,
            66686385,
            66687940,
            66685597,
            66690881,
            66692609,
            66686241,
            66688395,
            66686850,
            66686864,
            66686923,
            66691687,
            66689532,
            66689140
        ],
        "D": [
            66683330,
            66692291,
            66701690,
            66697025,
            66695475,
            66689729,
            66689439,
            66688995,
            66691097,
            66696361,
            66685375,
            66696190,
            66695912,
            66691534,
            66688277,
            66700728,
            66696238,
            66694893,
            66695943,
            66703253
        ],
        "A": [
            66683267,
            66683040,
            66685123,
            66683649,
            66682741,
            66682439,
            66682629,
            66682714,
            66683716,
            66683148,
            66683049,
            66683308,
            66683216,
            66682971,
            66682692,
            66683012,
            66683163,
            66683636,
            66683990,
            66682789
        ]
    },
    "name": "F. Two Bracket Sequences",
    "statement": "You are given two bracket sequences (not necessarily regular) s and t\r\nconsisting only of characters ” and ”. You want to construct the\r\nshortest bracket sequence that contains both given bracket sequences as\r\n(not necessarily contiguous).Recall what is the regular bracket\r\nsequence: is the regular bracket sequence; if S is the regular bracket\r\nsequence, then is a regular bracket sequence; if S and T regular bracket\r\nsequences, then ST (concatenation of S and T) is a regular bracket\r\nsequence. Recall that the subsequence of the string s is such string t\r\nthat can be obtained from s by removing some (possibly, zero) amount of\r\ncharacters. For example, \"\", \"\", \"\" and \"\" are subsequences of \"\", but\r\n\"\" and \"\" are not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\ntypedef pair<int, int> II;\n\nconst int N = 401;\n\nint len, n, m;\nint f[N][N][201];\nII trace[N][N][201];\nstring a, b;\n\nbool maximize(int &x, const int &y) {\n    if (x < y) x = y; else return false; return true;\n}\n\nvoid Trace(int id, int sum, int posa) {\n    if (!id) return;\n    int cur = trace[id][sum][posa].X;\n    int newsum = sum - trace[id][sum][posa].X;\n    int newposa = trace[id][sum][posa].Y;\n    Trace(id - 1, newsum, newposa);\n    if (cur == -1) putchar(')');\n    else putchar('(');\n}\n\nint main() {\n    cin >> a >> b;\n    n = a.length(); m = b.length();\n    a = \" \" + a; b = \" \" + b;\n    len = max(n, m) * 2;\n    memset(f, -1, sizeof(f));\n    f[0][0][0] = 0;\n    for (int i = 0; i < len; i++)\n        for (int sum = 0; sum <= len; sum++)\n            for (int posa = 0; posa <= n; posa++) if (f[i][sum][posa] != -1) {\n                if (sum - 1 >= 0) {\n                    int nexta = posa, nextb = f[i][sum][posa];\n                    if (posa < n)\n                        nexta = posa + (a[posa + 1] == ')');\n                    if (nextb < m)\n                        nextb += (b[nextb + 1] == ')');\n                    if (maximize(f[i + 1][sum - 1][nexta], nextb))\n                        trace[i + 1][sum - 1][nexta] = {-1, posa};\n                }\n                if (sum + 1 <= len) {\n                    int nexta = posa, nextb = f[i][sum][posa];\n                    if (posa < n)\n                        nexta = posa + (a[posa + 1] == '(');\n                    if (nextb < m)\n                        nextb += (b[nextb + 1] == '(');\n                    if (maximize(f[i + 1][sum + 1][nexta], nextb))\n                        trace[i + 1][sum + 1][nexta] = {1, posa};\n                }\n            }\n    int res = 0;\n    for (int i = 1; i <= len; i++)\n        if (f[i][0][n] == m) {\n            res = i;\n            break;\n        }\n    Trace(res, 0, n);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Two Bracket Sequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/72132",
    "editorial": "Firstly, notice that the length of the answer cannot exceed ( copies of\r\n). Now we can do some kind of simple dynamic programming. Let be the\r\nminimum possible length of the prefix of the regular bracket sequence if\r\nwe are processed first characters of the first sequence, first\r\ncharacters of the second sequence and the current balance is . Each\r\ndimension of this dp should have a size nearby .The base of this dp is ,\r\nall other values .Transitions are very easy: if we want to place the\r\nopening bracket, then we increase if the -th character of exists and\r\nequals â, the same with the second sequence and , the balance increases\r\nby one, and the length of the answer increases by one. If we want to\r\nplace the closing bracket, then we increase if the -th character of\r\nexists and equals â, the same with the second sequence and , the balance\r\ndecreases by one, and the length of the answer increases by one. .Donât\r\nforget to maintain parents in this dp to restore the actual answer!The\r\nlast problem that can be unresolved is how to write this dp? The easiest\r\nway is bfs, because every single transition increases our answer by one.\r\nThen we can restore answer from the state . You can write it\r\nrecursively, but I donât sure this will look good. And you also can\r\nwrite it just with nested loops, if you are careful enough.Time\r\ncomplexity: .If you know the faster solution, please share it!\r\n",
    "hint": []
}