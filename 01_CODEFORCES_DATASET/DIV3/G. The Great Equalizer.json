{
    "link": "https://codeforces.com//contest/1862/problem/G",
    "problemId": "2177634",
    "problem_idx": "G",
    "shortId": "1862G",
    "contest_number": "1862",
    "problem_submissions": {
        "G": [
            220245102,
            220236543,
            220240013,
            220263299,
            220256468,
            220270554,
            220407258,
            220261631,
            220276606,
            220277103,
            220277190,
            220265753,
            220272660,
            220272436,
            220276900,
            220270769,
            220279446,
            220270577,
            231887590,
            231887524,
            220377896,
            220376221,
            220375779,
            220287433,
            220285498,
            220284820,
            220274652,
            220267069,
            220285570,
            220280519
        ],
        "F": [
            220215510,
            220216380,
            220236628,
            220232754,
            220218803,
            220240895,
            220413869,
            220185778,
            220211559,
            220227122,
            220238991,
            220245238,
            220240906,
            220232310,
            220229370,
            220239430,
            220225756,
            220376173,
            220375742,
            220254210,
            220257832,
            220278068,
            220235150,
            220248305
        ],
        "E": [
            220203349,
            220208394,
            220220906,
            220202478,
            220220225,
            220336313,
            220335362,
            220227807,
            220202526,
            220238570,
            220214495,
            220229819,
            220221341,
            220220787,
            220218825,
            220224809,
            220217905,
            220376137,
            220375723,
            220232333,
            220250361,
            220231462,
            220220168,
            220236903
        ],
        "D": [
            220195280,
            220198509,
            220201838,
            220231248,
            220200432,
            220241039,
            220234728,
            220202010,
            220203000,
            220194405,
            220199267,
            220204119,
            220204397,
            220206486,
            220195334,
            220376096,
            220375678,
            220208148,
            220202416,
            220211386,
            220246850,
            220227240
        ],
        "C": [
            220183784,
            220178645,
            220194540,
            220223628,
            220184508,
            220217723,
            220185864,
            220183520,
            220194697,
            220216625,
            220191457,
            220187641,
            220185690,
            220198120,
            220201973,
            220376069,
            220375636,
            220182400,
            220182197,
            220187829,
            220185247,
            220218838
        ],
        "B": [
            220167869,
            220167779,
            220178691,
            220167799,
            220173120,
            220182282,
            220173679,
            220176676,
            220171769,
            220166010,
            220172585,
            220173029,
            220174605,
            220188618,
            220177089,
            220376035,
            220375602,
            220169392,
            220168222,
            220172418,
            220166374,
            220169270
        ],
        "A": [
            220162754,
            220162873,
            220166418,
            220162920,
            220167317,
            220165780,
            220168509,
            220165279,
            220163854,
            220162403,
            220163593,
            220166211,
            220165725,
            220172465,
            220175478,
            220376004,
            220375492,
            220163511,
            220162520,
            220166452,
            220197468,
            220163355
        ]
    },
    "name": "G. The Great Equalizer",
    "statement": "Tema bought an old device with a small screen and a worn-out inscription\r\n\"The Great Equalizer\" on the side.The seller said that the device needs\r\nto be given an array a of integers as input, after which \"The Great\r\nEqualizer\" will work as follows: Sort the current array in\r\nnon-decreasing order and remove duplicate elements leaving only one\r\noccurrence of each element. If the current length of the array is equal\r\nto 1, the device stops working and outputs the single number in the\r\narray output value of the device. Add an arithmetic progression {n,\r\nn - 1,\r\nn - 2,\r\nldots,\r\n1} to the current array, where n is the length of the current array. In\r\nother words, n - i is added to the i-th element of the array, when\r\nindexed from zero. Go to the first step. To test the operation of the\r\ndevice, Tema came up with a certain array of integers a, and then wanted\r\nto perform q operations on the array a of the following type: Assign the\r\nvalue x (1\r\nle x\r\nle 10^9) to the element a_i (1\r\nle i\r\nle n). Give the array a as input to the device and find out the result\r\nof the device\u2019s operation, . Help Tema find out the output values of the\r\ndevice after each operation.\r\n",
    "solutions": [
        "/*  \n  hmz is cute!\n--------------------------------------------\n  You've got to have faith\n  Don't let them cut you down cut you down once more\n*/\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY int\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e9)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<'0'||op>'9';op=getchar())if(op=='-')f=-1;\n\tfor(;op>='0'&&op<='9';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>='a'&&op<='z')return true;\n\tif(op>='A'&&op<='Z')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op=\"\";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar('0');return;}\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+'0');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,m,a[MAXN];\nmultiset<TY> s,num;\nIL void insert(TY now){\n\tmultiset<TY>::iterator itl=num.lower_bound(now),itr=num.upper_bound(now);\n\tTY A=-1,B=-1;\n\tif(itl!=num.begin()){\n\t\t--itl;A=*itl;\n\t\ts.insert(now-A);\n\t}if(itr!=num.end()){\n\t\tB=*itr;\n\t\ts.insert(B-now);\n\t}if(A!=-1&&B!=-1)s.erase(s.find(B-A));\n}IL void erase(TY now){\n\tmultiset<TY>::iterator itl=num.lower_bound(now),itr=num.upper_bound(now);\n\tTY A=-1,B=-1;\n\tif(itl!=num.begin()){\n\t\t--itl;A=*itl;\n\t\ts.erase(s.find(now-A));\n\t}if(itr!=num.end()){\n\t\tB=*itr;\n\t\ts.erase(s.find(B-now));\n\t}if(A!=-1&&B!=-1)s.insert(B-A);\n}IL void Insert(TY now){if(num.find(now)==num.end())insert(now);num.insert(now);}\nIL void Erase(TY now){num.erase(num.find(now));if(num.find(now)==num.end())erase(now);}\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tn=qr();For(i,1,n)a[i]=qr(),Insert(a[i]);\n\t\tm=qr();For(i,1,m){\n\t\t\tTY u=qr(),v=qr();\n\t\t\tErase(a[u]);a[u]=v;\n\t\t\tInsert(a[u]);\n\t\t\tqw(*--num.end()+(s.empty()?0:*--s.end()),' ');\n\t\t}putchar('\\n');\n\t\ts.clear();num.clear();\n\t}\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "math",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. The Great Equalizer.json",
    "editorial_link": "https://codeforces.com//blog/entry/119715",
    "editorial": "Let\u00e2\u0080\u0099s take a look at the maximum difference between adjacent numbers in\r\na sorted sequence. Each cycle it decreases by . This helps us understand\r\nthe main observation: the answer for the sequence is the maximum number\r\nin it + the maximum difference between adjacent numbers in sorted\r\norder.To answer queries, it is sufficient to maintain these two\r\nvalues.To maintain the maximum number, we will store the numbers in\r\nstd::multiset. And to maintain the maximum difference, we will maintain\r\nstd::multiset of differences. When replacing a number, we will remove\r\nthe old number and replace the difference between it and its neighbors\r\nwith the difference between the neighbors. Then we will add the new\r\nnumber and replace the difference between its neighbors with the\r\ndifference between the added number and each of the neighbors.All of\r\nthis is implemented through working with std::multiset, which you can\r\nsee, for example, in the author\u00e2\u0080\u0099s solution.\r\n"
}