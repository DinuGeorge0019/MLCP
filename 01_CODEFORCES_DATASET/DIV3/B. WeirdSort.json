{
    "link": "https://codeforces.com//contest/1311/problem/B",
    "problemId": "547477",
    "problem_idx": "B",
    "shortId": "1311B",
    "contest_number": "1311",
    "problem_submissions": {
        "E": [
            71808916,
            71808599,
            93123368,
            71844658,
            71866557,
            71838628,
            71799873
        ],
        "F": [
            71796868,
            71806217,
            71793472,
            71796876,
            71799840,
            71794628,
            71797683,
            71798778,
            71801869,
            71798514,
            71800897,
            71799483,
            71790429,
            71801970,
            71792412,
            71808363,
            71786195,
            71809262,
            71804250,
            71795148,
            71802574
        ],
        "D": [
            71789526,
            71792384,
            71787369,
            71788637,
            71807660,
            71784383,
            71788643,
            71785457,
            71791043,
            71788249,
            71788689,
            71786913,
            71784594,
            71790030,
            71782423,
            71790272,
            71801279,
            71813581,
            71789490,
            71790803,
            71785471,
            71796175
        ],
        "C": [
            71780601,
            71787244,
            71778720,
            71777956,
            71779055,
            71778652,
            71779823,
            71780370,
            71778687,
            71783497,
            71778399,
            71780701,
            71778150,
            71779429,
            71783732,
            71786917,
            71780561,
            71786514,
            71779237,
            71783097
        ],
        "B": [
            71777211,
            71782922,
            71775982,
            71774247,
            71774556,
            71775523,
            71776728,
            71774631,
            71774172,
            71777830,
            71773973,
            71777033,
            71796675,
            71772169,
            71780446,
            71783294,
            71775698,
            71782264,
            71797768,
            71775685
        ],
        "A": [
            71772411,
            71773163,
            71770634,
            71770076,
            71770517,
            71771510,
            71769980,
            71769842,
            71770112,
            71771016,
            71769997,
            71771281,
            71773789,
            71770312,
            71772059,
            71777686,
            71771553,
            71771635,
            71774048,
            71770666
        ]
    },
    "name": "B. WeirdSort",
    "statement": "You are given an array a of length n.You are also given a set of\r\npositions p_1, p_2,\r\ndots, p_m, where 1\r\nle p_i < n. The position p_i means that you can swap elements a[p_i] and\r\na[p_i + 1]. You can apply this operation any number of times for each of\r\nthe given .Your task is to determine if it is possible to sort the\r\ninitial array in non-decreasing order (a_1\r\nle a_2\r\nle\r\ndots\r\nle a_n) using only allowed swaps.For example, if a = [3, 2, 1] and p =\r\n[1, 2], then we can first swap elements a[2] and a[3] (because position\r\n2 is contained in the given set p). We get the array a = [3, 1, 2]. Then\r\nwe swap a[1] and a[2] (position 1 is also contained in p). We get the\r\narray a = [1, 3, 2]. Finally, we swap a[2] and a[3] again and get the\r\narray a = [1, 2, 3], sorted in non-decreasing order.You can see that if\r\na = [4, 1, 2, 3] and p = [3, 2] then you cannot sort the array.You have\r\nto answer t independent test cases.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint a[105],p[105];\nint main()\n{\n    int t,n,m,pp;\n    bool f;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=1;i<=m;i++)\n            scanf(\"%d\",&p[i]);\n        sort(p+1,p+m+1);\n        pp=1;\n        for(int i=2;i<=m;i++)\n            if(p[i]!=p[i-1]+1)\n            {\n                sort(a+p[pp],a+p[i-1]+2);\n                pp=i;\n            }\n        sort(a+p[pp],a+p[m]+2);\n        f=false;\n        for(int i=1;i<=n;i++)\n            if(a[i]<a[i-1])\n            {\n                f=true;\n                break;\n            }\n        if(f)\n            printf(\"NO\\n\");\n        else printf(\"YES\\n\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "sortings"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. WeirdSort.json",
    "editorial_link": "https://codeforces.com//blog/entry/74224",
    "editorial": "The simple simulation works here: while there is at least one inversion\r\n(such a pair of indices and that ) we can fix, let\u00e2\u0080\u0099s fix it (we can fix\r\nthis inversion if ). If there are inversions but we cannot fix any of\r\nthem, the answer is \"\". Otherwise, the answer is \"\".There is also a\r\nsolution: it is obvious that we have some segments in which we can\r\nchange the order of elements as we want. And it is also obvious that we\r\ncannot move elements between these \"allowed\" segments. So, each of them\r\nis independent of each other. We can just find all these segments of\r\nindices using two pointers and sort them independently. Then we just\r\nneed to check if the array becomes sorted.Time complexity is or .\r\n"
}