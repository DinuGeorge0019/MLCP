{
    "link": "https://codeforces.com//contest/2051/problem/E",
    "problemId": "3099578",
    "problem_idx": "E",
    "shortId": "2051E",
    "contest_number": "2051",
    "problem_submissions": {
        "G": [
            297891656,
            297890696,
            297899138,
            297892259,
            297912620,
            297920714,
            297934708,
            297929892,
            297931851,
            297911736,
            297927208,
            297928317,
            297947772,
            297909767,
            297942983,
            297993500,
            297875875,
            297873133,
            297875271
        ],
        "F": [
            297856552,
            297878644,
            297873030,
            297875253,
            297891474,
            297895628,
            297891515,
            297904684,
            297959623,
            297914765,
            297882921,
            297895179,
            297910575,
            297923862,
            297919187,
            297917128,
            297916364,
            297943956,
            297865687,
            297864877,
            297909911
        ],
        "E": [
            297841786,
            297836575,
            297839584,
            297846936,
            297869096,
            297865734,
            297862813,
            297854892,
            297860094,
            297876823,
            297874225,
            297892538,
            297862291,
            297876371,
            297877246,
            297922331,
            297840776,
            297834266,
            297852254,
            297850894
        ],
        "D": [
            297824998,
            297828255,
            297829120,
            297836876,
            297843401,
            297839448,
            297844425,
            297835789,
            297837071,
            297862412,
            297866230,
            297845487,
            297868513,
            297862250,
            297899798,
            297831894,
            297830585,
            297845610,
            297833477
        ],
        "C": [
            297817405,
            297821512,
            297822005,
            297826169,
            297828699,
            297832899,
            297832376,
            297822832,
            297823992,
            297849370,
            297841820,
            297834151,
            297857822,
            297848820,
            297891200,
            297825348,
            297827127,
            297840542,
            297824191
        ],
        "B": [
            297813648,
            297815534,
            297817642,
            297818888,
            297819929,
            297820049,
            297826062,
            297814904,
            297817786,
            297837190,
            297825933,
            297817655,
            297849719,
            297836185,
            297885765,
            297815546,
            297824155,
            297835551,
            297813164
        ],
        "A": [
            297812430,
            297812527,
            297814260,
            297815468,
            297814137,
            297814651,
            297817327,
            297812582,
            297812492,
            297830581,
            297819762,
            297812887,
            297821437,
            297881803,
            297812726,
            297821513,
            297830979,
            297812442
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137623",
    "editorial": "First, letâs design a solution in . We can solve the problem in , if we\r\niterate on the price we use, and for every price, calculate the number\r\nof trees bought and the number of negative reviews. However, we donât\r\nneed to check every possible price from to : letâs instead check every\r\ninteger in the union of and (or check every , and then check every ).Why\r\nis it always optimal? Suppose some integer price which is not present in\r\nthe union of and is optimal. Then, if we use instead of , the status of\r\neach customer will be the same, but we will get more money for each tree\r\nwe sell. So, it is enough to check the elements of and the elements of\r\nas possible prices. This works in , we need to speed it up. I will\r\nexplain two different methods that allow to check every price\r\nfaster.Shortly, we process all possible prices in ascending order, and\r\nwhen we go from one price to the next, we update the customers which no\r\nlonger want to buy a tree with a new price, and the customers which will\r\nleave a negative review if the price is increased.One of the ways to\r\nimplement it is as follows. For every customer, create two \"events\" of\r\nthe type \"when price exceeds , the customer will leave a negative\r\nreview\" and \"when price exceeds , the customer will no longer buy a tree\r\nand leave a negative review\". These events can be implemented as pairs\r\nof integers and .Then, we can sort the events and process them from left\r\nto right in sorted order, maintaining the number of trees and negative\r\nreviews. When we process the event with price , the change it makes will\r\ncome into effect only when the price exceeds , so we . Furthermore, all\r\nevents with the same price value should be processed at the same time\r\n(so if there are multiple events with the same price value, you donât\r\nupdate the answer after processing only several of them). All of this is\r\na bit complicated to implement, thatâs why I would like to show you\r\nanFor every price , we need to calculate two values: the number of trees\r\nbought, i. e. the number of customers such that ; the number of negative\r\nreviews, i. e. the number of customers such that . The first one can be\r\ncalculated in with binary search, if we sort the array . The second one\r\nis a bit trickier.Letâs calculate it as follows: take the number of\r\ntrees bought, and then subtract the number of trees bought without a\r\nnegative review (which is the number of customers such that ). If we\r\nsort both arrays and , this value can also be processed in with binary\r\nsearch. So, we spend time to check one possible price, and the number of\r\ndifferent prices we have to check is up to , so this solution works in .\r\n",
    "name": "E. Best Price",
    "statement": "A batch of Christmas trees has arrived at the largest store in Berland.\r\nn customers have already come to the store, wanting to buy them.Before\r\nthe sales begin, the store needs to determine the price for one tree\r\n(the price is the same for all customers). To do this, the store has\r\nsome information about each customer.For the i-th customer, two integers\r\na_i and b_i are known, which define their behavior: if the price of the\r\nproduct is at most a_i, the customer will buy a tree and leave a\r\npositive review; otherwise, if the price of the product is at most b_i,\r\nthe customer will buy a tree but leave a negative review; otherwise, the\r\ncustomer will not buy a tree at all. Your task is to calculate the\r\nmaximum possible earnings for the store, given that it can receive no\r\nmore than k negative reviews.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ll long longusing namespace std; int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);     int t;    cin >> t;     while(t--){        ll n, k;        cin >> n >> k;         vector<ll> a(n), b(n);         for(int i = 0; i < n; i++){            cin >> a[i];        }                for(int i = 0; i < n; i++){            cin >> b[i];        }         sort(a.begin(), a.end());        sort(b.begin(), b.end());         vector<ll> arr;        arr.reserve(4 * n);         for(int i = 0; i < n; i++){            arr.push_back(a[i]);            arr.push_back(a[i] + 1);            arr.push_back(b[i]);            arr.push_back(b[i] + 1);        }         sort(arr.begin(), arr.end());        arr.erase(unique(arr.begin(), arr.end()), arr.end());         ll ans = 0;         for(auto &p : arr){            if(p <= 0) continue;             int lba = int(lower_bound(a.begin(), a.end(), p) - a.begin());            int lbb = int(lower_bound(b.begin(), b.end(), p) - b.begin());             ll ncnt = (ll)lba - lbb;            if(ncnt <= k){                ll bs = n - lbb;                ll rv = p * bs;                ans = max(ans, rv);            }        }         cout << ans << \"\\n\";    }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Best Price.json",
    "hint": []
}