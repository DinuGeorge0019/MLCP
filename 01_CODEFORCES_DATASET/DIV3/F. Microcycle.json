{
    "link": "https://codeforces.com//contest/1927/problem/F",
    "problemId": "2464699",
    "problem_idx": "F",
    "shortId": "1927F",
    "contest_number": "1927",
    "problem_submissions": {
        "C": [
            245774999,
            245774883,
            245105422,
            245122382,
            245158304,
            245133466,
            245112415,
            245098943,
            245111076,
            245091126,
            245103710,
            245107875,
            245104800,
            245109291,
            245088939,
            245786825,
            245116795,
            245107590,
            245112204,
            245122106,
            245110489,
            245107546,
            245111221
        ],
        "D": [
            245774988,
            245774903,
            245126667,
            245124314,
            245152025,
            245153432,
            245150633,
            245112201,
            245122425,
            245118950,
            245114451,
            246093598,
            245128357,
            245112456,
            245133587,
            245114664,
            245786868,
            245131035,
            245123686,
            245138273,
            245112167,
            245122716,
            245116208,
            245129268
        ],
        "A": [
            245774978,
            245774852,
            245082305,
            245083383,
            245165173,
            245112854,
            245083966,
            245081484,
            245092954,
            245080652,
            245090517,
            245085040,
            245080976,
            245084295,
            245096827,
            245786733,
            245088207,
            245083129,
            245083368,
            245082872,
            245085962,
            245085358,
            245084178
        ],
        "G": [
            245774962,
            245189987,
            245223574,
            245121073,
            245211786,
            245227020,
            245179313,
            246085405,
            245611417,
            253341820,
            245766332,
            245766313,
            245521133
        ],
        "F": [
            245774946,
            245160123,
            245189910,
            245140204,
            245189390,
            245194353,
            245162965,
            245152515,
            245174987,
            245164490,
            245179652,
            245164683,
            245184260,
            245786958,
            245173789,
            245197866,
            245172638,
            245186291,
            245182363,
            245204502,
            245180485
        ],
        "E": [
            245774926,
            245132223,
            245142824,
            245171074,
            245104988,
            245171442,
            245119413,
            245133491,
            245140861,
            245144155,
            245140539,
            245143808,
            245144249,
            245155627,
            245786913,
            245146648,
            245137887,
            245152924,
            245140823,
            245144077,
            245125971,
            245156370
        ],
        "B": [
            245774866,
            245091252,
            245094838,
            245162618,
            245122271,
            245095055,
            245090386,
            245100335,
            245081684,
            245089900,
            245095184,
            245093242,
            245093048,
            245106643,
            245786775,
            245103674,
            245094877,
            245096630,
            245091382,
            245098673,
            245107003,
            245100041
        ]
    },
    "name": "F. Microcycle",
    "statement": "Given an undirected weighted graph with n vertices and m edges. There is\r\nat most one edge between each pair of vertices in the graph, and the\r\ngraph does not contain loops (edges from a vertex to itself). The graph\r\nis not necessarily connected.A cycle in the graph is called simple if it\r\ndoesn’t pass through the same vertex twice and doesn’t contain the same\r\nedge twice.Find any simple cycle in this graph in which the weight of\r\nthe lightest edge is minimal.\r\n",
    "solutions": [
        "// LUOGU_RID: 146673916\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint tt;\nint n,m;\nstruct Edge{\n\tint from,to,val;\n\tbool operator <(const Edge x){\n\t\treturn val<x.val;\n\t}\n}a[200001],b[200001];int tot;\nstruct edge{\n\tint from,to,val;\n}e[200001<<1];int head[200001],Stree;\nvoid addedge(int x,int y,int z){\n\te[++Stree].to=y,e[Stree].val=z;\n\te[Stree].from=head[x],head[x]=Stree;\n}\nint Fa[200001];\nvoid init(){\n\tfor(int i=1;i<=n;i++) Fa[i]=i;\n}\nint find(int x){\n\tif(x==Fa[x]) return x;\n\treturn Fa[x]=find(Fa[x]);\n}\nvoid merge(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x==y) return ;\n\tFa[x]=y;\n}\nint tree[200001<<2];\n#define ls (now<<1)\n#define rs (now<<1|1)\n#define mid ((l+r)>>1)\nvoid add(int now,int l,int r,int x,int k){\n\tif(l==r){\n\t\ttree[now]=k;\n\t\treturn ;\n\t}\n\tif(mid>=x) add(ls,l,mid,x,k);\n\telse add(rs,mid+1,r,x,k);\n\ttree[now]=min(tree[ls],tree[rs]);\n}\nint ask(int now,int l,int r,int x,int y){\n\tif(x>y) return 1e9;\n\tif(l>=x&&r<=y) return tree[now];\n\tint ret=1e9;\n\tif(mid>=x) ret=ask(ls,l,mid,x,y);\n\tif(mid<y) ret=min(ret,ask(rs,mid+1,r,x,y));\n\treturn ret;\n}\n#undef ls\n#undef rs\n#undef mid\nint fa[200001],dep[200001],siz[200001],son[200001],val[200001];\nint top[200001],id[200001],dfn;\nvoid dfs1(int now,int F){\n\tfa[now]=F;\n\tsiz[now]=1;\n\tdep[now]=dep[F]+1;\n\tfor(int i=head[now];i;i=e[i].from){\n\t\tint u=e[i].to;\n\t\tif(u==F) continue;\n\t\tval[u]=e[i].val;\n\t\tdfs1(u,now);\n\t\tsiz[now]+=siz[u];\n\t\tif(siz[u]>siz[son[now]]) son[now]=u;\n\t}\n}\nvoid dfs2(int now,int TOP){\n\ttop[now]=TOP;\n\tid[now]=++dfn;\n\tif(son[now]) dfs2(son[now],TOP);\n\tfor(int i=head[now];i;i=e[i].from){\n\t\tint u=e[i].to;\n\t\tif(u==son[now]||u==fa[now]) continue;\n\t\tdfs2(u,u);\n\t}\n\tadd(1,1,n,id[now],val[now]);\n}\nint ask(int x,int y){\n\tint ret=1e9;\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tret=min(ret,ask(1,1,n,id[top[x]],id[x]));\n\t\tx=fa[top[x]];\n\t}\n\tif(id[x]>id[y]) swap(x,y);\n\tret=min(ret,ask(1,1,n,id[x]+1,id[y]));\n\treturn ret;\n}\nint lca(int x,int y){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]<dep[y]) return x;\n\treturn y;\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin>>tt;\n\twhile(tt--){\n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcin>>a[i].from>>a[i].to>>a[i].val;\n\t\t}\n\t\tsort(a+1,a+1+m);\n\t\tinit();\n\t\ttot=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x=a[i].from,y=a[i].to;\n\t\t\tx=find(x),y=find(y);\n\t\t\tif(x==y){\n\t\t\t\tb[++tot]=a[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmerge(x,y);\n\t\t\taddedge(a[i].from,a[i].to,a[i].val);\n\t\t\taddedge(a[i].to,a[i].from,a[i].val);\n\t\t}\n\t\tdfn=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(id[i]) continue;\n\t\t\tdfs1(i,i);\n\t\t\tdfs2(i,i);\n\t\t}\n\t\tint x=-1,y=-1,ans=1e9;\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tint ret=ask(b[i].from,b[i].to);\n\t\t\tif(ret<ans){\n\t\t\t\tans=ret;\n\t\t\t\tx=b[i].from,y=b[i].to;\n\t\t\t}\n\t\t}\n\t\tint F=lca(x,y);\n\t\tvector<int> vec;\n\t\twhile(x!=F){\n\t\t\tvec.push_back(x);\n\t\t\tx=fa[x];\n\t\t} \n\t\tstack<int> sta;\n\t\twhile(y!=F){\n\t\t\tsta.push(y);\n\t\t\ty=fa[y];\n\t\t}\n\t\tvec.push_back(F);\n\t\twhile(!sta.empty()){\n\t\t\tvec.push_back(sta.top());\n\t\t\tsta.pop();\n\t\t}\n\t\tcout<<ans<<\" \"<<vec.size()<<'\\n';\n\t\tfor(int u:vec) cout<<u<<' ';cout<<'\\n';\n\t\tfor(int i=1;i<=n;i++) head[i]=0;\n\t\tfor(int i=1;i<=Stree;i++){\n\t\t\te[i].from=e[i].to=e[i].val=0;\n\t\t\tson[i]=fa[i]=siz[i]=id[i]=val[i]=top[i]=0;\n\t\t\tFa[i]=0;\n\t\t}Stree=0;\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "implementation",
        "sortings",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Microcycle.json",
    "editorial_link": "https://codeforces.com//blog/entry/125597",
    "editorial": "Letâs use the disjoint sets union (DSU). We will add edges to the DSU in\r\ndescending order of weight. At the same time, we will build a graph\r\ncontaining only the edges that, when added to the DSU, unite different\r\nsets. We will also remember the last edge that we did not add to the\r\ngraph, as it will be the lightest edge of the desired cycle. To find the\r\ncycle itself, we will find a path in the constructed graph leading from\r\none end of this edge to the other (due to the construction of the graph,\r\nit does not contain cycles, so we need to find a path in the tree).\r\n",
    "hint": []
}