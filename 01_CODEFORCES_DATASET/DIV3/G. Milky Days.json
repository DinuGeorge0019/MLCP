{
    "link": "https://codeforces.com//contest/2014/problem/G",
    "problemId": "2892479",
    "problem_idx": "G",
    "shortId": "2014G",
    "contest_number": "2014",
    "problem_submissions": {
        "G": [
            282355237,
            282340908,
            282349517,
            282469109,
            282768209
        ],
        "H": [
            282319139,
            282294919,
            282369641,
            282327328,
            282344971,
            282343427,
            282320463,
            282354346,
            282338340,
            282341971,
            282345189,
            282359227,
            282335882,
            282356841,
            282332486,
            282259554,
            282367573,
            282358571,
            282340140,
            282354845,
            282340779
        ],
        "F": [
            282310940,
            282344360,
            282329041,
            282301003,
            282317626,
            282346191,
            282313376,
            282324314,
            282336360,
            282330209,
            282316236,
            282352931,
            282339107,
            282367052,
            282355481,
            282342400,
            282311004,
            282354051,
            282348444,
            282360261
        ],
        "E": [
            282298135,
            282347444,
            282324784,
            282315211,
            282288353,
            282301236,
            282298734,
            282299501,
            282311127,
            282309362,
            282313492,
            282303867,
            282309804,
            282310056,
            282314491,
            282344707,
            282319635,
            282302427,
            282313050,
            282331264,
            282317148
        ],
        "D": [
            282266365,
            282262468,
            282284761,
            282266186,
            282281624,
            282263914,
            282278929,
            282290066,
            282285534,
            282292322,
            282283633,
            282303511,
            282281064,
            282294495,
            282319933,
            282298383,
            282290687,
            282285759,
            282297433,
            282291388
        ],
        "C": [
            282245761,
            282249551,
            282267820,
            282250356,
            282260562,
            282251055,
            282251810,
            282263518,
            282256201,
            282252015,
            282260274,
            282248128,
            282257994,
            282266861,
            282299616,
            282253349,
            282254086,
            282264623,
            282276303,
            282262355
        ],
        "B": [
            282235337,
            282236894,
            282246106,
            282232521,
            282241668,
            282237594,
            282243258,
            282239802,
            282239576,
            282238146,
            282241956,
            282238965,
            282240579,
            282237329,
            282279188,
            282240894,
            282242478,
            282240040,
            282236073,
            282244164,
            282271471
        ],
        "A": [
            282225117,
            282225433,
            282233872,
            282225077,
            282234075,
            282225216,
            282226675,
            282226848,
            282232220,
            282227137,
            282231989,
            282227272,
            282229469,
            282228546,
            282236816,
            282226223,
            282233092,
            282227477,
            282229182,
            282226562
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134210",
    "editorial": "The key for this problem is the use of a stack, where last item in is the first item out. As we scan through the diary entries, we will only drink till the day of the next entry. If there is left over milk, we will push them into the stack with number of pints and the day they were acquired. If there isn't enough milk to reach the next entry, we will check the stack for left overs. Careful implementation is required to check for expiry day. It might help to append a fictitious entry with large day number and 0\n pints. Since every pop from the stack accompanies either the processing of a diary entry or permanently removing a stack item, the number of stack operation is O(n)\n.\n\nSince diary entries are presented in sorted order, the time complexity is O(n)\n.\n\nNote: Originally, this problem has an easy version, where Little John drinks the oldest drinkable milk first. However testers and the team were uncertain about the difficulties of the two problems, and there was concern that they are too 'implementation heavy'. For the sake of balance, only the hard version is presented here as G. However, you may wish to try the easy version yourself. I recall my parents telling me to use the oldest milk first, and now I say the same to my children. Has it all been worthwhile?",
    "name": "G. Milky Days",
    "statement": "His dairy diary has n entries, showing that he acquired a_i pints of\r\nfresh milk on day d_i. Milk declines in freshness with time and stays\r\ndrinkable for a maximum of k days. In other words, fresh milk acquired\r\non day d_i will be drinkable between days d_i and d_i+k-1\r\ninclusive.Every day, Little John drinks drinkable milk, up to a maximum\r\nof m pints. In other words, if there are less than m pints of milk, he\r\nwill drink them all and not be satisfied; if there are at least m pints\r\nof milk, he will drink exactly m pints and be satisfied, and it’s a\r\n.Little John always drinks drinkable milk first.Determine the number of\r\nfor Little John.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, m, k;int top, b[N];PII a[N];vector<PII> e[N];void solve(){    cin >> n >> m >> k;    top = 0;    for (int i = 1; i <= n; i++)    {        int l, w;        cin >> l >> w;        a[i] = {l, w};        b[++top] = l;        b[++top] = l + k;    }    sort(b + 1, b + 1 + top);    top = unique(b + 1, b + 1 + top) - b - 1;    for (int i = 1; i <= top; i++)        e[i].clear();    int ans = 0;    for (int i = 1; i <= n; i++)    {        int x = lower_bound(b + 1, b + 1 + top, a[i].first) - b;        e[x].push_back({a[i].second, i});    }    priority_queue<array<int, 3>, vector<array<int, 3>>, greater<array<int, 3>>> q1;    priority_queue<array<int, 3>> q;    vector<int> vis(n + 1);    for (int i = 1; i < top; i++)    {        while (!q1.empty() && q1.top()[0] <= i)            vis[q1.top()[2]] = 1, q1.pop();        int pos = lower_bound(b + 1, b + 1 + top, b[i] + k) - b;        for (auto to : e[i])            q.push({pos, to.first, to.second}), q1.push({pos, to.first, to.second});        int days = b[i + 1] - b[i]; // 天数        int cnt = 0;        while (!q.empty())        {            auto [due, w, id] = q.top();            q.pop();            if (vis[id])                continue;            // cout << id << ' ' << w << endl;            if (w + cnt >= m)            {                int cs = (w + cnt) / m;                if (cs < days)                {                    days -= cs;                    ans += cs;                    w = (w + cnt) % m;                    cnt = w;                    // cout << b[i] << \"cs:\" << cs << endl;                }                else                {                    w = w + cnt - days * m;                    cnt = 0;                    ans += days;                    // cout << b[i] << \"days:\" << days << endl;                    days = 0;                    if (w)                        q.push({due, w, id});                    goto aa;                }            }            else                cnt += w;        }    aa:;    }    cout << ans << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Milky Days.json",
    "hint": [
        "Hint 1 Lets first process each day one by one.",
        "Hint 2 We should maintain list of all drinkable milks in a map. We should remove all non drinkable milk. We should add all the new milk we have got today.",
        "Hint 3 Now split into 2 cases — Latest milk quantity is less than m. Latest milk quantity is atleast m,",
        "Hint 4 For case 1, when latest milk quantity is less than m, We should bruteforce by taking latest milk and until we have total m, or no milk remains. Then increase time by 1.",
        "Hint 5 For case 2, when latest milk quantity is atleast m, Here, lets try to find how long can we drink current milk. We can drink it until — Some other milk comes If current quantity is C, then we can drink it for next C/m days If this milk came on dj day, we can drink it until dj+k-1 day Take minimum of these 3, and assume we have gotten m milk each day. Then remove this quantity from latest milk, and increase time."
    ]
}