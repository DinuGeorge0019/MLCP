{
    "link": "https://codeforces.com//contest/1690/problem/G",
    "problemId": "1423055",
    "problem_idx": "G",
    "shortId": "1690G",
    "contest_number": "1690",
    "problem_submissions": {
        "F": [
            159806986,
            159794535,
            159803560,
            159795356,
            159803611,
            159810003,
            161958741,
            159901379,
            159799120,
            159805990,
            159805447,
            159834670,
            159815479,
            159815758,
            159832304,
            159791660,
            159812232,
            159823656,
            159820324,
            159819489,
            159793231,
            159818514
        ],
        "G": [
            159789082,
            159825164,
            159831504,
            159831419,
            159832391,
            159839709,
            159834673,
            159846076,
            159851606,
            159849999,
            159835741,
            159843351,
            159856244,
            159825213,
            159841650,
            159850090,
            159841330,
            159847201,
            159833351,
            159855753
        ],
        "E": [
            159767819,
            159765301,
            159753624,
            159775193,
            159777984,
            159782869,
            159901400,
            159779470,
            159776567,
            159781160,
            159789988,
            159788967,
            159791938,
            159787307,
            159768121,
            159785541,
            159787298,
            159790761,
            159810098,
            159800474,
            159767523,
            159788062
        ],
        "D": [
            159735426,
            159753255,
            159744844,
            159759311,
            159761856,
            159749129,
            159760845,
            159762141,
            159745073,
            159747365,
            159767078,
            159764956,
            159753841,
            159768103,
            159754604,
            159758954,
            159769246,
            159761854,
            159752872,
            159766823
        ],
        "A": [
            159733481,
            159728723,
            159728980,
            159730869,
            159729579,
            159730292,
            159735804,
            159735374,
            159729478,
            159730047,
            159903613,
            159739525,
            159731331,
            159729145,
            159767995,
            159729359,
            159733585,
            159735989,
            159738194,
            159732884,
            159737457
        ],
        "B": [
            159731273,
            159733842,
            159733916,
            159746458,
            159736988,
            159735973,
            159743542,
            159743382,
            159735141,
            159735777,
            159750550,
            159745379,
            159735239,
            159770854,
            159740998,
            159742110,
            159755056,
            159746312,
            159757832,
            159745537
        ],
        "C": [
            159728882,
            159740086,
            159737931,
            159750746,
            159754739,
            159743933,
            159755874,
            159756762,
            159741517,
            159742259,
            159760507,
            159757905,
            159746715,
            159768067,
            159748475,
            159749851,
            159762561,
            159752246,
            159835353,
            159760474
        ]
    },
    "name": "G. Count the Trains",
    "statement": "There are n of independent carriages on the rails. The carriages are\r\nnumbered from left to right from 1 to n. The carriages are not connected\r\nto each other. The carriages move to the left, so that the carriage with\r\nnumber 1 moves ahead of all of them.The i-th carriage has its own\r\nengine, which can accelerate the carriage to a_i km/h, but the carriage\r\ncannot go faster than the carriage in front of it. See example for\r\nexplanation.All carriages start moving to the left at the same time, and\r\nthey naturally form . We will call consecutive moving carriages having\r\nthe same speed.For example, we have n=5 carriages and array a = [10, 13,\r\n5, 2, 6]. Then the final speeds of the carriages will be [10, 10, 5, 2,\r\n2]. Respectively, 3 of the train will be formed.There are also messages\r\nsaying that some engine has been corrupted: message \"\" means that the\r\nspeed of the k-th carriage has decreased by d (that is, there has been a\r\nchange in the maximum speed of the carriage a_k = a_k - d). Messages\r\narrive sequentially, the processing of the next message takes into\r\naccount the changes from all previous messages.After each message\r\ndetermine the number of formed trains.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1'000'000'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nstruct SegTree{\n    vector<int> tree;\n    int len;\n    vector<int> md;\n    void init(int n){\n        len = 1;\n        while (len < n){\n            len *= 2;\n        }\n        tree.assign(2 * len, 0);\n        md.assign(2 * len, -1);\n    }\n    void push(int v, int l, int r){\n        if (l + 1 == r){\n            return;\n        }\n        int m = (l + r) / 2;\n        if (md[v] != -1){\n            tree[2 * v] = (m - l) * md[v];\n            tree[2 * v + 1] = (r - m) * md[v];\n            md[2 * v] = md[2 * v + 1] = md[v];\n            md[v] = -1;\n        }\n    }\n    void update(int v, int l, int r, int ql, int qr, int d){\n        if (max(ql, l) >= min(qr, r)){\n            return;\n        }\n        if (ql <= l && r <= qr){\n            tree[v] = (r - l) * d;\n            md[v] = d;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(v, l, r);\n        update(2 * v, l, m, ql, qr, d), update(2 * v + 1, m, r, ql, qr, d);\n        tree[v] = tree[2 * v] + tree[2 * v + 1];\n    }\n    void update(int l, int r, int d){\n        update(1, 0, len, l, r + 1, d);\n    }\n    int get(int v, int l, int r, int ql, int qr){\n        if (max(ql, l) >= min(r, qr)){\n            return 0;\n        }\n        if (ql <= l && r <= qr){\n            return tree[v];\n        }\n        int m = (l + r) / 2;\n        push(v, l, r);\n        return get(2 * v, l, m, ql, qr) + get(2 * v + 1, m, r, ql, qr);\n    }\n    int get(int l, int r){\n        return get(1, 0, len, l, r + 1);\n    }\n};\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    int a[n];\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<int> p(n);\n    p[0] = a[0];\n    for (int i = 1; i < n; i++) p[i] = min(p[i - 1], a[i]);\n    vector<int> id(n);\n    id[0] = 1;\n    for (int i = 1; i < n; i++) id[i] = p[i] != p[i - 1];\n    SegTree stid, stp;\n    stid.init(n);\n    for (int i = 0; i < n; i++) stid.update(i, i, id[i]);\n    stp.init(n);\n    for (int i = 0; i < n; i++) stp.update(i, i, p[i]);\n    while (m--){\n        int k, d;\n        cin >> k >> d;\n        k--;\n        a[k] -= d;\n        if (a[k] < stp.get(k, k)){\n            int left = k, right = n;\n            while (right - left > 1) {\n                int mid = (left + right) / 2;\n                if (a[k] <= stp.get(mid, mid)) {\n                    left = mid;\n                } else {\n                    right = mid;\n                }\n            }\n            stp.update(k, left, a[k]);\n            stid.update(k, left, 0);\n            stid.update(k, k, 1);\n        }\n        cout << stid.get(0, n - 1) << \" \";\n    }\n    cout << \"\\n\";\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Count the Trains.json",
    "editorial_link": "https://codeforces.com//blog/entry/103658",
    "editorial": "In the set we will keep the indices that start the trains. That is, if\r\nthe array the real speeds of the carriages, then we will store in the\r\nnetwork such values that . As well as the value of . Thus, the size of\r\nthe set is the answer to the problem. Consider now the operation to\r\nreduce the speed of the carriage: find such maximal index in the set, if\r\nthe value , then we should add the value to the set, since it will start\r\na new train. Then we should remove all subsequent indexes from the set\r\nsuch that . Thus, for all operations we will add no more than elements\r\nto the array, and remove in total no more than elements from the set. We\r\nobtain the asymptotic .\r\n"
}