{
    "link": "https://codeforces.com//contest/1475/problem/D",
    "problemId": "877136",
    "problem_idx": "D",
    "shortId": "1475D",
    "contest_number": "1475",
    "problem_submissions": {
        "G": [
            105357435,
            105353117,
            105356792,
            105355999,
            105373741,
            105354969,
            105380919,
            105377146,
            105378300,
            105392699,
            105388391,
            105385880,
            105393662,
            105395380,
            105394840,
            105387401,
            105387670,
            105390094
        ],
        "F": [
            105351927,
            105357486,
            105365752,
            105373501,
            105363421,
            105369601,
            105373520,
            105367472,
            105382350,
            105374670,
            105379170,
            105369385,
            105379845,
            105380433,
            105376571,
            105377554,
            105393804
        ],
        "E": [
            105344845,
            105346728,
            105337063,
            105334310,
            105356585,
            105370551,
            105361997,
            105356836,
            105352936,
            105365884,
            105369358,
            105357806,
            105368246,
            105367253,
            105363206,
            105367340,
            105373988,
            105367073
        ],
        "D": [
            105338341,
            105341549,
            105347068,
            105372256,
            105350292,
            105364300,
            105354879,
            105371230,
            105368625,
            105358896,
            105361695,
            105380627,
            105356276,
            105359403,
            105359168,
            105355985,
            105378924,
            105382384,
            105379690
        ],
        "C": [
            105320580,
            105317968,
            105329054,
            105323429,
            105339564,
            105321102,
            105326770,
            105331530,
            105321133,
            105333110,
            105339000,
            105333226,
            105331288,
            105340903,
            105338355,
            105339758,
            105336564
        ],
        "B": [
            105309543,
            105309679,
            105321922,
            105311424,
            105316444,
            105311086,
            105314894,
            105313124,
            105310606,
            105313344,
            105315001,
            105318054,
            105314173,
            105311720,
            105316715,
            105316237,
            105318935
        ],
        "A": [
            105307097,
            105307137,
            105312703,
            105307046,
            105308743,
            105308312,
            105309093,
            105308294,
            105307309,
            105308822,
            105309783,
            105313391,
            105309615,
            105307651,
            105310811,
            105307813,
            105310833,
            105312748
        ]
    },
    "name": "D. Cleaning the Phone",
    "statement": "Polycarp often uses his smartphone. He has already installed n\r\napplications on it. Application with number i takes up a_i units of\r\nmemory.Polycarp wants to free at least m units of memory (by removing\r\nsome applications).Of course, some applications are more important to\r\nPolycarp than others. He came up with the following scoring system he\r\nassigned an integer b_i to each application: b_i = 1 regular\r\napplication; b_i = 2 important application. According to this rating\r\nsystem, his phone has b_1 + b_2 +\r\nldots + b_n convenience points.Polycarp believes that if he removes\r\napplications with numbers i_1, i_2,\r\nldots, i_k, then he will free a_{i_1} + a_{i_2} +\r\nldots + a_{i_k} units of memory and lose b_{i_1} + b_{i_2} +\r\nldots + b_{i_k} convenience points.For example, if n=5, m=7, a=[5, 3, 2,\r\n1, 4], b=[2, 1, 1, 2, 1], then Polycarp can uninstall the following\r\napplication sets (not all options are listed below): applications with\r\nnumbers 1, 4 and 5. In this case, it will free a_1+a_4+a_5=10 units of\r\nmemory and lose b_1+b_4+b_5=5 convenience points; applications with\r\nnumbers 1 and 3. In this case, it will free a_1+a_3=7 units of memory\r\nand lose b_1+b_3=3 convenience points. applications with numbers 2 and\r\n5. In this case, it will free a_2+a_5=7 memory units and lose b_2+b_5=2\r\nconvenience points. Help Polycarp, choose a set of applications, such\r\nthat if removing them will free at least m units of memory and lose the\r\nminimum number of convenience points, or indicate that such a set does\r\nnot exist.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\", x.f, \", \", x.s, \"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? \", \" : \"\", a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\n    void setOut(string s) { freopen(s.c_str(), \"w\", stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + \".in\"), setOut(s + \".out\"); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO(\"\");\n    int tt; re(tt);\n    while (tt--) {\n        int n, m; re(n, m);\n        vl a(n);\n        f0r(i, n) re(a[i]);\n        vi b(n);\n        f0r(i, n) re(b[i]);\n        ll sum = 0;\n        f0r(i, n) sum += a[i];\n        if (sum < m) {\n            ps(-1);\n            continue;\n        }\n        vector<vl> cost(3);\n        f0r(i, n) {\n            cost[b[i]].eb(a[i]);\n        }\n        f1r(i, 1, 3) sort(all(cost[i])), reverse(all(cost[i]));\n        vector<vl> pre(3);\n        sum = 0;\n        trav(t, cost[1]) sum += t;\n        int i2 = -1;\n        int u1 = sz(cost[1]);\n        int u2 = 0;\n        ll sum2 = 0;\n        int ans = 1e9;\n        for (int i1 = sz(cost[1])-1; i1 >= -1; i1--) {\n            while (i2 < sz(cost[2])-1 && sum + sum2 < m) {\n                i2++;\n                u2++;\n                sum2 += cost[2][i2];\n            }\n            if (sum + sum2 >= m) {\n                ckmin(ans, u1 + 2 * u2);\n\n            }\n\n\n            if (i1 != -1) sum -= cost[1][i1], u1--;\n        }\n        ps(ans);\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Cleaning the Phone.json",
    "editorial_link": "https://codeforces.com//blog/entry/87188",
    "editorial": "Let\u00e2\u0080\u0099s say we remove applications with and applications with . Obviously,\r\namong all the applications with , it was necessary to take maximum in\r\nmemory (so we will clear the most memory).Let\u00e2\u0080\u0099s split all the\r\napplications into two arrays with and and sort them. Then you need to\r\ntake a prefix from each array.Let\u00e2\u0080\u0099s iterate over which prefix we take\r\nfrom the first array. For it, we can uniquely find the second prefix (we\r\nremove applications until the sum exceeds ). If we now increase the\r\nfirst prefix by taking a new application, then we don\u00e2\u0080\u0099t need to take any\r\napplications in the second array. This means that when the first prefix\r\nis increased, the second one can only decrease.To solve the problem, you\r\ncan use the two-pointer method.\r\n"
}