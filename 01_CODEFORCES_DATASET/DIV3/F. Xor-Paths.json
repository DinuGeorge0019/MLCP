{"link": "https://codeforces.com//contest/1006/problem/F", "problemId": "198030", "problem_idx": "F", "shortId": "1006F", "contest_number": "1006", "problem_submissions": {"F": [40441400, 40440824, 40440718, 40440827, 40424217, 40442318, 40444967, 40447621, 40447392, 40445275, 40438703, 40428895, 40523944, 40456300, 40469784], "D": [40431223, 40427415, 40429428, 40427666, 40435691, 40430513, 40434142, 40438290, 40431310, 40440098, 40429630, 40428380, 40426509, 40433251, 40426493, 40678651, 40428666, 40431857, 40429891, 40428151, 40428405], "E": [40425946, 40430996, 40428189, 40432790, 40428480, 40435411, 40438586, 40437117, 40432836, 40443168, 40425115, 40431041, 40430321, 40417607, 40432842, 40431866, 40426721, 40428657, 40431622, 40432669], "C": [40421659, 40420878, 40419334, 40423831, 40424033, 40424261, 40424821, 40426724, 40426733, 40435459, 40420478, 40420692, 40423322, 40419164, 40418012, 40511067, 40419053, 40423337, 40419944, 40423295, 40422046], "B": [40419978, 40418807, 40418159, 40421590, 40425339, 40421610, 40421499, 40421847, 40440870, 40433565, 40419011, 40419302, 40420307, 40421856, 40421084, 40507243, 40417820, 40421010, 40421030, 40420039, 40420598], "A": [40417368, 40415298, 40415306, 40418538, 40416510, 40415729, 40416251, 40417776, 40416833, 40484358, 40430262, 40415381, 40416664, 40417319, 40423001, 40419643, 40482910, 40415406, 40415414, 40420065, 40415817, 40415886]}, "name": "F. Xor-Paths", "statement": "There is a rectangular grid of size n\r\ntimes m. Each cell has a number written on it; the number on the cell\r\n(i, j) is a_{i, j}. Your task is to calculate the number of paths from\r\nthe upper-left cell (1, 1) to the bottom-right cell (n, m) meeting the\r\nfollowing constraints: You can move to the right or to the bottom only.\r\nFormally, from the cell (i, j) you may move to the cell (i, j + 1) or to\r\nthe cell (i + 1, j). The target cell can\u2019t be outside of the grid. The\r\nof all the numbers on the path from the cell (1, 1) to the cell (n, m)\r\nmust be equal to k ( operation is the bitwise exclusive OR, it is\r\nrepresented as \u201d in Java or C++ and \"\" in Pascal). Find the number of\r\nsuch paths in the given grid.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint n, m;\nlong long k;\nlong long a[MAX_N + 1][MAX_N + 1];\nmap<long long, long long> f[MAX_N + 1][MAX_N + 1];\nlong long ans;\n\nvoid backtrack1(int x, int y, int step, long long xorsum) {\n\tif (step == n) {\n\t\tf[x][y][xorsum]++;\n\t\treturn;\n\t}\n\tif (x < n) {\n\t\tbacktrack1(x + 1, y, step + 1, xorsum ^ a[x + 1][y]);\n\t}\n\tif (y < m) {\n\t\tbacktrack1(x, y + 1, step + 1, xorsum ^ a[x][y + 1]);\n\t}\n}\n\nvoid backtrack2(int x, int y, int step, long long xorsum) {\n\tif (step == m) {\n\t\tans += f[x][y][k ^ a[x][y] ^ xorsum];\n\t\treturn;\n\t}\n\tif (x > 1) {\n\t\tbacktrack2(x - 1, y, step + 1, xorsum ^ a[x - 1][y]);\n\t}\n\tif (y > 1) {\n\t\tbacktrack2(x, y - 1, step + 1, xorsum^a[x][y - 1]);\n\t}\n}\n\nint main() {\n\t//freopen(\"input.inp\", \"r\", stdin);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> m >> k;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin >> a[i][j];\n\tans = 0;\n\tbacktrack1(1, 1, 1, a[1][1]);\n\tbacktrack2(n, m, 1, a[n][m]);\n\tcout << ans;\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "dp", "meet-in-the-middle"], "dificulty": "2100", "interactive": false}