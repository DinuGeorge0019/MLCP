{
    "link": "https://codeforces.com//contest/1547/problem/D",
    "problemId": "1041928",
    "problem_idx": "D",
    "shortId": "1547D",
    "contest_number": "1547",
    "problem_submissions": {
        "G": [
            121944344,
            121945250,
            121969047,
            121966817,
            121967594,
            121972943,
            121975745,
            121977858,
            122032964,
            121981350,
            122056223,
            121979237,
            121981913,
            121981376,
            121980625,
            122155991,
            121975434,
            121991454,
            121995068,
            121976725,
            121981904,
            121989177
        ],
        "F": [
            121935413,
            121935594,
            121941387,
            121951169,
            121954987,
            121958658,
            121946378,
            121960440,
            121957223,
            121947189,
            121953926,
            121961168,
            121956579,
            122155975,
            121957484,
            121963743,
            121963233,
            121983907,
            130067043,
            121967696,
            121964782
        ],
        "E": [
            121927323,
            121930033,
            121934266,
            121934350,
            121934750,
            121950868,
            121938700,
            121947044,
            121939016,
            121918151,
            121943738,
            121951247,
            121943401,
            122155944,
            121929091,
            121938064,
            121948603,
            121929249,
            121954857,
            121951226
        ],
        "D": [
            121920905,
            121925537,
            121926615,
            121928957,
            121929027,
            121935132,
            121933601,
            121938327,
            121930818,
            121951066,
            121937525,
            121939215,
            121938926,
            122155930,
            121923421,
            121931871,
            121939814,
            121923678,
            121938027,
            121939755
        ],
        "C": [
            121917301,
            121919644,
            121922161,
            121925361,
            121925131,
            121930197,
            121927618,
            121931352,
            121926041,
            121941579,
            121930327,
            121931481,
            121932549,
            122155920,
            121946724,
            121926871,
            121930207,
            121920117,
            121930152,
            121928271
        ],
        "B": [
            121913269,
            121913944,
            121915637,
            121917152,
            121916079,
            121921759,
            121916250,
            121921748,
            121918400,
            121932403,
            121917513,
            121922124,
            121917559,
            122155902,
            121918020,
            121915357,
            121920773,
            121914177,
            121922706,
            121919941
        ],
        "A": [
            121912871,
            121922538,
            121912963,
            121913157,
            121913099,
            121914913,
            121913485,
            121917366,
            121913258,
            121918822,
            121913536,
            121914396,
            121913813,
            122155895,
            121942243,
            121912931,
            121913822,
            121912948,
            121914731,
            121913859
        ]
    },
    "name": "D. Co-growing Sequence",
    "statement": "A sequence of non-negative integers a_1, a_2,\r\ndots, a_n is called if for all i from 1 to n - 1 all ones (of binary\r\nrepresentation) in a_i are in the places of ones (of binary\r\nrepresentation) in a_{i + 1} (in other words, a_i\r\n:\r\n&\r\n: a_{i + 1} = a_i, where\r\n& denotes bitwise AND). If n = 1 then the sequence is considered as\r\nwell.For example, the following four sequences are growing: [2, 3, 15,\r\n175] in binary it\u2019s [10_2, 11_2, 1111_2, 10101111_2]; [5] in binary it\u2019s\r\n[101_2]; [1, 3, 7, 15] in binary it\u2019s [1_2, 11_2, 111_2, 1111_2]; [0, 0,\r\n0] in binary it\u2019s [0_2, 0_2, 0_2]. The following three sequences are\r\nnon-growing: [3, 4, 5] in binary it\u2019s [11_2, 100_2, 101_2]; [5, 4, 3] in\r\nbinary it\u2019s [101_2, 100_2, 011_2]; [1, 2, 4, 8] in binary it\u2019s [0001_2,\r\n0010_2, 0100_2, 1000_2]. Consider two sequences of non-negative integers\r\nx_1, x_2,\r\ndots, x_n and y_1, y_2,\r\ndots, y_n. Let\u2019s call this pair of sequences if the sequence x_1\r\noplus y_1, x_2\r\noplus y_2,\r\ndots, x_n\r\noplus y_n is where\r\noplus denotes bitwise XOR.You are given a sequence of integers x_1, x_2,\r\ndots, x_n. Find the lexicographically minimal sequence y_1, y_2,\r\ndots, y_n such that sequences x_i and y_i are co-growing.The sequence\r\na_1, a_2,\r\ndots, a_n is lexicographically smaller than the sequence b_1, b_2,\r\ndots, b_n if there exists 1\r\nle k\r\nle n such that a_i = b_i for any 1\r\nle i < k but a_k < b_k.\r\n",
    "solutions": [
        "#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int prev = 0;\n        for (int i = 0; i < n; i++) {\n            int y = prev & (~a[i]);\n            cout << y << \" \";\n            prev = a[i] ^ y;\n        }\n        cout << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Co-growing Sequence.json",
    "editorial_link": "https://codeforces.com//blog/entry/92715",
    "editorial": "In order to build lexicographically minimal co-growing with sequence, it\r\nis enough to build its elements iteratively, beginning from and\r\nminimizing the -th element assuming that have already been found.Assign\r\n. According to the statement, all elements of the sequence are\r\nnon-negative, so cannot be less than zero. It turns out that is the\r\nminimal possible first element. The existence of an answer with follows\r\nfrom the construction algorithm described below.Let\u00e2\u0080\u0099s use mathematical\r\ninduction and construct under the assumption that all the previous\r\nelements of the sequence have already been constructed. In order to\r\nsatisfy the condition for the growth of the final sequence, the number\r\nmust contain one bits at all places (but not necessarily limited to\r\nthem), on which there are one bits in the number . Let\u00e2\u0080\u0099s denote for and\r\nfind out what bits can be in to satisfy this condition: If in stands bit\r\nthen independently from in at the same spot we can place any bit because\r\nthere is no limit on the corresponding bit in ; If in stands bit and in\r\nthen the corresponding bit in should be equal , so that in the\r\ncorresponding bit also equals one; If in and in stands bit then in\r\nshould be bit at the corresponding place for the same reasons. The bit\r\ntransformation described above can be given by the expression . Indeed,\r\nthis expression gives us bit \u00e2\u0080\u0099one\u00e2\u0080\u0099 at the fixed position if and only if\r\nat that place in stands bit and in stands bit. For the full solution, it\r\nremains only to apply this formula in a loop from to .\r\n"
}