{
    "link": "https://codeforces.com//contest/1005/problem/D",
    "problemId": "196284",
    "problem_idx": "D",
    "shortId": "1005D",
    "contest_number": "1005",
    "problem_submissions": {
        "F": [
            40138065,
            40147546,
            40139536,
            40144099,
            40139733,
            40144938,
            40143679,
            40171160,
            40146303,
            40189217
        ],
        "E1": [
            40128340,
            40127186,
            40134838,
            40136234,
            40136089,
            40143692,
            40135301,
            40137180,
            40144323,
            40124841,
            40127912,
            40131265,
            40133189,
            40133105,
            40133937,
            40134875,
            40135625,
            40134421,
            40131595,
            40135137
        ],
        "D": [
            40125067,
            40124979,
            40128112,
            40136992,
            40132454,
            40129148,
            40135768,
            40128554,
            40130545,
            40126741,
            40124080,
            40124881,
            40127069,
            40127363,
            40130715,
            40128279,
            40129716,
            40130196,
            40122168,
            40126677
        ],
        "C": [
            40122844,
            40120537,
            40121740,
            40127956,
            40126845,
            40126210,
            40127542,
            40132586,
            40121476,
            40122273,
            40121226,
            40121504,
            40123842,
            40124485,
            40124848,
            40125814,
            40188075,
            40124052,
            40125727,
            40127465,
            71194295,
            40123366
        ],
        "B": [
            40118557,
            40118253,
            40123880,
            40122022,
            40117993,
            40119623,
            40121553,
            40121128,
            40129302,
            40117431,
            40118713,
            40118894,
            40119013,
            40119692,
            40120886,
            40121682,
            40120694,
            40121733,
            40125463,
            40118716
        ],
        "A": [
            40117449,
            40117425,
            40122790,
            40118389,
            40117428,
            40118037,
            40118019,
            40118741,
            40117459,
            40117842,
            40117471,
            40117684,
            40117553,
            40117896,
            40118376,
            40119285,
            40118988,
            40117794,
            40123668,
            40117617
        ],
        "E2": [
            40142192,
            40138140,
            40137960,
            97340051,
            97338094,
            40194804,
            40187840
        ]
    },
    "name": "D. Polycarp and Div 3",
    "statement": "Polycarp likes numbers that are divisible by 3.He has a huge number s.\r\nPolycarp wants to cut from it the maximum number of numbers that are\r\ndivisible by 3. To do this, he makes an arbitrary number of vertical\r\ncuts between pairs of adjacent digits. As a result, after m such cuts,\r\nthere will be m+1 parts in total. Polycarp analyzes each of the obtained\r\nnumbers and finds the number of those that are divisible by 3.For\r\nexample, if the original number is s=3121, then Polycarp can cut it into\r\nthree parts with two cuts: 3|1|21. As a result, he will get two numbers\r\nthat are divisible by 3.Polycarp can make an arbitrary number of\r\nvertical cuts, where each cut is made between a pair of adjacent digits.\r\nThe resulting numbers cannot contain extra leading zeroes (that is, the\r\nnumber can begin with if and only if this number is exactly one\r\ncharacter ”). For example, , and are not valid numbers, but , and are\r\nvalid.What is the maximum number of numbers divisible by 3 that Polycarp\r\ncan obtain?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl \"\\n\"\n#define ft first\n#define sd second\n#define openfiles ifstream cin (\"input.txt\"); ofstream cout (\"output.txt\");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    string s;\n    cin >> s;\n    int sc = 0;\n\n    set<int> A;\n\n    for (int i: s) {\n        set<int> B;\n        i -= '0';\n        bool cut = 0;\n\n        for (int j: A) {\n            B.in(j+i);\n        }\n        B.in(i);\n        set<int> C;\n        for (int j: B) {\n            if (j % 3) {\n                C.in(j % 3);\n            } else {\n                cut = 1;\n            }\n        }\n\n        if (!cut) {\n            swap(A, C);\n        } else {\n            A.clear();\n            sc++;\n        }\n\n    }\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Polycarp and Div 3.json",
    "editorial_link": "https://codeforces.com//blog/entry/60511",
    "editorial": "There are multiple approaches to solve this problem. We will use dynamic\r\nprogramming approach.Letâs calculate values of the array , where is the\r\nanswer for prefix of the length . Obviously, , since for the empty\r\nstring (the prefix of the length ) the answer is .For you can find in\r\nthe following way.Letâs look in the last digit of the prefix of length .\r\nIt has index . Either it doesnât belong to segment divisible by , or it\r\nbelongs.If it doesnât belongs, it means we canât use the last digit, so\r\n. If it belongs we need to find shortest that is divisible by and try to\r\nupdate with the value . It means that we \"bite off\" the shortest\r\ndivisible by suffix and reduce the problem to a previous.A number is\r\ndivisible by if and only if sum of its digits is divisible by . So the\r\ntask is to find the shortest suffix of with sum of digits divisible by .\r\nIf such suffix is then and have the same remainder of sum of digits\r\nmodulo .Letâs maintain array of the length , where is the length of the\r\nlongest processed prefix with sum of digits equal to modulo . Use if\r\nthere is no such prefix. It is easy to see that where is the sum of\r\ndigits on the -th prefix modulo .So to find the maximal that substring\r\nis divisible by , just check that and use , where is the sum of digits\r\non the -th prefix modulo .It means that to handle case that the last\r\ndigit belongs to divisible by segment, you should try to update with\r\nvalue . In other words, just do .Sequentially calculating the values of\r\n, we obtain a linear solution.\r\n",
    "hint": []
}