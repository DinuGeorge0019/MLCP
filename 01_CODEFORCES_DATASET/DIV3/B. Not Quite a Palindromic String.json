{
    "link": "https://codeforces.com//contest/2114/problem/B",
    "problemId": "3405986",
    "problem_idx": "B",
    "shortId": "2114B",
    "contest_number": "2114",
    "problem_submissions": {
        "G": [
            321491820,
            321510895,
            321522705,
            321536205,
            321704142,
            321493544,
            321539010
        ],
        "D": [
            321453109,
            321433567,
            321464732,
            321435389,
            321418906,
            321422419,
            321426564,
            321427705,
            321433853,
            321447085,
            321448245,
            321448177,
            321438602,
            321430809,
            321444460,
            321433422,
            321441969,
            321447455
        ],
        "F": [
            321437069,
            321471653,
            321400560,
            321452634,
            321458136,
            321471530,
            321457608,
            321478622,
            321469763,
            321468286,
            321467066,
            321488259,
            321482829,
            321485396,
            321504556,
            321482048,
            321513883,
            321499978,
            321518132
        ],
        "E": [
            321425663,
            321448629,
            321447346,
            321419017,
            321427993,
            321438291,
            321439608,
            321441935,
            321448509,
            321455125,
            321437156,
            321464203,
            321462222,
            321450510,
            321461412,
            321455167,
            321460727,
            321424098
        ],
        "C": [
            321406317,
            321410944,
            321421134,
            321404932,
            321410584,
            321406511,
            321405596,
            321411420,
            321413167,
            321412908,
            321422303,
            321404419,
            321413740,
            321414690,
            321426901,
            321412443,
            321424589,
            321401692
        ],
        "B": [
            321397200,
            321399911,
            321415073,
            321397245,
            321403501,
            321400846,
            321423069,
            321401151,
            321406842,
            321401907,
            321401468,
            321410144,
            321404248,
            321407958,
            321413444,
            321402900,
            321412452,
            321392901
        ],
        "A": [
            321389400,
            321390323,
            321390935,
            321389192,
            321396857,
            321391523,
            321392082,
            321388740,
            321389560,
            321392729,
            321389834,
            321394641,
            321393501,
            321388215,
            321392515,
            321389988,
            321388815,
            321388090
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143268",
    "editorial": "To begin, let’s solve a simpler problem: we will find the minimum and\r\nmaximum possible number of good pairs. To achieve the minimum number of\r\npairs, we will place all zeros at the beginning of the string and all\r\nones at the end. Then, if the number of zeros is and the number of ones\r\nis , the number of good pairs will be (they will be in the middle of the\r\nstring). The maximum number of good pairs is equal to .For to be\r\nachievable, it must obviously be no less than the minimum and no more\r\nthan the maximum possible number of pairs; this condition is necessary\r\nbut not sufficient. For example, in a string of zeros and ones, you can\r\nobtain or good pairs, but you cannot obtain one. This happens because\r\nany swap of symbols changes the number of good pairs either by or by .\r\nLet’s demonstrate the results of swaps between the first elements of the\r\npairs: and and : the number of good pairs did not change; and and : the\r\nnumber of good pairs changed by ; and and : the number of good pairs\r\nchanged by ; and and : the number of good pairs did not change; other\r\npairs are either symmetrical to those shown or do not change the string.\r\n",
    "name": "B. Not Quite a Palindromic String",
    "statement": "Vlad found a binary string^{\r\ntext{ }} s of even length n. He considers a pair of indices (i, n - i +\r\n1), where 1\r\nle i < n - i + 1, to be good if s_i = s_{n - i + 1} holds true.For\r\nexample, in the string ” there is only 1 good pair, since s_1\r\nne s_6, s_2\r\nne s_5, and s_3=s_4. In the string ” there are no good pairs.Vlad loves\r\npalindromes, but not too much, so he wants to rearrange some characters\r\nof the string so that there are exactly k good pairs of\r\nindices.Determine whether it is possible to rearrange the characters in\r\nthe given string so that there are exactly k good pairs of indices (i,\r\nn - i + 1).^{\r\ntext{ }}A string s is called binary if it consists only of the\r\ncharacters ” and ”\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Not Quite a Palindromic String.json"
}