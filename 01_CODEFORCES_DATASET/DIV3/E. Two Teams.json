{
    "link": "https://codeforces.com//contest/1154/problem/E",
    "problemId": "331481",
    "problem_idx": "E",
    "shortId": "1154E",
    "contest_number": "1154",
    "problem_submissions": {
        "G": [
            52855762,
            52851693,
            52883699,
            52890510,
            52889410,
            52873345,
            64071464,
            52852198,
            52889617,
            52938027,
            52899099,
            52883451,
            52933277
        ],
        "F": [
            52847525,
            52855540,
            52853802,
            52856499,
            52854684,
            52859289,
            52859188,
            52856934,
            52861411,
            52860421,
            52864456,
            52865823,
            52865674,
            52862756,
            52863204,
            52898461,
            52885308,
            52867718
        ],
        "E": [
            52844409,
            52843854,
            52845875,
            52851030,
            52848418,
            52851394,
            52850626,
            52850695,
            52853071,
            52854108,
            52854816,
            52860104,
            52857303,
            52865759,
            52865330,
            52848827,
            52846804,
            52847297,
            52851755
        ],
        "D": [
            52838256,
            52840530,
            52838159,
            52842046,
            52844146,
            52843431,
            52844055,
            52843180,
            52844776,
            52845105,
            52843951,
            52855282,
            52849507,
            52844126,
            52848629,
            52839874,
            52840662,
            52843194,
            52840788
        ],
        "C": [
            52833823,
            52836291,
            52835397,
            52837673,
            52839569,
            52838593,
            52840124,
            52839273,
            52840405,
            52841087,
            52841150,
            52840622,
            52844765,
            52838877,
            52843127,
            52835631,
            52837394,
            52838050,
            52836957
        ],
        "B": [
            52831026,
            52830367,
            52830898,
            52831597,
            52835486,
            52833452,
            52832490,
            52835076,
            52832847,
            52835796,
            52836031,
            52832592,
            52835180,
            52833364,
            52837330,
            52831701,
            52832070,
            52833675,
            52832455
        ],
        "A": [
            52828088,
            52827996,
            52828695,
            52828356,
            52829673,
            52830380,
            52828666,
            52830260,
            52828393,
            52830384,
            52829496,
            52829394,
            52828592,
            52828708,
            52833449,
            52828168,
            52828298,
            52828150,
            52828517
        ]
    },
    "name": "E. Two Teams",
    "statement": "There are n students standing in a row. Two coaches are forming two\r\nteams the first coach chooses the first team and the second coach\r\nchooses the second team.The i-th student has integer programming skill\r\na_i. All programming skills are and between 1 and n, inclusive.Firstly,\r\nthe first coach will choose the student with maximum programming skill\r\namong all students not taken into any team, k closest students to the\r\nleft of him and k closest students to the right of him (if there are\r\nless than k students to the left or to the right, all of them will be\r\nchosen). All students that are chosen leave the row and join the first\r\nteam. Secondly, the second coach will make the same move (but all\r\nstudents chosen by him join the second team). Then again the first coach\r\nwill make such move, and so on. This repeats until the row becomes empty\r\n(i. e. the process ends when each student becomes to some team).Your\r\nproblem is to determine which students will be taken into the first team\r\nand which students will be taken into the second team.\r\n",
    "solutions": [
        "// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  set<pair<int, int> > s;\n  set<int> pos;\n  int n = read(), k = read();\n  vector<int> arr(n), ans(n);\n  for (int i = 0; i < n; ++i) {\n    s.emplace(arr[i] = read(), i);\n    pos.emplace(i);\n  }\n  while (!s.empty()) {\n    static int cur = 2;\n    if (cur & 1) ++cur; else --cur;\n    int id = s.rbegin()->second;\n    auto it = pos.find(id);\n    /* get left */ {\n      if (it != pos.begin()) {\n        auto jt = it; --jt;\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          if (jt == pos.begin()) {\n            pos.erase(jt); break;\n          }\n          auto kt = jt; --jt;\n          pos.erase(kt);\n        }\n      }\n    } /* get right */ {\n      auto jt = it; ++jt;\n      if (jt != pos.end()) {\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          auto kt = jt; ++jt; pos.erase(kt);\n          if (jt == pos.end()) break;\n        }\n      }\n    }\n    ans[*it] = cur;\n    s.erase({arr[*it], *it});\n    pos.erase(it);\n  }\n  for (int i = 0; i < n; ++i) {\n    printf(\"%d\", ans[i]);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Two Teams.json",
    "editorial_link": "https://codeforces.com//blog/entry/66586",
    "editorial": "Letâs maintain two data structures: a queue with positions of students\r\nin order of decreasing their programming skill and a set (, note that we\r\nneed exactly set) with positions of students not taken in any team.To\r\nconstruct the first data structure we need to sort pairs in decreasing\r\norder of the first element and after that push second elements in order\r\nfrom left to right.The second data structure can be constructed even\r\neasier we just need to insert all values from into it.Also letâs\r\nmaintain an array , where if the -th student belongs to the first team\r\nand otherwise, and the variable to determine whose turn is now\r\n(initially it is ).While our set is not empty, letâs repeat the\r\nfollowing algorithm: firstly, while the head (the first element) of the\r\nqueue is not in the set, pop it out. This is how we determine which\r\nstudent will be taken now. Let his position be . And donât forget to pop\r\nhim out too. Create the additional dynamic array which will contain all\r\nstudents we will add to the team during this turn.Letâs find the\r\niterator to the student with the position . Then make the following\r\nsequence of moves times: add the element the current iterator is\r\npointing at to the array , then if the current iterator is pointing at\r\nthe first element, break the cycle, otherwise go to the iterator\r\npointing at the previous element.Then letâs find the iterator to the\r\nstudent next to the student with position . And then letâs make almost\r\nthe same sequence of moves times: if the current iterator is pointing to\r\nthe end of the set, break the cycle, otherwise add the element the\r\ncurrent iterator is pointing at to the array and advance to the iterator\r\npointing at the next element.Then letâs remove all values from the array\r\nfrom the set, and for each student we delete letâs set . And change the\r\nvariable to if it is now and to otherwise.Time complexity: .\r\n",
    "hint": []
}