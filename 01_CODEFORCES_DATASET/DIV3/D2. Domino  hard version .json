{
    "link": "https://codeforces.com//contest/1551/problem/D2",
    "problemId": "1055224",
    "problem_idx": "D2",
    "shortId": "1551D2",
    "contest_number": "1551",
    "problem_submissions": {
        "D2": [
            123504570,
            123491119,
            123485402,
            123508709,
            123487387,
            123490299,
            123498497,
            123519517,
            123503570,
            123507308,
            123506328,
            123496338,
            123525324,
            123509854,
            123500000,
            123499688,
            123500681,
            123520243,
            123521810,
            123560543,
            123489816
        ],
        "D1": [
            123496540,
            123479404,
            123460900,
            123501007,
            123476769,
            123477339,
            123486676,
            123509110,
            123490131,
            123493249,
            123493173,
            123482125,
            123490880,
            123500902,
            123489510,
            123491442,
            123487788,
            123505201,
            123513198,
            123560527,
            123477927
        ],
        "E": [
            123487760,
            123503517,
            123508061,
            123512161,
            123512376,
            123522062,
            123512340,
            123494473,
            123520187,
            123519199,
            123522642,
            123508385,
            123509676,
            123525566,
            123522562,
            123529567,
            123525043,
            123524224,
            123527690,
            123529206
        ],
        "F": [
            123483346,
            123518773,
            123505149,
            123522554,
            123530029,
            123525813,
            123677834
        ],
        "C": [
            123463062,
            123471764,
            123465961,
            123494616,
            123466015,
            123470689,
            123479667,
            123473982,
            123478387,
            123473235,
            123485341,
            123504214,
            123476344,
            123474463,
            123482794,
            123487070,
            123509871,
            123495332,
            123505971,
            123560511,
            123471519
        ],
        "B1": [
            123458055,
            123450157,
            123447323,
            123480992,
            123471662,
            123459271,
            123448891,
            123453516,
            123457018,
            123473105,
            123465306,
            123457521,
            123473064,
            123450150,
            123457907,
            123454507,
            123450845,
            123454392,
            123459478,
            123486711,
            123560483,
            123451550
        ],
        "B2": [
            123455203,
            123463888,
            123460727,
            123523874,
            123456743,
            123463349,
            123471479,
            123467608,
            123467523,
            123462292,
            123471295,
            123468067,
            123463785,
            123466840,
            123469959,
            123475307,
            123473651,
            123478743,
            123500344,
            123560494,
            123462370
        ],
        "A": [
            123443367,
            123443254,
            123447159,
            123446121,
            123445546,
            123443509,
            123444177,
            123443572,
            123444116,
            123444163,
            123445991,
            123474697,
            123444077,
            123443229,
            123447862,
            123443364,
            123443226,
            123449045,
            123446138,
            123560465,
            123443541
        ]
    },
    "name": "D2. Domino  hard version ",
    "statement": "There\u2019s a table of n\r\ntimes m cells (n rows and m columns). The value of n\r\ncdot m is even.A domino is a figure that consists of two cells having a\r\ncommon side. It may be horizontal (one of the cells is to the right of\r\nthe other) or vertical (one of the cells is above the other).You need to\r\nplace\r\nfrac{nm}{2} dominoes on the table so that exactly k of them are\r\nhorizontal and all the other dominoes are vertical. The dominoes cannot\r\noverlap and must fill the whole table.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nconst int N = 105;\n\nvector<int> dx = {1,-1,0,0},dy = {0,0,1,-1};\n\nint can[N][N][26];\n\nint _runtimeTerror_()\n{\n    int n,m,k;\n    cin >> n >> m >> k;\n    vector<vector<char>> ans(n,vector<char>(m));\n    for(int i=0;i<n;++i)\n        for(int j=0;j<m;++j)\n            for(int k=0;k<26;++k)\n                can[i][j][k] = 0;\n\n    auto assign = [&](int x,int y,int c)\n    {\n        ans[x][y] = char(c + 'a');\n        for(int i=0;i<4;++i)\n        {\n            int u = x + dx[i],v = y + dy[i];\n            if(u >= 0 && u < n && v >= 0 && v < m)\n                can[u][v][c] = 1;\n        }\n    };\n    auto get = [&](vector<pair<pii,pii>> &a)\n    {\n        for(auto &[u,v]:a)\n        {\n            vector<int> cant(26,0);\n            auto [x,y] = u;\n            auto [xx,yy] = v;\n            for(int i=0;i<26;++i)\n                cant[i] = can[x][y][i] || can[xx][yy][i];\n            for(int i=0;i<26;++i)\n            {\n                if(cant[i] == 0)\n                {\n                    assign(x,y,i);\n                    assign(xx,yy,i);\n                    break;\n                }\n            }\n        }\n    };\n    vector<pair<pii,pii>> a;\n    if(n % 2 == 0 && m % 2 == 0)\n    {\n        if(k % 2 == 0)\n        {\n            cout << \"YES\\n\";\n            for(int i=0;i<n;i+=2)\n            {\n                for(int j=0;j<m;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n        }\n        else\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    else if(n % 2 == 1 && m % 2 == 0)\n    {\n        k -= m/2;\n        if(k >= 0 && k % 2 == 0)\n        {\n            for(int j=0;j<m;j+=2)\n            {\n                a.push_back({{n-1,j},{n-1,j+1}});\n            }\n            for(int i=0;i<n-1;i+=2)\n            {\n                for(int j=0;j<m;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n            cout << \"YES\\n\";\n        }\n        else\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    else if(n % 2 == 0 && m % 2 == 1)\n    {\n        if(k % 2 == 0 && k <= n * m / 2 - n / 2)\n        {\n            cout << \"YES\\n\";\n            for(int i=0;i<n;i+=2)\n                a.push_back({{i,m-1},{i+1,m-1}});\n            for(int i=0;i<n;i+=2)\n            {\n                for(int j=0;j<m-1;j+=2)\n                {\n                    if(k == 0)\n                    {\n                        a.push_back({{i,j},{i+1,j}});\n                        a.push_back({{i,j+1},{i+1,j+1}});\n                    }\n                    else\n                    {\n                        k -= 2;\n                        a.push_back({{i,j},{i,j+1}});\n                        a.push_back({{i+1,j},{i+1,j+1}});\n                    }\n                }\n            }\n        }\n        else\n        {\n            cout << \"NO\\n\";\n            return 0;\n        }\n    }\n    get(a);\n    for(int i=0;i<n;++i)\n    {\n        for(int j=0;j<m;++j)\n            cout << ans[i][j];\n        cout << \"\\n\";\n    }\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D2. Domino  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/93149",
    "editorial": "Suppose and are even. A necessary and sufficient condition of existence\r\nof the answer is that is even.Let\u00e2\u0080\u0099s prove the sufficient condition. If\r\nthe count of the horizontal dominoes is even, then we can combine them\r\nand vertical dominoes to blocks of size (the number of the vertical\r\ndominoes is even, too, if is even). If and are even, we can fill the\r\ntable with these blocks. The description of the locations of the\r\ndominoes may be printed as follows: consider the table is a chessboard\r\nwhere a cell is a block of two dominoes. Consider the leftmost topmost\r\ncell of the board is black. If a cell of the board is black, let\u00e2\u0080\u0099s mark\r\none of the dominoes of the block with the letter \"\" and the other one\r\nwith the letter \"\". If a cell of the board is white, let\u00e2\u0080\u0099s mark one of\r\nthe dominoes of the block with the letter \"\" and the other one with the\r\nletter \"\". There will be no situation that some two cells of the table\r\nare marked with one letter but belong to different dominoes.Let\u00e2\u0080\u0099s prove\r\nthe necessary condition. The number of cells in a column () is even, so\r\nthe number of cells that belong to vertical dominoes is even because\r\ncells of each vertical domino may be either belong to the column or not\r\nbelong at the same time. So the number of cells that belong to\r\nhorizontal dominoes is even. Let\u00e2\u0080\u0099s cross out all cells that belong to\r\nvertical dominoes and let\u00e2\u0080\u0099s find the leftmost column having cells that\r\nhaven\u00e2\u0080\u0099t been crossed out. It\u00e2\u0080\u0099s the leftmost column with such cells so\r\nthe pairwise cells of the non-crossed out cells belong to the column to\r\nthe right of the found one. The number of such cells in the right column\r\nis equal to the number of found cells so it\u00e2\u0080\u0099s even and the number of\r\nfound horizontal dominoes is even, too. Let\u00e2\u0080\u0099s cross out the found cells\r\nand the pairwise cells. The number of non-crossed out cells in the right\r\ncolumn will be even. The number of crossed-out horizontal dominoes will\r\nbe even, too. Let\u00e2\u0080\u0099s repeat this procedure until all the dominoes will be\r\ncrossed out. In every step, we have crossed out the even number of\r\nhorizontal dominoes, hence the total count of horizontal dominoes is\r\neven.Suppose is odd, hence is even. In this case, every column contains\r\nan odd number of cells, whereas the number of cells that belong to\r\nvertical dominoes is even. So the number of cells that belong to\r\nhorizontal dominoes is odd. Consider the leftmost column and find a cell\r\nof it that belongs to a horizontal domino (it must be found because the\r\nnumber of such cells is odd so it isn\u00e2\u0080\u0099t equal to ). Let\u00e2\u0080\u0099s find the\r\npairwise cell and cross out both cells. Currently, the two columns will\r\nhave an even number of non-crossed-out cells. Let\u00e2\u0080\u0099s repeat the procedure\r\nuntil all columns will have even non-crossed-out cells. We will cross\r\nout cells and dominoes. So the necessary condition is that the number of\r\nhorizontal dominoes () is at least .Let\u00e2\u0080\u0099s extend the necessary condition\r\nwith the following condition: the value of is even. Consider the table\r\nthat we\u00e2\u0080\u0099ve become after the previous procedure where each column has\r\nexactly one crossed-out cell. Let\u00e2\u0080\u0099s start the procedure we\u00e2\u0080\u0099ve done in\r\nthe case of even both and . The procedure can be started on our table\r\nbecause each column of the table has an even number of non-crossed-out\r\ncells. As a result of the procedure, we will cross out an even count of\r\nhorizontal dominoes, so the value of is even.Let\u00e2\u0080\u0099s build an answer if\r\nthe conditions and is even are met. Let\u00e2\u0080\u0099s place in the topmost row\r\nhorizontal dominoes and mark their cells as follows: the first domino\r\nwill be marked with \"\", the second one with \"\", the third one with \"\",\r\nand so on. As the result, the region of rows and columns will be\r\nunfilled. Both values are even, and the value of is even, too. So let\u00e2\u0080\u0099s\r\nfill the region as if it\u00e2\u0080\u0099s a separate table having even numbers of rows\r\nand columns. As it was proved above, it\u00e2\u0080\u0099s possible to do. The set of\r\nletters used for the region and set of the letters used for the topmost\r\nrow don\u00e2\u0080\u0099t have common elements, so there will be no cells that are\r\nmarked with one letter but belong to different dominoes.The case of odd\r\n(hence, is even) is similar to the previous one let\u00e2\u0080\u0099s transpose the\r\ntable (it will have rows and columns), swap the values of and , solve\r\nthe case above and transpose the table back to have rows and columns.\r\n"
}