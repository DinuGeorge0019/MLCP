{
    "link": "https://codeforces.com//contest/1374/problem/C",
    "problemId": "659586",
    "problem_idx": "C",
    "shortId": "1374C",
    "contest_number": "1374",
    "problem_submissions": {
        "E2": [
            85382072,
            85375189,
            85438625
        ],
        "F": [
            85353642,
            85415306,
            85383843,
            85383492,
            85387797
        ],
        "E1": [
            85326034,
            85415299,
            85334989,
            85321477,
            85339121,
            85319474,
            85320204,
            85328246,
            85336700,
            85339703,
            85337792,
            85338081,
            85335206,
            85337433,
            85338605,
            85342001,
            85329936,
            85333348,
            85346311
        ],
        "D": [
            85316338,
            85415714,
            85415293,
            85323106,
            85325598,
            85328229,
            85311173,
            85312812,
            85313089,
            85319125,
            85325499,
            85321861,
            85326849,
            85319951,
            85325883,
            85322528,
            85325568,
            85334734,
            85327646,
            85314511
        ],
        "C": [
            85307188,
            85415289,
            85310607,
            85296173,
            85316864,
            85302975,
            85301461,
            85301463,
            85305237,
            85304971,
            85309343,
            85306153,
            85311376,
            85308864,
            85309628,
            85308295,
            85307625,
            85311312,
            85303960
        ],
        "B": [
            85299874,
            85415460,
            85415277,
            85305586,
            85300354,
            85311254,
            85298580,
            85298918,
            85297647,
            85301049,
            85300227,
            85301912,
            85300264,
            85307719,
            85302644,
            85305750,
            85299884,
            85297473,
            85305618,
            85299402
        ],
        "A": [
            85296254,
            85418749,
            85415919,
            85415268,
            85300037,
            85296089,
            85298024,
            85296518,
            245635316,
            85296385,
            85295981,
            85296977,
            85296136,
            85296861,
            85296508,
            85298422,
            85298833,
            85299917,
            85296648,
            85305648,
            85300594,
            85296295
        ]
    },
    "name": "C. Move Brackets",
    "statement": "You are given a bracket sequence s of length n, where n is even\r\n(divisible by two). The string s consists of\r\nfrac{n}{2} opening brackets ” and\r\nfrac{n}{2} closing brackets ”.In one move, you can choose and move it to\r\nthe beginning of the string or to the end of the string (i.e. you choose\r\nsome index i, remove the i-th character of s and insert it before or\r\nafter all remaining characters of s).Your task is to find the minimum\r\nnumber of moves required to obtain from s. It can be proved that the\r\nanswer always exists under the given constraints.Recall what the regular\r\nbracket sequence is: \"\" is regular bracket sequence; if s is regular\r\nbracket sequence then \"\" + s + \"\" is regular bracket sequence; if s and\r\nt are regular bracket sequences then s + t is regular bracket sequence.\r\nFor example, \"\", \"\", \"\" and \"\" are regular bracket sequences, but \"\", \"\"\r\nand \"\" are not.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << \" is \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7;\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tstring s;\n\t\tint n;\n\t\tcin >> n >> s;\n\t\tint cnt = 0;\n\t\twhile(true) {\n\t\t\tint bal = 0;\n\t\t\tbool yes = 1;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c == '(') bal++;\n\t\t\t\telse bal--;\n\t\t\t\tif(bal < 0) yes = 0;\n\t\t\t}\n\t\t\tif(yes) break;\n\t\t\tstring t;\n\t\t\tbool f = 0;\n\t\t\tfor(int i = s.size() - 1; i >= 0; i--) {\n\t\t\t\tif(s[i] == '(') {\n\t\t\t\t\tif(f == 0) f = 1;\n\t\t\t\t\telse t.PB(s[i]);\n\t\t\t\t} else {\n\t\t\t\t\tt.PB(s[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.PB('(');\n\t\t\treverse(ALL(t));\n\t\t\ts = t;\n\t\t\tcnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\t\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Move Brackets.json",
    "editorial_link": "https://codeforces.com//blog/entry/79517",
    "editorial": "Letâs go from left to right over characters of maintaining the current\r\nbracket balance (for the position the balance is the number of opening\r\nbrackets on the prefix till the -th character minus the number of\r\nclosing brackets on the same prefix).If the current balance becomes less\r\nthan zero, then letâs just take some opening bracket after the current\r\nposition (it obviously exists because the number of opening equals the\r\nnumber of closing brackets) and move it to the beginning (so the\r\nnegative balance becomes zero again and the answer increases by one). Or\r\nwe can move the current closing bracket to the end of the string because\r\nit leads to the same result.Time complexity: .\r\n",
    "hint": []
}