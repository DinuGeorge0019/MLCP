{"link": "https://codeforces.com//contest/1660/problem/E", "problemId": "1349759", "problem_idx": "E", "shortId": "1660E", "contest_number": "1660", "problem_submissions": {"F1": [151547102, 151550004, 151556961, 151561107, 152978236, 151550675, 151561323, 151596179, 151595243, 151575027, 151566711, 151559623, 151557836, 151517033, 151568295, 151559969, 151568720, 151557907, 151582251, 151579930, 151557285, 151574893, 151574565, 151562629], "F2": [151547014, 151546872, 151557177, 151562642, 151572516, 151564512, 151576252, 151573626, 151582683, 151534999, 151575687, 151571693, 151586409, 151576536, 151582511, 151579993, 151572690, 151574663, 151588223, 151592536, 151592473], "D": [151536977, 151531465, 151548742, 151544876, 151565576, 151552307, 151540121, 151546219, 151566389, 151546387, 151551910, 151560561, 151552594, 151547123, 151585775, 151548480, 151568426, 151565752, 151535411], "E": [151525872, 151545578, 151554108, 151554403, 151545248, 151556608, 151552575, 151530576, 151571474, 151558277, 151578411, 151541773, 151585933, 151577061, 151547981, 151551718, 151578968, 151569807, 151537268], "C": [151521399, 151518644, 151534007, 151531901, 152978204, 151528259, 151524137, 151544564, 151553145, 151553027, 151553923, 151606337, 151534920, 151528160, 151532624, 151527489, 151538904, 151547071, 151543618, 151548209, 151522441], "B": [151518226, 151511243, 151513483, 151524120, 151516768, 151514262, 151517162, 151521061, 151542405, 151521485, 151521685, 151517284, 151514144, 151516159, 151521136, 151521193, 151528983, 151527060, 151511556], "A": [151508580, 151507746, 151508237, 151517215, 151507971, 151508603, 152300737, 151508040, 151508134, 151537652, 151507999, 151510953, 151511142, 151509365, 151510995, 151509112, 151523384, 151509588, 151513758, 151515112]}, "name": "E. Matrix and Shifts", "statement": "You are given a binary matrix A of size n\r\ntimes n. Rows are numbered from top to bottom from 1 to n, columns are\r\nnumbered from left to right from 1 to n. The element located at the\r\nintersection of row i and column j is called A_{ij}. Consider a set of 4\r\noperations: Cyclically shift all rows up. The row with index i will be\r\nwritten in place of the row i-1 (2\r\nle i\r\nle n), the row with index 1 will be written in place of the row n.\r\nCyclically shift all rows down. The row with index i will be written in\r\nplace of the row i+1 (1\r\nle i\r\nle n - 1), the row with index n will be written in place of the row 1.\r\nCyclically shift all columns to the left. The column with index j will\r\nbe written in place of the column j-1 (2\r\nle j\r\nle n), the column with index 1 will be written in place of the column n.\r\nCyclically shift all columns to the right. The column with index j will\r\nbe written in place of the column j+1 (1\r\nle j\r\nle n - 1), the column with index n will be written in place of the\r\ncolumn 1. You can perform an arbitrary (possibly zero) number of\r\noperations on the matrix; the operations can be performed in any\r\norder.After that, you can perform an arbitrary (possibly zero) number of\r\nnew xor-operations: Select any element A_{ij} and assign it with new\r\nvalue A_{ij}\r\noplus 1. In other words, the value of (A_{ij} + 1)\r\nbmod 2 will have to be written into element A_{ij}. Each application of\r\nthis xor-operation costs one burl. Note that the 4 shift operations are\r\nfree. These 4 operations can only be performed before xor-operations are\r\nperformed.Output the minimum number of burles you would have to pay to\r\nmake the A matrix unitary. A is a matrix with ones on the main diagonal\r\nand the rest of its elements are zeros (that is, A_{ij} = 1 if i = j and\r\nA_{ij} = 0 otherwise).\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<string> f(n);\n  for (int i = 0; i < n; i++) {\n    cin >> f[i];\n  }\n  vector<int> cnt(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cnt[(n + i - j) % n] += (f[i][j] - '0');\n    }\n  }\n  sort(all(cnt));\n  int ans = 0;\n  for (int i = 0; i < n - 1; i++) {\n    ans += cnt[i];\n  }\n  ans += n - cnt[n - 1];\n  cout << ans << '\\n';\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "greedy", "implementation"], "dificulty": "1600", "interactive": false}