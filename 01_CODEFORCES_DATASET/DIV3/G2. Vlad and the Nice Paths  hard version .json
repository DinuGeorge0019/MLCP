{"link": "https://codeforces.com//contest/1811/problem/G2", "problemId": "1864330", "problem_idx": "G2", "shortId": "1811G2", "contest_number": "1811", "problem_submissions": {"D": [200754699, 200776097, 200739331, 200726520, 200726373, 200739709, 200727620, 200738822, 200747547, 200759872, 200759241, 200755197, 200743077, 200739694, 200732035, 200829329, 200737167, 200752747, 201109379, 200751007, 200768259, 200755335], "C": [200736628, 200766081, 200730565, 200712627, 200719542, 200722259, 200709529, 200720517, 200728620, 200721825, 200720940, 200720985, 200725767, 200879176, 200829313, 200722588, 200730813, 201109333, 200731130, 200718431, 200716271], "E": [200723606, 200703078, 200750795, 200749843, 200716143, 200712796, 200731621, 200716868, 200723986, 200707830, 200710920, 200730415, 200743490, 200719631, 200829343, 200754433, 200735492, 201109566, 200738090, 200759827, 200722483], "A": [200719784, 200697693, 200709735, 200697878, 200695570, 200704142, 200696911, 200699911, 200693442, 200693354, 200694979, 200699076, 200694846, 200829295, 200700499, 200698275, 201109090, 200699672, 200700596, 200701647], "G2": [200717686, 200742559, 200770344, 200958696, 201374187, 200831218, 200831193], "G1": [200709506, 200742442, 200769728, 200763697, 200744953, 200746011, 200720480, 200748735, 200760247, 200772203, 200771883, 200769679, 200758537, 200829373, 200780627, 200774881, 201171573, 200757032], "B": [200708366, 200716585, 200706793, 200704223, 200701078, 200703012, 200714270, 200697883, 200700006, 200701394, 200706383, 200878903, 200709089, 200704797, 200829301, 200712812, 200723595, 201109130, 200726473, 200716074, 200734848], "F": [200764192, 200777349, 200768176, 201109661, 200843383, 200769121, 201693689, 201686646, 200776061]}, "name": "G2. Vlad and the Nice Paths  hard version ", "statement": ".Vlad found a row of n tiles and the integer k. The tiles are indexed\r\nfrom left to right and the i-th tile has the color c_i. After a little\r\nthought, he decided what to do with it.You can start from any tile and\r\njump to any number of tiles , forming the path p. Let\u2019s call the path p\r\nof length m if: p can be divided into blocks of length exactly k, that\r\nis, m is divisible by k; c_{p_1} = c_{p_2} =\r\nldots = c_{p_k}; c_{p_{k+1}} = c_{p_{k+2}} =\r\nldots = c_{p_{2k}};\r\nldots c_{p_{m-k+1}} = c_{p_{m-k+2}} =\r\nldots = c_{p_{m}}; Your task is to find the number of paths of length.\r\nSince this number may be too large, print it modulo 10^9 + 7.\r\n", "solutions": ["#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint f[5005][5005];\nint g[5005][5005];\nint mx[5005][5005];\nint tot[5005][5005];\nint mx_all[5005];\nint tot_all[5005];\nint a[5005];\n\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= k; j++) {\n      f[i][j] = 0;\n      g[i][j] = 0;\n      mx[i][j] = 0;\n      tot[i][j] = 0;\n      mx_all[j] = tot_all[j] = 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    f[i][1] = 1;\n    g[i][1] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= k; j++) {\n      int jj = j - 1 > 0 ? j - 1 : k;\n      if (j == 1) {\n        if (mx_all[jj] && f[i][j] < mx_all[jj] + 1) {\n          f[i][j] = mx_all[jj] + 1;\n          g[i][j] = tot_all[jj];\n        } else if (mx_all[jj] && f[i][j] == mx_all[jj] + 1) {\n          (g[i][j] += tot_all[jj]) %= MOD;\n        }\n      } else {\n        if (mx[a[i]][jj] && f[i][j] < mx[a[i]][jj] + 1) {\n          f[i][j] = mx[a[i]][jj] + 1;\n          g[i][j] = tot[a[i]][jj];\n        } else if (mx[a[i]][jj] && f[i][j] == mx[a[i]][jj] + 1) {\n          (g[i][j] += tot[a[i]][jj]) %= MOD;\n        }\n      }\n//      cerr << i << \" \" << j << \" \" << f[i][j] << endl;\n    }\n    for (int j = 1; j <= k; j++) {\n      if (mx_all[j] < f[i][j]) {\n//        cerr << \"FF \" << j << \" \" << mx_all[j] << endl;\n        mx_all[j] = f[i][j];\n        tot_all[j] = g[i][j];\n      } else if (mx_all[j] == f[i][j]) {\n        (tot_all[j] += g[i][j]) %= MOD;\n      }\n      if (mx[a[i]][j] < f[i][j]) {\n        mx[a[i]][j] = f[i][j];\n        tot[a[i]][j] = g[i][j];\n      } else if (mx[a[i]][j] == f[i][j]) {\n        (tot[a[i]][j] += g[i][j]) %= MOD;\n      }\n    }\n  }\n//  for (int i = 1; i <= n; i++) {\n//    for (int j = 1; j <= k; j++) {\n//      int jj = j - 1 > 0 ? j - 1 : k;\n//      for (int ii = 1; ii < i; ii++) {\n//        if (j == 1 || a[ii] == a[i]) {\n//          if (!f[ii][jj]) continue;\n//          if (f[i][j] < f[ii][jj] + 1) {\n//            f[i][j] = f[ii][jj] + 1;\n//            g[i][j] = g[ii][jj];\n//          } else if (f[i][j] == f[ii][jj] + 1) {\n//            (g[i][j] += g[ii][jj]) %= MOD;\n//          }\n//        }\n//      }\n//    }\n//  }\n  int mx = 0;\n  int tot = 0;\n  for (int i = 1; i <= n; i++) {\n//    if (f[i][0] == 10) cerr << i << \" \" << g[i][0] << endl;\n    if (mx < f[i][k]) {\n      mx = f[i][k];\n      tot = g[i][k];\n    } else if (mx == f[i][k]) {\n      (tot += g[i][k]) %= MOD;\n    }\n  }\n//  cerr << mx << endl;\n  if (mx == 0) {\n    cout << 1 << \"\\n\";\n    return;\n  }\n  cout << tot << \"\\n\";\n}\n\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n  int tt; cin >> tt;\n  while (tt--) {\n    solve();\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "combinatorics", "data structures", "dp", "math", "two pointers"], "dificulty": "2200", "interactive": false}