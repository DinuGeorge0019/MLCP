{
    "link": "https://codeforces.com//contest/2033/problem/G",
    "problemId": "2975323",
    "problem_idx": "G",
    "shortId": "2033G",
    "contest_number": "2033",
    "problem_submissions": {
        "G": [
            287783597,
            287787317,
            287795296,
            287783544,
            287803395,
            287748588
        ],
        "F": [
            287734852,
            287757040,
            287770540,
            287746378,
            287737617,
            287721257,
            287731364,
            287728898,
            287736216,
            287726597,
            287760471,
            287735582,
            287745631,
            287765424,
            287758074,
            287757377
        ],
        "E": [
            287718822,
            287738936,
            287751473,
            287738616,
            287715701,
            287703053,
            287722294,
            287724450,
            287723369,
            287719082,
            287731217,
            287727237,
            287801474,
            287714838,
            287735421,
            287716075,
            287729261,
            287727022
        ],
        "D": [
            287714983,
            287722085,
            287725450,
            287786370,
            287704734,
            287697239,
            287717412,
            287703434,
            287716864,
            287711396,
            287716556,
            287711480,
            292117815,
            287700070,
            287697469,
            287708922,
            287710949,
            287714668
        ],
        "C": [
            287710403,
            287713243,
            287708606,
            287801241,
            287699249,
            287754903,
            287711963,
            287742947,
            287707327,
            287728851,
            287705447,
            287701326,
            287753754,
            287722810,
            287701449,
            287701636,
            287702465
        ],
        "B": [
            287685440,
            287691876,
            287694502,
            287793205,
            287688586,
            287691395,
            287699888,
            287686533,
            287697947,
            287689283,
            287692659,
            287694883,
            287690951,
            287686973,
            287695322,
            287690158,
            287695612
        ],
        "A": [
            287681823,
            287680676,
            287682117,
            287787767,
            287680966,
            287680751,
            287692822,
            287680041,
            287683508,
            287679831,
            287683966,
            287684935,
            287683948,
            287680083,
            287685508,
            287682640,
            287681996
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135520",
    "editorial": "In each query, Chefir can ascend from vertex by no more than . To\r\nmaximize the distance, we need to first ascend times (), and then\r\ndescend to the deepest vertex.For each vertex , we will find the\r\ndistance to the farthest descendant of vertex . We will also need the\r\ndistance to the farthest descendant of vertex from a subtree of vertex ,\r\nwhich will allow us to avoid counting any edges twice when searching for\r\nthe answer.Now we can construct binary lifts. The lift by from vertex\r\nwill store information about all vertices from to the -th ancestor,\r\nexcluding vertex itself.The value of the lift from vertex by (i.e., to\r\nits ancestor ) will be calculated as follows: if , then the value is\r\nequal to , and otherwise. Here, is the distance from vertex to the root.\r\nThe subsequent lifts will be computed as the maximums of the\r\ncorresponding values. The constructed maximums will not account for\r\ncases where any edge was traversed twice.Thus, by ascending from vertex\r\nby , we will be able to find the best value of the form , and by adding\r\nto it, we will obtain the distance to the desired vertex.\r\n",
    "name": "G. Sakurako and Chefir",
    "statement": "Given a tree with n vertices rooted at vertex 1. While walking through\r\nit with her cat Chefir, Sakurako got distracted, and Chefir ran away.To\r\nhelp Sakurako, Kosuke recorded his q guesses. In the i-th guess, he\r\nassumes that Chefir got lost at vertex v_i and had k_i .Also, for each\r\nguess, Kosuke assumes that Chefir could move along the edges an\r\narbitrary number of times: from vertex a to vertex b, if a ^{\r\ntext{ }} of b, the will not change; from vertex a to vertex b, if a of\r\nb, then Chefir’s decreases by 1. If Chefir’s is 0, he cannot make a move\r\nof the second type.For each assumption, your task is to find the\r\ndistance to the farthest vertex that Chefir could reach from vertex v_i,\r\nhaving k_i .^{\r\ntext{ }}Vertex a is an ancestor of vertex b if the shortest path from b\r\nto the root passes through a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/rope> using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx; // /*//                                                //////////**DEFINES - START**////////// #define ret return#define fi first#define se second#define mp make_pair#define all(x) x.begin(), x.end()#define be(x) x.begin()#define en(x) x.end()#define sz(x) ll(x.size())#define for0(i, n) for (ll   i = 0; i < (n); ++i)#define for1(i, n) for (ll   i = 1; i < (n); ++i)#define rfor0(i, n) for (ll   i = (n) - 1; i >= 0; --i)#define rfor1(i, n) for (ll   i = (n) - 1; i >= 1; --i)#define rep(i, a, n) for (ll   i = a; i < ll(n); ++i)#define rrep(i, a, n) for (ll   i = a - 1; i >= ll(n); --i)#define popcount __builtin_popcount#define popcountll __builtin_popcountll#define fastIO() ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);#define con continue#define pb push_back#define pob pop_back#define deb(x) cout << (#x) << \" is \" << (x) << endl#define ins insert#define len(s) (s).length()#define gi greater<int>()#define gll greater<ll  >()#define gstr greater<string>()#define gpll greater<pair<ll  , ll  >>()#define rast(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))#define rev reverse#define ub upper_bound#define lb lower_bound#define bs binary_search#define rs resize#define last(a) a.back()#define co count#define ba(a) a.back()#define um unordered_map#define rsun(a) a.resize(unique(a.begin(), a.end())-a.begin())#define endl '\\n'#ifdef OG_Matveychick1bool local = true;#elsebool local = false;#endif //                                                \\\\\\\\\\\\\\\\\\\\**DEFINES - END**\\\\\\\\\\\\\\\\\\\\// */ // /*//                                                //////////**TYPEDEFS - START**////////// typedef vector<int> vi;typedef vector<vi> vvi;typedef vector<char> vc;typedef pair<int, int> pii;typedef vector<pii> vpii;typedef vector<string> vs;typedef long long ll;typedef unsigned long long ull;typedef vector<ull> vull;typedef pair<ll, ll> pll;typedef vector<ll> vll;typedef vector<pll> vpll;typedef pair<double, double> pdd;typedef double ld;typedef double D;typedef vector<ld> vld;typedef vector<pair<ld, ld>>        vpld;typedef string str;typedef set<ll> sll;typedef set<int> si;typedef set<str> ss;typedef set<pii> spii;typedef multiset<int> msi;typedef multiset<ll> msll;typedef multiset<str> mss;typedef multiset<pii> mspii;typedef multiset<pll> mspll;typedef map<str, str> mps;typedef map<int, int> mpi;typedef map<ll, ll> mpll;typedef map<int, vi> mpvi;typedef map<int, vll> mpvll;typedef map<char, int> mpci;typedef multimap<ll, ll> mmpll;typedef multimap<str, str> mmps;typedef multimap<int, int> mmpi;typedef vector<vector<int>> vvi;typedef vector<vector<ll>> vvll;typedef vector<vector<long double>> vvld;typedef vector<vvi> vvvi;typedef vector<vector<char>> vvc;typedef vector<vs> vvs;typedef vector<D> vD;typedef set<pair<ll, ll>>        spll;typedef pair<ull, ull> pull;typedef vector<pull> vpull;typedef vector<bool> vb;typedef vector<vb> vvb;typedef set<char> sc;typedef queue<int> qi;typedef queue<ll> qll;typedef queue<bool> qb;typedef vector<sll> vsll;typedef queue<pair<ll, ll>>        qpll;typedef vector<vector<pair<int, int>>>        vvpii;typedef vector<vector<pair<ll, ll>>>        vvpll;typedef vector<spll> vspll;typedef multiset<char> msc;typedef queue<str> qs;typedef vector<set<int>> vsi;typedef priority_queue<ll> pqll;typedef vector<vsll> vvsll;typedef pair<ld, ld> pld;typedef vector<vvll> vvvll;typedef set<ld> sld;typedef vector<vpld> vvpld;typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_set;typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>        ordered_multiset; //                                                \\\\\\\\\\\\\\\\\\\\**TYPEDEFS - END**\\\\\\\\\\\\\\\\\\\\// */  // /*//                                                //////////**CONSTANTS - START**////////// constexpr long double pi = 3.141592653589793238462643383279;const ll mod1 = 1e9 + 7;const ll mod2 = 998244353;const ll MAXLL = 9223372036854775807;//const ll MAXINT = 2147483647;const long double eps = 1e-9; //                                                \\\\\\\\\\\\\\\\\\\\**CONSTANTS - END**\\\\\\\\\\\\\\\\\\\\// */  // /*//                                                //////////**TEMPLATES - START**//////////  template<typename T>istream &operator>>(istream &in, vector<T> &a) {    for (T &i : a) in >> i;    return in;} template<typename T1, typename T2>istream &operator>>(istream &in, pair<T1, T2> &a) {    in >> a.fi >> a.se;    return in;} template<typename T1, typename T2>ostream &operator<<(ostream &out, pair<T1, T2> &a) {    out << a.fi << \" \" << a.se;    return out;} template<typename T1, typename T2>istream &operator>>(istream &in, vector<pair<T1, T2>> &a) {    for (        pair<T1, T2> &i            : a)        in >> i.fi >> i.                se;    return            in;} template<typename T>ostream &operator<<(ostream &out, const vector<T> &a) {    for (auto i : a) {        out << i << \" \";    }    return out;} template<typename T1, typename T2>ostream &operator<<(ostream &out, vector<pair<T1, T2>> &a) {    for (        pair<T1, T2> i            : a)        out << i.fi << \" \" << i.se <<            endl;    return            out;} template<typename T1>ostream &operator<<(ostream &out, vector<vector<T1>> &a) {    for (vector<T1> i : a) {        for (T1 j : i) out << j << \" \";        out << endl;    }    return out;} template<typename T1, typename T2>inline T1 min(T1 a, T2 b) {    b = (T1) b;    return a > b ? b : a;} template<typename T1, typename T2>inline T1 max(T1 a, T2 b) {    b = (T1) b;    return a > b ? a : b;} template<typename T1, typename T2>inline void amin(T1 &a, T2 b) {    a = min(a, b);} template<typename T1, typename T2>inline void amax(T1 &a, T2 b) {    a = max(a, b);}  //                                                \\\\\\\\\\\\\\\\\\\\**TEMPLATES - END**\\\\\\\\\\\\\\\\\\\\// */  // This bear is a good alternative to duck!!!/*    ????      ??????  ??????????????????? ????????????????  ??????   ???????????  ??????  ???????????? ?? ??????????????????   ??????????????? ?   ?????????????????   ???????   ???    ??    ????  ??????????     ????     ?? ???   ???????????? ?????  ???????????????????? ????????   ??  ??????? ???????         ????? */  double getTime() {    return clock() / (double) CLOCKS_PER_SEC;}  mt19937_64 rn(chrono::steady_clock::now().time_since_epoch().count());//mt19937_64 rn(4); ll rnd(ll l, ll r) {    ll a = rn() % (r - l + 1) + l;    return a;} void solve(); ll T = 1; signed main(int argc, char **argv) {    setlocale(LC_ALL, \"RUS\");    fastIO()    cout.precision(12);    cout << fixed;    if (local && argc == 1) {        freopen(\"input.txt\", \"r\", stdin);//        freopen(\"002.out\", \"w\", stdout);    }    cin >> T;    while (T--) {        solve();    }    if (local && argc == 1) {        cout << endl << fixed << \"time = \" << getTime();    }    return 0;}  /*    ___        __              __   ______          __        _____ __             __          __  __   /   | _____/ /___  ______ _/ /  / ____/___  ____/ /__     / ___// /_____ ______/ /______   / / / /__  ________  / /| |/ ___/ __/ / / / __ `/ /  / /   / __ \\/ __  / _ \\    \\__ \\/ __/ __ `/ ___/ __/ ___/  / /_/ / _ \\/ ___/ _ \\ / ___ / /__/ /_/ /_/ / /_/ / /  / /___/ /_/ / /_/ /  __/   ___/ / /_/ /_/ / /  / /_(__  )  / __  /  __/ /  /  __//_/  |_\\___/\\__/\\__,_/\\__,_/_/   \\____/\\____/\\__,_/\\___/   /____/\\__/\\__,_/_/   \\__/____/  /_/ /_/\\___/_/   \\___/*/  struct ST {    struct node;    ll n;    vector<node> tree;    vector<node> lazy;     struct node {        ll x;         node() {}         node(ll x) : x(x) {}    };     node neutral = 0;     friend node operator+(node a, node b) {        return max(a.x, b.x);    }     friend void operator%=(node &a, node b) {        a.x += b.x;    }     ST(ll n1) {        n = n1;        tree.resize(4 * n, neutral);        lazy.resize(4 * n, neutral);    }     void update(ll l, ll r, ll val) {        update(1, 0, n, l, r, val);    }     void update(ll pos, ll val) {        update(1, 0, n, pos, val);    }     node query(ll l, ll r) {        return query(1, 0, n, l, r);    }     void update(ll v, ll l, ll r, ll pos, ll val) {        tree[v] %= lazy[v / 2];        lazy[v] %= lazy[v / 2];        if (l > pos || r <= pos) {            return;        }        if (l == r - 1) {            tree[v] %= val;            return;        }        ll m = (l + r) / 2;        update(v * 2, l, m, pos, val);        update(v * 2 + 1, m, r, pos, val);        tree[v] = tree[v * 2] + tree[v * 2 + 1];        lazy[v] = neutral;    }     void update(ll v, ll l, ll r, ll L, ll R, ll val) {        tree[v] %= lazy[v / 2];        lazy[v] %= lazy[v / 2];        if (l >= R || r <= L) {            return;        }        if (l >= L && r <= R) {            tree[v] %= val;            lazy[v] %= val;            return;        }        ll m = (l + r) / 2;        update(v * 2, l, m, L, R, val);        update(v * 2 + 1, m, r, L, R, val);        tree[v] = tree[v * 2] + tree[v * 2 + 1];        lazy[v] = neutral;    }     node query(ll v, ll l, ll r, ll L, ll R) {        tree[v] %= lazy[v / 2];        lazy[v] %= lazy[v / 2];        if (l >= L && r <= R) {            return tree[v];        }        if (l >= R || r <= L) {            return neutral;        }        ll m = (l + r) / 2;        node re = query(v * 2, l, m, L, R) + query(v * 2 + 1, m, r, L, R);        tree[v] = tree[v * 2] + tree[v * 2 + 1];        lazy[v] = neutral;        return re;    }}; void dfs(ll v, ll p, vvll &g, vll &d, vvll &up, vll &s, vll &in, ll &ti, vll &e) {    up[0][v] = p;    e[ti] = v;    in[v] = ti++;    s[v] = 1;    if (v) d[v] = d[p] + 1;    for1(i, 20) up[i][v] = up[i - 1][up[i - 1][v]];    for (auto x : g[v]) {        if (x == p) con;        dfs(x, v, g, d, up, s, in, ti, e);        s[v] += s[x];    }} ll up(ll v, ll k, vvll &up) {    for0(i, 20) {        if ((1 << i) & k) v = up[i][v];    }    ret v;} void dfs(ll v, ll p, vvll &g, vll &in, vll &s, ST &t, vll &ans, vvpll &z, vvll &upp) {    for (auto [k, i] : z[v]) {        ll u = up(v, k, upp);        ans[i] = t.query(in[u], in[u] + s[u]).x;    }    for (auto x : g[v]) {        if (x == p) con;        t.update(0, sz(in), 1);        t.update(in[x], in[x] + s[x], -2);        dfs(x, v, g, in, s, t, ans, z, upp);        t.update(0, sz(in), -1);        t.update(in[x], in[x] + s[x], 2);    }} void solve() {    ll n;    cin >> n;    vvll g(n);    for0(i, n - 1) {        ll u, v;        cin >> u >> v;        u--;        v--;        g[u].pb(v);        g[v].pb(u);    }    vvll up(20, vll(n));    vll d(n), s(n), in(n), eu(n);    ll ti = 0;    dfs(0, 0, g, d, up, s, in, ti, eu);    ST t(n);    for0(i, n) {        t.update(i, d[eu[i]]);    }    vvpll z(n);    ll q;    cin >> q;    for0(i, q) {        ll v, k;        cin >> v >> k;        v--;        z[v].pb({k, i});    }    vll ans(q);    dfs(0, 0, g, in, s, t, ans, z, up);    for0(i, q) cout << ans[i] << ' ';    cout << endl;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Sakurako and Chefir.json",
    "hint": []
}