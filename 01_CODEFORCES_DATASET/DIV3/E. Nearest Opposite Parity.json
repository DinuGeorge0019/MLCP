{
    "link": "https://codeforces.com//contest/1272/problem/E",
    "problemId": "494357",
    "problem_idx": "E",
    "shortId": "1272E",
    "contest_number": "1272",
    "problem_submissions": {
        "E": [
            66703677,
            66698934,
            66711392,
            66720411,
            66715254,
            66696959,
            66695532,
            66698121,
            66701928,
            66701435,
            66706283,
            66705342,
            66707569,
            66707090,
            66777425,
            66705785,
            66709630,
            66710595,
            66706360,
            66711695
        ],
        "F": [
            66702563,
            66716210,
            66716034,
            66713486,
            66720407,
            66730946,
            66745196,
            66899419,
            66710448,
            69815932
        ],
        "B": [
            66692863,
            66686159,
            66691774,
            66706884,
            66714297,
            66683965,
            66685196,
            66684562,
            66686916,
            66692480,
            66696683,
            66688751,
            66692889,
            66696315,
            66685266,
            66695654,
            66691545,
            66689056,
            66687119,
            66686340
        ],
        "C": [
            66687313,
            66688012,
            66695426,
            66689433,
            66689685,
            66685389,
            66686891,
            66686385,
            66687940,
            66685597,
            66690881,
            66692609,
            66686241,
            66688395,
            66686850,
            66686864,
            66686923,
            66691687,
            66689532,
            66689140
        ],
        "D": [
            66683330,
            66692291,
            66701690,
            66697025,
            66695475,
            66689729,
            66689439,
            66688995,
            66691097,
            66696361,
            66685375,
            66696190,
            66695912,
            66691534,
            66688277,
            66700728,
            66696238,
            66694893,
            66695943,
            66703253
        ],
        "A": [
            66683267,
            66683040,
            66685123,
            66683649,
            66682741,
            66682439,
            66682629,
            66682714,
            66683716,
            66683148,
            66683049,
            66683308,
            66683216,
            66682971,
            66682692,
            66683012,
            66683163,
            66683636,
            66683990,
            66682789
        ]
    },
    "name": "E. Nearest Opposite Parity",
    "statement": "You are given an array a consisting of n integers. In one move, you can\r\njump from the position i to the position i - a_i (if 1\r\nle i - a_i) or to the position i + a_i (if i + a_i\r\nle n).For each position i from 1 to n you want to know the minimum the\r\nnumber of moves required to reach any position j such that a_j has the\r\nopposite parity from a_i (i.e. if a_i is odd then a_j has to be even and\r\nvice versa).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define fs first\n#define sc second\n\ntypedef pair <int, int> II;\nconst int N = 2E5 + 10;\n\nint n, a[N];\nint d[N][2];\nvector <int> adj[N];\n\nvoid Read_Input() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        if (i - a[i] >= 1) adj[i - a[i]].push_back(i);\n        if (i + a[i] <= n) adj[i + a[i]].push_back(i);\n        if (a[i] & 1) adj[n + 1].push_back(i);\n            else adj[n + 2].push_back(i);\n    }\n    adj[0].push_back(n + 1);\n    adj[0].push_back(n + 2);\n}\n\nvoid BFS() {\n    queue <II> Q;\n    Q.push({n + 1, 1});\n    Q.push({n + 2, 0});\n    d[n + 1][1] = d[n + 2][0] = 1;\n    while (Q.size()) {\n        int u = Q.front().fs;\n        int flag = Q.front().sc;\n        Q.pop();\n        for (int v : adj[u]) {\n            if (d[v][flag]) continue;\n            d[v][flag] = d[u][flag] + 1;\n            Q.push(II(v, flag));\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        if (d[i][!(a[i] & 1)]) printf(\"%d \", d[i][!(a[i] & 1)] - 2);\n            else printf(\"-1 \");\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    Read_Input();\n    BFS();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Nearest Opposite Parity.json",
    "editorial_link": "https://codeforces.com//blog/entry/72132",
    "editorial": "In this problem, we have directed graph consisting of vertices (indices\r\nof the array) and at most edges. Some vertices have the value , some\r\nhave the value . Our problem is to find for every vertex the nearest\r\nvertex having the opposite parity. Let\u00e2\u0080\u0099s try to solve the problem for\r\nodd numbers and then just run the same algorithm with even numbers.We\r\nhave multiple odd vertices and we need to find the nearest even vertex\r\nfor each of these vertices. This problem can be solved with the standard\r\nand simple but pretty idea. Let\u00e2\u0080\u0099s inverse our graph and run a\r\nmulti-source breadth-first search from all even vertices. The only\r\ndifference between standard bfs and multi-source bfs is that the second\r\none have many vertices at the first step (vertices having zero\r\ndistance).Now we can notice that because of bfs every odd vertex of our\r\ngraph has the distance equal to the minimum distance to some even vertex\r\nin the initial graph. This is exactly what we need. Then just run the\r\nsame algorithm for even numbers and print the answer.Time complexity: .\r\n"
}