{
    "link": "https://codeforces.com//contest/1980/problem/D",
    "problemId": "2679076",
    "problem_idx": "D",
    "shortId": "1980D",
    "contest_number": "1980",
    "problem_submissions": {
        "F2": [
            264034665,
            264025304,
            264247676,
            264019993,
            264024427,
            264029852,
            264023188,
            264027216,
            297729485,
            297729442,
            297728361,
            297728328
        ],
        "G": [
            264011385,
            263992122,
            268025366,
            264215525,
            264011872,
            264084430,
            264264232,
            264263765,
            264069123,
            264079559,
            264078668
        ],
        "F1": [
            263976190,
            263977123,
            263986480,
            263993424,
            264008757,
            263990594,
            264002101,
            263997926,
            264028649,
            263987133,
            263983649,
            263982394,
            264008279,
            263992416,
            264001050,
            263982241,
            263973003,
            297724971,
            263994302,
            263989092,
            263991078
        ],
        "E": [
            263949022,
            263952956,
            263961437,
            263972191,
            263952206,
            263972111,
            263965559,
            263972356,
            263979958,
            263960816,
            263958713,
            263958124,
            263952216,
            263968394,
            263952644,
            263960173,
            263957033,
            263960055,
            263959465,
            263968735
        ],
        "D": [
            263937338,
            263941014,
            263940806,
            263951978,
            263959721,
            263955612,
            263952654,
            263955258,
            263970236,
            263929153,
            263938177,
            263937870,
            263931692,
            263943850,
            263942483,
            263952145,
            263949853,
            263944438,
            263947463,
            263956473
        ],
        "C": [
            263918738,
            263918609,
            263924884,
            263925019,
            263927010,
            263934895,
            263950793,
            263933470,
            263946468,
            263911344,
            263918263,
            263919725,
            263911878,
            263921063,
            263925590,
            263921654,
            263927275,
            263926350,
            263931913,
            263931664
        ],
        "B": [
            263905986,
            263904943,
            263911595,
            263912040,
            263903286,
            263919041,
            263916463,
            263913479,
            263919564,
            263901644,
            263907263,
            263909074,
            263903306,
            263904343,
            263907275,
            263910981,
            263913905,
            263915385,
            263916132,
            263900094
        ],
        "A": [
            263898827,
            263896737,
            263896710,
            263899946,
            263896564,
            263900183,
            263902852,
            263902771,
            263905894,
            263896600,
            263896618,
            263897271,
            263897395,
            263896553,
            263899202,
            263896419,
            263897066,
            263897350,
            263900369,
            263899316,
            263897377
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130135",
    "editorial": "Letâs loop through the initial array , counting the GCD of neighbouring\r\nelements. If at some point, the GCD of the previous pair becomes greater\r\nthan the GCD of the next pair, we remember the index of the first\r\nelement of the pair that gave the greater GCD and stop the loop.Then\r\nconsider the following cases: the sequence of GCDs for array was already\r\nnon-decreasing. Then it is enough to remove the last element from it,\r\nthe previous elements of the GCD-sequence will not be affected. The\r\nanswer in this case is always . some element has been found such that .\r\nThen, since there is already at least one place in the original\r\nGCD-sequence where it ceases to be non-decreasing, we can try to fix it\r\nby removing the -th, -th or -th element from the array . Letâs create\r\nnew arrays of length , and in each of them remove one of the above\r\nelements. If at least one of these arrays has a non-decreasing\r\nGCD-sequence the answer is , otherwise .\r\n",
    "name": "D. GCD-sequence",
    "statement": "(Greatest Common Divisor) of two integers x and y is the maximum integer\r\nz by which both x and y are divisible. For example, GCD(36, 48) = 12,\r\nGCD(5, 10) = 5, and GCD(7,11) = 1.Kristina has an array a consisting of\r\nexactly n positive integers. She wants to count the GCD of each\r\nneighbouring pair of numbers to get a new array b, called . So, the\r\nelements of the GCD-sequence b will be calculated using the formula b_i\r\n= GCD(a_i, a_{i + 1}) for 1\r\nle i\r\nle n - 1.Determine whether it is possible to remove number from the\r\narray a so that the GCD sequence b is non-decreasing (i.e., b_i\r\nle b_{i+1} is always true).For example, let Khristina had an array a =\r\n[20, 6, 12, 3, 48, 36]. If she removes a_4 = 3 from it and counts the\r\nGCD-sequence of b, she gets: b_1 = GCD(20, 6) = 2 b_2 = GCD(6, 12) = 6\r\nb_3 = GCD(12, 48) = 12 b_4 = GCD(48, 36) = 12 The resulting GCD sequence\r\nb = [2,6,12,12] is non-decreasing because b_1\r\nle b_2\r\nle b_3\r\nle b_4.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n; cin >> n;        vector<int> a(n);        for (int &x: a) cin >> x;        vector<int> pre(n), suf(n), val(n - 1);        for (int i = 0; i + 1 < n; i++) {            val[i] = gcd(a[i], a[i + 1]);        }        pre[0] = 1;        for (int i = 1; i < n; i++) {            pre[i] = pre[i - 1] & (i - 2 < 0 || val[i - 1] >= val[i - 2]);        }        suf[n - 1] = 1;        for (int i = n - 2; i >= 0; i--) {            suf[i] = suf[i + 1] & (i + 1 >= n - 1 || val[i] <= val[i + 1]);        }        bool ans = pre[n - 2] || suf[1];        for (int i = 1; i + 1 < n; i++) {            int v = gcd(a[i - 1], a[i + 1]);            ans |= pre[i - 1] && suf[i + 1] && (i - 2 < 0 || val[i - 2] <= v) && (i + 1 >= n - 1 || v <= val[i + 1]);        }        cout << (ans ? \"YES\" : \"NO\") << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. GCD-sequence.json",
    "hint": []
}