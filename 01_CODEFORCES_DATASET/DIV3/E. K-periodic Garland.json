{
    "link": "https://codeforces.com//contest/1353/problem/E",
    "problemId": "620791",
    "problem_idx": "E",
    "shortId": "1353E",
    "contest_number": "1353",
    "problem_submissions": {
        "F": [
            80124393,
            80127683,
            80140343,
            80142966,
            80146411,
            80141780,
            80117292,
            80132406,
            80185189,
            80188504
        ],
        "E": [
            80114098,
            80117275,
            80128499,
            80145539,
            80125005,
            80139306,
            80127975,
            80135984,
            80130531,
            80129427,
            80125620,
            80129245,
            80158858,
            80112124,
            80126450,
            80133527,
            80128884,
            80134345,
            80129651,
            80135076
        ],
        "D": [
            80098108,
            80101755,
            80118374,
            80103972,
            80115994,
            80127815,
            80131082,
            80141865,
            80110266,
            80114346,
            80114023,
            80103850,
            80129182,
            80108992,
            80109025,
            80113948,
            80117006,
            80117268,
            80113177
        ],
        "C": [
            80084355,
            80086625,
            80089665,
            80090748,
            80109095,
            80123682,
            80137480,
            80143026,
            80095516,
            80096983,
            80101362,
            80092320,
            80098872,
            80100063,
            80094720,
            80102804,
            80094807,
            80099168,
            80099321
        ],
        "B": [
            80081560,
            80083037,
            80082947,
            80084540,
            80089013,
            80114962,
            80133140,
            80144863,
            80085266,
            80084702,
            80090165,
            80084822,
            80087571,
            80083864,
            80085636,
            80092945,
            80088539,
            80086038,
            80088726
        ],
        "A": [
            80079491,
            80079524,
            80080015,
            80080262,
            80083439,
            80109672,
            80135612,
            80143748,
            80080163,
            80079971,
            80082828,
            217548820,
            80080548,
            80081468,
            80091988,
            80079985,
            80084451,
            80081999,
            80081124,
            80083012
        ]
    },
    "name": "E. K-periodic Garland",
    "statement": "You are given a garland consisting of n lamps. States of the lamps are\r\nrepresented by the string s of length n. The i-th character of the\r\nstring s_i equals ” if the i-th lamp is turned off or ” if the i-th lamp\r\nis turned on. You are also given a positive integer k.In one move, you\r\ncan choose and change its state (i.e. turn it on if it is turned off and\r\nvice versa).The garland is called k-periodic if the distance between is\r\nk. Consider the case k=3. Then garlands \"\", \"\", \"\" and \"\" are good but\r\ngarlands \"\", \"\" and \"\" are not. Note that , i.e. the first turned on\r\nlamp is not going after the last turned on lamp and vice versa.Your task\r\nis to find the number of moves you need to make to obtain k-periodic\r\ngarland from the given one.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,k;\n           cin>>a>>k;\n           string s;\n           \n           vector <int> col(k); \n           vector <int> sum(k);\n           vector <vector<int>> kek(k); \n           for (int i=0;i<a;i++) {\n               char t; cin>>t; sum[i%k]+=(t-'0'); col[i%k]++; kek[i%k].push_back(t-'0');  \n           }\n           //cout<<sum1<<\"\"\n           int min1=1000000000;\n           int sum1=0;\n           for (int i=0;i<k;i++) sum1+=sum[i]; \n           for (int i=0;i<k;i++) {\n               int cur=sum1; cur-=sum[i]; \n               int kek1=sum[i];\n               int lol=0;\n               \n               vector <pair<int,int>> pref1(kek[i].size()+1);\n               for (int j=0;j<kek[i].size();j++) {\n                   if (j==0) {pref1[j]={0,0}; } else pref1[j]=pref1[j-1]; \n                   if (kek[i][j]==0) pref1[j].first++; else pref1[j].second++;\n                   kek1=min(kek1,sum[i]+pref1[j].first-pref1[j].second-lol); \n                   lol=max(lol,-pref1[j].second+pref1[j].first); \n               }\n               min1=min(min1,cur+kek1); \n           }\n           cout<<min1<<\"\\n\"; \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. K-periodic Garland.json",
    "editorial_link": "https://codeforces.com//blog/entry/77373",
    "editorial": "Let be the string containing all characters of that have indices and so\r\non (i.e. all such positions that have the remainder modulo ). Suppose we\r\nchoose that all turned on lamps will have remainder modulo . Then we\r\nneed to remove all ones at the positions that do not belong to this\r\nremainder. Also considering the string , we need to spend the number of\r\nmoves to make this string of kind \"contiguous block of zeros, contiguous\r\nblock of ones and again contiguous block of zeros\", because considering\r\nthe characters modulo will lead us to exactly this pattern (notice that\r\nsome blocks can be empty).How to calculate the answer for the string in\r\nlinear time? Let be the number of moves we need to fix the prefix of\r\ntill the -th character in a way that the -th character of is â. Let be\r\nthe number of ones in on the segment . Notice that we can calculate all\r\nrequired values in linear time using prefix sums. Then we can calculate\r\nas , where is the boolean value of the expression ( if is true and\r\notherwise). Let be the length of . Then the actual answer for the string\r\ncan be calculated as (thus we consider the case when the obtained string\r\ndoesnât contan ones at all and consider each position as the last\r\nposition of some one).So the actual answer can be calculated as .Time\r\ncomplexity: .\r\n",
    "hint": []
}