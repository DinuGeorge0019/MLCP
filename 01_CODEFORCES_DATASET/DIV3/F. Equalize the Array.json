{
    "link": "https://codeforces.com//contest/1490/problem/F",
    "problemId": "898528",
    "problem_idx": "F",
    "shortId": "1490F",
    "contest_number": "1490",
    "problem_submissions": {
        "G": [
            107575670,
            107570582,
            107580395,
            107578386,
            107578722,
            107587817,
            107582372,
            107587644,
            107590224,
            107587234,
            107581021,
            107587494,
            107591578,
            107587278,
            107594584,
            107580527,
            107594840,
            107604479,
            107585353
        ],
        "F": [
            107567259,
            107563218,
            107559121,
            107563180,
            107570162,
            107559715,
            107565176,
            107569965,
            107573956,
            107565331,
            107557975,
            107565094,
            107575477,
            107563453,
            107578839,
            107563945,
            107577436,
            107545806,
            107574260
        ],
        "E": [
            107556406,
            107555209,
            107554466,
            107554504,
            107563766,
            107548069,
            107557392,
            107558375,
            107560045,
            107556903,
            107568704,
            107559054,
            107564526,
            107568622,
            107566562,
            107557990,
            107565929,
            107550803,
            107568788
        ],
        "D": [
            107547185,
            107546416,
            107549582,
            107548987,
            107555867,
            107556006,
            107548279,
            107551082,
            107551588,
            107551655,
            107551977,
            107552563,
            107556439,
            107553824,
            107619966,
            107554583,
            107548604,
            107553073,
            107559705,
            107559541
        ],
        "C": [
            107543774,
            107582544,
            107542780,
            107545198,
            107545514,
            107545604,
            107541435,
            107544848,
            107546219,
            107546179,
            107546602,
            107549060,
            107548247,
            107550636,
            107543227,
            107548011,
            107545321,
            107547310,
            107550641,
            107555122
        ],
        "B": [
            107541208,
            107540999,
            107543105,
            107543215,
            107543363,
            107548411,
            107542386,
            107543350,
            107543787,
            107544607,
            107545190,
            107541258,
            107543035,
            107541260,
            107543659,
            107551661,
            107545377,
            107544997,
            107550231
        ],
        "A": [
            107538772,
            107538836,
            107539535,
            107539200,
            107538915,
            107539471,
            107539499,
            107538905,
            107539830,
            107541268,
            107539601,
            107539113,
            107538995,
            107538895,
            107540166,
            107538768,
            107540499,
            107538751,
            107538933
        ]
    },
    "name": "F. Equalize the Array",
    "statement": "Polycarp was gifted an array a of length n. Polycarp considers an array\r\nbeautiful if there exists a number C, such that each number in the array\r\noccurs either zero or C times. Polycarp wants to remove some elements\r\nfrom the array a to make it beautiful.For example, if n=6 and a = [1, 3,\r\n2, 1, 4, 2], then the following options are possible to make the array a\r\narray beautiful: Polycarp removes elements at positions 2 and 5, array a\r\nbecomes equal to [1, 2, 1, 2]; Polycarp removes elements at positions 1\r\nand 6, array a becomes equal to [3, 2, 1, 4]; Polycarp removes elements\r\nat positions 1, 2 and 6, array a becomes equal to [2, 1, 4]; Help\r\nPolycarp determine the minimum number of elements to remove from the\r\narray a to make it beautiful.\r\n",
    "solutions": [
        "#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint n;\nvector<int> v;\nint arr[200010];\nint prefix[200010];\nint suffix[200010];\n\nint main()\n{\n\tint t;\n\tint i;\n\tint x;\n\tint s, e;\n\tint ans;\n\tint sum;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\tsort(arr, arr + n);\n\n\t\tv.clear();\n\t\tx = 0;\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] != arr[x])\n\t\t\t{\n\t\t\t\tv.push_back(i - x);\n\t\t\t\tx = i;\n\t\t\t}\n\t\t}\n\t\tv.push_back(n - x);\n\n\t\tsort(v.begin(), v.end());\n\n\t\tprefix[0] = v[0];\n\t\tfor (i = 1; i < v.size(); i++)\n\t\t{\n\t\t\tprefix[i] = prefix[i - 1] + v[i];\n\t\t}\n\n\t\tsuffix[v.size()] = 0;\n\t\tfor (i = v.size() - 1; i >= 0; i--)\n\t\t{\n\t\t\tsuffix[i] = suffix[i + 1] + v[i];\n\t\t}\n\n\t\tans = 100000000;\n\t\ts = 0;\n\t\te = 0;\n\t\twhile (e < v.size())\n\t\t{\n\t\t\twhile (e < v.size() && v[e] == v[s]) e++;\n\n\t\t\tif (s == 0) sum = suffix[e] - (v.size() - e) * v[s];\n\t\t\telse sum = prefix[s - 1] + suffix[e] - (v.size() - e) * v[s];\n\n\t\t\tans = min(ans, sum);\n\n\t\t\ts = e;\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Equalize the Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/87874",
    "editorial": "Let\u00e2\u0080\u0099s calculate the value of how many times the number occurs in the\r\narray . We will iterate over the value of and look for the minimum\r\nnumber of moves necessary for each number to appear in the array either\r\ntimes, or times. Note that if there is no such number that , then such a\r\nvalue of will not give the minimum answer (because we have removed\r\nunnecessary elements).Then, for a specific , the answer is calculated as\r\nfollows: Since the number of candidates for the value of is no more than\r\n, this method works in .Then there are two ways to optimize our\r\nsolution: you can consider only unique values of (there are no more than\r\n), and get a solution in ; you can sort the values and use prefix sums,\r\nthis solution works for or for (if you use counting sort).\r\n"
}