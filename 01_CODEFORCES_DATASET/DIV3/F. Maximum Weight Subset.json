{
    "link": "https://codeforces.com//contest/1249/problem/F",
    "problemId": "447565",
    "problem_idx": "F",
    "shortId": "1249F",
    "contest_number": "1249",
    "problem_submissions": {
        "F": [
            63172408,
            63252026,
            63175429,
            63171983,
            63178449,
            63188348,
            63193416,
            63193368,
            63195011,
            69268865
        ],
        "E": [
            63161648,
            63161142,
            63155293,
            63168564,
            63183626,
            63170661,
            63178157,
            63147220,
            63160832,
            63164442,
            63162319,
            63163127,
            63161620,
            63169150,
            63158868,
            63166581,
            63166074,
            63872232,
            63872063,
            63864039,
            63863655,
            63183869,
            63172611
        ],
        "D2": [
            63157164,
            63157031,
            63151986,
            63179972,
            63178191,
            63150473,
            63149837,
            63165541,
            63155673,
            63158427,
            63157157,
            63159529,
            63165621,
            63157444,
            63163488,
            63165452,
            63163182,
            63158691,
            63160450,
            63167522
        ],
        "D1": [
            63157014,
            63157572,
            63148296,
            63180024,
            63178362,
            63150834,
            63150131,
            63159542,
            63156407,
            63158897,
            63156756,
            63159058,
            63165817,
            63157707,
            63163278,
            63165731,
            63163213,
            63159437,
            63160306,
            63162853
        ],
        "C2": [
            63144475,
            63148997,
            63163130,
            63147539,
            63156437,
            63140409,
            63142875,
            63141970,
            63143625,
            63146079,
            63146725,
            63146760,
            63166472,
            63142727,
            63151593,
            63150401,
            63148432,
            63146539,
            63148575
        ],
        "C1": [
            63144104,
            63149133,
            63151950,
            63147674,
            63156193,
            63140555,
            63142796,
            63141766,
            63143828,
            63146316,
            63145140,
            63146724,
            63147005,
            63140832,
            63152061,
            63150521,
            63148664,
            63146426,
            63148088
        ],
        "B2": [
            63138088,
            63140116,
            63145913,
            63136980,
            63145234,
            63136187,
            63136343,
            63136067,
            63136970,
            63136377,
            63140760,
            63137463,
            63136041,
            63138033,
            63138460,
            63138534,
            63142142,
            63140081,
            63199621,
            63137990
        ],
        "B1": [
            63136823,
            63140317,
            63145977,
            63137191,
            63138074,
            63136366,
            63134489,
            63135842,
            63137199,
            63136571,
            63138205,
            63137333,
            63136186,
            63137901,
            63138608,
            63138272,
            63140900,
            63139910,
            63137719
        ],
        "A": [
            63132494,
            63132712,
            63139517,
            63133327,
            63134818,
            63132878,
            63132304,
            63132430,
            63132570,
            63132479,
            63135293,
            63133449,
            63132465,
            63133181,
            63133050,
            63132876,
            63135189,
            63133242,
            63132357
        ]
    },
    "name": "F. Maximum Weight Subset",
    "statement": "You are given a tree, which consists of n vertices. Recall that a tree\r\nis a connected undirected graph without cycles. Vertices are numbered\r\nfrom 1 to n. All vertices have weights, the weight of the vertex v is\r\na_v.Recall that the distance between two vertices in the tree is the\r\nnumber of edges on a simple path between them.Your task is to find the\r\nsubset of vertices with the maximum total weight (the weight of the\r\nsubset is the sum of weights of all vertices in it) such that there is\r\nno pair of vertices with the distance k or less between them in this\r\nsubset.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<'0'||c>'9');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>='0'&&c<='9');\n\treturn res;\n}\nint a[210], dp[210][210], vis[210];\nvector<int> edge[210], son[210];\nint N=read(), K=read();\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto i:edge[x])if(!vis[i]){\n\t\tson[x].push_back(i);\n\t\tdfs(i);\n\t}\n\tdp[x][0]=a[x];\n\tfor(auto j:son[x]){\n\t\tdp[x][0]+=dp[j][K];\n\t}\n\tfor(int i=1; i<=K; i++){\n\t\tif(i+i<=K){\n\t\t\tint ma = 0;\n\t\t\tfor(int j = 0; j < son[x].size(); j++){\n\t\t\t\tint now = dp[son[x][j]][i-1];\n\t\t\t\tfor(int k = 0; k <son[x].size(); k++)if(k!=j){\n\t\t\t\t\tnow += dp[son[x][k]][K-i];\n\t\t\t\t}\n\t\t\t\tma = max(ma, now);\n\t\t\t}\n\t\t\tdp[x][i] = ma;\n\t\t}\n\t\telse{\n\t\t\tfor(auto j:son[x]){\n\t\t\t\tdp[x][i]+=dp[j][i-1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<N; i++){\n\t\tdp[x][i]=max(dp[x][i], dp[x][i+1]);\n\t}\n}\nint main() {\n\tfor(int i=1; i<=N; i++){\n\t\ta[i]=read();\n\t}\n\tfor(int i=1; i<N; i++){\n\t\tint a=read(), b=read();\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tdfs(1);\n\tint ans = 0;\n\t//for(int i=1; i<=N; i++){\n\t//\tfor(int j=0; j<=K; j++){\n\t//\t\tprintf(\"%d%c\", dp[i][j], j==K?'\\n':' ');\n\t//\t}\n\t//}\n\tfor(int i=0; i<=K; i++){\n\t\tans = max(ans, dp[1][i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Maximum Weight Subset.json",
    "editorial_link": "https://codeforces.com//blog/entry/70779",
    "editorial": "Letâs solve this problem using dynamic programming on a tree. Suppose\r\nthe tree is rooted and the root of the tree is . Also, letâs increase to\r\nfind the subset in which any pair of vertices had distance or greater\r\ninstead of or greater.Let be the maximum total weight of the subset in\r\nthe subtree of if the vertex with the minimum depth we took has depth .\r\nThen the answer is .Firstly, letâs calculate this dynamic programming\r\nfor all children of . Then we are ready to calculate all for all from to\r\n.Let the current depth be , then there are two cases: if then .\r\nOtherwise, letâs iterate over all children of and let be such child of\r\nthat the vertex with the minimum depth we took is in the subtree of .\r\nThen .After we calculated all values of for the vertex , we can notice\r\nthat this is not what we wanted. The current value of means the maximum\r\ntotal weight of the subset in the subtree of if the vertex with the\r\nminimum depth we took has depth . To fix this, letâs push to for all\r\ndepths from to .Time complexity: but it can be easily optimized to using\r\nsome prefix and suffix maximums.You can ask, why this is but not because\r\nwe iterating over all vertices, then over all possible depths, and then\r\nover children of the vertex, and again over children of the vertex. But\r\nin fact, this is because if we change the order of multiplication, we\r\ncan see that we are iterating over pairs (parent, child), then over\r\nchildren and possible depths, and the number of such pairs is , so the\r\ncomplexity is .\r\n",
    "hint": []
}