{
    "link": "https://codeforces.com//contest/1385/problem/F",
    "problemId": "675203",
    "problem_idx": "F",
    "shortId": "1385F",
    "contest_number": "1385",
    "problem_submissions": {
        "G": [
            87146925,
            87130516,
            87130073,
            87149307,
            87139436,
            87145109,
            87113469,
            87137001,
            87178119,
            87121112
        ],
        "F": [
            87133863,
            87148212,
            87150419,
            87133069,
            87155521,
            87156261,
            87129136,
            87201006,
            87199143,
            87198211,
            87198141,
            87197991,
            87133163,
            87135084,
            87147650,
            87153475,
            87157087,
            87159161,
            87143942,
            87140750,
            87158980
        ],
        "E": [
            87121743,
            87094311,
            87150777,
            87112227,
            87117131,
            87137692,
            87154530,
            87109484,
            87118031,
            87151551,
            87126695,
            87130754,
            87122234,
            87145112,
            87156780,
            87154434,
            87141435,
            87122925,
            87129785
        ],
        "D": [
            87114357,
            87136398,
            87136307,
            87098537,
            87103655,
            87133732,
            87148068,
            87097110,
            87107447,
            87106449,
            87137139,
            87106363,
            87103887,
            87118780,
            87124754,
            87090612,
            87122982,
            87110063,
            87101408,
            87100549
        ],
        "C": [
            87087119,
            87083714,
            87087183,
            87094082,
            87125584,
            87140844,
            87089726,
            87089545,
            87092040,
            87111442,
            87085820,
            87088762,
            87103769,
            87110798,
            87107696,
            87084280,
            87087235,
            87089175,
            87090633
        ],
        "B": [
            87082211,
            87084609,
            87082372,
            87086099,
            87118271,
            87134332,
            87085669,
            87082094,
            87085708,
            87097473,
            87081944,
            87080519,
            87090484,
            87088911,
            87082077,
            87081415,
            87081680,
            87080910,
            87083097
        ],
        "A": [
            87080978,
            87081308,
            87080529,
            87081521,
            87116439,
            87133004,
            87083295,
            87081194,
            87080773,
            87082296,
            87080859,
            87090051,
            87086698,
            87082297,
            87102822,
            87093275,
            87080753,
            87080503,
            87081225
        ]
    },
    "name": "F. Removing Leaves",
    "statement": "You are given a tree (connected graph without cycles) consisting of n\r\nvertices. The tree is unrooted it is just a connected undirected graph\r\nwithout cycles.In one move, you can choose exactly k leaves (leaf is\r\nsuch a vertex that is connected to only one another vertex) connected\r\nand remove them with edges incident to them. I.e. you choose such leaves\r\nu_1, u_2,\r\ndots, u_k that there are edges (u_1, v), (u_2, v),\r\ndots, (u_k, v) and remove these leaves and these edges.Your task is to\r\nfind the number of moves you can perform if you remove leaves\r\noptimally.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200010;\n\nint t, n, k, nei[N];\nbitset <N> leaf, out;\nvector <int> g[N], adj[N];\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 1; i <= n; ++i) {\n      g[i].clear(), adj[i].clear();\n      leaf[i] = out[i] = 0;\n    }\n    for (int i = 1, u, v; i < n; ++i) {\n      scanf(\"%d %d\", &u, &v);\n      g[u].emplace_back(v), g[v].emplace_back(u);\n    }\n    if (k == 1) {\n      printf(\"%d\\n\", n - 1);\n      continue;\n    }\n    for (int i = 1; i <= n; ++i) {\n      if (g[i].size() == 1) leaf[i] = 1; \n    }\n    for (int i = 1; i <= n; ++i) {\n      nei[i] = g[i].size();\n      for (int j : g[i]) if (leaf[j]) {\n        adj[i].emplace_back(j);\n      }\n    }\n    set <pair <int, int>> st;\n    for (int i = 1; i <= n; ++i) {\n      if (!leaf[i]) st.emplace(-adj[i].size(), i);\n    }\n    int ans = 0;\n    while (!st.empty()) {\n      int u = st.begin() -> second;\n      st.erase(st.begin());\n      if (adj[u].size() < k) break;\n      while (adj[u].size() >= k) {\n        ++ans;\n        for (int i = 0; i < k; ++i) {\n          int v = adj[u].back(); \n          adj[u].pop_back();\n          out[v] = 1, --nei[u];\n        }\n      }\n      if (nei[u] == 1) {\n        for (int v : g[u]) if (!out[v]) {\n          st.erase(make_pair(-adj[v].size(), v));\n          adj[v].emplace_back(u);\n          st.emplace(-adj[v].size(), v);\n        }\n      } else {\n        st.emplace(-adj[u].size(), u);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Removing Leaves.json",
    "editorial_link": "https://codeforces.com//blog/entry/80257",
    "editorial": "This is mostly implementation problem. We can notice that all leaves are\r\nindistinguishable for us. So if we have some vertex with at least leaves\r\nattached to it, we can choose it, remove these leaves from the tree and\r\ncontinue the algorithm. The rest is just an implementation: let\u00e2\u0080\u0099s\r\nmaintain for each vertex the list of all leaves which are connected to\r\nit and the set of vertices which is sorted by the size of . So let\u00e2\u0080\u0099s\r\ntake any vertex which Is connected with at least leaves (we can just\r\ntake the vertex with the maximum value in the set) and remove any leaves\r\nattached to it. If it has zero leaves after the current move, let\u00e2\u0080\u0099s mark\r\nis as a leaf and append it to the list of the corresponding vertex (you\r\nalso need to remove edges from the graph fast to find the required\r\nvertex, so you may need to maintain the graph as the list of sets). And\r\ndon\u00e2\u0080\u0099t forget about the case because it may be special for your solution\r\nso you could handle it in a special way.Time complexity: .\r\n"
}