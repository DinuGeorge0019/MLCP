{
    "link": "https://codeforces.com//contest/1108/problem/F",
    "problemId": "286773",
    "problem_idx": "F",
    "shortId": "1108F",
    "contest_number": "1108",
    "problem_submissions": {
        "F": [
            48844825,
            48862163,
            48848324,
            48848130,
            48852294,
            48850212,
            48838457,
            48838256,
            48836252,
            48909101,
            48845595,
            48850104,
            48843426,
            48844816,
            48883602
        ],
        "E1": [
            48835917,
            48840618,
            48808903,
            48835183,
            48832250,
            48823205,
            48832522,
            48828568,
            48833167,
            48832156,
            48841738,
            48836232,
            48828690,
            48847940,
            48835833,
            48836036,
            48834638,
            48838866,
            48844104
        ],
        "E2": [
            48835709,
            48844109,
            48822818,
            48835022,
            48838613,
            48845982,
            48955072,
            48856736,
            48884776,
            48838175,
            48842079,
            48839961,
            48846288,
            48846487,
            48844520,
            48843523
        ],
        "D": [
            48819956,
            48826572,
            48809346,
            48824842,
            48817280,
            48817540,
            48824822,
            48819948,
            48824552,
            48909120,
            48824055,
            48812013,
            48824784,
            48817759,
            48822110,
            48828365,
            48827975,
            48821821,
            48832316,
            48824776
        ],
        "C": [
            48816726,
            48823616,
            48805698,
            48816182,
            48814495,
            48812589,
            48819587,
            48815831,
            48817913,
            48909136,
            48819613,
            48817733,
            48820640,
            48837755,
            48816702,
            48811230,
            48820437,
            48818121,
            48821557,
            48818894
        ],
        "B": [
            48812488,
            48806606,
            48811060,
            48806723,
            48809336,
            48805383,
            48812792,
            48811800,
            48810047,
            48909150,
            48813994,
            48807942,
            48810147,
            48809048,
            48810769,
            48806352,
            48811586,
            48811107,
            48808604,
            48810570
        ],
        "A": [
            48804415,
            48868180,
            48868032,
            48808820,
            48801772,
            48803106,
            48804293,
            48801670,
            48804786,
            48802995,
            48802478,
            48909143,
            48804883,
            48801594,
            48807139,
            48804067,
            48807170,
            48802448,
            48806432,
            48806874,
            48802749,
            48804777
        ]
    },
    "name": "F. MST Unification",
    "statement": "You are given an undirected weighted graph with n vertices and m edges\r\n.The i-th edge is e_i = (u_i, v_i, w_i); the distance between vertices\r\nu_i and v_i along the edge e_i is w_i (1\r\nle w_i). The graph is , i. e. for any pair of vertices, there is at\r\nleast one path between them consisting only of edges of the given\r\ngraph.A minimum spanning tree (MST) in case of weights is a subset of\r\nthe edges of a connected weighted undirected graph that connects all the\r\nvertices together and has minimum total cost among all such subsets\r\n(total cost is the sum of costs of chosen edges).You can modify the\r\ngiven graph. The only operation you can perform is the following:\r\nincrease the weight of some edge by 1. You increase the weight of each\r\nedge multiple (possibly, zero) times.Suppose that the initial MST cost\r\nis k. Your problem is to increase weights of some edges in such a way\r\nthat the cost of MST in the obtained graph remains k, but MST is (it\r\nmeans that there is only one way to choose MST in the obtained\r\ngraph).Your problem is to calculate the number of operations required to\r\ndo it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fn \"test\"\n#define fn1 \"\"\n\nusing namespace std;\n\nconst int mn = 2 * (int)(1e5) + 10;\nconst int mod = 1 * (int)(1e9) + 7;\nconst int mm = 1 * (int)(1e3) + 10;\nconst int base = 1 * (int)(1e9);\nconst bool aNs = 0;\n\nint tt, ntest = 1;\n\nvoid docfile()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    if (ifstream(fn\".inp\"))\n    {\n        freopen(fn\".inp\", \"r\", stdin);\n        if (!aNs) freopen(fn\".out\", \"w\", stdout);\n\t\telse freopen (fn\".ans\", \"w\", stdout);\n    }else if (ifstream(fn1\".inp\"))\n    {\n        freopen(fn1\".inp\", \"r\", stdin);\n        freopen(fn1\".out\", \"w\", stdout);\n    }\n}\n\ntemplate <typename T>\nvoid read(T& x)\n{\n    x = 0; T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = ch == '-' ? - f : f, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    x *= f;\n}\n\ntemplate <typename T>\nvoid write (T a)\n{\n    if (a < 0)\n    {\n        putchar ('-');\n        write (-a);\n        return;\n    }\n    if (a < 10)\n    {\n        putchar ('0' + a);\n        return;\n    }\n    write (a / 10);\n    putchar ((char)('0' + (a % 10)));\n}\n\nint h[mn];\nbool ok[mn];\nvector<pair<int, int> > e[mn];\npair<int, int> lca[mn][19];\nint n;\n\nvoid Dfs (int u, int w)\n{\n    for (auto v : e[u])\n    if (v.first != w)\n    {\n        lca[v.first][0] = {u, v.second};\n        h[v.first] = h[u] + 1;\n        Dfs (v.first, u);\n    }\n}\n\nvoid InitLca()\n{\n    for (int i = 1; i <= 17; ++ i)\n    for (int u = 1; u <= n; ++ u)\n    {\n        lca[u][i].first = lca[lca[u][i - 1].first][i - 1].first;\n        lca[u][i].second = max (lca[u][i - 1].second, lca[lca[u][i - 1].first][i - 1].second);\n    }\n}\n\nint Lca (int u, int v)\n{\n    if (h[u] < h[v]) swap (u, v);\n    int mi = INT_MIN;\n    for (int i = 17; i >= 0; -- i)\n    if (h[lca[u][i].first] >= h[v])\n    {\n        mi = max (mi, lca[u][i].second);\n        u = lca[u][i].first;\n    }\n    if (u == v) return mi;\n    for (int i = 17; i >= 0; -- i)\n    if (lca[u][i].first != lca[v][i].first)\n    {\n        mi = max (mi, lca[u][i].second);\n        mi = max (mi, lca[v][i].second);\n        u = lca[u][i].first;\n        v = lca[v][i].first;\n    }\n    mi = max (mi, lca[u][0].second);\n    mi = max (mi, lca[v][0].second);\n    return mi;\n}\n\nint u[mn], id[mn], w[mn], v[mn], fa[mn];\n\nint Fa (int n)\n{\n    return (fa[n] < 0 ? n : fa[n] = Fa (fa[n]));\n}\n\nbool Uni (int u, int v)\n{\n    u = Fa (u); v = Fa (v);\n    if (u == v) return 0;\n    if (fa[u] > fa[v]) swap (u, v);\n    fa[u] += fa[v];\n    fa[v] = u;\n    return 1;\n}\n\nvoid enter()\n{\n    int m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++ i)\n    fa[i] = - 1;\n    for (int i = 0; i < m; ++ i)\n    {\n        cin >> u[i] >> v[i] >> w[i];\n        id[i] = i;\n    }\n    sort (id, id + m, [](int i, int j)\n         {\n              return w[i] < w[j];\n         });\n    for (int i = 0; i < m; ++ i)\n    {\n        int j = id[i];\n        if (Uni (u[j], v[j]))\n        {\n            ok[j] = 1;\n            e[u[j]].emplace_back(v[j], w[j]);\n            e[v[j]].emplace_back(u[j], w[j]);\n        }\n    }\n    h[1] = 1;\n    Dfs (1, 0);\n    InitLca();\n    int sol = 0;\n    for (int i = 0; i < m; ++ i)\n    if (!ok[i])\n    {\n        if (Lca (u[i], v[i]) == w[i]) ++ sol;\n    }\n    cout << sol;\n}\n\nvoid solve()\n{\n\n}\n\nvoid print_result()\n{\n\n}\n\nint main()\n{\n    docfile();\n    //cin>>ntest;\n    for (tt = 1; tt <= ntest; ++ tt)\n    {\n        enter();\n        solve();\n        print_result();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. MST Unification.json",
    "editorial_link": "https://codeforces.com//blog/entry/64751",
    "editorial": "The first (and the most straight-forward) approach is to construct MST\r\nwith any suitable algorithm, build LCA with the maximum edge on a path\r\nwith binary lifting technique and then we have to increase the answer\r\nfor each edge such that equals to the maximum edge on a path between and\r\nin MST.The second (and the most pretty and easy to implement) solution\r\nis the improved Kruskal algorithm.Let\u00e2\u0080\u0099s do Kruskal algorithm on the\r\ngiven edges. Sort them, and let\u00e2\u0080\u0099s consider all edges of the same weight\r\nat once. They can be divided into two classes. The first class contains\r\nedges which connect nothing and the second class contains edges which\r\ncan connect something. Let the number of edges of current weight be ,\r\nedges of the current weight of the first class be and edges with of\r\ncurrent weight of the second class be . Okay, we can just skip the first\r\nclass because it will never increase the answer. How to calculate\r\nuseless edges of the second class? Let\u00e2\u0080\u0099s try to merge all components\r\nconnected with edges of the second class. Suppose we make merges. Then\r\nwe have to increase weights of all remaining edges by one. So we add to\r\nthe answer the value and go to the next weight.Why is this right? This\r\nis right because if the edge of the second class cannot connect anything\r\nbecause of the previously considered edges then the maximum on a path\r\nbetween endpoints of this edge equals to this edge weight. So we have to\r\nincrease the weight of this edge by one. If we didn\u00e2\u0080\u0099t do it we would be\r\nable to replace the edge connects these components with our edge. And it\r\nis obvious that this edge is totally useless with the weight increased\r\nby one.Time complexity is because of edges sorting.\r\n"
}