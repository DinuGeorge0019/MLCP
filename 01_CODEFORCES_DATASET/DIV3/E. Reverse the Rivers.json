{
    "link": "https://codeforces.com//contest/2036/problem/E",
    "problemId": "2997672",
    "problem_idx": "E",
    "shortId": "2036E",
    "contest_number": "2036",
    "problem_submissions": {
        "G": [
            289568495,
            289592157,
            289591763,
            289595974,
            289727611,
            290290543
        ],
        "F": [
            289537821,
            289522926,
            289537324,
            289559326,
            289512509,
            289515984,
            289510795,
            289521272,
            289526918,
            289534575,
            289534164,
            289556542,
            289531934,
            289514943,
            289521852,
            289521308,
            289566779,
            289543749,
            289533352
        ],
        "E": [
            289519379,
            289513483,
            289516754,
            289537406,
            289502565,
            289497006,
            289514977,
            289504007,
            289502653,
            289492035,
            289506214,
            289517949,
            289508708,
            289505547,
            289524899,
            289498786,
            289538409,
            289511145,
            289522074,
            289542250
        ],
        "D": [
            289494755,
            289496973,
            289502561,
            289508569,
            289485075,
            289486449,
            289493423,
            289495061,
            289486975,
            289488146,
            289499112,
            289494333,
            289489388,
            289496285,
            289527032,
            289505896,
            289497283,
            289504013,
            289505465
        ],
        "C": [
            289479986,
            289485425,
            289473871,
            289486850,
            289474317,
            289472689,
            289477260,
            289486030,
            289480295,
            289481264,
            289478991,
            289479671,
            289477258,
            289477016,
            289506161,
            289489963,
            289490617,
            289481449,
            289485496
        ],
        "B": [
            289473268,
            289473263,
            289467611,
            289472113,
            289470722,
            289468547,
            289468418,
            289478505,
            289474994,
            289471830,
            289469932,
            289465642,
            289466472,
            289469818,
            289476408,
            289471072,
            289468104,
            289473322,
            289472255
        ],
        "A": [
            289464981,
            289463574,
            289462739,
            289463265,
            289465451,
            289464109,
            289462932,
            289467937,
            289463249,
            289464614,
            289463267,
            289462869,
            289462845,
            289463088,
            289467021,
            289463344,
            289462625,
            289465258,
            289463000
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135849",
    "editorial": "TutorialAfter computing the values of for all countries and regions, we\r\ncan notice that for a fixed region , the values of increase as the index\r\nincreases. This is because the bitwise or operation cannot decrease a\r\nnumber, but only increase or leave it unchanged. Hence, we can use\r\nbinary search to quickly find the country that matches the given\r\nconditions.For each query and for each requirement, if = < , we search\r\nfor the first country where (this will be the first country that does\r\nnot satisfy the condition). If sign = > , we look for the first country\r\nwhere . In both cases, we can use standard binary search to find the\r\nindex. If the checks leave at least one country that satisfies all the\r\nrequirements, we choose the country with the lowest number.Complexity:\r\ncounting values , processing each query using binary search , total .\r\n",
    "name": "E. Reverse the Rivers",
    "statement": "A conspiracy of ancient sages, who decided to redirect rivers for their\r\nown convenience, has put the world on the brink. But before implementing\r\ntheir grand plan, they decided to carefully think through their strategy\r\nthat\u2019s what sages do.There are n countries, each with exactly k regions.\r\nFor the j-th region of the i-th country, they calculated the value\r\na_{i,j}, which reflects the amount of water in it.The sages intend to\r\ncreate channels between the j-th region of the i-th country and the j-th\r\nregion of the (i + 1)-th country for all 1\r\nleq i\r\nleq (n - 1) and for all 1\r\nleq j\r\nleq k. Since all n countries are on a large slope, water flows towards\r\nthe country with the highest number. According to the sages\u2019\r\npredictions, after the channel system is created, the new value of the\r\nj-th region of the i-th country will be b_{i,j} = a_{1,j} | a_{2,j} |\r\n... | a_{i,j}, where | denotes the bitwise \"OR\" operation.After the\r\nredistribution of water, the sages aim to choose the most suitable\r\ncountry for living, so they will send you q queries for\r\nconsideration.Each query will contain m requirements. Each requirement\r\ncontains three parameters: the region number r, the sign o (either \"<\"\r\nor \">\"), and the value c. If o = \"<\", then in the r-th region of the\r\ncountry you choose, the new value must be strictly less than the limit\r\nc, and if o = \">\", it must be strictly greater.In other words, the\r\nchosen country i must satisfy all m requirements. If in the current\r\nrequirement o = \"<\", then it must hold that b_{i,r} < c, and if o = \">\",\r\nthen b_{i,r} > c.In response to each query, you should output a single\r\ninteger the number of the suitable country. If there are multiple such\r\ncountries, output the smallest one. If no such country exists, output\r\n-1.\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;void solve() {\tint n, k, q;\tcin >> n >> k >> q;\tvector<vector<int>> a(n + 1);\tfor (auto &it : a) {\t\tit.resize(k + 1);\t}\tfor (int i = 1; i <= n; i++) {\t\tfor (int j = 1; j <= k; j++) {\t\t\tcin >> a[i][j];\t\t\ta[i][j] |= a[i - 1][j];\t\t}\t}\twhile (q--) {\t\tint u;\t\tcin >> u;\t\tint cur_l = 1, cur_r = n;\t\tbool ch = true;\t\twhile (u--) {\t\t\tint r;\t\t\tchar o;\t\t\tint c;\t\t\tcin >> r >> o >> c;\t\t\tif (o == '>' && ch) {\t\t\t\tint lll = cur_l, rrr = cur_r, ans = -1;\t\t\t\twhile (lll <= rrr) {\t\t\t\t\tint mid = (lll + rrr) / 2;\t\t\t\t\tif (a[mid][r] > c) {\t\t\t\t\t\tans = mid;\t\t\t\t\t\trrr = mid - 1;\t\t\t\t\t}\t\t\t\t\telse lll = mid + 1;\t\t\t\t}\t\t\t\tif (ans == -1) {\t\t\t\t\tch = false;\t\t\t\t}\t\t\t\telse cur_l = ans;\t\t\t}\t\t\telse if (ch) {\t\t\t\tint lll = cur_l, rrr = cur_r, ans = -1;\t\t\t\twhile (lll <= rrr) {\t\t\t\t\tint mid = (lll + rrr) / 2;\t\t\t\t\tif (a[mid][r] < c) {\t\t\t\t\t\tans = mid;\t\t\t\t\t\tlll = mid + 1;\t\t\t\t\t}\t\t\t\t\telse rrr = mid - 1;\t\t\t\t}\t\t\t\tif (ans == -1) {\t\t\t\t\tch = false;\t\t\t\t}\t\t\t\telse cur_r = ans;\t\t\t}\t\t\t\t}\t\tif (ch) cout << cur_l << \"\\n\";\t\telse cout << -1 << \"\\n\";\t}}int main() {\tint t = 1;\twhile (t--) {\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Reverse the Rivers.json"
}