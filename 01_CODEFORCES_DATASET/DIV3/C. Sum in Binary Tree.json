{
    "link": "https://codeforces.com//contest/1843/problem/C",
    "problemId": "1972492",
    "problem_idx": "C",
    "shortId": "1843C",
    "contest_number": "1843",
    "problem_submissions": {
        "A": [
            210513115,
            210358669,
            210356867,
            210356606,
            210356554,
            210357901,
            210357194,
            210356864,
            210358095,
            210357837,
            210357098,
            210356516,
            210357328,
            210356501,
            210359161,
            210356847,
            210356427,
            210357415,
            210358119,
            210357120,
            210364703
        ],
        "F2": [
            210451991,
            210457207,
            210618819,
            210495074,
            210494100,
            210540752,
            210540669
        ],
        "F1": [
            210414403,
            210417478,
            210396846,
            210409917,
            210412496,
            210409842,
            210422089,
            210412238,
            210413002,
            210417779,
            210416655,
            210416375,
            210514291,
            210424999,
            210427270,
            210422907,
            210427091,
            210425631,
            210535488,
            210532084,
            210419095,
            210422275,
            210416513
        ],
        "E": [
            210391764,
            210391814,
            210384445,
            210387069,
            210389387,
            210395623,
            210390859,
            210397426,
            210401897,
            210395689,
            210473862,
            210401991,
            210402273,
            210403725,
            210394172,
            210401396,
            210403436,
            210400251,
            210398852,
            210406208,
            210398263
        ],
        "D": [
            210377103,
            210378604,
            210375920,
            210374828,
            210376525,
            210379717,
            210379591,
            210382067,
            210379942,
            210382515,
            210378874,
            210376209,
            210374876,
            210386844,
            210381700,
            210376444,
            210371551,
            210381744,
            210386605,
            210381316
        ],
        "C": [
            210369061,
            210367738,
            210368361,
            210366823,
            210368080,
            210359312,
            210366442,
            210374049,
            210371348,
            210364184,
            210365780,
            210367512,
            210366187,
            210360428,
            210370272,
            210365171,
            210363817,
            210370422,
            210368258,
            210373372
        ],
        "B": [
            210363239,
            210368717,
            210361290,
            210360953,
            210362948,
            210369749,
            210362940,
            210364525,
            210363196,
            210375176,
            210362328,
            210363841,
            210361045,
            210364327,
            210364107,
            210360838,
            210360957,
            210367115,
            210363394,
            210370393
        ]
    },
    "name": "C. Sum in Binary Tree",
    "statement": "Vanya really likes math. One day when he was solving another math\r\nproblem, he came up with an interesting tree. This tree is built as\r\nfollows.Initially, the tree has only one vertex with the number 1 the\r\nroot of the tree. Then, Vanya adds two children to it, assigning them\r\nconsecutive numbers 2 and 3, respectively. After that, he will add\r\nchildren to the vertices in increasing order of their numbers, starting\r\nfrom 2, assigning their children the minimum unused indices. As a\r\nresult, Vanya will have an infinite tree with the root in the vertex 1,\r\nwhere each vertex will have exactly two children, and the vertex numbers\r\nwill be arranged sequentially by layers. Vanya wondered what the sum of\r\nthe vertex numbers on the path from the vertex with number 1 to the\r\nvertex with number n in such a tree is equal to. Since Vanya doesnâ€™t\r\nlike counting, he asked you to help him find this sum.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint ans;\nvoid solve()\n{\n\tll n;\tll ans=0;\n\tcin>>n;\n\twhile(n)\n\t{\n\t\tans+=n;\n\t\tn>>=1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "math",
        "trees"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Sum in Binary Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/117468",
    "editorial": "It is easy to notice that the children of the vertex with number have\r\nnumbers and . So, the ancestor of the vertex has the number . Note that\r\nbased on this formula, the size of the path from the root to the vertex\r\nwith number equals . Therefore with given constraints we can write out\r\nthe path to the root explicitly and calculate the sum of vertex numbers\r\non it in .Total complexity: for the test case.\r\n",
    "hint": []
}