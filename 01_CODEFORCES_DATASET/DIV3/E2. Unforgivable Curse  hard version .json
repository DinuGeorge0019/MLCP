{
    "link": "https://codeforces.com//contest/1800/problem/E2",
    "problemId": "1805848",
    "problem_idx": "E2",
    "shortId": "1800E2",
    "contest_number": "1800",
    "problem_submissions": {
        "G": [
            195662820,
            195690940,
            195777313,
            195690603,
            196524855,
            196524658,
            196522076,
            195943836
        ],
        "F": [
            195638235,
            195668644,
            195626028,
            195643554,
            195664067,
            195653332,
            195675061,
            195673007,
            195816880,
            195814809,
            195671424,
            195665257,
            195659551,
            195670175,
            195698092,
            195680883,
            195680676,
            195689427,
            195669351,
            195693466
        ],
        "E2": [
            195612538,
            195639973,
            195612785,
            195633454,
            195608323,
            195629403,
            195623425,
            195629463,
            195626230,
            195629563,
            195651082,
            195630357,
            195636943,
            195619592,
            195639486,
            195641374,
            195638209,
            195651098,
            195639224
        ],
        "E1": [
            195609573,
            195639721,
            195612247,
            195613343,
            195609699,
            195630410,
            195623568,
            195625383,
            195625931,
            195618740,
            195651326,
            195630926,
            195636711,
            195618856,
            195639041,
            195641167,
            195628893,
            195650180,
            195639842
        ],
        "D": [
            195596585,
            195625770,
            195604693,
            195600193,
            195602000,
            195612110,
            195610320,
            195609709,
            195602062,
            195607762,
            195620848,
            195616904,
            195612803,
            195606522,
            195616372,
            195614847,
            195609456,
            195614238,
            195614684
        ],
        "C1": [
            195590954,
            195626345,
            195594910,
            195589947,
            195592829,
            195604029,
            195596848,
            195599696,
            195593933,
            195600094,
            195594609,
            195604030,
            195599932,
            195600191,
            195602733,
            195597615,
            195601757,
            195596127,
            195599897
        ],
        "C2": [
            195590683,
            195596363,
            195594725,
            195589578,
            195592485,
            195603666,
            195596587,
            195600171,
            195594252,
            195601050,
            195594186,
            195603461,
            195599812,
            195600859,
            195603073,
            195597061,
            195601904,
            195595910,
            195599331
        ],
        "A": [
            195587296,
            195585153,
            195582408,
            195584101,
            195582608,
            195583278,
            195583402,
            195582928,
            195582330,
            195583356,
            195582358,
            195587162,
            195585218,
            195584435,
            195584152,
            195585315,
            195585448,
            195583944,
            195583542
        ],
        "B": [
            195584191,
            195590087,
            195587727,
            195584989,
            195586915,
            195590416,
            195592972,
            195589242,
            195592390,
            195586361,
            195594730,
            195594317,
            195594021,
            195589463,
            195590127,
            195591494,
            195591394,
            195590938
        ]
    },
    "name": "E2. Unforgivable Curse  hard version ",
    "statement": "The chief wizard of the Wizengamot once caught the evil wizard Drahyrt,\r\nbut the evil wizard has returned and wants revenge on the chief wizard.\r\nSo he stole s from his student Harry.The is a n-length string of\r\nlowercase Latin letters.Drahyrt wants to replace with an unforgivable\r\ncurse string t.Dragirt, using ancient magic, can swap letters at a\r\ndistance k or k+1 in as many times as he wants. In other words, Drahyrt\r\ncan change letters in positions i and j in s if |i-j|=k or |i-j|=k+1.For\r\nexample, if k = 3, s = \"\" and t = \"\", Drahyrt can act as follows: swap\r\nthe letters at positions 1 and 4 to get \"\". swap the letters at\r\npositions 2 and 6 to get \"\". You are given s and t. Can Drahyrt change s\r\nto t?\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lo; \ntypedef pair< lo,lo > PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define endl \"\\n\"\n#define pb push_back\n#define fio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define FOR for(int i=1;i<=n;i++)\n#define mid ((start+end)/2)\n#define ort ((bas+son)/2)\n\nconst lo inf = 1000000000000000000;\nconst lo KOK = 100000;\nconst lo LOG = 30;\nconst lo li = 200002;\nconst lo mod = 1000000007;\n\nint n,m,k,flag,t,mpp[26][li],git[26][li];\nint cev;\nchar s[li],ss[li];\n\ninline int in(){\n    int x;\n    scanf(\"%d\",&x);\n    return x;\n}\n\nint main(void){\n    t=in();\n    while(t--){\n        n=in();\n        k=in();\n        scanf(\"%s %s\",(s+1),(ss+1));\n        for(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<min(n+1,k);j++){\n\t\t\t\tmpp[i][j]=0;\n\t\t\t\tgit[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tflag=0;\n        FOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[s[i]-'a'][i%k]++;\n\t\t}\n\t\tFOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[ss[i]-'a'][i%k]--;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<min(n+1,k);j++){\n\t\t\t\tmpp[i][j]+=git[i][j];\n\t\t\t\tif(j!=k-1 && n!=k+1){\n\t\t\t\t\tgit[i][j+1]+=mpp[i][j];\n\t\t\t\t\tmpp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(mpp[i][j]){flag=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(flag){printf(\"NO\\n\");}\n\t\telse printf(\"YES\\n\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Unforgivable Curse  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/113477",
    "editorial": "The solution of the problem hints to us that with the help of such\r\noperations, it is possible to move the symbol in the right direction by\r\nusing two operations. Then we can show that among the symbols that we\r\ncan swap with at least one other symbol, we can get any permutation.For\r\nexample, you can apply such a greedy solution: we will build an answer\r\nfrom the boundaries of the string to the middle. Since we can move the\r\nsymbol by a distance of , we can move it to the border and thus we can\r\nbuild any string .Thus, it is enough to check that the sets of\r\ncharacters that can be swapped with some other match. And for the rest\r\nof the characters, check that they just match.\r\n"
}