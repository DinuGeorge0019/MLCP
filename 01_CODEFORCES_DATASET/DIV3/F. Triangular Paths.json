{
    "link": "https://codeforces.com//contest/1506/problem/F",
    "problemId": "935564",
    "problem_idx": "F",
    "shortId": "1506F",
    "contest_number": "1506",
    "problem_submissions": {
        "F": [
            111021020,
            111023335,
            111043050,
            111045078,
            111042675,
            111022888,
            111045702,
            111030029,
            111059327,
            111056314,
            111054328,
            111053665,
            111049676,
            111057223,
            111055499,
            111051574,
            111018539
        ],
        "G": [
            111011051,
            111044191,
            111025676,
            111021333,
            111015838,
            111047466,
            111027389,
            111038444,
            111062619,
            111035705,
            111033084,
            111031458,
            111027898,
            111059943,
            111039951,
            111044272,
            111042579,
            110997057,
            111024212,
            111035025
        ],
        "E": [
            110998219,
            111002639,
            111005993,
            111004597,
            111005673,
            111003655,
            111009629,
            110993653,
            111011522,
            111018659,
            111024774,
            111017525,
            111015924,
            111022569,
            111022716,
            111033942,
            111001920,
            111012071,
            111010852
        ],
        "D": [
            110994014,
            110997858,
            111000907,
            110997329,
            111020775,
            111109278,
            110995630,
            111003898,
            110987445,
            111005061,
            111007314,
            111017748,
            111012182,
            111006395,
            111026211,
            111014600,
            111017473,
            111014918,
            111042008,
            110987093,
            111004976
        ],
        "C": [
            110991700,
            110993760,
            110994821,
            110991557,
            110994969,
            110992631,
            110998527,
            110995536,
            111000015,
            111001144,
            111003685,
            111008122,
            111006904,
            111001766,
            110999236,
            111006625,
            111008840,
            111033710,
            110991249,
            110998250
        ],
        "B": [
            110987614,
            110990504,
            110992033,
            110988684,
            110991376,
            110988565,
            110994317,
            111002159,
            110989417,
            110997996,
            110993594,
            111002185,
            110994767,
            111009342,
            111001911,
            111024800,
            111045128,
            110999737,
            110993374
        ],
        "A": [
            110986181,
            110985860,
            110985761,
            110986354,
            110986698,
            110986290,
            110988038,
            110996610,
            110986006,
            110986393,
            110986025,
            110986629,
            110986586,
            110988619,
            110989257,
            110990207,
            111021247,
            111003988,
            110987775
        ]
    },
    "name": "F. Triangular Paths",
    "statement": "Consider an infinite triangle made up of layers. Let\u2019s number the\r\nlayers, starting from one, from the top of the triangle (from top to\r\nbottom). The k-th layer of the triangle contains k points, numbered from\r\nleft to right. Each point of an infinite triangle is described by a pair\r\nof numbers (r, c) (1\r\nle c\r\nle r), where r is the number of the layer, and c is the number of the\r\npoint in the layer. From each point (r, c) there are two edges to the\r\npoints (r+1, c) and (r+1, c+1), but only one of the edges is activated.\r\nIf r + c is even, then the edge to the point (r+1, c) is activated,\r\notherwise the edge to the point (r+1, c+1) is activated. Look at the\r\npicture for a better understanding. From the point (r_1, c_1) it is\r\npossible to reach the point (r_2, c_2), if there is a path between them\r\nonly from edges. For example, in the picture above, there is a path from\r\n(1, 1) to (3, 2), but there is no path from (2, 1) to (1, 1).Initially,\r\nyou are at the point (1, 1). For each turn, you can: Replace activated\r\nedge for point (r, c). That is if the edge to the point (r+1, c) is\r\nactivated, then , the edge to the point (r+1, c+1) becomes activated,\r\notherwise if the edge to the point (r+1, c+1), then , the edge to the\r\npoint (r+1, c) becomes activated. This action increases the cost of the\r\npath by 1; Move from the current point to another by following the\r\nactivated edge. This action the cost of the path. You are given a\r\nsequence of n points of an infinite triangle (r_1, c_1), (r_2, c_2),\r\nldots, (r_n, c_n). Find the minimum cost path from (1, 1), passing\r\nthrough all n points in order.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\npair <int,int> a[200005];\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i].first;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i].second;\n\t\tsort(a+1,a+n+1);\n\t\tint ans=0;\n\t\ta[0]={1,1};\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif((a[i+1].second-a[i].second)==(a[i+1].first-a[i].first))\n\t\t\t{\n\t\t\t\tif(a[i].first+a[i].second&1) ans+=0;\n\t\t\t\telse ans+=a[i+1].second-a[i].second;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lst=a[i].first-a[i].second,nxt=a[i+1].first-a[i+1].second;\n\t\t\t\tif(lst%2==0) ++lst;\n\t\t\t\tif(nxt%2==0) ++nxt;\n\t\t\t\tans+=(nxt-lst)/2;\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "math",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Triangular Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/89007",
    "editorial": "Since all edges are directed downward, there is only one way to visit\r\nall points is to visit the points in ascending order of the layer\r\nnumber. Let\u00e2\u0080\u0099s sort the points in order of increasing layer.It is easy to\r\nsee that the cost of the entire path is equal to the sum of the cost of\r\npaths between adjacent points. Let\u00e2\u0080\u0099s learn how to calculate the cost of\r\na path between two points and : If , then if is even, then the cost is ,\r\notherwise the cost is ; Otherwise, move the point to and find the cost\r\nof the path with different criteria for the activation of the edges; If\r\nis even then the cost is ; Otherwise, the cost is ;\r\n"
}