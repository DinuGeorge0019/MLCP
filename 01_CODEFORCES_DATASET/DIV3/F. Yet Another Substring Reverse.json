{
    "link": "https://codeforces.com//contest/1234/problem/F",
    "problemId": "426516",
    "problem_idx": "F",
    "shortId": "1234F",
    "contest_number": "1234",
    "problem_submissions": {
        "F": [
            61647149,
            61645384,
            61650555,
            61651870,
            61667991,
            62194838,
            61712119,
            61666405,
            61729878,
            61729799,
            61664234,
            68329269,
            61680222,
            61752962
        ],
        "E": [
            61637715,
            61643598,
            61648539,
            61642595,
            61643656,
            61651547,
            61650480,
            61652692,
            61641203,
            61649142,
            61659878,
            61650257,
            61653772,
            61654963,
            61657548,
            61649045,
            61654746,
            61657468,
            61654998,
            61655416
        ],
        "C": [
            61632575,
            61627606,
            61654578,
            61628592,
            61630466,
            61624366,
            61638436,
            61629236,
            61652967,
            61631133,
            61636961,
            61642219,
            61643521,
            61637365,
            61636499,
            61632963,
            61634943,
            61633612,
            61629926,
            61640840
        ],
        "B1": [
            61622243,
            61619256,
            61623667,
            61618942,
            61620065,
            61620401,
            61621233,
            61618288,
            61620321,
            61625306,
            61621149,
            61623370,
            61622245,
            61622135,
            61620954,
            61622191,
            61621982,
            61619236,
            61622554,
            61619031
        ],
        "B2": [
            61622177,
            61619354,
            61626675,
            61618859,
            61617735,
            61620174,
            61619049,
            61620082,
            61618293,
            61625056,
            61620210,
            61624129,
            61619541,
            61622218,
            61620837,
            61628084,
            61621947,
            61619088,
            61624726,
            61619187
        ],
        "D": [
            61620922,
            61632151,
            61634663,
            61631934,
            61627516,
            61628612,
            61627461,
            61639106,
            61624471,
            61635660,
            61628357,
            61634636,
            61632191,
            61627962,
            61627805,
            61636954,
            61642587,
            61638100,
            61640694,
            61630321
        ],
        "A": [
            61612861,
            61620182,
            61616933,
            61612804,
            61614828,
            61613376,
            61613863,
            61613458,
            61613474,
            61619474,
            61614252,
            61614656,
            61613262,
            61614503,
            61613228,
            61614047,
            61614323,
            61618981,
            61616841,
            61613092
        ]
    },
    "name": "F. Yet Another Substring Reverse",
    "statement": "You are given a string s consisting only of first 20 lowercase Latin\r\nletters (\u201d, \u201d, ..., \u201d).Recall that the substring s[l; r] of the string s\r\nis the string s_l s_{l + 1}\r\ndots s_r. For example, the substrings of \"\" are \"\", \"\", \"\", \"\", but not\r\n\"\" and \"\".You can perform the following operation : choose some\r\nsubstring s[l; r] and it (i.e. the string s_l s_{l + 1}\r\ndots s_r becomes s_r s_{r - 1}\r\ndots s_l).Your goal is to maximize the length of the maximum substring\r\nof s consisting of (i.e. unique) characters.The string consists of\r\ncharacters if no character in this string appears more than once. For\r\nexample, strings \"\", \"\" and \"\" consist of distinct characters but\r\nstrings \"\", \"\" do not consist of distinct characters.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int N = 20;\nconst int SZ = (1 << N) + 7777;\n\nint A[SZ], precalc[SZ];\n\nint count(int msk) {\n\tint rez = 0;\n\n\tfor(int j = 0; j < N; ++j)\n\t\trez += (msk >> j) & 1;\n\n\treturn rez;\n}\n\nvoid solve() {\n\tfor(int msk = 0; msk < (1 << N); ++msk) {\n\t\tprecalc[msk] = count(msk);\n\t}\n\n\tstring str;\n\tcin >> str;\n\n\tint n = len(str);\n\tint answ = 0;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint msk = 0;\n\n\t\tfor(int j = i; j < n; ++j) {\n\t\t\tint code = str[j] - 'a';\n\t\t\t\n\t\t\tif((msk >> code) & 1)\n\t\t\t\tbreak;\n\n\t\t\tmsk |= (1 << code);\n\t\t\tA[msk] = precalc[msk];\n\t\t\tansw = (A[msk] > answ ? A[msk] : answ);\n\t\t}\n\t}\n\n\tfor(int j = 0; j < N; ++j) {\n\t\tfor(int msk = 0; msk < (1 << N); ++msk) {\n\t\t\tint bit = 1 << j;\n\n\t\t\tif(msk & bit) {\n\t\t\t\tA[msk] = (A[msk ^ bit] > A[msk] ? A[msk ^ bit] : A[msk]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int msk = 0; msk < (1 << N); ++msk) {\n\t\tint msk2 = ((1 << N) - 1) & (~msk);\n\t\tint value = A[msk] + A[msk2];\n\n\t\tansw = (value > answ ? value : answ);\n\t}\n\n\tcout << answ << '\\n';\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Yet Another Substring Reverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/70233",
    "editorial": "First of all, I wanted to offer you one little challenge: I found a\r\nsolution that I can\u00e2\u0080\u0099t break (and I don\u00e2\u0080\u0099t sure if it can be broken) and I\r\nwill be so happy if anyone will give me countertest which will break it.\r\nYou can see its code below.Let\u00e2\u0080\u0099s notice that we can reduce our problem\r\nto the following: find two substrings of the given string that letters\r\nin them do not intersect and the total length of these substrings is the\r\nmaximum possible. Why can we make such a reduction? It is so because our\r\nanswer consists of at most two non-intersecting parts: one fixed\r\nsubstring and at most one substring that we appended to the first one.\r\nWe can always append any other substring to the first one by one reverse\r\noperation (just look at some examples to understand it).Let\u00e2\u0080\u0099s iterate\r\nover all possible substrings of length at most (where is the size of the\r\nalphabet) which contain distinct letters. We can do it in . Let the\r\ncurrent substring containing distinct letters be . Let\u00e2\u0080\u0099s create the\r\nbitmask corresponding to this substring: the bit is if the -th letter of\r\nthe alphabet is presented in the substring and otherwise (letters are\r\n).Store all these masks somewhere. Notice that our current problem can\r\nbe reduced to the following: we have the set of masks and we need to\r\nfind a pair of masks that they do not intersect and their total number\r\nof ones in them is the maximum possible. This reduction is less obvious\r\nthan the previous one but you also can understand it considering some\r\nexamples.So how to solve this problem? We can do it with easy bitmasks\r\ndynamic programming! Let be the maximum number of ones in some mask that\r\nis presented in the given string and it is the submask of . How to\r\ncalculate this dynamic programming? First of all, all values for all\r\nmasks presented in the string are equal to the number of ones in\r\ncorresponding masks. Let\u00e2\u0080\u0099s iterate over all masks from to . Let the\r\ncurrent mask be . Then let\u00e2\u0080\u0099s try to update the answer for this mask with\r\nthe answer for one of its submasks. It is obvious that because of\r\ndynamic programming we need to remove at most one bit from our mask to\r\ncover all possible submasks that can update our answer. So let\u00e2\u0080\u0099s iterate\r\nover all bits in , let the current bit be . If this bit is zero then\r\njust skip it. Otherwise update , where is the operation.After\r\ncalculating this dynamic programming we can finally calculate the\r\nanswer. Let\u00e2\u0080\u0099s iterate over all masks presented in the string, let the\r\ncurrent mask be . We can update the answer with the number of ones in\r\nplus ( is the completion of ).Total complexity: .\r\n"
}