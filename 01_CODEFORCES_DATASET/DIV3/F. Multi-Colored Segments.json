{
    "link": "https://codeforces.com//contest/1741/problem/F",
    "problemId": "1580862",
    "problem_idx": "F",
    "shortId": "1741F",
    "contest_number": "1741",
    "problem_submissions": {
        "G": [
            175658655,
            175776548,
            175778289,
            175654398,
            175880793,
            175656924,
            175637609,
            175729544,
            176113562
        ],
        "F": [
            175634710,
            175634330,
            175639332,
            175634963,
            175641391,
            175642288,
            175651066,
            175638700,
            175650758,
            175650474,
            175650413,
            175696195,
            175630855,
            175641068,
            175713558,
            175713496,
            175713405,
            175713348,
            175712166,
            175712032,
            175710248,
            175653725,
            188881508,
            175657954,
            175660445,
            175647171
        ],
        "E": [
            175612842,
            175607012,
            175602583,
            175610869,
            175597285,
            175603137,
            175605173,
            175613578,
            175612154,
            175602225,
            175611227,
            175622904,
            175609226,
            175636862,
            175596615,
            175626249,
            175618084,
            175609955,
            175614301,
            175619312
        ],
        "D": [
            175600792,
            175598753,
            175587861,
            175602078,
            175590264,
            175593902,
            175593998,
            175614050,
            175599808,
            175588551,
            175598698,
            175602136,
            175595713,
            175593039,
            175644398,
            175600557,
            175714317,
            175605116,
            175598500,
            175596629,
            175607880
        ],
        "C": [
            175590194,
            175585809,
            175713811,
            175588824,
            175588091,
            175585251,
            175586131,
            175579401,
            175581660,
            175576056,
            175582459,
            175579198,
            175578713,
            175576074,
            175578615,
            175581737,
            175586416,
            175584583,
            175585714,
            175593866
        ],
        "B": [
            175579146,
            175570687,
            175567044,
            175573608,
            175578477,
            175570022,
            175570101,
            175572940,
            175567692,
            175571900,
            175569281,
            175569338,
            175568386,
            175570488,
            175571800,
            175575494,
            175567609,
            175569238,
            175585403
        ],
        "A": [
            175563566,
            175564993,
            175563738,
            175564174,
            175564333,
            175564490,
            175563949,
            175567859,
            175563695,
            175565037,
            175565795,
            175565035,
            175564013,
            175564907,
            175683101,
            175567126,
            175709307,
            175566606,
            175563970,
            175564612,
            175568510
        ]
    },
    "name": "F. Multi-Colored Segments",
    "statement": "Dmitry has n segments of different colors on the coordinate axis Ox.\r\nEach segment is characterized by three integers l_i, r_i and c_i (1\r\nle l_i\r\nle r_i\r\nle 10^9, 1\r\nle c_i\r\nle n), where l_i and r_i are are the coordinates of the ends of the i-th\r\nsegment, and c_i is its color.Dmitry likes to find the minimum distances\r\nbetween segments. However, he considers pairs of segments of the same\r\ncolor uninteresting. Therefore, he wants to know for each segment the\r\ndistance from this segment to the nearest colored segment.The distance\r\nbetween two segments is the minimum of the distances between a point of\r\nthe first segment and a point of the second segment. In particular, if\r\nthe segments intersect, then the distance between them is equal to 0.For\r\nexample, Dmitry has 5 segments: The first segment intersects with the\r\nsecond (and these are segments of different colors), so the answers for\r\nthem are equal to 0. For the 3-rd segment, the nearest segment of a\r\ndifferent color is the 2-nd segment, the distance to which is equal to\r\n2. For the 4-th segment, the nearest segment of a different color is the\r\n5-th segment, the distance to which is equal to 1. The 5-th segment lies\r\ninside the 2-nd segment (and these are segments of different colors), so\r\nthe answers for them are equal to 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define dprintf(...) //printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nstruct Seg {\n  int l, r, c, idx;\n\n  bool operator<(const Seg& other) const {\n    if (l != other.l) return l < other.l;\n    if (r != other.r) return r < other.r;\n    return idx < other.idx;\n  }\n\n  int dist(const Seg& other) const {\n    if (l <= other.l && other.l <= r) return 0;\n    if (l <= other.r && other.r <= r) return 0;\n\n    if (other.l <= l && l <= other.r) return 0;\n    if (other.l <= r && r <= other.r) return 0;\n\n    if (r < other.l)       // [l,r] [ol,or]\n      return other.l - r;\n    else                   // [ol,or] [l,r]\n      return l - other.r;\n  }\n};\n\nstruct SegSet {\n  map<int, Seg> mp;  // l=>r\n\n  int dist(const Seg& seg) {\n    auto it = mp.lower_bound(seg.l);\n    if (it != mp.begin()) it--;\n    if (it != mp.begin()) it--;\n    int ans = INT_MAX;\n    for (int k = 0; k < 5 && it != mp.end(); it++, k++) {\n      ans = min(ans, seg.dist(it->second));\n    }\n    return ans;\n  }\n\n  void add(Seg seg) {\n    auto it = mp.lower_bound(seg.l);\n    if (it != mp.begin()) it--;\n\n    while (it != mp.end() && it->second.r < seg.l)\n      it++;\n\n    while (it != mp.end() && seg.dist(it->second) == 0) {\n      seg.l = min(seg.l, it->second.l);\n      seg.r = max(seg.r, it->second.r);\n      auto it2 = it; ++it2;\n      mp.erase(it);\n      it = it2;\n    }\n\n    mp[seg.l] = seg;\n  }\n\n  void print() {\n    for (auto [k, seg] : mp)\n      dprintf(\"[%d,%d] \", seg.l, seg.r, seg.c);\n    dprintf(\"\\n\");\n  }\n};\n\n\nvoid solve() {\n  int N; cin >> N;\n\n  vector<Seg> segs(N);\n  for (int i = 0; i < N; i++) {\n    cin >> segs[i].l >> segs[i].r >> segs[i].c;\n    segs[i].idx = i;    \n  }\n\n  map<int, vector<Seg>> segs_by_color;\n  for (int i = 0; i < segs.size(); i++) {\n    segs_by_color[segs[i].c].push_back(segs[i]);\n  }\n\n  vector<int> colors;\n  for (auto& [color, color_segs] : segs_by_color) {\n    colors.push_back(color);\n  }\n\n  vector<int> ans(N, INT_MAX);\n\n  for (int dir = 0; dir < 2; dir++) {\n    SegSet segset;\n    dprintf(\"dir=%d\\n\", dir);\n\n    if (dir == 1) reverse(colors.begin(), colors.end());\n\n    for (int i = 0; i < colors.size(); i++) {\n      auto& color_segs = segs_by_color[colors[i]];\n      dprintf(\" color=%d \", colors[i]);\n\n      for (auto& seg : color_segs) {\n        int ss_dist = segset.dist(seg);\n        ans[seg.idx] = min(ans[seg.idx], ss_dist);\n      }\n\n      for (auto seg : color_segs) {\n        dprintf(\"add[%d,%d] \", seg.l, seg.r);\n        segset.add(seg);\n      }\n      dprintf(\" => \");\n      //segset.print();\n    }\n  }\n\n  for (int i = 0; i < ans.size(); i++) printf(i ? \" %d\" : \"%d\", ans[i]);\n  printf(\"\\n\");\n  dprintf(\"\\n\");\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "math",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Multi-Colored Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/107908",
    "editorial": "Let\u00e2\u0080\u0099s go through the segments times: in non-decreasing coordinates of\r\nthe left end, and then in non-increasing coordinates of the right end.\r\nTo walk a second time, just multiply the coordinates of the left and\r\nright borders by , and then swap them and walk from left to right.Going\r\nthrough the segments in non-decreasing coordinates of the left end, you\r\nneed to find for each segment a segment that starts not to the right of\r\nthe current one and ends as far to the right as possible. If the\r\ncoordinate of its right end is not less than the coordinate of the left\r\nend of the current segment, then it intersects with it, otherwise the\r\ndistance between them is equal to the distance between the coordinate of\r\nthe left end of the current segment and the maximum coordinate of the\r\nright end of the segment starting to the left of ours.Note that it is\r\nenough for us to store no more than segments: for each color we will\r\nstore the maximum right coordinate of the segment of this color, which\r\nhas already been considered. If we store the colors with the largest\r\nright coordinates, then one of them is definitely not equal to the\r\ncurrent one. When considering a segment, we add it to the list, and if\r\nthe size of the list becomes , then we leave of optimal elements.\r\n"
}