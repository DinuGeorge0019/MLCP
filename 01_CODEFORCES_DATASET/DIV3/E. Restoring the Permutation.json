{
    "link": "https://codeforces.com//contest/1506/problem/E",
    "problemId": "935563",
    "problem_idx": "E",
    "shortId": "1506E",
    "contest_number": "1506",
    "problem_submissions": {
        "F": [
            111021020,
            111023335,
            111043050,
            111045078,
            111042675,
            111022888,
            111045702,
            111030029,
            111059327,
            111056314,
            111054328,
            111053665,
            111049676,
            111057223,
            111055499,
            111051574,
            111018539
        ],
        "G": [
            111011051,
            111044191,
            111025676,
            111021333,
            111015838,
            111047466,
            111027389,
            111038444,
            111062619,
            111035705,
            111033084,
            111031458,
            111027898,
            111059943,
            111039951,
            111044272,
            111042579,
            110997057,
            111024212,
            111035025
        ],
        "E": [
            110998219,
            111002639,
            111005993,
            111004597,
            111005673,
            111003655,
            111009629,
            110993653,
            111011522,
            111018659,
            111024774,
            111017525,
            111015924,
            111022569,
            111022716,
            111033942,
            111001920,
            111012071,
            111010852
        ],
        "D": [
            110994014,
            110997858,
            111000907,
            110997329,
            111020775,
            111109278,
            110995630,
            111003898,
            110987445,
            111005061,
            111007314,
            111017748,
            111012182,
            111006395,
            111026211,
            111014600,
            111017473,
            111014918,
            111042008,
            110987093,
            111004976
        ],
        "C": [
            110991700,
            110993760,
            110994821,
            110991557,
            110994969,
            110992631,
            110998527,
            110995536,
            111000015,
            111001144,
            111003685,
            111008122,
            111006904,
            111001766,
            110999236,
            111006625,
            111008840,
            111033710,
            110991249,
            110998250
        ],
        "B": [
            110987614,
            110990504,
            110992033,
            110988684,
            110991376,
            110988565,
            110994317,
            111002159,
            110989417,
            110997996,
            110993594,
            111002185,
            110994767,
            111009342,
            111001911,
            111024800,
            111045128,
            110999737,
            110993374
        ],
        "A": [
            110986181,
            110985860,
            110985761,
            110986354,
            110986698,
            110986290,
            110988038,
            110996610,
            110986006,
            110986393,
            110986025,
            110986629,
            110986586,
            110988619,
            110989257,
            110990207,
            111021247,
            111003988,
            110987775
        ]
    },
    "name": "E. Restoring the Permutation",
    "statement": "A permutation is a sequence of n integers from 1 to n, in which all\r\nnumbers occur exactly once. For example, [1], [3, 5, 2, 1, 4], [1, 3, 2]\r\nare permutations, and [2, 3, 2], [4, 3, 1], [0] are not.Polycarp was\r\npresented with a permutation p of numbers from 1 to n. However, when\r\nPolycarp came home, he noticed that in his pocket, the permutation p had\r\nturned into an array q according to the following rule: q_i =\r\nmax(p_1, p_2,\r\nldots, p_i). Now Polycarp wondered what lexicographically minimal and\r\nlexicographically maximal permutations could be presented to him.An\r\narray a of length n is lexicographically smaller than an array b of\r\nlength n if there is an index i (1\r\nle i\r\nle n) such that the first i-1 elements of arrays a and b are the same,\r\nand the i-th element of the array a is less than the i-th element of the\r\narray b. For example, the array a=[1, 3, 2, 3] is lexicographically\r\nsmaller than the array b=[1, 3, 4, 2].For example, if n=7 and p=[3, 2,\r\n4, 1, 7, 5, 6], then q=[3, 3, 4, 4, 7, 7, 7] and the following\r\npermutations could have been as p initially: [3, 1, 4, 2, 7, 5, 6]\r\n(lexicographically minimal permutation); [3, 1, 4, 2, 7, 6, 5]; [3, 2,\r\n4, 1, 7, 5, 6]; [3, 2, 4, 1, 7, 6, 5] (lexicographically maximum\r\npermutation). For a given array q, find the lexicographically minimal\r\nand lexicographically maximal permutations that could have been\r\noriginally presented to Polycarp.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nmap <int,int> mp;\nint a[200005],vis[200005];\npriority_queue <int> q;\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++) vis[i]=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin >> a[i];\n\t\tint mx=0,now=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(mx!=a[i])\n\t\t\t{\n\t\t\t\tvis[mx=a[i]]=1;\n\t\t\t\tcout << mx << \" \";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(vis[now]) now++;\n\t\t\tcout << now << \" \";\n\t\t\tvis[now]=1;\n\t\t}\n\t\tcout << \"\\n\"; \n\t\tfor(int i=1;i<=n;i++) vis[i]=0;\n\t\tmx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(mx!=a[i])\n\t\t\t{\n\t\t\t\tfor(int j=mx+1;j<a[i];j++) q.push(j);\n\t\t\t\tvis[mx=a[i]]=1;\n\t\t\t\tcout << mx << \" \";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(vis[q.top()]) q.pop();\n\t\t\tcout << q.top() << \" \";\n\t\t\tq.pop();\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Restoring the Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/89007",
    "editorial": "If we want to build a minimal lexicographic permutation, we need to\r\nbuild it from left to right by adding the smallest possible element. If\r\n, so the new number must not be greater than all the previous ones, and\r\nif , then necessarily . does not happen, since is the maximum element\r\namong the first elements.We get a greedy solution if , then , otherwise\r\nwe put the minimum character that has not yet occurred in the\r\npermutation.\r\n"
}