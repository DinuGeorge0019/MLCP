{"link": "https://codeforces.com//contest/1729/problem/F", "problemId": "1538787", "problem_idx": "F", "shortId": "1729F", "contest_number": "1729", "problem_submissions": {"G": [171909059, 171928158, 171929650, 171937957, 171943890, 171891847, 177449161, 177445327, 172241447, 172480345], "F": [171894944, 171892697, 171881447, 171902682, 171920680, 171910535, 171878146, 171906331, 171923271, 171910232, 171914792, 171908912, 171906528, 171914845, 171906947, 171906893, 171920671, 171915782, 171919661], "E": [171877179, 171875756, 171902704, 171910299, 171904162, 171875139, 171920658, 171889898, 171889626, 171887188, 171887680, 171887875, 171890844, 171886351, 171876648, 171892405, 171885680], "D": [171861022, 171860553, 171863068, 171871491, 171878349, 171858368, 171848378, 171874244, 171864332, 171876318, 171869512, 171878854, 171871746, 171875870, 171867532, 171863495, 171872346, 171873328], "C": [171852852, 171855742, 171858347, 171863945, 171872549, 171852373, 171871529, 171858052, 171858976, 171859379, 171861408, 171866242, 171860889, 171865107, 171859758, 171855447, 171858502, 171863966], "B": [171845132, 171847312, 171845642, 171852489, 171856806, 171841700, 171849120, 171848235, 171844034, 171844485, 171847383, 171849511, 171849845, 171851995, 171846552, 171848340, 171844748, 171850134], "A": [171834897, 171837470, 171836390, 171836406, 171845837, 171834988, 171835540, 171837958, 171836211, 171834933, 171836834, 171836016, 171838691, 171835898, 171835047, 171838527, 171834668, 171838404]}, "name": "F. Kirei and the Linear Function", "statement": "Given the string s of decimal digits (-) of length n.A substring is a\r\nsequence of consecutive characters of a string. The substring of this\r\nstring is defined by a pair of indexes with its left and right ends. So,\r\neach pair of indexes (l, r), where 1\r\nle l\r\nle r\r\nle n, corresponds to a substring of the string s. We will define as\r\nv(l,r) the numeric value of the corresponding substring (leading zeros\r\nare allowed in it).For example, if n=7, s=\"\", then v(1,3)=100, v(2,3)=0\r\nand v(2,7)=3004.You are given n, s and an integer w (1\r\nle w < n).You need to process m queries, each of which is characterized\r\nby 3 numbers l_i, r_i, k_i (1\r\nle l_i\r\nle r_i\r\nle n; 0\r\nle k_i\r\nle 8).The answer to the ith query is such a pair of substrings of length\r\nw that if we denote them as (L_1, L_1+w-1) and (L_2, L_2+w-1), then: L_1\r\nne L_2, that is, the substrings are different; the remainder of dividing\r\na number v(L_1, L_1+w-1)\r\ncdot v(l_i, r_i) + v(L_2, L_2 + w - 1) by 9 is equal to k_i. If there\r\nare many matching substring pairs, then find a pair where L_1 is as\r\nsmall as possible. If there are many matching pairs in this case, then\r\nminimize L_2.Note that the answer may not exist.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl '\\n'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 9;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid deb() {cerr << \"\\n\";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\n\n\nstruct mint {\n    int x;\n    mint() : x(0) {}\n    mint(int x) : x((x % mod + mod) % mod) {}\n    mint operator -() const { return mint(0) - *this;}\n    mint operator ~() const { return mint(1) / *this;}\n    mint& operator +=(const mint& a) { if((x += a.x) >= mod) x -= mod; return *this;}\n    mint& operator -=(const mint& a) { if((x += mod - a.x) >= mod) x -= mod; return *this;}\n    mint& operator *=(const mint& a) { x = x * a.x % mod; return *this;}\n    mint& operator /=(const mint& a) { x = x * a.pow(mod-2).x % mod; return *this;}\n    mint operator +(const mint& a) const { return mint(*this) += a;}\n    mint operator -(const mint& a) const { return mint(*this) -= a;}\n    mint operator *(const mint& a) const { return mint(*this) *= a;}\n    mint operator /(const mint& a) const { return mint(*this) /= a;}\n    mint pow(int t) const { mint ret(1), pw = mint(*this); while(t){ if(t & 1) ret *= pw; pw *= pw; t /= 2;} return ret;}\n    bool operator <(const mint& a) const { return x < a.x;}\n    bool operator ==(const mint& a) const { return x == a.x;}\n    bool operator !=(const mint& a) const { return x != a.x;}\n    friend istream& operator >>(istream& is, mint& p) { return is >> p.x; }\n    friend ostream& operator <<(ostream& os, mint p){ return os << p.x; }\n};\n\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n\n    int w, q;\n    cin >> w >> q;\n\n    mint x = 0;\n\n    rep(i,0,w)\n    {\n        x = x * 10 + (s[i] - '0');\n    }\n\n    vvi g(9);\n\n    fr(i, 0, n - w)\n    {\n        g[x.x].pb(i);\n\n        if(i + w < n)\n        {\n            x = x * 10 + (s[i + w] - '0');\n            x -= mint(s[i] - '0') * mint(10).pow(w);\n        }\n    }\n\n\n    vector<mint> pre(n + 1);\n\n    rep(i,0,n)\n    {\n        pre[i + 1] = pre[i] * 10 + (s[i] - '0');\n    }\n    \n    \n    while(q--)\n    {\n        int l, r, k;\n        cin >> l >> r >> k;\n\n        mint z = pre[r] - pre[l - 1];\n\n        pii res = {n, n};\n\n        rep(i,0,9)\n        {\n            rep(j,0,9)\n            {\n                if(mint(i) * z + j == mint(k))\n                {\n                    //deb(i, j);\n\n                    if(i == j)\n                    {\n                        if(sz(g[i]) > 1)\n                        {\n                            mini(res, pii(g[i][0], g[i][1]));\n                        }\n                    }\n                    else\n                    {\n                        if(sz(g[i]) && sz(g[j]))\n                        {\n                            mini(res, pii(g[i][0], g[j][0]));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(res.fi == n)\n        {\n            cout << \"-1 -1\" << endl;\n        }\n        else\n        {\n            cout << res.fi + 1 << ' ' << res.se + 1 << endl;\n        }\n    }\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n"], "input": "", "output": "", "tags": ["hashing", "math"], "dificulty": "1900", "interactive": false}