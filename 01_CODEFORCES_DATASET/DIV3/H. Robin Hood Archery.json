{
    "link": "https://codeforces.com//contest/2014/problem/H",
    "problemId": "2892480",
    "problem_idx": "H",
    "shortId": "2014H",
    "contest_number": "2014",
    "problem_submissions": {
        "G": [
            282355237,
            282340908,
            282349517,
            282469109,
            282768209
        ],
        "H": [
            282319139,
            282294919,
            282369641,
            282327328,
            282344971,
            282343427,
            282320463,
            282354346,
            282338340,
            282341971,
            282345189,
            282359227,
            282335882,
            282356841,
            282332486,
            282259554,
            282367573,
            282358571,
            282340140,
            282354845,
            282340779
        ],
        "F": [
            282310940,
            282344360,
            282329041,
            282301003,
            282317626,
            282346191,
            282313376,
            282324314,
            282336360,
            282330209,
            282316236,
            282352931,
            282339107,
            282367052,
            282355481,
            282342400,
            282311004,
            282354051,
            282348444,
            282360261
        ],
        "E": [
            282298135,
            282347444,
            282324784,
            282315211,
            282288353,
            282301236,
            282298734,
            282299501,
            282311127,
            282309362,
            282313492,
            282303867,
            282309804,
            282310056,
            282314491,
            282344707,
            282319635,
            282302427,
            282313050,
            282331264,
            282317148
        ],
        "D": [
            282266365,
            282262468,
            282284761,
            282266186,
            282281624,
            282263914,
            282278929,
            282290066,
            282285534,
            282292322,
            282283633,
            282303511,
            282281064,
            282294495,
            282319933,
            282298383,
            282290687,
            282285759,
            282297433,
            282291388
        ],
        "C": [
            282245761,
            282249551,
            282267820,
            282250356,
            282260562,
            282251055,
            282251810,
            282263518,
            282256201,
            282252015,
            282260274,
            282248128,
            282257994,
            282266861,
            282299616,
            282253349,
            282254086,
            282264623,
            282276303,
            282262355
        ],
        "B": [
            282235337,
            282236894,
            282246106,
            282232521,
            282241668,
            282237594,
            282243258,
            282239802,
            282239576,
            282238146,
            282241956,
            282238965,
            282240579,
            282237329,
            282279188,
            282240894,
            282242478,
            282240040,
            282236073,
            282244164,
            282271471
        ],
        "A": [
            282225117,
            282225433,
            282233872,
            282225077,
            282234075,
            282225216,
            282226675,
            282226848,
            282232220,
            282227137,
            282231989,
            282227272,
            282229469,
            282228546,
            282236816,
            282226223,
            282233092,
            282227477,
            282229182,
            282226562
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134210",
    "editorial": "Sheriff can never win. This is quite obvious as Robin is the first to pick and both just keep picking the current biggest number. This means that Sheriff can at best get a tie \u0097 this happens if and only if all elements have even appearance. The segment al\u0085ar\n is a tie if and only if there's no element that appears an odd number of times.\n\nThere are multiple ways to solve this problem. Two are outlined.\n\nMo's algorithm \u0097 offline\nWe can keep the count of appearances of each element using an array in O(1)\n time. Sort the queries into blocks of size n???\n. Keep updating the boundaries of the current segment and the total count of elements that appear an odd number of times. Sheriff can tie iff there is no odd appearance.\n\nTime complexity \u0097 O((n+q)n???)\n.\n\nXor hashing\nConsider the prefixes of all targets. If the current segment is al\u0085ar\n, there's no element with odd appearance if and only if the set of numbers with odd appearance in a1\u0085al?1\n is the same as a1\u0085ar\n. We can check if two prefixes have the same set of elements with odd appearance with xor hashing.\n\nTime complexity \u0097 O(n+q)\n.",
    "name": "H. Robin Hood Archery",
    "statement": "Sheriff of Nottingham has organized a tournament in archery. It\u2019s the\r\nfinal round and Robin Hood is playing against Sheriff!There are n\r\ntargets in a row numbered from 1 to n. When a player shoots target i,\r\ntheir score increases by a_i and the target i is destroyed. The game\r\nconsists of turns and players alternate between whose turn it is. Robin\r\nHood always starts the game, then Sheriff and so on. The game continues\r\nuntil all targets are destroyed. Both players start with score 0.At the\r\nend of the game, the player with most score wins and the other player\r\nloses. If both players have the same score, it\u2019s a tie and no one wins\r\nor loses. In each turn, the player can shoot any target that wasn\u2019t shot\r\nbefore. Both play optimally to get the most score possible.Sheriff of\r\nNottingham has a suspicion that he might lose the game! This cannot\r\nhappen, you must help Sheriff. Sheriff will pose q queries, each\r\nspecifying l and r. This means that the game would be played only with\r\ntargets l, l+1,\r\ndots, r, as others would be removed by Sheriff before the game\r\nstarts.For each query l, r, determine whether the Sheriff can the game\r\nwhen only considering the targets l, l+1,\r\ndots, r.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 1e6 + 5;const int mod = 1e9 + 7;int n, m, a[N], pre1[N], pre2[N], hs1[N], hs2[N];mt19937 rnd(time(0));void init(){    for (int i = 1; i <= 1e6; i++)        hs1[i] = rnd(), hs2[i] = rnd();}void solve(){    cin >> n >> m;    for (int i = 1; i <= n; i++)        cin >> a[i], pre1[i] = pre1[i - 1] ^ hs1[a[i]], pre2[i] = pre2[i - 1] ^ hs2[a[i]];    while (m--)    {        int l, r;        cin >> l >> r;        if (pre1[r] == pre1[l - 1] && pre2[r] == pre2[l - 1])            cout << \"YES\\n\";        else            cout << \"NO\\n\";    }}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    init();    cin >> t;    while (t--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "greedy",
        "hashing"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\H. Robin Hood Archery.json"
}