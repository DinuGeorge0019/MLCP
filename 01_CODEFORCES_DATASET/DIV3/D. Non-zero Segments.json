{
    "link": "https://codeforces.com//contest/1426/problem/D",
    "problemId": "741033",
    "problem_idx": "D",
    "shortId": "1426D",
    "contest_number": "1426",
    "problem_submissions": {
        "F": [
            94089387,
            94092918,
            94090403,
            94095742,
            94088134,
            94102934,
            94096551,
            94090044,
            94100502,
            94103680,
            218894732,
            131689129,
            94100223,
            94101665,
            94085023,
            94099275,
            94107717,
            94108168
        ],
        "E": [
            94079004,
            94083320,
            94085257,
            94085446,
            94092844,
            94090813,
            94089559,
            94099737,
            94089791,
            94097053,
            94092910,
            94097010,
            94098462,
            94085593,
            94101850,
            94089304
        ],
        "D": [
            94071411,
            94077723,
            94078265,
            94077474,
            94069955,
            94078150,
            94084721,
            94071027,
            94084864,
            94076625,
            94083571,
            94075395,
            94086923,
            94082098,
            94077297,
            94085021
        ],
        "C": [
            94067630,
            94073367,
            94069883,
            94073399,
            94089927,
            94071160,
            94078615,
            94067330,
            94079325,
            94073107,
            94073949,
            94069099,
            94077626,
            94066598,
            94072495,
            94075528
        ],
        "A": [
            94065015,
            94061620,
            94061516,
            94063683,
            94064521,
            94061955,
            94064781,
            94061581,
            94061323,
            94061123,
            94062843,
            94062137,
            94062437,
            94068632,
            94061414,
            94062568
        ],
        "B": [
            94063517,
            94066888,
            94067224,
            94068533,
            94065544,
            94066401,
            94071303,
            94080232,
            94070524,
            94065932,
            94070012,
            94081030,
            94072459,
            94087907,
            94066918,
            94069482
        ]
    },
    "name": "D. Non-zero Segments",
    "statement": "Kolya got an integer array a_1, a_2,\r\ndots, a_n. The array can contain both positive and negative integers,\r\nbut Kolya doesn’t like 0, so the array doesn’t contain any zeros.Kolya\r\ndoesn’t like that the sum of some subsegments of his array can be 0. The\r\nsubsegment is some consecutive segment of elements of the array. You\r\nhave to help Kolya and change his array in such a way that it doesn’t\r\ncontain any subsegments with the sum 0. To reach this goal, you can\r\ninsert any integers between any pair of adjacent elements of the array\r\n(integers can be really any: positive, negative, 0, any by absolute\r\nvalue, even such a huge that they can’t be represented in most standard\r\nprogramming languages).Your task is to find the minimum number of\r\nintegers you have to insert into Kolya’s array in such a way that the\r\nresulting array doesn’t contain any subsegments with the sum 0.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl \"\\n\"\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<'('<<p.F<< \",\"<<p.S<<')'; \n}\n\nint _runtimeTerror_()\n{\n    ll n;\n    cin>>n;\n    vector<ll> v(n+1),u(n+1);\n    for(int i=1;i<=n;++i)\n        cin>>v[i];\n    for(int i=1;i<=n;++i)\n        u[i] = u[i-1] + v[i];\n    ll sum = 0,ans = 0;\n    set<ll> s;\n    s.insert(0);\n    for(int i=1;i<=n;++i)\n    {\n        sum += v[i];\n        if(s.count(sum))\n        {\n            ++ans;\n            s.clear();\n            s.insert(u[i-1]);\n        }\n        s.insert(sum);\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    //cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Non-zero Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/83120",
    "editorial": "Firstly, letâs understand that the sum of the segment is zero if is zero\r\n(in other words, ), where is the sum of the first elements ().Letâs\r\niterate over elements from left to right and add all prefix sums in the\r\nset. If we get the sum that is already in the set, we get some segment\r\nwith sum , and we need to fix it somehow. Letâs insert some huge number\r\nbefore the current element in such a way that all prefix sums starting\r\nfrom the current element to the end will be significantly bigger than\r\nall prefix sums to the left. In words of implementation, we just get rid\r\nof all prefix sums to the left (clear the set) and continue doing the\r\nsame process starting from the current element (so we just cut off the\r\nprefix of the array).This way is optimal because we remove all segments\r\nwith sum ending at the current element using only one insertion (and we\r\nneed to use at least one insertion to do that).Time complexity: .\r\n",
    "hint": []
}