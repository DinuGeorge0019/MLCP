{
    "link": "https://codeforces.com//contest/1624/problem/G",
    "problemId": "1256443",
    "problem_idx": "G",
    "shortId": "1624G",
    "contest_number": "1624",
    "problem_submissions": {
        "G": [
            142264977,
            142276263,
            142255328,
            142255380,
            142278979,
            142222438,
            142247481,
            142272907,
            142266089,
            142251678,
            142253083,
            142252160,
            142248179,
            142250137,
            142248523,
            142250039,
            142416148,
            142259210
        ],
        "F": [
            142255179,
            142272384,
            142268450,
            142243695,
            142285199,
            142258439,
            142236940,
            142264135,
            142393598,
            142331291,
            142248865,
            142296070,
            142276188,
            142284965,
            142276430,
            142260372
        ],
        "E": [
            142241464,
            142238534,
            142272316,
            142277777,
            142260025,
            142286074,
            142269495,
            142256319,
            142287785,
            142271217,
            142263215,
            142270151,
            142270566,
            142278137,
            142274750,
            142273040,
            142294098,
            142253958,
            142282423
        ],
        "D": [
            142225549,
            142220300,
            142226787,
            142230709,
            142223377,
            142265701,
            142282535,
            142273740,
            142234006,
            142223224,
            142236057,
            142230240,
            142221633,
            142230396,
            142243861,
            142238174,
            142223929,
            142233332,
            142233395,
            142227832
        ],
        "C": [
            142213147,
            142208364,
            142214903,
            142219856,
            142212618,
            142318538,
            142204231,
            142234937,
            142218849,
            142237305,
            142214526,
            142460843,
            142215423,
            142217168,
            142221355,
            142216799,
            142211503,
            142211985,
            142216819,
            142218405,
            142219857,
            142213500
        ],
        "B": [
            142197546,
            142199713,
            142206530,
            142215517,
            142199960,
            142202251,
            142206682,
            142220881,
            142202886,
            142198089,
            142210906,
            142196708,
            142210091,
            142205820,
            142205637,
            142211178,
            142207927,
            142211494,
            142209546
        ],
        "A": [
            142188870,
            142188452,
            142198531,
            142195180,
            142189107,
            142194205,
            142188426,
            142189618,
            142189485,
            142189892,
            142201064,
            142189063,
            142189404,
            142192459,
            142193156,
            142190543,
            142204194,
            142190164
        ]
    },
    "name": "G. MinOr Tree",
    "statement": "Recently, Vlad has been carried away by spanning trees, so his friends,\r\nwithout hesitation, gave him a connected weighted undirected graph of n\r\nvertices and m edges for his birthday.Vlad defined the of a spanning\r\ntree as the bitwise OR of all its weights, and now he is interested in\r\nwhat is the minimum possible that can be achieved by choosing a certain\r\nspanning tree. A spanning tree is a connected subgraph of a given graph\r\nthat does not contain cycles.In other words, you want to keep n-1 edges\r\nso that the graph remains connected and the bitwise OR weights of the\r\nedges are as small as possible. You have to find the minimum bitwise OR\r\nitself.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << ' ', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 2e5 + 10;\nconst int mod = 998244353;\nstruct edge {\n    int u, v, w;\n};\nedge e[N];\nint f[N];\nint F(int x) {\n    return x == f[x] ? x : f[x] = F(f[x]);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 1; i <= m; ++i) {\n            cin >> e[i].u >> e[i].v >> e[i].w;\n        }\n        int ans = (1ll << 30) - 1;\n        for (int i = 29; i >= 0; --i) {\n            iota(f + 1, f + 1 + n, 1);\n            ans ^= (1 << i);\n            for (int j = 1; j <= m; ++j) {\n                if ((e[j].w & ans) == e[j].w) {\n                    f[F(e[j].u)] = F(e[j].v);\n                }\n            }\n            bool ok = true;\n            int f1 = F(1);\n            for (int j = 2; j <= n; ++j) {\n                if (f1 != F(j)) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) {\n                ans ^= (1 << i);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. MinOr Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/98942",
    "editorial": "We need to minimize the result of the bitwise operation, so for\r\nconvenience, we represent the answer as a mask. Firstly, let\u00e2\u0080\u0099s assume\r\nthat this mask is composed entirely of ones.Let\u00e2\u0080\u0099s go from the most\r\nsignificant bit to the least significant one and try to reduce the\r\nanswer. To understand whether it is possible to remove the -th bit,\r\nremove it and check if the graph, in which all the weights are submasks\r\nof the current answer, is connected, for this, you can use depth-first\r\nsearch or a disjoint sets union. If the graph is connected, then the bit\r\ncan obviously be thrown out, and if not it cannot and must be returned.\r\n"
}