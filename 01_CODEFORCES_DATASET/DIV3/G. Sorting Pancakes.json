{
    "link": "https://codeforces.com//contest/1675/problem/G",
    "problemId": "1389924",
    "problem_idx": "G",
    "shortId": "1675G",
    "contest_number": "1675",
    "problem_submissions": {
        "G": [
            156006050,
            156007549,
            173914008,
            156574492,
            156062725,
            156044046
        ],
        "F": [
            155975284,
            155982189,
            155975181,
            155974056,
            155981368,
            155963854,
            155982839,
            155978540,
            155977742,
            155982621,
            155974644,
            155983326,
            155979741,
            155983593,
            155987528,
            155986330,
            155979073,
            155983357,
            155982704,
            155980054
        ],
        "B": [
            155956678,
            155933030,
            155935424,
            155929465,
            155930941,
            155933422,
            155931092,
            155933639,
            155934497,
            155933616,
            155938056,
            155932878,
            155937699,
            155932330,
            155932424,
            155935419,
            155934167,
            155935968,
            155938228,
            155943045
        ],
        "E": [
            155952600,
            155969940,
            155962457,
            155964374,
            155963814,
            155983208,
            155966957,
            155966086,
            155964414,
            155966097,
            155967685,
            155966676,
            155968339,
            155969173,
            155968619,
            155969521,
            155968330,
            155970439,
            155974921,
            155969157
        ],
        "D": [
            155947749,
            155955293,
            155954858,
            155948070,
            155952887,
            155947902,
            155952914,
            155950857,
            155960245,
            155955600,
            155958049,
            155956959,
            155958393,
            155952984,
            155959572,
            155957851,
            155953914,
            155962460,
            155960783,
            155957979
        ],
        "C": [
            155940658,
            155941257,
            155944890,
            155941178,
            155942028,
            155946945,
            155940227,
            155941361,
            155945588,
            155943949,
            155946857,
            155944434,
            155950008,
            155942914,
            155943655,
            155945930,
            155959132,
            155949802,
            155946391,
            155951636
        ],
        "A": [
            155928116,
            155927077,
            155928841,
            155925983,
            155926500,
            155932074,
            155926390,
            155927710,
            155930181,
            155927610,
            155931371,
            155927746,
            155927018,
            155927300,
            155927241,
            155926796,
            155928901,
            155928154,
            155927537,
            155926656
        ]
    },
    "name": "G. Sorting Pancakes",
    "statement": "Nastya baked m pancakes and spread them on n dishes. The dishes are in a\r\nrow and numbered from left to right. She put a_i pancakes on the dish\r\nwith the index i.Seeing the dishes, Vlad decided to bring order to the\r\nstacks and move some pancakes. In one move, he can shift one pancake\r\nfrom any dish to the closest one, that is, select the dish i (a_i > 0)\r\nand do one of the following: if i > 1, put the pancake on a dish with\r\nthe previous index, after this move a_i = a_i - 1 and a_{i - 1} = a_{i -\r\n1} + 1; if i < n, put the pancake on a dish with the following index,\r\nafter this move a_i = a_i - 1 and a_{i + 1} = a_{i + 1} + 1.Vlad wants\r\nto make the array a, after moving as few pancakes as possible. Help him\r\nfind the minimum number of moves needed for this.The array a=[a_1, a_2,\r\ndots,a_n] is called non-increasing if a_i\r\nge a_{i+1} for all i from 1 to n-1.\r\n",
    "solutions": [
        "#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == '-') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nconst int N = 255,INF = 0x3f3f3f3f;\nint ans,n,m,inp[N + 1],dp[2][N + 1][(N << 1) + 10],minn[2][N + 1][(N << 1) + 10],sum[N + 1];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\t#endif\n\tans = INF;\n\tn = read(),m = read();\n\tfor (int i = 1;i <= n;i++) inp[i] = read(),sum[i] = sum[i - 1] + inp[i];\n\tif (n == 1) {puts(\"0\");return 0;}\n\tmemset(dp,63,sizeof(dp)),memset(minn,63,sizeof(minn));\n\tfor (int j = 0;j <= m;j++){\n\t\tdp[1][j][j - inp[1] + m] = abs(j - inp[1]);\n\t\tminn[1][j][j - inp[1] + m] = abs(j - inp[1]);\n\t}\n\tfor (int k = 0;k <= (m << 1);k++){\n\t\tfor (int j = m;j >= 0;j--){\n\t\t\tminn[1][j][k] = min(dp[1][j][k],minn[1][j + 1][k]);\n\t\t}\n\t}\n\tfor (int i = 2;i <= n;i++){\n\t\tfor (int j = 0;j <= m;j++){\n\t\t\tfor (int k = 0;k <= (m << 1);k++) dp[i & 1][j][k] = minn[i & 1][j][k] = INF;\n\t\t}\n\t\tfor (int j = 0;j <= m;j++){\n\t\t\tfor (int k = 0;k <= (m << 1);k++){\n\t\t\t\tif (k - j + inp[i] >= 0 && k - j + inp[i] <= (m << 1)){\n\t\t\t\t\tdp[i & 1][j][k] = min(dp[i & 1][j][k],minn[(i & 1) ^ 1][j][k - j + inp[i]] + abs(k - m));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0;k <= (m << 1);k++){\n\t\t\tfor (int j = m;j >= 0;j--){\n\t\t\t\tminn[i & 1][j][k] = min(minn[i & 1][j + 1][k],dp[i & 1][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0;j <= m;j++) ans = min(ans,dp[n & 1][j][m]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Sorting Pancakes.json",
    "editorial_link": "https://codeforces.com//blog/entry/102550",
    "editorial": "For convenience, we will calculate the prefix sums on the array , we\r\nwill also enter the array containing the indexes of all pancakes and\r\ncalculate the prefix sums on it.Let\u00e2\u0080\u0099s use dynamic programming. Let\u00e2\u0080\u0099s\r\ndefine as the required number of operations to correctly lay out the -th\r\nprefix, with the final , and . Then you can go to from (the previous\r\nnumber must be greater, and the sum is fixed). To , it will be necessary\r\nto add a certain number of actions necessary to get , let\u00e2\u0080\u0099s call it (all\r\nthe terrible prefix sums are needed to count it). Since depends only on\r\nand , we only need to choose the minimum , the choice can be optimized\r\nby suffix minima. As a result, the solution works for , that\u00e2\u0080\u0099s how many\r\nstates need to be processed.\r\n"
}