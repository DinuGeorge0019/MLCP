{
    "link": "https://codeforces.com//contest/1650/problem/D",
    "problemId": "1321163",
    "problem_idx": "D",
    "shortId": "1650D",
    "contest_number": "1650",
    "problem_submissions": {
        "F": [
            148879513,
            148986538,
            148986467,
            148954476,
            148898287,
            148901435,
            148899333,
            148905510,
            148917052,
            148904349,
            148961796
        ],
        "E": [
            148849636,
            148864683,
            148963130,
            148875756,
            148872079,
            148878903,
            148875510,
            148901218,
            148892416,
            148888540,
            148898231,
            148888980,
            148883282,
            148898577,
            148883163,
            148907542,
            148907274,
            148906672,
            148906320,
            148893084,
            148887495,
            148892756,
            148872442,
            148863112
        ],
        "D": [
            148826882,
            148840222,
            148845807,
            148854912,
            148854752,
            148856728,
            148840985,
            148865410,
            148852435,
            148848691,
            148844798,
            148864773,
            148844781,
            148864322,
            148875613,
            148870696,
            148859219,
            148920116,
            148876044,
            148839258,
            148838584
        ],
        "C": [
            148820093,
            148831170,
            148831813,
            148836720,
            148830087,
            148836086,
            148827090,
            148852471,
            148837137,
            148831426,
            148825553,
            148845906,
            148830527,
            148848884,
            148845635,
            148848540,
            148844404,
            148859460,
            148825220,
            148833443
        ],
        "B": [
            148812353,
            148815870,
            148817423,
            148824929,
            148816344,
            148818724,
            148809035,
            148821547,
            148823462,
            148821683,
            148815397,
            148837950,
            148818597,
            148837067,
            163337223,
            148830901,
            148832514,
            148848552,
            148825246,
            148813545,
            148824771
        ],
        "A": [
            148807991,
            148808027,
            148809803,
            148809976,
            148810949,
            148808067,
            148809583,
            148816565,
            148811698,
            148808085,
            148807871,
            148819883,
            148808075,
            148829522,
            148809900,
            148814537,
            148809886,
            148812702,
            148807945,
            148820895
        ],
        "G": [
            148891310,
            148885828,
            148904919,
            148896469,
            148883806,
            148899609,
            148903599,
            148896840,
            148894409,
            148919593,
            148886999,
            148901688,
            148905478
        ]
    },
    "name": "D. Twist the Permutation",
    "statement": "Petya got an array a of numbers from 1 to n, where a[i]=i.He performed n\r\noperations sequentially. In the end, he received a new state of the a\r\narray.At the i-th operation, Petya chose the first i elements of the\r\narray and cyclically shifted them to the right an arbitrary number of\r\ntimes (elements with indexes i+1 and more remain in their places). One\r\ncyclic shift to the right is such a transformation that the array\r\na=[a_1, a_2,\r\ndots, a_n] becomes equal to the array a = [a_i, a_1, a_2,\r\ndots, a_{i-2}, a_{i-1}, a_{i+1}, a_{i+2},\r\ndots, a_n].For example, if a = [5,4,2,1,3] and i=3 (that is, this is the\r\nthird operation), then as a result of this operation, he could get any\r\nof these three arrays: a = [5,4,2,1,3] (makes 0 cyclic shifts, or any\r\nnumber that is divisible by 3); a = [2,5,4,1,3] (makes 1 cyclic shift,\r\nor any number that has a remainder of 1 when divided by 3); a =\r\n[4,2,5,1,3] (makes 2 cyclic shifts, or any number that has a remainder\r\nof 2 when divided by 3). Let’s look at an example. Let n=6, i.e.\r\ninitially a=[1,2,3,4,5,6]. A possible scenario is described below. i=1:\r\nno matter how many cyclic shifts Petya makes, the array a does not\r\nchange. i=2: let’s say Petya decided to make a 1 cyclic shift, then the\r\narray will look like a = [\r\ntextbf{2},\r\ntextbf{1}, 3, 4, 5, 6]. i=3: let’s say Petya decided to make 1 cyclic\r\nshift, then the array will look like a = [\r\ntextbf{3},\r\ntextbf{2},\r\ntextbf{1}, 4, 5, 6]. i=4: let’s say Petya decided to make 2 cyclic\r\nshifts, the original array will look like a = [\r\ntextbf{1},\r\ntextbf{4},\r\ntextbf{3},\r\ntextbf{2}, 5, 6]. i=5: let’s say Petya decided to make 0 cyclic shifts,\r\nthen the array won’t change. i=6: let’s say Petya decided to make 4\r\ncyclic shifts, the array will look like a = [\r\ntextbf{3},\r\ntextbf{2},\r\ntextbf{5},\r\ntextbf{6},\r\ntextbf{1},\r\ntextbf{4}]. You are given a final array state a after all n operations.\r\nDetermine if there is a way to perform the operation that produces this\r\nresult. In this case, if an answer exists, print the numbers of cyclical\r\nshifts that occurred during each of the n operations.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector<ll> V;\nvoid solve(){\n\tint n; cin>>n;\n\tdeque<int>deq;\n\tfor(int i=1; i<=n; i++){\n\t\tint x; cin>>x;\n\t\tdeq.push_back(x);\n\t}\n\tint cur = n;\n\tvector<int>ans;\n\twhile(cur>0){\n\t\tint cnt = 0;\n\t\twhile(deq.back()!=cur){\n\t\t\tcnt++;\n\t\t\tdeq.push_back(deq.front());\n\t\t\tdeq.pop_front();\n\t\t}\n\t\tdeq.pop_back();\n\t\tans.emplace_back(cnt);\n\t\tcur--;\n\t}\n\tfor(int i=n-1; i>=0; i--) cout<<ans[i]<<\" \"; cout<<'\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Twist the Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/100712",
    "editorial": "The first thing to notice the answer always exists. For numbers answer\r\nchoices, as well as permutation combinations. It remains only to restore\r\nthe answer from this permutation.We will restore by performing reverse\r\noperations. On the -th () operation will be selectd the first elements\r\nof the array and rotate them times to the left ( elements with numbers\r\nand more remain in their places).Where is equal to if , otherwise , and\r\nis the index of the number .Thus, for each from right to left,\r\nperforming a left cyclic shift operation, we move the number at index\r\n.As a result, we move numbers times. The time complexity .\r\n",
    "hint": []
}