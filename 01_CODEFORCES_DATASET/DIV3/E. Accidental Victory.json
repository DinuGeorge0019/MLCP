{
    "link": "https://codeforces.com//contest/1490/problem/E",
    "problemId": "898527",
    "problem_idx": "E",
    "shortId": "1490E",
    "contest_number": "1490",
    "problem_submissions": {
        "G": [
            107575670,
            107570582,
            107580395,
            107578386,
            107578722,
            107587817,
            107582372,
            107587644,
            107590224,
            107587234,
            107581021,
            107587494,
            107591578,
            107587278,
            107594584,
            107580527,
            107594840,
            107604479,
            107585353
        ],
        "F": [
            107567259,
            107563218,
            107559121,
            107563180,
            107570162,
            107559715,
            107565176,
            107569965,
            107573956,
            107565331,
            107557975,
            107565094,
            107575477,
            107563453,
            107578839,
            107563945,
            107577436,
            107545806,
            107574260
        ],
        "E": [
            107556406,
            107555209,
            107554466,
            107554504,
            107563766,
            107548069,
            107557392,
            107558375,
            107560045,
            107556903,
            107568704,
            107559054,
            107564526,
            107568622,
            107566562,
            107557990,
            107565929,
            107550803,
            107568788
        ],
        "D": [
            107547185,
            107546416,
            107549582,
            107548987,
            107555867,
            107556006,
            107548279,
            107551082,
            107551588,
            107551655,
            107551977,
            107552563,
            107556439,
            107553824,
            107619966,
            107554583,
            107548604,
            107553073,
            107559705,
            107559541
        ],
        "C": [
            107543774,
            107582544,
            107542780,
            107545198,
            107545514,
            107545604,
            107541435,
            107544848,
            107546219,
            107546179,
            107546602,
            107549060,
            107548247,
            107550636,
            107543227,
            107548011,
            107545321,
            107547310,
            107550641,
            107555122
        ],
        "B": [
            107541208,
            107540999,
            107543105,
            107543215,
            107543363,
            107548411,
            107542386,
            107543350,
            107543787,
            107544607,
            107545190,
            107541258,
            107543035,
            107541260,
            107543659,
            107551661,
            107545377,
            107544997,
            107550231
        ],
        "A": [
            107538772,
            107538836,
            107539535,
            107539200,
            107538915,
            107539471,
            107539499,
            107538905,
            107539830,
            107541268,
            107539601,
            107539113,
            107538995,
            107538895,
            107540166,
            107538768,
            107540499,
            107538751,
            107538933
        ]
    },
    "name": "E. Accidental Victory",
    "statement": "A championship is held in Berland, in which n players participate. The\r\nplayer with the number i has a_i (a_i\r\nge 1) tokens.The championship consists of n-1 games, which are played\r\naccording to the following rules: in each game, two random players with\r\nnon-zero tokens are selected; the player with more tokens is considered\r\nthe winner of the game (in case of a tie, the winner is chosen\r\nrandomly); the winning player takes all of the loser’s tokens; The last\r\nplayer with non-zero tokens is the winner of the championship.All random\r\ndecisions that are made during the championship are made equally\r\nprobable and independently.For example, if n=4, a = [1, 2, 4, 3], then\r\none of the options for the game (there could be other options) is:\r\nduring the first game, the first and fourth players were selected. The\r\nfourth player has more tokens, so he takes the first player’s tokens.\r\nNow a = [0, 2, 4, 4]; during the second game, the fourth and third\r\nplayers were selected. They have the same number of tokens, but in a\r\nrandom way, the third player is the winner. Now a = [0, 2, 8, 0]; during\r\nthe third game, the second and third players were selected. The third\r\nplayer has more tokens, so he takes the second player’s tokens. Now a =\r\n[0, 0, 10, 0]; the third player is declared the winner of the\r\nchampionship. Championship winners will receive personalized prizes.\r\nTherefore, the judges want to know in advance which players have a\r\nchance of winning, i.e have a non-zero probability of winning the\r\nchampionship. You have been asked to find all such players.\r\n",
    "solutions": [
        "#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nvector<pair<int, int>> v;\nvector<int> ans;\n\nint main()\n{\n\tint t;\n\tint n;\n\tint x;\n\tint i;\n\tint s;\n\tlong long sum;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tv.clear();\n\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x;\n\t\t\tv.push_back(make_pair(x, i + 1));\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tif (v[0].first == v[n - 1].first)\n\t\t{\n\t\t\tcout << n << '\\n';\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tcout << i << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tans.clear();\n\t\tsum = 0;\n\t\ts = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (sum < v[i].first)\n\t\t\t{\n\t\t\t\ts = i;\n\t\t\t}\n\n\t\t\tsum += v[i].first;\n\t\t}\n\n\t\tfor (i = s; i < n; i++)\n\t\t{\n\t\t\tans.push_back(v[i].second);\n\t\t}\n\n\t\tsort(ans.begin(), ans.end());\n\n\t\tcout << ans.size() << '\\n';\n\t\tfor (i = 0; i < ans.size(); i++)\n\t\t{\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Accidental Victory.json",
    "editorial_link": "https://codeforces.com//blog/entry/87874",
    "editorial": "How can a player be checked if he can win the championship? Obviously,\r\nhe must participate in all the games (otherwise we will increase the\r\nnumber of tokens of the opponents). So you can sort out all the people\r\nand play greedily with the weakest ones. Such a check will work in\r\nlinear time after sorting, so we got a solution for .The simplest\r\nsolution to this problem is binary search for the answer. We will sort\r\nall the players by the number of tokens they have. Letâs prove that if\r\nplayer can win, then player can also win (the numbers are dealt after\r\nsorting). If the player was able to win, then based on the strategy\r\nabove, he was able to defeat all the players on the prefix . The player\r\ncan also defeat all these players since he has at least as many tokens.\r\nNow both players have to defeat all opponents with numbers and the\r\nnumber of chips both players have is equal to the sum of the first\r\nnumbers in the array. So if the player has a strategy, then the player\r\ncan use the same strategy.Hence the answer to the problem is sorted\r\nsuffix of the input array. You can find this suffix using binary search\r\nand linear time checking.Bonus: this problem also has a fully linear\r\n(after sorting) solution.\r\n",
    "hint": []
}