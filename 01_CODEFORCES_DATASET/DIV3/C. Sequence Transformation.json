{"link": "https://codeforces.com//contest/1454/problem/C", "problemId": "808362", "problem_idx": "C", "shortId": "1454C", "contest_number": "1454", "problem_submissions": {"F": [99453540, 99460649, 99464491, 99462634, 99473778, 99480627, 99479512, 99481454, 99477847, 99480676, 99479843, 99479819, 99479502, 99484023, 99481094, 99490580, 99488276, 99483237, 99479347, 99483611, 99487863], "E": [99441379, 99441843, 99443837, 99448708, 99449197, 99455222, 99455619, 99453916, 99455714, 99453545, 99445866, 99465827, 99455361, 99467369, 99458698, 99458428, 99472900, 99479360, 99464656, 99473747], "D": [99425523, 99427863, 99428990, 99434572, 99428428, 99426135, 99429687, 99436442, 99439139, 99424677, 99437825, 99441009, 99434042, 99442449, 99447062, 99436193, 99440792, 99445227, 99448409, 99444791], "C": [99419955, 99419595, 99423754, 99425833, 99422653, 99419849, 99422609, 99424746, 99429403, 99428222, 99431585, 99425636, 99428930, 99432056, 99429114, 99423054, 99427497, 99444382, 99428490], "B": [99408996, 99409578, 99414483, 99418612, 99411159, 99409225, 99412165, 99413650, 99421215, 99411421, 99411800, 99420683, 99414143, 99411486, 99422648, 99414361, 99411697, 99416198, 99425925, 99418963], "A": [99404083, 99403968, 99404106, 99408387, 99404018, 99404036, 99404137, 99404612, 99409652, 99405438, 99405909, 99406625, 99408178, 99405245, 99412689, 99404230, 99404157, 99404843, 99418770, 99412328]}, "name": "C. Sequence Transformation", "statement": "You are given a sequence a, initially consisting of n integers.You want\r\nto transform this sequence so that all elements in it (i. e. it contains\r\nseveral occurrences of the same element).To achieve this, you choose\r\nsome integer x , and then perform the following operation any number of\r\ntimes (possibly zero): choose some segment [l, r] of the sequence and\r\nremove it. But there is one exception: . More formally, you choose some\r\ncontiguous subsequence [a_l, a_{l + 1},\r\ndots, a_r] such that a_i\r\nne x if l\r\nle i\r\nle r, and remove it. After removal, the numbering of elements to the\r\nright of the removed segment changes: the element that was the (r+1)-th\r\nis now l-th, the element that was (r+2)-th is now (l+1)-th, and so on\r\n(i. e. the remaining sequence just collapses).Note that you x after you\r\nchose it.For example, suppose n = 6, a = [1, 3, 2, 4, 1, 2]. Then one of\r\nthe ways to transform it in two operations is to choose x = 1, then:\r\nchoose l = 2, r = 4, so the resulting sequence is a = [1, 1, 2]; choose\r\nl = 3, r = 3, so the resulting sequence is a = [1, 1]. Note that\r\nchoosing x is not an operation. Also, note that you remove any\r\noccurrence of x.Your task is to find the number of operations required\r\nto transform the sequence in a way described above.You have to answer t\r\nindependent test cases.\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\", x.f, \", \", x.s, \"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? \", \" : \"\", a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\n    void setOut(string s) { freopen(s.c_str(), \"w\", stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + \".in\"), setOut(s + \".out\"); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO(\"\");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        vi use;\n        int it1 = 0;\n        int it2 = 0;\n        while (it1 != n) {\n            while (it2 != n-1 && a[it1] == a[it2+1]) it2++;\n            use.eb(a[it1]);\n            it1 = ++it2;\n        }\n        map<int, vi> cnt;\n        int sz = sz(use);\n        f0r(i, sz(use)) {\n            cnt[use[i]].eb(i);\n        }\n        if (sz(use) == 1) {\n            ps(0);\n            continue;\n        }\n        int ans = 1e9;\n        for (auto y : cnt) {\n            auto x = y.s;\n            if (x[0] == 0 && x.back() == sz-1) {\n                ckmin(ans, sz(x)-1);\n            } else if (x[0] == 0) {\n                ckmin(ans, sz(x));\n            } else if (x.back() == sz-1) {\n                ckmin(ans, sz(x));\n            } else {\n                ckmin(ans, sz(x)+1);\n            }\n        }\n        ps(ans);\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["greedy", "implementation"], "dificulty": "1200", "interactive": false}