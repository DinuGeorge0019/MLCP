{
    "link": "https://codeforces.com//contest/1433/problem/F",
    "problemId": "766661",
    "problem_idx": "F",
    "shortId": "1433F",
    "contest_number": "1433",
    "problem_submissions": {
        "E": [
            96118292,
            96100384,
            96144411,
            96131531,
            96126171,
            96116171,
            96143430,
            96124657,
            96110938,
            96142211,
            96123301,
            96164122,
            96137865,
            96137248,
            96139372,
            96151324,
            96105901,
            96108332,
            96119162
        ],
        "D": [
            96108021,
            96096525,
            96105972,
            96112718,
            96099052,
            96105757,
            96102154,
            96119014,
            96106156,
            96111319,
            96110517,
            96107146,
            96106344,
            96110999,
            96119720,
            96108556,
            96096494,
            96100784,
            96104899
        ],
        "F": [
            96105759,
            96110506,
            96119004,
            96125972,
            96132730,
            96142830,
            96120574,
            96135431,
            96163807,
            96138553,
            96152985,
            96127650,
            96151526,
            96153346,
            96158052,
            96144943,
            96148733,
            96135208
        ],
        "C": [
            96102081,
            96092029,
            96090502,
            96100255,
            96092651,
            96097485,
            96096234,
            96096200,
            96099117,
            96101166,
            96102838,
            96101507,
            96097647,
            96094575,
            96113560,
            96103107,
            96090286,
            96093702,
            96099170
        ],
        "G": [
            96094218,
            96125410,
            96128032,
            96141154,
            96154260,
            96149033,
            96156333,
            96142357,
            96139797,
            96146497,
            96163476,
            96140362,
            96161234,
            96163894,
            96152235,
            96163050,
            96123944,
            96205637
        ],
        "B": [
            96092183,
            96084902,
            96085565,
            96094926,
            96088334,
            96090362,
            96089755,
            96089494,
            96088669,
            96093848,
            96088026,
            96089177,
            96087731,
            96090077,
            96098934,
            96093459,
            96086464,
            96086371,
            96090772
        ],
        "A": [
            96084957,
            96082729,
            96082939,
            96083168,
            96082835,
            96084005,
            96082966,
            96083516,
            96083887,
            96086611,
            96083211,
            96084639,
            96083406,
            96083239,
            96092645,
            96083081,
            96082670,
            96083000,
            96085692
        ]
    },
    "name": "F. Zero Remainder Sum ",
    "statement": "You are given a matrix a of size n\r\ntimes m consisting of integers.You can choose\r\nleft\r\nlfloor\r\nfrac{m}{2}\r\nright\r\nrfloor elements in . Your task is to choose these elements in such a way\r\nthat their sum is k and this sum is the .In other words, you can choose\r\nno more than a half (rounded down) of elements in each row, you have to\r\nfind the maximum sum of these elements divisible by k.Note that you can\r\nchoose zero elements (and the sum of such set is 0).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint hmt() {int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';if(n) x=-x;return x;}\n#define in hmt()\n#define ins ({string x;char c=getchar();for(;c==' '||c=='\\n';c=getchar());for(;c!=' '&&c!='\\n';c=getchar()) x+=c;x;})\n#define forinc(i,a,b) for(int i=a,_b=b;i<=_b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forb(i,BS) for(int i=BS._Find_first();i< BS.size();i = BS._Find_next(i))\n#define timer 1.0*clock()/CLOCKS_PER_SEC\n#define forv(a,b) for(auto &a:b)\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define reset(f,x) memset(f,x,sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define onbit(x,i) (x|(1<<(i-1)))\n#define offbit(x,i) (x&~(1<<(i-1)))\nconst int N=75;\nint m,n,k,a[N][N],f[N][N][N][N];\nvoid maxi(int &a,int b)\n{\n    a=max(a,b);\n}\nint main()\n{\n    //freopen(\"1433F.inp\",\"r\",stdin);\n    m=in,n=in,k=in;\n    forinc(i,1,m) forinc(j,1,n) a[i][j]=in;\n    reset(f,-1);\n    f[1][0][0][0]=0;\n    forinc(i,1,m)\n    {\n        forinc(j,1,n) forinc(t,0,min(j-1,n/2)) forinc(c,0,k-1) if(f[i][j-1][t][c]!=-1)\n        {\n            maxi(f[i][j][t][c],f[i][j-1][t][c]);\n            maxi(f[i][j][t+1][(c+a[i][j])%k],f[i][j-1][t][c]+a[i][j]);\n        }\n        forinc(t,0,n/2) forinc(c,0,k-1) maxi(f[i+1][0][0][c],f[i][n][t][c]);\n    }\n    cout<<f[m+1][0][0][0]<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Zero Remainder Sum .json",
    "editorial_link": "https://codeforces.com//blog/entry/83903",
    "editorial": "This is pretty standard dynamic programming problem. Let be the maximum\r\npossible sum we can obtain if we are at the element right now, we took\r\nelements in the row and our current remainder is .Initially, all states\r\nare except .Transitions are standard because this is a knapsack problem:\r\nwe either take the element if or don\u00e2\u0080\u0099t take it. If the element is not\r\nthe last element of the row, then transitions look like that: we don\u00e2\u0080\u0099t\r\ntake the current element. we take the current element (this transition\r\nis only possible if ). The transitions from the last element of the row\r\nare almost the same, but the next element is and the new value of is\r\nalways zero.The answer is .\r\n"
}