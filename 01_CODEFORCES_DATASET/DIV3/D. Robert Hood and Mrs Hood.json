{
    "link": "https://codeforces.com//contest/2014/problem/D",
    "problemId": "2892476",
    "problem_idx": "D",
    "shortId": "2014D",
    "contest_number": "2014",
    "problem_submissions": {
        "G": [
            282355237,
            282340908,
            282349517,
            282469109,
            282768209
        ],
        "H": [
            282319139,
            282294919,
            282369641,
            282327328,
            282344971,
            282343427,
            282320463,
            282354346,
            282338340,
            282341971,
            282345189,
            282359227,
            282335882,
            282356841,
            282332486,
            282259554,
            282367573,
            282358571,
            282340140,
            282354845,
            282340779
        ],
        "F": [
            282310940,
            282344360,
            282329041,
            282301003,
            282317626,
            282346191,
            282313376,
            282324314,
            282336360,
            282330209,
            282316236,
            282352931,
            282339107,
            282367052,
            282355481,
            282342400,
            282311004,
            282354051,
            282348444,
            282360261
        ],
        "E": [
            282298135,
            282347444,
            282324784,
            282315211,
            282288353,
            282301236,
            282298734,
            282299501,
            282311127,
            282309362,
            282313492,
            282303867,
            282309804,
            282310056,
            282314491,
            282344707,
            282319635,
            282302427,
            282313050,
            282331264,
            282317148
        ],
        "D": [
            282266365,
            282262468,
            282284761,
            282266186,
            282281624,
            282263914,
            282278929,
            282290066,
            282285534,
            282292322,
            282283633,
            282303511,
            282281064,
            282294495,
            282319933,
            282298383,
            282290687,
            282285759,
            282297433,
            282291388
        ],
        "C": [
            282245761,
            282249551,
            282267820,
            282250356,
            282260562,
            282251055,
            282251810,
            282263518,
            282256201,
            282252015,
            282260274,
            282248128,
            282257994,
            282266861,
            282299616,
            282253349,
            282254086,
            282264623,
            282276303,
            282262355
        ],
        "B": [
            282235337,
            282236894,
            282246106,
            282232521,
            282241668,
            282237594,
            282243258,
            282239802,
            282239576,
            282238146,
            282241956,
            282238965,
            282240579,
            282237329,
            282279188,
            282240894,
            282242478,
            282240040,
            282236073,
            282244164,
            282271471
        ],
        "A": [
            282225117,
            282225433,
            282233872,
            282225077,
            282234075,
            282225216,
            282226675,
            282226848,
            282232220,
            282227137,
            282231989,
            282227272,
            282229469,
            282228546,
            282236816,
            282226223,
            282233092,
            282227477,
            282229182,
            282226562
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134210",
    "editorial": "Since the number of days n\n is capped, we can check all possible start day x\n in range [1,n?d+1]\n (so that the duration of d\n days would fit). We would like to find the number of overlapped jobs for each value of x\n.\n\nA job between days li\n and ri\n would overlap with the visit if the start day x\n satisfies li?d+1?x?ri\n. Naively, this range update could be potentially O(n)\n, which is too slow. However, noting the start and end, each job update could be done in 2\n operations. We add +1\n at li?d+1\n and ?1\n at ri+1\n, and after all jobs are recorded, we will take a prefix sum to work out the number of overlapped jobs for each x\n. When li?d+1\n drops below 1\n, we simply use 1\n to avoid lower values which are not being considered for x\n.\n\nThe time complexity is O(n)\n.\n\nNote: Robin's risky jobs are generally deemed illegal by the Sheriff of Nottingham. Robert is practical and helpful. Like all good parents, Mrs Hood is a worrier.",
    "name": "D. Robert Hood and Mrs Hood",
    "statement": "Robin\u2019s brother and mother are visiting, and Robin gets to choose the\r\nstart day for each visitor.All days are numbered from 1 to n. Visitors\r\nstay for d continuous days, all of those d days must be between day 1\r\nand n inclusive.Robin has a total of k risky \u2019jobs\u2019 planned. The i-th\r\njob takes place between days l_i and r_i inclusive, for 1\r\nle i\r\nle k. If a job takes place on any of the d days, the visit overlaps with\r\nthis job (the length of overlap is unimportant).Robin wants his\r\nbrother\u2019s visit to overlap with the maximum number of , and his mother\u2019s\r\nthe minimum.Find suitable start days for the visits of Robin\u2019s brother\r\nand mother. If there are multiple suitable days, choose the earliest\r\none.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, d, k;PII a[N];vector<int> e[N];void solve(){    cin >> n >> d >> k;    for (int i = 1; i <= n; i++)        e[i].clear();    for (int i = 1; i <= k; i++)    {        int l, r;        cin >> l >> r;        e[l].push_back(r);    }    priority_queue<int, vector<int>, greater<int>> q;    PII ans;    for (int i = 1; i <= d; i++)    {        for (auto to : e[i])            q.push(to);    }    ans = {q.size(), -1};    PII ans2 = {ans.first, 1};    for (int i = 2; i <= n - d + 1; i++)    {        while (!q.empty() && q.top() < i)            q.pop();        for (auto to : e[i + d - 1])            q.push(to);        ans = max(ans, {(int)q.size(), -i});        ans2 = min(ans2, {(int)q.size(), i});    }    cout << -ans.second << ' ' << ans2.second << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Robert Hood and Mrs Hood.json"
}