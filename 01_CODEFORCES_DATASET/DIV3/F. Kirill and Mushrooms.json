{
    "link": "https://codeforces.com//contest/1945/problem/F",
    "problemId": "2540241",
    "problem_idx": "F",
    "shortId": "1945F",
    "contest_number": "1945",
    "problem_submissions": {
        "G": [
            252240841,
            252250866,
            252420396,
            252278722,
            252525005,
            252548158,
            252390608,
            252567317,
            252552741
        ],
        "E": [
            252219497,
            252219260,
            252213387,
            252225102,
            252223337,
            252221318,
            252228596,
            252237032,
            252235746,
            252231786,
            252228604,
            252232973,
            252223877,
            252227459,
            252232102,
            252227652,
            252224399,
            252228708,
            252219208,
            252234028,
            252232706,
            252237279,
            252235482
        ],
        "F": [
            252212698,
            252234280,
            252233067,
            252234341,
            252240611,
            252234408,
            252239611,
            252243237,
            252244691,
            252376596,
            252238557,
            252239689,
            252241751,
            252248456,
            252244763,
            252248686,
            252238419,
            252251638,
            252253337,
            252249409,
            252253972,
            252250630
        ],
        "C": [
            252206245,
            252207712,
            252202451,
            252208700,
            252207454,
            252210649,
            252206365,
            252207126,
            252207020,
            252209180,
            252213309,
            252203687,
            252209170,
            252214626,
            252209187,
            252244934,
            252208556,
            252217228,
            252213088,
            252217154
        ],
        "D": [
            252198864,
            252212223,
            252207311,
            252216917,
            252210946,
            252214851,
            252215523,
            252213673,
            252211331,
            252213241,
            252218189,
            252208559,
            252214624,
            252218088,
            252216560,
            252210697,
            252213737,
            252221839,
            252218355,
            252222523
        ],
        "B": [
            252195700,
            252203456,
            252197691,
            252195312,
            252198069,
            252200483,
            252199692,
            252199256,
            252205068,
            252202776,
            252197737,
            252197316,
            252200847,
            252199778,
            252199654,
            252195229,
            252204485,
            252203677,
            252200862
        ],
        "A": [
            252193249,
            252196517,
            252194020,
            252193609,
            252194534,
            252195163,
            252195841,
            252195267,
            252193567,
            252198736,
            252193769,
            252193858,
            252193912,
            252195503,
            252195367,
            252193377,
            252195907,
            252194634,
            252196929
        ],
        "H": [
            252530309,
            252556908
        ]
    },
    "name": "F. Kirill and Mushrooms",
    "statement": "As soon as everyone in the camp fell asleep, Kirill sneaked out of the\r\ntent and went to the Wise Oak to gather mushrooms.It is known that there\r\nare n mushrooms growing under the Oak, each of which has magic power\r\nv_i. Kirill really wants to make a magical elixir of maximum strength\r\nfrom the mushrooms.The strength of the elixir is equal to the product of\r\nthe of mushrooms in it and the magic power among these mushrooms. To\r\nprepare the elixir, Kirill will sequentially pick one mushroom growing\r\nunder the Oak. Kirill can gather mushrooms in any order.However, it\u2019s\r\nnot that simple. The Wise Oak informed Kirill of a permutation of\r\nnumbers p from 1 to n. If Kirill picks only k mushrooms, then the magic\r\npower of all mushrooms with indices p_1, p_2,\r\ndots, p_{k - 1} will become 0. Kirill will not use mushrooms with zero\r\nmagic power to prepare the elixir.Your task is to help Kirill gather\r\nmushrooms in such a way that he can brew the elixir of maximum possible\r\nstrength. However, Kirill is a little scared to stay near the oak for\r\ntoo long, so out of all the suitable options for gathering mushrooms, he\r\nasks you to find the one with the minimum number of mushrooms.A\r\npermutation of length n is an array consisting of n different integers\r\nfrom 1 to n in any order. For example, [2,3,1,5,4] is a permutation, but\r\n[1,2,2] is not a permutation (2 appears in the array twice) and [1,3,4]\r\nis also not a permutation (n=3, but 4 appears in the array).\r\n",
    "solutions": [
        "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll INF = LLONG_MAX, MOD = 1e9 + 7, P = 239;\nconst ld PI = 3.1415926535897938462643383279502, EPS = 1e-7;\n\ntemplate <typename T>\ninline ll sz(const T &a) {\n    return a.size();\n}\n\ntemplate <typename T, typename C>\nistream &operator >> (istream &in, pair<T, C> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <typename T, typename C>\nostream &operator << (ostream &out, pair<T, C> a) {\n    return out << a.first << ' ' << a.second;\n}\n\ntemplate <typename T>\nistream & operator >> (istream &in, vector<T> &a) {\n    for (auto &i : a) {\n        in >> i;\n    }\n    return in;\n}\n\ntemplate <typename T>\nostream &operator << (ostream &out, vector<T> a) {\n    for (auto i : a) {\n        out << i << ' ';\n    }\n    return out;\n}\n\ntemplate <typename T>\nvoid print(vector<T> a, string c = \"\\n\") {\n    for (T i : a) {\n        cout << i << c;\n    }\n}\n\nvoid solve() {\n    ll n;\n    cin >> n;\n    vector<ll> v(n);\n    cin >> v;\n    vector<ll> p(n);\n    cin >> p;\n    vector<ll> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = v[p[i] - 1];\n    }\n    multiset<int, greater<>> not_in;\n    for (int i = 0; i < n; ++i) {\n        not_in.insert(a[i]);\n    }\n    multiset<int> in;\n    ll ans = 0, mn = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) {\n            if (not_in.find(a[i - 1]) != not_in.end()) {\n                not_in.erase(not_in.find(a[i - 1]));\n            } else {\n                in.erase(in.find(a[i - 1]));\n            }\n        }\n        while (sz(in) < i + 1 && !not_in.empty()) {\n            in.insert(*not_in.begin());\n            not_in.erase(not_in.begin());\n        }\n        if (sz(in) < i + 1) {\n            break;\n        }\n        if (*in.begin() * sz(in) > ans) {\n            ans = *in.begin() * sz(in);\n            mn = i + 1;\n        }\n    }\n    cout << ans << ' ' << mn;\n}\n\nsigned main() {\n#ifdef LOCAL\n    freopen(\"inp.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n    freopen(\"err.txt\", \"w\", stderr);\n\n    auto start_time = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int times = 1;\n    cin >> times;\n    while (times--)\n        solve(), cout << '\\n';\n\n#ifdef LOCAL\n    auto end_time = clock();\n    cerr << setprecision(3) << fixed << \"Execution time: \" << (end_time - start_time) * (int) 1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Kirill and Mushrooms.json",
    "editorial_link": "https://codeforces.com//blog/entry/127377",
    "editorial": "Consider a fixed number the amount of mushrooms in the elixir. In this\r\ncase, we need to maximize the minimum of the taken numbers. We will\r\niterate through the numbers in descending order: until we collect\r\nnumbers, we iterate over the next number. If its index is greater than\r\nor equal to , we take this number as the answer, otherwise we skip it.If\r\nwe iterate through , we get a solution in time. How can we speed it up?\r\nNotice that at incrementing , only a few numbers change: becomes zero,\r\nif we have already taken it, then we need to take the next one in\r\ndescending order. Also, we need to take the next number in descending\r\norder, because we are incrementing . After sorting, we can traverse the\r\narray in linear time. We keep a pointer to the last taken element, as\r\nwell as an array whether the -th number is taken, and an array whether\r\nthe -th number is turned into zero. Every time we move , we check that ,\r\nand if so, we take the number and set .Complexity: .\r\n"
}