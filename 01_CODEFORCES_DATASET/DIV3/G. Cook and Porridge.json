{
    "link": "https://codeforces.com//contest/1945/problem/G",
    "problemId": "2540242",
    "problem_idx": "G",
    "shortId": "1945G",
    "contest_number": "1945",
    "problem_submissions": {
        "G": [
            252240841,
            252250866,
            252420396,
            252278722,
            252525005,
            252548158,
            252390608,
            252567317,
            252552741
        ],
        "E": [
            252219497,
            252219260,
            252213387,
            252225102,
            252223337,
            252221318,
            252228596,
            252237032,
            252235746,
            252231786,
            252228604,
            252232973,
            252223877,
            252227459,
            252232102,
            252227652,
            252224399,
            252228708,
            252219208,
            252234028,
            252232706,
            252237279,
            252235482
        ],
        "F": [
            252212698,
            252234280,
            252233067,
            252234341,
            252240611,
            252234408,
            252239611,
            252243237,
            252244691,
            252376596,
            252238557,
            252239689,
            252241751,
            252248456,
            252244763,
            252248686,
            252238419,
            252251638,
            252253337,
            252249409,
            252253972,
            252250630
        ],
        "C": [
            252206245,
            252207712,
            252202451,
            252208700,
            252207454,
            252210649,
            252206365,
            252207126,
            252207020,
            252209180,
            252213309,
            252203687,
            252209170,
            252214626,
            252209187,
            252244934,
            252208556,
            252217228,
            252213088,
            252217154
        ],
        "D": [
            252198864,
            252212223,
            252207311,
            252216917,
            252210946,
            252214851,
            252215523,
            252213673,
            252211331,
            252213241,
            252218189,
            252208559,
            252214624,
            252218088,
            252216560,
            252210697,
            252213737,
            252221839,
            252218355,
            252222523
        ],
        "B": [
            252195700,
            252203456,
            252197691,
            252195312,
            252198069,
            252200483,
            252199692,
            252199256,
            252205068,
            252202776,
            252197737,
            252197316,
            252200847,
            252199778,
            252199654,
            252195229,
            252204485,
            252203677,
            252200862
        ],
        "A": [
            252193249,
            252196517,
            252194020,
            252193609,
            252194534,
            252195163,
            252195841,
            252195267,
            252193567,
            252198736,
            252193769,
            252193858,
            252193912,
            252195503,
            252195367,
            252193377,
            252195907,
            252194634,
            252196929
        ],
        "H": [
            252530309,
            252556908
        ]
    },
    "name": "G. Cook and Porridge",
    "statement": "Finally, lunchtime!n schoolchildren have lined up in a long queue at the\r\ncook’s tent for porridge. The cook will be serving porridge for D\r\nminutes. The schoolchild standing in the i-th position in the queue has\r\na priority of k_i and eats one portion of porridge in s_i minutes. of\r\neach minute of the break, the cook serves the first schoolchild in the\r\nqueue one portion of porridge, after which the schoolchild goes to eat\r\ntheir portion. If the i-th schoolchild is served a portion at the\r\nbeginning of the x-th minute, then they will return to the queue of the\r\n(x + s_i)-th minute.When the i-th schoolchild returns to the queue, the\r\nschoolchildren at the end of the queue whose priority is than that of\r\nthe i-th schoolchild must let them pass. Thus, they will stand in the\r\nqueue behind the last schoolchild whose priority is than their own. That\r\nis, behind the last schoolchild j with k_j\r\nge k_i. If there is no such schoolchild in the queue, the i-th\r\nschoolchild will stand at the front of the queue.If several\r\nschoolchildren return at the same time, they will return to the queue in\r\nascending order of their s_i.For example, if n = 3, D = 3, k = [2, 3,\r\n2], and s = [2, 1, 3], the serving will occur as follows: At the\r\nbeginning of minute 1, the students in the queue are [1, 2, 3], and\r\nstudent 1 is served porridge; at the beginning of minute 2, the students\r\nin the queue are [2, 3], and student 2 is served porridge; at the\r\nbeginning of minute 3, the student in the queue is [3], and student 3 is\r\nserved porridge; at the end of minute 3, student 2 returns to the queue,\r\nand the queue becomes [2]; at the end of minute 3, student 1 returns to\r\nthe queue, and the queue becomes [2, 1], as his priority is lower.\r\nDetermine the minimum number of minutes after the start of the break\r\nthat each schoolchild will receive porridge at least once, or report\r\nthat this will not happen within D minutes.\r\n",
    "solutions": [
        "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll INF = LLONG_MAX, MOD = 1e9 + 7, P = 239;\nconst ld PI = 3.1415926535897938462643383279502, EPS = 1e-7;\n\ntemplate <typename T>\ninline ll sz(const T &a) {\n    return a.size();\n}\n\ntemplate <typename T, typename C>\nistream &operator >> (istream &in, pair<T, C> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <typename T, typename C>\nostream &operator << (ostream &out, pair<T, C> a) {\n    return out << a.first << ' ' << a.second;\n}\n\ntemplate <typename T>\nistream & operator >> (istream &in, vector<T> &a) {\n    for (auto &i : a) {\n        in >> i;\n    }\n    return in;\n}\n\ntemplate <typename T>\nostream &operator << (ostream &out, vector<T> a) {\n    for (auto i : a) {\n        out << i << ' ';\n    }\n    return out;\n}\n\ntemplate <typename T>\nvoid print(vector<T> a, string c = \"\\n\") {\n    for (T i : a) {\n        cout << i << c;\n    }\n}\n\nmt19937 rnd(123);\n\nstruct Node {\n    ll v, y, s, mx, id;\n    Node *L, *R;\n    Node(ll vv = 0, ll idx = 0, ll yy = rnd()) {\n        v = vv;\n        y = yy;\n        id = idx;\n        mx = v;\n        s = 1;\n        L = nullptr;\n        R = nullptr;\n    }\n};\n\nll sz(Node* r) {\n    if (r == nullptr) {\n        return 0;\n    }\n    return r->s;\n}\n\nll mx(Node* r) {\n    if (r == nullptr) {\n        return -INF;\n    }\n    return r->mx;\n}\n\nvoid update(Node* r) {\n    if (r == nullptr) {\n        return;\n    }\n    r->s = sz(r->L) + sz(r->R) + 1;\n    r->mx = max({mx(r->L), mx(r->R), r->v});\n}\n\nNode* merge(Node *a, Node *b) {\n    if (a == nullptr) {\n        return b;\n    }\n    if (b == nullptr) {\n        return a;\n    }\n    if (a->y < b->y) {\n        a->R = merge(a->R, b);\n        update(a);\n        return a;\n    } else {\n        b->L = merge(a, b->L);\n        update(b);\n        return b;\n    }\n}\n\npair<Node*, Node*> split(Node* r, ll k) {\n    if (r == nullptr) {\n        return {nullptr, nullptr};\n    }\n    if (sz(r->L) >= k) {\n        auto p = split(r->L, k);\n        r->L = p.second;\n        update(r);\n        return {p.first, r};\n    } else {\n        auto p = split(r->R, k - sz(r->L) - 1);\n        r->R = p.first;\n        update(r);\n        return {r, p.second};\n    }\n}\n\nNode* insert(Node *r, ll k, ll x, ll i) {\n    auto p = split(r, k);\n    Node *n = new Node(x, i);\n    return merge(p.first, merge(n, p.second));\n}\n\npair<Node*, Node*> erase_first(Node* r) {\n    auto p = split(r, 1);\n    return p;\n}\n\nll fnd(Node* r, ll x) {\n    if (r == nullptr) {\n        return 0;\n    }\n    if (mx(r->R) >= x) {\n        return sz(r->L) + 1 + fnd(r->R, x);\n    } else if (r->v >= x) {\n        return sz(r->L);\n    } else {\n        return fnd(r->L, x);\n    }\n}\n\nvoid solve() {\n    ll n, d;\n    cin >> n >> d;\n    vector<ll> k(n), s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> k[i] >> s[i];\n    }\n    Node* r = nullptr;\n    for (int i = 0; i < n; ++i) {\n        r = insert(r, i, k[i], i);\n    }\n    vector<ll> ans(n, INF);\n    map<int, vector<int>> ret;\n    for (ll i = 1; i <= d; ++i) {\n        if (r != nullptr) {\n            Node* fst;\n            tie(fst, r) = erase_first(r);\n            ans[fst->id] = min(ans[fst->id], i);\n            ret[i + s[fst->id]].push_back(fst->id);\n        }\n        if (!ret[i].empty()) {\n            auto v = ret[i];\n            sort(v.begin(), v.end(), [&](ll fst, ll sec) {\n                return s[fst] < s[sec];\n            });\n            for (int j : v) {\n                ll idx = fnd(r, k[j]);\n                if (mx(r) < k[j]) {\n                    r = insert(r, 0, k[j], j);\n                } else {\n                    r = insert(r, idx + 1, k[j], j);\n                }\n            }\n        }\n    }\n    ll answer = *max_element(ans.begin(), ans.end());\n    cout << (answer == INF ? -1 : answer);\n}\n\nsigned main() {\n#ifdef LOCAL\n    freopen(\"inp.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n    freopen(\"err.txt\", \"w\", stderr);\n\n    auto start_time = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int times = 1;\n    cin >> times;\n    while (times--)\n        solve(), cout << '\\n';\n\n#ifdef LOCAL\n    auto end_time = clock();\n    cerr << setprecision(3) << fixed << \"Execution time: \" << (end_time - start_time) * (int) 1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Cook and Porridge.json",
    "editorial_link": "https://codeforces.com//blog/entry/127377",
    "editorial": "Letâs divide the queue into two parts: the original queue and the\r\nreturning people queue . will simply be an array with a pointer to the\r\ncurrent person at the front. And will be a priority queue. Now the\r\nproblem can be formulated as follows: find out how much time it will\r\ntake for to become equal to .Letâs iterate through the time. At each\r\nmoment, the cook serves porridge to either a person from or from . How\r\ndo we know which one? Letâs calculate an array of suffix maximums for .\r\nNow itâs clear that if (here is the priority of student ), then there is\r\nstill someone in with a higher than the one who wants to return, so at\r\nthe next moment the cook will serve porridge to a person from .\r\nOtherwise, the person with the maximum appetite from can bypass everyone\r\nfrom and get the porridge.To form , we will store an array of arrays ,\r\nwhere is the list of people who will return to the queue at the end of\r\nthe -th minute.Then we simply need to simulate this process. The answer\r\nwill be the moment when becomes equal to .Complexity:\r\n",
    "hint": []
}