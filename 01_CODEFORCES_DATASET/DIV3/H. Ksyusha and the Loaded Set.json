{
    "link": "https://codeforces.com//contest/2000/problem/H",
    "problemId": "2814034",
    "problem_idx": "H",
    "shortId": "2000H",
    "contest_number": "2000",
    "problem_submissions": {
        "H": [
            276260761,
            276254307,
            276338511,
            276338125,
            276287387,
            276274340,
            276297740,
            276283267,
            276239793
        ],
        "G": [
            276214295,
            276274205,
            276334839,
            276268681,
            276267752,
            276333913,
            276264214,
            276282487,
            276272917,
            276276698,
            276277916,
            276283043,
            276274434,
            276291075,
            276278976,
            276290903,
            276279110,
            276279777
        ],
        "F": [
            276187296,
            276292316,
            276241660,
            276217578,
            276210913,
            276233999,
            276287795,
            276243858,
            276234274,
            276242694,
            276256602,
            276245569,
            276246137,
            276247924,
            276245207,
            276252538,
            276247124,
            276252754
        ],
        "E": [
            276164357,
            276333842,
            276186649,
            276185811,
            276179141,
            276203373,
            276182533,
            276188814,
            276185638,
            276210532,
            276225686,
            276198909,
            276209550,
            276178261,
            276202986,
            276227179,
            276202989,
            276229818,
            276227160
        ],
        "D": [
            276136722,
            276189642,
            276169653,
            276164982,
            276157636,
            276177807,
            276157222,
            276166197,
            276153213,
            276123696,
            276151555,
            276167672,
            276198896,
            276149967,
            276172892,
            276184459,
            276158053,
            276189336,
            276175071,
            276189558
        ],
        "C": [
            276127716,
            276172717,
            276135515,
            276132005,
            276139984,
            276155253,
            276134367,
            276142615,
            276142046,
            276180920,
            276133384,
            276141737,
            276151150,
            276139308,
            276147822,
            276167768,
            276145316,
            276158457,
            276159660,
            276137717
        ],
        "B": [
            276113898,
            276143388,
            276119169,
            276116606,
            276127808,
            276130717,
            276117856,
            276125745,
            276187672,
            276126451,
            276118391,
            276127646,
            276126167,
            276125801,
            276113780,
            276142176,
            276122501,
            276133620,
            276118200,
            276121342
        ],
        "A": [
            276110192,
            276136464,
            276111783,
            276110916,
            276119966,
            276120191,
            276111146,
            276116630,
            276117760,
            276111077,
            276112237,
            276116291,
            276115237,
            276115760,
            276110510,
            276123000,
            276110417,
            276117261,
            276112340,
            276130762
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132689",
    "editorial": "We will maintain the elements of a set in . We will also maintain a of\r\nfree segments (in the form of half-intervals). These segments can be\r\neasily updated during insertion and deletion operations. In one case, we\r\nneed to remove a large segment and insert two small ones; in another\r\ncase, we need to remove two small ones and insert one large segment. We\r\nwill find suitable segments using .To answer the query , we will\r\nmaintain a Cartesian tree, where the keys are pairs . Additionally, we\r\nwill store the minimum of all left boundaries at the nodes. Now, to\r\nanswer the query, it is sufficient to cut the Cartesian tree at and take\r\nthe minimum from the stored minimums.The time complexity of the solution\r\nis: .\r\n",
    "name": "H. Ksyusha and the Loaded Set",
    "statement": "Ksyusha decided to start a game development company. To stand out among\r\ncompetitors and achieve success, she decided to write her own game\r\nengine. The engine must support a set initially consisting of n distinct\r\nintegers a_1, a_2,\r\nldots, a_n.The set will undergo m operations sequentially. The\r\noperations can be of the following types: Insert element x into the set;\r\nRemove element x from the set; Report the k-load of the set. The k-load\r\nof the set is defined as the integer d such that the integers d, d + 1,\r\nldots, d + (k - 1) do not appear in this set. For example, the 3-load of\r\nthe set\r\n{3, 4, 6, 11\r\n} is 7, since the integers 7, 8, 9 are absent from the set, and no\r\nsmaller value fits.Ksyusha is busy with management tasks, so you will\r\nhave to write the engine. Implement efficient support for the described\r\noperations.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include<array>using namespace std;#define ll long long//#define int long long#define y1 idfsu#define PII pair<int, int>#define fi first#define se second#define endl \"\\n\"const int MAX = 1e9;const int NN= 2e6 + 1;const int mod = 1e9 + 7;const int N = 100010;int tr[10000010];void build(int id, int l, int r){    if (l == r)        tr[id] = 0;    else    {        int mid = l + r >> 1;        build(id * 2, l, mid);        build(id * 2 + 1, mid + 1, r);        tr[id] = max(tr[id * 2], tr[id * 2 + 1]);    }}void change(int id, int l, int r, int wz, int z){    if (l == r)        tr[id] = z;    else    {        int mid = l + r >> 1;        if (mid >= wz)            change(id * 2, l, mid, wz, z);        else            change(id * 2 + 1, mid + 1, r, wz, z);        tr[id] = max(tr[id * 2], tr[id * 2 + 1]);    }}int cx(int id, int l, int r, int l1, int r1){    if (l == l1 && r == r1)        return tr[id];    int mid = l + r >> 1;    if (mid >= r1)        return cx(id * 2, l, mid, l1, r1);    else if (mid < l1)        return cx(id * 2, mid + 1, r, l1, r1);    else        return max(cx(id * 2, l, mid, l1, mid), cx(id * 2 + 1, mid + 1, r, mid + 1, r1));}void solve(){    int n;    set<int>k;    cin >> n;    for (int i = 1; i <= n; i++)    {        int a;        cin >> a;        k.insert(a);    }    k.insert(0);    int syg = 0;    for (auto i : k)    {        if (i == 0)            continue;        int z = i - syg - 1;        change(1, 1, NN, syg + 1, z);        syg = i;    }    change(1, 1, NN, syg + 1, 2e6);    int m;    cin >> m;    vector<int>ans;    while (m--)    {        char yy;        cin >> yy;        if (yy == '-')        {            int a;            cin >> a;            auto now = k.lower_bound(a);            change(1, 1, NN, (*now) + 1, 0);            now--;            change(1, 1, NN, (*now) + 1, 0);            auto nt = now;            now++;            k.erase(now);            now = nt;            nt++;            if (nt == k.end())                change(1, 1, NN, (*now) + 1, 2e6);            else                change(1, 1, NN , (*now) + 1, (*nt) - (*now) - 1);        }        else if (yy == '?')        {            int a;            cin >> a;            int now = 1, l = 1, r = NN;            while (l < r)            {                int mid = l + r >> 1;                if (tr[now * 2] >= a)                    r = mid, now *= 2;                else                    l = mid + 1, now = now * 2 + 1;            }            ans.push_back(l);        }        else        {            int a;            cin >> a;            auto now = k.lower_bound(a);            now--;            change(1, 1, NN, (*now) + 1, 0);            k.insert(a);            auto nt = now;            nt++;            change(1, 1, NN, (*now) + 1, (*nt) - (*now) - 1);            now++;            nt++;            if (nt == k.end())                change(1, 1, NN, (*now) + 1, 2e6);            else                change(1, 1, NN, (*now) + 1, (*nt) - (*now) - 1);        }    }    syg = 0;    for (auto i : k)    {        if (i == 0)            continue;        change(1, 1, NN, syg + 1, 0);        syg = i;    }    change(1, 1, NN, syg + 1, 0);    for (auto i : ans)        cout << i << ' ';    cout << endl;}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    build(1, 1, NN);    int T = 1;    cin >> T;    while (T--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\H. Ksyusha and the Loaded Set.json"
}