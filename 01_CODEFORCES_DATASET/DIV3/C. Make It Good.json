{"link": "https://codeforces.com//contest/1385/problem/C", "problemId": "675200", "problem_idx": "C", "shortId": "1385C", "contest_number": "1385", "problem_submissions": {"G": [87146925, 87130516, 87130073, 87149307, 87139436, 87145109, 87113469, 87137001, 87178119, 87121112], "F": [87133863, 87148212, 87150419, 87133069, 87155521, 87156261, 87129136, 87201006, 87199143, 87198211, 87198141, 87197991, 87133163, 87135084, 87147650, 87153475, 87157087, 87159161, 87143942, 87140750, 87158980], "E": [87121743, 87094311, 87150777, 87112227, 87117131, 87137692, 87154530, 87109484, 87118031, 87151551, 87126695, 87130754, 87122234, 87145112, 87156780, 87154434, 87141435, 87122925, 87129785], "D": [87114357, 87136398, 87136307, 87098537, 87103655, 87133732, 87148068, 87097110, 87107447, 87106449, 87137139, 87106363, 87103887, 87118780, 87124754, 87090612, 87122982, 87110063, 87101408, 87100549], "C": [87087119, 87083714, 87087183, 87094082, 87125584, 87140844, 87089726, 87089545, 87092040, 87111442, 87085820, 87088762, 87103769, 87110798, 87107696, 87084280, 87087235, 87089175, 87090633], "B": [87082211, 87084609, 87082372, 87086099, 87118271, 87134332, 87085669, 87082094, 87085708, 87097473, 87081944, 87080519, 87090484, 87088911, 87082077, 87081415, 87081680, 87080910, 87083097], "A": [87080978, 87081308, 87080529, 87081521, 87116439, 87133004, 87083295, 87081194, 87080773, 87082296, 87080859, 87090051, 87086698, 87082297, 87102822, 87093275, 87080753, 87080503, 87081225]}, "name": "C. Make It Good", "statement": "You are given an array a consisting of n integers. You have to find the\r\nlength of the smallest (shortest) of elements you need to erase from a\r\nto make it a array. Recall that the prefix of the array a=[a_1, a_2,\r\ndots, a_n] is a subarray consisting several first elements: the prefix\r\nof the array a of length k is the array [a_1, a_2,\r\ndots, a_k] (0\r\nle k\r\nle n).The array b of length m is called , if you can obtain a array c\r\n(c_1\r\nle c_2\r\nle\r\ndots\r\nle c_{m}) from it, repeating the following operation m times (initially,\r\nc is empty): select either the first or the last element of b, remove it\r\nfrom b, and append it to the end of the array c. For example, if we do 4\r\noperations: take b_1, then b_{m}, then b_{m-1} and at last b_2, then b\r\nbecomes [b_3, b_4,\r\ndots, b_{m-3}] and c =[b_1, b_{m}, b_{m-1}, b_2].Consider the following\r\nexample: b = [1, 2, 3, 4, 4, 2, 1]. This array is because we can obtain\r\narray c from it by the following sequence of operations: take the first\r\nelement of b, so b = [2, 3, 4, 4, 2, 1], c = [1]; take the last element\r\nof b, so b = [2, 3, 4, 4, 2], c = [1, 1]; take the last element of b, so\r\nb = [2, 3, 4, 4], c = [1, 1, 2]; take the first element of b, so b = [3,\r\n4, 4], c = [1, 1, 2, 2]; take the first element of b, so b = [4, 4], c =\r\n[1, 1, 2, 2, 3]; take the last element of b, so b = [4], c = [1, 1, 2,\r\n2, 3, 4]; take the only element of b, so b = [], c = [1, 1, 2, 2, 3, 4,\r\n4] c is non-decreasing. Note that the array consisting of one element is\r\n.Print the length of the shortest prefix of a to delete (erase), to make\r\na to be a array. Note that the required length can be 0.You have to\r\nanswer t independent test cases.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint t, n, a[N];\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) {\n      scanf(\"%d\", a + i);\n    }\n    int en = n;\n    while (en > 1 and a[en] <= a[en - 1]) --en;\n    while (en > 1 and a[en] >= a[en - 1]) --en;\n    printf(\"%d\\n\", en - 1);\n  }\n  return 0;\n}\n\n"], "input": "", "output": "", "tags": ["greedy"], "dificulty": "1200", "interactive": false}