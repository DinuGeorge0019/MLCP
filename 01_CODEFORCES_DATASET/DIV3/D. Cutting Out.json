{
    "link": "https://codeforces.com//contest/1077/problem/D",
    "problemId": "256063",
    "problem_idx": "D",
    "shortId": "1077D",
    "contest_number": "1077",
    "problem_submissions": {
        "F2": [
            45821914,
            45824097,
            45827727,
            45823038,
            45823838,
            45831345,
            45823658,
            45828538,
            45826654,
            45843367,
            45837244,
            45831421,
            45827068,
            75760321,
            46030227,
            46029209,
            46029112,
            45866424
        ],
        "F1": [
            45820450,
            45824142,
            45824461,
            45823167,
            76966420,
            45824019,
            45831648,
            45823900,
            45828343,
            45824802,
            45841509,
            45837306,
            45831567,
            45823097,
            45829985,
            45827347,
            75757082,
            45830229,
            45831957,
            45830358,
            45833935,
            45833332,
            45828687
        ],
        "E": [
            45816542,
            52239741,
            45818548,
            45816950,
            45819025,
            45815405,
            45821116,
            45817502,
            45823078,
            45808470,
            45827222,
            45833695,
            45822673,
            45820795,
            45823659,
            45825654,
            45825672,
            45828447,
            45825663,
            45830728
        ],
        "D": [
            45811969,
            52239759,
            45814314,
            45814285,
            45816755,
            45819154,
            45813076,
            45811883,
            45822278,
            45831158,
            45821016,
            45816579,
            45818656,
            45997108,
            45818703,
            45817324,
            45818247,
            45816683,
            45819278,
            45822009
        ],
        "C": [
            45807748,
            45809528,
            45808767,
            45809925,
            45807121,
            45806385,
            45818022,
            45810371,
            45804988,
            45857981,
            45852142,
            45840511,
            45811255,
            45820919,
            45810760,
            45809427,
            45810396,
            45809829,
            45812965,
            45808768,
            45810632,
            45815038,
            45809663
        ],
        "B": [
            45805407,
            45806822,
            45804781,
            45807614,
            45805828,
            45804425,
            45810429,
            45806291,
            45806153,
            45852010,
            45812539,
            45824293,
            45806882,
            45806701,
            45807779,
            45807759,
            45805186,
            45806900,
            45808256,
            45805906
        ],
        "A": [
            45803595,
            45803585,
            45803761,
            45803589,
            45806737,
            45803510,
            45815244,
            45803641,
            45804397,
            45851969,
            45805595,
            45822873,
            45804956,
            45804923,
            45805008,
            45804110,
            45803730,
            45804318,
            45804436,
            45803752
        ]
    },
    "name": "D. Cutting Out",
    "statement": "You are given an array s consisting of n integers.You have to find array\r\nt of length k such that you can cut out maximum number of copies of\r\narray t from array s.Cutting out the copy of t means that for each\r\nelement t_i of array t you have to find t_i in s and remove it from s.\r\nIf for some t_i you cannot find such element in s, then you cannot cut\r\nout one more copy of t. The both arrays can contain duplicate\r\nelements.For example, if s = [1, 2, 3, 2, 4, 3, 1] and k = 3 then one of\r\nthe possible answers is t = [1, 2, 3]. This array t can be cut out 2\r\ntimes. To cut out the first copy of t you can use the elements [1,\r\nunderline{\r\ntextbf{2}}, 3, 2, 4,\r\nunderline{\r\ntextbf{3}},\r\nunderline{\r\ntextbf{1}}] (use the highlighted elements). After cutting out the first\r\ncopy of t the array s can look like [1, 3, 2, 4]. To cut out the second\r\ncopy of t you can use the elements [\r\nunderline{\r\ntextbf{1}},\r\nunderline{\r\ntextbf{3}},\r\nunderline{\r\ntextbf{2}}, 4]. After cutting out the second copy of t the array s will\r\nbe [4]. Your task is to find such array t that you can cut out the copy\r\nof t from s maximum number of times. If there are multiple answers, you\r\nmay choose of them.\r\n",
    "solutions": [
        "#include<iostream> \n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define N 200010\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,cnt[N],id[N],ans[N];\nstruct data\n{\n\tint x,y;\n\tbool operator <(const data&a) const\n\t{\n\t\treturn y>a.y;\n\t}\n}a[N],b[N];\nbool check(int k)\n{\n\tfor (int i=1;i<=200000;i++) b[i]=a[i];\n\tint s=0;\n\tfor (int i=1;i<=200000;i++)\n\twhile (b[i].y>=k&&s<m) id[++s]=b[i].x,b[i].y-=k;\n\treturn s>=m;\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;i++) cnt[read()]++;\n\tfor (int i=1;i<=200000;i++) a[i].x=i,a[i].y=cnt[i];\n\tsort(a+1,a+200001);\n\tint l=0,r=n/m;\n\twhile (l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif (check(mid)) {for (int i=1;i<=m;i++) ans[i]=id[i];l=mid+1;}\n\t\telse r=mid-1;\n\t}\n\tfor (int i=1;i<=m;i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Cutting Out.json",
    "editorial_link": "https://codeforces.com//blog/entry/63274",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem using binary search by the answer. It is easy to\r\nsee that if we can construct the answer for some number of copies then\r\nwe also can do it for . The only thing we need is to write the function\r\nwhich will say can we cut off copies of some array from or not.Let\u00e2\u0080\u0099s\r\nimagine copies of string as a matrix of size . Obviously, each row of\r\nthis matrix should be equal to each other row. Let\u00e2\u0080\u0099s fill not rows but\r\ncolumns of this matrix. For some element of we can easy notice that we\r\ncan take exactly columns containing this element where is the number of\r\nsuch elements in . So, overall number of columns we can fill in this\r\nmatrix will be . If this value is greater than or equal to then is true\r\notherwise it is false.It is easy to construct the answer using all\r\nthings we described above.Overall complexity is where is the size of the\r\nalphabet.\r\n"
}