{"link": "https://codeforces.com//contest/1367/problem/F1", "problemId": "650998", "problem_idx": "F1", "shortId": "1367F1", "contest_number": "1367", "problem_submissions": {"F2": [84046399, 84094199, 84130636], "F1": [83980407, 83997753, 83993348, 83994650, 83999567, 84010715, 83998236, 84003996, 84009140, 84019849, 84274779, 84017193, 84019354, 84000999, 84010593, 84016471, 84014906, 84016930, 84014876, 84014935, 84017986], "D": [83971043, 83961145, 83985812, 83980115, 83973000, 83974852, 83986130, 83981366, 83974367, 83994623, 83977600, 83983323, 83996104, 83995930, 83983801, 83992346, 83994322, 83998169, 84019878, 83994750], "E": [83960157, 83975668, 83972713, 83967919, 83987024, 83979496, 83979914, 83997028, 83998395, 83978103, 83986303, 83992757, 84009544, 83998141, 84003322, 84000422, 84009434, 84005956, 84009927], "C": [83944345, 83953190, 83946330, 83950349, 83947422, 83950879, 83948329, 83963053, 83957928, 83954873, 83961995, 83964648, 83957400, 83955873, 83978101, 83977835, 83962124, 83950317, 83977481], "B": [83935714, 83939461, 83936897, 83955137, 83937279, 83939068, 83931855, 83950510, 83942524, 83939871, 83953252, 83938559, 83937149, 83961120, 83949153, 83945426, 83942777, 83939545, 83950410], "A": [83931489, 83931768, 83931529, 83932839, 83931493, 83933565, 83935945, 83942834, 83934889, 83933081, 83935891, 83931997, 83932187, 83932611, 83934727, 83936848, 83932660, 83932129, 83932693]}, "name": "F1. Flying Sort  Easy Version ", "statement": "You are given an array a of n integers . You can perform the following\r\noperations on array elements: choose any index i (1\r\nle i\r\nle n) and move the element a[i] to the of the array; choose any index i\r\n(1\r\nle i\r\nle n) and move the element a[i] to the of the array. For example, if n =\r\n5, a = [4, 7, 2, 3, 9], then the following sequence of operations can be\r\nperformed: after performing the operation of the first type to the\r\nsecond element, the array a will become [7, 4, 2, 3, 9]; after\r\nperforming the operation of the second type to the second element, the\r\narray a will become [7, 2, 3, 9, 4]. You can perform operations of any\r\ntype any number of times in any order.Find the minimum total number of\r\noperations of the first and second type that will make the a array\r\nsorted in non-decreasing order. In other words, what is the minimum\r\nnumber of operations that must be performed so the array satisfies the\r\ninequalities a[1]\r\nle a[2]\r\nle\r\nldots\r\nle a[n].\r\n", "solutions": ["#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nvoid f()\n{\n\tint n;\n\tcin >> n;\n\tint dp[n + 1] = {0};\n\tint arr[n + 1];\n\tarr[0] = -5;\n\tvector<int> comp;\n\tfl(i,1,n + 1)\n\t{\n\t\tcin >> arr[i];\n\t\tcomp.pb(arr[i]);\n\t}\n\tsort(comp.begin(), comp.end());\n\tcomp.resize(unique(comp.begin(), comp.end()) - comp.begin());\n\tfl(i,1,n + 1)\n\t{\n\t\tarr[i] = upper_bound(comp.begin(), comp.end(),arr[i]) - comp.begin();\n\t}\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 0;\n\t}\n\tint ans = 0;\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 1;\n\t\tfl(j,0,i)\n\t\t{\n\t\t\tif(arr[j] + 1 ==  arr[i])\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i],dp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tans = max(ans,dp[i]);\n\t}\n\tcout << n - ans << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}"], "input": "", "output": "", "tags": ["dp", "greedy", "two pointers"], "dificulty": "2100", "interactive": false}