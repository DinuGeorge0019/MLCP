{
    "link": "https://codeforces.com//contest/2036/problem/G",
    "problemId": "2997674",
    "problem_idx": "G",
    "shortId": "2036G",
    "contest_number": "2036",
    "problem_submissions": {
        "G": [
            289568495,
            289592157,
            289591763,
            289595974,
            289727611,
            290290543
        ],
        "F": [
            289537821,
            289522926,
            289537324,
            289559326,
            289512509,
            289515984,
            289510795,
            289521272,
            289526918,
            289534575,
            289534164,
            289556542,
            289531934,
            289514943,
            289521852,
            289521308,
            289566779,
            289543749,
            289533352
        ],
        "E": [
            289519379,
            289513483,
            289516754,
            289537406,
            289502565,
            289497006,
            289514977,
            289504007,
            289502653,
            289492035,
            289506214,
            289517949,
            289508708,
            289505547,
            289524899,
            289498786,
            289538409,
            289511145,
            289522074,
            289542250
        ],
        "D": [
            289494755,
            289496973,
            289502561,
            289508569,
            289485075,
            289486449,
            289493423,
            289495061,
            289486975,
            289488146,
            289499112,
            289494333,
            289489388,
            289496285,
            289527032,
            289505896,
            289497283,
            289504013,
            289505465
        ],
        "C": [
            289479986,
            289485425,
            289473871,
            289486850,
            289474317,
            289472689,
            289477260,
            289486030,
            289480295,
            289481264,
            289478991,
            289479671,
            289477258,
            289477016,
            289506161,
            289489963,
            289490617,
            289481449,
            289485496
        ],
        "B": [
            289473268,
            289473263,
            289467611,
            289472113,
            289470722,
            289468547,
            289468418,
            289478505,
            289474994,
            289471830,
            289469932,
            289465642,
            289466472,
            289469818,
            289476408,
            289471072,
            289468104,
            289473322,
            289472255
        ],
        "A": [
            289464981,
            289463574,
            289462739,
            289463265,
            289465451,
            289464109,
            289462932,
            289467937,
            289463249,
            289464614,
            289463267,
            289462869,
            289462845,
            289463088,
            289467021,
            289463344,
            289462625,
            289465258,
            289463000
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135849",
    "editorial": "TutorialTo begin with, we note that for any number , is satisfied.\r\nTherefore, by querying xor l r, you will get bitwise XOR of only those\r\nvolume numbers that are in the library in a single copy (within the\r\nscope of querying and , of course). Also note that for two pairwise\r\ndistinct numbers and , is always satisfied.Initially, our goal is to\r\ndetermine the largest bit of the maximum of the lost numbers. To do\r\nthis, we can go through the bits starting from the largest significant\r\nbit in n. For each -th bit, we will ask xor {2^i} {min(2^(i + 1) - 1,\r\nn)}. Note that all numbers on this interval have -th bit equal to one.\r\nThen if we get a result not equal to zero, then this bit is the desired\r\nlargest bit of the maximum of the lost numbers. If we get a result equal\r\nto zero, then this bit is guaranteed not to be present in any of the\r\nnumbers, i.e. all three numbers are less than .Letâs prove it. If we had\r\none or two numbers on the requested interval, their XOR would not be\r\n(see the first paragraph). If all three numbers are on this interval,\r\nthen the XOR of their -th bit is , and hence the XOR of the numbers\r\nthemselves is also different from .Now that we know the largest bit of\r\nthe desired number, we can find this number by any realization of binary\r\nsearch inside the interval . By the answer to any query on any interval\r\nwithin that interval, we can unambiguously know whether our number is\r\npresent on that interval or not the proof is similar to the one\r\nabove.The first number is found. The second number can be found using\r\nany bin search, since XOR of two different numbers is always different\r\nfrom zero. The main thing is not to forget to exclude the already found\r\nnumber from the obtained result using the same XOR. And the third number\r\ncan be found by requesting the result of the whole interval from to and\r\nexcluding the already found two numbers from it.Number of requests:\r\n",
    "name": "G. Library of Magic",
    "statement": "The Department of Supernatural Phenomena at the Oxenfurt Academy has\r\nopened the Library of Magic, which contains the works of the greatest\r\nsorcerers of Redania n (3\r\nleq n\r\nleq 10^{18}) types of books, numbered from 1 to n. Each book’s type\r\nnumber is indicated on its spine. Moreover, each type of book is stored\r\nin the library in exactly two copies! And you have been appointed as the\r\nlibrarian.One night, you wake up to a strange noise and see a creature\r\nleaving the building through a window. Three thick tomes of different\r\ncolors were sticking out of the mysterious thief’s backpack. Before you\r\nstart searching for them, you decide to compute the numbers a, b, and c\r\nwritten on the spines of these books. All three numbers are .So, you\r\nhave an unordered set of tomes, which includes one tome with each of the\r\npairwise distinct numbers a, b, and c, and two tomes for all numbers\r\nfrom 1 to n, except for a, b, and c. You want to find these values a, b,\r\nand c.Since you are not working in a simple library, but in the Library\r\nof Magic, you can only use one spell in the form of a query to check the\r\npresence of books in their place: \"\" with parameters l and r. Let k be\r\nthe number of such tomes in the library whose numbers are greater than\r\nor equal to l and less than or equal to r. You will receive the result\r\nof the computation v_1\r\noplus v_2\r\noplus ...\r\noplus v_k, where v_1 ... v_k are the numbers on the spines of these\r\ntomes, and\r\noplus denotes the operation of bitwise exclusive OR. Since your magical\r\nabilities as a librarian are severely limited, you can make no more than\r\n150 queries.\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;void solve() {\tll n;\tcin >> n;\tcout << \"xor \" << 1 << \" \" << n << endl;\tll k;\tcin >> k;\tll a, b, c;\tif (k != 0) {\t\tll l = 1, r = n;\t\tll new_l, new_r;\t\twhile (l != r) {\t\t\tll mid = (l + r) / 2;\t\t\tcout << \"xor \" << l << \" \" << mid << endl;\t\t\tll u;\t\t\tcin >> u;\t\t\tif (u == 0) {\t\t\t\tl = mid + 1;\t\t\t\tcontinue;\t\t\t}\t\t\tif (u == k) {\t\t\t\tr = mid;\t\t\t\tcontinue;\t\t\t}\t\t\tif (u <= n) {\t\t\t\tcout << \"xor \" << u << \" \" << u << endl;\t\t\t\tll w;\t\t\t\tcin >> w;\t\t\t\tif (w == 0) {\t\t\t\t\ta = (k ^ u);\t\t\t\t\tnew_l = l;\t\t\t\t\tnew_r = mid;\t\t\t\t}\t\t\t\telse {\t\t\t\t\ta = u;\t\t\t\t\tnew_l = mid + 1;\t\t\t\t\tnew_r = r;\t\t\t\t}\t\t\t}\t\t\telse {\t\t\t\ta = (k ^ u);\t\t\t\tnew_l = l;\t\t\t\tnew_r = mid;\t\t\t}\t\t\tbreak;\t\t}\t\tl = new_l;\t\tr = new_r;\t\twhile (l != r) {\t\t\tll mid = (l + r) / 2;\t\t\tcout << \"xor \" << l << \" \" << mid << endl;\t\t\tll u;\t\t\tcin >> u;\t\t\tif (u == 0) {\t\t\t\tl = mid + 1;\t\t\t\tcontinue;\t\t\t}\t\t\tif (u == (k ^ a)) {\t\t\t\tr = mid;\t\t\t\tcontinue;\t\t\t}\t\t\tb = u;\t\t\tc = (k ^ a ^ u);\t\t\tbreak;\t\t}\t\tvector <ll> v = { a, b, c };\t\tsort(v.begin(), v.end());\t\tcout << \"ans \" << v[0] << \" \" << v[1] << \" \" << v[2] << endl;\t\treturn;\t}\tll w = 1;\tfor (ll k = 0; k <= 59; k++) {\t\t//2 ^ k, 2^(k + 1) - 1\t\tcout << \"xor \" << w << \" \" << min(n, 2 * w - 1) << endl;\t\tll u;\t\tcin >> u;\t\tif (u == 0) {\t\t\tw *= 2;\t\t\tcontinue;\t\t}\t\ta = u;\t\tll l = w, r = min(n, 2 * w - 1);\t\tif (a > r) {\t\t\tbool ch = false;\t\t\twhile (l != r) {\t\t\t\tll mid = (l + r) / 2;\t\t\t\tcout << \"xor \" << l << \" \" << mid << endl;\t\t\t\tll u;\t\t\t\tcin >> u;\t\t\t\tif (u == 0) {\t\t\t\t\tl = mid + 1;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tif (u == (0 ^ a)) {\t\t\t\t\tr = mid;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tb = u;\t\t\t\tc = (0 ^ a ^ u);\t\t\t\tbreak;\t\t\t}\t\t}\t\telse {\t\t\tl = 2 * w, r = n;\t\t\twhile (l != r) {\t\t\t\tll mid = (l + r) / 2;\t\t\t\tcout << \"xor \" << l << \" \" << mid << endl;\t\t\t\tll u;\t\t\t\tcin >> u;\t\t\t\tif (u == 0) {\t\t\t\t\tl = mid + 1;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tif (u == (0 ^ a)) {\t\t\t\t\tr = mid;\t\t\t\t\tcontinue;\t\t\t\t}\t\t\t\tb = u;\t\t\t\tc = (0 ^ a ^ u);\t\t\t\tbreak;\t\t\t}\t\t}\t\tvector <ll> v = { a, b, c };\t\tsort(v.begin(), v.end());\t\tcout << \"ans \" << v[0] << \" \" << v[1] << \" \" << v[2] << endl;\t\treturn;\t}}int main() {\tint t = 1;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "divide and conquer",
        "interactive",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Library of Magic.json",
    "hint": [
        "Hint 1 Have you considered the cases where ?",
        "Hint 2 Suppose you are certain that at least one lost number is located on some segment . Can you choose a value such that the queries xor {le} {mid} and xor {mid + 1} {ri} you can unambiguously understand on which of the segments ( or ) lies at least one lost number, even if both of these queries return ?"
    ]
}