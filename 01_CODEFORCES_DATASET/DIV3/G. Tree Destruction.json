{
    "link": "https://codeforces.com//contest/2050/problem/G",
    "problemId": "3070032",
    "problem_idx": "G",
    "shortId": "2050G",
    "contest_number": "2050",
    "problem_submissions": {
        "G": [
            295020039,
            295012969,
            295024810,
            295026123,
            295231485,
            295230757,
            295027068,
            295011107,
            295020886,
            295043604,
            295023074,
            295040334,
            295040501,
            295044199,
            295042105,
            295035503,
            295046172,
            295069369,
            295055294,
            295058073
        ],
        "D": [
            295023542,
            295007735,
            295022150,
            295015640,
            295022096,
            295027211,
            295005995,
            295007532,
            295010040,
            295008211,
            295013052,
            295007075,
            295014360,
            295012052,
            295012580,
            295012327,
            295010790
        ],
        "F": [
            295009915,
            295016605,
            295015909,
            295021788,
            295023146,
            295035635,
            295031460,
            295012371,
            295027547,
            295033629,
            295028476,
            295029305,
            295012244,
            295027355,
            299441454,
            295024166,
            295024859,
            295021290
        ],
        "E": [
            295006159,
            295012248,
            295006655,
            295358340,
            294991246,
            295015587,
            295010009,
            295016041,
            295017979,
            295016907,
            295021107,
            295017866,
            295008404,
            295002349,
            295018392,
            295017130,
            295019301,
            295028396
        ],
        "C": [
            295000545,
            295002243,
            294997256,
            295011626,
            295006375,
            295000328,
            295001562,
            295020525,
            295004225,
            295001544,
            295003470,
            294999298,
            295008085,
            295003035,
            295005025,
            295008622,
            295001249
        ],
        "B": [
            294992701,
            294994611,
            294990329,
            295007113,
            294997489,
            294992969,
            294992993,
            295002206,
            294997468,
            294994758,
            294991989,
            294994433,
            294994702,
            294998118,
            294998487,
            295000433,
            294997971
        ],
        "A": [
            294987570,
            294988254,
            294987535,
            294987637,
            294990076,
            294987812,
            294987751,
            294999699,
            294989420,
            294988260,
            294987843,
            294987612,
            294989111,
            294989647,
            294989965,
            294992026,
            294994133
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137018",
    "editorial": "Letâs choose some vertices and , between which there are edges. Then,\r\nwhen removing this path, the tree will split into , where is the sum of\r\nthe degrees of the vertices on the path (this is exactly how many edges\r\nare connected to the chosen path).Letâs suspend the tree from vertex ,\r\nand for each vertex of the given tree, we will calculate two values: the\r\nbest answer if the path starts at vertex and ends in its subtree, and\r\nthe best answer if the path passes through vertex from one of its\r\nchildren to another. The recalculations of the dynamic programming will\r\nbe similar to those used in finding the diameter of the tree using\r\ndynamic programming.The answer will be the largest value among all and .\r\n",
    "name": "G. Tree Destruction",
    "statement": "Given a tree^{\r\ntext{ }} with n vertices. You can choose two vertices a and b once and\r\nremove all vertices on the path from a to b, including the vertices\r\nthemselves. If you choose a=b, only one vertex will be removed.Your task\r\nis to find the maximum number of connected components^{\r\ntext{ }} that can be formed after removing the path from the tree.^{\r\ntext{ }}A tree is a connected graph without cycles. ^{\r\ntext{ }}A connected component is a set of vertices such that there is a\r\npath along the edges from any vertex to any other vertex in the set (and\r\nit is not possible to reach vertices not belonging to this set)\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;  const long long NEG_INF = -1e18;  struct StackFrame {    int node;    int parent;    bool processed;    long long max1;    long long max2;}; int main(){    ios::sync_with_stdio(false);    cin.tie(NULL);     int t;    cin >> t;    while(t--){        int n;        cin >> n;        vector<vector<int>> a(n+1, vector<int>());        vector<int> deg(n+1, 0);        for(int i=0;i<n-1;i++){            int u, v;            cin >> u >> v;            a[u].push_back(v);            a[v].push_back(u);            deg[u]++;            deg[v]++;        }        int Mdeg = 0;        for(int v=1; v<=n; v++) {            if(deg[v] > Mdeg) Mdeg = deg[v];        }         vector<long long> w(n+1, 0);        for(int v=1; v<=n; v++) {            w[v] = (long long)deg[v] - 2;        }         long long x = NEG_INF;        stack<StackFrame> stk;        stk.push(StackFrame{1, -1, false, 0, 0});        vector<pair<long long, long long>> node_max(n+1, {0, 0});        while(!stk.empty()){            StackFrame current = stk.top();            stk.pop();            if(!current.processed){                stk.push(StackFrame{current.node, current.parent, true, 0, 0});                 for(auto &v : a[current.node]){                    if(v != current.parent){                        stk.push(StackFrame{v, current.node, false, 0, 0});                    }                }            }            else{                long long curw = w[current.node];                long long max1 = 0, max2 = 0;                for(auto &v : a[current.node]){                    if(v != current.parent){                        long long s = node_max[v].first;                        if(s > max1){                            max2 = max1;                            max1 = s;                        }                        else if(s > max2){                            max2 = s;                        }                    }                }                if(max1 > 0){                    x = max(x, curw + max1);                }                if(max1 > 0 && max2 > 0){                    x = max(x, curw + max1 + max2);                }                node_max[current.node].first = curw + max(max1, (long long)0);                node_max[current.node].second = max2;            }        }        long long ans = x + 2;        long long aaa = max((long long)Mdeg, ans);        cout << aaa << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Tree Destruction.json",
    "hint": []
}