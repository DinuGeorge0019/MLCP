{"link": "https://codeforces.com//contest/1675/problem/D", "problemId": "1389921", "problem_idx": "D", "shortId": "1675D", "contest_number": "1675", "problem_submissions": {"G": [156006050, 156007549, 173914008, 156574492, 156062725, 156044046], "F": [155975284, 155982189, 155975181, 155974056, 155981368, 155963854, 155982839, 155978540, 155977742, 155982621, 155974644, 155983326, 155979741, 155983593, 155987528, 155986330, 155979073, 155983357, 155982704, 155980054], "B": [155956678, 155933030, 155935424, 155929465, 155930941, 155933422, 155931092, 155933639, 155934497, 155933616, 155938056, 155932878, 155937699, 155932330, 155932424, 155935419, 155934167, 155935968, 155938228, 155943045], "E": [155952600, 155969940, 155962457, 155964374, 155963814, 155983208, 155966957, 155966086, 155964414, 155966097, 155967685, 155966676, 155968339, 155969173, 155968619, 155969521, 155968330, 155970439, 155974921, 155969157], "D": [155947749, 155955293, 155954858, 155948070, 155952887, 155947902, 155952914, 155950857, 155960245, 155955600, 155958049, 155956959, 155958393, 155952984, 155959572, 155957851, 155953914, 155962460, 155960783, 155957979], "C": [155940658, 155941257, 155944890, 155941178, 155942028, 155946945, 155940227, 155941361, 155945588, 155943949, 155946857, 155944434, 155950008, 155942914, 155943655, 155945930, 155959132, 155949802, 155946391, 155951636], "A": [155928116, 155927077, 155928841, 155925983, 155926500, 155932074, 155926390, 155927710, 155930181, 155927610, 155931371, 155927746, 155927018, 155927300, 155927241, 155926796, 155928901, 155928154, 155927537, 155926656]}, "name": "D. Vertical Paths", "statement": "You are given a rooted tree consisting of n vertices. Vertices are\r\nnumbered from 1 to n. Any vertex can be the root of a tree.A is a\r\nconnected undirected graph without cycles. A is a tree with a selected\r\nvertex, which is called the .The tree is specified by an array of\r\nparents p containing n numbers: p_i is a parent of the vertex with the\r\nindex i. The of a vertex u is a vertex that is the next vertex on the\r\nshortest path from u to the root. For example, on the simple path from 5\r\nto 3 (the root), the next vertex would be 1, so the parent of 5 is 1.The\r\nroot has no parent, so for it, the value of p_i is i (the root is the\r\nonly vertex for which p_i=i).Find such a set of paths that: each vertex\r\nbelongs to exactly one path, each path can contain one or more vertices;\r\nin each path each next vertex is a son of the current vertex (that is,\r\npaths always lead down from parent to son); number of paths is . For\r\nexample, if n=5 and p=[3, 1, 3, 3, 1], then the tree can be divided into\r\nthree paths: 3\r\nrightarrow 1\r\nrightarrow 5 (path of 3 vertices), 4 (path of 1 vertices). 2 (path of 1\r\nvertices).\r\n", "solutions": ["#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == '-') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\ninline int reads(char* s){\n\tint t = 0;\n\tregister char c = getchar();\n\twhile (c != '1' && c != '0' && c != '?') c = getchar();\n\twhile (c == '1' || c == '0' || c == '?') s[++t] = c,c = getchar();\n\treturn t;\n}\n\nconst int N = 2e5;\nint T,rt,n,ans,etot,stop,fa[N + 1],indeg[N + 1],head[N + 1],stk[N + 1];\n\nstruct Edge{\n\tint u,v,next;\n}e[(N << 1) + 1];\n\nvoid adde(int u,int v) {e[++etot] = (Edge){u,v,head[u]},head[u] = etot;}\n\nvoid dfs(int now,int f){\n\tstk[++stop] = now;\n\tif (!indeg[now]){\n\t\tprintf(\"%d\\n\",stop);\n\t\tfor (int i = 1;i <= stop;i++) printf(\"%d \",stk[i]);\n\t\tputchar('\\n');\n\t\tstop = 0;\n\t\treturn ;\n\t}\n\tfor (int i = head[now];i;i = e[i].next){\n\t\tif (e[i].v == f) continue;\n\t\tdfs(e[i].v,now);\n\t}\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = read();\n\t\tans = stop = etot = 0;\n\t\tfor (int i = 1;i <= n;i++) indeg[i] = 0,fa[i] = 0,head[i] = 0;\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tfa[i] = read();\n\t\t\tif (fa[i] != i) ++indeg[fa[i]],adde(i,fa[i]),adde(fa[i],i);\n\t\t\telse rt = i;\n\t\t}\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (!indeg[i]) ++ans;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tdfs(rt,0);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["graphs", "implementation", "trees"], "dificulty": "1300", "interactive": false}