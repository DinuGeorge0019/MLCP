{
    "link": "https://codeforces.com//contest/1374/problem/E1",
    "problemId": "659588",
    "problem_idx": "E1",
    "shortId": "1374E1",
    "contest_number": "1374",
    "problem_submissions": {
        "E2": [
            85382072,
            85375189,
            85438625
        ],
        "F": [
            85353642,
            85415306,
            85383843,
            85383492,
            85387797
        ],
        "E1": [
            85326034,
            85415299,
            85334989,
            85321477,
            85339121,
            85319474,
            85320204,
            85328246,
            85336700,
            85339703,
            85337792,
            85338081,
            85335206,
            85337433,
            85338605,
            85342001,
            85329936,
            85333348,
            85346311
        ],
        "D": [
            85316338,
            85415714,
            85415293,
            85323106,
            85325598,
            85328229,
            85311173,
            85312812,
            85313089,
            85319125,
            85325499,
            85321861,
            85326849,
            85319951,
            85325883,
            85322528,
            85325568,
            85334734,
            85327646,
            85314511
        ],
        "C": [
            85307188,
            85415289,
            85310607,
            85296173,
            85316864,
            85302975,
            85301461,
            85301463,
            85305237,
            85304971,
            85309343,
            85306153,
            85311376,
            85308864,
            85309628,
            85308295,
            85307625,
            85311312,
            85303960
        ],
        "B": [
            85299874,
            85415460,
            85415277,
            85305586,
            85300354,
            85311254,
            85298580,
            85298918,
            85297647,
            85301049,
            85300227,
            85301912,
            85300264,
            85307719,
            85302644,
            85305750,
            85299884,
            85297473,
            85305618,
            85299402
        ],
        "A": [
            85296254,
            85418749,
            85415919,
            85415268,
            85300037,
            85296089,
            85298024,
            85296518,
            245635316,
            85296385,
            85295981,
            85296977,
            85296136,
            85296861,
            85296508,
            85298422,
            85298833,
            85299917,
            85296648,
            85305648,
            85300594,
            85296295
        ]
    },
    "name": "E1. Reading Books  easy version ",
    "statement": ".Summer vacation has started so Alice and Bob want to play and joy,\r\nbut... Their mom doesn\u2019t think so. She says that they have to read some\r\namount of books before all entertainments. Alice and Bob will read each\r\nbook to end this exercise faster.There are n books in the family\r\nlibrary. The i-th book is described by three integers: t_i the amount of\r\ntime Alice and Bob need to spend to read it, a_i (equals 1 if Alice\r\nlikes the i-th book and 0 if not), and b_i (equals 1 if Bob likes the\r\ni-th book and 0 if not).So they need to choose some books from the given\r\nn books in such a way that: Alice likes k books from the chosen set and\r\nBob likes k books from the chosen set; the total reading time of these\r\nbooks is (they are children and want to play and joy as soon a\r\npossible). The set they choose is for both Alice an Bob (it\u2019s shared\r\nbetween them) and they read all books , so the total reading time is the\r\nsum of t_i over all books that are in the chosen set.Your task is to\r\nhelp them and find any suitable set of books or determine that it is\r\nimpossible to find such a set.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << \" is \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7;\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvi x, y, z;\n\tfor(int i = 0; i < n; i++) {\n\t\tint t, a, b;\n\t\tcin >> t >> a >> b;\n\t\tif(a == 0 && b == 0) continue;\n\t\tif(a == 1 && b == 1) z.PB(t);\n\t\telse if(a == 1) x.PB(t);\n\t\telse y.PB(t);\n\t}\n\tsort(ALL(x)), sort(ALL(y)), sort(ALL(z));\n\tfor(int i = 1; i < x.size(); i++) x[i] += x[i - 1];\n\tfor(int i = 1; i < y.size(); i++) y[i] += y[i - 1];\n\tfor(int i = 1; i < z.size(); i++) z[i] += z[i - 1];\n\tint ans = INT_MAX;\n\tfor(int i = 0; i <= z.size(); i++) {\n\t\tint cur = 0;\n\t\tif(i) cur += z[i - 1];\n\t\tint rem = k - i;\n\t\trem--;\n\t\tif(rem < 0) {\n\t\t\tans = min(ans, cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif(rem >= x.size() || rem >= y.size()) continue;\n\t\tcur += x[rem] + y[rem];\n\t\tans = min(ans, cur);\n\t}\n\tif(ans == INT_MAX) ans = -1;\n\tcout << ans << endl;\n\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. Reading Books  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/79517",
    "editorial": "Let\u00e2\u0080\u0099s divide all books into four groups: both Alice and Bob doesn\u00e2\u0080\u0099t like\r\nthese books; only Alice likes these books; only Bob likes these books;\r\nboth ALice and Bob like these books. Obviously, -group is useless now.\r\nSo, how to solve the problem? Let\u00e2\u0080\u0099s iterate over the number of books we\r\ntake from -group. Let it be . Then we obviously need to take exactly\r\nbooks from groups and . Among all books in these three groups we have to\r\nchoose the cheapest ones. To calculate sum of times in each group fast\r\nenought, we can sort each group independently and implement prefix sums\r\non these arrays. If is less than zero or greater than the size of or\r\n-group for each possible then the answer is .And don\u00e2\u0080\u0099t forget that the\r\nanswer can be up to .Time complexity: .\r\n"
}