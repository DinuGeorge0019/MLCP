{
    "link": "https://codeforces.com//contest/1538/problem/D",
    "problemId": "1011924",
    "problem_idx": "D",
    "shortId": "1538D",
    "contest_number": "1538",
    "problem_submissions": {
        "E": [
            119018264,
            119038794,
            119046659,
            119003625,
            119061307,
            119064399,
            119060278,
            119068960,
            119062453,
            119072155,
            119056952,
            119069527,
            119068076,
            119062727,
            119052586,
            119065637,
            119072255
        ],
        "G": [
            118999207,
            119020225,
            119021713,
            119024546,
            119107544,
            119036898,
            119028226,
            119029451,
            119031390,
            119029333,
            119068653,
            119056480,
            119036891,
            119015600,
            119058550,
            119027874,
            119041084,
            119096627,
            119043084,
            119070277,
            119029074,
            119028555
        ],
        "F": [
            118994094,
            119009122,
            119011522,
            119010675,
            119004928,
            119011877,
            119018391,
            119023066,
            119014211,
            118989351,
            119008401,
            119000204,
            119046720,
            119037498,
            119005370,
            119003036,
            119028602,
            119029230,
            118990749
        ],
        "D": [
            118990532,
            119001395,
            118990526,
            118995807,
            118995705,
            119004937,
            119011155,
            119067124,
            119007327,
            119008907,
            119005317,
            118992117,
            119028596,
            119008321,
            119000602,
            119002391,
            119020144,
            119032689,
            119023435,
            118984125
        ],
        "C": [
            118982217,
            119149641,
            118992295,
            118981240,
            118981637,
            118988631,
            118988597,
            118982472,
            118986969,
            118992547,
            118974451,
            118982264,
            119002368,
            118990651,
            118982560,
            118985014,
            119000072,
            119149116,
            118999633,
            118999834,
            118978123
        ],
        "B": [
            118976645,
            118977183,
            118975637,
            118977101,
            118977452,
            118979418,
            118976574,
            118977391,
            118980490,
            118978931,
            118982040,
            118985873,
            118979131,
            118975015,
            118996026,
            118998239,
            118980842,
            118992776,
            118974355
        ],
        "A": [
            118973297,
            118973758,
            118973272,
            118974245,
            118974991,
            118975654,
            118973422,
            118973780,
            118976143,
            118975162,
            118974140,
            118978811,
            118974004,
            118973371,
            118987598,
            118996831,
            118976899,
            118975174,
            118973279
        ]
    },
    "name": "D. Another Problem About Dividing Numbers",
    "statement": "You are given two integers a and b. In one turn, you can do one of the\r\nfollowing operations: Take an integer c (c > 1 and ) and replace a with\r\nfrac{a}{c}; Take an integer c (c > 1 and ) and replace b with\r\nfrac{b}{c}. Your goal is to make a equal to b using exactly k turns.For\r\nexample, the numbers a=36 and b=48 can be made equal in 4 moves: c=6,\r\ndivide b by c\r\nRightarrow a=36, b=8; c=2, divide a by c\r\nRightarrow a=18, b=8; c=9, divide a by c\r\nRightarrow a=2, b=8; c=4, divide b by c\r\nRightarrow a=2, b=2. For the given numbers a and b, determine whether it\r\nis possible to make them equal using exactly k turns.\r\n",
    "solutions": [
        "#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie's Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you're not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you're submitting in szkopul.)\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast,unroll-loops,tree-vectorize\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n \n//File I/O.\n#define FILE_IN \"cseq.inp\"\n#define FILE_OUT \"cseq.out\"\n#define ofile freopen(FILE_IN,\"r\",stdin);freopen(FILE_OUT,\"w\",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl \"\\n\"\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nvector<int> vec;\nint cnt(int x)\n{\n    int res=0,i;\n    for (i=2;i*i<=x;i++)\n    {\n        while(x%i==0)\n        {\n            x/=i;\n            res++;\n        }\n    }\n    if (x>1) res++;\n    return res;\n}\nint n,m,i,j,k,t,t1,u,v,a,b;\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>a>>b>>k;\n        u=cnt(a);\n        v=cnt(b);\n        if (k>u+v)\n        {\n            cout<<\"No\\n\";\n        }\n        else\n        {\n            if (k>1)\n            {\n                cout<<\"Yes\\n\";\n            }\n            else\n            {\n                if (((a%b==0)or(b%a==0))and(a-b))\n                {\n                    cout<<\"Yes\\n\";\n                }\n                else\n                {\n                    cout<<\"No\\n\";\n                }\n            }\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Another Problem About Dividing Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/91637",
    "editorial": "Let\u00e2\u0080\u0099s denote for the maximum number of moves for which the numbers and\r\ncan be made equal. It is easy to understand that the number of moves is\r\nmaximum when and each time we divided or by a prime number. That is, sum\r\nof exponents of prime divisors of sum of exponents of prime divisors of\r\n.Let\u00e2\u0080\u0099s denote by the minimum number of moves for which the numbers and\r\ncan be made equal. Consider a few cases: If , then ; If or , then ;\r\nOtherwise, then . Then, the answer \"\" is possible in the following\r\ncases: and and , or, and .\r\n"
}