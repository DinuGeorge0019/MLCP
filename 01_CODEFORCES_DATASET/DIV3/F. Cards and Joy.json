{
    "link": "https://codeforces.com//contest/999/problem/F",
    "problemId": "192345",
    "problem_idx": "F",
    "shortId": "999F",
    "contest_number": "999",
    "problem_submissions": {
        "E": [
            39482525,
            39480258,
            39480681,
            39472815,
            39481171,
            39483804,
            39482822,
            39487988,
            39486311,
            39488255,
            39483434,
            39476369,
            39475874,
            39475323,
            39478090,
            39485416,
            39483552,
            39485842,
            39478651
        ],
        "D": [
            39476985,
            39482714,
            39477867,
            39487661,
            39478808,
            39479957,
            39478688,
            39480079,
            39484369,
            39488043,
            39682317,
            39484150,
            39479480,
            39479981,
            39480905,
            39490327
        ],
        "F": [
            39474187,
            39476396,
            39486159,
            39480138,
            39488092,
            39484785,
            39487824,
            39489626,
            39479920,
            39488254,
            39490520,
            39472516,
            39481714,
            39495126,
            39494491,
            39484965,
            39486979,
            39528460,
            39528455,
            39509111
        ],
        "C": [
            39468293,
            39473877,
            39471032,
            39469713,
            39469003,
            39471817,
            39471185,
            39471833,
            39473032,
            39481734,
            39489064,
            39465485,
            39469355,
            39469432,
            39471841,
            39471812,
            39470774,
            39471323,
            39471302
        ],
        "B": [
            39466151,
            39472359,
            39467106,
            39467712,
            39466498,
            39469904,
            39468165,
            39469498,
            39470396,
            39480507,
            39490594,
            39469417,
            39466615,
            39467515,
            39469262,
            39469175,
            39469263,
            39468726
        ],
        "A": [
            39465278,
            39470703,
            39465116,
            39466655,
            39465297,
            39465892,
            39465427,
            39466410,
            39468368,
            39479548,
            39467417,
            39471284,
            39465152,
            39465656,
            39465454,
            39466984,
            39465563,
            39467221
        ]
    },
    "name": "F. Cards and Joy",
    "statement": "There are n players sitting at the card table. Each player has a\r\nfavorite number. The favorite number of the j-th player is f_j.There are\r\nk\r\ncdot n cards on the table. Each card contains a single integer: the i-th\r\ncard contains number c_i. Also, you are given a sequence h_1, h_2,\r\ndots, h_k. Its meaning will be explained below.The players have to\r\ndistribute all the cards in such a way that each of them will hold\r\nexactly k cards. After all the cards are distributed, each player counts\r\nthe number of cards he has that contains his favorite number. The joy\r\nlevel of a player equals h_t if the player holds t cards containing his\r\nfavorite number. If a player gets no cards with his favorite number\r\n(i.e., t=0), his joy level is 0.Print the maximum possible total joy\r\nlevels of the players after the cards are distributed. Note that the\r\nsequence h_1,\r\ndots, h_k is the same for all the players.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl '\\n'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, k;\nint a[MAXN], cnt1[MAXN], cnt2[MAXN], f[MAXN], h[MAXN];\n\nbool read() {\n    if (!(cin >> n >> k))\n        return false;\n\n    forn (i, n * k)\n        cin >> a[i];\n\n    forn (i, n)\n        cin >> f[i];\n\n    forn (i, k)\n        cin >> h[i + 1];\n\n    return true;\n}\n\nvoid solve() {\n    forn (i, n * k)\n        ++cnt1[a[i]];\n\n    forn (i, n)\n        ++cnt2[f[i]];\n\n    ll ans = 0;\n\n    for (int x = 1; x <= 100000; ++x)\n        if (cnt2[x] != 0) {\n            vector< vector<int> > dp(cnt2[x] + 1, vector<int>(cnt1[x] + 1, 0));\n\n            for (int i = 0; i < cnt2[x]; ++i)\n                for (int j = 0; j <= cnt1[x]; ++j)\n                    for (int dj = 0; dj <= k && j + dj <= cnt1[x]; ++dj)\n                        dp[i + 1][j + dj] = max(dp[i + 1][j + dj], dp[i][j] + h[dj]);\n\n            ans += dp[cnt2[x]][cnt1[x]];\n        }\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n\n#ifdef SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Cards and Joy.json",
    "editorial_link": "https://codeforces.com/blog/entry/60138",
    "editorial": "It is obvious that we can solve the problem separately for each favorite\r\nnumber because each player has only one favorite number, and if the\r\nplayer gets a card not having his favorite number, his joy will not\r\nchange.Let be the maximum possible total joy of players with the same\r\nfavorite number (it doesn\u00e2\u0080\u0099t matter which one) and cards (containing\r\ntheir favorite number) if the cards are distributed among the players\r\noptimally. Note that and . At the beginning, all entries of the table\r\nare zeroes. The transition in this dynamic programming depends on how\r\nmany cards the -th player will receive (which is between and ). In other\r\nwords, the dynamic programming transition will look like: for (int i =\r\n0; i <= k; ++i) dp[x + 1][y + i] = max(dp[x + 1][y + i], dp[x][y] +\r\nh[i]),where is the joy of the player if he receives exactly cards\r\ncontaining his favorite number. Note that .After filling the table, the\r\nanswer can be calculated very easily: , where is the number of players\r\nwith favorite number and is the number of cards containing the number\r\n.Time complexity is .\r\n"
}