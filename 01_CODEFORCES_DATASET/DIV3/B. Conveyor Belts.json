{
    "link": "https://codeforces.com//contest/1811/problem/B",
    "problemId": "1864324",
    "problem_idx": "B",
    "shortId": "1811B",
    "contest_number": "1811",
    "problem_submissions": {
        "D": [
            200754699,
            200776097,
            200739331,
            200726520,
            200726373,
            200739709,
            200727620,
            200738822,
            200747547,
            200759872,
            200759241,
            200755197,
            200743077,
            200739694,
            200732035,
            200829329,
            200737167,
            200752747,
            201109379,
            200751007,
            200768259,
            200755335
        ],
        "C": [
            200736628,
            200766081,
            200730565,
            200712627,
            200719542,
            200722259,
            200709529,
            200720517,
            200728620,
            200721825,
            200720940,
            200720985,
            200725767,
            200879176,
            200829313,
            200722588,
            200730813,
            201109333,
            200731130,
            200718431,
            200716271
        ],
        "E": [
            200723606,
            200703078,
            200750795,
            200749843,
            200716143,
            200712796,
            200731621,
            200716868,
            200723986,
            200707830,
            200710920,
            200730415,
            200743490,
            200719631,
            200829343,
            200754433,
            200735492,
            201109566,
            200738090,
            200759827,
            200722483
        ],
        "A": [
            200719784,
            200697693,
            200709735,
            200697878,
            200695570,
            200704142,
            200696911,
            200699911,
            200693442,
            200693354,
            200694979,
            200699076,
            200694846,
            200829295,
            200700499,
            200698275,
            201109090,
            200699672,
            200700596,
            200701647
        ],
        "G2": [
            200717686,
            200742559,
            200770344,
            200958696,
            201374187,
            200831218,
            200831193
        ],
        "G1": [
            200709506,
            200742442,
            200769728,
            200763697,
            200744953,
            200746011,
            200720480,
            200748735,
            200760247,
            200772203,
            200771883,
            200769679,
            200758537,
            200829373,
            200780627,
            200774881,
            201171573,
            200757032
        ],
        "B": [
            200708366,
            200716585,
            200706793,
            200704223,
            200701078,
            200703012,
            200714270,
            200697883,
            200700006,
            200701394,
            200706383,
            200878903,
            200709089,
            200704797,
            200829301,
            200712812,
            200723595,
            201109130,
            200726473,
            200716074,
            200734848
        ],
        "F": [
            200764192,
            200777349,
            200768176,
            201109661,
            200843383,
            200769121,
            201693689,
            201686646,
            200776061
        ]
    },
    "name": "B. Conveyor Belts",
    "statement": "Conveyor matrix m_n is matrix of size n\r\ntimes n, where n is an number. The matrix consists of concentric ribbons\r\nmoving clockwise.In other words, the conveyor matrix for n = 2 is simply\r\na matrix 2\r\ntimes 2, whose cells form a cycle of length 4 clockwise. For any natural\r\nk\r\nge 2, the matrix m_{2k} is obtained by adding to the matrix m_{2k - 2}\r\nan outer layer forming a clockwise cycle. . You are standing in a cell\r\nwith coordinates x_1, y_1 and you want to get into a cell with\r\ncoordinates x_2, y_2. A cell has coordinates x, y if it is located at\r\nthe intersection of the xth row and the yth column.Standing on some\r\ncell, every second you will move to the cell next in the direction of\r\nmovement of the tape on which you are. You can also move to a\r\nneighboring cell by spending one unit of energy. Movements happen\r\ninstantly and you can make an unlimited number of them at any time.Your\r\ntask is to find the minimum amount of energy that will have to be spent\r\nto get from the cell with coordinates x_1, y_1 to the cell with\r\ncoordinates x_2, y_2.For example, n=8 initially you are in a cell with\r\ncoordinates 1,3 and you want to get into a cell with coordinates 6, 4.\r\nYou can immediately make 2 movements, once you are in a cell with\r\ncoordinates 3, 3, and then after 8 seconds you will be in the right\r\ncell.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\n#define fi first\n#define se second\n#define E '\\n'\nmt19937 gen(chrono::system_clock().now().time_since_epoch().count());\n\nvoid svin() {\n    int n, x1, y1, x2, y2;\n    cin >> n >> x1 >> y1 >> x2 >> y2;\n    x1 = min(x1, n - x1 + 1);\n    y1 = min(y1, n - y1 + 1);\n    int k1 = min(x1, y1);\n    x2 = min(x2, n - x2 + 1);\n    y2 = min(y2, n - y2 + 1);\n    int k2 = min(x2, y2);\n//    cout << x1 << ' ' << y1 << ' ' << x2 << ' ' << y2 << E;\n    cout << abs(k1 - k2) << E;\n    return;\n}\n\nint32_t main () {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif // LOCAL\n    int qq;\n    cin >> qq;\n    while(qq--) {\n        svin();\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Conveyor Belts.json",
    "editorial_link": "https://codeforces.com//blog/entry/114788",
    "editorial": "Note that the conveyor matrix consists of cycles, through each of which\r\nwe can move without wasting energy. Now you need to find the distance\r\nbetween the cycles where the start and end cells are located. In one\r\nstep from any cycle, you can go either to the cycle that is closer to\r\nthe edge of the matrix, or to the cycle that is further from the edge of\r\nthe matrix. It turns out that it is enough to find on which cycles there\r\nare cells on the edge and take their difference modulo.\r\n"
}