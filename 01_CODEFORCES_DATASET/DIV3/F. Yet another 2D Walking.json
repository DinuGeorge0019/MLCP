{
    "link": "https://codeforces.com//contest/1066/problem/F",
    "problemId": "235864",
    "problem_idx": "F",
    "shortId": "1066F",
    "contest_number": "1066",
    "problem_submissions": {
        "F": [
            44205429,
            44212106,
            44214312,
            44211772,
            44215735,
            44216480,
            44217948,
            44226593
        ],
        "A": [
            44198897,
            44190264,
            44190996,
            44190521,
            44194374,
            44191748,
            44192884,
            44190114,
            44190457,
            44190392,
            44190295,
            44232541,
            44190105,
            44190131,
            44190364,
            44190102,
            44190147,
            44190161,
            44189962,
            44194814,
            44190476
        ],
        "B": [
            44197927,
            44195073,
            44192967,
            44193419,
            44192423,
            44197883,
            44195893,
            44197752,
            44191223,
            44190844,
            44195475,
            44193709,
            44258187,
            44195185,
            44192726,
            44197021,
            44193282,
            44199995,
            44192974,
            44197693,
            44198781,
            44196227
        ],
        "E": [
            44194302,
            44198044,
            44197688,
            44200186,
            44206112,
            44204683,
            44211808,
            44198204,
            44195532,
            44205080,
            44203248,
            44258229,
            44204157,
            44207684,
            44206425,
            44203537,
            44205955,
            44206848,
            44208459,
            44207862,
            44206046
        ],
        "D": [
            44192050,
            44200143,
            44200943,
            44204312,
            44203052,
            44199330,
            44205029,
            44195917,
            44202796,
            44193485,
            44198842,
            44258212,
            44199756,
            44199261,
            44202172,
            44206141,
            44203730,
            44203685,
            44199896,
            44193449,
            44202596
        ],
        "C": [
            44190191,
            44192207,
            44196592,
            44195653,
            44199921,
            44207097,
            44202048,
            44193208,
            44195430,
            44199895,
            44196374,
            44258203,
            44196767,
            44197574,
            44194617,
            44197700,
            44192395,
            44195734,
            44195568,
            44200428,
            44198081
        ]
    },
    "name": "F. Yet another 2D Walking",
    "statement": "Maksim walks on a Cartesian plane. Initially, he stands at the point (0,\r\n0) and in one move he can go to any of four adjacent points (left,\r\nright, up, down). For example, if Maksim is currently at the point (0,\r\n0), he can go to any of the following points in one move: (1, 0); (0,\r\n1); (-1, 0); (0, -1). There are also n key points at this plane. The\r\ni-th point is p_i = (x_i, y_i). It is guaranteed that 0\r\nle x_i and 0\r\nle y_i and there is no key point (0, 0).Let the first level points be\r\nsuch points that max(x_i, y_i) = 1, the second level points be such\r\npoints that max(x_i, y_i) = 2 and so on. Maksim wants to visit all the\r\nkey points. But he shouldn\u2019t visit points of level i + 1 if he does not\r\nvisit all the points of level i. He starts visiting the points from the\r\nminimum level of point from the given set.The distance between two\r\npoints (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2| where |v|\r\nis the absolute value of v.Maksim wants to visit all the key points in\r\nsuch a way that the total distance he walks will be minimum possible.\r\nYour task is to find this distance.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << '=' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << \" = {\"; FOR(_, l, r) cerr << ' ' << a[_]; cerr << \"}\\n\"; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl '\\n'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname \"\"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nmap<int, int> MIN, MAX;\n\npp id(int x, int t) {\n    if (t >= x) return pp(x, x + x - t);\n    return pp(t, x);\n}\n\nlong long Dist(pp a, pp b) {\n    return abs(a.first - b.first) + abs(a.second - b.second);\n}\n\nint main() {\n    #ifdef NERO\n    freopen(\"test.inp\",\"r\",stdin);\n    freopen(\"test.out\",\"w\",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname\".inp\",\"r\",stdin);\n        //freopen(taskname\".out\",\"w\",stdout);\n    #endif //NERO\n    IO;\n    int n;\n    cin >> n;\n    vector<int> r;\n    FOR(i, 1, n) {\n        int x, y;\n        cin >> x >> y;\n        int l = max(x, y), t;\n        if (x == l) t = x + l - y;\n        else t = x; \n        if (MIN.find(l) == MIN.end()) MIN[l] = t;\n        else MIN[l] = min(MIN[l], t);\n        if (MAX.find(l) == MAX.end()) MAX[l] = t;\n        else MAX[l] = max(MAX[l], t);\n        r.push_back(l);\n    }\n    r.push_back(0);\n    sort(all(r));\n    long long d0 = 0, d1 = 0;\n    if (MIN.find(0) != MIN.end()) {\n        d0 = Dist(pp(0, 0), id(0, MAX[0])) + Dist(id(0, MAX[0]), id(0, MIN[0]));\n        d1 = Dist(pp(0, 0), id(0, MIN[0])) + Dist(id(0, MIN[0]), id(0, MAX[0]));\n    }\n    int bef = 0;\n    for (int x : r) if (x != bef) {\n        long long nd0 = min(d0 + Dist(id(bef, MIN[bef]), id(x, MAX[x])), d1 + Dist(id(bef, MAX[bef]), id(x, MAX[x])));\n        long long nd1 = min(d0 + Dist(id(bef, MIN[bef]), id(x, MIN[x])), d1 + Dist(id(bef, MAX[bef]), id(x, MIN[x])));\n        d0 = nd0 + Dist(id(x, MIN[x]), id(x, MAX[x]));\n        d1 = nd1 + Dist(id(x, MIN[x]), id(x, MAX[x]));\n        bef = x;\n    }\n    cout << min(d0, d1);\n    #ifdef NERO\n    double etime = clock();\n    cerr << \"Execution time: \" << (etime - stime) / CLOCKS_PER_SEC * 1000 << \" ms.\\n\";\n    #endif // NERO\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Yet another 2D Walking.json",
    "editorial_link": "https://codeforces.com//blog/entry/62419",
    "editorial": "The main idea is that we don\u00e2\u0080\u0099t need more than border points on each\r\nlevel. So if we consider than the point is less than point when or and\r\nthen let\u00e2\u0080\u0099s distribute all the points by their levels using or something\r\nlike it, sort points on each level by the comparator above and remain\r\nthe first one and the last one on each level. Also let\u00e2\u0080\u0099s add the fictive\r\nlevel with the point . It is always true to remain at most points and\r\ncan be easily proved but this fact is very intuitive I think. Now let\u00e2\u0080\u0099s\r\ndo dynamic programming on the points. means that now we are at the level\r\nand stay in the first point (if ) or in the last point (if ) and we are\r\nalready visit all the points on the level . The value of this dynamic\r\nprogramming is the minimum possible total distance to reach this state.\r\nInitially, , other values are equal to . Let\u00e2\u0080\u0099s calculate this dynamic\r\nprogramming in order of increasing levels. Let be the first key point at\r\nthe level and be the last key point at the level . Now if we are at the\r\nlevel and the previous level is , these transitions are sufficient to\r\ncalculate states of dynamic programming on the current level: ; ; ; .\r\nThere means the distance between points and .Let last level we have be .\r\nAfter calculating this dynamic programming the answer is .\r\n"
}