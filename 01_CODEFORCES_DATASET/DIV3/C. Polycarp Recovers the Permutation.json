{"link": "https://codeforces.com//contest/1611/problem/C", "problemId": "1202186", "problem_idx": "C", "shortId": "1611C", "contest_number": "1611", "problem_submissions": {"G": [136919698, 136924345, 136928058, 137125236], "D": [136909432, 136888068, 136869096, 136875871, 136873458, 136872703, 136892897, 136874114, 136878310, 136876576, 136982847, 136873530, 136877831, 136975464, 136882777, 136872332, 136878705, 136879548, 136882637, 136884556, 136875995, 136885445], "C": [136904645, 136879235, 136858847, 136855243, 136861532, 136858913, 136876501, 136863657, 136864973, 136856130, 136982821, 136863847, 136868283, 136968820, 136869195, 136914947, 136862897, 136869863, 136862192, 136866525, 136860324, 136867113], "F": [136894434, 136926092, 136925788, 136894423, 136887654, 136898905, 136890793, 136892527, 136897622, 136914432, 136920232, 136982943, 136925360, 136906595, 136919174, 136903703, 136921493, 136918298, 136922728, 136905212, 136914690, 136921349], "E2": [136882323, 136916663, 136883396, 136897153, 136890210, 136911911, 136900593, 136909227, 136895787, 136903952, 136982885, 136896820, 136917983, 136900669, 136888044, 136899257, 136899662, 136904447, 136915639, 136920739, 136912069], "E1": [136879967, 136917077, 136876615, 136879938, 136883345, 136903050, 136866650, 136906813, 136891861, 136885925, 136982868, 136892962, 136889119, 136896344, 136885342, 136893182, 136895321, 136895279, 136895954, 136895593, 136897796], "B": [136853549, 136850019, 136845917, 136846742, 136848311, 136849660, 136855952, 136851245, 136847523, 136844081, 136855128, 136851469, 136843577, 136850258, 136848183, 136852060, 136853372, 136855929, 136847562, 136850988], "A": [136844450, 136846022, 136842097, 136842084, 136843783, 136847130, 136842440, 136842943, 136843633, 136841984, 136846854, 136846415, 136848083, 136843263, 136843590, 136843624, 136845033, 136842923, 136842870, 136846917]}, "name": "C. Polycarp Recovers the Permutation", "statement": "Polycarp wrote on a whiteboard an array p of length n, which is a\r\npermutation of numbers from 1 to n. In other words, in p each number\r\nfrom 1 to n occurs exactly once.He also prepared a resulting array a,\r\nwhich is initially empty (that is, it has a length of 0).After that, he\r\ndid exactly n . Each looked like this: Look at the leftmost and\r\nrightmost elements of p, and pick the smaller of the two. If you picked\r\nthe leftmost element of p, append it to the left of a; otherwise, if you\r\npicked the rightmost element of p, append it to the right of a. The\r\npicked element is erased from p. Note that on the last step, p has a\r\nlength of 1 and its minimum element is both leftmost and rightmost. In\r\nthis case, Polycarp can choose what role the minimum element plays. In\r\nother words, this element can be added to a both on the left and on the\r\nright (at the discretion of Polycarp).Let\u2019s look at an example. Let n=4,\r\np=[3, 1, 4, 2]. Initially a=[]. Then: During the first step, the minimum\r\nis on the right (with a value of 2), so after this step, p=[3,1,4] and\r\na=[2] (he added the value 2 to the right). During the second step, the\r\nminimum is on the left (with a value of 3), so after this step, p=[1,4]\r\nand a=[3,2] (he added the value 3 to the left). During the third step,\r\nthe minimum is on the left (with a value of 1), so after this step,\r\np=[4] and a=[1,3,2] (he added the value 1 to the left). During the\r\nfourth step, the minimum is both left and right (this value is 4). Let\u2019s\r\nsay Polycarp chose the right option. After this step, p=[] and\r\na=[1,3,2,4] (he added the value 4 to the right).Thus, a possible value\r\nof a after n steps could be a=[1,3,2,4].You are given the final value of\r\nthe resulting array a. Find possible initial value for p that can result\r\nthe given a, or determine that there is no solution.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        int N;\n        std::cin>>N;\n        int array[N];for(auto&x:array)std::cin>>x;\n        if(array[0]!=N&&array[N-1]!=N){\n            printf(\"-1\\n\");\n            continue;\n        }\n        if(array[0]==N){\n            std::deque<int> deq;\n            deq.push_back(N);\n            for(int i=1;i!=N;++i){\n                deq.push_back(array[i]);\n            }\n            std::reverse(deq.begin(),deq.end());\n            for(auto&x:deq)std::cout<<x<<\" \";std::cout<<\"\\n\";\n        }else {\n            std::deque<int> deq;\n            for(int i=N-1;i!=-1;--i){\n                deq.push_back(array[i]);\n            }\n            //std::reverse(deq.begin(),deq.end());\n            for(auto&x:deq)std::cout<<x<<\" \";std::cout<<\"\\n\";\n        }\n    }\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "1000", "interactive": false}