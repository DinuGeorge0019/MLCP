{
    "link": "https://codeforces.com//contest/1579/problem/A",
    "problemId": "1123866",
    "problem_idx": "A",
    "shortId": "1579A",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "A. Casimir's String Solitaire",
    "statement": "Casimir has a string s which consists of capital Latin letters \u201d, \u201d, and\r\n\u201d only. Each turn he can choose to do one of the two following actions:\r\nhe can either erase exactly one letter \u201d exactly one letter \u201d from\r\narbitrary places of the string (these letters don\u2019t have to be\r\nadjacent); or he can erase exactly one letter \u201d exactly one letter \u201d\r\nfrom arbitrary places in the string (these letters don\u2019t have to be\r\nadjacent). Therefore, each turn the length of the string is decreased\r\nexactly by 2. All turns are independent so for each turn, Casimir can\r\nchoose any of two possible actions.For example, with s = \"\" he can\r\nobtain a string s = \"\" in one turn (by erasing the first occurrence of \u201d\r\nand the second occurrence of \u201d). There are also many other options for a\r\nturn aside from this particular example.For a given string s determine\r\nwhether there is a sequence of actions leading to an empty string. In\r\nother words, Casimir\u2019s goal is to erase all letters from the string. Is\r\nthere a way to do this?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        char a[55];\n        cin >> a+1;\n        int n = strlen(a+1);\n        int c[2] = {0,0};\n        for(int i = 1;i <= n;i++) {\n            if(a[i] == 'B') c[1]++;\n            else c[0]++;\n        }\n        if(c[0] == c[1]) cout << \"YES\\n\";\n        else cout << \"NO\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Casimir's String Solitaire.json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "Note that no matter which action is chosen, after this action is\r\nperformed one letter \u00e2\u0080\u009d is erased from the string two letters in total\r\nare erased from the string Let\u00e2\u0080\u0099s denote the length of the string by . If\r\nis odd, then described turns can not erase all the characters from the\r\nstrings, because if he is deleting two letters on each turn, the length\r\nwill always remain odd. For example, if the original length of the\r\nstring is , then after one turn it will be equal to , and after two\r\nmoves it will be equal to in which case the next turn is impossible.\r\nThus, if the length of the row is odd, the answer is .If is even, it\r\nwill take exactly steps to erase all characters from the string. Since\r\neach action removes exactly one letter \u00e2\u0080\u009d from the string, the string can\r\nbecome empty only if there are exactly letters \u00e2\u0080\u009d.Let us show that this\r\ncondition is sufficient, that is, if a string has exactly half of the\r\nletters equal to \u00e2\u0080\u009d, then there always exists a sequence of actions\r\nleading to an empty string. Indeed, if a string of length has exactly\r\nletters \u00e2\u0080\u009d, exactly letters \u00e2\u0080\u009d and exactly letters \u00e2\u0080\u009d, then . Then Casimir\r\ncan make moves of the first type, each time removing the first\r\noccurrence of \u00e2\u0080\u009d and the first occurrence of \u00e2\u0080\u009d, and moves of the second\r\ntype, each time removing the first occurrence of \u00e2\u0080\u009d and the first\r\noccurrence of \u00e2\u0080\u009d. After such moves, the string will become empty.Thus,\r\nchecking that the number of letters \u00e2\u0080\u009d in the string is exactly half of\r\nits length was enough to solve the problem.\r\n"
}