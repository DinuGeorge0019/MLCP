{
    "link": "https://codeforces.com//contest/1955/problem/F",
    "problemId": "2579458",
    "problem_idx": "F",
    "shortId": "1955F",
    "contest_number": "1955",
    "problem_submissions": {
        "G": [
            255700432,
            255685371,
            255700202,
            255694984,
            255713116,
            255710945,
            255815483,
            255720205,
            255712913,
            255719635,
            255740112,
            255735779,
            255734648,
            255728080,
            255811582,
            255740083,
            255712654,
            255816753,
            255730101,
            255733676,
            255729429,
            255749883
        ],
        "F": [
            255690836,
            255730118,
            255712738,
            255723348,
            255696813,
            255721239,
            255711672,
            255703746,
            255701885,
            255718873,
            255724659,
            255733290,
            255718852,
            255723723,
            255725364,
            255717728,
            255710197,
            255736254,
            255712457
        ],
        "E": [
            255679602,
            255678850,
            255660817,
            255677164,
            255677495,
            255695083,
            255692381,
            255695668,
            255688219,
            255691378,
            255687451,
            255688784,
            255697004,
            255707937,
            255738844,
            255740248,
            255706468,
            255704684,
            255707886
        ],
        "D": [
            255663451,
            255667353,
            255685203,
            255671122,
            255669296,
            255675907,
            255680787,
            255676580,
            255675808,
            255675309,
            255677471,
            255667366,
            255685779,
            255681400,
            255682629,
            255685354,
            255677101,
            255696157,
            255690888
        ],
        "C": [
            255657238,
            255660807,
            255678901,
            255663623,
            255662171,
            255657175,
            255664052,
            255666604,
            255666050,
            255656375,
            255666921,
            255652774,
            255678671,
            255660970,
            255664282,
            255661069,
            255666029,
            255658918,
            255678375
        ],
        "B": [
            255642714,
            255647145,
            255662403,
            255652531,
            255651120,
            255650530,
            255651554,
            255653536,
            255651004,
            255648291,
            255648566,
            255643999,
            255648718,
            255649499,
            255650291,
            255653938,
            255647027,
            255650471,
            255659271
        ],
        "A": [
            255635163,
            255633427,
            255637795,
            255633451,
            255634276,
            255634783,
            255634704,
            255650196,
            255634135,
            255635088,
            255633579,
            255633389,
            255637393,
            255636215,
            255633812,
            255642645,
            255634779,
            255634460,
            255639283
        ],
        "H": [
            255690981,
            255842703,
            255840768
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128243",
    "editorial": "Letâs try to solve the problem if all the numbers in the sequence are\r\nequal to . If the number of elements is even, the bitwise XOR is zero,\r\nand if itâs odd, then itâs equal to . By removing one at a time, Eve\r\nwill change the parity, so the answer will be .Suppose there are some\r\nother numbers in the sequence besides . For Bob to win, the number of s\r\nstill needs to be even. Therefore, we can solve the problem for the\r\nremaining numbers separately from the fours.One of the solutions uses\r\ndynamic programming. Letâs denote as the maximum number of Bobâs wins,\r\nif there were initially ones, twos, and threes. Since an empty sequence\r\nis not considered in the answer, then . We will iterate over which\r\nnumber to remove, and get the following transitions: . Here, if the\r\nbitwise XOR of ones, twos, and threes is zero, and otherwise. The\r\ncomplexity of calculating these values is , where .Another solution is\r\nanalytical. Bob wins in two cases: if the number of ones, twos, and\r\nthrees is even; if the number of ones, twos, and threes is odd. In the\r\nfirst case, the bitwise XOR is zero, because each number occurs an even\r\nnumber of times, and in the second case, .To maintain the parities, Eve\r\nneeds to remove the same number, so with two removals, Bob will win\r\nonce. If the second condition is not initially met, it is always more\r\nadvantageous to remove numbers to reach the first case, then the answer\r\nis . If the second condition is already met, then needs to be added to\r\nthe answer.\r\n",
    "name": "F. Unfair Game",
    "statement": "Alice and Bob gathered in the evening to play an exciting game on a\r\nsequence of n integers, each integer of the sequence . The rules of the\r\ngame are too complex to describe, so let’s just describe the winning\r\ncondition Alice wins if the bitwise XOR of all the numbers in the\r\nsequence is non-zero; otherwise, Bob wins.The guys invited Eve to act as\r\na judge. Initially, Alice and Bob play with n numbers. After one game,\r\nEve removes one of the numbers from the sequence, then Alice and Bob\r\nplay with n-1 numbers. Eve removes one number again, after which Alice\r\nand Bob play with n - 2 numbers. This continues until the sequence of\r\nnumbers is empty.Eve seems to think that in such a game, Alice almost\r\nalways wins, so she wants Bob to win as many times as possible.\r\nDetermine the maximum number of times Bob can win against Alice if Eve\r\nremoves the numbers optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define int long longusing namespace std;class Segment_Tree{public:\tstruct tree{\t\tint l,r,sum,maxx,minx,flag;\t}tr[800005];\tvoid pushup(int u){\t\ttr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\t\ttr[u].maxx=max(tr[u<<1].maxx,tr[u<<1|1].maxx);\t\ttr[u].minx=min(tr[u<<1].minx,tr[u<<1|1].minx);\t}\tvoid pushdown(int u){\t\tif(tr[u].flag){\t\t\ttr[u<<1].sum+=tr[u].flag*(tr[u<<1].r-tr[u<<1].l+1),tr[u<<1].maxx+=tr[u].flag,tr[u<<1].minx+=tr[u].flag,tr[u<<1].flag+=tr[u].flag;\t\t\ttr[u<<1|1].sum+=tr[u].flag*(tr[u<<1|1].r-tr[u<<1|1].l+1),tr[u<<1|1].maxx+=tr[u].flag,tr[u<<1|1].minx+=tr[u].flag,tr[u<<1|1].flag+=tr[u].flag;\t\t\ttr[u].flag=0;\t\t}\t}\tvoid build(int u,int l,int r){\t\tif(l==r){\t\t\ttr[u]={l,r,0,0,0,0};\t\t\treturn;\t\t}\t\ttr[u]={l,r};\t\tint mid=l+r>>1;\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\t\tpushup(u);\t}\tvoid change(int u,int l,int r,int k){\t\tif(l>r)return;\t\tif(tr[u].l>=l&&tr[u].r<=r){\t\t\ttr[u].sum+=k*(tr[u].r-tr[u].l+1);\t\t\ttr[u].maxx+=k,tr[u].minx+=k;\t\t\ttr[u].flag+=k;\t\t\treturn;\t\t}\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1;\t\tif(l<=mid)change(u<<1,l,r,k);\t\tif(r>mid)change(u<<1|1,l,r,k);\t\tpushup(u);\t}\tint query_sum(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=0;\t\tif(l<=mid)res+=query_sum(u<<1,l,r);\t\tif(r>mid)res+=query_sum(u<<1|1,l,r);\t\treturn res;\t}\tint query_max(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].maxx;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=-1e18;\t\tif(l<=mid)res=max(res,query_max(u<<1,l,r));\t\tif(r>mid)res=max(res,query_max(u<<1|1,l,r));\t\treturn res;\t}\tint query_min(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].minx;;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=1e18;\t\tif(l<=mid)res=min(res,query_min(u<<1,l,r));\t\tif(r>mid)res=min(res,query_min(u<<1|1,l,r));\t\treturn res;\t}}sgt;int t,n,dp[205][205][205],a,b,c,d;int calc(int i,int j,int k){\tint a=i&1,b=j&1,c=k&1;\treturn a==b&&b==c;}signed main(){\tcin>>t;\tdp[0][0][0]=0;\tfor(int i=0;i<=200;i++)for(int j=0;j<=200;j++)for(int k=0;k<=200;k++){\t\tdp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k]+calc(i,j,k+1));\t\tdp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]+calc(i,j+1,k));\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]+calc(i+1,j,k));\t}\twhile(t--){\t\tcin>>a>>b>>c>>d;\t\tcout<<dp[a][b][c]+d/2<<\"\\n\";\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games",
        "greedy",
        "math",
        "schedules"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Unfair Game.json",
    "hint": []
}