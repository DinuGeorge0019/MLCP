{
    "link": "https://codeforces.com//contest/1974/problem/F",
    "problemId": "2657208",
    "problem_idx": "F",
    "shortId": "1974F",
    "contest_number": "1974",
    "problem_submissions": {
        "G": [
            261890876,
            261895242,
            261892104,
            261815844,
            261901397,
            261882110,
            261902942,
            261897196,
            261890302,
            261906925,
            261906633,
            261902994,
            261909128,
            262172085,
            261998366,
            261998046,
            261912311
        ],
        "F": [
            261873832,
            261860163,
            261871347,
            261886083,
            261890598,
            261905275,
            261893342,
            261893849,
            261885670,
            261888292,
            261884408,
            261903255,
            261856931,
            261866178,
            261998302,
            261867572,
            261874550,
            261881230,
            261896095,
            261891848
        ],
        "E": [
            261843511,
            261898684,
            261874046,
            261856295,
            261872971,
            261858650,
            261864336,
            261872189,
            261875499,
            261861733,
            261866981,
            261850233,
            261886170,
            261845363,
            261845593,
            261998691,
            261848135,
            261863399,
            261863179,
            261861452,
            261854564
        ],
        "D": [
            261828744,
            261833579,
            261844887,
            261858347,
            261848070,
            261834943,
            261843848,
            261843125,
            261893971,
            261854059,
            261850835,
            261836444,
            261865680,
            261830266,
            261832171,
            261998550,
            261835226,
            261844678,
            261837286,
            261829368,
            261844070
        ],
        "C": [
            261809458,
            261818269,
            261821670,
            261838680,
            261824893,
            261817516,
            261818307,
            261822342,
            261872865,
            261902570,
            261836543,
            261891689,
            261812999,
            261811999,
            261811344,
            261998621,
            261807237,
            261810379,
            261809093,
            261808251,
            261815953
        ],
        "B": [
            261801251,
            261803139,
            261801216,
            261828779,
            261802058,
            261805873,
            261803693,
            261800515,
            261806010,
            261808108,
            261800732,
            261800673,
            261801484,
            261801347,
            261998221,
            261798953,
            261798594,
            261800683,
            261798231,
            261800035
        ],
        "A": [
            261797694,
            261795610,
            261795288,
            261822724,
            261797136,
            261796736,
            262453696,
            261795629,
            261796165,
            261795943,
            261800077,
            261795571,
            261795380,
            261796034,
            261796954,
            261998187,
            261795311,
            261795243,
            261796139,
            261795603,
            261796608
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129686",
    "editorial": "First, let\u00e2\u0080\u0099s sort all cells with chips in non-decreasing order of the\r\nx-coordinate (let\u00e2\u0080\u0099s denote the array as ), also in a separate array we\r\nwill sort them in non-decreasing order of the y-coordinate.As we add\r\nmoves, we will maintain the boundaries of the original matrix to which\r\nit was cut: we will shift the respective boundary by . Obviously, the\r\nmoves will remove some prefix from the array and add it to the answer,\r\nand the moves will remove some suffix from the array and add it to the\r\nanswer. The same goes for the moves and and the array . Instead of\r\nremoving elements, the current boundaries of the arrays can be\r\nmaintained using two pointers.However, with this calculation, some chips\r\nmay be counted twice: when removed vertically and when removed\r\nhorizontally. To prevent this from happening, we will maintain a set of\r\nalready removed vertices and before adding a chip to the answer, we will\r\ncheck that it has not been removed before.\r\n",
    "name": "F. Cutting Game",
    "statement": "Alice and Bob were playing a game again. They have a grid of size a\r\ntimes b (1\r\nle a, b\r\nle 10^9), on which there are n chips, with at most one chip in each\r\ncell. The cell at the intersection of the x-th row and the y-th column\r\nhas coordinates (x, y).Alice made the first move, and the players took\r\nturns. On each move, a player could cut several (but not all) rows or\r\ncolumns from the beginning or end of the remaining grid and earn a point\r\nfor each chip that was on the cut part of the grid. Each move can be\r\ndescribed by the character \u201d, \u201d, \u201d, or \u201d and an integer k: If the\r\ncharacter is \u201d, then the first k remaining rows will be cut; If the\r\ncharacter is \u201d, then the last k remaining rows will be cut; If the\r\ncharacter is \u201d, then the first k remaining columns will be cut; If the\r\ncharacter is \u201d, then the last k remaining columns will be cut. Based on\r\nthe initial state of the grid and the players\u2019 moves, determine the\r\nnumber of points earned by Alice and Bob, respectively.\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <algorithm>#include <vector>#include <chrono>#include <random>#include <map>#include <set>using namespace std;typedef long long ll;const int N = 2e5 + 10;ll c[N], h[N];ll dp[N];ll nxt_dp[N];struct esim {\tint h1;\tint h2;\tint w1;\tint w2;};struct cell {\tint x;\tint y;};void solve() {\tint a, b, n, m;\tcin >> a >> b >> n >> m;\tvector <cell> v(n);\tfor (int i = 0; i < n; i++) {\t\tcin >> v[i].x >> v[i].y;\t}\tvector <esim> rect;\trect.push_back({ 1, a, 1, b });\tfor (int i = 1; i <= m; i++) {\t\tchar x;\t\tint k;\t\tcin >> x >> k;\t\trect.push_back(rect.back());\t\tif (x == 'D') {\t\t\trect.back().h2 -= k;\t\t}\t\telse if (x == 'U') {\t\t\trect.back().h1 += k;\t\t}\t\telse if (x == 'L') {\t\t\trect.back().w1 += k;\t\t}\t\telse rect.back().w2 -= k;\t}\u00a0\tint al = 0, bo = 0;\tfor (int i = 0; i < n; i++) {\t\tint l = 1, r = (int)rect.size() - 1, ans = -1;\t\twhile (l <= r) {\t\t\tint mid = (l + r) / 2;\t\t\tif (rect[mid].h1 <= v[i].x && rect[mid].h2 >= v[i].x\t\t\t\t&& rect[mid].w1 <= v[i].y && rect[mid].w2 >= v[i].y) {\t\t\t\tl = mid + 1;\t\t\t}\t\t\telse {\t\t\t\tans = mid;\t\t\t\tr = mid - 1;\t\t\t}\t\t}\t\tif (ans == -1) continue;\t\tif (ans % 2 == 1) al++;\t\telse bo++;\t}\tcout << al << \" \" << bo << \"\\n\";}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Cutting Game.json"
}