{
    "link": "https://codeforces.com//contest/1618/problem/G",
    "problemId": "1227956",
    "problem_idx": "G",
    "shortId": "1618G",
    "contest_number": "1618",
    "problem_submissions": {
        "G": [
            139298777,
            139297222,
            147150291,
            139364685,
            139409455,
            139648321,
            139647934
        ],
        "F": [
            139286789,
            139282379,
            139275492,
            139270703,
            139264773,
            139269869,
            139294667,
            139290022,
            139289512,
            139289145,
            139278629,
            139289873,
            139296435,
            139290218,
            139296340,
            139291619,
            139306934,
            139294280
        ],
        "E": [
            139268981,
            139269746,
            139265192,
            139288008,
            139286534,
            139292817,
            139289487,
            139275540,
            139264697,
            139274832,
            139271561,
            139276852,
            139289947,
            139276892,
            139262566,
            139266584,
            139281022,
            139278645,
            139265520,
            139264637
        ],
        "D": [
            139243472,
            139258171,
            139239440,
            139248181,
            139244770,
            139256877,
            139242852,
            139240922,
            139263049,
            139256358,
            139258140,
            139242686,
            139254763,
            139250478,
            139246269,
            139248291,
            139261914,
            139245393,
            139247542
        ],
        "C": [
            139236892,
            139248164,
            139234207,
            139233239,
            139237269,
            139236931,
            139234400,
            139234756,
            139241546,
            139242932,
            139243062,
            139234781,
            139244605,
            139237946,
            139235290,
            139240735,
            139234614,
            139239569,
            139238791
        ],
        "B": [
            139230188,
            139242690,
            139229799,
            139237462,
            139230545,
            139229999,
            139230110,
            139230462,
            139231463,
            139238436,
            139232362,
            139229957,
            139236386,
            139231275,
            139228222,
            139232735,
            139228200,
            139236174,
            139233281
        ],
        "A": [
            139224679,
            139233161,
            139223562,
            139225900,
            139224918,
            139224044,
            139223463,
            139224332,
            139224219,
            139225245,
            139226896,
            139224223,
            139228880,
            139226421,
            139224424,
            139224261,
            139224339,
            139225398,
            139227257
        ]
    },
    "name": "G. Trader Problem",
    "statement": "Monocarp plays a computer game (yet again!). This game has a unique\r\ntrading mechanics.To trade with a character, Monocarp has to choose one\r\nof the items he possesses and trade it for some item the other character\r\npossesses. Each item has an integer price. If Monocarp\u2019s chosen item has\r\nprice x, then he can trade it for any item with price not greater than\r\nx+k.Monocarp initially has n items, the price of the i-th item he has is\r\na_i. The character Monocarp is trading with has m items, the price of\r\nthe i-th item they have is b_i. Monocarp can trade with this character\r\nas many times as he wants (possibly even zero times), each time\r\nexchanging one of his items with one of the other character\u2019s items\r\naccording to the aforementioned constraints. Note that if Monocarp gets\r\nsome item during an exchange, he can trade it for another item (since\r\nnow the item belongs to him), and vice versa: if Monocarp trades one of\r\nhis items for another item, he can get his item back by trading\r\nsomething for it.You have to answer q queries. Each query consists of\r\none integer, which is the value of k, and asks you to calculate the\r\nmaximum possible total cost of items Monocarp can have after some\r\nsequence of trades, assuming that he can trade an item of cost x for an\r\nitem of cost not greater than x+k during each trade. Note that the\r\nqueries are independent: the trades do not actually occur, Monocarp only\r\nwants to calculate the maximum total cost he can get.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,h,t) for (int i=h;i<=t;i++)\n#define dep(i,t,h) for (int i=t;i>=h;i--)\n#define ll long long\nconst int N=5e5;\nint n,m,q;\nint fa[N];\nint find(int x)\n{\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nstruct re{\n\tint a,b;\n};\nre a[N],c[N];\nll ans[N],v[N],v2[N],v3[N],sum[N];\nbool cmp(re x,re y)\n{\n\treturn x.a<y.a;\n}\nset<pair<int,int> >S; \nint main()\n{\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>n>>m>>q;\n\tll now=0;\n\trep(i,1,n)\n\t{ \n\t  cin>>a[i].a; a[i].b=1;\n\t  now+=a[i].a;\n    }\n    rep(i,n+1,n+m)\n    {\n    \tcin>>a[i].a; a[i].b=0; \n    }\n    rep(i,1,n+m) fa[i]=i;\n    sort(a+1,a+n+m+1,cmp);\n    rep(i,1,n+m)\n\t{\n\t\tsum[i]=sum[i-1]+a[i].a;\n\t\tv[i]=a[i].a*a[i].b,v2[i]=a[i].b;\n\t\tv3[i]=i;\n    }\n    rep(i,2,n+m)\n      S.insert(make_pair(a[i].a-a[i-1].a,i));\n    rep(i,1,q) { cin>>c[i].a; c[i].b=i;}\n    sort(c+1,c+q+1,cmp);\n    rep(i,1,q)\n    {\n    \twhile (!S.empty()&&(*S.begin()).first<=c[i].a)\n    \t{\n    \t\tint h=(*S.begin()).second;\n    \t\tint f1=find(h),f2=find(h-1);\n    \t\tnow-=v[f1]; now-=v[f2];\n    \t\tfa[f1]=f2;\n    \t\tv2[f2]+=v2[f1];\n    \t\tv3[f2]=max(v3[f2],v3[f1]);\n    \t\tv[f2]=sum[v3[f2]]-sum[v3[f2]-v2[f2]];\n    \t\tnow+=v[f2];\n    \t\tS.erase(S.begin());\n    \t}\n    \tans[c[i].b]=now;\n    }\n    rep(i,1,q) cout<<ans[i]<<\"\\n\";\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "greedy",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Trader Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/97927",
    "editorial": "Suppose we have fixed the value of , so we can trade an item with price\r\nfor an item with price if . We can see that it\u00e2\u0080\u0099s never optimal to trade\r\nan item with higher price for an item with lower price, and we could\r\njust simulate the trading process as follows: try to find an item owned\r\nby Polycarp and a more expensive item owned by the other character which\r\ncan be traded, repeat until we cannot find any suitable\r\npair.Unfortunately, it is too slow. Instead, let\u00e2\u0080\u0099s try to analyze: for a\r\ngiven value of , how to verify that an item of price can be traded for\r\nan item of price (maybe not right away, but with intermediate\r\ntrades)?You can build a graph of vertices representing items, where two\r\nvertices representing items with prices and are connected by an edge if\r\nand only if . Then, the edges of the graph represent possible trades,\r\nand the paths in the graph represent sequences of trades. So, one item\r\ncan be traded for another item (possibly with intermediate trades) if\r\nthe vertices representing the items belong to the same component.For a\r\nfixed value of , we can build this graph, find all of its components,\r\ncalculate the number of Monocarp\u00e2\u0080\u0099s items in each component and add this\r\nnumber of most expensive vertices from the component to the answer.\r\nThere are two problems though.The first one is that the graph may have\r\nup to edges. But if we sort all items according to their prices, we are\r\nonly interested in edges between vertices which represent adjacent items\r\nin sorted order, so the size of the graph is decreased to .Another\r\nproblem is that there are multiple queries for different values of . To\r\nhandle it, we can sort the values of in ascending order and go in sorted\r\norder while maintaining the graph for the current value of . A data\r\nstructure like DSU or a method like small-to-large merging can be\r\nhelpful to update the components as they merge.The last trick: to\r\nquickly recalculate the number of items Monocarp has in a component and\r\nthe sum of most expensive several items, you can build two prefix sum\r\narrays one over the array storing the costs of the items, and another\r\none over the array which stores values or depending on who owns the\r\nrespective item (the items should still be considered in sorted order).\r\nSince each component is a segment of costs of items, prefix sums allow\r\nus to calculate the required values in .By the way, knowing that each\r\ncomponent is a segment, we can get rid of the graph and the structure\r\nthat stores it altogether and just maintain a set of segments of items\r\nrepresenting the components.\r\n"
}