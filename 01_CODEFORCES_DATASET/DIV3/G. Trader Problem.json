{"link": "https://codeforces.com//contest/1618/problem/G", "problemId": "1227956", "problem_idx": "G", "shortId": "1618G", "contest_number": "1618", "problem_submissions": {"G": [139298777, 139297222, 147150291, 139364685, 139409455, 139648321, 139647934], "F": [139286789, 139282379, 139275492, 139270703, 139264773, 139269869, 139294667, 139290022, 139289512, 139289145, 139278629, 139289873, 139296435, 139290218, 139296340, 139291619, 139306934, 139294280], "E": [139268981, 139269746, 139265192, 139288008, 139286534, 139292817, 139289487, 139275540, 139264697, 139274832, 139271561, 139276852, 139289947, 139276892, 139262566, 139266584, 139281022, 139278645, 139265520, 139264637], "D": [139243472, 139258171, 139239440, 139248181, 139244770, 139256877, 139242852, 139240922, 139263049, 139256358, 139258140, 139242686, 139254763, 139250478, 139246269, 139248291, 139261914, 139245393, 139247542], "C": [139236892, 139248164, 139234207, 139233239, 139237269, 139236931, 139234400, 139234756, 139241546, 139242932, 139243062, 139234781, 139244605, 139237946, 139235290, 139240735, 139234614, 139239569, 139238791], "B": [139230188, 139242690, 139229799, 139237462, 139230545, 139229999, 139230110, 139230462, 139231463, 139238436, 139232362, 139229957, 139236386, 139231275, 139228222, 139232735, 139228200, 139236174, 139233281], "A": [139224679, 139233161, 139223562, 139225900, 139224918, 139224044, 139223463, 139224332, 139224219, 139225245, 139226896, 139224223, 139228880, 139226421, 139224424, 139224261, 139224339, 139225398, 139227257]}, "name": "G. Trader Problem", "statement": "Monocarp plays a computer game (yet again!). This game has a unique\r\ntrading mechanics.To trade with a character, Monocarp has to choose one\r\nof the items he possesses and trade it for some item the other character\r\npossesses. Each item has an integer price. If Monocarp\u2019s chosen item has\r\nprice x, then he can trade it for any item with price not greater than\r\nx+k.Monocarp initially has n items, the price of the i-th item he has is\r\na_i. The character Monocarp is trading with has m items, the price of\r\nthe i-th item they have is b_i. Monocarp can trade with this character\r\nas many times as he wants (possibly even zero times), each time\r\nexchanging one of his items with one of the other character\u2019s items\r\naccording to the aforementioned constraints. Note that if Monocarp gets\r\nsome item during an exchange, he can trade it for another item (since\r\nnow the item belongs to him), and vice versa: if Monocarp trades one of\r\nhis items for another item, he can get his item back by trading\r\nsomething for it.You have to answer q queries. Each query consists of\r\none integer, which is the value of k, and asks you to calculate the\r\nmaximum possible total cost of items Monocarp can have after some\r\nsequence of trades, assuming that he can trade an item of cost x for an\r\nitem of cost not greater than x+k during each trade. Note that the\r\nqueries are independent: the trades do not actually occur, Monocarp only\r\nwants to calculate the maximum total cost he can get.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,h,t) for (int i=h;i<=t;i++)\n#define dep(i,t,h) for (int i=t;i>=h;i--)\n#define ll long long\nconst int N=5e5;\nint n,m,q;\nint fa[N];\nint find(int x)\n{\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nstruct re{\n\tint a,b;\n};\nre a[N],c[N];\nll ans[N],v[N],v2[N],v3[N],sum[N];\nbool cmp(re x,re y)\n{\n\treturn x.a<y.a;\n}\nset<pair<int,int> >S; \nint main()\n{\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>n>>m>>q;\n\tll now=0;\n\trep(i,1,n)\n\t{ \n\t  cin>>a[i].a; a[i].b=1;\n\t  now+=a[i].a;\n    }\n    rep(i,n+1,n+m)\n    {\n    \tcin>>a[i].a; a[i].b=0; \n    }\n    rep(i,1,n+m) fa[i]=i;\n    sort(a+1,a+n+m+1,cmp);\n    rep(i,1,n+m)\n\t{\n\t\tsum[i]=sum[i-1]+a[i].a;\n\t\tv[i]=a[i].a*a[i].b,v2[i]=a[i].b;\n\t\tv3[i]=i;\n    }\n    rep(i,2,n+m)\n      S.insert(make_pair(a[i].a-a[i-1].a,i));\n    rep(i,1,q) { cin>>c[i].a; c[i].b=i;}\n    sort(c+1,c+q+1,cmp);\n    rep(i,1,q)\n    {\n    \twhile (!S.empty()&&(*S.begin()).first<=c[i].a)\n    \t{\n    \t\tint h=(*S.begin()).second;\n    \t\tint f1=find(h),f2=find(h-1);\n    \t\tnow-=v[f1]; now-=v[f2];\n    \t\tfa[f1]=f2;\n    \t\tv2[f2]+=v2[f1];\n    \t\tv3[f2]=max(v3[f2],v3[f1]);\n    \t\tv[f2]=sum[v3[f2]]-sum[v3[f2]-v2[f2]];\n    \t\tnow+=v[f2];\n    \t\tS.erase(S.begin());\n    \t}\n    \tans[c[i].b]=now;\n    }\n    rep(i,1,q) cout<<ans[i]<<\"\\n\";\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dsu", "greedy", "sortings"], "dificulty": "2200", "interactive": false}