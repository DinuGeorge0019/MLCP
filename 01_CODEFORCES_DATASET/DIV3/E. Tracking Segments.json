{
    "link": "https://codeforces.com//contest/1843/problem/E",
    "problemId": "1972494",
    "problem_idx": "E",
    "shortId": "1843E",
    "contest_number": "1843",
    "problem_submissions": {
        "A": [
            210513115,
            210358669,
            210356867,
            210356606,
            210356554,
            210357901,
            210357194,
            210356864,
            210358095,
            210357837,
            210357098,
            210356516,
            210357328,
            210356501,
            210359161,
            210356847,
            210356427,
            210357415,
            210358119,
            210357120,
            210364703
        ],
        "F2": [
            210451991,
            210457207,
            210618819,
            210495074,
            210494100,
            210540752,
            210540669
        ],
        "F1": [
            210414403,
            210417478,
            210396846,
            210409917,
            210412496,
            210409842,
            210422089,
            210412238,
            210413002,
            210417779,
            210416655,
            210416375,
            210514291,
            210424999,
            210427270,
            210422907,
            210427091,
            210425631,
            210535488,
            210532084,
            210419095,
            210422275,
            210416513
        ],
        "E": [
            210391764,
            210391814,
            210384445,
            210387069,
            210389387,
            210395623,
            210390859,
            210397426,
            210401897,
            210395689,
            210473862,
            210401991,
            210402273,
            210403725,
            210394172,
            210401396,
            210403436,
            210400251,
            210398852,
            210406208,
            210398263
        ],
        "D": [
            210377103,
            210378604,
            210375920,
            210374828,
            210376525,
            210379717,
            210379591,
            210382067,
            210379942,
            210382515,
            210378874,
            210376209,
            210374876,
            210386844,
            210381700,
            210376444,
            210371551,
            210381744,
            210386605,
            210381316
        ],
        "C": [
            210369061,
            210367738,
            210368361,
            210366823,
            210368080,
            210359312,
            210366442,
            210374049,
            210371348,
            210364184,
            210365780,
            210367512,
            210366187,
            210360428,
            210370272,
            210365171,
            210363817,
            210370422,
            210368258,
            210373372
        ],
        "B": [
            210363239,
            210368717,
            210361290,
            210360953,
            210362948,
            210369749,
            210362940,
            210364525,
            210363196,
            210375176,
            210362328,
            210363841,
            210361045,
            210364327,
            210364107,
            210360838,
            210360957,
            210367115,
            210363394,
            210370393
        ]
    },
    "name": "E. Tracking Segments",
    "statement": "You are given an array a consisting of n zeros. You are also given a set\r\nof m not necessarily different segments. Each segment is defined by two\r\nnumbers l_i and r_i (1\r\nle l_i\r\nle r_i\r\nle n) and represents a subarray a_{l_i}, a_{l_i+1},\r\ndots, a_{r_i} of the array a.Let’s call the segment l_i, r_i if the\r\nnumber of ones on this segment than the number of zeros. For example, if\r\na = [1, 0, 1, 0, 1], then the segment [1, 5] is (the number of ones is\r\n3, the number of zeros is 2), but the segment [3, 4] is not is (the\r\nnumber of ones is 1, the number of zeros is 1).You also have q changes.\r\nFor each change you are given the number 1\r\nle x\r\nle n, which means that you must assign an element a_x the value 1.You\r\nhave to find the first change after which of m given segments becomes ,\r\nor report that none of them is beautiful after processing all q changes.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m,q;\nint ans;\nint a[N];\nint ql[N],qr[N];\nint c[N];\nvoid add(int u,int v)\n{\n\twhile(u<=n)\n\t{\n\t\tc[u]+=v;\n\t\tu+=u&-u;\n\t}\n}\nint ask(int u)\n{\n\tint res=0;\n\twhile(u)\n\t{\n\t\tres+=c[u];\n\t\tu-=u&-u;\n\t}\n\treturn res;\n}\nbool check(int s)\n{\n\tfor(int i=1;i<=n;++i)\tc[i]=0;\n\tfor(int i=1;i<=s;++i)\tadd(a[i],1);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint len=qr[i]-ql[i]+1;\n\t\tint tot=ask(qr[i])-ask(ql[i]-1);\n\t\tif(tot+tot>len)\treturn true;\n\t}\n\treturn false;\n}\nvoid solve()\n{\n\tn=read();\tm=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tql[i]=read();\n\t\tqr[i]=read();\n\t}\n\tq=read();\n\tfor(int i=1;i<=q;++i)\ta[i]=read();\n\tint l=1;int r=q+1;\n\twhile(l<r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid))\tr=mid;\n\t\telse\tl=mid+1;\n\t}\n\tif(l>q)\tputs(\"-1\");\n\telse printf(\"%d\\n\",l);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Tracking Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/117468",
    "editorial": "Letâs use a binary search for an answer. It will work, because if some\r\nsegment was good, then after one more change it will not be no longer\r\ngood, and if all segments were bad, then if you remove the last change,\r\nthey will remain bad.To check if there is a good segment for the prefix\r\nof changes, you can build the array obtained after these changes, and\r\nthen count the prefix sums in . After that, you can go through all the\r\nsegments and check for for a segment whether it is a good or not.Total\r\ncomplexity: .\r\n",
    "hint": []
}