{
    "link": "https://codeforces.com//contest/1005/problem/E2",
    "problemId": "196330",
    "problem_idx": "E2",
    "shortId": "1005E2",
    "contest_number": "1005",
    "problem_submissions": {
        "F": [
            40138065,
            40147546,
            40139536,
            40144099,
            40139733,
            40144938,
            40143679,
            40171160,
            40146303,
            40189217
        ],
        "E1": [
            40128340,
            40127186,
            40134838,
            40136234,
            40136089,
            40143692,
            40135301,
            40137180,
            40144323,
            40124841,
            40127912,
            40131265,
            40133189,
            40133105,
            40133937,
            40134875,
            40135625,
            40134421,
            40131595,
            40135137
        ],
        "D": [
            40125067,
            40124979,
            40128112,
            40136992,
            40132454,
            40129148,
            40135768,
            40128554,
            40130545,
            40126741,
            40124080,
            40124881,
            40127069,
            40127363,
            40130715,
            40128279,
            40129716,
            40130196,
            40122168,
            40126677
        ],
        "C": [
            40122844,
            40120537,
            40121740,
            40127956,
            40126845,
            40126210,
            40127542,
            40132586,
            40121476,
            40122273,
            40121226,
            40121504,
            40123842,
            40124485,
            40124848,
            40125814,
            40188075,
            40124052,
            40125727,
            40127465,
            71194295,
            40123366
        ],
        "B": [
            40118557,
            40118253,
            40123880,
            40122022,
            40117993,
            40119623,
            40121553,
            40121128,
            40129302,
            40117431,
            40118713,
            40118894,
            40119013,
            40119692,
            40120886,
            40121682,
            40120694,
            40121733,
            40125463,
            40118716
        ],
        "A": [
            40117449,
            40117425,
            40122790,
            40118389,
            40117428,
            40118037,
            40118019,
            40118741,
            40117459,
            40117842,
            40117471,
            40117684,
            40117553,
            40117896,
            40118376,
            40119285,
            40118988,
            40117794,
            40123668,
            40117617
        ],
        "E2": [
            40142192,
            40138140,
            40137960,
            97340051,
            97338094,
            40194804,
            40187840
        ]
    },
    "name": "E2. Median on Segments  General Case Edition ",
    "statement": "You are given an integer sequence a_1, a_2,\r\ndots, a_n.Find the number of pairs of indices (l, r) (1\r\nle l\r\nle r\r\nle n) such that the value of median of a_l, a_{l+1},\r\ndots, a_r is exactly the given number m.The median of a sequence is the\r\nvalue of an element which is in the middle of the sequence after sorting\r\nit in non-decreasing order. If the length of the sequence is even, the\r\nleft of two middle elements is used.For example, if a=[4, 2, 7, 5] then\r\nits median is 4 since after sorting the sequence, it will look like [2,\r\n4, 5, 7] and the left of two middle elements is equal to 4. The median\r\nof [7, 1, 2, 9, 6] equals 6 since after sorting, the value 6 will be in\r\nthe middle of the sequence.Write a program to find the number of pairs\r\nof indices (l, r) (1\r\nle l\r\nle r\r\nle n) such that the value of median of a_l, a_{l+1},\r\ndots, a_r is exactly the given number m.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\nint n , m;\nint a[400020 + 5];\nconst int MAXN = (2e5 + 20) * 25;\n  struct Node {\n    int val, size;\n    Node *ls, *rs;\n    Node(int _val, int _size, Node *_ls, Node *_rs) : val(_val), size(_size), ls(_ls), rs(_rs) {}\n    Node() {}\n    inline void pushup() {\n      if (!ls->size) return ;\n      val = rs->val, size = ls->size + rs->size;\n    }\n  } pool[MAXN<<1], *st[MAXN<<1], *root, *null;\nstruct LFT {\n  int cnt;\n  inline Node *newNode(int val, int size, Node *ls, Node *rs) {\n    return &(*st[cnt++] = Node(val, size, ls, rs));\n  }\n  inline Node *merge(Node *ls, Node *rs) {\n    return newNode(rs->val, ls->size + rs->size, ls, rs);\n  }\n  inline void maintain(Node *cur) {\n    Node *&ls = cur->ls, *&rs = cur->rs;\n    if (ls->size > rs->size * 4)\n      rs = merge(ls->rs, rs), st[--cnt] = ls, ls = ls->ls;\n    if (rs->size > ls->size * 4)\n      ls = merge(ls, rs->ls), st[--cnt] = rs, rs = rs->rs;\n  }\n  void insert(Node *cur, int x) {\n    if (cur->size == 1)\n      cur->ls = newNode(min(cur->val, x), 1, null, null),\n           cur->rs = newNode(max(cur->val, x), 1, null, null);\n    else insert(x > cur->ls->val ? cur->rs : cur->ls, x);\n    cur->pushup();\n    maintain(cur);\n  }\n  int kth(Node *cur, int x) {\n    if (cur->size == 1) return cur->val;\n    return x > cur->ls->size ? kth(cur->rs, x - cur->ls->size): kth(cur->ls, x);\n  }\n  int Rank(Node *cur, int x) {\n    if (cur->size == 1) return x > cur->val;\n    return x > cur->ls->val ? Rank(cur->rs, x) + cur->ls->size : Rank(cur->ls, x);\n  }\n  LFT(){for(int i = 0; i < (MAXN<<1); ++i) st[i] = &pool[i]; root = new Node(2147483647, 1, null, null); null = new Node(0, 0, 0, 0);}\n}T;\nstruct seg\n{\n    int l , r;\n    Node *rt;\n}node[400020 * 4];\nvoid build(int u,int l,int r)\n{\n    node[u].l = l , node[u].r = r;\n    node[u].rt = NULL;\n    if(l == r) {a[l] = u;return;}\n    build(u<<1 , l , (l + r) >> 1);\n    build(u<<1|1 , ((l + r) >> 1) + 1 , r);\n    return;\n}\nvoid upd(int u,int v)\n{\n    while(u){\n        if(!node[u].rt) node[u].rt = T.newNode(v , 1 , null , null);\n        else T.insert(node[u].rt , v);\n        //printf(\"INS %d %d %d\\n\",node[u].l,node[u].r,v);\n        u >>= 1;\n    }\n    return;\n}\nint Query(int u,int l,int r,int v)\n{\n    if(r < l) return 0;\n    if(node[u].l == l && node[u].r == r){\n        //printf(\"Q %d %d %d\\n\",l,r,v);\n        if(!node[u].rt) return 0;\n        return T.Rank(node[u].rt , v+1);\n    }\n    if(r <= node[u<<1].r) return Query(u<<1 , l , r , v);\n    else if(l >= node[u<<1|1].l) return Query(u<<1|1 , l , r , v);\n    else return Query(u<<1 , l , node[u<<1].r , v) + Query(u<<1|1 , node[u<<1|1].l , r , v);\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d\",&n,&m);\n    int x = 0, y = 0, L = 0;\n    build(1 , 1 , n*2 + 6);\n    long long ans = 0;\n    for(int i = 1;i <= n;i++){\n        upd(a[n*2 + 2 - (x*2 - L + n + 1)], n*2 + 2 - (y*2 - L + n + 1));\n        //printf(\"  UPD %d %d\\n\",x*2-L+n+1,y*2-L+n+1);\n        int p;scanf(\"%d\",&p);\n        if(p < m) x++;\n        else if(p > m) y++;\n        L++;\n        int pp = 0;\n        pp = Query(1 , 1 , n*2 + 2 - (x*2 - L + n + 2) , n*2 + 2 -(y*2 - L + n + 1));\n        ans += pp;\n        //printf(\"         AT %d %d\\n\",i,pp);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Median on Segments  General Case Edition .json",
    "editorial_link": "https://codeforces.com//blog/entry/60511",
    "editorial": "Let\u00e2\u0080\u0099s define a function greaterCount() number of subarrays with median\r\ngreater or equal than . In this case, the answer on the problem is\r\ngreaterCount() greaterCount().The subarray has median greater or equal\r\nthan , if and only if , where is the number equal or greater than\r\nelements, and is the number of less than elements.In other words,\r\ninstead of processing you can use the sequence containing or/and . An\r\nelement , if . An element , if . Now, the median of is greater or equal\r\nthan if and only if .Let\u00e2\u0080\u0099s iterate over from left to right. Maintain the\r\ncurrent partial sum . Additionally, in the array let\u00e2\u0080\u0099s maintain the\r\nnumber of partial sum for each its value. It means that before increase\r\nof you should do . So if is the index of the right endpoint of a\r\nsubarray (i.e. ), then number of suitable indices is number of such that\r\n. In other words, find sum of all , where it is exactly number of\r\nindices with partial sum less than .Each time partial sum changes on or\r\n. So the value \"sum of all , where \" is easy to recalculate on each\r\nchange. If you decrease , just subtract the value . If you increase ,\r\nbefore increasing just add .Since indices in can be from to , you can\r\nuse 0-based indices using an array . In this case, initialize as but not\r\nas (it makes to be non-negative on each step).This solution works in .\r\n"
}