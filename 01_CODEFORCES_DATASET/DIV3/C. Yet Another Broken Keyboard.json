{
    "link": "https://codeforces.com//contest/1272/problem/C",
    "problemId": "494355",
    "problem_idx": "C",
    "shortId": "1272C",
    "contest_number": "1272",
    "problem_submissions": {
        "E": [
            66703677,
            66698934,
            66711392,
            66720411,
            66715254,
            66696959,
            66695532,
            66698121,
            66701928,
            66701435,
            66706283,
            66705342,
            66707569,
            66707090,
            66777425,
            66705785,
            66709630,
            66710595,
            66706360,
            66711695
        ],
        "F": [
            66702563,
            66716210,
            66716034,
            66713486,
            66720407,
            66730946,
            66745196,
            66899419,
            66710448,
            69815932
        ],
        "B": [
            66692863,
            66686159,
            66691774,
            66706884,
            66714297,
            66683965,
            66685196,
            66684562,
            66686916,
            66692480,
            66696683,
            66688751,
            66692889,
            66696315,
            66685266,
            66695654,
            66691545,
            66689056,
            66687119,
            66686340
        ],
        "C": [
            66687313,
            66688012,
            66695426,
            66689433,
            66689685,
            66685389,
            66686891,
            66686385,
            66687940,
            66685597,
            66690881,
            66692609,
            66686241,
            66688395,
            66686850,
            66686864,
            66686923,
            66691687,
            66689532,
            66689140
        ],
        "D": [
            66683330,
            66692291,
            66701690,
            66697025,
            66695475,
            66689729,
            66689439,
            66688995,
            66691097,
            66696361,
            66685375,
            66696190,
            66695912,
            66691534,
            66688277,
            66700728,
            66696238,
            66694893,
            66695943,
            66703253
        ],
        "A": [
            66683267,
            66683040,
            66685123,
            66683649,
            66682741,
            66682439,
            66682629,
            66682714,
            66683716,
            66683148,
            66683049,
            66683308,
            66683216,
            66682971,
            66682692,
            66683012,
            66683163,
            66683636,
            66683990,
            66682789
        ]
    },
    "name": "C. Yet Another Broken Keyboard",
    "statement": "Recently, Norge found a string s = s_1 s_2\r\nldots s_n consisting of n lowercase Latin letters. As an exercise to\r\nimprove his typing speed, he decided to type all substrings of the\r\nstring s. Yes, all\r\nfrac{n (n + 1)}{2} of them!A substring of s is a non-empty string x =\r\ns[a\r\nldots b] = s_{a} s_{a + 1}\r\nldots s_{b} (1\r\nleq a\r\nleq b\r\nleq n). For example, \"\" and \"\" are substrings of \"\".Shortly after the\r\nstart of the exercise, Norge realized that his keyboard was broken,\r\nnamely, he could use only k Latin letters c_1, c_2,\r\nldots, c_k out of 26.After that, Norge became interested in how many\r\nsubstrings of the string s he could still type using his broken\r\nkeyboard. Help him to find this number.\r\n",
    "solutions": [
        "#define task \"test\"\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\n\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n\nconst ll LINF = 1E18;\nconst int INF = 1E9;\nconst int MOD = 1E9 + 7;\nconst int N = 2E5 + 5;\n\nint t = 1;\n\nint n, k, F[N][30];\nstring s;\n\nchar a[30];\n\nll res = 0;\n\nbool avail[30];\n\nvoid Input()\n{\n    cin >> n >> k;\n    cin >> s; s = \" \" + s;\n    for (int i = 1; i <= k; i++) cin >> a[i];\n}\n\nvoid Prepare()\n{\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 26; j++) F[i][j] = F[i - 1][j];\n        F[i][s[i] -'a']++;\n    }\n    memset(avail, 0, sizeof(avail));\n    for (int i = 1; i <= k; i++) avail[a[i] - 'a'] = true;\n}\n\nvoid Solve()\n{\n    ll R = 0;\n    for (int i = 1; i <= n; i++) {\n        if (R < i) R = i;\n\n        while (R <= n) {\n            bool ok = 1;\n            for (int j = 0; j < 26; j++) if (F[R][j] - F[i - 1][j] > 0) {\n                if (!avail[j]) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) break;\n            R++;\n        }\n        res += (ll) (R - i);\n      //  cout << i << \" \" << R << endl;\n    }\n\n    cout << res;\n\n}\n\nint main()\n{\n    if (fopen(task \".inp\",\"r\")){\n        freopen(task \".inp\",\"r\",stdin);\n        freopen(task \".out\",\"w\",stdout);\n    }\n    Input();\n    Prepare();\n    while (t--) Solve();\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Yet Another Broken Keyboard.json",
    "editorial_link": "https://codeforces.com//blog/entry/72132",
    "editorial": "Letâs replace all characters of with zeros and ones (zero if the\r\ncharacter is unavailable and one otherwise). Then we have the binary\r\nstring and we have to calculate the number of contiguous segments of\r\nthis string consisting only of ones. It can be done with two pointers\r\napproach.If we are staying at the position and its value is zero, just\r\nskip it. Otherwise, letâs find the leftmost position such that and the\r\n-th value is zero. Then we have to add to the answer the value and set\r\n.Time complexity: .\r\n",
    "hint": []
}