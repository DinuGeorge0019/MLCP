{"link": "https://codeforces.com//contest/1015/problem/F", "problemId": "203552", "problem_idx": "F", "shortId": "1015F", "contest_number": "1015", "problem_submissions": {"F": [41046686, 41089036, 41088828, 41088337, 41096109, 41155137], "E2": [41044021, 41044614, 41045819, 41046151, 41041339, 41120563, 41047819, 41049335, 41046653, 41047315, 41056482, 41049017, 41046489, 41053390, 41052850, 41051286, 41054981, 41057931, 41047714, 41052649, 41063809, 41051282], "E1": [41043653, 41042567, 41045757, 41045539, 41040702, 41045081, 41043696, 41046746, 41047236, 41044065, 41048961, 41046210, 41043883, 41050998, 41051221, 41044932, 41048477, 41047379, 41051531, 41047009], "D": [41031342, 41034646, 41036110, 41039331, 41043349, 41037861, 41039026, 41038448, 41038110, 41038683, 41037715, 41040743, 41035875, 41037945, 41039903, 41039757, 41039527, 41041117, 41039970, 41063782, 41038156], "B": [41028759, 41027947, 41029953, 41029847, 41027873, 41030296, 41030110, 41028724, 41031028, 41029894, 41029543, 41031067, 41030593, 41029154, 41029321, 41029551, 41029148, 41033439, 41031881, 41028034], "C": [41027720, 41029992, 41031722, 41032867, 41029608, 41033310, 41032299, 41030539, 41033426, 41032047, 41032615, 41033736, 41032226, 41030814, 41031207, 41031359, 41030973, 41035988, 41034551, 41029776], "A": [41025375, 41025426, 41026820, 41025657, 41025347, 41026304, 41026166, 41025506, 41029303, 41025595, 41025554, 41027421, 41025393, 41025748, 41025855, 41025912, 41025550, 41026111, 41026923, 41025435]}, "name": "F. Bracket Substring", "statement": "You are given a bracket sequence s (not necessarily a regular one). A\r\nbracket sequence is a string containing only characters \u201d and \u201d.A\r\nregular bracket sequence is a bracket sequence that can be transformed\r\ninto a correct arithmetic expression by inserting characters \u201d and \u201d\r\nbetween the original characters of the sequence. For example, bracket\r\nsequences \"\" and \"\" are regular (the resulting expressions are: \"\" and\r\n\"\"), and \"\", \"\" and \"\" are not.Your problem is to calculate the number\r\nof regular bracket sequences of length 2n containing the given bracket\r\nsequence s as a substring (consecutive sequence of characters) modulo\r\n10^9+7 (1000000007).\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define p_b push_back\n#define pll pair<ll,ll>\n#define endl \"\\n\"\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define ld long double\n\nusing namespace std;\ntypedef long long ll;\nconst ll MAXN = 1123456;\n\ntemplate <typename T>\nT sqr(T x){\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s){\n    cout << s << endl;\n    exit(0);\n}\n\nll bp(ll a,ll n){\n    ll res = 1;\n    while(n){\n        if(n % 2)res *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\nconst ll mod = 1e9 + 7;\n\nll dp[201][201][201];\n\nvoid f(ll& a, ll b){a = (a + b) % mod;}\n\nll z[MAXN];\n\nint main(){\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    ll m = s.size();\n    vector <ll> a(m + 1);\n    dp[0][0][0] = 1;\n    for(int i = 1; i <= m; i++){\n        if(s[i - 1] == ')')a[i] = -1;else a[i] = 1;\n    }\n    z[0] = 1e18;\n    for(ll i = 1, l = 0, r = 0; i < m; i++){\n        if (i <= r)z[i] = min (r - i + 1, z[i - l]);\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]])++z[i];\n\t\tif (i + z[i] - 1 > r)l = i,  r = i + z[i] - 1;\n    }\n    for(int i = 1; i <= 2 * n; i++){\n\n        for(int j = 0; j <= 101; j++)\n        for(int i1 = 0; i1 <= m; i1++){\n\n            for(int j1 = -1; j1 < 2; j1++)if(j1 != 0){\n                ll kol = dp[i - 1][j][i1];\n                if(j1 + j >= 0 && kol){\n                    if(i1 == m)dp[i][j1 + j][m] = (dp[i][j1 + j][m] + kol) % mod;\n                    else if(j1 == a[i1 + 1])dp[i][j1 + j][i1 + 1] = (dp[i][j1 + j][i1 + 1] + kol) % mod;\n                    else{\n                        for(int jj = i1; jj >= 0; jj--){\n                            bool ok = 0;\n                            if(!jj)ok = 1;\n                            else if(jj == 1 && a[1] == j1)ok = 1;\n                            else if(a[jj] == j1 && z[i1 - jj + 1] >= jj - 1)ok = 1;\n                            if(ok){\n                                dp[i][j1 + j][jj] = (dp[i][j1 + j][jj] + kol) % mod;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n    cout << dp[2 * n][0][m] << endl;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "strings"], "dificulty": "2300", "interactive": false}