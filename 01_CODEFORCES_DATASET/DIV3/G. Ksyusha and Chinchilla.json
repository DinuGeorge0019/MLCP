{
    "link": "https://codeforces.com//contest/1833/problem/G",
    "problemId": "1929820",
    "problem_idx": "G",
    "shortId": "1833G",
    "contest_number": "1833",
    "problem_submissions": {
        "F": [
            206599548,
            206499044,
            206510645,
            206497958,
            206917535,
            206498356,
            206512969,
            206501833,
            206507754,
            206504303,
            206775083,
            206513772,
            206514120,
            206515332,
            206518320,
            206514205,
            206521502,
            206515630,
            206524274,
            206520741,
            206520948,
            206526178,
            206521131
        ],
        "G": [
            206512331,
            206521465,
            206506545,
            206477170,
            206519573,
            206523410,
            206530322,
            206518526,
            206777759,
            206531078,
            206532207,
            206527389,
            206532553,
            206535240,
            206530738,
            206539901,
            206510414,
            206533541,
            209018213,
            206536054,
            206538842,
            206866462,
            206539276
        ],
        "E": [
            206494444,
            206500619,
            206508800,
            206912480,
            206752261,
            206508820,
            206500946,
            206513913,
            206499318,
            206515052,
            206776677,
            206501077,
            206501029,
            206508081,
            206504803,
            206505276,
            206514758,
            206507981,
            206532142,
            206514436,
            206505945,
            206510447,
            206508190
        ],
        "D": [
            206478490,
            206489393,
            206482509,
            206516497,
            206493139,
            206494430,
            206493405,
            206772261,
            206483249,
            206490999,
            206496792,
            206494490,
            206495499,
            206492096,
            206495671,
            206562276,
            206493504,
            206494409,
            206497119,
            206489160,
            206496422
        ],
        "C": [
            206468900,
            206472444,
            206487689,
            206481281,
            206470369,
            206469924,
            206472556,
            206474926,
            206470601,
            206467341,
            206478011,
            206475881,
            206470693,
            206472518,
            206472870,
            206562261,
            206473668,
            206473209,
            206471774,
            206472820,
            206477277
        ],
        "B": [
            206461337,
            206465386,
            206481088,
            206469699,
            206465480,
            206464242,
            206462159,
            206470246,
            206468314,
            206462993,
            206468820,
            206467031,
            206466013,
            206465802,
            206464804,
            206466201,
            206465451,
            206463520,
            206466366,
            206465332
        ],
        "A": [
            206458073,
            206459090,
            206464738,
            206461735,
            206459482,
            206458188,
            206458127,
            206458669,
            206459064,
            206459476,
            206460428,
            206459198,
            206458554,
            206458909,
            206458986,
            206459453,
            206458429,
            206458492,
            206458602
        ]
    },
    "name": "G. Ksyusha and Chinchilla",
    "statement": "Ksyusha has a pet chinchilla, a tree on n vertices and huge scissors. A\r\ntree is a connected graph without cycles. During a boring physics lesson\r\nKsyusha thought about how to entertain her pet.Chinchillas like to play\r\nwith . is a tree of 3 vertices. is the removal of some (not yet ) edge\r\nin the tree. Ksyusha has plenty of free time, so she can afford to make\r\nenough so that the tree splits into . In other words, after several\r\n(possibly zero) , each vertex must belong to .Help Ksyusha choose the\r\nedges to be or tell that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::vector g(n, std::vector<std::pair<int, int>>());\n    for (int i = 1; i < n; i++) {\n        int v, u;\n        std::cin >> v >> u;\n        --v, --u;\n        g[v].emplace_back(u, i);\n        g[u].emplace_back(v, i);\n    }\n    if (n % 3) {\n        std::cout << -1 << \"\\n\";\n        return;\n    }\n    std::vector<int> res;\n    std::vector ok(n, std::vector<bool>(2, false));\n    std::vector<int> sz(n);\n    std::vector<bool> exist(n, true);\n    auto calc = [&](auto &&calc, int v, int p) -> void {\n        sz[v] = 1;\n        for (auto [u, id] : g[v]) {\n            if (u == p) continue;\n            calc(calc, u, v);\n            sz[v] += sz[u];\n        }\n    };\n    auto dfs = [&](auto &&dfs, int v, int p) -> void {\n        for (auto [u, id] : g[v]) {\n            if (u == p) continue;\n            if (sz[u] % 3 == 0) {\n                exist[id] = false;\n                res.emplace_back(id);\n                dfs(dfs, u, v);\n            } else {\n                dfs(dfs, u, v);\n            }\n        }\n    };\n    calc(calc, 0, 0);\n    dfs(dfs, 0, 0);\n    int cnt1 = 0, cnt2 = 0;\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        for (auto [u, id] : g[i]) {\n            if (exist[id]) {\n                ++cnt;\n            }\n        }\n        if (cnt == 1) {\n            ++cnt1;\n        } else if (cnt == 2) {\n            ++cnt2;\n        } else {\n            std::cout << -1 << \"\\n\";\n            return;\n        }\n    }\n    if (cnt2 != n / 3) {\n        std::cout << -1 << \"\\n\";\n        return;\n    }\n    std::cout << (int) res.size() << \"\\n\";\n    for (auto x : res) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "dsu",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Ksyusha and Chinchilla.json",
    "editorial_link": "https://codeforces.com//blog/entry/116636",
    "editorial": "Letâs hang the tree by the vertex . This problem can be solved by\r\ndynamic programming. the ability to cut a subtree of if the edges in all\r\nchildren of must be cut off. the ability to cut a subtree of if exactly\r\none edge needs to be saved from to the child. ability to cut a subtree\r\nof if an edge above is cut off. Obviously, the answer will be .\r\nRecalculation in such dynamics is offered to the reader as an\r\nexercise.There is a simpler greedy solution. Letâs call a vertex that is\r\nnot a leaf and whose children are all leaves. Letâs call a vertex that\r\nis not a leaf and that has a child.If there is a vertex with at least\r\nthree children, the desired cut does not exist. If the vertex has\r\nexactly one child, we will cut off all children from its parent except .\r\nIf the vertex has exactly two children, we cut the edge into the parent\r\n.It is easy to understand that in this way the desired cut is restored\r\nuniquely. This problem can be solved by an elegant DFS, but the author\r\nconsiders BFS easier to understand.First, letâs count the number of\r\nchildren and the number of children for each vertex. We will store all\r\nvertices in the queue and process them sequentially. Cutting edges will\r\nchange the number of children and the number of children at some\r\nvertices. It should be handled carefully.This solution works for .\r\n",
    "hint": []
}