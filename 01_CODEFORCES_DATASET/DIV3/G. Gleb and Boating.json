{
    "link": "https://codeforces.com//contest/2091/problem/G",
    "problemId": "3289248",
    "problem_idx": "G",
    "shortId": "2091G",
    "contest_number": "2091",
    "problem_submissions": {
        "G": [
            312443740,
            312440964,
            312449961,
            312463242,
            312461876,
            312468559,
            312443596,
            312511383
        ],
        "F": [
            312388330,
            312412408,
            312430981,
            312418730,
            312432603,
            312362472,
            312401868,
            312388116,
            312384163,
            312385210,
            312393774,
            312407683,
            312403588,
            312409243,
            312397198,
            312421669,
            312449852,
            312416513
        ],
        "E": [
            312364224,
            312379570,
            312394687,
            312386750,
            312378910,
            312384287,
            312360471,
            312357459,
            312346051,
            312367500,
            312375652,
            312366419,
            312377485,
            312369213,
            312377446,
            312364255,
            312346485,
            312374845
        ],
        "D": [
            312353666,
            312365895,
            312355563,
            312369505,
            312366914,
            312413286,
            312349339,
            312363994,
            312361301,
            312362180,
            312358189,
            312363978,
            312355693,
            312364358,
            312351943,
            312340247,
            312363493
        ],
        "C": [
            312346511,
            312354545,
            312356602,
            312361282,
            312358087,
            312401227,
            312341205,
            312349482,
            312355403,
            312348089,
            312347345,
            312347202,
            312348084,
            312349677,
            312348353,
            312345589,
            312336376,
            312348785
        ],
        "B": [
            312338347,
            312349733,
            312341539,
            312347023,
            312339969,
            312398814,
            312336638,
            312337475,
            312341231,
            312340093,
            312340366,
            312337779,
            312341589,
            312345952,
            312339689,
            312336957,
            312335616,
            312341894
        ],
        "A": [
            312335159,
            312336162,
            312340416,
            312341479,
            312335895,
            312395413,
            312335001,
            312335418,
            312337197,
            312336076,
            312336210,
            312335026,
            312334941,
            312337205,
            312335107,
            312334877,
            312334813,
            312335610
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141047",
    "editorial": "Let’s consider a simple solution we will iterate through Gleb’s current\r\nstrength , from to , and check which positions can be reached using that\r\nstrength value. For each fixed , the set of positions can be obtained by\r\nany search method, for example, breadth-first search. Next, let’s assume\r\nthat Gleb has turned around and we will start a search from all reached\r\npositions with strength and in the opposite direction. For one strength\r\nvalue, such a search works in the worst case in , so the overall\r\ncomplexity of the algorithm will be (which, of course, will take too\r\nlong) and will require memory.Now we need to speed up this solution.\r\nFirst, we need to solve the problem for very large values of . It is not\r\ndifficult to prove that if , then for , the answer to the problem will\r\nbe or . Indeed, let’s assume that Gleb with strength has reached the\r\nmaximum possible position on the segment. Next, he turns around, takes\r\none step back (with strength ). Let’s find the position where Gleb will\r\nend up if he turns around and moves to the right with strength until he\r\ncrosses the boundary (including the assumption that he can swim beyond\r\n). Let this position be , where . Then, Gleb would need to take another\r\nsteps to the left with strength before the second turn; in this case, he\r\nwill end up exactly at point with strength . For this maneuver, he will\r\nneed a distance of at most .Thus, for , we can obtain either the answer\r\n(which can be checked by simple division) or the answer (we print it if\r\nthe answer is not possible). It is also easy to see that this statement\r\nremains true when starting from any point from to .Next, we will assume\r\nthat . Let the answer to the problem be . Then, if in the algorithm\r\ndescribed above we stop the iteration upon reaching point for some , the\r\ntotal running time will be . Considering the above, we can assert that\r\n(due to the even number of turns, the answer may not be suitable). Then\r\nthe running time of the algorithm does not exceed We can rewrite this\r\nvalue as follows: Next, we note that the sum of the factors in the\r\nnumerator equals , meaning that the maximum value is achieved when they\r\nare equal (see, for example, Karamata’s inequality). We obtain that:\r\nwhich is already fast enough to pass all tests.In practice, even in the\r\nworst case, the specified algorithm requires even fewer operations and\r\ncomfortably fits within the time limits.\r\n",
    "name": "G. Gleb and Boating",
    "statement": "Programmer Gleb frequently visits the IT Campus \"NEIMARK\" to participate\r\nin programming training sessions.Not only is Gleb a programmer, but he\r\nis also a renowned rower, so he covers part of his journey from home to\r\nthe campus by kayaking along a river. Assume that Gleb starts at point 0\r\nand must reach point s (i.e., travel s meters along a straight line). To\r\nmake the challenge tougher, Gleb has decided not to go outside the\r\nsegment [0, s]. The dimensions of the kayak can be neglected.Gleb is a\r\nstrong programmer! Initially, his power is k. Gleb’s power directly\r\naffects the movement of his kayak. If his current power is x, then with\r\none paddle stroke the kayak moves x meters in the current direction.\r\nGleb can turn around and continue moving in the opposite direction, but\r\nsuch a maneuver is quite challenging, and after each turn, his power\r\ndecreases by 1. The power can never become 0 if his current power is 1,\r\nthen even after turning it remains 1. Moreover, Gleb cannot make two\r\nturns in a row after each turn, he must move at least once before making\r\nanother turn. Similarly, Gleb cannot make a turn immediately after the\r\nstart he must first perform a paddle stroke.Gleb wants to reach point s\r\nfrom point 0 without leaving the segment [0, s] and while preserving as\r\nmuch power as possible. Help him given the value s and his initial power\r\nk, determine the maximum possible power he can have upon reaching point\r\ns.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "dp",
        "graphs",
        "greedy",
        "math",
        "number theory",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Gleb and Boating.json",
    "hint": []
}