{
    "link": "https://codeforces.com//contest/1624/problem/A",
    "problemId": "1256437",
    "problem_idx": "A",
    "shortId": "1624A",
    "contest_number": "1624",
    "problem_submissions": {
        "G": [
            142264977,
            142276263,
            142255328,
            142255380,
            142278979,
            142222438,
            142247481,
            142272907,
            142266089,
            142251678,
            142253083,
            142252160,
            142248179,
            142250137,
            142248523,
            142250039,
            142416148,
            142259210
        ],
        "F": [
            142255179,
            142272384,
            142268450,
            142243695,
            142285199,
            142258439,
            142236940,
            142264135,
            142393598,
            142331291,
            142248865,
            142296070,
            142276188,
            142284965,
            142276430,
            142260372
        ],
        "E": [
            142241464,
            142238534,
            142272316,
            142277777,
            142260025,
            142286074,
            142269495,
            142256319,
            142287785,
            142271217,
            142263215,
            142270151,
            142270566,
            142278137,
            142274750,
            142273040,
            142294098,
            142253958,
            142282423
        ],
        "D": [
            142225549,
            142220300,
            142226787,
            142230709,
            142223377,
            142265701,
            142282535,
            142273740,
            142234006,
            142223224,
            142236057,
            142230240,
            142221633,
            142230396,
            142243861,
            142238174,
            142223929,
            142233332,
            142233395,
            142227832
        ],
        "C": [
            142213147,
            142208364,
            142214903,
            142219856,
            142212618,
            142318538,
            142204231,
            142234937,
            142218849,
            142237305,
            142214526,
            142460843,
            142215423,
            142217168,
            142221355,
            142216799,
            142211503,
            142211985,
            142216819,
            142218405,
            142219857,
            142213500
        ],
        "B": [
            142197546,
            142199713,
            142206530,
            142215517,
            142199960,
            142202251,
            142206682,
            142220881,
            142202886,
            142198089,
            142210906,
            142196708,
            142210091,
            142205820,
            142205637,
            142211178,
            142207927,
            142211494,
            142209546
        ],
        "A": [
            142188870,
            142188452,
            142198531,
            142195180,
            142189107,
            142194205,
            142188426,
            142189618,
            142189485,
            142189892,
            142201064,
            142189063,
            142189404,
            142192459,
            142193156,
            142190543,
            142204194,
            142190164
        ]
    },
    "name": "A. Plus One on the Subset",
    "statement": "Polycarp got an array of integers a[1\r\ndots n] as a gift. Now he wants to perform a certain number of\r\noperations (possibly zero) so that all elements of the array become the\r\nsame (that is, to become a_1=a_2=\r\ndots=a_n). In one operation, he can take some indices in the array and\r\nincrease the elements of the array at those indices by 1.For example,\r\nlet a=[4,2,1,6,2]. He can perform the following operation: select\r\nindices 1, 2, and 4 and increase elements of the array in those indices\r\nby 1. As a result, in one operation, he can get a new state of the array\r\na=[5,3,1,7,2].What is the minimum number of operations it can take so\r\nthat all elements of the array become equal to each other (that is, to\r\nbecome a_1=a_2=\r\ndots=a_n)?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << ' ', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 5e5 + 10;\nconst int mod = 998244353;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (auto& i : a) {\n            cin >> i;\n        }\n        cout << *max_element(a.begin(), a.end()) - *min_element(a.begin(), a.end()) << '\\n';\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Plus One on the Subset.json",
    "editorial_link": "https://codeforces.com//blog/entry/98942",
    "editorial": "Letâs sort the numbers in ascending order. It becomes immediately clear\r\nthat it is not profitable for us to increase the numbers that are equal\r\nto the last number (the maximum of the array). It turns out that every\r\ntime you need to take such a subset of the array, in which all the\r\nnumbers, except the maximums. And once for each operation, the numbers\r\nin the subset are increased by one, then how many times can the\r\noperation be performed on the array? Accordingly .\r\n",
    "hint": []
}