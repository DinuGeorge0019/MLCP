{
    "link": "https://codeforces.com//contest/1183/problem/F",
    "problemId": "363546",
    "problem_idx": "F",
    "shortId": "1183F",
    "contest_number": "1183",
    "problem_submissions": {
        "F": [
            56110414,
            56117769,
            56118798,
            66995010,
            56101090,
            56148730,
            138937022,
            56112000
        ],
        "E": [
            56097887,
            56113357,
            56105226,
            56104643,
            56101888,
            56093414,
            56111233,
            56103293,
            56103078,
            56104487,
            56109659,
            56103780,
            56109510,
            56105711,
            56106565
        ],
        "H": [
            56097697,
            56113570,
            56105740,
            66667587,
            56101720,
            56109616,
            56111456,
            56108240,
            56103716,
            56105330,
            56106283,
            56109916,
            56106467
        ],
        "G": [
            56092005,
            56104084,
            56123883,
            56112098,
            56110719,
            56101673,
            56117506,
            56115328,
            59651445,
            56098320,
            138935815
        ],
        "D": [
            56088183,
            56091373,
            56093338,
            56090767,
            56087401,
            56085787,
            56095559,
            56092469,
            56089592,
            56093522,
            56092856,
            56094699,
            56091582,
            56093930,
            56090315,
            56096981,
            56094561
        ],
        "C": [
            56084972,
            56088064,
            56089777,
            56097980,
            56081517,
            56107044,
            56091000,
            56085493,
            56085540,
            56091330,
            56090250,
            56088370,
            56086037,
            56089714,
            56086123
        ],
        "B": [
            56081558,
            56084832,
            56083510,
            59085942,
            56083305,
            56103674,
            56097880,
            56086061,
            56083097,
            56081660,
            56086915,
            56086136,
            56085025,
            56087421,
            56081700,
            56084942,
            56082678
        ],
        "A": [
            56080149,
            56079717,
            56079676,
            57264074,
            56080781,
            56088646,
            56082120,
            56081323,
            56079728,
            56079791,
            56082274,
            56082965,
            56079889,
            56079932,
            56079796
        ]
    },
    "name": "F. Topforces Strikes Back",
    "statement": "One important contest will take place on the most famous programming\r\nplatform (Topforces) very soon!The authors have a pool of n problems and\r\nshould choose of them into this contest. The prettiness of the i-th\r\nproblem is a_i. The authors have to compose the most pretty contest (in\r\nother words, the cumulative prettinesses of chosen problems should be\r\n).But there is one important thing in the contest preparation: because\r\nof some superstitions of authors, the prettinesses of problems cannot\r\ndivide each other. In other words, if the prettinesses of chosen\r\nproblems are x, y, z, then x should be divisible by neither y, nor z, y\r\nshould be divisible by neither x, nor z and z should be divisible by\r\nneither x, nor y. If the prettinesses of chosen problems are x and y\r\nthen neither x should be divisible by y nor y should be divisible by x.\r\nAny contest composed from one problem is considered good.Your task is to\r\nfind out the maximum possible total prettiness of the contest composed\r\nof problems from the given pool.You have to answer q independent\r\nqueries.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nll t,te,n,N,has,a[202020],b[202020],i,ta,X[99];\nvoid cek(ll aa,ll bb,ll cc)\n{\n\tif(cc==0)return ;\n\thas=max(has,aa);\n\tif(cc==1)return ;\n\tX[cc]=a[bb];\n\tll ii,jj;\n\tfor(ii=bb-1;ii>=1;ii--)\n\t{\n\t\tll gagal=0;\n\t\tfor(jj=cc;jj<=3;jj++)\n\t\t{\n\t\t//\tcout<<ii<<\" \"<<jj<<\" \"<<X[jj]<<\" \"<<a[ii]<<\"\\n\";\n\t\t\tif(X[jj]%a[ii]==0)\n\t\t\t\tgagal=1;\n\t\t}\n\t\tif(!gagal)\n\t\t{\n\t\t\tcek(aa+a[ii],ii,cc-1);\n\t\t\treturn ;\n\t\t}\n\t}\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tte++;\n\t\tcin>>n;\n\t\tN=0;\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>ta;\n\t\t\tif(b[ta]!=te)\n\t\t\t\ta[++N]=ta;\n\t\t\tb[ta]=te;\n\t\t}\n\t\tsort(a+1,a+1+N);\n\t\thas=0;\n\t\tcek(a[N],N,3);\n\t\tif(N>1)\n\t\t\tcek(a[N-1],N-1,3);\n\t\tcout<<has<<\"\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Topforces Strikes Back.json",
    "editorial_link": "https://codeforces.com//blog/entry/68003",
    "editorial": "I know about some solutions that are trying to iterate over almost all\r\npossible triples, but I have a better and more interesting one.\r\nPossibly, it was already mentioned in comments, but I need to explain\r\nit.Let\u00e2\u0080\u0099s solve the problem greedily. Let\u00e2\u0080\u0099s sort the initial array. The\r\nfirst number we would like to choose is the maximum element. Then we\r\nneed to pop out some maximum elements that are divisors of the maximum.\r\nThen there are two cases: the array becomes empty, or we have some\r\nmaximum number that does not divide the chosen number. Let\u00e2\u0080\u0099s take it and\r\nrepeat the same procedure again, but now we have to find the number that\r\ndoes not divide neither the first taken number nor the second taken\r\nnumber.So we have at most three numbers after this procedure. Let\u00e2\u0080\u0099s\r\nupdate the answer with their sum. This solution is almost correct.\r\nAlmost! What have we forgotten? Let\u00e2\u0080\u0099s imagine that the maximum element\r\nis divisible by , and and there are three following numbers in the\r\narray: maximum divided by , by and by . Then their sum is greater than\r\nthe maximum (and may be greater than the answer we have!) because . So\r\nif these conditions are satisfied, let\u00e2\u0080\u0099s update the answer with the sum\r\nof these three numbers.It can be shown that this is the only possible\r\ntriple that can break our solution. The triple does not match because\r\nthe maximum divided by divides the maximum divided by . The triple is\r\nbad for the same reason. And the triple has sum less than the maximum\r\nelement.\r\n"
}