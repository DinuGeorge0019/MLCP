{
    "link": "https://codeforces.com//contest/1015/problem/E2",
    "problemId": "203551",
    "problem_idx": "E2",
    "shortId": "1015E2",
    "contest_number": "1015",
    "problem_submissions": {
        "F": [
            41046686,
            41089036,
            41088828,
            41088337,
            41096109,
            41155137
        ],
        "E2": [
            41044021,
            41044614,
            41045819,
            41046151,
            41041339,
            41120563,
            41047819,
            41049335,
            41046653,
            41047315,
            41056482,
            41049017,
            41046489,
            41053390,
            41052850,
            41051286,
            41054981,
            41057931,
            41047714,
            41052649,
            41063809,
            41051282
        ],
        "E1": [
            41043653,
            41042567,
            41045757,
            41045539,
            41040702,
            41045081,
            41043696,
            41046746,
            41047236,
            41044065,
            41048961,
            41046210,
            41043883,
            41050998,
            41051221,
            41044932,
            41048477,
            41047379,
            41051531,
            41047009
        ],
        "D": [
            41031342,
            41034646,
            41036110,
            41039331,
            41043349,
            41037861,
            41039026,
            41038448,
            41038110,
            41038683,
            41037715,
            41040743,
            41035875,
            41037945,
            41039903,
            41039757,
            41039527,
            41041117,
            41039970,
            41063782,
            41038156
        ],
        "B": [
            41028759,
            41027947,
            41029953,
            41029847,
            41027873,
            41030296,
            41030110,
            41028724,
            41031028,
            41029894,
            41029543,
            41031067,
            41030593,
            41029154,
            41029321,
            41029551,
            41029148,
            41033439,
            41031881,
            41028034
        ],
        "C": [
            41027720,
            41029992,
            41031722,
            41032867,
            41029608,
            41033310,
            41032299,
            41030539,
            41033426,
            41032047,
            41032615,
            41033736,
            41032226,
            41030814,
            41031207,
            41031359,
            41030973,
            41035988,
            41034551,
            41029776
        ],
        "A": [
            41025375,
            41025426,
            41026820,
            41025657,
            41025347,
            41026304,
            41026166,
            41025506,
            41029303,
            41025595,
            41025554,
            41027421,
            41025393,
            41025748,
            41025855,
            41025912,
            41025550,
            41026111,
            41026923,
            41025435
        ]
    },
    "name": "E2. Stars Drawing  Hard Edition ",
    "statement": "A is a figure of the following type: an asterisk character \u201d in the\r\ncenter of the figure and four rays (to the left, right, top, bottom) of\r\nthe same positive length. The size of a is the length of its rays. The\r\nsize of a star must be a positive number (i.e. rays of length 0 are not\r\nallowed).Let\u2019s consider empty cells are denoted by \u201d, then the following\r\nfigures are : You are given a rectangular grid of size n\r\ntimes m consisting only of asterisks \u201d and periods (dots) \u201d. Rows are\r\nnumbered from 1 to n, columns are numbered from 1 to m. Your task is to\r\ndraw this grid using number of or find out that it is impossible. can\r\nintersect, overlap or even coincide with each other. The number of in\r\nthe output can\u2019t exceed n\r\ncdot m. Each star should be completely inside the grid. You can use\r\nstars of same and arbitrary sizes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define p_b push_back\n#define endl \"\\n\"\n#define m_p make_pair\n#define fi first\n#define se second\n#define pll pair <ll,ll>\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\ntypedef long long ll;\n\nll binpow(ll a,ll n)\n{\n    ll res = 1;\n    while(n)\n    {\n        if(n % 2)res *= a;\n        a *= a;\n        n /= 2;\n    }\n    return res;\n}\n\ntemplate <typename T>\nT sqr(T x)\n{\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s)\n{\n    cout << s << endl;\n    exit(0);\n}\n\nll log(ll a,ll b){\n    ll res = 0;\n    while(a){\n        a /= b;\n        res++;\n    }\n    return res;\n}\n\nconst ll MAXN = 1123456;\n\nint n, m;\nll pref[1001][1001], prefu[1001][1001];\nchar a[1001][1001];\n\nll z[1003][1003], zu[1003][1003];\nll b[1003][1003];\n\nvector<pair<pll,ll> > ans;\n\nint main() {\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"1.in\",\"r\",stdin);\n    //freopen(\"1.out\",\"w\",stdout);\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i){\n        for (int j = 1; j <= m; ++j){\n            cin >> a[i][j];\n            pref[i][j] = pref[i][j - 1] + (a[i][j] == '*');\n            prefu[i][j] = prefu[i - 1][j] + (a[i][j] == '*');\n        }\n    }\n\n    for (int i = 1; i <= n; ++i){\n        for (int j = 1; j <= m; ++j){\n            if (a[i][j] == '*'){\n                ll l = 0, r = min(m - j, min(i - 1, min(n - i, j - 1)));\n                ll p = r;\n\n\n//                if (i == 3 && j == 5) cout << pref[i][j + r] << \" \" <<  pref[i][j - r - 1] << \"+\" << endl;\n//                if (i == 3 && j == 5) cout << prefu[i + r][j] << \" \" <<  prefu[i - r - 1][j] << \"+\" << endl;\n\n                while (l + 1 < r){\n                    ll c = (l + r) / 2;\n                    if ((prefu[i + c][j] - prefu[i - c - 1][j] == (i + c) - (i - c) + 1)\n                     && (pref[i][j + c] - pref[i][j - c -1] == (i + c) - (i - c) + 1 )) l = c; else r = c - 1;\n                }\n                ll c = l + 1;\n                while (l != p && (prefu[i + c][j] - prefu[i - c - 1][j] == (i + c) - (i - c) + 1)\n                     && (pref[i][j + c] - pref[i][j - c -1] == (i + c) - (i - c) + 1 )) {\n                    l = c;\n                    c = l + 1;\n                     }\n//                if (i == 3 && j == 5) {\n//                    cout << l << \"___\" << endl;\n//                }\n\n                if (l != 0) {\n                    ans.p_b({{i, j}, l});\n                    zu[i - l][j] += 1;\n                    zu[i + l + 1][j] += -1;\n                    z[i][j - l] += 1;\n                    z[i][j + l + 1] += -1;\n                }\n            }\n        }\n    }\n\n\n    for (int i = 1; i <= n; i++) {\n        ll o = 0;\n        for (int j = 1; j <= m; j++) {\n            o += z[i][j];\n            b[i][j] += o;\n        }\n    }\n\n\n    for (int j = 1; j <= m; j++) {\n        ll o = 0;\n        for (int i = 1; i <= n; i++) {\n            o += zu[i][j];\n            b[i][j] += o;\n        }\n    }\n\n//    for (int i = 1; i <= n; i++) {\n//        for (int j = 1; j <= m; j++) cout << b[i][j] << \" \";\n//        cout << endl;\n//    }\n\n\n\n    for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++) {\n        if (a[i][j] == '*' && b[i][j] != 0) continue;\n        if (a[i][j] != '*' && b[i][j] == 0) continue;\n        cout << -1;\n        return 0;\n    }\n\n\n    cout << ans.size() << endl;\n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i].fi.fi << \" \" << ans[i].fi.se << \" \" << ans[i].se << endl;\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E2. Stars Drawing  Hard Edition .json",
    "editorial_link": "https://codeforces.com/blog/entry/60949",
    "editorial": "I am sorry that some solutions pass tests in this problem also. I was\r\nsupposed to increase constraints or decrease time limit.The general idea\r\nof this problem is the same as in the previous problem. But now we\r\nshould do all what we were doing earlier faster. The solution is divided\r\nby two parts.The first part. Let\u00e2\u0080\u0099s calculate four matrices of size , ,\r\nand . will denote the distance to the nearest dot character to the top\r\nfrom the current position. The same, will denote the distance to the\r\nnearest dot character to the bottom from the current position, to the\r\nleft and to the right. We can calculate all these matrices in using easy\r\ndynamic programming. If we will iterate over all possible from to and\r\nfrom to , we can easy see the next: if the current character is dot,\r\nthen . Otherwise if then , and if then . Rest two matrices can be\r\ncalculated the as well as these two matrices but we should iterate over\r\nall from to and from to . So, this part of the solution works in .After\r\ncalculating all these matrices the maximum possible length of rays of\r\nthe with center in position is .The second part is to draw all in .\r\nLet\u00e2\u0080\u0099s calculate another two matrices of size and . Let\u00e2\u0080\u0099s iterate over\r\nall in our answer. Let the center of the current is and its size is .\r\nLet\u00e2\u0080\u0099s increase by one and decrease by one (if ). The same with the\r\nmatrix . Increase and decrease (if ). Then let\u00e2\u0080\u0099s iterate over all\r\npossible from to and from to . If then set and if set .How to know that\r\nthe character at the position is asterisk character or dot character? If\r\neither or greater than zero, then the character at the position in our\r\nmatrix will be the asterisk character. Otherwise it is the dot\r\ncharacter. This part works also in .Time complexity of the solution: .\r\n"
}