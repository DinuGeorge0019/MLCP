{
    "link": "https://codeforces.com//contest/1843/problem/F2",
    "problemId": "1972497",
    "problem_idx": "F2",
    "shortId": "1843F2",
    "contest_number": "1843",
    "problem_submissions": {
        "A": [
            210513115,
            210358669,
            210356867,
            210356606,
            210356554,
            210357901,
            210357194,
            210356864,
            210358095,
            210357837,
            210357098,
            210356516,
            210357328,
            210356501,
            210359161,
            210356847,
            210356427,
            210357415,
            210358119,
            210357120,
            210364703
        ],
        "F2": [
            210451991,
            210457207,
            210618819,
            210495074,
            210494100,
            210540752,
            210540669
        ],
        "F1": [
            210414403,
            210417478,
            210396846,
            210409917,
            210412496,
            210409842,
            210422089,
            210412238,
            210413002,
            210417779,
            210416655,
            210416375,
            210514291,
            210424999,
            210427270,
            210422907,
            210427091,
            210425631,
            210535488,
            210532084,
            210419095,
            210422275,
            210416513
        ],
        "E": [
            210391764,
            210391814,
            210384445,
            210387069,
            210389387,
            210395623,
            210390859,
            210397426,
            210401897,
            210395689,
            210473862,
            210401991,
            210402273,
            210403725,
            210394172,
            210401396,
            210403436,
            210400251,
            210398852,
            210406208,
            210398263
        ],
        "D": [
            210377103,
            210378604,
            210375920,
            210374828,
            210376525,
            210379717,
            210379591,
            210382067,
            210379942,
            210382515,
            210378874,
            210376209,
            210374876,
            210386844,
            210381700,
            210376444,
            210371551,
            210381744,
            210386605,
            210381316
        ],
        "C": [
            210369061,
            210367738,
            210368361,
            210366823,
            210368080,
            210359312,
            210366442,
            210374049,
            210371348,
            210364184,
            210365780,
            210367512,
            210366187,
            210360428,
            210370272,
            210365171,
            210363817,
            210370422,
            210368258,
            210373372
        ],
        "B": [
            210363239,
            210368717,
            210361290,
            210360953,
            210362948,
            210369749,
            210362940,
            210364525,
            210363196,
            210375176,
            210362328,
            210363841,
            210361045,
            210364327,
            210364107,
            210360838,
            210360957,
            210367115,
            210363394,
            210370393
        ]
    },
    "name": "F2. Omsk Metro  hard version ",
    "statement": "As is known, Omsk is the capital of Berland. Like any capital, Omsk has\r\na well-developed metro system. The Omsk metro consists of a certain\r\nnumber of stations connected by tunnels, and between any two stations\r\nthere is exactly one path that passes through each of the tunnels no\r\nmore than once. In other words, the metro is a tree.To develop the metro\r\nand attract residents, the following system is used in Omsk. Each\r\nstation has its own weight x\r\nin\r\n{-1, 1\r\n}. If the station has a weight of -1, then when the station is visited\r\nby an Omsk resident, a fee of 1 burle is charged. If the weight of the\r\nstation is 1, then the Omsk resident is rewarded with 1 burle.Omsk Metro\r\ncurrently has only one station with number 1 and weight x = 1. Every\r\nday, one of the following events occurs: You are a friend of Alex, so\r\nyour task is to answer Alex\u2019s questions.\r\ndaggerSubsegment continuous sequence of elements.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m,q;\nint cnt;\nvector<int >G[N];\nvector<int >V[N];\nint tot;\nint qx[N],qy[N],qz[N];\nint dmx[N],dmn[N];\nint emx[N],emn[N];\nint val[N];\nint sum[N];\nint root;\nint siz[N];\nint mxsiz[N];\nbool vis[N];\nbool vis2[N];\nbool ans[N];\nint find_siz(int u)\n{\n\tint res=1;\tvis[u]=true;\n\tfor(auto v:G[u])\n\t{\n\t\tif(vis[v])\tcontinue;\n\t\tres+=find_siz(v);\n\t}\n\tvis[u]=false;\n\treturn res;\n}\nvoid find_root(int u,int allsiz)\n{\n\tsiz[u]=1;\tmxsiz[u]=0;\tvis[u]=true;\n\tfor(auto v:G[u])\n\t{\n\t\tif(vis[v])\tcontinue;\n\t\tfind_root(v,allsiz);\n\t\tsiz[u]+=siz[v];\n\t\tmxsiz[u]=max(mxsiz[u],siz[v]);\n\t}\n\tmxsiz[u]=max(mxsiz[u],allsiz-siz[u]);\n\tif(!root||mxsiz[root]>mxsiz[u])\troot=u;\n\tvis[u]=false;\n}\nint tim[N];\nint col[N];\nint mx[N],mn[N];\nvoid dfs1(int u,int COL)\n{\n\tvis[u]=true;\n\tif(root==COL)\tCOL=u;\n\ttim[u]=root;\tcol[u]=COL;\n\tfor(auto v:G[u])\n\t{\n\t\tif(vis[v])\tcontinue;\n\t\t\n\t\tsum[v]=sum[u]+val[v];\n\t\t\n\t\tmn[v]=min(mn[u],sum[v]);\n\t\tmx[v]=max(mx[u],sum[v]);\n\t\t\n\t\tdmn[v]=min(dmn[u],sum[v]);\n\t\tdmx[v]=max(dmx[u],sum[v]);\n\t\t\n\t\temn[v]=min(emn[u],sum[v]-dmx[v]);\n\t\temx[v]=max(emx[u],sum[v]-dmn[v]);\n\t\t\n\t\tdfs1(v,COL);\n\t}\n\tvis[u]=false;\n}\n\nvoid dfs2(int u)\n{\n\tvis[u]=true;\n\t\n\tfor(auto v:V[u])\n\t{\n\t\tint x=u;\tint y=qx[v]^qy[v]^x;\n\t\tif(tim[y]!=tim[x])\tcontinue;\n\t\tif(col[y]==col[x])\tcontinue;\n\t\tif(emn[x]<=qz[v]&&qz[v]<=emx[x])\tans[v]=true;\n\t\tif(emn[y]<=qz[v]&&qz[v]<=emx[y])\tans[v]=true;\n\t\tif(mn[x]+mn[y]-val[root]<=qz[v]&&qz[v]<=mx[x]+mx[y]-val[root])\tans[v]=true;\n\t}\n\t\n\tfor(auto v:G[u])\n\t{\n\t\tif(vis[v])\tcontinue;\n\t\t\n\t\tdfs2(v);\n\t}\n\t\n\tvis[u]=false;\n}\nvoid solve(int u)\n{\n\troot=0;\n\tint allsiz=find_siz(u);\n\tfind_root(u,allsiz);\n\tsum[root]=val[root];\n\tmn[root]=mx[root]=val[root];\n\tdmn[root]=min(0,val[root]);\tdmx[root]=max(0,val[root]);\n\temn[root]=min(0,val[root]);\temx[root]=max(0,val[root]);\n\t\n\tdfs1(root,root);\n\tdfs2(root);\n\t\n\tvis[root]=true;\n\t\n\tfor(auto v:G[root])\n\t{\n\t\tif(vis[v])\tcontinue;\n\t\tsolve(v);\n\t}\n}\nvoid solve()\n{\n\tn=read();\tcnt=1;\ttot=0; val[1]=1;\n\tfor(int i=1;i<=n;++i)\tans[i]=false;\n\tfor(int i=1;i<=n;++i)\tG[i].clear();\n\tfor(int i=1;i<=n;++i)\tV[i].clear();\n\tfor(int i=1;i<=n;++i)\tvis[i]=false;\n\tfor(int i=1;i<=n;++i)\ttim[i]=col[i]=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tchar opt;\n\t\tcin>>opt;\n\t\tif(opt=='+')\n\t\t{\n\t\t\tint x=read();\tint y=++cnt;\tint z=read();\n\t\t\tval[y]=z;\n\t\t\tG[x].push_back(y);\n\t\t\tG[y].push_back(x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++tot;\n\t\t\tqx[tot]=read();\n\t\t\tqy[tot]=read();\n\t\t\tqz[tot]=read();\n\t\t\tif(qx[tot]==qy[tot])\n\t\t\t{\n\t\t\t\tif(!qz[tot])\tans[tot]=true;\n\t\t\t\tif(val[qx[tot]]==qz[tot])\tans[tot]=true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tV[qx[tot]].push_back(tot);\n\t\t\t\tV[qy[tot]].push_back(tot);\n\t\t\t}\n\t\t}\n\t}\n\tsolve(1);\n\tfor(int i=1;i<=tot;++i)\tYES(ans[i]);\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F2. Omsk Metro  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/117468",
    "editorial": "Similarly to the problem F1, we need to be able to find a subsegment\r\nwith maximum and minimum sum, but on an arbitrary path in the tree. To\r\ndo this, we will use the technique of binary lifts. For each lift, we\r\nwill store the maximum/minimum sum on the prefix and suffix, the sum of\r\nthe subsegment and the maximum sum on the subsegment, as in the problem\r\nabout the maximum sum on a subsegment of an array. Then, such values are\r\neasily can be recalculated by analogy with the recalculation from the\r\nproblem F1. It is also worth noting that such binary lifts can also be\r\nconstructed online, but this was not required in the problem.Then, all\r\nthat remains is to go up from the ends of the path to their LCA, and\r\nthen combine the answers of the vertical paths into the answer for the\r\nwhole path.Total complexity: .\r\n"
}