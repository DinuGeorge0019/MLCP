{"link": "https://codeforces.com//contest/1618/problem/F", "problemId": "1227955", "problem_idx": "F", "shortId": "1618F", "contest_number": "1618", "problem_submissions": {"G": [139298777, 139297222, 147150291, 139364685, 139409455, 139648321, 139647934], "F": [139286789, 139282379, 139275492, 139270703, 139264773, 139269869, 139294667, 139290022, 139289512, 139289145, 139278629, 139289873, 139296435, 139290218, 139296340, 139291619, 139306934, 139294280], "E": [139268981, 139269746, 139265192, 139288008, 139286534, 139292817, 139289487, 139275540, 139264697, 139274832, 139271561, 139276852, 139289947, 139276892, 139262566, 139266584, 139281022, 139278645, 139265520, 139264637], "D": [139243472, 139258171, 139239440, 139248181, 139244770, 139256877, 139242852, 139240922, 139263049, 139256358, 139258140, 139242686, 139254763, 139250478, 139246269, 139248291, 139261914, 139245393, 139247542], "C": [139236892, 139248164, 139234207, 139233239, 139237269, 139236931, 139234400, 139234756, 139241546, 139242932, 139243062, 139234781, 139244605, 139237946, 139235290, 139240735, 139234614, 139239569, 139238791], "B": [139230188, 139242690, 139229799, 139237462, 139230545, 139229999, 139230110, 139230462, 139231463, 139238436, 139232362, 139229957, 139236386, 139231275, 139228222, 139232735, 139228200, 139236174, 139233281], "A": [139224679, 139233161, 139223562, 139225900, 139224918, 139224044, 139223463, 139224332, 139224219, 139225245, 139226896, 139224223, 139228880, 139226421, 139224424, 139224261, 139224339, 139225398, 139227257]}, "name": "F. Reverse", "statement": "You are given two positive integers x and y. You can perform the\r\nfollowing operation with x: write it in its binary form without leading\r\nzeros, add 0 or 1 to the right of it, reverse the binary form and turn\r\nit into a decimal number which is assigned as the new value of x.For\r\nexample: 34 can be turned into 81 via one operation: the binary form of\r\n34 is 100010, if you add 1, reverse it and remove leading zeros, you\r\nwill get 1010001, which is the binary form of 81. 34 can be turned into\r\n17 via one operation: the binary form of 34 is 100010, if you add 0,\r\nreverse it and remove leading zeros, you will get 10001, which is the\r\nbinary form of 17. 81 can be turned into 69 via one operation: the\r\nbinary form of 81 is 1010001, if you add 0, reverse it and remove\r\nleading zeros, you will get 1000101, which is the binary form of 69. 34\r\ncan be turned into 69 via two operations: first you turn 34 into 81 and\r\nthen 81 into 69. Your task is to find out whether x can be turned into y\r\nafter a certain number of operations (possibly zero).\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,h,t) for (int i=h;i<=t;i++)\n#define dep(i,t,h) for (int i=t;i>=h;i--)\n#define ll long long\nconst int N=3e5;\nint a[N],b[N];\nll m;\nbool tt=0; \nll gcd(ll x,ll y)\n{\n\tif (!y) return x;\n\treturn gcd(y,x%y);\n}\nmap<ll,int> M;\nvoid dfs(ll n)\n{\n\tll n2=n;\n\tif (M[n]) return;\n\tM[n]=1;\n\tif (n==m) tt=1;\n\tif (n>1e18) return;\n\tint ww=0;\n\trep(i,1,61)\n\t{ \n\t  a[i]=n%2,n/=2;\n\t  if (n==0)\n\t  { \n\t    ww=i;\n\t    break;\n\t  }\n    }\n    a[0]=1;\n    reverse(a,a+ww+1);\n    ll ans=0;\n    rep(i,0,ww) ans+=(1ll<<i)*a[i];\n    dfs(ans);\n    n=n2;\n    {\n\t    rep(i,1,61)\n\t\t{ \n\t\t  a[i]=n%2,n/=2;\n\t\t  if (n==0)\n\t\t  { \n\t\t    ww=i;\n\t\t    break;\n\t\t  }\n\t    }\n\t    a[0]=0;\n\t    reverse(a,a+ww+1);\n        ll ans=0;\n        rep(i,0,ww) ans+=(1ll<<i)*a[i];\n\t    dfs(ans);\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint T;\n\t//cin>>T;\n\tT=1;\n\twhile (T--)\n\t{\n\t\tM.clear();\n\t\tll n;\n\t\tcin>>n>>m;\n\t\ttt=0; dfs(n);\n\t\tif (tt) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t/*\tif (n==m)\n\t\t{\n\t\t\tcout<<\"YES\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (n%2==0) n/=2;\n\t\tif (n>m||m%2==0)\n\t\t{\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ww=0,ww2=0;\n\t\trep(i,1,60)\n\t\t{ \n\t\t  a[i]=n%2,n/=2;\n\t\t  if (n==0)\n\t\t  { \n\t\t    ww=i;\n\t\t    break;\n\t\t  }\n\t    }\n\t\trep(i,1,60)\n\t\t{ \n\t\t  b[i]=m%2,m/=2;\n\t\t  if (m==0)\n\t\t  { \n\t\t    ww2=i;\n\t\t    break;\n\t\t  }\n\t    }\n\t    int ggg=0;\n\t    rep(i,1,ww2-ww+1)\n\t    {\n\t      bool tt=0;\n\t      rep(j,i,i+ww-1)\n\t        if (b[j]!=a[j-i+1]) tt=1;\n\t      if (!tt) ggg=1;\n\t      tt=0;\n\t      rep(j,i,i+ww-1)\n\t        if (b[j]!=a[ww-(j-i+1)+1]) tt=1;\n\t      if (!tt) ggg=1;\n\t    }\n        if (ggg) cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl; */\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "dfs and similar", "implementation", "math", "strings"], "dificulty": "2000", "interactive": false}