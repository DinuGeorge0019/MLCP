{
    "link": "https://codeforces.com//contest/1343/problem/D",
    "problemId": "599890",
    "problem_idx": "D",
    "shortId": "1343D",
    "contest_number": "1343",
    "problem_submissions": {
        "E": [
            77544731,
            77547078,
            77818546,
            77553455,
            77526508,
            77551799,
            77553477,
            77557131,
            77551163,
            77562420,
            77564988,
            77565009,
            77544133,
            77577002
        ],
        "D": [
            77525246,
            77528102,
            77748327,
            77524381,
            77567781,
            77531413,
            77529630,
            77539927,
            77535846,
            77538289,
            77534294,
            77537349,
            77562840,
            238605180,
            77507320,
            77510486,
            77513527,
            77513404
        ],
        "C": [
            77490036,
            77493815,
            77742798,
            77501239,
            77495338,
            77513080,
            77498834,
            77511866,
            77514187,
            77507681,
            77513027,
            77522212,
            77558773,
            77490933,
            77486396,
            77494674,
            77493219
        ],
        "B": [
            77481728,
            77486304,
            77493535,
            77484584,
            77496211,
            77506722,
            77497962,
            77502380,
            77499869,
            77502504,
            77507362,
            77557318,
            77482647,
            77482138,
            77485064,
            77486365
        ],
        "A": [
            77479154,
            77479897,
            77482377,
            77479329,
            77483177,
            77511043,
            77480713,
            77493273,
            77481543,
            77493574,
            77490656,
            77562988,
            77478656,
            77478590,
            77479688,
            77479813
        ],
        "F": [
            85928150,
            77633600
        ]
    },
    "name": "D. Constant Palindrome Sum",
    "statement": "You are given an array a consisting of n integers (it is guaranteed that\r\nn is even, i.e. divisible by 2). All a_i does not exceed some integer\r\nk.Your task is to replace the number of elements (replacement is the\r\nfollowing operation: choose some index i from 1 to n and replace a_i\r\nwith some integer in range [1; k]) to satisfy the following conditions:\r\nafter all replacements, all a_i are positive integers not greater than\r\nk; for all i from 1 to\r\nfrac{n}{2} the following equation is true: a_i + a_{n - i + 1} = x,\r\nwhere x should be for all\r\nfrac{n}{2} pairs of elements. You have to answer t independent test\r\ncases.\r\n",
    "solutions": [
        "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=1000000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nint n,k,a[N],sum[N],mn[N];\nstruct node{int id,l,r;}seg[N];\nbool operator <(node p,node q) {return p.r<q.r;}\nbool cmp(node p,node q) {return p.l<q.l;}\nmultiset<node> s;\nmultiset<node>::iterator it;\nvi ask;\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();k=read();\n\t\trep(i,1,n) a[i]=read();\n\t\trep(i,1,n>>1)\n\t\t{\n\t\t\tsum[a[i]+a[n-i+1]]++;\n\t\t\tint mn=min(a[i],a[n-i+1]),mx=max(a[i],a[n-i+1]);\n\t\t\tseg[i]=(node){i,mn+1,mx+k};\n\t\t}\n\t\tsort(seg+1,seg+1+(n>>1),cmp);\n\t\t//rep(i,1,(n>>1)) cout << seg[i].l << \" \" << seg[i].r << endl;\n\t\tint ans=n;int pos=1;\n\t\trep(x,2,k*2)\n\t\t{\n\t\t\twhile (!s.empty())\n\t\t\t{\n\t\t\t\tit=s.begin();node tmp=*it;\n\t\t\t\tif (x>tmp.r) s.erase(it);else break;\n\t\t\t}\n\t\t\twhile ((pos<=(n>>1)) && (seg[pos].l==x))\n\t\t\t{\n\t\t\t\ts.insert(seg[pos]);pos++;\n\t\t\t}\n\t\t\tint siz=s.size();\n\t\t\t//cout << x << \" \" << siz << endl;\n\t\t\tint now=siz-sum[x]+(n/2-siz)*2;\n\t\t\tans=min(ans,now);\n\t\t}\n\t\ts.clear();\n\t\tprintf(\"%d\\n\",ans);\n\t\trep(i,1,k*2) sum[i]=0;\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Constant Palindrome Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/76352",
    "editorial": "It is obvious that if we fix the value of then there are three cases for\r\nthe pair of elements: We don\u00e2\u0080\u0099t need to change anything in this pair; we\r\ncan replace one element to fix this pair; we need to replace both\r\nelements to fix this pair. The first part can be calculated easily in ,\r\nwe just need to create the array of frequencies , where is the number of\r\nsuch pairs that .The second part is a bit tricky but still doable in .\r\nFor each pair, let\u00e2\u0080\u0099s understand the minimum and the maximum sum we can\r\nobtain using at most one replacement. For the -th pair, all such sums\r\nbelong to the segment . Let\u00e2\u0080\u0099s make on this segment using prefix sums\r\n(make in the left border, in the right border plus one and then just\r\ncompute prefix sums on this array). Let this array be . Then the value\r\ntells the number of such pairs that we need to replace element in this\r\npair to make it sum equals .And the last part can be calculated as . So,\r\nfor the sum the answer is . We just need to take the minimum such value\r\namong all possible sums from to .There is another one solution that uses\r\nscanline, not depends on and works in but it has no cool ideas to\r\nexplain it here (anyway the main idea is almost the same as in the\r\nsolution above).\r\n"
}