{
    "link": "https://codeforces.com//contest/1343/problem/F",
    "problemId": "599891",
    "problem_idx": "F",
    "shortId": "1343F",
    "contest_number": "1343",
    "problem_submissions": {
        "E": [
            77544731,
            77547078,
            77818546,
            77553455,
            77526508,
            77551799,
            77553477,
            77557131,
            77551163,
            77562420,
            77564988,
            77565009,
            77544133,
            77577002
        ],
        "D": [
            77525246,
            77528102,
            77748327,
            77524381,
            77567781,
            77531413,
            77529630,
            77539927,
            77535846,
            77538289,
            77534294,
            77537349,
            77562840,
            238605180,
            77507320,
            77510486,
            77513527,
            77513404
        ],
        "C": [
            77490036,
            77493815,
            77742798,
            77501239,
            77495338,
            77513080,
            77498834,
            77511866,
            77514187,
            77507681,
            77513027,
            77522212,
            77558773,
            77490933,
            77486396,
            77494674,
            77493219
        ],
        "B": [
            77481728,
            77486304,
            77493535,
            77484584,
            77496211,
            77506722,
            77497962,
            77502380,
            77499869,
            77502504,
            77507362,
            77557318,
            77482647,
            77482138,
            77485064,
            77486365
        ],
        "A": [
            77479154,
            77479897,
            77482377,
            77479329,
            77483177,
            77511043,
            77480713,
            77493273,
            77481543,
            77493574,
            77490656,
            77562988,
            77478656,
            77478590,
            77479688,
            77479813
        ],
        "F": [
            85928150,
            77633600
        ]
    },
    "name": "F. Restore the Permutation by Sorted Segments",
    "statement": "We guessed a permutation p consisting of n integers. The permutation of\r\nlength n is the array of length n where each element from 1 to n appears\r\nexactly once. This permutation is a secret for you.For each position r\r\nfrom 2 to n we chose some other index l (l < r) and gave you the segment\r\np_l, p_{l + 1},\r\ndots, p_r in order (i.e. we rearranged the elements of this segment in a\r\nway that the elements of this segment are sorted). Thus, you are given\r\nexactly n-1 segments of the initial permutation but elements inside each\r\nsegment are sorted. The segments are given to you in random order.For\r\nexample, if the secret permutation is p=[3, 1, 4, 6, 2, 5] then the\r\npossible given set of segments can be: [2, 5, 6] [4, 6] [1, 3, 4] [1, 3]\r\n[1, 2, 4, 6] Your task is to find suitable permutation (i.e. any\r\npermutation corresponding to the given input data). It is guaranteed\r\nthat the input data corresponds to some permutation (i.e. such\r\npermutation exists).You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; //\ntypedef string str; //\n//\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; //\ntypedef pair<db,db> pd; //\n//\ntypedef vector<int> vi; \ntypedef vector<ll> vl; //\ntypedef vector<db> vd; //\ntypedef vector<str> vs; //\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; //\ntypedef vector<pd> vpd; //\n \ntypedef tree<pi, null_type, less<pi>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n \n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() //\n#define rsz resize\n#define ins insert //\n#define ft front() //\n#define bk back()\n#define pf push_front //\n#define pb push_back\n#define eb emplace_back //\n#define lb lower_bound //\n#define ub upper_bound //\n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; //\nconst ll INF = 1e18; //\nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; //\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); //\n//\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { //\n\treturn a < b ? a = b, 1 : 0; } //\nconstexpr int pct(int x) { return __builtin_popcount(x); } //\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) //\nconstexpr int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 //\n// IGNORE\nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n \n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n// IGNORE\n//\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint t;\n\tcin >> t;\n\tF0R(i, t){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> lists[n - 1];\n\t\tF0R(a, n - 1){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tF0R(b, k){\n\t\t\t\tint temp;\n\t\t\t\tcin >> temp;\n\t\t\t\ttemp--;\n\t\t\t\tlists[a].pb(temp);\n\t\t\t}\n\t\t}\n\t\tF0R(a, n){\n\t\t\tbool bad = false;\n\t\t\tvector<int> ans;\n\t\t\tset<int> l[n - 1];\n\t\t\tF0R(b, n - 1)\n\t\t\t\ttrav(c, lists[b])\n\t\t\t\t\tl[b].insert(c);\n\t\t\tans.pb(a);\n\t\t\tF0R(b, n - 1){\n\t\t\t\tint last = ans[sz(ans) - 1];\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tc.erase(last);\n\t\t\t\tint cnt = 0;\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tcnt += (c.size() == 1);\n\t\t\t\tif(cnt != 1){\n\t\t\t\t\tbad = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrav(c, l)\n\t\t\t\t\tif(c.size() == 1)\n\t\t\t\t\t\tans.pb(*c.begin());\n\t\t\t}\n\t\t\tif(!bad){\n\t\t\t\ttrav(b, lists){\n\t\t\t\t\tF0R(c, n){\n\t\t\t\t\t\tauto temp = lb(all(b), ans[c]);\n\t\t\t\t\t\tif(temp != b.end() && *temp == ans[c]){\n\t\t\t\t\t\t\tif(c + sz(b) > n){\n\t\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tset<int> test;\n\t\t\t\t\t\t\ttest.insert(ans[c]);\n\t\t\t\t\t\t\tFOR(d, c + 1, c + sz(b))\n\t\t\t\t\t\t\t\ttest.insert(ans[d]);\n\t\t\t\t\t\t\tF0R(d, sz(b))\n\t\t\t\t\t\t\t\ttest.erase(b[d]);\n\t\t\t\t\t\t\tif(sz(test) != 0){\n\t\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(bad)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(bad)\n\t\t\t\t\tcontinue;\n\t\t\t\ttrav(b, ans)\n\t\t\t\t\tcout << b + 1 << \" \";\n\t\t\t\tcout << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Restore the Permutation by Sorted Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/76352",
    "editorial": "Let\u00e2\u0080\u0099s fix the first element and then try to restore permutation using\r\nthis information. One interesting fact: if such permutation exists (with\r\nthis first element) then it can be restored uniquely. Let\u00e2\u0080\u0099s remove the\r\nfirst element from all segments containing it (we can use some\r\nlogarithmic data structure for it). Then we just have a smaller problem\r\nbut with one important condition: there is a segment consisting of one\r\nelement (again, if such permutation exists). So, if the number of\r\nsegments of length is zero or more than one by some reason then there is\r\nno answer for this first element. Otherwise, let\u00e2\u0080\u0099s place this segment (a\r\nsingle element) in second place, remove it from all segments containing\r\nit and just solve a smaller problem again.If we succeed with restoring\r\nthe permutation then we need to check if this permutation really\r\nsatisfies the given input segments (see the first test case of the\r\nexample to understand why this case appears). Let\u00e2\u0080\u0099s just iterate over\r\nall from to and then over all from to . If the segment is in the list,\r\nremove it and go to the next . If we can\u00e2\u0080\u0099t find the segment for some\r\nthen this permutation is wrong.Time complexity: (or less, maybe?)\r\n"
}