{
    "link": "https://codeforces.com//contest/1324/problem/F",
    "problemId": "560265",
    "problem_idx": "F",
    "shortId": "1324F",
    "contest_number": "1324",
    "problem_submissions": {
        "F": [
            73054270,
            73065556,
            73059176,
            73065084,
            73062305,
            73067024,
            73059856,
            73063932,
            73057486,
            73044832,
            73066147,
            73064314,
            73050991,
            73068503,
            73056693,
            73068743,
            73052567,
            73072067,
            73067317
        ],
        "D": [
            73040639,
            73032866,
            73027867,
            73035134,
            73830730,
            73040900,
            73034199,
            73041603,
            73041893,
            73039400,
            73030102,
            73036508,
            73039182,
            73043928,
            73037342,
            73043874,
            73046595,
            73050863,
            73040463,
            73039200
        ],
        "E": [
            73039379,
            73044039,
            73041492,
            73041070,
            73050415,
            73046726,
            73048264,
            73049396,
            73051216,
            73055090,
            73048254,
            73047762,
            73057013,
            73049889,
            73066804,
            73056073,
            73038769,
            73127806,
            73056264,
            73050880
        ],
        "C": [
            73027564,
            73028513,
            73042083,
            73030836,
            73032053,
            73030173,
            73031129,
            73033349,
            73032347,
            73043701,
            73030001,
            73034619,
            73039260,
            73030506,
            73031218,
            73027677,
            73054056,
            73034579,
            73032723
        ],
        "B": [
            73024859,
            73025917,
            73029672,
            73087132,
            73084344,
            73028176,
            73026383,
            73025561,
            73026159,
            73028367,
            73028047,
            73036513,
            73025105,
            73030025,
            73029700,
            73025213,
            73026085,
            73024555,
            73033601,
            73026846,
            73023952
        ],
        "A": [
            73023467,
            73023622,
            73025341,
            73025903,
            73023578,
            73023714,
            73023863,
            73024673,
            73025477,
            73026756,
            73024229,
            73024181,
            73024019,
            73023479,
            73023850,
            73023303,
            73028896,
            73023916,
            73029846
        ]
    },
    "name": "F. Maximum White Subtree",
    "statement": "You are given a tree consisting of n vertices. A tree is a connected\r\nundirected graph with n-1 edges. Each vertex v of this tree has a color\r\nassigned to it (a_v = 1 if the vertex v is white and 0 if the vertex v\r\nis black).You have to solve the following problem for each vertex v:\r\nwhat is the maximum difference between the number of white and the\r\nnumber of black vertices you can obtain if you choose some subtree of\r\nthe given tree that the vertex v? The subtree of the tree is the\r\nconnected subgraph of the given tree. More formally, if you choose the\r\nsubtree that contains cnt_w white vertices and cnt_b black vertices, you\r\nhave to maximize cnt_w - cnt_b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<vector<int>> e;\nvector<int> subtree;\nvector<int> c;\nvector<int> q; \nvector<bool> used;\nvector<int> d;\n\nmap<pll, int> suptree;\n\nvoid DFS(int v, int dd) {\n\td[v] = dd;\n\tused[v] = true;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (!used[nb])\n\t\t\tDFS(nb, dd + 1);\n\t}\n\tq.push_back(v);\n}\n\nvoid count(int v) {\n\tif (c[v])\n\t\tsubtree[v]++;\n\telse\n\t\tsubtree[v]--;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] > d[v]) \n\t\t\tif (subtree[nb] > 0)\n\t\t\t\tsubtree[v] += subtree[nb];\n\t}\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] > d[v]) {\n\t\t\tint wo = subtree[v];\n\t\t\tif (subtree[nb] > 0)\n\t\t\t\two -= subtree[nb];\n\t\t\tsuptree[{v, nb}] = wo;\n\t\t}\n\t}\n}\n\nvoid count_2(int v) {\n\tint par = -1;\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] < d[v])\n\t\t\tpar = nb;\n\t}\n\tfor (int i = 0; i < e[v].size(); i++) {\n\t\tint nb = e[v][i];\n\t\tif (d[nb] > d[v]) {\n\t\t\tint add = 0;\n\t\t\tadd = max(add, suptree[{v, nb}]);\n\t\t\tfor (int j = 0; j < e[nb].size(); j++) {\n\t\t\t\tint nbnb = e[nb][j];\n\t\t\t\tif (d[nbnb] > d[nb]) {\n\t\t\t\t\tsuptree[{nb, nbnb}] += add;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (par == -1)\n\t\treturn;\n\tif (suptree[{par, v}] > 0)\n\t\tsubtree[v] += suptree[{par, v}];\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    c.resize(n);\n    for (int i = 0; i < n; i++)\n    \tcin >> c[i];\n    e.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n    \tint a, b;\n    \tcin >> a >> b;\n    \te[a - 1].push_back(b - 1);\n    \te[b - 1].push_back(a - 1);\n    }\n    used.resize(n, false);\n   \td.resize(n);\n    DFS(0, 0);\n\n   \tsubtree.resize(n, 0);\n    for (auto v : q)\n    \tcount(v);\n/*\n    for (int i = 0; i < n; i++)\n    \tcout << subtree[i] << ' ';\n    cout << endl;\n    for (auto p : suptree) {\n    \tcout << p.F.F << ' ' << p.F.S << \": \" << p.S << endl;\n    }\n*/\n\n\n    reverse(q.begin(), q.end());\n    for (auto v : q)\n    \tcount_2(v);\n\n    for (int i = 0; i < n; i++)\n    \tcout << subtree[i] << ' ';\n    cout << endl;\n/*\n    for (auto p : suptree) {\n    \tcout << p.F.F << ' ' << p.F.S << \": \" << p.S << endl;\n    }\n*/\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Maximum White Subtree.json",
    "editorial_link": "https://codeforces.com//blog/entry/74714",
    "editorial": "This problem is about the \"rerooting\" technique. Firstly, let\u00e2\u0080\u0099s\r\ncalculate the answer for some fixed root. How can we do this? Let be the\r\nmaximum possible difference between the number of white and black\r\nvertices in some subtree of (yes, the subtree of the rooted tree, i.e.\r\nand all its direct and indirect children) that the vertex . We can\r\ncalculate this dynamic programming by simple dfs, for the vertex it will\r\nlook like this: .Okay, we can store the answer for the root somewhere.\r\nWhat\u00e2\u0080\u0099s next? Let\u00e2\u0080\u0099s try to change the root from the vertex to some\r\nadjacent to it vertex . Which states of dynamic programming will change?\r\nOnly and . Firstly, we need to \"remove\" the child from the subtree of\r\nthe vertex : . Then we need to \"attach\" the vertex and make it a child\r\nof the vertex : . Then we need to run this process recursively from\r\n(store the answer, reroot the tree and so on) and when it ends we need\r\nto \"rollback\" our changes. Now is the root again and we can try the next\r\nchild of as the root.Time complexity: .\r\n"
}