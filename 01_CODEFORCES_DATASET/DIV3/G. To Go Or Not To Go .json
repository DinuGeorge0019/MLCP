{
    "link": "https://codeforces.com//contest/1520/problem/G",
    "problemId": "976803",
    "problem_idx": "G",
    "shortId": "1520G",
    "contest_number": "1520",
    "problem_submissions": {
        "F2": [
            115377397,
            115305590,
            115287040,
            115299425,
            115275998,
            115291100,
            115279060,
            115289661,
            115284382,
            115289848,
            115308377,
            115278701,
            115306155,
            115291190,
            115265089,
            115307538,
            115303936,
            115461761,
            115294385,
            115296101
        ],
        "G": [
            115377372,
            115262775,
            115288422,
            115284069,
            115289230,
            115326140,
            115318505,
            115305519,
            115310728,
            115306048,
            115310484,
            115283392,
            115286859,
            115490380,
            115494255,
            115428029,
            115418593,
            115335990,
            115630972,
            115630383
        ],
        "F1": [
            115377349,
            115249032,
            115270195,
            115243368,
            115263879,
            115260580,
            115273435,
            115261038,
            115280609,
            115277317,
            115293876,
            115256261,
            115254859,
            115241348,
            115257133,
            115247327,
            115256409,
            115278650,
            115271950,
            115272669
        ],
        "E": [
            115377332,
            115237334,
            115239791,
            115237430,
            115247171,
            115242404,
            115248291,
            115250125,
            115252428,
            115257556,
            115318354,
            115247364,
            115240877,
            115248360,
            115247935,
            115237440,
            115241805,
            115254530,
            115253830,
            115256564
        ],
        "C": [
            115377311,
            115225774,
            115221824,
            115221195,
            115232319,
            115227403,
            115230041,
            115230111,
            115234657,
            115232187,
            115315640,
            115223231,
            115228100,
            115217322,
            115228063,
            115296150,
            115228425,
            115221440,
            115236900,
            115240483
        ],
        "D": [
            115377293,
            115218646,
            115225866,
            115229634,
            115238178,
            115231535,
            115237704,
            115234502,
            115238902,
            115239693,
            115238815,
            115228744,
            115221564,
            115219392,
            115231781,
            115227386,
            115230454,
            115232684,
            115243890,
            115245632
        ],
        "B": [
            115377281,
            115214791,
            115214878,
            115216679,
            115235400,
            115218148,
            115218189,
            115225076,
            115218800,
            115220311,
            115284747,
            115217692,
            115219291,
            115213196,
            115216288,
            115215912,
            115223513,
            115214573,
            115226157,
            115226244
        ],
        "A": [
            115377268,
            115212622,
            115212991,
            115213371,
            115214493,
            115214137,
            115213480,
            115215360,
            115213972,
            115213655,
            115216180,
            115212784,
            115213313,
            115212547,
            115212731,
            115213509,
            115217879,
            115212709,
            115218109,
            115218897
        ]
    },
    "name": "G. To Go Or Not To Go ",
    "statement": "Dima overslept the alarm clock, which was supposed to raise him to\r\nschool.Dima wonders if he will have time to come to the first lesson. To\r\ndo this, he needs to know the it will take him to get from home to\r\nschool.The city where Dima lives is a rectangular field of n\r\ntimes m size. Each cell (i, j) on this field is denoted by one number\r\na_{ij}: The number -1 means that the passage through the cell is\r\nprohibited; The number 0 means that the cell is free and Dima can walk\r\nthough it. The number x (1\r\nle x\r\nle 10^9) means that the cell contains a portal with a cost of x. A cell\r\nwith a portal is also considered free. From any portal, Dima can go to\r\nany other portal, while the time of moving from the portal (i, j) to the\r\nportal (x, y) corresponds to the sum of their costs a_{ij} + a_{xy}.In\r\naddition to moving between portals, Dima can also move between\r\nunoccupied cells adjacent to one side in time w. In particular, he can\r\nenter a cell with a portal and not use it.Initially, Dima is in the\r\nupper-left cell (1, 1), and the school is in the lower right cell (n,\r\nm).\r\n",
    "solutions": [
        "#include \"bits/extc++.h\"\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << \"L\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"]\" << \": \";       \\\nsep(cerr, \" | \", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl \"\\n\"\n\n#define sz(x) int((x).size())\n\nconst int maxn = 2e3;\nconst int dx[4] {0, 1, 0, -1}, dy[4] {1, 0, -1, 0};\n\nint n, m;\nlong w, arr[maxn][maxn];\n\nbool ibs(int x, int y) {\n\treturn 0 <= x && x < n && 0 <= y && y < m;\n}\n\nvector<vector<long>> bfs(int sx, int sy) {\n\tvector<vector<long>> dist(n, vector<long>(m, -1));\n\tqueue<pair<int, int>> q;\n\tq.emplace(sx, sy);\n\tdist[sx][sy] = 0;\n\twhile(sz(q)) {\n\t\tauto &[x, y] = q.front();\n\t\tq.pop();\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint cx = x + dx[i];\n\t\t\tint cy = y + dy[i];\n\t\t\tif(ibs(cx, cy) && arr[cx][cy] != -1 && dist[cx][cy] == -1) {\n\t\t\t\tdist[cx][cy] = dist[x][y] + w;\n\t\t\t\tq.emplace(cx, cy);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nvoid solve() {\n\tcin >> n >> m >> w;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tcin >> arr[i][j];\n\t\t}\n\t}\n\tauto s = bfs(0, 0), e = bfs(n - 1, m - 1);\n\tlong ports = 1e18, porte = 1e18;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < m; j++) {\n\t\t\tif(arr[i][j] > 0) {\n\t\t\t\tif(s[i][j] != -1) {\n\t\t\t\t\tports = min(ports, arr[i][j] + s[i][j]);\n\t\t\t\t\tdbg(i, j, arr[i][j], s[i][j], arr[i][j] + s[i][j]);\n\t\t\t\t}\n\t\t\t\tif(e[i][j] != -1) {\n\t\t\t\t\tporte = min(porte, arr[i][j] + e[i][j]);\n\t\t\t\t\tdbg(i, j, arr[i][j], e[i][j], arr[i][j] + e[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(max(ports, porte) == 1e18 && e[0][0] == -1) {\n\t\tcout << -1 << endl;\n\t}else {\n\t\tlong ans = 1e18;\n\t\tif(e[0][0] != -1) {\n\t\t\tans = min(ans, e[0][0]);\n\t\t\tdbg(ans);\n\t\t}\n\t\tans = min(ans, ports + porte);\n\t\tdbg(ans, ports, porte);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint t = 1;\n//\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << \"Case #\" << _ << \": \";\n\t\tsolve();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. To Go Or Not To Go .json",
    "editorial_link": "https://codeforces.com//blog/entry/90342",
    "editorial": "There is no point in using two transitions between portals, because if\r\nyou want to go from portal to portal , and then from portal to portal ,\r\nthen you can immediately go from portal to portal for less.Then there\r\nare two possible paths.First do not use portals. Here it is enough to\r\nfind the shortest path between two points.The second use a single\r\ntransition. Letâs choose a portal from which we should teleport.\r\nObviously, this is a portal with a minimum distance to it and the cost\r\nof the transition. Similarly, the portal in which we should teleport is\r\nselected.\r\n",
    "hint": []
}