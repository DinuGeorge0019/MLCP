{
    "link": "https://codeforces.com//contest/1102/problem/D",
    "problemId": "280230",
    "problem_idx": "D",
    "shortId": "1102D",
    "contest_number": "1102",
    "problem_submissions": {
        "F": [
            48140951,
            48147190,
            48151952,
            48147273,
            48149693,
            48148209,
            48149357,
            48156228,
            48324719,
            48156492,
            48211275,
            48210647,
            48465963
        ],
        "E": [
            48133168,
            48134978,
            48134782,
            48135856,
            48131616,
            48151765,
            48145873,
            48128235,
            48131297,
            48136054,
            48139969,
            48138178,
            48141535,
            48140000,
            50612473,
            49117474,
            48143805,
            48143096,
            48141761,
            48140639,
            48142040,
            48138664
        ],
        "D": [
            48130363,
            48129370,
            48132705,
            48133131,
            48146366,
            48139447,
            48153130,
            48141036,
            48138860,
            48132737,
            48132907,
            48132415,
            48134717,
            48134475,
            48133518,
            48130113,
            48138869,
            48135563,
            48136818,
            48135753
        ],
        "C": [
            48124610,
            48124428,
            48127226,
            48130117,
            48124395,
            48129801,
            48133951,
            48124097,
            48123397,
            48126329,
            48125852,
            48124992,
            48127428,
            48126645,
            48127128,
            48125282,
            48126002,
            48129026,
            48128077,
            48129849
        ],
        "B": [
            48122561,
            48122504,
            48125142,
            48127847,
            48123165,
            48123788,
            48132434,
            48120816,
            48121994,
            48123399,
            48123616,
            48121594,
            48124256,
            48123685,
            48122759,
            48123296,
            48123050,
            48125935,
            48125539,
            48126168
        ],
        "A": [
            48119616,
            48119377,
            48119214,
            48122772,
            48119115,
            48118984,
            48121381,
            48121124,
            48118971,
            48118958,
            48120635,
            48119936,
            48118948,
            48119353,
            48120109,
            48119913,
            48119534,
            48118997,
            48120967,
            48119662,
            48120313
        ]
    },
    "name": "D. Balanced Ternary String",
    "statement": "You are given a string s consisting of exactly n characters, and each\r\ncharacter is either \u201d, \u201d or \u201d. Such strings are called .Your task is to\r\nin this string with other characters to obtain a ternary string (\r\nternary string is a ternary string such that the number of characters \u201d\r\nin this string is equal to the number of characters \u201d, and the number of\r\ncharacters \u201d (and \u201d obviously) is equal to the number of characters\r\n\u201d).Among all possible ternary strings you have to obtain the\r\nlexicographically (alphabetically) smallest.Note that you can neither\r\nremove characters from the string nor add characters to the string. Also\r\nnote that you can replace the given characters only with characters \u201d, \u201d\r\nand \u201d.It is that the answer exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5;\nint n,a[N],freq[4];\nvector<int>v[2];\nvoid fix(int x,int y){\n\tint need = min(n/3 - freq[y],freq[x] - n/3);\n\tif(!need)return;\n\tfreq[y]+=need;\n\tfreq[x]-=need;\n\tif(x < y){\n\t\tfor(int j = n - 1;j + 1 && need;j--)\n\t\t\tif(a[j] == x)a[j] = y,need--;\n\t}\n\telse {\n\t\tfor(int j = 0;j < n && need;j++){\n\t\t\tif(a[j] == x)a[j] = y,need--;\t\n\t\t}\n\t}\n}\nint main(){\n// \tfreopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < n;i++){\n\t\tscanf(\"%1d\",a + i);\n\t\tfreq[a[i]]++;\n\t}\n\tfor(int i = 0;i < 3;i++)v[freq[i] < n/3].push_back(i);\n\tif(v[0].size() == 1 && v[0][0] != 2)reverse(v[1].begin(),v[1].end());\n\tfor(auto j : v[0])\n\t\tfor(auto i : v[1])\n\t\t\tfix(j,i);\n\tfor(int i = 0;i < n;i++)printf(\"%d\",a[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Balanced Ternary String.json",
    "editorial_link": "https://codeforces.com//blog/entry/64439",
    "editorial": "Let\u00e2\u0080\u0099s count how many characters \u00e2\u0080\u009d, \u00e2\u0080\u009d and \u00e2\u0080\u009d we have in the string and\r\nstore it in the array . Also let\u00e2\u0080\u0099s count our \"goal\" array . Firstly, the\r\narray is .The main idea of this problem is a pretty standard\r\nlexicographically greedy approach. We go from left to right and try to\r\nplace the minimum possible character at the current position in such a\r\nway that placing this character is not breaking conditions of our\r\nproblem. How can we apply this approach to this problem?Firstly, let\u00e2\u0080\u0099s\r\ndefine a function . What does the value of this function mean? It means\r\nthe number of replacements we need to reach from . Let at the beginning\r\nof the program. This value means the minimum number of replacements to\r\nobtain some balanced ternary string. Let\u00e2\u0080\u0099s maintain the variable which\r\ninitially is and means the number of replacements we already made.So, we\r\niterate over all positions from to . Firstly, let\u00e2\u0080\u0099s decrease . So the\r\narray maintains the current amount of characters on suffix of the\r\nstring. Now let\u00e2\u0080\u0099s iterate over characters from to and try to place every\r\ncharacter. If the current character is needed (), then let\u00e2\u0080\u0099s decrease\r\nand if the number of replacements will still be minimum possible after\r\nsuch replacement () then let\u00e2\u0080\u0099s place this character, set and go to the\r\nnext position. This will form lexicographically minimum possible answer\r\nwith minimum number of replacements.There is another (simpler) solution\r\nfrom PikMike, you can call him to explain it, I just will add his code\r\nto the editorial.\r\n"
}