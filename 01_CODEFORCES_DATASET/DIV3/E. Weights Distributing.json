{
    "link": "https://codeforces.com//contest/1343/problem/E",
    "problemId": "599892",
    "problem_idx": "E",
    "shortId": "1343E",
    "contest_number": "1343",
    "problem_submissions": {
        "E": [
            77544731,
            77547078,
            77818546,
            77553455,
            77526508,
            77551799,
            77553477,
            77557131,
            77551163,
            77562420,
            77564988,
            77565009,
            77544133,
            77577002
        ],
        "D": [
            77525246,
            77528102,
            77748327,
            77524381,
            77567781,
            77531413,
            77529630,
            77539927,
            77535846,
            77538289,
            77534294,
            77537349,
            77562840,
            238605180,
            77507320,
            77510486,
            77513527,
            77513404
        ],
        "C": [
            77490036,
            77493815,
            77742798,
            77501239,
            77495338,
            77513080,
            77498834,
            77511866,
            77514187,
            77507681,
            77513027,
            77522212,
            77558773,
            77490933,
            77486396,
            77494674,
            77493219
        ],
        "B": [
            77481728,
            77486304,
            77493535,
            77484584,
            77496211,
            77506722,
            77497962,
            77502380,
            77499869,
            77502504,
            77507362,
            77557318,
            77482647,
            77482138,
            77485064,
            77486365
        ],
        "A": [
            77479154,
            77479897,
            77482377,
            77479329,
            77483177,
            77511043,
            77480713,
            77493273,
            77481543,
            77493574,
            77490656,
            77562988,
            77478656,
            77478590,
            77479688,
            77479813
        ],
        "F": [
            85928150,
            77633600
        ]
    },
    "name": "E. Weights Distributing",
    "statement": "You are given an undirected unweighted graph consisting of n vertices\r\nand m edges (which represents the map of Bertown) and the array of\r\nprices p of length m. It is guaranteed that there is a path between each\r\npair of vertices (districts).Mike has planned a trip from the vertex\r\n(district) a to the vertex (district) b and then from the vertex\r\n(district) b to the vertex (district) c. He can visit the same district\r\ntwice or more. But there is one issue: authorities of the city want to\r\nset a price for using the road so if someone goes along the road then he\r\nshould pay the price corresponding to this road (). The list of prices\r\nthat will be used p is ready and they just want to distribute it between\r\nall roads in the town in such a way that each price from the array\r\ncorresponds to exactly one road.You are a good friend of Mike (and\r\nsuddenly a mayor of Bertown) and want to help him to make his trip as\r\ncheap as possible. So, your task is to distribute prices between roads\r\nin such a way that if Mike chooses the optimal path then the price of\r\nthe trip is the possible. .You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=200000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nstruct node{int to,nxt;}sq[N<<1];\nint all=0,head[N];\nint n,m,a,b,c,dis[3][N];\nbool vis[N];\nll w[N];\nstruct hnode{int u,dis;};\nbool operator <(hnode p,hnode q) {return p.dis>q.dis;}\npriority_queue<hnode> q;\n\nvoid addedge(int u,int v)\n{\n\t//cout << \"edge \" << u << \" \" << v << endl;\n\tall++;sq[all].to=v;sq[all].nxt=head[u];head[u]=all;\n}\n\nvoid dij(int st,int *dis)\n{\n\t//cout << \"start \" << st << endl;\n\trep(i,1,n) dis[i]=maxd,vis[i]=0;\n\tq.push((hnode){st,0});dis[st]=0;\n\t//rep(i,1,n) cout << dis[i] <<\" \";cout << endl;\n\twhile (!q.empty())\n\t{\n\t\tint u=q.top().u;q.pop();\n\t\tif (vis[u]) continue;vis[u]=1;\n\t\t//cout << \"now \" << u << endl;\n\t\tgo(u,i)\n\t\t{\n\t\t\t//cout << \"towards \" << v << endl;\n\t\t\tif (dis[v]>dis[u]+1)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tif (!vis[v]) q.push((hnode){v,dis[v]});\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i,1,n) cout << dis[i] << \" \";cout << endl;\n}\n\nll calc(int l,int r) \n{\n\tif (r>m) return 1e18;\n\telse return w[r]-w[l-1];\n}\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();m=read();a=read();b=read();c=read();\n\t\trep(i,1,m) w[i]=read();\n\t\tsort(w+1,w+1+m);\n\t\trep(i,1,m) w[i]+=w[i-1];\n\t\trep(i,1,m)\n\t\t{\n\t\t\tint u=read(),v=read();\n\t\t\taddedge(u,v);addedge(v,u);\n\t\t}\n\t\tdij(b,dis[0]);dij(a,dis[1]);dij(c,dis[2]);\n\t\t//rep(i,1,n) cout << dis[0][i] << \" \";\n\t\t//cout << endl;\n\t\tll ans=1e18;\n\t\trep(i,1,n)\n\t\t{\n\t\t\tint x=dis[0][i],y=dis[1][i],z=dis[2][i];\n\t\t\t//cout << i << \" \" << x << \" \"<< y << \" \"<< z << endl;\n\t\t\tll now=calc(1,x)*2+calc(x+1,x+y)+calc(x+y+1,x+y+z);\n\t\t\t//cout << now << endl;\n\t\t\tans=min(ans,now);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\trep(i,1,n) head[i]=0;all=0;\n\t}\n\treturn 0;\n}\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "greedy",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Weights Distributing.json",
    "editorial_link": "https://codeforces.com//blog/entry/76352",
    "editorial": "If we distribute costs optimally, then this pair of paths ( and ) can\r\nlook like just a straight path that doesn\u00e2\u0080\u0099t visit the same vertex twice\r\nor like three straight paths with one intersection point . The first\r\ncase is basically a subcase of the second one (with the intersection\r\npoint or ). So, if we fix the intersection point then these two paths (\r\nand ) become four paths (, , and ). We can notice that each path we\r\ndenoted should be the shortest possible because if it isn\u00e2\u0080\u0099t the shortest\r\none then we used some prices that we couldn\u00e2\u0080\u0099t use.Let the length of the\r\nshortest path from to be . Then it is obvious that for the fixed\r\nintersection point we don\u00e2\u0080\u0099t need to use more than smallest costs. Now we\r\nwant to distribute these costs between these three paths somehow. We can\r\nsee that the path from to is used twice so it is more optimally to\r\ndistribute the smallest costs along this part. So, let be the sum of the\r\nfirst smallest costs (just prefix sums on the sorted array ). Then for\r\nthe intersection point the answer is (if ). We can calculate distances\r\nfrom , and to each vertex with three runs of bfs.Time complexity: .\r\n"
}