{"link": "https://codeforces.com//contest/1607/problem/F", "problemId": "1168763", "problem_idx": "F", "shortId": "1607F", "contest_number": "1607", "problem_submissions": {"H": [134109261, 134122573, 134127039, 134129159, 134120326, 134124082, 134115613, 134086394, 222081291], "G": [134100516, 134111114, 134120315, 134119987, 134103409, 134125077, 134090777, 134124686, 134161401, 134108011, 134124515, 134135421, 134120363, 134127386, 134118374], "F": [134088119, 134094606, 134109434, 134113674, 134106214, 134130777, 134116309, 134123514, 134126664, 134098669, 134116441, 138590174, 134109926, 134122503, 134115728, 134132308], "E": [134075767, 134075550, 134083203, 134090648, 134082456, 134081369, 134087482, 134106728, 134090817, 134098958, 134102790, 134115817, 134085769, 134078748, 138590168, 134089452, 134089115, 134093726, 134096883, 134087185, 134095967, 134093434], "D": [134073147, 134079470, 134081268, 134078614, 134077065, 134080878, 134074693, 134077504, 134095837, 134113769, 134103320, 134076699, 134075433, 138590165, 134084570, 134083055, 134085492, 134086301, 134077797, 134088883, 134092149], "C": [134069725, 134073680, 134076697, 134075904, 134072982, 134074821, 134078550, 134074603, 134077620, 134094573, 134099873, 134073307, 134072872, 138590159, 134078305, 134075739, 134077550, 134078439, 134072306, 134082344, 134079268], "B": [134067338, 134069577, 134073071, 134074024, 134071494, 134070714, 134072150, 134072633, 134073059, 134091344, 134097562, 134068544, 134068492, 138590150, 134072771, 134079913, 134074563, 134075669, 134092880, 134071701, 134074168], "A": [134063636, 134063717, 134066145, 134063736, 134063629, 134070558, 134064987, 134064160, 134064799, 134089110, 134068267, 134064265, 134063696, 138590140, 134064218, 134065711, 134066701, 134063772, 134064096, 134065356, 134065091]}, "name": "F. Robot on the Board 2", "statement": "The robot is located on a checkered rectangular board of size n\r\ntimes m (n rows, m columns). The rows in the board are numbered from 1\r\nto n from top to bottom, and the columns from 1 to m from left to\r\nright.The robot is able to move from the current cell to one of the four\r\ncells adjacent by side.Each cell has one of the symbols \u201d, \u201d, \u201d or \u201d\r\nwritten on it, indicating the direction in which the robot will move\r\nwhen it gets in that cell left, right, down or up, respectively.The\r\nrobot can start its movement in any cell. He then moves to the adjacent\r\nsquare in the direction indicated on the current square in one move. If\r\nthe robot moves beyond the edge of the board, it falls and breaks. If\r\nthe robot appears in the cell it already visited before, it breaks (it\r\nstops and doesn\u2019t move anymore). Robot can choose any cell as the\r\nstarting cell. Its goal is to make the maximum number of steps before it\r\nbreaks or stops.Determine from which square the robot should start its\r\nmovement in order to execute as many commands as possible. A command is\r\nconsidered successfully completed if the robot has moved from the square\r\non which that command was written (it does not matter whether to another\r\nsquare or beyond the edge of the board).\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nchar a[2005][2005];\nint ans[2005][2005],n,m,vis[2005][2005],qwq,ANS,v2[2005][2005],flag=0,X,Y;\ninline void qaq(short x,short y)\n{\n\t//cout << x << \" \" << y << \"*\\n\";\n\tif(v2[x][y]==2) return ;\n\tv2[x][y]=2;\n\tans[x][y]=ANS;\n\tint nx=x,ny=y;\n\tif(a[x][y]=='L') --ny;\n\telse if(a[x][y]=='R') ++ny;\n\telse if(a[x][y]=='U') --nx;\n\telse if(a[x][y]=='D') ++nx;\n\tqaq(nx,ny);\n}\ninline int solve2(short x,short y)\n{\n\tif(v2[x][y]) return 0;\n\tv2[x][y]=1;\n//\tans[x][y]=ANS;\n\tint nx=x,ny=y;\n\tif(a[x][y]=='L') --ny;\n\telse if(a[x][y]=='R') ++ny;\n\telse if(a[x][y]=='U') --nx;\n\telse if(a[x][y]=='D') ++nx;\n\treturn 1+solve2(nx,ny);\n}\ninline int solve(short x,short y)\n{\n\tif(x<1||y<1||x>n||y>m) return 0;\n\tif(flag) return 0;\n\tif(vis[x][y]==qwq)\n\t{\n\t\tX=x,Y=y,flag=1;\n\t\treturn 0;\n\t}\n\tif(ans[x][y]) return ans[x][y];\n\tvis[x][y]=qwq;\n\tint nx=x,ny=y;\n\tif(a[x][y]=='L') --ny;\n\telse if(a[x][y]=='R') ++ny;\n\telse if(a[x][y]=='U') --nx;\n\telse if(a[x][y]=='D') ++nx;\n\treturn ans[x][y]=1+solve(nx,ny);\n}\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tcin >> n >> m;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tans[i][j]=0,vis[i][j]=0,v2[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tX=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(!vis[i][j])\n\t\t\t\t{\n\t\t\t\t\t++qwq,ANS=0;\n\t\t\t\t\tflag=0;\n\t\t\t\t\tsolve(i,j);\n\t\t\t//\t\tcout << X << \" \" << Y << \"*\\n\";\n\t\t\t\t\tif(X)\n\t\t\t\t\t{\n\t\t\t\t\t\tANS=solve2(X,Y);\n\t\t\t//\t\t\tcout << ANS << \"*\\n\";\n\t\t\t\t\t\tqaq(X,Y),++qwq,flag=0,solve(i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(ans[i][j]>mx) mx=ans[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(ans[i][j]==mx)\n\t\t\t\t{\n\t\t\t\t\tcout << i << \" \" << j << \" \" << mx << \"\\n\";\n\t\t\t\t\tmx=-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==-1) break;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dfs and similar", "graphs", "implementation"], "dificulty": "2300", "interactive": false}