{
    "link": "https://codeforces.com//contest/1607/problem/F",
    "problemId": "1168763",
    "problem_idx": "F",
    "shortId": "1607F",
    "contest_number": "1607",
    "problem_submissions": {
        "H": [
            134109261,
            134122573,
            134127039,
            134129159,
            134120326,
            134124082,
            134115613,
            134086394,
            222081291
        ],
        "G": [
            134100516,
            134111114,
            134120315,
            134119987,
            134103409,
            134125077,
            134090777,
            134124686,
            134161401,
            134108011,
            134124515,
            134135421,
            134120363,
            134127386,
            134118374
        ],
        "F": [
            134088119,
            134094606,
            134109434,
            134113674,
            134106214,
            134130777,
            134116309,
            134123514,
            134126664,
            134098669,
            134116441,
            138590174,
            134109926,
            134122503,
            134115728,
            134132308
        ],
        "E": [
            134075767,
            134075550,
            134083203,
            134090648,
            134082456,
            134081369,
            134087482,
            134106728,
            134090817,
            134098958,
            134102790,
            134115817,
            134085769,
            134078748,
            138590168,
            134089452,
            134089115,
            134093726,
            134096883,
            134087185,
            134095967,
            134093434
        ],
        "D": [
            134073147,
            134079470,
            134081268,
            134078614,
            134077065,
            134080878,
            134074693,
            134077504,
            134095837,
            134113769,
            134103320,
            134076699,
            134075433,
            138590165,
            134084570,
            134083055,
            134085492,
            134086301,
            134077797,
            134088883,
            134092149
        ],
        "C": [
            134069725,
            134073680,
            134076697,
            134075904,
            134072982,
            134074821,
            134078550,
            134074603,
            134077620,
            134094573,
            134099873,
            134073307,
            134072872,
            138590159,
            134078305,
            134075739,
            134077550,
            134078439,
            134072306,
            134082344,
            134079268
        ],
        "B": [
            134067338,
            134069577,
            134073071,
            134074024,
            134071494,
            134070714,
            134072150,
            134072633,
            134073059,
            134091344,
            134097562,
            134068544,
            134068492,
            138590150,
            134072771,
            134079913,
            134074563,
            134075669,
            134092880,
            134071701,
            134074168
        ],
        "A": [
            134063636,
            134063717,
            134066145,
            134063736,
            134063629,
            134070558,
            134064987,
            134064160,
            134064799,
            134089110,
            134068267,
            134064265,
            134063696,
            138590140,
            134064218,
            134065711,
            134066701,
            134063772,
            134064096,
            134065356,
            134065091
        ]
    },
    "name": "F. Robot on the Board 2",
    "statement": "The robot is located on a checkered rectangular board of size n\r\ntimes m (n rows, m columns). The rows in the board are numbered from 1\r\nto n from top to bottom, and the columns from 1 to m from left to\r\nright.The robot is able to move from the current cell to one of the four\r\ncells adjacent by side.Each cell has one of the symbols \u201d, \u201d, \u201d or \u201d\r\nwritten on it, indicating the direction in which the robot will move\r\nwhen it gets in that cell left, right, down or up, respectively.The\r\nrobot can start its movement in any cell. He then moves to the adjacent\r\nsquare in the direction indicated on the current square in one move. If\r\nthe robot moves beyond the edge of the board, it falls and breaks. If\r\nthe robot appears in the cell it already visited before, it breaks (it\r\nstops and doesn\u2019t move anymore). Robot can choose any cell as the\r\nstarting cell. Its goal is to make the maximum number of steps before it\r\nbreaks or stops.Determine from which square the robot should start its\r\nmovement in order to execute as many commands as possible. A command is\r\nconsidered successfully completed if the robot has moved from the square\r\non which that command was written (it does not matter whether to another\r\nsquare or beyond the edge of the board).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nchar a[2005][2005];\nint ans[2005][2005],n,m,vis[2005][2005],qwq,ANS,v2[2005][2005],flag=0,X,Y;\ninline void qaq(short x,short y)\n{\n\t//cout << x << \" \" << y << \"*\\n\";\n\tif(v2[x][y]==2) return ;\n\tv2[x][y]=2;\n\tans[x][y]=ANS;\n\tint nx=x,ny=y;\n\tif(a[x][y]=='L') --ny;\n\telse if(a[x][y]=='R') ++ny;\n\telse if(a[x][y]=='U') --nx;\n\telse if(a[x][y]=='D') ++nx;\n\tqaq(nx,ny);\n}\ninline int solve2(short x,short y)\n{\n\tif(v2[x][y]) return 0;\n\tv2[x][y]=1;\n//\tans[x][y]=ANS;\n\tint nx=x,ny=y;\n\tif(a[x][y]=='L') --ny;\n\telse if(a[x][y]=='R') ++ny;\n\telse if(a[x][y]=='U') --nx;\n\telse if(a[x][y]=='D') ++nx;\n\treturn 1+solve2(nx,ny);\n}\ninline int solve(short x,short y)\n{\n\tif(x<1||y<1||x>n||y>m) return 0;\n\tif(flag) return 0;\n\tif(vis[x][y]==qwq)\n\t{\n\t\tX=x,Y=y,flag=1;\n\t\treturn 0;\n\t}\n\tif(ans[x][y]) return ans[x][y];\n\tvis[x][y]=qwq;\n\tint nx=x,ny=y;\n\tif(a[x][y]=='L') --ny;\n\telse if(a[x][y]=='R') ++ny;\n\telse if(a[x][y]=='U') --nx;\n\telse if(a[x][y]=='D') ++nx;\n\treturn ans[x][y]=1+solve(nx,ny);\n}\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tcin >> n >> m;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tans[i][j]=0,vis[i][j]=0,v2[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tX=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(!vis[i][j])\n\t\t\t\t{\n\t\t\t\t\t++qwq,ANS=0;\n\t\t\t\t\tflag=0;\n\t\t\t\t\tsolve(i,j);\n\t\t\t//\t\tcout << X << \" \" << Y << \"*\\n\";\n\t\t\t\t\tif(X)\n\t\t\t\t\t{\n\t\t\t\t\t\tANS=solve2(X,Y);\n\t\t\t//\t\t\tcout << ANS << \"*\\n\";\n\t\t\t\t\t\tqaq(X,Y),++qwq,flag=0,solve(i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(ans[i][j]>mx) mx=ans[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(ans[i][j]==mx)\n\t\t\t\t{\n\t\t\t\t\tcout << i << \" \" << j << \" \" << mx << \"\\n\";\n\t\t\t\t\tmx=-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mx==-1) break;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Robot on the Board 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/96604",
    "editorial": "Let\u00e2\u0080\u0099s start moving from an arbitrary cell of the table, for example,\r\nfrom . Movement from each cell is specified by the direction given in\r\nthat cell, so you can run a loop with a stopping condition \"exit from\r\nthe board border or get to the already visited cell\". Create a separate\r\narray how many commands the robot will execute, starting the movement\r\nfrom the cell ; we will also use it to check whether the cell has\r\nalready been visited or not (not visited if is not yet\r\npositive).Finishing the movement from let\u00e2\u0080\u0099s consider two cases. Either\r\nwe have gone beyond the boundary of the array, then we can say for sure\r\nthat for the -th cell from the end of the sequence the answer is . Or we\r\ncame to the already visited cell, let it be the -th from the end in our\r\npath. Then at the end of the path, there is a cycle of length : starting\r\nthe movement at any cell of this cycle, the robot will walk exactly\r\nsteps until it arrives at the already visited cell. Thus, for distance\r\nwill be equal to , and for all others it will be, as in the first case,\r\n. Let us run the same algorithm from the next cell, which we have not\r\nyet considered. There will be three cases of robot stopping the\r\nexecution of the commands: the first two repeat those already considered\r\nabove, and the third case is that the robot will come to the cell\r\nalready visited on some of the previous iterations of our algorithm. In\r\nthis case we know that starting from , the robot will make exactly\r\nsteps, so for the -th cell from the end on the current path will hold.\r\nThe first two cases are handled completely in the same way as described\r\nabove. Each of the cases is eventually reduced to another iteration over\r\nthe cells visited in the current path. Let\u00e2\u0080\u0099s visit all the cells in\r\nreverse and mark all values of .Such algorithm is enough to repeat until\r\neach cell is processed, after which for each cell of the table its will\r\nbe known and we\u00e2\u0080\u0099ll only have to choose the maximal value of among all .\r\n"
}