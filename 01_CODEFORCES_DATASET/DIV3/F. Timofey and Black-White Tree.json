{
    "link": "https://codeforces.com//contest/1790/problem/F",
    "problemId": "1753651",
    "problem_idx": "F",
    "shortId": "1790F",
    "contest_number": "1790",
    "problem_submissions": {
        "G": [
            190854632,
            190862960,
            190871236,
            190852228,
            190874097,
            190860078,
            190864244,
            190870017,
            190877879,
            190877235,
            190904434,
            190907790,
            190907701,
            190907675,
            190907628,
            190907581,
            190906892,
            190854527,
            190922421
        ],
        "F": [
            190826149,
            190835977,
            190846761,
            190834910,
            190847927,
            190872422,
            190808806,
            190840036,
            190828723,
            190808476,
            190910332,
            190837355,
            196429864,
            190917553,
            190917160,
            190851135,
            190842374,
            190851773,
            190863031,
            190852368,
            190851643,
            190838344
        ],
        "E": [
            190812975,
            190818965,
            190827893,
            190863212,
            190836271,
            190829765,
            190825221,
            190876565,
            190808314,
            190824525,
            190821638,
            190829372,
            190820356,
            190812061,
            190820330,
            190820963,
            190806991,
            190818524,
            190819724,
            190846451
        ],
        "D": [
            190803665,
            190801014,
            190809824,
            190809927,
            190814214,
            190816750,
            190829094,
            190855040,
            190798110,
            190788994,
            190804480,
            190888100,
            190808920,
            190796914,
            191055501,
            190801526,
            190807925,
            190805582,
            190795106,
            190877973,
            190877812,
            190877739,
            190807212,
            190809993,
            190794263
        ],
        "C": [
            190799607,
            190794832,
            190803346,
            190801723,
            190802374,
            190811887,
            190835627,
            190842540,
            190791067,
            190792160,
            190797002,
            190796740,
            190791871,
            191053177,
            190792454,
            190799052,
            190800065,
            190792126,
            190796861,
            190801470,
            190788102
        ],
        "B": [
            190787414,
            190782870,
            190784109,
            190786307,
            190786713,
            190787527,
            190838763,
            190837244,
            190783518,
            190783528,
            190787197,
            190780535,
            190781020,
            190992563,
            190781621,
            190782537,
            190779326,
            190778124,
            190780824,
            190788703,
            190964430,
            190781997
        ],
        "A": [
            190775165,
            190772612,
            190774942,
            190772740,
            190773567,
            190776157,
            190841892,
            190833157,
            190774181,
            190772373,
            190774417,
            190772590,
            190773736,
            190991523,
            190774168,
            190774263,
            190772401,
            190772891,
            190774182,
            192760356,
            190775235,
            190774848
        ]
    },
    "name": "F. Timofey and Black-White Tree",
    "statement": "Timofey came to a famous summer school and found a tree on n vertices. A\r\ntree is a connected undirected graph without cycles.Every vertex of this\r\ntree, except c_0, is colored . The vertex c_0 is colored .Timofey wants\r\nto color all the vertices of this tree in . To do this, he performs n -\r\n1 operations. During the i-th operation, he selects the vertex c_i,\r\nwhich is currently , and paints it .Let’s call the of tree the minimum\r\ndistance between all pairs of different vertices in it. The distance\r\nbetween the vertices v and u is the number of edges on the path from v\r\nto u.After each operation, Timofey wants to know the of the current\r\ntree.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nint t,ans;\nint a[200100],u[200100],v[200100],d[200100];\nvector<int> g[200100];\nvoid solve(){\n        int n,i;cin>>n;\n        ans=n;\n        for(i=1;i<=n;i++)g[i].clear(),d[i]=n,cin>>a[i];\n        for(i=1;i<n;i++)cin>>u[i]>>v[i],g[u[i]].emplace_back(v[i]),g[v[i]].emplace_back(u[i]);\n        for(i=1;i<=n;i++){\n                if(ans>d[a[i]])ans=d[a[i]];\n                if(i>1)cout<<ans<<' ';\n                queue<int>que;que.emplace(a[i]);d[a[i]]=0;\n                for(;que.size();){\n                        int U=que.front();que.pop();\n                        for(int V:g[U]){\n                                int D=d[U]+1;\n                                if(D<d[V]&&D<ans)d[V]=D,que.emplace(V);\n                        }\n                }\n        }\n        cout<<'\\n';\n}\nsigned main(){\n        ios::sync_with_stdio(false);cin.tie(nullptr);\n        cin>>t;\n        while(t--)solve();\n        return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "divide and conquer",
        "graphs",
        "greedy",
        "math",
        "shortest paths",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Timofey and Black-White Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/111948",
    "editorial": "Letâs store for each vertex the minimum distance from it to the nearest\r\none, letâs call it . We will also store the global answer, which for\r\nobvious reasons does not increase, we will call it .Letâs now color the\r\nvertex , letâs set and run a depth first search from it. This DFS will\r\nvisit the vertices with . Let us consider the vertex and its neighbour .\r\nIf we can relax through , letâs do it and start from . Otherwise, has a\r\ncloser neighbour, letâs try to update the answer through it . Also, do\r\nnot forget to update the answer via from all vertices that we\r\nvisited.The correctness of the algorithm is obvious, letâs evaluate its\r\ntime complexity. It is easy to notice that after the first operations, .\r\nWe enter only the vertices, from which, firstly, does not exceed , and\r\nsecondly, was relaxed by the parent (that is, decreased by at least\r\n).So, we allowed ourselves a complete tree bypassing for the first\r\noperations, and then amortized performed no more than operations. The\r\nfinal asymptotics will be .\r\n",
    "hint": []
}