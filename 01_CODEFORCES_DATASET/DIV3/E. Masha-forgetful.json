{
    "link": "https://codeforces.com//contest/1624/problem/E",
    "problemId": "1256441",
    "problem_idx": "E",
    "shortId": "1624E",
    "contest_number": "1624",
    "problem_submissions": {
        "G": [
            142264977,
            142276263,
            142255328,
            142255380,
            142278979,
            142222438,
            142247481,
            142272907,
            142266089,
            142251678,
            142253083,
            142252160,
            142248179,
            142250137,
            142248523,
            142250039,
            142416148,
            142259210
        ],
        "F": [
            142255179,
            142272384,
            142268450,
            142243695,
            142285199,
            142258439,
            142236940,
            142264135,
            142393598,
            142331291,
            142248865,
            142296070,
            142276188,
            142284965,
            142276430,
            142260372
        ],
        "E": [
            142241464,
            142238534,
            142272316,
            142277777,
            142260025,
            142286074,
            142269495,
            142256319,
            142287785,
            142271217,
            142263215,
            142270151,
            142270566,
            142278137,
            142274750,
            142273040,
            142294098,
            142253958,
            142282423
        ],
        "D": [
            142225549,
            142220300,
            142226787,
            142230709,
            142223377,
            142265701,
            142282535,
            142273740,
            142234006,
            142223224,
            142236057,
            142230240,
            142221633,
            142230396,
            142243861,
            142238174,
            142223929,
            142233332,
            142233395,
            142227832
        ],
        "C": [
            142213147,
            142208364,
            142214903,
            142219856,
            142212618,
            142318538,
            142204231,
            142234937,
            142218849,
            142237305,
            142214526,
            142460843,
            142215423,
            142217168,
            142221355,
            142216799,
            142211503,
            142211985,
            142216819,
            142218405,
            142219857,
            142213500
        ],
        "B": [
            142197546,
            142199713,
            142206530,
            142215517,
            142199960,
            142202251,
            142206682,
            142220881,
            142202886,
            142198089,
            142210906,
            142196708,
            142210091,
            142205820,
            142205637,
            142211178,
            142207927,
            142211494,
            142209546
        ],
        "A": [
            142188870,
            142188452,
            142198531,
            142195180,
            142189107,
            142194205,
            142188426,
            142189618,
            142189485,
            142189892,
            142201064,
            142189063,
            142189404,
            142192459,
            142193156,
            142190543,
            142204194,
            142190164
        ]
    },
    "name": "E. Masha-forgetful",
    "statement": "Masha meets a new friend and learns his phone number s. She wants to\r\nremember it as soon as possible. The phone number is a string of length\r\nm that consists of digits from 0 to 9. The phone number may start with\r\n.Masha already knows n phone numbers (all numbers have the same length\r\nm). It will be easier for her to remember a new number if the s is\r\nrepresented as segments of numbers she already knows. Each such segment\r\nmust be of length , otherwise there will be too many segments and Masha\r\nwill get confused.For example, Masha needs to remember the number: s = \u201d\r\nand she already knows n = 4 numbers: \u201d, \u201d, \u201d, \u201d. You can represent s as\r\na 3 segment: \u201d of number one, \u201d of number two, and \u201d of number three.\r\nThere are other ways to represent s.Masha asks you for help, she asks\r\nyou to break the string s into segments of length 2 or more of the\r\nnumbers she already knows. If there are several possible answers, print\r\nof them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << ' ', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 1e3 + 10;\nconst int mod = 998244353;\nchar a[N][N];\nchar c[N];\nstruct pos {\n    int x, y, id;\n};\npos b[N * 2];\nint f[N];\nint s2i(char x, char y) {\n    return (x - '0') * 10 + y - '0';\n}\nint s2i(char x, char y, char z) {\n    return (x - '0') * 100 + (y - '0') * 10 + z - '0' + 1000;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < 2000; ++i) {\n            b[i].x = b[i].y = b[i].id = -1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            cin >> (a[i] + 1);\n            for (int j = 1; j <= m; ++j) {\n                if (j + 1 <= m) {\n                    int v = s2i(a[i][j], a[i][j + 1]);\n                    b[v].x = j;\n                    b[v].y = j + 1;\n                    b[v].id = i;\n                }\n                if (j + 2 <= m) {\n                    int v = s2i(a[i][j], a[i][j + 1], a[i][j + 2]);\n                    b[v].x = j;\n                    b[v].y = j + 2;\n                    b[v].id = i;\n                }\n            }\n        }\n        cin >> (c + 1);\n        memset(f, -1, sizeof f);\n        f[0] = 0;\n        for (int i = 1; i <= m; ++i) {\n            if (i - 2 >= 0 && f[i - 2] != -1 && b[s2i(c[i - 1], c[i])].id != -1) {\n                f[i] = i - 2;\n            }\n            if (i - 3 >= 0 && f[i - 3] != -1 && b[s2i(c[i - 2], c[i - 1], c[i])].id != -1) {\n                f[i] = i - 3;\n            }\n        }\n        if (f[m] == -1) {\n            cout << -1 << '\\n';\n        } else {\n            vector<pos> ans;\n            for (int i = m; i; i = f[i]) {\n                if (i - f[i] == 2) {\n                    ans.emplace_back(b[s2i(c[i - 1], c[i])]);\n                } else {\n                    ans.emplace_back(b[s2i(c[i - 2], c[i - 1], c[i])]);\n                }\n            }\n            reverse(ans.begin(), ans.end());\n            cout << ans.size() << '\\n';\n            for (auto& i : ans) {\n                cout << i.x << ' ' << i.y << ' ' << i.id << '\\n';\n            }\n        }\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "hashing",
        "implementation",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Masha-forgetful.json",
    "editorial_link": "https://codeforces.com//blog/entry/98942",
    "editorial": "The key idea is that any string of length greater than 3 can be obtained\r\nby concatenating strings of length or . Then when reading the data,\r\nremember all occurring substring of length and . There are at most . Now\r\nwe will count the dynamics on the prefix: if we can get the prefix of\r\nlength of phone by segments of length and of the known phones Masha.\r\nThen for the transition we need to look through the lengths and , then\r\ntake a substring of the corresponding length and find out whether such a\r\nstring occurred in the phones known to Masha.Then it will take or time\r\nto recalculate the dynamics, depending on the implementation. But it\r\nwill still take more time to read the data, so the final asymptotic will\r\nbe or .\r\n"
}