{
    "link": "https://codeforces.com//contest/1846/problem/E1",
    "problemId": "1999905",
    "problem_idx": "E1",
    "shortId": "1846E1",
    "contest_number": "1846",
    "problem_submissions": {
        "D": [
            212644561,
            212601869,
            212627940,
            212630796,
            212612008,
            212605457,
            212607036,
            212611321,
            212621249,
            212734960,
            212616654,
            212623428,
            212686759,
            212608967,
            212593345,
            212608113,
            212605022,
            212603622
        ],
        "C": [
            212643708,
            212590754,
            212597786,
            212637806,
            212599623,
            214976381,
            212594269,
            212592027,
            212594549,
            212623071,
            212602417,
            212609037,
            212589627,
            212599996,
            212584839,
            212597114,
            212594978,
            212592915
        ],
        "F": [
            212622545,
            212665462,
            212682260,
            212609400,
            212686828,
            212691684,
            212693145,
            212679766,
            212685268,
            212694899,
            212676430,
            212667305,
            212656670,
            212666460,
            212775385,
            212774487,
            212649190
        ],
        "G": [
            212619112,
            212649833,
            212653628,
            212587343,
            212666847,
            214992050,
            214991957,
            212665653,
            212663992,
            212653649,
            212664491,
            212735006,
            212682268,
            212688232,
            212639324,
            212635867,
            212663045,
            212661853,
            212662659,
            212670086
        ],
        "A": [
            212587490,
            212568900,
            212577930,
            212641869,
            212568823,
            212569846,
            212572480,
            212573171,
            212568754,
            212577603,
            212569523,
            212568240,
            212573791,
            212568987,
            212573789,
            212575418,
            212569442,
            212569804
        ],
        "E1": [
            212583884,
            212617316,
            212606448,
            212623115,
            212627434,
            212613908,
            212631957,
            212634362,
            212632579,
            212639238,
            212631656,
            212682549,
            212619469,
            212609399,
            212621056,
            212617657,
            212621413
        ],
        "E2": [
            212583611,
            212631229,
            212641088,
            212622205,
            212627031,
            212628097,
            212631648,
            212664333,
            212642292,
            212649427,
            213132515,
            212656109,
            212682093,
            212633331,
            212637787,
            212646679,
            213982829
        ],
        "B": [
            212579517,
            212579760,
            212584363,
            212640990,
            212582929,
            212579034,
            212579312,
            212580015,
            212584049,
            212590622,
            212582483,
            212573350,
            212580771,
            212574075,
            212585567,
            212583374,
            212575067,
            212577471
        ]
    },
    "name": "E1. Rudolf and Snowflakes  simple version ",
    "statement": "One winter morning, Rudolf was looking thoughtfully out the window,\r\nwatching the falling snowflakes. He quickly noticed a certain symmetry\r\nin the configuration of the snowflakes. And like a true mathematician,\r\nRudolf came up with a mathematical model of a snowflake.He defined a\r\nsnowflake as an undirected graph constructed according to the following\r\nrules: Initially, the graph has only one vertex. Then, more vertices are\r\nadded to the graph. The initial vertex is connected by edges to k new\r\nvertices (k > 1). Each vertex that is connected to only one other vertex\r\nis connected by edges to k more new vertices. This step should be done .\r\nThe smallest possible snowflake for k = 4 is shown in the figure. After\r\nsome mathematical research, Rudolf realized that such snowflakes may not\r\nhave any number of vertices. Help Rudolf check if a snowflake with n\r\nvertices can exist.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long root_n(long long n, int k)\n{\n\tlong long m = pow(n, (long double)1.0 / k);\n\twhile (pow(m, k) <= n) \n    m++;\n\tm--;\n\treturn m;\n}\n\nvoid solve()\n{\n  long long n;\n\tcin >> n;\n\n\n\tfor (int m = 3; m<65;++m)\n    {\n\t\tlong long k = root_n(n, m-1);\n\t\tif (k < 2) continue;\n\t\t__int128 nn = n;\n\t\tnn *= (k - 1);\n\t\tnn += 1;\n\t\twhile (nn % k == 0) nn /= k;\n\t\tif (nn == 1) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"NO\" << endl;\n\treturn;\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. Rudolf and Snowflakes  simple version .json",
    "editorial_link": "https://codeforces.com//blog/entry/118044",
    "editorial": "For the current given constraint you can precalculate whether it is\r\npossible to obtain each for some . To do this, we can iterate through\r\nall possible and for each of them calculate the values , , ..., , where\r\nis such that . For this version of problem it is enougth to calculete\r\nvaluse for .Note that the minimum number of snowflake layers is .\r\nTherefore, the calculations start from the value .We can store all the\r\nobtained values, for example, in a set. Alternatively, we can use an\r\narray called \"used\" and set the value in the array element with the\r\ncorresponding index for each obtained value.It is better to perform this\r\nprecalculation before iterating through the test cases.Then, for each\r\ntest, we only need to read the value of and check if we have obtained it\r\nin the precalculation described above.The time complexity of the\r\nsolution using a set is .The time complexity of the solution using the\r\n\"used\" array is .Here number of test cases.\r\n"
}