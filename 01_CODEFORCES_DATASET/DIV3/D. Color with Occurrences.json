{
    "link": "https://codeforces.com//contest/1714/problem/D",
    "problemId": "1490430",
    "problem_idx": "D",
    "shortId": "1714D",
    "contest_number": "1714",
    "problem_submissions": {
        "F": [
            166579305,
            166565691,
            166580443,
            166573014,
            166573474,
            166592525,
            166595105,
            166548029,
            166593205,
            166686575,
            166579941,
            166590847,
            166638992,
            167603752
        ],
        "D": [
            166555174,
            166529424,
            166533941,
            166553024,
            166532466,
            166537534,
            166569263,
            166563818,
            166546107,
            166686361,
            166550012,
            166577360,
            166525263,
            166545147,
            166538583,
            166541251,
            166536599,
            166539458,
            166766162,
            166567140,
            166550628,
            166541107
        ],
        "G": [
            166545336,
            166572008,
            166558804,
            166581190,
            166549499,
            166568428,
            166563357,
            166570492,
            166570829,
            166686732,
            166586648,
            166587656,
            166562027,
            166554683,
            166566856,
            166569305,
            166581306,
            166572830,
            166766125,
            166554830,
            166567931,
            166573074
        ],
        "E": [
            166529226,
            166550151,
            166552214,
            166540138,
            166557091,
            166551342,
            166540892,
            166583808,
            166558113,
            166686473,
            166559850,
            203226761,
            166572711,
            166543154,
            166563505,
            166554394,
            166558430,
            166551333,
            166551809,
            166536566,
            166532529,
            166559461
        ],
        "C": [
            166508236,
            166513547,
            166511820,
            166514654,
            166516790,
            166512293,
            166728853,
            166510608,
            166524319,
            166522144,
            166686237,
            166521175,
            166545986,
            166510036,
            166508148,
            166522114,
            166515443,
            166510078,
            166516228,
            166524460,
            166519794,
            166509906
        ],
        "B": [
            166507200,
            166510494,
            166509013,
            166507825,
            166510367,
            166509254,
            166728113,
            166507901,
            166516960,
            166518989,
            166685849,
            166514261,
            166539890,
            166507950,
            166506803,
            166510018,
            166509016,
            166508114,
            166511943,
            166508752,
            166512719,
            166508756
        ],
        "A": [
            166506659,
            166508343,
            166507357,
            166506909,
            166560580,
            166507658,
            166727935,
            166506862,
            166512344,
            166510563,
            166511944,
            166685755,
            166510846,
            166535694,
            166506790,
            166510397,
            166508153,
            166507023,
            166506968,
            166508973,
            166507229,
            166507722,
            166506864
        ]
    },
    "name": "D. Color with Occurrences",
    "statement": "You are given some text t and a set of n strings s_1, s_2,\r\ndots, s_n. In one step, you can choose any occurrence of any string s_i\r\nin the text t and color the corresponding characters of the text in red.\r\nFor example, if t=\r\ntexttt{bababa} and s_1=\r\ntexttt{ba}, s_2=\r\ntexttt{aba}, you can get t=\r\ncolor{red}{\r\ntexttt{ba}}\r\ntexttt{baba}, t=\r\ntexttt{b}\r\ncolor{red}{\r\ntexttt{aba}}\r\ntexttt{ba} or t=\r\ntexttt{bab}\r\ncolor{red}{\r\ntexttt{aba}} in one step.You want to color all the letters of the text t\r\nin red. When you color a letter in red again, it stays red.In the\r\nexample above, three steps are enough: Let’s color t[2\r\ndots 4]=s_2=\r\ntexttt{aba} in red, we get t=\r\ntexttt{b}\r\ncolor{red}{\r\ntexttt{aba}}\r\ntexttt{ba}; Let’s color t[1\r\ndots 2]=s_1=\r\ntexttt{ba} in red, we get t=\r\ncolor{red}{\r\ntexttt{baba}}\r\ntexttt{ba}; Let’s color t[4\r\ndots 6]=s_2=\r\ntexttt{aba} in red, we get t=\r\ncolor{red}{\r\ntexttt{bababa}}. Each string s_i can be applied any number of times (or\r\nnot at all). Occurrences for coloring can intersect\r\narbitrarily.Determine the minimum number of steps needed to color all\r\nletters t in red and how to do it. If it is impossible to color all\r\nletters of the text t in red, output .\r\n",
    "solutions": [
        "/*\nDiv 3, I literally don't care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=2e5+5,mod=1e9+7;\nstring s[11],t;\nll n,dp[N],ns;\nvector<ii> save[N];\nmap<string,ll> d;\nvoid solo()\n{\n   cin>>t>>n;\n   d.clear();\n   rep(i,1,n) cin>>s[i],d[s[i]]=i;\n   ns=t.size();\n   t=\".\"+t;\n   rep(i,1,ns) save[i].clear();\n   rep(i,1,ns) dp[i]=1e9;\n   rep(i,1,ns){\n       ll p=i;\n       reb(j,i,0){\n           string m=\"\";\n           rep(k,j,i) m+=t[k];\n           if (dp[i]>dp[j-1]+1 && d[m]){\n               save[i]=save[j-1];\n               save[i].pb({d[m],j});\n               dp[i]=save[i].size();\n           }\n           if (dp[j]<dp[p]+1) p=j;\n           if (d[m] && dp[p]+1<dp[i]){\n               save[i]=save[p];\n               save[i].pb({d[m],j});\n               dp[i]=save[i].size();\n           }\n       }\n   }\n   if (dp[ns]==1e9){\n       cout<<\"-1\\n\";\n       return;\n   }\n   cout<<save[ns].size()<<\"\\n\";\n   rv(i,save[ns]) cout<<i.F<<\" \"<<i.S<<\"\\n\";\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Color with Occurrences.json",
    "editorial_link": "https://codeforces.com//blog/entry/105549",
    "editorial": "The first step is to find the word that covers the maximum length\r\nprefix. If there is no such word, we cannot color the string.Then go\r\nthrough the positions inside the found prefix and find the next word,\r\nwhich is a tweak of , has the maximal length, and ends not earlier than\r\nthe previous found word, and not later than the text . If there is no\r\nsuch word, it is impossible to color .After the second word is found,\r\nsimilarly continue looking for the next ones.\r\n",
    "hint": []
}