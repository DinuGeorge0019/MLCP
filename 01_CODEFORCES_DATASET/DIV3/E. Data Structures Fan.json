{
    "link": "https://codeforces.com//contest/1872/problem/E",
    "problemId": "2198224",
    "problem_idx": "E",
    "shortId": "1872E",
    "contest_number": "1872",
    "problem_submissions": {
        "G": [
            222269305,
            222264289,
            222298879,
            222305481,
            222270629,
            222342415,
            222314228,
            222291632,
            222286722,
            222275567,
            222284367,
            222291047,
            222268166,
            222301101,
            222308831,
            222296849,
            222307124,
            222314609,
            222306727,
            222303618,
            222298039
        ],
        "F": [
            222253211,
            222274310,
            222263563,
            222275177,
            222283950,
            222342119,
            222263399,
            222275335,
            222259168,
            222301153,
            222293375,
            222280986,
            222289895,
            222284461,
            222268231,
            222282384,
            222274185,
            222276754,
            222273355,
            222290954
        ],
        "E": [
            222242579,
            222246400,
            222249497,
            222247597,
            222248802,
            222342265,
            222249154,
            222255647,
            222250780,
            222252960,
            222255367,
            222257063,
            222301644,
            222264271,
            222254606,
            222261852,
            222259585,
            222256505,
            222256891,
            222259676
        ],
        "D": [
            222233540,
            222240242,
            222235638,
            222238483,
            222241578,
            222341675,
            222240111,
            222249058,
            222245456,
            222243309,
            222249106,
            222245814,
            222245292,
            222248919,
            222247848,
            222246403,
            222250509,
            222246737,
            222246669,
            222248764
        ],
        "C": [
            222228280,
            222236162,
            222231841,
            222233925,
            222238951,
            222341397,
            222235622,
            222239086,
            222238021,
            222238244,
            222243551,
            222237799,
            222238155,
            222240804,
            222242295,
            222252499,
            222244345,
            222233052,
            222239640,
            222243679
        ],
        "B": [
            222223320,
            222228834,
            222223279,
            222226962,
            222230878,
            222341232,
            222228304,
            222229555,
            222234022,
            222230767,
            222235368,
            222229693,
            222228951,
            222233130,
            222233112,
            222230666,
            222236695,
            222242522,
            222228111,
            222239768
        ],
        "A": [
            222220034,
            222220138,
            222220149,
            222220934,
            222220877,
            222220135,
            222220624,
            222220385,
            222220004,
            222220348,
            222220097,
            222222211,
            222223046,
            222220972,
            222222909,
            222223854,
            222229902,
            222220171,
            222223172
        ]
    },
    "name": "E. Data Structures Fan",
    "statement": "You are given an array of integers a_1, a_2,\r\nldots, a_n, as well as a binary string^{\r\ndagger} s consisting of n characters.Augustin is a big fan of data\r\nstructures. Therefore, he asked you to implement a data structure that\r\ncan answer q queries. There are two types of queries: \"1 l r\" (1\r\nle l\r\nle r\r\nle n) replace each character s_i for l\r\nle i\r\nle r with its opposite. That is, replace all\r\ntexttt{0} with\r\ntexttt{1} and all\r\ntexttt{1} with\r\ntexttt{0}. \"2 g\" (g\r\nin\r\n{0, 1\r\n}) calculate the value of the bitwise XOR of the numbers a_i for all\r\nindices i such that s_i = g. Note that the\r\noperatorname{XOR} of an empty set of numbers is considered to be equal\r\nto 0.Please help Augustin to answer all the queries!For example, if n =\r\n4, a = [1, 2, 3, 6], s =\r\ntexttt{1001}, consider the following series of queries: \"2 0\" we are\r\ninterested in the indices i for which s_i =\r\ntt{0}, since s =\r\ntt{1001}, these are the indices 2 and 3, so the answer to the query will\r\nbe a_2\r\noplus a_3 = 2\r\noplus 3 = 1. \"1 1 3\" we need to replace the characters s_1, s_2, s_3\r\nwith their opposites, so before the query s =\r\ntt{1001}, and after the query: s =\r\ntt{0111}. \"2 1\" we are interested in the indices i for which s_i =\r\ntt{1}, since s =\r\ntt{0111}, these are the indices 2, 3, and 4, so the answer to the query\r\nwill be a_2\r\noplus a_3\r\noplus a_4 = 2\r\noplus 3\r\noplus 6 = 7. \"1 2 4\" s =\r\ntt{0111}\r\nto s =\r\ntt{0000}. \"2 1\" s =\r\ntt{0000}, there are no indices with s_i =\r\ntt{1}, so since the\r\noperatorname{XOR} of an empty set of numbers is considered to be equal\r\nto 0, the answer to this query is 0.^{\r\ndagger} A binary string is a string containing only characters\r\ntexttt{0} or\r\ntexttt{1}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\n#define pll pair<ll,ll>\n\nstruct SEG {\n    vector<pll> arr;\n    vector<bool> tswap;\n\n    void make(ll n) {\n        arr.resize(4*n);\n        tswap.resize(4*n);\n    }\n\n    void pull(ll v) {\n        arr[v] = arr[v*2];\n        arr[v].first ^= arr[v*2+1].first;\n        arr[v].second ^= arr[v*2+1].second;\n    }\n\n    void dswap(ll v) {\n        tswap[v] = !tswap[v];\n        swap(arr[v].first, arr[v].second);\n    }\n\n    void push(ll v) {\n        if (tswap[v]) {\n            dswap(v*2);\n            dswap(v*2+1);\n            tswap[v] = 0;\n        }\n    }\n\n    void set(ll v, ll tl, ll tr, ll ind, pll val) {\n        if (tl == tr) {\n            arr[v] = val;\n            return;\n        }\n        ll tm = (tl + tr) / 2;\n        if (ind <= tm)\n            set(v*2, tl, tm, ind, val);\n        else set(v*2+1, tm+1, tr, ind, val);\n        pull(v);\n    }\n\n    void rswap(ll v, ll tl, ll tr, ll l, ll r) {\n        if (l > r) return;\n        if (tl == l && tr == r) {\n            dswap(v);\n            return;\n        }\n        push(v);\n        ll tm = (tl + tr) / 2;\n        rswap(v*2, tl, tm, l, min(r, tm));\n        rswap(v*2+1, tm+1, tr, max(l,tm+1), r);\n        pull(v);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        SEG seg;\n        seg.make(n);\n        for (ll i = 0; i < n; i++) {\n            ll v;\n            cin >> v;\n            seg.set(1, 0, n-1, i, {v, 0});\n        }\n        for (ll i = 0; i < n; i++) {\n            char c;\n            cin >> c;\n            if (c == '1') seg.rswap(1, 0, n-1, i, i);\n        }\n        ll q;\n        cin >> q;\n        while (q--) {\n            ll t;\n            cin >> t;\n            if (t == 1) {\n                ll l, r;\n                cin >> l >> r;\n                seg.rswap(1, 0, n-1, l-1, r-1);\n            } else {\n                ll g;\n                cin >> g;\n                if (g == 0) {\n                    cout << seg.arr[1].first << ' ';\n                } else {\n                    cout << seg.arr[1].second << ' ';\n                }\n            }\n        }\n        cout << '\\n';\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "dp"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Data Structures Fan.json",
    "editorial_link": "https://codeforces.com//blog/entry/120165",
    "editorial": "Of course this problem has solutions that use data structures. For\r\nexample, you can use a segment tree with range updates to solve it in\r\ntime, or you can use a square root decomposition to solve it in\r\ntime.However, of course, we do not expect participants in Div3 to have\r\nknowledge of these advanced data structures, so there is a simpler\r\nsolution.We will store 2 variables: , which represent the XOR of all\r\nnumbers from group and group , respectively. When answering a query of\r\ntype 2, we will simply output either or . Now we need to understand how\r\nto update and after receiving a query of type 1.Letâs first solve a\r\nsimplified version: suppose that in type 1 queries, only a single\r\ncharacter of the string is inverted, i.e., in all type 1 queries.Letâs\r\nsee how and change after this query. If was and became , then the number\r\nwill be removed from group . So, we need to invert \"XOR \" from . Since\r\nXOR is its own inverse operation (), we can do this with . And in , we\r\nneed to add the number , since now . And we can do this with .The same\r\nthing happens if was .This is the key observation: when we invert , and\r\nchange in the same way, regardless of whether this inversion was from to\r\nor from to .Therefore, to update and after a query of type 1 with\r\nparameters , we need to do this: , and the same for .To quickly find the\r\nXOR value on a subsegment of the array , we can use a prefix XOR array.\r\nIf , then: .\r\n",
    "hint": []
}