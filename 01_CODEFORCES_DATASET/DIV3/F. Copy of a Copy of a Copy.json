{
    "link": "https://codeforces.com//contest/1772/problem/F",
    "problemId": "1699973",
    "problem_idx": "F",
    "shortId": "1772F",
    "contest_number": "1772",
    "problem_submissions": {
        "G": [
            185866908,
            185868804,
            185873335,
            185913962,
            185953726,
            185952520,
            186850297,
            186850227
        ],
        "F": [
            185855303,
            185865062,
            185861633,
            185852805,
            185857933,
            185851728,
            185860856,
            185855787,
            185864352,
            185856328,
            185859258,
            185858451,
            185854822,
            185861128,
            185859138,
            185859632,
            185864434,
            185848000
        ],
        "E": [
            185833320,
            185824865,
            185853135,
            185836538,
            185842386,
            185826244,
            185841572,
            185838582,
            185836735,
            185840815,
            185835557,
            185845402,
            185841206,
            185838785,
            185849100,
            185834339,
            185850985,
            185860647
        ],
        "D": [
            185819090,
            185847079,
            185843120,
            185824661,
            185823461,
            185842011,
            185826918,
            185829038,
            185828215,
            185825456,
            185830337,
            185829367,
            185832845,
            185833254,
            185834612,
            216833286,
            185829200,
            185833219,
            185836837
        ],
        "C": [
            185812558,
            185814879,
            185826142,
            185808094,
            185813274,
            185814811,
            185816864,
            185820487,
            185822215,
            185810534,
            185819302,
            185820777,
            185825870,
            185828411,
            185818012,
            185822938,
            185815452,
            185822870
        ],
        "B": [
            185806303,
            185808530,
            185810358,
            185820249,
            185807477,
            185807452,
            185807615,
            185812963,
            185808450,
            185814127,
            185808442,
            185811020,
            185818101,
            185811312,
            185806644,
            185817751,
            185807928,
            185811595
        ],
        "A": [
            185798273,
            185798668,
            185799351,
            185798230,
            185798228,
            185798156,
            185800228,
            185799343,
            185809092,
            185800941,
            185802793,
            185811122,
            185800618,
            185798345,
            185801366,
            185799187,
            185805016
        ]
    },
    "name": "F. Copy of a Copy of a Copy",
    "statement": "It all started with a black-and-white picture, that can be represented\r\nas an n\r\ntimes m matrix such that all its elements are either 0 or 1. The rows\r\nare numbered from 1 to n, the columns are numbered from 1 to m.Several\r\noperations were performed on the picture (possibly, zero), each of one\r\nof the two kinds: choose a cell such that it\u2019s not on the border\r\n(neither row 1 or n, nor column 1 or m) and it\u2019s surrounded by four\r\ncells of the opposite color (four zeros if it\u2019s a one and vice versa)\r\nand paint it the opposite color itself; make a copy of the current\r\npicture. Note that the order of operations could be arbitrary, they were\r\nnot necessarily alternating.You are presented with the outcome: all k\r\ncopies that were made. Additionally, you are given the initial picture.\r\nHowever, all k+1 pictures are shuffled.Restore the sequence of the\r\noperations. If there are multiple answers, print any of them. The tests\r\nare constructed from the real sequence of operations, i. e. at least one\r\nanswer always exists.\r\n",
    "solutions": [
        "/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll int\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=100+5,mod=1e9+7;\nll n,m,k,dd[31][31],onto[N],a[N];\nchar c[107][31][31],mar[31][31];\nll dx[4]={-1,0,0,1};\nll dy[4]={0,-1,1,0};\nvector<ii> res;\nbool filled (ll id, ll x, ll y){\n    return (c[id][x][y]!=c[id][x-1][y] && c[id][x][y]!=c[id][x+1][y] && c[id][x][y]!=c[id][x][y-1] && c[id][x][y]!=c[id][x][y+1]);\n}\nvoid elixprep(){\n    \n}\nbool check (ll idx, ll idy){\n    rep(i,1,n)\n    rep(j,1,m) dd[i][j]=0;\n    rep(i,1,n)\n    rep(j,1,m) if (c[idx][i][j]!=c[idy][i][j]) dd[i][j]=1;\n    rep(i,1,n)\n    rep(j,1,m) mar[i][j]=c[idx][i][j];\n    queue<ii> qe;\n    rep(i,2,n-1)\n    rep(j,2,m-1) if (dd[i][j] && filled(idx,i,j)) qe.push({i,j});\n    vector<ii> all;\n    while (!qe.empty()){\n        auto[x,y]=qe.front();\n        qe.pop();\n        all.pb({x,y});\n\n        if (c[idx][x][y]=='1') c[idx][x][y]='0';\n        else c[idx][x][y]='1';\n        dd[x][y]=0;\n        rep(l,0,3){\n            ll u=x+dx[l],v=y+dy[l];\n            if (u!=1 && v!=1 && u!=n && v!=m && filled(idx,u,v) && dd[u][v]) qe.push({u,v});\n        }\n    }\n    bool ok=1;\n    rep(i,1,n)\n    rep(j,1,m) if (dd[i][j]==1) ok=0;\n    rep(i,1,n)\n    rep(j,1,m) c[idx][i][j]=mar[i][j];\n    return ok;\n}\nvoid ini (ll idx, ll idy){\n    rep(i,1,n)\n    rep(j,1,m) dd[i][j]=0;\n    rep(i,1,n)\n    rep(j,1,m) if (c[idx][i][j]!=c[idy][i][j]) dd[i][j]=1;\n    rep(i,1,n)\n    rep(j,1,m) mar[i][j]=c[idx][i][j];\n    queue<ii> qe;\n    rep(i,2,n-1)\n    rep(j,2,m-1) if (dd[i][j] && filled(idx,i,j)) qe.push({i,j});\n    vector<ii> all;\n    while (!qe.empty()){\n        auto[x,y]=qe.front();\n        qe.pop();\n        res.pb({x,y});\n        if (c[idx][x][y]=='1') c[idx][x][y]='0';\n        else c[idx][x][y]='1';\n        dd[x][y]=0;\n        rep(l,0,3){\n            ll u=x+dx[l],v=y+dy[l];\n            if (u!=1 && v!=1 && u!=n && v!=m && filled(idx,u,v) && dd[u][v]) qe.push({u,v});\n        }\n    }\n    rep(i,1,n)\n    rep(j,1,m) c[idx][i][j]=mar[i][j];\n}\nbool cmp (ll x, ll y){\n    return check(x,y);\n}\nvoid elix()\n{\n    cin>>n>>m>>k;\n    rep(i,1,k+1) \n    rep(j,1,n)\n    rep(l,1,m) cin>>c[i][j][l];\n    rep(i,1,k+1) a[i]=i;\n    sort(a+1,a+k+2,cmp);\n    ll cur=a[1];\n    rep(i,2,k+1) check(a[i],a[i+1]);\n    rep(i,1,k) onto[a[i]]=a[i+1];\n    cout<<cur<<\"\\n\";\n    while(true){\n        if (onto[cur]==0) break;\n        ini(cur,onto[cur]);\n        res.pb({onto[cur],0});\n        cur=onto[cur];\n    }\n    cout<<res.size()<<\"\\n\";\n    rv(i,res) if (i.S==0) cout<<2<<\" \"<<i.F<<\"\\n\";\n    else cout<<1<<\" \"<<i.F<<\" \"<<i.S<<\"\\n\";\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    //cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}\n//listen to trap music. it won't help"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "implementation",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Copy of a Copy of a Copy.json",
    "editorial_link": "https://codeforces.com//blog/entry/110313",
    "editorial": "Notice the following: once you apply the recolor operation to some cell,\r\nyou can never recolor it again. That happens because you can\u00e2\u0080\u0099t recolor\r\nits neighbors too as each of them has at least one neighbor of the same\r\ncolor this cell itself.In particular, that implies that applying a\r\nrecolor operation always decreases the possible number of operations\r\nthat can be made currently. It doesn\u00e2\u0080\u0099t always decrease them by : from to\r\noperations can become unavailable, but it always decreases.That gives us\r\nan order of copies. Just sort them in the decreasing order of the number\r\nof recolor operations that can be made currently. If the numbers are the\r\nsame, the copies must be equal, so their order doesn\u00e2\u0080\u0099t matter.The only\r\nthing remains is to apply the operations. Turns out, their order doesn\u00e2\u0080\u0099t\r\nmatter at all. Consider all different cells for a pair of adjacent\r\npictures. It\u00e2\u0080\u0099s never possible that there are two different cells that\r\nare adjacent to each other. Thus, no operation can interfere with\r\nanother one. Just print all positions of different cells in any order\r\nyou want and make a copy.Overall complexity: .\r\n"
}