{"link": "https://codeforces.com//contest/1367/problem/F2", "problemId": "650999", "problem_idx": "F2", "shortId": "1367F2", "contest_number": "1367", "problem_submissions": {"F2": [84046399, 84094199, 84130636], "F1": [83980407, 83997753, 83993348, 83994650, 83999567, 84010715, 83998236, 84003996, 84009140, 84019849, 84274779, 84017193, 84019354, 84000999, 84010593, 84016471, 84014906, 84016930, 84014876, 84014935, 84017986], "D": [83971043, 83961145, 83985812, 83980115, 83973000, 83974852, 83986130, 83981366, 83974367, 83994623, 83977600, 83983323, 83996104, 83995930, 83983801, 83992346, 83994322, 83998169, 84019878, 83994750], "E": [83960157, 83975668, 83972713, 83967919, 83987024, 83979496, 83979914, 83997028, 83998395, 83978103, 83986303, 83992757, 84009544, 83998141, 84003322, 84000422, 84009434, 84005956, 84009927], "C": [83944345, 83953190, 83946330, 83950349, 83947422, 83950879, 83948329, 83963053, 83957928, 83954873, 83961995, 83964648, 83957400, 83955873, 83978101, 83977835, 83962124, 83950317, 83977481], "B": [83935714, 83939461, 83936897, 83955137, 83937279, 83939068, 83931855, 83950510, 83942524, 83939871, 83953252, 83938559, 83937149, 83961120, 83949153, 83945426, 83942777, 83939545, 83950410], "A": [83931489, 83931768, 83931529, 83932839, 83931493, 83933565, 83935945, 83942834, 83934889, 83933081, 83935891, 83931997, 83932187, 83932611, 83934727, 83936848, 83932660, 83932129, 83932693]}, "name": "F2. Flying Sort  Hard Version ", "statement": "You are given an array a of n integers . You can perform the following\r\noperations on array elements: choose any index i (1\r\nle i\r\nle n) and move the element a[i] to the of the array; choose any index i\r\n(1\r\nle i\r\nle n) and move the element a[i] to the of the array. For example, if n =\r\n5, a = [4, 7, 2, 2, 9], then the following sequence of operations can be\r\nperformed: after performing the operation of the first type to the\r\nsecond element, the array a will become [7, 4, 2, 2, 9]; after\r\nperforming the operation of the second type to the second element, the\r\narray a will become [7, 2, 2, 9, 4]. You can perform operations of any\r\ntype any number of times in any order.Find the minimum total number of\r\noperations of the first and second type that will make the a array\r\nsorted in non-decreasing order. In other words, what is the minimum\r\nnumber of operations must be performed so the array satisfies the\r\ninequalities a[1]\r\nle a[2]\r\nle\r\nldots\r\nle a[n].\r\n", "solutions": ["#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int mx = 400005;\nconst int N = mx; \nint n = N;  \nint t[2 * N];\nvoid modify(int p, ll value) {  \n  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = max(t[p] , t[p^1]);\n}\n \nint query(int l, int r) {  \n  int res = -2e9;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l&1) res =max(res, t[l++]);\n    if (r&1) res =max(res, t[--r]);\n  }\n  return res;\n}\nmap<int,int> mp,mp1,cnt,tot;\nint tst = 0;\nvoid f()\n{\n    mp.clear();\n    mp1.clear();\n    tot.clear();\n    cnt.clear();\n    int n;\n    cin >> n;\n    int dp[n + 1] = {0};\n    int arr[n + 1];\n    arr[0] = -5;\n    vector<int> comp;\n    fl(i,1,n + 1)\n    {\n     //   if(tst == 14999)\n        \n        cin >> arr[i];\n        tot[arr[i]]++;\n        comp.pb(arr[i]);\n    }\n    sort(comp.begin(), comp.end());\n    int mxn = 2e9;\n    fl(i,1,n + 1)\n    {\n        int x = arr[i];\n        mxn = min(mxn,x);\n    //  cout << arr[i] << \" \";\n        arr[i] = lower_bound(comp.begin(), comp.end(),arr[i]) - comp.begin() + 1;\n        arr[i] += mp[x];\n    //  cout << arr[i] << endl;\n        mp1[arr[i]] = x;\n        mp[x]++;\n    }\n    fl(i,0,n + 4)\n    {\n        modify(i,0);\n    }\n    fl(i,1,n + 1)\n    {\n        dp[i] = 0;\n    }\n    int ans = 0;\n    fl(i,1,n + 1)\n    {\n        dp[i] = 1;\n        int x = arr[i];\n        int org = mp1[x];\n        int id = lower_bound(comp.begin(), comp.end(),org) - comp.begin();\n        id--;\n        int tmp = 0;\n        int val = query(x - 1,x);\n    //    cout << val << endl;\n        dp[i] = val + 1;\n \n        if(id >= 0 && cnt[org] == 0)\n        {\n            tmp = comp[id];\n            dp[i] = max(dp[i], cnt[tmp] + 1);\n        }\n        modify(x,dp[i]);\n        ans = max(ans,dp[i]);\n        int nxt = upper_bound(comp.begin(), comp.end(),org) - comp.begin();\n        if(nxt < comp.size() && (cnt[org] + 1 == tot[org] || cnt[org] + 1 == dp[i]))\n        {\n            nxt = comp[nxt];\n            ans = max(ans,dp[i] + tot[nxt] - cnt[nxt]);\n        }\n   //     cout << arr[i] << \" \" << dp[i] << \" \" << ans <<   endl;\n        cnt[org]++;\n        ans = max(ans,cnt[org]);\n    }\n    fl(i,0,n + 1)\n    {\n    //  cout << arr[i] << endl;\n        modify(arr[i],0);\n    }\n    assert(ans <= n);\n    cout << n - ans << endl;\n}\nmain()\n{\n    khushi;\n    int t = 1;\n    cin >> t;\n    while(t--)\n    {\n        f();\n    }\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "dp", "greedy", "sortings", "two pointers"], "dificulty": "2400", "interactive": false}