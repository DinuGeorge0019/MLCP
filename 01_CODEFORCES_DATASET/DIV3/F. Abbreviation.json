{"link": "https://codeforces.com//contest/1003/problem/F", "problemId": "194986", "problem_idx": "F", "shortId": "1003F", "contest_number": "1003", "problem_submissions": {"E": [39924193, 39917808, 39923474, 39917540, 39932885, 39926804, 39919143, 39925938, 39924942, 39926556, 39916485, 39925183, 39923509, 39920705, 39924767, 39925403, 39927398, 39926899], "F": [39919506, 39935298, 39943902, 40106973, 40297506, 39953456, 39925614, 39922839], "C": [39912024, 39905824, 39904178, 39906213, 39904627, 42751959, 39907680, 39905143, 39911684, 39902878, 39905375, 39904334, 39906247, 39910129, 39910619, 39907113, 39906670, 39906706, 39905022, 39908497], "B": [39905186, 39902197, 39901483, 39902052, 39901889, 39904203, 39903228, 39903078, 39906991, 39902754, 39902358, 39904660, 39907858, 39906542, 39904875, 39903839, 39904869, 39907658, 39906314], "D": [39904096, 39911298, 39910719, 39910712, 39908080, 42751939, 39912030, 39914322, 39908951, 39910733, 39921416, 39908636, 39908754, 39914171, 39914980, 39914769, 39914559, 39912864, 39917039, 39913107], "A": [39900356, 39897220, 39898269, 39897962, 39896936, 39904258, 39898551, 39897613, 39900244, 39896869, 39897844, 39899297, 39896960, 39897545, 39899825, 39897411, 39897414, 39897064, 39897008]}, "name": "F. Abbreviation", "statement": "You are given a text consisting of n space-separated words. There is\r\nexactly one space character between any pair of adjacent words. There\r\nare no spaces before the first word and no spaces after the last word.\r\nThe length of text is the number of letters and spaces in it. w_i is the\r\ni-th word of text. All words consist only of lowercase Latin\r\nletters.Let\u2019s denote a segment of words w[i..j] as a sequence of words\r\nw_i, w_{i + 1},\r\ndots, w_j. Two segments of words w[i_1 .. j_1] and w[i_2 .. j_2] are\r\nconsidered if j_1 - i_1 = j_2 - i_2, j_1\r\nge i_1, j_2\r\nge i_2, and for every t\r\nin [0, j_1 - i_1] w_{i_1 + t} = w_{i_2 + t}. For example, for the text\r\n\"\" the segments w[1..2] and w[5..6] are equal, they correspond to the\r\nwords \"\".An abbreviation is a replacement of some segments of words with\r\ntheir first letters. In order to perform an abbreviation, you have to\r\nchoose non-intersecting equal segments of words, and replace each chosen\r\nsegment with the string consisting of first letters of the words in the\r\nsegment (written in uppercase). For example, for the text \"\" you can\r\nreplace segments of words w[2..4] and w[6..8] with an abbreviation \"\"\r\nand obtain the text \"\", or you can replace segments of words w[2..5] and\r\nw[6..9] with an abbreviation \"\" and obtain the text \"\".What is the\r\nminimum length of the text after at most one abbreviation?\r\n", "solutions": ["#include \"bits/stdc++.h\"\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<\"----------------\"<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<\" = \"<< x<<endl;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nconst int N=303;\nint par[N][N];\nint sz[N];\nchar s[N][MAXN];\nbool h[N][N][N],ok[N][N];\nint mod(ll x){\n\treturn (x%INF);\n}\nbool equal(int x,int y){\n\tif(sz[x]!=sz[y])\n\t\treturn 0;\n\tfor(int i=0;i<sz[x];i++)\n\t\tif(s[x][i]!=s[y][i])\n\t\t\treturn 0;\n\treturn 1;\t\t\n}\nint main(){\n    //~ freopen(\"file.in\", \"r\", stdin);\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n\t\tscanf(\"%s\",s[i]);\n\t\tsz[i]=strlen(s[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tpar[i][i]=sz[i];\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tpar[i][j]=par[i][j-1]+sz[j]+1;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tok[i][j]=equal(i,j);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(j+k>n or i+k>n or !ok[i+k-1][j+k-1])\n\t\t\t\t\tbreak;\n\t\t\t\th[i][j][k]=1;\t\n\t\t\t}\n\tint ans=par[0][n-1];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j+i<=n;j++){\n\t\t\tint now=j+i,cnt=1;\n\t\t\twhile(now+i<=n){\n\t\t\t\tif(h[j][now][i])\n\t\t\t\t\tnow+=i,cnt++;\n\t\t\t\telse\n\t\t\t\t\tnow++;\n\t\t\t\tif(cnt>=2)\n\t\t\t\t\tumin(ans,par[0][n-1]-cnt*par[j][j+i-1]+cnt*i);\t\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",ans);\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "hashing", "strings"], "dificulty": "2200", "interactive": false}