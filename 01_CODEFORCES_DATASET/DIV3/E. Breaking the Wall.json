{
    "link": "https://codeforces.com//contest/1674/problem/E",
    "problemId": "1387201",
    "problem_idx": "E",
    "shortId": "1674E",
    "contest_number": "1674",
    "problem_submissions": {
        "G": [
            155646371,
            155678319,
            155682648,
            155674622,
            155685706,
            155652398,
            155774505,
            155758418,
            155756941,
            155756549,
            155813512,
            155812905,
            155812142,
            155668112,
            155672472,
            155679227
        ],
        "E": [
            155631011,
            155634103,
            155643152,
            155675920,
            155631080,
            155651713,
            155617544,
            155694232,
            155715039,
            155714839,
            155714791,
            155637067,
            155642168,
            155638571,
            155649103,
            155635417,
            155641093,
            155646304,
            155721408,
            155721277,
            155636472,
            155697116,
            155650091,
            155644616
        ],
        "D": [
            155618739,
            155613748,
            155616684,
            155656367,
            155626968,
            155608446,
            155610953,
            155612083,
            155611734,
            155659957,
            155623954,
            155619138,
            155624149,
            155621266,
            155624757,
            155627320,
            155618076,
            155634919,
            155611685,
            155616988
        ],
        "F": [
            155617525,
            155657845,
            155669742,
            155653200,
            155666820,
            155638184,
            155625715,
            155652009,
            155672980,
            155630184,
            155664338,
            155667869,
            155668832,
            155674578,
            155651745,
            155669165,
            155649876,
            155663032,
            155653319,
            155665427
        ],
        "C": [
            155604778,
            155603079,
            155604115,
            155615008,
            155611152,
            155601227,
            155598610,
            155598459,
            155599303,
            155601929,
            155605133,
            155602572,
            155609155,
            155606549,
            155606406,
            155613995,
            155599916,
            155616867,
            155601683,
            155604335
        ],
        "B": [
            155596261,
            155597272,
            155595696,
            155604402,
            155605300,
            155597345,
            155593808,
            155599168,
            155593898,
            155596784,
            155597719,
            155597183,
            155602563,
            155597000,
            155600384,
            155600158,
            155595285,
            155605630,
            155596236,
            155595482
        ],
        "A": [
            155592021,
            155592145,
            155591844,
            155602088,
            155598548,
            155592326,
            155591501,
            155592241,
            155591537,
            155593757,
            155591678,
            155592049,
            155596267,
            155592804,
            155593311,
            155594974,
            155592005,
            155594331,
            155593247,
            155592088
        ]
    },
    "name": "E. Breaking the Wall",
    "statement": "Monocarp plays \"Rage of Empires II: Definitive Edition\" a strategic\r\ncomputer game. Right now he’s planning to attack his opponent in the\r\ngame, but Monocarp’s forces cannot enter the opponent’s territory since\r\nthe opponent has built a wall.The wall consists of n sections, aligned\r\nin a row. The i-th section initially has durability a_i. If durability\r\nof some section becomes 0 or less, this section is considered broken.To\r\nattack the opponent, Monocarp needs to break at least two sections of\r\nthe wall (any two sections: possibly adjacent, possibly not). To do\r\nthis, he plans to use an onager a special siege weapon. The onager can\r\nbe used to shoot any section of the wall; the shot deals 2 damage to the\r\ntarget section and 1 damage to adjacent sections. In other words, if the\r\nonager shoots at the section x, then the durability of the section x\r\ndecreases by 2, and the durability of the sections x - 1 and x + 1 (if\r\nthey exist) decreases by 1 each. Monocarp can shoot at any sections any\r\nnumber of times, .Monocarp wants to calculate the minimum number of\r\nonager shots needed to break at least two sections. Help him!\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n \nusing namespace std;\n \nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n \n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n \n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n \n#define pb                          push_back\n \n#define pry                         puts(\"YES\")\n#define prn                         puts(\"NO\")\n#define endl                        '\\n'\n \n#define fst                         first\n#define scn                         second\n \n#define int long long\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<int>a(n);\n    forn(i,n)cin>>a[i];\n    vector<int>b=a;\n    sort(all(b));\n    int ans = (b[0]+1)/2+(b[1]+1)/2;\n\n    for(int i=0;i+1<n;i++){\n        int x=a[i],y=a[i+1];\n        if(x>y)swap(x,y);\n        if(y>=2*x){\n            ans=min(ans,(y+1)/2);\n            continue;\n        }\n        int pp = y-x;\n        y-=pp*2;\n        x-=pp;\n        int now = pp+x/3*2+x%3;\n        ans=min(ans,now);\n    }\n    for(int i=0;i+2<n;++i){\n        int x=a[i],y=a[i+2];\n        if(x>y)swap(x,y);\n        int now=x/2+y/2;\n        x%=2,y%=2;\n        if(x || y) ++now;\n        ans=min(ans,now);\n    }\n    cout<<ans<<endl;\n}\n \nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while(t--)\n        solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Breaking the Wall.json",
    "editorial_link": "https://codeforces.com//blog/entry/102482",
    "editorial": "Letâs analyze three cases based on the distance between two sections we\r\nare going to break: break two neighboring sections ( and ); break two\r\nsections with another section between them ( and ); break two sections\r\nwith more than one section between them. Why exactly these cases?\r\nBecause the damage from the shots and the possibility to hit both\r\nsections with the same shot depends on the distance between them.If\r\nthere is more than one section between the two we want to break, then\r\nany shot hits only one of these sections, so each shot should be aimed\r\nat one of those sections, and we break them independently. Letâs pick\r\ntwo sections with minimum durability and calculate the number of shots\r\nrequired to break them; if these sections are and , then the required\r\nnumber of shots is . It actually does not matter if the distance between\r\nthem is less than ; if it is so, these sections will be analyzed in one\r\nof the other cases.Okay, now letâs deal with two sections having exactly\r\none section between them. We can iterate on all combinations of these\r\nsections (iterate on from to and pick sections and ). Letâs analyze how\r\ncan we damage them. If we shoot at the section between them, we deal\r\ndamage to both sections; if we shoot at one of those sections, we deal\r\ndamage to it and damage to the other section. So, each shot distributes\r\ndamage between these two sections the way we want to distribute it, and\r\nthe number of shots required to break these two sections is .The case\r\nwhen we try to break two adjacent sections is the trickiest one. Letâs\r\nsay that these sections are and , , and . If we target one of these\r\nsections, we deal damage to it and damage to the other section. Letâs\r\ntry to run the following algorithm: shoot at the section with higher\r\ndurability, until both of them break. It can be slow, but we can see\r\nthat after the first shots, the durabilities of the sections become\r\nequal, and each pair of shots after that deals damage to both sections.\r\nSo, we can model the first shots, subtract from and from , and then\r\nweâll need shots. The only case when this doesnât work is if we break\r\nboth sections before we equalize their durabilities; it means that and\r\nwe need to do only shots.\r\n",
    "hint": []
}