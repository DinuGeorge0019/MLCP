{
    "link": "https://codeforces.com//contest/1729/problem/E",
    "problemId": "1538786",
    "problem_idx": "E",
    "shortId": "1729E",
    "contest_number": "1729",
    "problem_submissions": {
        "G": [
            171909059,
            171928158,
            171929650,
            171937957,
            171943890,
            171891847,
            177449161,
            177445327,
            172241447,
            172480345
        ],
        "F": [
            171894944,
            171892697,
            171881447,
            171902682,
            171920680,
            171910535,
            171878146,
            171906331,
            171923271,
            171910232,
            171914792,
            171908912,
            171906528,
            171914845,
            171906947,
            171906893,
            171920671,
            171915782,
            171919661
        ],
        "E": [
            171877179,
            171875756,
            171902704,
            171910299,
            171904162,
            171875139,
            171920658,
            171889898,
            171889626,
            171887188,
            171887680,
            171887875,
            171890844,
            171886351,
            171876648,
            171892405,
            171885680
        ],
        "D": [
            171861022,
            171860553,
            171863068,
            171871491,
            171878349,
            171858368,
            171848378,
            171874244,
            171864332,
            171876318,
            171869512,
            171878854,
            171871746,
            171875870,
            171867532,
            171863495,
            171872346,
            171873328
        ],
        "C": [
            171852852,
            171855742,
            171858347,
            171863945,
            171872549,
            171852373,
            171871529,
            171858052,
            171858976,
            171859379,
            171861408,
            171866242,
            171860889,
            171865107,
            171859758,
            171855447,
            171858502,
            171863966
        ],
        "B": [
            171845132,
            171847312,
            171845642,
            171852489,
            171856806,
            171841700,
            171849120,
            171848235,
            171844034,
            171844485,
            171847383,
            171849511,
            171849845,
            171851995,
            171846552,
            171848340,
            171844748,
            171850134
        ],
        "A": [
            171834897,
            171837470,
            171836390,
            171836406,
            171845837,
            171834988,
            171835540,
            171837958,
            171836211,
            171834933,
            171836834,
            171836016,
            171838691,
            171835898,
            171835047,
            171838527,
            171834668,
            171838404
        ]
    },
    "name": "E. Guess the Cycle Size",
    "statement": ".We hid from you a cyclic graph of n vertices (3\r\nle n\r\nle 10^{18}). A cyclic graph is an undirected graph of n vertices that\r\nform one cycle. Each vertex belongs to the cycle, i.e. the length of the\r\ncycle (the number of edges in it) is exactly n. The order of the\r\nvertices in the cycle is arbitrary.You can make queries in the following\r\nway: \"\" where 1\r\nle a, b\r\nle 10^{18} and a\r\nneq b. In response to the query, the interactor outputs on a separate\r\nline the length of random of two paths from vertex a to vertex b, or if\r\nmax(a, b) > n. The interactor chooses one of the two paths with . The\r\nlength of the path is the number of edges in it.You win if you guess the\r\nnumber of vertices in the hidden graph (number n) by making no more than\r\n50 queries.Note that the interactor is implemented in such a way that\r\nfor any ordered pair (a, b), it always returns the same value for query\r\n\"\", no matter how many such queries. Note that the \"\" query may be\r\nanswered differently by the interactor.The vertices in the graph are\r\nrandomly placed, and their positions are fixed in advance.Hacks are\r\nforbidden in this problem. The number of tests the jury has is 50.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n//#define endl '\\n'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid deb() {cerr << \"\\n\";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nint ask(int x, int y)\n{\n    cout << \"? \" << x << ' ' << y << endl;\n\n    int res;\n    cin >> res;\n\n    return res; \n}\n\n\n\nvoid solve()\n{\n\n    int j = 2;\n\n    while(1)\n    {\n        rep(i,1,j)\n        {\n            int a = ask(i, j);\n\n            if(a == -1)\n            {\n                cout << \"! \" << j - 1 << endl;\n                return;\n            }\n\n            int b = ask(j, i);\n\n            if(a != b)\n            {\n                cout << \"! \" << a + b << endl;\n                return;\n            }\n        }\n\n        j++;\n    }\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    //cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "interactive",
        "probabilities"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Guess the Cycle Size.json",
    "editorial_link": "https://codeforces.com//blog/entry/106916",
    "editorial": "The implication was that the solution works correctly with some high\r\nprobability. So we tried to give such constraints so that the solution\r\nprobability is very high.The idea: we will output queries of the form\r\nand , gradually increasing from . If we get an answer to query the first\r\ntime, then the size of the graph is exactly .Otherwise, let the answer\r\nto the first query be and the answer to the second query be . With\r\nprobability . In this case, we can output the answer: , since there are\r\na total of two different paths from vertex to and we recognized them.\r\nAccordingly the total length of paths will be the size of the cyclic\r\ngraph.But with probability . In this case we must continue the\r\nalgorithm. At most we can make of such attempts. Let\u00e2\u0080\u0099s calculate the\r\nprobability of finding the correct graph size: . That is, we \"\" on one\r\ntest with probability . But we should have \"\" on tests. We get: .\r\n"
}