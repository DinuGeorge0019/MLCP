{
    "link": "https://codeforces.com//contest/1822/problem/B",
    "problemId": "1892787",
    "problem_idx": "B",
    "shortId": "1822B",
    "contest_number": "1822",
    "problem_submissions": {
        "G2": [
            203329589,
            203339263,
            203381498,
            203399783,
            203865362,
            203330305
        ],
        "G1": [
            203318956,
            203330193,
            203276966,
            203287325,
            203308786,
            203296983,
            203323825,
            203307123,
            203320850,
            203332700,
            203865002,
            203359496,
            203359463,
            203330685,
            204446172,
            203310290,
            203339354,
            203315428,
            203302676,
            203310873,
            203329569,
            203321024,
            203330750,
            203305233,
            203303556
        ],
        "F": [
            203311377,
            203304349,
            203289463,
            203315957,
            203293214,
            203321886,
            203310253,
            203289053,
            203315427,
            203322934,
            203309509,
            204446123,
            203336692,
            203316452,
            203330323,
            203318231,
            203332802,
            203314466,
            203335914,
            203292219,
            203326849
        ],
        "E": [
            203296483,
            203294918,
            203301869,
            203305615,
            203281331,
            203304282,
            203300144,
            203335324,
            203301320,
            203299094,
            203465042,
            203300212,
            204446093,
            203301112,
            203312462,
            203305245,
            203327828,
            203302228,
            203303478,
            203300745,
            203330969
        ],
        "D": [
            203286878,
            203281525,
            203307926,
            203293337,
            203328547,
            203299454,
            203293051,
            203279640,
            203292208,
            203282510,
            203460577,
            204446071,
            203291302,
            203284222,
            203296451,
            203281700,
            203294137,
            203283859,
            203282850,
            203323951,
            203292506
        ],
        "C": [
            203269093,
            203263336,
            203271435,
            203263663,
            203261370,
            203266562,
            203266457,
            203274387,
            203281914,
            203267451,
            203280043,
            204446050,
            203273380,
            203263600,
            203280452,
            203287125,
            203279715,
            203274210,
            203276492,
            203269231,
            203271656
        ],
        "B": [
            203260372,
            203258321,
            203263757,
            203259490,
            203258126,
            203261555,
            203264790,
            203259112,
            203258912,
            203260590,
            203267860,
            204445992,
            203266382,
            203260815,
            203264197,
            203259428,
            203281421,
            203266504,
            203265983,
            203265142,
            203265405
        ],
        "A": [
            203258554,
            203260901,
            203261112,
            203258337,
            203257932,
            203258591,
            203260388,
            203259429,
            203267599,
            203258710,
            203270958,
            204446004,
            203259390,
            203258512,
            203258527,
            203257933,
            203263156,
            203262719,
            203260859,
            203258150,
            203261484
        ]
    },
    "name": "B. Karina and Array",
    "statement": "Karina has an array of n integers a_1, a_2, a_3,\r\ndots, a_n. She loves multiplying numbers, so she decided that the of a\r\npair of numbers is their product. And the of an array is the maximum of\r\na pair of elements in the array.For example, for n = 4, a=[3, 5, 7, 4],\r\nthe of the array is\r\nmax(3\r\ncdot 5, 5\r\ncdot 7, 7\r\ncdot 4) =\r\nmax(15, 35, 28) = 35.Karina wants her array to be as as possible. In\r\norder to achieve her goal, she can remove some elements (possibly zero)\r\nfrom the array. After Karina removes all elements she wants to, the\r\narray must contain at least two elements.Unfortunately, Karina doesn\u2019t\r\nhave enough time to do all her tasks, so she asks you to calculate the\r\nmaximum of the array that she can get by removing any number of elements\r\n(possibly zero).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define lli long long int\n#define fr(i, k, n) for (lli i = k; i < n; i++)\n#define rf(i, n, k) for (lli i = n; i > k; i--)\n#define pb push_back\n\n// #include <ext/pb_ds/assoc_container.hpp>\n// #include <ext/pb_ds/tree_policy.hpp>\n// using namespace __gnu_pbds;\n\n// #define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n\nlli power(lli a, lli n)\n{\n    lli res = 1;\n    while (n)\n    {\n        if (n % 2)\n        {\n            res *= a;\n            // res %= mod;\n        }\n        a *= a;\n        // a %= mod;\n        n /= 2;\n    }\n    return res;\n}\n\nlli gcd(lli a, lli b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\nlli lcm(lli v, lli b)\n{\n    return (v * b) / gcd(v, b);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    // freopen(\"error.txt\", \"w\", stderr);\n#endif\n    lli t = 1;\n    cin >> t;\n    while (t--)\n    {\n        lli n;\n        cin >> n;\n        lli arr[n];\n        fr(i, 0, n){\n            cin >> arr[i];\n        }\n        sort(arr, arr + n);\n        cout << max(arr[0] * arr[1], arr[n - 1] * arr[n - 2]) << '\\n';\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Karina and Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/115409",
    "editorial": "In the problem, we are not required to minimize the number of deletions,\r\nso we will search for the answer greedily.First, let\u00e2\u0080\u0099s find two numbers\r\nin the array whose product is maximal. Note that the product of this\r\npair of numbers will be the answer, since we can remove all elements\r\nfrom the array except this pair, then they will become neighboring.It is\r\neasy to see that the product of a pair of positive numbers is maximal\r\nwhen both numbers in the pair are maximal. So we need to consider the\r\nproduct of the two largest numbers. But it\u00e2\u0080\u0099s worth remembering that the\r\nproduct of two negative numbers is positive, so the product of the two\r\nsmallest numbers is also worth considering. The answer to the problem\r\nwill be the maximum of these two products.To find the two largest and\r\ntwo smallest numbers, you can simply sort the array. The final\r\nasymptotics of the solution will be .\r\n"
}