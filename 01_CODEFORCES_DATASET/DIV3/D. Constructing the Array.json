{
    "link": "https://codeforces.com//contest/1353/problem/D",
    "problemId": "620790",
    "problem_idx": "D",
    "shortId": "1353D",
    "contest_number": "1353",
    "problem_submissions": {
        "F": [
            80124393,
            80127683,
            80140343,
            80142966,
            80146411,
            80141780,
            80117292,
            80132406,
            80185189,
            80188504
        ],
        "E": [
            80114098,
            80117275,
            80128499,
            80145539,
            80125005,
            80139306,
            80127975,
            80135984,
            80130531,
            80129427,
            80125620,
            80129245,
            80158858,
            80112124,
            80126450,
            80133527,
            80128884,
            80134345,
            80129651,
            80135076
        ],
        "D": [
            80098108,
            80101755,
            80118374,
            80103972,
            80115994,
            80127815,
            80131082,
            80141865,
            80110266,
            80114346,
            80114023,
            80103850,
            80129182,
            80108992,
            80109025,
            80113948,
            80117006,
            80117268,
            80113177
        ],
        "C": [
            80084355,
            80086625,
            80089665,
            80090748,
            80109095,
            80123682,
            80137480,
            80143026,
            80095516,
            80096983,
            80101362,
            80092320,
            80098872,
            80100063,
            80094720,
            80102804,
            80094807,
            80099168,
            80099321
        ],
        "B": [
            80081560,
            80083037,
            80082947,
            80084540,
            80089013,
            80114962,
            80133140,
            80144863,
            80085266,
            80084702,
            80090165,
            80084822,
            80087571,
            80083864,
            80085636,
            80092945,
            80088539,
            80086038,
            80088726
        ],
        "A": [
            80079491,
            80079524,
            80080015,
            80080262,
            80083439,
            80109672,
            80135612,
            80143748,
            80080163,
            80079971,
            80082828,
            217548820,
            80080548,
            80081468,
            80091988,
            80079985,
            80084451,
            80081999,
            80081124,
            80083012
        ]
    },
    "name": "D. Constructing the Array",
    "statement": "You are given an array a of length n consisting of zeros. You perform n\r\nactions with this array: during the i-th action, the following sequence\r\nof operations appears: Choose the maximum by length subarray ()\r\nconsisting of zeros, among all such segments choose the one; Let this\r\nsegment be [l; r]. If r-l+1 is odd (not divisible by 2) then assign\r\n(set) a[\r\nfrac{l+r}{2}] := i (where i is the number of the current action),\r\notherwise (if r-l+1 is even) assign (set) a[\r\nfrac{l+r-1}{2}] := i. Consider the array a of length 5 (initially a=[0,\r\n0, 0, 0, 0]). Then it changes as follows: Firstly, we choose the segment\r\n[1; 5] and assign a[3] := 1, so a becomes [0, 0, 1, 0, 0]; then we\r\nchoose the segment [1; 2] and assign a[1] := 2, so a becomes [2, 0, 1,\r\n0, 0]; then we choose the segment [4; 5] and assign a[4] := 3, so a\r\nbecomes [2, 0, 1, 3, 0]; then we choose the segment [2; 2] and assign\r\na[2] := 4, so a becomes [2, 4, 1, 3, 0]; and at last we choose the\r\nsegment [5; 5] and assign a[5] := 5, so a becomes [2, 4, 1, 3, 5]. Your\r\ntask is to find the array a of length n after performing all n actions.\r\n.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a;\n           cin>>a;\n           int inf=1000000;\n           priority_queue <pair<int,pair<int,int>>> cur;\n           cur.push({a,{inf-1,a}});\n           vector <int> ans(a+1);\n           int qq=0; \n           int it=0; \n           while (!cur.empty()) {\n               qq++; \n               it++; \n               pair<int,pair<int,int>> kek=cur.top(); cur.pop();\n               //cout<<kek.first<<\" \"<<kek.second.first<<\" \"<<kek.second.second<<\"\\n\"; \n               int l=inf-kek.second.first; \n               int r=kek.second.second;\n               int mem; \n               if ((r-l+1)%2==1) {mem=(l+r)/2; } else mem=(l+r-1)/2; \n               ans[mem]=qq; \n               if (l!=r) {\n                   if (l<mem) cur.push({mem-l,{inf-l,mem-1}}); \n                   if (r>mem) cur.push({r-mem,{inf-(mem+1),r}}); \n               }\n           }\n            for (int i=1;i<=a;i++) cout<<ans[i]<<\" \"; cout<<\"\\n\";         \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Constructing the Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/77373",
    "editorial": "This is just an implementation problem. We can use some kind of heap or\r\nordered set to store all segments we need in order we need. To solve\r\nthis problem on C++ with , we can just rewrite the comparator for like\r\nthis:And then just write the like this:Now the minimum element of the\r\nset will be the segment that we need to choose. Initially, the set will\r\ncontain only one segment . Suppose we choose the segment during the -th\r\naction. Let , where is divided by rounded down. Assign (set) , then if\r\nthe segment has positive (greater than zero) length, push this segment\r\nto the set and the same with the segment . After such actions we get the\r\nanswer.Time complexity: .\r\n",
    "hint": []
}