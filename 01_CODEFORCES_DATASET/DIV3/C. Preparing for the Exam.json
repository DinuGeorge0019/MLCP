{
    "link": "https://codeforces.com//contest/2051/problem/C",
    "problemId": "3099576",
    "problem_idx": "C",
    "shortId": "2051C",
    "contest_number": "2051",
    "problem_submissions": {
        "G": [
            297891656,
            297890696,
            297899138,
            297892259,
            297912620,
            297920714,
            297934708,
            297929892,
            297931851,
            297911736,
            297927208,
            297928317,
            297947772,
            297909767,
            297942983,
            297993500,
            297875875,
            297873133,
            297875271
        ],
        "F": [
            297856552,
            297878644,
            297873030,
            297875253,
            297891474,
            297895628,
            297891515,
            297904684,
            297959623,
            297914765,
            297882921,
            297895179,
            297910575,
            297923862,
            297919187,
            297917128,
            297916364,
            297943956,
            297865687,
            297864877,
            297909911
        ],
        "E": [
            297841786,
            297836575,
            297839584,
            297846936,
            297869096,
            297865734,
            297862813,
            297854892,
            297860094,
            297876823,
            297874225,
            297892538,
            297862291,
            297876371,
            297877246,
            297922331,
            297840776,
            297834266,
            297852254,
            297850894
        ],
        "D": [
            297824998,
            297828255,
            297829120,
            297836876,
            297843401,
            297839448,
            297844425,
            297835789,
            297837071,
            297862412,
            297866230,
            297845487,
            297868513,
            297862250,
            297899798,
            297831894,
            297830585,
            297845610,
            297833477
        ],
        "C": [
            297817405,
            297821512,
            297822005,
            297826169,
            297828699,
            297832899,
            297832376,
            297822832,
            297823992,
            297849370,
            297841820,
            297834151,
            297857822,
            297848820,
            297891200,
            297825348,
            297827127,
            297840542,
            297824191
        ],
        "B": [
            297813648,
            297815534,
            297817642,
            297818888,
            297819929,
            297820049,
            297826062,
            297814904,
            297817786,
            297837190,
            297825933,
            297817655,
            297849719,
            297836185,
            297885765,
            297815546,
            297824155,
            297835551,
            297813164
        ],
        "A": [
            297812430,
            297812527,
            297814260,
            297815468,
            297814137,
            297814651,
            297817327,
            297812582,
            297812492,
            297830581,
            297819762,
            297812887,
            297821437,
            297881803,
            297812726,
            297821513,
            297830979,
            297812442
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137623",
    "editorial": "For every question list, we should check if Monocarp knows all questions\r\nfrom the list, i. e. all numbers appear in the list . Searching for\r\nevery number in the list naively is too slow; instead, we can make a\r\nboolean array such that the -th element in it is if and only if Monocarp\r\nknows the -th question. That way, we can check if an integer appears in\r\nthe list in .However, that is not enough, since every list of questions\r\ncontains questions, and there are lists. We need to use the fact that\r\nevery list contains exactly questions somehow.If Monocarp knows all\r\nquestions, he can answer any question list (since he knows everything).\r\nIf Monocarp knows questions or less, he cannot pass at all, since every\r\nquestion list contains more questions than he knows. The only case\r\nthat\u00e2\u0080\u0099s left if when , i. e. Monocarp knows all questions except for one.\r\nLet\u00e2\u0080\u0099s analyze it in more detail (the two next paragraphs will assume\r\nthat ).Since every question list has the same size as the set of\r\nquestions known by Monocarp, then in order for Monocarp to pass the\r\nexam, these two sets of questions must be equal. However, checking that\r\nthey are equal by iterating on their contents is too slow; instead, we\r\nwill check that two sets of questions are different by .Let\u00e2\u0080\u0099s check if\r\nMonocarp knows the question . If he does, then the -th list of questions\r\nis different from the set of questions he knows, so he can\u00e2\u0080\u0099t pass. But\r\nif Monocarp doesn\u00e2\u0080\u0099t know the -th question, then he knows every question\r\nwhich is not , so he can pass. So, Monocarp knows the -th question list\r\nif and only if he does not know the -th question, and this can be\r\nchecked in .This way, we get a solution working in on each test case.\r\n",
    "name": "C. Preparing for the Exam",
    "statement": "Monocarp is preparing for his first exam at the university. There are n\r\ndifferent questions which can be asked during the exam, numbered from 1\r\nto n. There are m different lists of questions; each list consists of\r\nexactly n-1 different questions. Each list i is characterized by one\r\ninteger a_i, which is the index of the only question which is in the\r\ni-th list. For example, if n = 4 and a_i = 3, the i-th list contains\r\nquestions [1, 2, 4].During the exam, Monocarp will receive one of these\r\nm lists of questions. Then, the professor will make Monocarp answer all\r\nquestions from the list. So, Monocarp will pass only if he knows all\r\nquestions from the list.Monocarp knows the answers for k questions q_1,\r\nq_2,\r\ndots, q_k. For each list, determine if Monocarp will pass the exam if he\r\nreceives that list.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ll long longusing namespace std;\u00a0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\u00a0    int t;    cin >> t;\u00a0    while(t--){        ll n, m, k;        cin >> n >> m >> k;\u00a0        vector<ll> a(m);\u00a0        for(auto &x: a) {            cin >> x;        }\u00a0        vector<ll> q(k);\u00a0        for(auto &x: q) {            cin >> x;        }\u00a0        vector<char> res(n+1, 0);\u00a0        for(auto x: q){            if(x >=1 && x <=n){                res[x] = 1;            }        }\u00a0        string ans = \"\";        for(auto x: a){            if(x >=1 && x <=n && res[x]){                if(k == n){                    ans += '1';                }                else{                    ans += '0';                }            } else{                if(k == n -1){                    ans += '1';                }                else{                    ans += '0';                }            }        }\u00a0        cout << ans << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Preparing for the Exam.json"
}