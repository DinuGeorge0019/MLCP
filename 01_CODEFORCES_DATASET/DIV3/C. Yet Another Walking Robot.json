{
    "link": "https://codeforces.com//contest/1296/problem/C",
    "problemId": "531584",
    "problem_idx": "C",
    "shortId": "1296C",
    "contest_number": "1296",
    "problem_submissions": {
        "F": [
            70286253,
            70288122,
            70354438,
            70285370,
            70284169,
            70273160,
            70285348,
            70284069,
            73578212
        ],
        "E2": [
            70268992,
            70280432,
            70276298,
            70288167,
            70281465,
            70297360,
            70276336,
            70279357,
            70275001,
            70289621,
            70284967,
            70279268,
            70267172,
            70283236,
            70277761,
            70279813,
            70288110,
            70291891
        ],
        "E1": [
            70259556,
            70271142,
            70274990,
            70272602,
            70283753,
            70297032,
            70271882,
            70269738,
            70275752,
            70268786,
            70271448,
            70276258,
            70273279,
            70265150,
            70276327,
            70278408,
            70275898,
            70282584,
            70276913
        ],
        "D": [
            70254151,
            70262790,
            70262428,
            70261281,
            70276243,
            70262462,
            70263810,
            70262249,
            70265276,
            70259161,
            70259866,
            70267524,
            70269993,
            70279455,
            70268313,
            70271364,
            70271292,
            70266627,
            70267013
        ],
        "C": [
            70249671,
            70254183,
            70253966,
            70257190,
            70266437,
            70255782,
            70255981,
            70254148,
            70255586,
            70253171,
            70255047,
            70257702,
            70256317,
            70276767,
            70260739,
            70266471,
            70262570,
            70259034,
            70260723
        ],
        "B": [
            70243991,
            70245027,
            70247695,
            70248175,
            70243833,
            70246192,
            70247369,
            70246768,
            70245235,
            70247847,
            70245515,
            70248129,
            70249598,
            70248726,
            70249146,
            70250758,
            70248649,
            70248220
        ],
        "A": [
            70240828,
            70240986,
            70241720,
            70243455,
            70240584,
            70241402,
            70241482,
            70242817,
            70240810,
            70240914,
            70243012,
            70245219,
            70243961,
            70242643,
            70241917,
            70240694,
            70241375,
            70241384
        ]
    },
    "name": "C. Yet Another Walking Robot",
    "statement": "There is a robot on a coordinate plane. Initially, the robot is located\r\nat the point (0, 0). Its path is described as a string s of length n\r\nconsisting of characters ”, ”, ”, ”.Each of these characters corresponds\r\nto some move: ” (left): means that the robot moves from the point (x, y)\r\nto the point (x - 1, y); ” (right): means that the robot moves from the\r\npoint (x, y) to the point (x + 1, y); ” (up): means that the robot moves\r\nfrom the point (x, y) to the point (x, y + 1); ” (down): means that the\r\nrobot moves from the point (x, y) to the point (x, y - 1). The company\r\nthat created this robot asked you to optimize the path of the robot\r\nsomehow. To do this, you can remove of the path. But this company\r\ndoesn’t want their customers to notice the change in the robot behavior.\r\nIt means that if before the optimization the robot ended its path at the\r\npoint (x_e, y_e), then after optimization (i.e. removing some single\r\nsubstring from s) the robot also ends its path at the point (x_e,\r\ny_e).This optimization is a low-budget project so you need to remove\r\npossible substring to optimize the robot’s path such that the endpoint\r\nof his path doesn’t change. It is possible that you can’t optimize the\r\npath. Also, it is possible that after the optimization the target path\r\nis an empty string (i.e. deleted substring is the whole string s).Recall\r\nthat the substring of s is such string that can be obtained from s by\r\nremoving some amount of characters (possibly, zero) from the prefix and\r\nsome amount of characters (possibly, zero) from the suffix. For example,\r\nthe substrings of \"\" are \"\", \"\", \"\", \"\", but not \"\" and \"\".You have to\r\nanswer t independent test cases.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+10,M=N*400,mod=1e9+7;\nint n;char a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int x=0,y=0;\n        map<PII,int>mp;\n        mp[PII(0,0)]=0;\n        scanf(\"%d\",&n);\n        scanf(\"%s\",a+1);\n        int ans=INF;\n        int l=0;\n        for(int i=1;i<=n;i++){\n            if(a[i]=='L')x++;\n            if(a[i]=='R')x--;\n            if(a[i]=='U')y++;\n            if(a[i]=='D')y--;\n            if(mp.count(PII(x,y))){\n                int k=mp[PII(x,y)];\n                if(i-k<ans)ans=i-k,l=k+1;\n            }\n            mp[PII(x,y)]=i;\n        }\n        if(l==0)printf(\"-1\\n\");\n        else printf(\"%d %d\\n\",l,l+ans-1);\n    }\n    return 0;\n}\n/*\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Yet Another Walking Robot.json",
    "editorial_link": "https://codeforces.com//blog/entry/73627",
    "editorial": "Formally, the problem asks you to remove the shortest cycle from the\r\nrobotâs path. Because the endpoint of the path cannot be changed, the\r\nnumber of âs should be equal to the number of âs and the same with â and\r\nâ.How to find the shortest cycle? Letâs create the associative array (\r\nfor C++) which will say for each point of the path the maximum number of\r\noperations such that if we apply first operations we will stay at this\r\npoint. Initially, this array will contain only the point with the value\r\n. Letâs go over all characters of in order from left to right. Let the\r\ncurrent point be (we applied first operations, -indexed). If this point\r\nis in the array already, letâs try to update the answer with the value\r\nand left and right borders with values and correspondingly. Then letâs\r\nassign and continue.If there were no updates of the answer, the answer\r\nis . Otherwise, you can print any substring you found.Time complexity:\r\nper test case.\r\n",
    "hint": []
}