{"link": "https://codeforces.com//contest/1462/problem/D", "problemId": "833572", "problem_idx": "D", "shortId": "1462D", "contest_number": "1462", "problem_submissions": {"F": [101312311, 101295944, 101308624, 101308817, 101304111, 101280435, 101305797, 101310367, 101305342, 101311228, 101404636, 101403975, 101311880, 101300846, 101321777, 101323660, 101322804, 101312196, 101317325, 101337936, 101324335, 101318324], "E2": [101285396, 101295162, 101287717, 101294090, 101294721, 101302415, 101297486, 101291336, 101285191, 101301715, 101403947, 101297838, 101320202, 101301546, 101293087, 101297518, 101302712, 101306390, 101284328, 101307237, 101300711], "E1": [101282369, 101288225, 101284658, 101287780, 101297537, 101304897, 101298622, 101296342, 101290668, 101295792, 101403926, 101300370, 101291439, 101292410, 101297049, 101300114, 101296216, 101298222, 101280004, 101327539, 101299484, 101303183], "D": [101276901, 101274657, 101273346, 101282814, 101282205, 101287581, 101290967, 101279699, 101299600, 101289409, 101403847, 101286604, 101293181, 101285967, 101285140, 101285937, 101287608, 101292000, 101304911, 101416082, 101283715, 101288370], "C": [101268521, 101264616, 101269281, 101273876, 101272004, 101269250, 101272117, 101267115, 101271243, 101273829, 101403759, 101275279, 101269069, 101275015, 101277128, 101275423, 101281795, 101279889, 101270679, 101277574, 101275915], "B": [101264269, 101265842, 101265325, 101264865, 101264553, 101265746, 101267507, 101270770, 101264118, 101266219, 101403739, 101270231, 101266677, 101264816, 101274093, 101269885, 101269868, 101266304, 101266579, 101415580, 101272178, 101266529], "A": [101259376, 101261449, 101259287, 101259205, 101260758, 101260150, 101263911, 101273333, 101279124, 101260299, 101403717, 101261323, 101259580, 101259586, 101264162, 101263539, 101264411, 101259503, 101259664, 101259533, 101260523]}, "name": "D. Add to Neighbour and Remove", "statement": "Polycarp was given an array of a[1\r\ndots n] of n integers. He can perform the following operation with the\r\narray a no more than n times: Polycarp selects the index i and adds the\r\nvalue a_i to of its neighbors. More formally, Polycarp adds the value of\r\na_i to a_{i-1} or to a_{i+1} (if such a neighbor does not exist, then it\r\nis impossible to add to it). After adding it, Polycarp removes the i-th\r\nelement from the a array. During this step the length of a is decreased\r\nby 1. The two items above together denote one single operation.For\r\nexample, if Polycarp has an array a = [3, 1, 6, 6, 2], then it can\r\nperform the following sequence of operations with it: Polycarp selects i\r\n= 2 and adds the value a_i to (i-1)-th element: a = [4, 6, 6, 2].\r\nPolycarp selects i = 1 and adds the value a_i to (i+1)-th element: a =\r\n[10, 6, 2]. Polycarp selects i = 3 and adds the value a_i to (i-1)-th\r\nelement: a = [10, 8]. Polycarp selects i = 2 and adds the value a_i to\r\n(i-1)-th element: a = [18]. Note that Polycarp could stop performing\r\noperations at any time.Polycarp wondered how many minimum operations he\r\nwould need to perform to make all the elements of a equal (i.e., he\r\nwants all a_i are equal to each other).\r\n", "solutions": ["#include <bits/stdc++.h>\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define si short int\n#define speed ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define pill pair<ll,ll>\n#define f first\n#define s second\n#define pilc pair<ll,char>\n#define all(a) (a).begin(),(a).end()\n#define rep(s,e,step) for(int i = (s); i < (e) ; i += step)\n#define vrep(s,e,step) for(int j = (s); j < (e) ; j += step)\n#define ex exit(0) \n#define sz(a) (a).size()\n#define triple pair<pill, ll>\n#define pinode pair<node*, node*>\n#define quadra pair<pill, pill>\n#define ld long double\nusing namespace std;\n \nconst ll N = 2e5 + 10;\nconst ll M = 2e5 + 1;\nconst ll big = 1e18;\nconst ll hsh2 = 1964325029 ;\nconst long long mod = 1e9 + 7;\nconst long double EPS = 1e-14;\nconst ll block = 1e7;\nconst ll shift = 2e3;\nmt19937_64 rofl(chrono::steady_clock::now().time_since_epoch().count());\n\nll t;\nll a[N];\nvoid solve() {\n    ll n;\n    cin >> n;\n    ll sum = 0, mx = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i], sum += a[i], mx = max(mx, a[i]);\n\tfor(int j = n; j >= 1; j--) {\n\t\tif(sum % j)\n\t\t\tcontinue;\n\t\tif(sum / j < mx)\n\t\t\tcontinue;\n\t\tll L = n;\n\t\tbool can = 1;\n\t\twhile(L) {\n\t\t\tll x = L - 1;\n\t\t\tll z = a[L];\n\t\t\twhile(z < (sum / j) && x > 0)\n\t\t\t\tz += a[x], x--;\n\t\t\tif(z != sum / j)\n\t\t\t\tcan = 0;\n\t\t\tL = x;\t\t\t\t               \t\n\t\t}\n\t\tif(can)\t\n\t\t\treturn (void)(cout << n - j << '\\n');\t\t\t\n\t}\n}\n\nint main() {\n\tspeed;\n\tcin >> t;\n\twhile(t--)solve(); \t\n}              \n/*\nqiwwqdesw\n1\nd\n \n*/"], "input": "", "output": "", "tags": ["greedy", "math", "number theory"], "dificulty": "1400", "interactive": false}