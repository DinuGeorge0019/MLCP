{
    "link": "https://codeforces.com//contest/1551/problem/E",
    "problemId": "1055225",
    "problem_idx": "E",
    "shortId": "1551E",
    "contest_number": "1551",
    "problem_submissions": {
        "D2": [
            123504570,
            123491119,
            123485402,
            123508709,
            123487387,
            123490299,
            123498497,
            123519517,
            123503570,
            123507308,
            123506328,
            123496338,
            123525324,
            123509854,
            123500000,
            123499688,
            123500681,
            123520243,
            123521810,
            123560543,
            123489816
        ],
        "D1": [
            123496540,
            123479404,
            123460900,
            123501007,
            123476769,
            123477339,
            123486676,
            123509110,
            123490131,
            123493249,
            123493173,
            123482125,
            123490880,
            123500902,
            123489510,
            123491442,
            123487788,
            123505201,
            123513198,
            123560527,
            123477927
        ],
        "E": [
            123487760,
            123503517,
            123508061,
            123512161,
            123512376,
            123522062,
            123512340,
            123494473,
            123520187,
            123519199,
            123522642,
            123508385,
            123509676,
            123525566,
            123522562,
            123529567,
            123525043,
            123524224,
            123527690,
            123529206
        ],
        "F": [
            123483346,
            123518773,
            123505149,
            123522554,
            123530029,
            123525813,
            123677834
        ],
        "C": [
            123463062,
            123471764,
            123465961,
            123494616,
            123466015,
            123470689,
            123479667,
            123473982,
            123478387,
            123473235,
            123485341,
            123504214,
            123476344,
            123474463,
            123482794,
            123487070,
            123509871,
            123495332,
            123505971,
            123560511,
            123471519
        ],
        "B1": [
            123458055,
            123450157,
            123447323,
            123480992,
            123471662,
            123459271,
            123448891,
            123453516,
            123457018,
            123473105,
            123465306,
            123457521,
            123473064,
            123450150,
            123457907,
            123454507,
            123450845,
            123454392,
            123459478,
            123486711,
            123560483,
            123451550
        ],
        "B2": [
            123455203,
            123463888,
            123460727,
            123523874,
            123456743,
            123463349,
            123471479,
            123467608,
            123467523,
            123462292,
            123471295,
            123468067,
            123463785,
            123466840,
            123469959,
            123475307,
            123473651,
            123478743,
            123500344,
            123560494,
            123462370
        ],
        "A": [
            123443367,
            123443254,
            123447159,
            123446121,
            123445546,
            123443509,
            123444177,
            123443572,
            123444116,
            123444163,
            123445991,
            123474697,
            123444077,
            123443229,
            123447862,
            123443364,
            123443226,
            123449045,
            123446138,
            123560465,
            123443541
        ]
    },
    "name": "E. Fixed Points",
    "statement": "Consider a sequence of integers a_1, a_2,\r\nldots, a_n. In one move, you can select any element of the sequence and\r\ndelete it. After an element is deleted, all elements to the right are\r\nshifted to the left by 1 position, so there are no empty spaces in the\r\nsequence. So after you make a move, the sequence’s length decreases\r\nby 1. The indices of the elements after the move are recalculated.E. g.\r\nlet the sequence be a=[3, 2, 2, 1, 5]. Let’s select the element a_3=2 in\r\na move. Then after the move the sequence will be equal to a=[3, 2, 1,\r\n5], so the 3-rd element of the new sequence will be a_3=1 and the 4-th\r\nelement will be a_4=5.You are given a sequence a_1, a_2,\r\nldots, a_n and a number k. You need to find the minimum number of moves\r\nyou have to make so that in the resulting sequence there will be k\r\nelements that are equal to their indices, i. e. the resulting sequence\r\nb_1, b_2,\r\nldots, b_m will contain at least k indices i such that b_i = i.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    vector<int> a(n+1);\n    for(int i=1;i<=n;++i)\n        cin >> a[i];\n    vector<vector<ll>> dp(n+10,vector<ll>(n+10,0));\n    dp[0][0] = 0;\n    for(int i=0;i<n;++i)\n    {\n        for(int j=0;j<=i;++j)\n        {\n            amax(dp[i+1][j],dp[i][j]);\n            if(a[i+1] == j + 1)\n                amax(dp[i+1][j+1],dp[i][j] + 1);\n            else\n                amax(dp[i+1][j+1],dp[i][j]);\n        }\n    }\n    int ans = -1;\n    for(int i=1;i<=n;++i)\n    {\n        if(dp[n][i] >= k)\n            amax(ans,i);\n    }\n    if(ans == -1)\n        cout << ans << \"\\n\";\n    else\n        cout << n - ans << \"\\n\";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dp"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Fixed Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/93149",
    "editorial": "Letâs use the concept of dynamic programming. Letâs create an array\r\n(-indexed) with size of . will contain the maximal number of the\r\nelements equal to their indices if we have considered the first elements\r\nof the sequence and have elements.Letâs fill the array with zeroes, then\r\nwe will increase the elements of the array for different and . Letâs\r\nstart the -loop with parameter from to and the internal one with\r\nparameter from to . Consider an element . We can delete or not delete\r\nit.If we delete this element, the number of the elements equal to their\r\nindices will not be increased and the number of the non-deleted element\r\nwill not be increased, too. It means that the answer for may be updated\r\nwith . Since we are interested in a maximum answer, we rewrite only if\r\nis greater than .Suppose we donât delete this element. We havenât\r\ndeleted previously elements so will have the index and there will be\r\nnon-deleted elements if we consider elements so we must update . If (i.\r\ne. an element equal to its index is found), letâs update with .\r\nOtherwise, we should update it with . Remember that update may be done\r\nonly if we rewrite the less value with the greater value.Letâs build the\r\nanswer as follows. We need to minimize the number of deleted elements\r\n(maximize the number of non-deleted elements) so that the number of the\r\nelements equal to their indices is at least . Consider only the elements\r\nof having the first index . Letâs start a -loop in the descending order\r\nof . If , is the maximum number of elements that we will not delete, so\r\nthe answer is . If we will not find such that , thereâs no desired\r\nsequence of moves so the answer is .The algorithm works in .\r\n",
    "hint": []
}