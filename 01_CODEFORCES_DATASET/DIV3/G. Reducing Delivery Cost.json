{
    "link": "https://codeforces.com//contest/1433/problem/G",
    "problemId": "766662",
    "problem_idx": "G",
    "shortId": "1433G",
    "contest_number": "1433",
    "problem_submissions": {
        "E": [
            96118292,
            96100384,
            96144411,
            96131531,
            96126171,
            96116171,
            96143430,
            96124657,
            96110938,
            96142211,
            96123301,
            96164122,
            96137865,
            96137248,
            96139372,
            96151324,
            96105901,
            96108332,
            96119162
        ],
        "D": [
            96108021,
            96096525,
            96105972,
            96112718,
            96099052,
            96105757,
            96102154,
            96119014,
            96106156,
            96111319,
            96110517,
            96107146,
            96106344,
            96110999,
            96119720,
            96108556,
            96096494,
            96100784,
            96104899
        ],
        "F": [
            96105759,
            96110506,
            96119004,
            96125972,
            96132730,
            96142830,
            96120574,
            96135431,
            96163807,
            96138553,
            96152985,
            96127650,
            96151526,
            96153346,
            96158052,
            96144943,
            96148733,
            96135208
        ],
        "C": [
            96102081,
            96092029,
            96090502,
            96100255,
            96092651,
            96097485,
            96096234,
            96096200,
            96099117,
            96101166,
            96102838,
            96101507,
            96097647,
            96094575,
            96113560,
            96103107,
            96090286,
            96093702,
            96099170
        ],
        "G": [
            96094218,
            96125410,
            96128032,
            96141154,
            96154260,
            96149033,
            96156333,
            96142357,
            96139797,
            96146497,
            96163476,
            96140362,
            96161234,
            96163894,
            96152235,
            96163050,
            96123944,
            96205637
        ],
        "B": [
            96092183,
            96084902,
            96085565,
            96094926,
            96088334,
            96090362,
            96089755,
            96089494,
            96088669,
            96093848,
            96088026,
            96089177,
            96087731,
            96090077,
            96098934,
            96093459,
            96086464,
            96086371,
            96090772
        ],
        "A": [
            96084957,
            96082729,
            96082939,
            96083168,
            96082835,
            96084005,
            96082966,
            96083516,
            96083887,
            96086611,
            96083211,
            96084639,
            96083406,
            96083239,
            96092645,
            96083081,
            96082670,
            96083000,
            96085692
        ]
    },
    "name": "G. Reducing Delivery Cost",
    "statement": "You are a mayor of Berlyatov. There are n districts and m two-way roads\r\nbetween them. The i-th road connects districts x_i and y_i. The cost of\r\ntravelling along this road is w_i. There is some path between each pair\r\nof districts, so the city is connected.There are k delivery routes in\r\nBerlyatov. The i-th route is going from the district a_i to the district\r\nb_i. There is one courier on each route and the courier will always\r\nchoose the (minimum by total cost) path from the district a_i to the\r\ndistrict b_i to deliver products.The route can go from the district to\r\nitself, some couriers routes can coincide ().You can make at most one\r\nroad to have cost zero (i.e. you choose at most one road and change its\r\ncost with 0).Let d(x, y) be the cheapest cost of travel between\r\ndistricts x and y.Your task is to find the minimum total courier routes\r\ncost you can achieve, if you optimally select the some road and change\r\nits cost with 0. In other words, you have to find the minimum possible\r\nvalue of\r\nsum\r\nlimits_{i = 1}^{k} d(a_i, b_i) after applying the operation described\r\nabove optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint hmt() {int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c=='-');for(;isdigit(c);c=getchar()) x=x*10+c-'0';if(n) x=-x;return x;}\n#define in hmt()\n#define ins ({string x;char c=getchar();for(;c==' '||c=='\\n';c=getchar());for(;c!=' '&&c!='\\n';c=getchar()) x+=c;x;})\n#define forinc(i,a,b) for(int i=a,_b=b;i<=_b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forb(i,BS) for(int i=BS._Find_first();i< BS.size();i = BS._Find_next(i))\n#define timer 1.0*clock()/CLOCKS_PER_SEC\n#define forv(a,b) for(auto &a:b)\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define reset(f,x) memset(f,x,sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define onbit(x,i) (x|(1<<(i-1)))\n#define offbit(x,i) (x&~(1<<(i-1)))\nconst int N=1010;\nint n,m,k,f[N][N];\npii e[N];\nvector<pii> ke[N];\npriority_queue<pii,vector<pii>,greater<pii> > h;\nvoid DIJ(int s)\n{\n    forinc(i,1,n) f[s][i]=2e9;\n    f[s][s]=0;\n    h.push({0,s});\n    while(!h.empty())\n    {\n        int u=h.top().se,c=h.top().fi;\n        h.pop();\n        if(c>f[s][u]) continue;\n        forv(v,ke[u]) if(f[s][v.fi]>f[s][u]+v.se)\n            h.push({f[s][v.fi]=f[s][u]+v.se,v.fi});\n    }\n}\nint main()\n{\n    //freopen(\"1433G.inp\",\"r\",stdin);\n    n=in,m=in,k=in;\n    forinc(i,1,m)\n    {\n        int u=in,v=in,c=in;\n        ke[u].pb({v,c});\n        ke[v].pb({u,c});\n    }\n    forinc(i,1,k)\n    {\n        int u=in,v=in;\n        e[i]={u,v};\n    }\n    forinc(i,1,n) DIJ(i);\n    int ans=2e9;\n    forinc(u,1,n) forv(v,ke[u])\n    {\n        int ret=0;\n        forinc(i,1,k)\n        {\n            int x=e[i].fi,y=e[i].se;\n            ret+=min({f[x][y],f[x][u]+f[y][v.fi],f[x][v.fi]+f[y][u]});\n        }\n        ans=min(ans,ret);\n    }\n    cout<<ans<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Reducing Delivery Cost.json",
    "editorial_link": "https://codeforces.com//blog/entry/83903",
    "editorial": "If we would naively solve the problem, we would just try to replace each\r\nedge\u00e2\u0080\u0099s cost with zero and run Dijkstra algorithm times to get the\r\ncheapest paths. But this is too slow.Let\u00e2\u0080\u0099s try to replace each edge\u00e2\u0080\u0099s\r\ncost with zero anyway but use some precalculations to improve the speed\r\nof the solution. Let\u00e2\u0080\u0099s firstly run Dijkstra times to calculate all\r\ncheapest pairwise paths. Then, let\u00e2\u0080\u0099s fix which edge we \"remove\" .There\r\nare three cases for the path : this edge was not on the cheapest path\r\nbefore removing and is not on the cheapest path after removing. Then the\r\ncost of this path is . The second case is when this edge was not on the\r\ncheapest path before removing but it is on the cheapest path after\r\nremoving. Then the cost of this path is . So we are just going from to\r\nusing the cheapest path, then going through the zero edge and then going\r\nfrom to using the cheapest path also (or vice versa, from to and from to\r\n). And the third case is when this edge was already on the cheapest path\r\nbetween and but this case is essentially the same as the second one.So,\r\nif we fix the edge , then the answer for this edge is . Taking the\r\nminimum over all edges, we will get the answer.The precalculating part\r\nworks in and the second part works in .\r\n"
}