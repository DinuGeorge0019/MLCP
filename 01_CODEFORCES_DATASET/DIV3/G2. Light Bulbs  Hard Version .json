{
    "link": "https://codeforces.com//contest/1914/problem/G2",
    "problemId": "2388667",
    "problem_idx": "G2",
    "shortId": "1914G2",
    "contest_number": "1914",
    "problem_submissions": {
        "G1": [
            238018438,
            238000852,
            238043791,
            238031142,
            238036163,
            238022582,
            238087384,
            238021948,
            238036052,
            238042057,
            238044748,
            238044591,
            238050871,
            238049279,
            238041985,
            238041747,
            238051023,
            238045930,
            238048344,
            238046536
        ],
        "G2": [
            238018282,
            238029024,
            238043678,
            238093831,
            238412098,
            238148947,
            238064785,
            238049222,
            238126038,
            238092486,
            238087948,
            238046581
        ],
        "F": [
            237987101,
            237981616,
            238101450,
            238044891,
            238001429,
            238000631,
            238087366,
            238087349,
            237994511,
            237993999,
            238008838,
            238002775,
            238029366,
            238028703,
            238047984,
            238031007,
            238059042,
            238016608,
            238042673,
            238020683,
            238033160,
            238082942,
            238008762,
            238014024
        ],
        "E1": [
            237976613,
            237967906,
            237968713,
            237979764,
            237992475,
            238087307,
            237986420,
            237997495,
            237988975,
            237985077,
            238029878,
            238002145,
            237999975,
            237992524,
            237984395,
            237997791,
            237997737,
            237990723,
            237990559,
            238004571,
            238010992,
            238032680,
            237982405,
            237983507
        ],
        "E2": [
            237970390,
            237967235,
            237968505,
            237975110,
            237992780,
            238087324,
            238087318,
            237984061,
            238010057,
            237989036,
            237983616,
            238029826,
            238001371,
            237999445,
            237992650,
            237985208,
            237997942,
            237998156,
            237990939,
            238005322,
            238011620,
            238032636,
            237982481,
            237984584
        ],
        "D": [
            237961065,
            237957916,
            238104889,
            237961793,
            237958795,
            237961367,
            238087292,
            238087270,
            237986240,
            237957524,
            237975283,
            237962518,
            238030156,
            237976418,
            237969884,
            237965519,
            237971483,
            237975166,
            237976975,
            237983490,
            237986064,
            237975702,
            237967060,
            237966732
        ],
        "C": [
            237951819,
            237950855,
            237956944,
            237969583,
            237951814,
            238087237,
            237972501,
            237951530,
            237961828,
            237952459,
            238030394,
            237963594,
            237963444,
            237965677,
            237960539,
            237979704,
            237972502,
            237967766,
            237971691,
            237960187,
            237954042,
            237957084
        ],
        "B": [
            237947357,
            237946623,
            237951415,
            237946292,
            237950077,
            238087224,
            237953989,
            237947273,
            237953071,
            237947198,
            237948581,
            237951930,
            237944853,
            237953412,
            237972118,
            237952004,
            237972737,
            237961138,
            237948416,
            237947616,
            237950073
        ],
        "A": [
            237944355,
            237943313,
            237944942,
            237948071,
            237945058,
            238087212,
            237948311,
            237944114,
            237946737,
            237943516,
            237943664,
            237945100,
            237964491,
            237948297,
            237965985,
            237946077,
            237945584,
            237949431,
            237943847,
            237944147,
            237943327
        ]
    },
    "name": "G2. Light Bulbs  Hard Version ",
    "statement": ".There are 2n light bulbs arranged in a row. Each light bulb has a color\r\nfrom 1 to n ().Initially, all light bulbs are turned off. You choose a\r\nset of light bulbs S that you initially turn on. After that, you can\r\nperform the following operations in any order any number of times:\r\nchoose two light bulbs i and j , exactly one of which is on, and turn on\r\nthe second one; choose three light bulbs i, j, k, such that both light\r\nbulbs i and k , and the light bulb j is between them (i < j < k), and\r\nturn on the light bulb j. You want to choose a set of light bulbs S that\r\nyou initially turn on in such a way that by performing the described\r\noperations, you can ensure that all light bulbs are turned on.Calculate\r\ntwo numbers: the minimum size of the set S that you initially turn on;\r\nthe number of sets S of minimum size (taken modulo 998244353).\r\n",
    "solutions": [
        "//haachama cooking\n#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<int,int>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nconst ll N=2e5+5,mod=998244353;\nint gmi[20][2*N],lg[2*N],gma[20][2*N],R[N];\nii pos[N];\nll n,a[2*N],par[N];\nii get (ll l, ll r){\n    ii d;\n    ll g=lg[r-l+1];\n    d.F=min(gmi[g][l],gmi[g][r-(1<<g)+1]);\n    d.S=max(gma[g][l],gma[g][r-(1<<g)+1]);\n    return d;\n}\nll find (ll u){\n    if (u==par[u]) return u;\n    return (par[u]=find(par[u]));\n}\nvoid join (ll u, ll v){\n    ll x=find(u),y=find(v);\n    if (x==y) return;\n    par[x]=y;\n}\nvoid prep(){\n    rep(i,2,2*N-1) lg[i]=lg[i/2]+1;\n}\nvoid solve()\n{\n    cin>>n;\n    rep(i,1,n) pos[i]={0,0},par[i]=i;\n    rep(i,1,2*n){\n        cin>>a[i];\n        if (pos[a[i]].F==0) pos[a[i]].F=i;\n        else \n        {\n            pos[a[i]].S=i;\n            ll pf=pos[a[i]].F,ps=i;\n            gmi[0][pf]=pf;\n            gmi[0][ps]=pf;\n            gma[0][pf]=ps;\n            gma[0][ps]=ps;\n        }\n    }\n    rep(i,1,19)\n    rep(j,1,2*n) if (j+(1<<i)-1<=2*n) gmi[i][j]=min(gmi[i-1][j],gmi[i-1][j+(1<<(i-1))]);\n    rep(i,1,19)\n    rep(j,1,2*n) if (j+(1<<i)-1<=2*n) gma[i][j]=max(gma[i-1][j],gma[i-1][j+(1<<(i-1))]);\n    rep(i,1,n){\n        ll l=pos[i].F,r=pos[i].S;\n        ii pd=get(l,r);\n        ll x=pd.F,y=pd.S;\n        join(i,a[x]);\n        join(i,a[y]);\n    }\n    sort(pos+1,pos+n+1);\n    ll res=0,mx=0;\n    rep(i,1,n) if (pos[i].F>mx){\n        R[res]=mx;\n        res++;\n        mx=pos[i].S;\n    }\n    else mx=max(mx,(ll)pos[i].S);\n    cout<<res<<\" \";\n    R[res]=2*n;\n    res=1;\n    ll tmp=1;\n    ll cnt=0;\n    rep(i,1,2*n){\n        if (i>R[cnt]){\n            cnt++;\n            (res*=tmp)%=mod;\n            tmp=0;\n        }\n        if (find(a[i])==find(a[R[cnt]])) tmp++;\n    }\n    (res*=tmp)%=mod;\n    cout<<res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n    }\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "dfs and similar",
        "dp",
        "graphs",
        "hashing"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G2. Light Bulbs  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/123530",
    "editorial": "Let\u00e2\u0080\u0099s call a contiguous segment of lamps if the number of lamps for each\r\ncolor is either or in this segment. For example, a segment of lamps is\r\nclosed. Furthermore, let\u00e2\u0080\u0099s say that a closed segment of lamps is if it\r\nis impossible to split it into multiple closed segments. For example, is\r\nminimal, but is not since it can be split into and (which are\r\nclosed).Each closed segment has the following property: if you start\r\nwith any lamp in this segment, you cannot \"leave\" this segment; i. e.\r\nyou cannot use the lamps from this segment to light any lamps outside.\r\nTo prove this, let\u00e2\u0080\u0099s suppose the opposite: we started in the closed\r\nsegment and managed to turn a lamp of color outside that segment on (and\r\nthis was the first lamp outside of the segment we turned on). We could\r\nnot do it with the operation of the first type, since it would mean that\r\nthe other lamp of color is in the segment (so it is not closed); and we\r\ncould not do it with the operation of the second type, since for every\r\ncolor present in the closed segment, both lamps of that color (and the\r\nsegment they can light up) belong to the closed segment.For every\r\nminimal closed segment, we can light it up using just one lamp (for\r\nexample, the first lamp). So, to calculate the minimum possible size of\r\na set of lamps we initially turn on, we can just split the given\r\nsequence of colors into minimal closed segments.Unfortunately,\r\ncalculating the number of possible sets of lamps is trickier. For every\r\nminimal closed segment we got, we can calculate the number of \"starting\"\r\nlamps that allow us to light the whole segment, and multiply them.\r\nHowever, not every lamp from a minimal closed segment can be a\r\n\"starting\" lamp: for example, in the segment , any lamp of color can be\r\nused, but no lamp of other color can be used.To deal with this, let us\r\nfind minimal closed segments in the sequence of colors. In the example\r\nabove, we have to find out that both the segments and are closed; and\r\nsince lamps of colors and belong to the \"inner\" closed segment, they\r\ncannot be used to light the whole \"outer\" closed segment. So, if a lamp\r\nbelongs to any of the \"inner\" closed segments, it cannot be used as a\r\nstarting lamp. Let\u00e2\u0080\u0099s mark all such lamps.We can also show that if a lamp\r\nis not marked, it can be used as a starting lamp. It is because if we\r\nstart with some lamp and try to turn on everything we can with the\r\noperations given in the statement, we will get precisely the shortest\r\nclosed segment that lamp belongs to. Proving it is not that hard:\r\nsuppose we stopped before turning the whole shortest closed segment on;\r\neither we got multiple segments of lamps (and we can turn on everything\r\nin between them), or we got a segment which is not closed (and for at\r\nleast one color, there is exactly one lamp in it; so we can light the\r\nother lamp of that color).Okay, let\u00e2\u0080\u0099s recap. Our solution consists of\r\nthe following steps: find all minimal closed segments of lamps; for\r\nevery \"inner\" segment, mark all lamps in it to show they cannot be used\r\nas the starting lamps; split the given sequence of colors into the\r\nminimum number of segments; for each segment we got from the split,\r\ncalculate the number of unmarked lamps and multiply those values. The\r\nmost difficult part is finding all minimal closed segments of lamps. To\r\nget a solution in something like , we can do it naively: iterate on the\r\nleft border of the segment, add the first lamp in the segment, and keep\r\nadding next lamps until the number of lamps of each color becomes either\r\nor . That\u00e2\u0080\u0099s how the easy version of the problem is solved.For the hard\r\nversion, this is too slow. We have to find the closed segments faster.\r\nIn order to do this, we can use hashing. Many hashing methods can help,\r\nbut in my opinion, the most elegant one is XOR hashing, which works as\r\nfollows:For each color, generate a random -bit integer and replace both\r\noccurrences of that color with the generated number. Then, if the\r\nsegment is closed, the XOR of all numbers in the segment is equal to\r\n(each color occurs either or times, thus each integer is taken either or\r\ntimes, and all integers taken twice cancel out).This allows us to find\r\nall minimal closed segments in as follows: iterate on the array of\r\ncolors from left to right, maintaining the XOR on the current prefix and\r\na map where, for each XOR we encountered, we store the longest prefix\r\nwhich has that value of XOR. Then, after we process the -th element, we\r\ncan quickly find the left border of the segment ending in the -th\r\nelement by looking for the current XOR in the map. Don\u00e2\u0080\u0099t forget to\r\nupdate the map after that.That way, we arrive at a solution which works\r\nin , which is enough to solve the hard version.\r\n"
}