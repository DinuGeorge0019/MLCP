{
    "link": "https://codeforces.com//contest/1283/problem/C",
    "problemId": "504969",
    "problem_idx": "C",
    "shortId": "1283C",
    "contest_number": "1283",
    "problem_submissions": {
        "F": [
            67823245,
            67834634,
            67835859,
            67839332,
            67838778,
            68029277,
            67864524
        ],
        "E": [
            67815384,
            67819003,
            67822271,
            67817278,
            67817529,
            67816830,
            67820462,
            67815674,
            67819758,
            67822559,
            67825595,
            67826555,
            67825514,
            67818583,
            67817970,
            67826757
        ],
        "D": [
            67813119,
            67814942,
            67816390,
            67814327,
            67815165,
            67820564,
            67815719,
            67818760,
            67815953,
            67817694,
            67816237,
            67818386,
            67815983,
            67828465,
            67827664,
            67818584
        ],
        "C": [
            67810342,
            67821978,
            67810773,
            67807591,
            67808305,
            67810663,
            67811193,
            67813438,
            67808771,
            67811324,
            67808499,
            67810527,
            67810581,
            67811981,
            67810947,
            67812828
        ],
        "B": [
            67801292,
            67798549,
            67803137,
            67801302,
            67801574,
            67803276,
            67803578,
            67802026,
            67802576,
            67803714,
            67801063,
            67802206,
            67802199,
            67800040,
            67804358,
            67805065
        ],
        "A": [
            67797268,
            67797074,
            67797886,
            67797463,
            67797278,
            67797741,
            67798798,
            67797264,
            67798057,
            67798392,
            67797423,
            67797193,
            67798258,
            67797376,
            67798881,
            67799553
        ]
    },
    "name": "C. Friends and Gifts",
    "statement": "There are n friends who want to give gifts for the New Year to each\r\nother. Each friend should give one gift and receive one gift. The friend\r\ngive the gift to himself.For each friend the value f_i is known: it is\r\neither f_i = 0 if the i-th friend doesn\u2019t know whom he wants to give the\r\ngift to or 1\r\nle f_i\r\nle n if the i-th friend wants to give the gift to the friend f_i.You\r\nwant to fill in the unknown values (f_i = 0) in such a way that each\r\nfriend gives one gift and receives one gift and there is friend who\r\ngives the gift to himself. It is guaranteed that the initial information\r\nisn\u2019t contradictory.If there are several answers, you can print any.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\nint inDegree[MAXN];\nint outDegree[MAXN];\n\nvector< int > remain;\n\nvoid add(int U, int V)\n{\n\toutDegree[U]++;\n\tinDegree[V]++;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tscanf(\"%d\",&v[i]);\n\n\t\tif( v[i] != 0 ) add( i , v[i] );\n\t}\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tif( inDegree[i] == 0 && outDegree[i] == 0 ) remain.push_back( i );\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tif( inDegree[i] != 0 || outDegree[i] == 0 ) continue;\n\n\t\tint cur = i;\n\n\t\twhile( v[cur] != 0 ) cur = v[cur];\n\n\t\tif( remain.size()%2 == 1 )\n\t\t{\n\t\t\tint V = remain.back();\n\t\t\tremain.pop_back();\n\n\t\t\tv[cur] = V;\n\t\t\tv[ V ] = i;\n\n\t\t\tadd( cur , V );\n\t\t\tadd( V , i );\n\t\t}\n\t\telse v[ cur ] = i, add( cur , i );\n\t}\n\n\tif( remain.size()%2 == 1 )\n\t{\n\t\tint sz = remain.size();\n\n\t\tint A = remain[sz - 1];\n\t\tint B = remain[sz - 2];\n\t\tint C = remain[sz - 3];\n\n\t\tv[A] = B;\n\t\tv[B] = C;\n\t\tv[C] = A;\n\n\t\tadd( A , B );\n\t\tadd( B , C );\n\t\tadd( C , A );\n\n\t\tremain.pop_back();\n\t\tremain.pop_back();\n\t\tremain.pop_back();\n\t}\n\n\twhile( remain.size() > 0 )\n\t{\n\t\tint sz = remain.size();\n\n\t\tint A = remain[sz - 1];\n\t\tint B = remain[sz - 2];\n\n\t\tv[A] = B;\n\t\tv[B] = A;\n\n\t\tadd( A , B );\n\t\tadd( B , A );\n\n\t\tremain.pop_back();\n\t\tremain.pop_back();\n\t}\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tprintf(\"%d \",v[i]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Friends and Gifts.json",
    "editorial_link": "https://codeforces.com//blog/entry/72592",
    "editorial": "In this problem, we need to print the permutation without fixed points\r\n(without values ) but some values are known in advance. Let\u00e2\u0080\u0099s consider\r\nthe permutation as a graph. We know that the permutation is the set of\r\nnon-intersecting cycles. In this problem, we are given such a graph but\r\nsome edges are removed. How to deal with it?Firstly, let\u00e2\u0080\u0099s find isolated\r\nvertices in the graph. Let its number be . If then all is ok and we skip\r\nthe current step. If then let\u00e2\u0080\u0099s pin this isolated vertex to any vertex\r\nto which we can pin it. Otherwise, and we can create the chine\r\nconsisting of all isolated vertices.Now and we can finally construct the\r\nremaining part of the graph. We can notice that we have the same number\r\nof vertices with zero incoming and zero outcoming degrees. And because\r\nwe got rid of all possible loops in the graph, we can match these\r\nvertices as we want.Time complexity: .\r\n"
}