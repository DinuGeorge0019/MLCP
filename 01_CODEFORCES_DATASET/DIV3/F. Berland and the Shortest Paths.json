{
    "link": "https://codeforces.com//contest/1005/problem/F",
    "problemId": "196286",
    "problem_idx": "F",
    "shortId": "1005F",
    "contest_number": "1005",
    "problem_submissions": {
        "F": [
            40138065,
            40147546,
            40139536,
            40144099,
            40139733,
            40144938,
            40143679,
            40171160,
            40146303,
            40189217
        ],
        "E1": [
            40128340,
            40127186,
            40134838,
            40136234,
            40136089,
            40143692,
            40135301,
            40137180,
            40144323,
            40124841,
            40127912,
            40131265,
            40133189,
            40133105,
            40133937,
            40134875,
            40135625,
            40134421,
            40131595,
            40135137
        ],
        "D": [
            40125067,
            40124979,
            40128112,
            40136992,
            40132454,
            40129148,
            40135768,
            40128554,
            40130545,
            40126741,
            40124080,
            40124881,
            40127069,
            40127363,
            40130715,
            40128279,
            40129716,
            40130196,
            40122168,
            40126677
        ],
        "C": [
            40122844,
            40120537,
            40121740,
            40127956,
            40126845,
            40126210,
            40127542,
            40132586,
            40121476,
            40122273,
            40121226,
            40121504,
            40123842,
            40124485,
            40124848,
            40125814,
            40188075,
            40124052,
            40125727,
            40127465,
            71194295,
            40123366
        ],
        "B": [
            40118557,
            40118253,
            40123880,
            40122022,
            40117993,
            40119623,
            40121553,
            40121128,
            40129302,
            40117431,
            40118713,
            40118894,
            40119013,
            40119692,
            40120886,
            40121682,
            40120694,
            40121733,
            40125463,
            40118716
        ],
        "A": [
            40117449,
            40117425,
            40122790,
            40118389,
            40117428,
            40118037,
            40118019,
            40118741,
            40117459,
            40117842,
            40117471,
            40117684,
            40117553,
            40117896,
            40118376,
            40119285,
            40118988,
            40117794,
            40123668,
            40117617
        ],
        "E2": [
            40142192,
            40138140,
            40137960,
            97340051,
            97338094,
            40194804,
            40187840
        ]
    },
    "name": "F. Berland and the Shortest Paths",
    "statement": "There are n cities in Berland. Some pairs of cities are connected by\r\nroads. All roads are bidirectional. Each road connects two different\r\ncities. There is at most one road between a pair of cities. The cities\r\nare numbered from 1 to n.It is known that, from the capital (the city\r\nwith the number 1), you can reach any other city by moving along the\r\nroads.The President of Berland plans to improve the country\u2019s road\r\nnetwork. The budget is enough to repair exactly n-1 roads. The President\r\nplans to choose a set of n-1 roads such that: it is possible to travel\r\nfrom the capital to any other city along the n-1 chosen roads, if d_i is\r\nthe number of roads needed to travel from the capital to city i, moving\r\nonly along the n-1 chosen roads, then d_1 + d_2 +\r\ndots + d_n is minimized (i.e. as minimal as possible). In other words,\r\nthe set of n-1 roads should preserve the connectivity of the country,\r\nand the sum of distances from city 1 to all cities should be minimized\r\n(where you can only use the n-1 chosen roads).The president instructed\r\nthe ministry to prepare k possible options to choose n-1 roads so that\r\nboth conditions above are met.Write a program that will find k possible\r\nways to choose roads for repair. If there are fewer than k ways, then\r\nthe program should output all possible valid ways to choose roads.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl \"\\n\"\n#define ft first\n#define sd second\n#define openfiles ifstream cin (\"input.txt\"); ofstream cout (\"output.txt\");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, k;\n    vector<vector<int>> G;\n    vector<int> flag;\n    vector<vector<int>> colors;\n    map<pii, int> roads;\n    vector<bool> Ans;\n\n    vector<vector<bool>> ANSWER;\n\nvoid bfs(int x);\nvoid dfs();\nvoid out();\nint Nikita_apni_uje_sini(int i);\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    cin >> n >> m >> k;\n    G.assign(n, vector<int>(0, 0));\n    flag.assign(n, 0);\n    colors.assign(n, vector<int>(0,0));\n\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        G[x].pb(y);\n        G[y].pb(x);\n        roads[{x, y}] = i;\n        roads[{y, x}] = i;\n    }\n\n    bfs(0);\n\n    dfs();\n\n    Ans.assign(m, 0);\n    Nikita_apni_uje_sini(1);\n\n    cout << ANSWER.size() << endl;\n\n    for (auto i : ANSWER) {\n        for (auto j : i) {\n            cout << j;\n        }cout << endl;\n    }\n\n}\n\n\nint Nikita_apni_uje_sini(int i) {\n    if (i == n) {\n        out();\n        k--;\n    } else {\n        for (int x: colors[i]) {\n            Ans[x] = 1;\n            if (Nikita_apni_uje_sini(i+1) == 998244353) {\n                return 998244353;\n            }\n            Ans[x] = 0;\n        }\n    }\n\n    if (k == 0) {\n        return 998244353;\n    } else {\n        return 0;\n    }\n}\n\n\nvoid out() {\n    /**for (int i = 0; i < m; i++) {\n        cout << Ans[i];\n    }cout << endl;*/\n    ANSWER.pb(Ans);\n}\n\nvoid bfs(int x) {\n    (n, 0);\n    deque<int> O;\n    O.pb(x);\n    flag[x] = 1;\n\n    while(!O.empty()) {\n\n        x = O.front();\n        O.pop_front();\n\n        for (int y: G[x]) {\n            if (!flag[y]) {\n                flag[y] = flag[x] +1;\n                O.pb(y);\n            }\n        }\n\n    }\n}\n\nvoid dfs() {\n\n    int clr = 1;\n\n    for (int x = 1; x < n; x++) {\n\n        for (int y: G[x]) {\n            if (flag[y] < flag[x]) {\n                int road_number = roads[{x, y}];\n                colors[x].pb(road_number);\n            }\n        }\n\n    }\n\n}\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Berland and the Shortest Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/60511",
    "editorial": "Use BFS to precalculate an array the array of the shortest path lengths\r\nfrom the Capital.The condition to minimize sum of distances in each tree\r\nis equal to the fact that each tree is a shortest path tree. Let\u00e2\u0080\u0099s think\r\nabout them as about oriented outgoing from the Capital trees. Moving\r\nalong edges of such trees, you always move by shortest paths.An edge can\r\nbe included into such a tree if and only if (since original edges are\r\nbidirectional, you should consider each of them twice: as and as ).\r\nLet\u00e2\u0080\u0099s focus only on edges for which . Call them \"red\" edges.To build a\r\ntree for each city (except the Capital) you should choose exactly one\r\nred edge finishing in this city. That\u00e2\u0080\u0099s why the number of suitable trees\r\nis a product of numbers of incoming edges over all vertices (cities).But\r\nwe need to find only of such trees. Let\u00e2\u0080\u0099s start from some such tree and\r\nrebuild it on each step. As initial tree you can choose the first\r\nincoming red edge into each vertex (except the City). Actually, we will\r\ndo exactly increment operation for number in a mixed radix notation.To\r\nrebuild a tree iterate over vertices and if the current used red edge is\r\nnot the last for the vertex, use the next and stop algorithm. Otherwise\r\n(the last red edge is used), use the first red edge for this vertex (and\r\ngo to the next vertex) and continue with the next vertex. Compare this\r\nalgorithm with simple increment operation for long number.\r\n"
}