{
    "link": "https://codeforces.com//contest/1741/problem/D",
    "problemId": "1580860",
    "problem_idx": "D",
    "shortId": "1741D",
    "contest_number": "1741",
    "problem_submissions": {
        "G": [
            175658655,
            175776548,
            175778289,
            175654398,
            175880793,
            175656924,
            175637609,
            175729544,
            176113562
        ],
        "F": [
            175634710,
            175634330,
            175639332,
            175634963,
            175641391,
            175642288,
            175651066,
            175638700,
            175650758,
            175650474,
            175650413,
            175696195,
            175630855,
            175641068,
            175713558,
            175713496,
            175713405,
            175713348,
            175712166,
            175712032,
            175710248,
            175653725,
            188881508,
            175657954,
            175660445,
            175647171
        ],
        "E": [
            175612842,
            175607012,
            175602583,
            175610869,
            175597285,
            175603137,
            175605173,
            175613578,
            175612154,
            175602225,
            175611227,
            175622904,
            175609226,
            175636862,
            175596615,
            175626249,
            175618084,
            175609955,
            175614301,
            175619312
        ],
        "D": [
            175600792,
            175598753,
            175587861,
            175602078,
            175590264,
            175593902,
            175593998,
            175614050,
            175599808,
            175588551,
            175598698,
            175602136,
            175595713,
            175593039,
            175644398,
            175600557,
            175714317,
            175605116,
            175598500,
            175596629,
            175607880
        ],
        "C": [
            175590194,
            175585809,
            175713811,
            175588824,
            175588091,
            175585251,
            175586131,
            175579401,
            175581660,
            175576056,
            175582459,
            175579198,
            175578713,
            175576074,
            175578615,
            175581737,
            175586416,
            175584583,
            175585714,
            175593866
        ],
        "B": [
            175579146,
            175570687,
            175567044,
            175573608,
            175578477,
            175570022,
            175570101,
            175572940,
            175567692,
            175571900,
            175569281,
            175569338,
            175568386,
            175570488,
            175571800,
            175575494,
            175567609,
            175569238,
            175585403
        ],
        "A": [
            175563566,
            175564993,
            175563738,
            175564174,
            175564333,
            175564490,
            175563949,
            175567859,
            175563695,
            175565037,
            175565795,
            175565035,
            175564013,
            175564907,
            175683101,
            175567126,
            175709307,
            175566606,
            175563970,
            175564612,
            175568510
        ]
    },
    "name": "D. Masha and a Beautiful Tree",
    "statement": "The girl named Masha was walking in the forest and found a complete\r\nbinary tree of height n and a permutation p of length m=2^n.A complete\r\nbinary tree of height n is a rooted tree such that every vertex except\r\nthe leaves has exactly two sons, and the length of the path from the\r\nroot to any of the leaves is n. The picture below shows the complete\r\nbinary tree for n=2.A permutation is an array consisting of n different\r\nintegers from 1 to n. For example, [2,3,1,5,4] is a permutation, but\r\n[1,2,2] is not (2 occurs twice), and [1,3,4] is also not a permutation\r\n(n=3, but there is 4 in the array).Let’s enumerate m leaves of this tree\r\nfrom left to right. The leaf with the number i contains the value p_i (1\r\nle i\r\nle m).For example, if n = 2, p = [3, 1, 4, 2], the tree will look like\r\nthis: Masha considers a tree if the values in its leaves are ordered\r\nfrom left to right in increasing order.In one operation, Masha can\r\nchoose any non-leaf vertex of the tree and swap its left and right sons\r\n(along with their subtrees).For example, if Masha applies this operation\r\nto the root of the tree discussed above, it will take the following\r\nform: Help Masha understand if she can make a tree in a certain number\r\nof operations. If she can, then output the minimum number of operations\r\nto make the tree .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nint A[300000], N;\n\n// [l, r)\nint f(int l, int r) {\n  bool sorted = true;\n  for (int i = l+1; i < r; i++)\n    sorted &= A[i-1] <= A[i];\n  if (sorted) return 0;\n\n  int m = (l + r) / 2;\n  int ans_l = f(l, m);\n  if (ans_l < 0) return -1;\n  int ans_r = f(m, r);\n  if (ans_r < 0) return -1;\n\n  int ans = ans_l + ans_r;\n  if (A[m-1] > A[m]) {\n    ans++;\n    for (int i = l; i < m; i++)\n      swap(A[i], A[i-l+m]);\n  }\n\n  sorted = true;\n  for (int i = l+1; i < r; i++)\n    sorted &= A[i-1] <= A[i];\n  if (!sorted) return -1;\n  return ans;\n}\n\nvoid solve() {\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> A[i];\n\n  printf(\"%d\\n\", f(0, N));\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "divide and conquer",
        "graphs",
        "sortings",
        "trees"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Masha and a Beautiful Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/107908",
    "editorial": "Let some vertex be responsible for a segment of leaves . Then her left\r\nson is responsible for the segment , and the right for the segment .\r\nNote that if we do not apply the operation to this vertex, then it will\r\nnot be possible to move some element from the right sonâs segment to the\r\nleft sonâs segment. It remains to understand when we need to apply the\r\noperation to the vertex. Let the maximum on the segment be , the minimum\r\non the same segment is . Then if lies in the right son, and in the left,\r\nthen we should obviously apply the operation, for the reason described\r\nabove. In the case when lies in the left son, and in the right, the\r\napplication of the operation will definitely not allow you to get a\r\nsolution. Letâs continue to act in a similar way recursively from the\r\nchildren of the current vertex. At the end, we should check whether we\r\nhave received a sorted permutation. The above solution works for , since\r\nthere are levels in the tree and at each level, vertexes are responsible\r\nfor sheets in total. You can optimize this solution to if you\r\npre-calculate the maximum and minimum for each vertex.\r\n",
    "hint": []
}