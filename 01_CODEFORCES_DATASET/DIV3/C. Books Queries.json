{
    "link": "https://codeforces.com//contest/1066/problem/C",
    "problemId": "235861",
    "problem_idx": "C",
    "shortId": "1066C",
    "contest_number": "1066",
    "problem_submissions": {
        "F": [
            44205429,
            44212106,
            44214312,
            44211772,
            44215735,
            44216480,
            44217948,
            44226593
        ],
        "A": [
            44198897,
            44190264,
            44190996,
            44190521,
            44194374,
            44191748,
            44192884,
            44190114,
            44190457,
            44190392,
            44190295,
            44232541,
            44190105,
            44190131,
            44190364,
            44190102,
            44190147,
            44190161,
            44189962,
            44194814,
            44190476
        ],
        "B": [
            44197927,
            44195073,
            44192967,
            44193419,
            44192423,
            44197883,
            44195893,
            44197752,
            44191223,
            44190844,
            44195475,
            44193709,
            44258187,
            44195185,
            44192726,
            44197021,
            44193282,
            44199995,
            44192974,
            44197693,
            44198781,
            44196227
        ],
        "E": [
            44194302,
            44198044,
            44197688,
            44200186,
            44206112,
            44204683,
            44211808,
            44198204,
            44195532,
            44205080,
            44203248,
            44258229,
            44204157,
            44207684,
            44206425,
            44203537,
            44205955,
            44206848,
            44208459,
            44207862,
            44206046
        ],
        "D": [
            44192050,
            44200143,
            44200943,
            44204312,
            44203052,
            44199330,
            44205029,
            44195917,
            44202796,
            44193485,
            44198842,
            44258212,
            44199756,
            44199261,
            44202172,
            44206141,
            44203730,
            44203685,
            44199896,
            44193449,
            44202596
        ],
        "C": [
            44190191,
            44192207,
            44196592,
            44195653,
            44199921,
            44207097,
            44202048,
            44193208,
            44195430,
            44199895,
            44196374,
            44258203,
            44196767,
            44197574,
            44194617,
            44197700,
            44192395,
            44195734,
            44195568,
            44200428,
            44198081
        ]
    },
    "name": "C. Books Queries",
    "statement": "You have got a shelf and want to put some books on it.You are given q\r\nqueries of three types: id put a book having index id on the shelf to\r\nthe left from the leftmost existing book; id put a book having index id\r\non the shelf to the right from the rightmost existing book; id calculate\r\nthe minimum number of books you need to pop from the left or from the\r\nright in such a way that the book with index id will be leftmost or\r\nrightmost. You can assume that the first book you will put can have any\r\nposition (it does not matter) and queries of type 3 are always valid (it\r\nis guaranteed that the book in each such query is already placed). You\r\ncan also assume that you don\u2019t put the same book on the shelf twice, so\r\nids don\u2019t repeat in queries of first two types.Your problem is to answer\r\nall the queries of type 3 in order they appear in the input.Note that\r\nafter answering the query of type 3 all the books remain on the shelf\r\nand the relative order of books does not change.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << '=' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << \" = {\"; FOR(_, l, r) cerr << ' ' << a[_]; cerr << \"}\\n\"; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl '\\n'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname \"\"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N];\nint main() {\n    #ifdef NERO\n    freopen(\"test.inp\",\"r\",stdin);\n    freopen(\"test.out\",\"w\",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname\".inp\",\"r\",stdin);\n        //freopen(taskname\".out\",\"w\",stdout);\n    #endif //NERO\n    IO;\n    int q;\n    cin >> q;\n    int l = 1, r = 0;\n    REP(i, q) {\n        char type;\n        int id;\n        cin >> type >> id;\n        if (type == 'L') {\n            l--;\n            a[id] = l;\n        }\n        if (type == 'R') {\n            r++;\n            a[id] = r;\n        }\n        if (type == '?') {\n            cout << min(a[id] - l, r - a[id]) << endl;\n        }\n    }\n    #ifdef NERO\n    double etime = clock();\n    cerr << \"Execution time: \" << (etime - stime) / CLOCKS_PER_SEC * 1000 << \" ms.\\n\";\n    #endif // NERO\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Books Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/62419",
    "editorial": "Let imagine our shelf as an infinite array. Let\u00e2\u0080\u0099s carry the rightmost\r\nfree position from the left of our shelf (let it be and initially it\r\nequals to ) and the leftmost free position from the right of our shelf\r\n(let it be and initially it equals to ). Also let\u00e2\u0080\u0099s carry the array of\r\nlength where will be equal to the position in our imaginary array of the\r\nbook with a number .Let\u00e2\u0080\u0099s put the first book to the position . Also\r\nlet\u00e2\u0080\u0099s save that (where is the number of the first book) equals to . How\r\nwill change and ? will become and will become . Now let\u00e2\u0080\u0099s process\r\nqueries one by one. If now we have the query of type with a book with a\r\nnumber , then let\u00e2\u0080\u0099s set and set . The query of type can be processed\r\nsimilarly. Now what about queries of type ? The answer to this query\r\nequals to , where is the absolute value of .\r\n"
}