{
    "link": "https://codeforces.com//contest/1878/problem/E",
    "problemId": "2229486",
    "problem_idx": "E",
    "shortId": "1878E",
    "contest_number": "1878",
    "problem_submissions": {
        "G": [
            225357770,
            225356148,
            225378677,
            225396088,
            225913288,
            225913201,
            225920084,
            225806168
        ],
        "E": [
            225342729,
            225298379,
            225344738,
            225348985,
            225318623,
            225299675,
            225329860,
            225336305,
            225327357,
            225306213,
            225322089,
            225309942,
            225339644,
            225341224,
            225341243,
            225343329,
            225344211,
            225338004,
            225316088
        ],
        "D": [
            225335832,
            225341527,
            225309051,
            225331018,
            225323094,
            225338405,
            225319972,
            225330316,
            225308377,
            225329843,
            225347560,
            225344567,
            225325782,
            225334610,
            225324123,
            225325861,
            225322057,
            225328040,
            225346585
        ],
        "C": [
            225318388,
            225345357,
            225316589,
            225296717,
            225295479,
            225291873,
            225287260,
            225292130,
            225288945,
            225292627,
            225291194,
            225293331,
            225301422,
            225296957,
            225301805,
            225302804,
            225306798,
            225304842,
            225306017
        ],
        "F": [
            225309193,
            225371590,
            225359110,
            225363020,
            225336771,
            225356090,
            225361957,
            225350800,
            225360150,
            225370320,
            225377951,
            225387862,
            225369402,
            225367044,
            225368506,
            225373551,
            225374797,
            225379464,
            225370893
        ],
        "B": [
            225289378,
            225311939,
            225302167,
            225288412,
            225283039,
            225282551,
            225280252,
            225288368,
            225281781,
            225285957,
            225281577,
            225284558,
            225292958,
            225290446,
            225282910,
            225296220,
            225284347,
            225295270,
            225303310
        ],
        "A": [
            225283036,
            225276287,
            225280098,
            225277273,
            225274431,
            225277937,
            225274529,
            225279212,
            225276095,
            225274228,
            225275085,
            225274508,
            225280174,
            225280595,
            225275774,
            225283697,
            225275093,
            225278575,
            225275576
        ]
    },
    "name": "E. Iva   Pav",
    "statement": "Iva gave Pav an array a of n elements.Let’s define f(l, r) = a_l\r\n&\r\na_{l+1}\r\n&\r\ndots\r\n&\r\na_r (here\r\n& denotes the bitwise AND operation). f(l, r) l>r.Iva also gave Pav q\r\nqueries.Each query consists of 2 numbers, k and l, and she wants Pav to\r\nfind the largest index r (l\r\nle r\r\nle n), such that f(l, r)\r\nge k. Pav wants to solve this problem fast because he doesn’t want to\r\nupset Iva. He needs your help.\r\n",
    "solutions": [
        "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200001], pre[200001][32];\ninline bool check(int l, int r, int k) {\n\tint ans = 0;\n\tfor (int i = 0; i ^ 32; ++i) {\n\t\tif (pre[r][i] - pre[l - 1][i] == r - l + 1)\n\t\t\tans |= 1 << i;\n\t}\n\treturn ans >= k;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, q;\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tcin >> a[i];\n\t\tcin >> q;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j ^ 32; ++j)\n\t\t\t\tpre[i][j] = pre[i - 1][j] + (a[i] >> j & 1);\n\t\t}\n\t\tfor (; q--;) {\n\t\t\tint L, k;\n\t\t\tcin >> L >> k;\n\t\t\tif (a[L] < k) {\n\t\t\t\tcout << \"-1 \";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = L, r = n, mid;\n\t\t\tfor (; l < r;) {\n\t\t\t\tmid = l + r + 1 >> 1;\n\t\t\t\tif (check(L, mid, k))\n\t\t\t\t\tl = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tcout << r << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Iva   Pav.json",
    "editorial_link": "https://codeforces.com//blog/entry/120813",
    "editorial": "We can, for each bit, calculate the prefix sums of the array ( is the\r\nnumber of occurrences of the -th bit in the first elements of the array.\r\nThis can be calculated in . We know that if , then the -th bit is\r\npresent in all elements of the subsegment [] of the array , which means\r\nthe value of is equal to the sum of all bits for which this condition is\r\ntrue on the subsegment from to , and we can calculate that in . Next,\r\nfor each query, we can use binary search to find , by calculating . If\r\nthen we found an index for which the condition is true, so we move the\r\nleft to , else we move the right to . This solution works in which is\r\naround operations, with a low constant factor.It is possible to optimize\r\nthe solution even more by using sparse tables, to calculate in therefore\r\nremoving the factor, but we think that sparse tables are a little bit\r\ntoo advanced of a topic for div3 E, so we didnât make that solution\r\nnecessary.\r\n",
    "hint": [
        "Hint 1 Try calculating bit by bit",
        "Hint 2 Which condition has to hold true for all elements on a subsegment , and for a certain bit, for that bit to be present in ?",
        "Hint 3 How can we check if that condition is true for a certain bit fast?",
        "Hint 4 Try prefix sums.",
        "Hint 5 Try binary search."
    ]
}