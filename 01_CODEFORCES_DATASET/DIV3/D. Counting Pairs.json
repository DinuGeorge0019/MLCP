{
    "link": "https://codeforces.com//contest/2051/problem/D",
    "problemId": "3099577",
    "problem_idx": "D",
    "shortId": "2051D",
    "contest_number": "2051",
    "problem_submissions": {
        "G": [
            297891656,
            297890696,
            297899138,
            297892259,
            297912620,
            297920714,
            297934708,
            297929892,
            297931851,
            297911736,
            297927208,
            297928317,
            297947772,
            297909767,
            297942983,
            297993500,
            297875875,
            297873133,
            297875271
        ],
        "F": [
            297856552,
            297878644,
            297873030,
            297875253,
            297891474,
            297895628,
            297891515,
            297904684,
            297959623,
            297914765,
            297882921,
            297895179,
            297910575,
            297923862,
            297919187,
            297917128,
            297916364,
            297943956,
            297865687,
            297864877,
            297909911
        ],
        "E": [
            297841786,
            297836575,
            297839584,
            297846936,
            297869096,
            297865734,
            297862813,
            297854892,
            297860094,
            297876823,
            297874225,
            297892538,
            297862291,
            297876371,
            297877246,
            297922331,
            297840776,
            297834266,
            297852254,
            297850894
        ],
        "D": [
            297824998,
            297828255,
            297829120,
            297836876,
            297843401,
            297839448,
            297844425,
            297835789,
            297837071,
            297862412,
            297866230,
            297845487,
            297868513,
            297862250,
            297899798,
            297831894,
            297830585,
            297845610,
            297833477
        ],
        "C": [
            297817405,
            297821512,
            297822005,
            297826169,
            297828699,
            297832899,
            297832376,
            297822832,
            297823992,
            297849370,
            297841820,
            297834151,
            297857822,
            297848820,
            297891200,
            297825348,
            297827127,
            297840542,
            297824191
        ],
        "B": [
            297813648,
            297815534,
            297817642,
            297818888,
            297819929,
            297820049,
            297826062,
            297814904,
            297817786,
            297837190,
            297825933,
            297817655,
            297849719,
            297836185,
            297885765,
            297815546,
            297824155,
            297835551,
            297813164
        ],
        "A": [
            297812430,
            297812527,
            297814260,
            297815468,
            297814137,
            297814651,
            297817327,
            297812582,
            297812492,
            297830581,
            297819762,
            297812887,
            297821437,
            297881803,
            297812726,
            297821513,
            297830979,
            297812442
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137623",
    "editorial": "There is a common trick in problems of the form \"count something on\r\nsegment \": calculate the answer for , and then subtract the answer for .\r\nWe can use this trick in our problem as follows: calculate the number of\r\npairs such that the sum of all other elements is less than , and\r\nsubtract the number of pairs such that the sum is less than .Now we need\r\nto solve the following problem: given an array and an integer ,\r\ncalculate the number of ways to choose () so that the sum of all\r\nelements, except for and , is less than .Naive solution (iterate on the\r\npair, calculate the sum of remaining elements) works in . It can be\r\nimproved to if, instead of calculating the sum of remaining elements in\r\n, we do it in : if we remove and , the remaining elements sum up to ,\r\nwhere is the sum of all elements.However, is still too slow. For every ,\r\nlet\u00e2\u0080\u0099s try to calculate the number of elements which \"match\" it faster.\r\nIf we sort the array, the answer won\u00e2\u0080\u0099t change; but in a sorted array,\r\nfor every , all possible values of form a suffix of the array (if and ,\r\nthen ). So, for every , let\u00e2\u0080\u0099s find the minimum such that ; all are\r\npossible \"matches\" for . This can be done with two pointers method: when\r\nwe decrease , the index won\u00e2\u0080\u0099t decrease.Unfortunately, this method has an\r\nissue. We need to calculate only pairs where , but this method doesn\u00e2\u0080\u0099t\r\nmaintain this constraint. However, this issue can be easily\r\nresolved.First, let\u00e2\u0080\u0099s get rid of pairs where . To do so, simply\r\ncalculate the number of indices such that .Then, let\u00e2\u0080\u0099s get rid of pairs\r\nwhere . For every such pair, there is a pair with where these two\r\nindices are swapped (and vice versa), so we just need to divide the\r\nnumber of pairs by .Now we have a solution working in for each test\r\ncase. Instead of two pointers, you can use binary search, the complexity\r\nwill be the same.\r\n",
    "name": "D. Counting Pairs",
    "statement": "You are given a sequence a, consisting of n integers, where the i-th\r\nelement of the sequence is equal to a_i. You are also given two integers\r\nx and y (x\r\nle y).A pair of integers (i, j) is considered if the following\r\nconditions are met: 1\r\nle i < j\r\nle n; if you simultaneously remove the elements at positions i and j\r\nfrom the sequence a, the sum of the remaining elements is at least x and\r\nat most y. Your task is to determine the number of pairs of integers for\r\nthe given sequence a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ll long longusing namespace std;\u00a0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\u00a0    int t;    cin >> t;\u00a0    while(t--){        ll n, x, y;        cin >> n >> x >> y;\u00a0        vector<ll> a(n);\u00a0        for(auto &val : a) {            cin >> val;        }\u00a0        ll S = 0;\u00a0        for(auto val : a) {            S += val;        }\u00a0        ll L = S - y;        ll R = S - x;\u00a0        L = max(L, (ll)2);        R = min(R, (ll)2000000000);\u00a0        sort(a.begin(), a.end());\u00a0        ll cnt = 0;\u00a0        for(ll i = 0; i < n-1; ++i){            ll lv = L - a[i];            ll uv = R - a[i];\u00a0            ll jl = lower_bound(a.begin() + i + 1, a.end(), lv) - a.begin();            ll ju = upper_bound(a.begin() + i + 1, a.end(), uv) - a.begin() - 1;\u00a0            if(jl <= ju && jl < n && ju >= i +1){                cnt += (ju - jl +1);            }        }\u00a0        cout << cnt << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Counting Pairs.json"
}