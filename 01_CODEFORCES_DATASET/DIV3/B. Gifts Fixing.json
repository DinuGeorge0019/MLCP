{
    "link": "https://codeforces.com//contest/1399/problem/B",
    "problemId": "691717",
    "problem_idx": "B",
    "shortId": "1399B",
    "contest_number": "1399",
    "problem_submissions": {
        "F": [
            89035173,
            89029933
        ],
        "E2": [
            89011999,
            89030510,
            89080621,
            89039473,
            89040534,
            89201926,
            89050383,
            89034156,
            89084070,
            89049259,
            89035111,
            89052507,
            89050541,
            89057093,
            89080141
        ],
        "E1": [
            88996046,
            89009546,
            89080613,
            89010335,
            89023941,
            89019900,
            89014538,
            89084044,
            89031455,
            89027397,
            89021735,
            89030142,
            89008436,
            89007483,
            89015010,
            89097316,
            89017545,
            89018333,
            89016025,
            89019887,
            89020808
        ],
        "D": [
            88983986,
            88986050,
            89080684,
            89080600,
            88990615,
            88995867,
            88990140,
            88981358,
            89083571,
            89083120,
            88982379,
            89003434,
            89001587,
            89002958,
            88987435,
            88992856,
            88978240,
            88981220,
            89097279,
            88987544,
            88985548,
            88986877,
            88997105
        ],
        "C": [
            88974580,
            88974518,
            89080589,
            88982402,
            88985705,
            88979354,
            88966362,
            89082893,
            88973387,
            88994104,
            88993313,
            88993807,
            88971087,
            88979014,
            88975937,
            88963847,
            89097258,
            88972661,
            88974247,
            88977241,
            88976735,
            88981249
        ],
        "B": [
            88964383,
            88965521,
            89080579,
            88970001,
            88977862,
            88967937,
            88959373,
            89082724,
            88963456,
            88986912,
            88979078,
            88973586,
            88969906,
            88966168,
            88957629,
            88964497,
            89097240,
            88962105,
            88966474,
            88966506,
            88969861
        ],
        "A": [
            88956237,
            88956430,
            89080574,
            88960295,
            88969663,
            88957655,
            88955164,
            89082748,
            88955338,
            88967328,
            88967166,
            88962494,
            88973926,
            88959306,
            88955102,
            88955579,
            89097191,
            88955839,
            88955943,
            88956625,
            88962720
        ]
    },
    "name": "B. Gifts Fixing",
    "statement": "You have n gifts and you want to give all of them to children. Of\r\ncourse, you don’t want to offend anyone, so all gifts should be equal\r\nbetween each other. The i-th gift consists of a_i candies and b_i\r\noranges.During one move, you can choose some gift 1\r\nle i\r\nle n and do one of the following operations: eat exactly from this gift\r\n(decrease a_i by one); eat exactly from this gift (decrease b_i by one);\r\neat exactly and exactly from this gift (decrease both a_i and b_i by\r\none). Of course, you can not eat a candy or orange if it’s not present\r\nin the gift (so neither a_i nor b_i can become less than zero).As said\r\nabove, all gifts should be equal. This means that after some sequence of\r\nmoves the following two conditions should be satisfied: a_1 = a_2 =\r\ndots = a_n and b_1 = b_2 =\r\ndots = b_n (and a_i equals b_i is ).Your task is to find the number of\r\nmoves required to equalize all the given gifts.You have to answer t\r\nindependent test cases.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define se second\n#define db double\n#define U unsigned\n#define P std::pair<int,int>\n#define LL long long\n#define pb push_back\n#define MP std::make_pair\n#define all(x) x.begin(),x.end()\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(int i = a;i <= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 50+5;\nint a[MAXN],b[MAXN],n;\nLL ans = 1e18;\n\ninline LL chk(int x,int y){\n    LL res = 0; \n    FOR(i,1,n){\n        if(a[i] < x || b[i] < y) return 1e18;\n        int d1 = a[i]-x,d2 = b[i]-y;\n        res += std::min(d1,d2);\n        res += std::max(d1,d2)-std::min(d1,d2);\n    }\n    return res;\n}\n\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--){\n        scanf(\"%d\",&n);\n        FOR(i,1,n) scanf(\"%d\",a+i);\n        FOR(i,1,n) scanf(\"%d\",b+i);ans = 1e18;\n        FOR(i,1,n) FOR(j,1,n) ans = std::min(ans,chk(a[i],b[j]));\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Gifts Fixing.json",
    "editorial_link": "https://codeforces.com//blog/entry/81082",
    "editorial": "At first, consider the problems on candies and oranges independently.\r\nThen itâs pretty obvious that for candies the optimal way is to decrease\r\nall to the value (we need obtain at least this value to equalize all the\r\nelements and there is no point to decrease elements further). The same\r\nworks for the array . Then, if we unite these two problems, we need to\r\ntake the maximum moves we need for each , because we need exactly that\r\namount of moves to decrease to and to simultaneously.So, the answer is .\r\n",
    "hint": []
}