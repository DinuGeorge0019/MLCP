{
    "link": "https://codeforces.com//contest/1472/problem/G",
    "problemId": "854357",
    "problem_idx": "G",
    "shortId": "1472G",
    "contest_number": "1472",
    "problem_submissions": {
        "F": [
            103262561,
            103276963,
            103283145,
            103236120,
            103299603,
            103280037,
            103283982,
            103299636,
            103262171,
            103266435,
            103266707,
            103276432,
            103305724,
            103305561,
            103312140,
            103296820,
            103289516
        ],
        "G": [
            103247133,
            103238309,
            103265834,
            103256471,
            103273915,
            103293538,
            103298242,
            103268903,
            103231487,
            103253031,
            103265141,
            103262744,
            103269566,
            103284052,
            103274415
        ],
        "E": [
            103232102,
            103223895,
            103237385,
            103272807,
            103242184,
            103256098,
            103261560,
            103284295,
            103272410,
            103347793,
            103285217,
            103237054,
            103246827,
            103233098,
            103239873,
            103242625,
            103245603,
            103246214,
            103227701,
            103253419
        ],
        "D": [
            103207950,
            103207957,
            103217168,
            103202671,
            103216674,
            103217143,
            103225940,
            103215649,
            103278518,
            103287434,
            103203579,
            103227081,
            103193660,
            103216373,
            103212463,
            103198886,
            103214065,
            103204468,
            103205436
        ],
        "C": [
            103194323,
            103193866,
            103191356,
            103198459,
            103198975,
            103205574,
            103191182,
            103243332,
            103280810,
            103289310,
            103198851,
            103199943,
            103206511,
            103207377,
            103204240,
            103192503,
            103203543,
            103196542,
            103198696
        ],
        "B": [
            103191009,
            103189264,
            103188527,
            103213801,
            103193697,
            103201611,
            103200035,
            103198875,
            103286479,
            103291761,
            103193834,
            103194538,
            103187178,
            103193610,
            103194731,
            103188054,
            103194899,
            103190639,
            103190538
        ],
        "A": [
            103186521,
            103187194,
            103186563,
            103201739,
            103187144,
            103188906,
            103207506,
            103187635,
            103246273,
            103293364,
            103186560,
            103189197,
            103194552,
            103186844,
            103187875,
            103186517,
            103187671,
            103186808,
            103186538
        ]
    },
    "name": "G. Moving to the Capital",
    "statement": "There are n cities in Berland. The city numbered 1 is the capital. Some\r\npairs of cities are connected by a road of length 1.Before the trip,\r\nPolycarp for each city found out the value of d_i the shortest distance\r\nfrom the capital (the 1-st city) to the i-th city.Polycarp begins his\r\njourney in the city with number s and, being in the i-th city, chooses\r\none of the following actions: Travel from the i-th city to the j-th city\r\nif there is a road from the i-th city to the j-th and d_i < d_j; Travel\r\nfrom the i-th city to the j-th city if there is a road from the i-th\r\ncity to the j-th and d_i\r\ngeq d_j; Stop traveling. Since the government of Berland does not want\r\nall people to come to the capital, so Polycarp can take the second\r\naction from the list. in other words, he can perform the second action 0\r\nor 1 time during his journey. Polycarp, on the other hand, wants to be\r\nas close to the capital as possible. For example, if n = 6 and the\r\ncities are connected, as in the picture above, then Polycarp could have\r\nmade the following travels (not all possible options): 2\r\nrightarrow 5\r\nrightarrow 1\r\nrightarrow 2\r\nrightarrow 5; 3\r\nrightarrow 6\r\nrightarrow 2; 1\r\nrightarrow 3\r\nrightarrow 6\r\nrightarrow 2\r\nrightarrow 5. Polycarp wants for each starting city i to find out how\r\nclose he can get to the capital. More formally: he wants to find the\r\nminimal value of d_j that Polycarp can get from the city i to the city j\r\naccording to the rules described above.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n, m;\n\nvector <int> inEdges[N_MAX], outEdges[N_MAX];\n\nint d[N_MAX];\n\nqueue <int> q;\n\nvector <int> order;\n\nvoid bfs ()\n{\n    for(int i = 1; i <= n; i++)\n        d[i] = -1;\n    q.push(1);\n    d[1] = 0;\n    order.clear();\n    while(q.empty() == false)\n    {\n        int u = q.front();\n        order.push_back(u);\n        q.pop();\n        for(int v : outEdges[u])\n            if(d[v] == -1)\n            {\n                d[v] = d[u] + 1;\n                q.push(v);\n            }\n    }\n}\n\nint best[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n >> m;\n        for(int i = 1; i <= m; i++)\n        {\n            int u, v;\n            cin >> u >> v;\n            inEdges[v].push_back(u);\n            outEdges[u].push_back(v);\n        }\n        bfs();\n        for(int i = 1; i <= n; i++)\n        {\n            best[i] = d[i];\n            for(int j : outEdges[i])\n                best[i] = min(best[i], d[j]);\n        }\n        reverse(order.begin(), order.end());\n        for(int u : order)\n        {\n            for(int v : outEdges[u])\n                if(d[u] < d[v])\n                    best[u] = min(best[u], best[v]);\n        }\n        for(int i = 1; i <= n; i++)\n            cout << best[i] << \" \";\n        cout << \"\\n\";\n        for(int i = 1; i <= n; i++)\n        {\n            inEdges[i].clear();\n            outEdges[i].clear();\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Moving to the Capital.json",
    "editorial_link": "https://codeforces.com//blog/entry/86406",
    "editorial": "Find the distances to all vertices and construct a new graph that has\r\nonly edges that goes from a vertex with a smaller distance to a vertex\r\nwith a larger distance. Such a graph cannot contain cycles.Next, you\r\nneed to run a dynamic programming similar to finding bridges in an\r\nundirected graph. First, we write the minimum distance from each vertex\r\nto the capital using no more than one edge. This distance is either\r\nequal to the distance from the capital to the vertex itself, or the\r\ndistance to the vertex connected to us by one of the remote edges. We\r\ncanât go through more than one remote edge.The real answer for a vertex\r\nis the minimum of such values in all vertices reachable from in the new\r\ngraph. Since the new graph is acyclic, we can calculate the answer using\r\ndynamic programming and a depth-first search started from the capital.\r\n",
    "hint": []
}