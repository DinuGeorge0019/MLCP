{
    "link": "https://codeforces.com//contest/1520/problem/F1",
    "problemId": "976801",
    "problem_idx": "F1",
    "shortId": "1520F1",
    "contest_number": "1520",
    "problem_submissions": {
        "F2": [
            115377397,
            115305590,
            115287040,
            115299425,
            115275998,
            115291100,
            115279060,
            115289661,
            115284382,
            115289848,
            115308377,
            115278701,
            115306155,
            115291190,
            115265089,
            115307538,
            115303936,
            115461761,
            115294385,
            115296101
        ],
        "G": [
            115377372,
            115262775,
            115288422,
            115284069,
            115289230,
            115326140,
            115318505,
            115305519,
            115310728,
            115306048,
            115310484,
            115283392,
            115286859,
            115490380,
            115494255,
            115428029,
            115418593,
            115335990,
            115630972,
            115630383
        ],
        "F1": [
            115377349,
            115249032,
            115270195,
            115243368,
            115263879,
            115260580,
            115273435,
            115261038,
            115280609,
            115277317,
            115293876,
            115256261,
            115254859,
            115241348,
            115257133,
            115247327,
            115256409,
            115278650,
            115271950,
            115272669
        ],
        "E": [
            115377332,
            115237334,
            115239791,
            115237430,
            115247171,
            115242404,
            115248291,
            115250125,
            115252428,
            115257556,
            115318354,
            115247364,
            115240877,
            115248360,
            115247935,
            115237440,
            115241805,
            115254530,
            115253830,
            115256564
        ],
        "C": [
            115377311,
            115225774,
            115221824,
            115221195,
            115232319,
            115227403,
            115230041,
            115230111,
            115234657,
            115232187,
            115315640,
            115223231,
            115228100,
            115217322,
            115228063,
            115296150,
            115228425,
            115221440,
            115236900,
            115240483
        ],
        "D": [
            115377293,
            115218646,
            115225866,
            115229634,
            115238178,
            115231535,
            115237704,
            115234502,
            115238902,
            115239693,
            115238815,
            115228744,
            115221564,
            115219392,
            115231781,
            115227386,
            115230454,
            115232684,
            115243890,
            115245632
        ],
        "B": [
            115377281,
            115214791,
            115214878,
            115216679,
            115235400,
            115218148,
            115218189,
            115225076,
            115218800,
            115220311,
            115284747,
            115217692,
            115219291,
            115213196,
            115216288,
            115215912,
            115223513,
            115214573,
            115226157,
            115226244
        ],
        "A": [
            115377268,
            115212622,
            115212991,
            115213371,
            115214493,
            115214137,
            115213480,
            115215360,
            115213972,
            115213655,
            115216180,
            115212784,
            115213313,
            115212547,
            115212731,
            115213509,
            115217879,
            115212709,
            115218109,
            115218897
        ]
    },
    "name": "F1. Guess the K-th Zero  Easy version ",
    "statement": "Polycarp is playing a computer game. In this game, an array consisting\r\nof zeros and ones is hidden. Polycarp wins if he guesses the position of\r\nthe k-th zero from the left t times.Polycarp can make no more than 20\r\nrequests of the following type: l r find out the sum of all elements in\r\npositions from l to r (1\r\nle l\r\nle r\r\nle n) inclusive. To make the game more interesting, each guessed zero\r\nturns into one and the game continues on the changed array. More\r\nformally, if the position of the k-th zero was x, then after Polycarp\r\nguesses this position, the x-th element of the array will be replaced\r\nfrom 0 to 1. Of course, this feature affects something only for t>1.Help\r\nPolycarp win the game.\r\n",
    "solutions": [
        "#include \"bits/extc++.h\"\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << \"L\" << __LINE__ << \" [\" << #__VA_ARGS__ << \"]\" << \": \";       \\\nsep(cerr, \" | \", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n#define sz(x) int((x).size())\n\nint query(int l, int r) {\n\tcout << \"? \" << l + 1 << \" \" << r + 1 << endl;\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nint solve(int l, int r, int x) {\n\tif(l == r) {\n\t\tassert(x == 0);\n\t\treturn l;\n\t}\n\tint mid = (l + r) / 2;\n\tint lcnt = query(l, mid);\n\tlcnt = (mid - l + 1) - lcnt;\n\tif(x < lcnt) {\n\t\treturn solve(l, mid, x);\n\t}\n\treturn solve(mid + 1, r, x - lcnt);\n}\n\nvoid solve() {\n\tint n, t;\n\tcin >> n >> t;\n\twhile(t--) {\n\t\tint k;\n\t\tcin >> k;\n\t\tint ans = solve(0, n - 1, k - 1) + 1;\n\t\tcout << \"! \" << ans << endl;\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n//\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint t = 1;\n//\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << \"Case #\" << _ << \": \";\n\t\tsolve();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F1. Guess the K-th Zero  Easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/90342",
    "editorial": "This problem can be solved by binary search. Letâs maintain a segment\r\nthat is guaranteed to contain the -th zero and gradually narrow it\r\ndown.Let the current segment be and we want to find -th zero on it.\r\nLetâs make a query on the half of the segment , where . If there are at\r\nleast zeros on the left half of the segment, then we go to the left\r\nsegment and look for the -th zero.If there is only zeros on the left\r\nhalf, then we go to the right segment and look for -th zero.We will\r\nspend queries, which is within the limits.\r\n",
    "hint": []
}