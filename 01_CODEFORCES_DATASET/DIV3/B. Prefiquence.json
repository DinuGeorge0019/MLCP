{
    "link": "https://codeforces.com//contest/1968/problem/B",
    "problemId": "2623675",
    "problem_idx": "B",
    "shortId": "1968B",
    "contest_number": "1968",
    "problem_submissions": {
        "F": [
            259208894,
            259192204,
            259185814,
            259205926,
            259242959,
            259215044,
            259179290,
            259190114,
            259216954,
            259302916,
            259212644,
            259208852,
            259222440,
            259210837,
            259204073,
            259227691,
            259201018,
            259218958,
            259204819
        ],
        "E": [
            259198300,
            259183461,
            259215786,
            259191191,
            259192837,
            259198727,
            259236182,
            259168432,
            259184957,
            259179781,
            259194081,
            259195056,
            259231050,
            259231521,
            259327258,
            259180151,
            259200852,
            259182663,
            259179463,
            259183623
        ],
        "G2": [
            259186685,
            259239909,
            259237625,
            259241997,
            259235354,
            259226000,
            259243947,
            259228639,
            262253234,
            259225397,
            259489997,
            259461445,
            259242047,
            259619000
        ],
        "G1": [
            259172182,
            259216815,
            259198347,
            259219357,
            259218204,
            259223007,
            259214631,
            259207519,
            259198761,
            262711818,
            262258560,
            262253422,
            259213763,
            259227265,
            259216575,
            259180421,
            259195827,
            259338684,
            259243309,
            259209911,
            259297378,
            259235530,
            259244896
        ],
        "D": [
            259161835,
            259156950,
            259156189,
            259171496,
            259177367,
            259178250,
            259199117,
            259158093,
            259160446,
            259163964,
            259175052,
            259175484,
            259167009,
            259176266,
            259164921,
            259177714,
            259173819,
            259164483,
            259172917
        ],
        "C": [
            259152841,
            259145856,
            259145544,
            259159725,
            259152568,
            259159426,
            259163309,
            259139270,
            259147979,
            259150772,
            259151955,
            259161539,
            259151127,
            259153825,
            259150211,
            259158770,
            259156793,
            259150702,
            259156119
        ],
        "B": [
            259136289,
            259136909,
            259140277,
            259151011,
            259143044,
            259141191,
            259151719,
            259145824,
            259142864,
            259141679,
            259140361,
            259151405,
            259137211,
            259140708,
            259142606,
            259140153,
            259168292,
            259138044,
            259146579
        ],
        "A": [
            259134027,
            259133864,
            259135795,
            259139729,
            259136361,
            259136180,
            259137028,
            259134216,
            259135159,
            259133888,
            259134447,
            259140823,
            259134142,
            259134410,
            259136294,
            259134349,
            259138324,
            259134339,
            259139880
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129096",
    "editorial": "We will be solving this task using dynamic programming.Let us define as\r\nthe maximal prefix of that is contained in as a subsequence.Then the\r\ntransitions are as follows: if is equal to then . otherwise . The answer\r\nis .\r\n",
    "name": "B. Prefiquence",
    "statement": "You are given two binary strings a and b. A binary string is a string\r\nconsisting of the characters ” and ”.Your task is to determine the\r\nmaximum possible number k such that a prefix of string a of length k is\r\na subsequence of string b.A sequence a is a subsequence of a sequence b\r\nif a can be obtained from b by the deletion of several (possibly, zero\r\nor all) elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using namespace std; typedef long long ll; void solve(); int main() {    cin.tie(nullptr)->sync_with_stdio(false);    int _ = 1;    cin >> _;    while (_--) {        solve();    }} #define int ll void solve() {    int n, m;    cin >> n >> m;    string s, t;    cin >> s >> t;    int l = 0, r = s.size() + 1;    auto check = [&](int mid) -> bool {        for (int i = 0, j = 0; i < mid; ++i) {            while (j < t.size() && t[j] != s[i]) ++j;            if (j == t.size()) return false;            ++j;        }        return true;    };    while (r - l > 1) {        int mid = (l + r) / 2;        check(mid) ? l = mid : r = mid;    }    cout << l << '\\n';}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "two pointers"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Prefiquence.json",
    "hint": [
        "Hint 1 Try to check for every if the prefix of of length is a subsequence of ."
    ]
}