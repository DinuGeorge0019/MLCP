{
    "link": "https://codeforces.com//contest/2008/problem/F",
    "problemId": "2850011",
    "problem_idx": "F",
    "shortId": "2008F",
    "contest_number": "2008",
    "problem_submissions": {
        "H": [
            279136956,
            279175231,
            279161763,
            279179363,
            279181586,
            279168976,
            279216022,
            279614299,
            279182476,
            279209636,
            279208468,
            279207341,
            279210332,
            279350027,
            279217913,
            279220559,
            279216550,
            279220895,
            279220924,
            279302743
        ],
        "G": [
            279119447,
            279152222,
            279151084,
            279131568,
            279192199,
            279163482,
            279207144,
            279160784,
            279362880,
            279111562,
            279178333,
            279161657,
            279296750,
            279200995,
            279191409,
            279192959,
            279209224,
            279173816,
            279190595,
            279189666,
            279155886,
            279187798
        ],
        "F": [
            279104606,
            279131689,
            279118881,
            279127227,
            279115943,
            279103916,
            279131962,
            279356689,
            279077044,
            279134534,
            279099699,
            279292527,
            279106499,
            279150166,
            279167659,
            279130886,
            279186290,
            279121299,
            279117301,
            279134844
        ],
        "E": [
            279097264,
            279123319,
            279112502,
            279113482,
            279140821,
            279152927,
            279147312,
            279181553,
            279142676,
            279163125,
            279188714,
            279161254,
            279138336,
            279154142,
            279156092,
            279140491,
            279154770,
            279110096,
            279153681,
            279116556
        ],
        "D": [
            279079188,
            279103941,
            279108267,
            279089266,
            279105270,
            279092186,
            279119277,
            279128075,
            279092080,
            279120640,
            279166364,
            279126815,
            279110851,
            279134432,
            279119823,
            279121959,
            279088289,
            279095604,
            279098547
        ],
        "C": [
            279075309,
            279090563,
            279107974,
            279084125,
            279095019,
            279080293,
            279095460,
            279192216,
            279081252,
            279108974,
            279132485,
            279093671,
            279089579,
            279098258,
            279105761,
            279109828,
            279083132,
            279080197,
            279089704
        ],
        "B": [
            279070569,
            279078207,
            279107778,
            279079153,
            279085265,
            279120271,
            279088210,
            279097026,
            279076070,
            279110876,
            279124102,
            279123495,
            279082667,
            279084060,
            279083489,
            279098074,
            279099366,
            279076888,
            279076970,
            279080147
        ],
        "A": [
            279068125,
            279068165,
            279106509,
            279068333,
            279073493,
            279112154,
            279077178,
            279083226,
            279068010,
            279081658,
            279079540,
            279073175,
            279071802,
            279068979,
            279070906,
            279069965,
            279068711,
            279069909,
            279068403
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/133509",
    "editorial": "By the statement, we need to find the value of this expresion . Let\u00e2\u0080\u0099s\r\nfind this two values separately. For the first, we can do it in several\r\nways. We can see that this sum equal to and compute by prefix sum. Also,\r\nwe can notice that it is equal to . Note, that for second approach you\r\nneed to use division by modulo, i.e. for prime p. To compute , you can\r\ncompute by modulo and than use division by modulo for . Then, also using\r\ndivision by modulo you need to divide first value by second.\r\n",
    "name": "F. Sakurako s Box",
    "statement": "Sakurako has a box with n balls. Each ball has it\u2019s value. She wants to\r\nbet with her friend that if the friend randomly picks two balls from the\r\nbox (it could be two distinct balls, but they may have the same value),\r\nthe product of their values will be the same as the number that Sakurako\r\nguessed.Since Sakurako has a PhD in probability, she knows that the best\r\nnumber to pick is the expected value, but she forgot how to calculate\r\nit. Help Sakurako and find the expected value of the product of two\r\nelements from the array.It can be shown that the expected value has the\r\nform\r\nfrac{P}{Q}, where P and Q are non-negative integers, and Q\r\nne 0. Report the value of P\r\ncdot Q^{-1}(\r\nbmod 10^9+7).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0namespace std {\u00a0template <int D, typename T>struct Vec : public vector<Vec<D - 1, T>> {    static_assert(D >= 1);    template <typename... Args>    Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}};\u00a0template <typename T>struct Vec<1, T> : public vector<T> {    Vec(int n = 0, T val = T()) : std::vector<T>(n, val) {}};\u00a0template <class Fun>class y_combinator_result {    Fun fun_;\u00a0   public:    template <class T>    explicit y_combinator_result(T&& fun) : fun_(std::forward<T>(fun)) {}\u00a0    template <class... Args>    decltype(auto) operator()(Args&&... args) {        return fun_(std::ref(*this), std::forward<Args>(args)...);    }};\u00a0template <class Fun>decltype(auto) y_combinator(Fun&& fun) {    return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));}\u00a0}  // namespace std\u00a0template <typename T>T inverse(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\u00a0template <typename T>class Modular {   public:    using Type = typename decay<decltype(T::value)>::type;\u00a0    constexpr Modular() : value() {}    template <typename U>    Modular(const U& x) {        value = normalize(x);    }\u00a0    template <typename U>    static Type normalize(const U& x) {        Type v;        if (-mod() <= x && x < mod())            v = static_cast<Type>(x);        else            v = static_cast<Type>(x % mod());        if (v < 0) v += mod();        return v;    }\u00a0    const Type& operator()() const { return value; }    template <typename U>    explicit operator U() const { return static_cast<U>(value); }    constexpr static Type mod() { return T::value; }\u00a0    Modular& operator+=(const Modular& other) {        if ((value += other.value) >= mod()) value -= mod();        return *this;    }    Modular& operator-=(const Modular& other) {        if ((value -= other.value) < 0) value += mod();        return *this;    }    template <typename U>    Modular& operator+=(const U& other) { return *this += Modular(other); }    template <typename U>    Modular& operator-=(const U& other) { return *this -= Modular(other); }    Modular& operator++() { return *this += 1; }    Modular& operator--() { return *this -= 1; }    Modular operator++(int) {        Modular result(*this);        *this += 1;        return result;    }    Modular operator--(int) {        Modular result(*this);        *this -= 1;        return result;    }    Modular operator-() const { return Modular(-value); }\u00a0    template <typename U = T>    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));        return *this;    }    template <typename U = T>    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());        value = normalize(value * rhs.value - q * mod());        return *this;    }    template <typename U = T>    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {        value = normalize(value * rhs.value);        return *this;    }\u00a0    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\u00a0    friend const Type& abs(const Modular& x) { return x.value; }\u00a0    template <typename U>    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\u00a0    template <typename U>    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\u00a0    template <typename V, typename U>    friend V& operator>>(V& stream, Modular<U>& number);\u00a0   private:    Type value;};\u00a0template <typename T>bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }template <typename T, typename U>bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }template <typename T, typename U>bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\u00a0template <typename T>bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }template <typename T, typename U>bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }template <typename T, typename U>bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\u00a0template <typename T>bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\u00a0template <typename T>Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U>Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U>Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\u00a0template <typename T>Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U>Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U>Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\u00a0template <typename T>Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U>Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U>Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\u00a0template <typename T>Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U>Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U>Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\u00a0template <typename T, typename U>Modular<T> power(const Modular<T>& a, const U& b) {    assert(b >= 0);    Modular<T> x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) res *= x;        x *= x;        p >>= 1;    }    return res;}\u00a0template <typename T>bool IsZero(const Modular<T>& number) {    return number() == 0;}\u00a0template <typename T>string to_string(const Modular<T>& number) {    return to_string(number());}\u00a0// U == std::ostream? but done this way because of fastoutputtemplate <typename U, typename T>U& operator<<(U& stream, const Modular<T>& number) {    return stream << number();}\u00a0// U == std::istream? but done this way because of fastinputtemplate <typename U, typename T>U& operator>>(U& stream, Modular<T>& number) {    typename common_type<typename Modular<T>::Type, long long>::type x;    stream >> x;    number.value = Modular<T>::normalize(x);    return stream;}\u00a0/*using ModType = int;\u00a0struct VarMod { static ModType value; };ModType VarMod::value;ModType& md = VarMod::value;using Mint = Modular<VarMod>;*/\u00a0constexpr int md = 1e9 + 7;using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\u00a0vector<Mint> fact(1, 1);vector<Mint> inv_fact(1, 1);\u00a0Mint C(int n, int k) {    if (k < 0 || k > n) {        return 0;    }    while ((int)fact.size() < n + 1) {        fact.push_back(fact.back() * (int)fact.size());        inv_fact.push_back(1 / fact.back());    }    return fact[n] * inv_fact[k] * inv_fact[n - k];}\u00a0int32_t main() {    ios_base::sync_with_stdio(0);    cin.tie(0);\u00a0    int t;    cin >> t;    while (t--) {        int n;        cin >> n;        vector<Mint> a(n);        for (int i = 0; i < n; i++) cin >> a[i];        Mint sum = accumulate(a.begin(), a.end(), Mint(0));        Mint res = 0;        for (int i = 0; i < n; i++) {            res += a[i] * (sum - a[i]);        }        res /= Mint(n) * (n - 1);        cout << res << '\\n';    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Sakurako s Box.json"
}