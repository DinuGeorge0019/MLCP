{"link": "https://codeforces.com//contest/1878/problem/G", "problemId": "2229488", "problem_idx": "G", "shortId": "1878G", "contest_number": "1878", "problem_submissions": {"G": [225357770, 225356148, 225378677, 225396088, 225913288, 225913201, 225920084, 225806168], "E": [225342729, 225298379, 225344738, 225348985, 225318623, 225299675, 225329860, 225336305, 225327357, 225306213, 225322089, 225309942, 225339644, 225341224, 225341243, 225343329, 225344211, 225338004, 225316088], "D": [225335832, 225341527, 225309051, 225331018, 225323094, 225338405, 225319972, 225330316, 225308377, 225329843, 225347560, 225344567, 225325782, 225334610, 225324123, 225325861, 225322057, 225328040, 225346585], "C": [225318388, 225345357, 225316589, 225296717, 225295479, 225291873, 225287260, 225292130, 225288945, 225292627, 225291194, 225293331, 225301422, 225296957, 225301805, 225302804, 225306798, 225304842, 225306017], "F": [225309193, 225371590, 225359110, 225363020, 225336771, 225356090, 225361957, 225350800, 225360150, 225370320, 225377951, 225387862, 225369402, 225367044, 225368506, 225373551, 225374797, 225379464, 225370893], "B": [225289378, 225311939, 225302167, 225288412, 225283039, 225282551, 225280252, 225288368, 225281781, 225285957, 225281577, 225284558, 225292958, 225290446, 225282910, 225296220, 225284347, 225295270, 225303310], "A": [225283036, 225276287, 225280098, 225277273, 225274431, 225277937, 225274529, 225279212, 225276095, 225274228, 225275085, 225274508, 225280174, 225280595, 225275774, 225283697, 225275093, 225278575, 225275576]}, "name": "G. wxhtzdy ORO Tree", "statement": "After (finally) qualifying for the IOI 2023, wxhtzdy was very happy, so\r\nhe decided to do what most competitive programmers do: trying to guess\r\nthe problems that will be on IOI. During this process, he accidentally\r\nmade a problem, which he thought was really cool.You are given a tree (a\r\nconnected acyclic graph) with n vertices and n-1 edges. Vertex i (1\r\nle i\r\nle n) has a value a_i. Lets\u2019 define g(u, v) as the bitwise or of the\r\nvalues of all vertices on the shortest path from u to v. For example,\r\nlet\u2019s say that we want to calculate g(3, 4), on the tree from the first\r\ntest case in the example. On the path from 3 to 4 are vertices 3, 1, 4.\r\nThen, g(3, 4) = a_3\r\n|\r\na_1\r\n|\r\na_4 (here, | represents the bitwise OR operation).Also, you are given q\r\nqueries, and each query looks like this:You are given x and y. Let\u2019s\r\nconsider all vertices z such that z is on the shortest path from x to y\r\n(inclusive).Lets define the of a vertex z as the sum of the number of\r\nnon-zero bits in g(x, z) and the number of non-zero bits in g(y, z). You\r\nneed to find the maximum among all vertices z on the shortest path from\r\nx to y.Since his brain is really tired after solving an output only\r\nproblem on SIO (he had to do it to qualify for the IOI), he wants your\r\nhelp with this problem.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define ll long long\n#define ii pair<int,int>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \": \" << x << endl\n#define pub push_back\n#define pob pop_backac\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=2e5+5;\nint T;\nint n,q;\nint val[N];\nvector<int >G[N];\nvector<pair<int ,int > >V[N];\nint cnt[N][30];\nint jp[N][20];\nint dep[N];\nint t[N],top;\nvoid dfs(int u,int fa)\n{\n    V[u].clear();\n    int sz=V[fa].size();\n    V[u].push_back({u,val[u]});\n    int sum=val[u];\n    for(int i=0;i<sz;++i)\n    {\n        sum|=V[fa][i].second;\n        t[i]=sum;\n    }\n    for(int i=0;i<sz;++i)\n    {\n        if(t[i]!=t[i+1]||i+1==sz)\n            V[u].push_back({V[fa][i].first,t[i]});\n    }\n    dep[u]=dep[fa]+1;\n    jp[u][0]=fa;\n    for(int i=1;i<20;++i)\n        jp[u][i]=jp[jp[u][i-1]][i-1];\n    for(int i=0;i<30;++i)\n        cnt[u][i]=cnt[fa][i]+((val[u]>>i)&1);\n    for(auto v:G[u])\n    {\n        if(v==fa)   continue;\n        dfs(v,u);\n    }\n}\nint lca(int x,int y)\n{\n    if(dep[x]<dep[y])   swap(x,y);\n    for(int i=19;i>=0;--i)\n        if(dep[jp[x][i]]>=dep[y])   x=jp[x][i];\n    if(x==y)    return x;\n    for(int i=19;i>=0;--i)\n        if(jp[x][i]!=jp[y][i])  x=jp[x][i],y=jp[y][i];\n    return jp[x][0];\n}\nint calc(int x,int y)\n{\n    int z=lca(x,y);\n    int res=0;\n    for(int i=0;i<30;++i)\n        if(cnt[x][i]+cnt[y][i]-cnt[z][i]-cnt[jp[z][0]][i])  res++;\n    return res;\n}\nint solve(int x,int y,int z)\n{\n    int ans=calc(x,x)+calc(x,y);\n    for(auto [u,v]:V[x])\n    {\n        int now=jp[u][0];\n        if(dep[now]<dep[z]) break;\n        ans=max(ans,calc(x,now)+calc(now,y));\n    }\n    return ans;\n}\nvoid solve()\n{\n    n=read();\n    for(int i=1;i<=n;++i)   val[i]=read();\n    for(int i=1;i<=n;++i)   G[i].clear();\n    for(int i=1;i<n;++i)\n    {\n        int x=read();   int y=read();\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    dfs(1,0);\n    q=read();\n    while(q--)\n    {\n        int x=read();   int y=read();   int z=lca(x,y);\n        printf(\"%d\\n\",max(solve(x,y,z),solve(y,x,z)));\n    }\n}\nint main()\n{\n    T=read();\n    while(T--)  solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "brute force", "data structures", "dfs and similar", "implementation", "trees"], "dificulty": "2300", "interactive": false}