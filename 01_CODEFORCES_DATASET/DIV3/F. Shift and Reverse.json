{
    "link": "https://codeforces.com//contest/1907/problem/F",
    "problemId": "2365627",
    "problem_idx": "F",
    "shortId": "1907F",
    "contest_number": "1907",
    "problem_submissions": {
        "E": [
            235922096,
            235913995,
            235900143,
            235903340,
            235921667,
            235901704,
            235905781,
            236028309,
            235900905,
            235914797,
            235900953,
            235904410,
            235901939,
            235904392,
            235896353,
            235889597,
            235895501,
            235901631,
            235906746,
            235904536
        ],
        "G": [
            235905776,
            235944172,
            240754131,
            236224108,
            239539892
        ],
        "D": [
            235889060,
            235907893,
            235885826,
            235889907,
            235880968,
            235891188,
            235887305,
            235888897,
            235891138,
            235883950,
            235891896,
            235891023,
            235886777,
            235889881,
            237694958,
            235867800,
            235908732,
            235892927,
            235897779,
            235896975
        ],
        "F": [
            235888366,
            235927475,
            235911089,
            235918673,
            235897756,
            235921167,
            235919938,
            235923351,
            235911206,
            235921824,
            235923367,
            235927696,
            235932260,
            235934792,
            235914612,
            235925488,
            235926925,
            235918432,
            235922859
        ],
        "C": [
            235881778,
            235895243,
            235879309,
            235877991,
            235891348,
            235879417,
            235877691,
            235876696,
            235876979,
            235890394,
            235881961,
            235879314,
            235876924,
            235882981,
            236028314,
            235898937,
            235877137,
            235881599,
            235886820,
            235888590
        ],
        "B": [
            235864949,
            235883426,
            235872876,
            235865746,
            235868017,
            235866431,
            235870498,
            236028285,
            235870319,
            235871004,
            235871121,
            235872127,
            235871434,
            235867930,
            235865841,
            235901960,
            235870212,
            235875746,
            235875948,
            235874656
        ],
        "A": [
            235860107,
            235867323,
            235860491,
            235859890,
            235861006,
            235859799,
            235860028,
            235860311,
            235859823,
            235863201,
            235863210,
            235860674,
            236211486,
            235860837,
            235860015,
            235864893,
            235860651,
            235867283,
            235865532,
            235861983
        ]
    },
    "name": "F. Shift and Reverse",
    "statement": "Given an array of integers a_1, a_2,\r\nldots, a_n. You can make two types of operations with this array: Shift:\r\nmove the last element of array to the first place, and shift all other\r\nelements to the right, so you get the array a_n, a_1, a_2,\r\nldots, a_{n-1}. Reverse: reverse the whole array, so you get the array\r\na_n, a_{n-1},\r\nldots, a_1. Your task is to sort the array in non-decreasing order using\r\nthe minimal number of operations, or say that it is impossible.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define ll long long\n#define ii pair<int,int>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \": \" << x << endl\n#define pub push_back\n#define pob pop_backac\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n;\nint a[N];\nint al[N],ar[N];\nint bl[N],br[N];\nvoid solve()\n{\n    n=read();   int ans=INF;\n    for(int i=1;i<=n;++i)   a[i]=read();\n    \n    for(int i=1;i<=n;++i)\n    {\n        al[i]=bl[i]=i;\n        if(i==1)    continue;\n        if(a[i-1]<=a[i])    al[i]=al[i-1];\n        if(a[i-1]>=a[i])    bl[i]=bl[i-1];\n    }\n    for(int i=n;i>=1;--i)\n    {\n        ar[i]=br[i]=i;\n        if(i==n)    continue;\n        if(a[i]<=a[i+1])    ar[i]=ar[i+1];\n        if(a[i]>=a[i+1])    br[i]=br[i+1];\n    }\n    if(al[n]==1)    ans=min(ans,0);\n    if(br[1]==n)    ans=min(ans,1);\n    for(int i=1;i<n;++i)\n    {\n        if(al[i]==1&&ar[i+1]==n&&a[n]<=a[1])\n        {\n            ans=min(ans,n-i);\n            ans=min(ans,1+i+1);\n        }\n        if(bl[i]==1&&br[i+1]==n&&a[1]<=a[n])\n        {\n            ans=min(ans,n-i+1);\n            ans=min(ans,1+i);\n        }\n    }\n    if(ans>=INF)    puts(\"-1\");\n    else    printf(\"%d\\n\",ans);\n    \n}\nint main()\n{\n    T=read();\n    while(T--)  solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Shift and Reverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/123012",
    "editorial": "In this problem, there are several possible sequences of actions from\r\nwhich the optimal one must be chosen. For brevity, let\u00e2\u0080\u0099s denote the\r\nreverse by the letter \"\", and the shift by the letter \"\": Let\u00e2\u0080\u0099s write\r\nout the array twice and count the segments on which it increases and\r\ndecreases. This way, we can find all possible shifts that will sort the\r\narray.\r\n"
}