{
    "link": "https://codeforces.com//contest/1283/problem/F",
    "problemId": "504972",
    "problem_idx": "F",
    "shortId": "1283F",
    "contest_number": "1283",
    "problem_submissions": {
        "F": [
            67823245,
            67834634,
            67835859,
            67839332,
            67838778,
            68029277,
            67864524
        ],
        "E": [
            67815384,
            67819003,
            67822271,
            67817278,
            67817529,
            67816830,
            67820462,
            67815674,
            67819758,
            67822559,
            67825595,
            67826555,
            67825514,
            67818583,
            67817970,
            67826757
        ],
        "D": [
            67813119,
            67814942,
            67816390,
            67814327,
            67815165,
            67820564,
            67815719,
            67818760,
            67815953,
            67817694,
            67816237,
            67818386,
            67815983,
            67828465,
            67827664,
            67818584
        ],
        "C": [
            67810342,
            67821978,
            67810773,
            67807591,
            67808305,
            67810663,
            67811193,
            67813438,
            67808771,
            67811324,
            67808499,
            67810527,
            67810581,
            67811981,
            67810947,
            67812828
        ],
        "B": [
            67801292,
            67798549,
            67803137,
            67801302,
            67801574,
            67803276,
            67803578,
            67802026,
            67802576,
            67803714,
            67801063,
            67802206,
            67802199,
            67800040,
            67804358,
            67805065
        ],
        "A": [
            67797268,
            67797074,
            67797886,
            67797463,
            67797278,
            67797741,
            67798798,
            67797264,
            67798057,
            67798392,
            67797423,
            67797193,
            67798258,
            67797376,
            67798881,
            67799553
        ]
    },
    "name": "F. DIY Garland",
    "statement": "Polycarp has decided to decorate his room because the New Year is soon.\r\nOne of the main decorations that Polycarp will install is the garland he\r\nis going to solder himself.Simple garlands consisting of several lamps\r\nconnected by one wire are too boring for Polycarp. He is going to solder\r\na garland consisting of n lamps and n - 1 wires. Exactly one lamp will\r\nbe connected to power grid, and power will be transmitted from it to\r\nother lamps by the wires. Each wire connectes exactly two lamps; one\r\nlamp is called for this wire (the one that gets power from some other\r\nwire and transmits it to this wire), the other one is called (the one\r\nthat gets power from this wire). Obviously, each lamp has at most one\r\nwire that brings power to it (and this lamp is the auxiliary lamp for\r\nthis wire, and the main lamp for all other wires connected directly to\r\nit).Each lamp has a brightness value associated with it, the i-th lamp\r\nhas brightness 2^i. We define the of the wire as the sum of brightness\r\nvalues over all lamps that become disconnected from the grid if the wire\r\nis cut (and all other wires are still working).Polycarp has drawn the\r\nscheme of the garland he wants to make (the scheme depicts all n lamp\r\nand n - 1 wires, and the lamp that will be connected directly to the\r\ngrid is marked; the wires are placed in such a way that the power can be\r\ntransmitted to each lamp). After that, Polycarp calculated the\r\nimportance of each wire, enumerated them from 1 to n - 1 in descending\r\norder of their importance, and then wrote the index of the main lamp for\r\neach wire (in the order from the first wire to the last one).The\r\nfollowing day Polycarp bought all required components of the garland and\r\ndecided to solder it but he could not find the scheme. Fortunately,\r\nPolycarp found the list of indices of main lamps for all wires. Can you\r\nhelp him restore the original scheme?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\n\nbool findPath[MAXN];\n\nvector< pii > ans;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 1 ; i < n ; i++)\n\t\tscanf(\"%d\",&v[i]);\n\n\tprintf(\"%d\\n\",v[1]);\n\n\tfindPath[ v[1] ] = true;\n\n\tint p = 2;\n\tint last = n;\n\n\twhile( true )\n\t{\n\t\twhile( last > 0 && findPath[last] ) last--;\n\t\tfindPath[last] = true;\n\n\t\tif( last == 0 ) break;\n\n\t\twhile( p < n && !findPath[ v[p] ] )\n\t\t{\n\t\t\tans.push_back( { v[p - 1] , v[p] } );\n\t\t\tfindPath[ v[p] ] = true;\n\t\t\tp++;\n\t\t}\n\n\t\tans.push_back( { last , v[p - 1] } );\n\t\tp++;\n\t}\n\n\tfor(int i = 0 ; i < n - 1 ; i++)\n\t\tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. DIY Garland.json",
    "editorial_link": "https://codeforces.com//blog/entry/72592",
    "editorial": "First of all, we don\u00e2\u0080\u0099t like the fact that importance values can be\r\nintegers up to (it is kinda hard to work with them). Let\u00e2\u0080\u0099s rephrase the\r\nproblem.The highest bit set to in the importance value denotes the\r\nmaximum in the subtree rooted at the auxiliary lamp for the wire. So, we\r\nsort the wires according to the maximums in their subtrees. To break\r\nties, we could consider the second maximum, then the third maximum but\r\nthat\u00e2\u0080\u0099s not convenient. We can use something much easier: suppose there\r\nare two vertices with the same maximum in their subtrees; these vertices\r\nbelong to the path from the root to the maximum in their subtrees, and\r\nthe one which is closer to the root has the greater importance value.\r\nSo, to get the order described in the problem statement, we could sort\r\nthe vertices according to the maximum in their subtrees, and use depth\r\nas the tie-breaker.What does this imply? All vertices of some prefix are\r\nancestors of vertex , so some prefix denotes the path from the root to\r\n(excluding itself). Then there are some values describing the path from\r\nsome already visited vertex to (if was not met before), then to , and so\r\non.How can we use this information to restore the original tree? is the\r\nroot, obviously. Then the sequence can be separated into several\r\nsubsegments, each representing a vertical path in the tree (and each\r\nvertex is the parent of the next vertex in the sequence, if they belong\r\nto the same subsegment). How can we separate these vertices into\r\nsubsegments, and how to find the parents for vertices which did not\r\nappear in the sequence at all? Suppose some vertex appears several times\r\nin our sequence. The first time it appeared in the sequence, it was in\r\nthe middle of some vertical path, so the previous vertex is its parent;\r\nand every time this vertex appears again, it means that we start a new\r\npath and that\u00e2\u0080\u0099s how decomposition into paths is done.Determining the\r\nparents of vertices that did not appear in the sequence is a bit harder,\r\nbut can also be done. Let\u00e2\u0080\u0099s recall that our sequence is decomposed into\r\npaths from root to , from some visited vertex to , from some visited\r\nvertex to , and so on; so, each time the path changes, it means that we\r\nhave found the maximum vertex (among unvisited ones). So we should keep\r\ntrack of the maximum vertex that was not introduced in the sequence\r\nwhile we split it into paths, and each time a path breaks, it means that\r\nwe found the vertex we were keeping track of.Overall, this solution can\r\nbe implemented in .\r\n"
}