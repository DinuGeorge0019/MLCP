{
    "link": "https://codeforces.com//contest/2106/problem/F",
    "problemId": "3350611",
    "problem_idx": "F",
    "shortId": "2106F",
    "contest_number": "2106",
    "problem_submissions": {
        "G1": [
            317037524,
            317062262,
            317061590,
            317052941,
            317066213,
            317065911
        ],
        "F": [
            317035761,
            317047729,
            317029292,
            317067306,
            317073415,
            317070219,
            317022800,
            317030307,
            317028689,
            317050113,
            317855906,
            317044171,
            317050574,
            317045837,
            317043135,
            317044827,
            317050773,
            317041440
        ],
        "E": [
            317020313,
            317010744,
            317046134,
            317035937,
            317029339,
            317046150,
            317010414,
            317018526,
            317021744,
            317013609,
            317950136,
            317028070,
            317036331,
            317032678,
            317025857,
            317036190,
            317040887
        ],
        "D": [
            316999946,
            317027974,
            317011069,
            317020862,
            317037534,
            317031860,
            316984555,
            317007925,
            317005998,
            317006604,
            317007086,
            317010692,
            317015300,
            317015795,
            317017807,
            317018294,
            316999673
        ],
        "C": [
            316988591,
            316986472,
            316999853,
            317026133,
            316999286,
            317002344,
            316991443,
            316988219,
            317000196,
            316978313,
            316994740,
            316996215,
            317004560,
            317006037,
            317004240,
            317004181,
            316991883
        ],
        "B": [
            316981000,
            316979542,
            316988448,
            316988900,
            316993570,
            316993687,
            317000718,
            316983017,
            316992142,
            316991120,
            316981211,
            316985408,
            316994310,
            316999518,
            316991380,
            316984785,
            316983692
        ],
        "A": [
            316977086,
            316978937,
            316978575,
            316978826,
            316982345,
            316979125,
            316997396,
            316978412,
            316977215,
            316981299,
            316977127,
            316977164,
            316982363,
            316981149,
            316979807,
            316979304,
            316977212
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142254",
    "editorial": "(Author & Analysis: SpyrosAliv) SolutionEach column can be broken down\r\nto components: If , the top-most component will contain zeros, the\r\nsecond component a single one, and the third component zeros. If , the\r\ntop-most component will contain ones, the second component a single\r\nzero, and the third component ones. The easiest way to visualize is with\r\nDSU. For each column, create components, and for each component\r\nimplicitly store the number of s in it. Now, we will try to merge all\r\nadjacent components that both consist of zeros. Consider the following\r\ntransitions, for every : If and , then the top-most component of column\r\nwill be merged with the top-most component of column . The same goes for\r\nthe two bottom-most components. If and , then the top-most component of\r\ncolumn will be merged with the top-most component of column . If and ,\r\nthen the bottom-most component of column will be merged with the\r\nbottom-most component of column . If and , we merge nothing. After we\r\nfinish the merging, we just take the component with the maximum number\r\nof zeros, which will be the answer to this problem. Note that you do not\r\nactually have to use DSU; we only care about the sizes and not the\r\nrepresentatives, so we can also use simple prefix sums.\r\n",
    "name": "F. Goblin",
    "statement": "Dr. TC has a new patient called Goblin. He wants to test Goblin’s\r\nintelligence, but he has gotten bored of his standard test. So, he\r\ndecided to make it a bit harder.First, he creates a binary string^{\r\ntext{ }} s having n characters. Then, he creates n binary strings a_1,\r\na_2,\r\nldots, a_n. It is known that a_i is created by first copying s, then\r\nflipping the i-th character (\r\ntexttt{1} becomes\r\ntexttt{0} and vice versa). After creating all n strings, he arranges\r\nthem into an n\r\ntimes n grid g where g_{i, j} = a_{i_j}. A set S of size k containing\r\ndistinct integer pairs\r\n{(x_1, y_1), (x_2, y_2),\r\nldots, (x_k, y_k)\r\n} is considered good if: 1\r\nleq x_i, y_i\r\nleq n for all 1\r\nleq i\r\nleq k. g_{x_i, y_i} =\r\ntexttt{0} for all 1\r\nleq i\r\nleq k. For any two integers i and j (1\r\nleq i, j\r\nleq k), coordinate (x_i, y_i) is reachable from coordinate (x_j, y_j) by\r\ntraveling through a sequence of adjacent cells (which share a side) that\r\nall have a value of\r\ntexttt{0}. Goblin’s task is to find the maximum possible size of a good\r\nset S. Because Dr. TC is generous, this time he gave him two seconds to\r\nfind the answer instead of one. Goblin is not known for his honesty, so\r\nhe has asked you to help him cheat.^{\r\ntext{ }}A binary string is a string that only consists of characters\r\ntexttt{1} and\r\ntexttt{0}.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "greedy",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Goblin.json",
    "hint": []
}