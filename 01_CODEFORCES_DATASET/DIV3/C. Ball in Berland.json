{
    "link": "https://codeforces.com//contest/1475/problem/C",
    "problemId": "877135",
    "problem_idx": "C",
    "shortId": "1475C",
    "contest_number": "1475",
    "problem_submissions": {
        "G": [
            105357435,
            105353117,
            105356792,
            105355999,
            105373741,
            105354969,
            105380919,
            105377146,
            105378300,
            105392699,
            105388391,
            105385880,
            105393662,
            105395380,
            105394840,
            105387401,
            105387670,
            105390094
        ],
        "F": [
            105351927,
            105357486,
            105365752,
            105373501,
            105363421,
            105369601,
            105373520,
            105367472,
            105382350,
            105374670,
            105379170,
            105369385,
            105379845,
            105380433,
            105376571,
            105377554,
            105393804
        ],
        "E": [
            105344845,
            105346728,
            105337063,
            105334310,
            105356585,
            105370551,
            105361997,
            105356836,
            105352936,
            105365884,
            105369358,
            105357806,
            105368246,
            105367253,
            105363206,
            105367340,
            105373988,
            105367073
        ],
        "D": [
            105338341,
            105341549,
            105347068,
            105372256,
            105350292,
            105364300,
            105354879,
            105371230,
            105368625,
            105358896,
            105361695,
            105380627,
            105356276,
            105359403,
            105359168,
            105355985,
            105378924,
            105382384,
            105379690
        ],
        "C": [
            105320580,
            105317968,
            105329054,
            105323429,
            105339564,
            105321102,
            105326770,
            105331530,
            105321133,
            105333110,
            105339000,
            105333226,
            105331288,
            105340903,
            105338355,
            105339758,
            105336564
        ],
        "B": [
            105309543,
            105309679,
            105321922,
            105311424,
            105316444,
            105311086,
            105314894,
            105313124,
            105310606,
            105313344,
            105315001,
            105318054,
            105314173,
            105311720,
            105316715,
            105316237,
            105318935
        ],
        "A": [
            105307097,
            105307137,
            105312703,
            105307046,
            105308743,
            105308312,
            105309093,
            105308294,
            105307309,
            105308822,
            105309783,
            105313391,
            105309615,
            105307651,
            105310811,
            105307813,
            105310833,
            105312748
        ]
    },
    "name": "C. Ball in Berland",
    "statement": "At the school where Vasya is studying, preparations are underway for the\r\ngraduation ceremony. One of the planned performances is a ball, which\r\nwill be attended by pairs of boys and girls.Each class must present two\r\ncouples to the ball. In Vasya’s class, a boys and b girls wish to\r\nparticipate. But not all boys and not all girls are ready to dance in\r\npairs.Formally, you know k possible one-boy-one-girl pairs. You need to\r\nchoose two of these pairs so that no person is in more than one pair.For\r\nexample, if a=3, b=4, k=4 and the couples (1, 2), (1, 3), (2, 2), (3, 4)\r\nare ready to dance together (in each pair, the boy’s number comes first,\r\nthen the girl’s number), then the following combinations of two pairs\r\nare possible (not all possible options are listed below): (1, 3) and (2,\r\n2); (3, 4) and (1, 3); But the following combinations are not possible:\r\n(1, 3) and (1, 2) the first boy enters two pairs; (1, 2) and (2, 2) the\r\nsecond girl enters two pairs; Find the number of ways to select two\r\npairs that match the condition above. Two ways are considered different\r\nif they consist of different pairs.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\", x.f, \", \", x.s, \"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? \", \" : \"\", a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\n    void setOut(string s) { freopen(s.c_str(), \"w\", stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + \".in\"), setOut(s + \".out\"); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO(\"\");\n    int tt; re(tt);\n    while (tt--) {\n        ll aa, bb, k; \n        re(aa, bb, k);\n        vi a(k);\n        f0r(i, k) re(a[i]), a[i]--;\n        vi b(k);\n        f0r(i, k) re(b[i]), b[i]--;\n        vl cnt1(aa);\n        vl cnt2(bb);\n        f0r(i, k) {\n            cnt1[a[i]]++;\n        }\n        ll ans = k * (k - 1) / 2;\n        f0r(i, k) {\n            cnt2[b[i]]++;\n        }\n        trav(t, cnt1) { \n            ans -= t * (t - 1) / 2;\n        }\n        trav(t, cnt2) {\n            ans -= t * (t - 1) / 2;\n        }\n        ps(ans);\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "graphs",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Ball in Berland.json",
    "editorial_link": "https://codeforces.com//blog/entry/87188",
    "editorial": "We can think that it is given a bipartite graph. Boys and girls are the\r\nvertices of the graph. If a boy and a girl are ready to dance together,\r\nthen an edge is drawn between them. In this graph, you need to select\r\ntwo edges that do not intersect at the vertices.Let the number of edges\r\nincluded in the vertex .Iterate over the first edge (). It will block of\r\nother edges (all adjacent to vertex , to vertex , but the edge () will\r\nbe blocked twice. All non-blocked edges do not intersect with () at the\r\nvertices. So you can add to the answer.\r\n",
    "hint": []
}