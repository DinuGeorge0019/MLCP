{"link": "https://codeforces.com//contest/1272/problem/B", "problemId": "494354", "problem_idx": "B", "shortId": "1272B", "contest_number": "1272", "problem_submissions": {"E": [66703677, 66698934, 66711392, 66720411, 66715254, 66696959, 66695532, 66698121, 66701928, 66701435, 66706283, 66705342, 66707569, 66707090, 66777425, 66705785, 66709630, 66710595, 66706360, 66711695], "F": [66702563, 66716210, 66716034, 66713486, 66720407, 66730946, 66745196, 66899419, 66710448, 69815932], "B": [66692863, 66686159, 66691774, 66706884, 66714297, 66683965, 66685196, 66684562, 66686916, 66692480, 66696683, 66688751, 66692889, 66696315, 66685266, 66695654, 66691545, 66689056, 66687119, 66686340], "C": [66687313, 66688012, 66695426, 66689433, 66689685, 66685389, 66686891, 66686385, 66687940, 66685597, 66690881, 66692609, 66686241, 66688395, 66686850, 66686864, 66686923, 66691687, 66689532, 66689140], "D": [66683330, 66692291, 66701690, 66697025, 66695475, 66689729, 66689439, 66688995, 66691097, 66696361, 66685375, 66696190, 66695912, 66691534, 66688277, 66700728, 66696238, 66694893, 66695943, 66703253], "A": [66683267, 66683040, 66685123, 66683649, 66682741, 66682439, 66682629, 66682714, 66683716, 66683148, 66683049, 66683308, 66683216, 66682971, 66682692, 66683012, 66683163, 66683636, 66683990, 66682789]}, "name": "B. Snow Walking Robot", "statement": "Recently you have bought a snow walking robot and brought it home.\r\nSuppose your home is a cell (0, 0) on an infinite grid.You also have the\r\nsequence of instructions of this robot. It is written as the string s\r\nconsisting of characters \u201d, \u201d, \u201d and \u201d. If the robot is in the cell (x,\r\ny) right now, he can move to one of the adjacent cells (depending on the\r\ncurrent instruction). If the current instruction is \u201d, then the robot\r\ncan move to the left to (x - 1, y); if the current instruction is \u201d,\r\nthen the robot can move to the right to (x + 1, y); if the current\r\ninstruction is \u201d, then the robot can move to the top to (x, y + 1); if\r\nthe current instruction is \u201d, then the robot can move to the bottom to\r\n(x, y - 1). You\u2019ve noticed the warning on the last page of the manual:\r\nif the robot visits some cell ( (0, 0)) twice then it breaks.So the\r\nsequence of instructions is valid if the robot starts in the cell (0,\r\n0), performs the given instructions, visits no cell other than (0, 0)\r\ntwo or more times and ends the path in the cell (0, 0). Also cell (0, 0)\r\nshould be visited two times: at the beginning and at the end (if the\r\npath is empty then it is visited only once). For example, the following\r\nsequences of instructions are considered valid: \"\", \"\", \"\", and the\r\nfollowing are considered invalid: \"\" (the endpoint is not (0, 0)) and \"\"\r\n(the cell (0, 1) is visited twice).The initial sequence of instructions,\r\nhowever, might be not valid. You don\u2019t want your robot to break so you\r\ndecided to reprogram it in the following way: you will remove some\r\n(possibly, all or none) instructions from the initial sequence of\r\ninstructions, then rearrange the remaining instructions as you wish and\r\nturn on your robot to move. Your task is to remove as few instructions\r\nfrom the initial sequence as possible and rearrange the remaining ones\r\nso that the sequence is valid. Report the valid sequence of the maximum\r\nlength you can obtain.Note that you can choose order of remaining\r\ninstructions (you don\u2019t need to minimize the number of swaps or any\r\nother similar metric).You have to answer q independent test cases.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1E5 + 10;\n\nint n;\nchar st[N];\n\nvoid Solve() {\n    int d[4] = {0};\n    char cc[4] = {'L', 'R', 'U', 'D'};\n    for (int i = 1; i <= n; i++) {\n        if (st[i] == 'L') d[0]++;\n        if (st[i] == 'R') d[1]++;\n        if (st[i] == 'U') d[2]++;\n        if (st[i] == 'D') d[3]++;\n    }\n    int tmp = 0;\n    int t1 = min(d[0], d[1]);\n    int t2 = min(d[2], d[3]);\n    int ans = t1 * 2 + t2 * 2;\n    for (int i = 0; i < 4; i++)\n        tmp += d[i] > 0;\n    if (!t1 && !t2) {\n        printf(\"0\\n\\n\");\n    } else if (!t1 || !t2) {\n        if (t1) {\n            printf(\"2\\nLR\\n\");\n        } else {\n            printf(\"2\\nUD\\n\");\n        }\n    } else {\n        printf(\"%d\\n\", ans);\n        for (int i = 0; i < t1; i++)\n            putchar('L');\n        for (int i = 0; i < t2; i++)\n            putchar('U');\n        for (int i = 0; i < t1; i++)\n            putchar('R');\n        for (int i = 0; i < t2; i++)\n            putchar('D');\n        putchar('\\n');\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    int TC; scanf(\"%d\\n\", &TC);\n    while (TC--) {\n        scanf(\"%s\", st + 1);\n        n = strlen(st + 1);\n        Solve();\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "implementation"], "dificulty": "1200", "interactive": false}