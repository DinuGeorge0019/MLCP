{
    "link": "https://codeforces.com//contest/1506/problem/G",
    "problemId": "935565",
    "problem_idx": "G",
    "shortId": "1506G",
    "contest_number": "1506",
    "problem_submissions": {
        "F": [
            111021020,
            111023335,
            111043050,
            111045078,
            111042675,
            111022888,
            111045702,
            111030029,
            111059327,
            111056314,
            111054328,
            111053665,
            111049676,
            111057223,
            111055499,
            111051574,
            111018539
        ],
        "G": [
            111011051,
            111044191,
            111025676,
            111021333,
            111015838,
            111047466,
            111027389,
            111038444,
            111062619,
            111035705,
            111033084,
            111031458,
            111027898,
            111059943,
            111039951,
            111044272,
            111042579,
            110997057,
            111024212,
            111035025
        ],
        "E": [
            110998219,
            111002639,
            111005993,
            111004597,
            111005673,
            111003655,
            111009629,
            110993653,
            111011522,
            111018659,
            111024774,
            111017525,
            111015924,
            111022569,
            111022716,
            111033942,
            111001920,
            111012071,
            111010852
        ],
        "D": [
            110994014,
            110997858,
            111000907,
            110997329,
            111020775,
            111109278,
            110995630,
            111003898,
            110987445,
            111005061,
            111007314,
            111017748,
            111012182,
            111006395,
            111026211,
            111014600,
            111017473,
            111014918,
            111042008,
            110987093,
            111004976
        ],
        "C": [
            110991700,
            110993760,
            110994821,
            110991557,
            110994969,
            110992631,
            110998527,
            110995536,
            111000015,
            111001144,
            111003685,
            111008122,
            111006904,
            111001766,
            110999236,
            111006625,
            111008840,
            111033710,
            110991249,
            110998250
        ],
        "B": [
            110987614,
            110990504,
            110992033,
            110988684,
            110991376,
            110988565,
            110994317,
            111002159,
            110989417,
            110997996,
            110993594,
            111002185,
            110994767,
            111009342,
            111001911,
            111024800,
            111045128,
            110999737,
            110993374
        ],
        "A": [
            110986181,
            110985860,
            110985761,
            110986354,
            110986698,
            110986290,
            110988038,
            110996610,
            110986006,
            110986393,
            110986025,
            110986629,
            110986586,
            110988619,
            110989257,
            110990207,
            111021247,
            111003988,
            110987775
        ]
    },
    "name": "G. Maximize the Remaining String",
    "statement": "You are given a string s, consisting of lowercase Latin letters. While\r\nthere is at least one character in the string s that is , you perform\r\nthe following operation: you choose the index i (1\r\nle i\r\nle |s|) such that the character at position i occurs times in the string\r\ns, and delete the character at position i, that is, replace s with s_1\r\ns_2\r\nldots s_{i-1} s_{i+1} s_{i+2}\r\nldots s_n. For example, if s=, then you can apply the following sequence\r\nof operations: i=6\r\nRightarrow s=; i=1\r\nRightarrow s=; i=7\r\nRightarrow s=; Given a given string s, find the lexicographically\r\nmaximum string that can be obtained after applying a certain sequence of\r\noperations after which all characters in the string .A string a of\r\nlength n is lexicographically less than a string b of length m, if:\r\nthere is an index i (1\r\nle i\r\nle\r\nmin(n, m)) such that the first i-1 characters of the strings a and b are\r\nthe same, and the i-th character of the string a is less than i-th\r\ncharacter of string b; the first\r\nmin(n, m) characters in the strings a and b are the same and n < m. For\r\nexample, the string a= is lexicographically less than the string b=.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint lst[205];\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring a;\n\t\tcin >> a;\n\t\tint n=a.size();\n\t\tfor(int i='a';i<='z';i++) lst[i]=n;\n\t\tlst[0]=n;\n\t\tfor(int i=0;i<a.size();i++)\n\t\t\tlst[a[i]]=i;\n\t\tint pos=0;\n\t\tfor(int X=0;X<=26;X++)\n\t\t{\n\t\t\tchar mx=0;\n\t\t\tfor(int i=pos;i<n;i++)\n\t\t\t{\n\t\t\t\tmx=max(mx,a[i]);\n\t\t\t\tif(lst[a[i]]==i)\n\t\t\t\t{\n\t\t\t\t\tlst[mx]=n;\n\t\t\t\t\tcout << mx;\n\t\t\t\t\twhile(a[pos]!=mx) ++pos;\n\t\t\t\t\t++pos; \n\t\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\t\tif(a[i]==mx) a[i]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Maximize the Remaining String.json",
    "editorial_link": "https://codeforces.com//blog/entry/89007",
    "editorial": "How can you check if you can perform such a sequence of operations on\r\nthe string to get the string ? Note that each time we delete an\r\narbitrary character that is repeated at least two times, so must be a\r\nsubsequence of the string and have the same character set as the string\r\n.We will consequently build the resulting string , adding characters to\r\nthe end. To check if there is such a sequence of operations that turns\r\nthe string into the string (a string that first contains the characters\r\nof the string , then the character , and then some unknown characters),\r\nit is enough to do the following: Find the minimum index such that is\r\nincluded in as a subsequence; Find the minimum index () such that ; Then\r\nthe substring must contain all characters that are in the string , but\r\nwhich are not in the string . Letâs denote a function that checks the\r\ncriterion above as .Having received the verification criterion, the\r\nfollowing algorithm can be made: Initially is an empty string; While\r\nthere is a character in the string that is not in the string , we will\r\nfind the maximum character not contained in , but contained in , for\r\nwhich and add it to the end of the string . Since at each step we take\r\nthe maximum symbol for which the criterion is met, the resulting string\r\nwill be the lexicographically maximum.\r\n",
    "hint": []
}