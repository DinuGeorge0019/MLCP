{
    "link": "https://codeforces.com//contest/1579/problem/E1",
    "problemId": "1123870",
    "problem_idx": "E1",
    "shortId": "1579E1",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "E1. Permutation Minimization by Deque",
    "statement": "A permutation p of size n is given. A of size n is an array of size n in\r\nwhich each integer from 1 to n occurs exactly once. For example, [1, 4,\r\n3, 2] and [4, 2, 1, 3] are correct permutations while [1, 2, 4] and [1,\r\n2, 2] are not.Let us consider an empty deque (double-ended queue). A\r\ndeque is a data structure that supports adding elements to both the\r\nbeginning and the end. So, if there are elements [1, 5, 2] currently in\r\nthe deque, adding an element 4 to the beginning will produce the\r\nsequence [\r\ncolor{red}{4}, 1, 5, 2], and adding same element to the end will produce\r\n[1, 5, 2,\r\ncolor{red}{4}].The elements of the permutation are sequentially added to\r\nthe initially empty deque, starting with p_1 and finishing with p_n.\r\nBefore adding each element to the deque, you may choose whether to add\r\nit to the beginning or the end.For example, if we consider a permutation\r\np = [3, 1, 2, 4], one of the possible sequences of actions looks like\r\nthis:\r\nquad 1.add 3 to the end of the deque:deque has a sequence [\r\ncolor{red}{3}] in it;\r\nquad 2.add 1 to the beginning of the deque:deque has a sequence [\r\ncolor{red}{1}, 3] in it;\r\nquad 3.add 2 to the end of the deque:deque has a sequence [1, 3,\r\ncolor{red}{2}] in it;\r\nquad 4.add 4 to the end of the deque:deque has a sequence [1, 3, 2,\r\ncolor{red}{4}] in it;Find the lexicographically smallest possible\r\nsequence of elements in the deque after the entire permutation has been\r\nprocessed. A sequence [x_1, x_2,\r\nldots, x_n] is than the sequence [y_1, y_2,\r\nldots, y_n] if there exists such i\r\nleq n that x_1 = y_1, x_2 = y_2,\r\nldots, x_{i - 1} = y_{i - 1} and x_i < y_i. In other words, if the\r\nsequences x and y have some (possibly empty) matching prefix, and the\r\nnext element of the sequence x is strictly smaller than the\r\ncorresponding element of the sequence y. For example, the sequence [1,\r\n3, 2, 4] is smaller than the sequence [1, 3, 4, 2] because after the two\r\nmatching elements [1, 3] in the start the first sequence has an element\r\n2 which is smaller than the corresponding element 4 in the second\r\nsequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005],n;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        deque <int> dq;\n        for(int i = 1;i <= n;i++) {\n            int x; cin >> x;\n            if(dq.empty()) dq.pb(x);\n            else {\n                if(x < dq.front()) dq.push_front(x);\n                else dq.push_back(x);\n            }\n        }\n        while(!dq.empty()) {\n            cout << dq.front() << ' ';\n            dq.pop_front();\n        }\n        cout << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. Permutation Minimization by Deque.json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "We\u00e2\u0080\u0099ll process the permutation elements one by one.For the first element,\r\nit doesn\u00e2\u0080\u0099t matter which side of the deque we add it to, the result of\r\nits addition will be the same there will be a sequence of one element\r\n(equal to the first permutation element) in the deque.Now let\u00e2\u0080\u0099s consider\r\nadding the -th element of a permutation to the deque. First will be\r\nconsidered, then , and so on up to . Let us describe the general\r\nalgorithm for choosing the side of the deque for each step. Note that if\r\nthe elements are now in the deque, then all final permutations that can\r\nbe obtained in the deque from the current state can be broken down into\r\npairs of the form where the beginning and the end of the final\r\npermutations, hidden behind \"\", are obtained by the same sequences of\r\nall the following choices and thus are equal between the first and the\r\nsecond.Note that when the first permutation will always be\r\nlexicographically smaller than the second one, and vice versa.\r\nTherefore, regardless of the following choices, if then the second\r\npermutation will never be minimal, and if then the first permutation\r\nwill never be minimal.This means that we can make a choice about the\r\nside of the deque to add the -th element to based only on its relation\r\nto : if , then is added to the beginning of the deque, otherwise to the\r\nend.The time complexity is . Alternative solutions, which also fit in\r\nthe time limit, involved finding a lexicographically minimal increasing\r\nsequence in the reversed original permutation and could be implemented\r\neither with time complexity or with time complexity if the permutation\u00e2\u0080\u0099s\r\ndefinition was taken into consideration.\r\n"
}