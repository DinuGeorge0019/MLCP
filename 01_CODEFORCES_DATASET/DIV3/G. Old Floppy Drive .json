{"link": "https://codeforces.com//contest/1490/problem/G", "problemId": "898529", "problem_idx": "G", "shortId": "1490G", "contest_number": "1490", "problem_submissions": {"G": [107575670, 107570582, 107580395, 107578386, 107578722, 107587817, 107582372, 107587644, 107590224, 107587234, 107581021, 107587494, 107591578, 107587278, 107594584, 107580527, 107594840, 107604479, 107585353], "F": [107567259, 107563218, 107559121, 107563180, 107570162, 107559715, 107565176, 107569965, 107573956, 107565331, 107557975, 107565094, 107575477, 107563453, 107578839, 107563945, 107577436, 107545806, 107574260], "E": [107556406, 107555209, 107554466, 107554504, 107563766, 107548069, 107557392, 107558375, 107560045, 107556903, 107568704, 107559054, 107564526, 107568622, 107566562, 107557990, 107565929, 107550803, 107568788], "D": [107547185, 107546416, 107549582, 107548987, 107555867, 107556006, 107548279, 107551082, 107551588, 107551655, 107551977, 107552563, 107556439, 107553824, 107619966, 107554583, 107548604, 107553073, 107559705, 107559541], "C": [107543774, 107582544, 107542780, 107545198, 107545514, 107545604, 107541435, 107544848, 107546219, 107546179, 107546602, 107549060, 107548247, 107550636, 107543227, 107548011, 107545321, 107547310, 107550641, 107555122], "B": [107541208, 107540999, 107543105, 107543215, 107543363, 107548411, 107542386, 107543350, 107543787, 107544607, 107545190, 107541258, 107543035, 107541260, 107543659, 107551661, 107545377, 107544997, 107550231], "A": [107538772, 107538836, 107539535, 107539200, 107538915, 107539471, 107539499, 107538905, 107539830, 107541268, 107539601, 107539113, 107538995, 107538895, 107540166, 107538768, 107540499, 107538751, 107538933]}, "name": "G. Old Floppy Drive ", "statement": "Polycarp was dismantling his attic and found an old floppy drive on it.\r\nA round disc was inserted into the drive with n integers written on\r\nit.Polycarp wrote the numbers from the disk into the a array. It turned\r\nout that the drive works according to the following algorithm: the drive\r\ntakes one positive number x as input and puts a pointer to the first\r\nelement of the a array; after that, the drive starts rotating the disk,\r\nevery second moving the pointer to the next element, counting the sum of\r\nall the elements that have been under the pointer. Since the disk is\r\nround, in the a array, the last element is again followed by the first\r\none; as soon as the sum is at least x, the drive will shut down.\r\nPolycarp wants to learn more about the operation of the drive, but he\r\nhas absolutely no free time. So he asked you m questions. To answer the\r\ni-th of them, you need to find how many seconds the drive will work if\r\nyou give it x_i as input. Please note that in some cases the drive can\r\nwork infinitely.For example, if n=3, m=3, a=[1, -3, 4] and x=[1, 5, 2],\r\nthen the answers to the questions are as follows: the answer to the\r\nfirst query is 0 because the drive initially points to the first item\r\nand the initial sum is 1. the answer to the second query is 6, the drive\r\nwill spin the disk completely twice and the amount becomes\r\n1+(-3)+4+1+(-3)+4+1=5. the answer to the third query is 2, the amount is\r\n1+(-3)+4=2.\r\n", "solutions": ["#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int SIZE = 1 << 20;\nconst int len = 1 << 19;\nlong long tree[SIZE];\nint n, m;\nint arr[200010];\n\nvoid update(int idx, long long value)\n{\n\tidx += len;\n\ttree[idx] = value;\n\tidx /= 2;\n\twhile (idx >= 1)\n\t{\n\t\ttree[idx] = max(tree[2 * idx], tree[2 * idx + 1]);\n\t\tidx /= 2;\n\t}\n}\n\nint get(int idx, int s, int e, long long value)\n{\n\tint mid;\n\n\tif (idx >= len) return s;\n\n\tmid = (s + e) / 2;\n\n\tif (tree[2 * idx] >= value) return get(2 * idx, s, mid, value);\n\telse return get(2 * idx + 1, mid + 1, e, value);\n}\n\nint main()\n{\n\tint t;\n\tint i;\n\tlong long x;\n\tlong long sum;\n\tlong long cycle;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n >> m;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\tsum = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tsum += arr[i];\n\n\t\t\tupdate(i, sum);\n\t\t}\n\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> x;\n\n\t\t\tif (tree[1] >= x)\n\t\t\t{\n\t\t\t\tcout << get(1, 0, len - 1, x) << ' ';\n\t\t\t}\n\t\t\telse if (sum <= 0)\n\t\t\t{\n\t\t\t\tcout << -1 << ' ';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcycle = (x - tree[1]) / sum + ((x - tree[1]) % sum != 0);\n\t\t\t\tx -= sum * cycle;\n\t\t\t\tcout << get(1, 0, len - 1, x) + n * cycle << ' ';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tupdate(i, 0);\n\t\t}\n\t}\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "math"], "dificulty": "1900", "interactive": false}