{
    "link": "https://codeforces.com//contest/1851/problem/D",
    "problemId": "2115026",
    "problem_idx": "D",
    "shortId": "1851D",
    "contest_number": "1851",
    "problem_submissions": {
        "F": [
            215583047,
            215569492,
            215579077,
            215566307,
            215574419,
            215578454,
            215575870,
            215577530,
            215600568,
            215575641,
            215585936,
            215588041,
            215589152,
            215586581,
            215589298,
            215588709,
            215587486,
            216018365,
            215590568,
            215575574
        ],
        "G": [
            215575283,
            215598343,
            215593159,
            215608828,
            215590713,
            215597061,
            215596537,
            215602648,
            215584695,
            215594862,
            215612719,
            215611638,
            215605638,
            215614880,
            215606881,
            215615959,
            215606526,
            216018381,
            215609478,
            215603760
        ],
        "E": [
            215554147,
            215554902,
            215554482,
            215549142,
            215560459,
            215554036,
            215562257,
            215556727,
            215561636,
            215565663,
            215559271,
            215553466,
            215557917,
            215563847,
            215562734,
            215562948,
            215560103,
            216018352,
            215576817,
            215612963
        ],
        "D": [
            215533409,
            215535460,
            215534208,
            215534687,
            215544754,
            215542789,
            215542369,
            215538307,
            215549445,
            215557571,
            215540094,
            215538955,
            215546789,
            215540331,
            215545020,
            215541882,
            215571406,
            216018332,
            215565562,
            215552208
        ],
        "C": [
            215518745,
            215521123,
            215523873,
            215521189,
            215525356,
            215529106,
            215527649,
            215544242,
            215522653,
            215536104,
            215522716,
            215526033,
            215531440,
            215519368,
            215532583,
            215551484,
            215548134,
            216018314,
            215549325,
            215536690
        ],
        "B": [
            215513234,
            215513521,
            215514166,
            215512941,
            215516397,
            215517695,
            215518324,
            215516319,
            215512960,
            215513498,
            215512779,
            215518016,
            215520983,
            215513367,
            215522456,
            215515383,
            215523869,
            216018292,
            215522857,
            215529428
        ],
        "A": [
            215510383,
            215510586,
            215509986,
            215743464,
            215510085,
            215510245,
            215511678,
            215512593,
            215510630,
            215510455,
            215509888,
            215510070,
            215513854,
            215516572,
            215510721,
            215514161,
            215521066,
            215511827,
            216018280,
            215514844,
            215514533
        ]
    },
    "name": "D. Prefix Permutation Sums",
    "statement": "Your friends have an array of n elements, calculated its array of prefix\r\nsums and passed it to you, accidentally losing one element during the\r\ntransfer. Your task is to find out if the given array can matches .A\r\npermutation of n elements is an array of n numbers from 1 to n such that\r\neach number occurs exactly times in it.The array of prefix sums of the\r\narray a is such an array b that b_i =\r\nsum_{j=1}^i a_j, 1\r\nle i\r\nle n.For example, the original permutation was [1, 5, 2, 4, 3]. Its\r\narray of prefix sums [1, 6, 8, 12, 15]. Having lost one element, you can\r\nget, for example, arrays [6, 8, 12, 15] or [1, 6, 8, 15].It can also be\r\nshown that the array [1, 2, 100] does not correspond to any permutation.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n\n#define int long long\n\nconst int MOD=998244353;\nint n,a[200001];\nvoid Delta() {\n   cin >> n;\n   for(int i=1;i<n;++i) cin >> a[i];\n   vector<int> Q={a[1]};\n   for(int i=2;i<n;++i) Q.push_back(a[i]-a[i-1]);\n   sort(Q.begin(),Q.end());\n   set<int> P;\n   int lft=-1,sum=0,cnt=0;\n   for(int i:Q) {\n      if(P.count(i)||i>n) {\n         if(lft!=-1) {\n            cout << \"NO\" << endl;\n            return;\n         }\n         lft=i;\n      } else P.insert(i);\n   }\n   for(int i=1;i<=n;++i)\n      if(!P.count(i)) {\n         cnt++;\n         sum+=i;\n      }\n   if((cnt==2&&sum==lft)||cnt==1)\n      cout << \"YES\" << endl;\n   else\n      cout << \"NO\" << endl;\n}\nsigned main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);cout.tie(0);\n   int T;cin >> T;\n   while(T--) Delta();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Prefix Permutation Sums.json",
    "editorial_link": "https://codeforces.com//blog/entry/118667",
    "editorial": "To begin with, letâs learn how to reconstruct an array from its prefix\r\nsum array. This can be done by calculating the differences between\r\nadjacent elements.If the element is missing from the array, we will add\r\nit and check if the array corresponds to some permutation.Otherwise,\r\nthere is a missing element in the middle or at the beginning of the\r\narray.Letâs count the occurrences of each difference between adjacent\r\nelements. Obviously, we should have one extra number and missing\r\nnumbers.If the count of differences occurring at least times is at least\r\n, the answer is .The answer is also if any difference occurs at least\r\ntimes.Otherwise, we check that exactly distinct numbers are missing, and\r\ntheir sum is equal to the only duplicate.\r\n",
    "hint": []
}