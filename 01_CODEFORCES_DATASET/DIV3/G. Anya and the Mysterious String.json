{
    "link": "https://codeforces.com//contest/1881/problem/G",
    "problemId": "2259908",
    "problem_idx": "G",
    "shortId": "1881G",
    "contest_number": "1881",
    "problem_submissions": {
        "G": [
            227881682,
            227890897,
            227853197,
            227853881,
            227975243,
            227899786,
            227901394,
            227911349,
            227907618,
            227893303,
            227897169,
            227918994,
            227917936,
            227914137,
            227899980,
            227912585,
            227907908,
            227897166,
            227915427,
            230763040,
            227916848,
            227913341,
            227920356,
            227867452,
            228095818,
            227915038
        ],
        "F": [
            227862562,
            227861356,
            227870757,
            227856965,
            227974789,
            227875295,
            227869909,
            227878015,
            227879864,
            227885516,
            227883744,
            227872766,
            227871133,
            227860506,
            227889327,
            230763024,
            227881722,
            227900442,
            227886326,
            227835034,
            228095806,
            227892673
        ],
        "E": [
            227850824,
            227843540,
            227942027,
            227858077,
            227874342,
            227854004,
            227852561,
            227851500,
            227864039,
            227865490,
            227859415,
            227863643,
            227846602,
            227918283,
            227845118,
            227881868,
            230762984,
            227865398,
            227875008,
            227858082,
            227872189,
            228095799,
            227883249
        ],
        "D": [
            227844854,
            227839094,
            227848716,
            227843412,
            227838899,
            227847809,
            227840878,
            227858992,
            227854380,
            227853013,
            227858090,
            227884786,
            227839966,
            227871576,
            230762965,
            227859752,
            227867911,
            227861846,
            227874828,
            228095791,
            227866894
        ],
        "C": [
            227838508,
            227835537,
            227842531,
            227866399,
            228637953,
            227849689,
            227840361,
            227848329,
            227855215,
            227848107,
            227840529,
            227850980,
            227881582,
            227837426,
            227868576,
            230762944,
            227849495,
            227862177,
            227853530,
            227898622,
            228095784,
            227862705
        ],
        "B": [
            227831568,
            227831942,
            227835393,
            227838918,
            227835692,
            227835105,
            227836643,
            227839535,
            227838170,
            227834145,
            227842440,
            227842178,
            227832528,
            227844145,
            230762918,
            227842892,
            227850062,
            227840218,
            227885672,
            228095774,
            227845241
        ],
        "A": [
            227829772,
            227829881,
            227830670,
            227836999,
            227830954,
            227830777,
            227830578,
            227833236,
            227838249,
            227829831,
            227837181,
            227833271,
            227908499,
            227830499,
            230762881,
            227836954,
            227841775,
            227831030,
            227889886,
            228095766,
            227839571
        ]
    },
    "name": "G. Anya and the Mysterious String",
    "statement": "Anya received a string s of length n brought from Rome. The string s\r\nconsists of lowercase Latin letters and at first glance does not raise\r\nany suspicions. An instruction was attached to the string.A palindrome\r\nis a string that reads the same from left to right and right to left.\r\nFor example, the strings \"\", \"\", \"\" are palindromes, while the strings\r\n\"\", \"\", \"\" are not.A substring [l\r\nldots r] of string s is a string s_l s_{l+1}\r\nldots s_{r-1} s_r. For example, the substring [4\r\nldots 6] of the string \"\" is the string \"\".A string is called if it\r\ncontain a substring of length two that is a palindrome. For example, the\r\nstrings \"\", \"\", and \"\" are , while the strings \"\", \"\" are not.When an\r\ninteger x is added to the character s_i, it is replaced x times with the\r\ncharacter in the alphabet, with \"\" being replaced by \"\".When an integer\r\nx is added to the substring [l, r] of string s, it becomes the string\r\ns_1 s_2\r\nldots s_{l-1} (s_l + x) (s_{l+1} + x)\r\nldots (s_{r-1} + x) (s_r + x) s_{r+1}\r\nldots s_n. For example, when the substring [2, 4] of the string \"\" is\r\nadded with the number 6, the resulting string is \"\".After reading the\r\ninstruction, Anya resigned herself to the fact that she has to answer m\r\nqueries. The queries can be of two types: Add the number x to the\r\nsubstring [l\r\nldots r] of string s. Determine whether the substring [l\r\nldots r] of string s is .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define pb push_back\n#define ii pair<ll,ll>\n#define F first\n#define S second\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\n#define dd pair<double,double>\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,seg[N],lz[N];\nstring s;\nvoid prep(){\n\n}\nvoid dwn (ll id){\n    ll t=lz[id];\n    (lz[id*2]+=lz[id])%=26;\n    (lz[id*2+1]+=lz[id])%=26;\n    (seg[id*2]+=lz[id])%=26;\n    (seg[id*2+1]+=lz[id])%=26;\n    lz[id]=0;\n}\nvoid upds (ll id, ll l, ll r, ll u, ll v, ll val){\n    if (l>v || r<u || l>r || u>v) return;\n    if (u<=l && r<=v){\n        (seg[id]+=val)%=26;\n        (lz[id]+=val)%=26;\n        return;\n    }\n    dwn(id);\n    ll mid=(l+r)/2;\n    upds(id*2,l,mid,u,v,val);\n    upds(id*2+1,mid+1,r,u,v,val);\n    seg[id]=(seg[id*2]+seg[id*2+1])%26;\n}\nll gets (ll id, ll l, ll r, ll u, ll v){\n    if (l>v || r<u || l>r || u>v) return 0;\n    if (u<=l && r<=v) return seg[id];\n    dwn(id);\n    ll mid=(l+r)/2;\n    ll x=gets(id*2,l,mid,u,v);\n    ll y=gets(id*2+1,mid+1,r,u,v);\n    return (x+y)%26;\n}\nstruct bit{\n    ll bit[N];\n    ll m;\n    void upd (ll pos, ll val){\n        for (ll i=pos;i<=m;i+=(i&-i))\n        bit[i]+=val;\n    }\n    ll getp (ll pos){\n        ll r=0;\n        for (ll i=pos;i>=1;i-=(i&-i))\n        r+=bit[i];\n        return r;\n    }\n    ll get (ll l, ll r){\n        if (l>r) return 0;        \n        return getp(r)-getp(l-1);\n    }\n};\nbit x1,x2;\nvoid solve()\n{\n    cin>>n>>q>>s;\n    x1.m=n;\n    x2.m=n;\n    rep(i,1,n) x1.bit[i]=x2.bit[i]=0;\n    rep(id,1,4*n) seg[id]=lz[id]=0;\n    s=\".\"+s;\n    rep(i,1,n) upds(1,1,n,i,i,s[i]-'a');\n    rep(i,1,n-1) if (s[i]==s[i+1]) x1.upd(i,1);\n    rep(i,1,n-2) if (s[i]==s[i+2]) x2.upd(i,1);\n    while (q--){\n        ll ty;\n        cin>>ty;\n        if (ty==1){\n            ll l,r,x;\n            cin>>l>>r>>x;\n            ll p=l-1;\n            if (p>=1){\n                if (p+1<=n && gets(1,1,n,p,p)==gets(1,1,n,p+1,p+1)) x1.upd(p,-1);\n                if (p+2<=n && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,-1);\n            }\n            p=l-2;\n            if (p>=1 && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,-1);\n            p=r+1;\n            if (p<=n){\n                //cout<<p<<\" \";\n                if (p-1>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-1,p-1)) x1.upd(p-1,-1);\n                if (p-2>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,-1);\n            }\n            p=r+2;\n            if (p<=n && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,-1);\n            upds(1,1,n,l,r,x);\n            p=l-1;\n            if (p>=1){\n                if (p+1<=n && gets(1,1,n,p,p)==gets(1,1,n,p+1,p+1)) x1.upd(p,1);\n                if (p+2<=n && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,1);\n            }\n            p=r+1;\n            if (p<=n){\n                if (p-1>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-1,p-1)) x1.upd(p-1,1);\n                if (p-2>=1 && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,1);\n            }\n            p=l-2;\n            if (p>=1 && gets(1,1,n,p,p)==gets(1,1,n,p+2,p+2)) x2.upd(p,1);\n            p=r+2;\n            if (p<=n && gets(1,1,n,p,p)==gets(1,1,n,p-2,p-2)) x2.upd(p-2,1);\n        }\n        else{\n            ll l,r;\n            cin>>l>>r;\n            ll p=x1.get(l,r-1);\n            p=max(p,x2.get(l,r-2));\n            if (!p) cout<<\"YES\";\n            else cout<<\"NO\";\n            cout<<\"\\n\";\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    prep();\n    while (tests--){\n        solve();\n        cout<<endl;\n}\n    cerr << \"\\n\" << (double)clock() / CLOCKS_PER_SEC * 1000 << \" ms\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Anya and the Mysterious String.json",
    "editorial_link": "https://codeforces.com//blog/entry/121327",
    "editorial": "Let\u00e2\u0080\u0099s make two obvious observations about palindromes of length at least\r\n: Palindromes of length contain a palindrome substring ; Palindromes of\r\nlength contain a palindrome substring . Now we need to learn how to\r\ntrack only palindromes of length and . Let\u00e2\u0080\u0099s call an index bad if a\r\npalindrome of length starts from it, and terrible if a palindrome of\r\nlength starts from it. We will store the bad and terrible indices in a\r\npair of .Let\u00e2\u0080\u0099s assume that there are no modification queries and we need\r\nto check the substring for beauty. If there exists a bad index () or a\r\nterrible index (), then the substring is not beautiful; otherwise, it is\r\nbeautiful. This can be checked using binary search on the set.Now let\u00e2\u0080\u0099s\r\nlearn how to make modifications. Notice that palindromes do not appear\r\nor disappear inside a segment, but they can appear or disappear at its\r\nboundaries. Let\u00e2\u0080\u0099s use a data structure that can add values on a segment\r\nand retrieve a value at a point. If such a structure exists, we will add\r\nto the segment , and then process the nearest indices to and the nearest\r\nindices to . We can describe more precisely which bad and terrible\r\nindices should be processed, but it does not affect the solution,\r\nbecause the number of such indices is still . When processing the\r\nindices, we use point queries and insertion/deletion operations in .Now\r\nwe need to implement such a data structure. The author suggests using a\r\nFenwick tree on a difference array. A segment tree with lazy propagation\r\nwill also work. This gives a solution with time complexity.\r\n"
}