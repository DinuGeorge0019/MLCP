{"link": "https://codeforces.com//contest/1426/problem/C", "problemId": "741032", "problem_idx": "C", "shortId": "1426C", "contest_number": "1426", "problem_submissions": {"F": [94089387, 94092918, 94090403, 94095742, 94088134, 94102934, 94096551, 94090044, 94100502, 94103680, 218894732, 131689129, 94100223, 94101665, 94085023, 94099275, 94107717, 94108168], "E": [94079004, 94083320, 94085257, 94085446, 94092844, 94090813, 94089559, 94099737, 94089791, 94097053, 94092910, 94097010, 94098462, 94085593, 94101850, 94089304], "D": [94071411, 94077723, 94078265, 94077474, 94069955, 94078150, 94084721, 94071027, 94084864, 94076625, 94083571, 94075395, 94086923, 94082098, 94077297, 94085021], "C": [94067630, 94073367, 94069883, 94073399, 94089927, 94071160, 94078615, 94067330, 94079325, 94073107, 94073949, 94069099, 94077626, 94066598, 94072495, 94075528], "A": [94065015, 94061620, 94061516, 94063683, 94064521, 94061955, 94064781, 94061581, 94061323, 94061123, 94062843, 94062137, 94062437, 94068632, 94061414, 94062568], "B": [94063517, 94066888, 94067224, 94068533, 94065544, 94066401, 94071303, 94080232, 94070524, 94065932, 94070012, 94081030, 94072459, 94087907, 94066918, 94069482]}, "name": "C. Increase and Copy", "statement": "Initially, you have the array a consisting of one element 1 (a = [1]).In\r\none move, you can do one of the following things: Increase some ()\r\nelement of a by 1 (choose some i from 1 to the current length of a and\r\nincrease a_i by one); Append the copy of some () element of a to the end\r\nof the array (choose some i from 1 to the current length of a and append\r\na_i to the end of the array). For example, consider the sequence of five\r\nmoves: You take the first element a_1, append its copy to the end of the\r\narray and get a = [1, 1]. You take the first element a_1, increase it by\r\n1 and get a = [2, 1]. You take the second element a_2, append its copy\r\nto the end of the array and get a = [2, 1, 1]. You take the first\r\nelement a_1, append its copy to the end of the array and get a = [2, 1,\r\n1, 2]. You take the fourth element a_4, increase it by 1 and get a = [2,\r\n1, 1, 3]. Your task is to find the number of moves required to obtain\r\nthe array with the sum at least n.You have to answer t independent test\r\ncases.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl \"\\n\"\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<'('<<p.F<< \",\"<<p.S<<')'; \n}\n\nint _runtimeTerror_()\n{\n    ll n;\n    cin>>n;\n    ll ans = INF;\n    for(ll i=1;i*i<=n;++i)\n    {\n        if(n%i==0)\n        {\n            amin(ans,(i-1) + n/i -1);\n        }\n        else\n        {\n            amin(ans,(i-1) + n/i);\n        }\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "math"], "dificulty": "1100", "interactive": false}