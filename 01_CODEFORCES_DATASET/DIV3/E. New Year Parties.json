{
    "link": "https://codeforces.com//contest/1283/problem/E",
    "problemId": "504971",
    "problem_idx": "E",
    "shortId": "1283E",
    "contest_number": "1283",
    "problem_submissions": {
        "F": [
            67823245,
            67834634,
            67835859,
            67839332,
            67838778,
            68029277,
            67864524
        ],
        "E": [
            67815384,
            67819003,
            67822271,
            67817278,
            67817529,
            67816830,
            67820462,
            67815674,
            67819758,
            67822559,
            67825595,
            67826555,
            67825514,
            67818583,
            67817970,
            67826757
        ],
        "D": [
            67813119,
            67814942,
            67816390,
            67814327,
            67815165,
            67820564,
            67815719,
            67818760,
            67815953,
            67817694,
            67816237,
            67818386,
            67815983,
            67828465,
            67827664,
            67818584
        ],
        "C": [
            67810342,
            67821978,
            67810773,
            67807591,
            67808305,
            67810663,
            67811193,
            67813438,
            67808771,
            67811324,
            67808499,
            67810527,
            67810581,
            67811981,
            67810947,
            67812828
        ],
        "B": [
            67801292,
            67798549,
            67803137,
            67801302,
            67801574,
            67803276,
            67803578,
            67802026,
            67802576,
            67803714,
            67801063,
            67802206,
            67802199,
            67800040,
            67804358,
            67805065
        ],
        "A": [
            67797268,
            67797074,
            67797886,
            67797463,
            67797278,
            67797741,
            67798798,
            67797264,
            67798057,
            67798392,
            67797423,
            67797193,
            67798258,
            67797376,
            67798881,
            67799553
        ]
    },
    "name": "E. New Year Parties",
    "statement": "Oh, New Year. The time to gather all your friends and reflect on the\r\nheartwarming events of the past year...n friends live in a city which\r\ncan be represented as a number line. The i-th friend lives in a house\r\nwith an integer coordinate x_i. The i-th friend can come celebrate the\r\nNew Year to the house with coordinate x_i-1, x_i+1 or stay at x_i. Each\r\nfriend is allowed to move no more than once.For all friends 1\r\nle x_i\r\nle n holds, however, they can come to houses with coordinates 0 and n+1\r\n(if their houses are at 1 or n, respectively).For example, let the\r\ninitial positions be x = [1, 2, 4, 4]. The final ones then can be [1, 3,\r\n3, 4], [0, 2, 3, 3], [2, 2, 5, 5], [2, 1, 3, 5] and so on. The number of\r\noccupied houses is the number of distinct positions among the final\r\nones.So all friends choose the moves they want to perform. After that\r\nthe number of occupied houses is calculated. What is the minimum and the\r\nmaximum number of occupied houses can there be?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\n\nbool marc[MAXN];\n\nint getMin()\n{\n\tint ans = 0;\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tint x = v[i];\n\n\t\tif( !marc[x - 1] && !marc[x] && !marc[x + 1] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x + 1] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint getMax()\n{\n\tint ans = 0;\n\n\tmemset( marc , false , sizeof(marc) );\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tint x = v[i];\n\n\t\tif( !marc[x - 1] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x - 1] = true;\n\t\t}\n\t\telse if( !marc[x] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x] = true;\n\t\t}\n\t\telse if( !marc[x + 1] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x + 1] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tscanf(\"%d\",&v[i]);\n\n\tsort( v + 1 , v + n + 1 );\n\n\tprintf(\"%d \",getMin());\n\tprintf(\"%d \",getMax());\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. New Year Parties.json",
    "editorial_link": "https://codeforces.com//blog/entry/72592",
    "editorial": "At first treat the two subtasks as completely independent problems.For\r\nboth solutions the array of frequences is more convinient to use, so\r\nletâs build it ( is the number of friends living in house ).1)\r\nMinimumCollect the answer greedily from left to right. If then proceed\r\nto , otherwise add to the answer and proceed to .To prove that letâs\r\nmaximize the number of merges of houses instead of minimizing the actual\r\ncount of them. Itâs easy to show that the final number of houses is the\r\ninitial one minus the number of merges.So if there are people in all\r\nconsecutive houses starting from , then merges is the absolute best you\r\ncan do with them, skipping any of the merges wonât get the better\r\nanswer. For only of them occupied merge is the best and we can achieve\r\nthat merge. And a single occupied house obviously will do merges.2)\r\nMaximumAlso greedy but letâs process the houses in segments of\r\nconsecutive positions with positive . Take a look at the sum of some\r\nsegment of houses. If the sum is greater than the length then you can\r\nenlarge that segment house to the left or to the right. If the sum is\r\ngreater by at least , than you can enlarge it both directions at the\r\nsame time.Thus the following greedy will work. Letâs update the segments\r\nfrom left to right. For each segments check the distance to the previous\r\none (if it was enlarged to the right then consider the new right\r\nborder). If you can enlarge the current segment and there is space on\r\nthe left, then enlarge it. And if you still have possibility to enlarge\r\nthe segment then enlarge it to the right.Notice that it doesnât matter\r\nwhich of any pair of consecutive segments will take the spot between\r\nthem as the answer changes the same.The initial segments can be obtained\r\nwith two pointers.Overall complexity: .\r\n",
    "hint": []
}