{
    "link": "https://codeforces.com//contest/1385/problem/E",
    "problemId": "675202",
    "problem_idx": "E",
    "shortId": "1385E",
    "contest_number": "1385",
    "problem_submissions": {
        "G": [
            87146925,
            87130516,
            87130073,
            87149307,
            87139436,
            87145109,
            87113469,
            87137001,
            87178119,
            87121112
        ],
        "F": [
            87133863,
            87148212,
            87150419,
            87133069,
            87155521,
            87156261,
            87129136,
            87201006,
            87199143,
            87198211,
            87198141,
            87197991,
            87133163,
            87135084,
            87147650,
            87153475,
            87157087,
            87159161,
            87143942,
            87140750,
            87158980
        ],
        "E": [
            87121743,
            87094311,
            87150777,
            87112227,
            87117131,
            87137692,
            87154530,
            87109484,
            87118031,
            87151551,
            87126695,
            87130754,
            87122234,
            87145112,
            87156780,
            87154434,
            87141435,
            87122925,
            87129785
        ],
        "D": [
            87114357,
            87136398,
            87136307,
            87098537,
            87103655,
            87133732,
            87148068,
            87097110,
            87107447,
            87106449,
            87137139,
            87106363,
            87103887,
            87118780,
            87124754,
            87090612,
            87122982,
            87110063,
            87101408,
            87100549
        ],
        "C": [
            87087119,
            87083714,
            87087183,
            87094082,
            87125584,
            87140844,
            87089726,
            87089545,
            87092040,
            87111442,
            87085820,
            87088762,
            87103769,
            87110798,
            87107696,
            87084280,
            87087235,
            87089175,
            87090633
        ],
        "B": [
            87082211,
            87084609,
            87082372,
            87086099,
            87118271,
            87134332,
            87085669,
            87082094,
            87085708,
            87097473,
            87081944,
            87080519,
            87090484,
            87088911,
            87082077,
            87081415,
            87081680,
            87080910,
            87083097
        ],
        "A": [
            87080978,
            87081308,
            87080529,
            87081521,
            87116439,
            87133004,
            87083295,
            87081194,
            87080773,
            87082296,
            87080859,
            87090051,
            87086698,
            87082297,
            87102822,
            87093275,
            87080753,
            87080503,
            87081225
        ]
    },
    "name": "E. Directing Edges",
    "statement": "You are given a graph consisting of n vertices and m edges. It is not\r\nguaranteed that the given graph is connected. Some edges are already\r\ndirected and you can’t change their direction. Other edges are\r\nundirected and you have to choose some direction for all these edges.You\r\nhave to direct undirected edges in such a way that the resulting graph\r\nis directed and acyclic (i.e. the graph with all edges directed and\r\nhaving no directed cycles). Note that you have to direct undirected\r\nedges.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200010;\n\nbitset <N> vis;\nvector <int> g[N], h[N], st;\nint t, n, m, type[N], U[N], V[N], comp[N], cur, topo[N];\n\nvoid forw (int u) {\n  vis[u] = 1;\n  for (int v : g[u]) if (!vis[v]) forw(v);\n  st.emplace_back(u);\n}\n\nvoid bacw (int u) {\n  comp[u] = cur;\n  for (int v : h[u]) if (!comp[v]) bacw(v);\n}\n\nint main() {\n  cin >> t;\n  while (t--) {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; ++i) {\n      g[i].clear(), h[i].clear(), vis[i] = comp[i] = 0;\n    }\n    for (int i = 1; i <= m; ++i) {\n      scanf(\"%d %d %d\", type + i, U + i, V + i);\n      if (type[i]) {\n        g[U[i]].emplace_back(V[i]);\n        h[V[i]].emplace_back(U[i]);\n      }\n    }\n    st.clear();\n    for (int i = 1; i <= n; ++i) {\n      if (!vis[i]) forw(i);\n    }\n    reverse(st.begin(), st.end());\n    cur = 0;\n    for (int u : st) {\n      if (!comp[u]) ++cur, bacw(u); \n    }\n    bool cyc = 0;\n    for (int i = 1; i <= n; ++i) {\n      for (int j : g[i]) if (comp[i] == comp[j]) {\n        cyc = 1;\n        break;\n      }\n    }\n    if (cyc) {\n      puts(\"NO\");\n      continue;\n    }\n    puts(\"YES\");\n    for (int i = 0; i < n; ++i) topo[st[i]] = i;\n    for (int i = 1; i <= m; ++i) {\n      int u = U[i], v = V[i];\n      if (!type[i] and topo[u] > topo[v]) swap(u, v);\n      printf(\"%d %d\\n\", u, v);\n    }\n  }\n  return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Directing Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/80257",
    "editorial": "Firstly, if the graph consisting of initial vertices and only directed\r\nedges contains at least one cycle then the answer is \"\". Otherwise, the\r\nanswer is always \"\". Letâs build it. Letâs build the topological sort of\r\nthe graph without undirected edges. Then letâs check for each directed\r\nedge if itâs going from left to right (in order of topological sort). If\r\nit isnât true then there is a cycle and the answer is \"\". Otherwise,\r\nletâs direct each edge from left to right in order of the topological\r\nsort.\r\n",
    "hint": []
}