{"link": "https://codeforces.com//contest/1475/problem/G", "problemId": "877139", "problem_idx": "G", "shortId": "1475G", "contest_number": "1475", "problem_submissions": {"G": [105357435, 105353117, 105356792, 105355999, 105373741, 105354969, 105380919, 105377146, 105378300, 105392699, 105388391, 105385880, 105393662, 105395380, 105394840, 105387401, 105387670, 105390094], "F": [105351927, 105357486, 105365752, 105373501, 105363421, 105369601, 105373520, 105367472, 105382350, 105374670, 105379170, 105369385, 105379845, 105380433, 105376571, 105377554, 105393804], "E": [105344845, 105346728, 105337063, 105334310, 105356585, 105370551, 105361997, 105356836, 105352936, 105365884, 105369358, 105357806, 105368246, 105367253, 105363206, 105367340, 105373988, 105367073], "D": [105338341, 105341549, 105347068, 105372256, 105350292, 105364300, 105354879, 105371230, 105368625, 105358896, 105361695, 105380627, 105356276, 105359403, 105359168, 105355985, 105378924, 105382384, 105379690], "C": [105320580, 105317968, 105329054, 105323429, 105339564, 105321102, 105326770, 105331530, 105321133, 105333110, 105339000, 105333226, 105331288, 105340903, 105338355, 105339758, 105336564], "B": [105309543, 105309679, 105321922, 105311424, 105316444, 105311086, 105314894, 105313124, 105310606, 105313344, 105315001, 105318054, 105314173, 105311720, 105316715, 105316237, 105318935], "A": [105307097, 105307137, 105312703, 105307046, 105308743, 105308312, 105309093, 105308294, 105307309, 105308822, 105309783, 105313391, 105309615, 105307651, 105310811, 105307813, 105310833, 105312748]}, "name": "G. Strange Beauty", "statement": "Polycarp found on the street an array a of n elements.Polycarp invented\r\nhis criterion for the beauty of an array. He calls an array a beautiful\r\nif at least one of the following conditions must be met i\r\nne j: a_i is divisible by a_j; or a_j is divisible by a_i. For example,\r\nif: n=5 and a=[7, 9, 3, 14, 63], then the a array is not beautiful (for\r\ni=4 and j=2, none of the conditions above is met); n=3 and a=[2, 14,\r\n42], then the a array is beautiful; n=4 and a=[45, 9, 3, 18], then the a\r\narray is not beautiful (for i=1 and j=4 none of the conditions above is\r\nmet); Ugly arrays upset Polycarp, so he wants to remove some elements\r\nfrom the array a so that it becomes beautiful. Help Polycarp determine\r\nthe smallest number of elements to remove to make the array a beautiful.\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << \"{\"; for (const auto &x : c) { if (!f) os << \", \"; f = false; os << x; } return os << \"}\"; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << \" = \" << x << \"\\n\"; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(',')) << \" = \" << x << \" | \"; debug(s.substr(s.find(',') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\", x.f, \", \", x.s, \"}\"); }\n    template<class T> void pr(const T& x) {\n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? \", \" : \"\", a), fst = 0;\n        pr(\"}\"); }\n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); }\n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\n    void setOut(string s) { freopen(s.c_str(), \"w\", stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + \".in\"), setOut(s + \".out\"); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nnamespace FactorBasic {\n\ntemplate <class T> std::vector<std::pair<T, int>> factor(T x) {\n    std::vector<std::pair<T, int>> pri;\n    for (T i = 2; i * i <= x; ++i) {\n        if (x % i == 0) {\n            int t = 0;\n            while (x % i == 0) x /= i, t++;\n            pri.push_back({i, t});\n        }\n    }\n    if (x > 1) pri.push_back({x, 1});\n    return pri;\n}\n\ntemplate <class T> T phi(T x) {\n    for (auto& a : factor(x)) x -= x / a.first;\n    return x;\n}\n\ntemplate <class T> void tour(std::vector<std::pair<T, int>>& v, std::vector<T>& res, int ind, T cur) {\n    if (ind == int(v.size())) res.push_back(cur);\n    else {\n        T mul = 1;\n        for (int i = 0; i < v[ind].second + 1; i++) {\n            tour(v, res, ind + 1, cur * mul);\n            mul *= v[ind].first;\n        }\n    }\n}\n\ntemplate <class T> std::vector<T> get_divisor(T x) {\n    auto v = factor(x);\n    std::vector<T> res; \n    tour(v, res, 0, (T) 1);\n    sort(res.begin(), res.end());\n    return res;\n}\n\n}\n\nusing namespace FactorBasic;\n\n\nconst int N = 2e5 + 5;\n\nvi divi[N];\nint dp[N];\n\nint main() {\n    setIO(\"\");\n    f1r(i, 1, N) {\n        divi[i] = get_divisor(i);\n        sort(all(divi[i]));\n    }\n\n    int tt; re(tt);\n    while (tt--) {\n        f1r(i, 1, N) dp[i] = 0;\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        sort(all(a));\n        trav(x, a) {\n            int res = 0;\n            trav(d, divi[x]) {\n                if (x == d) break;\n                ckmax(res, dp[d] + 1);\n            }\n            ckmax(dp[x], max(res, dp[x] + 1));\n        }\n\n        int ans = 0;\n        f1r(i, 1, N) ckmax(ans, dp[i]);\n        ps(n - ans);\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["dp", "math", "number theory", "sortings"], "dificulty": "1900", "interactive": false}