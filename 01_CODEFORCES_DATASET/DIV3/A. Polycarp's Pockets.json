{
    "link": "https://codeforces.com//contest/1003/problem/A",
    "problemId": "194981",
    "problem_idx": "A",
    "shortId": "1003A",
    "contest_number": "1003",
    "problem_submissions": {
        "E": [
            39924193,
            39917808,
            39923474,
            39917540,
            39932885,
            39926804,
            39919143,
            39925938,
            39924942,
            39926556,
            39916485,
            39925183,
            39923509,
            39920705,
            39924767,
            39925403,
            39927398,
            39926899
        ],
        "F": [
            39919506,
            39935298,
            39943902,
            40106973,
            40297506,
            39953456,
            39925614,
            39922839
        ],
        "C": [
            39912024,
            39905824,
            39904178,
            39906213,
            39904627,
            42751959,
            39907680,
            39905143,
            39911684,
            39902878,
            39905375,
            39904334,
            39906247,
            39910129,
            39910619,
            39907113,
            39906670,
            39906706,
            39905022,
            39908497
        ],
        "B": [
            39905186,
            39902197,
            39901483,
            39902052,
            39901889,
            39904203,
            39903228,
            39903078,
            39906991,
            39902754,
            39902358,
            39904660,
            39907858,
            39906542,
            39904875,
            39903839,
            39904869,
            39907658,
            39906314
        ],
        "D": [
            39904096,
            39911298,
            39910719,
            39910712,
            39908080,
            42751939,
            39912030,
            39914322,
            39908951,
            39910733,
            39921416,
            39908636,
            39908754,
            39914171,
            39914980,
            39914769,
            39914559,
            39912864,
            39917039,
            39913107
        ],
        "A": [
            39900356,
            39897220,
            39898269,
            39897962,
            39896936,
            39904258,
            39898551,
            39897613,
            39900244,
            39896869,
            39897844,
            39899297,
            39896960,
            39897545,
            39899825,
            39897411,
            39897414,
            39897064,
            39897008
        ]
    },
    "name": "A. Polycarp's Pockets",
    "statement": "Polycarp has n coins, the value of the i-th coin is a_i. Polycarp wants\r\nto distribute all the coins between his pockets, but he cannot put two\r\ncoins with the same value into the same pocket.For example, if Polycarp\r\nhas got six coins represented as an array a = [1, 2, 4, 3, 3, 2], he can\r\ndistribute the coins into two pockets as follows: [1, 2, 3], [2, 3,\r\n4].Polycarp wants to distribute all the coins with the minimum number of\r\nused pockets. Help him to do that.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<\"----------------\"<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<\" = \"<< x<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\n\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nint n;\nint a[MAXN];\nstring s;\nvoid input(){\n\tfor(int i=0,t;i<n;i++)\n\t\tscanf(\"%d\",&t),\n\t\ta[t]++;\n}\nvoid inputs(){\n\tcin >> s;\n}\nvoid no(){\n\tprintf(\"No\");\n}\nvoid yes(){\n\tprintf(\"Yes\");\n}\nint ans;\nint main()\n{\n    //~ freopen(\"file.in\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    input();\n    \n    \n    \n    for(int i=1;i<101;i++)\n    \tumax(ans,a[i]);\n    \n//    inputs();\n//\tif(   )\n//\t\tyes();\n//\telse\n//\t\tno();\n\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Polycarp's Pockets.json",
    "editorial_link": "https://codeforces.com/blog/entry/60417",
    "editorial": "We have to find the maximum number of elements with the same value (it\r\ncan be done by counting). This number will be the answer because if\r\nthere are no more than elements with the same value in the array it is\r\nobvious that we cannot use less than pockets, but we also doesn\u00e2\u0080\u0099t need\r\nto use more than pockets because of the other values can be also\r\ndistributed using pockets.Overall complexity is .\r\n"
}