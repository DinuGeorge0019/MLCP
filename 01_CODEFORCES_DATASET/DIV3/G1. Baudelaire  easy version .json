{
    "link": "https://codeforces.com//contest/2106/problem/G1",
    "problemId": "3350612",
    "problem_idx": "G1",
    "shortId": "2106G1",
    "contest_number": "2106",
    "problem_submissions": {
        "G1": [
            317037524,
            317062262,
            317061590,
            317052941,
            317066213,
            317065911
        ],
        "F": [
            317035761,
            317047729,
            317029292,
            317067306,
            317073415,
            317070219,
            317022800,
            317030307,
            317028689,
            317050113,
            317855906,
            317044171,
            317050574,
            317045837,
            317043135,
            317044827,
            317050773,
            317041440
        ],
        "E": [
            317020313,
            317010744,
            317046134,
            317035937,
            317029339,
            317046150,
            317010414,
            317018526,
            317021744,
            317013609,
            317950136,
            317028070,
            317036331,
            317032678,
            317025857,
            317036190,
            317040887
        ],
        "D": [
            316999946,
            317027974,
            317011069,
            317020862,
            317037534,
            317031860,
            316984555,
            317007925,
            317005998,
            317006604,
            317007086,
            317010692,
            317015300,
            317015795,
            317017807,
            317018294,
            316999673
        ],
        "C": [
            316988591,
            316986472,
            316999853,
            317026133,
            316999286,
            317002344,
            316991443,
            316988219,
            317000196,
            316978313,
            316994740,
            316996215,
            317004560,
            317006037,
            317004240,
            317004181,
            316991883
        ],
        "B": [
            316981000,
            316979542,
            316988448,
            316988900,
            316993570,
            316993687,
            317000718,
            316983017,
            316992142,
            316991120,
            316981211,
            316985408,
            316994310,
            316999518,
            316991380,
            316984785,
            316983692
        ],
        "A": [
            316977086,
            316978937,
            316978575,
            316978826,
            316982345,
            316979125,
            316997396,
            316978412,
            316977215,
            316981299,
            316977127,
            316977164,
            316982363,
            316981149,
            316979807,
            316979304,
            316977212
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142254",
    "editorial": "(Author & Analysis: SpyrosAliv) SolutionFor some node , let be its value\r\nand be the sum of the values of all nodes on the simple path from the\r\nroot of the tree to node ( will also be referenced as \"the sum of node \"\r\nfor the purposes of this solution). Also, let be the parent of node (if\r\nis not the root).Suppose that we know which node is the root of the\r\ntree. Then, we can make queries to find , which is sufficient to figure\r\nout : it holds that , therefore .Then, we have queries left to find the\r\nactual root of the tree. Consider some node , and all of its neighbor\r\nnodes .Observation 1: Toggling the value of node will change the sum of\r\nevery adjacent node to that is not the parent. Observation 2: We can\r\nfind the parent of node within queries. Consider doing binary search to\r\nfind which node does not change its sum when toggling the value of . In\r\norder to check if the prefix includes the parent of , we do the\r\nfollowing: query for , toggle the value of , and query for again. Let .\r\nFrom Observation 1, if every node among changed its value, then , so we\r\nknow that the parent does not belong in that prefix. Otherwise, there is\r\na node that did not change its sum, so we can continue our binary search\r\non that prefix. This takes queries performed times. Note that if we\r\nnever find the parent, it must mean that is the root of the tree.Since\r\nthe tree is a star, if we find the parent of node , we will find the\r\nroot. If there does not exist a parent, then is the root. The problem\r\nhas been solved in queries, which comfortably fits the query limit.There\r\nare a lot of other (better) solutions for this version (for example,\r\nthis solution), but this solution helps best for coming up with the idea\r\nfor G2.\r\n",
    "name": "G1. Baudelaire  easy version ",
    "statement": "Baudelaire is very rich, so he bought a tree of size n that is rooted at\r\nsome arbitrary node. Additionally, every node has a value of 1 or -1.\r\nCow the Nerd saw the tree and fell in love with it. However, computer\r\nscience doesn’t pay him enough, so he can’t afford to buy it. Baudelaire\r\ndecided to play a game with Cow the Nerd, and if he won, he would gift\r\nhim the tree.Cow the Nerd does not know which node is the root, and he\r\ndoesn’t know the values of the nodes either. However, he can ask\r\nBaudelaire queries of two types: 1 k u_1 u_2 ... u_k: Let f(u) be the\r\nsum of the values of all nodes in the path from the root of the tree to\r\nnode u. Cow the Nerd may choose an integer k (1\r\nle k\r\nle n) and k nodes u_1, u_2, ..., u_k, and he will receive the value\r\nf(u_1) + f(u_2) + ... + f(u_k). 2 u: Baudelaire will toggle the value of\r\nnode u. Specifically, if the value of u is 1 it will become -1, and vice\r\nversa. Cow the Nerd wins if he guesses the value of every node correctly\r\n(the values of the final tree, performing the queries) within n + 200\r\ntotal queries. Can you help him win?\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "divide and conquer",
        "greedy",
        "interactive",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G1. Baudelaire  easy version .json",
    "hint": []
}