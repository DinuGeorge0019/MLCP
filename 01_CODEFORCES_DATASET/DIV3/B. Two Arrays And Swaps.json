{"link": "https://codeforces.com//contest/1353/problem/B", "problemId": "620788", "problem_idx": "B", "shortId": "1353B", "contest_number": "1353", "problem_submissions": {"F": [80124393, 80127683, 80140343, 80142966, 80146411, 80141780, 80117292, 80132406, 80185189, 80188504], "E": [80114098, 80117275, 80128499, 80145539, 80125005, 80139306, 80127975, 80135984, 80130531, 80129427, 80125620, 80129245, 80158858, 80112124, 80126450, 80133527, 80128884, 80134345, 80129651, 80135076], "D": [80098108, 80101755, 80118374, 80103972, 80115994, 80127815, 80131082, 80141865, 80110266, 80114346, 80114023, 80103850, 80129182, 80108992, 80109025, 80113948, 80117006, 80117268, 80113177], "C": [80084355, 80086625, 80089665, 80090748, 80109095, 80123682, 80137480, 80143026, 80095516, 80096983, 80101362, 80092320, 80098872, 80100063, 80094720, 80102804, 80094807, 80099168, 80099321], "B": [80081560, 80083037, 80082947, 80084540, 80089013, 80114962, 80133140, 80144863, 80085266, 80084702, 80090165, 80084822, 80087571, 80083864, 80085636, 80092945, 80088539, 80086038, 80088726], "A": [80079491, 80079524, 80080015, 80080262, 80083439, 80109672, 80135612, 80143748, 80080163, 80079971, 80082828, 217548820, 80080548, 80081468, 80091988, 80079985, 80084451, 80081999, 80081124, 80083012]}, "name": "B. Two Arrays And Swaps", "statement": "You are given two arrays a and b both consisting of n positive (greater\r\nthan zero) integers. You are also given an integer k.In one move, you\r\ncan choose two indices i and j (1\r\nle i, j\r\nle n) and swap a_i and b_j (i.e. a_i becomes b_j and vice versa). Note\r\nthat i and j can be equal or different (in particular, swap a_2 with b_2\r\nor swap a_3 and b_9 both are acceptable moves).Your task is to find the\r\npossible sum you can obtain in the array a if you can do no more than\r\n(i.e. at most) k such moves (swaps).You have to answer t independent\r\ntest cases.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - \u043f\u0440\u043e\u0441\u0442\u043e\u0435\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,k;\n           cin>>a>>k;\n           vector <int> m1(a);\n           vector <int> m2(a);\n           for (int i=0;i<a;i++) {\n               cin>>m1[i]; \n           }\n           for (int i=0;i<a;i++) cin>>m2[i];\n           sort(m1.begin(),m1.end());\n           sort(m2.begin(),m2.end());\n           reverse(m2.begin(),m2.end());\n           int sum=0;\n           for (int i=0;i<a;i++) {\n               if (i<k) sum+=max(m1[i],m2[i]); else sum+=m1[i]; \n                \n           }\n           cout<<sum<<\"\\n\"; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432, \u0442\u043e \u0437\u0430\u043a\u043e\u043c\u0435\u043d\u0442\u0438\u0442\u044c\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }"], "input": "", "output": "", "tags": ["greedy", "sortings"], "dificulty": "800", "interactive": false}