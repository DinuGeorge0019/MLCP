{
    "link": "https://codeforces.com//contest/1296/problem/F",
    "problemId": "531588",
    "problem_idx": "F",
    "shortId": "1296F",
    "contest_number": "1296",
    "problem_submissions": {
        "F": [
            70286253,
            70288122,
            70354438,
            70285370,
            70284169,
            70273160,
            70285348,
            70284069,
            73578212
        ],
        "E2": [
            70268992,
            70280432,
            70276298,
            70288167,
            70281465,
            70297360,
            70276336,
            70279357,
            70275001,
            70289621,
            70284967,
            70279268,
            70267172,
            70283236,
            70277761,
            70279813,
            70288110,
            70291891
        ],
        "E1": [
            70259556,
            70271142,
            70274990,
            70272602,
            70283753,
            70297032,
            70271882,
            70269738,
            70275752,
            70268786,
            70271448,
            70276258,
            70273279,
            70265150,
            70276327,
            70278408,
            70275898,
            70282584,
            70276913
        ],
        "D": [
            70254151,
            70262790,
            70262428,
            70261281,
            70276243,
            70262462,
            70263810,
            70262249,
            70265276,
            70259161,
            70259866,
            70267524,
            70269993,
            70279455,
            70268313,
            70271364,
            70271292,
            70266627,
            70267013
        ],
        "C": [
            70249671,
            70254183,
            70253966,
            70257190,
            70266437,
            70255782,
            70255981,
            70254148,
            70255586,
            70253171,
            70255047,
            70257702,
            70256317,
            70276767,
            70260739,
            70266471,
            70262570,
            70259034,
            70260723
        ],
        "B": [
            70243991,
            70245027,
            70247695,
            70248175,
            70243833,
            70246192,
            70247369,
            70246768,
            70245235,
            70247847,
            70245515,
            70248129,
            70249598,
            70248726,
            70249146,
            70250758,
            70248649,
            70248220
        ],
        "A": [
            70240828,
            70240986,
            70241720,
            70243455,
            70240584,
            70241402,
            70241482,
            70242817,
            70240810,
            70240914,
            70243012,
            70245219,
            70243961,
            70242643,
            70241917,
            70240694,
            70241375,
            70241384
        ]
    },
    "name": "F. Berland Beauty",
    "statement": "There are n railway stations in Berland. They are connected to each\r\nother by n-1 railway sections. The railway network is connected, i.e.\r\ncan be represented as an undirected tree.You have a map of that network,\r\nso for each railway section you know which stations it connects.Each of\r\nthe n-1 sections has some integer value of the . However, these values\r\nare not marked on the map and you don’t know them. All these values are\r\nfrom 1 to 10^6 inclusive.You asked m passengers some questions: the j-th\r\none told you three values: his departure station a_j; his arrival\r\nstation b_j; minimum scenery beauty along the path from a_j to b_j (the\r\ntrain is moving along the shortest path from a_j to b_j). You are\r\nplanning to update the map and set some value f_i on each railway\r\nsection the . The passengers’ answers should be consistent with these\r\nvalues.Print any valid set of values f_1, f_2,\r\ndots, f_{n-1}, which the passengers’ answer is consistent with or report\r\nthat it doesn’t exist.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define LL long long\n#define PB push_back\n#define PII pair<int,int>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int N=5010,M=N*400,mod=1e9+7;\nint n,m;\nint a[N];\nvector<int>G[N];\nint siz[N],fa[N],son[N],de[N];\nint cnt,dfn[N],top[N],ed[N];\nvoid dfs1(int x){\n    siz[x]=1;\n    son[x]=-1;\n    for(int i=0;i<G[x].size();i++){\n        int &y=G[x][i];\n        if(!de[y]){\n            fa[y]=x;\n            de[y]=de[x]+1;\n            dfs1(y);\n            siz[x]+=siz[y];\n            if(son[x]==-1||siz[y]>siz[son[x]])son[x]=y;\n        }\n    }\n}\nvoid dfs2(int x,int t){\n    top[x]=t;\n    dfn[x]=++cnt;\n    if(siz[x]==1){\n        ed[x]=cnt;return;\n    }\n    dfs2(son[x],t);\n    for(int i=0;i<G[x].size();i++){\n        int &y=G[x][i];\n        if(y!=fa[x]&&y!=son[x])dfs2(y,y);\n    }\n    ed[x]=cnt;\n}\nstruct edge{\n    int u,v;\n}p[N];\nstruct node{\n    int u,v,x;\n}q[N];\nint mn[N][N];\nvoid upd(int u,int v,int x){\n    while(u!=v){\n        if(de[u]<de[v])swap(u,v);\n        mn[u][fa[u]]=mn[fa[u]][u]=max(mn[u][fa[u]],x);\n        u=fa[u];\n    }\n}\nint query(int u,int v){\n    int re=1e6;\n    while(u!=v){\n        if(de[u]<de[v])swap(u,v);\n        re=min(re,mn[u][fa[u]]);\n        u=fa[u];\n        //mn[u][fa[u]]=mn[fa[u]][u]=max(mn[u][fa[u]],x);\n    }\n    return re;\n}\nint main()\n{\n\n    cin>>n;\n    for(int i=1,u,v;i<n;i++){\n        scanf(\"%d%d\",&p[i].u,&p[i].v);\n        G[p[i].u].PB(p[i].v);\n        G[p[i].v].PB(p[i].u);\n    }\n    de[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    cin>>m;\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d%d\",&q[i].u,&q[i].v,&q[i].x);\n        upd(q[i].u,q[i].v,q[i].x);\n    }\n    for(int i=1,y;i<=m;i++){\n        y=query(q[i].u,q[i].v);\n        if(y!=q[i].x){\n            cout<<-1;\n            return 0;\n        }\n    }\n    for(int i=1;i<n;i++){\n        mn[p[i].u][p[i].v]=max(mn[p[i].u][p[i].v],1);\n        printf(\"%d \",mn[p[i].u][p[i].v]);\n    }\n    return 0;\n}\n/*\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Berland Beauty.json",
    "editorial_link": "https://codeforces.com//blog/entry/73627",
    "editorial": "Firstly, letâs precalculate arrays . The array is the array of \"parents\"\r\nif we run dfs from the vertex . So, is the vertex that is the previous\r\none before on the directed path . This part can be precalculated in time\r\nand we need it just for convenience.Initially, all values (beauties of\r\nthe edges) are zeros. Letâs consider queries in order of non-decreasing\r\n. For the current query, letâs consider the whole path and update the\r\nvalue for each on this path in the following way: . After processing all\r\nqueries, letâs replace all values with . This part works also in time\r\n.And the last part of the solution is to check if the data we\r\nconstructed isnât contradictory. We can iterate over all paths and find\r\nthe minimum value on this path. We have to sure if it equals . If it\r\nisnât true for at least one query, then the answer is .Otherwise, we can\r\nprint the resulting tree.Time complexity: , but it can be done in at\r\nleast (I hope someone can explain this solution because I am too lazy to\r\ndo it now).\r\n",
    "hint": []
}