{
    "link": "https://codeforces.com//contest/2060/problem/E",
    "problemId": "3147474",
    "problem_idx": "E",
    "shortId": "2060E",
    "contest_number": "2060",
    "problem_submissions": {
        "G": [
            301873530,
            301859046,
            301852803,
            301886996,
            301829945,
            301884074,
            301865362,
            301944483,
            301877663
        ],
        "F": [
            301809977,
            301827952,
            301788384,
            301831904,
            301878286,
            301872767,
            301850953,
            301874252,
            301811774,
            301816800,
            301831940,
            301815743,
            301889712,
            301854030,
            301836262,
            301832755,
            301848647,
            301843962,
            301841616,
            301902407
        ],
        "E": [
            301780977,
            301790293,
            301841004,
            301786821,
            301854824,
            301815095,
            301816295,
            301758990,
            301799665,
            301795284,
            301801086,
            301920235,
            301889573,
            301794741,
            301799175,
            301804483,
            301807413,
            301794652,
            301768541
        ],
        "D": [
            301771562,
            301772155,
            301822748,
            301775745,
            301785461,
            301801939,
            301852011,
            301776457,
            301782878,
            301769755,
            301787487,
            301917787,
            301889434,
            301776569,
            301786371,
            301790878,
            301764610,
            301773754,
            301756989
        ],
        "C": [
            301748633,
            301761322,
            301773736,
            301772188,
            301769620,
            301776760,
            301770890,
            301782439,
            301749719,
            301754417,
            301759048,
            301774305,
            301916945,
            301889316,
            301755362,
            301775118,
            301772704,
            301748352,
            301760800,
            301753236
        ],
        "B": [
            301746021,
            301755202,
            301761527,
            301755925,
            301795537,
            301759408,
            301745641,
            301745397,
            301750029,
            301750098,
            301915984,
            301888995,
            301750358,
            301751304,
            301755984,
            301781169,
            301750274,
            301748735
        ],
        "A": [
            301739564,
            301739279,
            301761253,
            301738865,
            301749974,
            301743163,
            301743222,
            301739250,
            301739375,
            301743095,
            301739024,
            301915381,
            301888689,
            301739666,
            301739726,
            301746215,
            301745343,
            301738637,
            301738767
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/138580",
    "editorial": "Video\r\n",
    "name": "E. Graph Composition",
    "statement": "You are given two simple undirected graphs F and G with n vertices. F\r\nhas m_1 edges while G has m_2 edges. You may perform one of the\r\nfollowing two types of operations any number of times: Select two\r\nintegers u and v (1\r\nleq u,v\r\nleq n) such that there is an edge between u and v in F. Then, remove\r\nthat edge from F. Select two integers u and v (1\r\nleq u,v\r\nleq n) such that there is no edge between u and v in F. Then, add an\r\nedge between u and v in F. Determine the minimum number of operations\r\nrequired such that for all integers u and v (1\r\nleq u,v\r\nleq n), there is a path from u to v in F there is a path from u to v in\r\nG.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; struct DSU {\tint n;\tvector<int> parent, rank_;\t\tDSU(int n) : n(n), parent(n), rank_(n, 0) {\t\tfor(int i=0; i<n; i++){\t\t\tparent[i] = i;\t\t}\t}\t\tint find_set(int v) {\t\tif (parent[v] == v) return v;\t\treturn parent[v] = find_set(parent[v]);\t}\t\tvoid union_set(int a, int b) {\t\ta = find_set(a);\t\tb = find_set(b);\t\tif(a == b) return;\t\tif(rank_[a] < rank_[b]) {\t\t\tparent[a] = b;\t\t} else if(rank_[a] > rank_[b]) {\t\t\tparent[b] = a;\t\t} else {\t\t\tparent[b] = a;\t\t\trank_[a]++;\t\t}\t}}; int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr); \tint t;\tcin >> t;\twhile(t--){\t\tint n, m1, m2;\t\tcin >> n >> m1 >> m2;\t\tvector<pair<int,int>> edgesF(m1);\t\tfor(int i=0; i<m1; i++){\t\t\tint u,v;\t\t\tcin >> u >> v;\t\t\t--u; --v;  // make 0-based\t\t\tedgesF[i] = {u,v};\t\t}\t\t\t\t// Read G edges\t\tvector<vector<int>> adjG(n);\t\tfor(int i=0; i<m2; i++){\t\t\tint u,v;\t\t\tcin >> u >> v;\t\t\t--u; --v; // make 0-based\t\t\tadjG[u].push_back(v);\t\t\tadjG[v].push_back(u);\t\t}\t\tvector<int> compG(n, -1);\t\tint compCount = 0;\t\tfor(int start=0; start<n; start++){\t\t\tif(compG[start] != -1) continue;\t\t\t// BFS/DFS from start\t\t\tqueue<int>q;\t\t\tq.push(start);\t\t\tcompG[start] = compCount;\t\t\t\t\t\twhile(!q.empty()){\t\t\t\tint u = q.front(); \t\t\t\tq.pop();\t\t\t\tfor(int w: adjG[u]){\t\t\t\t\tif(compG[w]==-1){\t\t\t\t\t\tcompG[w] = compCount;\t\t\t\t\t\tq.push(w);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tcompCount++;\t\t}\t\tDSU ufF(n);\t\tlong long removeCount = 0;\t\tfor(auto &e: edgesF){\t\t\tint x = e.first, y = e.second;\t\t\tif(compG[x] != compG[y]){\t\t\t\tremoveCount++; // cross-edge\t\t\t} else {\t\t\t\tufF.union_set(x,y);\t\t\t}\t\t}\t\tvector<unordered_set<int>> parentSets(compCount);\t\tfor(int u=0; u<n; u++){\t\t\tint c = compG[u];\t\t\tint p = ufF.find_set(u);\t\t\tparentSets[c].insert(p);\t\t}\t\t\t\tlong long addCount = 0;\t\tfor(int i=0; i<compCount; i++){\t\t\tint r_i = (int) parentSets[i].size();\t\t\tif(r_i > 0) {\t\t\t\taddCount += (r_i - 1);\t\t\t}\t\t}\t\tlong long ans = removeCount + addCount;\t\tcout << ans << \"\\n\";\t} \treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Graph Composition.json"
}