{"link": "https://codeforces.com//contest/999/problem/B", "problemId": "192341", "problem_idx": "B", "shortId": "999B", "contest_number": "999", "problem_submissions": {"E": [39482525, 39480258, 39480681, 39472815, 39481171, 39483804, 39482822, 39487988, 39486311, 39488255, 39483434, 39476369, 39475874, 39475323, 39478090, 39485416, 39483552, 39485842, 39478651], "D": [39476985, 39482714, 39477867, 39487661, 39478808, 39479957, 39478688, 39480079, 39484369, 39488043, 39682317, 39484150, 39479480, 39479981, 39480905, 39490327], "F": [39474187, 39476396, 39486159, 39480138, 39488092, 39484785, 39487824, 39489626, 39479920, 39488254, 39490520, 39472516, 39481714, 39495126, 39494491, 39484965, 39486979, 39528460, 39528455, 39509111], "C": [39468293, 39473877, 39471032, 39469713, 39469003, 39471817, 39471185, 39471833, 39473032, 39481734, 39489064, 39465485, 39469355, 39469432, 39471841, 39471812, 39470774, 39471323, 39471302], "B": [39466151, 39472359, 39467106, 39467712, 39466498, 39469904, 39468165, 39469498, 39470396, 39480507, 39490594, 39469417, 39466615, 39467515, 39469262, 39469175, 39469263, 39468726], "A": [39465278, 39470703, 39465116, 39466655, 39465297, 39465892, 39465427, 39466410, 39468368, 39479548, 39467417, 39471284, 39465152, 39465656, 39465454, 39466984, 39465563, 39467221]}, "name": "B. Reversing Encryption", "statement": "A string s of length n can be encrypted by the following algorithm:\r\niterate over all divisors of n in decreasing order (i.e. from n to 1),\r\nfor each divisor d, reverse the substring s[1\r\ndots d] (i.e. the substring which starts at position 1 and ends at\r\nposition d). For example, the above algorithm applied to the string s=\"\"\r\nleads to the following changes: \"\"\r\nto \"\"\r\nto \"\"\r\nto \"\"\r\nto \"\" (obviously, the last reverse operation doesn\u2019t change the string\r\nbecause d=1).You are given the encrypted string t. Your task is to\r\ndecrypt this string, i.e., to find a string s such that the above\r\nalgorithm results in string t. It can be proven that this string s\r\nalways exists and is unique.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl '\\n'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(2e5) + 17;\n\nint n;\nstring s;\n\nbool read() {\n    if (!(cin >> n >> s))\n        return false;\n\n    return true;\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; ++i)\n        if (n % i == 0) {\n            reverse(s.begin(), s.begin() + i);\n        }\n\n    cout << s << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n\n#ifdef SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "900", "interactive": false}