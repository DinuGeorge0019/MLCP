{
    "link": "https://codeforces.com//contest/1932/problem/A",
    "problemId": "2483348",
    "problem_idx": "A",
    "shortId": "1932A",
    "contest_number": "1932",
    "problem_submissions": {
        "F": [
            247041710,
            247046104,
            247061921,
            247064848,
            247065969,
            247067691,
            247069162,
            247061542,
            247047981,
            247066270,
            247064434,
            247030399,
            247061453,
            247062334,
            247071817,
            247074345,
            247065688,
            247070314,
            247059158
        ],
        "E": [
            247027158,
            247035724,
            247041508,
            247047392,
            247034566,
            247041281,
            247042901,
            247046269,
            247024107,
            247043959,
            247047309,
            247065699,
            247024211,
            247033451,
            247040047,
            247039052,
            247047772,
            247051378,
            247048000
        ],
        "D": [
            247025048,
            247024422,
            247027652,
            247025385,
            247027600,
            247026819,
            247026306,
            247030155,
            247057812,
            247034591,
            247024028,
            247050558,
            247039827,
            247050562,
            247026148,
            247035436,
            247033238,
            247031618,
            247035376
        ],
        "C": [
            247015841,
            247009093,
            247007805,
            247004912,
            247003665,
            247007946,
            247004168,
            247011243,
            247008047,
            247006061,
            247009525,
            247006826,
            247014290,
            247003444,
            247011933,
            247011062,
            247018803,
            247012040,
            247018641
        ],
        "B": [
            247001265,
            246998420,
            246995287,
            246992797,
            246996723,
            246996283,
            246995886,
            247000182,
            247000282,
            246995830,
            246996405,
            246997168,
            246998810,
            246995354,
            247001435,
            246999756,
            247001109,
            246996459,
            247006888
        ],
        "A": [
            246992414,
            246989927,
            246990007,
            246989302,
            246989500,
            246989572,
            246991281,
            246989684,
            246995787,
            246990634,
            246991174,
            246992575,
            246993925,
            246989365,
            246994593,
            246993034,
            246991641,
            246989247,
            246991878
        ],
        "G": [
            247104441,
            247824611,
            247147433,
            247796255
        ]
    },
    "name": "A. Thorns and Coins",
    "statement": "During your journey through computer universes, you stumbled upon a very\r\ninteresting world. It is a path with n consecutive cells, each of which\r\ncan either be empty, contain thorns, or a coin. In one move, you can\r\nmove one or two cells along the path, provided that the destination cell\r\ndoes not contain thorns (and belongs to the path). If you move to the\r\ncell with a coin, you pick it up. You want to collect as many coins as\r\npossible. Find the maximum number of coins you can collect in the\r\ndiscovered world if you start in the leftmost cell of the path.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <array>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pb push_back //emplace_back\n#define pp pop_back\n#define pii pair<ll, ll> //pair<int, int>\n#define all(x) (x).begin(),(x).end()\n#define mp(a,b) make_pair(a , b)\n#define lb lower_bound\n#define ub upper_bound\n#define sz(x) (ll)(x).size()\n#define F first\n#define S second x) (x).begin()\n#define For(x, n) for(int (x) = 0 ; (x) < (n) ; (x)++)\n#define debug(x) cout << #x << \" : \" << x << endl << flush\n#define endl '\\n'\n#define arr(x) array<ll , (x)>\n#define yes cout << \"YES\\n\"\n#define no cout << \"NO\\n\"\n#define FAST ios_base::sync_with_stdio(0);cin.tie(0);\n\nll Sum(ll a , ll b , ll MOD)\n{\n a %= MOD;\n b %= MOD;\n a += b;\n return a % MOD;\n}\n\nll Mul(ll a , ll b , ll MOD)\n{\n a %= MOD;\n b %= MOD;\n a *= b;\n return a % MOD;\n}\n\nll Pow(ll a , ll b , ll MOD)\n{\n   ll res = 1;\n   while(b)\n   {\n        if((b & 1))res = Mul(res , a , MOD);\n     a = Mul(a , a , MOD);\n     b >>= 1;\n   }\n   return res;\n}\n\nll Min(ll a , ll b)\n{\n   if(a > b)return b;\n   return a;\n}\n\nll Max(ll a , ll b)\n{\n   if(a > b)return a;\n   return b;\n}\n\nll Ceil(ll a , ll b)\n{\n if(b < 0)\n  a *= -1, b *= -1;\n\n if(a < 0)return a/b;\n\n return(a + (b-1))/b;\n}\n\n/////////////////////\n//VALS\n\n/////////////////////\n//FUNS\n\n/////////////////////\n//SOLVE\nvoid solve()\n{\n\tll n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\t\n\tll f = n;\n\tFor(i,n-1)\n\t{\n\t\tif(f == n and s[i] == '*' and s[i+1] == '*')f = i;\n\t}\n\tll ans = 0;\n\tFor(i,f)ans += (s[i] == '@');\n\t\n\tcout << ans << endl;\n\t\t\n}\n/////////////////////\n//MAIN\nint main()\n{\n    FAST;\n    ll t = 1;\n    cin >> t;\n    while(t--)\n    {\n        solve();\n    }\n}\n/////////////////////\n/*\nZZZZZZZ     A        M     M     IIIIIII  N     N\n     Z     A A      M M   M M       I     NN    N\n    Z     A   A    M   M M   M      I     N N   N\n   Z     AAAAAAA  M     M     M     I     N  N  N\n  Z      A     A  M           M     I     N   N N\n Z       A     A  M           M     I     N    NN\nZZZZZZZ  A     A  M           M  IIIIIII  N     N  TREE\n*/\n    "
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Thorns and Coins.json",
    "editorial_link": "https://codeforces.com//blog/entry/126196",
    "editorial": "Let\u00e2\u0080\u0099s move forward by if the next cell does not have spikes, and by\r\notherwise. By doing so, we will visit all spike-free cells that we can\r\nreach, and thus collect all the coins in those cells. Note that if we\r\nare in cell , and cells and have spikes, then we can only jump into the\r\nspikes and thus end the game.Therefore, we need to count how many coins\r\nappear in the string before the substring \"\".\r\n"
}