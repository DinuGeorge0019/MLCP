{
    "link": "https://codeforces.com//contest/1945/problem/D",
    "problemId": "2540239",
    "problem_idx": "D",
    "shortId": "1945D",
    "contest_number": "1945",
    "problem_submissions": {
        "G": [
            252240841,
            252250866,
            252420396,
            252278722,
            252525005,
            252548158,
            252390608,
            252567317,
            252552741
        ],
        "E": [
            252219497,
            252219260,
            252213387,
            252225102,
            252223337,
            252221318,
            252228596,
            252237032,
            252235746,
            252231786,
            252228604,
            252232973,
            252223877,
            252227459,
            252232102,
            252227652,
            252224399,
            252228708,
            252219208,
            252234028,
            252232706,
            252237279,
            252235482
        ],
        "F": [
            252212698,
            252234280,
            252233067,
            252234341,
            252240611,
            252234408,
            252239611,
            252243237,
            252244691,
            252376596,
            252238557,
            252239689,
            252241751,
            252248456,
            252244763,
            252248686,
            252238419,
            252251638,
            252253337,
            252249409,
            252253972,
            252250630
        ],
        "C": [
            252206245,
            252207712,
            252202451,
            252208700,
            252207454,
            252210649,
            252206365,
            252207126,
            252207020,
            252209180,
            252213309,
            252203687,
            252209170,
            252214626,
            252209187,
            252244934,
            252208556,
            252217228,
            252213088,
            252217154
        ],
        "D": [
            252198864,
            252212223,
            252207311,
            252216917,
            252210946,
            252214851,
            252215523,
            252213673,
            252211331,
            252213241,
            252218189,
            252208559,
            252214624,
            252218088,
            252216560,
            252210697,
            252213737,
            252221839,
            252218355,
            252222523
        ],
        "B": [
            252195700,
            252203456,
            252197691,
            252195312,
            252198069,
            252200483,
            252199692,
            252199256,
            252205068,
            252202776,
            252197737,
            252197316,
            252200847,
            252199778,
            252199654,
            252195229,
            252204485,
            252203677,
            252200862
        ],
        "A": [
            252193249,
            252196517,
            252194020,
            252193609,
            252194534,
            252195163,
            252195841,
            252195267,
            252193567,
            252198736,
            252193769,
            252193858,
            252193912,
            252195503,
            252195367,
            252193377,
            252195907,
            252194634,
            252196929
        ],
        "H": [
            252530309,
            252556908
        ]
    },
    "name": "D. Seraphim the Owl",
    "statement": "The guys lined up in a queue of n people, starting with person number i\r\n= 1, to ask Serafim the Owl about the meaning of life. Unfortunately,\r\nKirill was very busy writing the legend for this problem, so he arrived\r\na little later and stood at the end of the line after the n-th person.\r\nKirill is completely dissatisfied with this situation, so he decided to\r\nbribe some people ahead of him.For the i-th person in the queue, Kirill\r\nknows two values: a_i and b_i. If at the moment Kirill is standing at\r\nposition i, then he can choose any position j such that j < i and\r\nexchange places with the person at position j. In this case, Kirill will\r\nhave to pay him a_j coins. And for each k such that j < k < i, Kirill\r\nwill have to pay b_k coins to the person at position k. Kirill can\r\nperform this action any number of times.Kirill is thrifty, so he wants\r\nto spend as few coins as possible, but he doesn\u2019t want to wait too long,\r\nso Kirill believes he should be among the first m people in line.Help\r\nKirill determine the minimum number of coins he will have to spend in\r\norder to not wait too long.\r\n",
    "solutions": [
        "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll INF = LLONG_MAX, MOD = 1e9 + 7, P = 239;\nconst ld PI = 3.1415926535897938462643383279502, EPS = 1e-7;\n\ntemplate <typename T>\ninline ll sz(const T &a) {\n    return a.size();\n}\n\ntemplate <typename T, typename C>\nistream &operator >> (istream &in, pair<T, C> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <typename T, typename C>\nostream &operator << (ostream &out, pair<T, C> a) {\n    return out << a.first << ' ' << a.second;\n}\n\ntemplate <typename T>\nistream & operator >> (istream &in, vector<T> &a) {\n    for (auto &i : a) {\n        in >> i;\n    }\n    return in;\n}\n\ntemplate <typename T>\nostream &operator << (ostream &out, vector<T> a) {\n    for (auto i : a) {\n        out << i << ' ';\n    }\n    return out;\n}\n\ntemplate <typename T>\nvoid print(vector<T> a, string c = \"\\n\") {\n    for (T i : a) {\n        cout << i << c;\n    }\n}\n\nvoid solve() {\n    ll n, m;\n    cin >> n >> m;\n    vector<ll> a(n), b(n);\n    cin >> a >> b;\n    ll ans = 0;\n    for (int i = m; i < n; ++i) {\n        ans += min(a[i], b[i]);\n    }\n    ll sum2 = 0, ans2 = INF;\n    for (int i = m - 1; i >= 0; --i) {\n        ans2 = min(sum2 + a[i], ans2);\n        sum2 += b[i];\n    }\n    cout << ans + ans2;\n}\n\nsigned main() {\n#ifdef LOCAL\n    freopen(\"inp.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n    freopen(\"err.txt\", \"w\", stderr);\n\n    auto start_time = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int times = 1;\n    cin >> times;\n    while (times--)\n        solve(), cout << '\\n';\n\n#ifdef LOCAL\n    auto end_time = clock();\n    cerr << setprecision(3) << fixed << \"Execution time: \" << (end_time - start_time) * (int) 1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Seraphim the Owl.json",
    "editorial_link": "https://codeforces.com//blog/entry/127377",
    "editorial": "Let\u00e2\u0080\u0099s consider a greedy approach. Suppose we are standing at position .\r\nFind the first such that and . If such exists and , then swap with .\r\nThis will be optimal, because in any case we will have to pay the people\r\nat positions some amount of coins, and in this way we will pay each\r\nperson at position where , coins. According to the greedy condition , so\r\nis the minimum amount of coins we can pay -th person. We will also pay\r\nthe -th person coins. , hence we will pay the minimum amount of coins to\r\nall people.If such does not exist, then it is advantageous for us to\r\nchoose the final position , such that , in order to finish the movements\r\nand overpay as little as possible. Simply check each , recalculating the\r\nanswer using prefix sums on array and choose the smallest\r\none.Asymptotics: .\r\n"
}