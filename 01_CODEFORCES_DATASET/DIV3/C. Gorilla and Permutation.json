{
    "link": "https://codeforces.com//contest/1992/problem/C",
    "problemId": "2748265",
    "problem_idx": "C",
    "shortId": "1992C",
    "contest_number": "1992",
    "problem_submissions": {
        "G": [
            270004158,
            270000712,
            270020186,
            270006424,
            270010291,
            270026135,
            270032635,
            270035721,
            270033149,
            270036718,
            270041253,
            270830404,
            270035615,
            270034895,
            270041739,
            270045150,
            269953500,
            270015289,
            269950486
        ],
        "F": [
            269972577,
            270018896,
            269993465,
            269987867,
            269991929,
            270003873,
            269994703,
            270009199,
            270016540,
            270005935,
            270127981,
            270013136,
            270020087,
            270019936,
            270018379,
            269963694,
            270043761,
            270005597,
            269985278
        ],
        "D": [
            269954705,
            269930808,
            269933166,
            269942867,
            269936957,
            269946925,
            269942518,
            269941050,
            269944797,
            269962503,
            269960047,
            269956728,
            269964646,
            270000105,
            269992943,
            269953387,
            270024549,
            269937412
        ],
        "E": [
            269950946,
            269964630,
            269972651,
            269967159,
            269979484,
            269986612,
            269986054,
            269986867,
            269983914,
            269989311,
            269990694,
            269983845,
            269996015,
            269971543,
            269983529,
            270000206,
            270015715,
            269961487
        ],
        "C": [
            269920653,
            269918264,
            269915470,
            269928750,
            269924685,
            269919119,
            269916880,
            269924258,
            269918590,
            269936939,
            269921649,
            269929196,
            269923650,
            269913996,
            269998285,
            269933575,
            270027835,
            269914944
        ],
        "B": [
            269901952,
            269907735,
            269910847,
            269907929,
            269906378,
            269906593,
            269906048,
            269911414,
            269907898,
            269912483,
            269907733,
            269916021,
            269911764,
            269906789,
            270003910,
            269961585,
            270031623,
            269906408
        ],
        "A": [
            269898839,
            269900621,
            269899306,
            269900117,
            269900634,
            269898982,
            269898946,
            269899343,
            269899743,
            269900745,
            269900678,
            269900839,
            269903685,
            269898938,
            270007186,
            269957657,
            270033185,
            269900065
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131461",
    "editorial": "TutorialLet be some permutation. Let\u00e2\u0080\u0099s look at the contribution of the\r\nnumber to the sum . If it is less than , the contribution is , otherwise\r\nthe contribution is . Similarly, let\u00e2\u0080\u0099s look at the contribution of to\r\nthe sum . If it is greater than , the contribution is , otherwise it is\r\n. Since , each number gives a contribution greater than in at most one\r\nsum. Therefore, it is advantageous to place numbers not less than at the\r\nbeginning, and numbers not greater than at the end. Also, numbers not\r\nless than should be in descending order to maximize the sum of .\r\nSimilarly, numbers not greater than should be in ascending order to\r\nminimize the sum of .For example, you can construct such a permutation:\r\n. It is easy to see that cannot be greater for any other permutation,\r\nand cannot be less for any other permutation, so our answer is\r\noptimal.Solution complexity: .\r\n",
    "name": "C. Gorilla and Permutation",
    "statement": "Gorilla and Noobish_Monk found three numbers n, m, and k (m < k). They\r\ndecided to construct a permutation^{\r\ndagger} of length n.For the permutation, Noobish_Monk came up with the\r\nfollowing function: g(i) is the sum of all the numbers in the\r\npermutation on a prefix of length i that are not greater than m.\r\nSimilarly, Gorilla came up with the function f, where f(i) is the sum of\r\nall the numbers in the permutation on a prefix of length i that are not\r\nless than k. A prefix of length i is a subarray consisting of the first\r\ni elements of the original array.For example, if n = 5, m = 2, k = 5,\r\nand the permutation is [5, 3, 4, 1, 2], then: f(1) = 5, because 5\r\nge 5; g(1) = 0, because 5 > 2; f(2) = 5, because 3 < 5; g(2) = 0,\r\nbecause 3 > 2; f(3) = 5, because 4 < 5; g(3) = 0, because 4 > 2; f(4) =\r\n5, because 1 < 5; g(4) = 1, because 1\r\nle 2; f(5) = 5, because 2 < 5; g(5) = 1 + 2 = 3, because 2\r\nle 2. Help them find a permutation for which the value of\r\nleft(\r\nsum_{i=1}^n f(i) -\r\nsum_{i=1}^n g(i)\r\nright) is maximized.^{\r\ndagger}A permutation of length n is an array consisting of n distinct\r\nintegers from 1 to n in any order. For example, [2,3,1,5,4] is a\r\npermutation, but [1,2,2] is not a permutation (as 2 appears twice in the\r\narray) and [1,3,4] is also not a permutation (as n=3, but 4 appears in\r\nthe array).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using namespace std;\u00a0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\u00a0const int MXN = 2e5 + 5;\u00a0mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\u00a0void _(){\tint n, m, k;\tcin >> n >> m >> k;\tfor (int i = n; i >= k; i--) cout << i << ' ';\tfor (int i = m + 1; i < k; i++) cout << i << ' ';\tfor (int i = 1; i <= m; i++) cout << i << ' ';\tcout << '\\n';\t}\u00a0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\twhile (t--)\t{\t\t_();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Gorilla and Permutation.json"
}