{
    "link": "https://codeforces.com//contest/1141/problem/D",
    "problemId": "316172",
    "problem_idx": "D",
    "shortId": "1141D",
    "contest_number": "1141",
    "problem_submissions": {
        "G": [
            52739588,
            51536187,
            51534299,
            51525036,
            55748640,
            98770872,
            51606575,
            51605903,
            51550288,
            51562985
        ],
        "E": [
            51521056,
            51509494,
            51514700,
            51509864,
            51515343,
            51512067,
            51514136,
            51516742,
            51515279,
            51513645,
            51514418,
            51515657,
            51529830,
            51518938,
            51520757,
            51514193,
            51518496,
            51519253
        ],
        "F2": [
            51512804,
            51520813,
            51519468,
            51520462,
            51524714,
            51522819,
            51524615,
            51526867,
            51526388,
            51528287,
            51528610,
            51526942,
            51526833,
            51528921,
            51567579,
            51529733,
            51520266,
            51530585,
            51528159
        ],
        "F1": [
            51512586,
            51519520,
            51520037,
            51530962,
            51520861,
            51524235,
            51522340,
            51524194,
            51526191,
            51525945,
            51527775,
            51528063,
            51527052,
            51527343,
            51520158,
            51528384,
            51528375,
            51520780,
            51530653,
            51527810
        ],
        "D": [
            51504077,
            51500288,
            51507602,
            51497021,
            51498993,
            51505660,
            51501736,
            51504542,
            51504450,
            51505517,
            51507648,
            51506380,
            51507813,
            51509739,
            51507965,
            51506483,
            51503583,
            51507577,
            51514228
        ],
        "C": [
            51496498,
            51493212,
            51499078,
            51492880,
            51502608,
            51499584,
            51495627,
            51495976,
            51499494,
            51500075,
            51499041,
            51503297,
            51499022,
            51497246,
            51497075,
            51529270,
            51499224,
            51506668
        ],
        "B": [
            51489707,
            51490678,
            51493680,
            51489601,
            51492373,
            51494463,
            51492484,
            51490578,
            51491799,
            51494772,
            51492508,
            51496543,
            51490227,
            51491876,
            51492884,
            51490276,
            51493813,
            51493209
        ],
        "A": [
            51488460,
            51488637,
            51489458,
            51488560,
            51490651,
            51489465,
            51489640,
            51488837,
            51490105,
            51489577,
            51489271,
            51494436,
            51488528,
            51488619,
            51489959,
            51488566,
            51490539
        ]
    },
    "name": "D. Colored Boots",
    "statement": "There are n left boots and n right boots. Each boot has a color which is\r\ndenoted as a lowercase Latin letter or a question mark (\u201d). Thus, you\r\nare given two strings l and r, both of length n. The character l_i\r\nstands for the color of the i-th left boot and the character r_i stands\r\nfor the color of the i-th right boot.A lowercase Latin letter denotes a\r\nspecific color, but the question mark (\u201d) denotes an indefinite color.\r\nTwo specific colors are if they are exactly the same. An indefinite\r\ncolor is with any (specific or indefinite) color.For example, the\r\nfollowing pairs of colors are compatible: (\u201d, \u201d), (\u201d, \u201d), (\u201d, \u201d) and (\u201d,\r\n\u201d). The following pairs of colors are compatible: (\u201d, \u201d) and (\u201d,\r\n\u201d).Compute the maximum number of pairs of boots such that there is one\r\nleft and one right boot in a pair and their colors are compatible.Print\r\nthe maximum number of such pairs and the pairs themselves. A boot can be\r\npart of at most one pair.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nll n;\nstring s1, s2;\nvector< vector<ll> > g1(200);\nvector< vector<ll> > g2(200);\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n\n    cin >> s1 >> s2;\n    for(int i = 0; i < n; ++i){\n        g1[s1[i]].pb(i + 1);\n        g2[s2[i]].pb(i + 1);\n    }\n\n    vector<pair<ll, ll> > ans;\n\n    for(int i = 0; i < 200; ++i){\n        if((int)'?' == i) continue;\n        if(g1[i].size() != 0 && g2[i].size() != 0){\n            for(int j = 0; j < min((ll)g1[i].size(), (ll)g2[i].size()); ++j){\n                ans.pb({g1[i][j], g2[i][j]});\n            }\n        }\n    }\n\n    ll cur = 0;\n    ll vopr = (int)'?';\n        for(int i = 0; i < 200; ++i){\n            if(i == vopr) continue;\n            if(cur >= g1[vopr].size()) break;\n            if(g1[i].size() < g2[i].size()){\n                for(int j = g1[i].size(); j < g2[i].size(); ++j){\n                    ans.pb({g1[vopr][cur], g2[i][j]});\n                    cur++;\n                    if(cur >= g1[vopr].size()) break;\n                }\n            }\n        }\n\n    ll cur1 = cur;\n\n    cur = 0;\n\n        for(int i = 0; i < 200; ++i){\n            if(i == vopr) continue;\n            if(cur >= g2[vopr].size()) break;\n            if(g2[i].size() < g1[i].size()){\n                for(int j = g2[i].size(); j < g1[i].size(); ++j){\n                    ans.pb({g1[i][j], g2[vopr][cur]});\n                    cur++;\n                    if(cur >= g2[vopr].size()) break;\n                }\n            }\n        }\n\n    ll cur2 = cur;\n\n    for(int i1 = cur1, i2 = cur2; i1 < g1[vopr].size() && i2 < g2[vopr].size(); ++i1, ++i2){\n        ans.pb({g1[vopr][i1], g2[vopr][i2]});\n    }\n\n    cout << ans.size() << '\\n';\n    for(int i = 0; i < ans.size(); ++i){\n        cout << ans[i].first << ' ' << ans[i].second << '\\n';\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Colored Boots.json",
    "editorial_link": "https://codeforces.com//blog/entry/66062",
    "editorial": "Use greedy approach in this problem. At first, match such pairs that\r\ncolors are exactly the same (and they are specific, not indefinite).\r\nAfter it match each indefinite colored left boot (if any) with any\r\nspecific colored right boot. Possibly, some indefinite colored left\r\nboots stay unmatched. Similarly, match each indefinite colored right\r\nboot (if any) with any specific colored left boot. And finally match\r\nindefinite colored left and right boots (if any).\r\n"
}