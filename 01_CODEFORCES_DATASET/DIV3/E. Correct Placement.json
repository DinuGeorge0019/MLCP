{
    "link": "https://codeforces.com//contest/1472/problem/E",
    "problemId": "854355",
    "problem_idx": "E",
    "shortId": "1472E",
    "contest_number": "1472",
    "problem_submissions": {
        "F": [
            103262561,
            103276963,
            103283145,
            103236120,
            103299603,
            103280037,
            103283982,
            103299636,
            103262171,
            103266435,
            103266707,
            103276432,
            103305724,
            103305561,
            103312140,
            103296820,
            103289516
        ],
        "G": [
            103247133,
            103238309,
            103265834,
            103256471,
            103273915,
            103293538,
            103298242,
            103268903,
            103231487,
            103253031,
            103265141,
            103262744,
            103269566,
            103284052,
            103274415
        ],
        "E": [
            103232102,
            103223895,
            103237385,
            103272807,
            103242184,
            103256098,
            103261560,
            103284295,
            103272410,
            103347793,
            103285217,
            103237054,
            103246827,
            103233098,
            103239873,
            103242625,
            103245603,
            103246214,
            103227701,
            103253419
        ],
        "D": [
            103207950,
            103207957,
            103217168,
            103202671,
            103216674,
            103217143,
            103225940,
            103215649,
            103278518,
            103287434,
            103203579,
            103227081,
            103193660,
            103216373,
            103212463,
            103198886,
            103214065,
            103204468,
            103205436
        ],
        "C": [
            103194323,
            103193866,
            103191356,
            103198459,
            103198975,
            103205574,
            103191182,
            103243332,
            103280810,
            103289310,
            103198851,
            103199943,
            103206511,
            103207377,
            103204240,
            103192503,
            103203543,
            103196542,
            103198696
        ],
        "B": [
            103191009,
            103189264,
            103188527,
            103213801,
            103193697,
            103201611,
            103200035,
            103198875,
            103286479,
            103291761,
            103193834,
            103194538,
            103187178,
            103193610,
            103194731,
            103188054,
            103194899,
            103190639,
            103190538
        ],
        "A": [
            103186521,
            103187194,
            103186563,
            103201739,
            103187144,
            103188906,
            103207506,
            103187635,
            103246273,
            103293364,
            103186560,
            103189197,
            103194552,
            103186844,
            103187875,
            103186517,
            103187671,
            103186808,
            103186538
        ]
    },
    "name": "E. Correct Placement",
    "statement": "Polycarp has invited n friends to celebrate the New Year. During the\r\ncelebration, he decided to take a group photo of all his friends. Each\r\nfriend can stand or lie on the side.Each friend is characterized by two\r\nvalues h_i (their height) and w_i (their width). On the photo the i-th\r\nfriend will occupy a rectangle h_i\r\ntimes w_i (if they are standing) or w_i\r\ntimes h_i (if they are lying on the side).The j-th friend can be placed\r\nin front of the i-th friend on the photo if his rectangle is lower and\r\nnarrower than the rectangle of the i-th friend. Formally, of the\r\nfollowing conditions must be fulfilled: h_j < h_i w_j < w_i (both\r\nfriends are standing or both are lying); w_j < h_i h_j < w_i (one of the\r\nfriends is standing and the other is lying). For example, if n = 3,\r\nh=[3,5,3] and w=[4,4,3], then: the first friend can be placed in front\r\nof the second: w_1 < h_2 and h_1 < w_2 (one of the them is standing and\r\nthe other one is lying); the third friend can be placed in front of the\r\nsecond: h_3 < h_2 and w_3 < w_2 (both friends are standing or both are\r\nlying). In other cases, the person in the foreground will overlap the\r\nperson in the background.Help Polycarp for each i find any j, such that\r\nthe j-th friend can be located in front of the i-th friend (i.e. at\r\nleast one of the conditions above is fulfilled).Please note that you do\r\nnot need to find the arrangement of all people for a group photo. You\r\njust need to find for each friend i any other friend j who can be\r\nlocated in front of him. Think about it as you need to solve n separate\r\nindependent subproblems.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nint a[N_MAX], b[N_MAX];\n\nvector <int> v;\n\nmap <int, int> mp;\n\npair <int, int> BIT[2 * N_MAX];\n\nvoid update (int pos, int val, int x)\n{\n    for(int i = pos; i <= 2 * n; i += i & -i)\n        BIT[i] = min(BIT[i], make_pair(val, x));\n}\n\npair <int, int> query (int pos)\n{\n    pair <int, int> ans = make_pair(INT_MAX, 0);\n    for(int i = pos; i >= 1; i -= i & -i)\n        ans = min(ans, BIT[i]);\n    return ans;\n}\n\npair <int, int> ans1[N_MAX], ans2[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        v.clear();\n        mp.clear();\n        for(int i = 1; i <= n; i++)\n        {\n            cin >> a[i] >> b[i];\n            v.push_back(a[i]);\n            v.push_back(b[i]);\n            ans1[i] = ans2[i] = make_pair(INT_MAX, 0);\n        }\n        sort(v.begin(), v.end());\n        int curr = 0;\n        for(int i = 0; i < (int)v.size(); i++)\n        {\n            if(i == 0 || v[i] > v[i - 1])\n                curr++;\n            mp[v[i]] = curr;\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            a[i] = mp[a[i]];\n            b[i] = mp[b[i]];\n        }\n        for(int i = 1; i <= 2 * n; i++)\n            BIT[i] = make_pair(INT_MAX, 0);\n        for(int i = 1; i <= n; i++)\n        {\n            ans1[i] = min(ans1[i], query(a[i]));\n            ans2[i] = min(ans2[i], query(b[i]));\n            update(a[i] + 1, b[i], i);\n        }\n        for(int i = 1; i <= 2 * n; i++)\n            BIT[i] = make_pair(INT_MAX, 0);\n        for(int i = n; i >= 1; i--)\n        {\n            ans1[i] = min(ans1[i], query(a[i]));\n            ans2[i] = min(ans2[i], query(b[i]));\n            update(a[i] + 1, b[i], i);\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            if(ans1[i].first < b[i])\n                cout << ans1[i].second << \" \";\n            else if(ans2[i].first < a[i])\n                cout << ans2[i].second << \" \";\n            else\n                cout << \"-1 \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Correct Placement.json",
    "editorial_link": "https://codeforces.com//blog/entry/86406",
    "editorial": "Letâs sort all people by their height in descending order.Now letâs go\r\nthrough all the people and look for the position of the person in the\r\nsorted array, the height of which is strictly less than ours (for\r\nexample, by binary search). Obviously, only those people who are in the\r\nsorted array later than the found person can stand in front of us (all\r\nof them have a height strictly less than ours).Among all these people,\r\nit is more profitable for us to take a person with minimum width. In\r\norder to find such a person quickly, we can find a person with the\r\nminimum width for each suffix of the sorted array.To handle a situation\r\nwhere a person is lying down, we need to swap the width and height and\r\nrepeat the algorithm above.\r\n",
    "hint": []
}