{
    "link": "https://codeforces.com//contest/1328/problem/E",
    "problemId": "573971",
    "problem_idx": "E",
    "shortId": "1328E",
    "contest_number": "1328",
    "problem_submissions": {
        "F": [
            74521514,
            74458947,
            74467934,
            74459743,
            74477945,
            74479296,
            74477976,
            74460067,
            74479401,
            74451936,
            74481411,
            74517274,
            74469162,
            74751835,
            74484053,
            74570676,
            75069905
        ],
        "E": [
            74521498,
            74425897,
            74448868,
            74469722,
            74453344,
            74450430,
            74451583,
            74481242,
            74461079,
            74480712,
            74461492,
            74440509,
            74433950,
            74453485,
            74450187,
            74455849,
            74458845,
            74470218,
            74462427,
            74456809
        ],
        "D": [
            74521470,
            74418087,
            74432049,
            74443528,
            74433824,
            74440013,
            74434934,
            74442956,
            74448606,
            74468894,
            74434326,
            74418253,
            74446884,
            74422378,
            74433135,
            74445359,
            74444092,
            74446810,
            74436674,
            74439681,
            74436955
        ],
        "C": [
            74521449,
            74427519,
            74417294,
            74412670,
            74418245,
            74414924,
            74418343,
            74430971,
            74433882,
            74427388,
            74419673,
            74411543,
            74408681,
            74418088,
            74421292,
            74418723,
            74414986,
            74421425,
            74419827,
            74417279,
            74426221
        ],
        "B": [
            74521428,
            74410739,
            74410669,
            74414505,
            74408929,
            74424040,
            74412257,
            74445705,
            74430405,
            74422019,
            74402783,
            74408301,
            74420620,
            74406341,
            74415300,
            74411825,
            74407115,
            74413788,
            74409526,
            74409821,
            74428748
        ],
        "A": [
            74521413,
            74399723,
            74400111,
            74400161,
            74407479,
            74400948,
            74397437,
            74397606,
            74401496,
            74400048,
            74407625,
            74397552,
            74398246,
            74403424,
            74403420,
            74398403,
            74402962,
            74402324,
            74397768,
            74400852,
            74397419,
            74399350,
            74399074
        ]
    },
    "name": "E. Tree Queries",
    "statement": "You are given a rooted tree consisting of n vertices numbered from 1 to\r\nn. The root of the tree is a vertex number 1.A tree is a connected\r\nundirected graph with n-1 edges.You are given m queries. The i-th query\r\nconsists of the set of k_i distinct vertices v_i[1], v_i[2],\r\ndots, v_i[k_i]. Your task is to say if there is a path from the root to\r\nsome vertex u such that each of the given k vertices is either belongs\r\nto this path or has the distance 1 to some vertex of this path.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, m, dep[N], sz[N], dfn[N], fa[N][20], v[N], dnum;\nvector<int> e[N];\nint dfs(int id, int f, int d) {\n  fa[id][0] = f, dep[id] = d, sz[id] = 1, dfn[id] = ++dnum;\n  for (auto it : e[id])\n    if (it != fa[id][0]) sz[id] += dfs(it, id, d + 1);\n  return sz[id];\n}\nbool cmp(int a, int b) { return dep[a] > dep[b]; }\nint LCA(int x, int y) {\n  if (dep[x] < dep[y]) swap(x, y);\n  for (int i = 18; ~i; i--)\n    if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];\n  if (x == y) return x;\n  for (int i = 18; ~i; i--)\n    if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];\n  return fa[x][0];\n}\nbool check(int x, int y) {\n  int d = LCA(x, y);\n  if (d != y && fa[y][0] != d) return false;\n  return true;\n}\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  dfs(1, 0, 1);\n  for (int i = 1; i < 19; i++)\n    for (int j = 1; j <= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];\n  for (int i = 1; i <= m; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for (int j = 1; j <= k; j++) scanf(\"%d\", &v[j]);\n    sort(v + 1, v + k + 1, cmp);\n    bool pd = 1;\n    for (int j = 1; j < k; j++)\n      if (!check(v[j], v[j + 1])) pd = 0;\n    puts(pd ? \"YES\" : \"NO\");\n  }\n  return 0;\n}\n/*\n10 6\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n7 8\n7 9\n9 10\n4 3 8 9 10\n3 2 4 6\n3 2 1 5\n3 4 8 2\n2 6 10\n3 5 4 7\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Tree Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/75246",
    "editorial": "Firstly, letâs choose some deepest (farthest from the root) vertex in\r\nthe query (among all such vertices we can choose any). It is obvious\r\nthat every vertex in the query should either belong to the path from the\r\nroot to or the distance to some vertex of this path should be at most\r\none. Now there are two ways: write some LCA algorithms and other hard\r\nstuff which is unnecessary in this problem or write about lines of code\r\nand solve the problem.Letâs take every non-root vertex (except ) and\r\nreplace it with its parent. So, whatâs next? Now the answer is \"\" if\r\nvertex (after transformation) belongs to the path from root to . Now we\r\njust need to check if it is true.We can do this using the very standard\r\ntechnique: firstly, letâs run dfs from the root and calculate for each\r\nvertex the first time we visited it () and the last time we visited it\r\n().We can do this using the following code: void dfs(int v, int par =\r\n-1) { tin[v] = T++; for (auto to : g[v]) { if (to == par) continue;\r\ndfs(to, v); } tout[v] = T++;}Initially, equals zero. Now we have a\r\nbeautiful structure giving us so much information about the tree.\r\nConsider all segments . We can see that there is no pair of intersecting\r\nsegments. The pair of segments and is either non-intersecting at all or\r\none segment lies inside the other one. The second beautiful fact is that\r\nfor each vertex in the subtree of the segment lies inside the segment\r\n.So, we can check if one vertex is the parent of the other: the vertex\r\nis the parent of the vertex if and only if and (the vertex is the parent\r\nof itself).How do we check if the vertex lies on the path from the root\r\nto the vertex ? It lies on this path if the root is the parent of (it is\r\nalways true) and is the parent of . This approach can be used for each\r\npath (such a path from to that is either or ).Time complexity: .\r\n",
    "hint": []
}