{
    "link": "https://codeforces.com//contest/1234/problem/B2",
    "problemId": "426512",
    "problem_idx": "B2",
    "shortId": "1234B2",
    "contest_number": "1234",
    "problem_submissions": {
        "F": [
            61647149,
            61645384,
            61650555,
            61651870,
            61667991,
            62194838,
            61712119,
            61666405,
            61729878,
            61729799,
            61664234,
            68329269,
            61680222,
            61752962
        ],
        "E": [
            61637715,
            61643598,
            61648539,
            61642595,
            61643656,
            61651547,
            61650480,
            61652692,
            61641203,
            61649142,
            61659878,
            61650257,
            61653772,
            61654963,
            61657548,
            61649045,
            61654746,
            61657468,
            61654998,
            61655416
        ],
        "C": [
            61632575,
            61627606,
            61654578,
            61628592,
            61630466,
            61624366,
            61638436,
            61629236,
            61652967,
            61631133,
            61636961,
            61642219,
            61643521,
            61637365,
            61636499,
            61632963,
            61634943,
            61633612,
            61629926,
            61640840
        ],
        "B1": [
            61622243,
            61619256,
            61623667,
            61618942,
            61620065,
            61620401,
            61621233,
            61618288,
            61620321,
            61625306,
            61621149,
            61623370,
            61622245,
            61622135,
            61620954,
            61622191,
            61621982,
            61619236,
            61622554,
            61619031
        ],
        "B2": [
            61622177,
            61619354,
            61626675,
            61618859,
            61617735,
            61620174,
            61619049,
            61620082,
            61618293,
            61625056,
            61620210,
            61624129,
            61619541,
            61622218,
            61620837,
            61628084,
            61621947,
            61619088,
            61624726,
            61619187
        ],
        "D": [
            61620922,
            61632151,
            61634663,
            61631934,
            61627516,
            61628612,
            61627461,
            61639106,
            61624471,
            61635660,
            61628357,
            61634636,
            61632191,
            61627962,
            61627805,
            61636954,
            61642587,
            61638100,
            61640694,
            61630321
        ],
        "A": [
            61612861,
            61620182,
            61616933,
            61612804,
            61614828,
            61613376,
            61613863,
            61613458,
            61613474,
            61619474,
            61614252,
            61614656,
            61613262,
            61614503,
            61613228,
            61614047,
            61614323,
            61618981,
            61616841,
            61613092
        ]
    },
    "name": "B2. Social Network  hard version ",
    "statement": ".You are messaging in one of the popular social networks via your\r\nsmartphone. Your smartphone can show at most k most recent conversations\r\nwith your friends. Initially, the screen is empty (i.e. the number of\r\ndisplayed conversations equals 0).Each conversation is between you and\r\nsome of your friends. There is at most one conversation with any of your\r\nfriends. So each conversation is uniquely defined by your friend.You\r\n(suddenly!) have the ability to see the future. You know that during the\r\nday you will receive n messages, the i-th message will be received from\r\nthe friend with ID id_i (1\r\nle id_i\r\nle 10^9).If you receive a message from id_i in the conversation which is\r\ncurrently displayed on the smartphone then nothing happens: the\r\nconversations of the screen do not change and do not change their order,\r\nyou read the message and continue waiting for new messages.Otherwise\r\n(i.e. if there is no conversation with id_i on the screen): Firstly, if\r\nthe number of conversations displayed on the screen is k, the last\r\nconversation (which has the position k) is removed from the screen. Now\r\nthe number of conversations on the screen is guaranteed to be less than\r\nk and the conversation with the friend id_i is not displayed on the\r\nscreen. The conversation with the friend id_i appears on the first (the\r\ntopmost) position on the screen and all the other displayed\r\nconversations are shifted one position down. Your task is to find the\r\nlist of conversations (in the order they are displayed on the screen)\r\nafter processing all n messages.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tstd::set<int> active;\n\tstd::deque<int> state;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint val;\n\t\tcin >> val;\n\n\t\tif(active.count(val) == 0) {\n\t\t\tif(len(state) < k) {\n\t\t\t\tstate.push_front(val);\n\t\t\t\tactive.insert(val);\n\t\t\t} else {\n\t\t\t\tint last = state.back();\n\t\t\t\tstate.pop_back();\n\t\t\t\tactive.erase(last);\n\n\t\t\t\tstate.push_front(val);\n\t\t\t\tactive.insert(val);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << len(state) << '\\n';\n\n\tfor(auto& elem: state) {\n\t\tcout << elem << ' ';\n\t}\n\n\tcout << '\\n';\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B2. Social Network  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/70233",
    "editorial": "The idea of this solution is the same as in the easy version, but now we\r\nneed to do the same sequence of moves faster. We can notice that the\r\nsmartphone screen works as a queue, so let store it as a queue! When the\r\nnew message appears, we have to check if the friend with this ID is in\r\nthe queue already, but we need to check it somehow fast. Letâs use some\r\nlogarithmic structure that stores the same information as the queue but\r\nin other order to find, add and remove elements fast. In C++ this\r\nstructure is .So letâs check if the current friend is in the queue, and\r\nif no, letâs check if the size of the queue is . If it is so then letâs\r\nremove the first element of the queue from it and the same element from\r\nthe set also. Then add the current friend to the queue and to the set.\r\nAfter processing all messages, the reversed queue (the queue from tail\r\nto head) is the answer to the problem.Time complexity: .And donât forget\r\nthat and other standard hashmaps can work in linear time in the worst\r\ncase, so you need to redefine the hash function to use them. You can\r\nread more about this issue here:\r\nhttps://codeforces.com/blog/entry/62393.\r\n",
    "hint": []
}