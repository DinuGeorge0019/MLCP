{
    "link": "https://codeforces.com//contest/2051/problem/G",
    "problemId": "3099580",
    "problem_idx": "G",
    "shortId": "2051G",
    "contest_number": "2051",
    "problem_submissions": {
        "G": [
            297891656,
            297890696,
            297899138,
            297892259,
            297912620,
            297920714,
            297934708,
            297929892,
            297931851,
            297911736,
            297927208,
            297928317,
            297947772,
            297909767,
            297942983,
            297993500,
            297875875,
            297873133,
            297875271
        ],
        "F": [
            297856552,
            297878644,
            297873030,
            297875253,
            297891474,
            297895628,
            297891515,
            297904684,
            297959623,
            297914765,
            297882921,
            297895179,
            297910575,
            297923862,
            297919187,
            297917128,
            297916364,
            297943956,
            297865687,
            297864877,
            297909911
        ],
        "E": [
            297841786,
            297836575,
            297839584,
            297846936,
            297869096,
            297865734,
            297862813,
            297854892,
            297860094,
            297876823,
            297874225,
            297892538,
            297862291,
            297876371,
            297877246,
            297922331,
            297840776,
            297834266,
            297852254,
            297850894
        ],
        "D": [
            297824998,
            297828255,
            297829120,
            297836876,
            297843401,
            297839448,
            297844425,
            297835789,
            297837071,
            297862412,
            297866230,
            297845487,
            297868513,
            297862250,
            297899798,
            297831894,
            297830585,
            297845610,
            297833477
        ],
        "C": [
            297817405,
            297821512,
            297822005,
            297826169,
            297828699,
            297832899,
            297832376,
            297822832,
            297823992,
            297849370,
            297841820,
            297834151,
            297857822,
            297848820,
            297891200,
            297825348,
            297827127,
            297840542,
            297824191
        ],
        "B": [
            297813648,
            297815534,
            297817642,
            297818888,
            297819929,
            297820049,
            297826062,
            297814904,
            297817786,
            297837190,
            297825933,
            297817655,
            297849719,
            297836185,
            297885765,
            297815546,
            297824155,
            297835551,
            297813164
        ],
        "A": [
            297812430,
            297812527,
            297814260,
            297815468,
            297814137,
            297814651,
            297817327,
            297812582,
            297812492,
            297830581,
            297819762,
            297812887,
            297821437,
            297881803,
            297812726,
            297821513,
            297830979,
            297812442
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137623",
    "editorial": "Note that when you place snakes on the strip in some order, they form\r\nsome permutation. And when you fix that permutation, you can place them\r\ngreedily.In other words, when you know in what order you\u00e2\u0080\u0099ll place\r\nsnakes, it\u00e2\u0080\u0099s always optimal to place them as close to each other as\r\npossible. Since the bigger the initial distance the bigger the resulting\r\ndistance of the farthest snake (or the bigger the final score). We can\r\neven calculate that final score precisely: it\u00e2\u0080\u0099s equal to .So, we can\r\nsolve the task in two steps. First, let\u00e2\u0080\u0099s calculate the minimum possible\r\ndistance between snakes and if we plan to place snake right after snake\r\n. Suppose the initial between these snakes is . Let\u00e2\u0080\u0099s skim through all\r\nevents: each time the -th snake enlarges, our gap decreases, or . each\r\ntime the -th snake shrinks, our gap increases, or . if at any moment\r\nbecomes negative, then we lose. In other words, we needed bigger initial\r\n. We can rephrase what happens more formally: for each event let if\r\nincreases, if decreases or otherwise. Then after the -th event the\r\ncurrent gap will be equal to .The following inequality should hold for\r\neach : or . So, if we will find the minimum then we can set the initial\r\ndistance to this minimum gap plus one, or .Now we know the minimum\r\ndistances between neighboring snakes, so we can find the optimal order.\r\nLet\u00e2\u0080\u0099s do it with bitmask dp , since all we need to know in each state is\r\nthe set of already placed snakes and the last snake . Transitions are\r\nstraightforward: let\u00e2\u0080\u0099s just choose the next snake to place and place it\r\nat distance .The initial states are for each . The answer is , i. e. we\r\njust choose the last snake.The time complexity is for the first part (or\r\nif written more optimally) plus for the second part.\r\n",
    "name": "G. Snakes",
    "statement": "Suppose you play a game where the game field looks like a strip of 1\r\ntimes 10^9 square cells, numbered from 1 to 10^9.You have n snakes\r\n(numbered from 1 to n) you need to place into some cells. Initially,\r\neach snake occupies exactly one cell, and you can\u2019t place more than one\r\nsnake into one cell. After that, the game starts.The game lasts for q\r\nseconds. There are two types of events that may happen each second:\r\nsnake s_i : if snake s_i occupied cells [l, r], it enlarges to a segment\r\n[l, r + 1]; snake s_i : if snake s_i occupied cells [l, r], it shrinks\r\nto a segment [l + 1, r]. Each second, exactly one of the events\r\nhappens.If at any moment of time, any snake runs into some obstacle\r\n(either another snake or the end of the strip), you lose. Otherwise, you\r\nwin with the score equal to the maximum cell occupied by any snake so\r\nfar.What is the minimum possible score you can achieve?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ll long longusing namespace std;\u00a0static const ll INF = LLONG_MAX / 2;\u00a0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\u00a0    int n, q;    cin >> n >> q;\u00a0    vector<vector<int>> e(n, vector<int>(q+1, 0));    vector<vector<int>> s(n, vector<int>(q+1, 0));\u00a0    for(int i = 0; i < n; i++){        for(int t = 1; t <= q; t++){            e[i][t] = e[i][t-1];            s[i][t] = s[i][t-1];        }    }\u00a0    for(int i = 0; i < n; i++){        for(int t = 0; t <= q; t++){            e[i][t] = 0;            s[i][t] = 0;        }    }\u00a0    vector<vector<int>> de(n, vector<int>(q+1,0));    vector<vector<int>> ds(n, vector<int>(q+1,0));\u00a0    for(int k = 1; k <= q; k++){        int si;        char c;        cin >> si >> c;        si -= 1;        if(c == '+'){            de[si][k] += 1;        } else {            ds[si][k] += 1;        }    }\u00a0    for(int i=0; i<n; i++){        for(int t=1; t<=q; t++){            e[i][t] = e[i][t-1] + de[i][t];            s[i][t] = s[i][t-1] + ds[i][t];        }    }\u00a0    vector<vector<ll>> cost(n, vector<ll>(n, 0LL));    for(int i = 0; i < n; i++){        for(int j = 0; j < n; j++){            if(i == j){                cost[i][j] = 0LL;                continue;            }            ll mx = LLONG_MIN;\u00a0            for(int t=0; t<=q; t++){                ll diff = (ll)e[i][t] - (ll)s[j][t];                if(diff > mx) mx = diff;            }            cost[i][j] = mx + 1LL;        }    }\u00a0    vector<ll> maxRight(n,0LL);    for(int i=0; i<n; i++){        ll mr = 0;        for(int t=0; t<=q; t++){            mr = max(mr, (ll)e[i][t]);        }        maxRight[i] = mr;    }\u00a0    static ll dpLeft[1<<20][20];    static ll dpAns[1<<20][20];    int fullMask = (1 << n) - 1;\u00a0    for(int mask=0; mask<(1<<n); mask++){        for(int i=0; i<n; i++){            dpLeft[mask][i] = INF;            dpAns[mask][i] = INF;        }    }\u00a0    for(int i=0; i<n; i++){        int m = (1<<i);        dpLeft[m][i] = 1LL;        dpAns[m][i] = 1LL + maxRight[i];    }\u00a0    for(int mask=0; mask<(1<<n); mask++){        for(int last=0; last<n; last++){            if( dpLeft[mask][last] == INF ) continue;\u00a0            ll curL = dpLeft[mask][last];            ll curM = dpAns[mask][last];\u00a0            int notUsed = (~mask) & fullMask;            while(notUsed){                int j = __builtin_ctz(notUsed);                notUsed ^= (1<<j);\u00a0                ll newLeft = curL + cost[last][j];                ll newMax = max( curM, newLeft + maxRight[j] );\u00a0                int newMask = mask | (1<<j);\u00a0                if( (newMax < dpAns[newMask][j]) ||                    (newMax == dpAns[newMask][j] && newLeft < dpLeft[newMask][j]) ){                    dpAns[newMask][j] = newMax;                    dpLeft[newMask][j]    = newLeft;                }            }        }    }\u00a0    ll ans = INF;\u00a0    for(int i=0; i<n; i++){        ans = min(ans, dpAns[fullMask][i]);    }\u00a0    cout << ans << \"\\n\";    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "dsu",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Snakes.json"
}