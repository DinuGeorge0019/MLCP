{
    "link": "https://codeforces.com//contest/1878/problem/F",
    "problemId": "2229487",
    "problem_idx": "F",
    "shortId": "1878F",
    "contest_number": "1878",
    "problem_submissions": {
        "G": [
            225357770,
            225356148,
            225378677,
            225396088,
            225913288,
            225913201,
            225920084,
            225806168
        ],
        "E": [
            225342729,
            225298379,
            225344738,
            225348985,
            225318623,
            225299675,
            225329860,
            225336305,
            225327357,
            225306213,
            225322089,
            225309942,
            225339644,
            225341224,
            225341243,
            225343329,
            225344211,
            225338004,
            225316088
        ],
        "D": [
            225335832,
            225341527,
            225309051,
            225331018,
            225323094,
            225338405,
            225319972,
            225330316,
            225308377,
            225329843,
            225347560,
            225344567,
            225325782,
            225334610,
            225324123,
            225325861,
            225322057,
            225328040,
            225346585
        ],
        "C": [
            225318388,
            225345357,
            225316589,
            225296717,
            225295479,
            225291873,
            225287260,
            225292130,
            225288945,
            225292627,
            225291194,
            225293331,
            225301422,
            225296957,
            225301805,
            225302804,
            225306798,
            225304842,
            225306017
        ],
        "F": [
            225309193,
            225371590,
            225359110,
            225363020,
            225336771,
            225356090,
            225361957,
            225350800,
            225360150,
            225370320,
            225377951,
            225387862,
            225369402,
            225367044,
            225368506,
            225373551,
            225374797,
            225379464,
            225370893
        ],
        "B": [
            225289378,
            225311939,
            225302167,
            225288412,
            225283039,
            225282551,
            225280252,
            225288368,
            225281781,
            225285957,
            225281577,
            225284558,
            225292958,
            225290446,
            225282910,
            225296220,
            225284347,
            225295270,
            225303310
        ],
        "A": [
            225283036,
            225276287,
            225280098,
            225277273,
            225274431,
            225277937,
            225274529,
            225279212,
            225276095,
            225274228,
            225275085,
            225274508,
            225280174,
            225280595,
            225275774,
            225283697,
            225275093,
            225278575,
            225275576
        ]
    },
    "name": "F. Vasilije Loves Number Theory",
    "statement": "Vasilije is a smart student and his discrete mathematics teacher Sonja\r\ntaught him number theory very well.He gave Ognjen a positive integer\r\nn.Denote d(n) as the number of positive integer divisors of n, and\r\ndenote gcd(a, b) as the largest integer g such that a is divisible by g\r\nand b is divisible by g.After that, he gave Ognjen q queries, and there\r\nare 2 types of queries. 1, x set n to n\r\ncdot x, and then answer the following question: does there exist a\r\npositive integer a such that gcd(a, n) = 1, and d(n\r\ncdot a) = n? 2 reset n to its initial value (before any queries). Note\r\nthat n get back to its initial value after the query.Since Ognjen is\r\nafraid of number theory, Vasilije promised him that , d(n)\r\nle 10^9, however, even with that constraint, he still needs your help\r\nwith this problem.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define ll long long\n#define ii pair<int,int>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \": \" << x << endl\n#define pub push_back\n#define pob pop_backac\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n,q;\nmap<int ,int >cnt;\nll tot,now;\nvoid calc(int x)\n{\n    for(int i=2;i*i<=x;++i)\n    {\n        while(x%i==0)\n        {\n            x/=i;\n            tot/=(cnt[i]+1);\n            cnt[i]++;\n            tot*=(cnt[i]+1);\n        }\n    }\n    if(x!=1)\n    {\n        tot/=(cnt[x]+1);\n        cnt[x]++;\n        tot*=(cnt[x]+1);\n    }\n}\nbool check(ll x)\n{\n    for(int i=2;i*i<=x;++i)\n    {\n        int c=0;\n        while(x%i==0)   x/=i,c++;\n        if(cnt[i]<c)    return false;\n    }\n    if(x!=1&&cnt[x]<1)  return false;\n    return true;\n}\nvoid solve()\n{\n    n=read();   q=read();\n    cnt.clear();    tot=1;  //now=n;\n    calc(n);\n    while(q--)\n    {\n        int opt=read();\n        if(opt==1)\n        {\n            int x=read();\n            calc(x);   now*=x;\n            if(check(tot))    puts(\"YES\");\n            else    puts(\"NO\");\n        }\n        else\n        {\n            cnt.clear();    tot=1;  //now=n;\n            calc(n);\n        }\n    }\n}\nint main()\n{\n    T=read();\n    while(T--)  solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math",
        "number theory"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Vasilije Loves Number Theory.json",
    "editorial_link": "https://codeforces.com//blog/entry/120813",
    "editorial": "Answer: a solution exists divides .Proof: consider the prime\r\nfactorization of the number , where represents the -th prime number, and\r\nrepresents the highest power of the -th prime number such that divides .\r\nKnowing this we can calculate the number of divisors of with the\r\nfollowing formula: .Letâs now consider the operations we are performing.\r\nWe are multiplying the number by a number that has no common prime\r\nfactors with (condition ).Multiplying by any integer will only bring new\r\nprime factors to , which means that we can not change what is already in\r\nthe brackets of the formula for the number of divisors , but we can add\r\nnew brackets. Therefore, will always be a divisor of the number . So, we\r\ncan write . In order to achieve , we must also have . Therefore, it is\r\nnecessary for to be a divisor of . Letâs show that this is also\r\nsufficient. Letâs denote . Choose any prime number that is not a factor\r\nof (such a prime exists because there are infinitely many prime numbers,\r\nwhile has a finite number of prime factors). By multiplying by , we\r\nobtain .Using this fact, we just need to efficiently check whether\r\ndivides after each type 1 query. How do we do this?First we\r\npre-calculate for each positive integer less than its smallest prime\r\nfactor. This allows us to factorize all numbers smaller than or equal to\r\nin logarithmic time. We also factorize and find its number of divisors\r\nusing the formula mentioned above, and store for each prime factor its\r\nhighest power which still divides . We can do this using an array, or\r\nusing a map, either way, letâs call this structure .Now we need to deal\r\nwith the queries:For type 2 query we just need to reset everything.For\r\nthe first query, we factorize in operations and let be the factorization\r\nof the number . We update the by doing the following: for each prime in\r\n, divide by , then add to , and then multiply by . After we calculate ,\r\nwe should check if is divisible by it. We can do this in 2 ways:Solution\r\n1:We do this by multiplying the value of all previous type queries\r\n(after the last type query), and the value of the starting by modulo ,\r\nbecause can get really large, and we canât store it in a 64-bit integer.\r\nIf the value mod is , then its divisible and the answer to our query is\r\n\"\", else it is \"\".Time complexity .Solution 2:This solution is even\r\nfaster, but it might be harder to implement, and thatâs why we didnât\r\nmake it necessary.Instead of storing queries, we just need to use\r\nanother map to store the prime divisors of , now we can compare each\r\nprime divisor and its power for and for the product of and all queries\r\nafter the last reset. Now for each prime in , the power of that prime\r\nhas to be smaller or equal to than the power of that prime in the\r\nproduct of and queries. Since , the map for will have at most entries,\r\nso this solution runs in .\r\n",
    "hint": [
        "Hint 1 What does the condition allow us to do?",
        "Hint 2 How does any allowed operation affect ?",
        "Hint 3 Try to prove that the answer is \"YES\" if divides .",
        "Hint 4 Try to prove that the answer is \"NO\" otherwise.",
        "Hint 5 How can you find and maintain the number of divisors quickly?",
        "Hint 6 To make the implementation easier, try using the condition ."
    ]
}