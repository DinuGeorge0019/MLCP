{
    "link": "https://codeforces.com//contest/1955/problem/H",
    "problemId": "2579460",
    "problem_idx": "H",
    "shortId": "1955H",
    "contest_number": "1955",
    "problem_submissions": {
        "G": [
            255700432,
            255685371,
            255700202,
            255694984,
            255713116,
            255710945,
            255815483,
            255720205,
            255712913,
            255719635,
            255740112,
            255735779,
            255734648,
            255728080,
            255811582,
            255740083,
            255712654,
            255816753,
            255730101,
            255733676,
            255729429,
            255749883
        ],
        "F": [
            255690836,
            255730118,
            255712738,
            255723348,
            255696813,
            255721239,
            255711672,
            255703746,
            255701885,
            255718873,
            255724659,
            255733290,
            255718852,
            255723723,
            255725364,
            255717728,
            255710197,
            255736254,
            255712457
        ],
        "E": [
            255679602,
            255678850,
            255660817,
            255677164,
            255677495,
            255695083,
            255692381,
            255695668,
            255688219,
            255691378,
            255687451,
            255688784,
            255697004,
            255707937,
            255738844,
            255740248,
            255706468,
            255704684,
            255707886
        ],
        "D": [
            255663451,
            255667353,
            255685203,
            255671122,
            255669296,
            255675907,
            255680787,
            255676580,
            255675808,
            255675309,
            255677471,
            255667366,
            255685779,
            255681400,
            255682629,
            255685354,
            255677101,
            255696157,
            255690888
        ],
        "C": [
            255657238,
            255660807,
            255678901,
            255663623,
            255662171,
            255657175,
            255664052,
            255666604,
            255666050,
            255656375,
            255666921,
            255652774,
            255678671,
            255660970,
            255664282,
            255661069,
            255666029,
            255658918,
            255678375
        ],
        "B": [
            255642714,
            255647145,
            255662403,
            255652531,
            255651120,
            255650530,
            255651554,
            255653536,
            255651004,
            255648291,
            255648566,
            255643999,
            255648718,
            255649499,
            255650291,
            255653938,
            255647027,
            255650471,
            255659271
        ],
        "A": [
            255635163,
            255633427,
            255637795,
            255633451,
            255634276,
            255634783,
            255634704,
            255650196,
            255634135,
            255635088,
            255633579,
            255633389,
            255637393,
            255636215,
            255633812,
            255642645,
            255634779,
            255634460,
            255639283
        ],
        "H": [
            255690981,
            255842703,
            255840768
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128243",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem for a single tower. The tower\u00e2\u0080\u0099s area of effect\r\nis a circle, so the theoretically possible number of cells in which a\r\ntower with radius will deal damage is . In total, the tower will deal\r\ndamage to the enemy. At the same time, the initial health of the enemy\r\nwill be increased by , so in fact, this health increase needs to be\r\nsubtracted from the tower\u00e2\u0080\u0099s damage. Thus, the maximum radius for the\r\ntower can be found from the inequality , assuming that the tower has a\r\ndamage of . This estimate gives , above which the enemy\u00e2\u0080\u0099s health\r\nincrease is too large for the tower to overcome.So, there are not so\r\nmany radii, and each radius can be applied to no more than one tower. We\r\nwill use the subset dynamic programming method: the maximum damage that\r\nthe first towers will deal with the optimal distribution of the radii in\r\nthe . The transitions are quite simple: . The answer will be the maximum\r\nvalue . this is the number of cells covered by the -th tower when the\r\nradius is set to . It can be calculated for one tower and for one radius\r\nin time, just iterate through the square with a side length of and a\r\ncenter coinciding with the location of the tower. In total, the\r\nprecalculation of for all towers and all radii will take time. The\r\ncomplexity of calculating the dynamic programming values is , so the\r\nfinal complexity of the solution is .\r\n",
    "name": "H. The Most Reckless Defense",
    "statement": "You are playing a very popular Tower Defense game called \"Runnerfield\r\n2\". In this game, the player sets up defensive towers that attack\r\nenemies moving from a certain starting point to the player\u2019s base.You\r\nare given a grid of size n\r\ntimes m, on which k towers are already placed and a path is laid out\r\nthrough which enemies will move. The cell at the intersection of the\r\nx-th row and the y-th column is denoted as (x, y).Each second, a tower\r\ndeals p_i units of damage to all enemies within its range. For example,\r\nif an enemy is located at cell (x, y) and a tower is at (x_i, y_i) with\r\na range of r, then the enemy will take damage of p_i if (x - x_i) ^ 2 +\r\n(y - y_i) ^ 2\r\nle r ^ 2.Enemies move from cell (1, 1) to cell (n, m), visiting each\r\ncell of the path exactly once. An enemy instantly moves to an adjacent\r\ncell horizontally or vertically, but before doing so, it spends one\r\nsecond in the current cell. If its health becomes zero or less during\r\nthis second, the enemy can no longer move. The player loses if an enemy\r\nreaches cell (n, m) and can make one more move.By default, all towers\r\nhave a zero range, but the player can set a tower\u2019s range to an integer\r\nr (r > 0), in which case the health of all enemies will increase by 3^r.\r\nHowever, each r can only be used for tower.Suppose an enemy has a base\r\nhealth of h units. If the tower ranges are 2, 4, and 5, then the enemy\u2019s\r\nhealth at the start of the path will be h + 3 ^ 2 + 3 ^ 4 + 3 ^ 5 = h +\r\n9 + 81 + 243 = h + 333. The choice of ranges is made once before the\r\nappearance of enemies and cannot be changed after the game starts.Find\r\nthe maximum amount of base health h for which it is possible to set the\r\nranges so that the player does not lose when an enemy with health h\r\npasses through (without considering the additions for tower ranges).\r\n",
    "solutions": [
        "#include<set>#include<map>#include<list>#include<cmath>#include<queue>#include<stack>#include<deque>#include<vector>#include<random>#include<string>#include<cstdio>#include<bitset>#include<cassert>#include<cstring>#include<cstdlib>#include<numeric>#include<iomanip>#include<iostream>#include<algorithm>#include<functional>#include<unordered_map>\u00a0\u00a0#define endl \"\\n\"#define ll long long#define int llusing namespace std;const int mod = 998244353;const int maxn = 5e5 + 7;\u00a0int r3[11];\u00a0void solve() {    int n, m, k;    cin >> n >> m >> k;    vector<string> s(n);    for (int i = 0; i < n; i++)cin >> s[i];    vector<vector<int>> damage(k, vector<int>(10, 0));\u00a0    for (int t = 0; t < k; t++) {        int x, y, p;        cin >> x >> y >> p;        x--, y--;        for (int r = 1; r < 11; r++) {            for (int i = 0; i < n; i++) {                for (int j = 0; j < m; j++) {                    if (s[i][j] == '#' && (x - i) * (x - i) + (y - j) * (y - j) <= r * r) {                        damage[t][r - 1] += p;                    }                }            }            damage[t][r - 1] -= r3[r];        }\u00a0\u00a0    }\u00a0    vector<int> f(1 << 10);    for (int i = 0; i < k; i++) {        auto g = f;        for (int st = 0; st < (1 << 10); st++) {            for (int j = 0; j < 10; j++) {                if (st >> j & 1) {                    g[st] = max(g[st], f[st ^ (1 << j)] + damage[i][j]);                }            }        }        swap(g, f);    }\u00a0    std::cout << *max_element(f.begin(), f.end()) << endl;}\u00a0signed main() {    std::ios::sync_with_stdio(false), cin.tie(0);    r3[0] = 1;    for (int i = 1; i <= 10; i++) r3[i] = r3[i - 1] * 3;    int t;    cin >> t;    while (t--)solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dp",
        "flows",
        "graph matchings",
        "shortest paths"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\H. The Most Reckless Defense.json"
}