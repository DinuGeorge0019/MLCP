{
    "link": "https://codeforces.com//contest/1029/problem/A",
    "problemId": "211256",
    "problem_idx": "A",
    "shortId": "1029A",
    "contest_number": "1029",
    "problem_submissions": {
        "F": [
            42047829,
            42034824,
            42039218,
            42045140,
            42050850,
            42057641,
            42355180,
            42049291,
            42049170,
            42057320,
            42157687,
            42044089,
            42546658,
            42048831,
            42049225,
            42048355,
            42061045,
            42061015
        ],
        "E": [
            42043766,
            42041583,
            42051097,
            42052718,
            42057627,
            42056052,
            42145593,
            42070440,
            42053184,
            42057293
        ],
        "D": [
            42037124,
            55325923,
            42076677,
            42050558,
            42365691,
            42365676,
            42365497,
            42365477,
            42365258,
            42365242,
            42365230,
            42365081,
            42364971,
            42364957,
            42364791,
            42356686,
            42356662,
            42356121,
            42356098,
            42356090,
            42356074,
            42355955,
            42355933,
            42355895,
            42355839,
            42355815,
            42355732,
            42355678,
            42042982,
            42045076,
            42143765,
            42043950,
            42072305,
            42083814,
            42075124,
            42052333,
            42052607,
            42052955
        ],
        "B": [
            42031994,
            42043199,
            42035507,
            42029721,
            42032248,
            42032998,
            42057919,
            42057314,
            42036457,
            42033868,
            42032775,
            42032090,
            42031079,
            42035681,
            42032483,
            42034211,
            53975070,
            42033101,
            42031960,
            42034275,
            42035033,
            42032988
        ],
        "A": [
            42030943,
            42032428,
            42030337,
            42031598,
            42030794,
            42031593,
            42030225,
            42057135,
            42032959,
            42032163,
            42030490,
            42030591,
            42029747,
            42032386,
            42029916,
            42032324,
            42075267,
            42030907,
            42030283,
            42032164,
            42032054,
            42031161
        ],
        "C": [
            42049735,
            42046367,
            42031881,
            42035737,
            42041787,
            42040163,
            42049039,
            42037198,
            42037422,
            42033541,
            42040258,
            42044533,
            42039967,
            42042410,
            42036447,
            42044633,
            42041967,
            42040799
        ]
    },
    "name": "A. Many Equal Substrings",
    "statement": "You are given a string t consisting of n lowercase Latin letters and an\r\ninteger number k.Let’s define a substring of some string s with indices\r\nfrom l to r as s[l\r\ndots r].Your task is to construct such string s of minimum possible\r\nlength that there are exactly k positions i such that s[i\r\ndots i + n - 1] = t. In other words, your task is to construct such\r\nstring s of minimum possible length that there are exactly k substrings\r\nof s equal to t.It is guaranteed that the answer is always unique.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n\n\nint n,k;\n\nstring t;\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n >> k >> t;\n    int mx=0;\n    for(int i=1;i<n;i++){\n        int gd=1;\n        for(int j=0;j<i;j++){\n            if(t[j]!=t[n-i+j]) gd=0;\n        }\n        if(gd) mx=i;\n    }\n    cout << t;\n    for(int i=2;i<=k;i++){\n        for(int j=mx;j<n;j++) cout << t[j];\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\A. Many Equal Substrings.json",
    "editorial_link": "https://codeforces.com/blog/entry/61439",
    "editorial": "Letâs carry the current answer as , the last position weâre checked as\r\nand the number of occurrences as . Initially, the answer is , is and is\r\n(0-indexed). We donât need to check the position because there is the\r\nbeginning of the occurrence of at this position. Also is by the same\r\nreason. Letâs repeat the following algorithm while : if , where |ans| is\r\nthe length of the answer, letâs add to the answer, increase and by . In\r\nthe other case letâs check if there is a prefix of starting from . If it\r\nis, let be its length. Then we need to add the suffix of starting from\r\ntill the end of , increase and by . If there is no prefix of starting\r\nfrom the we just increase .The other idea is the following: we have to\r\nfind the period of the string . Let this period will be . Then the\r\nanswer is repeated times and . The period of the string is the minimum\r\nprefix of this string such that we can repeat this prefix infinite\r\nnumber of times so the prefix of this infinite string will be . For\r\nexample, the period of the string is , the period of the string is and\r\nthe period of the string is . The period of the string can be found\r\nusing prefix-function of the string or in naively.\r\n",
    "hint": []
}