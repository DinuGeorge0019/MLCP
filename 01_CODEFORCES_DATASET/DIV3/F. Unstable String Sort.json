{"link": "https://codeforces.com//contest/1213/problem/F", "problemId": "399405", "problem_idx": "F", "shortId": "1213F", "contest_number": "1213", "problem_submissions": {"F": [59744893, 59749834, 59752078, 59758038, 59760843, 59749304, 59755658, 59753555, 59746277, 59750645, 61343687, 61343661, 61343648, 61343618, 61343520, 61343278, 60634386, 59775323, 59750244, 61204533, 59752892, 59797507], "E": [59737696, 59743919, 59747577, 59744833, 59735288, 59758317, 59737942, 59763722, 59753071, 59747085, 60634367, 59747957, 59750137, 59754792, 59753767, 59755311], "G": [59727157, 59735316, 59735384, 59743644, 59742824, 59749657, 59742214, 59747653, 59735778, 59738294, 59735722, 59736569, 59754233, 60634412, 59737158, 59744394, 59749114, 59742323, 59744002, 59732055, 59770392, 59747210], "D1": [59722102, 59719494, 59727128, 59722171, 59736098, 59727619, 59727732, 59725611, 59727388, 59733062, 59729604, 59727297, 59726052, 60634351, 59721705, 59730365, 59732883, 59727664, 59731108, 59737247, 59732784], "D2": [59721760, 59722747, 59727674, 59722359, 59721508, 59736468, 59731787, 59743643, 59725289, 59727512, 59732689, 59729260, 59727002, 59732076, 60634360, 59721352, 59736832, 59737287, 59732145, 59730871, 59737130, 59732397], "C": [59718793, 59715437, 59720057, 59718496, 59726783, 59722688, 59718368, 59722836, 59719661, 59725890, 59722169, 59721614, 60634346, 59736818, 59724098, 59724288, 59727369, 59723746, 59726630, 59726972], "B": [59712460, 59711849, 59713537, 59713547, 59714412, 59717212, 59714229, 59714299, 59715293, 59714606, 59715624, 59714068, 60634341, 59718378, 59714795, 59717101, 59713372, 59717314, 59722177, 59715750], "A": [59710837, 59710763, 59711301, 59711479, 59712215, 59715335, 59710947, 59711797, 59711527, 59711289, 59711355, 59710892, 60635322, 59713486, 59711520, 59711772, 59719126, 59712741, 59713602, 59712425]}, "name": "F. Unstable String Sort", "statement": "Authors have come up with the string s consisting of n lowercase Latin\r\nletters.You are given two permutations of its indices (not necessary\r\nequal) p and q (both of length n). Recall that the permutation is the\r\narray of length n which contains each integer from 1 to n exactly\r\nonce.For all i from 1 to n-1 the following properties hold: s[p_i]\r\nle s[p_{i + 1}] and s[q_i]\r\nle s[q_{i + 1}]. It means that if you will write down all characters of\r\ns in order of permutation indices, the resulting string will be sorted\r\nin the non-decreasing order.Your task is to restore such string s of\r\nlength n consisting of which suits the given permutations.If there are\r\nmultiple answers, you can print any of them.\r\n", "solutions": ["#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define endl '\\n'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint p[N], q[N], idx[N];\n\nint dsu[N], rmax[N];\n\nint root(int u) {\n    return ((u == dsu[u]) ? u : dsu[u] = root(dsu[u]));\n}\n\nvoid uni(int u,int v) {\n    u = root(u), v = root(v);\n    if(u == v) return;\n    dsu[v] = u;\n}\n\nvoid connect(int i1,int i2) {\n    while(i2 > i1) {\n        uni(i2 - 1, i2);\n        i2 = dsu[i2];\n    }\n}\n\nchar val[N], ans[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(\"inp.txt\", \"r\", stdin);\n        freopen(\"out.txt\", \"w\", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n, k;\n    cin >> n >> k;\n    fr(i, 1, n) {\n        dsu[i] = i;\n    }\n    fr(i, 1, n) {\n        cin >> p[i];\n        idx[p[i]] = i;\n    }\n    fr(i, 1, n) {\n        cin >> q[i];\n    }\n    fr(i, 1, n - 1) {\n        int i1 = idx[q[i]], i2 = idx[q[i + 1]];\n        if(i2 < i1) {\n            connect(i2, i1);\n        }\n    }\n    int c = 0;\n    char ch = 'a';\n    fr(i ,1, n) {\n        if(dsu[i] == i) {\n            c++;\n            val[i] = ch;\n            if(ch < 'z') ch++;\n        }\n    }\n    if(c < k) {\n        cout << \"NO\";\n        return 0;\n    }\n    fr(i, 1, n) {\n        ans[p[i]] = val[root(i)];\n    }\n    cout << \"YES\" << endl;\n    fr(i, 1, n) {\n        cout << ans[i];\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dsu", "graphs", "greedy", "implementation", "strings"], "dificulty": "2100", "interactive": false}