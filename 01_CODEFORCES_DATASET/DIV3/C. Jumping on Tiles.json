{
    "link": "https://codeforces.com//contest/1729/problem/C",
    "problemId": "1538784",
    "problem_idx": "C",
    "shortId": "1729C",
    "contest_number": "1729",
    "problem_submissions": {
        "G": [
            171909059,
            171928158,
            171929650,
            171937957,
            171943890,
            171891847,
            177449161,
            177445327,
            172241447,
            172480345
        ],
        "F": [
            171894944,
            171892697,
            171881447,
            171902682,
            171920680,
            171910535,
            171878146,
            171906331,
            171923271,
            171910232,
            171914792,
            171908912,
            171906528,
            171914845,
            171906947,
            171906893,
            171920671,
            171915782,
            171919661
        ],
        "E": [
            171877179,
            171875756,
            171902704,
            171910299,
            171904162,
            171875139,
            171920658,
            171889898,
            171889626,
            171887188,
            171887680,
            171887875,
            171890844,
            171886351,
            171876648,
            171892405,
            171885680
        ],
        "D": [
            171861022,
            171860553,
            171863068,
            171871491,
            171878349,
            171858368,
            171848378,
            171874244,
            171864332,
            171876318,
            171869512,
            171878854,
            171871746,
            171875870,
            171867532,
            171863495,
            171872346,
            171873328
        ],
        "C": [
            171852852,
            171855742,
            171858347,
            171863945,
            171872549,
            171852373,
            171871529,
            171858052,
            171858976,
            171859379,
            171861408,
            171866242,
            171860889,
            171865107,
            171859758,
            171855447,
            171858502,
            171863966
        ],
        "B": [
            171845132,
            171847312,
            171845642,
            171852489,
            171856806,
            171841700,
            171849120,
            171848235,
            171844034,
            171844485,
            171847383,
            171849511,
            171849845,
            171851995,
            171846552,
            171848340,
            171844748,
            171850134
        ],
        "A": [
            171834897,
            171837470,
            171836390,
            171836406,
            171845837,
            171834988,
            171835540,
            171837958,
            171836211,
            171834933,
            171836834,
            171836016,
            171838691,
            171835898,
            171835047,
            171838527,
            171834668,
            171838404
        ]
    },
    "name": "C. Jumping on Tiles",
    "statement": "Polycarp was given a row of tiles. Each tile contains one lowercase\r\nletter of the Latin alphabet. The entire sequence of tiles forms the\r\nstring s.In other words, you are given a string s consisting of\r\nlowercase Latin letters.Initially, Polycarp is on the tile of the row\r\nand wants to get to the tile by jumping on the tiles. Jumping from i-th\r\ntile to j-th tile has a cost equal to |index(s_i) - index(s_j)|, where\r\nindex(c) is the index of the letter c in the alphabet (for example,\r\nindex(\u201d)=1, index(\u201d)=2, ..., index(\u201d)=26) .Polycarp wants to get to the\r\nn-th tile for the minimum total cost, but at the same time make number\r\nof jumps.In other words, among all possible ways to get to the last tile\r\nfor the total cost, he will choose the one with the number of\r\njumps.Polycarp can visit each tile .Polycarp asks you to help print the\r\nsequence of indices of string s on which he should jump.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl '\\n'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid deb() {cerr << \"\\n\";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n    vvi g(26);\n\n    rep(i,0,n)\n    {\n        g[s[i] - 'a'].pb(i);\n    }\n\n\n    cout << abs(s[0] - s.back()) << ' ';\n\n    vi res;\n\n    if(s[0] < s.back())\n    {\n        fr(i, s[0] - 'a', s.back() - 'a')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    else\n    {\n        frev(i, s.back() - 'a', s[0] - 'a')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    \n    \n    cout << sz(res) << endl;\n\n    trav(x, res)\n    {\n        cout << x + 1 << ' ';\n    }\n\n    cout << endl;\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Jumping on Tiles.json",
    "editorial_link": "https://codeforces.com//blog/entry/106916",
    "editorial": "It\u00e2\u0080\u0099s worth knowing that ways like (\u00e2\u0080\u009d -> \u00e2\u0080\u009d) and (\u00e2\u0080\u009d -> \u00e2\u0080\u009d -> \u00e2\u0080\u009d) have the\r\nsame cost. That is, first you need to understand the letter on the first\r\ntile and the last one (conditionally, the letters and ).Then you just\r\nneed to find all such tiles on which the letters are between the letters\r\nand inclusive.We go through each letter from to and for each letter we\r\nvisit every tile that has a given letter (but we must not forget to\r\nstart exactly at tile and end at tile ).\r\n"
}