{
    "link": "https://codeforces.com//contest/1660/problem/F2",
    "problemId": "1349761",
    "problem_idx": "F2",
    "shortId": "1660F2",
    "contest_number": "1660",
    "problem_submissions": {
        "F1": [
            151547102,
            151550004,
            151556961,
            151561107,
            152978236,
            151550675,
            151561323,
            151596179,
            151595243,
            151575027,
            151566711,
            151559623,
            151557836,
            151517033,
            151568295,
            151559969,
            151568720,
            151557907,
            151582251,
            151579930,
            151557285,
            151574893,
            151574565,
            151562629
        ],
        "F2": [
            151547014,
            151546872,
            151557177,
            151562642,
            151572516,
            151564512,
            151576252,
            151573626,
            151582683,
            151534999,
            151575687,
            151571693,
            151586409,
            151576536,
            151582511,
            151579993,
            151572690,
            151574663,
            151588223,
            151592536,
            151592473
        ],
        "D": [
            151536977,
            151531465,
            151548742,
            151544876,
            151565576,
            151552307,
            151540121,
            151546219,
            151566389,
            151546387,
            151551910,
            151560561,
            151552594,
            151547123,
            151585775,
            151548480,
            151568426,
            151565752,
            151535411
        ],
        "E": [
            151525872,
            151545578,
            151554108,
            151554403,
            151545248,
            151556608,
            151552575,
            151530576,
            151571474,
            151558277,
            151578411,
            151541773,
            151585933,
            151577061,
            151547981,
            151551718,
            151578968,
            151569807,
            151537268
        ],
        "C": [
            151521399,
            151518644,
            151534007,
            151531901,
            152978204,
            151528259,
            151524137,
            151544564,
            151553145,
            151553027,
            151553923,
            151606337,
            151534920,
            151528160,
            151532624,
            151527489,
            151538904,
            151547071,
            151543618,
            151548209,
            151522441
        ],
        "B": [
            151518226,
            151511243,
            151513483,
            151524120,
            151516768,
            151514262,
            151517162,
            151521061,
            151542405,
            151521485,
            151521685,
            151517284,
            151514144,
            151516159,
            151521136,
            151521193,
            151528983,
            151527060,
            151511556
        ],
        "A": [
            151508580,
            151507746,
            151508237,
            151517215,
            151507971,
            151508603,
            152300737,
            151508040,
            151508134,
            151537652,
            151507999,
            151510953,
            151511142,
            151509365,
            151510995,
            151509112,
            151523384,
            151509588,
            151513758,
            151515112
        ]
    },
    "name": "F2. Promising String  hard version ",
    "statement": "We will call a non-empty string if it contains the same number of plus\r\nand minus signs. For example: strings \"\" and \"\" are balanced, and\r\nstrings \"\", \"\" and \"\" are not balanced.We will call a string if the\r\nstring can be made balanced by several (possibly zero) uses of the\r\nfollowing operation: replace two minus signs with one plus sign. In\r\nparticular, every balanced string is promising. However, the converse is\r\nnot true: not every promising string is balanced.For example, the string\r\n\"\" is promising, because you can replace two adjacent minuses with plus\r\nand get a balanced string \"\", or get another balanced string \"\".How many\r\nnon-empty substrings of the given string s are promising? Each non-empty\r\npromising substring must be counted in the answer as many times as it\r\noccurs in string s.Recall that a substring is a sequence of consecutive\r\ncharacters of the string. For example, for string \"\" its substring are:\r\n\"\", \"\", \"\", \"\" (the string is a substring of itself) and some others.\r\nBut the following strings are not its substring: \"\", \"\", \"\".\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/detail/standard_policies.hpp>\n\n#define pb push_back\n#define int long long\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define ld long double\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef tree<\n    pair<int, int>,\n    null_type,\n    less<pair<int, int>>,\n    rb_tree_tag,\n    tree_order_statistics_node_update>\n    ordered_set;\n\nint f(vector<int> a) {\n  reverse(all(a));\n  int s = 0;\n  ordered_set kek;\n  for (int i = 0; i < (int) a.size(); i++) {\n    int x = a[i];\n    s += kek.order_of_key({x + 1, -1});\n    kek.insert({x, i});\n  }\n  return s;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector<int> p = {0};\n  for (auto c : s) {\n    if (c == '-') {\n      p.pb(p.back() - 1);\n    } else {\n      p.pb(p.back() + 1);\n    }\n  }\n  vector<vector<int>> ps(3);\n  for (auto x : p) {\n    ps[(3 * n - x) % 3].pb(x);\n  }\n  int ans = 0;\n  for (int i = 0; i < 3; i++) {\n    ans += f(ps[i]);\n  }\n  cout << ans << '\\n';\n}\n\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F2. Promising String  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/101526",
    "editorial": "Now we need to quickly find for a given balance value (on the prefix),\r\nthe number of matching left boundaries. The boundary is suitable if the\r\nbalance on the boundary is comparable modulo to the current balance and\r\nthe current balance is less than the balance on the boundary, since we\r\nneed the balance on the segment to be non-positive. That is, we need to\r\nbe able to find a number of numbers for each value of the balance that\r\nis not less than ours. This can be done either by data structure, or\r\nnotice that the balance takes only different values, then you can find\r\nthe number of numbers not less on the prefix for .\r\n"
}