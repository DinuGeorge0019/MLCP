{
    "link": "https://codeforces.com//contest/1579/problem/F",
    "problemId": "1123872",
    "problem_idx": "F",
    "shortId": "1579F",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "F. Array Stabilization  AND version ",
    "statement": "You are given an array a[0\r\nldots n - 1] = [a_0, a_1,\r\nldots, a_{n - 1}] of zeroes and ones only. Note that in this problem,\r\nunlike the others, the array indexes are numbered from zero, not from\r\none.In one step, the array a is replaced by another array of length n\r\naccording to the following rules: First, a new array a^{\r\nrightarrow d} is defined as a cyclic shift of the array a to the right\r\nby d cells. The elements of this array can be defined as a^{\r\nrightarrow d}_i = a_{(i + n - d)\r\nbmod n}, where (i + n - d)\r\nbmod n is the remainder of integer division of i + n - d by n. It means\r\nthat the whole array a^{\r\nrightarrow d} can be represented as a sequence a^{\r\nrightarrow d} = [a_{n - d}, a_{n - d + 1},\r\nldots, a_{n - 1}, a_0, a_1,\r\nldots, a_{n - d - 1}] Then each element of the array a_i is replaced by\r\na_i\r\n,\r\n&\r\n, a^{\r\nrightarrow d}_i, where\r\n& is a logical \"AND\" operator. For example, if a = [0, 0, 1, 1] and d =\r\n1, then a^{\r\nrightarrow d} = [1, 0, 0, 1] and the value of a after the first step\r\nwill be [0\r\n,\r\n&\r\n, 1, 0\r\n,\r\n&\r\n, 0, 1\r\n,\r\n&\r\n, 0, 1\r\n,\r\n&\r\n, 1], that is [0, 0, 0, 1].The process ends when the array stops\r\nchanging. For a given array a, determine whether it will consist of only\r\nzeros at the end of the process. If yes, also find the number of steps\r\nthe process will take before it finishes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[1000005],n,d,g,c[1000005];\nvector <int> cyc[1000005];\n\nvoid dfs(int x) {\n    c[x] = 1;\n    cyc[g].pb(x);\n    if(!c[(x+d-1)%n+1]) dfs((x+d-1)%n+1);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n >> d;\n        g = 0;\n        for(int i = 1;i <= n;i++) cin >> a[i], c[i] = 0, cyc[i].clear();\n        for(int i = 1;i <= n;i++) {\n            if(!c[i]) {\n                ++g;\n                dfs(i);\n            }\n        }\n        int no = 0,ans = 0;\n        for(int i = 1;i <= g;i++) {\n            int nope = 0;\n            for(int j : cyc[i]) {\n                if(!a[j]) nope = 1;\n            }\n            if(!nope) {no = 1; break;}\n            int st;\n            for(int j = 0;j < cyc[i].size();j++) {\n                if(!a[cyc[i][j]]) {\n                    st = j;\n                    break;\n                }\n            }\n            int row = 0;\n            for(int j = st+1;j < cyc[i].size();j++) {\n                row++;\n                if(!a[cyc[i][j]]) row = 0;\n                else ans = max(ans,row);\n            }\n            for(int j = 0;j < st;j++) {\n                row++;\n                if(!a[cyc[i][j]]) row = 0;\n                else ans = max(ans,row);\n            }\n        }\n        if(no) {\n            cout << \"-1\\n\";\n            continue;\n        }\n        cout << ans << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "graphs",
        "math",
        "number theory",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Array Stabilization  AND version .json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "We\u00e2\u0080\u0099ll consider an arbitrary index of the array and see what changes\r\nhappen to during several steps of the described algorithm. Let\u00e2\u0080\u0099s denote\r\nby the value of the array after steps of the algorithm and prove by\r\ninduction that is the logical \"AND\" of elements of the array , starting\r\nfrom with step to the left, that is Base of induction: for the element\r\nof the original array is . For clarity we can also show that the\r\nstatement is true for : during the first step is replaced by by the\r\ndefinition of cyclic shift by to the right.For simplicity, we will omit\r\nthe \"\" operation in the following formulas but will keep it in mind\r\nimplicitly. That is, will imply .Induction step: let the above statement\r\nbe true for , let us prove it for . By the definition of cyclic shift .\r\nAnd by the induction assumption, these two numbers are equal to Since\r\nthe logical \"AND\" is an idempotent operation, that is, it does not\r\nchange its result when repeatedly applied to any argument, then that is\r\nequal to their logical \"AND\" is also equal to which is what we wanted to\r\nprove.It follows from this formula that turns to zero after the -th step\r\nif and only if , , ..., , and . Up to the -th step all elements will be\r\nequal to , and so their logical \"AND\" will also be equal to . As soon as\r\nappears in the sequence in question, the logical \"AND\" will also become\r\nzero. Thus, we reduced the problem to finding the maximal block of\r\nelements equal to of the pattern . Note that by shifts of the array\r\nsplits into cyclic sequences of this kind, each of length . Let\u00e2\u0080\u0099s look\r\nat these cyclic sequences independently from each other and iterate over\r\neach of them in linear time complexity to find the maximal block of\r\nconsecutive elements equal to this will be the answer to the\r\nproblem.Remember to check that if at least one of these sequences\r\nconsists entirely of elements equal to , its elements will never zero\r\nout, and the answer in such case is .The time complexity is .\r\n"
}