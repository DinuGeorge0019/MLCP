{
    "link": "https://codeforces.com//contest/2000/problem/G",
    "problemId": "2814033",
    "problem_idx": "G",
    "shortId": "2000G",
    "contest_number": "2000",
    "problem_submissions": {
        "H": [
            276260761,
            276254307,
            276338511,
            276338125,
            276287387,
            276274340,
            276297740,
            276283267,
            276239793
        ],
        "G": [
            276214295,
            276274205,
            276334839,
            276268681,
            276267752,
            276333913,
            276264214,
            276282487,
            276272917,
            276276698,
            276277916,
            276283043,
            276274434,
            276291075,
            276278976,
            276290903,
            276279110,
            276279777
        ],
        "F": [
            276187296,
            276292316,
            276241660,
            276217578,
            276210913,
            276233999,
            276287795,
            276243858,
            276234274,
            276242694,
            276256602,
            276245569,
            276246137,
            276247924,
            276245207,
            276252538,
            276247124,
            276252754
        ],
        "E": [
            276164357,
            276333842,
            276186649,
            276185811,
            276179141,
            276203373,
            276182533,
            276188814,
            276185638,
            276210532,
            276225686,
            276198909,
            276209550,
            276178261,
            276202986,
            276227179,
            276202989,
            276229818,
            276227160
        ],
        "D": [
            276136722,
            276189642,
            276169653,
            276164982,
            276157636,
            276177807,
            276157222,
            276166197,
            276153213,
            276123696,
            276151555,
            276167672,
            276198896,
            276149967,
            276172892,
            276184459,
            276158053,
            276189336,
            276175071,
            276189558
        ],
        "C": [
            276127716,
            276172717,
            276135515,
            276132005,
            276139984,
            276155253,
            276134367,
            276142615,
            276142046,
            276180920,
            276133384,
            276141737,
            276151150,
            276139308,
            276147822,
            276167768,
            276145316,
            276158457,
            276159660,
            276137717
        ],
        "B": [
            276113898,
            276143388,
            276119169,
            276116606,
            276127808,
            276130717,
            276117856,
            276125745,
            276187672,
            276126451,
            276118391,
            276127646,
            276126167,
            276125801,
            276113780,
            276142176,
            276122501,
            276133620,
            276118200,
            276121342
        ],
        "A": [
            276110192,
            276136464,
            276111783,
            276110916,
            276119966,
            276120191,
            276111146,
            276116630,
            276117760,
            276111077,
            276112237,
            276116291,
            276115237,
            276115760,
            276110510,
            276123000,
            276110417,
            276117261,
            276112340,
            276130762
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132689",
    "editorial": "Letâs find the maximum time for each vertex, at which it is possible to\r\nleave from it and reach vertex at time . To find this value, we will run\r\nDijkstraâs algorithm from the last vertex.When processing the next edge,\r\nwe will check if it is possible to travel by bus during the time\r\ninterval from to . If it is possible, we will travel by bus; otherwise,\r\nwe will either walk or wait at this vertex and then go by bus.\r\n",
    "name": "G. Call During the Journey",
    "statement": "You live in a city consisting of n intersections and m streets\r\nconnecting some pairs of intersections. You can travel in either\r\ndirection on each street. No two streets connect the same pair of\r\nintersections, and no street connects an intersection to itself. You can\r\nreach any intersection from any other, possibly passing through some\r\nother intersections.Every minute, you can board a bus at intersection\r\nu_i and travel for l_{i1} minutes to intersection v_i. Conversely, you\r\ncan travel from intersection v_i to intersection u_i in l_{i1} minutes.\r\nYou can only board and exit the bus at intersections. You can only board\r\nthe bus at an intersection if you are currently there.You can also walk\r\nalong each street, which takes l_{i2} > l_{i1} minutes.You can make\r\nstops at intersections.You live at intersection number 1. Today you woke\r\nup at time 0, and you have an important event scheduled at intersection\r\nnumber n, which you must reach no later than time t_0. You also have a\r\nphone call planned that will last from t_1 to t_2 minutes (t_1 < t_2 <\r\nt_0). During the phone call, you cannot ride the bus, but you can walk\r\nalong any streets, make stops, or stay at home. You can exit the bus at\r\nminute t_1 and board the bus again at minute t_2.Since you want to get\r\nenough sleep, you became curious how late can you leave home to have\r\ntime to talk on the phone and still not be late for the event?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#include<array>using namespace std;#define ll long long#define int long long#define y1 idfsu#define PII pair<int, int>#define fi first#define se second#define endl \"\\n\"const int MAX = 1e9;const int MAXN = 1e6 + 10;const int mod = 1e9 + 7;const int N = 100010;vector<array<int, 3>>o[N];int dist[N];int st[N];void solve(){    int n, m;    cin >> n >> m;    for (int i = 1; i <= n; i++)        o[i].clear(), dist[i] = -1e15, st[i] = 0;    int t1, t2, t3;    cin>>t3 >> t1 >> t2;    for (int i = 1; i <= m; i++)    {        int u, v, l1, l2;        cin >> u >> v >> l1 >> l2;        o[u].push_back({ v,l1,l2 });        o[v].push_back({ u,l1,l2 });    }    dist[n] = t3;    priority_queue<PII>p;    p.push({ t3,n });    while (p.size())    {        PII now = p.top();        p.pop();        if (dist[now.se] != now.fi)            continue;        st[now.se] = 1;        for (auto i : o[now.se])        {            if (st[i[0]])                continue;            int sj = now.first - i[2];            if (now.fi <= t1 || now.first - i[1] >= t2)                sj = now.first - i[1];            else if(now.first>t1)                sj = max(sj, t1 - i[1]);            if (sj > dist[i[0]])                dist[i[0]] = sj, p.push({ sj,i[0] });        }    }    if (dist[1] < 0)        cout << -1 << endl;    else        cout << dist[1] << endl;}signed main(){    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    int T = 1;    cin >> T;    while (T--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Call During the Journey.json",
    "hint": []
}