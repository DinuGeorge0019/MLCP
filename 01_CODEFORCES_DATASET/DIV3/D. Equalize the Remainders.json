{"link": "https://codeforces.com//contest/999/problem/D", "problemId": "192343", "problem_idx": "D", "shortId": "999D", "contest_number": "999", "problem_submissions": {"E": [39482525, 39480258, 39480681, 39472815, 39481171, 39483804, 39482822, 39487988, 39486311, 39488255, 39483434, 39476369, 39475874, 39475323, 39478090, 39485416, 39483552, 39485842, 39478651], "D": [39476985, 39482714, 39477867, 39487661, 39478808, 39479957, 39478688, 39480079, 39484369, 39488043, 39682317, 39484150, 39479480, 39479981, 39480905, 39490327], "F": [39474187, 39476396, 39486159, 39480138, 39488092, 39484785, 39487824, 39489626, 39479920, 39488254, 39490520, 39472516, 39481714, 39495126, 39494491, 39484965, 39486979, 39528460, 39528455, 39509111], "C": [39468293, 39473877, 39471032, 39469713, 39469003, 39471817, 39471185, 39471833, 39473032, 39481734, 39489064, 39465485, 39469355, 39469432, 39471841, 39471812, 39470774, 39471323, 39471302], "B": [39466151, 39472359, 39467106, 39467712, 39466498, 39469904, 39468165, 39469498, 39470396, 39480507, 39490594, 39469417, 39466615, 39467515, 39469262, 39469175, 39469263, 39468726], "A": [39465278, 39470703, 39465116, 39466655, 39465297, 39465892, 39465427, 39466410, 39468368, 39479548, 39467417, 39471284, 39465152, 39465656, 39465454, 39466984, 39465563, 39467221]}, "name": "D. Equalize the Remainders", "statement": "You are given an array consisting of n integers a_1, a_2,\r\ndots, a_n, and a positive integer m. It is guaranteed that m is a\r\ndivisor of n.In a single move, you can choose any position i between 1\r\nand n and increase a_i by 1.Let\u2019s calculate c_r (0\r\nle r\r\nle m-1) the number of elements having remainder r when divided by m. In\r\nother words, for each remainder, let\u2019s find the number of corresponding\r\nelements in a with that remainder.Your task is to change the array in\r\nsuch a way that c_0 = c_1 =\r\ndots = c_{m-1} =\r\nfrac{n}{m}.Find the minimum number of moves to satisfy the above\r\nrequirement.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl '\\n'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(4e5) + 17;\n\nint n, m;\nint a[MAXN];\nvector<int> kok[MAXN];\n\nbool read() {\n    if (!(cin >> n >> m))\n        return false;\n\n    forn (i, n)\n        cin >> a[i];\n\n    return true;\n}\n\nvoid solve() {\n    forn (i, n)\n        kok[a[i] % m].push_back(i);\n\n    set< pair<int, int> > cock;\n    ll ans = 0;\n\n    forn (i, 2 * m)\n        if (sz(kok[i % m]) < n / m) {\n            for (; !cock.empty() && sz(kok[i % m]) < n / m; cock.erase(cock.begin())) {\n                auto j = cock.begin()->second;\n                auto t = (m + i % m - cock.begin()->first) % m;\n                ans += t;\n                a[j] += t;\n                kok[i % m].push_back(j);\n            }\n        } else if (sz(kok[i % m]) > n / m) {\n            for (; sz(kok[i % m]) > n / m; kok[i % m].pop_back())\n                cock.insert(make_pair(i % m, kok[i % m].back()));\n        }\n\n    cout << ans << endl;\n\n    forn (i, n)\n        cout << a[i] << ' ';\n\n    cout << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n\n#ifdef SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n};\n\n"], "input": "", "output": "", "tags": ["data structures", "greedy", "implementation"], "dificulty": "1900", "interactive": false}