{
    "link": "https://codeforces.com//contest/2037/problem/E",
    "problemId": "3030273",
    "problem_idx": "E",
    "shortId": "2037E",
    "contest_number": "2037",
    "problem_submissions": {
        "E": [
            292047075,
            292001485,
            292009292,
            291996476,
            292062011,
            292051813,
            292265678,
            292262203,
            292192703,
            292071302,
            292070663,
            291999780,
            292064784,
            292052672,
            292050626,
            292052922,
            292071828,
            291992209,
            292000170,
            291988756,
            292008406,
            292007324
        ],
        "F": [
            292022218,
            292017907,
            292024969,
            292058791,
            292012459,
            292558370,
            292027964,
            292322779,
            292083202,
            292025710,
            292058305,
            292053924,
            292057524,
            292098039,
            292062013,
            292058405,
            292072247,
            292041262,
            291975958,
            292082628,
            292078164,
            292082635,
            292046600
        ],
        "G": [
            291996486,
            292046822,
            292051239,
            292033736,
            292022807,
            292088543,
            292046321,
            292046301,
            292015442,
            292027681,
            292033325,
            292031649,
            292030485,
            292058022,
            292068187,
            292049914,
            292058005,
            292018113,
            291981788,
            292025943,
            292032506,
            292023447,
            292184893
        ],
        "D": [
            291973736,
            291988212,
            291992996,
            291979703,
            291998834,
            291983903,
            292002713,
            292029295,
            291999646,
            291984954,
            292024081,
            292031106,
            291991931,
            291978485,
            292010279,
            291980815,
            291970955,
            291981313,
            291985613
        ],
        "C": [
            291961505,
            291975167,
            291974207,
            291964672,
            291977153,
            291965604,
            291972603,
            291985859,
            291958605,
            291975659,
            291971736,
            292051709,
            291965196,
            293681954,
            291964838,
            291966108,
            291957366,
            291965128,
            291970402
        ],
        "B": [
            291956714,
            291952988,
            291957798,
            291954795,
            291952360,
            291952928,
            291957139,
            291960930,
            291959780,
            291972890,
            291956311,
            291964398,
            291952930,
            291955364,
            291953325,
            291955467,
            291951893,
            291958231,
            291957803
        ],
        "A": [
            291948750,
            291945793,
            291946764,
            291946202,
            291945511,
            291946198,
            291946444,
            291950431,
            291945465,
            291953437,
            291945736,
            291948815,
            291947311,
            291946698,
            291949011,
            291949226,
            291946064,
            291945840,
            291951387
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136334",
    "editorial": "Notice that for if for some r\n we have f(1,r)<f(1,r+1)\n then we can conclude that sr+1=1\n (if it is 0\n then f(1,r)=f(1,r+1)\n will be true) and if f(1,r)\n is non-zero and f(1,r)=f(1,r+1)\n then sr+1\n is 0\n.\n\nUnfortunately this is only useful if there is a 0\n in s1,s2,...,sr\n, so the next thing can try is to find is the value of the longest prefix such that f(1,r)\n is 0\n (after this point there will be a zero in all prefixes).\n\nSee that if f(1,r)=0\n and f(1,r+1)=k\n then sr+1=1\n, the last k\n characters of s1,s2,...,sr\n must be 0\n and the first r?k\n characters must be 1\n. To prove this we can argue by contradiction, suppose it is not true and then it will become apparent that some shorter prefix will be non-zero when we query it.\n\nThe one case that this does not cover is when all prefixes are zero, from similar contradiction argument as above we can see that the string must look like 111...1100....000\n in this case, in this case it is not hard to see that all queries will give a value of zero, and thus we can report that it is impossible.\n\nSo we should query all prefixes, the first one which is non-zero (if this does not exist we can report impossible) we can deduce its value as discussed above, then there will be a 0\n in the prefix so we can deduce all subsequent characters as discussed at the start.",
    "name": "E. Kachina s Favorite Binary String",
    "statement": "Kachina challenges you to guess her favorite binary string^{\r\ntext{ }} s of length n. She defines f(l, r) as the number of\r\nsubsequences^{\r\ntext{ }} of\r\ntexttt{01} in s_l s_{l+1}\r\nldots s_r. To determine s, you can ask her some questions. In each\r\nquestion, you can choose two indices l and r (1\r\nleq l < r\r\nleq n) and ask her for the value of f(l, r).Determine and output s after\r\nasking Kachina no more than n questions. However, it may be the case\r\nthat s is . In this case, you would need to report\r\ntexttt{IMPOSSIBLE} instead.Formally, s is if after asking n questions,\r\nthere are always multiple possible strings for s, regardless of what\r\nquestions are asked.\r\ntexttt{IMPOSSIBLE} ^{\r\ntext{ }}A binary string only contains characters\r\ntexttt{0} and\r\ntexttt{1}.^{\r\ntext{ }}A sequence a is a subsequence of a sequence b if a can be\r\nobtained from b by the deletion of several (possibly, zero or all)\r\nelements. For example, subsequences of\r\nmathtt{1011101} are\r\nmathtt{0},\r\nmathtt{1},\r\nmathtt{11111},\r\nmathtt{0111}, but not\r\nmathtt{000} nor\r\nmathtt{11100}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> #define int long long#define fi first#define se second const int N = 2e5 + 5;const int K = 1e2 + 5;const int mod = 998244353; #define all(v) (v).begin(), (v).end()#define pii pair<int, int> using namespace std; mt19937 rd(chrono::steady_clock::now().time_since_epoch().count()); int t, n, a[N]; signed main() {    ios_base::sync_with_stdio(0);    cin.tie(0);     if(ifstream(\"file.inp\")){    \tfreopen(\"file.inp\", \"r\", stdin);    \tfreopen(\"file.out\", \"w\", stdout);    }     cin >> t;    while(t--) {    \tcin >> n;    \tbool imp = 1;    \ta[1] = 0;    \tfor(int i = 2; i <= n; i++) {    \t\tcout << \"? \" << 1 << ' ' << i << endl;    \t\tcin >> a[i];    \t\tif(a[i] > 0) imp = 0;    \t}    \tif(imp) {    \t\tcout << \"! IMPOSSIBLE\" << endl;    \t}    \telse {    \t\tstring s(n, '1');    \t\tint cnt = 0;    \t\tfor(int i = 2; i <= n; i++) {    \t\t\tif(a[i] > a[i - 1]) {    \t\t\t\tfor(int j = i - 2; j >= i - 1 - a[i] + 2 * a[i - 1]; j--) {                        s[j] = '0';                        cnt++;    \t\t\t\t}    \t\t\t}    \t\t\telse if(a[i] == a[i - 1] && cnt) s[i - 1] = '0';    \t\t}    \t\tcout << \"! \" << s << endl;    \t}    }     return 0;} // tuntun"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "interactive",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Kachina s Favorite Binary String.json",
    "hint": []
}