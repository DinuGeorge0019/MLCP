{
    "link": "https://codeforces.com//contest/1092/problem/F",
    "problemId": "271425",
    "problem_idx": "F",
    "shortId": "1092F",
    "contest_number": "1092",
    "problem_submissions": {
        "F": [
            47218597,
            47207874,
            47241634,
            47318477,
            47214615,
            47217604,
            47210093,
            47210748,
            47212691,
            47213985,
            47215066,
            47216141
        ],
        "D1": [
            47215980,
            47227965,
            47212365,
            47220485,
            47215001,
            47223458,
            47225913,
            47226094,
            47209533,
            47227527,
            47227478,
            47227395,
            47227268,
            47226719,
            47216461,
            47213724,
            47334192
        ],
        "D2": [
            47212833,
            47212767,
            47218226,
            47218497,
            47219527,
            47223320,
            47217259,
            47271469,
            47223969,
            47236061,
            47213976,
            47212963,
            47333101
        ],
        "C": [
            47208479,
            47202011,
            47208106,
            47207681,
            47211238,
            47213730,
            47205520,
            47206298,
            47207117,
            47206109,
            47208340,
            47227233,
            47226698,
            47207049,
            47207288,
            47209584,
            47210057,
            47206966,
            47207998
        ],
        "B": [
            47202083,
            47196597,
            47203007,
            47199377,
            47202631,
            47197720,
            47198736,
            47196902,
            47198167,
            47197186,
            47198915,
            47226662,
            47196684,
            47197714,
            47198493,
            47198454,
            47201892,
            47199196
        ],
        "A": [
            47200523,
            47196094,
            47201972,
            47196916,
            47200910,
            47196295,
            47196192,
            47197255,
            47196159,
            47196525,
            47196472,
            47196994,
            47226648,
            47196039,
            47196511,
            47196950,
            47196914,
            47198726,
            47197707
        ],
        "E": [
            47266392,
            47319938,
            47234188,
            47277429,
            47369991
        ]
    },
    "name": "F. Tree with Maximum Cost",
    "statement": "You are given a tree consisting exactly of n vertices. Tree is a\r\nconnected undirected graph with n-1 edges. Each vertex v of this tree\r\nhas a value a_v assigned to it.Let dist(x, y) be the distance between\r\nthe vertices x and y. The distance between the vertices is the number of\r\nedges on the simple path between them.Let’s define the cost of the tree\r\nas the following value: firstly, let’s fix some vertex of the tree. Let\r\nit be v. Then the cost of the tree is\r\nsum\r\nlimits_{i = 1}^{n} dist(i, v)\r\ncdot a_i.Your task is to calculate the of the tree if you can choose v\r\narbitrarily.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<vector>\nusing namespace std;\nvector<int>e[200001];\nlong long dp0[200001],s[200001];\nlong long a[200001];\nvoid dfs0(int x,int lt){\n    s[x]=a[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs0(y,x);\n        dp0[x]+=dp0[y]+s[y];\n        s[x]+=s[y];\n    }\n}\nlong long an;\nvoid dfs(int x,int lt,long long v){\n    if(v+dp0[x]>an)an=v+dp0[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs(y,x,v+dp0[x]-dp0[y]-s[y]*2+s[1]);\n    }\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs0(1,1);\n    dfs(1,1,0);\n    printf(\"%lld\\n\",an);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Tree with Maximum Cost.json",
    "editorial_link": "https://codeforces.com//blog/entry/63961",
    "editorial": "Firstly, letâs calculate the answer (let it be ) for some fixed vertex.\r\nLet this vertex be the vertex . Just run simple and calculate the result\r\nusing the formula from the problem statement. Also letâs calculate the\r\nsum of values (let the sum in the subtree of the vertex be ) in each\r\nsubtree of the given tree if its root is the vertex . It can be easily\r\ndone with simple dynamic programming.And now the magic part: letâs apply\r\nthe technique which is called \"\" (at least we called it so). Letâs\r\nmaintain the correct values in subtrees at each step of our algorithm.\r\nHow will values and the answer change if we will go through the edge\r\n?The following sequence of changes will change all values correctly:\r\nFirstly, it can be seen that will decrease by (because the distance to\r\neach vertex in this subtree will decrease by one); then will decrease by\r\n(because we change the root of the tree) (we need this step to maintain\r\nthe correct values); then will increase by (because the distance to each\r\nvertex in this subtree will increase by one); and then will increase by\r\n(because we change the root of the tree) (we need this step to maintain\r\nthe correct values). So, we can recalculate all the values we need if we\r\ngo through the edge. So now we can write another one to try to update\r\nthe answer for each vertex as a root (as the chosen vertex).\r\n",
    "hint": []
}