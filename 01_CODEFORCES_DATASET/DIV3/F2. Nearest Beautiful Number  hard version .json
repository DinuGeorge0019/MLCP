{
    "link": "https://codeforces.com//contest/1560/problem/F2",
    "problemId": "1082102",
    "problem_idx": "F2",
    "shortId": "1560F2",
    "contest_number": "1560",
    "problem_submissions": {
        "F2": [
            126333818,
            126306855,
            126317964,
            126343969,
            126329373,
            126329484,
            126318670,
            126324734,
            126340312,
            126380679,
            126324751,
            126323492,
            126392331,
            126323366,
            126338259,
            181389292,
            126327293,
            126341450,
            126335878,
            126346280,
            126343998,
            126334938,
            126331523,
            126358791
        ],
        "E": [
            126314275,
            126322204,
            126332108,
            126337635,
            126318617,
            126338757,
            126331477,
            126341239,
            126380625,
            126338931,
            126345881,
            126392319,
            126339127,
            126324096,
            126341795,
            126324358,
            126350364,
            126334805,
            126335135,
            126362201,
            126365972,
            126318677
        ],
        "F1": [
            126309457,
            126306646,
            126317821,
            126307775,
            126330038,
            126318533,
            126324378,
            126310262,
            126324870,
            126323614,
            126392323,
            126323290,
            126338176,
            126327481,
            126351876,
            126335480,
            126346365,
            126344093,
            126335132,
            126331374,
            126336670
        ],
        "D": [
            126298074,
            126431766,
            126302775,
            126302608,
            126296584,
            126295532,
            126300302,
            126303789,
            126294528,
            126389287,
            126379378,
            126374780,
            126312331,
            126313764,
            126392312,
            126309627,
            126305716,
            126307963,
            126306718,
            126303322,
            126315291,
            126312680,
            126316841,
            126311452,
            126300681
        ],
        "C": [
            126288623,
            126433600,
            126292103,
            126291590,
            126288757,
            126288046,
            126289111,
            126288025,
            126294392,
            126290860,
            126380656,
            126297916,
            126292682,
            126392309,
            126304707,
            126294000,
            126293843,
            126290516,
            126295186,
            126293202,
            126294960,
            126303302,
            126297335,
            126292511
        ],
        "B": [
            126283242,
            126282856,
            126282667,
            126281542,
            126281182,
            126284410,
            126281360,
            126280185,
            126288262,
            126283351,
            126501327,
            126501253,
            126392300,
            126294064,
            126288477,
            126286554,
            126285105,
            126283253,
            126285740,
            126288591,
            126286357,
            126288697,
            126284546
        ],
        "A": [
            126276779,
            126276302,
            126276753,
            126276379,
            126276291,
            126277704,
            126276617,
            126277755,
            126279450,
            126276413,
            126392288,
            126284958,
            126277758,
            126277313,
            126277718,
            126276817,
            126277182,
            126278392,
            126279481,
            126277037,
            126282057
        ]
    },
    "name": "F2. Nearest Beautiful Number  hard version ",
    "statement": "You are given an integer n. Find the minimum integer x such that x\r\nge n and the number x is k-.A number is called k- if its decimal\r\nrepresentation having no leading zeroes contains no more than k\r\ndifferent digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21\r\nare k- whereas the numbers 120, 445435 and 998244353 are not.\r\n",
    "solutions": [
        "/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n \n#include <bits/stdc++.h>\n  \n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n \n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n \n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n\nusing namespace std;\n\nint t, k;\nstring s;\n\nint convert(string& s) {\n    int res = 0;\n    for (auto f : s) res = res * 10 + f - '0';\n    return res;\n}\n\nint cnt(string& s) {\n    set<char> se;\n    for (auto f : s) se.insert(f);\n    return sz(se);\n}\n\nsigned main() {\n    \n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(\"cf.inp\", \"r\", stdin);\n    // freopen(\"cf.out\", \"w\", stdout);\n\n    cin >> t;\n    while (t--) {\n        cin >> s >> k;\n        if (cnt(s) <= k) {\n            cout << s << \"\\n\";\n            continue;\n        }\n\n        int res = INF;\n        if (k == 1) {\n            int n = convert(s), res = INF;\n            for1(i,1,9) {\n                int p = 0;\n                for1(j,1,10) {\n                    p = p * 10 + i;\n                    if (p >= n) {\n                        res = min(res, p);\n                        break;\n                    }\n                } \n            }\n            cout << res << \"\\n\";\n\n            continue;\n        }\n\n        int cur = 0;\n        while (sz(s) > 1) {\n            while (s[sz(s) - 1] + 1 <= '9') {\n                s[sz(s) - 1]++;\n                int p = cnt(s);\n                if (p < k) {\n                    string t = s;\n                    for1(i,1,cur) t += '0';\n                    res = min(res, convert(t));\n                }\n                else if (p == k) {\n                    string t = s;\n                    char m = 'a';\n                    for (auto f : s) m = min(m, f);\n                    for1(i,1,cur) t += m;\n                    res = min(res, convert(t));\n                }\n            }\n            s.pop_back();\n            cur++;\n        }\n\n        cout << res << \"\\n\";\n    }\n    \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F2. Nearest Beautiful Number  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/94009",
    "editorial": "Suppose the number contains digits and its decimal representation is .\r\nThe desired number isnât greater than the number consisting of digits .\r\nThis number is -beautiful whereas any -beautiful number is at the same\r\ntime -beautiful, so contains at most digits. At the same time, so\r\ncontains at least digits. Therefore, the desired number contains exactly\r\ndigits.Since we search for the minimum , we need to minimize first of\r\nall the first digit, only then the second digit, etc. Therefore, we need\r\nto find a prefix of the decimal representation of such that is a prefix\r\nof the decimal representation of . Letâs do it greedily.Letâs find the\r\nmaximum prefix of such that contains no more than distinct numbers.\r\nSuppose the prefix has the length . If , then is already -beautiful,\r\nletâs output it. Otherwise, letâs increase the prefix like a number by ,\r\ne.g. if and , then we increase by , the resulting prefix is . All other\r\ndigits (), letâs set to zeroes (e.g. if and , then will be turned into\r\n). The answer for the old is the answer for the new . To get the answer\r\nfor the new , letâs start the described procedure once again preparing\r\nthe new .Letâs find the maximum prefix of such that contains no more\r\nthan distinct numbers. Itâs possible to do using a in which for each\r\ndigit (the key) the number of its occurrences in the prefix is stored.\r\nFor an empty prefix, the is empty. If we increase the prefix length by ,\r\nwe need to check that contains no more than keys and add a new key with\r\nthe value or increase the value of an existing key. If the length of the\r\nfound prefix is equal to the length of the whole decimal representation,\r\nthe given number is already -beautiful so the answer is .Otherwise, the\r\nfound prefix may not be a prefix of the desired number. Letâs change the\r\ndigits of the decimal representation of to turn it into the desired\r\nnumber . Letâs start the following procedure: suppose we consider a\r\nprefix with the length equal to . First, letâs find out, is it possible\r\nto increase the first element out of the prefix (i. e. ). We need to do\r\nit because if we consider the length , then the prefix with the length\r\ncannot be unchanged so the element must be changed whereas it cannot be\r\ndecreased because, in this case, we will get the number which is less\r\nthan . If we can increase the element so that the prefix with the length\r\nhas at most distinct digits, the only thing that is remained to do is to\r\nfill the remaining digits somehow greedily and output the result. If we\r\ncannot increase the element , letâs decrease the length of the\r\nconsidered prefix by updating the (letâs decrease the value\r\ncorresponding to the key by , then, if itâs equal to , we remove the key\r\nfrom the ).Consider, how and under what conditions we can change and the\r\nfollowing digits: If , itâs impossible. Suppose the considered prefix\r\ncontains less than distinct digits (the number of the keys in the is\r\nless than ). In this case, we can replace the digit with the value so\r\nthe prefix with the length will not contain more than distinct elements\r\nbecause the prefix with the length doesnât contain more than distinct\r\nelements. If the prefix with the length still contains less than\r\ndistinct numbers, letâs replace the remaining digits (, , etc) with .\r\nOtherwise, we can replace them with the minimum digit that occurs in the\r\nprefix with the length (it may be ). Suppose the considered prefix\r\ncontains exactly distinct digits. So letâs find the minimum digit that\r\noccurs in the prefix with the length and is greater than . If such digit\r\nexists, letâs replace with it, and all following digits with the minimum\r\ndigit that occurs in the prefix with the length . Otherwise, the element\r\ncannot be increased.The converted by the procedure is the answer.\r\n",
    "hint": []
}