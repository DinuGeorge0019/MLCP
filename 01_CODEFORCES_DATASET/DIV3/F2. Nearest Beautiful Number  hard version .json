{"link": "https://codeforces.com//contest/1560/problem/F2", "problemId": "1082102", "problem_idx": "F2", "shortId": "1560F2", "contest_number": "1560", "problem_submissions": {"F2": [126333818, 126306855, 126317964, 126343969, 126329373, 126329484, 126318670, 126324734, 126340312, 126380679, 126324751, 126323492, 126392331, 126323366, 126338259, 181389292, 126327293, 126341450, 126335878, 126346280, 126343998, 126334938, 126331523, 126358791], "E": [126314275, 126322204, 126332108, 126337635, 126318617, 126338757, 126331477, 126341239, 126380625, 126338931, 126345881, 126392319, 126339127, 126324096, 126341795, 126324358, 126350364, 126334805, 126335135, 126362201, 126365972, 126318677], "F1": [126309457, 126306646, 126317821, 126307775, 126330038, 126318533, 126324378, 126310262, 126324870, 126323614, 126392323, 126323290, 126338176, 126327481, 126351876, 126335480, 126346365, 126344093, 126335132, 126331374, 126336670], "D": [126298074, 126431766, 126302775, 126302608, 126296584, 126295532, 126300302, 126303789, 126294528, 126389287, 126379378, 126374780, 126312331, 126313764, 126392312, 126309627, 126305716, 126307963, 126306718, 126303322, 126315291, 126312680, 126316841, 126311452, 126300681], "C": [126288623, 126433600, 126292103, 126291590, 126288757, 126288046, 126289111, 126288025, 126294392, 126290860, 126380656, 126297916, 126292682, 126392309, 126304707, 126294000, 126293843, 126290516, 126295186, 126293202, 126294960, 126303302, 126297335, 126292511], "B": [126283242, 126282856, 126282667, 126281542, 126281182, 126284410, 126281360, 126280185, 126288262, 126283351, 126501327, 126501253, 126392300, 126294064, 126288477, 126286554, 126285105, 126283253, 126285740, 126288591, 126286357, 126288697, 126284546], "A": [126276779, 126276302, 126276753, 126276379, 126276291, 126277704, 126276617, 126277755, 126279450, 126276413, 126392288, 126284958, 126277758, 126277313, 126277718, 126276817, 126277182, 126278392, 126279481, 126277037, 126282057]}, "name": "F2. Nearest Beautiful Number  hard version ", "statement": "You are given an integer n. Find the minimum integer x such that x\r\nge n and the number x is k-.A number is called k- if its decimal\r\nrepresentation having no leading zeroes contains no more than k\r\ndifferent digits. E.g. if k = 2, the numbers 3434443, 55550, 777 and 21\r\nare k- whereas the numbers 120, 445435 and 998244353 are not.\r\n", "solutions": ["/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n \n#include <bits/stdc++.h>\n  \n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n \n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n \n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n\nusing namespace std;\n\nint t, k;\nstring s;\n\nint convert(string& s) {\n    int res = 0;\n    for (auto f : s) res = res * 10 + f - '0';\n    return res;\n}\n\nint cnt(string& s) {\n    set<char> se;\n    for (auto f : s) se.insert(f);\n    return sz(se);\n}\n\nsigned main() {\n    \n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(\"cf.inp\", \"r\", stdin);\n    // freopen(\"cf.out\", \"w\", stdout);\n\n    cin >> t;\n    while (t--) {\n        cin >> s >> k;\n        if (cnt(s) <= k) {\n            cout << s << \"\\n\";\n            continue;\n        }\n\n        int res = INF;\n        if (k == 1) {\n            int n = convert(s), res = INF;\n            for1(i,1,9) {\n                int p = 0;\n                for1(j,1,10) {\n                    p = p * 10 + i;\n                    if (p >= n) {\n                        res = min(res, p);\n                        break;\n                    }\n                } \n            }\n            cout << res << \"\\n\";\n\n            continue;\n        }\n\n        int cur = 0;\n        while (sz(s) > 1) {\n            while (s[sz(s) - 1] + 1 <= '9') {\n                s[sz(s) - 1]++;\n                int p = cnt(s);\n                if (p < k) {\n                    string t = s;\n                    for1(i,1,cur) t += '0';\n                    res = min(res, convert(t));\n                }\n                else if (p == k) {\n                    string t = s;\n                    char m = 'a';\n                    for (auto f : s) m = min(m, f);\n                    for1(i,1,cur) t += m;\n                    res = min(res, convert(t));\n                }\n            }\n            s.pop_back();\n            cur++;\n        }\n\n        cout << res << \"\\n\";\n    }\n    \n}"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "constructive algorithms", "dfs and similar", "dp", "greedy"], "dificulty": "2100", "interactive": false}