{
    "link": "https://codeforces.com//contest/1933/problem/G",
    "problemId": "2499503",
    "problem_idx": "G",
    "shortId": "1933G",
    "contest_number": "1933",
    "problem_submissions": {
        "F": [
            248591555,
            248583197,
            248612069,
            248598539,
            248597755,
            248643416,
            248594242,
            248617583,
            248616936,
            248585168,
            248614930,
            248616674,
            248602103,
            248594258,
            248595945,
            248611877,
            248611178,
            248616575,
            248616309,
            248622503,
            248617674
        ],
        "E": [
            248548292,
            248552431,
            248546385,
            248561374,
            248556960,
            248652019,
            248551455,
            248552418,
            248555156,
            248564471,
            248563614,
            248548908,
            248551471,
            248562111,
            248581222,
            248571134,
            248569128,
            248568252,
            248572929,
            248557480,
            248572070
        ],
        "D": [
            248528452,
            248534682,
            248520947,
            248525201,
            248536025,
            248654461,
            248561233,
            248528372,
            248531274,
            248536504,
            248531753,
            248522180,
            248521565,
            248548476,
            248549982,
            248534397,
            248534785,
            248540283,
            248533460,
            248533936,
            248522543
        ],
        "C": [
            248516161,
            248524318,
            248516570,
            248527729,
            248522314,
            248522710,
            248519907,
            248542337,
            248516141,
            248527195,
            248558597,
            248543262,
            248520926,
            248522993,
            248519350,
            248521925,
            248526364,
            248527609,
            248534164
        ],
        "B": [
            248505336,
            248503901,
            248517888,
            248511472,
            248507016,
            248507736,
            248508836,
            248511885,
            248506077,
            248516238,
            248525805,
            248512121,
            248503633,
            248509962,
            248507053,
            248512665,
            248511061,
            248506937,
            248515209
        ],
        "A": [
            248494249,
            248494304,
            248494559,
            248496663,
            248496909,
            248500497,
            248494197,
            248494587,
            248497967,
            248494007,
            248495080,
            248494500,
            248498090,
            248639683,
            248493804,
            248494937,
            248495858,
            248498778,
            248497100,
            248494989,
            248499649
        ],
        "G": [
            248742272,
            248790545,
            248713826,
            248773615,
            248759515
        ]
    },
    "name": "G. Turtle Magic  Royal Turtle Shell Pattern",
    "statement": "Turtle Alice is currently designing a fortune cookie box, and she would\r\nlike to incorporate the theory of LuoShu into it.The box can be seen as\r\nan n\r\ntimes m grid (n, m\r\nge 5), where the rows are numbered 1, 2,\r\ndots, n and columns are numbered 1, 2,\r\ndots, m. Each cell can either be or have a single fortune cookie of one\r\nof the following shapes: or . The cell at the intersection of the a-th\r\nrow and the b-th column is denoted as (a, b).Initially, the entire grid\r\nis empty. Then, Alice performs q operations on the fortune cookie box.\r\nThe i-th operation (1\r\nle i\r\nle q) is as follows: specify a currently empty cell (r_i,c_i) and a\r\nshape (circle or square), then put a fortune cookie of the specified\r\nshape on cell (r_i,c_i). Note that after the i-th operation, the cell\r\n(r_i,c_i) is no longer empty.Before all operations after each of the q\r\noperations, Alice wonders what the number of ways to place fortune\r\ncookies in is, such that the following condition is satisfied:No three\r\nconsecutive cells (in horizontal, vertical, and both diagonal\r\ndirections) contain cookies of the same shape. Formally: There does not\r\nexist any (i,j) satisfying 1\r\nle i\r\nle n, 1\r\nle j\r\nle m-2, such that there are cookies of the same shape in cells (i,j),\r\n(i,j+1), (i,j+2). There does not exist any (i,j) satisfying 1\r\nle i\r\nle n-2, 1\r\nle j\r\nle m, such that there are cookies of the same shape in cells (i,j),\r\n(i+1,j), (i+2,j). There does not exist any (i,j) satisfying 1\r\nle i\r\nle n-2, 1\r\nle j\r\nle m-2, such that there are cookies of the same shape in cells (i,j),\r\n(i+1,j+1), (i+2,j+2). There does not exist any (i,j) satisfying 1\r\nle i\r\nle n-2, 1\r\nle j\r\nle m-2, such that there are cookies of the same shape in cells (i,j+2),\r\n(i+1,j+1), (i+2,j). You should output all answers modulo 998\r\n,244\r\n,353. Also note that it is possible that after some operations, the\r\ncondition is already not satisfied with the already placed candies, in\r\nthis case you should output 0.\r\n",
    "solutions": [
        "//Author = Anirudh Srikanth (yeetholmes619) [B20CS006]\n//https://github.com/yeetholmes619/Template.git\n#include <bits/stdc++.h>\n#ifdef DEBUG\n#include \"debug.h\"\n#endif\n#ifndef DEBUG\n#define debug(args...)\n#endif\n#define curtime             chrono::high_resolution_clock::now()\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#define timedif(start,end)  chrono::duration_cast<chrono::nanoseconds>(end - start).count()\nusing namespace std;\n#define ll long long\n#define ld long double\n#define INF LLONG_MAX\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define FOR(i,a,b) for(int i = a; i <= b; i++)\n#define ROF(i,a,b) for(int i = a; i >= b; i--)\n#define vi vector<int>\n#define pii pair<int,int>\n#define vpii vector<pair<int,int>>\ntemplate <typename T>\nusing matrix = vector<vector<T>>;\n\n#define SZ(x) (int)(x.size())\n#define mp make_pair\n#define allvec(v) v.begin(), v.end()\n#define int long long\n#define output(value) cout << value << \"\\n\"\nconst int mod1 =1000000007;\nconst int mod2 = 998244353;\ntemplate<typename T1, typename T2> // cin >> pair<T1, T2>\nistream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); } \ntemplate<typename T> // cin >> vector<T>\nistream& operator>>(istream &istream, vector<T> &v)\n{\n\tfor (auto &it : v)\n\t\tcin >> it;\n\treturn istream;\n}\n \ntemplate<typename T1, typename T2> // cout << pair<T1, T2>\nostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }\ntemplate<typename T> // cout << vector<T>\nostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }\n \n//\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\GLOBAL VARIABLES/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\///\\/\\/\nint n,m,q;\nvector<matrix<int>> poss;\n//\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\///\\/\\/\\/\\/\\/\\/\nvoid precomp(){\n        matrix<int>grid(5,vi(5,-69));\n        int n = 5;\n        int m = 5;\n        auto check = [&](){\n                for(int i = 0; i+2 < n; i++){\n                        for(int j = 0; j < m; j++){\n                                int cnt = 0;\n                                for(int k = 0; k < 3; k++){\n                                        cnt += grid[i+k][j];\n                                }\n                                if(cnt == 0 or cnt == 3)\n                                        return false;\n                        }\n                }\n                for(int i =0 ; i < n; i++){\n                        for(int j = 0; j+ 2 < m; j++){\n                                int cnt =0 ;\n                                for(int k = 0; k < 3; k++){\n                                        cnt += grid[i][j+k];\n                                }\n                                if(cnt == 0 or cnt == 3){\n                                        return false;\n                                }\n                        }\n                }\n                for(int i = 0; i+2 < n; i++){\n                        for(int j = 0; j +2 < m; j++){\n                                int cnt= 0 ;\n                                for(int k =0 ; k < 3; k++){\n                                        cnt += grid[i+k][j+k];\n                                }\n                                if(cnt == 0 or cnt == 3){\n                                        return false;\n                                }\n                        }\n                }\n                for(int i = 0; i + 2< n; i++){\n                        for(int j = 2; j < m; j++){\n                                int cnt = 0;\n                                for(int k = 0; k < 3; k++){\n                                        cnt += grid[i+k][j-k];\n                                }\n                                if(cnt == 0 or cnt == 3){\n                                        return false;\n                                }\n                        }\n                }\n                return true;\n        };\n        function<int(int)> dfs = [&](int x)->int{\n                if(x == m*n){\n                        if(check()){\n                                poss.pb(grid);\n                                debug(grid);\n                        }\n                        return check();\n                }\n                int i = x/m;\n                int j = x%m;\n                int ans = 0;\n                grid[i][j] = 0;\n                if(check())\n                        ans += dfs(x+1);\n                grid[i][j] = 1;\n                if(check())\n                        ans += dfs(x+1);\n                grid[i][j] = -69;\n                return ans;\n        };\n        dfs(0);\n}\n\n\nvoid take(){\n        cin>>n>>m>>q;\n}\n\nvoid solve(){\n        take();\n        debug(poss);\n        auto check = [&](pii x, matrix<int> grid){\n                int i = x.first/5;\n                int j = x.first%5;\n                bool ans = grid[i][j] == x.second;\n                debug(x,grid,ans);\n                return ans;\n        };\n        output(8);\n        queue<matrix<int>> good;\n        for(auto t: poss){\n                good.push(t);\n        }\n        while(q--){\n                int x, y;\n                cin>>x>>y;\n                x--;y--;\n                string cell;\n                cin>>cell;\n                int v = (cell == \"circle\")  ?1 :0;\n                x%=4;\n                y%= 4;\n                pii reqi = pii{x*5 + y, v};\n                int ans = 0;\n                queue<matrix<int>> temp;\n                while(good.size()){\n                        auto grid = good.front();\n                        good.pop();\n                        int maybe = true;\n                        if(!check(reqi,grid)){\n                                maybe = false;\n                        }\n                        if(maybe){\n                                temp.push(grid);\n                                ans++;\n                        }\n                }\n                good = temp;\n                output(ans);\n        }\n\n\n\n}\n\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    auto time0 = curtime;\n\tll t = 1;\n\tcin >> t;\n    precomp();\n\tfor(int i = 1 ; i <= t; i++) {\n\t\t//cout << \"Case #\" << i << \": \";\n        debug(i);\n\t\tsolve();\n\t}\n#ifdef YEET\n    cerr<<\"Execution Time: \"<<timedif(time0,curtime)*1e-9<<\" sec\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "dfs and similar",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Turtle Magic  Royal Turtle Shell Pattern.json",
    "editorial_link": "https://codeforces.com//blog/entry/126560",
    "editorial": "We claim that there are only configurations that satisfy the condition.\r\nThe proof is as follows.Firstly, consider a subgrid that does not lie on\r\nany of the gridâs corners. Within the subgrid, there must be 2 Os and 2\r\nXs. Assume the contrary that there are 3 Os or 4 Os. (The case with 3 Xs\r\nor 4 Xs is done too due to symmetry.)Then, after some logical deduction\r\nwe will end up with 3 consecutive Xs, as illustrated in the following\r\nfigure.The condition is not satisfied, hence there is a contradiction\r\nand there must be 2 Os and 2 Xs within a subgrid that does not lie on\r\nany of the gridâs corners.Next, consider a subgrid that does not lie on\r\nany of the gridâs corners. Within the subgrid, at least one sub-subgrid\r\nis one of the four patterns below. We will call the following patterns .\r\nAssume the contrary that none of the 4 sub-subgrids in the subgrid are\r\none of the four given patterns. This naturally means every two cells\r\nwhich share an edge have different shapes. This gives the following two\r\npatterns:The diagonals have the same shape, so the condition is not\r\nsatisfied. There is a contradiction, hence the claim is true.Next,\r\nconsider a subgrid that does not lie on any of the gridâs corners. (We\r\nhave proved its existence in Claim 2.)Finally, it is possible to\r\nuniquely extend a good subgrid to the rest of the grid. For example, you\r\ncan see in the illustration below, after a few unique logical deductions\r\nthe grey pattern on the top can tesselate itself a few times, and this\r\ncan be infinitely repeated.Therefore, the entire grid must be\r\ntesselations of one of the four good patterns. The first two patterns\r\nmay be shifted one column to the right, and the last two patterns may be\r\nshifted one column downwards. So there are a total of ways to satisfy\r\nthe condition.Specifically, the ways for are as follows:As for some\r\nimplementation details, the following statements each correspond to one\r\nconfiguration that satisfies the condition. represents whether the cell\r\non the -th row and the -th column () has a circle-shaped fortune cookie.\r\niff is odd. iff is even. iff is odd. iff is even. iff is odd. iff is\r\neven. iff is odd. iff is even. Try to solve the problem for general .\r\nSpecifically that includes the cases when .\r\n",
    "hint": []
}