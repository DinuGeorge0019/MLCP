{
    "link": "https://codeforces.com//contest/1409/problem/F",
    "problemId": "716930",
    "problem_idx": "F",
    "shortId": "1409F",
    "contest_number": "1409",
    "problem_submissions": {
        "F": [
            91841452,
            91841006,
            91847094,
            91849145,
            91853876,
            91853063,
            91844676,
            91826529,
            91863527,
            91862569,
            91861696,
            91867633,
            91863103,
            91860709,
            91861645,
            91851313,
            91859301,
            91874305,
            91863916,
            91868988
        ],
        "E": [
            91827324,
            91839984,
            91836314,
            91835556,
            91831349,
            91852207,
            91886381,
            91857615,
            91843090,
            91845624,
            91838339,
            91851120,
            91837678,
            91852948,
            91866189,
            91853121,
            91849423,
            91856636,
            91853663
        ],
        "D": [
            91824220,
            91828702,
            91829052,
            91826254,
            91834063,
            91852756,
            91824308,
            91834176,
            91832475,
            91841859,
            91848714,
            91840119,
            91835288,
            91844671,
            91837282,
            91846495,
            91838632
        ],
        "C": [
            91818297,
            91820814,
            91822012,
            91821252,
            91820474,
            91823540,
            91825047,
            91828813,
            91828605,
            91824227,
            91820725,
            91829115,
            91823214,
            91824095,
            91821560,
            91823224,
            91828004,
            91829526
        ],
        "B": [
            91812965,
            91813416,
            91816401,
            91808485,
            91814835,
            91816697,
            91810019,
            91810994,
            91822185,
            91815944,
            91811525,
            91819746,
            91813210,
            91817451,
            91814034,
            91810729,
            91815998,
            91816789
        ],
        "A": [
            91801654,
            91804481,
            91803475,
            91801145,
            91812176,
            91802127,
            91801025,
            91800872,
            91805502,
            91801293,
            91801197,
            91802135,
            91802754,
            91805435,
            91802071,
            91800716,
            91803654,
            91812308
        ]
    },
    "name": "F. Subsequences of Length Two",
    "statement": "You are given two strings s and t consisting of lowercase Latin letters.\r\nThe length of t is 2 (i.e. this string consists only of two\r\ncharacters).In one move, you can choose character of s and replace it\r\nwith lowercase Latin letter. More formally, you choose some i and\r\nreplace s_i (the character at the position i) with some character from \u201d\r\nto \u201d.You want to do k replacements in such a way that the number of\r\noccurrences of t in s as a .Recall that a subsequence is a sequence that\r\ncan be derived from the given sequence by deleting zero or more elements\r\nwithout changing the order of the remaining elements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long lli;\ntypedef pair<int, int> ii;\ntypedef pair<lli, lli> ll;\n\nint n, memo[205][205][205];\nchar s[205], t[5];\n\nint dp(int p, int a, int k) {\n\tint ret = 0;\n\tif (p == n)\n\t\treturn 0;\n\tif (memo[p][a][k] != -1)\n\t\treturn memo[p][a][k];\n\tif ((s[p] == t[0]) && (s[p] == t[1]))\n\t\tret = max(ret, dp(p + 1, a + 1, k) + a);\n\telse if (s[p] == t[0])\n\t\tret = max(ret, dp(p + 1, a + 1, k));\n\telse if (s[p] == t[1])\n\t\tret = max(ret, dp(p + 1, a, k) + a);\n\telse\n\t\tret = max(ret, dp(p + 1, a, k));\n\tif (k > 0) {\n\t\tif (t[0] == t[1])\n\t\t\tret = max(ret, dp(p + 1, a + 1, k - 1) + a);\n\t\telse {\n\t\t\tret = max(ret, dp(p + 1, a + 1, k - 1));\n\t\t\tret = max(ret, dp(p + 1, a, k - 1) + a);\n\t\t}\n\t}\n\tmemo[p][a][k] = ret;\n\treturn ret;\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d %s %s\", &n, &k, s, t);\n\tmemset(memo, -1, sizeof memo);\n\tprintf(\"%d\\n\", dp(0, 0, k));\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Subsequences of Length Two.json",
    "editorial_link": "https://codeforces.com//blog/entry/82284",
    "editorial": "I\u00e2\u0080\u0099m almost sure this problem can be solved faster and with greater\r\nconstraints but this version is fine for the last problem.Consider both\r\nstrings -indexed and let\u00e2\u0080\u0099s do the dynamic programming . It means the\r\nmaximum number of occurrences of if we considered first characters of ,\r\ndid moves and the number of characters is . The answer to the problem is\r\n. Initially all states are and is . What about transitions? There are\r\nessentially three types of them: don\u00e2\u0080\u0099t change the current character,\r\nchange the current character to and change the current character to\r\n.Let\u00e2\u0080\u0099s create three additional variables to make our life easier (if\r\nthat were true...). is if and otherwise, is if and otherwise and is if\r\nand otherwise. Now let\u00e2\u0080\u0099s make and describe our transitions: Don\u00e2\u0080\u0099t change\r\nthe -th character:.The expression is just ternary if statement: if is\r\ntrue, return , otherwise return . So, the number of characters increases\r\nif equals and the answer increases if the -th character equals (because\r\nwe added all occurrences that end in the -th character). Change the -th\r\ncharacter to (possible only when ):.The number of characters always\r\nincreases and the answer increases if equals by the same reason as in\r\nthe previous transition. Change the -th character to (possible only when\r\n):.The number of characters increases only if and the answer always\r\nincreases.Note that we always increase the number of moves in the second\r\nand the third transitions even when equals or because this case is\r\nhandled in the first transition, so we don\u00e2\u0080\u0099t care.Time complexity:\r\n.There are also some greedy approaches which work in with pretty small\r\nconstant and can be optimized even further.\r\n"
}