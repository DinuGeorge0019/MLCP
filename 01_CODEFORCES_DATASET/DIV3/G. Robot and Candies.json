{"link": "https://codeforces.com//contest/1611/problem/G", "problemId": "1202191", "problem_idx": "G", "shortId": "1611G", "contest_number": "1611", "problem_submissions": {"G": [136919698, 136924345, 136928058, 137125236], "D": [136909432, 136888068, 136869096, 136875871, 136873458, 136872703, 136892897, 136874114, 136878310, 136876576, 136982847, 136873530, 136877831, 136975464, 136882777, 136872332, 136878705, 136879548, 136882637, 136884556, 136875995, 136885445], "C": [136904645, 136879235, 136858847, 136855243, 136861532, 136858913, 136876501, 136863657, 136864973, 136856130, 136982821, 136863847, 136868283, 136968820, 136869195, 136914947, 136862897, 136869863, 136862192, 136866525, 136860324, 136867113], "F": [136894434, 136926092, 136925788, 136894423, 136887654, 136898905, 136890793, 136892527, 136897622, 136914432, 136920232, 136982943, 136925360, 136906595, 136919174, 136903703, 136921493, 136918298, 136922728, 136905212, 136914690, 136921349], "E2": [136882323, 136916663, 136883396, 136897153, 136890210, 136911911, 136900593, 136909227, 136895787, 136903952, 136982885, 136896820, 136917983, 136900669, 136888044, 136899257, 136899662, 136904447, 136915639, 136920739, 136912069], "E1": [136879967, 136917077, 136876615, 136879938, 136883345, 136903050, 136866650, 136906813, 136891861, 136885925, 136982868, 136892962, 136889119, 136896344, 136885342, 136893182, 136895321, 136895279, 136895954, 136895593, 136897796], "B": [136853549, 136850019, 136845917, 136846742, 136848311, 136849660, 136855952, 136851245, 136847523, 136844081, 136855128, 136851469, 136843577, 136850258, 136848183, 136852060, 136853372, 136855929, 136847562, 136850988], "A": [136844450, 136846022, 136842097, 136842084, 136843783, 136847130, 136842440, 136842943, 136843633, 136841984, 136846854, 136846415, 136848083, 136843263, 136843590, 136843624, 136845033, 136842923, 136842870, 136846917]}, "name": "G. Robot and Candies", "statement": "Polycarp has a rectangular field of n\r\ntimes m cells (the size of the n\r\ncdot m field does not exceed 10^6 cells, m\r\nge 2), in each cell of which there can be candy. There are n rows and m\r\ncolumns in the field.Let\u2019s denote a cell with coordinates x vertically\r\nand y horizontally by (x, y). Then the top-left cell will be denoted as\r\n(1, 1), and the bottom-right cell will be denoted as (n, m).If there is\r\ncandy in the cell, then the cell is marked with the symbol \u201d, otherwise\r\nwith the symbol \u201d.Polycarp made a Robot that can collect candy. The\r\nRobot can move from (x, y) either to (x+1, y+1), or to (x+1, y-1). If\r\nthe Robot is in a cell that contains candy, it takes it.While there is\r\nat least one candy on the field, the following procedure is executed:\r\nPolycarp puts the Robot in an arbitrary cell on the of the field. He\r\nhimself chooses in which cell to place the Robot. It is allowed to put\r\nthe Robot in the same cell multiple times. The Robot moves across the\r\nfield and collects candies. He controls the Robot. When the Robot leaves\r\nthe field, Polycarp takes it. If there are still candies left, Polycarp\r\nrepeats the procedure. Find the number of times Polycarp needs to put\r\nthe Robot on the topmost row of the field in order to collect all the\r\ncandies. It is guaranteed that Polycarp can always collect all the\r\ncandies.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing ld = long double;\ntypedef std::pair<ld,ld> pii;\ntypedef std::pair<pii,pii> ppp;\nint main()\n{\n    int t;\n    std::cin>>t;\n    for(int __=0;__!=t;++__){\n        int N,M;\n        std::cin>>N>>M;\n        std::string ss[N]={};\n        for(auto&x:ss)std::cin>>x;\n        int total=0;\n        {\n            std::vector<ppp> vec;\n            for(int i=0;i!=N;++i){\n                for(int j=0;j!=M;++j){\n                    if((i&1)==(j&1))\n                    if(ss[i][j]=='1'){\n                        int s=j,t=i;\n                        vec.push_back({{t-s,s+t},{s,t}});\n                    }\n                }\n            }\n            std::sort(vec.begin(),vec.end());\n            std::reverse(vec.begin(),vec.end());\n            std::vector<ld> pilha;\n            int resps[N][3]={};\n            for(int _=0;_!=vec.size();++_){\n                ld x = vec[_].first.second;\n                auto it = std::lower_bound(pilha.begin(),pilha.end(),x);\n                if(it==pilha.end()){\n                    pilha.push_back(x);\n                }else {\n                    *it=x;\n                }\n            }\n            total+=pilha.size();\n        }\n        {\n            std::vector<ppp> vec;\n            for(int i=0;i!=N;++i){\n                for(int j=0;j!=M;++j){\n                    if((i&1)!=(j&1))\n                    if(ss[i][j]=='1'){\n                        int s=j,t=i;\n                        vec.push_back({{t-s,s+t},{s,t}});\n                    }\n                }\n            }\n            std::sort(vec.begin(),vec.end());\n            std::reverse(vec.begin(),vec.end());\n            std::vector<ld> pilha;\n            for(int _=0;_!=vec.size();++_){\n                ld x = vec[_].first.second;\n                auto it = std::lower_bound(pilha.begin(),pilha.end(),x);\n                if(it==pilha.end()){\n                    pilha.push_back(x);\n                }else {\n                    auto dist = it-pilha.begin();\n                    *it=x;\n                }\n            }\n            total+=pilha.size();\n        }\n        std::cout<<total<<\"\\n\";\n    }\n}\n"], "input": "", "output": "", "tags": ["data structures", "graph matchings", "greedy"], "dificulty": "2500", "interactive": false}