{
    "link": "https://codeforces.com//contest/1196/problem/F",
    "problemId": "377796",
    "problem_idx": "F",
    "shortId": "1196F",
    "contest_number": "1196",
    "problem_submissions": {
        "F": [
            57681700,
            57688661,
            57693585,
            57690559,
            57665659,
            57695119,
            57781679,
            83242061,
            57916383,
            68726830,
            82270831
        ],
        "B": [
            57673541,
            57649544,
            57652269,
            57654230,
            57679335,
            57653669,
            57651478,
            57654275,
            57652865,
            57652183,
            103121358,
            59232415,
            57652308,
            57652960,
            57653412,
            57655574,
            58261889,
            57653528,
            57654061,
            57651928,
            57655085,
            57658491,
            57652103
        ],
        "A": [
            57662145,
            57646582,
            57648135,
            57648211,
            57648294,
            57649147,
            57647064,
            57648725,
            57646690,
            57646929,
            57647619,
            57646915,
            57649771,
            57648481,
            58261863,
            57647513,
            57649572,
            57646786,
            57647851,
            57652602,
            57647144
        ],
        "E": [
            57660066,
            57677485,
            57675366,
            57677436,
            57681282,
            57677830,
            57673842,
            57672850,
            57676048,
            57682764,
            57679085,
            57680414,
            57680019,
            57677517,
            58261965,
            57678819,
            57684523,
            57681696,
            57679722,
            57677290,
            57678640
        ],
        "C": [
            57658492,
            57654354,
            57658481,
            57657615,
            57689981,
            57659504,
            57656630,
            57658570,
            57658429,
            57659478,
            57661824,
            57660864,
            57657934,
            57660478,
            58261906,
            57662669,
            57660523,
            57674035,
            57662185,
            57663396,
            57666540
        ],
        "D1": [
            57651996,
            57658879,
            57661770,
            57666118,
            57654079,
            57666561,
            57662530,
            57664730,
            57663635,
            57664913,
            57668860,
            57664436,
            57664910,
            57666776,
            58261921,
            57667464,
            57664679,
            57661598,
            57670813,
            57668128,
            57657381
        ],
        "D2": [
            57650929,
            57658567,
            57664847,
            57665451,
            57654443,
            57666008,
            57663080,
            57665252,
            57667224,
            57664331,
            57668491,
            57667512,
            57669290,
            57667407,
            58261939,
            57671667,
            57668510,
            57661989,
            57670493,
            57667835,
            57657749
        ]
    },
    "name": "F. K-th Path",
    "statement": "You are given a connected undirected weighted graph consisting of n\r\nvertices and m edges.You need to print the k-th smallest shortest path\r\nin this graph (paths from the vertex to itself are not counted, paths\r\nfrom i to j and from j to i are counted as one).More formally, if d is\r\nthe matrix of shortest paths, where d_{i, j} is the length of the\r\nshortest path between vertices i and j (1\r\nle i < j\r\nle n), then you need to print the k-th element in the sorted array\r\nconsisting of all d_{i, j}, where 1\r\nle i < j\r\nle n.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\ntypedef long long ll;\n#define pa pair<ll,int>\n#define mkp make_pair\nusing namespace std;\nint n,m,k,lenE;\nll dis[810][810];\nstruct ed{\n    int x,y,z;\n    bool operator<(const ed &x)const{return z<x.z;}\n}E[200010],newE[810];\nstruct edge{\n    int to,next,v;\n}e[400010];\nint head[200010],cnt;\ninline void ins(int u,int v,int w)\n{\n    e[++cnt].to=v;\n    e[cnt].next=head[u];\n    e[cnt].v=w;\n    head[u]=cnt;\n}\ninline void insert(int u,int v,int w)\n{\n    ins(u,v,w);\n    ins(v,u,w);\n}\nbool vis[810];\npriority_queue<pa,vector<pa>,greater<pa> >q;\ninline void dijkstra(int cur,ll dis[810],int S)\n{\n    for (int i=1;i<=cur;i++)dis[i]=-1,vis[i]=0;\n    dis[S]=0;q.push(mkp(0,S));\n    while (!q.empty())\n    {\n        int now=q.top().second;q.pop();\n        if (vis[now])continue;vis[now]=1;\n        for(int i=head[now];i;i=e[i].next)\n        if(dis[e[i].to]==-1||dis[now]+e[i].v<dis[e[i].to])\n        {\n            dis[e[i].to]=dis[now]+e[i].v;\n            q.push(mkp(dis[e[i].to],e[i].to));\n        }\n    }\n}\nmap<pa,int>mp;\nmap<int,int>mp2;\nvector<int>pnt;\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&k);\n    if (n-1>=k)\n    {\n        for (int i=1;i<=m;i++)\n        {\n            int x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n            E[i]={x,y,z};\n        }\n        sort(E+1,E+m+1);\n        int res=k;\n        for (int i=1;i<=m;i++)\n        {\n            if (mp[{E[i].x,E[i].y}])continue;\n            mp[{E[i].x,E[i].y}]=1;\n            mp[{E[i].y,E[i].x}]=1;\n            newE[++lenE]={E[i].x,E[i].y,E[i].z};\n            mp2[E[i].x]=1;\n            mp2[E[i].y]=1;\n            res--;\n            if (!res)break;\n        }\n        int cur=0;\n        for (auto i=mp2.begin();i!=mp2.end();i++)\n        {\n            i->second=++cur;\n        }\n        for (int i=1;i<=lenE;i++)\n        {\n            insert(mp2[E[i].x],mp2[E[i].y],E[i].z);\n        }\n        for (int i=1;i<=cur;i++)dijkstra(cur,dis[i],i);\n        vector<ll>d;\n        for (int i=1;i<=cur;i++)\n            for (int j=i+1;j<=cur;j++)\n                if (~dis[i][j])d.push_back(dis[i][j]);\n        sort(d.begin(),d.end());\n        printf(\"%lld\\n\",d[k-1]);\n        return 0;\n    }\n    memset(dis,-1,sizeof dis);\n    for (int i=1;i<=m;i++)\n    {\n        int x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n        if(dis[x][y]==-1||dis[x][y]>z)dis[x][y]=dis[y][x]=z;\n    }\n    for (int k=1;k<=n;k++)\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=n;j++)if (~dis[i][k]&&~dis[k][j])\n            {\n                if (dis[i][j]==-1||dis[i][j]>dis[i][k]+dis[k][j])\n                    dis[i][j]=dis[i][k]+dis[k][j];\n            }\n    vector<ll>d;d.clear();\n    for (int i=1;i<=n;i++)\n        for (int j=i+1;j<=n;j++)\n        {\n            if(~dis[i][j])d.push_back(dis[i][j]);\n        }\n    sort(d.begin(),d.end());\n    printf(\"%lld\\n\",d[k-1]);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. K-th Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/68655",
    "editorial": "The main observation is that you donât need more than smallest by weight\r\nedges (among all edges with the maximum weights you can choose any).\r\nMaybe there will be a proof later, but now I ask other participant to\r\nwrite it.So you sort the initial edges and after that you can construct\r\na graph consisting of no more than vertices and no more than edges. You\r\njust can build the new graph consisting only on these vertices and edges\r\nand run Floyd-Warshall algorithm to find the matrix of shortest paths.\r\nThen sort all shorted distances and print the -th element of this sorted\r\narray.Time complexity: .I know that there are other approaches that can\r\nsolve this problem with greater , but to make this problem easily this\r\nsolution is enough.\r\n",
    "hint": []
}