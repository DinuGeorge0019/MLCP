{"link": "https://codeforces.com//contest/1283/problem/D", "problemId": "504970", "problem_idx": "D", "shortId": "1283D", "contest_number": "1283", "problem_submissions": {"F": [67823245, 67834634, 67835859, 67839332, 67838778, 68029277, 67864524], "E": [67815384, 67819003, 67822271, 67817278, 67817529, 67816830, 67820462, 67815674, 67819758, 67822559, 67825595, 67826555, 67825514, 67818583, 67817970, 67826757], "D": [67813119, 67814942, 67816390, 67814327, 67815165, 67820564, 67815719, 67818760, 67815953, 67817694, 67816237, 67818386, 67815983, 67828465, 67827664, 67818584], "C": [67810342, 67821978, 67810773, 67807591, 67808305, 67810663, 67811193, 67813438, 67808771, 67811324, 67808499, 67810527, 67810581, 67811981, 67810947, 67812828], "B": [67801292, 67798549, 67803137, 67801302, 67801574, 67803276, 67803578, 67802026, 67802576, 67803714, 67801063, 67802206, 67802199, 67800040, 67804358, 67805065], "A": [67797268, 67797074, 67797886, 67797463, 67797278, 67797741, 67798798, 67797264, 67798057, 67798392, 67797423, 67797193, 67798258, 67797376, 67798881, 67799553]}, "name": "D. Christmas Trees", "statement": "There are n Christmas trees on an infinite number line. The i-th tree\r\ngrows at the position x_i. All x_i are guaranteed to be distinct.Each\r\npoint can be either occupied by the Christmas tree, by the human or not\r\noccupied at all. Non-integer points cannot be occupied by anything.There\r\nare m people who want to celebrate Christmas. Let y_1, y_2,\r\ndots, y_m be the positions of people (note that all values x_1, x_2,\r\ndots, x_n, y_1, y_2,\r\ndots, y_m should be and all y_j should be ). You want to find such an\r\narrangement of people that the value\r\nsum\r\nlimits_{j=1}^{m}\r\nmin\r\nlimits_{i=1}^{n}|x_i - y_j| is the minimum possible (in other words, the\r\nsum of distances to the nearest Christmas tree for all people should be\r\nminimized).In other words, let d_j be the distance from the j-th human\r\nto the nearest Christmas tree (d_j =\r\nmin\r\nlimits_{i=1}^{n} |y_j - x_i|). Then you need to choose such positions\r\ny_1, y_2,\r\ndots, y_m that\r\nsum\r\nlimits_{j=1}^{m} d_j is the minimum possible.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n, m;\n\nint x[MAXN];\n\nlli val;\n\nvector< int > ans;\n\nmap< int , int > dist;\nmap< int , bool > marc;\n\nqueue< int > q;\n\nvoid add(int i, int d, bool t)\n{\n\tq.push( i );\n\n\tdist[ i ] = d;\n\tmarc[ i ] = true;\n\n\tval += d;\n\n\tif( t ) ans.push_back( i );\n}\n\nvoid BFS()\n{\n\twhile( !q.empty() && ans.size() < m )\n\t{\n\t\tint cur = q.front();\n\t\tq.pop();\n\n\t\tint L = cur - 1;\n\t\tint R = cur + 1;\n\n\t\tif( !marc[L] ) add( L , dist[cur] + 1 , true );\n\n\t\tif( ans.size() >= m ) break;\n\n\t\tif( !marc[R] ) add( R , dist[cur] + 1 , true );\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tscanf(\"%d\",&x[i]);\n\t\tadd( x[i] , 0 , false );\n\t}\n\n\tBFS();\n\n\tprintf(\"%lld\\n\",val);\n\n\tsort( ans.begin() , ans.end() );\n\n\tfor(int i = 0 ; i < m ; i++)\n\t\tprintf(\"%d \",ans[i]);\n}"], "input": "", "output": "", "tags": ["graphs", "greedy", "shortest paths"], "dificulty": "1800", "interactive": false}