{"link": "https://codeforces.com//contest/1551/problem/F", "problemId": "1055226", "problem_idx": "F", "shortId": "1551F", "contest_number": "1551", "problem_submissions": {"D2": [123504570, 123491119, 123485402, 123508709, 123487387, 123490299, 123498497, 123519517, 123503570, 123507308, 123506328, 123496338, 123525324, 123509854, 123500000, 123499688, 123500681, 123520243, 123521810, 123560543, 123489816], "D1": [123496540, 123479404, 123460900, 123501007, 123476769, 123477339, 123486676, 123509110, 123490131, 123493249, 123493173, 123482125, 123490880, 123500902, 123489510, 123491442, 123487788, 123505201, 123513198, 123560527, 123477927], "E": [123487760, 123503517, 123508061, 123512161, 123512376, 123522062, 123512340, 123494473, 123520187, 123519199, 123522642, 123508385, 123509676, 123525566, 123522562, 123529567, 123525043, 123524224, 123527690, 123529206], "F": [123483346, 123518773, 123505149, 123522554, 123530029, 123525813, 123677834], "C": [123463062, 123471764, 123465961, 123494616, 123466015, 123470689, 123479667, 123473982, 123478387, 123473235, 123485341, 123504214, 123476344, 123474463, 123482794, 123487070, 123509871, 123495332, 123505971, 123560511, 123471519], "B1": [123458055, 123450157, 123447323, 123480992, 123471662, 123459271, 123448891, 123453516, 123457018, 123473105, 123465306, 123457521, 123473064, 123450150, 123457907, 123454507, 123450845, 123454392, 123459478, 123486711, 123560483, 123451550], "B2": [123455203, 123463888, 123460727, 123523874, 123456743, 123463349, 123471479, 123467608, 123467523, 123462292, 123471295, 123468067, 123463785, 123466840, 123469959, 123475307, 123473651, 123478743, 123500344, 123560494, 123462370], "A": [123443367, 123443254, 123447159, 123446121, 123445546, 123443509, 123444177, 123443572, 123444116, 123444163, 123445991, 123474697, 123444077, 123443229, 123447862, 123443364, 123443226, 123449045, 123446138, 123560465, 123443541]}, "name": "F. Equidistant Vertices", "statement": "A tree is an undirected connected graph without cycles.You are given a\r\ntree of n vertices. Find the number of ways to choose exactly k vertices\r\nin this tree (i. e. a k-element subset of vertices) so that all pairwise\r\ndistances between the selected vertices are equal (in other words, there\r\nexists an integer c such that for all u, v (u\r\nne v, u, v are in selected vertices) d_{u,v}=c, where d_{u,v} is the\r\ndistance from u to v).Since the answer may be very large, you need to\r\noutput it modulo 10^9 + 7.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\nconst int M = 1000000007;\nconst int MM = 998244353;\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2351\n#endif\n\n    \nconst int MOD=1000000007;\nstruct Mint {\n    int val;\n \n    Mint(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n        if (v >= MOD)\n            v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        int g = m, r = a, x = 0, y = 1;\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        } \n        return x < 0 ? x + m : x;\n    } \n    explicit operator int() const {\n        return val;\n    }\n    Mint& operator+=(const Mint &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    Mint& operator-=(const Mint &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n           #if !defined(_WIN32) || defined(_WIN64)\n                return x % m;\n           #endif\n           unsigned x_high = x >> 32, x_low = (unsigned) x;\n           unsigned quot, rem;\n           asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n           return rem;\n    }\n    Mint& operator*=(const Mint &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n    Mint& operator/=(const Mint &other) {\n        return *this *= other.inv();\n    }\n    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }\n    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }\n    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }\n    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }\n    Mint& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n    Mint& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }\n    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }\n    Mint operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n    bool operator==(const Mint &other) const { return val == other.val; }\n    bool operator!=(const Mint &other) const { return val != other.val; }\n    Mint inv() const {\n        return mod_inv(val);\n    }\n    Mint power(long long p) const {\n        assert(p >= 0);\n        Mint a = *this, result = 1;\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n        return result;\n    }\n    friend ostream& operator << (ostream &stream, const Mint &m) {\n        return stream << m.val;\n    }\n    friend istream& operator >> (istream &stream, Mint &m) {\n        return stream>>m.val;   \n    }\n};\n\n\nint _runtimeTerror_()\n{\n    int n,k;\n    cin >> n >> k;\n    vector<vector<int>> g(n+1);\n    for(int i=1;i<=n-1;++i)\n    {\n        int x,y;\n        cin >> x >> y;\n        g[x].push_back(y),g[y].push_back(x);\n    }\n    vector<int> dep(n+1);\n    Mint ans = 0;\n    vector<vector<int>> cnt(n+1,vector<int>(n+1,0));\n    int have = 0;\n    function<void(int,int,int)> dfs = [&](int s,int p,int tt)\n    {\n        int cur = 0;\n        ++cnt[dep[s]][tt];\n        for(auto &j:g[s])\n        {\n            if(j != p)\n            {\n                dep[j] = dep[s] + 1;\n                if(p == 0)\n                    dfs(j,s,++cur);\n                else\n                    dfs(j,s,tt);\n            }\n        }\n        if(p == 0)\n            have = cur;\n    };\n    if(k == 2)\n    {\n        cout << Mint(n) * Mint(n-1)/2 << \"\\n\";\n        return 0;\n    }\n    int K = k;\n    for(int i=1;i<=n;++i)\n    {\n        for(int j=0;j<=n;++j)\n        {\n            for(int k=0;k<=n;++k)\n                cnt[j][k] = 0;\n            dep[j] = 0;\n        }\n        dfs(i,0,0);\n        vector<vector<Mint>> dp(have+1,vector<Mint>(k+1,0));\n        debug(have);\n        // continue;\n        for(int j=1;j<=n;++j)\n        {\n            int t = 0;\n            vector<int> want;\n            for(int k=1;k<=have;++k)\n            {\n                if(cnt[j][k] > 0)\n                    want.push_back(cnt[j][k]);\n            }\n            t = sz(want);\n            debug(i,j,want);\n            if(t < K)\n                break;\n            for(int k=1;k<=t;++k)\n                for(int l=0;l<=K;++l)\n                    dp[k][l] = 0;\n            dp[0][0] = 1;\n            for(int x=1;x<=t;++x)\n            {\n                for(int l=0;l<=K;++l)\n                {\n                    if(l == 0)\n                        dp[x][l] = dp[x-1][l];\n                    else\n                        dp[x][l] = dp[x-1][l] + dp[x-1][l-1] * want[x-1];\n                }\n            }\n            ans += dp[t][K];\n        }\n        // debug(i,int(ans));\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "combinatorics", "dfs and similar", "dp", "trees"], "dificulty": "2200", "interactive": false}