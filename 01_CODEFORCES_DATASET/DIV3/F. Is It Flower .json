{"link": "https://codeforces.com//contest/1811/problem/F", "problemId": "1864328", "problem_idx": "F", "shortId": "1811F", "contest_number": "1811", "problem_submissions": {"D": [200754699, 200776097, 200739331, 200726520, 200726373, 200739709, 200727620, 200738822, 200747547, 200759872, 200759241, 200755197, 200743077, 200739694, 200732035, 200829329, 200737167, 200752747, 201109379, 200751007, 200768259, 200755335], "C": [200736628, 200766081, 200730565, 200712627, 200719542, 200722259, 200709529, 200720517, 200728620, 200721825, 200720940, 200720985, 200725767, 200879176, 200829313, 200722588, 200730813, 201109333, 200731130, 200718431, 200716271], "E": [200723606, 200703078, 200750795, 200749843, 200716143, 200712796, 200731621, 200716868, 200723986, 200707830, 200710920, 200730415, 200743490, 200719631, 200829343, 200754433, 200735492, 201109566, 200738090, 200759827, 200722483], "A": [200719784, 200697693, 200709735, 200697878, 200695570, 200704142, 200696911, 200699911, 200693442, 200693354, 200694979, 200699076, 200694846, 200829295, 200700499, 200698275, 201109090, 200699672, 200700596, 200701647], "G2": [200717686, 200742559, 200770344, 200958696, 201374187, 200831218, 200831193], "G1": [200709506, 200742442, 200769728, 200763697, 200744953, 200746011, 200720480, 200748735, 200760247, 200772203, 200771883, 200769679, 200758537, 200829373, 200780627, 200774881, 201171573, 200757032], "B": [200708366, 200716585, 200706793, 200704223, 200701078, 200703012, 200714270, 200697883, 200700006, 200701394, 200706383, 200878903, 200709089, 200704797, 200829301, 200712812, 200723595, 201109130, 200726473, 200716074, 200734848], "F": [200764192, 200777349, 200768176, 201109661, 200843383, 200769121, 201693689, 201686646, 200776061]}, "name": "F. Is It Flower ", "statement": "Vlad found a flowerbed with graphs in his yard and decided to take one\r\nfor himself. Later he found out that in addition to the usual graphs,\r\nk-flowers also grew on that flowerbed. A graph is called a k-flower if\r\nit consists of a simple cycle of length k, through each vertex of which\r\npasses its own simple cycle of length k and these cycles do not\r\nintersect at the vertices. For example, 3-flower looks like this: Note\r\nthat 1-flower and 2-flower do not exist, since at least 3 vertices are\r\nneeded to form a cycle.Vlad really liked the structure of the k-flowers\r\nand now he wants to find out if he was lucky to take one of them from\r\nthe flowerbed.\r\n", "solutions": ["#define _CRT_SECURE_NO_WARNINGS//MSVC compiler\n#include <cstdio>//cstdio fan\n#include <cstring>//strlen\n#include <cstdint>\n#include <cmath>\n//#include <cstdlib>\n//#include <cctype>\n//#include <type_traits>\n//#include <string>\n//#include <iostream>\n#include <algorithm>\n#include <iterator>\n//#include <array>\n//#include <vector>\n#include <map>\n#include <numeric>\n#include <array>\n//#include <tuple>\n//#include <queue>\n//#include <set>\n//#include <bitset>\n#include <bit>\n#ifdef ON_PC\n#include <chrono>\n#include <cassert>\n#else\n#define assert(v) {}\n#endif//ON_PC    \n\nusing u = unsigned;\nusing u64 = uint64_t;\n\n#ifdef ON_PC\nconstexpr u N = u(500);\n#else\nconstexpr u N = u(2e5);\n#endif//ON_PC    \nconstexpr u N2 = std::bit_ceil(N);\nconstexpr u64 mod = u(1e9)+7;\n\nu n, m, k;\n\nu deg[N];\nbool vis[N];\n\nstd::vector<u> childs[N];\nstd::vector<u> main_cycle;\n\nvoid solve() {\n    scanf(\"%u%u\", &n, &m);\n    k = std::sqrt(n);\n    if (k * k != n || (k+1)*k != m) { // invalid V|E count\n        for (u i = 0, u, v; i < m; i++) scanf(\"%u%u\", &u, &v);\n        puts(\"NO\");\n        return;\n    }\n    std::memset(deg, 0, sizeof(u) * n);\n    for (u i = 0; i < n; i++) childs[i].clear();\n    for (u i = 0, u, v; i < m; i++) scanf(\"%u%u\", &u, &v), u--, v--, deg[u]++, deg[v]++, childs[u].push_back(v), childs[v].push_back(u);\n    main_cycle.clear();\n    for (u i = 0; i < n; i++) {\n        if (deg[i] != 2 && deg[i] != 4) { // invalid degree\n            puts(\"NO\");\n            return;\n        }\n        if (deg[i] == 4) {\n            u cnt = 0;\n            for (u ch : childs[i]) {\n                cnt += deg[ch] == 4;\n            }\n            if (cnt != 2) { // invalid main cycle\n                puts(\"NO\");\n                return;\n            }\n            main_cycle.push_back(i);\n        }\n    }\n    if (main_cycle.size() != k) { // invalid main cycle len\n        puts(\"NO\");\n        return;\n    }\n\n    std::memset(vis, 0, n);\n    u cur = main_cycle[0]; // connected graph\n    u vis_cnt = 0;\n    while (!vis[cur]) {\n        vis[cur] = true;\n        vis_cnt += 1;\n        for (u ch : childs[cur]) {\n            if (deg[ch] == 4 && !vis[ch]) cur = ch;\n        }\n    }\n    if (vis_cnt != k) { // unconnected graph | more than 1 main cycle\n        puts(\"NO\");\n        return;\n    }\n\n    for (u v : main_cycle) {\n        u prev = v;\n        u cur = 0;\n        u len = 1;\n        for (u ch : childs[v]) {\n            if (deg[ch] != 4) cur = ch;\n        }\n        while (deg[cur] == 2) {\n            u pp = cur;\n            cur = childs[cur][0] == prev ? childs[cur][1] : childs[cur][0];\n            len++;\n            prev = pp;\n        }\n        if (len != k || cur != v) { // invalid \"leaf\" cycle\n            puts(\"NO\");\n            return;\n        }\n    }\n\n    puts(\"YES\");\n}\n//*///*\n\nint main() {\n#ifdef ON_PC\n    freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"t_output.txt\",\"w\",stdout);\n    try{auto beg = std::chrono::steady_clock::now();\n#endif//ON_PC\n    unsigned q = 1;scanf(\"%u\", &q);\n    //printf(\"%u\\n\", q);\n    while(q--) solve();//for CF solution\n#ifdef ON_PC\n    printf(\"\\nexecution time: %.8lf\\n\", std::chrono::duration<double>(std::chrono::steady_clock::now() - beg).count());\n    }catch(std::exception& ex){printf(\"e: %s\\n\", ex.what());}catch(int i){printf(\"e: %i\\n\", i);}catch(...){puts(\"e: [inv]\");}\n#endif//ON_PC\n}"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "implementation"], "dificulty": "2100", "interactive": false}