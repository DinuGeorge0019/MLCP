{
    "link": "https://codeforces.com//contest/1183/problem/G",
    "problemId": "363547",
    "problem_idx": "G",
    "shortId": "1183G",
    "contest_number": "1183",
    "problem_submissions": {
        "F": [
            56110414,
            56117769,
            56118798,
            66995010,
            56101090,
            56148730,
            138937022,
            56112000
        ],
        "E": [
            56097887,
            56113357,
            56105226,
            56104643,
            56101888,
            56093414,
            56111233,
            56103293,
            56103078,
            56104487,
            56109659,
            56103780,
            56109510,
            56105711,
            56106565
        ],
        "H": [
            56097697,
            56113570,
            56105740,
            66667587,
            56101720,
            56109616,
            56111456,
            56108240,
            56103716,
            56105330,
            56106283,
            56109916,
            56106467
        ],
        "G": [
            56092005,
            56104084,
            56123883,
            56112098,
            56110719,
            56101673,
            56117506,
            56115328,
            59651445,
            56098320,
            138935815
        ],
        "D": [
            56088183,
            56091373,
            56093338,
            56090767,
            56087401,
            56085787,
            56095559,
            56092469,
            56089592,
            56093522,
            56092856,
            56094699,
            56091582,
            56093930,
            56090315,
            56096981,
            56094561
        ],
        "C": [
            56084972,
            56088064,
            56089777,
            56097980,
            56081517,
            56107044,
            56091000,
            56085493,
            56085540,
            56091330,
            56090250,
            56088370,
            56086037,
            56089714,
            56086123
        ],
        "B": [
            56081558,
            56084832,
            56083510,
            59085942,
            56083305,
            56103674,
            56097880,
            56086061,
            56083097,
            56081660,
            56086915,
            56086136,
            56085025,
            56087421,
            56081700,
            56084942,
            56082678
        ],
        "A": [
            56080149,
            56079717,
            56079676,
            57264074,
            56080781,
            56088646,
            56082120,
            56081323,
            56079728,
            56079791,
            56082274,
            56082965,
            56079889,
            56079932,
            56079796
        ]
    },
    "name": "G. Candy Box  hard version ",
    "statement": "There are n candies in a candy box. The type of the i-th candy is a_i (1\r\nle a_i\r\nle n). You have to prepare a gift using some of these candies with the\r\nfollowing restriction: the numbers of candies of each type presented in\r\na gift should be all distinct (i. e. for example, a gift having two\r\ncandies of type 1 and two candies of type 2 is bad).. It is also\r\npossible that of some types will be taken to a gift.You really like some\r\nof the candies and don’t want to include them into the gift, but you\r\nwant to eat them yourself instead. For each candy, a number f_i is\r\ngiven, which is equal to 0 if you really want to keep i-th candy for\r\nyourself, or 1 if you don’t mind including it into your gift. It is\r\npossible that two candies of the same type have different values of\r\nf_i.You want your gift to be as large as possible, but you don’t want to\r\ninclude too many of the candies you want to eat into the gift. So, you\r\nwant to calculate the maximum possible number of candies that can be\r\nincluded into a gift, and among all ways to choose maximum number of\r\ncandies, you want to maximize the number of candies having f_i = 1 in\r\nyour gift.You have to answer q independent queries.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nll t,n,i,a[202020],d[202020],e[202020],has,sisa,z[202020],ta,f[202020],h2;\nvector<ll> isi[202020];\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tcin>>n;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tcin>>a[i]>>ta;\n\t\t\td[a[i]]++;\n\t\t\te[a[i]]++;\n\t\t\tf[a[i]]+=ta;\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\td[a[i]]--;\n\t\t\tif(d[a[i]]==0)\n\t\t\t{\n\t\t\t\tisi[e[a[i]]].pb(f[a[i]]);\n\t\t\t\tz[e[a[i]]]++;\n\t\t\t}\n\t\t}\n\t\thas=0;\n\t\th2=0;\n\t\tpriority_queue<ll> pq;\n\t\tsisa=0;\n\t\tfor(i=n;i>=1;i--)\n\t\t{\n\t\t\twhile(!isi[i].empty())\n\t\t\t{\n\t\t\t\tpq.push(isi[i].back());\n\t\t\t\tisi[i].pop_back();\n\t\t\t}\n\t\t\tif(!pq.empty())\n\t\t\t{\n\t\t\t\thas+=i;\n\t\t\t\th2+=min(i,pq.top());\n\t\t\t\tpq.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<has<<\" \"<<h2<<\"\\n\";\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\td[a[i]]=0;\n\t\t\te[a[i]]=0;\n\t\t\tf[a[i]]=0;\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Candy Box  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/68003",
    "editorial": "First of all, to maximize the number of candies in the gift, we can use\r\nthe following greedy algorithm: letâs iterate on the number of candies\r\nof some type we take from to backwards. For fixed , letâs try to find\r\nany suitable type of candies. A type is suitable if there are at least\r\ncandies of this type in the box. If there exists at least one such type\r\nthat wasnât used previously, letâs pick any such type and take exactly\r\ncandies of this type (and decrease ). It does not matter which type we\r\npick if we only want to maximize the number of candies we take.Okay,\r\nletâs now modify this solution to maximize the number of candies having\r\n. We initially could pick any type that has at least candies, but now we\r\nshould choose a type depending on the number of candies with in this\r\ntype. For example, if we have two types having and candies with\r\nrespectively, and we want to pick candies from one type and candies from\r\nanother type, and and , itâs better to pick candies of the first type\r\nand candies of the second type. In this case we have candies with , in\r\nthe other case itâs . And if and , then . So, when we want to pick a\r\ntype of candies such that we will take exactly candies of this type,\r\nitâs optimal to choose a type that wasnât used yet, contains at least\r\ncandies, and has maximum possible number of candies with . This best\r\ntype can be maintained with a multiset or a set of pairs.\r\n",
    "hint": []
}