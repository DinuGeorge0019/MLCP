{
    "link": "https://codeforces.com//contest/1154/problem/F",
    "problemId": "331482",
    "problem_idx": "F",
    "shortId": "1154F",
    "contest_number": "1154",
    "problem_submissions": {
        "G": [
            52855762,
            52851693,
            52883699,
            52890510,
            52889410,
            52873345,
            64071464,
            52852198,
            52889617,
            52938027,
            52899099,
            52883451,
            52933277
        ],
        "F": [
            52847525,
            52855540,
            52853802,
            52856499,
            52854684,
            52859289,
            52859188,
            52856934,
            52861411,
            52860421,
            52864456,
            52865823,
            52865674,
            52862756,
            52863204,
            52898461,
            52885308,
            52867718
        ],
        "E": [
            52844409,
            52843854,
            52845875,
            52851030,
            52848418,
            52851394,
            52850626,
            52850695,
            52853071,
            52854108,
            52854816,
            52860104,
            52857303,
            52865759,
            52865330,
            52848827,
            52846804,
            52847297,
            52851755
        ],
        "D": [
            52838256,
            52840530,
            52838159,
            52842046,
            52844146,
            52843431,
            52844055,
            52843180,
            52844776,
            52845105,
            52843951,
            52855282,
            52849507,
            52844126,
            52848629,
            52839874,
            52840662,
            52843194,
            52840788
        ],
        "C": [
            52833823,
            52836291,
            52835397,
            52837673,
            52839569,
            52838593,
            52840124,
            52839273,
            52840405,
            52841087,
            52841150,
            52840622,
            52844765,
            52838877,
            52843127,
            52835631,
            52837394,
            52838050,
            52836957
        ],
        "B": [
            52831026,
            52830367,
            52830898,
            52831597,
            52835486,
            52833452,
            52832490,
            52835076,
            52832847,
            52835796,
            52836031,
            52832592,
            52835180,
            52833364,
            52837330,
            52831701,
            52832070,
            52833675,
            52832455
        ],
        "A": [
            52828088,
            52827996,
            52828695,
            52828356,
            52829673,
            52830380,
            52828666,
            52830260,
            52828393,
            52830384,
            52829496,
            52829394,
            52828592,
            52828708,
            52833449,
            52828168,
            52828298,
            52828150,
            52828517
        ]
    },
    "name": "F. Shovels Shop",
    "statement": "There are n shovels in the nearby shop. The i-th shovel costs a_i\r\nbourles.Misha has to buy k shovels. Each shovel can be bought .Misha can\r\nbuy shovels by several purchases. During one purchase he can choose any\r\nsubset of remaining (non-bought) shovels and buy this subset.There are\r\nalso m special offers in the shop. The j-th of them is given as a pair\r\n(x_j, y_j), and it means that if Misha buys x_j shovels then y_j of them\r\nare for free (i.e. he will not pay for y_j most cheapest shovels during\r\nthe current purchase).Misha can use any offer any (possibly, zero)\r\nnumber of times, but he cannot use offer during (but he can buy shovels\r\nwithout using any offers).Your task is to calculate the minimum cost of\r\nbuying k shovels, if Misha buys them optimally.\r\n",
    "solutions": [
        "// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nconst size_t N = 2000 + 5;\n\nint main() {\n  int n = read(), m = read(), k = read();\n  vector<int> a(n + 1);\n  generate(a.begin() + 1, a.end(), read);\n  sort(a.begin() + 1, a.end());\n  a.erase(a.begin() + k + 1, a.end());\n  vector<int> sum(a.size());\n  partial_sum(a.begin(), a.end(), sum.begin());\n\n  vector<int> mx(k + 1), dp(k + 1, INT_MAX);\n  for (int i = 0; i < m; ++i) {\n    int x = read(), y = read();\n    if (x <= k && mx[x] < y) mx[x] = y;\n  }\n\n  dp[0] = 0;\n\n  auto chkMin = [](int &dp, int val) {\n    if (val < dp) dp = val;\n  };\n\n  for (int i = 0; i < k; ++i) {\n    for (int j = 1; i + j <= k; ++j) {\n      chkMin(dp[i + j], dp[i] + sum[i + j] - sum[i + mx[j]]);\n    }\n  }\n\n  cout << dp[k] << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Shovels Shop.json",
    "editorial_link": "https://codeforces.com//blog/entry/66586",
    "editorial": "First of all, since we are going to buy exactly shovels, we may discard\r\nmost expensive shovels from the input and set (and solve the problem\r\nwhich requires us to buy all the shovels). Also, letâs add an offer\r\nwhich allows us to buy shovel and get cheapest of them for free, to\r\nsimulate that we can buy shovels without using offers.Now we claim that\r\nif we sort all the shovels by their costs, itâs optimal to divide the\r\narray of costs into some consecutive subarrays and buy each subarray\r\nusing some offer. Why should the sets of shovels for all purchases be\r\nconsecutive subarrays? Suppose itâs not so: letâs pick two purchases\r\nsuch that they are \"mixed\" in the array of costs, i. e. there exists at\r\nleast one shovel bought in the first purchase such that there exists a\r\nshovel cheaper than it and a shovel more expensive than it, both bought\r\nin the second purchase. If shovel is for free, then we may \"swap\"\r\nshovels and , otherwise we may swap shovels and , and the answer wonât\r\nbecome worse. So, we can do it until all purchases correspond to\r\nsubsegments in the array of costs.Then itâs easy to see that we can make\r\npurchases in such a way that we always buy some amount of cheapest\r\nshovels. And now the problem can be solved by knapsack-like dynamic\r\nprogramming: let be the minimum cost to buy exactly cheapest shovels. is\r\n, and for each offer we can update by the value of , where is the sum of\r\ncosts of all shovels in the sorted order from shovel on position to\r\nshovel on position , inclusive (these sums can be calculated in using\r\npartial sums method).\r\n",
    "hint": []
}