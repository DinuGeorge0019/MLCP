{
    "link": "https://codeforces.com//contest/1328/problem/D",
    "problemId": "573970",
    "problem_idx": "D",
    "shortId": "1328D",
    "contest_number": "1328",
    "problem_submissions": {
        "F": [
            74521514,
            74458947,
            74467934,
            74459743,
            74477945,
            74479296,
            74477976,
            74460067,
            74479401,
            74451936,
            74481411,
            74517274,
            74469162,
            74751835,
            74484053,
            74570676,
            75069905
        ],
        "E": [
            74521498,
            74425897,
            74448868,
            74469722,
            74453344,
            74450430,
            74451583,
            74481242,
            74461079,
            74480712,
            74461492,
            74440509,
            74433950,
            74453485,
            74450187,
            74455849,
            74458845,
            74470218,
            74462427,
            74456809
        ],
        "D": [
            74521470,
            74418087,
            74432049,
            74443528,
            74433824,
            74440013,
            74434934,
            74442956,
            74448606,
            74468894,
            74434326,
            74418253,
            74446884,
            74422378,
            74433135,
            74445359,
            74444092,
            74446810,
            74436674,
            74439681,
            74436955
        ],
        "C": [
            74521449,
            74427519,
            74417294,
            74412670,
            74418245,
            74414924,
            74418343,
            74430971,
            74433882,
            74427388,
            74419673,
            74411543,
            74408681,
            74418088,
            74421292,
            74418723,
            74414986,
            74421425,
            74419827,
            74417279,
            74426221
        ],
        "B": [
            74521428,
            74410739,
            74410669,
            74414505,
            74408929,
            74424040,
            74412257,
            74445705,
            74430405,
            74422019,
            74402783,
            74408301,
            74420620,
            74406341,
            74415300,
            74411825,
            74407115,
            74413788,
            74409526,
            74409821,
            74428748
        ],
        "A": [
            74521413,
            74399723,
            74400111,
            74400161,
            74407479,
            74400948,
            74397437,
            74397606,
            74401496,
            74400048,
            74407625,
            74397552,
            74398246,
            74403424,
            74403420,
            74398403,
            74402962,
            74402324,
            74397768,
            74400852,
            74397419,
            74399350,
            74399074
        ]
    },
    "name": "D. Carousel",
    "statement": "The round carousel consists of n figures of animals. Figures are\r\nnumbered from 1 to n in order of the carousel moving. Thus, after the\r\nn-th figure the figure with the number 1 follows. Each figure has its\r\nown type the type of the animal corresponding to this figure (the horse,\r\nthe tiger and so on). The type of animal of the i-th figure equals t_i.\r\n. You want to color each figure in one of the colors. You think that\r\nit’s boring if the carousel contains two different figures (with the\r\ndistinct types of animals) going one right after another and colored in\r\nthe same color.Your task is to color the figures in such a way that the\r\nnumber of distinct colors used is the minimum possible and there are no\r\nfigures of the different types going one right after another and colored\r\nin the same color. If you use exactly k distinct colors, then the colors\r\nof figures should be denoted with integers from 1 to k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint q, n, t[N], c[N];\nint main() {\n  cin >> q;\n  while (q--) {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> t[i];\n    bool s = 0;\n    for (int i = 2; i <= n; i++)\n      if (t[i] != t[i - 1]) s = 1;\n    if (s == 0) {\n      cout << \"1\\n\";\n      for (int i = 1; i <= n; i++) cout << 1 << \" \";\n    } else {\n      if (n % 2 == 0 || t[1] == t[n]) {\n        cout << \"2\\n\";\n        for (int i = 1; i <= n; i++) cout << ((i & 1) + 1) << \" \";\n      } else {\n        bool tag = 0;\n        for (int i = 2; i <= n; i++)\n          if (t[i] == t[i - 1]) {\n            cout << \"2\\n\";\n            for (int j = 1; j <= i - 1; j++) cout << ((j & 1) + 1) << \" \";\n            for (int j = i; j <= n; j++) cout << (((j - 1) & 1) + 1) << \" \";\n            tag = 1;\n            break;\n          }\n        if (!tag) {\n          cout << \"3\\n\";\n          for (int i = 1; i <= n; i++) cout << (i < n ? (i & 1) + 1 : 3) << \" \";\n        }\n      }\n    }\n    puts(\"\");\n  }\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "graphs",
        "greedy",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Carousel.json",
    "editorial_link": "https://codeforces.com//blog/entry/75246",
    "editorial": "The answer to this problem is at most . Letâs prove it by\r\nconstruction.Firstly, if all are equal then the answer is . Otherwise,\r\nthere are at least two different values in the array so the answer is at\r\nleast . If is even then the answer is always because you can color\r\nfigures in the following way: . If is odd then consider two cases. The\r\nfirst case is when some pair of adjacent figures have the same type.\r\nThen the answer is because you can merge these two values into one and\r\nget the case of even . Otherwise, all pairs of adjacent figures have\r\ndifferent types and if you consider this cyclic array as a graph (cycle\r\nof length ) then you can notice that it isnât bipartite so you need at\r\nleast colors to achieve the answer (color all vertices in such a way\r\nthat any two adjacent vertices have different colors). And the answer\r\nlooks like .\r\n",
    "hint": []
}