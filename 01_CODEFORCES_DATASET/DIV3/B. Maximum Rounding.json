{
    "link": "https://codeforces.com//contest/1857/problem/B",
    "problemId": "2150543",
    "problem_idx": "B",
    "shortId": "1857B",
    "contest_number": "1857",
    "problem_submissions": {
        "G": [
            217667474,
            217665550,
            217689340,
            217662818,
            217685310,
            217676468,
            217687922,
            217701057,
            217700197,
            217807896,
            217807827,
            217712091,
            217684113,
            217720675,
            217807627,
            217677400,
            217731532,
            217711676,
            217719652,
            217714022,
            217712604,
            217718357,
            217710888
        ],
        "F": [
            217659021,
            217648989,
            217664891,
            217627744,
            217669247,
            217691937,
            217689514,
            217664113,
            217674769,
            217680535,
            217666261,
            217699208,
            217671748,
            217807538,
            217701131,
            217674808,
            217679890,
            217683947,
            217696220,
            217689116,
            217681500,
            217688375
        ],
        "B": [
            217642867,
            217642809,
            217629703,
            217685667,
            217635907,
            217630271,
            217642640,
            217631148,
            217634501,
            217636716,
            217631884,
            217632923,
            217807034,
            217775927,
            217633962,
            217640699,
            217644829,
            217637634,
            217632935,
            217633927,
            217650168,
            217644229
        ],
        "D": [
            217638870,
            217638947,
            217636496,
            217634474,
            217647504,
            217644974,
            217647862,
            217645462,
            217646166,
            217647061,
            217646308,
            217648033,
            217807098,
            217775952,
            217684716,
            217643681,
            217658546,
            217653658,
            217651018,
            217652036,
            217655292,
            217662419
        ],
        "E": [
            217634664,
            217632006,
            217641596,
            217642974,
            217661622,
            217655519,
            217656154,
            217657341,
            217663115,
            217656176,
            217655704,
            217660327,
            217807112,
            217775966,
            217649059,
            217656810,
            217665253,
            217663579,
            217661514,
            217671790,
            217665209,
            217669853
        ],
        "C": [
            217623043,
            217660653,
            217633113,
            217671603,
            217641405,
            217641348,
            217633280,
            217640705,
            217639467,
            217642154,
            217639690,
            217640983,
            217807070,
            217775937,
            217639411,
            217632787,
            217649913,
            217647923,
            217645015,
            217643972,
            217637879,
            217653046
        ],
        "A": [
            217621356,
            217622367,
            217617259,
            217636401,
            217628184,
            217620735,
            217618278,
            217621503,
            217622297,
            217628772,
            217620627,
            217617547,
            217806999,
            217775914,
            217772364,
            217772351,
            217620412,
            217618442,
            217617205,
            217621216,
            217619220,
            217624745,
            217618215,
            217619189
        ]
    },
    "name": "B. Maximum Rounding",
    "statement": "Given a natural number x. You can perform the following operation:\r\nchoose a positive integer k and round x to the k-th digit Note that the\r\npositions are numbered from right to left, starting from zero. If the\r\nnumber has k digits, it is considered that the digit at the k-th\r\nposition is equal to 0.The rounding is done as follows: if the digit at\r\nthe (k-1)-th position is greater than or equal to 5, then the digit at\r\nthe k-th position is increased by 1, otherwise the digit at the k-th\r\nposition remains unchanged (mathematical rounding is used). if before\r\nthe operations the digit at the k-th position was 9, and it should be\r\nincreased by 1, then we search for the least position k\u2019 (k\u2019>k), where\r\nthe digit at the k\u2019-th position is less than 9 and add 1 to the digit at\r\nthe k\u2019-th position. Then we assign k=k\u2019. after that, all digits which\r\npositions are less than k are replaced with zeros.Your task is to make x\r\nas large as possible, if you can perform the operation as many times as\r\nyou want.For example, if x is equal to 3451, then if you choose\r\nconsecutively: k=1, then after the operation x will become 3450 k=2,\r\nthen after the operation x will become 3500 k=3, then after the\r\noperation x will become 4000 k=4, then after the operation x will become\r\n0 To maximize the answer, you need to choose k=2 first, and then k=3,\r\nthen the number will become 4000.\r\n",
    "solutions": [
        "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n\nusing ll = long long;\nusing ld = long double;\n\n#define int long long\n\nvoid solve() {\n    string s;\n    cin >> s;\n    vector <int> a;\n    for (int i = 0; i < s.size(); ++i) {\n        a.push_back(s[s.size() - 1 - i] - '0');\n    }\n    a.push_back(0);\n    int f = 0, mp = -1;\n    for (int i = 0; i < a.size(); ++i) {\n        if (f) {\n            if (a[i] == 9) {\n                mp = i;\n                a[i] = 0;\n                continue;\n            }\n            a[i]++;\n            f = 0;\n        }\n        if (a[i] > 4) {\n            mp = i;\n            a[i] = 0;\n            f = 1;\n        }\n    }\n    for (int i = 0; i <= mp; ++i) a[i] = 0;\n    if (a.back() == 0) a.pop_back();\n    reverse(all(a));\n    for (auto& e : a) cout << e;\n    cout << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Maximum Rounding.json",
    "editorial_link": "https://codeforces.com//blog/entry/119134",
    "editorial": "First, sorry for the unclear statement. We have rewritten it for several\r\ntimes and have chosen the best one.Let\u00e2\u0080\u0099s define as the length of the\r\n.Notice, that after applying the rounding to , all the digits to the\r\nright of become . If the -th digit is less than , after the rounding\r\nit\u00e2\u0080\u0099ll only worsen the answer.On the other side, if the -th digit is not\r\nless than , than rounding to the -th digit always leads to better\r\nanswer, because after the operation will increase.From these\r\nobservations, we can come up with the following greedy algorithm: look\r\nthrough all from to , and if the -th digit is not less than , we use the\r\nrounding operation adding one to the ()-th digit. And don\u00e2\u0080\u0099t worry if\r\nthat digit which must be increased by one is , because in such case we\r\nalways use the rounding operation on the next step.\r\n"
}