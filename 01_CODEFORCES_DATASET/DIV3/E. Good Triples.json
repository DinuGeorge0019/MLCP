{
    "link": "https://codeforces.com//contest/1907/problem/E",
    "problemId": "2365625",
    "problem_idx": "E",
    "shortId": "1907E",
    "contest_number": "1907",
    "problem_submissions": {
        "E": [
            235922096,
            235913995,
            235900143,
            235903340,
            235921667,
            235901704,
            235905781,
            236028309,
            235900905,
            235914797,
            235900953,
            235904410,
            235901939,
            235904392,
            235896353,
            235889597,
            235895501,
            235901631,
            235906746,
            235904536
        ],
        "G": [
            235905776,
            235944172,
            240754131,
            236224108,
            239539892
        ],
        "D": [
            235889060,
            235907893,
            235885826,
            235889907,
            235880968,
            235891188,
            235887305,
            235888897,
            235891138,
            235883950,
            235891896,
            235891023,
            235886777,
            235889881,
            237694958,
            235867800,
            235908732,
            235892927,
            235897779,
            235896975
        ],
        "F": [
            235888366,
            235927475,
            235911089,
            235918673,
            235897756,
            235921167,
            235919938,
            235923351,
            235911206,
            235921824,
            235923367,
            235927696,
            235932260,
            235934792,
            235914612,
            235925488,
            235926925,
            235918432,
            235922859
        ],
        "C": [
            235881778,
            235895243,
            235879309,
            235877991,
            235891348,
            235879417,
            235877691,
            235876696,
            235876979,
            235890394,
            235881961,
            235879314,
            235876924,
            235882981,
            236028314,
            235898937,
            235877137,
            235881599,
            235886820,
            235888590
        ],
        "B": [
            235864949,
            235883426,
            235872876,
            235865746,
            235868017,
            235866431,
            235870498,
            236028285,
            235870319,
            235871004,
            235871121,
            235872127,
            235871434,
            235867930,
            235865841,
            235901960,
            235870212,
            235875746,
            235875948,
            235874656
        ],
        "A": [
            235860107,
            235867323,
            235860491,
            235859890,
            235861006,
            235859799,
            235860028,
            235860311,
            235859823,
            235863201,
            235863210,
            235860674,
            236211486,
            235860837,
            235860015,
            235864893,
            235860651,
            235867283,
            235865532,
            235861983
        ]
    },
    "name": "E. Good Triples",
    "statement": "Given a non-negative integer number n (n\r\nge 0). Let\u2019s say a triple of non-negative integers (a, b, c) is good if\r\na + b + c = n, and digsum(a) + digsum(b) + digsum(c) = digsum(n), where\r\ndigsum(x) is the sum of digits of number x.For example, if n = 26, then\r\nthe pair (4, 12, 10) is good, because 4 + 12 + 10 = 26, and (4) + (1 +\r\n2) + (1 + 0) = (2 + 6).Your task is to find the number of good triples\r\nfor the given number n. The order of the numbers in a triple matters.\r\nFor example, the triples (4, 12, 10) and (10, 12, 4) are two different\r\ntriples.\r\n",
    "solutions": [
        "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<array>\n#include<set>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\nlong long g[10] = { 1,3,6,10,15,21,28,36,45,55 };\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i ^ s.size(); ++i)\n\t\t\tans *= g[s[i] - '0'];\n\t\tcout << ans << '\\n';\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "number theory"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Good Triples.json",
    "editorial_link": "https://codeforces.com//blog/entry/123012",
    "editorial": "A triplet is considered good only if each digit of the number was\r\nobtained without carrying over during addition. For example, consider ,\r\n, ; the sum of the digits is , and the sum of the digits of their sum is\r\n. This means that whenever there is a carry in one of the digits, the\r\nsum always increases more than .This allows us to consider each digit\r\nseparately and multiply their answers. The answer for each digit will be\r\nthe number of digit triplets with the sum . These values do not depend\r\non the input data, so they can be precalculated, but this is not\r\nnecessary to pass the tests.\r\n"
}