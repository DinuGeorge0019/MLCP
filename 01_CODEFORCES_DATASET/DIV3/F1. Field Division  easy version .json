{
    "link": "https://codeforces.com//contest/1980/problem/F1",
    "problemId": "2679078",
    "problem_idx": "F1",
    "shortId": "1980F1",
    "contest_number": "1980",
    "problem_submissions": {
        "F2": [
            264034665,
            264025304,
            264247676,
            264019993,
            264024427,
            264029852,
            264023188,
            264027216,
            297729485,
            297729442,
            297728361,
            297728328
        ],
        "G": [
            264011385,
            263992122,
            268025366,
            264215525,
            264011872,
            264084430,
            264264232,
            264263765,
            264069123,
            264079559,
            264078668
        ],
        "F1": [
            263976190,
            263977123,
            263986480,
            263993424,
            264008757,
            263990594,
            264002101,
            263997926,
            264028649,
            263987133,
            263983649,
            263982394,
            264008279,
            263992416,
            264001050,
            263982241,
            263973003,
            297724971,
            263994302,
            263989092,
            263991078
        ],
        "E": [
            263949022,
            263952956,
            263961437,
            263972191,
            263952206,
            263972111,
            263965559,
            263972356,
            263979958,
            263960816,
            263958713,
            263958124,
            263952216,
            263968394,
            263952644,
            263960173,
            263957033,
            263960055,
            263959465,
            263968735
        ],
        "D": [
            263937338,
            263941014,
            263940806,
            263951978,
            263959721,
            263955612,
            263952654,
            263955258,
            263970236,
            263929153,
            263938177,
            263937870,
            263931692,
            263943850,
            263942483,
            263952145,
            263949853,
            263944438,
            263947463,
            263956473
        ],
        "C": [
            263918738,
            263918609,
            263924884,
            263925019,
            263927010,
            263934895,
            263950793,
            263933470,
            263946468,
            263911344,
            263918263,
            263919725,
            263911878,
            263921063,
            263925590,
            263921654,
            263927275,
            263926350,
            263931913,
            263931664
        ],
        "B": [
            263905986,
            263904943,
            263911595,
            263912040,
            263903286,
            263919041,
            263916463,
            263913479,
            263919564,
            263901644,
            263907263,
            263909074,
            263903306,
            263904343,
            263907275,
            263910981,
            263913905,
            263915385,
            263916132,
            263900094
        ],
        "A": [
            263898827,
            263896737,
            263896710,
            263899946,
            263896564,
            263900183,
            263902852,
            263902771,
            263905894,
            263896600,
            263896618,
            263897271,
            263897395,
            263896553,
            263899202,
            263896419,
            263897066,
            263897350,
            263900369,
            263899316,
            263897377
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130135",
    "editorial": "Since Alice can only move down or to the right, if in the -th row cells\r\nbelong to her, then in the -th row she can have cells. The construction\r\nof the maximum plot can be represented as follows: we will go through\r\nthe rows from bottom to top and keep track of how many cells we have\r\ncollected in the row below. In the current row, we will collect either\r\nthe same number of cells, or all the cells up to the leftmost fountain\r\nin the row, if there are fewer such cells.There are three possible\r\npositions of the fountains relative to the boundary with Alice\u00e2\u0080\u0099s plot:\r\nthe fountain has no adjacent cells belonging to Alice\u00e2\u0080\u0099s plot; the\r\nfountain has one adjacent cell belonging to Alice\u00e2\u0080\u0099s plot; the fountain\r\nhas two adjacent cells belonging to Alice\u00e2\u0080\u0099s plot. The area of Alice\u00e2\u0080\u0099s\r\nplot changes only when removing the third type of fountain position,\r\nwhich we will call the . Since a has formed, in the row below Alice had\r\nmore cells, and when removing this fountain, she will be able to take at\r\nleast one cell with this fountain, and the answer for it will be . For\r\nthe other two types of positions, removing the fountain will not change\r\nthe size of the plot, and the answer for them will be (you can proof it\r\nby yourself).To ensure that the solution does not depend on the size of\r\nthe field, we will sort the fountains in descending order of the\r\ncoordinate, and in case of equality of , in ascending order of the\r\ncoordinate. We will iterate through the fountains in this order, keep\r\ntrack of the coordinates of the last , and update the answer when a new\r\nis found.\r\n",
    "name": "F1. Field Division  easy version ",
    "statement": "Alice and Bob are dividing the field. The field is a rectangle of size n\r\ntimes m (2\r\nle n, m\r\nle 10^9), the rows are numbered from 1 to n from top to bottom, and the\r\ncolumns are numbered from 1 to m from left to right. The cell at the\r\nintersection of row r and column c is denoted as (r, c).Bob has k (2\r\nle k\r\nle 2\r\ncdot 10^5) fountains, all of them are located in different cells of the\r\nfield. Alice is responsible for dividing the field, but she must meet\r\nseveral conditions: To divide the field, Alice will start her path in\r\nany free (without a fountain) cell on the left or top side of the field\r\nand will move, each time moving to the adjacent cell or . Her path will\r\nend on the right or bottom side of the field. Alice\u2019s path will divide\r\nthe field into two parts one part will belong to Alice (this part\r\nincludes the cells of her path), the other part to Bob. Alice will own\r\nthe part that includes the cell (n, 1). Bob will own the part that\r\nincludes the cell (1, m). Alice wants to divide the field in such a way\r\nas to get as many cells as possible.Bob wants to keep ownership of all\r\nthe fountains, but he can give one of them to Alice. First, output the\r\ninteger\r\nalpha the maximum possible size of Alice\u2019s plot, if Bob does not give\r\nher any fountain (i.e., all fountains will remain on Bob\u2019s plot). Then\r\noutput k non-negative integers a_1, a_2,\r\ndots, a_k, where: a_i=0, if after Bob gives Alice the i-th fountain, the\r\nmaximum possible size of Alice\u2019s plot does not increase (i.e., remains\r\nequal to\r\nalpha); a_i=1, if after Bob gives Alice the i-th fountain, the maximum\r\npossible size of Alice\u2019s plot increases (i.e., becomes greater than\r\nalpha).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;using i64 = int64_t;\u00a0int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n, m, k; cin >> n >> m >> k;        vector<array<int, 3>> v;        for (int id = 0; id < k; id++) {            int i, j; cin >> j >> i;            v.push_back({i, -j, id});        }        sort(v.begin(), v.end());        int mx = 0, ls = -1;        i64 cnt = i64(n) * m;        vector<int> ans(k, 0);        int id = 0;        for (auto [i, j, id]: v) {            j = -j;            if (j > mx) {                cnt -= i64(i - ls) * mx;                ls = i;                mx = j;                ans[id] = 1;            }        }        cnt -= i64(m + 1 - ls) * mx;        cout << cnt << \"\\n\";        for (int x: ans) cout << x << \" \";        cout << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F1. Field Division  easy version .json"
}