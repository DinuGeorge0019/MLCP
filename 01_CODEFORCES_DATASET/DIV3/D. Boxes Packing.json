{"link": "https://codeforces.com//contest/1066/problem/D", "problemId": "235862", "problem_idx": "D", "shortId": "1066D", "contest_number": "1066", "problem_submissions": {"F": [44205429, 44212106, 44214312, 44211772, 44215735, 44216480, 44217948, 44226593], "A": [44198897, 44190264, 44190996, 44190521, 44194374, 44191748, 44192884, 44190114, 44190457, 44190392, 44190295, 44232541, 44190105, 44190131, 44190364, 44190102, 44190147, 44190161, 44189962, 44194814, 44190476], "B": [44197927, 44195073, 44192967, 44193419, 44192423, 44197883, 44195893, 44197752, 44191223, 44190844, 44195475, 44193709, 44258187, 44195185, 44192726, 44197021, 44193282, 44199995, 44192974, 44197693, 44198781, 44196227], "E": [44194302, 44198044, 44197688, 44200186, 44206112, 44204683, 44211808, 44198204, 44195532, 44205080, 44203248, 44258229, 44204157, 44207684, 44206425, 44203537, 44205955, 44206848, 44208459, 44207862, 44206046], "D": [44192050, 44200143, 44200943, 44204312, 44203052, 44199330, 44205029, 44195917, 44202796, 44193485, 44198842, 44258212, 44199756, 44199261, 44202172, 44206141, 44203730, 44203685, 44199896, 44193449, 44202596], "C": [44190191, 44192207, 44196592, 44195653, 44199921, 44207097, 44202048, 44193208, 44195430, 44199895, 44196374, 44258203, 44196767, 44197574, 44194617, 44197700, 44192395, 44195734, 44195568, 44200428, 44198081]}, "name": "D. Boxes Packing", "statement": "Maksim has n objects and m boxes, each box has size exactly k. Objects\r\nare numbered from 1 to n in order from left to right, the size of the\r\ni-th object is a_i.Maksim wants to pack his objects into the boxes and\r\nhe will pack objects by the following algorithm: he takes one of the\r\nempty boxes he has, goes from left to right through the objects, and if\r\nthe i-th object fits in the current box (the remaining size of the box\r\nis greater than or equal to a_i), he puts it in the box, and the\r\nremaining size of the box decreases by a_i. Otherwise he takes the new\r\nempty box and continues the process above. If he has no empty boxes and\r\nthere is at least one object not in some box then Maksim cannot pack the\r\nchosen set of objects.Maksim wants to know the maximum number of objects\r\nhe can pack by the algorithm above. To reach this target, . Your task is\r\nto say the maximum number of objects Maksim can pack in boxes he\r\nhas.Each time when Maksim tries to pack the objects into the boxes, he\r\nwill make empty all the boxes he has before do it (and the relative\r\norder of the remaining set of objects will not change).\r\n", "solutions": ["#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << '=' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << \" = {\"; FOR(_, l, r) cerr << ' ' << a[_]; cerr << \"}\\n\"; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl '\\n'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname \"\"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N];\nint main() {\n    #ifdef NERO\n    freopen(\"test.inp\",\"r\",stdin);\n    freopen(\"test.out\",\"w\",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname\".inp\",\"r\",stdin);\n        //freopen(taskname\".out\",\"w\",stdout);\n    #endif //NERO\n    IO;\n    int n, m, k;\n    cin >> n >> m >> k;\n    FOR(i, 1, n) cin >> a[i];\n    int cnt = 0;\n    int sum = 0;\n    FORD(i, n, 1) {\n        if (sum + a[i] > k) {\n            cnt++;\n            sum = 0;\n        }\n        if (cnt == m || a[i] > k) {\n            cout << n - i;\n            return 0;\n        }\n        sum += a[i];\n    }\n    cout << n;\n    #ifdef NERO\n    double etime = clock();\n    cerr << \"Execution time: \" << (etime - stime) / CLOCKS_PER_SEC * 1000 << \" ms.\\n\";\n    #endif // NERO\n}\n"], "input": "", "output": "", "tags": ["binary search", "implementation"], "dificulty": "1800", "interactive": false}