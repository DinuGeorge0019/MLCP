{
    "link": "https://codeforces.com//contest/1066/problem/D",
    "problemId": "235862",
    "problem_idx": "D",
    "shortId": "1066D",
    "contest_number": "1066",
    "problem_submissions": {
        "F": [
            44205429,
            44212106,
            44214312,
            44211772,
            44215735,
            44216480,
            44217948,
            44226593
        ],
        "A": [
            44198897,
            44190264,
            44190996,
            44190521,
            44194374,
            44191748,
            44192884,
            44190114,
            44190457,
            44190392,
            44190295,
            44232541,
            44190105,
            44190131,
            44190364,
            44190102,
            44190147,
            44190161,
            44189962,
            44194814,
            44190476
        ],
        "B": [
            44197927,
            44195073,
            44192967,
            44193419,
            44192423,
            44197883,
            44195893,
            44197752,
            44191223,
            44190844,
            44195475,
            44193709,
            44258187,
            44195185,
            44192726,
            44197021,
            44193282,
            44199995,
            44192974,
            44197693,
            44198781,
            44196227
        ],
        "E": [
            44194302,
            44198044,
            44197688,
            44200186,
            44206112,
            44204683,
            44211808,
            44198204,
            44195532,
            44205080,
            44203248,
            44258229,
            44204157,
            44207684,
            44206425,
            44203537,
            44205955,
            44206848,
            44208459,
            44207862,
            44206046
        ],
        "D": [
            44192050,
            44200143,
            44200943,
            44204312,
            44203052,
            44199330,
            44205029,
            44195917,
            44202796,
            44193485,
            44198842,
            44258212,
            44199756,
            44199261,
            44202172,
            44206141,
            44203730,
            44203685,
            44199896,
            44193449,
            44202596
        ],
        "C": [
            44190191,
            44192207,
            44196592,
            44195653,
            44199921,
            44207097,
            44202048,
            44193208,
            44195430,
            44199895,
            44196374,
            44258203,
            44196767,
            44197574,
            44194617,
            44197700,
            44192395,
            44195734,
            44195568,
            44200428,
            44198081
        ]
    },
    "name": "D. Boxes Packing",
    "statement": "Maksim has n objects and m boxes, each box has size exactly k. Objects\r\nare numbered from 1 to n in order from left to right, the size of the\r\ni-th object is a_i.Maksim wants to pack his objects into the boxes and\r\nhe will pack objects by the following algorithm: he takes one of the\r\nempty boxes he has, goes from left to right through the objects, and if\r\nthe i-th object fits in the current box (the remaining size of the box\r\nis greater than or equal to a_i), he puts it in the box, and the\r\nremaining size of the box decreases by a_i. Otherwise he takes the new\r\nempty box and continues the process above. If he has no empty boxes and\r\nthere is at least one object not in some box then Maksim cannot pack the\r\nchosen set of objects.Maksim wants to know the maximum number of objects\r\nhe can pack by the algorithm above. To reach this target, . Your task is\r\nto say the maximum number of objects Maksim can pack in boxes he\r\nhas.Each time when Maksim tries to pack the objects into the boxes, he\r\nwill make empty all the boxes he has before do it (and the relative\r\norder of the remaining set of objects will not change).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << '=' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << \" = {\"; FOR(_, l, r) cerr << ' ' << a[_]; cerr << \"}\\n\"; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl '\\n'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname \"\"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N];\nint main() {\n    #ifdef NERO\n    freopen(\"test.inp\",\"r\",stdin);\n    freopen(\"test.out\",\"w\",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname\".inp\",\"r\",stdin);\n        //freopen(taskname\".out\",\"w\",stdout);\n    #endif //NERO\n    IO;\n    int n, m, k;\n    cin >> n >> m >> k;\n    FOR(i, 1, n) cin >> a[i];\n    int cnt = 0;\n    int sum = 0;\n    FORD(i, n, 1) {\n        if (sum + a[i] > k) {\n            cnt++;\n            sum = 0;\n        }\n        if (cnt == m || a[i] > k) {\n            cout << n - i;\n            return 0;\n        }\n        sum += a[i];\n    }\n    cout << n;\n    #ifdef NERO\n    double etime = clock();\n    cerr << \"Execution time: \" << (etime - stime) / CLOCKS_PER_SEC * 1000 << \" ms.\\n\";\n    #endif // NERO\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Boxes Packing.json",
    "editorial_link": "https://codeforces.com//blog/entry/62419",
    "editorial": "The first solution is some kind of a straight-forward understanding the\r\nproblem. Letâs do binary search on the answer. So our problem is to find\r\nthe smallest such that the suffix of the array starting from the\r\nposition can be packed in boxes. It is easy to see that if we can do it\r\nfor some then we always can do it for . And to find the answer for the\r\nfixed we have to simulate the process described in the problem statement\r\nstarting from the position . Okay, this is solution.The second solution\r\nis more interesting than the first one. The approach is to reverse the\r\ninitial array, simulate the process from the first position of reversed\r\narray and then all the objects we can pack are in the best answer and\r\nthere is no better answer at all.Why it works?Letâs take a look on the\r\nlast box in the best answer if we will go from left to right in the\r\ninitial array. Let objects in this box be . What do we see? . So all\r\nthese objects are fit in the last box (obviously). Now if we will\r\niterate over objects from right to left, these objects will fit also! It\r\nmeans that we cannot do worse by such a transform (reversing) at least\r\nfor the last box.But what will happen if we can put some of the previous\r\nobjects in this box? Well, it will not make worse for this box, but what\r\nabout next boxes (previous boxes in straight notation)? Let objects in\r\nthe penultimate box be . What do we see? These objects are fit in this\r\nbox (obviously again). What will happen if we will put in the last box\r\none or more objects of this box? Then the border of objects which we\r\nwill put in it will not increase because we the number of object in this\r\nbox. So we can see that for previous boxes this condition is also\r\nsatisfied.So we can solve the problem with this approach. Time\r\ncomplexity of this solution is .\r\n",
    "hint": []
}