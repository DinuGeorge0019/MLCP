{
    "link": "https://codeforces.com//contest/1593/problem/G",
    "problemId": "1142168",
    "problem_idx": "G",
    "shortId": "1593G",
    "contest_number": "1593",
    "problem_submissions": {
        "G": [
            131796315,
            131809860,
            131836830,
            131839082,
            131841650,
            131846524,
            131852907,
            131782296,
            148479901,
            131828563
        ],
        "D2": [
            131785134,
            131788443,
            131789598,
            131915775,
            131805880,
            131823322,
            131831578,
            131821525,
            131793982,
            131849437,
            131784594,
            131791388,
            131828383,
            131836476,
            131831664,
            131825743,
            131905244,
            131794334
        ],
        "F": [
            131781426,
            131837226,
            131815253,
            131811669,
            131876285,
            131849937,
            131847427,
            131845860,
            131816994,
            131855037,
            131787838,
            131800685,
            131891194
        ],
        "E": [
            131774861,
            131775908,
            131796997,
            131786728,
            131876206,
            131792098,
            131797221,
            131825650,
            131807172,
            131832634,
            131793728,
            131840729,
            131794124,
            131808830,
            131787792,
            131786397,
            131783883,
            131789053,
            223850329,
            131905293,
            131805482
        ],
        "B": [
            131755249,
            131755158,
            131757455,
            131754198,
            131760377,
            131758125,
            131761538,
            131761685,
            131807386,
            131800607,
            131823956,
            131758842,
            131777000,
            131762147,
            131758359,
            131757156,
            131752418,
            131759279,
            131754084,
            131765706
        ],
        "C": [
            131755086,
            131765317,
            131761314,
            131762977,
            131768274,
            131765107,
            131772896,
            131769864,
            131760280,
            131765951,
            131827956,
            131767746,
            131761402,
            131771022,
            131806450,
            131797380,
            131767699,
            131763033,
            131759309,
            131766132,
            131759703,
            131774485
        ],
        "D1": [
            131754873,
            131770215,
            131766394,
            131756595,
            131776207,
            131772281,
            131769846,
            131778601,
            131766158,
            131773159,
            131795293,
            131772976,
            131778104,
            131776921,
            131775662,
            131772715,
            131771125,
            131769653,
            131765142,
            131779945
        ],
        "A": [
            131752757,
            131748062,
            131750155,
            131748058,
            131749835,
            131748696,
            131748309,
            131753208,
            131799940,
            131756190,
            131825544,
            131751230,
            131754683,
            131752419,
            131750607,
            131749631,
            131748206,
            131752432,
            131748594,
            131755250
        ]
    },
    "name": "G. Changing Brackets",
    "statement": "A sequence of round and square brackets is given. You can change the\r\nsequence by performing the following operations: change the direction of\r\na bracket from opening to closing and vice versa without changing the\r\nform of the bracket: i.e. you can change \u201d to \u201d and \u201d to \u201d; you can\r\nchange \u201d to \u201d and \u201d to \u201d. The operation costs 0 burles. change any\r\nbracket to bracket having the same direction: i.e. you can change \u201d to \u201d\r\nbut from \u201d to \u201d; similarly, you can change \u201d to \u201d but from \u201d to \u201d. The\r\noperation costs 1 burle. The operations can be performed in any order\r\nany number of times.You are given a string s of the length n and q\r\nqueries of the type \"\" where 1\r\nle l < r\r\nle n. For every substring s[l\r\ndots r], find the minimum cost to pay to make it a correct bracket\r\nsequence. It is guaranteed that the substring s[l\r\ndots r] has an even length.The queries must be processed independently,\r\ni.e. the changes made in the string for the answer to a question i don\u2019t\r\naffect the queries j (j > i). In other words, for every query, the\r\nsubstring s[l\r\ndots r] is given from the initially given string s.A correct bracket\r\nsequence is a sequence that can be built according the following rules:\r\nan empty sequence is a correct bracket sequence; if \"\" is a correct\r\nbracket sequence, the sequences \"\" and \"\" are correct bracket sequences.\r\nif \"\" and \"\" are correct bracket sequences, the sequence \"\" (the\r\nconcatenation of the sequences) is a correct bracket sequence. E.g. the\r\nsequences \"\", \"\", \"\" and \"\" are correct bracket sequences whereas \"\", \"\"\r\nand \"\" are not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=1000005;\nint t,sum[N],q,l,r;\nstring s;\nint main() {\n   \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>s;\n        for (int i=0;i<s.length();i++) {\n            sum[i+1]=sum[i];\n            if (s[i]=='['||s[i]==']') {\n                if (i%2) sum[i+1]++;\n                else sum[i+1]--;\n            }\n        }\n        cin>>q;\n        for (int i=1;i<=q;i++) {\n            cin>>l>>r;\n            cout<<abs(sum[r]-sum[l-1])<<\"\\n\";\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Changing Brackets.json",
    "editorial_link": "https://codeforces.com//blog/entry/96034",
    "editorial": "Consider a substring . Let\u00e2\u0080\u0099s call square brackets located in odd\r\npositions in the substring brackets, and square brackets located in even\r\npositions brackets. Let be the number of odd brackets, be the number of\r\neven brackets, be the number of all square brackets. Let\u00e2\u0080\u0099s prove that\r\nthe string can be turned into a correct bracket sequence for burles if\r\nand only if .Let\u00e2\u0080\u0099s prove the necessary condition. Suppose the initial\r\nsubstring has been turned into a correct bracket sequence. Since we have\r\npaid burles, there\u00e2\u0080\u0099s no bracket which form has been changed. Therefore,\r\nfor the new sequence is the same as for the initial sequence, the\r\nsimilar situation happens with .Let\u00e2\u0080\u0099s say that two square brackets form\r\na pair if the left one is an opening bracket and the right one is a\r\nclosing bracket and the substring between them is a correct bracket\r\nsequence. A pair can be formed only by one odd bracket and one even\r\nbracket because between them is placed an even number of brackets (since\r\nit\u00e2\u0080\u0099s a correct bracket sequence) so the difference between their indices\r\nis odd. In a correct bracket sequence, each square bracket has a\r\npairwise bracket. Therefore, a correct bracket sequence contains pairs\r\nof brackets so .Let\u00e2\u0080\u0099s prove the sufficient condition. Suppose the\r\ninitial substring contains equal numbers of odd and even brackets. Let\u00e2\u0080\u0099s\r\nprove by induction that the substring may be turned into a correct\r\nbracket sequence for burles.Suppose . So the initial substring contains\r\nonly round brackets. Let\u00e2\u0080\u0099s make the first brackets opening and the other\r\nbrackets closing. The resulting sequence is a correct bracket sequence\r\nwhereas we haven\u00e2\u0080\u0099t changed the form of any bracket so the cost is equal\r\nto .A correct bracket sequence has two important properties: after\r\ndeleting its substring being a correct bracket sequence, the resulting\r\nstring is a correct bracket sequence; after inserting at any place any\r\ncorrect bracket sequence, the resulting string is a correct bracket\r\nsequence. These properties can be applied to an incorrect bracket\r\nsequence, too: after deleting a substring being a correct bracket\r\nsubsequence from an incorrect bracket sequence or inserting a correct\r\nbracket sequence into an incorrect one, the resulting sequence is an\r\nincorrect bracket sequence.Consider a substring such that . Suppose we\r\nhave proved before that each substring having decreased by can be turned\r\ninto a correct bracket sequence for burles. Let\u00e2\u0080\u0099s find two square\r\nbrackets such that one of them is odd and another one is even and there\r\nare no square brackets between them. There\u00e2\u0080\u0099s an even number of round\r\nbrackets between them that can be turned into a correct bracket sequence\r\nfor burles. Let\u00e2\u0080\u0099s make the left found bracket opening and the right one\r\nclosing. Then the substring starting at the left found bracket and\r\nending at the right found bracket is a correct bracket sequence. Let\u00e2\u0080\u0099s\r\nremove it from . The resulting string contains odd brackets and even\r\nbrackets so, by the assumption of induction, it can be turned into a\r\ncorrect bracket sequence for burles. Let\u00e2\u0080\u0099s do it and then insert the\r\nremoved string into its place. Since we insert a correct bracket\r\nsequence into a correct bracket sequence, the resulting string is a\r\ncorrect bracket sequence.Actually, the operations of inserting and\r\nremoving are not allowed, they have been used for clarity, the string\r\ncan be turned into a correct bracket sequence without these operations\r\nas follows: let\u00e2\u0080\u0099s turn the substring we have removed into a correct\r\nbracket sequence (as it was described above), then change the other\r\nbrackets of the string the same way as it was done with the string that\r\nwas the result after removing. The resulting string is a correct bracket\r\nsequence. Therefore, the illegal operations of inserting and removing\r\nare not necessary, all other operations cost burles so the substring can\r\nbe turned into a correct bracket sequence for burles.Therefore, to turn\r\na substring into a correct bracket sequence, we need to get a sequence\r\nsuch that . Suppose, initiallly, . Let\u00e2\u0080\u0099s pay burles to replace odd\r\nbrackets with round brackets. If , let\u00e2\u0080\u0099s replace even brackets with\r\nround brackets. Anyway, we must pay burles. We cannot pay less than this\r\nvalue because for a correct bracket sequence, . But there\u00e2\u0080\u0099s no need to\r\npay more than this value, because, if we turn the initial substring into\r\na sequence with , we can turn it into a correct bracket sequence for\r\nfree. Therfore, the answer for a given question is .Since we must answer\r\nthe queries fast, let\u00e2\u0080\u0099s use a concept of prefix sums. If the given\r\nstring contains brackets, let\u00e2\u0080\u0099s create arrays and with the length . will\r\ncontain the number of odd brackets on the prefix of the string with the\r\nlength , the same value for even brackets. Let\u00e2\u0080\u0099s initialize and then\r\niterate from to . Let\u00e2\u0080\u0099s initialize and . If the -th bracket is round,\r\nthen the current values are correct. Otherwise, let\u00e2\u0080\u0099s find out what\r\nbracket is it. If is odd, the bracket is odd so we must increase by . If\r\nis even, the bracket is even so we must increase by .To get the answer\r\nfor a current and , let\u00e2\u0080\u0099s calculate and . is a number of odd brackets\r\nthat belong to the prefix with the length but not to the prefix with the\r\nlength so . Similarly, . The remaining thing is to output .\r\n"
}