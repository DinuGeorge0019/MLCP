{"link": "https://codeforces.com//contest/1593/problem/G", "problemId": "1142168", "problem_idx": "G", "shortId": "1593G", "contest_number": "1593", "problem_submissions": {"G": [131796315, 131809860, 131836830, 131839082, 131841650, 131846524, 131852907, 131782296, 148479901, 131828563], "D2": [131785134, 131788443, 131789598, 131915775, 131805880, 131823322, 131831578, 131821525, 131793982, 131849437, 131784594, 131791388, 131828383, 131836476, 131831664, 131825743, 131905244, 131794334], "F": [131781426, 131837226, 131815253, 131811669, 131876285, 131849937, 131847427, 131845860, 131816994, 131855037, 131787838, 131800685, 131891194], "E": [131774861, 131775908, 131796997, 131786728, 131876206, 131792098, 131797221, 131825650, 131807172, 131832634, 131793728, 131840729, 131794124, 131808830, 131787792, 131786397, 131783883, 131789053, 223850329, 131905293, 131805482], "B": [131755249, 131755158, 131757455, 131754198, 131760377, 131758125, 131761538, 131761685, 131807386, 131800607, 131823956, 131758842, 131777000, 131762147, 131758359, 131757156, 131752418, 131759279, 131754084, 131765706], "C": [131755086, 131765317, 131761314, 131762977, 131768274, 131765107, 131772896, 131769864, 131760280, 131765951, 131827956, 131767746, 131761402, 131771022, 131806450, 131797380, 131767699, 131763033, 131759309, 131766132, 131759703, 131774485], "D1": [131754873, 131770215, 131766394, 131756595, 131776207, 131772281, 131769846, 131778601, 131766158, 131773159, 131795293, 131772976, 131778104, 131776921, 131775662, 131772715, 131771125, 131769653, 131765142, 131779945], "A": [131752757, 131748062, 131750155, 131748058, 131749835, 131748696, 131748309, 131753208, 131799940, 131756190, 131825544, 131751230, 131754683, 131752419, 131750607, 131749631, 131748206, 131752432, 131748594, 131755250]}, "name": "G. Changing Brackets", "statement": "A sequence of round and square brackets is given. You can change the\r\nsequence by performing the following operations: change the direction of\r\na bracket from opening to closing and vice versa without changing the\r\nform of the bracket: i.e. you can change \u201d to \u201d and \u201d to \u201d; you can\r\nchange \u201d to \u201d and \u201d to \u201d. The operation costs 0 burles. change any\r\nbracket to bracket having the same direction: i.e. you can change \u201d to \u201d\r\nbut from \u201d to \u201d; similarly, you can change \u201d to \u201d but from \u201d to \u201d. The\r\noperation costs 1 burle. The operations can be performed in any order\r\nany number of times.You are given a string s of the length n and q\r\nqueries of the type \"\" where 1\r\nle l < r\r\nle n. For every substring s[l\r\ndots r], find the minimum cost to pay to make it a correct bracket\r\nsequence. It is guaranteed that the substring s[l\r\ndots r] has an even length.The queries must be processed independently,\r\ni.e. the changes made in the string for the answer to a question i don\u2019t\r\naffect the queries j (j > i). In other words, for every query, the\r\nsubstring s[l\r\ndots r] is given from the initially given string s.A correct bracket\r\nsequence is a sequence that can be built according the following rules:\r\nan empty sequence is a correct bracket sequence; if \"\" is a correct\r\nbracket sequence, the sequences \"\" and \"\" are correct bracket sequences.\r\nif \"\" and \"\" are correct bracket sequences, the sequence \"\" (the\r\nconcatenation of the sequences) is a correct bracket sequence. E.g. the\r\nsequences \"\", \"\", \"\" and \"\" are correct bracket sequences whereas \"\", \"\"\r\nand \"\" are not.\r\n", "solutions": ["#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=1000005;\nint t,sum[N],q,l,r;\nstring s;\nint main() {\n   \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>s;\n        for (int i=0;i<s.length();i++) {\n            sum[i+1]=sum[i];\n            if (s[i]=='['||s[i]==']') {\n                if (i%2) sum[i+1]++;\n                else sum[i+1]--;\n            }\n        }\n        cin>>q;\n        for (int i=1;i<=q;i++) {\n            cin>>l>>r;\n            cout<<abs(sum[r]-sum[l-1])<<\"\\n\";\n        }\n    }\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dp", "greedy"], "dificulty": "2200", "interactive": false}