{
    "link": "https://codeforces.com//contest/1974/problem/E",
    "problemId": "2657207",
    "problem_idx": "E",
    "shortId": "1974E",
    "contest_number": "1974",
    "problem_submissions": {
        "G": [
            261890876,
            261895242,
            261892104,
            261815844,
            261901397,
            261882110,
            261902942,
            261897196,
            261890302,
            261906925,
            261906633,
            261902994,
            261909128,
            262172085,
            261998366,
            261998046,
            261912311
        ],
        "F": [
            261873832,
            261860163,
            261871347,
            261886083,
            261890598,
            261905275,
            261893342,
            261893849,
            261885670,
            261888292,
            261884408,
            261903255,
            261856931,
            261866178,
            261998302,
            261867572,
            261874550,
            261881230,
            261896095,
            261891848
        ],
        "E": [
            261843511,
            261898684,
            261874046,
            261856295,
            261872971,
            261858650,
            261864336,
            261872189,
            261875499,
            261861733,
            261866981,
            261850233,
            261886170,
            261845363,
            261845593,
            261998691,
            261848135,
            261863399,
            261863179,
            261861452,
            261854564
        ],
        "D": [
            261828744,
            261833579,
            261844887,
            261858347,
            261848070,
            261834943,
            261843848,
            261843125,
            261893971,
            261854059,
            261850835,
            261836444,
            261865680,
            261830266,
            261832171,
            261998550,
            261835226,
            261844678,
            261837286,
            261829368,
            261844070
        ],
        "C": [
            261809458,
            261818269,
            261821670,
            261838680,
            261824893,
            261817516,
            261818307,
            261822342,
            261872865,
            261902570,
            261836543,
            261891689,
            261812999,
            261811999,
            261811344,
            261998621,
            261807237,
            261810379,
            261809093,
            261808251,
            261815953
        ],
        "B": [
            261801251,
            261803139,
            261801216,
            261828779,
            261802058,
            261805873,
            261803693,
            261800515,
            261806010,
            261808108,
            261800732,
            261800673,
            261801484,
            261801347,
            261998221,
            261798953,
            261798594,
            261800683,
            261798231,
            261800035
        ],
        "A": [
            261797694,
            261795610,
            261795288,
            261822724,
            261797136,
            261796736,
            262453696,
            261795629,
            261796165,
            261795943,
            261800077,
            261795571,
            261795380,
            261796034,
            261796954,
            261998187,
            261795311,
            261795243,
            261796139,
            261795603,
            261796608
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129686",
    "editorial": "Letâs consider the classic knapsack problem. Let be the minimum cost\r\nrequired to achieve happiness . In the -th month, we iterate through and\r\ncheck if , and if so, we can afford to transition to and accordingly\r\nupdate .The complexity is for each set of input data.\r\n",
    "name": "E. Money Buys Happiness",
    "statement": "Being a physicist, Charlie likes to plan his life in simple and precise\r\nterms. For the next m months, starting with no money, Charlie will work\r\nhard and earn x pounds per month. For the i-th month (1\r\nle i\r\nle m), there’ll be a single opportunity of paying cost c_i pounds to\r\nobtain happiness h_i.Borrowing is not allowed. Money earned in the i-th\r\nmonth can only be spent in a later j-th month (j>i).Since physicists\r\ndon’t code, help Charlie find the maximum obtainable sum of happiness.\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <algorithm>#include <vector>#include <chrono>#include <random>#include <map>#include <set>using namespace std;typedef long long ll;const int N = 2e5 + 10;ll c[N], h[N];ll dp[N];ll nxt_dp[N];void solve() {\tint sm = 0;\tint m, x;\tcin >> m >> x;\tfor (int i = 1; i <= m; i++) {\t\tcin >> c[i] >> h[i];\t\tsm += h[i];\t}\tfor (int i = 1; i <= sm; i++) {\t\tdp[i] = -1;\t}\tdp[0] = 0;\tfor (int i = 1; i <= m; i++) {\t\tfor (int j = 0; j <= sm; j++) {\t\t\tnxt_dp[j] = dp[j];\t\t\tif (j >= h[i] && dp[j - h[i]] != -1) {\t\t\t\tll w = dp[j - h[i]];\t\t\t\tif (w >= c[i]) {\t\t\t\t\tif (nxt_dp[j] == -1) nxt_dp[j] = w - c[i];\t\t\t\t\telse if (nxt_dp[j] < w - c[i]) nxt_dp[j] = w - c[i];\t\t\t\t} \t\t\t}\t\t}\t\tfor (int j = 0; j <= sm; j++) {\t\t\tdp[j] = nxt_dp[j];\t\t\tif (dp[j] != -1) dp[j] += x;\t\t}\t}\tfor (int j = sm; j >= 0; j--) {\t\tif (dp[j] != -1) {\t\t\tcout << j << \"\\n\";\t\t\treturn;\t\t}\t}}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Money Buys Happiness.json",
    "hint": []
}