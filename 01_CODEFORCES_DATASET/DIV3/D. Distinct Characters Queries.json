{"link": "https://codeforces.com//contest/1234/problem/D", "problemId": "426514", "problem_idx": "D", "shortId": "1234D", "contest_number": "1234", "problem_submissions": {"F": [61647149, 61645384, 61650555, 61651870, 61667991, 62194838, 61712119, 61666405, 61729878, 61729799, 61664234, 68329269, 61680222, 61752962], "E": [61637715, 61643598, 61648539, 61642595, 61643656, 61651547, 61650480, 61652692, 61641203, 61649142, 61659878, 61650257, 61653772, 61654963, 61657548, 61649045, 61654746, 61657468, 61654998, 61655416], "C": [61632575, 61627606, 61654578, 61628592, 61630466, 61624366, 61638436, 61629236, 61652967, 61631133, 61636961, 61642219, 61643521, 61637365, 61636499, 61632963, 61634943, 61633612, 61629926, 61640840], "B1": [61622243, 61619256, 61623667, 61618942, 61620065, 61620401, 61621233, 61618288, 61620321, 61625306, 61621149, 61623370, 61622245, 61622135, 61620954, 61622191, 61621982, 61619236, 61622554, 61619031], "B2": [61622177, 61619354, 61626675, 61618859, 61617735, 61620174, 61619049, 61620082, 61618293, 61625056, 61620210, 61624129, 61619541, 61622218, 61620837, 61628084, 61621947, 61619088, 61624726, 61619187], "D": [61620922, 61632151, 61634663, 61631934, 61627516, 61628612, 61627461, 61639106, 61624471, 61635660, 61628357, 61634636, 61632191, 61627962, 61627805, 61636954, 61642587, 61638100, 61640694, 61630321], "A": [61612861, 61620182, 61616933, 61612804, 61614828, 61613376, 61613863, 61613458, 61613474, 61619474, 61614252, 61614656, 61613262, 61614503, 61613228, 61614047, 61614323, 61618981, 61616841, 61613092]}, "name": "D. Distinct Characters Queries", "statement": "You are given a string s consisting of lowercase Latin letters and q\r\nqueries for this string.Recall that the substring s[l; r] of the string\r\ns is the string s_l s_{l + 1}\r\ndots s_r. For example, the substrings of \"\" are \"\", \"\", \"\", \"\", but not\r\n\"\" and \"\".There are two types of queries: 1\u00a0 pos\u00a0 c (1\r\nle pos\r\nle |s|, c is lowercase Latin letter): replace s_{pos} with c (set\r\ns_{pos} := c); 2\u00a0 l\u00a0 r (1\r\nle l\r\nle r\r\nle |s|): calculate the number of distinct characters in the substring\r\ns[l; r].\r\n", "solutions": ["#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int MAX_N = (int)1e5 + 777;\nconst int A     = 26;\n\nint tree[2 * MAX_N], n;\n\nvoid solve() {\n\tstring str;\n\tcin >> str;\n\n\tn = len(str);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint code = str[i] - 'a';\n\t\ttree[i + n] = 1 << code;\n\t}\n\n\tfor(int i = n - 1; i > 0; --i) {\n\t\ttree[i] = tree[2 * i] | tree[2 * i + 1];\n\t}\n\n\tint q;\n\tcin >> q;\n\n\twhile(q--) {\n\t\tint type;\n\t\tcin >> type;\n\n\t\tif(type == 1) {\n\t\t\tint pos;\n\t\t\tchar chr;\n\t\t\tcin >> pos >> chr;\n\t\t\t--pos;\n\t\t\tpos += n;\n\n\t\t\tint code = chr - 'a';\n\t\t\ttree[pos] = 1 << code;\n\n\t\t\tfor(; pos > 0; pos /= 2)\n\t\t\t\ttree[pos / 2] = tree[pos] | tree[pos ^ 1];\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l, --r;\n\t\t\tl += n, r += n;\n\t\t\t++r;\n\n\t\t\tint msk = 0;\n\n\t\t\twhile(l < r) {\n\t\t\t\tif(l & 1)\n\t\t\t\t\tmsk |= tree[l++];\n\n\t\t\t\tif(r & 1)\n\t\t\t\t\tmsk |= tree[--r];\n\n\t\t\t\tl /= 2;\n\t\t\t\tr /= 2;\n\t\t\t}\n\n\t\t\tint answ = 0;\n\n\t\t\tfor(int j = 0; j < A; ++j) {\n\t\t\t\tansw += (msk >> j) & 1;\n\t\t\t}\n\n\t\t\tcout << answ << '\\n';\n\t\t}\n\t}\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "1600", "interactive": false}