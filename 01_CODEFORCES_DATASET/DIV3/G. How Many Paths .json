{
    "link": "https://codeforces.com//contest/1547/problem/G",
    "problemId": "1041931",
    "problem_idx": "G",
    "shortId": "1547G",
    "contest_number": "1547",
    "problem_submissions": {
        "G": [
            121944344,
            121945250,
            121969047,
            121966817,
            121967594,
            121972943,
            121975745,
            121977858,
            122032964,
            121981350,
            122056223,
            121979237,
            121981913,
            121981376,
            121980625,
            122155991,
            121975434,
            121991454,
            121995068,
            121976725,
            121981904,
            121989177
        ],
        "F": [
            121935413,
            121935594,
            121941387,
            121951169,
            121954987,
            121958658,
            121946378,
            121960440,
            121957223,
            121947189,
            121953926,
            121961168,
            121956579,
            122155975,
            121957484,
            121963743,
            121963233,
            121983907,
            130067043,
            121967696,
            121964782
        ],
        "E": [
            121927323,
            121930033,
            121934266,
            121934350,
            121934750,
            121950868,
            121938700,
            121947044,
            121939016,
            121918151,
            121943738,
            121951247,
            121943401,
            122155944,
            121929091,
            121938064,
            121948603,
            121929249,
            121954857,
            121951226
        ],
        "D": [
            121920905,
            121925537,
            121926615,
            121928957,
            121929027,
            121935132,
            121933601,
            121938327,
            121930818,
            121951066,
            121937525,
            121939215,
            121938926,
            122155930,
            121923421,
            121931871,
            121939814,
            121923678,
            121938027,
            121939755
        ],
        "C": [
            121917301,
            121919644,
            121922161,
            121925361,
            121925131,
            121930197,
            121927618,
            121931352,
            121926041,
            121941579,
            121930327,
            121931481,
            121932549,
            122155920,
            121946724,
            121926871,
            121930207,
            121920117,
            121930152,
            121928271
        ],
        "B": [
            121913269,
            121913944,
            121915637,
            121917152,
            121916079,
            121921759,
            121916250,
            121921748,
            121918400,
            121932403,
            121917513,
            121922124,
            121917559,
            122155902,
            121918020,
            121915357,
            121920773,
            121914177,
            121922706,
            121919941
        ],
        "A": [
            121912871,
            121922538,
            121912963,
            121913157,
            121913099,
            121914913,
            121913485,
            121917366,
            121913258,
            121918822,
            121913536,
            121914396,
            121913813,
            122155895,
            121942243,
            121912931,
            121913822,
            121912948,
            121914731,
            121913859
        ]
    },
    "name": "G. How Many Paths ",
    "statement": "You are given a directed graph G which can contain loops (edges from a\r\nvertex to itself). Multi-edges are absent in G which means that for all\r\nordered pairs (u, v) exists at most one edge from u to v. Vertices are\r\nnumbered from 1 to n.A path from u to v is a sequence of edges such\r\nthat: vertex u is the start of the first edge in the path; vertex v is\r\nthe end of the last edge in the path; for all pairs of adjacent edges\r\nnext edge starts at the vertex that the previous edge ends on. We will\r\nassume that the empty sequence of edges is a path from u to u.For each\r\nvertex v output one of four values: 0, if there are no paths from 1 to\r\nv; 1, if there is only one path from 1 to v; 2, if there is more than\r\none path from 1 to v and the number of paths is finite; -1, if the\r\nnumber of paths from 1 to v is infinite. Let\u2019s look at the example shown\r\nin the figure. Then: the answer for vertex 1 is 1: there is only one\r\npath from 1 to 1 (path with length 0); the answer for vertex 2 is 0:\r\nthere are no paths from 1 to 2; the answer for vertex 3 is 1: there is\r\nonly one path from 1 to 3 (it is the edge (1, 3)); the answer for vertex\r\n4 is 2: there are more than one paths from 1 to 4 and the number of\r\npaths are finite (two paths: [(1, 3), (3, 4)] and [(1, 4)]); the answer\r\nfor vertex 5 is -1: the number of paths from 1 to 5 is infinite (the\r\nloop can be used in a path many times); the answer for vertex 6 is -1:\r\nthe number of paths from 1 to 6 is infinite (the loop can be used in a\r\npath many times).\r\n",
    "solutions": [
        "#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n, m;\n        cin >> n >> m;\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            g[x].push_back(y);\n        }\n\n        vector<int> used(n);\n        vector<int> dd(n);\n        vector<int> onc(n);\n\n        function<void(int)> dfs = [&](int v) {\n            used[v] = 1;\n            for (int i : g[v]) {\n                if (used[i] == 1) {\n                    onc[i] = 1;\n                } else if (used[i] == 2) {\n                    dd[i] = 1;\n                } else {\n                    dfs(i);\n                }\n            }\n            used[v] = 2;\n        };\n\n        dfs(0);\n\n        function<void(int)> dfs2 = [&](int v) {\n            for (int i : g[v]) {\n                if (!onc[i]) {\n                    onc[i] = 1;\n                    dfs2(i);\n                }\n            }\n        };\n\n        function<void(int)> dfs3 = [&](int v) {\n            for (int i : g[v]) {\n                if (!dd[i]) {\n                    dd[i] = 1;\n                    dfs3(i);\n                }\n            }\n        };\n\n        for (int i = 0; i < n; i++) {\n            if (onc[i]) {\n                dfs2(i);\n            }\n            if (dd[i]) {\n                dfs3(i);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                cout << \"0 \";\n            } else if (onc[i]) {\n                cout << \"-1 \";\n            } else if (dd[i]) {\n                cout << \"2 \";\n            } else {\n                cout << \"1 \";\n            }\n        }\n        cout << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. How Many Paths .json",
    "editorial_link": "https://codeforces.com//blog/entry/92715",
    "editorial": "The first motivation for solving this problem is to write a lot of\r\nstandard code like \"find strongly connected components\", do some DP over\r\nthe condensed graph (the graph of strongly connected components), and so\r\non.In fact, this problem can be solved much more elegantly with less\r\ncode if you have a little better understanding of how depth-first search\r\nworks.Consider a usual depth-first search on a digraph that is started\r\nfrom the vertex . This will be a normal depth-first search, which will\r\npaint vertices using three colors: white (the vertex has not yet been\r\nfound by the search), gray (the vertex is processing by DFS), and black\r\n(the vertex has already been processed by the DFS completely, that is,\r\ncompletely bypassed its subtree of the depth-first search tree).Here\u00e2\u0080\u0099s\r\nthe pseudocode:The following statements are true: there is a cycle in\r\nthe digraph reachable from if and only if the root call visits in the\r\nline when ; moreover, for each reachable cycle from there is at least\r\none vertex that will execute the previous item (then the vertex belongs\r\nto the cycle); if the root call visits in the line , when , then there\r\nis more than one path (the opposite is not true). It is clear that there\r\nare infinite paths from to if and only if there is a vertex on some path\r\nfrom to such that is in a cycle. Thus, we mark all such vertices for\r\nwhich at the moment of execution of the line . The fact is true: A\r\nsimilar fact is also true for finding vertices to which at least two\r\npaths (but a finite number) lead. Let\u00e2\u0080\u0099s mark all such vertices for which\r\nat the moment of execution of the line . The fact is true: So the\r\nsolution looks like this: let\u00e2\u0080\u0099s make a depth-first search from the root,\r\nmark during it those vertices that were gray when trying to go to them\r\n(group A) and were black when trying to go to them (group B); mark the\r\nvertices reachable from the group A (let\u00e2\u0080\u0099s call them AA); mark the\r\nvertices reachable from the group B (let\u00e2\u0080\u0099s call them BB); the answer for\r\nthe vertex is: if it is not reachable from (this determines the first\r\nDFS); , if it is from AA; if it is from BB (but not from AA); , if it is\r\nnot from AA and not from BB. In the author\u00e2\u0080\u0099s solution, only one dfs\r\nfunction was used with an additional boolean parameter to determine its\r\nmode.\r\n"
}