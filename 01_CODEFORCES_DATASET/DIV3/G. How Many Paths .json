{"link": "https://codeforces.com//contest/1547/problem/G", "problemId": "1041931", "problem_idx": "G", "shortId": "1547G", "contest_number": "1547", "problem_submissions": {"G": [121944344, 121945250, 121969047, 121966817, 121967594, 121972943, 121975745, 121977858, 122032964, 121981350, 122056223, 121979237, 121981913, 121981376, 121980625, 122155991, 121975434, 121991454, 121995068, 121976725, 121981904, 121989177], "F": [121935413, 121935594, 121941387, 121951169, 121954987, 121958658, 121946378, 121960440, 121957223, 121947189, 121953926, 121961168, 121956579, 122155975, 121957484, 121963743, 121963233, 121983907, 130067043, 121967696, 121964782], "E": [121927323, 121930033, 121934266, 121934350, 121934750, 121950868, 121938700, 121947044, 121939016, 121918151, 121943738, 121951247, 121943401, 122155944, 121929091, 121938064, 121948603, 121929249, 121954857, 121951226], "D": [121920905, 121925537, 121926615, 121928957, 121929027, 121935132, 121933601, 121938327, 121930818, 121951066, 121937525, 121939215, 121938926, 122155930, 121923421, 121931871, 121939814, 121923678, 121938027, 121939755], "C": [121917301, 121919644, 121922161, 121925361, 121925131, 121930197, 121927618, 121931352, 121926041, 121941579, 121930327, 121931481, 121932549, 122155920, 121946724, 121926871, 121930207, 121920117, 121930152, 121928271], "B": [121913269, 121913944, 121915637, 121917152, 121916079, 121921759, 121916250, 121921748, 121918400, 121932403, 121917513, 121922124, 121917559, 122155902, 121918020, 121915357, 121920773, 121914177, 121922706, 121919941], "A": [121912871, 121922538, 121912963, 121913157, 121913099, 121914913, 121913485, 121917366, 121913258, 121918822, 121913536, 121914396, 121913813, 122155895, 121942243, 121912931, 121913822, 121912948, 121914731, 121913859]}, "name": "G. How Many Paths ", "statement": "You are given a directed graph G which can contain loops (edges from a\r\nvertex to itself). Multi-edges are absent in G which means that for all\r\nordered pairs (u, v) exists at most one edge from u to v. Vertices are\r\nnumbered from 1 to n.A path from u to v is a sequence of edges such\r\nthat: vertex u is the start of the first edge in the path; vertex v is\r\nthe end of the last edge in the path; for all pairs of adjacent edges\r\nnext edge starts at the vertex that the previous edge ends on. We will\r\nassume that the empty sequence of edges is a path from u to u.For each\r\nvertex v output one of four values: 0, if there are no paths from 1 to\r\nv; 1, if there is only one path from 1 to v; 2, if there is more than\r\none path from 1 to v and the number of paths is finite; -1, if the\r\nnumber of paths from 1 to v is infinite. Let\u2019s look at the example shown\r\nin the figure. Then: the answer for vertex 1 is 1: there is only one\r\npath from 1 to 1 (path with length 0); the answer for vertex 2 is 0:\r\nthere are no paths from 1 to 2; the answer for vertex 3 is 1: there is\r\nonly one path from 1 to 3 (it is the edge (1, 3)); the answer for vertex\r\n4 is 2: there are more than one paths from 1 to 4 and the number of\r\npaths are finite (two paths: [(1, 3), (3, 4)] and [(1, 4)]); the answer\r\nfor vertex 5 is -1: the number of paths from 1 to 5 is infinite (the\r\nloop can be used in a path many times); the answer for vertex 6 is -1:\r\nthe number of paths from 1 to 6 is infinite (the loop can be used in a\r\npath many times).\r\n", "solutions": ["#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n, m;\n        cin >> n >> m;\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            g[x].push_back(y);\n        }\n\n        vector<int> used(n);\n        vector<int> dd(n);\n        vector<int> onc(n);\n\n        function<void(int)> dfs = [&](int v) {\n            used[v] = 1;\n            for (int i : g[v]) {\n                if (used[i] == 1) {\n                    onc[i] = 1;\n                } else if (used[i] == 2) {\n                    dd[i] = 1;\n                } else {\n                    dfs(i);\n                }\n            }\n            used[v] = 2;\n        };\n\n        dfs(0);\n\n        function<void(int)> dfs2 = [&](int v) {\n            for (int i : g[v]) {\n                if (!onc[i]) {\n                    onc[i] = 1;\n                    dfs2(i);\n                }\n            }\n        };\n\n        function<void(int)> dfs3 = [&](int v) {\n            for (int i : g[v]) {\n                if (!dd[i]) {\n                    dd[i] = 1;\n                    dfs3(i);\n                }\n            }\n        };\n\n        for (int i = 0; i < n; i++) {\n            if (onc[i]) {\n                dfs2(i);\n            }\n            if (dd[i]) {\n                dfs3(i);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                cout << \"0 \";\n            } else if (onc[i]) {\n                cout << \"-1 \";\n            } else if (dd[i]) {\n                cout << \"2 \";\n            } else {\n                cout << \"1 \";\n            }\n        }\n        cout << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "trees"], "dificulty": "2100", "interactive": false}