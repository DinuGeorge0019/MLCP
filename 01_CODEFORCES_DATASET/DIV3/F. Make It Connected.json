{
    "link": "https://codeforces.com//contest/1095/problem/F",
    "problemId": "275106",
    "problem_idx": "F",
    "shortId": "1095F",
    "contest_number": "1095",
    "problem_submissions": {
        "E": [
            47572493,
            47577391,
            47577601,
            47571130,
            47573480,
            47573851,
            47579488,
            47579243,
            47583313,
            47572977,
            47576569,
            47582897,
            47574546,
            47577946,
            47581685,
            47573841,
            47582231,
            47584199,
            47573945,
            47583101
        ],
        "F": [
            47566370,
            47573294,
            47562701,
            47573988,
            47579057,
            47581403,
            47572438,
            47566223,
            47578405,
            47576558,
            47583994,
            47577257,
            47570463,
            47582128,
            47586705,
            47807775,
            47807743,
            47807736,
            47807702,
            47586605,
            47608877,
            47573085,
            47580349,
            47588876,
            47585818
        ],
        "D": [
            47563209,
            47614712,
            47567371,
            47571011,
            47564325,
            47567777,
            47568284,
            47567860,
            47577158,
            47566286,
            47577441,
            47568324,
            47562890,
            47577182,
            47571848,
            47568920,
            47581067,
            47574935,
            47575170,
            47568243,
            47568626
        ],
        "C": [
            47559007,
            47560130,
            47566278,
            47559870,
            47560866,
            47562972,
            47564210,
            47560920,
            47562511,
            47560682,
            47563534,
            47559786,
            51809567,
            47573250,
            47561981,
            47566916,
            47564246,
            47565270,
            47562848,
            47563772,
            47565179
        ],
        "B": [
            47555392,
            47555193,
            47564009,
            47556364,
            47556516,
            47555175,
            47555868,
            47555467,
            47557131,
            47554642,
            47557601,
            47555771,
            47557598,
            47556456,
            47555954,
            47558351,
            47557404,
            47558162,
            47559339,
            47556593
        ],
        "A": [
            47554038,
            47554188,
            47553996,
            47553824,
            47555088,
            47553896,
            47554204,
            47554208,
            47554977,
            47553891,
            47554134,
            47554837,
            47554623,
            47554538,
            47554565,
            47555784,
            47555600,
            47554171,
            47557808,
            47555100
        ]
    },
    "name": "F. Make It Connected",
    "statement": "You are given an undirected graph consisting of n vertices. A number is\r\nwritten on each vertex; the number on vertex i is a_i. Initially there\r\nare no edges in the graph.You may add some edges to this graph, but you\r\nhave to pay for them. The cost of adding an edge between vertices x and\r\ny is a_x + a_y coins. There are also m special offers, each of them is\r\ndenoted by three numbers x, y and w, and means that you can add an edge\r\nconnecting vertices x and y and pay w coins for it. You don\u2019t have to\r\nuse special offers: if there is a pair of vertices x and y that has a\r\nspecial offer associated with it, you still may connect these two\r\nvertices paying a_x + a_y coins for it.What is the minimum number of\r\ncoins you have to spend to make the graph connected? Recall that a graph\r\nis connected if it\u2019s possible to get from any vertex to any other vertex\r\nusing only the edges belonging to this graph.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<\" \";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl '\\n'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<\" \"<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint par[200010];\nint root(int v){return par[v] < 0 ? v : (par[v] = root(par[v]));}\n\nint merge(int x,int y){\n    if((x = root(x)) == (y = root(y))) return 0 ;\n\tif(par[y] < par[x])\tswap(x, y);\n\tpar[x] += par[y];\n\tpar[y] = x;\n\treturn 1;\n}\n\n\nint main(){\n\tfast_io;\n\tfor (int i = 0; i < 200010; ++i)\n\t{\n\t\tpar[i]=-1;\n\t}\n\tint n,m;\n\tcin>>n>>m;\n\tvector<pair<ll,pair<int,int> > >edge;\n\tpair<ll,int> a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i].first;\n\t\ta[i].second=i+1;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tll x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tedge.push_back({z,{x,y}});\n\t}\n\tsort(a,a+n);\n\tfo(i,1,n-1){\n\t\tedge.push_back({a[i].first+a[0].first,{a[i].second,a[0].second}});\n\t}\n\tsort(edge.begin(), edge.end());\n\tll ans=0;\n\tfor(auto i:edge){\n\t\tint x=i.second.first;\n\t\tint y=i.second.second;\n\t\tll w=i.first;\n\t\tif(merge(x,y)){\n\t\t\tans+=w;\n\t\t}\n\t}\n\tshow(ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Make It Connected.json",
    "editorial_link": "https://codeforces.com//blog/entry/64130",
    "editorial": "Suppose we have found all the edges of the graph explicitly, sorted\r\nthem, and start running Kruskal on the sorted list of edges. Each time\r\nwe add some edge to MST, it is either a special edge given in the input,\r\nor an edge which was generated with cost (whichever costs less). Let\u00e2\u0080\u0099s\r\ntry to analyze how can we find the cheapest edge of each type that\r\nconnects two components. For special edges, we may just maintain the\r\nnumber of special edges we already added or skipped, and when choosing a\r\nnew edge, we skip some more (possibly zero) special edges that don\u00e2\u0080\u0099t\r\nconnect anything, until we find an edge that connects something. And for\r\nthe other type of edges, we may find two components having minimum\r\nnumbers on the vertices in those components as small as possible, and\r\njust connect the minimum vertex in the first component with the minimum\r\nvertex in the second component. We may simulate this by maintaining a\r\ndata structure (for example, a multiset), where for each component we\r\nwill store the vertex having minimum in this component, and pick two\r\nminimums from this set. We also have to be able to check if two vertices\r\nare connected (this can be done with DSU) and merge two components.But\r\nthis solution can be made easier. Every time we add a \"non-special\"\r\nedge, one of the ends of this edge is the vertex with minimum . So we\r\nmay just find this vertex, generate all edges connecting this vertex to\r\nall other vertices, merge this set of edges with the set of special\r\nedges, and run any MST algorithm on the resulting set of edges. If there\r\nare multiple minimums in the array , then we may pick any of them\r\nbecause in Kruskal algorithm it doesn\u00e2\u0080\u0099t matter which of the edges with\r\nequal costs we try to add first.\r\n"
}