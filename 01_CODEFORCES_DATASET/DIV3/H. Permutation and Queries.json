{
    "link": "https://codeforces.com//contest/1619/problem/H",
    "problemId": "1234629",
    "problem_idx": "H",
    "shortId": "1619H",
    "contest_number": "1619",
    "problem_submissions": {
        "G": [
            140078255,
            140073592,
            140089436,
            140078390,
            140089746,
            140079476,
            145924145,
            151265654,
            141670945,
            140147260
        ],
        "F": [
            140065181,
            140063048,
            140076024,
            140070362,
            140081694,
            140073270,
            140077189,
            140077988,
            140079343,
            140077681,
            140080239,
            140066442,
            140086181,
            140083843,
            140081135,
            140087882,
            140074406,
            140085836
        ],
        "E": [
            140056688,
            140034731,
            140064173,
            140064735,
            140063371,
            140067175,
            140068525,
            140064758,
            140060381,
            140065082,
            140053212,
            140051892,
            140072728,
            140067484,
            140070209,
            140073990,
            140083979,
            140064170
        ],
        "D": [
            140049695,
            140056611,
            140052445,
            140059443,
            140054727,
            140062375,
            140050362,
            140046453,
            140049546,
            140054923,
            140069697,
            140074223,
            140057739,
            140070163,
            140060824,
            140054342,
            140053714,
            140047137
        ],
        "C": [
            140041270,
            140047619,
            140037577,
            140053359,
            140066154,
            140055677,
            140034474,
            140041067,
            140041491,
            140044199,
            140042854,
            140041981,
            140038481,
            140037319,
            140043801,
            140042895,
            140046624,
            140037654
        ],
        "B": [
            140028867,
            140058223,
            140027097,
            140049372,
            140023898,
            140046113,
            140024005,
            140028515,
            140025918,
            140030098,
            140028524,
            140024247,
            140024021,
            140025866,
            140024580,
            140024963,
            140030726,
            140023456
        ],
        "A": [
            140018513,
            140037253,
            140018425,
            140048050,
            140017040,
            140043315,
            140017477,
            140024037,
            140017841,
            140019535,
            140020013,
            143793925,
            140020824,
            140018421,
            140017149,
            140018606,
            140017171,
            140021392,
            140017164
        ],
        "H": [
            140381628,
            140278376
        ]
    },
    "name": "H. Permutation and Queries",
    "statement": "You are given a permutation p of n elements. A permutation of n elements\r\nis an array of length n containing each integer from 1 to n exactly\r\nonce. For example, [1, 2, 3] and [4, 3, 5, 1, 2] are permutations, but\r\n[1, 2, 4] and [4, 3, 2, 1, 2] are not permutations. You should perform q\r\nqueries.There are two types of queries: 1 x y swap p_x and p_y. 2 i k\r\nprint the number that i will become if we assign i = p_i k times.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <utility>\n#include <cmath>\n#include <numeric>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pb push_back\n#define endl \"\\n\"\n#define all(x) x.begin(), x.end()\nconst int M = 200007;\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst double pi = acos(-1);\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint n, q, p[M], go[M], pref[M];\n\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> n >> q;\n    int block = sqrt(n);\n    for(int i = 1; i <= n; ++i) cin >> p[i];\n    for(int i = 1; i <= n; ++i){\n         pref[p[i]] = i;\n         int x = i;\n         for(int j = 0; j < block; ++j) x = p[x];\n         go[i] = x;\n    }\n    while(q--){\n        int t, x, y;\n        cin >> t >> x >> y;\n        if(t == 1){\n            swap(pref[p[x]], pref[p[y]]);\n            swap(p[x], p[y]);\n            int cur = x;\n            for(int i = 0; i < block; ++i) cur = p[cur];\n            for(int i = 0; i < block; ++i){\n                go[x] = cur;\n                cur = pref[cur];\n                x = pref[x];\n            }\n            cur = y;\n            for(int i = 0; i < block; ++i) cur = p[cur];\n            for(int i = 0; i < block; ++i){\n                go[y] = cur;\n                cur = pref[cur];\n                y = pref[y];\n            }\n        }\n        else{\n            while(y >= block){\n                y -= block;\n                x = go[x];\n            }\n            while(y--) x = p[x];\n            cout << x << endl;\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\H. Permutation and Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/98159",
    "editorial": "Let\u00e2\u0080\u0099s compute an array of integers answers to all possible second-type\r\nqueries with , . Now, if we have to perform any second-type query, we\r\ncan split it into at most queries with and at most queries with .Let\u00e2\u0080\u0099s\r\nalso compute an array of integers reverse permutation. If , then .To\r\nperform any first-type query, we should recompute , and . We can swap\r\nand in the array and and in the array No more than elements will be\r\nchanged in the array . These are elements with indexes ( elements) and (\r\nelements). We can recompute and then assign and times. Similarly for\r\n.Time complexity: .\r\n"
}