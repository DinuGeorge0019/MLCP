{
    "link": "https://codeforces.com//contest/1840/problem/E",
    "problemId": "1953890",
    "problem_idx": "E",
    "shortId": "1840E",
    "contest_number": "1840",
    "problem_submissions": {
        "F": [
            208833790,
            208800411,
            208738760,
            209755935,
            209049385,
            208856014,
            209001807,
            208972286,
            208793724,
            208849975,
            208903598,
            208797579
        ],
        "G1": [
            208785771,
            208798432,
            208798357,
            208759195,
            208773439,
            208768889,
            208784002,
            208782335,
            208787497,
            208757942,
            208778755,
            208795357,
            208767231,
            208800566,
            208774728,
            208784989
        ],
        "E": [
            208753398,
            208785836,
            208748100,
            208765491,
            208750014,
            208755889,
            208765809,
            208754982,
            208762975,
            208781811,
            208772087,
            208761782,
            208769368,
            208753067,
            208766710,
            208788699,
            208769932,
            208783505
        ],
        "D": [
            208744126,
            208768462,
            208780675,
            208742981,
            208738438,
            208740573,
            208744384,
            208743731,
            208753081,
            208742587,
            208741121,
            208744633,
            208752378,
            208785200,
            208747160,
            208737487,
            208749117,
            208750811
        ],
        "C": [
            208735712,
            208748530,
            208760247,
            208732224,
            208732082,
            208735505,
            208732760,
            208736708,
            208736616,
            208732221,
            208734089,
            208735409,
            208731496,
            208735170,
            208735073,
            208732504,
            208740037,
            208734211
        ],
        "B": [
            208731964,
            208736585,
            208755855,
            208723242,
            208728019,
            208731061,
            208728033,
            208728670,
            208729598,
            208727581,
            208727427,
            208728541,
            208726241,
            208724120,
            208726831,
            208725953,
            208755806,
            208732737,
            208735050
        ],
        "A": [
            208722150,
            208725086,
            208751995,
            208724436,
            208720280,
            208721134,
            208721012,
            208722594,
            208721192,
            208720913,
            208720713,
            208722663,
            208720260,
            208738330,
            208720865,
            208721050,
            208723621,
            208721860
        ],
        "G2": [
            208799121,
            208804613,
            209755710,
            211933185,
            208984229,
            208984015,
            208982917,
            208981704,
            208903638
        ]
    },
    "name": "E. Character Blocking",
    "statement": "You are given two strings of equal length s_1 and s_2, consisting of\r\nlowercase Latin letters, and an integer t.You need to answer q queries,\r\nnumbered from 1 to q. The i-th query comes in the i-th second of time.\r\nEach query is one of three types: block the characters at position pos\r\n(indexed from 1) in both strings for t seconds; swap two unblocked\r\ncharacters; determine if the two strings are equal at the time of the\r\nquery, ignoring blocked characters. Note that in queries of the second\r\ntype, the characters being swapped can be from the same string or from\r\ns_1 and s_2.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint k,q;\nchar s[N],t[N];\nvector<int >V[N];\nint tot;\nbool vis[N];\nvoid calc(int x)\n{\n\t\n}\nvoid solve()\n{\n\tscanf(\"%s\",s+1);\n\tscanf(\"%s\",t+1);\n\tn=strlen(s+1);\n\tk=read();\tq=read();\ttot=0;\n\tfor(int i=1;i<=n;++i)\tvis[i]=true;\n\tfor(int i=1;i<=q;++i)\tV[i].clear();\n\tfor(int i=1;i<=n;++i)\tif(s[i]!=t[i])\ttot++;\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tfor(auto v:V[i])\n\t\t{\n\t\t\tif(s[v]!=t[v])\ttot++;\n\t\t}\n\t\tint opt=read();\n\t\tif(opt==1)\n\t\t{\n\t\t\tint x=read();\n\t\t\tif(i+k<=q)\tV[i+k].push_back(x);\n\t\t\tif(s[x]!=t[x])\ttot--;\n\t\t}\n\t\tif(opt==2)\n\t\t{\n\t\t\tint t1=read();\tint p1=read();\n\t\t\tint t2=read();\tint p2=read();\n\t\t\tif(t1>t2)\n\t\t\t{\n\t\t\t\tswap(t1,t2);\n\t\t\t\tswap(p1,p2);\n\t\t\t}\n\t\t\tif(t2==1)\n\t\t\t{\n\t\t\t\tif(s[p1]!=t[p1])\ttot--;\n\t\t\t\tif(s[p2]!=t[p2])\ttot--;\n\t\t\t\tswap(s[p1],s[p2]);\n\t\t\t\tif(s[p1]!=t[p1])\ttot++;\n\t\t\t\tif(s[p2]!=t[p2])\ttot++;\n\t\t\t}\n\t\t\telse if(t1==2)\n\t\t\t{\n\t\t\t\tif(s[p1]!=t[p1])\ttot--;\n\t\t\t\tif(s[p2]!=t[p2])\ttot--;\n\t\t\t\tswap(t[p1],t[p2]);\n\t\t\t\tif(s[p1]!=t[p1])\ttot++;\n\t\t\t\tif(s[p2]!=t[p2])\ttot++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(s[p1]!=t[p1])\ttot--;\n\t\t\t\tif(s[p2]!=t[p2])\ttot--;\n\t\t\t\tswap(s[p1],t[p2]);\n\t\t\t\tif(s[p1]!=t[p1])\ttot++;\n\t\t\t\tif(s[p2]!=t[p2])\ttot++;\n\t\t\t}\n\t\t}\n\t\tif(opt==3)\n\t\t{\n\t\t\tputs(tot? \"NO\":\"YES\");\n\t\t}\n\t}\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Character Blocking.json",
    "editorial_link": "https://codeforces.com//blog/entry/117060",
    "editorial": "Two strings are equal if and only if there is no position such that the\r\ncharacters at position are not blocked and (we will call such a position\r\n). We will use this observation to maintain the current number of\r\npositions, denoted by .Let be an indicator variable. if position is ,\r\notherwise .During an operation (blocking or swapping), we only need to\r\nsubtract the indicator variables of all positions affected by the\r\noperation from . There will be of them. Then, we modify the string\r\naccording to the operation and add new indicator variables to .To\r\ncorrectly handle blocking queries, or more precisely, to unblock\r\npositions in time, we will use a queue. After each blocking query, we\r\nwill add a pair of numbers to the queue. The first number of the pair is\r\nthe position to unblock, and the second number is the time to unblock.\r\nNow, before each operation, we will unblock positions by looking at the\r\nhead of the queue.\r\n"
}