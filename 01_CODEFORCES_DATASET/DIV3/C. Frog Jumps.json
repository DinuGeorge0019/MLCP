{
    "link": "https://codeforces.com//contest/1324/problem/C",
    "problemId": "560262",
    "problem_idx": "C",
    "shortId": "1324C",
    "contest_number": "1324",
    "problem_submissions": {
        "F": [
            73054270,
            73065556,
            73059176,
            73065084,
            73062305,
            73067024,
            73059856,
            73063932,
            73057486,
            73044832,
            73066147,
            73064314,
            73050991,
            73068503,
            73056693,
            73068743,
            73052567,
            73072067,
            73067317
        ],
        "D": [
            73040639,
            73032866,
            73027867,
            73035134,
            73830730,
            73040900,
            73034199,
            73041603,
            73041893,
            73039400,
            73030102,
            73036508,
            73039182,
            73043928,
            73037342,
            73043874,
            73046595,
            73050863,
            73040463,
            73039200
        ],
        "E": [
            73039379,
            73044039,
            73041492,
            73041070,
            73050415,
            73046726,
            73048264,
            73049396,
            73051216,
            73055090,
            73048254,
            73047762,
            73057013,
            73049889,
            73066804,
            73056073,
            73038769,
            73127806,
            73056264,
            73050880
        ],
        "C": [
            73027564,
            73028513,
            73042083,
            73030836,
            73032053,
            73030173,
            73031129,
            73033349,
            73032347,
            73043701,
            73030001,
            73034619,
            73039260,
            73030506,
            73031218,
            73027677,
            73054056,
            73034579,
            73032723
        ],
        "B": [
            73024859,
            73025917,
            73029672,
            73087132,
            73084344,
            73028176,
            73026383,
            73025561,
            73026159,
            73028367,
            73028047,
            73036513,
            73025105,
            73030025,
            73029700,
            73025213,
            73026085,
            73024555,
            73033601,
            73026846,
            73023952
        ],
        "A": [
            73023467,
            73023622,
            73025341,
            73025903,
            73023578,
            73023714,
            73023863,
            73024673,
            73025477,
            73026756,
            73024229,
            73024181,
            73024019,
            73023479,
            73023850,
            73023303,
            73028896,
            73023916,
            73029846
        ]
    },
    "name": "C. Frog Jumps",
    "statement": "There is a frog staying to the left of the string s = s_1 s_2\r\nldots s_n consisting of n characters (to be more precise, the frog\r\ninitially stays at the cell 0). Each character of s is either ” or ”. It\r\nmeans that if the frog is staying at the i-th cell and the i-th\r\ncharacter is ”, the frog can jump only to the left. If the frog is\r\nstaying at the i-th cell and the i-th character is ”, the frog can jump\r\nonly to the right. ..The frog wants to reach the n+1-th cell. The frog\r\nchooses some value d (and cannot change it later) and jumps by no more\r\nthan d cells at once. I.e. if the i-th character is ” then the frog can\r\njump to any cell in a range [max(0, i - d); i - 1], and if the i-th\r\ncharacter is ” then the frog can jump to any cell in a range [i + 1;\r\nmin(n + 1; i + d)].The frog doesn’t want to jump far, so your task is to\r\nfind the minimum possible value of d such that the frog can reach the\r\ncell n+1 from the cell 0 if it can jump by no more than d cells at once.\r\n.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<ll> m;\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n    \tstring s;\n    \tcin >> s;\n    \tvector<int> bad;\n    \tbad.resize(s.size() + 1, 0);\n    \tfor (int j = 0; j < s.size(); j++)\n    \t\tif (s[j] == 'L')\n    \t\t\tbad[j + 1] = bad[j] + 1;\n    \tint ans = 0;\n    \tfor (int j = 0; j < bad.size(); j++)\n    \t\tans = max(ans, bad[j] + 1);\n    \tcout << ans << endl;\n    }\n\n\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "greedy",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Frog Jumps.json",
    "editorial_link": "https://codeforces.com//blog/entry/74714",
    "editorial": "The only observation we need is that we donât need to jump left at all.\r\nThis only decreases our position so we have less freedom after the jump\r\nto the left. Then, to minimize , we only need to jump between the\r\nclosest â cells. So, if we build the array , where is the position of\r\nthe -th â cell from left to right (-indexed), then the answer is .Time\r\ncomplexity: .\r\n",
    "hint": []
}