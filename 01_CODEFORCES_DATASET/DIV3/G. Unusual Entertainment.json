{"link": "https://codeforces.com//contest/1899/problem/G", "problemId": "2331134", "problem_idx": "G", "shortId": "1899G", "contest_number": "1899", "problem_submissions": {"F": [233143025, 233133982, 233130296, 233135870, 233148550, 233134446, 233142101, 233143528, 233137718, 233124178, 233156213, 233142736, 233146627, 233148250, 233151072, 233160085, 233144575, 233142191, 233145257], "G": [233138408, 233146326, 233159108, 233167876, 233139809, 233174157, 233151111, 233162558, 233172488, 233169093, 233111352, 233167938, 242655902, 233290539, 233290341, 233290070, 233289390, 233245121, 233170983, 233290531, 233287729, 233172360, 233175792, 233169702, 233171345, 233192789, 233177667, 233175782, 233178766], "E": [233114571, 233127232, 233121824, 233122699, 233130644, 233123626, 233133888, 233135449, 233124510, 233138032, 233128201, 233131969, 233135507, 233133374, 233128056, 233141353, 233143922, 233131851, 233131472, 233136155], "D": [233111699, 233121597, 233118099, 233117874, 233205451, 233126502, 233118119, 233124806, 233129661, 233120822, 233191880, 233146423, 233118570, 233129133, 233128652, 233206707, 233122554, 233128504, 233129136, 233124567, 233125679, 233129711], "C": [233108190, 233112630, 233112731, 233109007, 233111806, 233112675, 233116595, 233114564, 233114241, 233115530, 233131350, 233124886, 233117819, 233122046, 233110706, 233117591, 233116329, 233117499, 233115669, 233122737], "B": [233106685, 233108026, 233109547, 233105619, 233103878, 233109223, 233117329, 233111321, 233108212, 233111255, 233135350, 233111178, 233113286, 233109355, 233206110, 233136456, 233114316, 233109473, 233113702, 233110574, 233113403], "A": [233102009, 233097462, 233097385, 233097622, 233097414, 233102057, 233099804, 233098553, 233136611, 233099117, 233097804, 233097758, 233102063, 233104551, 233097360, 233101589, 233099162, 233098150]}, "name": "G. Unusual Entertainment", "statement": "A is a connected graph without cycles.A is an array consisting of n\r\ndistinct integers from 1 to n in any order. For example, [5, 1, 3, 2, 4]\r\nis a permutation, but [2, 1, 1] is not a permutation (as 1 appears twice\r\nin the array) and [1, 3, 2, 5] is also not a permutation (as n = 4, but\r\n5 is present in the array).After a failed shoot in the BrMeast video,\r\nAlex fell into depression. Even his birthday did not make him happy.\r\nHowever, after receiving a gift from Timofey, Alex\u2019s mood suddenly\r\nimproved. Now he spent days playing with the gifted constructor.\r\nRecently, he came up with an unusual entertainment.Alex builds a tree\r\nfrom his constructor, consisting of n vertices numbered from 1 to n,\r\nwith the root at vertex 1. Then he writes down each integer from 1 to n\r\nin some order, obtaining a permutation p. After that, Alex comes up with\r\nq triples of integers l, r, x. For each triple, he tries to determine if\r\nthere is at least one descendant of vertex x among the vertices p_l,\r\np_{l+1},\r\nldots, p_r.A vertex u is a descendant of vertex v if and only if\r\nmathrm{dist}(1, v) +\r\nmathrm{dist}(v, u) =\r\nmathrm{dist}(1, u), where\r\nmathrm{dist}(a, b) is the distance between vertices a and b. In other\r\nwords, vertex v must be on the path from the root to vertex u.Alex told\r\nZakhar about this entertainment. Now Alex tells his friend q triples as\r\ndescribed above, hoping that Zakhar can check for the presence of a\r\ndescendant. Zakhar is very sleepy, so he turned to you for help. Help\r\nZakhar answer all of Alex\u2019s questions and finally go to sleep.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nclass segtree_t {\n       public:\n        segtree_t *left, *right;\n        int l, r, m, val, lazy;\n\n        segtree_t(int l, int r) : l(l), r(r), m(l + r >> 1), val(0), lazy(0) {\n                if (l == r) return;\n                left = new segtree_t(l, m);\n                right = new segtree_t(m + 1, r);\n        }\n\n        void Update(int s, int t, int x) {\n                if (r < s or l > t) return;\n                if (s <= l && r <= t) {\n                        val += (r - l + 1) * x;\n                        lazy += x;\n                        return;\n                }\n                Down();\n                left->Update(s, t, x);\n                right->Update(s, t, x);\n                Up();\n        }\n\n        int Get(int s, int t) {\n                if (r < s or l > t) return 0;\n                if (s <= l && r <= t) return val;\n                Down();\n                return left->Get(s, t) + right->Get(s, t);\n        }\n\n        void Up() {\n                val = left->val + right->val;\n        }\n\n        void Down() {\n                left->lazy += lazy;\n                right->lazy += lazy;\n                right->val += lazy * (r - m);\n                left->val += lazy * (m - l + 1);\n                lazy = 0;\n        }\n};\n\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int t;\n        cin >> t;\n        while (t--) {\n                int n, q;\n                cin >> n >> q;\n                vector<vector<int>> adj(n);\n                for (int i = 0; i < n - 1; i++) {\n                        int u, v;\n                        cin >> u >> v;\n                        u--, v--;\n                        adj[u].emplace_back(v);\n                        adj[v].emplace_back(u);\n                }\n\n                vector<int> tin(n), tout(n), d(n);\n                int timer = 0;\n                vector<int> par(n);\n\n                function<void(int, int)> dfs = [&](int u, int p) {\n                        par[u] = p;\n                        tin[u] = timer++;\n                        for (int v : adj[u]) {\n                                if (v == p) continue;\n                                dfs(v, u);\n                                d[u] += d[v];\n                        }\n                        d[u]++;\n                        tout[u] = timer;\n                };\n                dfs(0, -1);\n\n                vector<int> a(n);\n                for (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\n                vector<vector<pair<int, int>>> qryL(n);\n                vector<vector<pair<int, int>>> qryR(n);\n                vector<int> b(q);\n\n                for (int i = 0; i < q; i++) {\n                        int l, r, x;\n                        cin >> l >> r >> x;\n                        l--, r--, x--;\n                        b[i] = x;\n                        qryL[l].emplace_back(i, x);\n                        qryR[r].emplace_back(i, x);\n                }\n\n                vector<int> sum(q);\n\n                segtree_t *tree = new segtree_t(0, n);\n\n                for (int i = 0; i < n; i++) {\n                        for (auto [id, x] : qryL[i]) {\n                                sum[id] += tree->Get(tin[x], tout[x] - 1);\n                        }\n                        tree->Update(tin[a[i]], tin[a[i]], +1);\n                }\n\n                tree = new segtree_t(0, n);\n\n                for (int i = n - 1; i >= 0; i--) {\n                        for (auto [id, x] : qryR[i]) {\n                                sum[id] += tree->Get(tin[x], tout[x] - 1);\n                        }\n                        tree->Update(tin[a[i]], tin[a[i]], +1);\n                }\n\n                for (int i = 0; i < q; i++) {\n                        if (sum[i] == d[b[i]]) {\n                                cout << \"NO\\n\";\n                        } else {\n                                cout << \"YES\\n\";\n                        }\n                }\n                cout << '\\n';\n        }\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dsu", "shortest paths", "sortings", "trees", "two pointers"], "dificulty": "1900", "interactive": false}