{
    "link": "https://codeforces.com//contest/1133/problem/F2",
    "problemId": "308950",
    "problem_idx": "F2",
    "shortId": "1133F2",
    "contest_number": "1133",
    "problem_submissions": {
        "D": [
            50977706,
            50947355,
            100723482,
            50948843,
            50965152,
            50935620,
            50935134,
            50952860,
            50961383,
            50959922,
            50946976,
            50948619,
            50947073,
            50956907,
            50943195,
            50949460,
            50954635,
            50944647,
            50949611,
            50956624,
            50946681
        ],
        "F2": [
            50968854,
            50972022,
            50971221,
            50968366,
            50974597,
            50974087,
            50943311,
            50962568,
            51093176,
            50963051,
            50977549,
            50968954,
            51769081,
            50977124
        ],
        "F1": [
            50959078,
            50955230,
            50953315,
            50941907,
            50960168,
            50965272,
            50946141,
            50954816,
            50951285,
            50952154,
            50957023,
            50955812,
            50957050,
            50952531,
            50960906,
            50958622,
            50953869,
            50954476
        ],
        "E": [
            50952051,
            50961583,
            50962693,
            50951706,
            50964620,
            50954025,
            50954150,
            51032280,
            50963022,
            50950927,
            50972774,
            50964124,
            50963306,
            50964161,
            50960490,
            50966174
        ],
        "C": [
            50941353,
            50944201,
            50940430,
            50966196,
            50945464,
            50942925,
            50961788,
            50941100,
            50944821,
            50937379,
            50934514,
            50937910,
            50939090,
            50938244,
            50940255,
            50945217,
            50944371,
            50941409
        ],
        "B": [
            50938985,
            50941949,
            50938577,
            50961461,
            50942033,
            50940896,
            50965475,
            50936621,
            50942180,
            50948476,
            50938680,
            50936870,
            50936790,
            50935051,
            50937755,
            50941216,
            50940158,
            50939408
        ],
        "A": [
            50935306,
            50937849,
            50935030,
            50945613,
            51260785,
            50935398,
            50937671,
            50967123,
            50933770,
            50933763,
            50935392,
            50934515,
            50935161,
            50934233,
            50933760,
            50935141,
            50934723,
            50937065,
            50936471
        ]
    },
    "name": "F2. Spanning Tree with One Fixed Degree",
    "statement": "You are given an undirected unweighted connected graph consisting of n\r\nvertices and m edges. It is guaranteed that there are no self-loops or\r\nmultiple edges in the given graph.Your task is to find spanning tree of\r\nthis graph such that the is equal to D (or say that there are no such\r\nspanning trees). Recall that the degree of a vertex is the number of\r\nedges incident to it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define INF 9223372036854775807\n#define M_PI 3.14159265358979323846\n\nint mod = INF;\n\nint fastPow(int b, int e){int r = 1;while(e){if(e%2 == 1){r*=b;r%=mod;}b*=b;b%=mod;e/=2;}return r;}\nint pgcd(int a, int b){ if(a%b == 0) return b; else return pgcd(b, a%b);}\nint sign(int a){if(a < 0){ return -1;}if(a == 0) {return 0;}return 1;}\nbool isPrime(int a){if(a == 1) {return false;}int f = sqrt(a);for(int i = 2; i<=f; i++){if(a%i == 0){return false;}}return true;}\nint toInt(string s){int tot = 0;for(int i = s.size()-1; i >= 0; i--){tot+=((s[i]-'0')%mod)*fastPow(10,i);tot%=mod;}return tot;}\nstring toString(int a){string s = \"\";while(a){s = (char)('0'+a%10) + s;a/=10;}return s;}\n\nint U[200009];\n\nint getParents(int a){\n    if(U[a] == a) return a;\n    else return U[a] = getParents(U[a]);\n}\n\nvoid Union(int a, int b){\n    U[getParents(a)] = getParents(b);\n}\n\nvector<int> Graph[200009];\n\nvector< bool > visited(200009);\n\nvoid dfs(int node){\n    visited[node] = true;\n    for(int a : Graph[node]){\n        if(visited[a]) continue;\n        dfs(a);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, d;\n    cin >> n >> m >> d;\n    vector< pair<int, int> > v(0);\n    vector< pair<int, int> > keep(0);\n    for(int i = 0; i < m; i++){\n        int a, b;\n        cin >> a >> b;\n        if(a == 1 || b == 1){\n            if(b == 1) swap(a,b);\n            v.push_back(make_pair(a,b));\n            continue;\n        }\n        keep.push_back({a,b});\n        Graph[a].push_back(b);\n        Graph[b].push_back(a);\n    }\n    int tot = 0;\n    for(int i = 0; i <= n; i++){\n        U[i] = i;\n    }\n    vector<int> head(0);\n    for(auto a : v){\n        if(!visited[a.second]){\n            head.push_back(a.second);\n            dfs(a.second);\n            tot++;\n        }\n    }\n    if(tot > d || v.size() < d){\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"YES\" << endl;\n    for(int a : head){\n        d--;\n        Union(1,a);\n        cout << 1 << ' ' << a << endl;\n    }\n    for(int i = 0; i < v.size(); i++){\n        if(!d) break;\n        if(getParents(1) != getParents(v[i].second)){\n            Union(1,v[i].second);\n            d--;\n            cout << 1 << ' ' << v[i].second << endl;\n        }\n    }\n    while(!keep.empty()){\n        pair<int, int> p = keep.back();\n        keep.pop_back();\n        int a = p.first;\n        int b = p.second;\n        if(getParents(a) != getParents(b)){\n            cout << a << ' ' << b << endl;\n            Union(a,b);\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F2. Spanning Tree with One Fixed Degree.json",
    "editorial_link": "https://codeforces.com//blog/entry/65807",
    "editorial": "Firstly, let\u00e2\u0080\u0099s remove the vertex from the graph. Then let\u00e2\u0080\u0099s calculate\r\nthe number of connected components. Let it be .The answer is if and only\r\nif or is greater than the number of edges incident to the first\r\nvertex.Otherwise let\u00e2\u0080\u0099s construct the answer. Firstly, let\u00e2\u0080\u0099s add into the\r\nnew graph spanning trees of components in the initial graph without\r\nvertex .Then let\u00e2\u0080\u0099s add into the new graph edges from vertex one edge to\r\neach component.Then let\u00e2\u0080\u0099s add into the new graph any remaining edges\r\nfrom vertex .The last thing we need is to construct a spanning tree of a\r\nnew graph such that all edges incident to the vertex are in this\r\nspanning tree (and other edges doesn\u00e2\u0080\u0099t matter).How to do it? Let\u00e2\u0080\u0099s run\r\nfrom the vertex in a new graph!\r\n"
}