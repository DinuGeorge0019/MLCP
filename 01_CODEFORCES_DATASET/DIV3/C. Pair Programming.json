{
    "link": "https://codeforces.com//contest/1547/problem/C",
    "problemId": "1041927",
    "problem_idx": "C",
    "shortId": "1547C",
    "contest_number": "1547",
    "problem_submissions": {
        "G": [
            121944344,
            121945250,
            121969047,
            121966817,
            121967594,
            121972943,
            121975745,
            121977858,
            122032964,
            121981350,
            122056223,
            121979237,
            121981913,
            121981376,
            121980625,
            122155991,
            121975434,
            121991454,
            121995068,
            121976725,
            121981904,
            121989177
        ],
        "F": [
            121935413,
            121935594,
            121941387,
            121951169,
            121954987,
            121958658,
            121946378,
            121960440,
            121957223,
            121947189,
            121953926,
            121961168,
            121956579,
            122155975,
            121957484,
            121963743,
            121963233,
            121983907,
            130067043,
            121967696,
            121964782
        ],
        "E": [
            121927323,
            121930033,
            121934266,
            121934350,
            121934750,
            121950868,
            121938700,
            121947044,
            121939016,
            121918151,
            121943738,
            121951247,
            121943401,
            122155944,
            121929091,
            121938064,
            121948603,
            121929249,
            121954857,
            121951226
        ],
        "D": [
            121920905,
            121925537,
            121926615,
            121928957,
            121929027,
            121935132,
            121933601,
            121938327,
            121930818,
            121951066,
            121937525,
            121939215,
            121938926,
            122155930,
            121923421,
            121931871,
            121939814,
            121923678,
            121938027,
            121939755
        ],
        "C": [
            121917301,
            121919644,
            121922161,
            121925361,
            121925131,
            121930197,
            121927618,
            121931352,
            121926041,
            121941579,
            121930327,
            121931481,
            121932549,
            122155920,
            121946724,
            121926871,
            121930207,
            121920117,
            121930152,
            121928271
        ],
        "B": [
            121913269,
            121913944,
            121915637,
            121917152,
            121916079,
            121921759,
            121916250,
            121921748,
            121918400,
            121932403,
            121917513,
            121922124,
            121917559,
            122155902,
            121918020,
            121915357,
            121920773,
            121914177,
            121922706,
            121919941
        ],
        "A": [
            121912871,
            121922538,
            121912963,
            121913157,
            121913099,
            121914913,
            121913485,
            121917366,
            121913258,
            121918822,
            121913536,
            121914396,
            121913813,
            122155895,
            121942243,
            121912931,
            121913822,
            121912948,
            121914731,
            121913859
        ]
    },
    "name": "C. Pair Programming",
    "statement": "Monocarp and Polycarp are learning new programming techniques. Now they\r\ndecided to try pair programming.It’s known that they have worked\r\ntogether on the same file for n + m minutes. Every minute exactly one of\r\nthem made one change to the file. Before they started, there were\r\nalready k lines written in the file.Every minute exactly one of them\r\ndoes one of two actions: adds a new line to the end of the file or\r\nchanges one of its lines.Monocarp worked in total for n minutes and\r\nperformed the sequence of actions [a_1, a_2,\r\ndots, a_n]. If a_i = 0, then he adds a new line to the end of the file.\r\nIf a_i > 0, then he changes the line with the number a_i. Monocarp\r\nperformed actions strictly in this order: a_1, then a_2, ...,\r\na_n.Polycarp worked in total for m minutes and performed the sequence of\r\nactions [b_1, b_2,\r\ndots, b_m]. If b_j = 0, then he adds a new line to the end of the file.\r\nIf b_j > 0, then he changes the line with the number b_j. Polycarp\r\nperformed actions strictly in this order: b_1, then b_2, ...,\r\nb_m.Restore their common sequence of actions of length n + m such that\r\nall actions would be correct there should be no changes to lines that do\r\nnot yet exist. Keep in mind that in the common sequence Monocarp’s\r\nactions should form the subsequence [a_1, a_2,\r\ndots, a_n] and Polycarp’s subsequence [b_1, b_2,\r\ndots, b_m]. They can replace each other at the computer any number of\r\ntimes.Let’s look at an example. Suppose k = 3. Monocarp first changed\r\nthe line with the number 2 and then added a new line (thus, n = 2,\r\n: a = [2, 0]). Polycarp first added a new line and then changed the line\r\nwith the number 5 (thus, m = 2,\r\n: b = [0, 5]).Since the initial length of the file was 3, in order for\r\nPolycarp to change line number 5 two new lines must be added beforehand.\r\nExamples of correct sequences of changes, in this case, would be [0, 2,\r\n0, 5] and [2, 0, 0, 5]. Changes [0, 0, 5, 2] (wrong order of actions)\r\nand [0, 5, 2, 0] (line 5 cannot be edited yet) are not correct.\r\n",
    "solutions": [
        "#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int k, n, m;\n        cin >> k >> n >> m;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        int x = 0, y = 0;\n        vector<int> ans;\n        for (int z = 0; z < n + m; z++) {\n            if (x < n && a[x] == 0) {\n                ans.push_back(0);\n                x++;\n                k++;\n            } else if (y < m && b[y] == 0) {\n                ans.push_back(0);\n                y++;\n                k++;\n            } else if (y == m || (x < n && a[x] < b[y])) {\n                if (a[x] > k) {\n                    cout << \"-1\\n\";\n                    return;\n                }\n                ans.push_back(a[x++]);\n            } else {\n                if (b[y] > k) {\n                    cout << \"-1\\n\";\n                    return;\n                }\n                ans.push_back(b[y++]);\n            }\n        }\n        for (int i : ans) {\n            cout << i << \" \";\n        }\n        cout << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "two pointers"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Pair Programming.json",
    "editorial_link": "https://codeforces.com//blog/entry/92715",
    "editorial": "The solution is that if we can do something, letâs do it. It doesnât\r\nmake sense not to act, because neither adding a new row nor modifying an\r\nexisting one can prevent the existing row from being changed in the\r\nfuture. Therefore, we will iterate over the actions and eagerly act\r\nMonocarp or Polycarp.Letâs create two pointers and in arrays and index\r\nof possible action of Monocarp and Polycarp and the current length of\r\nthe file.Suppose that or on current iteration. Then we take the\r\nappropriate zero element and increase by one. We can do that because\r\nappending a new line cannot make a new answer prefix incorrect if the\r\nprevious prefix was correct.Suppose that and . If and then there is no\r\nanswer because we can potentially do only two actions and both make the\r\nanswer incorrect. If one number is greater than and the other is less\r\nthan or equals then we take the one that less than or equals .If one of\r\nthe sequences or ends then only one potential action needs to be checked\r\nat each iteration.\r\n",
    "hint": []
}