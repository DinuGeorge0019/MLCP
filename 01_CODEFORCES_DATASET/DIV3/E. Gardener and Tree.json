{
    "link": "https://codeforces.com//contest/1593/problem/E",
    "problemId": "1142166",
    "problem_idx": "E",
    "shortId": "1593E",
    "contest_number": "1593",
    "problem_submissions": {
        "G": [
            131796315,
            131809860,
            131836830,
            131839082,
            131841650,
            131846524,
            131852907,
            131782296,
            148479901,
            131828563
        ],
        "D2": [
            131785134,
            131788443,
            131789598,
            131915775,
            131805880,
            131823322,
            131831578,
            131821525,
            131793982,
            131849437,
            131784594,
            131791388,
            131828383,
            131836476,
            131831664,
            131825743,
            131905244,
            131794334
        ],
        "F": [
            131781426,
            131837226,
            131815253,
            131811669,
            131876285,
            131849937,
            131847427,
            131845860,
            131816994,
            131855037,
            131787838,
            131800685,
            131891194
        ],
        "E": [
            131774861,
            131775908,
            131796997,
            131786728,
            131876206,
            131792098,
            131797221,
            131825650,
            131807172,
            131832634,
            131793728,
            131840729,
            131794124,
            131808830,
            131787792,
            131786397,
            131783883,
            131789053,
            223850329,
            131905293,
            131805482
        ],
        "B": [
            131755249,
            131755158,
            131757455,
            131754198,
            131760377,
            131758125,
            131761538,
            131761685,
            131807386,
            131800607,
            131823956,
            131758842,
            131777000,
            131762147,
            131758359,
            131757156,
            131752418,
            131759279,
            131754084,
            131765706
        ],
        "C": [
            131755086,
            131765317,
            131761314,
            131762977,
            131768274,
            131765107,
            131772896,
            131769864,
            131760280,
            131765951,
            131827956,
            131767746,
            131761402,
            131771022,
            131806450,
            131797380,
            131767699,
            131763033,
            131759309,
            131766132,
            131759703,
            131774485
        ],
        "D1": [
            131754873,
            131770215,
            131766394,
            131756595,
            131776207,
            131772281,
            131769846,
            131778601,
            131766158,
            131773159,
            131795293,
            131772976,
            131778104,
            131776921,
            131775662,
            131772715,
            131771125,
            131769653,
            131765142,
            131779945
        ],
        "A": [
            131752757,
            131748062,
            131750155,
            131748058,
            131749835,
            131748696,
            131748309,
            131753208,
            131799940,
            131756190,
            131825544,
            131751230,
            131754683,
            131752419,
            131750607,
            131749631,
            131748206,
            131752432,
            131748594,
            131755250
        ]
    },
    "name": "E. Gardener and Tree",
    "statement": "A tree is an undirected connected graph in which there are no cycles.\r\nThis problem is about non-rooted trees. A leaf of a tree is a vertex\r\nthat is connected to vertex.The gardener Vitaly grew a tree from n\r\nvertices. He decided to trim the tree. To do this, he performs a number\r\nof operations. In one operation, he removes leaves of the tree. For\r\nexample, consider the tree shown in the figure above. The figure below\r\nshows the result of applying exactly one operation to the tree. Note the\r\nspecial cases of the operation: applying an operation to an empty tree\r\n(of 0 vertices) does not change it; applying an operation to a tree of\r\none vertex removes this vertex (this vertex is treated as a leaf);\r\napplying an operation to a tree of two vertices removes both vertices\r\n(both vertices are treated as leaves). Vitaly applied k operations\r\nsequentially to the tree. How many vertices remain?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=400005;\nqueue<int> q;\nint t,n,k,kt[N],d[N];\nvector<int> a[N];\nint main() {\n  \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>n>>k;\n        for (int i=1;i<=n;i++) {\n            kt[i]=d[i]=0;\n            a[i].clear();\n        }\n        for (int i=1;i<n;i++) {\n            int u,v;\n            cin>>u>>v;\n            a[u].push_back(v);\n            a[v].push_back(u);\n            d[u]++;\n            d[v]++;\n        }\n        int res=n;\n        for (int i=1;i<=n;i++)\n        if (d[i]<=1) {\n            q.push(i);\n            kt[i]=1;\n        }\n        while (!q.empty()) {\n\n            int u=q.front();\n            res--;\n            q.pop();\n            if (kt[u]==k) continue;\n            for (auto v:a[u])\n            if (!kt[v]) {\n                d[v]--;\n                if (d[v]<=1) {\n                    kt[v]=kt[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n        cout<<res<<\"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Gardener and Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/96034",
    "editorial": "Let\u00e2\u0080\u0099s create two arrays of length . The element of the array will\r\ncontain the operation number at which the vertex which is the index of\r\nthe array will be deleted. The array will contain the number of\r\nneighbors of a given vertex at a certain time. This array must be\r\ninitialized with the number of neighbors in the original tree.Initially,\r\nwe will suppose that the gardener performs an infinite number of\r\noperations, and we will simply calculate for each vertex the number of\r\nthe operation on which it will be deleted. Let\u00e2\u0080\u0099s create a queue , which\r\nwill store the order of deleting vertices. The queue will contain only\r\nthose vertices whose neighbors, except, maybe, one, have been removed\r\n(i.e. ). Let\u00e2\u0080\u0099s add all leaves of the original tree to it, for each of\r\nthem let\u00e2\u0080\u0099s store the value in the array (because all original leaves\r\nwill be removed during the first operation).Next, we will take\r\nsequentially one vertex from the queue and update the data about its\r\nneighbors. Consider the neighbors. Since we are deleting the current\r\nvertex, we need to update of its neighbors. If the neighbor\u00e2\u0080\u0099s is equal\r\nto , then it\u00e2\u0080\u0099s already in the queue and it doesn\u00e2\u0080\u0099t need to be considered\r\nright now. Otherwise, we will decrease the neighbor\u00e2\u0080\u0099s by . If it becomes\r\nequal to , then the neighbor must be added to the queue. The number of\r\nthe operation during which the neighbor will be deleted is equal to the\r\nnumber of the operation during which the current vertex will be deleted\r\nplus .After we calculate the numbers of operations for all vertices, we\r\nneed to select among them those that will not be deleted during\r\noperations with numbers . Thus, the answer is the number of vertices\r\nsuch that .\r\n"
}