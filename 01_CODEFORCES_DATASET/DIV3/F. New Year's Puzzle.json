{
    "link": "https://codeforces.com//contest/1472/problem/F",
    "problemId": "854356",
    "problem_idx": "F",
    "shortId": "1472F",
    "contest_number": "1472",
    "problem_submissions": {
        "F": [
            103262561,
            103276963,
            103283145,
            103236120,
            103299603,
            103280037,
            103283982,
            103299636,
            103262171,
            103266435,
            103266707,
            103276432,
            103305724,
            103305561,
            103312140,
            103296820,
            103289516
        ],
        "G": [
            103247133,
            103238309,
            103265834,
            103256471,
            103273915,
            103293538,
            103298242,
            103268903,
            103231487,
            103253031,
            103265141,
            103262744,
            103269566,
            103284052,
            103274415
        ],
        "E": [
            103232102,
            103223895,
            103237385,
            103272807,
            103242184,
            103256098,
            103261560,
            103284295,
            103272410,
            103347793,
            103285217,
            103237054,
            103246827,
            103233098,
            103239873,
            103242625,
            103245603,
            103246214,
            103227701,
            103253419
        ],
        "D": [
            103207950,
            103207957,
            103217168,
            103202671,
            103216674,
            103217143,
            103225940,
            103215649,
            103278518,
            103287434,
            103203579,
            103227081,
            103193660,
            103216373,
            103212463,
            103198886,
            103214065,
            103204468,
            103205436
        ],
        "C": [
            103194323,
            103193866,
            103191356,
            103198459,
            103198975,
            103205574,
            103191182,
            103243332,
            103280810,
            103289310,
            103198851,
            103199943,
            103206511,
            103207377,
            103204240,
            103192503,
            103203543,
            103196542,
            103198696
        ],
        "B": [
            103191009,
            103189264,
            103188527,
            103213801,
            103193697,
            103201611,
            103200035,
            103198875,
            103286479,
            103291761,
            103193834,
            103194538,
            103187178,
            103193610,
            103194731,
            103188054,
            103194899,
            103190639,
            103190538
        ],
        "A": [
            103186521,
            103187194,
            103186563,
            103201739,
            103187144,
            103188906,
            103207506,
            103187635,
            103246273,
            103293364,
            103186560,
            103189197,
            103194552,
            103186844,
            103187875,
            103186517,
            103187671,
            103186808,
            103186538
        ]
    },
    "name": "F. New Year's Puzzle",
    "statement": "Polycarp got the following problem: given a grid strip of size 2\r\ntimes n, some cells of it are blocked. You need to check if it is\r\npossible to tile all free cells using the 2\r\ntimes 1 and 1\r\ntimes 2 tiles (dominoes).For example, if n = 5 and the strip looks like\r\nthis (black cells are blocked): Then it can be tiled, for example, using\r\ntwo vertical and two horizontal tiles, as in the picture below\r\n(different tiles are marked by different colors). And if n = 3 and the\r\nstrip looks like this: It is impossible to tile free cells.Polycarp\r\neasily solved this task and received his New Yearâ€™s gift. Can you solve\r\nit?\r\n",
    "solutions": [
        "/**\n ____ ____ ____ ____ ____\n||a |||t |||o |||d |||o ||\n||__|||__|||__|||__|||__||\n|/__\\|/__\\|/__\\|/__\\|/__\\|\n\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M_MAX = 200002;\n\nint t;\n\nint n, m;\n\nstruct Block\n{\n    int a, b;\n};\n\nbool operator < (const Block &x, const Block &y)\n{\n    return x.b < y.b;\n}\n\nBlock v[M_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n >> m;\n        for(int i = 1; i <= m; i++)\n            cin >> v[i].a >> v[i].b;\n        sort(v + 1, v + m + 1);\n        bool complete = true;\n        bool answer = true;\n        for(int i = 1; i <= m && answer == true; i++)\n        {\n            if(v[i].b == v[i - 1].b)\n                continue;\n            if(i < m && v[i].b == v[i + 1].b)\n            {\n                answer = complete;\n                continue;\n            }\n            if(complete == true)\n            {\n                complete = false;\n                continue;\n            }\n            if(v[i].a == v[i - 1].a)\n            {\n                if((v[i].b - v[i - 1].b) % 2 == 0)\n                    answer = false;\n                else\n                    complete = true;\n            }\n            else\n            {\n                if((v[i].b - v[i - 1].b) % 2 == 1)\n                    answer = false;\n                else\n                    complete = true;\n            }\n        }\n        if(complete == false)\n            answer = false;\n        if(answer == true)\n            cout << \"YES\\n\";\n        else\n            cout << \"NO\\n\";\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "graph matchings",
        "greedy",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. New Year's Puzzle.json",
    "editorial_link": "https://codeforces.com//blog/entry/86406",
    "editorial": "If the first column is empty, we can always cover it with a vertical\r\ntile: if the next column is also empty, then we will have to put either\r\ntwo vertical or two horizontal tiles, but they are obtained from each\r\nother by rotating; if the next column contains at least one blocked\r\ncell, then we have no other options but to cover the column with a\r\nvertical board. If the first column is fully blocked, then we can just\r\nskip it.Remove such columns from the beginning, reducing the problem.\r\nNow the first column contains one empty and one blocked cell. Obviously,\r\nin place of an empty cell, we will have to place a horizontal tile. If\r\nthis did not work, then the tiling does not exist. Otherwise there are\r\ntwo cases: if the next column is empty, it will turn into a column with\r\none occupied cell. Then we continue to put horizontal tiles; if the next\r\ncolumn contains one blocked cell, then it becomes fully blocked and we\r\nreturn to the first step. It turns out the following greedy algorithm,\r\nwe sort all columns with at least one cell blocked (there are no more\r\nthan such columns) by number. Now, if we see a column with one occupied\r\ncell, then the next one must also be with one occupied cell (we skipped\r\nthe empty columns), but this cell must have a different color in the\r\nchess coloring (so that we can tile the space between them with\r\nhorizontal boards. This check is easy to do after sorting the columns.\r\n",
    "hint": []
}