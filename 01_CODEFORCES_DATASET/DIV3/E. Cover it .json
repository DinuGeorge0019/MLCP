{
    "link": "https://codeforces.com//contest/1176/problem/E",
    "problemId": "356087",
    "problem_idx": "E",
    "shortId": "1176E",
    "contest_number": "1176",
    "problem_submissions": {
        "F": [
            55366536,
            55370553,
            55370076,
            55361482,
            55349957,
            55373782,
            55383169,
            55421204,
            55381361
        ],
        "D": [
            55352843,
            55361188,
            55360704,
            55370696,
            55358745,
            55347526,
            55359651,
            55356479,
            55361066,
            55360096,
            55360897,
            55358553,
            55352085,
            55359124,
            55360813,
            55363517,
            55362204,
            55360723,
            55360975,
            55364720
        ],
        "E": [
            55349152,
            55349756,
            55351649,
            55354804,
            55365594,
            55358360,
            55348657,
            55350850,
            55353780,
            55351477,
            62626593,
            55421378,
            55390144,
            55390011,
            55389979,
            55389924,
            55350785,
            55361448,
            55351241,
            55350527,
            55353065,
            55353378,
            55348945,
            55354346,
            55353391
        ],
        "C": [
            55342677,
            55351695,
            55338466,
            55345985,
            55363580,
            55342563,
            55343971,
            55347250,
            55345645,
            55345777,
            55347227,
            55345382,
            55347101,
            55344713,
            55348024,
            55345956,
            55344452,
            55349792,
            55346750
        ],
        "B": [
            55338190,
            55339928,
            55338713,
            55340244,
            55360985,
            55338545,
            55340194,
            55344577,
            55338952,
            55340812,
            55340557,
            55340932,
            55341245,
            55341745,
            55340147,
            55340311,
            55339019,
            55342585,
            55340210
        ],
        "A": [
            55337291,
            55337321,
            55338350,
            55337635,
            55360313,
            55337458,
            55338052,
            55339410,
            55337348,
            55337956,
            55338200,
            55338309,
            55337308,
            55337677,
            55337569,
            55337795,
            55337752,
            55337587,
            55338006
        ]
    },
    "name": "E. Cover it ",
    "statement": "You are given an undirected unweighted connected graph consisting of n\r\nvertices and m edges. It is guaranteed that there are no self-loops or\r\nmultiple edges in the given graph.Your task is to choose\r\nlfloor\r\nfrac{n}{2}\r\nrfloor vertices in this graph so unchosen vertex is adjacent (in other\r\nwords, connected by an edge) to at least one of chosen vertices.It is\r\nguaranteed that the answer exists. If there are multiple answers, you\r\ncan print any.You will be given multiple independent queries to answer.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=200005;\nint t,n,m,head[Maxn],tot,cnt,vis[Maxn];\nstruct edg\n{\n\tint nxt,to;\n}edge[2*Maxn];\nvoid add(int x,int y)\n{\n\tedge[++cnt]=(edg){head[x],y};\n\thead[x]=cnt;\n}\nvoid dfs(int u)\n{\n\tfor(int i=head[u];i;i=edge[i].nxt)\n\t{\n\t\tint to=edge[i].to;\n\t\tif(!vis[to])\n\t\t\tvis[to]=vis[u]==1?2:1,dfs(to);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\ttot=0;\n\t\tcnt=0;\n\t\tmemset(head,0,sizeof(int[n+1]));\n\t\tmemset(vis,0,sizeof(int[n+1]));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tadd(a,b);\n\t\t\tadd(b,a);\n\t\t}\n\t\tvis[1]=1;\n\t\tdfs(1);\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ttot+=(vis[i]==1);\n\t\tif(tot*2>n)\n\t\t{\n\t\t\tprintf(\"%d\\n\",n-tot);\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(vis[i]==2)\n\t\t\t\t\tprintf(\"%d \",i);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",tot);\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(vis[i]==1)\n\t\t\t\t\tprintf(\"%d \",i);\n\t\t\tprintf(\"\\n\"); \n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "shortest paths",
        "trees"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Cover it .json",
    "editorial_link": "https://codeforces.com/blog/entry/67598",
    "editorial": "Firstly, letâs run bfs on the given graph and calculate distances for\r\nall vertices. In fact, we donât need distances, we need their parities.\r\nThe second part is to find all vertices with an even distance, all\r\nvertices with and odd distance, and print the smallest by size part. Why\r\nis it always true? Firstly, it is obvious that at least one of these\r\nsizes will not exceed . And secondly, because we are checking just\r\nparities of distances, it is obvious that each vertex of some parity is\r\nconnected with at least one vertex of the opposite parity (because it\r\nhas this parity from some vertex of the opposite parity).\r\n",
    "hint": []
}