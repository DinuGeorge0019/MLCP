{
    "link": "https://codeforces.com//contest/1324/problem/E",
    "problemId": "560264",
    "problem_idx": "E",
    "shortId": "1324E",
    "contest_number": "1324",
    "problem_submissions": {
        "F": [
            73054270,
            73065556,
            73059176,
            73065084,
            73062305,
            73067024,
            73059856,
            73063932,
            73057486,
            73044832,
            73066147,
            73064314,
            73050991,
            73068503,
            73056693,
            73068743,
            73052567,
            73072067,
            73067317
        ],
        "D": [
            73040639,
            73032866,
            73027867,
            73035134,
            73830730,
            73040900,
            73034199,
            73041603,
            73041893,
            73039400,
            73030102,
            73036508,
            73039182,
            73043928,
            73037342,
            73043874,
            73046595,
            73050863,
            73040463,
            73039200
        ],
        "E": [
            73039379,
            73044039,
            73041492,
            73041070,
            73050415,
            73046726,
            73048264,
            73049396,
            73051216,
            73055090,
            73048254,
            73047762,
            73057013,
            73049889,
            73066804,
            73056073,
            73038769,
            73127806,
            73056264,
            73050880
        ],
        "C": [
            73027564,
            73028513,
            73042083,
            73030836,
            73032053,
            73030173,
            73031129,
            73033349,
            73032347,
            73043701,
            73030001,
            73034619,
            73039260,
            73030506,
            73031218,
            73027677,
            73054056,
            73034579,
            73032723
        ],
        "B": [
            73024859,
            73025917,
            73029672,
            73087132,
            73084344,
            73028176,
            73026383,
            73025561,
            73026159,
            73028367,
            73028047,
            73036513,
            73025105,
            73030025,
            73029700,
            73025213,
            73026085,
            73024555,
            73033601,
            73026846,
            73023952
        ],
        "A": [
            73023467,
            73023622,
            73025341,
            73025903,
            73023578,
            73023714,
            73023863,
            73024673,
            73025477,
            73026756,
            73024229,
            73024181,
            73024019,
            73023479,
            73023850,
            73023303,
            73028896,
            73023916,
            73029846
        ]
    },
    "name": "E. Sleeping Schedule",
    "statement": "Vova had a pretty weird sleeping schedule. There are h hours in a day.\r\nVova will sleep exactly n times. The i-th time he will sleep exactly\r\nafter a_i hours from the time he woke up. You can assume that Vova woke\r\nup exactly at the beginning of this story (the initial time is 0). Each\r\ntime Vova sleeps (in other words, h hours).Vova thinks that the i-th\r\nsleeping time is if he starts to sleep between hours l and r\r\ninclusive.Vova can control himself and before the i-th time can choose\r\nbetween two options: go to sleep after a_i hours or after a_i - 1\r\nhours.Your task is to say the maximum number of sleeping times Vova can\r\nobtain if he acts optimally.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define F first\n#define S second\ntypedef long long   ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;  \n\nll n;\nvector<ll> m;\n\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, h, l, r;\n    cin >> n >> h >> l >> r;\n    vector<ll> a;\n    a.resize(n);\n    for (int i = 0; i < n; i++)\n    \tcin >> a[i];\n\n    vector<vector<int>> dp;\n    dp.resize(n + 1);\n    for (int i = 0; i < n + 1; i++)\n    \tdp[i].resize(h, -10000000);\n    dp[0][0] = 0;\n\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n    \tfor (int j = 0; j < h; j++) {\n    \t\tint prev1 = j - a[i - 1];\n    \t\twhile (prev1 < 0)\n    \t\t\tprev1 += h;\n    \t\twhile (prev1 >= h)\n    \t\t\tprev1 -= h;\n    \t\tint prev2 = j - a[i - 1] + 1;\n    \t\twhile (prev2 < 0)\n    \t\t\tprev2 += h;\n    \t\twhile (prev2 >= h)\n    \t\t\tprev2 -= h;\n\n    \t\tdp[i][j] = max(dp[i - 1][prev1], dp[i - 1][prev2]);\n    \t\tif (j >= l && j <= r)\n    \t\t\tdp[i][j]++;\n    \t\tans = max(ans, dp[i][j]);\n    \t}\n    }\n    cout << ans << endl;\n\n\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Sleeping Schedule.json",
    "editorial_link": "https://codeforces.com//blog/entry/74714",
    "editorial": "This is a very standard dynamic programming problem. Let be the maximum\r\nnumber of sleeping times if Vova had a sleep times already and the\r\nnumber of times he goes to sleep earlier by one hour is exactly . Then\r\nthe value will be the answer. Initially, all and .What about\r\ntransitions? Let the current state of the dynamic programming be and .\r\nThen we can don\u00e2\u0080\u0099t go to sleep earlier and make the first transition: .\r\nThe sign is modulo operation and the notation is the boolean result of\r\nthe expression ( if is true and otherwise). And the second transition if\r\nwe go to sleep earlier: .Don\u00e2\u0080\u0099t forget to don\u00e2\u0080\u0099t make transitions from\r\nunreachable states.Time complexity: .\r\n"
}