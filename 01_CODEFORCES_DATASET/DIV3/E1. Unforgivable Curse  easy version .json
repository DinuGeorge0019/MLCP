{
    "link": "https://codeforces.com//contest/1800/problem/E1",
    "problemId": "1805847",
    "problem_idx": "E1",
    "shortId": "1800E1",
    "contest_number": "1800",
    "problem_submissions": {
        "G": [
            195662820,
            195690940,
            195777313,
            195690603,
            196524855,
            196524658,
            196522076,
            195943836
        ],
        "F": [
            195638235,
            195668644,
            195626028,
            195643554,
            195664067,
            195653332,
            195675061,
            195673007,
            195816880,
            195814809,
            195671424,
            195665257,
            195659551,
            195670175,
            195698092,
            195680883,
            195680676,
            195689427,
            195669351,
            195693466
        ],
        "E2": [
            195612538,
            195639973,
            195612785,
            195633454,
            195608323,
            195629403,
            195623425,
            195629463,
            195626230,
            195629563,
            195651082,
            195630357,
            195636943,
            195619592,
            195639486,
            195641374,
            195638209,
            195651098,
            195639224
        ],
        "E1": [
            195609573,
            195639721,
            195612247,
            195613343,
            195609699,
            195630410,
            195623568,
            195625383,
            195625931,
            195618740,
            195651326,
            195630926,
            195636711,
            195618856,
            195639041,
            195641167,
            195628893,
            195650180,
            195639842
        ],
        "D": [
            195596585,
            195625770,
            195604693,
            195600193,
            195602000,
            195612110,
            195610320,
            195609709,
            195602062,
            195607762,
            195620848,
            195616904,
            195612803,
            195606522,
            195616372,
            195614847,
            195609456,
            195614238,
            195614684
        ],
        "C1": [
            195590954,
            195626345,
            195594910,
            195589947,
            195592829,
            195604029,
            195596848,
            195599696,
            195593933,
            195600094,
            195594609,
            195604030,
            195599932,
            195600191,
            195602733,
            195597615,
            195601757,
            195596127,
            195599897
        ],
        "C2": [
            195590683,
            195596363,
            195594725,
            195589578,
            195592485,
            195603666,
            195596587,
            195600171,
            195594252,
            195601050,
            195594186,
            195603461,
            195599812,
            195600859,
            195603073,
            195597061,
            195601904,
            195595910,
            195599331
        ],
        "A": [
            195587296,
            195585153,
            195582408,
            195584101,
            195582608,
            195583278,
            195583402,
            195582928,
            195582330,
            195583356,
            195582358,
            195587162,
            195585218,
            195584435,
            195584152,
            195585315,
            195585448,
            195583944,
            195583542
        ],
        "B": [
            195584191,
            195590087,
            195587727,
            195584989,
            195586915,
            195590416,
            195592972,
            195589242,
            195592390,
            195586361,
            195594730,
            195594317,
            195594021,
            195589463,
            195590127,
            195591494,
            195591394,
            195590938
        ]
    },
    "name": "E1. Unforgivable Curse  easy version ",
    "statement": "The chief wizard of the Wizengamot once caught the evil wizard Drahyrt,\r\nbut the evil wizard has returned and wants revenge on the chief wizard.\r\nSo he stole s from his student Harry.The is a n-length string of\r\nlowercase Latin letters.Drahyrt wants to replace with an unforgivable\r\ncurse string t.Drahyrt, using ancient magic, can swap letters at a\r\ndistance k or k+1 in as many times as he wants. In other words, Drahyrt\r\ncan change letters in positions i and j in s if |i-j|=3 or |i-j|=4.For\r\nexample, if s = \"\" and t = \"\", Drahyrt can act as follows: swap the\r\nletters at positions 1 and 4 to get \"\". swap the letters at positions 2\r\nand 6 to get \"\". You are given s and t. Can Drahyrt change s to t?\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lo; \ntypedef pair< lo,lo > PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define endl \"\\n\"\n#define pb push_back\n#define fio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define FOR for(int i=1;i<=n;i++)\n#define mid ((start+end)/2)\n#define ort ((bas+son)/2)\n\nconst lo inf = 1000000000000000000;\nconst lo KOK = 100000;\nconst lo LOG = 30;\nconst lo li = 200002;\nconst lo mod = 1000000007;\n\nint n,m,k,flag,t,mpp[26][li],git[26][li];\nint cev;\nchar s[li],ss[li];\n\ninline int in(){\n    int x;\n    scanf(\"%d\",&x);\n    return x;\n}\n\nint main(void){\n    t=in();\n    while(t--){\n        n=in();\n        k=in();\n        scanf(\"%s %s\",(s+1),(ss+1));\n        for(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tmpp[i][j]=0;\n\t\t\t\tgit[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tflag=0;\n        FOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[s[i]-'a'][i%k]++;\n\t\t}\n\t\tFOR{\n\t\t\tif(i+k>n && i-k<1){\n\t\t\t\tif(s[i]!=ss[i]){flag=1;break;}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmpp[ss[i]-'a'][i%k]--;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<=25;i++){\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tmpp[i][j]+=git[i][j];\n\t\t\t\tif(j!=k-1 && n!=k+1){\n\t\t\t\t\tgit[i][j+1]+=mpp[i][j];\n\t\t\t\t\tmpp[i][j]=0;\n\t\t\t\t}\n\t\t\t\tif(mpp[i][j]){flag=1;break;}\n\t\t\t}\n\t\t}\n\t\tif(flag){printf(\"NO\\n\");}\n\t\telse printf(\"YES\\n\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dsu",
        "graphs",
        "greedy",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E1. Unforgivable Curse  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/113477",
    "editorial": "In these constraints , the problem could be solved as follows:Note that\r\nfor strings of length and more, it is enough to check that the strings\r\nand match character by character, that is, up to permutation, since each\r\ncharacter can be moved to the desired half, and then moved to the\r\ndesired side by length by applying two operations on the length is and\r\n.For example, there was a string \"\" and we want to shift the character\r\nto the left, then we can first get the string \"\" and then the string \"\".\r\nWell, we can restore the used symbols by putting them in their place \"\".\r\nThat is, we were able to simply swap two adjacent characters.Thus, with\r\nsuch a clipping, it was possible to solve the problem by brute force for\r\n. To iterate, it was possible to store of strings, which we can get and\r\niterate through all the strings using .\r\n"
}