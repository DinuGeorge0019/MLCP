{
    "link": "https://codeforces.com//contest/1560/problem/C",
    "problemId": "1082098",
    "problem_idx": "C",
    "shortId": "1560C",
    "contest_number": "1560",
    "problem_submissions": {
        "F2": [
            126333818,
            126306855,
            126317964,
            126343969,
            126329373,
            126329484,
            126318670,
            126324734,
            126340312,
            126380679,
            126324751,
            126323492,
            126392331,
            126323366,
            126338259,
            181389292,
            126327293,
            126341450,
            126335878,
            126346280,
            126343998,
            126334938,
            126331523,
            126358791
        ],
        "E": [
            126314275,
            126322204,
            126332108,
            126337635,
            126318617,
            126338757,
            126331477,
            126341239,
            126380625,
            126338931,
            126345881,
            126392319,
            126339127,
            126324096,
            126341795,
            126324358,
            126350364,
            126334805,
            126335135,
            126362201,
            126365972,
            126318677
        ],
        "F1": [
            126309457,
            126306646,
            126317821,
            126307775,
            126330038,
            126318533,
            126324378,
            126310262,
            126324870,
            126323614,
            126392323,
            126323290,
            126338176,
            126327481,
            126351876,
            126335480,
            126346365,
            126344093,
            126335132,
            126331374,
            126336670
        ],
        "D": [
            126298074,
            126431766,
            126302775,
            126302608,
            126296584,
            126295532,
            126300302,
            126303789,
            126294528,
            126389287,
            126379378,
            126374780,
            126312331,
            126313764,
            126392312,
            126309627,
            126305716,
            126307963,
            126306718,
            126303322,
            126315291,
            126312680,
            126316841,
            126311452,
            126300681
        ],
        "C": [
            126288623,
            126433600,
            126292103,
            126291590,
            126288757,
            126288046,
            126289111,
            126288025,
            126294392,
            126290860,
            126380656,
            126297916,
            126292682,
            126392309,
            126304707,
            126294000,
            126293843,
            126290516,
            126295186,
            126293202,
            126294960,
            126303302,
            126297335,
            126292511
        ],
        "B": [
            126283242,
            126282856,
            126282667,
            126281542,
            126281182,
            126284410,
            126281360,
            126280185,
            126288262,
            126283351,
            126501327,
            126501253,
            126392300,
            126294064,
            126288477,
            126286554,
            126285105,
            126283253,
            126285740,
            126288591,
            126286357,
            126288697,
            126284546
        ],
        "A": [
            126276779,
            126276302,
            126276753,
            126276379,
            126276291,
            126277704,
            126276617,
            126277755,
            126279450,
            126276413,
            126392288,
            126284958,
            126277758,
            126277313,
            126277718,
            126276817,
            126277182,
            126278392,
            126279481,
            126277037,
            126282057
        ]
    },
    "name": "C. Infinity Table",
    "statement": "Polycarp has found a table having an infinite number of rows and\r\ncolumns. The rows are numbered from 1, starting from the topmost one.\r\nThe columns are numbered from 1, starting from the leftmost\r\none.Initially, the table hasn’t been filled and Polycarp wants to fix\r\nit. He writes integers from 1 and so on to the table as follows. The\r\nleftmost topmost cell of the table is filled with the number 1. Then he\r\nwrites in the table all positive integers beginning from 2 sequentially\r\nusing the following algorithm.First, Polycarp selects the leftmost\r\nnon-filled cell in the first row and fills it. Then, while the left\r\nneighbor of the last filled cell is filled, he goes down and fills the\r\nnext cell. So he goes down until the last filled cell has a non-filled\r\nneighbor to the left (look at the vertical arrow going down in the\r\nfigure above).After that, he fills the cells from the right to the left\r\nuntil he stops at the first column (look at the horizontal row in the\r\nfigure above). Then Polycarp selects the leftmost non-filled cell in the\r\nfirst row, goes down, and so on.A friend of Polycarp has a favorite\r\nnumber k. He wants to know which cell will contain the number. Help him\r\nto find the indices of the row and the column, such that the\r\nintersection of the row and the column is the cell containing the number\r\nk.\r\n",
    "solutions": [
        "/*#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n \n#include <bits/stdc++.h>\n  \n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n \n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n \n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n\nusing namespace std;\n\nsigned main() {\n    \n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(\"cf.inp\", \"r\", stdin);\n    // freopen(\"cf.out\", \"w\", stdout);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n        int a = sqrt(n);\n        int b = a * a;\n\n        if (b == n) {\n            cout << a << \" \" << 1 << \"\\n\";\n        }\n        else {\n            n -= b;\n            if (n <= a + 1) cout << n << \" \" << a + 1 << \"\\n\";\n            else {\n                n -= (a + 1);\n                cout << a + 1 << \" \" << (a + 1) - n << \"\\n\";\n            }\n        }\n    }\n    \n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Infinity Table.json",
    "editorial_link": "https://codeforces.com//blog/entry/94009",
    "editorial": "Letâs call a set of cells being filled from the topmost row to the\r\nleftmost column a . E. g. the -st layer consists of the single number ,\r\nthe -nd layer consists of the numbers , and , the -rd layer consists of\r\nthe numbers , , , and , etc.The number of cells in layers forms an\r\narithmetic progression. The first layer consists of cells, the -th layer\r\nconsists of cells. The minimum number in the -th layer is equal to the\r\nsum of sizes of all layers from the -st to the -th plus .Suppose that\r\nbelongs to the -th layer. Consider the value of . Polycarp fills exactly\r\ncells on the -th layer before he starts filling the cells from the right\r\nto the left (i. e. while he goes down). Therefore, if , the number\r\nbelongs to the -th row and the -th column. Otherwise, the number belongs\r\nto the -th row and the -th column.Consider a way to find the coordinates\r\nof a given number . Letâs iterate by the layer number to which given the\r\nnumber belongs calculating the values of and (going to the next layer,\r\nletâs calculate the next layer parameters as follows: ; ). The iteration\r\nmust be stopped if the layer number is such that . Using the values of\r\nand , we can calculate the given numberâs coordinates in the described\r\nway in . The total time of calculating the coodrinates for one given is\r\nwhere is the number of the layer to which the given belongs.Letâs\r\nrepresent the value of as : . , hence . Therefore, the coordinates of\r\none number may be calculated in . At the same time, as it follows from\r\nthe formulas, the layer number can be calculated as follows: (the square\r\nroot of rounded up). To avoid accuracy problems, you can calculate the\r\nvalue using a loop.\r\n",
    "hint": []
}