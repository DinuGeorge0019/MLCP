{
    "link": "https://codeforces.com//contest/1674/problem/F",
    "problemId": "1387202",
    "problem_idx": "F",
    "shortId": "1674F",
    "contest_number": "1674",
    "problem_submissions": {
        "G": [
            155646371,
            155678319,
            155682648,
            155674622,
            155685706,
            155652398,
            155774505,
            155758418,
            155756941,
            155756549,
            155813512,
            155812905,
            155812142,
            155668112,
            155672472,
            155679227
        ],
        "E": [
            155631011,
            155634103,
            155643152,
            155675920,
            155631080,
            155651713,
            155617544,
            155694232,
            155715039,
            155714839,
            155714791,
            155637067,
            155642168,
            155638571,
            155649103,
            155635417,
            155641093,
            155646304,
            155721408,
            155721277,
            155636472,
            155697116,
            155650091,
            155644616
        ],
        "D": [
            155618739,
            155613748,
            155616684,
            155656367,
            155626968,
            155608446,
            155610953,
            155612083,
            155611734,
            155659957,
            155623954,
            155619138,
            155624149,
            155621266,
            155624757,
            155627320,
            155618076,
            155634919,
            155611685,
            155616988
        ],
        "F": [
            155617525,
            155657845,
            155669742,
            155653200,
            155666820,
            155638184,
            155625715,
            155652009,
            155672980,
            155630184,
            155664338,
            155667869,
            155668832,
            155674578,
            155651745,
            155669165,
            155649876,
            155663032,
            155653319,
            155665427
        ],
        "C": [
            155604778,
            155603079,
            155604115,
            155615008,
            155611152,
            155601227,
            155598610,
            155598459,
            155599303,
            155601929,
            155605133,
            155602572,
            155609155,
            155606549,
            155606406,
            155613995,
            155599916,
            155616867,
            155601683,
            155604335
        ],
        "B": [
            155596261,
            155597272,
            155595696,
            155604402,
            155605300,
            155597345,
            155593808,
            155599168,
            155593898,
            155596784,
            155597719,
            155597183,
            155602563,
            155597000,
            155600384,
            155600158,
            155595285,
            155605630,
            155596236,
            155595482
        ],
        "A": [
            155592021,
            155592145,
            155591844,
            155602088,
            155598548,
            155592326,
            155591501,
            155592241,
            155591537,
            155593757,
            155591678,
            155592049,
            155596267,
            155592804,
            155593311,
            155594974,
            155592005,
            155594331,
            155593247,
            155592088
        ]
    },
    "name": "F. Desktop Rearrangement",
    "statement": "Your friend Ivan asked you to help him rearrange his desktop. The\r\ndesktop can be represented as a rectangle matrix of size n\r\ntimes m consisting of characters \u201d (empty cell of the desktop) and \u201d (an\r\nicon).The desktop is called if all its icons are occupying some prefix\r\nof full columns and, possibly, the prefix of the next column (and there\r\nare no icons outside this figure). In other words, some amount of first\r\ncolumns will be filled with icons and, possibly, some amount of first\r\ncells of the next (after the last full column) column will be also\r\nfilled with icons (and all the icons on the desktop belong to this\r\nfigure). This is pretty much the same as the real life icons\r\narrangement.In one move, you can take one icon and move it to any empty\r\ncell in the desktop.Ivan loves to add some icons to his desktop and\r\nremove them from it, so he is asking you to answer q queries: what is\r\nthe number of moves required to make the desktop after adding/removing\r\none icon?Note that and change the state of the desktop.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n \nusing namespace std;\n \nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\nconst int md2 = 1e9+9;\n \n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n \n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n \n#define pb                          push_back\n \n#define pry                         puts(\"YES\")\n#define prn                         puts(\"NO\")\n#define endl                        '\\n'\n \n#define fst                         first\n#define scn                         second\n \n#define c(x)                        (ll)(x-'a')\n \nconst int N=1005;\nchar c[N][N];\n\ntemplate<typename T>\nstruct FenwickTree2D{\n    vector<vector<T>> fen;\n    int n, m;\n    FenwickTree2D(int N, int M){\n        n = N, m = M; \n        fen.assign(n + 1, vector<T>(m + 1 , 0));\n    }\n    void modif(int x, int y, int val){\n        ++x, ++y;\n        for(int i = x;i <= n; i += i & -i){\n            for(int j = y;j <= m; j += j & -j){\n                fen[i][j] += val;\n            }\n        }\n    }\n\n    T query(int x, int y) {\n        ++x, ++y;\n        T ret = 0;\n        for(int i = x; i >= 1;i -= i & -i)\n            for(int j = y;j >= 1;j -= j & -j)\n                ret += fen[i][j];\n        return ret;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n};\n\nvoid solve(){\n    int n,m,q;\n    cin>>n>>m>>q;\n    FenwickTree2D<long long> st(n + 1, m + 1);\n    forn(i,n){\n        forn(j,m){\n            cin>>c[i][j];\n            if(c[i][j]=='*')st.modif(i,j,1);\n        }\n    }\n\n    while(q--) {\n        int x,y;\n        cin>>x>>y;\n        --x,--y;\n        if(c[x][y]=='*'){\n            st.modif(x,y,-1);\n            c[x][y]='.';\n        }else{\n            st.modif(x,y,1);\n            c[x][y]='*';\n        }\n\n        long long total = st.query(0,0,n-1,m-1);\n        long long complete = total/n;\n        long long remaining = total - complete*n;\n        long long ans = complete * n + remaining;\n        if(complete)ans-=st.query(0,0,n-1,complete-1);\n        if(remaining)ans-=st.query(0,complete,remaining-1, complete);\n        cout <<ans<<endl;\n    }\n}\n \nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Desktop Rearrangement.json",
    "editorial_link": "https://codeforces.com//blog/entry/102482",
    "editorial": "I\u00e2\u0080\u0099ve seen a lot of data structures solutions for this problem, but\r\nauthor\u00e2\u0080\u0099s solution doesn\u00e2\u0080\u0099t use them and works in .Firstly, let\u00e2\u0080\u0099s change\r\nour matrix to a string , because it will be easier to work with a string\r\nthan with a matrix. The order of characters will be from top to bottom,\r\nfrom left to right (i. e. the outer cycle by columns, and the inner by\r\nrows). Then, let\u00e2\u0080\u0099s calculate the number of icons on the desktop (the\r\nnumber of \u00e2\u0080\u009d in ). Then the answer will be, obviously, the number of dots\r\non the prefix of of size .Now let\u00e2\u0080\u0099s deal with queries. It can be shown\r\nthat one query changes our answer by no more than .Let be the position\r\nof the cell that is being changed in (zero-indexed). Then, if , there\r\nare two cases. If is \u00e2\u0080\u009d, then we have one more icon on our prefix, so the\r\nanswer decreases by one (because we filled one empty space in the good\r\ndesktop). Otherwise, it increases by one (because this icon is outside\r\nour prefix).Then let\u00e2\u0080\u0099s change the corresponding character by the\r\nopposite. After that, we should move our right border () accordingly to\r\nthe new number of icons. Note that this border is exclusive. If becomes\r\n\u00e2\u0080\u009d, then we will increase the variable . But before that, if is \u00e2\u0080\u009d, then\r\nthere should be an icon, and it is not here yet, so the answer\r\nincreases. Otherwise, our border will decrease. Then, if is \u00e2\u0080\u009d, then the\r\nanswer decreases (because there was a place for an icon, and now it is\r\nnot needed anymore).Time complexity: .\r\n"
}