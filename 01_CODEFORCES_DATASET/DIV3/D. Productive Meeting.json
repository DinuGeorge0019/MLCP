{
    "link": "https://codeforces.com//contest/1579/problem/D",
    "problemId": "1123869",
    "problem_idx": "D",
    "shortId": "1579D",
    "contest_number": "1579",
    "problem_submissions": {
        "G": [
            130137274,
            130120638,
            130155046,
            130156225,
            130163836,
            130179545,
            130168337,
            130158927,
            130165156,
            130198303,
            130191623,
            130244137,
            130192656
        ],
        "E2": [
            130129123,
            130137578,
            130134268,
            130135000,
            130132286,
            130127123,
            130146290,
            130145108,
            130149289,
            130140257,
            130139480,
            130140744,
            130135527,
            130143398,
            130123582,
            130147751,
            130139094,
            130145725,
            130136545,
            130146933
        ],
        "F": [
            130125518,
            130115413,
            130143625,
            130141220,
            130143971,
            130167063,
            130157787,
            130168199,
            130155796,
            130152120,
            130146742,
            130149015,
            130150286,
            130148427,
            130153717,
            130166412,
            130156991,
            130153655,
            130149578,
            130134036
        ],
        "E1": [
            130117970,
            130121669,
            130119905,
            130127812,
            130120295,
            130128369,
            130136696,
            130129561,
            130139968,
            130118319,
            130116344,
            130126763,
            130130246,
            130132247,
            130119799,
            130120223,
            130117670,
            130134770,
            130118389,
            130133123
        ],
        "D": [
            130114825,
            130131006,
            130115575,
            130122918,
            130116396,
            130116584,
            130127769,
            130136071,
            130142472,
            130116682,
            130121234,
            130122150,
            130126027,
            130120420,
            130116268,
            130113854,
            130122134,
            130132072,
            130125736,
            130128217
        ],
        "C": [
            130111875,
            130134780,
            130127605,
            130118045,
            130126486,
            130136003,
            130133755,
            130153746,
            130136597,
            130126873,
            130133654,
            130133053,
            130123204,
            130126284,
            130128738,
            130132948,
            130148452,
            130128270,
            130158049,
            130155693
        ],
        "B": [
            130106161,
            130116908,
            130108929,
            130112526,
            130111768,
            130114142,
            130116092,
            130125486,
            130125850,
            130111350,
            130113414,
            130109874,
            130116163,
            130111654,
            130112328,
            130107695,
            130114784,
            130116681,
            130114568,
            130117978
        ],
        "A": [
            130098440,
            130100824,
            130100944,
            130103654,
            130098460,
            130102451,
            130102139,
            130101021,
            130117992,
            130105259,
            130098578,
            130098425,
            130098461,
            130105623,
            130098680,
            130098458,
            130101628,
            130099346,
            130098971,
            130099307
        ]
    },
    "name": "D. Productive Meeting",
    "statement": "An important meeting is to be held and there are exactly n people\r\ninvited. At any moment, any two people can step back and talk in\r\nprivate. The same two people can talk several (as many as they want)\r\ntimes per meeting.Each person has limited . The sociability of the i-th\r\nperson is a non-negative integer a_i. This means that after exactly a_i\r\ntalks this person leaves the meeting (and does not talk to anyone else\r\nanymore). If a_i = 0, the i-th person leaves the meeting immediately\r\nafter it starts.A meeting is considered most if the maximum possible\r\nnumber of talks took place during it.You are given an array of\r\nsociability a, determine which people should talk to each other so that\r\nthe total number of talks is as large as possible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"Ofast\")\n#pragma gcc optimize(\"unroll-loops\")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005],n;\npriority_queue <pi> q;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        while(!q.empty()) q.pop();\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            if(a[i]) q.push({a[i],i});\n        }\n        vecpi ans;\n        while(q.size() > 1) {\n            int idx1 = q.top().y; q.pop();\n            int idx2 = q.top().y; q.pop();\n            ans.pb({idx1,idx2});\n            a[idx1]--, a[idx2]--;\n            if(a[idx1]) q.push({a[idx1],idx1});\n            if(a[idx2]) q.push({a[idx2],idx2});\n        }\n        cout << ans.size() << '\\n';\n        for(pi i : ans) cout << i.x << ' ' << i.y << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Productive Meeting.json",
    "editorial_link": "https://codeforces.com//blog/entry/95447",
    "editorial": "For the first conversation let\u00e2\u0080\u0099s choose two people and with maximal\r\nvalues of sociability. Note that after this conversation takes place, we\r\nmove on to a similar problem, but in which and are decreased by . After\r\ndecreasing and by , we repeat the choice of the two people with the\r\nmaximum values of sociability. Let us repeat such iterations while at\r\nleast two people with positive sociability parameters remain.Let us\r\nprove that this solution leads to the optimal answer. Let\u00e2\u0080\u0099s denote the\r\nsum by and consider two fundamentally different cases: The maximal\r\nelement is greater than or equal to the sum of all remaining elements.\r\nThat is, there exists such that . In this case, note that the -th person\r\ncan not possibly have more than conversations, because by that point all\r\nother people already reached their sociability limits and left the\r\nmeeting. Thus, if , the answer cannot be more than . Note that this\r\nestimation is accurate since an example exists in which -th person talks\r\nto all other people as many times as possible (that is, times with -th\r\nperson for all ). And the algorithm described above will just choose the\r\nth person as one of the participants of a conversation every time,\r\nbecause for every conversation both and decrease by exactly , so the\r\ninequality holds and it follows that Otherwise, we can prove that the\r\nmaximum number of conversations is always . Obviously, it is impossible\r\nto get more than this number, since each conversation requires exactly\r\ntwo units of sociability (one from two people), while a larger answer\r\nwould mean that which is obviously wrong. Let us prove that this answer\r\nis achieved by the described algorithm. Let\u00e2\u0080\u0099s look at the last\r\nconversation held. If there are at least two more people left in the\r\nmeeting after it, we can hold another conversation, which means there is\r\na more optimal answer. If there are zero people left in the meeting,\r\nthen an estimate of of conversations has been achieved. And if there is\r\none person with a remaining sociability , then an estimate of of\r\nconversations has been achieved. If there is exactly one remaining\r\nperson with a sociability residual , then we can guarantee that this\r\nperson has participated in all previous conversations. Indeed, let\u00e2\u0080\u0099s\r\nlook at the last conversation it was held between two people with the\r\nmaximum parameters of the remaining sociability. But the -th person has\r\nat least sociability remaining, so it couldn\u00e2\u0080\u0099t have been the other two\r\npeople with residuals of who left right after that. Thus, analyzing all\r\nconversations in reverse order, we can prove that at any time , which\r\nmeans that it is in fact the case considered above. We have proven that\r\nthe described greedy algorithm works. This algorithm can be implemented\r\nby using any balanced search tree, such as . By storing pairs of\r\nelements in it, we could for each time choose the next two people to\r\ntalk to and update the sociability values.The time complexity is .\r\n"
}