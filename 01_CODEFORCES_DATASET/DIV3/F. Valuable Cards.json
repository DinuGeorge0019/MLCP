{
    "link": "https://codeforces.com//contest/1992/problem/F",
    "problemId": "2748268",
    "problem_idx": "F",
    "shortId": "1992F",
    "contest_number": "1992",
    "problem_submissions": {
        "G": [
            270004158,
            270000712,
            270020186,
            270006424,
            270010291,
            270026135,
            270032635,
            270035721,
            270033149,
            270036718,
            270041253,
            270830404,
            270035615,
            270034895,
            270041739,
            270045150,
            269953500,
            270015289,
            269950486
        ],
        "F": [
            269972577,
            270018896,
            269993465,
            269987867,
            269991929,
            270003873,
            269994703,
            270009199,
            270016540,
            270005935,
            270127981,
            270013136,
            270020087,
            270019936,
            270018379,
            269963694,
            270043761,
            270005597,
            269985278
        ],
        "D": [
            269954705,
            269930808,
            269933166,
            269942867,
            269936957,
            269946925,
            269942518,
            269941050,
            269944797,
            269962503,
            269960047,
            269956728,
            269964646,
            270000105,
            269992943,
            269953387,
            270024549,
            269937412
        ],
        "E": [
            269950946,
            269964630,
            269972651,
            269967159,
            269979484,
            269986612,
            269986054,
            269986867,
            269983914,
            269989311,
            269990694,
            269983845,
            269996015,
            269971543,
            269983529,
            270000206,
            270015715,
            269961487
        ],
        "C": [
            269920653,
            269918264,
            269915470,
            269928750,
            269924685,
            269919119,
            269916880,
            269924258,
            269918590,
            269936939,
            269921649,
            269929196,
            269923650,
            269913996,
            269998285,
            269933575,
            270027835,
            269914944
        ],
        "B": [
            269901952,
            269907735,
            269910847,
            269907929,
            269906378,
            269906593,
            269906048,
            269911414,
            269907898,
            269912483,
            269907733,
            269916021,
            269911764,
            269906789,
            270003910,
            269961585,
            270031623,
            269906408
        ],
        "A": [
            269898839,
            269900621,
            269899306,
            269900117,
            269900634,
            269898982,
            269898946,
            269899343,
            269899743,
            269900745,
            269900678,
            269900839,
            269903685,
            269898938,
            270007186,
            269957657,
            270033185,
            269900065
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/131461",
    "editorial": "TutorialLetâs consider the greedy algorithm âtake as long as you canâ.\r\nLetâs prove that it works. In any optimal division, if we take the first\r\nsegment of non-maximum length, we will not violate the criteria if we\r\ntransfer one element from the second segment to the first. Therefore,\r\nthe given greedy algorithm is correct.Now letâs figure out how to\r\nquickly understand if the segment can be extended. First, find all\r\ndivisors of the number . If the number is not a divisor of it, then it\r\ncannot be included in any set of numbers whose product is equal to , so\r\nwe can simply add it to the segment. If is a divisor, we need to somehow\r\nlearn to understand whether it, in combination with some other divisors,\r\ngives the number on the segment. We will maintain a set of divisors that\r\nare products of some numbers in the segment. To update the set when\r\nadding , we will go through all the divisors of this set and for each\r\ndivisor add to the set. If we added the number to the set, will already\r\nbe in the next segment and we need to clear the set.P. S.: About\r\nimplementation details and runtime. If you maintain the set in a set\r\nstructure, then we get a runtime of , where is the number of divisors of\r\n. Instead of a set, you can use, for example, a global array of size ,\r\nas well as maintain a vector of reachable divisors. Using these\r\nstructures, you can achieve a runtime of .\r\n",
    "name": "F. Valuable Cards",
    "statement": "In his favorite cafe Kmes once again wanted to try the herring under a\r\nfur coat. Previously, it would not have been difficult for him to do\r\nthis, but the cafe recently introduced a new purchasing policy.Now, in\r\norder to make a purchase, Kmes needs to solve the following problem: n\r\ncards with prices for different positions are laid out in front of him,\r\non the i-th card there is an integer a_i, among these prices there is no\r\nwhole positive integer x.Kmes is asked to divide these cards into the\r\nminimum number of segments (so that each card belongs to exactly one\r\nsegment). A segment is considered if it is impossible to select a subset\r\nof cards with a product equal to x. All segments, in which Kmes will\r\ndivide the cards, must be .Formally, the segment (l, r) is if there are\r\nno indices i_1 < i_2 <\r\nldots < i_k such that l\r\nle i_1, i_k\r\nle r, and a_{i_1}\r\ncdot a_{i_2}\r\nldots\r\ncdot a_{i_k} = x.Help Kmes determine the minimum number of segments in\r\norder to enjoy his favorite dish.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using namespace std; #define int long long#define inf 0x3F3F3F3F3F3F3F3F const int MXN = 2e5 + 5; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); int id[MXN], a[MXN]; void _(){\tint n, x;\tcin >> n >> x;\tfor (int i = 1; i <= n; i++) cin >> a[i];\tvector<int> v;\tfor (int i = 1; i * i <= x; i++) \t{\t\tif (x % i == 0) v.push_back(i);\t\tif (x % i == 0 && x / i != i) v.push_back(x / i);\t}\tsort(v.begin(), v.end());\tfor (int i = 0; i < v.size(); i++) id[v[i]] = i;\tvector<int> dp(v.size(), 0);\tdp[0] = 1;\tint res = 1;\tfor (int i = 1; i <= n; i++)\t{\t\tif (x % a[i]) continue;\t\tfor (int j = (int)v.size() - 1; j >= 0; j--)\t\t{\t\t\tif (v[j] % a[i] || dp[j]) continue;\t\t\tint k = id[v[j] / a[i]];\t\t\tdp[j] |= dp[k];\t\t}\t\tif (dp.back()) \t\t{\t\t\tres++;\t\t\tdp.assign(v.size(), 0);\t\t\tdp[0] = dp[id[a[i]]] = 1;\t\t}\t}\tcout << res << '\\n';} signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\twhile (t--)\t{\t\t_();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "number theory",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Valuable Cards.json",
    "hint": []
}