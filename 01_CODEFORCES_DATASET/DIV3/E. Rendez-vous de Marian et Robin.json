{
    "link": "https://codeforces.com//contest/2014/problem/E",
    "problemId": "2892477",
    "problem_idx": "E",
    "shortId": "2014E",
    "contest_number": "2014",
    "problem_submissions": {
        "G": [
            282355237,
            282340908,
            282349517,
            282469109,
            282768209
        ],
        "H": [
            282319139,
            282294919,
            282369641,
            282327328,
            282344971,
            282343427,
            282320463,
            282354346,
            282338340,
            282341971,
            282345189,
            282359227,
            282335882,
            282356841,
            282332486,
            282259554,
            282367573,
            282358571,
            282340140,
            282354845,
            282340779
        ],
        "F": [
            282310940,
            282344360,
            282329041,
            282301003,
            282317626,
            282346191,
            282313376,
            282324314,
            282336360,
            282330209,
            282316236,
            282352931,
            282339107,
            282367052,
            282355481,
            282342400,
            282311004,
            282354051,
            282348444,
            282360261
        ],
        "E": [
            282298135,
            282347444,
            282324784,
            282315211,
            282288353,
            282301236,
            282298734,
            282299501,
            282311127,
            282309362,
            282313492,
            282303867,
            282309804,
            282310056,
            282314491,
            282344707,
            282319635,
            282302427,
            282313050,
            282331264,
            282317148
        ],
        "D": [
            282266365,
            282262468,
            282284761,
            282266186,
            282281624,
            282263914,
            282278929,
            282290066,
            282285534,
            282292322,
            282283633,
            282303511,
            282281064,
            282294495,
            282319933,
            282298383,
            282290687,
            282285759,
            282297433,
            282291388
        ],
        "C": [
            282245761,
            282249551,
            282267820,
            282250356,
            282260562,
            282251055,
            282251810,
            282263518,
            282256201,
            282252015,
            282260274,
            282248128,
            282257994,
            282266861,
            282299616,
            282253349,
            282254086,
            282264623,
            282276303,
            282262355
        ],
        "B": [
            282235337,
            282236894,
            282246106,
            282232521,
            282241668,
            282237594,
            282243258,
            282239802,
            282239576,
            282238146,
            282241956,
            282238965,
            282240579,
            282237329,
            282279188,
            282240894,
            282242478,
            282240040,
            282236073,
            282244164,
            282271471
        ],
        "A": [
            282225117,
            282225433,
            282233872,
            282225077,
            282234075,
            282225216,
            282226675,
            282226848,
            282232220,
            282227137,
            282231989,
            282227272,
            282229469,
            282228546,
            282236816,
            282226223,
            282233092,
            282227477,
            282229182,
            282226562
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134210",
    "editorial": "This problem builds on the standard Dijkstra algorithm. So please familiarise yourself with the algorithm if not already.\n\nIn Dijkstra algorithm, a distance vector/list is used to store travel times to all vertices, here we need to double the vector/list to store travel times to vertices arriving with and without a horse. If a vertex has a horse, then it's possible to transition from without horse to with horse there. The Dijkstra algorithm is then run as standard.\n\nWhat if a horse has already been taken by Marian when Robin arrives, and vice versa? Well, the optimal solution would not require the second person to arrive to use the horse, because the first to arrive could simply wait for the second to arrive, giving an earlier meeting than whatever is possible if the second to arrive had to use the horse and go elsewhere. Therefore, for any vertex, 1\n horse is sufficient.\n\nWe run Dijkstra algorithm twice to find the fastest time Robin and Marian could reach any vertex i\n as tR(i)\n and tM(i)\n. The earliest meeting time at a given vertex i\n is max(tR(i),tM(i))\n, and we need to check all vertices.\n\nThe time complexity is that of Dijkstra algorithm which, in this problem, is O(nlogn)\n.",
    "name": "E. Rendez-vous de Marian et Robin",
    "statement": "The travel network is represented as n vertices numbered from 1 to n and\r\nm edges. The i-th edge connects vertices u_i and v_i, and takes w_i\r\nseconds to travel (all w_i are even). Marian starts at vertex 1 (Market)\r\nand Robin starts at vertex n (Major Oak).In addition, h of the n\r\nvertices each has a single horse available. Both Marian and Robin are\r\ncapable riders, and could mount horses in no time (i.e. in 0 seconds).\r\nTravel times are halved when riding. Once mounted, a horse lasts the\r\nremainder of the travel. Meeting must take place on a vertex (i.e. not\r\non an edge). Either could choose to wait on any vertex.Output the\r\nearliest time Robin and Marian can meet. If vertices 1 and n are\r\ndisconnected, output -1 as the meeting is cancelled.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 4e5 + 5;const int mod = 1e9 + 7;int n, m, h, a[N], dis1[N], dis2[N];vector<PII> e[N];bool vis[N];void solve(){    cin >> n >> m >> h;    for (int i = 1; i <= 2 * n; i++)        e[i].clear(), a[i] = 0, vis[i] = 0;    for (int i = 1; i <= h; i++)    {        int x;        cin >> x;        a[x] = 1;    }    for (int i = 1; i <= m; i++)    {        int u, v, w;        cin >> u >> v >> w;        if (a[u])            e[u].push_back({v + n, w / 2});        e[u].push_back({v, w});        e[u + n].push_back({v + n, w / 2});        if (a[v])            e[v].push_back({u + n, w / 2});        e[v].push_back({u, w});        e[v + n].push_back({u + n, w / 2});    }    fill(dis1 + 1, dis1 + 1 + 2 * n, 1e18);    fill(dis2 + 1, dis2 + 1 + 2 * n, 1e18);    priority_queue<array<int, 2>, vector<array<int, 2>>, greater<array<int, 2>>> q;    q.push({0, 1});    dis1[1] = 0;    while (!q.empty())    {        auto [d, u] = q.top();        q.pop();        if (vis[u])            continue;        vis[u] = 1;        for (auto [to, w] : e[u])        {            if (dis1[u] + w < dis1[to])            {                dis1[to] = dis1[u] + w;                q.push({dis1[to], to});            }        }    }    for (int i = 1; i <= 2 * n; i++)        vis[i] = 0;    q.push({0, n});    dis2[n] = 0;    while (!q.empty())    {        auto [d, u] = q.top();        q.pop();        if (vis[u])            continue;        vis[u] = 1;        for (auto [to, w] : e[u])        {            if (dis2[u] + w < dis2[to])            {                dis2[to] = dis2[u] + w;                q.push({dis2[to], to});            }        }    }    int ans = 1e18;    for (int i = 1; i <= n; i++)        ans = min(ans, max(min(dis1[i], dis1[i + n]), min(dis2[i + n], dis2[i])));    cout << (ans == 1e18 ? -1 : ans) << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Rendez-vous de Marian et Robin.json"
}