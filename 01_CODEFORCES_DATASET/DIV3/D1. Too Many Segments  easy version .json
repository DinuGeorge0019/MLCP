{
    "link": "https://codeforces.com//contest/1249/problem/D1",
    "problemId": "447562",
    "problem_idx": "D1",
    "shortId": "1249D1",
    "contest_number": "1249",
    "problem_submissions": {
        "F": [
            63172408,
            63252026,
            63175429,
            63171983,
            63178449,
            63188348,
            63193416,
            63193368,
            63195011,
            69268865
        ],
        "E": [
            63161648,
            63161142,
            63155293,
            63168564,
            63183626,
            63170661,
            63178157,
            63147220,
            63160832,
            63164442,
            63162319,
            63163127,
            63161620,
            63169150,
            63158868,
            63166581,
            63166074,
            63872232,
            63872063,
            63864039,
            63863655,
            63183869,
            63172611
        ],
        "D2": [
            63157164,
            63157031,
            63151986,
            63179972,
            63178191,
            63150473,
            63149837,
            63165541,
            63155673,
            63158427,
            63157157,
            63159529,
            63165621,
            63157444,
            63163488,
            63165452,
            63163182,
            63158691,
            63160450,
            63167522
        ],
        "D1": [
            63157014,
            63157572,
            63148296,
            63180024,
            63178362,
            63150834,
            63150131,
            63159542,
            63156407,
            63158897,
            63156756,
            63159058,
            63165817,
            63157707,
            63163278,
            63165731,
            63163213,
            63159437,
            63160306,
            63162853
        ],
        "C2": [
            63144475,
            63148997,
            63163130,
            63147539,
            63156437,
            63140409,
            63142875,
            63141970,
            63143625,
            63146079,
            63146725,
            63146760,
            63166472,
            63142727,
            63151593,
            63150401,
            63148432,
            63146539,
            63148575
        ],
        "C1": [
            63144104,
            63149133,
            63151950,
            63147674,
            63156193,
            63140555,
            63142796,
            63141766,
            63143828,
            63146316,
            63145140,
            63146724,
            63147005,
            63140832,
            63152061,
            63150521,
            63148664,
            63146426,
            63148088
        ],
        "B2": [
            63138088,
            63140116,
            63145913,
            63136980,
            63145234,
            63136187,
            63136343,
            63136067,
            63136970,
            63136377,
            63140760,
            63137463,
            63136041,
            63138033,
            63138460,
            63138534,
            63142142,
            63140081,
            63199621,
            63137990
        ],
        "B1": [
            63136823,
            63140317,
            63145977,
            63137191,
            63138074,
            63136366,
            63134489,
            63135842,
            63137199,
            63136571,
            63138205,
            63137333,
            63136186,
            63137901,
            63138608,
            63138272,
            63140900,
            63139910,
            63137719
        ],
        "A": [
            63132494,
            63132712,
            63139517,
            63133327,
            63134818,
            63132878,
            63132304,
            63132430,
            63132570,
            63132479,
            63135293,
            63133449,
            63132465,
            63133181,
            63133050,
            63132876,
            63135189,
            63133242,
            63132357
        ]
    },
    "name": "D1. Too Many Segments  easy version ",
    "statement": ".You are given n segments on the coordinate axis OX. Segments can\r\nintersect, lie inside each other and even coincide. The i-th segment is\r\n[l_i; r_i] (l_i\r\nle r_i) and it covers all integer points j such that l_i\r\nle j\r\nle r_i.The integer point is called if it is covered by than k\r\nsegments.Your task is to remove the minimum number of segments so that\r\nthere are no points at all.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<'0'||c>'9');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>='0'&&c<='9');\n\treturn res;\n}\ntypedef pair<pair<int, int>, int> Point;\npriority_queue<Point> Q;\nPoint s[200010];\nvector<int> ans;\nint add[200010];\nint main() {\n\tint N=read(), K=read();\n\tfor(int i=1; i<=N; i++){\n\t\tint a=read(), b=read();\n\t\ts[i]=make_pair(make_pair(a, b), i);\n\t\tadd[a]++;\n\t\tadd[b+1]--;\n\t}\n\tsort(s+1, s+1+N);\n\tint now=0, ind=1;\n\tfor(int i=1; i<=200000; i++){\n\t\twhile(ind<=N && s[ind].first.first==i){\n\t\t\tint a = s[ind].first.first, b = s[ind].first.second;\n\t\t\tQ.push( make_pair(make_pair(b, a), s[ind].second) );\n\t\t\tind++;\n\t\t}\n\t\tnow+=add[i];\n\t\twhile(now>K){\n\t\t\tPoint t = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(t.first.first >= i){\n\t\t\t\tans.push_back(t.second);\n\t\t\t\tnow--;\n\t\t\t\tadd[t.first.first+1]++;\n\t\t\t}\n\t\t}\n\t\tif(ind==N+1)break;\n\t}\n\tprintf(\"%d\\n\", ans.size());\n\tfor(auto a:ans){\n\t\tprintf(\"%d \", a);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D1. Too Many Segments  easy version .json",
    "editorial_link": "https://codeforces.com//blog/entry/70779",
    "editorial": "In this problem, the following greedy solution works: letâs find the\r\nleftmost point covered by more than segments. We should fix it somehow.\r\nHow to do it? Letâs find some segment that was not removed already, it\r\ncovers this point and its rightmost end is maximum possible, and remove\r\nthis segment.You can implement it in any time you want, even in naively.\r\n",
    "hint": []
}