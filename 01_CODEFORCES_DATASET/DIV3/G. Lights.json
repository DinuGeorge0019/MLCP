{
    "link": "https://codeforces.com//contest/1907/problem/G",
    "problemId": "2365628",
    "problem_idx": "G",
    "shortId": "1907G",
    "contest_number": "1907",
    "problem_submissions": {
        "E": [
            235922096,
            235913995,
            235900143,
            235903340,
            235921667,
            235901704,
            235905781,
            236028309,
            235900905,
            235914797,
            235900953,
            235904410,
            235901939,
            235904392,
            235896353,
            235889597,
            235895501,
            235901631,
            235906746,
            235904536
        ],
        "G": [
            235905776,
            235944172,
            240754131,
            236224108,
            239539892
        ],
        "D": [
            235889060,
            235907893,
            235885826,
            235889907,
            235880968,
            235891188,
            235887305,
            235888897,
            235891138,
            235883950,
            235891896,
            235891023,
            235886777,
            235889881,
            237694958,
            235867800,
            235908732,
            235892927,
            235897779,
            235896975
        ],
        "F": [
            235888366,
            235927475,
            235911089,
            235918673,
            235897756,
            235921167,
            235919938,
            235923351,
            235911206,
            235921824,
            235923367,
            235927696,
            235932260,
            235934792,
            235914612,
            235925488,
            235926925,
            235918432,
            235922859
        ],
        "C": [
            235881778,
            235895243,
            235879309,
            235877991,
            235891348,
            235879417,
            235877691,
            235876696,
            235876979,
            235890394,
            235881961,
            235879314,
            235876924,
            235882981,
            236028314,
            235898937,
            235877137,
            235881599,
            235886820,
            235888590
        ],
        "B": [
            235864949,
            235883426,
            235872876,
            235865746,
            235868017,
            235866431,
            235870498,
            236028285,
            235870319,
            235871004,
            235871121,
            235872127,
            235871434,
            235867930,
            235865841,
            235901960,
            235870212,
            235875746,
            235875948,
            235874656
        ],
        "A": [
            235860107,
            235867323,
            235860491,
            235859890,
            235861006,
            235859799,
            235860028,
            235860311,
            235859823,
            235863201,
            235863210,
            235860674,
            236211486,
            235860837,
            235860015,
            235864893,
            235860651,
            235867283,
            235865532,
            235861983
        ]
    },
    "name": "G. Lights",
    "statement": "In the end of the day, Anna needs to turn off the lights in the office.\r\nThere are n lights and n light switches, but their operation scheme is\r\nreally strange. The switch i changes the state of light i, but it also\r\nchanges the state of some other light a_i (change the state means that\r\nif the light was on, it goes off and vice versa).Help Anna to turn all\r\nthe lights off using minimal number of switches, or say it is\r\nimpossible.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define ll long long\n#define ii pair<int,int>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \": \" << x << endl\n#define pub push_back\n#define pob pop_backac\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n;\nchar s[N];\nint a[N];\nbool vis[N];\nint fa[N];\nint du[N];\nvector<int >G[N];\nmap<ii,int >tag;\nint t[N],top;\nvoid solve()\n{\n    tag.clear();\n    n=read();\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;++i)   du[i]=0;\n    for(int i=1;i<=n;++i)   G[i].clear();\n    for(int i=1;i<=n;++i)   vis[i]=false;\n    for(int i=1;i<=n;++i)   a[i]=s[i]-'0';\n    for(int i=1;i<=n;++i)\n    {\n        fa[i]=read();\n        ++du[fa[i]];\n        G[fa[i]].push_back(i);\n        tag[{i,fa[i]}]=tag[{fa[i],i}]=i;\n    }\n    queue<int >q;\n    for(int i=1;i<=n;++i)\n        if(!du[i])  q.push(i);\n    while(!q.empty())\n    {\n        int u=q.front();    q.pop();\n        a[fa[u]]^=a[u]; vis[u]=a[u];\n        if(!--du[fa[u]])    q.push(fa[u]);\n    }\n    for(int i=1;i<=n;++i)\n    {\n        if(!du[i])  continue;\n        top=0;\n        int now=i;\n        while(true)\n        {\n            du[now]=0;\n            t[++top]=now;\n            now=fa[now];\n            if(now==i)  break;\n        }\n        int ok=-1;  int sum=INF;\n        for(int k=0;k<2;++k)\n        {\n            int pre=k;  now=0;\n            int s=0;\n            for(int j=1;j<=top;++j)\n            {\n                now=a[t[j]]^pre;\n                pre=now;\n                s+=now;\n            }\n            if(pre!=k)  continue;\n            if(sum<s)   continue;\n            sum=s;\n            ok=k;\n        }\n        if(ok==-1)\n        {\n            puts(\"-1\");\n            return ;\n        }\n        int pre=ok;  now=0;\n        for(int j=1;j<=top;++j)\n        {\n            now=a[t[j]]^pre;\n            vis[t[j]]=now;\n            pre=now;\n        }\n    }\n    \n    int tot=0;\n    for(int i=1;i<=n;++i)   tot+=vis[i];\n    printf(\"%d\\n\",tot);\n    for(int i=1;i<=n;++i)   if(vis[i])  printf(\"%d \",i);\n    puts(\"\");\n}\nint main()\n{\n    T=read();\n    while(T--)  solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Lights.json",
    "editorial_link": "https://codeforces.com//blog/entry/123012",
    "editorial": "Letâs construct a directed graph where an edge originates from vertex to\r\nvertex . In such a graph, exactly one edge originates from each vertex,\r\nand there is exactly one cycle in each connected component.First, we\r\nwill turn off all the lights that are not part of the cycles; the\r\nsequence of such turn-offs is unique: We will remove all the turned-off\r\nvertices into which no edges enter, and we will turn off and remove the\r\nturned-on ones.After that, only cycle components will remain, some of\r\nwhich may have lights turned on. Consider any edge of the cycle from to\r\n; we will either press switch or not. To count the number of operations\r\nin these cases, we will use the same algorithm as before.\r\n",
    "hint": []
}