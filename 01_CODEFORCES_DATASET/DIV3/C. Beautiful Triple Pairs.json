{
    "link": "https://codeforces.com//contest/1974/problem/C",
    "problemId": "2657205",
    "problem_idx": "C",
    "shortId": "1974C",
    "contest_number": "1974",
    "problem_submissions": {
        "G": [
            261890876,
            261895242,
            261892104,
            261815844,
            261901397,
            261882110,
            261902942,
            261897196,
            261890302,
            261906925,
            261906633,
            261902994,
            261909128,
            262172085,
            261998366,
            261998046,
            261912311
        ],
        "F": [
            261873832,
            261860163,
            261871347,
            261886083,
            261890598,
            261905275,
            261893342,
            261893849,
            261885670,
            261888292,
            261884408,
            261903255,
            261856931,
            261866178,
            261998302,
            261867572,
            261874550,
            261881230,
            261896095,
            261891848
        ],
        "E": [
            261843511,
            261898684,
            261874046,
            261856295,
            261872971,
            261858650,
            261864336,
            261872189,
            261875499,
            261861733,
            261866981,
            261850233,
            261886170,
            261845363,
            261845593,
            261998691,
            261848135,
            261863399,
            261863179,
            261861452,
            261854564
        ],
        "D": [
            261828744,
            261833579,
            261844887,
            261858347,
            261848070,
            261834943,
            261843848,
            261843125,
            261893971,
            261854059,
            261850835,
            261836444,
            261865680,
            261830266,
            261832171,
            261998550,
            261835226,
            261844678,
            261837286,
            261829368,
            261844070
        ],
        "C": [
            261809458,
            261818269,
            261821670,
            261838680,
            261824893,
            261817516,
            261818307,
            261822342,
            261872865,
            261902570,
            261836543,
            261891689,
            261812999,
            261811999,
            261811344,
            261998621,
            261807237,
            261810379,
            261809093,
            261808251,
            261815953
        ],
        "B": [
            261801251,
            261803139,
            261801216,
            261828779,
            261802058,
            261805873,
            261803693,
            261800515,
            261806010,
            261808108,
            261800732,
            261800673,
            261801484,
            261801347,
            261998221,
            261798953,
            261798594,
            261800683,
            261798231,
            261800035
        ],
        "A": [
            261797694,
            261795610,
            261795288,
            261822724,
            261797136,
            261796736,
            262453696,
            261795629,
            261796165,
            261795943,
            261800077,
            261795571,
            261795380,
            261796034,
            261796954,
            261998187,
            261795311,
            261795243,
            261796139,
            261795603,
            261796608
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129686",
    "editorial": "To consider each pair only once, we will go from left to right and while\r\nadding a new triplet, we will add to the answer the number of already\r\nadded triplets that form a beautiful pair with the current one.We will\r\nmaintain a with triplets, to denote a triplet with an error, we will\r\nplace (or any other value that cannot occur in the array ) in place of\r\nthe error.Thus, for each triplet , the already found triplets , , will\r\nbe good. In each case, triplets equal to will also be included, so they\r\nneed to be subtracted from each of the three cases.\r\n",
    "name": "C. Beautiful Triple Pairs",
    "statement": "Polycarp was given an array a of n integers. He really likes triples of\r\nnumbers, so for each j (1\r\nle j\r\nle n - 2) he wrote down a triple of elements [a_j, a_{j + 1}, a_{j +\r\n2}].Polycarp considers a pair of triples b and c if they differ in\r\nexactly one position, that is, one of the following conditions is\r\nsatisfied: b_1\r\nne c_1 and b_2 = c_2 and b_3 = c_3; b_1 = c_1 and b_2\r\nne c_2 and b_3 = c_3; b_1 = c_1 and b_2 = c_2 and b_3\r\nne c_3. Find the number of pairs of triples among the written triples\r\n[a_j, a_{j + 1}, a_{j + 2}].\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <algorithm>#include <vector>#include <chrono>#include <random>#include <map>#include <set>using namespace std;typedef long long ll;const int N = 2e5 + 10;int a[N];void solve() {\tint n;\tcin >> n;\tfor (int i = 1; i <= n; i++) {\t\tcin >> a[i];\t}\tvector<map <pair<int, int>, int>> mp(3);\tmap <pair<int, pair<int, int>>, int> yp;\tfor (int i = 1; i <= n - 2; i++) {\t\tmp[0][{ a[i], a[i + 1] }]++;\t\tmp[1][{ a[i], a[i + 2] }]++;\t\tmp[2][{ a[i + 1], a[i + 2] }]++;\t\typ[{a[i], { a[i + 1], a[i + 2] }}]++;\t}\tll ans = 0;\tfor (auto w : mp) {\t\tfor (auto it : w) {\t\t\tans = (ans + (it.second * 1ll * (it.second - 1)) / 2);\t\t}\t}\tll w = 0;\tfor (auto it : yp) {\t\tw = (w + (it.second * 1ll * (it.second - 1)) / 2);\t}\tans -= 3 * w;\tcout << ans << \"\\n\";} int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\C. Beautiful Triple Pairs.json",
    "hint": []
}