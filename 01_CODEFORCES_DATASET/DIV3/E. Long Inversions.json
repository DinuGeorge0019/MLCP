{
    "link": "https://codeforces.com//contest/1955/problem/E",
    "problemId": "2579457",
    "problem_idx": "E",
    "shortId": "1955E",
    "contest_number": "1955",
    "problem_submissions": {
        "G": [
            255700432,
            255685371,
            255700202,
            255694984,
            255713116,
            255710945,
            255815483,
            255720205,
            255712913,
            255719635,
            255740112,
            255735779,
            255734648,
            255728080,
            255811582,
            255740083,
            255712654,
            255816753,
            255730101,
            255733676,
            255729429,
            255749883
        ],
        "F": [
            255690836,
            255730118,
            255712738,
            255723348,
            255696813,
            255721239,
            255711672,
            255703746,
            255701885,
            255718873,
            255724659,
            255733290,
            255718852,
            255723723,
            255725364,
            255717728,
            255710197,
            255736254,
            255712457
        ],
        "E": [
            255679602,
            255678850,
            255660817,
            255677164,
            255677495,
            255695083,
            255692381,
            255695668,
            255688219,
            255691378,
            255687451,
            255688784,
            255697004,
            255707937,
            255738844,
            255740248,
            255706468,
            255704684,
            255707886
        ],
        "D": [
            255663451,
            255667353,
            255685203,
            255671122,
            255669296,
            255675907,
            255680787,
            255676580,
            255675808,
            255675309,
            255677471,
            255667366,
            255685779,
            255681400,
            255682629,
            255685354,
            255677101,
            255696157,
            255690888
        ],
        "C": [
            255657238,
            255660807,
            255678901,
            255663623,
            255662171,
            255657175,
            255664052,
            255666604,
            255666050,
            255656375,
            255666921,
            255652774,
            255678671,
            255660970,
            255664282,
            255661069,
            255666029,
            255658918,
            255678375
        ],
        "B": [
            255642714,
            255647145,
            255662403,
            255652531,
            255651120,
            255650530,
            255651554,
            255653536,
            255651004,
            255648291,
            255648566,
            255643999,
            255648718,
            255649499,
            255650291,
            255653938,
            255647027,
            255650471,
            255659271
        ],
        "A": [
            255635163,
            255633427,
            255637795,
            255633451,
            255634276,
            255634783,
            255634704,
            255650196,
            255634135,
            255635088,
            255633579,
            255633389,
            255637393,
            255636215,
            255633812,
            255642645,
            255634779,
            255634460,
            255639283
        ],
        "H": [
            255690981,
            255842703,
            255840768
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128243",
    "editorial": "No substring of the string needs to be inverted twice, as it does not\r\nchange the string in any way. Let\u00e2\u0080\u0099s fix and try to check if all the\r\ncharacters of the string can be made equal to . Suppose the first\r\ncharacters are already equal to , and . Then we need to invert all the\r\nbits starting from the -th to the -th inclusive, i.e., not invert the\r\nfirst characters. If we invert any of the first characters, then we will\r\nhave to invert it again. Either we will invert again, so it will become\r\nequal to , or we will invert the characters to the left and come to the\r\nsame situation, but for a smaller prefix.Naive checking for a fixed\r\ntakes time, if we honestly invert characters every time we encounter .\r\nWe will maintain an inversion counter how many times we need to invert a\r\ncharacter of the string. Getting the actual value of a character is\r\nsimple if the counter is odd, invert the character. If , add to the\r\ncounter, and remember that we need to subtract from the counter after\r\nposition , forming a segment . This way, the complexity of the check\r\nwill be .It remains to iterate over and find the maximum for which it\r\nwas possible to bring the string to all s. The complexity of the\r\nsolution is .\r\n",
    "name": "E. Long Inversions",
    "statement": "A binary string s of length n is given. A binary string is a string\r\nconsisting only of the characters \u201d and \u201d.You can choose an integer k (1\r\nle k\r\nle n) and then apply the following operation any number of times: choose\r\nk consecutive characters of the string and invert them, i.e., replace\r\nall \u201d with \u201d and vice versa.Using these operations, you need to make all\r\nthe characters in the string equal to \u201d.For example, if n=5, s=00100,\r\nyou can choose k=3 and proceed as follows: choose the substring from the\r\n1-st to the 3-rd character and obtain s=\r\ncolor{blue}{110}00; choose the substring from the 3-rd to the 5-th\r\ncharacter and obtain s=11\r\ncolor{blue}{111}; Find the maximum value of k for which it is possible\r\nto make all the characters in the string equal to \u201d using the described\r\noperations. Note that the number of operations required to achieve this\r\nis not important.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define int long longusing namespace std;class Segment_Tree{public:\tstruct tree{\t\tint l,r,sum,maxx,minx,flag;\t}tr[800005];\tvoid pushup(int u){\t\ttr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\t\ttr[u].maxx=max(tr[u<<1].maxx,tr[u<<1|1].maxx);\t\ttr[u].minx=min(tr[u<<1].minx,tr[u<<1|1].minx);\t}\tvoid pushdown(int u){\t\tif(tr[u].flag){\t\t\ttr[u<<1].sum+=tr[u].flag*(tr[u<<1].r-tr[u<<1].l+1),tr[u<<1].maxx+=tr[u].flag,tr[u<<1].minx+=tr[u].flag,tr[u<<1].flag+=tr[u].flag;\t\t\ttr[u<<1|1].sum+=tr[u].flag*(tr[u<<1|1].r-tr[u<<1|1].l+1),tr[u<<1|1].maxx+=tr[u].flag,tr[u<<1|1].minx+=tr[u].flag,tr[u<<1|1].flag+=tr[u].flag;\t\t\ttr[u].flag=0;\t\t}\t}\tvoid build(int u,int l,int r){\t\tif(l==r){\t\t\ttr[u]={l,r,0,0,0,0};\t\t\treturn;\t\t}\t\ttr[u]={l,r};\t\tint mid=l+r>>1;\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\t\tpushup(u);\t}\tvoid change(int u,int l,int r,int k){\t\tif(l>r)return;\t\tif(tr[u].l>=l&&tr[u].r<=r){\t\t\ttr[u].sum+=k*(tr[u].r-tr[u].l+1);\t\t\ttr[u].maxx+=k,tr[u].minx+=k;\t\t\ttr[u].flag+=k;\t\t\treturn;\t\t}\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1;\t\tif(l<=mid)change(u<<1,l,r,k);\t\tif(r>mid)change(u<<1|1,l,r,k);\t\tpushup(u);\t}\tint query_sum(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=0;\t\tif(l<=mid)res+=query_sum(u<<1,l,r);\t\tif(r>mid)res+=query_sum(u<<1|1,l,r);\t\treturn res;\t}\tint query_max(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].maxx;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=-1e18;\t\tif(l<=mid)res=max(res,query_max(u<<1,l,r));\t\tif(r>mid)res=max(res,query_max(u<<1|1,l,r));\t\treturn res;\t}\tint query_min(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].minx;;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=1e18;\t\tif(l<=mid)res=min(res,query_min(u<<1,l,r));\t\tif(r>mid)res=min(res,query_min(u<<1|1,l,r));\t\treturn res;\t}}sgt;int t,n,sum[5005];string s;signed main(){\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\tcin>>t;\twhile(t--){\t\tcin>>n>>s,s=\" \"+s;\t\tint ans=0;\t\tfor(int i=n;i;i--){\t\t\tfor(int j=1;j<=n;j++)sum[j]=0;\t\t\tint flag=1;\t\t\tfor(int j=1;j<=n-i+1;j++){\t\t\t\tint x=(s[j]-'0')+sum[j-1]-sum[max(j-i,0ll)];x%=2;\t\t\t\tif(x==0)sum[j]=sum[j-1]+1;\t\t\t\telse sum[j]=sum[j-1];\t\t\t}\t\t\tfor(int j=n-i+2;j<=n;j++){\t\t\t\tint x=(s[j]-'0')+sum[j-1]-sum[max(j-i,0ll)];x%=2;\t\t\t\tflag&=(x==1),sum[j]=sum[j-1];\t\t\t}\t\t\tif(flag){\t\t\t\tans=i;\t\t\t\tbreak;\t\t\t}\t\t}\t\tcout<<ans<<\"\\n\";\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Long Inversions.json"
}