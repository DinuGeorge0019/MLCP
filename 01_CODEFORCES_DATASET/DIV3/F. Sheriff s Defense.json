{
    "link": "https://codeforces.com//contest/2014/problem/F",
    "problemId": "2892478",
    "problem_idx": "F",
    "shortId": "2014F",
    "contest_number": "2014",
    "problem_submissions": {
        "G": [
            282355237,
            282340908,
            282349517,
            282469109,
            282768209
        ],
        "H": [
            282319139,
            282294919,
            282369641,
            282327328,
            282344971,
            282343427,
            282320463,
            282354346,
            282338340,
            282341971,
            282345189,
            282359227,
            282335882,
            282356841,
            282332486,
            282259554,
            282367573,
            282358571,
            282340140,
            282354845,
            282340779
        ],
        "F": [
            282310940,
            282344360,
            282329041,
            282301003,
            282317626,
            282346191,
            282313376,
            282324314,
            282336360,
            282330209,
            282316236,
            282352931,
            282339107,
            282367052,
            282355481,
            282342400,
            282311004,
            282354051,
            282348444,
            282360261
        ],
        "E": [
            282298135,
            282347444,
            282324784,
            282315211,
            282288353,
            282301236,
            282298734,
            282299501,
            282311127,
            282309362,
            282313492,
            282303867,
            282309804,
            282310056,
            282314491,
            282344707,
            282319635,
            282302427,
            282313050,
            282331264,
            282317148
        ],
        "D": [
            282266365,
            282262468,
            282284761,
            282266186,
            282281624,
            282263914,
            282278929,
            282290066,
            282285534,
            282292322,
            282283633,
            282303511,
            282281064,
            282294495,
            282319933,
            282298383,
            282290687,
            282285759,
            282297433,
            282291388
        ],
        "C": [
            282245761,
            282249551,
            282267820,
            282250356,
            282260562,
            282251055,
            282251810,
            282263518,
            282256201,
            282252015,
            282260274,
            282248128,
            282257994,
            282266861,
            282299616,
            282253349,
            282254086,
            282264623,
            282276303,
            282262355
        ],
        "B": [
            282235337,
            282236894,
            282246106,
            282232521,
            282241668,
            282237594,
            282243258,
            282239802,
            282239576,
            282238146,
            282241956,
            282238965,
            282240579,
            282237329,
            282279188,
            282240894,
            282242478,
            282240040,
            282236073,
            282244164,
            282271471
        ],
        "A": [
            282225117,
            282225433,
            282233872,
            282225077,
            282234075,
            282225216,
            282226675,
            282226848,
            282232220,
            282227137,
            282231989,
            282227272,
            282229469,
            282228546,
            282236816,
            282226223,
            282233092,
            282227477,
            282229182,
            282226562
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/134210",
    "editorial": "An important observation is that strengthening a base only influences its neighbors, so we can just keep consider adjacent nodes as later ones are not affected. Let's consider induction to solve this problem. Let d[i][0]\n denote the most gold from node i\n and all its children if we don't strengthen node i\n and d[i][1]\n if we do strengthen the node i\n.\n\nBase case: If the current node i\n is a leaf, d[i][0]=0\n, d[i][1]=ai\n.\n\nInduction step: Consider the node i\n with children 1\u0085m\n. Assume that all nodes 1\u0085m\n are already calculated. If we don't strengthen the node i\n, d[i][0]=?mj=1max(d[j][0],d[j][1])\n. If the node i\n is strengthened, d[i][1]=ai+?mj=1max(d[j][0],d[j][1]?2?c)\n.\n\nTime complexity \u0097 O(n)\n.",
    "name": "F. Sheriff s Defense",
    "statement": "The folk hero Robin Hood has been troubling Sheriff of Nottingham\r\ngreatly. Sheriff knows that Robin Hood is about to attack his camps and\r\nhe wants to be prepared.Sheriff of Nottingham built the camps with\r\nstrategy in mind and thus there are exactly n camps numbered from 1 to n\r\nand n-1 trails, each connecting two camps. Any camp can be reached from\r\nany other camp. Each camp i has initially a_i gold. As it is now, all\r\ncamps would be destroyed by Robin. Sheriff can strengthen a camp by\r\nsubtracting exactly c gold from and use it to build better defenses for\r\nthat camp. Strengthening a camp its gold, only its neighbors\u2019 gold. A\r\ncamp can have negative gold. After Robin Hood\u2019s attack, all camps that\r\nhave been strengthened survive the attack, all others are\r\ndestroyed.What\u2019s the maximum gold Sheriff can keep in his surviving\r\ncamps after Robin Hood\u2019s attack if he strengthens his camps optimally?\r\nCamp a is neighboring camp b if and only if there exists a trail\r\nconnecting a and b. Only strengthened camps count towards the answer, as\r\nothers are destroyed.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;#define int long long#define endl '\\n'#define PII pair<int, int>const int N = 2e5 + 5;const int mod = 1e9 + 7;int n, m, a[N], dp[N][2];vector<int> e[N];void dfs(int u, int fa){    for (auto to : e[u])        if (to != fa)        {            dfs(to, u);            dp[u][0] += max(dp[to][0], dp[to][1]);            dp[u][1] += max(dp[to][0], dp[to][1] - 2 * m);        }}void solve(){    cin >> n >> m;    for (int i = 1; i <= n; i++)        cin >> a[i], e[i].clear(), dp[i][0] = 0, dp[i][1] = a[i];    for (int i = 1; i < n; i++)    {        int u, v;        cin >> u >> v;        e[u].push_back(v), e[v].push_back(u);    }    dfs(1, 0);    cout << max(dp[1][0], dp[1][1]) << endl;}signed main(){    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);    int t = 1;    cin >> t;    while (t--)        solve();    return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Sheriff s Defense.json"
}