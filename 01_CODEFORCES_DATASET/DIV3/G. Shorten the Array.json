{
    "link": "https://codeforces.com//contest/2093/problem/G",
    "problemId": "3316694",
    "problem_idx": "G",
    "shortId": "2093G",
    "contest_number": "2093",
    "problem_submissions": {
        "G": [
            314598849,
            314606152,
            314587837,
            314603802,
            314617244,
            314636843,
            314627641,
            314600484,
            314594509,
            314620818,
            314635145,
            314608319,
            314614792,
            314625948,
            314636125,
            314647345,
            314643350,
            314696296,
            314695422,
            314626566,
            320943180,
            316430155,
            316118291,
            316109856,
            314647533
        ],
        "F": [
            314558487,
            314577897,
            314625297,
            314618724,
            314550975,
            314613160,
            314640815,
            314612755,
            314576025,
            314580140,
            314620214,
            314601161,
            314634333,
            314617932,
            314620741,
            314641936,
            316430291,
            314618171
        ],
        "E": [
            314544557,
            314535804,
            314564193,
            314584439,
            314601580,
            314571635,
            314566292,
            314573283,
            314566908,
            314569827,
            314594393,
            314592990,
            314569180,
            314598271,
            314602179,
            314604220,
            314574875
        ],
        "D": [
            314536131,
            314548404,
            314559767,
            314561746,
            314588013,
            314559202,
            314556203,
            314580187,
            314554129,
            314551666,
            314587477,
            314585574,
            314553841,
            314581434,
            314576973,
            314582629,
            314601313
        ],
        "C": [
            314526642,
            314521445,
            314518733,
            314537065,
            314535871,
            314531879,
            314535043,
            314525409,
            314542891,
            314542275,
            314543204,
            314552545,
            314540325,
            314550521,
            314542741,
            314550013,
            314552540
        ],
        "B": [
            314515947,
            314513843,
            314512428,
            314541683,
            314519273,
            314519539,
            314519019,
            314557363,
            314534402,
            314538618,
            314524038,
            314544076,
            314523050,
            314523557,
            314528828,
            314536221,
            314527428
        ],
        "A": [
            314508419,
            314505299,
            314504405,
            314507249,
            314505871,
            314511003,
            314506100,
            314506987,
            314535725,
            314508847,
            314505153,
            314508202,
            314508618,
            314506581,
            314510822,
            314519518,
            314513582
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141434",
    "editorial": "First, note that in the optimal segment , the maximum value of must be\r\nachieved precisely when and . Otherwise, we can shift at least one of\r\nthe boundaries, thereby reducing the length of the found segment. Our\r\ntask then becomes to find the nearest pair of indices and such that\r\n.Next, we consider all numbers in the array as binary strings padded\r\nwith leading zeros to a length of . Note that ordinary comparison of\r\nnumbers is equivalent to lexicographical order on such strings.Let , , ,\r\nthen the condition is equivalent to the existence of a bit such that and\r\n. Or , and then for any it will hold that .Suppose we have fixed the\r\nvalues of , , and , then we need to find such a number that and and .\r\nFor the given and , we are interested in the nearest that satisfies\r\nthese conditions.We will traverse the array from left to right and\r\nmaintain in a binary trie all the numbers we have already passed. We\r\nwill also keep track of the maximum index among the added numbers in the\r\ncorresponding subtree at each node of the trie. Thus, the search for the\r\nnearest suitable for a given will look like a descent in the trie along\r\nthe string . If the value in the -th bit of the number is , we need to\r\ndescend along the edge . Otherwise, if , we should check the maximum\r\nindex in the subtree , but we will descend along the edge .Thus, after\r\nprocessing all the numbers in the array, we will find a pair of nearest\r\n, , for which . The solution works in .\r\n",
    "name": "G. Shorten the Array",
    "statement": "The beauty of an array b of length m is defined as\r\nmax(b_i\r\noplus b_j) among all possible pairs 1\r\nle i\r\nle j\r\nle m, where x\r\noplus y is the bitwise XOR of numbers x and y. We denote the beauty\r\nvalue of the array b as f(b).An array b is called beautiful if f(b)\r\nge k.Recently, Kostya bought an array a of length n from the store. He\r\nconsiders this array too long, so he plans to cut out some beautiful\r\nsubarray from it. That is, he wants to choose numbers l and r (1\r\nle l\r\nle r\r\nle n) such that the array a_{l\r\ndots r} is beautiful. The length of such a subarray will be the number\r\nr - l + 1. The entire array a is also considered a subarray (with l = 1\r\nand r = n).Your task is to find the length of the shortest beautiful\r\nsubarray in the array a. If no subarray is beautiful, you should output\r\nthe number -1.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "dfs and similar",
        "greedy",
        "strings",
        "trees",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\G. Shorten the Array.json",
    "hint": [
        "Hint 1 Let the shortest segment have boundaries and . What can be said about the indices and for which the maximum value of the expression is achieved?",
        "Hint 2 The operation on int32 numbers can be represented as the XOR of two binary strings of length . What can be said about the comparison of numbers? In what case does the expression hold? And ?",
        "Hint 3 How can we use a trie on binary strings to find the nearest index such that ?"
    ]
}