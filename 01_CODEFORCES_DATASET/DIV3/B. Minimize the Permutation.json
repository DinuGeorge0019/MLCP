{
    "link": "https://codeforces.com//contest/1256/problem/B",
    "problemId": "459825",
    "problem_idx": "B",
    "shortId": "1256B",
    "contest_number": "1256",
    "problem_submissions": {
        "C": [
            64235233,
            64227620,
            64227351,
            64236152,
            64252052,
            64225352,
            64226667,
            64237109,
            64249877,
            64222625,
            64278670,
            64233886,
            64252797,
            64233119,
            64246491,
            64253891
        ],
        "F": [
            64233031,
            64241980,
            64252827,
            64253934,
            64245116,
            64253899,
            64232381,
            64237354,
            64239968,
            64313496,
            64235709,
            64249337
        ],
        "E": [
            64221946,
            64223976,
            64247117,
            64244704,
            64224516,
            64249242,
            64227415,
            64227683,
            64231825,
            64236214,
            64243137,
            64237104,
            64247426,
            64247032,
            64250549,
            64247147,
            64241890,
            64239099,
            64237754
        ],
        "B": [
            64221631,
            64212047,
            64218399,
            64317159,
            64218926,
            64240089,
            64228311,
            64210409,
            64218403,
            64212202,
            64219328,
            64218836,
            64219933,
            64225452,
            64221378,
            64217229,
            64214632,
            64216240,
            64215942
        ],
        "D": [
            64215172,
            64216393,
            64233882,
            64227241,
            64227346,
            64251438,
            64216967,
            64223705,
            64223794,
            64230378,
            64223867,
            64223333,
            64232043,
            64229490,
            64228441,
            64222986,
            64234141,
            64223821,
            64223652
        ],
        "A": [
            64212957,
            64209179,
            64210635,
            64210231,
            64209282,
            64209523,
            64209181,
            64209149,
            64208937,
            64208806,
            64214758,
            64212460,
            64209582,
            64215325,
            64209661,
            64209581,
            64209733,
            64208776,
            64209184,
            64209129
        ]
    },
    "name": "B. Minimize the Permutation",
    "statement": "You are given a permutation of length n. Recall that the permutation is\r\nan array consisting of n distinct integers from 1 to n in arbitrary\r\norder. For example, [2, 3, 1, 5, 4] is a permutation, but [1, 2, 2] is\r\nnot a permutation (2 appears twice in the array) and [1, 3, 4] is also\r\nnot a permutation (n=3 but there is 4 in the array).You can perform at\r\nmost n-1 operations with the given permutation (it is possible that you\r\ndon’t perform any operations at all). The i-th operation allows you to\r\nswap elements of the given permutation on positions i and i+1. . The\r\noperations can be performed in arbitrary order.Your task is to find the\r\nlexicographically minimum possible permutation obtained by performing\r\nsome of the given operations in some order.You can see the definition of\r\nthe lexicographical order in the notes section.You have to answer q\r\nindependent test cases.For example, let’s consider the permutation [5,\r\n4, 1, 3, 2]. The minimum possible permutation we can obtain is [1, 5, 2,\r\n4, 3] and we can do it in the following way: perform the second\r\noperation (swap the second and the third elements) and obtain the\r\npermutation [5, 1, 4, 3, 2]; perform the fourth operation (swap the\r\nfourth and the fifth elements) and obtain the permutation [5, 1, 4, 2,\r\n3]; perform the third operation (swap the third and the fourth elements)\r\nand obtain the permutation [5, 1, 2, 4, 3]. perform the first operation\r\n(swap the first and the second elements) and obtain the permutation [1,\r\n5, 2, 4, 3]; Another example is [1, 2, 4, 3]. The minimum possible\r\npermutation we can obtain is [1, 2, 3, 4] by performing the third\r\noperation (swap the third and the fourth elements).\r\n",
    "solutions": [
        "//ZJ_MRZ's Code\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<vector>\n#define re register\n#define N 110\nusing namespace std;\ninline int read();\ninline long long readl();\ninline void write(int x,int ch);\ninline void writel(int x,int ch);\nint a[N],n;\ninline void sol() {\n\tn=read();\n\tint minv,minn,minr;\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i]=read();\n\t\tif(a[i]==1) {\n\t\t\tminn=i;\n\t\t\tminr=i;\n\t\t}\n\t}\n\tfor(int i=minn-1;i>=1;i--)\n\t\tswap(a[i],a[i+1]);\n\twhile(minr<n) {\n\t\tminv=200;\n\t\tfor(int i=minr;i<=n;i++) {\n\t\t\tif(a[i]<minv) {\n\t\t\t\tminv=a[i];\n\t\t\t\tminn=i;\n\t\t\t}\n\t\t}\n\t\tif(minn==minr) {\n\t\t\tminr++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=minn-1;i>=minr;i--)\n\t\t\tswap(a[i],a[i+1]);\n\t\tminr=minn;\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tcout<<a[i]<<\" \";\n\t}\n\tcout<<endl;\n\treturn;\n}\nsigned main() {\n\tint T;\n\tT=read();\n\twhile(T--) {\n\t\tsol();\n\t}\n\treturn 0;\n}\ninline void writel(long long x,int ch) {\n\tif(x<0) {\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tif(x>9) {\n\t\twrite(x/10,0);\n\t}\n\tputchar(x%10+'0');\n\tif(ch)\n\t\tprintf(\"\\n\");\n\treturn;\n}\ninline void write(int x,int ch) {\n\tif(x<0) {\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tif(x>9) {\n\t\twrite(x/10,0);\n\t}\n\tputchar(x%10+'0');\n\tif(ch)\n\t\tprintf(\"\\n\");\n\treturn;\n}\ninline long long readl() {\n    long long x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0') {\n        if(ch=='-')\n            f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9') {\n        x=x*10+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int read() {\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch>'9'||ch<'0') {\n        if(ch=='-')\n            f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9') {\n        x=x*10+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Minimize the Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/71184",
    "editorial": "The following greedy solution works: letâs take the minimum element and\r\nmove it to the leftmost position we can. With this algorithm, all\r\nforbidden operations are form the prefix of operations: (), , ..., and\r\nso on. So we can carry the position of the leftmost operation we can\r\nperform . Initially, it is . We repeat the algorithm until . Letâs find\r\nthe position of the minimum element among elements . Let this position\r\nbe . If then letâs increase and continue the algorithm. Otherwise, we\r\nneed to move the element from the position to the position and then set\r\n.Time complexity: .\r\n",
    "hint": []
}