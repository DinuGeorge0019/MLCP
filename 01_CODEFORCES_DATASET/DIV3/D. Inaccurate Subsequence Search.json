{
    "link": "https://codeforces.com//contest/1955/problem/D",
    "problemId": "2579456",
    "problem_idx": "D",
    "shortId": "1955D",
    "contest_number": "1955",
    "problem_submissions": {
        "G": [
            255700432,
            255685371,
            255700202,
            255694984,
            255713116,
            255710945,
            255815483,
            255720205,
            255712913,
            255719635,
            255740112,
            255735779,
            255734648,
            255728080,
            255811582,
            255740083,
            255712654,
            255816753,
            255730101,
            255733676,
            255729429,
            255749883
        ],
        "F": [
            255690836,
            255730118,
            255712738,
            255723348,
            255696813,
            255721239,
            255711672,
            255703746,
            255701885,
            255718873,
            255724659,
            255733290,
            255718852,
            255723723,
            255725364,
            255717728,
            255710197,
            255736254,
            255712457
        ],
        "E": [
            255679602,
            255678850,
            255660817,
            255677164,
            255677495,
            255695083,
            255692381,
            255695668,
            255688219,
            255691378,
            255687451,
            255688784,
            255697004,
            255707937,
            255738844,
            255740248,
            255706468,
            255704684,
            255707886
        ],
        "D": [
            255663451,
            255667353,
            255685203,
            255671122,
            255669296,
            255675907,
            255680787,
            255676580,
            255675808,
            255675309,
            255677471,
            255667366,
            255685779,
            255681400,
            255682629,
            255685354,
            255677101,
            255696157,
            255690888
        ],
        "C": [
            255657238,
            255660807,
            255678901,
            255663623,
            255662171,
            255657175,
            255664052,
            255666604,
            255666050,
            255656375,
            255666921,
            255652774,
            255678671,
            255660970,
            255664282,
            255661069,
            255666029,
            255658918,
            255678375
        ],
        "B": [
            255642714,
            255647145,
            255662403,
            255652531,
            255651120,
            255650530,
            255651554,
            255653536,
            255651004,
            255648291,
            255648566,
            255643999,
            255648718,
            255649499,
            255650291,
            255653938,
            255647027,
            255650471,
            255659271
        ],
        "A": [
            255635163,
            255633427,
            255637795,
            255633451,
            255634276,
            255634783,
            255634704,
            255650196,
            255634135,
            255635088,
            255633579,
            255633389,
            255637393,
            255636215,
            255633812,
            255642645,
            255634779,
            255634460,
            255639283
        ],
        "H": [
            255690981,
            255842703,
            255840768
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128243",
    "editorial": "How to check if two arrays are good? For each element of , try to pair\r\nit with an element from array . If we managed to create or more pairs,\r\nthen the arrays are good.Since rearranging the elements of the array is\r\nallowed, we will maintain three multisets , , and . In , we will store\r\nall elements from for which we found a pair, and in and , all elements\r\nfrom and for which a pair was not found, i.e., . Then the arrays are\r\ngood if .It remains to understand how to find all good subsegments using\r\nthis data organization. Suppose we shift the left boundary by ,\r\nsimultaneously moving the right boundary, where . We need to remove the\r\npair with the element from , if it exists, and immediately try to find a\r\nreplacement for the removed pair in . After that, we try to find a pair\r\nfor from , and if a pair cannot be found, we place the element in .The\r\ncomplexity of the solution is or if a hash table is used.\r\n",
    "name": "D. Inaccurate Subsequence Search",
    "statement": "Maxim has an array a of n integers and an array b of m integers (m\r\nle n).Maxim considers an array c of length m to be good if the elements\r\nof array c can be rearranged in such a way that at least k of them match\r\nthe elements of array b. For example, if b = [1, 2, 3, 4] and k = 3,\r\nthen the arrays [4, 1, 2, 3] and [2, 3, 4, 5] are good (they can be\r\nreordered as follows: [1, 2, 3, 4] and [5, 2, 3, 4]), while the arrays\r\n[3, 4, 5, 6] and [3, 4, 3, 4] are not good.Maxim wants to choose every\r\nsubsegment of array a of length m as the elements of array c. Help Maxim\r\ncount how many selected arrays will be good.In other words, find the\r\nnumber of positions 1\r\nle l\r\nle n - m + 1 such that the elements a_l, a_{l+1},\r\ndots, a_{l + m - 1} form a good array.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>#define int long longusing namespace std;class Segment_Tree{public:\tstruct tree{\t\tint l,r,sum,maxx,minx,flag;\t}tr[800005];\tvoid pushup(int u){\t\ttr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;\t\ttr[u].maxx=max(tr[u<<1].maxx,tr[u<<1|1].maxx);\t\ttr[u].minx=min(tr[u<<1].minx,tr[u<<1|1].minx);\t}\tvoid pushdown(int u){\t\tif(tr[u].flag){\t\t\ttr[u<<1].sum+=tr[u].flag*(tr[u<<1].r-tr[u<<1].l+1),tr[u<<1].maxx+=tr[u].flag,tr[u<<1].minx+=tr[u].flag,tr[u<<1].flag+=tr[u].flag;\t\t\ttr[u<<1|1].sum+=tr[u].flag*(tr[u<<1|1].r-tr[u<<1|1].l+1),tr[u<<1|1].maxx+=tr[u].flag,tr[u<<1|1].minx+=tr[u].flag,tr[u<<1|1].flag+=tr[u].flag;\t\t\ttr[u].flag=0;\t\t}\t}\tvoid build(int u,int l,int r){\t\tif(l==r){\t\t\ttr[u]={l,r,0,0,0,0};\t\t\treturn;\t\t}\t\ttr[u]={l,r};\t\tint mid=l+r>>1;\t\tbuild(u<<1,l,mid),build(u<<1|1,mid+1,r);\t\tpushup(u);\t}\tvoid change(int u,int l,int r,int k){\t\tif(l>r)return;\t\tif(tr[u].l>=l&&tr[u].r<=r){\t\t\ttr[u].sum+=k*(tr[u].r-tr[u].l+1);\t\t\ttr[u].maxx+=k,tr[u].minx+=k;\t\t\ttr[u].flag+=k;\t\t\treturn;\t\t}\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1;\t\tif(l<=mid)change(u<<1,l,r,k);\t\tif(r>mid)change(u<<1|1,l,r,k);\t\tpushup(u);\t}\tint query_sum(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].sum;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=0;\t\tif(l<=mid)res+=query_sum(u<<1,l,r);\t\tif(r>mid)res+=query_sum(u<<1|1,l,r);\t\treturn res;\t}\tint query_max(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].maxx;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=-1e18;\t\tif(l<=mid)res=max(res,query_max(u<<1,l,r));\t\tif(r>mid)res=max(res,query_max(u<<1|1,l,r));\t\treturn res;\t}\tint query_min(int u,int l,int r){\t\tif(tr[u].l>=l&&tr[u].r<=r)return tr[u].minx;;\t\tpushdown(u);\t\tint mid=tr[u].l+tr[u].r>>1,res=1e18;\t\tif(l<=mid)res=min(res,query_min(u<<1,l,r));\t\tif(r>mid)res=min(res,query_min(u<<1|1,l,r));\t\treturn res;\t}}sgt;int t,n,m,k,a[200005],b[200005],cnt1[200005],cnt2[200005];map<int,int>mp1,mp2;signed main(){\tcin>>t;\twhile(t--){\t\tcin>>n>>m>>k,mp1.clear(),mp2.clear();\t\tfor(int i=1;i<=n;i++)cin>>a[i];\t\tfor(int i=1;i<=m;i++)cin>>b[i],mp2[b[i]]++;\t\tint cnt=0,ans=0;\t\tfor(int i=1;i<=m;i++){\t\t\tmp1[a[i]]++;\t\t\tif(mp1[a[i]]<=mp2[a[i]])cnt++;\t\t}ans=cnt>=k;\t\tfor(int i=1;i<n-m+1;i++){\t\t\tmp1[a[i]]--;\t\t\tif(mp1[a[i]]<mp2[a[i]])cnt--;\t\t\tmp1[a[i+m]]++;\t\t\tif(mp1[a[i+m]]<=mp2[a[i+m]])cnt++;\t\t\tans+=cnt>=k;\t\t}\t\tcout<<ans<<\"\\n\";\t}}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Inaccurate Subsequence Search.json"
}