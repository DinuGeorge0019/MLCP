{"link": "https://codeforces.com//contest/1547/problem/F", "problemId": "1041930", "problem_idx": "F", "shortId": "1547F", "contest_number": "1547", "problem_submissions": {"G": [121944344, 121945250, 121969047, 121966817, 121967594, 121972943, 121975745, 121977858, 122032964, 121981350, 122056223, 121979237, 121981913, 121981376, 121980625, 122155991, 121975434, 121991454, 121995068, 121976725, 121981904, 121989177], "F": [121935413, 121935594, 121941387, 121951169, 121954987, 121958658, 121946378, 121960440, 121957223, 121947189, 121953926, 121961168, 121956579, 122155975, 121957484, 121963743, 121963233, 121983907, 130067043, 121967696, 121964782], "E": [121927323, 121930033, 121934266, 121934350, 121934750, 121950868, 121938700, 121947044, 121939016, 121918151, 121943738, 121951247, 121943401, 122155944, 121929091, 121938064, 121948603, 121929249, 121954857, 121951226], "D": [121920905, 121925537, 121926615, 121928957, 121929027, 121935132, 121933601, 121938327, 121930818, 121951066, 121937525, 121939215, 121938926, 122155930, 121923421, 121931871, 121939814, 121923678, 121938027, 121939755], "C": [121917301, 121919644, 121922161, 121925361, 121925131, 121930197, 121927618, 121931352, 121926041, 121941579, 121930327, 121931481, 121932549, 122155920, 121946724, 121926871, 121930207, 121920117, 121930152, 121928271], "B": [121913269, 121913944, 121915637, 121917152, 121916079, 121921759, 121916250, 121921748, 121918400, 121932403, 121917513, 121922124, 121917559, 122155902, 121918020, 121915357, 121920773, 121914177, 121922706, 121919941], "A": [121912871, 121922538, 121912963, 121913157, 121913099, 121914913, 121913485, 121917366, 121913258, 121918822, 121913536, 121914396, 121913813, 122155895, 121942243, 121912931, 121913822, 121912948, 121914731, 121913859]}, "name": "F. Array Stabilization  GCD version ", "statement": "You are given an array of positive integers a = [a_0, a_1,\r\ndots, a_{n - 1}] (n\r\nge 2).In one step, the array a is replaced with another array of length\r\nn, in which each element is the greatest common divisor (GCD) of two\r\nneighboring elements (the element itself and its right neighbor;\r\nconsider that the right neighbor of the (n - 1)-th element is the 0-th\r\nelement).Formally speaking, a new array b = [b_0, b_1,\r\ndots, b_{n - 1}] is being built from array a = [a_0, a_1,\r\ndots, a_{n - 1}] such that b_i =\r\ngcd(a_i, a_{(i + 1)\r\nmod n}), where\r\ngcd(x, y) is the greatest common divisor of x and y, and x\r\nmod y is the remainder of x dividing by y. In one step the array b is\r\nbuilt and then the array a is replaced with b (that is, the assignment a\r\nb is taking place).For example, if a = [16, 24, 10, 5] then b = [\r\ngcd(16, 24),\r\ngcd(24, 10),\r\ngcd(10, 5),\r\ngcd(5, 16)] = [8, 2, 5, 1]. Thus, after one step the array a = [16, 24,\r\n10, 5] will be equal to [8, 2, 5, 1].For a given array a, find the\r\nminimum number of steps after which all values a_i become equal (that\r\nis, a_0 = a_1 =\r\ndots = a_{n - 1}). If the original array a consists of identical\r\nelements then consider the number of steps is equal to 0.\r\n", "solutions": ["#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    struct ST {\n        vector<int> a;\n\n        ST(vector<int> &b) {\n            a.resize(b.size() * 4);\n            build(0, 0, b.size(), b);\n        }\n\n        void build(int i, int l, int r, vector<int> &b) {\n            if (l + 1 == r) {\n                a[i] = b[l];\n            } else {\n                int m = (l + r) >> 1;\n                build(i * 2 + 1, l, m, b);\n                build(i * 2 + 2, m, r, b);\n                a[i] = gcd(a[i * 2 + 1], a[i * 2 + 2]);\n            }\n        }\n\n        int get(int i, int l, int r, int ql, int qr) {\n            if (r <= ql || qr <= l) {\n                return 0;\n            }\n            if (ql <= l && r <= qr) {\n                return a[i];\n            }\n            int m = (l + r) >> 1;\n            return gcd(get(i * 2 + 1, l, m, ql, qr), get(i * 2 + 2, m, r, ql, qr));\n        }\n    };\n\n    void solve() {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        auto b = a;\n        a.insert(a.end(), b.begin(), b.end());\n        ST st(a);\n        int l = 0, r = n;\n        while (l + 1 < r) {\n            int m = (l + r) >> 1;\n            int g = st.get(0, 0, 2 * n, 0, m);\n            bool ok = true;\n            for (int i = 1; i < n; i++) {\n                int z = st.get(0, 0, 2 * n, i, i + m);\n                if (g != z) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        cout << l << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures", "divide and conquer", "number theory", "two pointers"], "dificulty": "1900", "interactive": false}