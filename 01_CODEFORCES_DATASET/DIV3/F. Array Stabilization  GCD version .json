{
    "link": "https://codeforces.com//contest/1547/problem/F",
    "problemId": "1041930",
    "problem_idx": "F",
    "shortId": "1547F",
    "contest_number": "1547",
    "problem_submissions": {
        "G": [
            121944344,
            121945250,
            121969047,
            121966817,
            121967594,
            121972943,
            121975745,
            121977858,
            122032964,
            121981350,
            122056223,
            121979237,
            121981913,
            121981376,
            121980625,
            122155991,
            121975434,
            121991454,
            121995068,
            121976725,
            121981904,
            121989177
        ],
        "F": [
            121935413,
            121935594,
            121941387,
            121951169,
            121954987,
            121958658,
            121946378,
            121960440,
            121957223,
            121947189,
            121953926,
            121961168,
            121956579,
            122155975,
            121957484,
            121963743,
            121963233,
            121983907,
            130067043,
            121967696,
            121964782
        ],
        "E": [
            121927323,
            121930033,
            121934266,
            121934350,
            121934750,
            121950868,
            121938700,
            121947044,
            121939016,
            121918151,
            121943738,
            121951247,
            121943401,
            122155944,
            121929091,
            121938064,
            121948603,
            121929249,
            121954857,
            121951226
        ],
        "D": [
            121920905,
            121925537,
            121926615,
            121928957,
            121929027,
            121935132,
            121933601,
            121938327,
            121930818,
            121951066,
            121937525,
            121939215,
            121938926,
            122155930,
            121923421,
            121931871,
            121939814,
            121923678,
            121938027,
            121939755
        ],
        "C": [
            121917301,
            121919644,
            121922161,
            121925361,
            121925131,
            121930197,
            121927618,
            121931352,
            121926041,
            121941579,
            121930327,
            121931481,
            121932549,
            122155920,
            121946724,
            121926871,
            121930207,
            121920117,
            121930152,
            121928271
        ],
        "B": [
            121913269,
            121913944,
            121915637,
            121917152,
            121916079,
            121921759,
            121916250,
            121921748,
            121918400,
            121932403,
            121917513,
            121922124,
            121917559,
            122155902,
            121918020,
            121915357,
            121920773,
            121914177,
            121922706,
            121919941
        ],
        "A": [
            121912871,
            121922538,
            121912963,
            121913157,
            121913099,
            121914913,
            121913485,
            121917366,
            121913258,
            121918822,
            121913536,
            121914396,
            121913813,
            122155895,
            121942243,
            121912931,
            121913822,
            121912948,
            121914731,
            121913859
        ]
    },
    "name": "F. Array Stabilization  GCD version ",
    "statement": "You are given an array of positive integers a = [a_0, a_1,\r\ndots, a_{n - 1}] (n\r\nge 2).In one step, the array a is replaced with another array of length\r\nn, in which each element is the greatest common divisor (GCD) of two\r\nneighboring elements (the element itself and its right neighbor;\r\nconsider that the right neighbor of the (n - 1)-th element is the 0-th\r\nelement).Formally speaking, a new array b = [b_0, b_1,\r\ndots, b_{n - 1}] is being built from array a = [a_0, a_1,\r\ndots, a_{n - 1}] such that b_i =\r\ngcd(a_i, a_{(i + 1)\r\nmod n}), where\r\ngcd(x, y) is the greatest common divisor of x and y, and x\r\nmod y is the remainder of x dividing by y. In one step the array b is\r\nbuilt and then the array a is replaced with b (that is, the assignment a\r\nb is taking place).For example, if a = [16, 24, 10, 5] then b = [\r\ngcd(16, 24),\r\ngcd(24, 10),\r\ngcd(10, 5),\r\ngcd(5, 16)] = [8, 2, 5, 1]. Thus, after one step the array a = [16, 24,\r\n10, 5] will be equal to [8, 2, 5, 1].For a given array a, find the\r\nminimum number of steps after which all values a_i become equal (that\r\nis, a_0 = a_1 =\r\ndots = a_{n - 1}). If the original array a consists of identical\r\nelements then consider the number of steps is equal to 0.\r\n",
    "solutions": [
        "#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    struct ST {\n        vector<int> a;\n\n        ST(vector<int> &b) {\n            a.resize(b.size() * 4);\n            build(0, 0, b.size(), b);\n        }\n\n        void build(int i, int l, int r, vector<int> &b) {\n            if (l + 1 == r) {\n                a[i] = b[l];\n            } else {\n                int m = (l + r) >> 1;\n                build(i * 2 + 1, l, m, b);\n                build(i * 2 + 2, m, r, b);\n                a[i] = gcd(a[i * 2 + 1], a[i * 2 + 2]);\n            }\n        }\n\n        int get(int i, int l, int r, int ql, int qr) {\n            if (r <= ql || qr <= l) {\n                return 0;\n            }\n            if (ql <= l && r <= qr) {\n                return a[i];\n            }\n            int m = (l + r) >> 1;\n            return gcd(get(i * 2 + 1, l, m, ql, qr), get(i * 2 + 2, m, r, ql, qr));\n        }\n    };\n\n    void solve() {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        auto b = a;\n        a.insert(a.end(), b.begin(), b.end());\n        ST st(a);\n        int l = 0, r = n;\n        while (l + 1 < r) {\n            int m = (l + r) >> 1;\n            int g = st.get(0, 0, 2 * n, 0, m);\n            bool ok = true;\n            for (int i = 1; i < n; i++) {\n                int z = st.get(0, 0, 2 * n, i, i + m);\n                if (g != z) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        cout << l << \"\\n\";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], \"r\", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "divide and conquer",
        "number theory",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Array Stabilization  GCD version .json",
    "editorial_link": "https://codeforces.com//blog/entry/92715",
    "editorial": "First, note that the array stabilizes if and only if it consists of\r\nequal elements, and the number the array will be consisted of is .\r\nIndeed, at the -th step a number equal to will be written at the -th\r\nposition in the array.This is easy to prove by induction: if at the\r\nprevious step the adjacent elements in the array were equal to of the\r\nnumbers on adjacent segments of length in the original array, then their\r\ngreatest common divisor will be the greatest common divisor of the union\r\nof these two segments (GCD is an idempotent operation).Thus, the\r\nalgorithm will stop in no more than steps, since after steps all numbers\r\nwill be equal exactly to . If we divide all the numbers by before\r\nstarting the algorithm, then the number of steps won\u00e2\u0080\u0099t change, but the\r\narray will stabilize at the number .Since the numbers in the array after\r\nthe -th step will be exactly equal to of all segments of length of the\r\noriginal array , it follows that the number of steps after which all\r\nvalues become the same is exactly equal to the length of the maximum\r\nsegment of the original array on which .There are several ways to find\r\nthe length of such a segment. For example, you can use range GCD query\r\nand binary search. The following method is based on the factorization of\r\nnumbers, in other words, on their decomposition into prime factors.\r\nFactorization in this problem could be done using both the sieve of\r\nEratosthenes or factoring each number independently in .After all the\r\nnumbers have been factorized, iterate over each and each prime in its\r\nfactorization. In linear time we can go left and right from , finding\r\nthe maximum segment of numbers that contain the same factor . Then we\r\ncan update the answer with the length of this segment and move onto the\r\nnext prime in the factorization of or go to , if all primes have already\r\nbeen iterated through.Note that if a segment of numbers divisible by\r\ncontains indices from to , then we iterate through it times. In order to\r\navoid reiteration on each segment, we remove from the factorizations of\r\nall numbers on the segment after considering only one.The resulting\r\nsolution works in , where the maximum number of different primes in\r\nfactoriztion of . Considering that , , so the solution fits into the\r\ntime limit.\r\n"
}