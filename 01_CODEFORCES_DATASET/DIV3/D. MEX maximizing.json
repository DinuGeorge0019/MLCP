{
    "link": "https://codeforces.com//contest/1294/problem/D",
    "problemId": "521710",
    "problem_idx": "D",
    "shortId": "1294D",
    "contest_number": "1294",
    "problem_submissions": {
        "F": [
            69345723,
            69341742,
            69353873,
            69354168,
            69362489,
            69359650,
            69346353,
            69348606,
            69346845,
            69359883,
            69366706,
            69362024,
            69366917,
            69346932,
            69357467,
            69365166,
            69348414,
            69365647,
            69364629
        ],
        "E": [
            69338805,
            69351779,
            69339037,
            69344007,
            69344151,
            69343043,
            69361056,
            69360226,
            69364740,
            69351017,
            69346873,
            69323356,
            69353170,
            69364089,
            69360143,
            69354125,
            69351861,
            69359421,
            69360122,
            69354120
        ],
        "D": [
            69326821,
            69327425,
            69329129,
            69327902,
            69327595,
            69331659,
            69323447,
            69329706,
            69328760,
            69337985,
            69335298,
            69329000,
            69425046,
            69424930,
            69331368,
            69329469,
            69336157,
            69331418,
            69331535,
            69332903,
            69334125
        ],
        "C": [
            69316704,
            69318571,
            69324078,
            69319609,
            69320098,
            69321493,
            69318537,
            69320636,
            69318004,
            69321999,
            69327286,
            69331832,
            69318703,
            69317985,
            69329221,
            69324244,
            69332444,
            69322784,
            69323291
        ],
        "B": [
            69312164,
            69313583,
            69315904,
            69322215,
            69312293,
            69313735,
            69314120,
            69311768,
            69311366,
            69316184,
            69310957,
            69317833,
            69313722,
            69313259,
            69323626,
            69316316,
            69314611,
            69315633,
            69316963
        ],
        "A": [
            69304908,
            69306368,
            69307420,
            69304625,
            69304112,
            69305282,
            69304786,
            69304157,
            69304143,
            69307552,
            69304615,
            69309994,
            69304636,
            69303953,
            69304661,
            69308930,
            69306713,
            69306352,
            69305710
        ]
    },
    "name": "D. MEX maximizing",
    "statement": "Recall that of an array is a that does not belong to the array.\r\nExamples: for the array [0, 0, 1, 0, 2] MEX equals to 3 because numbers\r\n0, 1 and 2 are presented in the array and 3 is the minimum non-negative\r\ninteger not presented in the array; for the array [1, 2, 3, 4] MEX\r\nequals to 0 because 0 is the minimum non-negative integer not presented\r\nin the array; for the array [0, 1, 4, 3] MEX equals to 2 because 2 is\r\nthe minimum non-negative integer not presented in the array. You are\r\ngiven an empty array a=[] (in other words, a zero-length array). You are\r\nalso given a positive integer x.You are also given q queries. The j-th\r\nquery consists of one integer y_j and means that you have to append one\r\nelement y_j to the array. The array length increases by 1 after a\r\nquery.In one move, you can choose any index i and set a_i := a_i + x or\r\na_i := a_i - x (i.e. increase or decrease any element of the array by\r\nx). The only restriction is that . Since initially the array is empty,\r\nyou can perform moves only after the first query.You have to maximize\r\nthe (minimum excluded) of the array if you can perform any number of\r\nsuch operations (you can even perform the operation multiple times with\r\none element).You have to find the answer after each of q queries (i.e.\r\nthe j-th answer corresponds to the array of length j).\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nint tr[N];\nvoid add(int id,int x){\n    //if(id==0)return;\n    for(;id<=n+1;id+=id&-id)tr[id]+=x;\n}\nint query(int id){\n    int re=0;\n    for(;id;id-=id&-id)re+=tr[id];\n    return re;\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1,x;i<=n;i++){\n        scanf(\"%d\",&x);\n        x%=m;\n        int l=0,r=n/m;\n        int ans=n+2;\n        while(l<=r){\n            int mid=l+r>>1;\n            if(mid*m+x+1>n+1)r=mid-1;\n            else if(query(mid*m+x+1)-query(mid*m+x)==0)ans=mid,r=mid-1;\n            else l=mid+1;\n        }\n        if(ans<=n+1)\n        add(ans*m+x+1,1);\n        //cout<<\"fuck \"<<ans<<' '<<x<<' '<<ans*m+x<<endl;\n        l=1,r=n+1;\n        ans=n+1;\n        while(l<=r){\n            int mid=l+r>>1;\n            if(query(mid)<mid)ans=mid,r=mid-1;\n            else l=mid+1;\n        }\n        printf(\"%d\\n\",ans-1);\n\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. MEX maximizing.json",
    "editorial_link": "https://codeforces.com//blog/entry/73274",
    "editorial": "Firstly, letâs understand what the operation does. It changes the\r\nelement but holds the remainder modulo . So we can consider all elements\r\nmodulo .Let be the number of elements with the value modulo , be the\r\nnumber of elements with the value modulo , and so on. Letâs understand,\r\nwhere is the \"bottleneck\" of MEX. Obviously, we can always fill exactly\r\nfull blocks, so MEX is at least . MEX will be among all elements such\r\nthat . Among all such elements MEX will be the minimum such . Let it be\r\n. So the final value of MEX is .How to deal with queries? Letâs maintain\r\nthe sorted set of pairs () for all and change it with respect to\r\nappended values. During each query letâs change the set correspondingly\r\nand take the answer as the first element of this set using the formula\r\nabove.Time complexity: . There is also an easy linear solution that uses\r\nthe same idea but in a different way.\r\n",
    "hint": []
}