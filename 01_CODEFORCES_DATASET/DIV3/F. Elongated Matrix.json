{
    "link": "https://codeforces.com//contest/1102/problem/F",
    "problemId": "280232",
    "problem_idx": "F",
    "shortId": "1102F",
    "contest_number": "1102",
    "problem_submissions": {
        "F": [
            48140951,
            48147190,
            48151952,
            48147273,
            48149693,
            48148209,
            48149357,
            48156228,
            48324719,
            48156492,
            48211275,
            48210647,
            48465963
        ],
        "E": [
            48133168,
            48134978,
            48134782,
            48135856,
            48131616,
            48151765,
            48145873,
            48128235,
            48131297,
            48136054,
            48139969,
            48138178,
            48141535,
            48140000,
            50612473,
            49117474,
            48143805,
            48143096,
            48141761,
            48140639,
            48142040,
            48138664
        ],
        "D": [
            48130363,
            48129370,
            48132705,
            48133131,
            48146366,
            48139447,
            48153130,
            48141036,
            48138860,
            48132737,
            48132907,
            48132415,
            48134717,
            48134475,
            48133518,
            48130113,
            48138869,
            48135563,
            48136818,
            48135753
        ],
        "C": [
            48124610,
            48124428,
            48127226,
            48130117,
            48124395,
            48129801,
            48133951,
            48124097,
            48123397,
            48126329,
            48125852,
            48124992,
            48127428,
            48126645,
            48127128,
            48125282,
            48126002,
            48129026,
            48128077,
            48129849
        ],
        "B": [
            48122561,
            48122504,
            48125142,
            48127847,
            48123165,
            48123788,
            48132434,
            48120816,
            48121994,
            48123399,
            48123616,
            48121594,
            48124256,
            48123685,
            48122759,
            48123296,
            48123050,
            48125935,
            48125539,
            48126168
        ],
        "A": [
            48119616,
            48119377,
            48119214,
            48122772,
            48119115,
            48118984,
            48121381,
            48121124,
            48118971,
            48118958,
            48120635,
            48119936,
            48118948,
            48119353,
            48120109,
            48119913,
            48119534,
            48118997,
            48120967,
            48119662,
            48120313
        ]
    },
    "name": "F. Elongated Matrix",
    "statement": "You are given a matrix a, consisting of n rows and m columns. Each cell\r\ncontains an integer in it.You can change the order of rows arbitrarily\r\n(including leaving the initial order), but you can\u2019t change the order of\r\ncells in a row. After you pick some order of rows, you traverse the\r\nwhole matrix the following way: firstly visit all cells of the first\r\ncolumn from the top row to the bottom one, then the same for the second\r\ncolumn and so on. During the traversal you write down the sequence of\r\nthe numbers on the cells in the same order you visited them. Let that\r\nsequence be s_1, s_2,\r\ndots, s_{nm}. The traversal is k-acceptable if for all i (1\r\nle i\r\nle nm - 1) |s_i - s_{i + 1}|\r\nge k.Find the maximum integer k such that there exists some order of\r\nrows of matrix a that it produces a k-acceptable traversal.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 16,M = 1e4;\nint n,m,a[N][M],dp[1<<N][N],now;\nint cost[N][N],last[N][M];\nint find(int x,int y){\n\tint val = 1e9;\n\tfor(int i = 0;i < m;i++)val = min(val,abs(a[x][i] - a[y][i]));\n\tcost[x][y] = val;\n\tval = 1e9;\n\tfor(int i = 0;i + 1 < m;i++)val = min(val,abs(a[y][i] - a[x][i + 1]));\n\tlast[x][y] = val;\n}\nint calc(int msk,int at){\n\tif(__builtin_popcount(msk) == n)return last[now][at];\n\tint &ref = dp[msk][at];\n\tif(ref != -1)return ref;\n\tref = -2;\n\tfor(int i = 0;i < n;i++)\n\t\tif(!(msk&(1<<i)))\n\t\t\tref = max(ref,min(calc(msk|(1<<i),i),cost[at][i]));\n\treturn ref;\n}\nint main(){\n// \tfreopen(\"input.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0;i < n;i++)\n\t\tfor(int j = 0;j < m;j++)\n\t\t\tscanf(\"%d\",&a[i][j]);\n\tfor(int i = 0;i < n;i++)\n\t\tfor(int j = 0;j < n;j++)\n\t\t\tfind(i,j);\n\tint ans = -1;\n\tfor(int i = 0;i < n;i++){\n\t\tnow = i;\n\t\tmemset(dp,-1,sizeof dp);\n\t\tans = max(ans,calc(1<<i,i));\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "dp",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Elongated Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/64439",
    "editorial": "Really low constraints, choosing some permutation... Surely, this will\r\nbe some dp on subsets!At first, let\u00e2\u0080\u0099s get rid of . For each two rows\r\ncalculate the minimum difference between the elements of the same\r\ncolumns let\u00e2\u0080\u0099s call this for some rows , . This will be used to put row\r\nright after row . Let\u00e2\u0080\u0099s also calculate the minimum difference between\r\nthe elements of the column of row and column of row . This will be used\r\nto put row as the last row and row as the first one.Now let\u00e2\u0080\u0099s think of\r\nchoosing the permutation as choosing the traversal of the following\r\ngraph. Vertices are rows and the weights of edges between the vertices\r\nare stored in . However, you can\u00e2\u0080\u0099t straight up do minimum weight\r\nHamiltonian cycle search as the edge between the first vertex and the\r\nlast one should be of weight from and not .Let\u00e2\u0080\u0099s fix some starting\r\nvertex and find minimum weight Hamiltonian paths from it to all\r\nvertices. Finally, update the answer with . That will lead to approach\r\n(minimum weight Hamiltonian path is a well-known problem solved by\r\n).That\u00e2\u0080\u0099s completely fine and it\u00e2\u0080\u0099s the most intended solution.However,\r\nthere exist another solution that would have worked better if the edge\r\nweight were a bit smaller.Let\u00e2\u0080\u0099s do binary search, each time checking if\r\nthe answer is greater or equal to . The check is simple enough. Now the\r\ngraph is binary (edge exists if its weight is greater or equal to ),\r\nthus you should check for existence of Hamiltonian path, not for the\r\nminimum weight one. That can be done in , leading to solution. The key\r\nidea of that dp is storing the vertices where the path of the current\r\nmask could have ended as a mask itself. Then it becomes with\r\ntransitions.Overall complexity: or .\r\n"
}