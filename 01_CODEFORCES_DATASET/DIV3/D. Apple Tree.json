{
    "link": "https://codeforces.com//contest/1843/problem/D",
    "problemId": "1972493",
    "problem_idx": "D",
    "shortId": "1843D",
    "contest_number": "1843",
    "problem_submissions": {
        "A": [
            210513115,
            210358669,
            210356867,
            210356606,
            210356554,
            210357901,
            210357194,
            210356864,
            210358095,
            210357837,
            210357098,
            210356516,
            210357328,
            210356501,
            210359161,
            210356847,
            210356427,
            210357415,
            210358119,
            210357120,
            210364703
        ],
        "F2": [
            210451991,
            210457207,
            210618819,
            210495074,
            210494100,
            210540752,
            210540669
        ],
        "F1": [
            210414403,
            210417478,
            210396846,
            210409917,
            210412496,
            210409842,
            210422089,
            210412238,
            210413002,
            210417779,
            210416655,
            210416375,
            210514291,
            210424999,
            210427270,
            210422907,
            210427091,
            210425631,
            210535488,
            210532084,
            210419095,
            210422275,
            210416513
        ],
        "E": [
            210391764,
            210391814,
            210384445,
            210387069,
            210389387,
            210395623,
            210390859,
            210397426,
            210401897,
            210395689,
            210473862,
            210401991,
            210402273,
            210403725,
            210394172,
            210401396,
            210403436,
            210400251,
            210398852,
            210406208,
            210398263
        ],
        "D": [
            210377103,
            210378604,
            210375920,
            210374828,
            210376525,
            210379717,
            210379591,
            210382067,
            210379942,
            210382515,
            210378874,
            210376209,
            210374876,
            210386844,
            210381700,
            210376444,
            210371551,
            210381744,
            210386605,
            210381316
        ],
        "C": [
            210369061,
            210367738,
            210368361,
            210366823,
            210368080,
            210359312,
            210366442,
            210374049,
            210371348,
            210364184,
            210365780,
            210367512,
            210366187,
            210360428,
            210370272,
            210365171,
            210363817,
            210370422,
            210368258,
            210373372
        ],
        "B": [
            210363239,
            210368717,
            210361290,
            210360953,
            210362948,
            210369749,
            210362940,
            210364525,
            210363196,
            210375176,
            210362328,
            210363841,
            210361045,
            210364327,
            210364107,
            210360838,
            210360957,
            210367115,
            210363394,
            210370393
        ]
    },
    "name": "D. Apple Tree",
    "statement": "Timofey has an apple tree growing in his garden; it is a rooted tree of\r\nn vertices with the root in vertex 1 (the vertices are numbered from 1\r\nto n). A tree is a connected graph without loops and multiple edges.This\r\ntree is very unusual it grows with its root upwards. However, it\u2019s quite\r\nnormal for programmer\u2019s trees.The apple tree is quite young, so only two\r\napples will grow on it. Apples will grow in certain vertices (these\r\nvertices may be the same). After the apples grow, Timofey starts shaking\r\nthe apple tree until the apples fall. Each time Timofey shakes the apple\r\ntree, the following happens to each of the apples:Let the apple now be\r\nat vertex u. If a vertex u has a child, the apple moves to it (if there\r\nare several such vertices, the apple can move to any of them).\r\nOtherwise, the apple falls from the tree. It can be shown that after a\r\nfinite time, both apples will fall from the tree.Timofey has q\r\nassumptions in which vertices apples can grow. He assumes that apples\r\ncan grow in vertices x and y, and wants to know the number of pairs of\r\nvertices (a, b) from which apples can fall from the tree, where a the\r\nvertex from which an apple from vertex x will fall, b the vertex from\r\nwhich an apple from vertex y will fall. Help him do this.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p=='-';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(\"YES\");\n    else    puts(\"NO\");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nconst int MX=1e6;\nint fac[N];\nint inv[N];\nint ksm(int u,int v)\n{\n    int res=1;\n    while(v)\n    {\n        if(v&1) res=(ll)res*u%P;\n        v>>=1;  u=(ll)u*u%P;\n    }\n    return res;\n}\nint C(int n,int m)\n{\n    if(m<0) return 0;\n    if(n<0) return 0;\n    return (ll)fac[n]*inv[m]%P*inv[n-m]%P;\n}\nvoid init_C()\n{\n    fac[0]=1;\n    for(int i=1;i<=MX;++i)  fac[i]=(ll)fac[i-1]*i%P;\n    inv[MX]=ksm(fac[MX],P-2);\n    for(int i=MX;i>=1;--i)  inv[i-1]=(ll)inv[i]*i%P;\n}\nint T;\nint n,m;\nint ans;\nvector<int >G[N];\nint cnt[N];\nvoid dfs(int u,int fa)\n{\n\tfor(auto v:G[u])\n\t{\n\t\tif(v==fa)\tcontinue;\n\t\tdfs(v,u);\tcnt[u]+=cnt[v];\n\t}\n\tcnt[u]=max(cnt[u],1);\n}\nvoid solve()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)\tG[i].clear();\n\tfor(int i=1;i<=n;++i)\tcnt[i]=0;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint x=read();\tint y=read();\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tm=read();\n\twhile(m--)\n\t{\n\t\tint x=read();\tint y=read();\n\t\tprintf(\"%lld\\n\",(ll)cnt[x]*cnt[y]);\n\t}\n}\nint main()\n{\n\tint T=read();\n\twhile(T--)\tsolve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\D. Apple Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/117468",
    "editorial": "Let be the number of vertices from which an apple can fall if it is in\r\nthe vertex . Then the answer to the query is .Note that the value of is\r\nequal to the number of leaves in the subtree of vertex . Then, these\r\nvalues can be computed using the DFS or BFS. The value for a vertex will\r\nbe equal to if this vertex is a leaf, otherwise it will be equal to the\r\nsum of these values for all children of the vertex.Total complexity: .\r\n"
}