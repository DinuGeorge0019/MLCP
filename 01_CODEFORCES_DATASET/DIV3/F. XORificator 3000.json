{
    "link": "https://codeforces.com//contest/2036/problem/F",
    "problemId": "2997673",
    "problem_idx": "F",
    "shortId": "2036F",
    "contest_number": "2036",
    "problem_submissions": {
        "G": [
            289568495,
            289592157,
            289591763,
            289595974,
            289727611,
            290290543
        ],
        "F": [
            289537821,
            289522926,
            289537324,
            289559326,
            289512509,
            289515984,
            289510795,
            289521272,
            289526918,
            289534575,
            289534164,
            289556542,
            289531934,
            289514943,
            289521852,
            289521308,
            289566779,
            289543749,
            289533352
        ],
        "E": [
            289519379,
            289513483,
            289516754,
            289537406,
            289502565,
            289497006,
            289514977,
            289504007,
            289502653,
            289492035,
            289506214,
            289517949,
            289508708,
            289505547,
            289524899,
            289498786,
            289538409,
            289511145,
            289522074,
            289542250
        ],
        "D": [
            289494755,
            289496973,
            289502561,
            289508569,
            289485075,
            289486449,
            289493423,
            289495061,
            289486975,
            289488146,
            289499112,
            289494333,
            289489388,
            289496285,
            289527032,
            289505896,
            289497283,
            289504013,
            289505465
        ],
        "C": [
            289479986,
            289485425,
            289473871,
            289486850,
            289474317,
            289472689,
            289477260,
            289486030,
            289480295,
            289481264,
            289478991,
            289479671,
            289477258,
            289477016,
            289506161,
            289489963,
            289490617,
            289481449,
            289485496
        ],
        "B": [
            289473268,
            289473263,
            289467611,
            289472113,
            289470722,
            289468547,
            289468418,
            289478505,
            289474994,
            289471830,
            289469932,
            289465642,
            289466472,
            289469818,
            289476408,
            289471072,
            289468104,
            289473322,
            289472255
        ],
        "A": [
            289464981,
            289463574,
            289462739,
            289463265,
            289465451,
            289464109,
            289462932,
            289467937,
            289463249,
            289464614,
            289463267,
            289462869,
            289462845,
            289463088,
            289467021,
            289463344,
            289462625,
            289465258,
            289463000
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135849",
    "editorial": "TutorialWe also recommend the beautiful tutorial by ne_justlm!Let us\r\nintroduce the notation .The first thing that comes to mind when reading\r\nthe condition is that we can compute XOR of all numbers on the segment\r\nfor by the following formula: Then can be found as .Now note that for\r\nthe answer we only need to learn for to find XOR of all uninteresting on\r\nthe segment: then we can do XOR with the whole segment and get XOR of\r\nall interesting numbers already.The base of the modulus, equal to the\r\ndegree of two, is not chosen by chance: we only need to compress and by\r\ntimes in such a way that the resulting range contains all uninteresting\r\nnumbers shifted bits to the right. Then computing we get exactly the\r\ndesired XOR of uninteresting numbers, also shifted bits to the right.\r\nThen, to find these remaining lower bits, we just need to find the\r\nnumber of uninteresting numbers on the segment . If it is odd, these\r\nbits will be equal to , since they are all equal to , and so have the\r\nsame minor bits equal to proper, and so their XOR an odd number of times\r\nwill also be equal to .Otherwise, the lower bits of the answer will be ,\r\nsince we have done XOR an even number of times. The number of\r\nuninteresting numbers on the segment can be calculated in a similar way\r\nto , namely find their number on the segments and and subtract the\r\nlatter from the former. The number of numbers equal to modulo and not\r\nexceeding is calculated as .Time complexity of the solution: .\r\n",
    "name": "F. XORificator 3000",
    "statement": "Alice has been giving gifts to Bob for many years, and she knows that\r\nwhat he enjoys the most is performing bitwise XOR of integers. Bob\r\nconsiders a positive integer x to be if it satisfies x\r\nnot\r\nequiv k (\r\nbmod 2^i). Therefore, this year for his birthday, she gifted him a\r\nsuper-powerful \"XORificator 3000\", the latest model.Bob was very pleased\r\nwith the gift, as it allowed him to instantly compute the XOR of all\r\nintegers in any range from l to r, inclusive. After all, what else does\r\na person need for happiness? Unfortunately, the device was so powerful\r\nthat at one point it performed XOR with itself and disappeared. Bob was\r\nvery upset, and to cheer him up, Alice asked you to write your version\r\nof the \"XORificator\".\r\n",
    "solutions": [
        "#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;ll get_xor(ll l, ll r) {\tif (l == r) return l;\tif (r == l + 1) return (l ^ (l + 1));\tll ans = 0;\tif (l % 2 == 1) { ans ^= l; l++; }\tif (r % 2 == 0) { ans ^= r; r--; }\tll ones = (r - l + 1) / 2;\tif (ones % 2 == 1) ans ^= 1;\treturn ans;}ll pw2(ll i) {\tll ans = 1;\twhile (i--) {\t\tans = ans + ans;\t}\treturn ans;}ll f(ll x, ll i, ll k) {\tif (x == 0) return 0;\tll u = get_xor(1, x);\t//cout << \"? \" << u << \" \";\tif (x < k) return u;\t//2 ^ i * w + k <= x\t//2 ^ i * w <= (x - k)\t//w <= (x - k) / (2 ^ i)\tll p = pw2(i);\tll c = (x - k) / p + 1;\tif (c % 2 == 1) u ^= k;\tll w = get_xor(0, (x - k) / p);\tw *= p;\tu ^= w;\treturn u;}void solve() {\tll l, r, i, k;\tcin >> l >> r >> i >> k;\tcout << (f(r, i, k) ^ f(l - 1, i, k)) << \"\\n\";}int main() {\tint t = 1;\tcin >> t;\twhile (t--) {\t\tsolve();\t}\t//cout << get_xor(1, 28) << \" \";\t//cout << f(28, 3, 7) << \" \";}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "number theory",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. XORificator 3000.json"
}