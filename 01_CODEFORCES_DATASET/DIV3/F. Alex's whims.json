{
    "link": "https://codeforces.com//contest/1899/problem/F",
    "problemId": "2331133",
    "problem_idx": "F",
    "shortId": "1899F",
    "contest_number": "1899",
    "problem_submissions": {
        "F": [
            233143025,
            233133982,
            233130296,
            233135870,
            233148550,
            233134446,
            233142101,
            233143528,
            233137718,
            233124178,
            233156213,
            233142736,
            233146627,
            233148250,
            233151072,
            233160085,
            233144575,
            233142191,
            233145257
        ],
        "G": [
            233138408,
            233146326,
            233159108,
            233167876,
            233139809,
            233174157,
            233151111,
            233162558,
            233172488,
            233169093,
            233111352,
            233167938,
            242655902,
            233290539,
            233290341,
            233290070,
            233289390,
            233245121,
            233170983,
            233290531,
            233287729,
            233172360,
            233175792,
            233169702,
            233171345,
            233192789,
            233177667,
            233175782,
            233178766
        ],
        "E": [
            233114571,
            233127232,
            233121824,
            233122699,
            233130644,
            233123626,
            233133888,
            233135449,
            233124510,
            233138032,
            233128201,
            233131969,
            233135507,
            233133374,
            233128056,
            233141353,
            233143922,
            233131851,
            233131472,
            233136155
        ],
        "D": [
            233111699,
            233121597,
            233118099,
            233117874,
            233205451,
            233126502,
            233118119,
            233124806,
            233129661,
            233120822,
            233191880,
            233146423,
            233118570,
            233129133,
            233128652,
            233206707,
            233122554,
            233128504,
            233129136,
            233124567,
            233125679,
            233129711
        ],
        "C": [
            233108190,
            233112630,
            233112731,
            233109007,
            233111806,
            233112675,
            233116595,
            233114564,
            233114241,
            233115530,
            233131350,
            233124886,
            233117819,
            233122046,
            233110706,
            233117591,
            233116329,
            233117499,
            233115669,
            233122737
        ],
        "B": [
            233106685,
            233108026,
            233109547,
            233105619,
            233103878,
            233109223,
            233117329,
            233111321,
            233108212,
            233111255,
            233135350,
            233111178,
            233113286,
            233109355,
            233206110,
            233136456,
            233114316,
            233109473,
            233113702,
            233110574,
            233113403
        ],
        "A": [
            233102009,
            233097462,
            233097385,
            233097622,
            233097414,
            233102057,
            233099804,
            233098553,
            233136611,
            233099117,
            233097804,
            233097758,
            233102063,
            233104551,
            233097360,
            233101589,
            233099162,
            233098150
        ]
    },
    "name": "F. Alex's whims",
    "statement": "is a connected graph without cycles. It can be shown that any tree of n\r\nvertices has exactly n - 1 edges. is a vertex in the tree with exactly\r\none edge connected to it. between two vertices u and v in a tree is the\r\nminimum number of edges that must be passed to come from vertex u to\r\nvertex v.Alex\u2019s birthday is coming up, and Timofey would like to gift\r\nhim a tree of n vertices. However, Alex is a very moody boy. Every day\r\nfor q days, he will choose an integer, denoted by the integer chosen on\r\nthe i-th day by d_i. If on the i-th day there are not two leaves in the\r\ntree at a distance d_i, Alex will be .Timofey decides to gift Alex a\r\ndesigner so that he can change his tree as he wants. Timofey knows that\r\nAlex is also lazy (a disaster, not a human being), so at the beginning\r\nof every day, he can perform than one operation of the following kind:\r\nChoose vertices u, v_1, and v_2 such that there is an edge between u and\r\nv_1 and no edge between u and v_2. Then remove the edge between u and\r\nv_1 and add an edge between u and v_2. This operation be performed if\r\nthe graph is no longer a tree after it.Somehow Timofey managed to find\r\nout all the d_i. After that, he had another brilliant idea just in case,\r\nmake an instruction manual for the set, one that Alex wouldn\u2019t be\r\n.Timofey is not as lazy as Alex, but when he saw the integer n, he\r\nquickly lost the desire to develop the instruction and the original\r\ntree, so he assigned this task to you. It can be shown that a tree and a\r\nsequence of operations satisfying the described conditions always\r\nexist.Here is an example of an operation where vertices were selected: u\r\n6, v_1 1, v_2 4.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint32_t main() {\n        ios_base::sync_with_stdio(0);\n        cin.tie(0);\n        int t;\n        cin >> t;\n        while (t--) {\n                int n, q;\n                cin >> n >> q;\n                for (int i = 1; i < n; i++) cout << i << ' ' << i + 1 << '\\n';\n                int cur = n - 1;\n                int fuck = 2;\n                for (int i = 0; i < q; i++) {\n                        int d;\n                        cin >> d;\n                        if (d == cur) {\n                                cout << \"-1 -1 -1\\n\";\n                        } else {\n                                // n - fuck + 1 = d\n                                // fuck = n - d + 1\n                                cout << 1 << ' ' << fuck << ' ' << n - d + 1 << '\\n';\n                                fuck = n - d + 1;\n                                cur = d;\n                        }\n                }\n        }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "shortest paths",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Alex's whims.json",
    "editorial_link": "https://codeforces.com//blog/entry/122407",
    "editorial": "EditorialThis problem can be solved in several similar ways, one of them\r\nis given below. First, it is most convenient to take a bamboo vertices\r\nfrom to connected in order. Then, we will maintain the following\r\nconstruction. At each moment of time, vertices and will be connected by\r\nan edge, from vertex there will be at most two branches, which are\r\nsequentially connected vertices (bamboo). Thus, at any given time there\r\nwill be at most three leaves in the tree, one of which is vertex .We\r\nwill maintain vertices from two branches in two arrays. Then, let the\r\ncurrent number from the query be . If the distance from any of the\r\nleaves to vertex is , we don\u00e2\u0080\u0099t need to perform the operation. Otherwise,\r\nlet\u00e2\u0080\u0099s do the operation so that the distance from a leaf from, for\r\nexample, the first branch to vertex is equal to . If the current\r\ndistance is greater than , then we remove the extra vertices to the end\r\nof the second branch, and otherwise we add the necessary ones from the\r\nend of the second branch. Thus, after each operation, the distance from\r\nvertex to some of the sheets will be equal to .Transformations can be\r\ndone by completely moving vertices, then the total complexity .\r\n"
}