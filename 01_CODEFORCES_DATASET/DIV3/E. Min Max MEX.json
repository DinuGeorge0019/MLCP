{
    "link": "https://codeforces.com//contest/2093/problem/E",
    "problemId": "3316692",
    "problem_idx": "E",
    "shortId": "2093E",
    "contest_number": "2093",
    "problem_submissions": {
        "G": [
            314598849,
            314606152,
            314587837,
            314603802,
            314617244,
            314636843,
            314627641,
            314600484,
            314594509,
            314620818,
            314635145,
            314608319,
            314614792,
            314625948,
            314636125,
            314647345,
            314643350,
            314696296,
            314695422,
            314626566,
            320943180,
            316430155,
            316118291,
            316109856,
            314647533
        ],
        "F": [
            314558487,
            314577897,
            314625297,
            314618724,
            314550975,
            314613160,
            314640815,
            314612755,
            314576025,
            314580140,
            314620214,
            314601161,
            314634333,
            314617932,
            314620741,
            314641936,
            316430291,
            314618171
        ],
        "E": [
            314544557,
            314535804,
            314564193,
            314584439,
            314601580,
            314571635,
            314566292,
            314573283,
            314566908,
            314569827,
            314594393,
            314592990,
            314569180,
            314598271,
            314602179,
            314604220,
            314574875
        ],
        "D": [
            314536131,
            314548404,
            314559767,
            314561746,
            314588013,
            314559202,
            314556203,
            314580187,
            314554129,
            314551666,
            314587477,
            314585574,
            314553841,
            314581434,
            314576973,
            314582629,
            314601313
        ],
        "C": [
            314526642,
            314521445,
            314518733,
            314537065,
            314535871,
            314531879,
            314535043,
            314525409,
            314542891,
            314542275,
            314543204,
            314552545,
            314540325,
            314550521,
            314542741,
            314550013,
            314552540
        ],
        "B": [
            314515947,
            314513843,
            314512428,
            314541683,
            314519273,
            314519539,
            314519019,
            314557363,
            314534402,
            314538618,
            314524038,
            314544076,
            314523050,
            314523557,
            314528828,
            314536221,
            314527428
        ],
        "A": [
            314508419,
            314505299,
            314504405,
            314507249,
            314505871,
            314511003,
            314506100,
            314506987,
            314535725,
            314508847,
            314505153,
            314508202,
            314508618,
            314506581,
            314510822,
            314519518,
            314513582
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141434",
    "editorial": "To solve the problem, we use binary search on the answer.To do this, we\r\nneed to learn how to check for a given whether there exists a partition\r\nthat allows achieving an answer of at least . To do this, we will\r\ncollect the segments one by one, that is, first we will find the minimal\r\nvalid first segment, then the second, and so on. Since the segments must\r\nbe non-overlapping and must give the entire array in union, it means\r\nthat in a correct partition there must exist a segment containing the\r\nfirst element; also, the MEX of this segment must be at least , which\r\nmeans it needs to be increased until the MEX becomes greater than or\r\nequal to . As soon as this happens, it makes no sense to further\r\nincrease the segment, so we move on to the next element and begin to\r\nselect the next segment.To maintain MEX on a segment, we can use a\r\ncounting array and a variable in which we store the current MEX. When a\r\nnew number is added to the segment, we run a while loop, and while there\r\nis a number in the segment equal to the current MEX, we increase MEX by\r\none. This works amortized in the number of elements in the segment,\r\nsince MEX on the segment cannot be greater than the length of the\r\nsegment.Asymptotic of the solution: .\r\n",
    "name": "E. Min Max MEX",
    "statement": "You are given an array a of length n and a number k.A subarray is\r\ndefined as a sequence of one or more consecutive elements of the array.\r\nYou need to split the array a into k non-overlapping subarrays b_1, b_2,\r\ndots, b_k such that the union of these subarrays equals the entire\r\narray. Additionally, you need to maximize the value of x, which is equal\r\nto the minimum MEX(b_i), for i\r\nin [1..k].MEX(v) denotes the smallest non-negative integer that is not\r\npresent in the array v.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\E. Min Max MEX.json",
    "hint": [
        "Hint 1 How to check if a solution exists for a fixed ?",
        "Hint 2 We can use binary search."
    ]
}