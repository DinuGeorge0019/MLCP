{
    "link": "https://codeforces.com//contest/1675/problem/F",
    "problemId": "1389923",
    "problem_idx": "F",
    "shortId": "1675F",
    "contest_number": "1675",
    "problem_submissions": {
        "G": [
            156006050,
            156007549,
            173914008,
            156574492,
            156062725,
            156044046
        ],
        "F": [
            155975284,
            155982189,
            155975181,
            155974056,
            155981368,
            155963854,
            155982839,
            155978540,
            155977742,
            155982621,
            155974644,
            155983326,
            155979741,
            155983593,
            155987528,
            155986330,
            155979073,
            155983357,
            155982704,
            155980054
        ],
        "B": [
            155956678,
            155933030,
            155935424,
            155929465,
            155930941,
            155933422,
            155931092,
            155933639,
            155934497,
            155933616,
            155938056,
            155932878,
            155937699,
            155932330,
            155932424,
            155935419,
            155934167,
            155935968,
            155938228,
            155943045
        ],
        "E": [
            155952600,
            155969940,
            155962457,
            155964374,
            155963814,
            155983208,
            155966957,
            155966086,
            155964414,
            155966097,
            155967685,
            155966676,
            155968339,
            155969173,
            155968619,
            155969521,
            155968330,
            155970439,
            155974921,
            155969157
        ],
        "D": [
            155947749,
            155955293,
            155954858,
            155948070,
            155952887,
            155947902,
            155952914,
            155950857,
            155960245,
            155955600,
            155958049,
            155956959,
            155958393,
            155952984,
            155959572,
            155957851,
            155953914,
            155962460,
            155960783,
            155957979
        ],
        "C": [
            155940658,
            155941257,
            155944890,
            155941178,
            155942028,
            155946945,
            155940227,
            155941361,
            155945588,
            155943949,
            155946857,
            155944434,
            155950008,
            155942914,
            155943655,
            155945930,
            155959132,
            155949802,
            155946391,
            155951636
        ],
        "A": [
            155928116,
            155927077,
            155928841,
            155925983,
            155926500,
            155932074,
            155926390,
            155927710,
            155930181,
            155927610,
            155931371,
            155927746,
            155927018,
            155927300,
            155927241,
            155926796,
            155928901,
            155928154,
            155927537,
            155926656
        ]
    },
    "name": "F. Vlad and Unfinished Business",
    "statement": "Vlad and Nastya live in a city consisting of n houses and n-1 road. From\r\neach house, you can get to the other by moving only along the roads.\r\nThat is, the city is a tree.Vlad lives in a house with index x, and\r\nNastya lives in a house with index y. Vlad decided to visit Nastya.\r\nHowever, he remembered that he had postponed for later k things that he\r\nhas to do before coming to Nastya. To do the i-th thing, he needs to\r\ncome to the a_i-th house, things can be done in any order. In 1 minute,\r\nhe can walk from one house to another if they are connected by a\r\nroad.Vlad does not really like walking, so he is interested what is the\r\nminimum number of minutes he has to spend on the road to do all things\r\nand then come to Nastya. Houses a_1, a_2,\r\ndots, a_k he can visit in any order. He can visit any house multiple\r\ntimes (if he wants).\r\n",
    "solutions": [
        "#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == '-') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nconst int N = 2e5 + 10;\nint T,n,k,x,y,etot,dfncnt,head[N + 1],inp[N + 1],f[21][N + 1],dep[N + 1],dfn[N + 1];\nbool mk[N + 1];\nll ans;\n\nstruct Edge{\n\tint u,v,next;\n}e[(N << 1) + 1];\n\nstruct Node{\n\tint i,dep;\n\tbool operator < (const Node& rhs) const{return this->dep < rhs.dep;}\n}ns[N + 1];\n\nvoid init(int n,int k){\n\tetot = 0,ans = 0;\n\tfor (int i = 0;i <= n;i++) head[i] = inp[i] = dep[i] = 0,mk[i] = 0,dfn[i] = 0;\n\tfor (int i = 0;i <= 20;i++){\n\t\tfor (int j = 0;j <= n;j++) f[i][j] = 0;\n\t}\n}\n\nvoid adde(int u,int v) {e[++etot] = (Edge){u,v,head[u]},head[u] = etot;}\n\nvoid pre(int now,int fa){\n\tdfn[now] = ++dfncnt;\n\tdep[now] = dep[fa] + 1;\n\tf[0][now] = fa;\n\tfor (int i = 1;i <= 20;i++) f[i][now] = f[i - 1][f[i - 1][now]];\n\tfor (int i = head[now];i;i = e[i].next){\n\t\tif (e[i].v == fa) continue;\n\t\tpre(e[i].v,now);\n\t}\n}\n\nint getlca(int x,int y){\n\tif (dep[x] < dep[y]) swap(x,y);\n\tfor (int i = 20;i >= 0;i--){\n\t\tif (dep[f[i][x]] >= dep[y]) x = f[i][x];\n\t}\n\tif (x == y) return x;\n\tfor (int i = 20;i >= 0;i--){\n\t\tif (f[i][x] != f[i][y]) x = f[i][x],y = f[i][y];\n\t}\n\treturn f[0][x];\n}\n\nint getdis(int x,int y){\n\tif (x == y) return 0;\n\tint lca = getlca(x,y);\n\treturn dep[x] + dep[y] - (dep[lca] << 1);\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = read(),k = read();\n\t\tx = read(),y = read();\n\t\tinit(n,k);\n\t\tfor (int i = 1;i <= k;i++) mk[inp[i] = read()] = 1;\n\t\tif (!mk[x]) inp[++k] = x,mk[x] = 1;\n\t\tif (!mk[y]) inp[++k] = y,mk[y] = 1;\n\t\tfor (int i = 1;i < n;i++){\n\t\t\tint u = read(),v = read();\n\t\t\tadde(u,v),adde(v,u);\n\t\t}\n\t\tpre(1,0);\n\t\tfor (int i = 1;i <= k;i++) ns[i] = (Node){inp[i],dfn[inp[i]]};\n\t\tsort(ns + 1,ns + k + 1);\n\t\tint last = ns[1].i;\n\t\tfor (int i = 2;i <= k;i++){\n\t\t\tans += getdis(last,ns[i].i);\n\t\t\tlast = ns[i].i;\n\t\t}\n\t\tans += getdis(ns[1].i,ns[k].i);\n\t\tans -= getdis(x,y);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\F. Vlad and Unfinished Business.json",
    "editorial_link": "https://codeforces.com//blog/entry/102550",
    "editorial": "To begin with, we will hang the tree by the vertex . In fact, we want to\r\ngo from the root to the top of , going off this path to do things and\r\ncoming back. At one vertex of the path, it is advantageous to get off it\r\nin all the necessary directions and follow it further. So we will go\r\nonce for each edge leading to and times for each edge leading to some of\r\nthe cases, but not leading to .Let\u00e2\u0080\u0099s match each vertex with an edge to\r\nits ancestor. If the edge of a vertex leads to , then is in the subtree\r\nof this vertex, similarly with vertices with cases. It is necessary for\r\neach vertex to determine whether there is a vertex in its subtree and\r\nwhether there is a vertex from the array , this can be done using a\r\ndepth-first search, then we will calculate the answer according to the\r\nrules described above.\r\n"
}