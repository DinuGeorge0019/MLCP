{
    "link": "https://codeforces.com//contest/1741/problem/B",
    "problemId": "1580858",
    "problem_idx": "B",
    "shortId": "1741B",
    "contest_number": "1741",
    "problem_submissions": {
        "G": [
            175658655,
            175776548,
            175778289,
            175654398,
            175880793,
            175656924,
            175637609,
            175729544,
            176113562
        ],
        "F": [
            175634710,
            175634330,
            175639332,
            175634963,
            175641391,
            175642288,
            175651066,
            175638700,
            175650758,
            175650474,
            175650413,
            175696195,
            175630855,
            175641068,
            175713558,
            175713496,
            175713405,
            175713348,
            175712166,
            175712032,
            175710248,
            175653725,
            188881508,
            175657954,
            175660445,
            175647171
        ],
        "E": [
            175612842,
            175607012,
            175602583,
            175610869,
            175597285,
            175603137,
            175605173,
            175613578,
            175612154,
            175602225,
            175611227,
            175622904,
            175609226,
            175636862,
            175596615,
            175626249,
            175618084,
            175609955,
            175614301,
            175619312
        ],
        "D": [
            175600792,
            175598753,
            175587861,
            175602078,
            175590264,
            175593902,
            175593998,
            175614050,
            175599808,
            175588551,
            175598698,
            175602136,
            175595713,
            175593039,
            175644398,
            175600557,
            175714317,
            175605116,
            175598500,
            175596629,
            175607880
        ],
        "C": [
            175590194,
            175585809,
            175713811,
            175588824,
            175588091,
            175585251,
            175586131,
            175579401,
            175581660,
            175576056,
            175582459,
            175579198,
            175578713,
            175576074,
            175578615,
            175581737,
            175586416,
            175584583,
            175585714,
            175593866
        ],
        "B": [
            175579146,
            175570687,
            175567044,
            175573608,
            175578477,
            175570022,
            175570101,
            175572940,
            175567692,
            175571900,
            175569281,
            175569338,
            175568386,
            175570488,
            175571800,
            175575494,
            175567609,
            175569238,
            175585403
        ],
        "A": [
            175563566,
            175564993,
            175563738,
            175564174,
            175564333,
            175564490,
            175563949,
            175567859,
            175563695,
            175565037,
            175565795,
            175565035,
            175564013,
            175564907,
            175683101,
            175567126,
            175709307,
            175566606,
            175563970,
            175564612,
            175568510
        ]
    },
    "name": "B. Funny Permutation",
    "statement": "A sequence of n numbers is called if it contains all numbers from 1 to n\r\nexactly once. For example, the sequences [3, 1, 4, 2], [1] and [2,1] are\r\npermutations, but [1,2,1], [0,1] and [1,3,4] are not.For a given number\r\nn you need to make a permutation p such that two requirements are\r\nsatisfied at the same time: For each element p_i, at least one of its\r\nneighbors has a value that differs from the value of p_i by one. That\r\nis, for each element p_i (1\r\nle i\r\nle n), at least one of its neighboring elements (standing to the left or\r\nright of p_i) must be p_i + 1, or p_i - 1. the permutation must have no\r\nfixed points. That is, for every i (1\r\nle i\r\nle n), p_i\r\nneq i must be satisfied. Let\u2019s call the permutation that satisfies these\r\nrequirements .For example, let n = 4. Then [4, 3, 1, 2] is a\r\npermutation, since: to the right of p_1=4 is p_2=p_1-1=4-1=3; to the\r\nleft of p_2=3 is p_1=p_2+1=3+1=4; to the right of p_3=1 is\r\np_4=p_3+1=1+1=2; to the left of p_4=2 is p_3=p_4-1=2-1=1. for all i is\r\np_i\r\nne i. For a given positive integer n, output permutation of length n, or\r\noutput if permutation of length n does not exist.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  if (n == 3) { printf(\"-1\\n\"); return; }\n\n  vector<int> a;\n  if (n % 2 == 0) {\n    for (int i = 1; i <= n; i++) {\n      a.push_back(n - i + 1);\n    }\n  } else {\n    a.push_back(n);\n    a.push_back(n-1);\n    for (int i = 1; i <= n-2; i++)\n      a.push_back(i);\n  }\n\n  for (int i = 1; i <= n; i++) {\n    int x = a[i-1];\n    printf(i > 1 ? \" %d\" : \"%d\", x);\n    if (x == i) printf(\"*\");\n  }\n\n  printf(\"\\n\");\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV3\\B. Funny Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/107908",
    "editorial": "We cannot make a funny permutation only when , because one of the\r\nneighboring elements of must be equal to . Any permutation made in this\r\nway will not satisfy the conditions: The permutation [] will have a\r\nfixed point . The permutation [] will have a fixed point . The\r\npermutation [] will not have a neighbor equal to for . For the remaining\r\nvalues of , make the following observations: For , the only funny\r\npermutation is []. When , permutations of the form [] will always be\r\nfunny because all elements will have a neighbor equal to or , and the\r\npermutation will have no fixed points (, , and for will always be true\r\n).\r\n"
}