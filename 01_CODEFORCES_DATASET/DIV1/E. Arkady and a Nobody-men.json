{
    "link": "https://codeforces.com//contest/860/problem/E",
    "problemId": "122868",
    "problem_idx": "E",
    "shortId": "860E",
    "contest_number": "860",
    "problem_submissions": {
        "E": [
            30442338,
            30439610,
            30443019,
            30443046,
            30440508,
            30432483,
            30439294,
            30445411,
            30436063,
            30437142,
            30437221,
            30481068,
            30480696,
            30454225,
            30453851,
            30453830,
            30453714,
            30453688,
            30451950,
            30438289,
            30430653,
            30450525
        ],
        "C": [
            30436281,
            30442840,
            30434064,
            30433549,
            30444395,
            30448672,
            30433775,
            30432045,
            30440377,
            30451948,
            30455922,
            30438248,
            30440061,
            30440352,
            30434684,
            30440440,
            30440439,
            30441823
        ],
        "D": [
            30433124,
            30431343,
            30438212,
            30436898,
            30431927,
            30428404,
            30445018,
            30435042,
            30427155,
            30430494,
            30439252,
            30433856,
            31966531,
            30430878,
            30431992,
            30442376,
            30442582,
            30437824,
            30433265,
            30433563,
            30431407
        ],
        "B": [
            30425955,
            30423718,
            30424479,
            30425464,
            30424782,
            30426033,
            30423375,
            30424915,
            30427560,
            30426303,
            30423664,
            30424888,
            30426149,
            30428815,
            30436103,
            30426185,
            30427070,
            30426587,
            30424713
        ],
        "A": [
            30423599,
            30422216,
            30422379,
            30422507,
            30422342,
            30423247,
            30422321,
            30422663,
            30422437,
            30424719,
            30423379,
            30422275,
            30422538,
            30422660,
            30423270,
            30433600,
            30422460,
            30423290,
            30423757,
            30422708
        ]
    },
    "name": "E. Arkady and a Nobody-men",
    "statement": "Arkady words in a large company. There are employees working in a system\r\nof a strict hierarchy. Namely, each employee, with an exception of the\r\nCEO, has exactly one immediate manager. The CEO is a manager (through a\r\nchain of immediate managers) of all employees.Each employee has an\r\ninteger rank. The CEO has rank equal to , each other employee has rank\r\nequal to the rank of his immediate manager plus .Arkady has a good post\r\nin the company, however, he feels that he is nobody in the company\u2019s\r\nstructure, and there are a lot of people who can replace him. He\r\nintroduced the value of . Consider an employee and an employee , the\r\nlatter being manager of (not necessarily immediate). Then the\r\nreplaceability of with respect to is the number of subordinates (not\r\nnecessarily immediate) of the manager , whose rank is not greater than\r\nthe rank of . Apart from replaceability, Arkady introduced the value of\r\n. The negligibility of employee equals the sum of his replaceabilities\r\nwith respect to all his managers, i.e. , where the sum is taken over all\r\nhis managers .Arkady is interested not only in negligibility of himself,\r\nbut also in negligibility of all employees in the company. Find the\r\nnegligibility of each employee for Arkady.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint P[20][505050],D[505050];\nll ret[505050];\nvector<int> E[505050];\n\nvector<int> ev[505050];\n\nint lca(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn (aa==bb)?aa:P[0][aa];               // vertex\n}\n\nvoid dfs(int cur,int dep) {\n\tD[cur]=dep;\n\tev[D[cur]].push_back(cur);\n\tFORR(e,E[cur]) dfs(e,dep+1);\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tscanf(\"%d\",&N);\n\t\n\tint root=-1;\n\tFOR(i,N) {\n\t\tscanf(\"%d\",&P[0][i+1]);\n\t\tif(P[0][i+1]==0) root=i+1, P[0][i+1]=root;\n\t\telse E[P[0][i+1]].push_back(i+1);\n\t}\n\t\n\tdfs(root,0);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\t\n\tfor(i=1;i<=N;i++) if(ev[i].size()) {\n\t\tFORR(e,ev[i]) ret[e]=ret[P[0][e]]+D[e];\n\t\tFOR(j,2) {\n\t\t\tvector<vector<int>> V;\n\t\t\tll sum=0;\n\t\t\tFOR(x,ev[i].size()) {\n\t\t\t\tint e=ev[i][x];\n\t\t\t\tif(x==0) {\n\t\t\t\t\tV.push_back({e,-1,0});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twhile(1) {\n\t\t\t\t\t\tint cand=V.back()[0];\n\t\t\t\t\t\tint lc=lca(cand,e);\n\t\t\t\t\t\tif(V.back()[1]<D[lc]) {\n\t\t\t\t\t\t\tV.push_back({e,D[lc],x});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum-=1LL*(V[V.size()-1][2]-V[V.size()-2][2])*(V[V.size()-1][1]+1);\n\t\t\t\t\t\tV.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tsum+=1LL*(V[V.size()-1][2]-V[V.size()-2][2])*(V[V.size()-1][1]+1);\n\t\t\t\t\tret[e]+=sum;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treverse(ALL(ev[i]));\n\t\t}\n\t}\n\t\n\tFOR(i,N) printf(\"%\" PRIu64 \"%c\", ret[i+1],(i==N-1)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Arkady and a Nobody-men.json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "First of all, , where is the sum of (number of descendants of the rank\r\ndepth[v]) for all predecessors of . All we need is to compute now. Let\u00e2\u0080\u0099s\r\nmake a dfs in the graph. Let the dfs(v) return a vector such that is the\r\nfollowing tuple: (number of vertices on depth in subtree of , some\r\nvertex with depth in the subtree of , the if we consider only\r\npredecessors in the subtree of ). Also let\u00e2\u0080\u0099s build some structure so\r\nthat we can easily restore answers in this subtree if we know the final\r\nvalue of . We will see what is this structure later. To compute we need\r\nto be able to merge two s of its sons. Let\u00e2\u0080\u0099s say we merge tuple with .\r\nThen all we need to do is: , , return as the result. However, we must\r\nalso be able to restore after the dfs is complete (remind the unknown\r\nstructure). So after performing let\u00e2\u0080\u0099s add an edge to a new graph with\r\nweight . Note that the difference between these values will be the same\r\nall the time after the tuples are merged, so using this edge we will be\r\nable to restore the answer . After the dfs is done, run another dfs on\r\nthe new graph to restore the values and then . To perform the second\r\nstep fast, we need to note that we can always merge smaller s into\r\nlarger, and move them in into parents. Since each tuple is merged into a\r\nlarger vector only once, this solution works in total in .\r\n"
}