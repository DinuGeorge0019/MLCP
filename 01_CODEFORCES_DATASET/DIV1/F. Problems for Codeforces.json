{
    "link": "https://codeforces.com//contest/1580/problem/F",
    "problemId": "1124759",
    "problem_idx": "F",
    "shortId": "1580F",
    "contest_number": "1580",
    "problem_submissions": {
        "B": [
            130368546,
            130343157,
            130344628,
            130363173,
            130349401,
            130355243,
            130367468,
            130348461,
            130361528,
            130349821,
            130353521,
            130358877,
            130349956,
            130352430,
            130351206,
            130360978,
            130375295,
            130370586,
            130394237,
            130361703
        ],
        "F": [
            130365168,
            131645253,
            131635746,
            130511674,
            130411823,
            130434722,
            130858441,
            130432452
        ],
        "D": [
            130353694,
            130351879,
            130354504,
            130348465,
            130361242,
            130356218,
            130400584,
            130360744,
            130356043,
            130858484,
            130362840,
            130366863,
            130368106,
            130352099,
            130366694,
            130365720,
            130365962,
            130368047,
            130360831,
            130353993,
            130370294
        ],
        "C": [
            130347074,
            130348749,
            130348466,
            130344529,
            130355623,
            130348660,
            130349751,
            130374035,
            130353918,
            130350011,
            130356865,
            130358625,
            130355024,
            130348708,
            130393503,
            130361958,
            130360836,
            130360159,
            130358052,
            130357895,
            130349443,
            130349567
        ],
        "A": [
            130339939,
            130502005,
            130339930,
            130348093,
            130341897,
            130340621,
            130340244,
            130356449,
            130343417,
            130342143,
            130341207,
            130340481,
            130341559,
            130340530,
            130339691,
            130340905,
            130340089,
            130340579,
            130352882
        ],
        "E": [
            130370647,
            130421659
        ]
    },
    "name": "F. Problems for Codeforces",
    "statement": "XYMXYM and CQXYM will prepare n problems for Codeforces. The difficulty\r\nof the problem i will be an integer a_i, where a_i\r\ngeq 0. The difficulty of the problems must satisfy a_i+a_{i+1}<m (1\r\nleq i < n), and a_1+a_n<m, where m is a fixed integer. XYMXYM wants to\r\nknow how many plans of the difficulty of the problems there are modulo\r\n998\r\n,244\r\n,353.Two plans of difficulty a and b are different only if there is an\r\ninteger i (1\r\nleq i\r\nleq n) satisfying a_i\r\nneq b_i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int RT = 3;\n\nconst int MAXT = 19;\nconst int MAXL = 550000;\n\nint fac[MAXL + 5], ifac[MAXL + 5], inv[MAXL + 5];\nint rg[MAXT + 5];\n\nint ub2(int n)\n{\n\tint ret = 0;\n\twhile((1 << ret) < n) ret ++;\n\treturn ret;\n}\n\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1LL * ret * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint cr[MAXL + 5];\nvoid dft(int arr[], int siz, int dir)\n{\n\tif(dir == -1) reverse(arr + 1, arr + (1 << siz));\n\tint cur = 0;\n\tfor(int i = 0; i < (1 << siz); i ++) {\n\t\tif(cur < i) swap(arr[cur], arr[i]);\n\t\tfor(int j = siz - 1; j >= 0; j --) {\n\t\t\tcur ^= 1 << j;\n\t\t\tif(cur >> j & 1) break;\n\t\t}\n\t}\n\trep1(d, siz) {\n\t\tint pr = rg[d];\n\t\tcr[0] = 1;\n\t\tfor(int i = 1; i < (1 << (d - 1)); i ++) cr[i] = 1LL * cr[i - 1] * pr % MOD;\n\t\tfor(int i = 0; i < (1 << siz); i += 1 << d) rep(j, 1 << (d - 1)) {\n\t\t\tint ev = arr[i + j], od = 1LL * arr[i + j + (1 << (d - 1))] * cr[j] % MOD;\n\t\t\tarr[i + j] = ev + od - (ev + od >= MOD ? MOD : 0);\n\t\t\tarr[i + j + (1 << (d - 1))] = ev - od + (ev - od < 0 ? MOD : 0);\n\t\t}\n\t}\n\tif(dir == -1) {\n\t\tint invn = inv[1 << siz];\n\t\trep(i, 1 << siz) arr[i] = 1LL * arr[i] * invn % MOD;\n\t}\n}\n\nint tmp0[MAXL + 5], tmp1[MAXL + 5];\nvoid poly_mul(int A[], int B[], int ret[], int siz)\n{\n\trep(i, 1 << (siz + 1)) tmp0[i] = i >> siz ? 0 : A[i];\n\trep(i, 1 << (siz + 1)) tmp1[i] = i >> siz ? 0 : B[i];\n\tdft(tmp0, siz + 1, 1);\n\tdft(tmp1, siz + 1, 1);\n\trep(i, 1 << (siz + 1)) ret[i] = 1LL * tmp0[i] * tmp1[i] % MOD;\n\tdft(ret, siz + 1, -1);\n}\n\nvoid poly_inv(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) tmp1[i] = i == 0 ? power(A[0], MOD - 2) : 0;\n\trep1(i, siz) {\n\t\trep(j, 1 << (i + 1)) tmp0[j] = j >> i ? 0 : A[j];\n\t\trep(j, 1 << (i + 1)) tmp1[j] = j >> (i - 1) ? 0 : tmp1[j];\n\t\tdft(tmp0, i + 1, 1);\n\t\tdft(tmp1, i + 1, 1);\n\t\trep(j, 1 << (i + 1)) tmp1[j] = (2 + 1LL * (MOD - tmp0[j]) * tmp1[j] % MOD) * tmp1[j] % MOD;\n\t\tdft(tmp1, i + 1, -1);\n\t}\n\trep(i, 1 << siz) ret[i] = tmp1[i];\n}\n\nint tmp2[MAXL + 5];\nvoid poly_ln(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) if(i > 0) tmp2[i - 1] = 1LL * A[i] * i % MOD;\n\tpoly_inv(A, ret, siz);\n\tpoly_mul(ret, tmp2, ret, siz);\n\tfor(int i = (1 << siz) - 1; i >= 0; i --) ret[i] = i == 0 ? 0 : 1LL * inv[i] * ret[i - 1] % MOD;\n}\n\nint tmp3[MAXL + 5], tmp4[MAXL + 5];\nvoid poly_exp(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) tmp3[i] = i == 0;\n\trep1(i, siz) {\n\t\tpoly_ln(tmp3, tmp4, i);\n\t\trep(j, 1 << i) tmp4[j] = ((j == 0) + A[j] - tmp4[j] + MOD) % MOD;\n\t\tpoly_mul(tmp3, tmp4, tmp3, i);\n\t}\n\trep(i, 1 << siz) ret[i] = tmp3[i];\n}\n\nvoid init()\n{\n\trg[0] = 1;\n\trep1(i, MAXT) rg[i] = power(RT, (MOD - 1) >> i);\n\tfac[0] = 1;\n\trep1(i, MAXL) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\tifac[MAXL] = power(fac[MAXL], MOD - 2);\n\tfor(int i = MAXL; i >= 1; i --) ifac[i - 1] = 1LL * ifac[i] * i % MOD;\n\trep1(i, MAXL) inv[i] = 1LL * ifac[i] * fac[i - 1] % MOD;\n}\n\nint n, m, dat[300005], A[300005], B[300005], C[300005], D[300005], E[300005], F[300005], G[300005];\n\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\", &n, &m);\n\tint cur = 1;\n\trep1(i, n) {\n\t\tint maxt = (m + i) / 2;\n\t\tif(maxt == (m + i - 1) / 2) cur = 1LL * cur * (maxt - i + 1) % MOD;\n\t\telse cur = 1LL * cur * maxt % MOD;\n\t\tcur = 1LL * cur * inv[i] % MOD;\n\t\tdat[i] = (cur + MOD) % MOD;\n\t}\n\t\n\trep1(i, n) if(i % 4 == 0) A[i] = (MOD - dat[i]) % MOD;\n\telse if(i % 4 == 1) B[i] = dat[i];\n\telse if(i % 4 == 2) A[i] = dat[i];\n\telse B[i] = (MOD - dat[i]) % MOD;\n\t\n\tA[0] = 1;\n\trep1(i, n) A[i] = (MOD - A[i]) % MOD;\n\tpoly_inv(A, C, 16);\n\tpoly_mul(B, C, D, 16);\n\tD[0] = 1;\n\trep1(i, n) D[i] = (MOD - D[i]) % MOD;\n\tpoly_inv(D, E, 16);\n\tpoly_ln(C, F, 16);\n\tpoly_ln(E, G, 16);\n\tint ans = 1LL * n * (F[n] + G[n]) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "fft",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Problems for Codeforces.json",
    "editorial_link": "https://codeforces.com//blog/entry/95477",
    "editorial": "If two numbers satisfying\n, there can only be one number not less than . Consider that cut the\ncycle to a sequence at the first position satisfying . When we minus all\nthe numbers that are not less than by , we can get a sub-problem.\nHowever, If is an even number, we may not find such a position , but we\ncan still get a sub-problem easily. For this problem on a sequence, we\ncan divide the sequence into many segments, and each of them can not be\ncut by us anymore. There may be only segment, and the first, last\nelement of the segment are not less than . There may be many segments,\nthe length of the first one and last one are even, and the rest of them\nare odd. To solve the problem, we define the GF A,B. A is the GF of the\nlength of the segments are odd situation, and B is the even one. If is\nodd, the segment with only a number exists, and the GF of number of the\nsequence should be: Otherwise, it is: . To solve this problem, use NTT\nand polynomial inversion algorithm is just ok. Each time we transform a\nproblem with limit to , so the time complexity is . solution\n",
    "hint": []
}