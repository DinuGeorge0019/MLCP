{
    "link": "https://codeforces.com//contest/497/problem/C",
    "problemId": "19573",
    "problem_idx": "C",
    "shortId": "497C",
    "contest_number": "497",
    "problem_submissions": {
        "E": [
            9174487,
            9174196,
            9175010,
            9199333,
            9175252,
            9176527,
            9176653,
            9180194
        ],
        "D": [
            9170679,
            9173274,
            9174804,
            9174751,
            9171031,
            9176067,
            9175754
        ],
        "C": [
            9168733,
            9168537,
            9168027,
            43565108,
            9170031,
            9168979,
            9168260,
            9169684,
            9168763,
            9174362,
            9172330,
            9171998,
            9173920,
            9168319,
            9168825,
            9168629,
            43565576,
            9168203
        ],
        "B": [
            9166459,
            9166265,
            9166436,
            9199442,
            9167203,
            9166878,
            9166797,
            9166926,
            9170793,
            9172501,
            9170015,
            9168743,
            9169417,
            9166154,
            9166746,
            9166737,
            9165998
        ],
        "A": [
            9164122,
            9164273,
            9164359,
            9164060,
            9163922,
            9164065,
            9163958,
            9164600,
            9164390,
            9164526,
            9164902,
            9167522,
            9163923,
            9163921,
            9164484,
            9163952
        ]
    },
    "name": "C. Distributing Parts ",
    "statement": "You are an assistant director in a new musical play. The play consists\r\nof musical parts, each part must be performed by exactly one actor.\r\nAfter the casting the director chose actors who can take part in the\r\nplay. Your task is to assign the parts to actors. However, there are\r\nseveral limitations.First, each actor has a certain voice range and\r\nthere are some parts that he cannot sing. Formally, there are two\r\nintegers for each actor, and () the pitch of the lowest and the highest\r\nnote that the actor can sing. There also are two integers for each part\r\nand () the pitch of the lowest and the highest notes that are present in\r\nthe part. The -th actor can perform the -th part if and only if , i.e.\r\neach note of the part is in the actor\u2019s voice range.According to the\r\ncontract, the -th actor can perform at most parts. Besides, you are\r\nallowed not to give any part to some actors (then they take part in\r\ncrowd scenes).The rehearsal starts in two hours and you need to do the\r\nassignment quickly!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\nconst int M = 100000;\n\nstruct Input {\n\tint n;\n\tint a[N], b[N];\n\tint m;\n\tint c[M], d[M], k[M];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\t}\n\t\tcin >> m;\n\t\tforn (i, m) {\n\t\t\tscanf(\"%d%d%d\", &c[i], &d[i], &k[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tbool res;\n\tint ans[N];\n\t\n\tvoid write () {\n\t\tif (!res) {\n\t\t\tputs(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tputs(\"YES\");\n\t\tforn (i, n) {\n\t\t\tif (i) {\n\t\t\t\tprintf(\" \");\n\t\t\t}\n\t\t\tprintf(\"%d\", ans[i] + 1);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tvoid solve () {\n\t\tve<pa<int, pii> > q;\n\t\tforn (i, n) {\n\t\t\tq.pb(mp(b[i], mp(0, i)));\n\t\t}\n\t\tforn (i, m) {\n\t\t\tq.pb(mp(d[i], mp(1, i)));\n\t\t}\n\t\tsort(all(q));\n\t\t\n\t\tset<pii> s;\n\t\tforn (i, sz(q)) {\n\t\t\tif (q[i].sc.fs == 0) {\n\t\t\t\ts.insert(mp(-a[q[i].sc.sc], q[i].sc.sc));\n\t\t\t} else {\n\t\t\t\tforn (j, k[q[i].sc.sc]) {\n\t\t\t\t\tauto it = s.upper_bound(mp(-c[q[i].sc.sc], N));\n\t\t\t\t\tif (it == s.begin()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t--it;\n\t\t\t\t\tans[it->sc] = q[i].sc.sc;\n\t\t\t\t\ts.erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = s.empty();\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Distributing Parts .json",
    "editorial_link": "https://codeforces.com/blog/entry/15208",
    "editorial": "Sort all the parts and actors altogether by increasing lower bounds (if\r\nequal, actors precede parts); process all the enitities in this order.\r\nWe maintain a set of actors which have already occured in the order; if\r\nwe meet an entry for an actor, add it to the set. If we currently\r\nprocess a part, we have to assign it to an actor; from the current set\r\nof actors we have to choose one such that his (the constraint is\r\nprovided by the fact that the -th actor has occured earlier than the -th\r\npart); if there are no such actors in the set, no answer can be\r\nobtained; if there are several actors satisftying this requirement, we\r\nshould choose one with minimal (intuitively, he will be less useful in\r\nthe future). Assign the chosen actor with the current part and decrement\r\nhis ; if is now zero, the actor can not be used anymore, thus we remove\r\nhim from the set. To fit the limits we should implement the set of\r\ncurrent actors as some efficient data structure (e.g., an std::set or a\r\ntreap). The resulting complexity is . Challenge: suppose that now there\r\nare copies of the -th part (), and each copy must be separately assigned\r\nwith an actor in a valid way. Can you solve this new problem with all\r\nthe old constraints (as the actual distribution now has too much\r\nentries, it is sufficient to check whether an answer exists)?\r\n"
}