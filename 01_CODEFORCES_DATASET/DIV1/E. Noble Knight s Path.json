{
    "link": "https://codeforces.com//contest/226/problem/E",
    "problemId": "1854",
    "problem_idx": "E",
    "shortId": "226E",
    "contest_number": "226",
    "problem_submissions": {
        "D": [
            2242483,
            2240843,
            2242697,
            2239811,
            2241181,
            2240471,
            2243151,
            2239681,
            2243648,
            2243129,
            2242567,
            2244564,
            2243396,
            2244004,
            2242755,
            2240654,
            2242232,
            2243688
        ],
        "C": [
            2240518,
            2242095,
            2241935,
            2242212,
            2245368,
            2243264,
            2242355,
            2244421,
            2245094,
            2240401,
            2245716,
            2240548,
            2245297,
            2273600,
            2246168,
            2251858
        ],
        "B": [
            2238162,
            2238317,
            2238835,
            2237653,
            2238869,
            2244282,
            2240573,
            2241479,
            2239690,
            2239960,
            2240247,
            2244047,
            2239779,
            2243326,
            2239668,
            2238560,
            2240587,
            2244817
        ],
        "A": [
            2237392,
            2237493,
            2237370,
            2238271,
            2237948,
            2237516,
            2239157,
            2243302,
            2237640,
            2237633,
            2237332,
            2273554,
            2237740,
            2237340,
            2237663,
            2237380,
            2241341,
            2242419
        ],
        "E": [
            3877418,
            2263890,
            2247800
        ]
    },
    "name": "E. Noble Knight s Path",
    "statement": "In Berland each feudal owns exactly one castle and each castle belongs\r\nto exactly one feudal.Each feudal, except one (the King) is subordinate\r\nto another feudal. A feudal can have any number of vassals\r\n(subordinates).Some castles are connected by roads, it is allowed to\r\nmove along the roads in both ways. Two castles have a road between them\r\nif and only if the owner of one of these castles is a direct subordinate\r\nto the other owner.Each year exactly one of these two events may happen\r\nin Berland. The barbarians attacked castle . The interesting fact is,\r\nthe barbarians never attacked the same castle twice throughout the whole\r\nBerlandian history. A noble knight sets off on a journey from castle to\r\ncastle (provided that on his path he encounters each castle not more\r\nthan once). Let\u2019s consider the second event in detail. As the journey\r\nfrom to is not short, then the knight might want to stop at a castle he\r\nencounters on his way to have some rest. However, he can\u2019t stop at just\r\nany castle: his nobility doesn\u2019t let him stay in the castle that has\r\nbeen desecrated by the enemy\u2019s stench. A castle is desecrated if and\r\nonly if it has been attacked after the year of . So, the knight chooses\r\nthe -th castle he encounters, starting from (castles and aren\u2019t taken\r\ninto consideration), that hasn\u2019t been attacked in years from till\r\ncurrent year.The knights don\u2019t remember which castles were attacked on\r\nwhat years, so he asked the court scholar, aka you to help them. You\u2019ve\r\ngot a sequence of events in the Berland history. Tell each knight, in\r\nwhat city he should stop or else deliver the sad news that the path from\r\ncity to city has less than cities that meet his requirements, so the\r\nknight won\u2019t be able to rest.\r\n",
    "solutions": [
        "#include <map>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXM = 17;\nconst int MAXN = 1 << MAXM;\n\nstruct TreeDecomposition {\n  vector<int> e[MAXN], c[MAXN];\n  int s[MAXN];    // subtree size\n  int p[MAXN];    // parent id\n  int r[MAXN];    // chain root id\n  int t[MAXN];    // timestamp, index used in segtree\n  int ts;\n\n  void dfs_(int v, int f) {\n    p[v] = f;\n    s[v] = 1;\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f) {\n        dfs_(w, v);\n        s[v] += s[w];\n      }\n    }\n  }\n\n  void decomp_(int v, int f, int k) {\n    t[v] = ts++;\n    c[k].push_back(v);\n    r[v] = k;\n\n    int x = 0, y = -1;\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f) {\n        if (s[w] > x) {\n          x = s[w];\n          y = w;\n        }\n      }\n    }\n    if (y != -1) {\n      decomp_(y, v, k);\n    }\n\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f && w != y) {\n        decomp_(w, v, w);\n      }\n    }\n  }\n\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      e[i].clear();\n    }\n  }\n\n  void add(int a, int b) {\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  void build() {  // !!\n    ts = 0;\n    dfs_(0, 0);\n    decomp_(0, 0, 0);\n  }\n} hld;\n\nstruct LCA {\n  vector<int> e[MAXN];\n  int d[MAXN], p[MAXN][MAXM];\n\n  void dfs_(int v, int f) {\n    p[v][0] = f;\n    for (int i = 1; i < MAXM; ++i) {\n      p[v][i] = p[p[v][i - 1]][i - 1];\n    }\n    for (int i = 0; i < (int)e[v].size(); ++i) {\n      int w = e[v][i];\n      if (w != f) {\n        d[w] = d[v] + 1;\n        dfs_(w, v);\n      }\n    }\n  }\n\n  int up_(int v, int m) {\n    for (int i = 0; i < MAXM; ++i) {\n      if (m & (1 << i)) {\n        v = p[v][i];\n      }\n    }\n    return v;\n  }\n\n  int lca(int a, int b) {\n    if (d[a] > d[b]) {\n      swap(a, b);\n    }\n    b = up_(b, d[b] - d[a]);\n    if (a == b) {\n      return a;\n    } else {\n      for (int i = MAXM - 1; i >= 0; --i) {\n        if (p[a][i] != p[b][i]) {\n          a = p[a][i];\n          b = p[b][i];\n        }\n      }\n      return p[a][0];\n    }\n  }\n\n  void init(int n) {\n    for (int i = 0; i < n; ++i) {\n      e[i].clear();\n    }\n  }\n\n  void add(int a, int b) {\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  void build() {\n    d[0] = 0;\n    dfs_(0, 0);\n  }\n} lca;\n\nstruct SegTree {\n  int n;\n  map<int, int> mp[MAXN + MAXN];\n\n  void init(int m) {\n    n = 1;\n    while (n < m) {\n      n <<= 1;\n    }\n    fill(mp + 1, mp + n + n, map<int, int>());\n  }\n\n  void del(int i, int e) {\n    for (i += n; i > 0; i >>= 1) {\n      mp[i][e];\n    }\n  }\n\n  void build() {\n    for (int i = 1; i < n + n; ++i) {\n      int k = 0;\n      for (auto& j: mp[i]) {\n        j.second = k++;\n      }\n      mp[i][MAXN] = k;  // guard\n    }\n  }\n\n  // [x, y)\n  int bad(int p, int x, int y) const {\n    return mp[p].lower_bound(y)->second - mp[p].lower_bound(x)->second;\n  }\n\n  static int L(int i) { return i << 1; }\n  static int R(int i) { return L(i) ^ 1; }\n\n  int good(int p, int pl, int pr, int l, int r, int x, int y) {\n    l = max(l, pl);\n    r = min(r, pr);\n    if (l >= r) {\n      return 0;\n    } else if (pl == l && pr == r) {\n      return pr - pl - bad(p, x, y);\n    } else {\n      int pm = (pl + pr) / 2;\n      return good(L(p), pl, pm, l, r, x, y) + good(R(p), pm, pr, l, r, x, y);\n    }\n  }\n\n\n  int index(int p, int pl, int pr, int l, int r, int x, int y, int& z) {\n    l = max(l, pl);\n    r = min(r, pr);\n    if (l >= r) {\n      return -1;\n    }\n    if (pl == l && pr == r) {\n      int g = pr - pl - bad(p, x, y);\n      if (z >= g) {\n        z -= g;\n        return -1;\n      }\n    }\n    if (pr - pl == 1) {\n      return pl;\n    }\n    int pm = (pl + pr) / 2;\n    int ret = index(L(p), pl, pm, l, r, x, y, z);\n    if (ret != -1) {\n      return ret;\n    } else {\n      return index(R(p), pm, pr, l, r, x, y, z);\n    }\n  }\n} st;\n\nvector<pair<int, int> > keypath(int a, int b) {\n  int c = lca.lca(a, b);\n  vector<pair<int, int> > pa, pb;\n\n  while (hld.r[a] != hld.r[c]) {\n    pa.push_back({a, hld.r[a]});\n    a = hld.p[hld.r[a]];\n  }\n  while (hld.r[b] != hld.r[c]) {\n    pb.push_back({hld.r[b], b});\n    b = hld.p[hld.r[b]];\n  }\n  pa.push_back({a, b});\n  pa.insert(pa.end(), pb.rbegin(), pb.rend());\n\n  return pa;\n}\n\nstruct Query {\n  int a, b, x, y, k, ans;\n} q[MAXN];\n\nstatic int invt[MAXN];\n\nint main() {\n  int n, m, t;\n\n  scanf(\"%d\", &n);\n  hld.init(n);\n  lca.init(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &t);\n    --t;\n    if (t >= 0) {\n      hld.add(i, t);\n      lca.add(i, t);\n    }\n  }\n  hld.build();\n  lca.build();\n  for (int i = 0; i < n; ++i) {\n    invt[hld.t[i]] = i;\n  }\n#ifdef __WATASHI__\n  for (int i = 0; i < n; ++i) {\n    if (hld.c[i].empty()) {\n      continue;\n    }\n    for (int j: hld.c[i]) {\n      printf(\" %d\", j);\n    }\n    puts(\"\");\n  }\n#endif\n\n  scanf(\"%d\", &m);\n  st.init(n);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d%d\", &t, &q[i].a);\n    --q[i].a;\n    if (t == 1) {\n      st.del(hld.t[q[i].a], i);\n      q[i].x = -1;\n    } else {\n      scanf(\"%d%d%d\", &q[i].b, &q[i].k, &q[i].x);\n      --q[i].b;\n      --q[i].k;\n      q[i].y = i;\n    }\n  }\n  st.build();\n\n  for (int i = 0; i < m; ++i) {\n    if (q[i].x == -1) {\n      continue;\n    } else {\n      q[i].ans = -1;\n      q[i].k += st.good(1, 0, st.n, hld.t[q[i].a], hld.t[q[i].a] + 1, q[i].x, q[i].y);\n      // q[i].k += st.good(1, 0, st.n, hld.t[q[i].b], hld.t[q[i].b] + 1, q[i].x, q[i].y);\n      for (auto j: keypath(q[i].a, q[i].b)) {\n        int a = hld.t[j.first], b = hld.t[j.second], good;\n        if (a <= b) {\n          good = st.good(1, 0, st.n, a, b + 1, q[i].x, q[i].y);\n        } else {\n          good = st.good(1, 0, st.n, b, a + 1, q[i].x, q[i].y);\n        }\n        // printf(\"[%d] %d -> %d (%d)\\n\", i, j.first + 1, j.second + 1, good);\n        // printf(\"a = %d, b = %d, k = %d\\n\", a, b, q[i].k);\n        if (q[i].k >= good) {\n          q[i].k -= good;\n        } else if (a <= b) {\n          q[i].ans = st.index(1, 0, st.n, a, b + 1, q[i].x, q[i].y, q[i].k);\n          break;\n        } else {\n          q[i].k = good - 1 - q[i].k;\n          q[i].ans = st.index(1, 0, st.n, b, a + 1, q[i].x, q[i].y, q[i].k);\n          break;\n        }\n      }\n      if (q[i].ans != -1) {\n        q[i].ans = invt[q[i].ans];\n        if (q[i].ans == q[i].b) {\n          q[i].ans = -1;\n        } else {\n          ++q[i].ans;\n        }\n      }\n      printf(\"%d\\n\", q[i].ans);\n    }\n  }\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Noble Knight s Path.json",
    "editorial_link": "https://codeforces.com/blog/entry/5378",
    "editorial": "It's easy to guess that castles form a tree. Let's build heavy-light decomposition over it. Moreover, let's build persistent segment tree (with sum as the function) over each path. Tree's vertex will contain 0, if castle wasn't attacked by barbarians, and 1 otherwise.\n\nEach knight's path should be divided into not more than two subpaths each of them lays on the path from one of the route's end to tree's root (just use lca in order to do it). Now let's solve the problem for each of the subpaths separately. We should sequentially process paths from heavy-light decomposition and single vertices, which lay on subpath. We are going to count the amount of vertices, which was not visited since year y?+?1 up to the current year, i.e. (in the case of a path of the decomposition) such vertices, that the difference between values in the current version of persistent segment tree and in the version corresponding to year y (use binary search to find required version in the list of versions) is equal to zero (in case with single vertice it's enough to remember time when vertice was visited). As soon as the amount of appropriate vertices become not less than k, we should simultaneously walk down in two tree's versions in order to get the answer.\n\nIf the kth vertex isn't found on the first subpath, you should pay attention on the fact, that as we always go from down to up, we should accurately recalculate required vertex's number, in order to know it's position in the second subpath from down to up.\n\nComplexity: O(m\u00b7log2 n) \u0097 in each query of the first type it can be necessary to update some segment tree, this action takes O(log n) operations; in each query of the second type there are O(log n) decomposition's paths, each of them is processed in O(log n) (firstly, binary search through versions' list, then query to the tree/walking down)."
}