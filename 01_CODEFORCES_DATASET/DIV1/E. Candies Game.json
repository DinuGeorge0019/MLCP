{
    "link": "https://codeforces.com//contest/341/problem/E",
    "problemId": "3426",
    "problem_idx": "E",
    "shortId": "341E",
    "contest_number": "341",
    "problem_submissions": {
        "D": [
            4376750,
            4378780,
            4376395,
            4376720,
            4378230,
            4379371,
            4379846,
            4378978,
            4379778,
            4378578,
            4381466,
            4381249,
            4379639,
            4434623,
            4381692,
            4380681,
            4380927,
            4380941,
            4449185,
            4374777
        ],
        "C": [
            4375168,
            4374068,
            4379294,
            4375659,
            4375652,
            4375871,
            4375036,
            4378006,
            4374746,
            4375347,
            4374858,
            4376054,
            4375611,
            4377642,
            4376535,
            4378502,
            4380054,
            4385371
        ],
        "B": [
            4372755,
            4372469,
            4374229,
            4375035,
            4374390,
            4374268,
            4379570,
            4373332,
            4379590,
            4372609,
            4373078,
            4372906,
            4373853,
            4373520,
            4374372,
            4374299,
            4376277,
            4376672
        ],
        "A": [
            4372149,
            4371769,
            4372926,
            4372916,
            4383777,
            4373604,
            4372813,
            4371963,
            4372756,
            4380996,
            4371671,
            4372384,
            4372154,
            4458518,
            4372373,
            4372183,
            4373535,
            4372955,
            4378126,
            4376128
        ],
        "E": [
            4404432,
            4383929,
            4395989,
            4381763
        ]
    },
    "name": "E. Candies Game",
    "statement": "Iahub is playing an uncommon game. Initially, he has boxes, numbered 1,\r\n2, 3, , . Each box has some number of candies in it, described by a\r\nsequence , , , . The number represents the number of candies in box .\r\nThe goal of the game is to move all candies into two boxes. The rest of\r\nboxes must contain candies. Iahub is allowed to do several (possible\r\nzero) moves. At each move he chooses two different boxes and , such that\r\n. Then, Iahub moves from box to box exactly candies. Obviously, when two\r\nboxes have equal number of candies, box number becomes empty.Your task\r\nis to give him a set of moves such as Iahub to archive the goal of the\r\ngame. If Iahub can’t win the game for the given configuration of boxes,\r\noutput -1. Please note that in case there exist a solution, you don’t\r\nneed to print the solution using minimal number of moves.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) cout << #x << \" = \"; cout << x << endl;\n#define PR(a,n) cout << #a << \" = \"; FOR(_,1,n) cout << a[_] << ' '; cout << endl;\n#define PR0(a,n) cout << #a << \" = \"; REP(_,n) cout << a[_] << ' '; cout << endl;\nusing namespace std;\n\n//Buffer reading\nint INP,AM,REACHEOF;\nconst int BUFSIZE = (1<<12) + 17;\nchar BUF[BUFSIZE+1], *inp=BUF;\n#define GETCHAR(INP) { \\\n    if(!*inp && !REACHEOF) { \\\n        memset(BUF,0,sizeof BUF);\\\n        int inpzzz = fread(BUF,1,BUFSIZE,stdin);\\\n        if (inpzzz != BUFSIZE) REACHEOF = true;\\\n        inp=BUF; \\\n    } \\\n    INP=*inp++; \\\n}\n#define DIG(a) (((a)>='0')&&((a)<='9'))\n#define GN(j) { \\\n    AM=0;\\\n    GETCHAR(INP); while(!DIG(INP) && INP!='-') GETCHAR(INP);\\\n    if (INP=='-') {AM=1;GETCHAR(INP);} \\\n    j=INP-'0'; GETCHAR(INP); \\\n    while(DIG(INP)){j=10*j+(INP-'0');GETCHAR(INP);} \\\n    if (AM) j=-j;\\\n}\n//End of buffer reading\n\nconst int MN = 1011;\nint a[MN], n, x[11];\nvector< pair<int,int> > res;\n\nvoid solve(int x, int y, int z) {\n    if (a[y] < a[x]) swap(x, y);\n    if (a[z] < a[x]) swap(x, z);\n    if (a[z] < a[y]) swap(y, z);\n\n    if (a[x] == 0) return ;\n\n    int mv = a[y] / a[x];\n    REP(bit,30) {\n        if ((1<<bit) > mv) break;\n        if (mv & (1<<bit)) {\n            res.push_back(make_pair(x, y));\n            a[y] -= a[x];\n            a[x] += a[x];\n        }\n        else {\n            res.push_back(make_pair(x, z));\n            a[z] -= a[x];\n            a[x] += a[x];\n        }\n    }\n}\n\nint main() {\n    ios :: sync_with_stdio(false);\n    while (cin >> n) {\n        res.clear();\n        FOR(i,1,n) cin >> a[i];\n\n        int cnt = 0;\n        FOR(i,1,n) if (a[i]) {\n            ++cnt;\n            x[cnt] = i;\n            if (cnt == 3) break;\n        }\n        if (cnt < 2) {\n            puts(\"-1\\n\");\n            continue;\n        }\n        while (cnt == 3) {\n            solve(x[1], x[2], x[3]);\n            cnt = 0;\n            FOR(i,1,n) if (a[i]) {\n                ++cnt;\n                x[cnt] = i;\n                if (cnt == 3) break;\n            }\n        }\n\n        printf(\"%d\\n\", res.size());\n        REP(i,res.size()) printf(\"%d %d\\n\", res[i].first, res[i].second);\n        puts(\"\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Candies Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/8755",
    "editorial": "Key observation Suppose you have 3 boxes containing A, B, C candies (A,\r\nB, C all greater than 0). Then, there will be always possible to empty\r\none of boxes using some moves. Proof We can suppose that A <= B <= C. We\r\nneed some moves such as the minimum from A, B, C will be zero. If we\r\nalways keep the numbers in order A <= B <= C, it s enough some moves\r\nsuch as A = 0. I ll call this notation (A, B, C). How can we prove that\r\nalways exist such moves? We can use reductio ad absurdum to prove it.\r\nLet s suppose, starting from (A, B, C) we can go to a state (A2, B2,\r\nC2). We suppose A2 (A2 > 0) is minimal from every state we can obtain.\r\nSince A2 is minimal number of coins that can be obtained and A2 is not\r\nzero, the statement is equivalent with we can t empty one chest from\r\nconfiguration (A, B, C). Then, we can prove that from (A2, B2, C2) we\r\ncan go to a state (A3, B3, C3), where A3 < A2. Obviously, this\r\ncontradicts our assumption that A2 is minimal of every possible states.\r\nIf A2 would be minimal, then there won t be any series of moves to empty\r\none chest. But A2 isn t minimal, hence there always exist some moves to\r\nempty one chest. Our algorithm so far: void emptyOneBox(int A, int B,\r\nint C) { if A is 0, then exit function. Make some moves such as to find\r\nanother state (A2, B2, C2) with A2 < A. emptyOneBox (A2, B2, C2); } The\r\nonly problem which needs to be proven now is: given a configuration (A,\r\nB, C) with A > 0, can we find another one (A2, B2, C2) such as A2 < A?\r\nThe answer is always yes, below I ll prove why. Firstly, let s imagine\r\nwe want to constantly move candies into a box. It doesnât matter yet\r\nfrom where come the candies, what matters is candies arrive into the\r\nbox. The box has initially X candies. After 1 move, it will have 2 * X\r\ncandies. After 2 moves, it will have 2 * (2 * X) candies = 4 * X\r\ncandies. Generally, after K moves, the box will contain 2^K * X candies.\r\nWe have A < B < C (if 2 numbers are equal, we can make a move and empty\r\n1 box). If we divide B by A, we get from math that B = A * q + r.\r\n(obviously, always r < A). What if we can move exactly A * q candies\r\nfrom B to A? Then, our new state would be (r, B2, C2). We have now a\r\nnumber A2 = r, such as A2 < A. How can we move exactly A * q coins? Let\r\ns write q in base 2. Making that, q will be written as a sum of powers\r\nof 2. Suppose lim is the maximum number such as 2 ^ lim <= q. We get\r\nevery number k from 0 to lim. For each k, I push into the first box (the\r\nbox containing initially A candies) a certain number of candies. As\r\nproven before, Iâll need to push (2 ^ k) * A candies. Letâs take a look\r\nat the k-th bit from binary representation of q. If k-th bit is 1, B\r\nwill be written as following: B = A * (2 ^ k + 2 ^ (other_power_1) + 2 ^\r\n(other_power_2) + ...) + r. Hence, Iâll be able to move A * (2 ^ k)\r\ncandies from \"B box\" to \"A box\". Otherwise, Iâll move from \"C box\" to \"A\r\nbox\". It will be always possible to do this move, as C > B and I could\r\ndo that move from B, too. The proposed algorithm may look abstract, so\r\nletâs take an example. Suppose A = 3, B = 905 and C = 1024. Can we get\r\nless than 3 for this state? B = 3 * 301 + 2. B = 3 * (100101101)2 + 2. K\r\n= 0: we need to move (2^0) * 3 coins into A. 0th bit of q is 1, so we\r\ncan move from B to A. A = 6, B = 3 * (100101100)2 + 2 C = 1024 K = 1: we\r\nneed to move (2 ^ 1) * 3 coins into A. Since 1th bit of q is already 0,\r\nwe have to move from C. A = 12, B = 3 * (100101100)2 + 2 C = 1018 K = 2:\r\nwe need to move (2 ^ 2) * 3 coins into A. 2nd bit of q is 1, so we can\r\nmove from B. A = 24, B = 3 * (100101000)2 + 2 C = 1018 K = 3: we need to\r\nmove (2 ^ 3) * 3 coins into A. 3nd bit of q is 1, so we can move from B.\r\nA = 48, B = 3 * (100100000)2 + 2 C = 1018 K = 4. we need to move (2 ^\r\n4) * 3 coins into A. 4th bit of q is 0, we need to move from C. A = 96,\r\nB = 3 * (100100000)2 + 2 C = 970 K = 5. we need to move (2 ^ 5) * 3\r\ncoins into A. 5th bit of q is 1, so we need to move from B. A = 192, B =\r\n3 * (100000000)2 + 2 C = 970 K = 6 we need to move (2 ^ 6) * 3 coins\r\ninto A. We mve them from C. A = 384 B = 3 * (100000000)2 + 2 C = 778 K =\r\n7 we need to move (2 ^ 7) * 3 coins into A. We move them from C A = 768\r\nB = 3 * (100000000)2 + 2 C = 394 K=8 Finally, we can move our last 1 bit\r\nfrom B to A. A = 1536 B = 3 * (000000000)2 + 2 C = 394 A = 1536 B = (3 *\r\n0 + 2) C = 394 In the example, from (3, 905, 1024) we can arrive to (2,\r\n394, 1536). Then, with same logic, we can go from (2, 394, 1536) to (0,\r\nX, Y), because 394 = 2 * 197 + 0. This is how you could write\r\nemptyOneBox() procedure. The remained problem is straight-forward: if\r\ninitially there are zero or one boxes having candies, the answer is\r\n\"-1\". Otherwise, until there are more than 2 boxes having candies, pick\r\n3 boxes arbitrary and apply emptyOneBox(). Here is a source implementing\r\nthe algorithm. 4383485\r\n",
    "hint": []
}