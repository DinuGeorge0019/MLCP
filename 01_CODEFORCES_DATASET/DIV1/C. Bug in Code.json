{
    "link": "https://codeforces.com//contest/420/problem/C",
    "problemId": "8700",
    "problem_idx": "C",
    "shortId": "420C",
    "contest_number": "420",
    "problem_submissions": {
        "D": [
            6447019,
            6443008,
            6912685,
            6445957,
            6445329,
            6443168,
            6444131,
            6443396,
            6445355,
            6451593,
            6451581,
            6451576,
            6445477,
            6445823,
            6445771,
            6446204,
            6445678,
            6446109,
            6446112,
            6453468,
            6446223,
            6446441
        ],
        "E": [
            6445798,
            6444814,
            6444979,
            6445922,
            97601411,
            6445707,
            6451168,
            6446265,
            6453470,
            6452703
        ],
        "B": [
            6443597,
            6444025,
            6443126,
            6443737,
            6443495,
            6442572,
            6444279,
            6445309,
            6444923,
            6442844,
            6443551,
            6443899,
            6443352,
            6444309,
            6444403,
            6443539,
            6442859,
            6444609,
            6443627
        ],
        "C": [
            6442567,
            6449379,
            6444178,
            6442191,
            6444286,
            6443894,
            6442929,
            6444396,
            6449718,
            6444138,
            6442459,
            6444175,
            6443120,
            6442842,
            6444661,
            6443838,
            6443047,
            6444348
        ],
        "A": [
            6440359,
            6440343,
            6443435,
            6440637,
            6440896,
            6440723,
            6443481,
            6440285,
            6440476,
            6440399,
            6440452,
            6440422,
            6440497,
            6442028,
            6443134,
            6440669,
            6440645,
            6440656,
            6441090
        ]
    },
    "name": "C. Bug in Code",
    "statement": "Recently a serious bug has been found in the FOS code. The head of the F\r\ncompany wants to find the culprit and punish him. For that, he set up an\r\norganizational meeting, the issue is: who’s bugged the code? Each of the\r\ncoders on the meeting said: ’I know for sure that either or did it!’The\r\nhead of the company decided to choose two suspects and invite them to\r\nhis office. Naturally, he should consider the coders’ opinions. That’s\r\nwhy the head wants to make such a choice that at least of coders agreed\r\nwith it. A coder agrees with the choice of two suspects if at least one\r\nof the two people that he named at the meeting was chosen as a suspect.\r\nIn how many ways can the head of F choose two suspects?Note that even if\r\nsome coder was chosen as a suspect, he can agree with the head’s choice\r\nif he named the other chosen coder at the meeting.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define LLD long long\n#define N 300005\nusing namespace std;\n\nstruct dat{\n\tint x, id;\n\tbool operator < (dat const &T) const{return x < T.x;}\n};\n\nint n, m, x, y, tx, ty;\nint d[N], v[N];\ndat a[N];\nmap<int, int> S[N];\nLLD ret;\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tFOR(i,0,n) a[i].id = i;\n\tFOR(i,0,n){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--, y--;\n\t\tS[x][y]++;\n\t\tS[y][x]++;\n\t\ta[x].x++, a[y].x++;\n\t\td[x]++, d[y]++;\n\t}\n\t\n\tsort(a, a + n);\n\tret = 0;\n\tfor (int i=0, j=n; i<n-1; i++){\n\t\twhile (j > i && a[i].x + a[j-1].x >= m) --j;\n\t\tj = max(j, i + 1);\n\t\tif (j == n) continue;\n\t\tx = a[i].id;\n\t\tret += n - j;\n\t\tfor (map<int, int>::iterator itr=S[x].begin(); itr != S[x].end(); itr++){\n\t\t\ttx = itr->first;\n\t\t\tty = itr->second;\n\t\t\tif (v[tx]) continue;\n\t\t\tif (d[tx] + d[x] >= m && d[tx] + d[x] - ty < m) --ret;\n\t\t}\n\t\tv[x] = 1;\n\t}\n\t\n\tprintf(\"%I64d\\n\", ret);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Bug in Code.json",
    "editorial_link": "https://codeforces.com//blog/entry/11871",
    "editorial": "Lets construct an undirected graph, the vertices of the graph are the\r\npersons, there is an edge between two persons if there are claim of some\r\nperson about these two persons. Now we can describe the problem on this\r\ngraph. We need to find the number of such pairs of vertices that at\r\nleast edges are adjacent to them. How to count such pairs. Just for each\r\nvertex to calculate the number of vertices such that , then we should\r\nconsider all the adjacent vertices correctly. Iterate through all the\r\nedges and subtract such the vertices from the answer. Then iterate\r\nthrough adjacent vertices and add only such of them that is needed to be\r\nadded. Pay attention to multiple edges, they should be considered very\r\ncarefully.\r\n",
    "hint": []
}