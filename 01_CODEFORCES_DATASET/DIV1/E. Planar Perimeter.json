{
    "link": "https://codeforces.com//contest/1242/problem/E",
    "problemId": "461423",
    "problem_idx": "E",
    "shortId": "1242E",
    "contest_number": "1242",
    "problem_submissions": {
        "D": [
            64429860,
            64401395,
            64404795,
            64415190,
            64415054,
            64417615,
            65038601,
            64421033
        ],
        "E": [
            64409298,
            64420461,
            64419778,
            64424736,
            64419348,
            64414319,
            64418306,
            64411659,
            85134215,
            64416609
        ],
        "C": [
            64384054,
            64387078,
            64388913,
            64394464,
            64389930,
            64394199,
            64391758,
            64389823,
            64419752,
            64392841,
            64389286,
            64389598,
            64391081,
            64391511,
            64389424,
            64390727,
            64393812,
            64387821,
            64392710
        ],
        "B": [
            64375742,
            64376014,
            64376258,
            64379755,
            64379732,
            64382090,
            64380230,
            64379007,
            64378437,
            64381299,
            64377955,
            64379394,
            64386968,
            64379314,
            64379387,
            64378002,
            64378249,
            64378976,
            64378094,
            64382011
        ],
        "A": [
            64373553,
            64378605,
            64373529,
            64375482,
            64375227,
            64375209,
            64374548,
            64373968,
            64380733,
            64373781,
            64373964,
            64373921,
            64376154,
            64374077,
            64374590,
            64374513,
            64373655,
            64375273,
            64373875,
            64376239
        ]
    },
    "name": "E. Planar Perimeter",
    "statement": "Ujan has finally cleaned up his house and now wants to decorate the\r\ninterior. He decided to place a beautiful carpet that would really tie\r\nthe guest room together.He is interested in carpets that are made up of\r\npolygonal patches such that each side of a patch is either a side of\r\nanother (different) patch, or is an exterior side of the whole carpet.\r\nIn other words, the carpet can be represented as a planar graph, where\r\neach patch corresponds to a face of the graph, each face is a simple\r\npolygon. The perimeter of the carpet is the number of the exterior\r\nsides. Ujan considers a carpet beautiful if it consists of f patches,\r\nwhere the i-th patch has exactly a_i sides, and the perimeter is the\r\nsmallest possible. Find an example of such a carpet, so that Ujan can\r\norder it!\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 3e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ndeque<int> ans[MX];\nmap<pi,int> m;\n\nvoid checkDup() {\n\ttrav(t,m) if (t.f.f == t.f.s || t.s > 2) {\n\t\tps(\"OOPS\");\n\t\treturn;\n\t}\n}\n\nbool ae(int a, int b, int c = 1) {\n\tif (a > b) swap(a,b);\n\tm[{a,b}] += c;\n\treturn m[{a,b}] > 2;\n}\n\nint n,extra;\ndeque<int> cur; \n\ndeque<int> getPoly(int mx, int x) {\n\tdeque<int> CUR;\n\tfor (int j = sz(cur)-mx-1; j < sz(cur); ++j) CUR.pb(cur[j]); // mx+1 in common\n\textra = x-(mx+1); F0R(j,extra) CUR.pb(++n);\n\treturn CUR;\n}\n\nbool addAll(deque<int> d) {\n\tbool bad = 0;\n\tF0R(i,sz(d)) {\n\t\tbad |= ae(d[i],d[(i+1)%sz(d)]);\n\t}\n\treturn bad;\n}\n\nbool makeDup(deque<int> d) {\n\tbool bad = addAll(d);\n\tF0R(i,sz(d)) ae(d[i],d[(i+1)%sz(d)],-1);\n\treturn bad;\n}\n\nvoid solve(vi A) {\n\tm.clear(); cur = deque<int>(); n = 0;\n\tvpi a; F0R(i,sz(A)) a.pb({A[i],i});\n\tsort(all(a));\n\t\n\tint mn = a.back().f;\n\tF0R(i,sz(a)-1) mn -= a[i].f-2;\n\tif (mn % 2 == 0) ckmax(mn,4);\n\telse ckmax(mn,3);\n\tF0R(i,a.back().f) cur.pb(++n); ans[a.back().s] = cur;\n\tR0F(i,sz(a)-1) {\n\t\tassert(sz(cur) >= a[i].f);\n\t\tint x = cur.front(); cur.pop_front(); cur.pb(x);\n\t\tint mx = a[i].f-1;\n\t\tif (a[i].f == sz(cur)) ckmin(mx,a[i].f-2);\n\t\tckmin(mx,(sz(cur)+a[i].f-(i == 0 ? 0 : a[i-1].f))/2);\n\t\tassert(mx > 0); int res = sz(cur)+a[i].f-2*mx;\n\t\tint N = n;\n\t\tauto CUR = getPoly(mx,a[i].f);\n\t\twhile (makeDup(CUR)) {\n\t\t\tcur.push_front(cur.back()); cur.pop_back();\n\t\t\tn = N; CUR = getPoly(mx,a[i].f);\n\t\t}\n\t\tassert(!addAll(CUR));\n\t\t// ps(\"HA\",cur,CUR);\n\t\tint tmp = sz(cur)-mx; while (sz(cur) > tmp) cur.pop_back();\n\t\tF0R(i,extra+1) cur.pb(CUR[sz(CUR)-1-i]);\n\t\tans[a[i].s] = CUR;\n\t\tif (sz(cur) != res) {\n\t\t\texit(5);\n\t\t\tps(\"WUT\",A,mx,cur,res);\n\t\t\texit(0);\n\t\t}\n\t\t// sz(cur)+a[i].f-2*x >= a[i-1].f\n\t}\n\tassert(sz(cur) == mn);\n\tps(n);\n\tF0R(i,sz(A)) {\n\t\ttrav(t,ans[i]) pr(t,' ');\n\t\t// F0R(j,sz(ans[i])) ae(ans[i][j],ans[i][(j+1)%sz(ans[i])]);\n\t\tps();\n\t}\n\tcheckDup();\n}\n\nint main() {\n\tsetIO(); \n\tint f; re(f); vi A(f); re(A);\n\tsolve(A);\n\texit(0);\n\t/*F0R(i,100) {\n\t\tint x = rand()%10+1;\n\t\tvi v;\n\t\tF0R(j,x) v.pb(rand()%10+3);\n\t\tsolve(v);\n\t}*/\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Planar Perimeter.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "If there is just a single face, just output it. Suppose there are at\r\nleast faces.Let\u00e2\u0080\u0099s say that we \"glue\" a cycle to a planar graph along\r\nedges if we place this cycle so that the graph and the cycle share edges\r\non their perimeters.First, sort the numbers in decreasing order (then we\r\nhave ). By gluing any to the cycle, we can decrease the number of edges\r\nby at most . Also note that the answer is always at least , because\r\nthere cannot be multiple edges between two vertices. Thus, if , then the\r\nanswer is (we subtract from to keep the perimeter at least : these are\r\nthe edges that we don\u00e2\u0080\u0099t glue anything to).Otherwise the answer is either\r\nor (depending on the parity of ). The algorithm to construct the graph:\r\nlet . Iterate from to . While , glue the -th cycle with the graph along\r\none edge (). For the first such that this does not hold, glue it so that\r\n. Afterwards just glue each remaining cycles along edges with the\r\ngraph.There is one problem with this algorithm: it can happen that we\r\nadd multiple edges between two vertices. This situation is as follows:\r\nsuppose you are at some point of the algorithm with a planar graph that\r\nyou\u00e2\u0080\u0099re building. Suppose there is an edge between some vertices and on\r\nthe current perimeter, and you now happen to glue a cycle along the\r\nedges between and , and the last edge of the cycle you\u00e2\u0080\u0099re gluing must\r\nconnect and . To solve this situation, take the vertex adjacent to to\r\nthe right on the perimeter, and the vertex adjacent to also to the right\r\non the perimeter. Now, and cannot be connected by an edge in the current\r\ngraph, because then it would intersect the edge between and . This would\r\nbe a contradiction, because the graph is planar. Then you glue the cycle\r\nalong the edges between and .The complexity of the algorithm: . You\r\nshould be careful with the implementation: for example, not to make\r\nperimeter equal to at some point or use some edge in more than two\r\nfaces.\r\n"
}