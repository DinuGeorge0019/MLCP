{
    "link": "https://codeforces.com//contest/708/problem/E",
    "problemId": "68954",
    "problem_idx": "E",
    "shortId": "708E",
    "contest_number": "708",
    "problem_submissions": {
        "D": [
            20128638,
            20126204,
            20127943,
            20128433,
            20129319,
            20131176,
            20131436,
            20129838,
            20122993,
            20128159,
            20142291,
            20131523,
            20133302
        ],
        "C": [
            20118349,
            20120224,
            20122617,
            20118594,
            20120712,
            20117957,
            20121003,
            20121397,
            20122448,
            20125761,
            20125377,
            20142883,
            20115423,
            20116938,
            20120664,
            20122725,
            20120078,
            20120943
        ],
        "B": [
            20114040,
            20113824,
            20115208,
            20114995,
            20116521,
            20114682,
            20122861,
            20116437,
            20115616,
            20134188,
            20115824,
            20122403,
            20114546,
            20119679,
            20134838,
            20114458,
            20118558,
            20114710,
            20134501
        ],
        "A": [
            20109754,
            20109973,
            20109781,
            20109720,
            20110304,
            20110371,
            20110361,
            20110988,
            20111867,
            20110273,
            20109747,
            20109936,
            20109851,
            20109665,
            20123051,
            20111085,
            20110162,
            20110043,
            20110060
        ],
        "E": [
            20132586,
            20171243,
            20148122,
            20129101,
            20132661,
            20128262,
            20149149
        ]
    },
    "name": "E. Student s Camp",
    "statement": "Alex studied well and won the trip to student camp Alushta, located on\r\nthe seashore. Unfortunately, it’s the period of the strong winds now and\r\nthere is a chance the camp will be destroyed! Camp building can be\r\nrepresented as the rectangle of concrete blocks height and blocks\r\nwidth.Every day there is a breeze blowing from the sea. Each block,\r\nexcept for the blocks of the upper and lower levers, such that there is\r\nno block to the left of it is destroyed with the probability .\r\nSimilarly, each night the breeze blows in the direction to the sea.\r\nThus, each block (again, except for the blocks of the upper and lower\r\nlevers) such that there is no block to the right of it is destroyed with\r\nthe same probability . Note, that blocks of the upper and lower level\r\nare , so there are only blocks that can be destroyed.The period of the\r\nstrong winds will last for days and nights. If during this period the\r\nbuilding will split in at least two connected components, it will\r\ncollapse and Alex will have to find another place to spend summer.Find\r\nthe probability that Alex won’t have to look for other opportunities and\r\nwill be able to spend the summer in this camp.\r\n",
    "solutions": [
        "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\n#define int long long\n\nconst int N = (int) 2e5 + 5, mod = (int) 1e9 + 7, M = 3005;\nint pw(int a, int b) { return b != 0? pw(a * a % mod, b >> 1) * (b & 1? a: 1) % mod: 1; }\nint f[N], invf[N], pickp[N], pickn[N], sd[N], dest[N], lp[M], rp[M], olp[M], orp[M], lps[M];\nint comb(int n, int r) {\n    if (n < 0 || r < 0 || n - r < 0) return 0;\n    return f[n] * invf[r] % mod * invf[n - r] % mod;\n}\nint mul(int x, int y) { return x * y % mod; }\nint add(int x, int y) { return (x + y + 100 * mod) % mod; }\nint sadd(int &x, int y) { return x = add(x, y); }\n\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    f[0] = invf[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = f[i - 1] * i % mod, invf[i] = pw(f[i], mod - 2);\n    int n, m;\n    cin >> n >> m;\n    int pa, pb;\n    cin >> pa >> pb;\n    for (int i = 0; i < N; ++i)\n        pickp[i] = pw(pa, i) * pw(pw(pb, mod - 2), i) % mod, pickn[i] = pw(pb - pa, i) * pw(pw(pb, mod - 2), i) % mod;\n    int k;\n    cin >> k;\n    for (int j = 0; j < N; ++j) {\n        dest[j] = comb(k, j) * pickp[j] % mod * pickn[k - j] % mod;\n        sadd(sd[j], add(j == 0? 0: sd[j - 1], dest[j]));\n    }\n    lp[0] = 1;\n    rp[m - 1] = 1;\n    for (int d = 0; d < n + 1; ++d) {\n        memcpy(olp, lp, sizeof lp);\n        memcpy(orp, rp, sizeof rp);\n        memset(lp, 0, sizeof lp);\n        memset(lps, 0, sizeof lps);\n        memset(rp, 0, sizeof rp);\n        int sumrp = 0, all = 0, cur_val = 0;\n        for (int j = 0; j < m; ++j)\n            sadd(all, olp[j]);\n        if (d == n) {\n            cout << all;\n            return 0;\n        }\n        for (int j = m - 1; j >= 0; --j)\n            lps[j] = add(lps[j + 1], olp[j]);\n        for (int j = 0; j < m; ++j) {\n            sadd(rp[j], -mul(cur_val, dest[m - j - 1]));\n            sadd(rp[j], -mul(lps[j + 1], mul(sd[j], dest[m - j - 1])));\n            sadd(rp[j], mul(mul(all, sd[j]), dest[m - j - 1]));\n//            cout << j << ' ' << all << ' ' << cnt << ' ' << sd[j] << ' ' << dest[m - j - 1] << ' ' << cur_val << ' ' << lps[j + 1] << endl;\n            sadd(sumrp, orp[j]);\n            sadd(cur_val, mul(sumrp, dest[j + 1]));\n        }\n        for (int j = 0; j < m; ++j) {\n            lp[j] = rp[m - j - 1];\n        }\n    }\n\n\n\n\n\n}\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Student s Camp.json",
    "editorial_link": "https://codeforces.com//blog/entry/46763",
    "editorial": "Let is probability that first rows are connected and -th row is (itâs\r\nalways a segment). We can write a simple equation: for , where is the\r\nprobability that after days row will became a range . This probability\r\nis equal to where Now consider and and Now Here we subtract from\r\nprobability of all segments the segments on the left and on the\r\nright.Now we wonât calculate but . Itâs to calculate each separate\r\nvalue, but itâs also possible to calculate them all in if we iterate\r\nover from to and hold several values during this process. Particularly,\r\nwe need precalculated sums of with fixed and to hold the sum of for\r\n(recall that . See code for details. is just prefix sums of what we\r\ncalculated.So we obtain the solution with complexity.\r\n",
    "hint": []
}