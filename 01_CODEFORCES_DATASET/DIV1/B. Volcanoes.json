{"link": "https://codeforces.com//contest/383/problem/B", "problemId": "5723", "problem_idx": "B", "shortId": "383B", "contest_number": "383", "problem_submissions": {"B": [5756409, 5751225, 5757744, 5753341, 5808519, 5808489, 5808447, 5758844, 5759238, 5752874, 5755308, 5752676, 5753907, 5753281, 5756832, 5755532], "E": [5754649, 5757705, 5753388, 5758136, 5808454, 5755553, 5754159, 5755881, 5756030, 5755626, 5754883, 5757327, 5758405, 5757943], "D": [5753594, 5752449, 5752307, 5754262, 5808453, 5751984, 5752563, 5753410, 5753070, 5753481, 5755159, 5755983, 5755452, 5753533, 5756037, 5756133, 5757148, 5756616, 5755389, 5756824], "C": [5750456, 5751886, 5754923, 5749119, 5751328, 5751146, 5750311, 5750868, 5752299, 5751003, 5750201, 5751936, 5751653, 5754669, 5750989, 5754841, 5751430, 5750434], "A": [5747280, 5747986, 5747387, 5747246, 5808450, 5747221, 5747445, 5747936, 5747254, 5748686, 5747361, 5747734, 5747935, 5748612, 5748223, 5747638, 5747622, 5749616, 5757219]}, "name": "B. Volcanoes", "statement": "Iahub got lost in a very big desert. The desert can be represented as a\r\nsquare matrix, where each cell is a zone of the desert. The cell\r\nrepresents the cell at row and column . Iahub can go from one cell only\r\ndown or right, that is to cells or . Also, there are cells that are\r\noccupied by volcanoes, which Iahub cannot enter. Iahub is initially at\r\ncell and he needs to travel to cell . Knowing that Iahub needs second to\r\ntravel from one cell to another, find the minimum time in which he can\r\narrive in cell .\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nbool cmp2(const pii &a, const pii &b) {\n  return a.second == b.second ? a.first < b.first : a.second < b.second;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int h, m;\n  while (scanf(\"%d%d\", &h, &m) >= 1) {\n    int w = h;\n\n    vector<pii> pts(m);\n    for (int i = 0; i < m; i++)\n      scanf(\"%d%d\", &pts[i].first, &pts[i].second);\n    sort(pts.begin(), pts.end(), cmp2);\n\n    vi ys;\n    ys.pb(1);\n    ys.pb(2);\n    ys.pb(h - 1);\n    ys.pb(h);\n    for (int i = 0; i < m; i++)\n    for (int k = -1; k <= 1; k++)\n      ys.pb(pts[i].second + k);\n    {\n      int ptr = 0;\n      for (int i = 0; i < sz(ys); i++)\n        if (1 <= ys[i] && ys[i] <= h)\n          ys[ptr++] = ys[i];\n      ys.resize(ptr);\n    }\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    assert(sz(ys) >= 1);\n    assert(ys[0] == 1);\n    assert(ys.back() == h);\n\n    set<pii> cur;\n    cur.insert(mp(1, 1));\n\n    int pptr = 0;\n    for (int cyid = 0; cyid < sz(ys); cyid++) {\n      int cy = ys[cyid];\n//      eprintf(\"y=%d\\n\", cy);\n      vi curs;\n      while (pptr < m && pts[pptr].second == cy) {\n        curs.pb(pts[pptr++].first);\n      }\n      curs.pb(w + 1);\n\n      int bord = 0;\n      for (int i = 0; i < sz(curs); i++) {\n        int minx = curs[i];\n//        eprintf(\"  process %d\\n\", minx);\n        for (;;) {\n          set<pii>::iterator it = cur.lower_bound(mp(bord + 1, -1));\n          if (it == cur.end()) break;\n          if (it->first > curs[i]) break;\n          minx = min(minx, it->first);\n//          eprintf(\"    remove %d..%d\\n\", it->first, it->second);\n          if (it->second > curs[i]) {\n//            eprintf(\"      add %d..%d\\n\", curs[i] + 1, it->second);\n            cur.insert(mp(curs[i] + 1, it->second));\n          }\n          cur.erase(it);\n        }\n        assert(minx > bord);\n        if (minx < curs[i]) {\n//          eprintf(\"    new %d..%d\\n\", minx, curs[i] - 1);\n          cur.insert(mp(minx, curs[i] - 1));\n        }\n        bord = minx;\n      }\n      assert(sz(cur) <= sz(curs) + 3);\n\n/*      eprintf(\"  nya:\\n\");\n      for (set<pii>::iterator it = cur.begin(); it != cur.end(); it++)\n        eprintf(\"    %d..%d\\n\", it->first, it->second);*/\n    }\n\n    if (!cur.empty() && cur.rbegin()->second >= w)\n      printf(\"%d\\n\", h + w - 2);\n    else\n      printf(\"-1\\n\");\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "implementation", "sortings", "two pointers"], "dificulty": "2500", "interactive": false}