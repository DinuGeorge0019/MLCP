{
    "link": "https://codeforces.com//contest/1292/problem/F",
    "problemId": "519781",
    "problem_idx": "F",
    "shortId": "1292F",
    "contest_number": "1292",
    "problem_submissions": {
        "F": [
            69140685,
            69148403,
            71814085,
            71814062,
            71813990,
            70217605,
            69197847,
            69495748,
            71223361
        ],
        "D": [
            69122533,
            69114171,
            69256713,
            69123417,
            69126885,
            69163995,
            69128025,
            69127012,
            69131460,
            69130080,
            69130342,
            69128215,
            69129378,
            69133922,
            69131233,
            69132965,
            69132809,
            69134434,
            69132903,
            69127292,
            69140744,
            69136786
        ],
        "C": [
            69113617,
            69117304,
            69112958,
            69113829,
            69164607,
            69112261,
            69111227,
            69113942,
            69113564,
            69116428,
            69114170,
            69121126,
            69118602,
            69121886,
            69119931,
            69117602,
            69119253,
            69121231,
            69130721,
            69112217,
            69119945
        ],
        "B": [
            69102431,
            69100917,
            69105559,
            69104060,
            69164579,
            69104349,
            69103131,
            69105348,
            69102973,
            69106424,
            69106338,
            69108218,
            69106515,
            69110303,
            69110995,
            69110488,
            69109887,
            69114588,
            69102534,
            69105217,
            69108444
        ],
        "A": [
            69100122,
            69100064,
            69101788,
            69100300,
            69164572,
            69100144,
            69100129,
            69100151,
            69100251,
            69100494,
            69100278,
            69100280,
            69100245,
            69101280,
            69102544,
            69101036,
            69101104,
            69100156,
            69100106,
            69100348,
            69100678
        ],
        "E": [
            69145246,
            69152430,
            69165289,
            69151098,
            69168995,
            69165203,
            69152318,
            69162582,
            69185344
        ]
    },
    "name": "F. Nora s Toy Boxes",
    "statement": "Back in time, the seven-year-old Nora used to play lots of games with\r\nher creation ROBO_Head-02, both to have fun and enhance his\r\nabilities.One day, Nora\u2019s adoptive father, Phoenix Wyle, brought Nora n\r\nboxes of toys. Before unpacking, Nora decided to make a fun game for\r\nROBO.She labelled all n boxes with n distinct integers a_1, a_2,\r\nldots, a_n and asked ROBO to do the following action several (possibly\r\nzero) times: Pick three distinct indices i, j and k, such that a_i\r\nmid a_j and a_i\r\nmid a_k. In other words, a_i divides both a_j and a_k, that is a_j\r\nbmod a_i = 0, a_k\r\nbmod a_i = 0. After choosing, Nora will give the k-th box to ROBO, and\r\nhe will place it on top of the box pile at his side. Initially, the pile\r\nis empty. After doing so, the box k becomes unavailable for any further\r\nactions. Being amused after nine different tries of the game, Nora asked\r\nROBO to calculate the number of possible different piles having the\r\namount of boxes in them. Two piles are considered different if there\r\nexists a position where those two piles have different boxes.Since ROBO\r\nwas still in his infant stages, and Nora was still too young to\r\nconcentrate for a long time, both fell asleep before finding the final\r\nanswer. Can you help them?As the number of such piles can be very large,\r\nyou should print the answer modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\n\nconst int N = 62;\nconst int K = 12;\nint dp[(1 << K) + 5][N];\nint C[N][N];\nint a[N];\nint b[N];\nint d[N];\nbool used[N];\nint n, m;\n\nint solve(int k) {\n\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\tfor (int i = 0; i <= k; i++)\n\t\t\tdp[mask][i] = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tdp[d[i]][1] = add(dp[d[i]][1], 1);\n\t}\n\tfor (int p = 1; p < k; p++) {\n\t\tfor (int mask = 0; mask < (1 << m); mask++) {\n\t\t\tif (dp[mask][p] == 0) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint z = mask & d[i];\n\t\t\t\tif (z == 0) continue;\n\t\t\t\tif (z == d[i]) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[mask | d[i]][p + 1] = add(dp[mask | d[i]][p + 1], dp[mask][p]);\n\t\t\t}\n\t\t\tif (cnt < p) throw;\n\t\t\tdp[mask][p + 1] = add(dp[mask][p + 1], mult(cnt - p, dp[mask][p]));\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\tres = add(res, dp[mask][k]);\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tsort(a, a + n);\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(\"%d \", a[i]);\n//\teprintf(\"\\n\");\n\tfor (int i = 0; i < n; i++) {\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (a[i] % a[j] == 0)\n\t\t\t\tok = false;\n\t\tif (!ok) continue;\n\t\tint cnt = 0;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[j] % a[i] == 0)\n\t\t\t\tcnt++;\n\t\tif (cnt < 2) continue;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[j] % a[i] == 0)\n\t\t\t\tb[j] |= 1 << m;\n\t\tm++;\n\t}\n\tif (m > K) throw;\n\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(\"%d \", b[i]);\n//\teprintf(\"\\n\");\n\n\tint ans = 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tif (b[i] == 0) continue;\n\t\tint mask = b[i];\n\t\tbool ch = true;\n\t\twhile(ch) {\n\t\t\tch = false;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (used[j]) continue;\n\t\t\t\tint z = mask & b[j];\n\t\t\t\tif (z == 0) continue;\n\t\t\t\tif (z == b[j]) continue;\n\t\t\t\tmask |= b[j];\n\t\t\t\tch = true;\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (used[j]) continue;\n\t\t\tif (b[j] == 0) continue;\n\t\t\tif (mask & b[j]) {\n\t\t\t\td[k++] = b[j];\n\t\t\t\tused[j] = 1;\n\t\t\t}\n\t\t}\n\t\tans = mult(ans, C[sum + k - 1][k - 1]);\n\t\tans = mult(ans, solve(k));\n\t\tsum += k - 1;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Nora s Toy Boxes.json",
    "editorial_link": "https://codeforces.com//blog/entry/73051",
    "editorial": "We consider a directed graph , where we draw an edge from vertex to\r\nvertex if . Notice that is a DAG and is transitive (if then ).For each\r\nvertex, we consider two states: \"on\" (not deleted) and \"off\" (deleted).\r\nAn edge is \"on\" if both end vertices are not deleted, and \"off\"\r\notherwise. The operation is equivalent to choosing a vertices triple\r\nsuch that , , are on and ; then turn off vertex and append to the end of\r\n.We first solve the problem for a weakly connected component (only\r\nchoosing vertices triple belong to this component in each operation).\r\nDefine the set of all vertices with no incoming edges, and the set of\r\nremaining vertices (). Obviously, vertices in can\u00e2\u0080\u0099t be turned off. We\r\nneed to figure out the maximum number of vertices in we can turn off.We\r\nconsider the reversed process. Initially, some vertices in are turned\r\noff, and we can turn on a vertex with the following operation: choose a\r\nvertices triple such that , are on, is off, and ; then turn on and\r\nappend to the beginning of . Consider a vertex . If has no incoming edge\r\nfrom another vertex in , must has an incoming edge from a vertex in (if\r\nnot, have no incoming edge, which mean should be in instead of ,\r\ncontradiction). Otherwise, let the vertex with minimum among all\r\nvertices in with an outgoing edge to . has no incoming edge from another\r\nvertex in , so there exist a vertex that has an outgoing edge to . Since\r\nis transitive and , has an outgoing edge to . Let\u00e2\u0080\u0099s the set of all\r\nvertices in that is currently on, and the set of remaining vertices in\r\n(). We will prove that, if is not empty, we can always turn on a vertex\r\nin . If this is true, starting from the state where contain only one\r\nvertex (and contain the remaining vertices of ), one can repeat turning\r\non a vertex in until all vertices in are on.To prove it, we need to show\r\nthat there exist a vertex in that has an outgoing edge to some vertex in\r\nand some vertex in (so we can choose the triple of three mentioned\r\nvertices to turn on a vertex in ). Consider two cases: Case 1: There\r\nexist some edge with and .Let a vertex in that has an outgoing edge to .\r\nSince is transitive and , are in , are also in . In other word, has an\r\noutgoing edge to both and . Case 2: There is no edge from a vertex in to\r\na vertex in . In this case, if there exist no vertex in that has an\r\noutgoing edge to some vertex in and some vertex in , the component would\r\nbe divided into two smaller component (one with all vertices in with\r\ntheir incoming vertices, one with all vertices in with their incoming\r\nvertices). This contradict the fact that , and are weakly connected. The\r\nlemma above give us the maximum length of sequence we can construct: .\r\nNow we need to count the number of such sequence . Equivalently, for\r\neach vertex , we need to count the number of orders to turn on all other\r\nvertices in (given that is initially on and all other vertices in are\r\ninitially off).Let the vertices in and the vertices in . First, how can\r\nwe know whether we can turn on a vertex in , without having to consider\r\nthe states of other vertices in ?For a vertex in that is off, assume\r\nthat we can turn on by choosing a triple such that . In other to choose\r\nthe triple, , must be on and . Let the vertex in that has an outgoing\r\nedge to ( is always on since ). Since the graph is transitive, also has\r\noutgoing edges to and . Therefore, we can turn on by choosing the triple\r\ninstead. With the above lemma, it is sufficient to only consider, for\r\neach vertex , whether there is an on outgoing edge from . We can use a\r\nbitmask of length to represent this information, with -th bit equal if\r\nhas an on outgoing edge (and equal otherwise). For each vertex , let the\r\nbitmask of length , with -th bit equal if has an outgoing edge to in\r\n.Let the number of distinct box piles of length ROBO can have, with the\r\n-th bit of equals if has an on outgoing edge to a vertex in that is\r\nturned on. For a vertex that is currently off, we can turn on if .There\r\nare two cases: Turn on a currently-off vertex in a way that is expanded\r\n(some bit(s) turn into bit(s) ). To archive this, we must select in such\r\na way that must not be a subset of , and we can turn on (if a satisfy\r\nthese two conditions, we know for sure that is currently off).\r\nTherefore, for such that and , we update the following: Turn on a\r\ncurrently-off vertex in a way that is not expanded. Let be the number of\r\nindices j such that . We can turn on one of the vertices that is\r\ncurrently off. Therefore, we update the following: To solve the general\r\ncase, we can calculate the number of orders for each weakly connected\r\ncomponent separately and then combine the result with some combinatorics\r\nformula.Complexity: , with the maximum number of vertices with no\r\nincoming vertices (number of vertices in set ) among all weakly\r\nconnected component. We will prove that (where is the constraint of and\r\n), therefore the algorithm fit the given time limit.For simplicity,\r\nassume that is divisible by . Let\u00e2\u0080\u0099s focus only on the weakly connected\r\ncomponent with maximum number of vertices (which will equal ). Let\u00e2\u0080\u0099s\r\ndefine and in the same manner as the above solution. Notice that, for\r\nall from to , if in , then is a separate weakly connected component.\r\nTherefore, all numbers in should range from to .On another hand, there\r\nshould be no number in that divide another one in . In other word,\r\nconsider the divisibility graph of all integer from to . Therefore, the\r\nsize of cannot exceed the size of the maximum anti-chain (a subset of\r\nvertices such that no pair of vertices is connected by an edge) of the\r\ngraph. The size of the maximum anti-chain of the divisibility graph with\r\nvertices from to is (proof below). Therefore, the size of cannot exceed\r\n, or . Though, for an anti-chain of the divisibility graph with\r\nvertices, even if we include all the numbers from to , it may happen\r\nthat vertices of the anti-chain belong to different weakly connected\r\ncomponent. In reality, our brute-force program figure out that in the\r\nworst case, (achieved with ). We still need to prove that, for even ,\r\nthe maximum anti-chain of the divisibility graph with vertices from to\r\nis .For any number , let the number received by continuously divide by .\r\nIn other word, let the maximum value of such that is divisible by , then\r\n. Notice that, for two number and , if then divides or divides .For all\r\nfrom to , has at most different value (all odd number from to ). For any\r\nsubset of integers from to , if has elements or more, according to\r\nPigeonhole principle, there are two elements in that have the same value\r\nof . One of these two numbers will divide the other, so is not an\r\nanti-chain.\r\n"
}