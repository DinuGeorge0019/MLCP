{"link": "https://codeforces.com//contest/1292/problem/F", "problemId": "519781", "problem_idx": "F", "shortId": "1292F", "contest_number": "1292", "problem_submissions": {"F": [69140685, 69148403, 71814085, 71814062, 71813990, 70217605, 69197847, 69495748, 71223361], "D": [69122533, 69114171, 69256713, 69123417, 69126885, 69163995, 69128025, 69127012, 69131460, 69130080, 69130342, 69128215, 69129378, 69133922, 69131233, 69132965, 69132809, 69134434, 69132903, 69127292, 69140744, 69136786], "C": [69113617, 69117304, 69112958, 69113829, 69164607, 69112261, 69111227, 69113942, 69113564, 69116428, 69114170, 69121126, 69118602, 69121886, 69119931, 69117602, 69119253, 69121231, 69130721, 69112217, 69119945], "B": [69102431, 69100917, 69105559, 69104060, 69164579, 69104349, 69103131, 69105348, 69102973, 69106424, 69106338, 69108218, 69106515, 69110303, 69110995, 69110488, 69109887, 69114588, 69102534, 69105217, 69108444], "A": [69100122, 69100064, 69101788, 69100300, 69164572, 69100144, 69100129, 69100151, 69100251, 69100494, 69100278, 69100280, 69100245, 69101280, 69102544, 69101036, 69101104, 69100156, 69100106, 69100348, 69100678], "E": [69145246, 69152430, 69165289, 69151098, 69168995, 69165203, 69152318, 69162582, 69185344]}, "name": "F. Nora s Toy Boxes", "statement": "Back in time, the seven-year-old Nora used to play lots of games with\r\nher creation ROBO_Head-02, both to have fun and enhance his\r\nabilities.One day, Nora\u2019s adoptive father, Phoenix Wyle, brought Nora n\r\nboxes of toys. Before unpacking, Nora decided to make a fun game for\r\nROBO.She labelled all n boxes with n distinct integers a_1, a_2,\r\nldots, a_n and asked ROBO to do the following action several (possibly\r\nzero) times: Pick three distinct indices i, j and k, such that a_i\r\nmid a_j and a_i\r\nmid a_k. In other words, a_i divides both a_j and a_k, that is a_j\r\nbmod a_i = 0, a_k\r\nbmod a_i = 0. After choosing, Nora will give the k-th box to ROBO, and\r\nhe will place it on top of the box pile at his side. Initially, the pile\r\nis empty. After doing so, the box k becomes unavailable for any further\r\nactions. Being amused after nine different tries of the game, Nora asked\r\nROBO to calculate the number of possible different piles having the\r\namount of boxes in them. Two piles are considered different if there\r\nexists a position where those two piles have different boxes.Since ROBO\r\nwas still in his infant stages, and Nora was still too young to\r\nconcentrate for a long time, both fell asleep before finding the final\r\nanswer. Can you help them?As the number of such piles can be very large,\r\nyou should print the answer modulo 10^9 + 7.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y) {\n\treturn ((ll)x * y) % MOD;\n}\n\nconst int N = 62;\nconst int K = 12;\nint dp[(1 << K) + 5][N];\nint C[N][N];\nint a[N];\nint b[N];\nint d[N];\nbool used[N];\nint n, m;\n\nint solve(int k) {\n\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\tfor (int i = 0; i <= k; i++)\n\t\t\tdp[mask][i] = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tdp[d[i]][1] = add(dp[d[i]][1], 1);\n\t}\n\tfor (int p = 1; p < k; p++) {\n\t\tfor (int mask = 0; mask < (1 << m); mask++) {\n\t\t\tif (dp[mask][p] == 0) continue;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint z = mask & d[i];\n\t\t\t\tif (z == 0) continue;\n\t\t\t\tif (z == d[i]) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[mask | d[i]][p + 1] = add(dp[mask | d[i]][p + 1], dp[mask][p]);\n\t\t\t}\n\t\t\tif (cnt < p) throw;\n\t\t\tdp[mask][p + 1] = add(dp[mask][p + 1], mult(cnt - p, dp[mask][p]));\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int mask = 0; mask < (1 << m); mask++)\n\t\tres = add(res, dp[mask][k]);\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tsort(a, a + n);\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(\"%d \", a[i]);\n//\teprintf(\"\\n\");\n\tfor (int i = 0; i < n; i++) {\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (a[i] % a[j] == 0)\n\t\t\t\tok = false;\n\t\tif (!ok) continue;\n\t\tint cnt = 0;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[j] % a[i] == 0)\n\t\t\t\tcnt++;\n\t\tif (cnt < 2) continue;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[j] % a[i] == 0)\n\t\t\t\tb[j] |= 1 << m;\n\t\tm++;\n\t}\n\tif (m > K) throw;\n\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(\"%d \", b[i]);\n//\teprintf(\"\\n\");\n\n\tint ans = 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tif (b[i] == 0) continue;\n\t\tint mask = b[i];\n\t\tbool ch = true;\n\t\twhile(ch) {\n\t\t\tch = false;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (used[j]) continue;\n\t\t\t\tint z = mask & b[j];\n\t\t\t\tif (z == 0) continue;\n\t\t\t\tif (z == b[j]) continue;\n\t\t\t\tmask |= b[j];\n\t\t\t\tch = true;\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (used[j]) continue;\n\t\t\tif (b[j] == 0) continue;\n\t\t\tif (mask & b[j]) {\n\t\t\t\td[k++] = b[j];\n\t\t\t\tused[j] = 1;\n\t\t\t}\n\t\t}\n\t\tans = mult(ans, C[sum + k - 1][k - 1]);\n\t\tans = mult(ans, solve(k));\n\t\tsum += k - 1;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "combinatorics", "dp"], "dificulty": "3500", "interactive": false}