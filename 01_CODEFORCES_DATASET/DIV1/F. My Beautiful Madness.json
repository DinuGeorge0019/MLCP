{
    "link": "https://codeforces.com//contest/1464/problem/F",
    "problemId": "839215",
    "problem_idx": "F",
    "shortId": "1464F",
    "contest_number": "1464",
    "problem_submissions": {
        "D": [
            101893944,
            101884165,
            101894987,
            101897288,
            101893426,
            101899167,
            101898742,
            101897221,
            101904879,
            101902404,
            101904041,
            101898196,
            101901056,
            101893113,
            101900043,
            101901977,
            101879521,
            101891500
        ],
        "E": [
            101884958,
            101888698,
            101880762,
            101885481,
            101895459,
            101874392,
            101918343,
            101889791,
            101890948,
            101887375,
            142038158,
            102279161,
            102087511,
            101887630,
            101883023,
            101908666,
            101908552,
            101908506,
            101893369,
            101884575,
            101899034,
            101888272,
            101881773,
            101903223,
            101903745,
            101882555
        ],
        "C": [
            101877309,
            101876849,
            101885303,
            101878303,
            101875140,
            101886810,
            101875737,
            101878040,
            101880124,
            101880970,
            101877103,
            101881975,
            101878148,
            101882821,
            101880363,
            101877971,
            101885296,
            101877773,
            101876637
        ],
        "B": [
            101870508,
            101872024,
            101876423,
            101872980,
            101870882,
            101883179,
            101870101,
            101869654,
            101875498,
            101874908,
            101869353,
            101877667,
            101902344,
            101877756,
            101876619,
            101904584,
            101891390,
            101873346,
            101870962
        ],
        "A": [
            101862412,
            101862840,
            101865321,
            101865985,
            101861233,
            101876553,
            101861535,
            101873147,
            101867432,
            101867877,
            101872819,
            101866189,
            101865464,
            101863366,
            101870449,
            101865209,
            101894436,
            101867001,
            101859824
        ],
        "F": [
            101921592,
            101921489,
            101921368,
            101920713,
            113148352,
            197483789,
            101923610,
            101916398,
            101915019,
            107239743,
            103939202
        ]
    },
    "name": "F. My Beautiful Madness",
    "statement": "You are given a tree. We will consider simple paths on it. Let\u2019s denote\r\npath between vertices a and b as (a, b). Let d-neighborhood of a path be\r\na set of vertices of the tree located at a distance\r\nleq d from at least one vertex of the path (for example, 0-neighborhood\r\nof a path is a path itself). Let P be a multiset of the tree paths.\r\nInitially, it is empty. You are asked to maintain the following queries:\r\n1 u v add path (u, v) into P (1\r\nleq u, v\r\nleq n). 2 u v delete path (u, v) from P (1\r\nleq u, v\r\nleq n). Notice that (u, v) equals to (v, u). For example, if P =\r\n{(1, 2), (1, 2)\r\n}, than after query 2 2 1, P =\r\n{(1, 2)\r\n}. 3 d if intersection of all d-neighborhoods of paths from P is not\r\nempty output \"\", otherwise output \"\" (0\r\nleq d\r\nleq n - 1).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\ntemplate <typename T, class Compare = std::less<T>> class RangeMinQuery : private Compare {\n\tstatic const int BUCKET_SIZE = 32;\n\tstatic const int BUCKET_SIZE_LOG = 5;\n\tstatic_assert(BUCKET_SIZE == (1 << BUCKET_SIZE_LOG), \"BUCKET_SIZE should be a power of 2\");\n\tstatic const int CACHE_LINE_ALIGNMENT = 64;\n\tint n = 0;\n\tstd::vector<T> data;\n\tstd::vector<T> pref_data;\n\tstd::vector<T> suff_data;\n\tstd::vector<T> sparse_table;\n\tstd::vector<uint32_t> range_mask;\n\nprivate:\n\tint num_buckets() const {\n\t\treturn n >> BUCKET_SIZE_LOG;\n\t}\n\tint num_levels() const {\n\t\treturn num_buckets() ? 32 - __builtin_clz(num_buckets()) : 0;\n\t}\n\tint sparse_table_size() const {\n\t\treturn num_buckets() * num_levels();\n\t}\nprivate:\n\tconst T& min(const T& a, const T& b) const {\n\t\treturn Compare::operator()(a, b) ? a : b;\n\t}\n\tvoid setmin(T& a, const T& b) const {\n\t\tif (Compare::operator()(b, a)) a = b;\n\t}\n\n\ttemplate <typename Vec> static int get_size(const Vec& v) { using std::size; return int(size(v)); }\n\npublic:\n\tRangeMinQuery() {}\n\ttemplate <typename Vec> explicit RangeMinQuery(const Vec& data_, const Compare& comp_ = Compare())\n\t\t: Compare(comp_)\n\t\t, n(get_size(data_))\n\t\t, data(n)\n\t\t, pref_data(n)\n\t\t, suff_data(n)\n\t\t, sparse_table(sparse_table_size())\n\t\t, range_mask(n)\n\t{\n\t\tfor (int i = 0; i < n; i++) data[i] = data_[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tuint32_t m = range_mask[i-1];\n\t\t\t\twhile (m && !Compare::operator()(data[(i | (BUCKET_SIZE-1)) - __builtin_clz(m)], data[i])) {\n\t\t\t\t\tm -= uint32_t(1) << (BUCKET_SIZE - 1 - __builtin_clz(m));\n\t\t\t\t}\n\t\t\t\tm |= uint32_t(1) << (i & (BUCKET_SIZE - 1));\n\t\t\t\trange_mask[i] = m;\n\t\t\t} else {\n\t\t\t\trange_mask[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpref_data[i] = data[i];\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tsetmin(pref_data[i], pref_data[i-1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tsuff_data[i] = data[i];\n\t\t\tif (i+1 < n && ((i+1) & (BUCKET_SIZE-1))) {\n\t\t\t\tsetmin(suff_data[i], suff_data[i+1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < num_buckets(); i++) {\n\t\t\tsparse_table[i * num_levels()] = data[i * BUCKET_SIZE];\n\t\t\tfor (int v = 1; v < BUCKET_SIZE; v++) {\n\t\t\t\tsetmin(sparse_table[i * num_levels()], data[i * BUCKET_SIZE + v]);\n\t\t\t}\n\t\t}\n\t\tfor (int l = 0; l+1 < num_levels(); l++) {\n\t\t\tfor (int i = 0; i + (1 << (l+1)) <= num_buckets(); i++) {\n\t\t\t\tsparse_table[(l+1) + i * num_levels()] = min(sparse_table[l + i * num_levels()], sparse_table[l + (i + (1 << l)) * num_levels()]);\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int l, int r) const {\n\t\tassert(l <= r);\n\t\tint bucket_l = (l >> BUCKET_SIZE_LOG);\n\t\tint bucket_r = (r >> BUCKET_SIZE_LOG);\n\t\tif (bucket_l == bucket_r) {\n\t\t\tuint32_t msk = range_mask[r] & ~((uint32_t(1) << (l & (BUCKET_SIZE-1))) - 1);\n\t\t\tint ind = (l & ~(BUCKET_SIZE-1)) + __builtin_ctz(msk);\n\t\t\treturn data[ind];\n\t\t} else {\n\t\t\tT ans = min(suff_data[l], pref_data[r]);\n\t\t\tbucket_l++;\n\t\t\tif (bucket_l < bucket_r) {\n\t\t\t\tint level = (32 - __builtin_clz(bucket_r - bucket_l)) - 1;\n\t\t\t\tsetmin(ans, sparse_table[level + bucket_l * num_levels()]);\n\t\t\t\tsetmin(ans, sparse_table[level + (bucket_r - (1 << level)) * num_levels()]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, Q; cin >> N >> Q;\n\tvector<vector<int>> adj(N);\n\tfor (int e = 0; e < N-1; e++) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tvector<int> depth(N);\n\tvector<int> preorder_idx(N);\n\tvector<pair<int, int>> preorder_lcas(N-1);\n\tint cur_idx = 0;\n\tstd::y_combinator([&](auto self, int cur, int prv = -1) -> void {\n\t\tdepth[cur] = (prv == -1 ? 0 : depth[prv] + 1);\n\t\tpreorder_idx[cur] = cur_idx;\n\t\tcur_idx++;\n\t\tfor (int nxt : adj[cur]) {\n\t\t\tif (nxt == prv) continue;\n\t\t\tpreorder_lcas[cur_idx-1] = max(preorder_lcas[cur_idx-1], {depth[cur], cur});\n\t\t\tself(nxt, cur);\n\t\t}\n\t})(0);\n\n\tRangeMinQuery<pair<int, int>> lca_rmq(preorder_lcas);\n\n\tauto lca = [&](int a, int b) {\n\t\tif (a == b) return a;\n\t\ta = preorder_idx[a];\n\t\tb = preorder_idx[b];\n\t\tif (a > b) swap(a, b);\n\t\treturn lca_rmq.query(a, b-1).second;\n\t};\n\n\tauto dist = [&](int a, int b) {\n\t\treturn depth[a] + depth[b] - 2 * depth[lca(a,b)];\n\t};\n\n\tusing path_t = pair<int, int>;\n\n\tauto closest_pt = [&](int a, path_t p) {\n\t\tint c = lca(p.first, p.second);\n\t\tint x = lca(a, p.first);\n\t\tint y = lca(a, p.second);\n\t\treturn max({c,x,y}, [&](int u, int v) { return depth[u] < depth[v]; });\n\t};\n\n\t// If radius = 0, the path represents the set of centers; otherwise, it represents some diameter\n\tusing diam_t = pair<int, path_t>;\n\tdiam_t NO_DIAM{int(1e9), path_t{-1, -1}};\n\n\tauto build_diam = [&](int a, int b) -> diam_t {\n\t\treturn {dist(a,b), {a,b}};\n\t};\n\n\tauto update_diam = [&](diam_t d, path_t a) -> diam_t {\n\t\tif (d == NO_DIAM) return {0, a};\n\t\tint x = closest_pt(d.second.first, a);\n\t\tint y = closest_pt(d.second.second, a);\n\t\tif (x != y) {\n\t\t\tif (d.first == 0) {\n\t\t\t\treturn {0, {x, y}};\n\t\t\t} else {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\tassert(x == y);\n\t\tif (d.first == 0) {\n\t\t\tint z = closest_pt(x, d.second);\n\t\t\treturn build_diam(x, z);\n\t\t} else {\n\t\t\treturn max({d, build_diam(d.second.first, x), build_diam(d.second.second, x)});\n\t\t}\n\t};\n\n\tset<pair<path_t, int>> alive;\n\tvector<vector<path_t>> ops(2*Q);\n\tvector<int> queries(Q, -1);\n\n\tfor (int q = 0; q < Q; q++) {\n\t\tint op; cin >> op;\n\t\tif (op == 1 || op == 2) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tif (u > v) swap(u, v);\n\t\t\tpath_t path(u, v);\n\t\t\tif (op == 1) {\n\t\t\t\talive.insert({path, q});\n\t\t\t} else {\n\t\t\t\tauto it = alive.lower_bound({path, -1});\n\t\t\t\tassert(it != alive.end() && it->first == path);\n\t\t\t\tint t0 = it->second;\n\t\t\t\talive.erase(it);\n\n\t\t\t\tfor (int a = Q+t0, b = Q+q; a < b; a >>= 1, b >>= 1) {\n\t\t\t\t\tif (a & 1) ops[a++].push_back(path);\n\t\t\t\t\tif (b & 1) ops[--b].push_back(path);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (op == 3) {\n\t\t\tint d; cin >> d;\n\t\t\tqueries[q] = d * 2;\n\t\t} else assert(false);\n\t}\n\tfor (auto it : alive) {\n\t\tint t0 = it.second;\n\t\tpath_t path = it.first;\n\t\tfor (int a = Q+t0, b = Q+Q; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) ops[a++].push_back(path);\n\t\t\tif (b & 1) ops[--b].push_back(path);\n\t\t}\n\t}\n\n\tvector<int> actual_diam(Q);\n\tstd::y_combinator([&](auto self, int a, diam_t d) -> void {\n\t\tfor (path_t p : ops[a]) {\n\t\t\td = update_diam(d, p);\n\t\t}\n\t\tif (a >= Q) {\n\t\t\tactual_diam[a-Q] = d.first;\n\t\t} else {\n\t\t\tself(2*a, d);\n\t\t\tself(2*a+1, d);\n\t\t}\n\t})(1, NO_DIAM);\n\n\tfor (int q = 0; q < Q; q++) {\n\t\tif (queries[q] == -1) continue;\n\t\tcout << (actual_diam[q] <= queries[q] ? \"Yes\" : \"No\") << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. My Beautiful Madness.json",
    "editorial_link": "https://codeforces.com//blog/entry/85792",
    "editorial": "When I write \"a vertex at a distance up from the given\", I mean such a\r\nvertex, if it exists; otherwise the root of the tree.Let\u00e2\u0080\u0099s learn how to\r\nanswer the query of whether the intersection of -neighborhoods of all\r\npaths is empty. For a given path is a vertex at a distance up from the\r\nLCA of this path.Lemma: if the intersection is non-empty, then the\r\ndeepest vertex is included in it.Proof: let the intersection be\r\nnon-empty, and the deepest vertex (let\u00e2\u0080\u0099s call it ) is not included in\r\nthe intersection. The path that spawned is located along with the\r\nneighborhood in \u00e2\u0080\u0099s subtree. is not included in the intersection, so\r\nthere is some path whose neighborhood does not contain v. Note that it\r\ncannot be in the subtree of , since then its vertex would be deeper than\r\n; hence it lies outside the subtree with the neighborhood, hence the\r\nintersection of all neighborhoods is empty. Contradiction.This knowledge\r\nallows us to check if the intersection is empty by checking if one\r\nparticular vertex lies in the intersection (for a query, recognizing is\r\neasy if we maintain a set of LCA of paths from P, ordered by depth). Let\r\nbe a vertex at a distance above . First, a necessary condition: for each\r\npath from , the subtree of contains at least one end. Let\u00e2\u0080\u0099s implement it\r\nlike this: when the path comes, we do , , . Now the sum of in a subtree\r\nof a vertex is the number of ends of different paths in it.Now we know\r\nfor sure that there is no path that lies strictly outside the subtree,\r\nthat is, all paths for which LCA is outside the subtree of pass through\r\n, and hence lies in their -neighborhood. The only remaining paths to\r\ncheck are those in the subtree. The shortest distance from to such paths\r\nis the distance to their (this is not true if the lies on the path , but\r\nthis path itself has length and we will definitely reach such from ).We\r\ngot the following task about processing queries on a tree: among the\r\nvertices of the given subtree with , find the farthest from the given\r\nvertex (also contained in this subtree) This one can be solved using HLD\r\nin , I recommend referring to the code.\r\n"
}