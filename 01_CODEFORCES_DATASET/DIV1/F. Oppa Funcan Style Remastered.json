{"link": "https://codeforces.com//contest/986/problem/F", "problemId": "186086", "problem_idx": "F", "shortId": "986F", "contest_number": "986", "problem_submissions": {"D": [42104811, 42104792, 42104740, 42104337, 42103931, 42103877, 42103819, 42103728, 42103430, 42103363, 42090622, 42090614, 42090469, 42090439, 42090421, 42090403, 42090387, 38733857, 38748243, 38741625, 38744949, 38732535, 38776124, 38775923, 73829906, 48935186, 46682125, 38947315, 38947302, 38947285, 38946968, 38946777, 38946767, 38946516, 38946375, 38946181, 38944862, 38944853, 38944843, 38944833, 38944826, 38944784, 38944707, 38944667, 38944627, 38903696, 38903692, 38903690, 38903603, 38903544, 38903533, 38903435, 38903221, 38903111, 38903010, 38902730, 38902722, 38902698, 38868689, 38868687, 38868625, 38868606, 38868604, 38868564, 38868475, 38868474, 38868436, 38868410, 38868378, 38868342, 38868314, 38868268, 38868265, 38868261, 38868236, 38868233, 38868218, 38868215, 38868193, 38868187, 38868182, 38868177, 38868174, 38868170, 38868106, 38868104, 38868091, 38868070, 38868066, 38868064, 38868060, 38868052, 38868048, 38868019, 38868012, 38868008, 38868002, 38783809, 38783797, 38783781, 38783746, 38783741, 38783462, 38783445, 38780380, 38776796, 38776020, 38776009, 38775996, 38775983, 38775959, 38774927, 38774159, 38774142, 38774133, 38774083, 38772484, 38772455, 38772446, 38772398, 38772056, 38771982, 38771852, 38771749, 38771473, 38770302, 38770261, 38758325, 38743969, 38775097, 38775073, 38775025, 38774686, 38769151], "E": [38747055, 38738177, 38746661, 38745236, 38748676, 38751753, 38745180, 38747262, 38746823, 38745830, 38751939, 38740507, 38750013, 38749870, 38752411, 38979399, 38747190, 38753936, 38746328, 42589039, 38781799, 38781783, 38752251, 38750400, 38738811, 38743630], "F": [38743952, 38741619, 38749997, 38752035, 38759153, 38766951, 38747287, 38803173, 38802767], "C": [38736843, 38745069, 38732331, 38733537, 38731636, 38741009, 38735527, 38733610, 38737347, 38735879, 38747912, 38735093, 38731137, 38747956, 38732967, 38749305, 38742224, 38742550, 38745758, 38746063], "B": [38727078, 38726856, 38726789, 38729993, 38726090, 38734230, 38728365, 38728016, 38727081, 38728548, 38726100, 38728328, 38735514, 38726544, 38737280, 38727906, 38727500, 38748980, 38769342], "A": [38722963, 38723690, 38723235, 38724127, 38723622, 38736390, 38723609, 38724267, 38724018, 38725327, 38724685, 38725264, 38723597, 38724159, 38722907, 38723625, 38725178, 38724347, 38741266, 38724867]}, "name": "F. Oppa Funcan Style Remastered", "statement": "Surely you have seen insane videos by South Korean rapper PSY, such as\r\n\"Gangnam Style\", \"Gentleman\" and \"Daddy\". You might also hear that PSY\r\nhas been recording video \"Oppa Funcan Style\" two years ago\r\n(unfortunately we couldn\u2019t find it on the internet). We will remind you\r\nwhat this hit looked like (you can find original description here):On\r\nthe ground there are n platforms, which are numbered with integers from\r\n1 to n, on i-th platform there is a dancer with number i. Further, every\r\nsecond all the dancers standing on the platform with number i jump to\r\nthe platform with the number f(i). The moving rule f is selected in\r\nadvance and is not changed throughout the clip.The duration of the clip\r\nwas k seconds and the rule f was chosen in such a way that after k\r\nseconds all dancers were in their initial positions (i.e. the i-th\r\ndancer stood on the platform with the number i). That allowed to loop\r\nthe clip and collect even more likes.PSY knows that enhanced versions of\r\nold artworks become more and more popular every day. So he decided to\r\nrelease a remastered-version of his video.In his case \"enhanced version\"\r\nmeans even more insanity, so the number of platforms can be up to\r\n10^{18}! But the video director said that if some dancer stays on the\r\nsame platform all the time, then the viewer will get bored and will turn\r\noff the video immediately. Therefore, for all x from 1 to n f(x)\r\nneq x must hold.Big part of classic video\u2019s success was in that looping,\r\nso in the remastered version all dancers should return to their initial\r\npositions in the end of the clip as well.PSY hasn\u2019t decided on the exact\r\nnumber of platforms and video duration yet, so he asks you to check if\r\nthere is a good rule f for different options.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 29.05.2018 19:27:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long c) {\n  long long sign = 1;\n  if (a < 0) {\n    a = -a;\n    sign = -sign;\n  }\n  if (b < 0) {\n    b = -b;\n    sign = -sign;\n  }\n  a %= c;\n  b %= c;\n  long long res = 0;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res + a) % c;\n    }\n    a = (a + a) % c;\n    b >>= 1;\n  }\n  if (sign == -1) {\n    res = (-res) % c;\n  }\n  return res;\n}\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  T p = b / a;\n  T g = extgcd(b - p * a, a, y, x);\n  x -= p * y;\n  return g;\n}\n\ntemplate<typename T>\nbool diophantine(T a, T b, T c, T &x, T &y, T &g) {\n  if (a == 0 && b == 0) {\n    if (c == 0) {\n      x = y = g = 0;\n      return true;\n    }\n    return false;\n  }\n  if (a == 0) {\n    if (c % b == 0) {\n      x = 0;\n      y = c / b;\n      g = abs(b);\n      return true;\n    }\n    return false;\n  }\n  if (b == 0) {\n    if (c % a == 0) {\n      x = c / a;\n      y = 0;\n      g = abs(a);\n      return true;\n    }\n    return false;\n  }\n  g = extgcd(a, b, x, y);\n  if (c % g != 0) {\n    return false;\n  }\n  T dx = c / a;\n  c -= dx * a;\n  T dy = c / b;\n  c -= dy * b;\n  x = dx + mulmod(x, c / g, b);\n  y = dy + mulmod(y, c / g, a);\n  g = abs(g);\n  return true;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int MAX = (int) (sqrt(1e15) + 1e3);\n  vector<bool> is_prime(MAX, true);\n  for (int i = 2; i * i < MAX; i++) {\n    if (is_prime[i]) {\n      for (int j = i * i; j < MAX; j += i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n  vector<int> primes;\n  for (int i = 2; i < MAX; i++) {\n    if (is_prime[i]) {\n      primes.push_back(i);\n    }\n  }\n  int sz = (int) primes.size();\n  int tt;\n  cin >> tt;\n  vector<long long> ns(tt), ks(tt);\n  map<long long,vector<int>> mapik;\n  vector<int> res(tt, 0);\n  for (int i = 0; i < tt; i++) {\n    cin >> ns[i] >> ks[i];\n    mapik[ks[i]].push_back(i);\n  }\n  for (auto &p : mapik) {\n    long long k = p.first;\n    vector<long long> d;\n    {\n      long long tmp = k;\n      for (int it = 0; it < sz && (long long) primes[it] * primes[it] <= tmp; it++) {\n        if (tmp % primes[it] == 0) {\n          d.push_back(primes[it]);\n          while (tmp % primes[it] == 0) {\n            tmp /= primes[it];\n          }\n        }\n      }\n      if (tmp > 1) {\n        d.push_back(tmp);\n      }\n    }\n    if (d.size() == 0) {\n      continue;\n    }\n    if (d.size() == 1) {\n      for (int i : p.second) {\n        res[i] = (ns[i] % d[0] == 0);\n      }\n      continue;\n    }\n    if (d.size() == 2) {\n      for (int i : p.second) {\n        long long x, y, g;\n        if (diophantine(d[0], d[1], ns[i], x, y, g)) {\n          if (x >= 0 && y < 0) {\n            long long can_subtr = x / d[1];\n            long long need_add = ((-y) + d[0] - 1) / d[0];\n            if (can_subtr >= need_add) {\n              y = 0;\n            }\n          }\n          if (x < 0 && y >= 0) {\n            long long can_subtr = y / d[0];\n            long long need_add = ((-x) + d[1] - 1) / d[1];\n            if (can_subtr >= need_add) {\n              x = 0;\n            }\n          }\n          res[i] = (x >= 0 && y >= 0);\n        }\n      }\n      continue;\n    }\n    const long long inf = (long long) 2e18;\n    vector<long long> dist(d[0], inf);\n    priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > s;\n    dist[0] = 0;\n    s.emplace(dist[0], 0);\n    while (!s.empty()) {\n      long long expected = s.top().first;\n      int i = s.top().second;\n      s.pop();\n      if (dist[i] != expected) {\n        continue;\n      }\n      for (int it = 1; it < (int) d.size(); it++) {\n        int to = (int) ((i + d[it]) % d[0]);\n        if (dist[i] + d[it] < dist[to]) {\n          dist[to] = dist[i] + d[it];\n          s.emplace(dist[to], to);\n        }\n      }\n    }\n    for (int i : p.second) {\n      res[i] = (ns[i] >= dist[ns[i] % d[0]]);\n    }\n  }\n  for (int i = 0; i < tt; i++) {\n    cout << (res[i] ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "math", "number theory", "shortest paths"], "dificulty": "3300", "interactive": false}