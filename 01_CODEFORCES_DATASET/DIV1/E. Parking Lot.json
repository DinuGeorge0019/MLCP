{
    "link": "https://codeforces.com//contest/480/problem/E",
    "problemId": "15742",
    "problem_idx": "E",
    "shortId": "480E",
    "contest_number": "480",
    "problem_submissions": {
        "E": [
            8311013,
            8313055,
            8314156,
            8325797,
            8315473,
            8325232,
            11709971,
            8353321
        ],
        "C": [
            8305908,
            8306095,
            8306489,
            8305168,
            8306046,
            8307120,
            8307521,
            8307102,
            8305050,
            8306309,
            8306145,
            8307452,
            8307404,
            8307470,
            8307938,
            8306829,
            8309720,
            8308359
        ],
        "A": [
            8304671,
            8302322,
            8301986,
            8303885,
            8302500,
            8302484,
            8302315,
            8302995,
            8305921,
            8302490,
            8302288,
            8303565,
            8303850,
            8303423,
            8302746,
            8302974,
            8303485,
            8317285
        ],
        "B": [
            8303927,
            8304607,
            8304712,
            8306656,
            8304745,
            8305167,
            8304670,
            8305422,
            8307631,
            8304999,
            8304658,
            8305487,
            8305732,
            8314422,
            8305673,
            8308163,
            8305105,
            8306250
        ],
        "D": [
            8310575,
            8311382,
            8313441,
            8312962,
            8315083,
            8315272,
            8314092,
            8316276,
            8315227,
            8311890,
            8317405,
            8315325,
            8316637
        ]
    },
    "name": "E. Parking Lot",
    "statement": "Petya’s been bored at work and he is killing the time by watching the\r\nparking lot at the office. The parking lot looks from above like an\r\ntable (a cell of the table corresponds to a single parking spot). Some\r\nspots in the parking lot are taken, others are empty.Petya watches cars\r\nriding into the parking lot one by one. After a car settles down at the\r\nparking spot, Petya amuzes himself by counting what maximum square of\r\nempty spots (i.e. a square subtable) can be seen on the parking lot if\r\nwe look at it from above. Also, he takes notes of the square’s size\r\n(side length) in his notebook. You task is: given the state of the\r\nparking lot at the initial moment of time and the information about\r\nwhere the arriving cars park, restore what Petya wrote in his notebook.\r\nIt is midday, so nobody leaves the lot.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic int N, M;\nstatic vector<string> grid;\nstatic vector<vi> nleft, nright;\n\nstatic void fix_row(int r)\n{\n    int last = -1;\n    for (int i = 0; i < M; i++)\n    {\n        if (grid[r][i] == 'X')\n            last = i;\n        nleft[r][i] = last;\n    }\n\n    last = M;\n    for (int i = M - 1; i >= 0; i--)\n    {\n        if (grid[r][i] == 'X')\n            last = i;\n        nright[r][i] = last;\n    }\n}\n\nstatic int best_col(int c)\n{\n    int best = 0;\n    int r0 = 0;\n    int r1 = r0;\n    deque<pii> left, right;\n    while (r0 < N)\n    {\n        if (r1 <= r0)\n        {\n            left.push_back(pii(r1, nleft[r1][c]));\n            right.push_back(pii(r1, nright[r1][c]));\n            r1++;\n        }\n        while (right[0].second - left[0].second - 1 > r1 - r0)\n        {\n            best = max(best, r1 - r0);\n            while (!left.empty() && nleft[r1][c] > left.back().second)\n                left.pop_back();\n            left.push_back(pii(r1, nleft[r1][c]));\n            while (!right.empty() && nright[r1][c] < right.back().second)\n                right.pop_back();\n            right.push_back(pii(r1, nright[r1][c]));\n            r1++;\n        }\n        best = max(best, right[0].second - left[0].second - 1);\n        r0++;\n        while (!left.empty() && left[0].first < r0)\n            left.pop_front();\n        while (!right.empty() && right[0].first < r0)\n            right.pop_front();\n    }\n    return best;\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int K;\n    cin >> N >> M >> K;\n    grid.clear();\n    grid.resize(N);\n    nleft.resize(N + 1, vi(M, -1));\n    nright.resize(N + 1, vi(M, M));\n    for (int i = 0; i < M; i++)\n    {\n        nleft[N][i] = M;\n        nright[N][i] = -1;\n    }\n\n    for (int i = 0; i < N; i++)\n        cin >> grid[i];\n\n    vector<pii> park;\n    for (int i = 0; i < K; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--;\n        y--;\n        grid[x][y] = 'X';\n        park.push_back(pii(x, y));\n    }\n\n    int cur = 0;\n    for (int i = 0; i < N; i++)\n        fix_row(i);\n    for (int i = 0; i < M; i++)\n        cur = max(cur, best_col(i));\n    vi ans(K);\n    ans[K - 1] = cur;\n    for (int i = K - 1; i > 0; i--)\n    {\n        int r, c;\n        tie(r, c) = park[i];\n        grid[r][c] = '.';\n        fix_row(r);\n        cur = max(cur, best_col(c));\n        ans[i - 1] = cur;\n    }\n    for (int v : ans)\n        cout << v << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Parking Lot.json",
    "editorial_link": "https://codeforces.com//blog/entry/14351",
    "editorial": "let s consider all empty\nsquare in the table. There a too many of them, but imagine that we can\nafford to loop through all of them. If we fix a square, we can find out\nwhen it is no longer empty: find the first event that belongs to this\nsquare. Let this event has number , and the size of the square is . Now\nwe can update the answers for all events with numbers less than with a\nvalue of . The model solution use the idea of Divide and Conquer. Let s\nmake a recursive routine that takes a rectangular sub-table, bounded\nwith (), and a list of events that happen inside this sub-table. The\npurpose of the routine is to consider how maximal empty squares in this\nsub-table change in time, and to update the answers for some of the\nevents. Let s assume that (the opposite case is symmetric). Take the\nmiddle row . Virtually split all the squares inside the sub-table into\nthose which lie above , those which lie below , and those which\nintersect . For the first two parts, make two recursive calls, splitting\nthe list of events as well. Now focus on the squares that intersect the\nrow . Using initial table, for each cell we can precompute the distance\nto the nearest taken cell in all four directions (or the distance to the\nborder, if there is no such cell): , , . Using this values, build two\nhistograms for the row : the first is an array of values , where ; the\nsecond is an array of values , where . I say histograms here, because\nthese arrays actually can be viewed as heights of empty columns,\npointing from the row upwards and downwards. Lets call the first\nhistogram upper , the second one lower . Now consider all events inside\nthe sub-table in the order they happen. Each event changes a single\nvalue in a histogram. If after some event the maximum empty square found\nin the histograms has size , and the next event has number , we can\nupdate answers for all events with numbers with the value of . It\nremains to learn to find a maximum square in two histograms. It can be\ndone by a two-pointer approach. Set both pointers to the beginning. Move\nthe second pointer until there is such square in histograms: there is a\nsquare with side length if (minimum on the interval in the upper\nhistogram) + (minimum on the interval in the upper histogram) 1 >= k.\nWhen the second pointer can not be moved any more, update the answer and\nmove the first pointer. To find the minimum in O(1), author s solution\ncreates a queue with minimum in O(1) support. That is, the maximum\nsquare can be found in linear time. Let s try to estimate the running\ntime. Each call of the routine (omitting inner calls) costs , where is\nthe shortest side of the sub-table, and is the number of events in it.\nIf we draw a recursion tree, we will see that each second call decreases\ntwice. The total cost of all operations in a single level of a recursion\ntree is , where is the total number of events. As long as we have ,\noverall complexity is .\n",
    "hint": []
}