{"link": "https://codeforces.com//contest/576/problem/D", "problemId": "34886", "problem_idx": "D", "shortId": "576D", "contest_number": "576", "problem_submissions": {"D": [12948640, 12948506, 12948354, 12937171, 12937633, 12940817, 12940388, 12940233, 12940092, 12939430, 12939063, 12935207, 12942962, 12940891, 12941506, 12939643, 12933648, 12943594], "C": [12932865, 12929775, 12930204, 12934079, 12931097, 12934157, 12932646, 12938006, 12960885, 12936499, 12932088, 12931162, 12933248, 12943319, 12926742, 12932751, 12928085, 12932873, 12935950], "B": [12930813, 12932445, 12933792, 12931978, 12932789, 12930228, 12930366, 12941663, 12931673, 12935038, 12935800, 12940912, 12931636, 12948000, 12937985, 12933306, 12935930, 12933037], "A": [12926373, 12925995, 12926783, 12926169, 12926245, 12926309, 12926740, 12939248, 12926537, 12926100, 12927525, 12926051, 12926418, 12928170, 12926649, 12926146, 12926053, 12936482], "E": [12958478, 12974224, 12948989, 13216883, 12944220]}, "name": "D. Flights for Regular Customers", "statement": "In the country there are exactly cities numbered with positive integers\r\nfrom to . In each city there is an airport is located.Also, there is the\r\nonly one airline, which makes flights. Unfortunately, to use them, you\r\nneed to be a regular customer of this company, namely, you have the\r\nopportunity to enjoy flight from city to city only if you have already\r\nmade at least flights before that.Please note that flight flies exactly\r\nfrom city to city . It can not be used to fly from city to city . An\r\ninteresting fact is that there may possibly be recreational flights with\r\na beautiful view of the sky, which begin and end in the same city.You\r\nneed to get from city to city . Unfortunately, you\u2019ve never traveled by\r\nplane before. What minimum number of flights you have to perform in\r\norder to get to city ?Note that the same flight can be used multiple\r\ntimes.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 151\nint n,m;\nstruct mac{\n  bitset<MAX> t[MAX];\n  void dod(int a,int b){\n    t[a][b] = 1;\n  }\n  mac(){};\n  mac(mac& a,mac& b){\n    R(i,n){\n      R(j,n){\n      if(a.t[i][j])\n        t[i] |= b.t[j];\n      }\n    }\n  }\n}ak,dm;\nvector<mac> lo;\nint t = 0;\nint odp(int i){\n  while(i){\n    i--;\n    mac kan(dm,lo[i]);\n    if(kan.t[0][n-1] == 0){\n      dm = kan;\n      t+=1<<i;\n    }\n  }\n  printf(\"%d\\n\",t+1);\n  exit(0);\n}\nvector<pair<int,PI> > w;\nvoid pot(int wyk){\n  lo.clear();\n  lo.PB(ak);\n  int i = 0;\n  while(wyk){\n    if(wyk&1){\n      mac kan(dm,lo[i]);\n      if(kan.t[0][n-1]){\n        odp(i);\n      }\n      dm = kan;\n      t+=1<<i;\n    }\n    wyk/=2;\n    lo.PB(mac(lo[i],lo[i]));\n    i++;\n  }\n}\nmain(){\n  make(n);\n  make(m);\n  ak.dod(n-1,n-1);\n  R(i,n){\n    dm.dod(i,i);\n  }\n  R(i,m){\n    int a,b,d;\n    make2(a,b);\n    a--;b--;\n    make(d);\n    w.PB({d,MP(a,b)});\n  }\n  sort(ALL(w));\n  int i = 0;\n  w.PB({(int)1e9+200,{0,0}});\n  while(i<m){\n    while(i < m && w[i].FI == t){\n      ak.dod(w[i].SE.FI,w[i].SE.SE);\n      i++;\n    }\n    pot(w[i].FI-t);\n  }\n  puts(\"Impossible\");\n}\n"], "input": "", "output": "", "tags": ["dp", "matrices"], "dificulty": "2700", "interactive": false}