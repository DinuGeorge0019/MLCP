{"link": "https://codeforces.com//contest/372/problem/D", "problemId": "4185", "problem_idx": "D", "shortId": "372D", "contest_number": "372", "problem_submissions": {"D": [5426977, 5430216, 5428682, 5430119, 5427511, 5430570, 5430674, 5430157, 5432457, 5430283, 5428509, 5431356, 5431746, 5438335, 5439009, 5430897, 5431697, 5427479, 5431615, 5437474], "C": [5425620, 5423917, 5425367, 5426752, 5429971, 5426458, 5425626, 5427101, 5430049, 5423463, 5427437, 5427041, 5428996, 5429237, 5430350, 5429420, 5425660, 5426153], "B": [5423489, 5421838, 5424137, 5424220, 5424353, 5423172, 5423669, 5423082, 5424372, 5425505, 5428480, 5425133, 5425580, 5425422, 5424402, 5431761, 5424978, 5423136, 5424295], "A": [5421957, 5420847, 5421730, 5421129, 5421031, 5420888, 5422498, 5422219, 5421566, 5422639, 5425833, 5421459, 5427633, 5423077, 5420877, 5428458, 5422847, 5420856, 5421782], "E": [5430957]}, "name": "D. Choosing Subtree is Fun", "statement": "There is a tree consisting of vertices. The vertices are numbered from\r\nto .Let\u2019s define the length of an interval as the value . The score of a\r\nsubtree of this tree is the maximum length of such an interval that, the\r\nvertices with numbers belong to the subtree.Considering all subtrees of\r\nthe tree whose size is at most , return the maximum score of the\r\nsubtree. Note, that in this problem tree is not rooted, so a subtree is\r\nan arbitrary connected subgraph of the tree.\r\n", "solutions": ["#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n//#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(int)n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ACCU accumulate\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<ll> VL;\nconst ll mod=1000000007;\nconst double eps=1e-9;\nconst double pi=acos(0)*2;\nll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nconst int N=201000;\nset<int> mp;\nint dep[N],f[N],F[N][20],id[N],cnt[N];\nint y[N],nxt[N],fst[N],tot,ans,n,k,u,v;\n\nvoid add(int u,int v) {tot++;y[tot]=v;nxt[tot]=fst[u];fst[u]=tot;}\nvoid dfs(int u,int p) { f[u]=p;id[cnt[u]=++tot]=u;\n\tfor (int j=fst[u];j;j=nxt[j]) if (y[j]!=p) dep[y[j]]=dep[u]+1,dfs(y[j],u);}\nint LCA(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tfor (int k=dep[v]-dep[u],j=17;j>=0;j--) if ((k>>j)&1) v=F[v][j],k^=(1<<j);\n\tif (u==v) return u;\n\tfor (int k=17;f[u]!=f[v];u=F[u][k],v=F[v][k]) for (;k && F[u][k]==F[v][k];k--);\n\treturn f[u];\n}\nvoid modify(char ch,int u) {\n\ttypeof(mp.begin()) it=mp.lower_bound(cnt[u]);\n\tif (*it==cnt[u]) mp.erase(cnt[u]),it=mp.lower_bound(cnt[u]);\n\tif (!mp.size()) {if (ch=='+') mp.insert(cnt[u]);return;}\n\tint q=id[(it==mp.end())?*mp.begin():*it],p=id[(it--==mp.begin())?*(--mp.end()):*it];\n\tint dt=dep[u]-dep[LCA(p,u)]-dep[LCA(q,u)]+dep[LCA(p,q)];\n\tif (ch=='+') ans+=dt,mp.insert(cnt[u]); else ans-=dt;\t\n}\nbool check(int v) {\n\tans=0;\n\tmp.clear();\n\trep(i,1,v) modify('+',i);\n\trep(i,v,n+1) {\n\t\tmodify('+',i);\n\t\tif (ans+1<=k) return 1;\n\t\tmodify('-',i+1-v);\n\t}\n\treturn 0;\n} \nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,1,n) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\ttot=0;dfs(1,0);id[n+1]=n+1;\n\trep(i,1,n+1) F[i][0]=f[i];\n\trep(j,1,18) rep(i,1,n+1) F[i+1][j]=F[F[i+1][j-1]][j-1];\n\tint l=1,r=n+1;\n\twhile (l+1<r) {\n\t\tint md=(l+r)>>1;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tprintf(\"%d\\n\",l);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dfs and similar", "trees", "two pointers"], "dificulty": "2600", "interactive": false}