{"link": "https://codeforces.com//contest/364/problem/B", "problemId": "4042", "problem_idx": "B", "shortId": "364B", "contest_number": "364", "problem_submissions": {"E": [5182930, 5182917, 5182805, 5182789, 5182779, 5163338, 5192424, 5192315, 5285842], "C": [5159826, 5156914, 5156913, 5159036, 5158199, 5156857, 5160288, 5159437, 5160554, 5160938, 5160044, 5162865, 5159797, 5161370], "B": [5155945, 5152807, 5153694, 5154783, 5155872, 5158323, 5155584, 5154573, 5157525, 5158221, 5171150, 5155541, 5157687, 5162725, 5157104], "A": [5151035, 5151153, 5151193, 5150604, 5151593, 5151967, 5152019, 5151677, 5154003, 5153612, 5152606, 5154441, 5150915, 5155034], "D": [5159378, 5164152, 5164129, 5165101, 26468599, 26468582, 26468554, 5164765, 5178204, 5178186, 5165121, 5171056, 5929384, 5343038]}, "name": "B. Free Market", "statement": "John Doe has recently found a \"Free Market\" in his city that is the\r\nplace where you can exchange some of your possessions for other things\r\nfor free. John knows that his city has items in total (each item is\r\nunique). You can bring any number of items to the market and exchange\r\nthem for any other one. Note that each item is one of a kind and that\r\nmeans that you cannot exchange set for set . However, you can always\r\nexchange set for any set , unless there is item , such that occurs in\r\nand occurs in .For each item, John knows its value . John\u2019s sense of\r\njustice doesn\u2019t let him exchange a set of items for a set of items , if\r\n( is the total price of items in the set ). During one day John can\r\nexchange only one set of items for something else. Initially, he has no\r\nitems. John wants to get a set of items with the maximum total price.\r\nFind the cost of such set and the minimum number of days John can get it\r\nin.\r\n", "solutions": ["#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define REPC(I, C) for (int I = 0; !(C); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\nconst int SIZE = 500010;\nint dp[SIZE+1];\nint BIT[SIZE+1];\nvoid insert(int x,int v){\n    while(x<SIZE+1){\n        BIT[x]=min(BIT[x],v);\n        x+=x&-x;\n    }\n}\nint qq(int x){\n    int res=(int)1e9;\n    while(x){\n        res=min(res,BIT[x]);\n        x-=x&-x;\n    }\n    return res;\n}\nint main(){\n    int up=SIZE;\n    dp[SIZE]=1;\n    for(int i=0;i<=SIZE;i++)BIT[i]=(int)1e9;\n    DRII(n,d);\n    REP(i,n){\n        DRI(x);\n        for(int j=up;j<=SIZE;j++){\n            if(dp[j])dp[j-x]=1;\n        }\n        up-=x;\n    }\n    insert(SIZE,0);\n    int an1=0,an2=0;\n    for(int i=SIZE-1;i>0;i--){\n        if(!dp[i])continue;\n        int tmp=qq(min(SIZE,i+d));\n        if(tmp<(int)1e9){\n            an1=SIZE-i;\n            an2=tmp+1;\n            insert(i,tmp+1);\n        }\n    }\n    printf(\"%d %d\\n\",an1,an2);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy"], "dificulty": "2200", "interactive": false}