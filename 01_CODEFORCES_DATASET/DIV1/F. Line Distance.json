{"link": "https://codeforces.com//contest/1446/problem/F", "problemId": "797261", "problem_idx": "F", "shortId": "1446F", "contest_number": "1446", "problem_submissions": {"D2": [98488179, 98479602, 98464320, 98467493, 98464495, 98464291, 98477056, 98482171, 98496133, 98469225, 98470769, 98488185, 98481918, 98482926, 98479038], "F": [98482236, 98470414, 98500090, 98497700, 98476856, 98476210, 98484136, 98489678, 98481827, 98491554, 98484171, 98504348, 98502497, 98493379, 98482100, 98486768, 98492674, 98490163, 98501084], "E": [98475344, 98498258, 98500804, 98495217, 115705388, 106404746], "D1": [98457158, 98460382, 98456556, 98456978, 98464440, 98464426, 98466567, 98470196, 98464176, 98472990, 98478320, 98479479, 98482287, 98493368, 98460232, 98466662, 98460275, 98466691, 98472979, 98478998], "C": [98450996, 98452840, 98450218, 98453943, 98450946, 98452214, 98452223, 98455447, 98455497, 98455239, 98461758, 98461392, 98466665, 98466780, 98453580, 98454283, 98455611, 98457408, 98454698, 98458074], "B": [98446682, 98448334, 98447974, 98447142, 98452896, 98448193, 98448567, 98451491, 98449697, 98450934, 98454616, 98452183, 98446811, 98455267, 98447295, 98450250, 98449344, 98450158, 98450376, 98449480], "A": [98444992, 98445944, 98444925, 98445065, 98445347, 98445666, 98444771, 98446535, 98446420, 98447534, 98447441, 98445935, 98450208, 98461593, 98445099, 98445257, 98445487, 98446333, 98447509, 98445254]}, "name": "F. Line Distance", "statement": "You are given an integer k and n distinct points with integer\r\ncoordinates on the Euclidean plane, the i-th point has coordinates (x_i,\r\ny_i).Consider a list of all the\r\nfrac{n(n - 1)}{2} pairs of points ((x_i, y_i), (x_j, y_j)) (1\r\nle i < j\r\nle n). For every such pair, write out the distance from the line through\r\nthese two points to the origin (0, 0).Your goal is to calculate the k-th\r\nsmallest number among these distances.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst double PI = 4 * atan(1.);\n\nconst int IT = 80;\nconst double INF = 2e4;\nconst int N = 200100;\nint n;\ndouble a[N][2];\nint b[N][2];\npair<double, int> ord[N];\nint m;\n\n\nstruct Fenwick {\n\tvector<int> fenv;\n\n\tFenwick() : fenv() {}\n\tFenwick(int n) : fenv(vector<int>(n, 0)) {}\n\n\tvoid add(int p, int x) {\n\t\tfor(; p < (int)fenv.size(); p |= p + 1)\n\t\t\tfenv[p] += x;\n\t}\n\tint get(int r) {\n\t\tint res = 0;\n\t\tfor(; r >= 0; r = (r & (r + 1)) - 1)\n\t\t\tres += fenv[r];\n\t\treturn res;\n\t}\n\tint getSum(int l, int r) {\n\t\tif (l >= r) return 0;\n\t\treturn get(r - 1) - get(l - 1);\n\t}\n} fenv;\n\ndouble normAng(double ang) {\n\twhile(ang >= 2 * PI) ang -= 2 * PI;\n\twhile(ang < 0) ang += 2 * PI;\n\treturn ang;\n}\n\nll solve(double R) {\n//\tprintf(\"solve %.5lf\\n\", R);\n\tm = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble L = sqrt(a[i][0] * a[i][0] + a[i][1] * a[i][1]);\n\t\tif (L <= R) continue;\n\t\tm++;\n\t\tdouble ang = atan2(a[i][1], a[i][0]);\n\t\tdouble phi = acos(R / L);\n//\t\tprintf(\"%.5lf %.5lf\\n\", ang, phi);\n\t\tord[2 * m - 2] = mp(normAng(ang - phi), -m);\n\t\tord[2 * m - 1] = mp(normAng(ang + phi), m);\n\t}\n\tsort(ord, ord + 2 * m);\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tint v = ord[i].second;\n\t\tif (v < 0) {\n\t\t\tb[-v][0] = i;\n\t\t} else {\n\t\t\tb[v][1] = i;\n\t\t}\n\t}\n\tfenv = Fenwick(2 * m);\n\tfor (int i = 1; i <= m; i++) {\n//\t\tprintf(\"%d %d\\n\", b[i][0], b[i][1]);\n\t\tif (b[i][0] > b[i][1])\n\t\t\tfenv.add(b[i][0], 1);\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < 2 * m; i++) {\n\t\tint v = ord[i].second;\n\t\tif (v < 0) {\n\t\t\tv *= -1;\n\t\t\t\n\t\t\tfenv.add(i, 1);\n\t\t} else {\n\n\t\t\tfenv.add(b[v][0], -1);\n\t\t\tif (b[v][0] < b[v][1]) {\n\t\t\t\tans += fenv.getSum(b[v][0], b[v][1]);\n\t\t\t} else {\n\t\t\t\tans += fenv.getSum(b[v][0], 2 * m) + fenv.getSum(0, b[v][1]);\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"ans = %lld\\n\", ans);\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tll k;\n\tscanf(\"%d%lld\", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tscanf(\"%lf\", &a[i][j]);\n\tdouble l = 0, r = INF;\n//\tsolve(0.5);\n\tfor (int it = 0; it < IT; it++) {\n\t\tdouble x = (l + r) / 2;\n\t\tll z = solve(x);\n\t\tif (k + z > (ll)n * (n - 1) / 2)\n\t\t\tl = x;\n\t\telse\n\t\t\tr = x;\n\t}\n\tprintf(\"%.15lf\\n\", l);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "geometry"], "dificulty": "3200", "interactive": false}