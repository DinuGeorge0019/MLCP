{
    "link": "https://codeforces.com//contest/866/problem/F",
    "problemId": "125345",
    "problem_idx": "F",
    "shortId": "866F",
    "contest_number": "866",
    "problem_submissions": {
        "G": [
            48042764,
            48042747,
            48042330,
            48042234,
            48042200,
            30882226,
            30888984,
            57250068
        ],
        "D": [
            31044799,
            30877994,
            30876120,
            30879768,
            30877841,
            30935417,
            30935391,
            30878366,
            82427005,
            30877626,
            30880014,
            30879034,
            30880919,
            30880306,
            30879681,
            30881205,
            30880292,
            30878146,
            30881085,
            30880894
        ],
        "F": [
            30883978,
            30915539,
            30915526,
            30915506,
            30915496,
            30915492,
            30915483,
            30915431,
            30915401,
            30915351,
            30915334,
            30888671,
            30882806,
            57257664
        ],
        "C": [
            30875892,
            30877179,
            30883361,
            30877278,
            30966883,
            30966734,
            30935175,
            30876872,
            30891743,
            30891736,
            30880301,
            30877644,
            30878514,
            30877044,
            30878539,
            30877470,
            30877525,
            30878653,
            30881355,
            30877891,
            31274174,
            30878115
        ],
        "B": [
            30874326,
            30883354,
            30901870,
            30876267,
            30875622,
            30878803,
            30876656,
            30875923,
            30874820,
            30876008,
            30875772,
            30876212,
            30875972,
            30876853,
            30876928,
            30876128,
            30876479
        ],
        "A": [
            30872518,
            30872539,
            30872760,
            30872739,
            30875884,
            30873740,
            30872744,
            30872982,
            30875680,
            30874617,
            30872755,
            30881297,
            30873075,
            30873379,
            30873703,
            30873164,
            30874384
        ],
        "E": [
            30957127,
            30884728,
            30888758,
            30909701
        ]
    },
    "name": "F. Egg Roulette",
    "statement": "The game of Egg Roulette is played between two players. Initially raw\r\neggs and cooked eggs are placed randomly into a carton. The shells are\r\nleft on so there is no way to distinguish a raw egg from a cooked egg.\r\nOne at a time, a player will select an egg, and then smash the egg on\r\nhis/her forehead. If the egg was cooked, not much happens, but if the\r\negg was raw, it will make quite the mess. This continues until one\r\nplayer has broken raw eggs, at which point that player is declared the\r\nloser and the other player wins.The order in which players take turns\r\ncan be described as a string of ” and ” characters, where the -th\r\ncharacter tells which player should choose the -th egg. Traditionally,\r\nplayers take turns going one after the other. That is, they follow the\r\nordering \"\". This isn’t very fair though, because the second player will\r\nwin more often than the first. We’d like you to find a better ordering\r\nfor the players to take their turns. Let’s define the unfairness of an\r\nordering as the absolute difference between the first player’s win\r\nprobability and the second player’s win probability. We’re interested in\r\norderings that minimize the unfairness. We only consider an ordering\r\nvalid if it contains the same number of ”s as ”s.You will also be given\r\na string of length containing only ”, ”, and ” characters. An ordering\r\nis said to match if it only differs from in positions where contains a\r\n”. Of the valid orderings that minimize unfairness, how many match ?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.09.2017 21:16:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long C[777][777];\n\nint r, c;\nlong long total;\nlong long best = (long long) 1e18, best_z = -1;\n\nvoid dfs(long long x, long long y, int v1, int v2) {\n  long long diff = abs(x - y);\n  if (best <= 1 || diff - C[v1][r] * C[v2][r] >= best) {\n    return;\n  }\n  if (v1 == r - 1 && v2 == r - 1) {\n    long long diff = abs(x - y);\n    if (diff < best) {\n      best = diff;\n      best_z = x;\n    }\n    return;\n  }\n  if (v1 >= r) {\n    long long cur1 = C[v1][r] - C[v1 - 1][r];\n    long long sum2 = C[v2][r];\n    dfs(x, y + cur1 * sum2, v1 - 1, v2);\n  }\n  if (v2 >= r) {\n    long long sum1 = C[v1][r];\n    long long cur2 = C[v2][r] - C[v2 - 1][r];\n    dfs(x + sum1 * cur2, y, v1, v2 - 1);\n  }\n}\n\nchar s[12345];\nint cntA[12345], cntB[12345];\nmap<long long, long long> mp;\n\nlong long solve(long long x, long long y, int v1, int v2) {\n  long long state = x * 10000 + v1 * 100 + v2;\n  if (mp.find(state) != mp.end()) {\n    return mp[state];\n  }\n  long long &res = mp[state];\n  long long diff = abs(x - y);\n  if (diff - C[v1][r] * C[v2][r] > best) {\n    return res = 0;\n  }\n  if (v1 < r || v2 < r) {\n    if (v1 >= cntA[v1 + v2] && v2 >= cntB[v1 + v2]) {\n      int sum = v1 + v2;\n      v1 -= cntA[sum];\n      v2 -= cntB[sum];\n      return res = C[v1 + v2][v1]; \n    }\n    return res = 0;\n  }\n  res = 0;\n  char c = s[v1 + v2 - 1];\n  if (c != 'B') {\n    long long cur1 = C[v1][r] - C[v1 - 1][r];\n    long long sum2 = C[v2][r];\n    res += solve(x, y + cur1 * sum2, v1 - 1, v2);\n  }\n  if (c != 'A') {\n    long long sum1 = C[v1][r];\n    long long cur2 = C[v2][r] - C[v2 - 1][r];\n    res += solve(x + sum1 * cur2, y, v1, v2 - 1);\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d %d\", &r, &c);\n  for (int i = 0; i <= 2 * (r + c); i++) {\n    for (int j = 0; j <= 2 * (r + c); j++) {\n      if (j == 0) C[i][j] = 1; else\n      if (i == 0) C[i][j] = 0;\n      else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]);\n    }\n  }\n  total = C[r + c][r] * C[r + c][r];\n  {\n    long long x = 0, y = 0;\n    int v1 = r + c, v2 = r + c;\n    while (v1 >= r && v2 >= r) {\n      if (x > y) {\n        long long cur1 = C[v1][r] - C[v1 - 1][r];\n        long long sum2 = C[v2][r];\n        y += cur1 * sum2;\n        v1--;\n      } else {\n        long long sum1 = C[v1][r];\n        long long cur2 = C[v2][r] - C[v2 - 1][r];\n        x += sum1 * cur2;\n        v2--;\n      }\n    }\n    best = abs(x - y);\n  }\n  dfs(0, 0, r + c, r + c);\n  scanf(\"%s\", s);\n  cntA[0] = cntB[0] = 0;\n  for (int i = 0; i < 2 * (r + c); i++) {\n    cntA[i + 1] = cntA[i] + (s[i] == 'A');\n    cntB[i + 1] = cntB[i] + (s[i] == 'B');\n  }\n  long long ans = solve(0, 0, r + c, r + c);\n  cout << ans << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "meet-in-the-middle"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Egg Roulette.json",
    "editorial_link": "https://codeforces.com//blog/entry/54888",
    "editorial": "We can permute any prefix of an ordering containing at most R?-?1 'A's or R?-?1 'B's without changing the unfairness. This is because within that prefix one of the players cannot lose the game. This means that every ordering there is a unique ordering with the same unfairness that begins with exactly R?-?1 'A's followed by R?-?1 'B's and can be obtained by permuting such a prefix. Let's call this the canonical form of an ordering.\n\nTo search for canonical forms, we need to consider the remaining 2?*?(C?+?1) turns. The constraints set this to at most 42, so we can split it into two halves, compute every possible ordering for the left C?+?1 turns and right C?+?1 turns, then use a meet-in-the-middle algorithm to find those that minimize unfairness.\n\nFor each ordering in each half, we also need to compute how many corresponding orderings match the given string S. For the right half this is easy - every ordering either matches once or not at all. For the left half we have to consider non-canonical orderings. To compute this, we first need to find the longest prefix of the ordering that can be permuted. This is the longest prefix where every turn is the same as the first turn. Then we need to count how many 'A' and 'B' characters are in the ordering within that prefix, and how many 'A' and 'B' characters are in S within that prefix. If there are more 'A' or 'B' characters in S than the ordering, there are zero matches, otherwise the number of matches is given by a binomial coefficient.",
    "hint": []
}