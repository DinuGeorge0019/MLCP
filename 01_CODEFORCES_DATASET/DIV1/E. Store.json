{
    "link": "https://codeforces.com//contest/1010/problem/E",
    "problemId": "201806",
    "problem_idx": "E",
    "shortId": "1010E",
    "contest_number": "1010",
    "problem_submissions": {
        "B": [
            40799404,
            40801993,
            40788669,
            40787652,
            40789673,
            40789686,
            40789983,
            40785033,
            40792839,
            40805864,
            40788811,
            40787383,
            40789849,
            40789369,
            40787726,
            40805158,
            40792120,
            40788528
        ],
        "E": [
            40798849,
            40800058,
            40798099,
            40803219,
            40808162,
            40803215,
            40805435,
            40803779,
            40802990,
            40802895,
            40802904,
            40807344,
            40809272,
            40807596,
            40809118,
            40796705,
            40826253,
            40825565,
            40825440,
            40825326,
            40820969,
            40809148,
            40810854
        ],
        "D": [
            40790648,
            40792110,
            40793613,
            40792349,
            40794914,
            40795576,
            40794812,
            40796573,
            40795996,
            40791327,
            40795441,
            40794120,
            40793973,
            40796503,
            40791721,
            40802197,
            40794990,
            40796187
        ],
        "C": [
            40786265,
            40787662,
            40789931,
            40785223,
            40786749,
            40786331,
            40785962,
            40786363,
            40790435,
            40784715,
            40788036,
            40789805,
            40785906,
            40791178,
            40784561,
            40799332,
            40788152,
            40791287
        ],
        "A": [
            40783437,
            40783575,
            40783713,
            40784110,
            40784394,
            40784590,
            40783557,
            40784035,
            40783594,
            40783743,
            40791154,
            40783813,
            40784202,
            40785469,
            40783661,
            40798279,
            40784877,
            40785930
        ],
        "F": [
            40820195,
            40821625,
            40821278,
            40814070,
            40812966,
            47670616
        ]
    },
    "name": "E. Store",
    "statement": "Natasha was already going to fly back to Earth when she remembered that\r\nshe needs to go to the Martian store to buy Martian souvenirs for her\r\nfriends.It is known, that the Martian year lasts x_{max} months, month\r\nlasts y_{max} days, day lasts z_{max} seconds. Natasha also knows that\r\nthis store works according to the following schedule: 2 months in a year\r\nwere selected: x_l and x_r (1\r\nle x_l\r\nle x_r\r\nle x_{max}), 2 days in a month: y_l and y_r (1\r\nle y_l\r\nle y_r\r\nle y_{max}) and 2 seconds in a day: z_l and z_r (1\r\nle z_l\r\nle z_r\r\nle z_{max}). The store works at all such moments (month x, day y, second\r\nz), when simultaneously x_l\r\nle x\r\nle x_r, y_l\r\nle y\r\nle y_r and z_l\r\nle z\r\nle z_r.Unfortunately, Natasha does not know the numbers\r\nx_l,x_r,y_l,y_r,z_l,z_r.One Martian told Natasha: \"I went to this store\r\n(n+m) times. n times of them it was opened, and m times closed.\" He also\r\ndescribed his every trip to the store: the month, day, second of the\r\ntrip and whether the store was open or closed at that moment.Natasha can\r\ngo to the store k times. For each of them, determine whether the store\r\nat the time of the trip is open, closed, or this information is unknown.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/CLionProjects/ACM/input.txt\", \"r\", stdin);\n//freopen(\"/home/alexandero/CLionProjects/ACM/output.txt\", \"w\", stdout);\n//freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin \u00bb t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nstruct SegTree {\n  int shift;\n  vector<int> tree;\n  vector<int> xs;\n  void build() {\n    make_unique(xs);\n    shift = 1;\n    while (shift < xs.size()) {\n      shift *= 2;\n    }\n    tree.assign(2 * shift, 0);\n  }\n  int get_lower_bound(int coord) {\n    return lower_bound(all(xs), coord) - xs.begin();\n  }\n  int get_sum(int l, int r) {\n    l = get_lower_bound(l);\n    r = get_lower_bound(r);\n    l += shift;\n    r += shift;\n    int res = 0;\n    while (l < r) {\n      if (l & 1) {\n        res += tree[l++];\n        continue;\n      }\n      if (r & 1) {\n        res += tree[--r];\n        continue;\n      }\n      l /= 2;\n      r /= 2;\n    }\n    return res;\n  }\n  void update(int x, int val) {\n    int v = get_lower_bound(x);\n    assert(xs[v] == x);\n    v += shift;\n    while (v) {\n      tree[v] += val;\n      v /= 2;\n    }\n  }\n};\n\nstruct LargeTree {\n  int shift;\n  vector<SegTree> trees;\n  LargeTree(int n) {\n    shift = 1;\n    while (shift < n) {\n      shift *= 2;\n    }\n    trees.resize(2 * shift);\n  }\n  void build() {\n    for (int i = 0; i < trees.size(); ++i) {\n      trees[i].build();\n    }\n  }\n  void raw_insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].xs.push_back(y);\n      x /= 2;\n    }\n  }\n  void insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].update(y, 1);\n      x /= 2;\n    }\n  }\n  int count(int lx, int rx, int ly, int ry) {\n    lx += shift;\n    rx += shift;\n    int res = 0;\n    while (lx < rx) {\n      if (lx & 1) {\n        res += trees[lx++].get_sum(ly, ry);\n        continue;\n      }\n      if (rx & 1) {\n        res += trees[--rx].get_sum(ly, ry);\n        continue;\n      }\n      lx /= 2;\n      rx /= 2;\n    }\n    return res;\n  }\n};\n\nconst int C = 100500;\n\nstruct Query {\n  int z;\n  int lx, rx;\n  int ly, ry;\n  int sign;\n  int id;\n};\n\nint pidorand() {\n  return (rand() << 16) | rand();\n}\n\n#ifndef AIM\n#define rand pidorand\n#endif\n\nvoid solve(bool read) {\n  //read = false;\n  LargeTree tree(C);\n  vector<int> borders(3);\n  for (int i = 0; i < 3; ++i) {\n    if (read) {\n      cin >> borders[i];\n    } else {\n      borders[i] = 100000;\n    }\n  }\n  int n, m, k;\n  if (read) {\n    cin >> n >> m >> k;\n  } else {\n    n = 1;\n    m = 100000;\n    k = 100000;\n  }\n  vector<int> mins(3, C), maxes(3, 0);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      int cur;\n      if (read) {\n        cin >> cur;\n      } else {\n        cur = rand() % borders[j] + 1;\n      }\n      relax_min(mins[j], cur);\n      relax_max(maxes[j], cur);\n    }\n  }\n  auto is_into = [&] (const vector<int>& cur) {\n    for (int i = 0; i < 3; ++i) {\n      if (cur[i] < mins[i] || cur[i] > maxes[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  vector<vector<vector<int>>> not_visited(C);\n  for (int i = 0; i < m; ++i) {\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n    }\n    if (is_into(cur)) {\n      cout << \"INCORRECT\\n\";\n      return;\n    }\n    not_visited[cur[2]].push_back({cur[0], cur[1]});\n    tree.raw_insert(cur[0], cur[1]);\n  }\n  tree.build();\n\n  cout << \"CORRECT\\n\";\n\n  vector<int> res(k, 0);\n  vector<bool> is_inside(k, false);\n  vector<vector<Query>> queries(C);\n  for (int i = 0; i < k; ++i) {\n    auto cur_mins = mins;\n    auto cur_maxes = maxes;\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n      relax_min(cur_mins[j], cur[j]);\n      relax_max(cur_maxes[j], cur[j]);\n    }\n    if (is_into(cur)) {\n      is_inside[i] = true;\n      continue;\n    }\n    Query cur_q = {cur_maxes[2], cur_mins[0], cur_maxes[0] + 1, cur_mins[1], cur_maxes[1] + 1, 1, i};\n    queries[cur_q.z].push_back(cur_q);\n    cur_q.z = cur_mins[2] - 1;\n    cur_q.sign = -1;\n    if (cur_q.z >= 0) {\n      queries[cur_q.z].push_back(cur_q);\n    }\n  }\n\n  for (int z = 0; z < C; ++z) {\n    for (auto& vec : not_visited[z]) {\n      tree.insert(vec[0], vec[1]);\n    }\n    for (auto& q : queries[z]) {\n      res[q.id] += q.sign * tree.count(q.lx, q.rx, q.ly, q.ry);\n    }\n  }\n\n  for (int i = 0; i < k; ++i) {\n    if (is_inside[i]) {\n      cout << \"OPEN\\n\";\n      continue;\n    }\n    if (res[i] > 0) {\n      cout << \"CLOSED\\n\";\n      continue;\n    }\n    cout << \"UNKNOWN\\n\";\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Store.json",
    "editorial_link": "https://codeforces.com/blog/entry/60851",
    "editorial": "Consider options: . This means that Natasha does not know about any\r\nmoment when the store was closed. Let\u00e2\u0080\u0099s find the numbers , , , , , ,\r\nwhere are moments when store is open. For each query answer , if , , and\r\n. Answer otherwise. . Let\u00e2\u0080\u0099s find the numbers , , , , , , where are\r\nmoments when store is open. If there is at least one moment , when the\r\nstore is closed, and , and , then the answer is . Otherwise, let\u00e2\u0080\u0099s\r\ncreate a compressed two-dimensional segment tree. The first coordinate\r\nis number of the month in the year, the second coordinate is number of\r\nthe day in a month. At each vertex of the tree of segments we store a\r\npair of numbers the greatest such number of a second , when the store\r\nwas closed, in this day of this month, that , and the smallest such\r\nnumber of a second , when the store was closed, in this day of this\r\nmonth, that . Now every query we will handle like this. If , and ,\r\nanswer . Otherwise, consider the parallelepiped given by the coordinates\r\nof opposite vertices and and consider each vertex in turn the\r\nparallelepiped under consideration. Let\u00e2\u0080\u0099s make the query in the segment\r\ntree , . Let the received answer is . If the number or number is between\r\nnumbers and , this means that there is such a time point , when the\r\nstore is closed, that is between and (the month of the year when the\r\nstore is closed, is between the month in the year when the store is\r\nopen, and the month in the year in the query), is between and (the day\r\nin the month when the store is closed is between the day in the month\r\nwhen the store is open and the day in the month in the query), is\r\nbetween and (second in a day, when the store is closed, is between a\r\nsecond in a day, when the store is open and a second in a day in the\r\nquery), hence the answer to the query is . If the condition is not\r\nsatisfied for any vertex of the parallelepiped, the answer is\r\n.Complexity: .\r\n"
}