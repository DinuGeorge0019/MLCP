{"link": "https://codeforces.com//contest/1545/problem/C", "problemId": "1042719", "problem_idx": "C", "shortId": "1545C", "contest_number": "1545", "problem_submissions": {"D": [122107122, 122101318, 122112155, 122104020, 122109653, 122107428, 122115750, 122116493, 122121641, 122123526, 122112699, 122120695, 122128586, 122117389, 122107326, 122130554, 122090817, 122093272, 122093535], "C": [122095530, 122110873, 122098409, 122112986, 122088985, 122122234, 122107021, 122110115, 122100227, 122102454, 122124600, 122110793, 122110757, 122109117, 122128432, 122119096, 122155152, 122213467], "A": [122082186, 122076078, 122075671, 122076509, 122122714, 122075627, 122075591, 122075678, 122076215, 122076949, 122075854, 122076317, 122085649, 122075796, 122075639, 122080513, 122075936, 122075621, 122078770], "B": [122079612, 122088170, 122082472, 122119780, 122079771, 122077496, 122090297, 122081981, 122082032, 122084749, 122098370, 122095139, 122093255, 122128209, 122084402, 122088184, 122078878, 122077599, 122119388], "F": [122258728, 122258683, 122258676, 122258661, 122258513, 122258288, 122147603, 122158393, 122158209], "E2": [122155943, 122135135], "E1": [122155936, 122155364, 122153713, 122135243]}, "name": "C. AquaMoon and Permutations", "statement": "Cirno has prepared n arrays of length n each. Each array is a\r\npermutation of n integers from 1 to n. These arrays are special: for all\r\n1\r\nleq i\r\nleq n, if we take the i-th element of each array and form another array\r\nof length n with these elements, the resultant array is also a\r\npermutation of n integers from 1 to n. In the other words, if you put\r\nthese n arrays under each other to form a matrix with n rows and n\r\ncolumns, this matrix is a Latin square.Afterwards, Cirno added\r\nadditional n arrays, each array is a permutation of n integers from 1 to\r\nn. For all 1\r\nleq i\r\nleq n, there exists position 1\r\nleq k\r\nleq n, such that for the i-th array and the (n + i)-th array, the k-th\r\nelement of both arrays is the same. Notice that the arrays indexed from\r\nn + 1 to 2n form a Latin square. Also, Cirno made sure that for all 2n\r\narrays, no two arrays are completely equal, i. e. for all pair of\r\nindices 1\r\nleq i < j\r\nleq 2n, there exists position 1\r\nleq k\r\nleq n, such that the k-th elements of the i-th and j-th array are\r\n.Finally, Cirno arbitrarily changed the order of 2n arrays.AquaMoon\r\ncalls a subset of all 2n arrays of size n if these arrays from a Latin\r\nsquare.AquaMoon wants to know how many good subsets exist. Because this\r\nnumber may be particularly large, find it modulo 998\r\n,244\r\n,353. Also, she wants to find any good subset. Can you help her?\r\n", "solutions": ["#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pi;\ntypedef vector<int>vi;\nconst int maxn=505;\nconst int M=998244353;\nint c[505][505],a[1005][505],n,_;\nbool f[1005][1005],vis[1005];\nvi ans;\nvoid dfs(int u,int o){\n    if (!o) ans.pb(u); vis[u]=1;\n    for (int i=1;i<=n*2;i++) if (!vis[i]&&f[u][i]) dfs(i,o^1);\n}\nvoid del(int x){\n    vis[x]=1;\n    for (int i=1;i<=n;i++) c[i][a[x][i]]--;\n}\nvoid solve(){\n    scanf(\"%d\",&n);\n    memset(vis,0,sizeof(vis));\n    memset(c,0,sizeof(c));\n    memset(f,0,sizeof(f));\n    ans.clear();\n    for (int i=1;i<=n*2;i++){\n        for (int j=1;j<=n;j++){\n            scanf(\"%d\",&a[i][j]);\n            c[j][a[i][j]]++;\n        }\n        for (int j=1;j<i;j++)\n            for (int k=1;k<=n;k++)\n                if (a[i][k]==a[j][k]){\n                    f[i][j]=f[j][i]=1;\n                    break;\n                }\n    }\n    c[0][0]=1001;\n    while (1){\n        int p=0,q=0;\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=n;j++)\n                if (c[i][j]>0&&c[i][j]<c[p][q]) p=i,q=j;\n        if (c[p][q]>1) break;\n        int w=-1;\n        for (int i=1;i<=n*2;i++)\n            if (!vis[i]&&a[i][p]==q){\n                w=i;\n                break;\n            }\n        assert(w!=-1);\n        del(w);ans.pb(w);\n        for (int i=1;i<=n*2;i++) if (!vis[i]&&f[i][w]) del(i);\n    }\n    int tot=1;\n    for (int i=1;i<=n*2;i++) if (!vis[i]) dfs(i,0),tot=tot*2%M;\n    printf(\"%d\\n\",tot);\n    sort(ans.begin(),ans.end());\n    for (auto x:ans) printf(\"%d \",x);puts(\"\");\n}\nint main(){\n    scanf(\"%d\",&_);\n    while (_--) solve();\n}\n\n"], "input": "", "output": "", "tags": ["2-sat", "brute force", "combinatorics", "constructive algorithms", "graph matchings", "graphs"], "dificulty": "2800", "interactive": false}