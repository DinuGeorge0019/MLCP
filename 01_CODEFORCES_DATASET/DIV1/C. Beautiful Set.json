{
    "link": "https://codeforces.com//contest/364/problem/C",
    "problemId": "4043",
    "problem_idx": "C",
    "shortId": "364C",
    "contest_number": "364",
    "problem_submissions": {
        "E": [
            5182930,
            5182917,
            5182805,
            5182789,
            5182779,
            5163338,
            5192424,
            5192315,
            5285842
        ],
        "C": [
            5159826,
            5156914,
            5156913,
            5159036,
            5158199,
            5156857,
            5160288,
            5159437,
            5160554,
            5160938,
            5160044,
            5162865,
            5159797,
            5161370
        ],
        "B": [
            5155945,
            5152807,
            5153694,
            5154783,
            5155872,
            5158323,
            5155584,
            5154573,
            5157525,
            5158221,
            5171150,
            5155541,
            5157687,
            5162725,
            5157104
        ],
        "A": [
            5151035,
            5151153,
            5151193,
            5150604,
            5151593,
            5151967,
            5152019,
            5151677,
            5154003,
            5153612,
            5152606,
            5154441,
            5150915,
            5155034
        ],
        "D": [
            5159378,
            5164152,
            5164129,
            5165101,
            26468599,
            26468582,
            26468554,
            5164765,
            5178204,
            5178186,
            5165121,
            5171056,
            5929384,
            5343038
        ]
    },
    "name": "C. Beautiful Set",
    "statement": "We\u2019ll call a set of positive integers beautiful if the following\r\ncondition fulfills: for any prime , if , then . In other words, if one\r\nnumber from the set is divisible by prime , then at least half of\r\nnumbers from the set is divisible by .Your task is to find any beautiful\r\nset, where the number of elements is equal to and each element doesn\u2019t\r\nexceed .\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define REPC(I, C) for (int I = 0; !(C); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\nint p[20]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61};\nint cnt[20];\nint up,d[10000000],dn;\nvoid dfs(int x,int v,int n){\n    if(x==n){\n        d[dn++]=v;\n        return;\n    }\n    dfs(x+1,v,n);\n    while(v*p[x]<=up){\n        v*=p[x];\n        dfs(x+1,v,n);\n    }\n}\nint main(){\n    DRI(K);\n    up=2*K*K;\n    for(int i=2;;i++){\n        dn=0;\n        dfs(0,1,i);\n        if(dn<K*2)continue;\n        sort(d,d+dn);\n        MS0(cnt);\n        REP(j,K){\n            if(j)printf(\" \");\n            REP(k,i)if(d[dn-1-j]%p[k]==0)cnt[k]++;\n            printf(\"%d\",d[dn-1-j]);\n        }\n        REP(j,i)\n            if(cnt[j]*2<K)fprintf(stderr,\"haha!\\n\");\n        puts(\"\");\n        return 0;\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Beautiful Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/9657",
    "editorial": "We expected many unproved, but tested solutions. I think that careful prove of my solution with pen and paper is very difficult. So I will use some statistic-based facts.\n\nConsider the set of divisors of number k. One can check that it's beautiful set.\nIf factorisation of k has the form  where ?i???3 and pi is distinct primes, set of divisors of k which is less than  is also beautiful.\nHow to prove item 2? Consider set A of pairs of divisors of k (ai,?bi) such as ai\u00b7bi?=?k and ai?<?bi. Obiviously (if k is not complete square) any divisor will be contained only in one pair. It's easy too see that . Consider some element of factorisation of k p? such as  and it is not true that . Let f(x) is maximal number s such as . f(ai)?+?f(bi)?=??. For every q such as  numbers q,?q\u00b7p,?...,?q\u00b7p? will be divisors of k. That implies that  where d is number of divisors of . So in  pairs both numbers are divisible by p. So set {a0,?...,?a|A|} is beautiful.\nBut there are some pairs with f(ai)?=??.  is equivalent approval.\nIt's always possible to find such k as number of it's divisors is bigger than 2\u00b7w where w is number of elements in required set. You may write following dp to find it.\ndp[i][j] is minimal k which is constructed of first i primes ans has j divisors. \nAbout 10 primes is enough to cover all k.\nNow we can construct beautiful sets with more than k elements.\nUsing item 4 we will understand that constructed answer is very beautiful (about 60% of elements divisible by every possible p) and we can always delete extra elements.\nLast items is not strict, but one can check it with his computer."
}