{"link": "https://codeforces.com//contest/1599/problem/I", "problemId": "1136888", "problem_idx": "I", "shortId": "1599I", "contest_number": "1599", "problem_submissions": {"J": [131341071], "I": [131324833], "F": [131321008], "H": [131309947], "C": [131304492], "A": [131303141], "B": [], "D": [], "E": [], "G": []}, "name": "I. Desert", "statement": "You are given an undirected graph of N nodes and M edges, E_1, E_2,\r\ndots E_M.A connected graph is a cactus if each of it\u2019s edges belogs to\r\nat most one simple cycle. A graph is a desert if each of it\u2019s connected\r\ncomponents is a cactus. Find the number of pairs (L, R), (1\r\nleq L\r\nleq R\r\nleq M) such that, if we delete all the edges except for E_L, E_{L+1},\r\ndots E_R, the graph is a desert.\r\n", "solutions": ["#include<bits/stdc++.h>\n#define L(i, j, k) for (int i = (j); i <= (k); ++i) \n#define R(i, j, k) for (int i = (j); i >= (k); --i)  \n#define ll long long\n#define vi vector < int > \n#define sz(a) ((int) (a).size())\nusing namespace std;\nconst int N = 1e6 + 7, mod = 1e9 + 7, inv6 = (mod + 1) / 6, W = 2;\nint n, m, ch[N][2], mx[N], w[N], tag[N], fa[N], s[N], flag[N], fr[N], to[N], tot;\nbool get(int x) {\n\treturn ch[fa[x]][0] == x || ch[fa[x]][1] == x;\n}\nvoid filp(int x) {\n\tif(x) flag[x] ^= 1, swap(ch[x][0], ch[x][1]);\n}\nvoid upd(int x) {\n\ts[x] = x <= n ? 1919810 : x;\n\tif(ch[x][0] && s[x] > s[ch[x][0]]) s[x] = s[ch[x][0]];\n\tif(ch[x][1] && s[x] > s[ch[x][1]]) s[x] = s[ch[x][1]];\n\tmx[x] = max(w[x], max(mx[ch[x][0]], mx[ch[x][1]]));\n}\nvoid AD (int x, int r) {\n\ttag[x] += r, mx[x] += r, w[x] += r;\n}\nvoid pushdown(int x) {\n\tif(flag[x]) {\n\t\tif(ch[x][0]) filp(ch[x][0]);\n\t\tif(ch[x][1]) filp(ch[x][1]);\n\t\tflag[x] ^= 1;\t\n\t}\n\t\n\tif(tag[x]) {\n\t\tif(ch[x][0]) AD(ch[x][0], tag[x]);\n\t\tif(ch[x][1]) AD(ch[x][1], tag[x]);\n\t\ttag[x] = 0;\n\t}\n}\nvoid rotate(int x) {\n\tint y = fa[x], z = fa[y], fson = (ch[y][1] == x), ano = ch[x][1^fson];\n\tif(get(y)) ch[z][ch[z][1] == y] = x;\n\tif(ano) fa[ano] = y;\n\tfa[y] = x, fa[x] = z, ch[x][1^fson] = y, ch[y][fson] = ano;\n\tupd(y), upd(x);\n}\nint fx, f[N], total;\nvoid Splay(int x) {\n\ttotal = 1, fx = f[total] = x;\n\twhile(get(fx)) ++total, fx = f[total] = fa[fx];\n\twhile(total) pushdown(f[total]), --total;\n\twhile(get(x)) {\n\t\tint y = fa[x], z = fa[y];\n\t\tif(get(y)) rotate(((ch[y][0] == x) ^ (ch[z][0] == y)) ? x : y);\n\t\trotate(x);\n\t}\n\tupd(x);\n}\nvoid access(int x) {\n\tint y = 0;\n\twhile(x) {\n\t\tSplay(x);\n\t\tch[x][1] = y;\n\t\tupd(x);\n\t\ty = x;\n\t\tx = fa[x];\n\t}\n}\nvoid makeroot(int x) {\n\taccess(x), Splay(x), filp(x);\n}\nint findroot(int x) {\n\taccess(x), Splay(x);\n\twhile(ch[x][0]) pushdown(x), x = ch[x][0];\n\tSplay(x);\n\treturn x;\n}\nvoid split(int x, int y) {\n\tmakeroot(x), access(y), Splay(y); \n}\nvoid link(int x, int y) {\n\tmakeroot(x);\n\tif(findroot(y) != x) fa[x] = y;\n} \nvoid cut(int x, int y) {\n\tmakeroot(x);\n\tif(findroot(y) == x && fa[y] == x && ! ch[y][0]) ch[x][1] = fa[y] = 0, upd(x);\n}\n\nint eu[N], ev[N];\nbool ok[N];\nint main () {\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0); \n\tcin >> n >> m;\n\tL(i, 0, n) w[i] = -1e9;\n\tL(i, 1, m) \n\t\tcin >> eu[i] >> ev[i];\n\tint cr = 1;\n\tll ns = 0;\n\tL(i, 1, m) {\n\t\tif(i > 1) {\n\t\t\tint g = i - 1;\n\t\t\tif(ok[g]) cut (eu[g], g + n), cut (ev[g], g + n);\n\t\t\telse split (eu[g], ev[g]), AD(ev[g], -1);\n\t\t}\n\t\twhile (cr <= m) {\n\t\t\tif(findroot (eu[cr]) == findroot (ev[cr])) {\n\t\t\t\tsplit (eu[cr], ev[cr]);\n//\t\t\t\tcout << \"mx = \" << mx[ev[cr]] << '\\n';\n\t\t\t\tif(mx[ev[cr]] >= 1) break;\n\t\t\t\tint t = s[ev[cr]] - n;\n//\t\t\t\tcout << \"t = \" << t << '\\n';\n\t\t\t\tcut (eu[t], t + n), cut (eu[t], t + n), ok[t] = false;\n\t\t\t\tlink (eu[cr], cr + n), link (ev[cr], cr + n);\n\t\t\t\tsplit (eu[t], ev[t]);\n\t\t\t\tAD(ev[t], 1);\n\t\t\t}\n\t\t\telse link (eu[cr], cr + n), link (ev[cr], cr + n);\n\t\t\tok[cr] = true, cr += 1;\n\t\t}\n\t\tns += cr - i;\n//\t\tcout << i << \" : \" << cr << '\\n';\n\t}\n\tcout << ns << '\\n';\n\treturn 0;\n} "], "input": "", "output": "", "tags": ["data structures", "graphs"], "dificulty": "2700", "interactive": false}