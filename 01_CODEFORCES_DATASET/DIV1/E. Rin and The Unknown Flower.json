{
    "link": "https://codeforces.com//contest/1292/problem/E",
    "problemId": "519780",
    "problem_idx": "E",
    "shortId": "1292E",
    "contest_number": "1292",
    "problem_submissions": {
        "F": [
            69140685,
            69148403,
            71814085,
            71814062,
            71813990,
            70217605,
            69197847,
            69495748,
            71223361
        ],
        "D": [
            69122533,
            69114171,
            69256713,
            69123417,
            69126885,
            69163995,
            69128025,
            69127012,
            69131460,
            69130080,
            69130342,
            69128215,
            69129378,
            69133922,
            69131233,
            69132965,
            69132809,
            69134434,
            69132903,
            69127292,
            69140744,
            69136786
        ],
        "C": [
            69113617,
            69117304,
            69112958,
            69113829,
            69164607,
            69112261,
            69111227,
            69113942,
            69113564,
            69116428,
            69114170,
            69121126,
            69118602,
            69121886,
            69119931,
            69117602,
            69119253,
            69121231,
            69130721,
            69112217,
            69119945
        ],
        "B": [
            69102431,
            69100917,
            69105559,
            69104060,
            69164579,
            69104349,
            69103131,
            69105348,
            69102973,
            69106424,
            69106338,
            69108218,
            69106515,
            69110303,
            69110995,
            69110488,
            69109887,
            69114588,
            69102534,
            69105217,
            69108444
        ],
        "A": [
            69100122,
            69100064,
            69101788,
            69100300,
            69164572,
            69100144,
            69100129,
            69100151,
            69100251,
            69100494,
            69100278,
            69100280,
            69100245,
            69101280,
            69102544,
            69101036,
            69101104,
            69100156,
            69100106,
            69100348,
            69100678
        ],
        "E": [
            69145246,
            69152430,
            69165289,
            69151098,
            69168995,
            69165203,
            69152318,
            69162582,
            69185344
        ]
    },
    "name": "E. Rin and The Unknown Flower",
    "statement": "On a normal day at the hidden office in A.R.C. Markland-N, Rin received\r\nan artifact, given to her by the exploration captain Sagar.After much\r\nanalysis, she now realizes that this artifact contains data about a\r\nstrange flower, which has existed way before the New Age. However, the\r\ninformation about its chemical structure has been encrypted heavily.The\r\nchemical structure of this flower can be represented as a string p. From\r\nthe unencrypted papers included, Rin already knows the length n of that\r\nstring, and she can also conclude that the string contains at most three\r\ndistinct letters: \"\" (as in Carbon), \"\" (as in Hydrogen), and \"\" (as in\r\nOxygen).At each moment, Rin can input a string s of an arbitrary length\r\ninto the artifact\u2019s terminal, and it will return every starting position\r\nof s as a of p.However, the artifact has limited energy and cannot be\r\nrecharged in any way, since the technology is way too ancient and is\r\nincompatible with any current A.R.C.\u2019s devices. To be specific: The\r\nartifact only contains\r\nfrac{7}{5} units of energy. For each time Rin inputs a string s of\r\nlength t, the artifact consumes\r\nfrac{1}{t^2} units of energy. If the amount of energy reaches below\r\nzero, the task will be considered failed immediately, as the artifact\r\nwill go black forever. Since the artifact is so precious yet fragile,\r\nRin is very nervous to attempt to crack the final data. Can you give her\r\na helping hand?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 19.01.2020 17:31:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s(n, '?');\n    auto Ask = [&](string t) {\n      cout << \"? \" << t << endl;\n      int foo;\n      cin >> foo;\n      for (int i = 0; i < foo; i++) {\n        int bar;\n        cin >> bar;\n        --bar;\n        for (int j = 0; j < (int) t.size(); j++) {\n          s[bar + j] = t[j];\n        }\n      }\n    };\n    if (n <= 7) {\n      Ask(\"CH\");\n      Ask(\"CO\");\n      if (s == string(n, '?')) {\n        if (n == 4) {\n          Ask(\"HO\");\n          if (s == string(n, '?')) {\n            Ask(\"OH\");\n            if (s == string(n, '?')) {\n              Ask(\"CCC\");\n              if (s == string(n, '?')) {\n                Ask(\"OOO\");\n                if (s[0] == 'O') {\n                  if (s[n - 1] == '?') s[n - 1] = 'C';\n                } else {\n                  Ask(\"HHH\");\n                  if (s[0] == 'H') {\n                    if (s[n - 1] == '?') s[n - 1] = 'C';\n                  } else {\n                    Ask(\"OOCC\");\n                    if (s == string(n, '?')) s = \"HHCC\";\n                  }\n                }\n              } else {\n                Ask(\"HCCC\");\n                Ask(\"OCCC\");\n              }\n            } else {\n              for (int i = 0; i < n; i++) {\n                if (s[i] == '?') {\n                  s[i] = 'O';\n                } else {\n                  break;\n                }\n              }\n              goto haha;\n            }\n          } else {\n            goto haha;\n          }\n        } else {\n          Ask(\"CC\");\n          if (s[1] != '?' && s[0] == '?') {\n            string q = s;\n            q[0] = 'H';\n            Ask(q);\n            if (s[0] == '?') {\n              s[0] = 'O';\n            }\n          } else {\n            Ask(\"OH\");\n            Ask(\"HO\");\n            if (s == string(n, '?')) {\n              Ask(string(n, 'H'));\n              Ask(string(n, 'O'));\n              if (s == string(n, '?')) {\n                string q(n, 'H');\n                q[n - 1] = 'C';\n                Ask(q);\n                if (s == string(n, '?')) {\n                  s = string(n, 'O');\n                  s[n - 1] = 'C';\n                }\n              }\n            } else {\n              if (s[n - 1] == 'C' && s.find(\"H\") == string::npos && s.find(\"O\") == string::npos) {\n                string q = s;\n                for (int i = 0; i < n; i++) {\n                  if (q[i] == '?') {\n                    q[i] = 'H';\n                  }\n                }\n                Ask(q);\n                if (s[0] == '?') {\n                  for (int i = 0; i < n; i++) {\n                    if (s[i] == '?') {\n                      s[i] = 'O';\n                    }\n                  }\n                }\n              } else {\n                int beg = 0;\n                while (beg < n) {\n                  if (s[beg] != '?') {\n                    ++beg;\n                    continue;\n                  }\n                  int end = beg;\n                  while (end + 1 < n && s[end + 1] == '?') {\n                    ++end;\n                  }\n                  if (beg == 0) {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[end + 1];\n                    }\n                  } else {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[beg - 1];\n                    }\n                  }\n                  beg = end + 1;\n                }\n                string q = s;\n                q[n - 1] = 'C';\n                Ask(q);\n              }\n            }\n          }\n        }\n      } else {\n        haha:\n        while (true) {\n          bool any = false;\n          for (int i = 0; i < n; i++) {\n            if (s[i] == '?') {\n              any = true;\n              break;\n            }\n          }\n          if (!any) {\n            break;\n          }\n          bool found = false;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] == '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] != '?' && s[i + 4] != '?') {\n              string q = \"C\";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += s[i + 4];\n              Ask(q);\n              if (s[i] == '?') {\n                q[0] = 'O';\n                Ask(q);\n                if (s[i] == '?') {\n                  s[i] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] != '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] != '?' && s[i + 4] == '?') {\n              string q = \"\";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += \"C\";\n              Ask(q);\n              if (s[i + 4] == '?') {\n                q[4] = 'O';\n                Ask(q);\n                if (s[i + 4] == '?') {\n                  s[i + 4] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] == '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] != '?') {\n              string q = \"C\";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              Ask(q);\n              if (s[i] == '?') {\n                q[0] = 'O';\n                Ask(q);\n                if (s[i] == '?') {\n                  s[i] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] != '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] == '?') {\n              string q = \"\";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += \"C\";\n              Ask(q);\n              if (s[i + 3] == '?') {\n                q[3] = 'O';\n                Ask(q);\n                if (s[i + 3] == '?') {\n                  s[i + 3] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] == '?' && s[i + 1] != '?' && s[i + 2] != '?') {\n              string q = \"C\";\n              q += s[i + 1];\n              q += s[i + 2];\n              Ask(q);\n              if (s[i] == '?') {\n                q[0] = 'O';\n                Ask(q);\n                if (s[i] == '?') {\n                  s[i] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] != '?' && s[i + 1] != '?' && s[i + 2] == '?') {\n              string q = \"\";\n              q += s[i];\n              q += s[i + 1];\n              q += \"C\";\n              Ask(q);\n              if (s[i + 2] == '?') {\n                q[2] = 'O';\n                Ask(q);\n                if (s[i + 2] == '?') {\n                  s[i + 2] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          assert(found);\n        }\n      }\n    } else {\n      Ask(\"CH\");\n      Ask(\"CO\");\n      Ask(\"HC\");\n      Ask(\"HO\");\n      Ask(\"OC\");\n      if (s == string(n, '?')) {\n        Ask(string(n, 'C'));\n        if (s == string(n, '?')) {\n          Ask(\"OHH\");\n          if (s == string(n, '?')) {\n            Ask(string(n - 1, 'O'));\n            if (s == string(n, '?')) {\n              s = string(n, 'H');\n            } else {\n              if (s[n - 1] == '?') {\n                s[n - 1] = 'H';\n              }\n            }\n          } else {\n            for (int i = 0; i < n; i++) {\n              if (s[i] == '?') {\n                s[i] = 'O';\n              } else {\n                break;\n              }\n            }\n            for (int i = n - 1; i >= 0; i--) {\n              if (s[i] == '?') {\n                s[i] = 'H';\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        Ask(\"OHH\");\n        int pref = 0, suf = 0;\n        int beg = 0;\n        while (beg < n) {\n          if (s[beg] != '?') {\n            ++beg;\n            continue;\n          }\n          int end = beg;\n          while (end + 1 < n && s[end + 1] == '?') {\n            ++end;\n          }\n          if (beg == 0) {\n            if (s[end + 1] != 'H') {\n              for (int i = beg; i <= end; i++) {\n                s[i] = s[end + 1];\n              }\n            } else {\n              pref = end + 1;\n            }\n          } else {\n            if (end == n - 1) {\n              if (s[beg - 1] != 'O') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              } else {\n                for (int i = beg; i <= end - 1; i++) {\n                  s[i] = 'O';\n                }\n                suf = 1;\n              }\n            } else {\n              if (s[beg - 1] == 'O' && s[end + 1] == 'H') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = 'O';\n                }\n              } else {\n                assert(s[beg - 1] == s[end + 1]);\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              }\n            }\n          }\n          beg = end + 1;\n        }\n        if (pref > 0) {\n          string q = s;\n          if (suf > 0) {\n            q.pop_back();\n          }\n          for (int i = 0; i < pref; i++) {\n            q[i] = 'O';\n          }\n          Ask(q);\n          if (s[0] == '?') {\n            for (int i = 0; i < pref; i++) {\n              s[i] = 'H';\n            }\n          }\n        }\n        if (suf > 0) {\n          string q = s;\n          q[n - 1] = 'O';\n          Ask(q);\n          if (s[n - 1] == '?') {\n            s[n - 1] = 'H';\n          }\n        }\n      }\n    }\n    cout << \"! \" << s << endl;\n    int foo;\n    cin >> foo;\n    if (foo == 0) break;\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "interactive",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Rin and The Unknown Flower.json",
    "editorial_link": "https://codeforces.com//blog/entry/73051",
    "editorial": "To be fair, this is a complicated decision tree problem. I recommend\r\ninstead of heading straight to read the main solutions for this, try to\r\nspend some time and come up with at least 2 solutions for the case when\r\nthe query limit is 5/3 first.<spoilers> There are many solutions when\r\nlimit = 5/3, and I\u00e2\u0080\u0099ll point 2 of them out. The difference between the\r\ntwo solutions is how you approach the string and build a decision tree\r\nout of those queries:1. disclose every joint of the string (which is\r\nequivalent to find every position that S[i]==S[i+1]). All remaining\r\nletters can be filled up with the nearest disclosed letter to it. This\r\ncan be done by asking 6 queries: \"\", \"\", \"\", \"\", \"\", \"\". If none of the\r\nletters is disclosed, then all of the letters are the same. You can\r\ndisclose all of them by asking 2 more queries of length n and determine\r\nwhat letter is it.2. (in my opinion): The idea of this is to disclose at\r\nleast one letter of the string, to disclose the rest with at most one\r\nstring of length to each. We could do this by simply asking \"\". This\r\ncould go either way: If a \u00e2\u0080\u009d is disclosed at a position , we can disclose\r\nthe position with one query of length , with one query of length , ...\r\nand so on. From there, undisclose position with a query of length , with\r\na query of length , ... and so on. If no letter is disclosed, the\r\nproblem narrows down to solve with a binary string and total cost of .\r\nThere are multiple ways to tackle this so I won\u00e2\u0080\u0099t spend any more time to\r\nexplain this case. The key here is to come up with a strategy that works\r\nin all branches of the decision tree. And to do that, we must find a\r\ngood starting query/set of queries to begin with.In the two strategies\r\nabove, number 1 is too brutal, and number 2 is too naive. But my main\r\nsolution contains the essences which can be seen in both solutions. The\r\nmain idea is to find a set of queries to begin with like strat 2 but\r\nwould give us more hints and cost us less when things go the other\r\nway.We\u00e2\u0080\u0099ll start by asking queries with \"\", \"\", \"\", \"\", which in total\r\nhave cost of . That way, the non-disclosed parts can be one of those:\r\nConsecutive similar characters. A joint starting with \"\". Supposed that\r\nafter four above queries and no occurrences were found at all, the\r\nstring can now be only in one of those kinds: An entire string\r\nconstructed by a single character. A string of form \"\", with \"\" being\r\neither \"\" or \"\". In other words, the string is constructed by characters\r\n\"\", followed by characters \"\" (). Proof for this is trivial.We\u00e2\u0080\u0099ll find\r\nthe trace of large chunks of \"\" or \"\" (cannot find every trace since the\r\ncost limit is very tight here, the minimum length allowed should only be\r\n). To do this, we\u00e2\u0080\u0099ll ask queries \"\" and \"\" sequentially. If any of the\r\ntwo queries return occurrence(s), that means all occurrences of \"\" or \"\"\r\nhas been revealed (and also guaranteed to completely inherit the right\r\nside of the string), any undisclosed characters on the left will\r\nobviously be \"\". From here, we can conclude and return the original\r\nstring.However, if both queries return nothing, this means either the\r\nstring contains only \"\" characters or there are at most rightmost\r\ncharacters being \"\" or \"\". Given this, we ought to find the chunk of \"\"\r\nby asking query \"\" (similar logic to the former step). If it returns\r\noccurrence(s) and there are still undisclosed characters, we\u00e2\u0080\u0099ll need\r\nanother query of length to finalize: replacing all of the undisclosed\r\npositions to \"\" then ask a query with that string, if it returns\r\noccurrence then \"\" is for the missing characters, otherwise \"\" is.This\r\nmethod works because there will always be one chunk with length at least\r\n(on either end of the string), except two cases: \"\" and \"\".You will get\r\nto this if all three above queries failed to return anything. However,\r\nsince this is a matter of picking one from two, a single query of either\r\nstring will work: the original string is the asked string if occurrence\r\nfound, otherwise the other.This is also the worst case in this branch.\r\nTotal cost would be - very close to the limit.Back to the case that some\r\noccurrence(s) are found when after asking the joint queries. The logic\r\nnow is pretty similar to strat 2 mentioned above however due to the more\r\nvaried undisclosed patterns, we\u00e2\u0080\u0099ll need to take some extra caution.First\r\nof all, we\u00e2\u0080\u0099ll start at the leftmost revealed segment, and disclose any\r\nhidden characters to the left of it. It\u00e2\u0080\u0099s easy to see that the leftmost\r\nrevealed character can never be \"\", and since the leftmost hidden\r\nsegment always come in one of two forms similar to the no-occurrence\r\ncase branch above, you can always reveal the nearest character by\r\nassuming it is the same as the current leftmost revealed character and\r\nuse it as a query to ask. If the assumption is incorrect, then it and\r\nany remaining hidden letters to the left of it will be \"\".Now that we\r\nhave a fully revealed prefix, we\u00e2\u0080\u0099ll extend it by revealing letters to\r\nthe right. For simplicity, let\u00e2\u0080\u0099s split into two cases: one when there\r\nare revealed letter(s) not within our current prefix, one when there is\r\nnone.If such revealed letters are found, consider the one being closest\r\nto our prefix. We can see that the hidden gap between our prefix and it\r\ncan only be produced by some (probably none) characters being the same\r\nas our rightmost character in the prefix, followed by some (probably\r\nnone) characters being the same as our leftmost character outside of the\r\nprefix. Thus, we can simply assume the next hidden character is the same\r\nas our rightmost in-prefix character, then ask the query. If the\r\nassumption is incorrect, fill it and all the remaining hidden characters\r\nin that segment with the other one.If there are none, then the last\r\nhidden segment is again, similar to the no-occurrence case branch.\r\nHowever, we have a significant clue this time: our rightmost in-prefix\r\ncharacter. If it is not \"\", we can quickly fill all the hidden positions\r\nwith it, otherwise, we\u00e2\u0080\u0099ll keep asking query again, assuming the next\r\nhidden character is still \"\": if incorrect, take another query to ask if\r\neither it is \"\" or \"\", and then fill it and all the other hidden ones.**\r\nExample interaction:The string is \"\" (, in other words the string is\r\nconstruct by appending character \"\" to the string \"\").=> 50(Finding\r\njoints not starting at O)? CH => 0? CO => 1 1? HC => 0? HO => 0(Now, the\r\nstring can be deduced as \"\")? COO => 0 (Assuming that the third\r\ncharacter is still \"\", sadly it isn\u00e2\u0080\u0099t.)? COC => 0 (Assuming that the\r\nthird character is still \"\", and it isn\u00e2\u0080\u0099t either.)(By now we can deduce\r\nthe string to be \"\", since the fourth character and beyond cannot be\r\nanything other than \"\" (otherwise it would have raised a signal in the\r\njoints queries)).! COHHHH... => 1** End of example.The maximum cost for\r\nthis will be ( because starting from a joint means we have at least\r\nfound characters, incremented by by the character we\u00e2\u0080\u0099re about to\r\nguess):With going to positive infinity, the limit of this function will\r\nbe , therefore this solution still works.</spoilers>Big credits to Sooke\r\nfor making this problem more interesting by pointing out a way to reduce\r\nthe initial limit (5/3) and make this problem much less trivial.\r\n"
}