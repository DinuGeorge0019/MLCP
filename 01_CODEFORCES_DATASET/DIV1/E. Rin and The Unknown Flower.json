{"link": "https://codeforces.com//contest/1292/problem/E", "problemId": "519780", "problem_idx": "E", "shortId": "1292E", "contest_number": "1292", "problem_submissions": {"F": [69140685, 69148403, 71814085, 71814062, 71813990, 70217605, 69197847, 69495748, 71223361], "D": [69122533, 69114171, 69256713, 69123417, 69126885, 69163995, 69128025, 69127012, 69131460, 69130080, 69130342, 69128215, 69129378, 69133922, 69131233, 69132965, 69132809, 69134434, 69132903, 69127292, 69140744, 69136786], "C": [69113617, 69117304, 69112958, 69113829, 69164607, 69112261, 69111227, 69113942, 69113564, 69116428, 69114170, 69121126, 69118602, 69121886, 69119931, 69117602, 69119253, 69121231, 69130721, 69112217, 69119945], "B": [69102431, 69100917, 69105559, 69104060, 69164579, 69104349, 69103131, 69105348, 69102973, 69106424, 69106338, 69108218, 69106515, 69110303, 69110995, 69110488, 69109887, 69114588, 69102534, 69105217, 69108444], "A": [69100122, 69100064, 69101788, 69100300, 69164572, 69100144, 69100129, 69100151, 69100251, 69100494, 69100278, 69100280, 69100245, 69101280, 69102544, 69101036, 69101104, 69100156, 69100106, 69100348, 69100678], "E": [69145246, 69152430, 69165289, 69151098, 69168995, 69165203, 69152318, 69162582, 69185344]}, "name": "E. Rin and The Unknown Flower", "statement": "On a normal day at the hidden office in A.R.C. Markland-N, Rin received\r\nan artifact, given to her by the exploration captain Sagar.After much\r\nanalysis, she now realizes that this artifact contains data about a\r\nstrange flower, which has existed way before the New Age. However, the\r\ninformation about its chemical structure has been encrypted heavily.The\r\nchemical structure of this flower can be represented as a string p. From\r\nthe unencrypted papers included, Rin already knows the length n of that\r\nstring, and she can also conclude that the string contains at most three\r\ndistinct letters: \"\" (as in Carbon), \"\" (as in Hydrogen), and \"\" (as in\r\nOxygen).At each moment, Rin can input a string s of an arbitrary length\r\ninto the artifact\u2019s terminal, and it will return every starting position\r\nof s as a of p.However, the artifact has limited energy and cannot be\r\nrecharged in any way, since the technology is way too ancient and is\r\nincompatible with any current A.R.C.\u2019s devices. To be specific: The\r\nartifact only contains\r\nfrac{7}{5} units of energy. For each time Rin inputs a string s of\r\nlength t, the artifact consumes\r\nfrac{1}{t^2} units of energy. If the amount of energy reaches below\r\nzero, the task will be considered failed immediately, as the artifact\r\nwill go black forever. Since the artifact is so precious yet fragile,\r\nRin is very nervous to attempt to crack the final data. Can you give her\r\na helping hand?\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 19.01.2020 17:31:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s(n, '?');\n    auto Ask = [&](string t) {\n      cout << \"? \" << t << endl;\n      int foo;\n      cin >> foo;\n      for (int i = 0; i < foo; i++) {\n        int bar;\n        cin >> bar;\n        --bar;\n        for (int j = 0; j < (int) t.size(); j++) {\n          s[bar + j] = t[j];\n        }\n      }\n    };\n    if (n <= 7) {\n      Ask(\"CH\");\n      Ask(\"CO\");\n      if (s == string(n, '?')) {\n        if (n == 4) {\n          Ask(\"HO\");\n          if (s == string(n, '?')) {\n            Ask(\"OH\");\n            if (s == string(n, '?')) {\n              Ask(\"CCC\");\n              if (s == string(n, '?')) {\n                Ask(\"OOO\");\n                if (s[0] == 'O') {\n                  if (s[n - 1] == '?') s[n - 1] = 'C';\n                } else {\n                  Ask(\"HHH\");\n                  if (s[0] == 'H') {\n                    if (s[n - 1] == '?') s[n - 1] = 'C';\n                  } else {\n                    Ask(\"OOCC\");\n                    if (s == string(n, '?')) s = \"HHCC\";\n                  }\n                }\n              } else {\n                Ask(\"HCCC\");\n                Ask(\"OCCC\");\n              }\n            } else {\n              for (int i = 0; i < n; i++) {\n                if (s[i] == '?') {\n                  s[i] = 'O';\n                } else {\n                  break;\n                }\n              }\n              goto haha;\n            }\n          } else {\n            goto haha;\n          }\n        } else {\n          Ask(\"CC\");\n          if (s[1] != '?' && s[0] == '?') {\n            string q = s;\n            q[0] = 'H';\n            Ask(q);\n            if (s[0] == '?') {\n              s[0] = 'O';\n            }\n          } else {\n            Ask(\"OH\");\n            Ask(\"HO\");\n            if (s == string(n, '?')) {\n              Ask(string(n, 'H'));\n              Ask(string(n, 'O'));\n              if (s == string(n, '?')) {\n                string q(n, 'H');\n                q[n - 1] = 'C';\n                Ask(q);\n                if (s == string(n, '?')) {\n                  s = string(n, 'O');\n                  s[n - 1] = 'C';\n                }\n              }\n            } else {\n              if (s[n - 1] == 'C' && s.find(\"H\") == string::npos && s.find(\"O\") == string::npos) {\n                string q = s;\n                for (int i = 0; i < n; i++) {\n                  if (q[i] == '?') {\n                    q[i] = 'H';\n                  }\n                }\n                Ask(q);\n                if (s[0] == '?') {\n                  for (int i = 0; i < n; i++) {\n                    if (s[i] == '?') {\n                      s[i] = 'O';\n                    }\n                  }\n                }\n              } else {\n                int beg = 0;\n                while (beg < n) {\n                  if (s[beg] != '?') {\n                    ++beg;\n                    continue;\n                  }\n                  int end = beg;\n                  while (end + 1 < n && s[end + 1] == '?') {\n                    ++end;\n                  }\n                  if (beg == 0) {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[end + 1];\n                    }\n                  } else {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[beg - 1];\n                    }\n                  }\n                  beg = end + 1;\n                }\n                string q = s;\n                q[n - 1] = 'C';\n                Ask(q);\n              }\n            }\n          }\n        }\n      } else {\n        haha:\n        while (true) {\n          bool any = false;\n          for (int i = 0; i < n; i++) {\n            if (s[i] == '?') {\n              any = true;\n              break;\n            }\n          }\n          if (!any) {\n            break;\n          }\n          bool found = false;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] == '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] != '?' && s[i + 4] != '?') {\n              string q = \"C\";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += s[i + 4];\n              Ask(q);\n              if (s[i] == '?') {\n                q[0] = 'O';\n                Ask(q);\n                if (s[i] == '?') {\n                  s[i] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] != '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] != '?' && s[i + 4] == '?') {\n              string q = \"\";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += \"C\";\n              Ask(q);\n              if (s[i + 4] == '?') {\n                q[4] = 'O';\n                Ask(q);\n                if (s[i + 4] == '?') {\n                  s[i + 4] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] == '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] != '?') {\n              string q = \"C\";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              Ask(q);\n              if (s[i] == '?') {\n                q[0] = 'O';\n                Ask(q);\n                if (s[i] == '?') {\n                  s[i] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] != '?' && s[i + 1] != '?' && s[i + 2] != '?' && s[i + 3] == '?') {\n              string q = \"\";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += \"C\";\n              Ask(q);\n              if (s[i + 3] == '?') {\n                q[3] = 'O';\n                Ask(q);\n                if (s[i + 3] == '?') {\n                  s[i + 3] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] == '?' && s[i + 1] != '?' && s[i + 2] != '?') {\n              string q = \"C\";\n              q += s[i + 1];\n              q += s[i + 2];\n              Ask(q);\n              if (s[i] == '?') {\n                q[0] = 'O';\n                Ask(q);\n                if (s[i] == '?') {\n                  s[i] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] != '?' && s[i + 1] != '?' && s[i + 2] == '?') {\n              string q = \"\";\n              q += s[i];\n              q += s[i + 1];\n              q += \"C\";\n              Ask(q);\n              if (s[i + 2] == '?') {\n                q[2] = 'O';\n                Ask(q);\n                if (s[i + 2] == '?') {\n                  s[i + 2] = 'H';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          assert(found);\n        }\n      }\n    } else {\n      Ask(\"CH\");\n      Ask(\"CO\");\n      Ask(\"HC\");\n      Ask(\"HO\");\n      Ask(\"OC\");\n      if (s == string(n, '?')) {\n        Ask(string(n, 'C'));\n        if (s == string(n, '?')) {\n          Ask(\"OHH\");\n          if (s == string(n, '?')) {\n            Ask(string(n - 1, 'O'));\n            if (s == string(n, '?')) {\n              s = string(n, 'H');\n            } else {\n              if (s[n - 1] == '?') {\n                s[n - 1] = 'H';\n              }\n            }\n          } else {\n            for (int i = 0; i < n; i++) {\n              if (s[i] == '?') {\n                s[i] = 'O';\n              } else {\n                break;\n              }\n            }\n            for (int i = n - 1; i >= 0; i--) {\n              if (s[i] == '?') {\n                s[i] = 'H';\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        Ask(\"OHH\");\n        int pref = 0, suf = 0;\n        int beg = 0;\n        while (beg < n) {\n          if (s[beg] != '?') {\n            ++beg;\n            continue;\n          }\n          int end = beg;\n          while (end + 1 < n && s[end + 1] == '?') {\n            ++end;\n          }\n          if (beg == 0) {\n            if (s[end + 1] != 'H') {\n              for (int i = beg; i <= end; i++) {\n                s[i] = s[end + 1];\n              }\n            } else {\n              pref = end + 1;\n            }\n          } else {\n            if (end == n - 1) {\n              if (s[beg - 1] != 'O') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              } else {\n                for (int i = beg; i <= end - 1; i++) {\n                  s[i] = 'O';\n                }\n                suf = 1;\n              }\n            } else {\n              if (s[beg - 1] == 'O' && s[end + 1] == 'H') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = 'O';\n                }\n              } else {\n                assert(s[beg - 1] == s[end + 1]);\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              }\n            }\n          }\n          beg = end + 1;\n        }\n        if (pref > 0) {\n          string q = s;\n          if (suf > 0) {\n            q.pop_back();\n          }\n          for (int i = 0; i < pref; i++) {\n            q[i] = 'O';\n          }\n          Ask(q);\n          if (s[0] == '?') {\n            for (int i = 0; i < pref; i++) {\n              s[i] = 'H';\n            }\n          }\n        }\n        if (suf > 0) {\n          string q = s;\n          q[n - 1] = 'O';\n          Ask(q);\n          if (s[n - 1] == '?') {\n            s[n - 1] = 'H';\n          }\n        }\n      }\n    }\n    cout << \"! \" << s << endl;\n    int foo;\n    cin >> foo;\n    if (foo == 0) break;\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "interactive", "math"], "dificulty": "3500", "interactive": false}