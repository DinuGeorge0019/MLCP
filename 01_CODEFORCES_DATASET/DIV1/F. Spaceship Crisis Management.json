{
    "link": "https://codeforces.com//contest/1628/problem/F",
    "problemId": "1270548",
    "problem_idx": "F",
    "shortId": "1628F",
    "contest_number": "1628",
    "problem_submissions": {
        "F": [
            143704137,
            143703628,
            143702221,
            143703556,
            147001965
        ],
        "E": [
            143675713,
            143683767,
            143678064,
            143684015,
            143703839,
            143703586,
            143684851,
            143683465,
            143685498,
            143691038,
            143689260,
            143676465,
            143693250,
            143684297,
            143687706,
            143698977,
            143697149,
            143693737,
            143726859,
            143698932,
            143695817,
            143695968
        ],
        "D2": [
            143658634,
            143670285,
            143666637,
            143665499,
            143666995,
            143667409,
            143672399,
            143672413,
            143661151,
            143647661,
            143658816,
            143673791,
            143659789,
            143650476,
            143675004,
            143660718,
            143676678,
            143684084,
            143660907
        ],
        "D1": [
            143652051,
            143661015,
            143649637,
            143665355,
            143640835,
            143647447,
            143672291,
            143669534,
            143658393,
            143632054,
            143652557,
            143673638,
            143659662,
            143650805,
            143669620,
            143647751,
            143667415,
            143668369,
            143654580
        ],
        "C": [
            143648600,
            143653504,
            143662609,
            143671130,
            143659087,
            143671994,
            143662240,
            143665901,
            143679854,
            143654744,
            143666734,
            143658744,
            143650933,
            143640762,
            143660335,
            143673771,
            143662259,
            143663580,
            143684690
        ],
        "B": [
            143641041,
            143647996,
            143687560,
            143645776,
            143664691,
            143661275,
            143640613,
            143649322,
            143664737,
            143644329,
            143690738,
            143695054,
            143657006,
            143653454,
            143666253,
            143657114,
            143649062,
            143668019
        ],
        "A": [
            143633679,
            143636764,
            143632428,
            143638866,
            143635799,
            143637277,
            143632341,
            143633434,
            143635604,
            143658928,
            143634190,
            143633884,
            143633848,
            143634819,
            143640442,
            143650623,
            143643930,
            143639364,
            143636998
        ]
    },
    "name": "F. Spaceship Crisis Management",
    "statement": "Given the target position t = (0, 0), a set of n pieces of space junk l\r\ndescribed by line segments l_i = ((a_{ix}, a_{iy}), (b_{ix}, b_{iy})),\r\nand a starting position s = (s_x, s_y), is there a direction such that\r\nfloating in that direction from the starting position would lead to the\r\ntarget position?When the spaceship hits a piece of space junk, what\r\nhappens depends on the absolute difference in angle between the floating\r\ndirection and the line segment,\r\ntheta: If\r\ntheta < 45^{\r\ncirc}, the spaceship slides along the piece of space junk in the\r\ndirection that minimizes the change in angle, and when the spaceship\r\nslides off the end of the space junk, it continues floating in the\r\ndirection it came in (before hitting the space junk). If\r\ntheta\r\nge 45^{\r\ncirc}, the spaceship stops, because there is too much friction to slide\r\nalong the space junk. You are only given the set of pieces of space junk\r\nonce, and the target position is always (0, 0), but there are q queries,\r\neach with a starting position s_j = (s_{jx}, s_{jy}).Answer the above\r\nquestion for each query.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.01.2022 18:59:59       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nstruct TPoint {\n  T x;\n  T y;\n  int id;\n\n  TPoint() : x(0), y(0), id(-1) {}\n  TPoint(const T& x_, const T& y_) : x(x_), y(y_), id(-1) {}\n  TPoint(const T& x_, const T& y_, int id_) : x(x_), y(y_), id(id_) {}\n\n  static constexpr T eps = static_cast<T>(1e-9);\n\n  inline TPoint operator+(const TPoint& rhs) const { return TPoint(x + rhs.x, y + rhs.y); }\n  inline TPoint operator-(const TPoint& rhs) const { return TPoint(x - rhs.x, y - rhs.y); }\n  inline TPoint operator*(const T& rhs) const { return TPoint(x * rhs, y * rhs); }\n  inline TPoint operator/(const T& rhs) const { return TPoint(x / rhs, y / rhs); }\n\n  friend T smul(const TPoint& a, const TPoint& b) {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  friend T vmul(const TPoint& a, const TPoint& b) {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  inline T abs2() const {\n    return x * x + y * y;\n  }\n\n  inline bool operator<(const TPoint& rhs) const {\n    return (y < rhs.y || (y == rhs.y && x < rhs.x));\n  }\n\n  inline bool is_upper() const {\n    return (y > eps || (abs(y) <= eps && x > eps));\n  }\n\n  inline int cmp_polar(const TPoint& rhs) const {\n    assert(abs(x) > eps || abs(y) > eps);\n    assert(abs(rhs.x) > eps || abs(rhs.y) > eps);\n    bool a = is_upper();\n    bool b = rhs.is_upper();\n    if (a != b) {\n      return (a ? -1 : 1);\n    }\n    long long v = x * rhs.y - y * rhs.x;\n    return (v > eps ? -1 : (v < -eps ? 1 : 0));\n  }\n};\n\nusing Point = TPoint<long long>;\n//using Point = TPoint<long double>;\n\ntemplate <typename T>\nstring to_string(const TPoint<T>& p) {\n  return \"(\" + to_string(p.x) + \", \" + to_string(p.y) + \")\";\n}\n\nclass segtree {\n public:\n  struct node {\n    int val = -1;\n\n    void apply(int l, int r, int v) {\n      val = v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.val = 0;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].val != 0) {\n      tree[x + 1].apply(l, y, tree[x].val);\n      tree[z].apply(y + 1, r, tree[x].val);\n      tree[x].val = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nbool Intersect(Point a, Point b, Point c, Point d) {\n  debug(a, b, c, d);\n  long long A = b.y - a.y;\n  long long B = a.x - b.x;\n  long long C = -A * a.x - B * a.y;\n  long long z1 = A * c.x + B * c.y + C;\n  long long z2 = A * d.x + B * d.y + C;\n  if (z1 < 0 && z2 < 0) return false;\n  if (z1 > 0 && z2 > 0) return false;\n  A = d.y - c.y;\n  B = c.x - d.x;\n  C = -A * c.x - B * c.y;\n  z1 = A * a.x + B * a.y + C;\n  z2 = A * b.x + B * b.y + C;\n  if (z1 < 0 && z2 < 0) return false;\n  if (z1 > 0 && z2 > 0) return false;\n  if (z1 == 0 && z2 == 0) {\n    long long xa = a.x;\n    long long xb = b.x;\n    long long xc = c.x;\n    long long xd = d.x;\n    if (xa > xb) swap(xa, xb);\n    if (xc > xd) swap(xc, xd);\n    if (xb < xc || xd < xa) return false;\n    xa = a.y;\n    xb = b.y;\n    xc = c.y;\n    xd = d.y;\n    if (xa > xb) swap(xa, xb);\n    if (xc > xd) swap(xc, xd);\n    if (xb < xc || xd < xa) return false;\n  }\n  return true;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<Point> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i].x >> a[i].y >> b[i].x >> b[i].y;\n  }\n  int q;\n  cin >> q;\n  vector<Point> s(q);\n  for (int i = 0; i < q; i++) {\n    cin >> s[i].x >> s[i].y;\n  }\n  vector<bool> res(q, false);\n  auto Test = [&](Point vy) {\n    Point vx(vy.y, -vy.x);\n    auto Rotate = [&](Point p) {\n      return Point(smul(p, vx), smul(p, vy));\n    };\n    vector<Point> ar(n), br(n);\n    vector<long long> A(n), B(n), C(n);\n    for (int i = 0; i < n; i++) {\n      ar[i] = Rotate(a[i]);\n      br[i] = Rotate(b[i]);\n      if (ar[i].x > br[i].x) {\n        swap(ar[i], br[i]);\n      }\n      A[i] = ar[i].y - br[i].y;\n      B[i] = br[i].x - ar[i].x;\n      C[i] = -A[i] * ar[i].x - B[i] * ar[i].y;\n    }\n    vector<Point> sr(q);\n    for (int i = 0; i < q; i++) {\n      sr[i] = Rotate(s[i]);\n    }\n    sr.push_back(Point(0, 0));\n    vector<pair<long long, int>> ev;\n    for (int i = 0; i < n; i++) {\n      ev.emplace_back(ar[i].x, ~i);\n      ev.emplace_back(br[i].x, i + q + 1);\n    }\n    for (int i = 0; i <= q; i++) {\n      ev.emplace_back(sr[i].x, i);\n    }\n    sort(ev.begin(), ev.end());\n    long long X = 0;\n    auto cmp = [&](int i, int j) { \n      if (i < n && j < n) {\n        long long num_i = (-X * A[i] - C[i]);\n        long long den_i = B[i];\n        long long num_j = (-X * A[j] - C[j]);\n        long long den_j = B[j];\n        if (den_i == 0) num_i = ar[i].y, den_i = 1;\n        if (den_j == 0) num_j = ar[j].y, den_j = 1;\n        return __int128(num_i) * den_j < __int128(num_j) * den_i;\n      }\n      if (i >= n && j >= n) {\n        return sr[i - n].y < sr[j - n].y;\n      }\n      if (i < n && j >= n) {\n        long long num_i = (-X * A[i] - C[i]);\n        long long den_i = B[i];\n        if (den_i == 0) num_i = ar[i].y, den_i = 1;\n        return num_i < sr[j - n].y * den_i;\n      }\n      assert(i >= n && j < n);\n      long long num_j = (-X * A[j] - C[j]);\n      long long den_j = B[j];\n      if (den_j == 0) num_j = ar[j].y, den_j = 1;\n      return sr[i - n].y * den_j < num_j;\n    };\n    vector<vector<int>> g(n + q + 1);\n    multiset<int, decltype(cmp)> segs(cmp);\n    for (auto& e : ev) {\n      X = e.first;\n      int id = e.second;\n      if (id < 0) {\n        id = ~id;\n        auto it = segs.insert(id);\n        if (it != segs.begin()) {\n          g[*prev(it)].push_back(id);\n        }\n        auto it2 = next(it);\n        if (it2 != segs.end()) {\n          g[id].push_back(*it2);\n        }\n        continue;\n      }\n      if (id >= q + 1) {\n        id -= q + 1;\n        auto it = segs.find(id);\n        if (it != segs.begin()) {\n          auto itR = next(it);\n          if (itR != segs.end()) {\n            g[*prev(it)].push_back(*itR);\n          }\n        }\n        segs.erase(it);\n        continue;\n      }\n      auto it = segs.lower_bound(n + id);\n      if (it != segs.begin()) {\n        g[*prev(it)].push_back(n + id);\n      }\n      if (it != segs.end()) {\n        g[n + id].push_back(*it);\n      }\n    }\n    vector<int> deg(n + q + 1);\n    for (int i = 0; i < n + q + 1; i++) {\n      for (int j : g[i]) {\n        deg[j] += 1;\n      }\n    }\n    vector<int> que;\n    for (int i = 0; i < n + q + 1; i++) {\n      if (deg[i] == 0) {\n        que.push_back(i);\n      }\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (--deg[j] == 0) {\n          que.push_back(j);\n        }\n      }\n    }\n    assert((int) que.size() == n + q + 1);\n    vector<long long> xs(1, 0);\n    for (int i = 0; i < n; i++) {\n      xs.push_back(ar[i].x);\n      xs.push_back(br[i].x);\n    }\n    for (int i = 0; i < q; i++) {\n      xs.push_back(sr[i].x);\n    }\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    auto GetX = [&](long long x) {\n      auto it = lower_bound(xs.begin(), xs.end(), x);\n      assert(it != xs.end() && (*it) == x);\n      return (int) (it - xs.begin());\n    };\n    int cnt = (int) xs.size();\n    debug(vx, vy, que, g);\n    segtree st(cnt);\n    for (int i : que) {\n//      vector<int> vs;\n//      for (int ii = 0; ii < cnt; ii++) vs.push_back(st.get(ii, ii).val);\n//      debug(vs);\n      if (i == n + q) {\n        int x = GetX(0);\n        st.modify(x, x, 1);\n        continue;\n      }\n      if (i >= n) {\n        int x = GetX(sr[i - n].x);\n        if (st.get(x, x).val == 1) {\n          res[i - n] = true;\n        }\n        continue;\n      }\n      long long dx = abs(ar[i].x - br[i].x);\n      long long dy = abs(ar[i].y - br[i].y);\n      int ax = GetX(ar[i].x);\n      int bx = GetX(br[i].x);\n      if (dx >= dy) {\n        st.modify(ax, bx, -1);\n      } else {\n        int val = (ar[i].y < br[i].y ? st.get(ax, ax).val : st.get(bx, bx).val);\n        st.modify(ax, bx, val);\n      }\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    Test(a[i]);\n    Test(b[i]);\n  }\n  for (int i = 0; i < q; i++) {\n    Point p0(0, 0);\n    Point p1 = s[i];\n    bool ok = true;\n    for (int j = 0; j < n; j++) {\n      auto got = Intersect(p0, p1, a[j], b[j]);\n      debug(got);\n      if (got) {\n        ok = false;\n        break; \n      }\n    }\n    if (ok) {\n      res[i] = true;\n    }\n  }\n  for (int i = 0; i < q; i++) {\n    cout << (res[i] ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "geometry",
        "sortings"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Spaceship Crisis Management.json",
    "editorial_link": "https://codeforces.com//blog/entry/99276",
    "editorial": "The exit position at a specific segment is always the same, only the\r\nexit direction changes depending on which angle the spaceship comes in\r\nat. Therefore, if we know the set of directions that are good to hit a\r\nsegment at, we know if a path that hits the segment is good or not. Note\r\nthat itâs only useful to consider directions that are either the\r\ndirection from the closest point on some segment to the target, or from\r\nsome starting position to the target. Letâs call these directions .Slow\r\nsolution: We can use DP to determine the set of useful directions for\r\neach segment: Sort the segments by distance to the target, and for each\r\nsegment try shooting a ray in every relevant direction that is within 45\r\ndegrees of the direction of the segment itself, and see if it either\r\nhits the target or a segment where that direction is good. The\r\ncomparison with 45 degrees can be done exactly using e.g. properties of\r\nthe dot product. Then for each starting position query, the same ray\r\nshooting can be done. This is because there are relevant directions,\r\npositions from which to shoot rays, and segments to check intersection\r\nwith. This is too slow.We found two different ways to optimize this:1.\r\nSince we need to know what a ray hits for many different directions from\r\nthe same origin, we could do some preprocessing at each origin. A\r\nLi-Chao tree traditionally finds the minimum y-value at a certain\r\nx-coordinate among a set of line segments. But it doesnât have to\r\ncontain line segments. It can contain any set of functions such that any\r\npair of them intersect at most once. This includes distance to 2D line\r\nsegments from a fixed origin as a function of angle. Using this, we can\r\nfor each origin do time precomputation to get time per query to a single\r\ndirection, resulting in the time complexity 2. Solution by Maksim1744:\r\nIf we fix the floating direction, the movement between space junk forms\r\nedges in a functional graph. We can use a sweep to build the graph and\r\nthen for each starting position and determine if it reaches the target\r\nin the graph. Doing this for all relevant directions also results in a\r\ntime a complexity of\r\n",
    "hint": []
}