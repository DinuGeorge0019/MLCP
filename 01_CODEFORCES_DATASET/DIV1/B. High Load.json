{"link": "https://codeforces.com//contest/827/problem/B", "problemId": "113846", "problem_idx": "B", "shortId": "827B", "contest_number": "827", "problem_submissions": {"F": [28447535, 28704912], "B": [28442493, 28434829, 28432891, 28434941, 28434124, 28440743, 28434219, 28434038, 28435758, 28436170, 28442340, 28436191, 28436588, 28434003, 28436389, 28434757, 28437055, 28448594, 28438989], "C": [28440487, 28438660, 28438441, 28438938, 28437666, 28446435, 28437809, 28439569, 28439405, 28439836, 28438472, 28441170, 28440770, 28437931, 28442353, 28442274, 28441410, 28437286, 28455031, 28442955], "E": [28436548, 28441080, 28466758, 28444795, 28441962, 28439200, 28445462, 28450329, 28446470, 28443820, 28444149, 28441607, 28444424, 28451564, 28465030, 28453083, 28453061, 28452855, 28445979, 28445398, 28447328, 28450262, 28443711, 28447639], "A": [28432871, 28432173, 28431465, 28433215, 28452981, 28437424, 28432872, 28451754, 28432696, 28432687, 28432382, 28432827, 28432606, 28431751, 28435184, 28437702, 28433063, 28446111, 28434053], "D": [28445554, 28441989, 28447486, 28446928, 28441195, 28445740, 28448719, 28454047, 28460505, 28543175, 28454400, 28446342, 28447977, 29638472, 28445305, 28443739]}, "name": "B. High Load", "statement": "Arkady needs your help again! This time he decided to build his own\r\nhigh-speed Internet exchange point. It should consist of nodes connected\r\nwith minimum possible number of wires into one network (a wire directly\r\nconnects two nodes). Exactly of the nodes should be exit-nodes, that\r\nmeans that each of them should be connected to exactly one other node of\r\nthe network, while all other nodes should be connected to at least two\r\nnodes in order to increase the system stability.Arkady wants to make the\r\nsystem as fast as possible, so he wants to minimize the maximum distance\r\nbetween two exit-nodes. The distance between two nodes is the number of\r\nwires a package needs to go through between those two nodes.Help Arkady\r\nto find such a way to build the network that the distance between the\r\ntwo most distant exit-nodes is as small as possible.\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nVI ex,ey;\nin co(in n, in k){\n  if(n==1)\n    return 0;\n  if(n==2){\n    ex.PB(0);\n    ey.PB(1);\n    return 1;\n  }\n  k=min(k,n-1);\n  assert(k>=2);\n  if(n==k+1){\n    for(in i=n-1;i>=n-k;--i){\n      ex.PB(0);\n      ey.PB(i);\n    }\n    return 2;\n  }\n  if(n==k+2){\n    ex.PB(0);\n    ey.PB(2);\n    ex.PB(0);\n    ey.PB(1);\n    for(in i=3;i<n;++i){\n      ex.PB(1);\n      ey.PB(i);\n    }\n    return 3;\n  }\n  in sf=co(n-k,k);\n  in nxtu=n-k-1;\n  for(in i=nxtu+1;i<n;++i){\n    ex.PB(nxtu--);\n    if(nxtu<0)\n      nxtu=0;\n    ey.PB(i);\n  }\n  return 2+sf;\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,k;\n  cin>>n>>k;\n  cout<<co(n,k)<<\"\\n\";\n  forv(i,ex){\n    cout<<ex[i]+1<<\" \"<<ey[i]+1<<\"\\n\";\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "implementation", "trees"], "dificulty": "1800", "interactive": false}