{
    "link": "https://codeforces.com//contest/1098/problem/E",
    "problemId": "278464",
    "problem_idx": "E",
    "shortId": "1098E",
    "contest_number": "1098",
    "problem_submissions": {
        "E": [
            51775559,
            48006690,
            48011091,
            47996318,
            48015799,
            48015745,
            48015679,
            48016465
        ],
        "D": [
            47994331,
            47991784,
            48004915,
            47986667,
            47997263,
            47997207,
            47997823,
            48003406,
            48012772,
            48000542,
            48002246,
            47998686,
            48003172,
            48003847,
            48013739,
            48013700,
            48013652,
            48012961,
            48012955,
            48007481,
            48004946,
            47998449,
            48006927,
            47993907
        ],
        "C": [
            47990851,
            47988182,
            48002088,
            47984104,
            47990986,
            47992891,
            47990373,
            47996864,
            47993728,
            47992046,
            48002685,
            47997828,
            47997416,
            47983441,
            47996246,
            48004923,
            47992474,
            48000276
        ],
        "B": [
            47984141,
            47982505,
            48010238,
            47997345,
            47983353,
            47986135,
            47985242,
            47985258,
            47997818,
            47982827,
            47991394,
            47990410,
            47990108,
            47991143,
            47984918,
            47988149,
            47999187,
            48005571
        ],
        "A": [
            47975157,
            47974213,
            48009223,
            47974115,
            47975580,
            47975415,
            47977674,
            47976551,
            47976714,
            47995866,
            47975779,
            47977103,
            47975994,
            47986982,
            47978302,
            47975716,
            47976034,
            47978693
        ],
        "F": [
            54648301
        ]
    },
    "name": "E. Fedya the Potter",
    "statement": "Fedya loves problems involving data structures. Especially ones about\r\ndifferent queries on subsegments. Fedya had a nice array a_1, a_2,\r\nldots a_n and a beautiful data structure. This data structure, given l\r\nand r, 1\r\nle l\r\nle r\r\nle n, could find the greatest integer d, such that d divides each of\r\na_l, a_{l+1}, ..., a_{r}. Fedya really likes this data structure, so he\r\napplied it to every non-empty contiguous subarray of array a, put all\r\nanswers into the array and sorted it. He called this array b. It\u2019s easy\r\nto see that array b contains n(n+1)/2 elements.After that, Fedya\r\nimplemented another cool data structure, that allowed him to find sum\r\nb_l + b_{l+1} +\r\nldots + b_r for given l and r, 1\r\nle l\r\nle r\r\nle n(n+1)/2. Surely, Fedya applied this data structure to every\r\ncontiguous subarray of array b, called the result c and sorted it. Help\r\nFedya find the lower median of array c.Recall that for a sorted array of\r\nlength k the is an element at position\r\nlfloor\r\nfrac{k + 1}{2}\r\nrfloor, if elements of the array are enumerated starting from 1. For\r\nexample, the lower median of array (1, 1, 2, 3, 6) is 2, and the lower\r\nmedian of (0, 17, 23, 96) is 17.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n\nint n;\nint tab[nax];\n\nll ile[nax];\n\nll m;\n\nvoid rek(int a, int b)\n{\n\tif (a>b)\n\t\treturn;\n\tint s=(a+b)>>1;\n\tvector <pll> l, p;\n\tint x=0;\n\tfor (int i=s; i>=a; i--)\n\t{\n\t\tx=__gcd(x, tab[i]);\n\t\tif (l.empty() || x!=l.back().first)\n\t\t\tl.push_back({x, 0});\n\t\tl.back().second++;\n\t}\n\tx=0;\n\tfor (int i=s; i<=b; i++)\n\t{\n\t\tx=__gcd(x, tab[i]);\n\t\tif (p.empty() || x!=p.back().first)\n\t\t\tp.push_back({x, 0});\n\t\tp.back().second++;\n\t}\n\tfor (pll i : l)\n\t\tfor (pll j : p)\n\t\t\tile[__gcd(i.first, j.first)]+=i.second*j.second;\n\trek(a, s-1);\n\trek(s+1, b);\n}\n\nll brut(ll v)\n{\n\tvll wek;\n\tfor (int i=1; i<nax; i++)\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t\twek.push_back(i);\n\tll ret=0;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=i; j<(int)wek.size(); j++)\n\t\t{\n\t\t\ts+=wek[j];\n\t\t\tif (s>v)\n\t\t\t\tbreak;\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll brut2(ll v)\n{\n\tvll wek;\n\tfor (int i=1; i<nax; i++)\n\t\tfor (int j=0; j<ile[i]; j++)\n\t\t\twek.push_back(i);\n\tll ret=0;\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=i; j<(int)wek.size(); j++)\n\t\t{\n\t\t\ts+=wek[j];\n\t\t\tif (s>v)\n\t\t\t\tbreak;\n\t\t\tif (wek[j]!=wek[i])\n\t\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nll daj(pll v)\n{\n\treturn v.first*v.second;\n}\n\nll sum[nax];\n\nll magiabr(ll lim, ll a, ll m1, ll b, ll m2)\n{\n\tll ret=0;\n\tfor (ll i=1; i<=m1; i++)\n\t\tfor (ll j=1; j<=m2; j++)\n\t\t\tif (i*a+j*b<=lim)\n\t\t\t\tret++;\n\t//~ debug() << imie(ret);\n\treturn ret;\n}\n\nnamespace copypaste\n{\n  void eukl(ll &x, ll &y, ll a, ll b) {\n  if (!a) { x = 0; y = 1; return; }\n  eukl(y, x, b % a, a);\n  x -= y * (b / a);\n}\n\nll euklides(ll y, ll x, ll d)\n{\n\tif (!y)\n\t\treturn d+1;\n\tif (y>=x)\n\t{\n\t\tll dz=y/x;\n\t\tll ile=d*(d+1)/2;\n\t\treturn euklides(y%x, x, d)+dz*ile;\n\t}\n\telse\n\t{\n\t\tll ile=(d*y+x-1)/x;\n\t\tll sum=(d+1)*(ile+1)+1+d/x+((ile*x)/y-d);\n\t\treturn sum-euklides(x, y, ile);\n\t}\n}\n\nll main2(ll a, ll b, ll c)\n{\n\t//~ ll a, b, c;\n\t//~ scanf(\"%lld%lld%lld\", &a, &b, &c);\n\tif (a>c || b>c)\n\t{\n\t\t//~ printf(\"%lld\\n\", 1+c/a+c/b);\n\t\treturn 1+c/a+c/b;\n\t\t//~ return 0;\n\t}\n\tll g=__gcd(a, b);\n\tc/=g;\n\ta/=g;\n\tb/=g;\n\tll x, y;\n\teukl(x, y, a, b);\n\tx*=(c%a);\n\ty*=(c%a);\n\tx+=(c/a);\n\tassert(x*a+b*y==c);\n\t\n\tif (x<0)\n\t{\n\t\tll ile=(-x-1)/b;\n\t\tx+=ile*b;\n\t\ty-=ile*a;\n\t}\n\tif (x>=0)\n\t{\n\t\tll ile=x/b+1;\n\t\tx-=ile*b;\n\t\ty+=ile*a;\n\t}\n\t\n\tassert(x*a+b*y==c);\n\tassert(x<0);\n\tassert(x+b>=0);\n\t\n\tll p=c/b;\n\t\n\tll wyn=x*(p+1);\n\twyn-=euklides(b, a, y-p-1);\n\twyn+=euklides(b, a, y);\n\t\n\treturn wyn;\n\t//~ printf(\"%lld\\n\", wyn);\n\t//~ return 0;\n}\n}//copy\n\nll trzesienie(ll a, ll b, ll c) {\n\tif (c<0) return 0;\n\tif (a>b) swap(a, b);\n\tll p=c/b;\n\tll k=b/a;\n\tll d=(c-p*b)/a;\n\treturn trzesienie(b-k*a, a, c-a*(k*p+d+1))+(p+1)*(d+1)+k*p*(p+1)/2;\n}\n\nll eukl(ll lim, ll a, ll b)\n{\n\tif (lim<0)\n\t\treturn 0;\n\treturn trzesienie(a, b, lim);\n\t//~ if (!a)\n\t\t//~ return lim/b+1;\n\t//~ if (!b)\n\t\t//~ return lim/a+1;\n\t//~ ll ret=0;\n\t//~ for (ll i=0; i*a<=lim; i++)\n\t//~ {\n\t\t//~ for (ll j=0; j*b<=lim; j++)\n\t\t\t//~ if (i*a+j*b<=lim)\n\t\t\t\t//~ ret++;\n\t//~ }\n\t//~ return ret;\n}\n\nll magia(ll lim, ll a, ll x, ll b, ll y)\n{\n\tlim-=a+b;\n\tif (lim<0)\n\t\treturn 0;\n\tif (lim>=(x-1)*a+(y-1)*b)\n\t\treturn x*y;\n\t//~ return eukl(lim, a, x, b, y);\n\treturn eukl(lim, a, b)-eukl(lim-x*a, a, b)-eukl(lim-y*b, a, b)+eukl(lim-x*a-y*b, a, b);\n}\n\nll licz(ll v)\n{\n\t//~ return brut(v);\n\tll ret=0;\n\tfor (int i=1; i<nax; i++)\n\t{\n\t\tif (!ile[i])\n\t\t\tcontinue;\n\t\tll w=min(ile[i], v/i);\n\t\tret+=w*(2*ile[i]-w+1)/2;\n\t}\n\t//~ return ret+brut2(v);\n\tvector<pll> wek;\n\tfor (int i=1; i<nax; i++)\n\t\tif (ile[i])\n\t\t\twek.push_back({i, ile[i]});\n\tint r=wek.size();\n\tint w=0;\n\tll trz=0;\n\tsum[0]=0;\n\tfor (int i=0; i<r; i++)\n\t\tsum[i+1]=sum[i]+wek[i].second;\n\t//~ debug() << \"jade \" << v << \" \" << wek;\n\tfor (int i=0; i<r; i++)\n\t{\n\t\tw=max(w, i);\n\t\tif (w==i)\n\t\t\ttrz=0;\n\t\twhile(w+1<r && trz+daj(wek[w+1])<=v)\n\t\t{\n\t\t\tw++;\n\t\t\ttrz+=daj(wek[w]);\n\t\t}\n\t\tif (w+1!=r)\n\t\t\tret+=magia(v-trz, wek[i].first, wek[i].second, wek[w+1].first, wek[w+1].second);\n\t\t//~ debug() << \"kurwa \" << i << \" \" << w << \"    \" << trz;\n\t\tll ter=trz;\n\t\tfor (int j=w; j>i; j--)\n\t\t{\n\t\t\tter-=daj(wek[j]);\n\t\t\tif (ter+daj(wek[j])+daj(wek[i])<=v)\n\t\t\t{\n\t\t\t\tret+=wek[i].second*(sum[j+1]-sum[i+1]);\n\t\t\t\t//~ debug() << \"hurt \" << wek[i].second*(sum[j+1]-sum[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret+=magia(v-ter, wek[i].first, wek[i].second, wek[j].first, wek[j].second);\n\t\t}\n\t\t\n\t\tif (i+1!=r)\n\t\t\ttrz-=daj(wek[i+1]);\n\t}\n\t//~ assert(ret==brut(v));\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\trek(1, n);\n\t//~ for (int i=1; i<nax; i++)\n\t\t//~ if (ile[i])\n\t\t\t//~ debug() << i << \" \" << ile[i];\n\tll pom=n*(n+1LL)/2;\n\tm=(pom*(pom+1))/2;\n\tm=(m+1)/2;\n\tdebug() << imie(m);\n\tll bsa=1;\n\tll bsb=0;\n\tfor (int i=1; i<nax; i++)\n\t\tbsb+=i*ile[i];\n\t//~ debug() << imie(bsb);\n\twhile(bsa<bsb)\n\t{\n\t\tll bss=(bsa+bsb)>>1;\n\t\tif (licz(bss)>=m)\n\t\t\tbsb=bss;\n\t\telse\n\t\t\tbsa=bss+1;\n\t}\n\tprintf(\"%lld\\n\", bsa);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Fedya the Potter.json",
    "editorial_link": "https://codeforces.com/blog/entry/64331",
    "editorial": "There are different values of gcd, because if we fix the left bound of a\r\nsegment and iterate right bound from left bound to the end, the gcd\r\nstays unchanged or decreases in two or more times. We can get a\r\ncompressed version of array if we compress equal consecutive elements in\r\nto pair . We can use segment tree to find all segments of equal\r\nelements.Let\u00e2\u0080\u0099s estimate how many segments in array have sum less or\r\nequals some . If size of array had been small, we could have done the 2\r\npointers technique to do that. Unfortunately, size of array is .\r\nHowever, array has a lot of equal elements. So, the solution is to\r\nprocess a group of equal elements in a fast way. Let\u00e2\u0080\u0099s fix bounds and in\r\narray , assume - is a sum of elements beetwen and , after we have a\r\ngroup of elements , with size , after we have a group of elements , with\r\nsize . Then, it is easy to see that our task is to find out how many\r\npairs of integers satisfy the condition: .This is a standard task where\r\nwe need to calculate all integer points under a line that can be done\r\nwith the euclidean algorithm. Here the example of a plot of this\r\nfunction: To find the median element, we can use a binary search with\r\nthe above function.\r\n"
}