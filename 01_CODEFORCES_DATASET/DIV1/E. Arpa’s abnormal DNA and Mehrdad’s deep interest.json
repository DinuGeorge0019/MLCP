{"link": "https://codeforces.com//contest/741/problem/E", "problemId": "83314", "problem_idx": "E", "shortId": "741E", "contest_number": "741", "problem_submissions": {"D": [22777729, 22777450, 22755590, 22758367, 22756137, 22808584, 22805290, 22759931, 22759071, 22750711, 22754148, 22814636, 47300114, 22755389, 22758896, 22756607, 22790736, 22757335, 22793289], "C": [22742829, 22742451, 22758088, 22742404, 22760066, 22743932, 22747335, 22749445, 22763475, 22742054, 22742076, 22737953, 22744276, 22742907, 22746646], "B": [22738380, 22738003, 22739684, 22748249, 22740546, 22740616, 22739371, 22740551, 22740349, 22741081, 22738198, 22739206, 22740665, 22739327, 22739681, 22737298, 22743723, 22740079, 22738120, 22735907], "A": [22734595, 22733654, 22736292, 22744160, 22745379, 22739567, 22735733, 22736022, 22736152, 22736425, 22735084, 22735416, 22736004, 22734761, 22740072, 22741265, 22735495, 22735318, 22738723], "E": [22798525]}, "name": "E. Arpa\u2019s abnormal DNA and Mehrdad\u2019s deep interest", "statement": "Anyone knows that Arpa isn\u2019t a normal man, he is ... well, sorry, I\r\ncan\u2019t explain it more. Mehrdad is interested about the reason, so he\r\nasked Sipa, one of the best biology scientists in Arpa\u2019s land, for help.\r\nSipa has a DNA editor. Sipa put Arpa under the DNA editor. DNA editor\r\nshowed Arpa\u2019s DNA as a string consisting of lowercase English letters.\r\nAlso Sipa has another DNA consisting of lowercase English letters that\r\nbelongs to a normal man.Now there are options to change Arpa\u2019s DNA,\r\nnumbered from to . -th of them is to put between -th and -th characters\r\nof (). If , will be put before , and if , it will be put after .Mehrdad\r\nwants to choose the most option for Arpa\u2019s DNA among these options. DNA\r\nis more than if is lexicographically smaller than . Mehrdad asked Sipa\r\nquestions: Given integers , what is the most interesting option if we\r\nonly consider such options that and ? If there are several most\r\ninteresting options, Mehrdad wants to know one with the smallest number\r\n.Since Sipa is a biology scientist but not a programmer, you should help\r\nhim.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 201000;\nconst int B = 300;\n\nstruct STrmq {\n  vector<vector<int>> table;\n  vector<int> logs, array;\n\n  STrmq(const vector<int>& a) {\n    if (a.size() == 0) return;\n\n    array = a;\n    int lg = 0;\n    while ((1<<lg) <= (int)a.size()) lg++;\n    table = vector<vector<int>>(a.size(), vector<int>(lg));\n\n    REP(i, (int)a.size()) table[i][0] = i;\n    FOR(j, 1, lg) REP(i, (int)a.size()) {\n      if (i + (1<<(j-1)) < (int)a.size() && a[ table[i+(1<<(j-1))][j-1] ] < a[ table[i][j-1] ]) {\n        table[i][j] = table[i+(1<<(j-1))][j-1];\n      } else {\n        table[i][j] = table[i][j-1];\n      }\n    }\n\n    logs.resize(a.size() + 1);\n    logs[0] = 0;\n    FOR(i, 1, (int)a.size() + 1)\n      logs[i] = logs[i - 1] + (i == (1 << (logs[i-1]+1)));\n  }\n\n  int query(int a, int b) {\n    int k = logs[b - a + 1];\n    if (array[table[a][k]] <= array[table[b-(1<<k)+1][k]]) {\n      return table[a][k];\n    } else {\n      return table[b-(1<<k)+1][k];\n    }\n  }\n};\n\nvector<int> RMQ(const vector<int>& array, const vector<pair<int, int>>& queries) {\n  int n = array.size();\n  vector<int> dad(n);\n  function<int (int)> findset = [&] (int x) {\n    return x == dad[x] ? x : dad[x] = findset(dad[x]);\n  };\n \n  vector<vector<int>> qs(n);\n  REP(i, (int)queries.size()) qs[queries[i].second].push_back(i);\n\n  vector<int> ans(queries.size());\n  vector<int> stack;\n  REP(i, n) {\n    dad[i] = i;\n    while (stack.size() && array[stack.back()] > array[i]) {\n      dad[stack.back()] = i;\n      stack.pop_back();\n    }\n    stack.push_back(i);\n    for (int qi: qs[i]) ans[qi] = findset(queries[qi].first);\n  }\n  \n  return ans;\n}\n\nnamespace SuffixArray {\n  const int MAXN = 200020;\n\n  int lcp[MAXN], A[MAXN];\n  \n  void build(char *s, int n) {\n    static int tmp[MAXN], bc[MAXN];\n    REP(i, n) A[i] = i, bc[i] = s[i];\n\n    for (int T = 1; ; T *= 2) {\n      auto cmp = [&s, &T, &n] (const int &a, const int &b) {\n\tif (bc[a] != bc[b]) return bc[a] < bc[b];\n\tif (a+T >= n || b+T >= n) return a > b;\n\treturn bc[a+T] < bc[b+T];\n      };\n      sort(A, A + n, cmp);\n      tmp[A[0]] = 0;\n      FOR(i, 1, n) tmp[A[i]] = tmp[A[i-1]] + cmp(A[i-1], A[i]);\n      REP(i, n) bc[i] = tmp[i];\n      if (bc[A[n-1]] == n-1) break;\n    }\n\n    lcp[0] = 0;\n    int h = 0;\n    REP(i, n)\n      if (bc[i] > 0) {\n\tint j = A[ bc[i]-1 ];\n\twhile (i+h < n && j+h < n && s[i+h] == s[j+h]) h++;\n\tlcp[bc[i]] = h;\n\tif (h > 0) --h;\n      }\n  }\n};\n\nchar s[MAX];\nchar t[MAX];\nchar a[MAX];\n\nint slen, tlen;\n\nint main(void) {\n  int q;\n  scanf(\"%s %s %d\", s, t, &q);\n  slen = strlen(s);\n  tlen = strlen(t);\n\n  REP(i, slen) a[i] = s[i];\n  REP(i, tlen) a[slen + i] = t[i];\n\n  SuffixArray::build(a, slen + tlen);\n  int* A = SuffixArray::A;\n  int* lcp = SuffixArray::lcp;\n  vector<int> invA(slen + tlen);\n  REP(i, slen + tlen) invA[A[i]] = i;\n  \n  STrmq lcp_rmq(vector<int>(lcp, lcp + slen + tlen));\n  auto get_lcp = [&] (int i, int j) {\n    assert(i < slen + tlen && j < slen + tlen);\n    if (i == j) return slen + tlen - i;\n    i = invA[i], j = invA[j];\n    if (i > j) swap(i, j);\n    return lcp[lcp_rmq.query(i + 1, j)];\n  };\n\n  vector<int> v;\n  REP(i, slen + 1) v.push_back(i);\n\n  sort(v.begin(), v.end(), [&] (int x, int y) {\n      int l;\n      bool flip = false;\n      if (x < y) swap(x, y), flip = true;\n      if (x-y >= tlen) {\n        if ((l = get_lcp(y, slen)) < tlen) return (a[y+l] < a[slen+l]) ^ flip;\n        if ((l = get_lcp(y+tlen, y)) < x-y-tlen) return (a[y+tlen+l] < a[y+l]) ^ flip;\n        if ((l = get_lcp(slen, x-tlen)) < tlen) return (a[slen+l] < a[x-tlen+l]) ^ flip;\n      } else {\n        if ((l = get_lcp(y, slen)) < x-y) return (a[y+l] < a[slen+l]) ^ flip;\n        if ((l = get_lcp(slen, slen+x-y)) < tlen-(x-y)) return (a[slen+l] < a[slen+x-y+l]) ^ flip;\n        if ((l = get_lcp(slen+tlen-(x-y), y)) < (x-y)) return (a[slen+tlen-(x-y)+l] < a[y+l]) ^ flip;\n      }\n      return (x < y) ^ flip;\n    }\n  );\n\n  int n = slen + 1;\n  vector<int> a(n);\n  REP(i, n) a[v[i]] = i;\n  \n  STrmq rmq(a);\n\n  vector<pair<int, int>> ans(q);\n  vector<int> ql(q), qr(q), qk(q), qx(q), qy(q);\n  vector<vector<int>> qs(B);\n\n  REP(i, q) {\n    scanf(\"%d %d %d %d %d\", &ql[i], &qr[i], &qk[i], &qx[i], &qy[i]);\n    \n    ans[i] = {n, -1};\n    \n    if (qk[i] < B) {\n      qs[qk[i]].push_back(i);\n    } else {\n      int x = qx[i], y = qy[i];\n      while (x < n) {\n        int l = max(ql[i], x);\n        int r = min(qr[i], y);\n        if (l <= r) {\n          int best = rmq.query(l, r);\n          ans[i] = min(ans[i], {a[best], best});\n        }\n        x += qk[i], y += qk[i];\n      }\n    }\n  }\n    \n  FOR(k, 1, B) {\n    REP(i, k) {\n      vector<int> v;\n      for (int j = i; j < n; j += k)\n        v.push_back(a[j]);\n\n      vector<pair<int, int>> queries;\n      vector<int> queries_id;\n      \n      for (int qi: qs[k]) {\n        if (qx[qi] <= i && i <= qy[qi] && qr[qi] >= i) {\n          int l = (ql[qi]-i+k-1) / k;\n          int r = (qr[qi]-i) / k;\n          if (l <= r) {\n            queries.push_back({l, r});\n            queries_id.push_back(qi);\n          }\n        }\n      }\n\n      if (v.size() && queries.size()) {\n        vector<int> mins = RMQ(v, queries);\n        REP(j, (int)mins.size()) {\n          int qi = queries_id[j];\n          int best = mins[j]*k + i;\n          ans[qi] = min(ans[qi], {a[best], best});\n        }\n      }\n    }\n  }\n  \n  REP(i, q) printf(\"%d \", ans[i].second);\n  printf(\"\\n\");\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "string suffix structures"], "dificulty": "3400", "interactive": false}