{
    "link": "https://codeforces.com//contest/1477/problem/B",
    "problemId": "879396",
    "problem_idx": "B",
    "shortId": "1477B",
    "contest_number": "1477",
    "problem_submissions": {
        "F": [
            106163553,
            106080431,
            106150219,
            105761318,
            105790194,
            105781844
        ],
        "E": [
            105766462,
            105760921,
            105747638,
            105773646,
            105773472,
            105764661,
            105770759,
            105771270,
            105749455,
            107250678,
            107250631,
            105808122
        ],
        "D": [
            105731973,
            105737956,
            105755294,
            105737357,
            105717044,
            105720581,
            105719208,
            105736745,
            105737576,
            105738580,
            105738914,
            105740692,
            105740131,
            105745290,
            105736926,
            105743296,
            105740891,
            105744844
        ],
        "C": [
            105691291,
            105711864,
            105715665,
            105695858,
            105694977,
            105690018,
            105684885,
            105689512,
            105691536,
            105703366,
            105691967,
            105704561,
            105705153,
            105695098,
            105696313,
            105696567,
            105685916,
            105688953,
            105706121,
            105699876
        ],
        "B": [
            105686611,
            105689935,
            105698256,
            105689750,
            105687613,
            105687015,
            105689324,
            105687283,
            105688577,
            105688486,
            105689038,
            105688335,
            105694661,
            105689327,
            105691535,
            105686246,
            105746534,
            105716194,
            105694969,
            105691857
        ],
        "A": [
            105676617,
            105680391,
            105688488,
            105677583,
            105677613,
            105677290,
            105676167,
            105677997,
            105678469,
            105681155,
            105678265,
            105679581,
            105683427,
            105682439,
            105681417,
            105677926,
            105677952,
            105676881,
            105698728,
            105687449
        ]
    },
    "name": "B. Nezzar and Binary String",
    "statement": "Nezzar has a binary string s of length n that he wants to share with his\r\nbest friend, Nanako. Nanako will spend q days inspecting the binary\r\nstring. At the same time, Nezzar wants to change the string s into\r\nstring f during these q days, because it looks better.It is known that\r\nNanako loves consistency so much. On the i-th day, Nanako will inspect a\r\nsegment of string s from position l_i to position r_i inclusive. If the\r\nsegment contains both characters \u201d and \u201d, Nanako becomes unhappy and\r\nthrows away the string.After this inspection, at the i-th night, Nezzar\r\ncan secretly change than half of the characters in the segment from l_i\r\nto r_i inclusive, otherwise the change will be too obvious.Now Nezzar\r\nwonders, if it is possible to avoid Nanako being unhappy and at the same\r\ntime have the string become equal to the string f at the end of these q\r\ndays and nights.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//atcoder-library \u3092\u307e\u3042\u307e\u3042\u30b3\u30d4\u30fc\u3057\u3066\u4f7f\u3063\u3066\u3044\u308b\n\n//N() \u304c\u5358\u4f4d\u5143\n\n//merge \u3067\u7247\u65b9\u304c inactive \u306e\u3068\u304d\u306f\u3082\u3046\u7247\u65b9\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\uff0c\n//\u3068\u3044\u3063\u305f\u3068\u304d\u306b\uff0clazy \u306e\u60c5\u5831\u307e\u3067\u30b3\u30d4\u30fc\u3057\u3066\u6e21\u3055\u306a\u3044\u3088\u3046\u306b\u3059\u308b\n\n//get \u306e\u6700\u5f8c\u306e\u5f15\u6570\u306f\u5358\u4f4d\u5143\u3068\u53e3\u3067\u306f\u8a00\u3044\u3064\u3064\u30fb\u30fb\u30fb\uff1f\n//\u305f\u3068\u3048\u3070 min \u3067\u6700\u5f8c\u306e\u5f15\u6570\u3092 0 \u306b\u3057\u3066\u3082 1 \u3068\u304b\u304c\u8fd4\u3063\u3066\u304f\u308b\u3053\u3068\u306f\u3042\u308b\uff08\u4e00\u6557\uff09\n\n//VERIFY:\n//https://atcoder.jp/contests/practice2/tasks/practice2_k\ntemplate<class N>\nstruct seglazy{\n\tvc<N> x;\n\tint L,s;\n\tseglazy(){}\n\ttemplate<class T>\n\tseglazy(const vc<T>& a){\n\t\tint n=a.size();\n\t\tL=0;\n\t\twhile((1<<L)<n)L++;\n\t\ts=1<<L;\n\t\tx.resize(s*2);\n\t\trep(i,n)x[s+i]=N(a[i]);\n\t\tgnr(i,1,s)upd(i);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tN composite(int l,int r){\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif(l==r)return N();\n\t\t\n\t\tl+=s;\n\t\tr+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\t\t\n\t\tN sml,smr;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) sml = N::merge(sml, x[l++]);\n\t\t\tif (r & 1) smr = N::merge(x[--r], smr);\n\t\t\tl >>= 1;\n\t\t\tr >>= 1;\n\t\t}\n\n\t\treturn N::merge(sml, smr);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int l, int r, F f,Args&&... args) {\n\t\tassert(0<=l&&l<=r&&r<=s);\n\t\tif (l == r) return;\n\n\t\tl+=s;\n\t\tr+=s;\n\n\t\tfor (int i = L; i >= 1; i--) {\n\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t}\n\n\t\t{\n\t\t\tint l2 = l, r2 = r;\n\t\t\twhile (l < r) {\n\t\t\t\tif (l & 1){\n\t\t\t\t\t(x[l++].*f)(forward<Args>(args)...);\n\t\t\t\t}\n\t\t\t\tif (r & 1){\n\t\t\t\t\t(x[--r].*f)(forward<Args>(args)...);\n\t\t\t\t}\n\t\t\t\tl >>= 1;\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tl = l2;\n\t\t\tr = r2;\n\t\t}\n\n\t\tfor (int i = 1; i <= L; i++) {\n\t\t\tif (((l >> i) << i) != l) upd(l >> i);\n\t\t\tif (((r >> i) << i) != r) upd((r - 1) >> i);\n\t\t}\n\t}\n\tN getall(){return x[1];}\n\ttemplate <class F,class... Args> \n\tpair<int,N> max_right(int l,F f,Args&&... args){\n\t\tassert(0<=l&&l<=s);\n\t\tif(l==s)return mp(s,N());\n\t\tl+=s;\n\t\t\n\t\tfor (int i = L; i >= 1; i--) push(l >> i);\n\t\tN sm;\n\t\tassert((sm.*f)(forward<Args>(args)...));\n\t\tdo {\n\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\tif (!(N::merge(sm,x[l]).*f)(forward<Args>(args)...)){\n\t\t\t\twhile (l < s) {\n\t\t\t\t\tpush(l);\n\t\t\t\t\tl = (2 * l);\n\t\t\t\t\tN tmp=N::merge(sm,x[l]);\n\t\t\t\t\tif ((tmp.*f)(forward<Args>(args)...)) {\n\t\t\t\t\t\tsm = tmp;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mp(l - s,sm);\n\t\t\t}\n\t\t\tsm = N::merge(sm, x[l]);\n\t\t\tl++;\n\t\t} while ((l & -l) != l);\n\t\treturn mp(s,sm);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid point_change(int p,F f,Args&&...args){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\t(x[p].*f)(forward<Args>(args)...);\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tN point_get(int p){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\treturn x[p];\n\t}\n\tvoid point_set(int p,N val){\n\t\tassert(0 <= p && p < s);\n\t\tp += s;\n\t\tfor (int i = L; i >= 1; i--) push(p >> i);\n\t\tx[p]=val;\n\t\tfor (int i = 1; i <= L; i++) upd(p >> i);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n};\n\nstruct N{\n\tint len,cnt[2],lz;\n\tN(int v=-1):len(v==-1?0:1),cnt{v==0,v==1},lz(-1){}\n\tvoid set_val(int v){\n\t\tassert(v==0||v==1);\n\t\tcnt[v]=len;\n\t\tcnt[v^1]=0;\n\t\tlz=v;\n\t}\n\tvoid push(N&x,N&y){\n\t\tif(lz!=-1){\n\t\t\tx.set_val(lz);\n\t\t\ty.set_val(lz);\n\t\t}\n\t\tlz=-1;\n\t}\n\tstatic N merge(N x,N y){\n\t\tN res;\n\t\tres.len=x.len+y.len;\n\t\trep(k,2)res.cnt[k]=x.cnt[k]+y.cnt[k];\n\t\tres.lz=-1;\n\t\treturn res;\n\t}\n};\n\nvi strvi(){\n\tstring s;cin>>s;\n\tvi res(si(s));\n\trep(i,si(s))res[i]=s[i]-'0';\n\treturn res;\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tvi tar=strvi();\n\tvi src=strvi();\n\tvc<pi> qs;\n\trep(i,q){\n\t\tint l,r;cin>>l>>r;\n\t\tl--;\n\t\tqs.eb(l,r);\n\t}\n\treverse(all(qs));\n\tseglazy<N> seg(src);\n\tfor(auto lr:qs){\n\t\tint l,r;tie(l,r)=lr;\n\t\tN cur=seg.composite(l,r);\n\t\tif(cur.cnt[0]==cur.cnt[1]){\n\t\t\treturn no(0);\n\t\t}\n\t\trep(k,2){\n\t\t\tif(cur.cnt[k]>cur.cnt[k^1]){\n\t\t\t\tseg.ch(l,r,&N::set_val,k);\n\t\t\t}\n\t\t}\n\t}\n\tvc<N> res;\n\tseg.enumerate(0,n,res);\n\trep(i,n){\n\t\tif(res[i].cnt[tar[i]]==0)return no(0);\n\t}\n\treturn yes(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Nezzar and Binary String.json",
    "editorial_link": "https://codeforces.com//blog/entry/87294",
    "editorial": "The operations can be described backward: Iterate days in reverse order\r\nand start with . In -th day, if there is a strict majority of s or s\r\nbetween and , change element inside the range to be the majority.\r\nOtherwise, declare that the operation failed. We can see that the\r\n\"backward\" operation is deterministic, so we can compute the source\r\nstring from destination string alone and check if the source string\r\ncomputed equal to .To simulate the operations, We need to support two\r\nkind of operations: range query on sum, and range assignment Which can\r\nbe simulated using e.g. lazy segment tree.Time complexity:\r\n"
}