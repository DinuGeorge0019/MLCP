{
    "link": "https://codeforces.com//contest/1299/problem/E",
    "problemId": "536067",
    "problem_idx": "E",
    "shortId": "1299E",
    "contest_number": "1299",
    "problem_submissions": {
        "E": [
            70686331,
            70660774,
            70672529,
            70679200,
            70746311,
            70716482,
            70681811,
            70790234,
            70723071
        ],
        "D": [
            70674287,
            70655315,
            70663097,
            70655518,
            70663548,
            70664397,
            70662876,
            70665818,
            70662357,
            70666704,
            70668591,
            70669155,
            70686750,
            70667002,
            70665737,
            71199373,
            70666543,
            70669128,
            70668132,
            70673600,
            70668620
        ],
        "C": [
            70635644,
            70641348,
            70637841,
            70635684,
            70637585,
            70645672,
            70638367,
            70644518,
            70637825,
            70637282,
            70642089,
            70641136,
            70646842,
            70640536,
            71199306,
            70645534,
            70641268,
            70637543,
            70642972,
            70649159
        ],
        "B": [
            70632114,
            70637553,
            70635893,
            70632956,
            70633376,
            70640030,
            70635212,
            70636081,
            70641111,
            70643564,
            70635522,
            70636070,
            70638648,
            70636548,
            71199268,
            70634654,
            70643537,
            70631220,
            70636193,
            70643457
        ],
        "A": [
            70629120,
            70629188,
            70630935,
            70629077,
            70628970,
            70632328,
            70630392,
            70630475,
            70630208,
            70630228,
            70630097,
            70629324,
            70630825,
            70631100,
            71199221,
            70629815,
            70629724,
            70628897,
            70629666,
            70629786
        ]
    },
    "name": "E. So Mean",
    "statement": ".We have hidden a permutation p_1, p_2,\r\ndots, p_n of numbers from 1 to n from you, where n . You can try to\r\nguess it using the following queries:? k a_1 a_2\r\ndots a_k.In response, you will learn if the average of elements with\r\nindexes a_1, a_2,\r\ndots, a_k is an integer. In other words, you will receive 1 if\r\nfrac{p_{a_1} + p_{a_2} +\r\ndots + p_{a_k}}{k} is integer, and 0 otherwise. You have to guess the\r\npermutation. You can ask .Note that permutations [p_1, p_2,\r\ndots, p_k] and [n + 1 - p_1, n + 1 - p_2,\r\ndots, n + 1 - p_k] are indistinguishable. Therefore, .Note that the\r\npermutation p is fixed before the start of the interaction and doesn\u2019t\r\ndepend on your queries. In other words, .Note that you don\u2019t have to\r\nminimize the number of queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=810;\nint p[N],pos[N],val[N],rem,n;\n\nint cval[N],ccnt;\n\nbool ask(VI x) {\n\tccnt++;\n\tif (SZ(x)==1) return 1;\n\tprintf(\"? %d\",SZ(x));\n\tfor (auto y:x) printf(\" %d\",y);\n\tputs(\"\");\n\tfflush(stdout);\n\tint t=0;\n\tscanf(\"%d\",&t);\n\treturn t;\n\tint s=0;\n\tfor (auto y:x) s+=cval[y];\n\treturn s%SZ(x)==0;\n\treturn t;\n}\n\nvoid dist(int l,int r) {\n\tVI x;\n\trep(i,1,n+1) if (val[i]==0) x.pb(i);\n\trandom_shuffle(all(x));\n\tif (rem==1) {\n\t\tVI rr;\n\t\tfor (auto y:x) {\n\t\t\tVI xx;\n\t\t\tfor (auto z:x) if (z!=y) xx.pb(z);\n\t\t\tif (ask(xx)) rr.pb(y);\n\t\t\tif (SZ(rr)>=2) break;\n\t\t}\n\t\tpos[1]=rr[0];\n\t\tval[rr[0]]=1;\n\t\tpos[n]=rr[1];\n\t\tval[rr[1]]=n;\n\t\treturn;\n\t}\n\tVI fl;\n\tfor (auto y:x) if (p[y]==l%rem) fl.pb(y);\n\trep(i,0,SZ(fl)) {\n\t\tint y=fl[i];\n\t\tif (i==SZ(fl)-1) { pos[l]=y; val[y]=l; break; }\n\t\tVI xx;\n\t\tfor (auto z:x) if (z!=y) xx.pb(z);\n\t\tif (ask(xx)) {\n\t\t\tpos[l]=y;\n\t\t\tval[y]=l;\n\t\t\tbreak;\n\t\t}\n\t}\n\tVI fr;\n\tfor (auto y:x) if (p[y]==r%rem) fr.pb(y);\n\trep(i,0,SZ(fr)) {\n\t\tint y=fr[i];\n\t\tif (i==SZ(fr)-1) { pos[r]=y; val[y]=r; break; }\n\t\tVI xx;\n\t\tfor (auto z:x) if (z!=y) xx.pb(z);\n\t\tif (ask(xx)) {\n\t\t\tpos[r]=y;\n\t\t\tval[y]=r;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) cval[i]=i;\n\trandom_shuffle(cval+1,cval+n+1);\n\trem=1;\n\tdist(1,n);\n\trem=2;\n\tfor (int i=1;i<=n;i++) if (val[i]==0) {\n\t\tif (ask(VI{pos[1],i})) p[i]=1;\n\t\telse p[i]=0;\n\t}\n\tfor (int i=2;i<=n/2;i++) {\n\t\tdist(i,n+1-i);\n\t\tif (i==rem) {\n\t\t\trep(j,1,n+1) if (val[j]==0) {\n\t\t\t\tint z1=p[j],z2=p[j]+rem;\n\t\t\t\tif (z2>n) continue;\n\t\t\t\tint ps=(n+1)*rem;\n\t\t\t\tint x=(ps+z1)%(2*rem);\n\t\t\t\tif (x>=1&&x<=rem) {\n\t\t\t\t\tVI yy;\n\t\t\t\t\trep(i,1,rem+1) {\n\t\t\t\t\t\tif (i!=x) yy.pb(pos[i]);\n\t\t\t\t\t\tyy.pb(pos[n+1-i]);\n\t\t\t\t\t}\n\t\t\t\t\tyy.pb(j);\n\t\t\t\t\tif (ask(yy)) p[j]=z1; else p[j]=z2;\n\t\t\t\t} else {\n\t\t\t\t\tx=(ps+z2)%(2*rem);\n\t\t\t\t\tassert(x>=1&&x<=rem);\n\t\t\t\t\tVI yy;\n\t\t\t\t\trep(i,1,rem+1) {\n\t\t\t\t\t\tif (i!=x) yy.pb(pos[i]);\n\t\t\t\t\t\tyy.pb(pos[n+1-i]);\n\t\t\t\t\t}\n\t\t\t\t\tyy.pb(j);\n\t\t\t\t\tif (ask(yy)) p[j]=z2; else p[j]=z1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trem*=2;\n\t\t}\n\t}\n\tif (val[1]>n/2) {\n\t\trep(i,1,n+1) val[i]=n+1-val[i];\n\t}\n\n\tif (cval[1]>n/2) {\n\t\trep(i,1,n+1) cval[i]=n+1-cval[i];\n\t}\n\n\tprintf(\"!\");\n\trep(i,1,n+1) printf(\" %d\",val[i]);\n\tputs(\"\");\n\trep(i,1,n+1) {\n\t\t//assert(val[i]==cval[i]);\n\t}\n\tfprintf(stderr,\"%d\\n\",ccnt);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "interactive",
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. So Mean.json",
    "editorial_link": "https://codeforces.com//blog/entry/73763",
    "editorial": "Let\u00e2\u0080\u0099s solve this problem in several steps.First, let\u00e2\u0080\u0099s ask a query about\r\neach group of numbers. Note that . Therefore, answer will be only for\r\nnumbers and . Find the positions where and lie, assign one of them to be\r\nand the other one to be (it doesn\u00e2\u0080\u0099t matter how to assign and to these\r\nspots, as permutations and are indistinguishable). .Note that knowing ,\r\nwe can find parity of every other number. Indeed, just ask about and ,\r\nif answer is , is odd, else it is even..Suppose that we have found\r\nnumbers at some point. Let\u00e2\u0080\u0099s find numbers and .Consider all numbers\r\nexcept now. Ask a query about each subset of numbers among them. Again,\r\nwe can see that we will get answer only when we omit and . Indeed, ,\r\nwhich is only for and .Now that we know parities of all numbers, we can\r\ndistinguish between and . So, we determined and in .Note that this\r\nalready means that we can solve our problem in queries, which is\r\nqueries. Unfortunately, this is much larger than we are allowed.\r\nHowever, we will use this method for .Let\u00e2\u0080\u0099s use the procedure above to\r\nfind numbers . We have used queries by now, but let\u00e2\u0080\u0099s round this up to .\r\nNow, we are going to find the remainders of each element of permutation\r\nmodulo , , , . As , we will be able to restore each number uniquely.To\r\nfind remainders modulo , we will first ask each number with already\r\nfound and . We will get only for numbers, divisible by . Next, we will\r\nask each number whose remainder under division by we haven\u00e2\u0080\u0099t yet found\r\nwith , . This way we find all the numbers which give the remainder . All\r\nothers give the remainder .We spend .Similarly, we find remainders mod\r\nand mod . For mod , at step ask each number whose remainder we don\u00e2\u0080\u0099t\r\nknow yet with (for from to ). We spend .For mod , first ask all numbers\r\nwhose remainders we don\u00e2\u0080\u0099t know yet with , then with , , , , (sums of all\r\nthese sets are different mod ).We spend .Now time to find remainders mod\r\n. We already know all remainders mod . To distinguish from , ask with .\r\nTo distinguish from , ask with .We spend .Now time to find remainders\r\nmod . We already know all remainders mod . Similarly, to distinguish\r\nfrom , ask with , , to distinguish from , ask with .We spend ., we spend\r\n. Note that this bound is easy to optimize (for example, determine all\r\nremainders mod and from , and after that check only candidates which\r\nwork mod in phase . This will reduce the number of operations to\r\noperations. Of course, a lot of other optimizations are possible.\r\n"
}