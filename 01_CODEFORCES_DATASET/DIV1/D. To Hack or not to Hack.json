{
    "link": "https://codeforces.com//contest/663/problem/D",
    "problemId": "55355",
    "problem_idx": "D",
    "shortId": "663D",
    "contest_number": "663",
    "problem_submissions": {
        "E": [
            17350327,
            17349864,
            17353803,
            17353745,
            17350870,
            17351032,
            17350940,
            17349799,
            17351986,
            17351243,
            17350710,
            17347131,
            17352995,
            17350415,
            17349363,
            17351067,
            17353219,
            17353206,
            17350737
        ],
        "C": [
            17347790,
            17347307,
            17349302,
            17348183,
            17352062,
            17347576,
            17351577,
            17349777,
            17347691,
            17348798,
            17348588,
            17350481,
            17349299,
            17347750,
            17349697,
            17348180,
            17348352
        ],
        "B": [
            17346317,
            17346919,
            17351687,
            17347488,
            17350797,
            17352612,
            17346896,
            17352716,
            17346251,
            17346169
        ],
        "A": [
            17345568,
            17345670,
            17345320,
            17345148,
            17345271,
            17344956,
            17347728,
            17345255,
            17346364,
            17352110,
            17345277,
            17344920,
            17352735,
            17344992,
            17345337
        ],
        "D": [
            17350825,
            17611100,
            17366417
        ]
    },
    "name": "D. To Hack or not to Hack",
    "statement": "Consider a regular Codeforces round consisting of three problems that\r\nuses dynamic scoring.You are given an almost final scoreboard. For each\r\nparticipant (including yourself), the time of the accepted submission\r\nfor each of the problems is given. Also, for each solution you already\r\nknow whether you are able to hack it or not. The only changes in the\r\nscoreboard that will happen before the end of the round are your\r\nchallenges.What is the best place you may take at the end?More formally,\r\npeople are participating (including yourself). For any problem, if it\r\nwas solved by exactly people at the end of the round, the maximum score\r\nfor this problem is defined as: If , then the maximum possible score is\r\n; If , then the maximum possible score is ; If , then the maximum\r\npossible score is ; If , then the maximum possible score is ; If , then\r\nthe maximum possible score is ; If , then the maximum possible score is\r\n. Let the maximum possible score for some problem be equal to . Then a\r\ncontestant who didn\u2019t manage to get it accepted (or his solution was\r\nhacked) earns points for this problem. If he got the the solution\r\naccepted minutes after the beginning of the round (and his solution\r\nwasn\u2019t hacked), he earns points for this problem.The overall score of a\r\nparticipant is equal to the sum of points he earns for each problem plus\r\npoints for each successful hack (only you make hacks).The resulting\r\nplace you get is equal to one plus the number of participants who\u2019s\r\noverall score is strictly greater than yours.\r\n",
    "solutions": [
        "#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 5001;\nint a[maxn][3];\nint sol[3], can[3];\nint t[3], tob[3];\nint dp[2][90][90][90];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n;\n    cin >> n;\n\n    forn(i, n) forn(j, 3) {\n        cin >> a[i][j];\n        sol[j] += a[i][j] != 0;\n        can[j] += a[i][j] < 0;\n    }\n    if (can[0] + can[1] + can[2] >= 90) {\n        cout << 1 << '\\n';\n        return 0;\n    }\n    int ans = 1e9;\n    for (t[0] = 0; t[0] < 6; ++t[0]) {\n        for (t[1] = 0; t[1] < 6; ++t[1]) {\n            for (t[2] = 0; t[2] < 6; ++t[2]) {\n                bool ok = true;\n                forn(i, 3) {\n                    tob[i] = min(can[i], max(0, (t[i] == 5 ? (int)1e9 : sol[i] - (n >> (t[i] + 1)) - 1)));\n                    int z = (sol[i] - tob[i]) << (t[i] + 1);\n                    ok &= ((t[i] == 5 || n < z) && z <= 2 * n);\n                }\n                if (!ok) continue;\n                int myB = 0;\n                forn(i, 3) {\n                    myB += 100 * tob[i];\n                    if (a[0][i]) myB += 2 * (t[i] + 1) * (250 - a[0][i]);\n                }\n                forn(i, tob[0] + 1) forn(j, tob[1] + 1) forn(k, tob[2] + 1) dp[0][i][j][k] = 1e9;\n                dp[0][tob[0]][tob[1]][tob[2]] = 0;\n                int twin = 0;\n                for1(p, n - 1) {\n                    bool ist = true;\n                    forn(m, 3) ist &= a[p][m] >= 0;\n                    if (ist) {\n                        int hisb = 0;\n                        forn(m, 3) {\n                            if (a[p][m]) hisb += 2 * (t[m] + 1) * (250 - abs(a[p][m]));\n                        }\n                        if (hisb > myB) ++twin;\n                        continue;\n                    }\n                    forn(i, tob[0] + 1) forn(j, tob[1] + 1) forn(k, tob[2] + 1) dp[1][i][j][k] = 1e9;\n                    forn(i, tob[0] + 1) forn(j, tob[1] + 1) forn(k, tob[2] + 1) {\n                        forn(ti, 2) forn(tj, 2) forn(tk, 2) {\n                            if (ti && (!i || a[p][0] >= 0)) continue;\n                            if (tj && (!j || a[p][1] >= 0)) continue;\n                            if (tk && (!k || a[p][2] >= 0)) continue;\n                            int hisB = 0;\n                            if (a[p][0] && !ti) hisB += 2 * (t[0] + 1) * (250 - abs(a[p][0]));\n                            if (a[p][1] && !tj) hisB += 2 * (t[1] + 1) * (250 - abs(a[p][1]));\n                            if (a[p][2] && !tk) hisB += 2 * (t[2] + 1) * (250 - abs(a[p][2]));\n                            uin(dp[1][i - ti][j - tj][k - tk], dp[0][i][j][k] + (hisB > myB));\n                        }\n                    }\n                    forn(i, tob[0] + 1) forn(j, tob[1] + 1) forn(k, tob[2] + 1) dp[0][i][j][k] = dp[1][i][j][k];\n                }\n//                cerr << t[0] << ' ' << t[1] << ' ' << t[2] << ' ' << tob[0] << ' ' << tob[1] << ' ' << tob[2] << ' ' << myB << ' ' << twin + dp[0][0][0][0] + 1 << '\\n';\n                uin(ans, twin + dp[0][0][0][0]);\n            }\n        }\n    }                                        \n    cout << ans + 1 << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. To Hack or not to Hack.json",
    "editorial_link": "https://codeforces.com//blog/entry/44408",
    "editorial": "Observation number one \u0097 as you are the only participant who is able to hack, the total score of any other participant cannot exceed 9000 (3 problems for 3000 points). Hence hacking at least 90 solutions automatically guarantees the first place (the hacks alone increase the score by 9000 points).\n\nNow we are left with the problem where the number of hacks we make is at most 90. We can try each of the 63 possible score assignments for the problems in the end of the round. As we know the final score for each problem, we can calculate the maximum number of hacks we are allowed to make so the problem gets the assigned score. This is also the exact amount of hacks we will make in that problem. As we know the number of hacks we will make, we can calculate our final total score. Now there are at most 90 participants who we can possibly hack. We are interested only in those who are on top of us. By hacking we want to make their final score less than that of us. This problem can by solved by means of dynamic programming:\n\ndp[p][i][j][k] \u0097 the maximum number of participants among the top p, whom we can push below us by hacking first problem i times, second problem j times and third problem k times.\n\nThe recurrence: we pick a subset of solutions of the current participant that we will hack, and if after these hacks we will push him below us, we update the corresponding dp state. For example, if it is enough to hack the first and the third problems, then dp[p?+?1][i?+?1][j][k?+?1]?=?max(dp[p?+?1][i?+?1][j][k?+?1],?dp[p][i][j][k]?+?1)"
}