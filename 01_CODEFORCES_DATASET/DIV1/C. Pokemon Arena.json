{
    "link": "https://codeforces.com//contest/1936/problem/C",
    "problemId": "2503247",
    "problem_idx": "C",
    "shortId": "1936C",
    "contest_number": "1936",
    "problem_submissions": {
        "D": [
            249364690,
            248943933,
            248953790,
            249029415,
            248948695,
            249384877,
            248946718,
            249691560,
            248955075,
            248956184,
            248951174,
            248957366,
            248965278,
            248962414,
            248959804,
            248956212,
            248940582,
            248972190,
            248967537,
            248935591,
            248968777
        ],
        "F": [
            248959624,
            248956053,
            249024905,
            249024791,
            249617325,
            249616926,
            249616449,
            249616090
        ],
        "C": [
            248923874,
            248935905,
            248936411,
            248923821,
            249389527,
            249389485,
            249389471,
            248932096,
            249960032,
            249959905,
            248928496,
            248925527,
            248927912,
            248933135,
            248931237,
            248927110,
            248920757,
            248942173,
            248944746,
            248948052,
            248945719,
            248954792,
            249702139,
            249700847,
            248946434,
            248946276
        ],
        "B": [
            248915925,
            248925932,
            248926756,
            248909886,
            248921270,
            250626935,
            248920462,
            248915106,
            248915547,
            248917787,
            248924541,
            248919814,
            248929862,
            248928500,
            248928933,
            248958629,
            248930625,
            248933889,
            248965009,
            248934936
        ],
        "A": [
            248907152,
            248906597,
            248909183,
            248914647,
            248906656,
            250627352,
            248907025,
            248906362,
            248923349,
            248909550,
            248908351,
            248909231,
            248911552,
            248909761,
            248918833,
            248908591,
            248914734,
            248920857
        ],
        "E": [
            248969738,
            248981250,
            249019529,
            248981225,
            248968880,
            249091224,
            249090696,
            252634475,
            249522528
        ]
    },
    "name": "C. Pok\u00e9mon Arena",
    "statement": "You are at a dueling arena. You also possess n Pok mons. Initially, only\r\nthe 1-st Pok mon is standing in the arena.Each Pok mon has m attributes.\r\nThe j-th attribute of the i-th Pok mon is a_{i,j}. Each Pok mon also has\r\na cost to be hired: the i-th Pok mon\u2019s cost is c_i.You want to have the\r\nn-th Pok mon stand in the arena. To do that, you can perform the\r\nfollowing two types of operations any number of times in any order:\r\nChoose three integers i, j, k (1\r\nle i\r\nle n, 1\r\nle j\r\nle m, k > 0), increase a_{i,j} by k permanently. The cost of this\r\noperation is k. Choose two integers i, j (1\r\nle i\r\nle n, 1\r\nle j\r\nle m) and hire the i-th Pok mon to duel with the current Pok mon in the\r\narena based on the j-th attribute. The i-th Pok mon will win if a_{i,j}\r\nis the j-th attribute of the current Pok mon in the arena (otherwise, it\r\nwill lose). After the duel, only the winner will stand in the arena. The\r\ncost of this operation is c_i. Find the minimum cost you need to pay to\r\nhave the n-th Pok mon stand in the arena.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\nll kosz[nax];\nvll wek[nax];\n\nint k;\n\nvector<vector<pll>> graf;\n\nvll odl;\n\nvoid ogarnij()\n{\n\twhile((int)graf.size()<=k)\n\t\tgraf.push_back(vector<pll>(0));\n}\n\nvoid edge(int a, int b, ll w)\n{\n\tgraf[a].push_back({b, w});\n\t//~ debug() << imie(a) << imie(b) << imie(w);\n}\n\nvoid test()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld \", &kosz[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twek[i].clear();\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tll x;\n\t\t\tscanf(\"%lld\", &x);\n\t\t\twek[i].push_back(x);\n\t\t}\n\t}\n\tk=n;\n\tgraf.clear();\n\togarnij();\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tvector<pll> pos;\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tk++;\n\t\t\togarnij();\n\t\t\tedge(j, k, 0);\n\t\t\tedge(k, j, kosz[j]);\n\t\t\tpos.push_back({wek[j][i], k});\n\t\t}\n\t\tsort(pos.begin(), pos.end());\n\t\tfor (int j=1; j<n; j++)\n\t\t{\n\t\t\tedge(pos[j-1].second, pos[j].second, 0);\n\t\t\tedge(pos[j].second, pos[j-1].second, pos[j].first-pos[j-1].first);\n\t\t}\n\t}\n\todl.clear();\n\todl.resize(k+1, -1);\n\tpriority_queue<pll> kol;\n\todl[1]=0;\n\tkol.push({0, 1});\n\twhile(!kol.empty())\n\t{\n\t\tint v=kol.top().second;\n\t\tll w=-kol.top().first;\n\t\tkol.pop();\n\t\tif (odl[v]!=w)\n\t\t\tcontinue;\n\t\tfor (pll i : graf[v])\n\t\t{\n\t\t\tll x=i.second+w;\n\t\t\tif (odl[i.first]!=-1 && odl[i.first]<=x)\n\t\t\t\tcontinue;\n\t\t\todl[i.first]=x;\n\t\t\t//~ if (i.first==n && x==1)\n\t\t\t//~ {\n\t\t\t\t//~ debug() << imie(v) << imie(w) << imie(i);\n\t\t\t\t//~ exit(0);\n\t\t\t//~ }\n\t\t\tkol.push({-x, i.first});\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", odl[n]);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Pok\u00e9mon Arena.json",
    "editorial_link": "https://codeforces.com//blog/entry/126513",
    "editorial": "Tutorial Let\u00e2\u0080\u0099s consider Pok mon as nodes, and defeating Pok mon by Pok\nmon as the edge . Then the problem is essentially finding the shortest\npath from to .If we brute force to construct the graph, the time\ncomplexity will be , which is unacceptable. How can we find a better way\nto build the graph?Recalling, we need to represent all processes like\n\"Pok mon increased attribute by some value and defeated Pok mon \" using\npaths in the graph.We will use the following graph building to achieve\nthis. Overall, we consider each attribute separately. For the -th\nattribute, we construct virtual nodes and , and connect each Pok mon\nbased on the -th attribute.For example, and , we have the following\ngraph building for attribute :In this graph,for example,\"Pok mon\nincreased attribute by and defeated Pok mon \" can be represented as path\n.More generally, our graph building method is : Consider each attribute\nseparately. Assuming we are processing the -th attribute, insert all\ninto and sort it (for convenience, we assume that they are pairwise\ndifferent). Construct virtual nodes and ; Add edge with a value of for ;\nAdd edge with a value of for ; Add edge with a value of for ; Add edge\nwith a value of for ; Add edge with a value of for . Then we just run\nDijkstra algorithm in this graph. The time complexity is .\n"
}