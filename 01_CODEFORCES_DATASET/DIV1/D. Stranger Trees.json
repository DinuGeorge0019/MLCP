{
    "link": "https://codeforces.com//contest/917/problem/D",
    "problemId": "151490",
    "problem_idx": "D",
    "shortId": "917D",
    "contest_number": "917",
    "problem_submissions": {
        "C": [
            34680068,
            34681336,
            34678312,
            34684700,
            34684340,
            34684129,
            34684130,
            34686499,
            34795938,
            34730488,
            34696787
        ],
        "A": [
            34673920,
            34665747,
            34666503,
            34668041,
            34667604,
            34679203,
            34668301,
            34677179,
            34678218,
            34682551,
            34666784,
            34671651,
            34681613,
            34668433,
            34679190,
            34665183,
            34667188,
            34667822,
            34678091,
            34668342
        ],
        "B": [
            34672970,
            34673451,
            34671200,
            34673043,
            34673517,
            34672805,
            34670705,
            34675348,
            34676012,
            34676530,
            34670452,
            34673092,
            34671413,
            34673682,
            34678568,
            34669943,
            34672667,
            34674568,
            34678107,
            34670900
        ],
        "D": [
            34670187,
            34675817,
            34681965,
            34679140,
            34679490,
            34676721,
            34681020,
            34673182,
            34673535,
            34673684,
            34678521,
            34677964,
            34675981,
            34677937,
            34674919,
            37086325,
            34680194,
            34680489,
            34679577,
            34678015,
            34681680
        ],
        "E": [
            38254406,
            38253558,
            38252911
        ]
    },
    "name": "D. Stranger Trees",
    "statement": "Will shares a psychic connection with the Upside Down Monster, so\r\neverything the monster knows, Will knows. Suddenly, he started drawing,\r\npage after page, non-stop. Joyce, his mom, and Chief Hopper put the\r\ndrawings together, and they realized, it’s a labeled tree! A tree is a\r\nconnected acyclic graph. Will’s tree has vertices. Joyce and Hopper\r\ndon’t know what that means, so they’re investigating this tree and\r\nsimilar trees. For each such that , they’re going to investigate all\r\nlabeled trees with vertices that share exactly edges with Will’s tree.\r\nTwo labeled trees are different if and only if there’s a pair of\r\nvertices such that there’s an edge between and in one tree and not in\r\nthe other one.Hopper and Joyce want to know how much work they have to\r\ndo, so they asked you to tell them the number of labeled trees with\r\nvertices that share exactly edges with Will’s tree, for each . The\r\nanswer could be very large, so they only asked you to tell them the\r\nanswers modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nint n,u,v,gg[N][N];\nll f[N][N],ff[N];\nll det() {\n\tll ans=1;\n\trep(i,1,n) {\n\t\tbool fg=0;\n\t\trep(j,i,n) if (f[j][i]!=0) {\n\t\t\trep(k,i,n) swap(f[i][k],f[j][k]);\n\t\t\tif (j!=i) ans=-ans;\n\t\t\tfg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) return 0;\n\t\trep(j,i+1,n) {\n\t\t\tll tmp=-f[j][i]*powmod(f[i][i],mod-2)%mod;\n\t\t\trep(k,i,n) f[j][k]=(f[j][k]+tmp*f[i][k])%mod;\n\t\t}\n\t\t\n\t}\n\trep(i,1,n) ans=ans*f[i][i]%mod;\n\tif (ans<0) ans+=mod;\n\treturn ans;\n}\n\nll inv[N],g[N],c[N],w[N];\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t--u; --v;\n\t\tgg[u][v]=gg[v][u]=1;\n\t}\n\trep(x,0,n+1) {\n\t\trep(i,0,n) f[i][i]=0;\n\t\trep(i,0,n) rep(j,0,n) if (i!=j) {\n\t\t\tf[i][j]=-(gg[i][j]?x:1);\n\t\t\tf[i][i]-=f[i][j];\n\t\t}\n\t\tff[x]=det();\n\t}\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++) inv[i]=mod-(inv[mod%i]*(mod/i))%mod;\n\tg[0]=g[1]=1;\n\tfor (int i=2;i<=n;i++) g[i]=g[i-1]*inv[i]%mod;\n\tfor (int i=0;i<=n;i++) w[i]=powmod(i,n);\n\tfor (int i=n;i>=0;i--) {\n\t\tfor (int j=0;j<=i;j++) {\n\t\t\tif (j&1) {\n\t\t\t\tc[i]-=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]<0) c[i]+=mod;\n\t\t\t} else {\n\t\t\t\tc[i]+=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]>=mod) c[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tff[j]-=c[i]*w[j]%mod;\n\t\t\tif (ff[j]<0) ff[j]+=mod;\n\t\t\tw[j]=w[j]*inv[j]%mod;\n\t\t}\n\t}\n\trep(i,0,n) printf(\"%lld \",c[i]); puts(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "matrices",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Stranger Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/57420",
    "editorial": "Solution 1: First, for every such that we are going to find for every\r\nedges in the original tree we are going to find the number of labeled\r\ntrees having these edges, then we will add them all to . But Mr. Author\r\narenât we going to count some tree that has exactly (where ) common\r\nedges with the original tree in ? Yes, thatâs true. But we only count it\r\ntimes! So, after computing the res array we are going to iterate from to\r\nassuming that the res is correct for all (our current iteration), and\r\nthen reduce (the fixed res) from . Then weâll have the correct value for\r\n. But Mr. Author, how are we going to find in the first place? Letâs\r\nfirst find out for a fixed edges forest, in how ways we connect the\r\nremaining vertices to get a tree. Letâs look at the components in the\r\nforest. Only their sizes are relevant because we canât connect anything\r\ninside them. Let the sizes be . (if you assume that the sizes are all ,\r\nthe number of resulting trees are (Kayleyâs theorem)). To solve this\r\nsubproblem, letâs go to another subproblem. Letâs assume that for every\r\nadditional edge, we know which components it is going to go connect.\r\nThen, the number of resulting trees is where is the degree of component\r\n(edges between this component and other components). The reason is that\r\nwe have vertices inside component to give to every edge that has one\r\nendpoint in . Ok going back to the parent subproblem. huh? Iâve heard\r\nthat vertex appears in the Prufer code of a tree times. so weâve gotta\r\nmultiply the answer by every time it appears in Prufer code. Itâs also\r\nmultiplied by because we havenât multiplied it one time ( not ). But how\r\nto make it get multiplied by every time component is chosen? Look at\r\nthis product. . If in the -th parenthesis is chosen, then let the -th\r\nplace on the Prufer code of the tree connecting the components be the\r\ncomponent . The good thing about this product is that if component has\r\ncome in the Prufer code times, then the multiplication of the\r\nparenthesis has in it. So it counts exactly what we want to count. is\r\nthe answer for some fixed edges. corresponds to in the original problem\r\nand corresponds to . so we want to count Okay Mr. Author so how do we\r\ncount this for every fixed edges in the original tree. Lets count which\r\ncontains of every component inside âs subtree which doesnât include âs\r\ncomponent and . We can update this from âs children. Letâs add âs\r\nchildren one by one to the by assuming that the children we didnât go\r\nover donât exist in âs subtree. letâs go over and , we either fix the\r\nedge between and then itâll add to and otherwise itâll add to . We can\r\nalso divide it by at the end with modulo inverses. We can find with the\r\nsum of . (with as a corner case). The solution may look that itâs\r\nbecause itâs inside fors. But itâs actually if the and fors go until and\r\n(actually only the subtree of that weâve iterated on). So the cost is .\r\nLetâs look at it like every vertex from âs subtree is handshaking with\r\nevery vertex of âs subtree and the cost of their handshaking is . We\r\nknow that two vertices handshake only once. Thatâs why itâll be which is\r\nof . Solution 2: Letâs define as the number of spanning trees of the\r\ngraph plus copies of (the original tree). If we look at weâll see that\r\nit is actually because it has ways to choose which of the multiple edges\r\nit should choose for the common edges. So the problem is to find âs\r\ncoefficients. We can do that by polynomial interpolation if we have\r\nsample answers of . Letâs just get instances of for till . We can find\r\nthat using Kirchhoffâs matrix tree theorem to find the number of\r\nspanning trees of a graph. So the complexity is . So we have an\r\ncomplexity. This is how to do it in -> (I donât know it yet, Iâll update\r\nit when I have it ready)\r\n",
    "hint": []
}