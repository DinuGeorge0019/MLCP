{
    "link": "https://codeforces.com//contest/917/problem/D",
    "problemId": "151490",
    "problem_idx": "D",
    "shortId": "917D",
    "contest_number": "917",
    "problem_submissions": {
        "C": [
            34680068,
            34681336,
            34678312,
            34684700,
            34684340,
            34684129,
            34684130,
            34686499,
            34795938,
            34730488,
            34696787
        ],
        "A": [
            34673920,
            34665747,
            34666503,
            34668041,
            34667604,
            34679203,
            34668301,
            34677179,
            34678218,
            34682551,
            34666784,
            34671651,
            34681613,
            34668433,
            34679190,
            34665183,
            34667188,
            34667822,
            34678091,
            34668342
        ],
        "B": [
            34672970,
            34673451,
            34671200,
            34673043,
            34673517,
            34672805,
            34670705,
            34675348,
            34676012,
            34676530,
            34670452,
            34673092,
            34671413,
            34673682,
            34678568,
            34669943,
            34672667,
            34674568,
            34678107,
            34670900
        ],
        "D": [
            34670187,
            34675817,
            34681965,
            34679140,
            34679490,
            34676721,
            34681020,
            34673182,
            34673535,
            34673684,
            34678521,
            34677964,
            34675981,
            34677937,
            34674919,
            37086325,
            34680194,
            34680489,
            34679577,
            34678015,
            34681680
        ],
        "E": [
            38254406,
            38253558,
            38252911
        ]
    },
    "name": "D. Stranger Trees",
    "statement": "Will shares a psychic connection with the Upside Down Monster, so\r\neverything the monster knows, Will knows. Suddenly, he started drawing,\r\npage after page, non-stop. Joyce, his mom, and Chief Hopper put the\r\ndrawings together, and they realized, it\u2019s a labeled tree! A tree is a\r\nconnected acyclic graph. Will\u2019s tree has vertices. Joyce and Hopper\r\ndon\u2019t know what that means, so they\u2019re investigating this tree and\r\nsimilar trees. For each such that , they\u2019re going to investigate all\r\nlabeled trees with vertices that share exactly edges with Will\u2019s tree.\r\nTwo labeled trees are different if and only if there\u2019s a pair of\r\nvertices such that there\u2019s an edge between and in one tree and not in\r\nthe other one.Hopper and Joyce want to know how much work they have to\r\ndo, so they asked you to tell them the number of labeled trees with\r\nvertices that share exactly edges with Will\u2019s tree, for each . The\r\nanswer could be very large, so they only asked you to tell them the\r\nanswers modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nint n,u,v,gg[N][N];\nll f[N][N],ff[N];\nll det() {\n\tll ans=1;\n\trep(i,1,n) {\n\t\tbool fg=0;\n\t\trep(j,i,n) if (f[j][i]!=0) {\n\t\t\trep(k,i,n) swap(f[i][k],f[j][k]);\n\t\t\tif (j!=i) ans=-ans;\n\t\t\tfg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) return 0;\n\t\trep(j,i+1,n) {\n\t\t\tll tmp=-f[j][i]*powmod(f[i][i],mod-2)%mod;\n\t\t\trep(k,i,n) f[j][k]=(f[j][k]+tmp*f[i][k])%mod;\n\t\t}\n\t\t\n\t}\n\trep(i,1,n) ans=ans*f[i][i]%mod;\n\tif (ans<0) ans+=mod;\n\treturn ans;\n}\n\nll inv[N],g[N],c[N],w[N];\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t--u; --v;\n\t\tgg[u][v]=gg[v][u]=1;\n\t}\n\trep(x,0,n+1) {\n\t\trep(i,0,n) f[i][i]=0;\n\t\trep(i,0,n) rep(j,0,n) if (i!=j) {\n\t\t\tf[i][j]=-(gg[i][j]?x:1);\n\t\t\tf[i][i]-=f[i][j];\n\t\t}\n\t\tff[x]=det();\n\t}\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++) inv[i]=mod-(inv[mod%i]*(mod/i))%mod;\n\tg[0]=g[1]=1;\n\tfor (int i=2;i<=n;i++) g[i]=g[i-1]*inv[i]%mod;\n\tfor (int i=0;i<=n;i++) w[i]=powmod(i,n);\n\tfor (int i=n;i>=0;i--) {\n\t\tfor (int j=0;j<=i;j++) {\n\t\t\tif (j&1) {\n\t\t\t\tc[i]-=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]<0) c[i]+=mod;\n\t\t\t} else {\n\t\t\t\tc[i]+=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]>=mod) c[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tff[j]-=c[i]*w[j]%mod;\n\t\t\tif (ff[j]<0) ff[j]+=mod;\n\t\t\tw[j]=w[j]*inv[j]%mod;\n\t\t}\n\t}\n\trep(i,0,n) printf(\"%lld \",c[i]); puts(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "matrices",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Stranger Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/57420",
    "editorial": "Solution 1: First, for every such that we are going to find for every\r\nedges in the original tree we are going to find the number of labeled\r\ntrees having these edges, then we will add them all to . But Mr. Author\r\naren\u00e2\u0080\u0099t we going to count some tree that has exactly (where ) common\r\nedges with the original tree in ? Yes, that\u00e2\u0080\u0099s true. But we only count it\r\ntimes! So, after computing the res array we are going to iterate from to\r\nassuming that the res is correct for all (our current iteration), and\r\nthen reduce (the fixed res) from . Then we\u00e2\u0080\u0099ll have the correct value for\r\n. But Mr. Author, how are we going to find in the first place? Let\u00e2\u0080\u0099s\r\nfirst find out for a fixed edges forest, in how ways we connect the\r\nremaining vertices to get a tree. Let\u00e2\u0080\u0099s look at the components in the\r\nforest. Only their sizes are relevant because we can\u00e2\u0080\u0099t connect anything\r\ninside them. Let the sizes be . (if you assume that the sizes are all ,\r\nthe number of resulting trees are (Kayley\u00e2\u0080\u0099s theorem)). To solve this\r\nsubproblem, let\u00e2\u0080\u0099s go to another subproblem. Let\u00e2\u0080\u0099s assume that for every\r\nadditional edge, we know which components it is going to go connect.\r\nThen, the number of resulting trees is where is the degree of component\r\n(edges between this component and other components). The reason is that\r\nwe have vertices inside component to give to every edge that has one\r\nendpoint in . Ok going back to the parent subproblem. huh? I\u00e2\u0080\u0099ve heard\r\nthat vertex appears in the Prufer code of a tree times. so we\u00e2\u0080\u0099ve gotta\r\nmultiply the answer by every time it appears in Prufer code. It\u00e2\u0080\u0099s also\r\nmultiplied by because we haven\u00e2\u0080\u0099t multiplied it one time ( not ). But how\r\nto make it get multiplied by every time component is chosen? Look at\r\nthis product. . If in the -th parenthesis is chosen, then let the -th\r\nplace on the Prufer code of the tree connecting the components be the\r\ncomponent . The good thing about this product is that if component has\r\ncome in the Prufer code times, then the multiplication of the\r\nparenthesis has in it. So it counts exactly what we want to count. is\r\nthe answer for some fixed edges. corresponds to in the original problem\r\nand corresponds to . so we want to count Okay Mr. Author so how do we\r\ncount this for every fixed edges in the original tree. Lets count which\r\ncontains of every component inside \u00e2\u0080\u0099s subtree which doesn\u00e2\u0080\u0099t include \u00e2\u0080\u0099s\r\ncomponent and . We can update this from \u00e2\u0080\u0099s children. Let\u00e2\u0080\u0099s add \u00e2\u0080\u0099s\r\nchildren one by one to the by assuming that the children we didn\u00e2\u0080\u0099t go\r\nover don\u00e2\u0080\u0099t exist in \u00e2\u0080\u0099s subtree. let\u00e2\u0080\u0099s go over and , we either fix the\r\nedge between and then it\u00e2\u0080\u0099ll add to and otherwise it\u00e2\u0080\u0099ll add to . We can\r\nalso divide it by at the end with modulo inverses. We can find with the\r\nsum of . (with as a corner case). The solution may look that it\u00e2\u0080\u0099s\r\nbecause it\u00e2\u0080\u0099s inside fors. But it\u00e2\u0080\u0099s actually if the and fors go until and\r\n(actually only the subtree of that we\u00e2\u0080\u0099ve iterated on). So the cost is .\r\nLet\u00e2\u0080\u0099s look at it like every vertex from \u00e2\u0080\u0099s subtree is handshaking with\r\nevery vertex of \u00e2\u0080\u0099s subtree and the cost of their handshaking is . We\r\nknow that two vertices handshake only once. That\u00e2\u0080\u0099s why it\u00e2\u0080\u0099ll be which is\r\nof . Solution 2: Let\u00e2\u0080\u0099s define as the number of spanning trees of the\r\ngraph plus copies of (the original tree). If we look at we\u00e2\u0080\u0099ll see that\r\nit is actually because it has ways to choose which of the multiple edges\r\nit should choose for the common edges. So the problem is to find \u00e2\u0080\u0099s\r\ncoefficients. We can do that by polynomial interpolation if we have\r\nsample answers of . Let\u00e2\u0080\u0099s just get instances of for till . We can find\r\nthat using Kirchhoff\u00e2\u0080\u0099s matrix tree theorem to find the number of\r\nspanning trees of a graph. So the complexity is . So we have an\r\ncomplexity. This is how to do it in -> (I don\u00e2\u0080\u0099t know it yet, I\u00e2\u0080\u0099ll update\r\nit when I have it ready)\r\n"
}