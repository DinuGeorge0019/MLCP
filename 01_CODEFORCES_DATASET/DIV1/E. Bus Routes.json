{
    "link": "https://codeforces.com//contest/1827/problem/E",
    "problemId": "1922414",
    "problem_idx": "E",
    "shortId": "1827E",
    "contest_number": "1827",
    "problem_submissions": {
        "B1": [
            205909125,
            205871229,
            205860094,
            205853484,
            205858214,
            205884799,
            205855785,
            205857268,
            205859721,
            205854125,
            205853990,
            205854393,
            205857685,
            205856108,
            205871852,
            205864517,
            205849753,
            205856355,
            206036248,
            205883111,
            205857458,
            205852308
        ],
        "C": [
            205887704,
            205865086,
            205862189,
            205877784,
            205865401,
            205880693,
            205873972,
            205883370,
            205896807,
            205874900,
            205883582,
            205869590,
            205872529,
            205865317,
            205875560,
            205870203,
            205870915,
            206036332,
            205857923,
            205878002,
            205869836
        ],
        "E": [
            205882857,
            205890682,
            205893722,
            205893207,
            205891321,
            205895989,
            205901490,
            205897572,
            205894529,
            205889627,
            205900528,
            205921803,
            205921497,
            205921364,
            205921183,
            205920554,
            205920187,
            205928602,
            205907318,
            205907019,
            205906136,
            205905793,
            205905368,
            205905221,
            205903986
        ],
        "B2": [
            205871376,
            205860123,
            205854465,
            205857731,
            205884857,
            205854446,
            205857708,
            205859949,
            205855049,
            205892922,
            205864074,
            205856597,
            205855367,
            205871926,
            205864651,
            205863717,
            205856284,
            206036255,
            205889062,
            205869038,
            205876542
        ],
        "D": [
            205863885,
            205875931,
            205878262,
            205884073,
            205878863,
            205877520,
            205881913,
            205884050,
            205871773,
            205899731,
            205892557,
            205885814,
            205881313,
            205883473,
            205884864,
            205888365,
            205888201,
            206036361,
            205877449,
            205886393,
            205963414,
            205889611
        ],
        "A": [
            205845172,
            205844037,
            205843466,
            205843847,
            205844462,
            205843511,
            205844799,
            205845695,
            205844273,
            205843867,
            205845548,
            205843654,
            205843208,
            205846139,
            205845358,
            205843530,
            206036234,
            205846931,
            205848794,
            205843958
        ],
        "F": [
            207299235,
            207299224,
            207299166,
            207299023,
            207298779,
            207298502,
            207298128
        ]
    },
    "name": "E. Bus Routes",
    "statement": "There is a country consisting of n cities and n - 1 bidirectional roads\r\nconnecting them such that we can travel between any two cities using\r\nthese roads. In other words, these cities and roads form a tree.There\r\nare m bus routes connecting the cities together. A bus route between\r\ncity x and city y allows you to travel between any two cities in the\r\nsimple path between x and y with this route.Determine if for every pair\r\nof cities u and v, you can travel from u to v using at most two bus\r\nroutes.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nnamespace ecnerwala {\n\nusing std::swap;\n\nstruct level_ancestor {\n\tint N;\n\tstd::vector<int> preorder;\n\tstd::vector<int> idx;\n\tstd::vector<std::pair<int, int>> heavyPar; // heavy parent, distance\n\tlevel_ancestor() : N(0) {}\n\n\tlevel_ancestor(const std::vector<int>& par) : N(int(par.size())), preorder(N), idx(N), heavyPar(N) {\n\t\tstd::vector<std::vector<int>> ch(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] != -1) ch[par[i]].push_back(i);\n\t\t}\n\t\tstd::vector<int> sz(N);\n\t\tint nxt_idx = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (par[i] == -1) {\n\t\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\t\t\tsz[cur] = 1;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt);\n\t\t\t\t\t\tsz[cur] += sz[nxt];\n\t\t\t\t\t}\n\t\t\t\t\tif (!ch[cur].empty()) {\n\t\t\t\t\t\tauto mit = max_element(ch[cur].begin(), ch[cur].end(), [&](int a, int b) { return sz[a] < sz[b]; });\n\t\t\t\t\t\tswap(*ch[cur].begin(), *mit);\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t\tstd::y_combinator([&](auto self, int cur, int isRoot = true) -> void {\n\t\t\t\t\tpreorder[idx[cur] = nxt_idx++] = cur;\n\t\t\t\t\tif (isRoot) {\n\t\t\t\t\t\theavyPar[idx[cur]] = {par[cur] == -1 ? -1 : idx[par[cur]], 1};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(idx[par[cur]] == idx[cur]-1);\n\t\t\t\t\t\theavyPar[idx[cur]] = heavyPar[idx[cur]-1];\n\t\t\t\t\t\theavyPar[idx[cur]].second++;\n\t\t\t\t\t}\n\t\t\t\t\tbool chRoot = false;\n\t\t\t\t\tfor (int nxt : ch[cur]) {\n\t\t\t\t\t\tself(nxt, chRoot);\n\t\t\t\t\t\tchRoot = true;\n\t\t\t\t\t}\n\t\t\t\t})(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint get_ancestor(int a, int k) const {\n\t\tassert(k >= 0);\n\t\ta = idx[a];\n\t\twhile (a != -1 && k) {\n\t\t\tif (k >= heavyPar[a].second) {\n\t\t\t\tk -= heavyPar[a].second;\n\t\t\t\tassert(heavyPar[a].first <= a - heavyPar[a].second);\n\t\t\t\ta = heavyPar[a].first;\n\t\t\t} else {\n\t\t\t\ta -= k;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tif (a == -1) return -1;\n\t\telse return preorder[a];\n\t}\n\n\tint lca(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\treturn preorder[a];\n\t\t\t}\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t}\n\n\tint dist(int a, int b) const {\n\t\ta = idx[a], b = idx[b];\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tif (a > b) swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (a > b - heavyPar[b].second) {\n\t\t\t\tres += b - a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres += heavyPar[b].second;\n\t\t\tb = heavyPar[b].first;\n\t\t\tif (b == -1) return -1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n} // namespace ecnerwala\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tint M;\n\tcin >> M;\n\tvector<vector<int> > tree(N);\n\tfor(int i = 0; i < N-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tassert(u < N && v < N);\n\t\ttree[u].push_back(v);\n\t\ttree[v].push_back(u);\n\t}\n\tvector<int> par(N);\n\ty_combinator(\n\t\t[&](auto self, int v, int p) -> void {\n\t\t\tpar[v] = p;\n\t\t\tfor(int w : tree[v]){\n\t\t\t\tif(w == p) continue;\n\t\t\t\tself(w, v);\n\t\t\t}\n\t\t}\n\t)(0, -1);\n\tvector<vector<int> > roads_vertex(N);\n\tfor(int i = 0; i < M; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\troads_vertex[u].push_back(v);\n\t\troads_vertex[v].push_back(u);\n\t}\n\tvector<int> leaves;\n\tfor(int i = 0; i < N; i++){\n\t\tif(tree[i].size() == 1) leaves.push_back(i);\n\t}\n\tauto la = ecnerwala::level_ancestor(par);\n\tvector<int> st(N);\n\tint T = 0;\n\ty_combinator(\n\t\t[&](auto self, int v, int p) -> void {\n\t\t\tst[v] = T;\n\t\t\tT++;\n\t\t\tfor(int w : tree[v]){\n\t\t\t\tif(w == p) continue;\n\t\t\t\tself(w, v);\n\t\t\t}\n\t\t}\n\t)(0, -1);\n\n\t// vector<int> dp(N, 0);\n\t// for(int v : leaves){\n\t// \tvector<int> cc = roads_vertex[v];\n\t// \tcc.push_back(v);\n\t// \tsort(cc.begin(), cc.end(), [&](int x, int y) { return st[x] < st[y]; });\n\t// \tint L = cc.front();\n\t// \tfor(int x : cc) L = la.lca(x, L);\n\t// \tdp[L] += 1;\n\t// \tif(L > 0) dp[par[L]] -= 1;\n\t// \tint B = L;\n\t// \tfor(int x : cc){\n\t// \t\tint A = la.lca(B, x);\n\t// \t\tdp[x] += 1;\n\t// \t\tdp[A] -= 1;\n\t// \t\tB = A;\n\t// \t}\n\t// }\n\t// y_combinator(\n\t// \t[&](auto self, int v, int p) -> void {\n\t// \t\tfor(int w : tree[v]){\n\t// \t\t\tif(w == p) continue;\n\t// \t\t\tdp[v] += dp[w];\n\t// \t\t}\n\t// \t}\n\t// )(0, -1);\n\tint lowest_leaf = -1;\n\tint lowest = -1;\n\tfor(int v : leaves){\n\t\tvector<int> cc = roads_vertex[v];\n\t\tcc.push_back(v);\n\t\tint L = v;\n\t\tfor(int x : cc) L = la.lca(x, L);\n\t\tif(lowest == -1 || st[L] > st[lowest]){\n\t\t\tlowest = L;\n\t\t\tlowest_leaf = v;\n\t\t}\n\t}\n\n\tfor(int v : leaves){\n\t\tbool on_path = false;\n\t\tvector<int> cc = roads_vertex[v];\n\t\tcc.push_back(v);\n\t\tfor(int x : cc){\n\t\t\tif(la.dist(x, v) == la.dist(x, lowest) + la.dist(lowest, v)) on_path = true;\n\t\t}\n\t\tif(!on_path){\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\tcout << (v+1) << ' ' << (lowest_leaf + 1) << '\\n';\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bus Routes.json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "Solution First, notice that for a pair of nodes such that is not a leaf,\nwe can find a leaf such that path fully covers path . Therefore, we only\nneed to care about whether all pairs of leaves can reach each other\nusing at most routes.LemmaThe condition above is equivalent to: There\nexists a node such that can reach all leaves by using at most one\nroute.ProofThe necessity part is trivial, so letâs prove the sufficiency\npart.Let the leaves of the tree be . Let be the induced subgraph of all\nnodes reachable by using at most one route. If and is reachable within\ntwo routes, then the intersection of and is non-empty. We need to prove\nthat the intersection of all is non-empty.If , , and are pairwise\nreachable within two paths, then the intersection of , , and must be\npairwise non-empty. Since the graph is a tree, it follows trivially that\nintersection of , , and must be non-empty. We can generalize this to all\nleaves, thus proving the sufficiency part. To check if an answer exists\nor not, we can use this trick from ko_osaga to find how many covers each\nnode in . The answer is YES when there is a node that is covered by all\n.To find the two candidates when the answer is NO, notice that one of\nthem is the first leaf such that there is no node that is covered by .\nWe can find with binary search. To find the other one, root the tree at\nand define as the lowest node reachable by using at most one route. The\nother candidate is a node such that is not in .Time complexity:\n.Testerâs solution: Root the tree at some non-leaf vertex. Define as the\nlowest node (minimum depth) reachable by using at most one route. Take\nthe node with the deepest (maximum depth) . Then the answer for this\nproblem is iff for every leaf , either lie in âs subtree or has a path\nto .\n",
    "hint": [
        "Hint 1 You do not need to consider all pairs of nodes, only some of them will do.",
        "Hint 2 Find an equivalent condition of the statement. Hint 2.1 Let be the set of all nodes reachable by u using at most one route. Consider all where is a leaf in the tree.",
        "Hint 2.1 Let be the set of all nodes reachable by u using at most one route. Consider all where is a leaf in the tree."
    ]
}