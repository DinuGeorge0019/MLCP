{
    "link": "https://codeforces.com//contest/383/problem/D",
    "problemId": "5725",
    "problem_idx": "D",
    "shortId": "383D",
    "contest_number": "383",
    "problem_submissions": {
        "B": [
            5756409,
            5751225,
            5757744,
            5753341,
            5808519,
            5808489,
            5808447,
            5758844,
            5759238,
            5752874,
            5755308,
            5752676,
            5753907,
            5753281,
            5756832,
            5755532
        ],
        "E": [
            5754649,
            5757705,
            5753388,
            5758136,
            5808454,
            5755553,
            5754159,
            5755881,
            5756030,
            5755626,
            5754883,
            5757327,
            5758405,
            5757943
        ],
        "D": [
            5753594,
            5752449,
            5752307,
            5754262,
            5808453,
            5751984,
            5752563,
            5753410,
            5753070,
            5753481,
            5755159,
            5755983,
            5755452,
            5753533,
            5756037,
            5756133,
            5757148,
            5756616,
            5755389,
            5756824
        ],
        "C": [
            5750456,
            5751886,
            5754923,
            5749119,
            5751328,
            5751146,
            5750311,
            5750868,
            5752299,
            5751003,
            5750201,
            5751936,
            5751653,
            5754669,
            5750989,
            5754841,
            5751430,
            5750434
        ],
        "A": [
            5747280,
            5747986,
            5747387,
            5747246,
            5808450,
            5747221,
            5747445,
            5747936,
            5747254,
            5748686,
            5747361,
            5747734,
            5747935,
            5748612,
            5748223,
            5747638,
            5747622,
            5749616,
            5757219
        ]
    },
    "name": "D. Antimatter",
    "statement": "Iahub accidentally discovered a secret lab. He found there devices\r\nordered in a line, numbered from to from left to right. Each device can\r\ncreate either units of matter or units of antimatter. Iahub wants to\r\nchoose some contiguous subarray of devices in the lab, specify the\r\nproduction mode for each of them (produce matter or antimatter) and\r\nfinally take a photo of it. However he will be successful only if the\r\namounts of matter and antimatter produced in the selected subarray will\r\nbe the same (otherwise there would be overflowing matter or antimatter\r\nin the photo). You are requested to compute the number of different ways\r\nIahub can successful take a photo. A photo is different than another if\r\nit represents another subarray, or if at least one device of the\r\nsubarray is set to produce matter in one of the photos and antimatter in\r\nthe other one.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nconst int MOD = int(1e9 + 7);\nvoid madd(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint mmul(int a, int b) { return ll(a) * b % MOD; }\n\nvi as;\n\nint calc(int l, int r) {\n  if (l == r) return 0;\n  int m = (l + r) / 2;\n  int res = 0;\n  madd(res, calc(l, m));\n  madd(res, calc(m + 1, r));\n\n  int suml = 0, sumr = 0;\n  for (int i = l; i <= r; i++)\n    if (i <= m) suml += as[i];\n    else sumr += as[i];\n\n  vi canl(2 * suml + 1), canr(2 * sumr + 1);\n  #define step(xxx) \\\n      for (int i2 = 0; i2 < sz(cur); i2++) { \\\n        ncur[i2] = 0; \\\n        if (i2 >= as[i]) madd(ncur[i2], cur[i2 - as[i]]); \\\n        if (i2 + as[i] < sz(cur)) madd(ncur[i2], cur[i2 + as[i]]); \\\n      } \\\n      cur.swap(ncur); \\\n      for (int i2 = 0; i2 < sz(cur); i2++) \\\n        madd(xxx[i2], cur[i2]);\n  {\n    vi cur(sz(canl)), ncur(sz(canl));\n    cur[sz(canl) / 2] = 1;\n    for (int i = m; i >= l; i--) {\n      step(canl)\n    }\n  }\n  {\n    vi cur(sz(canr), 0), ncur(sz(canr));\n    cur[sz(canr) / 2] = 1;\n    for (int i = m + 1; i <= r; i++) {\n      step(canr)\n    }\n  }\n\n//  res = 0;\n  for (int i = 0; i < sz(canl); i++) {\n    int x = i - sz(canl) / 2;\n    int y = -x;\n    int i2 = y + sz(canr) / 2;\n    if (0 <= i2 && i2 < sz(canr)) {\n//      eprintf(\"x=%d (%d), y=%d (%d)\\n\", x, canl[i], y, canr[i2]);\n      madd(res, mmul(canl[i], canr[i2]));\n    }\n  }\n//  eprintf(\"calc(%d..%d)=%d\\n\", l, r, res);\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    as = vi(n);\n    for (int i = 0; i < n; i++)\n      scanf(\"%d\", &as[i]);\n    printf(\"%d\\n\", calc(0, n - 1));\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Antimatter.json",
    "editorial_link": "https://codeforces.com/blog/entry/10476",
    "editorial": "The problem is: given an array, iterate all possible subarrays (all possible elements such as their indexes are consecutive). Now, for a fixed subarray we need to know in how many ways we can color its elements in black and white, such as sum of black elements is equal to sum of white elements. The result is sum of this number, for each subarray.\n\nLets solve an easier problem first. This wont immediately solve the harder version, but it will be useful later. Suppose youve fixed a subarray. In how many ways can you color it with black and white? Suppose subarray has N elements and sum of them is M. Also, suppose for a coloring, sum of blacks is sB and sum of whites is sW. For coloring to be valid, sB = sW. But we also know that sB + sW = M (because each element is colored by exactly one color). We get that 2 * sB = M, so sB = M / 2. The problem is now: in how many ways can we color elements in black such as sum of blacks is M / 2 (after we fix a black coloring, we color with white non colored elements; sum of white colored elements is also M / 2). This is a well known problem: Knapsack problem. Let ways[i][j] = in how many ways one can obtain sum j from first i elements. When adding (i + 1) object, after ways[i] is calculated, for a fixed sum j we can do 2 things: add (i + 1) object to sum j or skip it. Depending of what we chosen, we add value ways[i][j] to ways[i + 1][j + value[i + 1]] or to ways[i + 1][j]. The result is in ways[N][M / 2]. This works in O(N * M) time.\n\nAn immediate solution can be obtained now: take all subarrays and apply above approach. This leads to an O(N ^ 2 * M ^ 2) solution, which is too much. One can reduce complexity to O(N ^ 2* M) by noting that processing subarray [i, j] can be done with already calculated values for subarray [i, j  1]. Hence, instead of adding N elements, its enough to add 1 element to already calculated values (element from position j). Sadly, O(N ^ 2 * M) is still too slow, so we need to find something better. The solution presented below will look forced if you didnt solve some problems with this technique before. Its hard to come with an approach without practicing this kind of tasks. But dont worry, as much as you practice them, as easily youll solve those problems.\n\nWell solve task by divide and conquer. Complexity of this solution is O(N * M * logN). Let f(left, right) a function that counts number of colorings for each subarray [i, j], such as subarray [i, j] is included in subarray [left, right] (left <= i <= j <= right). Answer is in f(1, N). The trick is to define a value med = (left + right) / 2 (very frequent trick in divide and conquer problems, called usually a median). We can next classify [i, j] subarrays in 3 types:\n\n1/ i <= med j <= med\n\n2/ i > med j > med\n\n3/ i <= med j > med\n\nWe can solve 1/ and 2/ by calling f(left, med) and f(med + 1, right). The remained problem is when i <= med and j > med. If we solve 3/ in O((right  left) * M) time, this will be enough to overall achieve O(N * M * logN) (for this moment trust me, youll see later why its so :) ).\n\nLets denote by i1 last i1 elements from subarray [left, med]. Also, lets note by i2 first i2 elements from subarray [med + 1, right]. For example, let left = 1 and right = 5, with array {1, 2, 3, 4, 5}. med is 3 and for i1 = 2 and i2 = 1, left subarray is {2, 3} and right subarray is {4}. By iterating i1 from 1 to med  left + 1 and i2 from 1 to right  med and then unite subarrays i1 and i2, we obtain all subarrays described in 3/ . Lets denote by j1 sum of a possible black coloring of i1. Similarly, j2 is sum of a possible black coloring of i2.\n\nSuppose we fixed i1, i2, j1 and j2. When its the coloring valid? Let S sum of united subarrays i1 and i2 (S = value[med  i1 + 1] + value[med  i1 + 2] + ... + value[med] + value[med + 1] + ... + value[med + i2  1] + value[med + i2]). Now its time to use what I explained at the beginning of solution. The coloring is good only when j1 + j2 = S / 2. We can rewrite the relation as 2 * (j1 + j2) = sum_of_elements_from_i1 + sum_of_elements_from_i2. We can rewrite it even more:\n\n2 * j1 + 2 * j2  sum_of_elements_from_i1  sum_of_elements_from_i2 = 0\n\n2 * j1  sum_of_elements_from_i1 = sum_of_elements_from_i2  2 * j2 = combination_value\n\nThis relation is the key of solving problem. You can see now that relation is independent in left and right side. We calculate left[i1][j1] and right[i2][j2] = in how many ways can I obtain sum of blacks j1 (j2) from first i1 (i2) from left (right) side. Lets calculate also count[value] = in how many ways can I obtain combination_value equal to value in the right side. For some fixed (i2, j2) I add to count[sum_of_elements_from_i2  2 * j2] value right[i2][j2]. In this way count[] is calculated correctly and completely. Now, lets fix a sum (i1, j1) in the left side. Were interested how many good colorings are such as there exist a coloring of j1 in i1 elements (the endpoint of left is fixed to be i1 and I need to calculate endpoints i2 for right, then to make colorings of i2). A coloring is good if combination_value of (i1, j1) and (i2, j2) is equal. Hence, I need to know in how many ways I can color i1 elements to obtain sum j1 and also I need to know in how many ways I can color elements from right to obtain same combination_value as its in the left. Its not hard to see that answer for a fixed (i1, j1) is left[i1][j1] * count[2 * j1  sum_of_elements_from_i1]. This takes O((right  left) * M) time.\n\nThe only thing remained in the problem is to see why complexity is O(N * M * logN). We can assume N is a power of 2 (it not, lets round N to smallest power of 2 bigger than N; complexity for N is at least as good as complexity for this number). Draw a binary complete tree with N nodes. Each node corresponds to an appeal of f(). For a level, exactly O(N * M) operations are performed. To see why:\n\nFor level 1, therell be 1 node performing N * M operations.\n\nFor level 2, therell be 2 nodes performing (N / 2) * M operations. Summing up we get O(N * M).\n\nFor level 3, therell be 4 nodes performing (N / 4) * M operations. Summing up we get O(N *M) as well.\n\nand so on.\n\nSo for each level we perform O(N * M) operations. A binary complete tree has maximum O(logN) levels, so overall complexity is O(N * M * logN).",
    "hint": []
}