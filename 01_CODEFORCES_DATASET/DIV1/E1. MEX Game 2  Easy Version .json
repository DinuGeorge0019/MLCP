{
    "link": "https://codeforces.com//contest/1943/problem/E1",
    "problemId": "2535044",
    "problem_idx": "E1",
    "shortId": "1943E1",
    "contest_number": "1943",
    "problem_submissions": {
        "E2": [
            251755986,
            251774166,
            251721110,
            251772938,
            251976046,
            251850394,
            251783692,
            252482559,
            251768795,
            251806219,
            251801786,
            251784602,
            251808955,
            251786442,
            251790915,
            251791945,
            252167133,
            254017076,
            252396752,
            251948632
        ],
        "E1": [
            251743400,
            251761808,
            251720570,
            251764606,
            251765135,
            251768616,
            251774247,
            251768081,
            251767041,
            251779764,
            251763055,
            251770682,
            251776382,
            251772657,
            253458372,
            251772270,
            251777192,
            251779122,
            251781255
        ],
        "D2": [
            251730537,
            251743841,
            251769783,
            251827860,
            251827638,
            251812685,
            251750876,
            251749250,
            251743677,
            251754133,
            251758370,
            251752785,
            251846892,
            251763163,
            251753145,
            251743858,
            251746564,
            251754334,
            251790796,
            253458316,
            251757628,
            251757687,
            251759092,
            251761488
        ],
        "D1": [
            251727886,
            251730644,
            251753185,
            251730641,
            251733326,
            251727921,
            251742335,
            251739558,
            251743910,
            251737861,
            251737457,
            251736749,
            251746112,
            251745451,
            251785836,
            252959932,
            251749532,
            251743349,
            251754372,
            251751101
        ],
        "C": [
            251715534,
            251721073,
            251747865,
            251720444,
            251722988,
            251756982,
            251730923,
            251730217,
            251735041,
            251727939,
            251724586,
            251722879,
            251721249,
            251735499,
            251732028,
            252959913,
            251731321,
            251736408,
            251741233,
            251741283
        ],
        "B": [
            251709195,
            251712754,
            251737904,
            251712353,
            251714193,
            252482757,
            251715199,
            251720530,
            251721280,
            251721320,
            251719084,
            251718139,
            251714047,
            251713923,
            251720644,
            251719922,
            252531274,
            251717454,
            251716526,
            251722194,
            252064777,
            251726935
        ],
        "A": [
            251701793,
            251702717,
            251723885,
            251701730,
            251702780,
            251702880,
            251702623,
            251701902,
            251707932,
            251702391,
            251707705,
            251702309,
            251701731,
            251703701,
            251706521,
            252531268,
            251732626,
            251703091,
            251704741,
            251703882
        ],
        "F": [
            251801182,
            252436931,
            251845260,
            251783880
        ]
    },
    "name": "E1. MEX Game 2  Easy Version ",
    "statement": "Alice and Bob play yet another game on an array a of size n. Alice\r\nstarts with an empty array c. Both players take turns playing, with\r\nAlice starting first.On Alice’s turn, she picks one element from a,\r\nappends that element to c, and then deletes it from a.On Bob’s turn, he\r\npicks at most k elements from a, and then deletes it from a. The game\r\nends when the array a is empty. Alice’s score is defined to be the MEX^\r\ndagger of c. Alice wants to maximize her score while Bob wants to\r\nminimize it. Find Alice’s final score if both players play optimally.The\r\narray will be given in compressed format. Instead of giving the elements\r\npresent in the array, we will be giving their frequencies. Formally, you\r\nwill be given m, the maximum element in the array, and then m + 1\r\nintegers f_0, f_1,\r\nldots, f_m, where f_i represents the number of times i occurs in the\r\narray a.^\r\ndagger The\r\noperatorname{MEX} (minimum excludant) of an array of integers is defined\r\nas the smallest non-negative integer which does not occur in the array.\r\nFor example: The MEX of [2,2,1] is 0, because 0 does not belong to the\r\narray. The MEX of [3,1,0,1] is 2, because 0 and 1 belong to the array,\r\nbut 2 does not. The MEX of [0,3,1,2] is 4, because 0, 1, 2 and 3 belong\r\nto the array, but 4 does not.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.03.2024 11:13:36\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int m, k;\n    cin >> m >> k;\n    vector<int> f(m + 1);\n    for (int i = 0; i <= m; i++) {\n      cin >> f[i];\n    }\n    int low = 0, high = m + 1;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      bool win = true;\n      for (int pref = 1; pref <= mid; pref++) {\n        vector<int> a(f.begin(), f.begin() + mid);\n        sort(a.begin(), a.end());\n        a.resize(pref);\n        int els = pref;\n        for (int i = 0; i < pref - 1; i++) {\n          if (a[i + 1] <= k) {\n            win = false;\n            break;\n          }\n          els -= 1;\n          int steps = k;\n          int suf = 1;\n          while (steps > 0) {\n            while (suf < els && a[pref - suf] == a[pref - (suf + 1)]) {\n              suf += 1;\n            }\n            int diff = a[pref - suf] - (suf == els ? 0 : a[pref - (suf + 1)]);\n            if (steps / suf >= diff) {\n              steps -= suf * diff;\n              for (int j = 0; j < suf; j++) {\n                a[pref - 1 - j] -= diff;\n              }\n            } else {\n              int all = steps / suf;\n              for (int j = 0; j < suf; j++) {\n                a[pref - 1 - j] -= all;\n              }\n              steps -= all * suf;\n              assert(0 <= steps && steps < suf);\n              for (int j = 0; j < steps; j++) {\n                a[pref - suf + j] -= 1;\n              }\n              steps = 0;\n              break;\n            }\n          }\n        }\n      }\n      if (win) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E1. MEX Game 2  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "SolutionFor now, lets try to see if . This is equivalent to Alice being\r\nable to take occurence of everything when the game is reduced to numbers\r\n.Aliceâs strategy here is actually easy to find. At every step, Alice\r\nwill choose the minimum such that , and she hasnât chosen yet. You can\r\nreason this with greedy stays ahead, exchange argument, whatever you\r\nwant.This gives us a nice definition of Aliceâs moves, however we\r\nseemingly have to maintain the sorted sequence of always. But we can\r\nactually rewrite Bobâs moves such that it does not affect the sorted\r\norder of and always keeps it sorted. Here, by sorted order, we mean some\r\npermutation of such that whenever .First, instead of subtracting , we\r\nwill do subtractions of only . Then, the only case when sorted order can\r\nbe destroyed is when there exists and such that and we do an operation\r\non but occurs before in the sorted order. This issue can simply be fixed\r\nby doing the operation on the smallest (according to sorted order) such\r\nthat .Now, we have a good way of representing Alice moves. Suppose we\r\nfixed the element that Bob \"wins\" on. Then, Bobâs strategy will\r\nobviously be to make the frequency of that element as small as possible,\r\nbut he must make sure to never violate sorted condition. Since Bob will\r\nmake at most moves, you can just simulate his moves. The main details of\r\nthe simulation is that you need to figure out upto what index all values\r\nwill become equal when doing k operations (or nearly equal, off by 1),\r\nand then first take all elements to that state. Let be the remaining\r\noperations from the operations after this, and the length of the equal\r\nsequence. Then you will reduce every frequency by , and finally reduce\r\nthe first mod numbers of this sequence. Check the code for more\r\ndetails.A naive implementation takes per move, so per element we fix =>\r\ntotal to check . With a binary search on the answer, you get . It can be\r\noptimized further, but it wasnt needed to pass. Most other polynomial\r\nsolutions should pass this.\r\n",
    "hint": [
        "Hint 1 It might be optimal for Bob to reduce multiple elements at the same time, thus making Alice choose between which element she wants to take.",
        "Hint 2 Suppose you are only checking whether for now, what would Alice's strategy be?",
        "Hint 3 Try fixing the element that Bob wants to make sure Alice is not able to get. What would be his strategy then?"
    ]
}