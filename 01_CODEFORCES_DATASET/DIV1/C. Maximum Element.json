{
    "link": "https://codeforces.com//contest/889/problem/C",
    "problemId": "133720",
    "problem_idx": "C",
    "shortId": "889C",
    "contest_number": "889",
    "problem_submissions": {
        "D": [
            32268277,
            32261782,
            32262346,
            32267448,
            32264912,
            32270286,
            32262994,
            32270235,
            32268920
        ],
        "E": [
            32261080,
            32269250,
            42287448
        ],
        "C": [
            32258949,
            32258309,
            32261571,
            32258724,
            32261718,
            32260558,
            32259837,
            32261642,
            32262113,
            32268280,
            32263105,
            32260984,
            32260094,
            32262538,
            32263363,
            32275764,
            32267069,
            32261624,
            32263229
        ],
        "B": [
            32252734,
            32253330,
            32255576,
            32255239,
            32254428,
            32258155,
            32254407,
            32256519,
            32255311,
            32263055,
            32253848,
            32255572,
            32252983,
            32255704,
            32255404,
            32253464,
            32255981
        ],
        "A": [
            32248128,
            32248978,
            32250463,
            32251033,
            32250128,
            32254306,
            32249854,
            32249329,
            32248510,
            32248897,
            32270420,
            32248851,
            32248699,
            32248336,
            32249379,
            32249111,
            32248222,
            32250477
        ]
    },
    "name": "C. Maximum Element",
    "statement": "One day Petya was solving a very interesting problem. But although he\r\nused many optimization techniques, his solution still got Time limit\r\nexceeded verdict. Petya conducted a thorough analysis of his program and\r\nfound out that his function for finding maximum element in an array of\r\npositive integers was too slow. Desperate, Petya decided to use a\r\nsomewhat unexpected optimization using parameter , so now his function\r\ncontains the following code:int fast_max(int n, int a[]) { int ans = 0;\r\nint offset = 0; for (int i = 0; i < n; ++i) if (ans < a[i]) { ans =\r\na[i]; offset = 0; } else { offset = offset + 1; if (offset == k) return\r\nans; } return ans;}That way the function iteratively checks array\r\nelements, storing the intermediate maximum, and if after consecutive\r\niterations that maximum has not changed, it is returned as the\r\nanswer.Now Petya is interested in fault rate of his function. He asked\r\nyou to find the number of permutations of integers from to such that the\r\nreturn value of his function on those permutations is not equal to .\r\nSince this number could be very big, output the answer modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\n\nll rev(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = rev(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll f[MAXN];\nll fct[MAXN];\nll rfct[MAXN];\n\nll cnk(int x, int y) {\n    return fct[x + y] * rfct[x] % MOD * rfct[y] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    rfct[n] = rev(fct[n]);\n    for (int i = n; i > 0; --i) {\n        rfct[i - 1] = (rfct[i] * i) % MOD;\n    }\n    \n    ll mulall = 1;\n    ll ans = fct[n - 1];\n\n\n    ll sum = 0;\n    f[0] = 1;\n    sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        sum = (sum + f[i - 1]) % MOD;\n        ll cf = sum * mulall % MOD;\n        ans += cf * fct[n - 1] % MOD * rfct[i] % MOD;\n        ans %= MOD;\n        mulall = (mulall * i) % MOD;\n        f[i] = (rev(mulall) * cf) % MOD;\n        if (i >= k) {\n            sum = (sum - f[i - k] + MOD) % MOD;\n        }\n    }\n\n    cout << (fct[n] - ans + MOD) % MOD;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Maximum Element.json",
    "editorial_link": "https://codeforces.com//blog/entry/55734",
    "editorial": "You asked to find the number of permutations p of length n such that exists index i, such that pi???n, pi is greater than any pj for j in [1,?i?-?1] and greater then any pj for j in [i?+?1,?i?+?k]. We will call such permutations good.\n\nDefine D(n) as number of good permutations that have pn?=?n. Notice that if k???n, then D(n)?=?0. Let w be a permutations such that wn?=?n. If index of element n?-?1 is lesser than n?-?k, then w is good. Otherwise if n?-?1 index is j,?j???n?-?k, then because there are less then k elements between n?-?1 and n, w could be good only if i from the definition would be lesser than j. In that case permutation w1,?...,?wj would form a good permutation of length j of some numbers with wj being the maximum.\n\nTherefore the following equation is correct:\n\n\nWhich can be computed in O(n2), or in O(n) rewritten in the form\n\nand using prefix sums for values .\nThe answer is than calculated as follows:\n\n\nComplexity: O(n)."
}