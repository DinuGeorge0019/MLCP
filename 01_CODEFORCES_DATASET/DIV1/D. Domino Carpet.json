{"link": "https://codeforces.com//contest/77/problem/D", "problemId": "415", "problem_idx": "D", "shortId": "77D", "contest_number": "77", "problem_submissions": {"C": [401808, 400742, 400966, 404072, 400361, 400208, 400941, 399132, 399539, 399983, 400378, 399774, 407149, 402287, 402282, 402225, 399744, 398637, 400241, 400014, 400485], "E": [401176, 402597, 401454, 404668, 404079, 401115], "D": [400489, 400068, 398548, 399459, 399287, 399070, 400249, 400372, 401807, 401513, 401013, 400602, 401052, 401269, 401311, 401338, 401597], "B": [397537, 397714, 397225, 397036, 397723, 398174, 398236, 398396, 398520, 398673, 398469, 399312, 399073, 398622, 399195], "A": [396875, 396922, 399679, 397569, 397031, 397132, 397284, 396942, 397289, 397332, 421869, 407442, 397680, 397555, 399935, 397041, 397524, 397500]}, "name": "D. Domino Carpet", "statement": "Having watched the commercial, virus Hexadecimal also wanted to get a\r\nDomino Carpet and wanted badly to be photographed in front of it. But of\r\ncourse, a virus will never consent to buying a licensed Carpet! So she\r\nordered a truck of dominoes and decided to make such a Carpet herself.\r\nThe original Domino Carpet is a field of squares in size. Each square is\r\nhalf of a domino, and can be rotated either vertically or horizontally,\r\nindependently from its neighbors. Vertically rotated domino halves look\r\nlike this: And horizontally rotated halves look like this: Notice, that\r\nsome halves looks the same in both rotations, but other halves\r\ndiffer.Dominoes bought by Hexadecimal are represented by uncuttable\r\nchips in size, which can be laid either vertically or horizontally. If\r\nthe chip is laid vertically, then both of it\u2019s halves should be laid\r\nvertically orientated; if the chip is laid horizontally, then both of\r\nit\u2019s halves should be laid horizontally.The samples of valid and invalid\r\ndominoes laid vertically and horizontally are: Virus Hexadecimal\r\nassembles her own Domino Carpet so that the following conditions are\r\nsatisfied: each carpet square is covered by a domino chip, i.e. there\r\nare no empty squares; all domino chips lie entirely within the carpet\r\nand don\u2019t overlap with each other; if there is a horizontal domino chip\r\nwith its left half in column then there are no horizontal domino chips\r\nwith their left halves in columns or . Before starting to assemble her\r\nown Domino Carpet, the virus wants to know the number of ways to achieve\r\nthe intended purpose modulo .You can assume that the virus has an\r\ninfinitely large number of dominoes of each type.\r\n", "solutions": ["#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define y0 y3487465\n#define y1 y8687969\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) {\n    re x > 0 ? x : -x;\n}\n\nconst string dom[2][7] = {\n    {\".........\",\"....O....\",\"O.......O\",\"O...O...O\",\"O.O...O.O\",\"O.O.O.O.O\",\"OOO...OOO\"},\n    {\".........\",\"....O....\",\"..O...O..\",\"..O.O.O..\",\"O.O...O.O\",\"O.O.O.O.O\",\"O.OO.OO.O\"}};\n\nconst int mod = 1000000007;\n\nint n;\nint m;\nchar w[1002][1002];\nint g[250][250];\nint can[250], can2[250];\nint cnt[251], res[251];\n\nint get (int i, int j) {\n    string s = \"\";\n    for (int p = 0; p < 3; p++)\n        for (int q = 0; q < 3; q++)\n            s += w[i + p][j + q];\n    int res = 0;\n    for (int p = 0; p < 2; p++)\n        for (int q = 0; q < 7; q++)\n            if (s == dom[p][q])\n                res |= (p + 1);\n    re res;\n}\n\nint main() {\n    scanf (\"%d%d\", &n, &m); \n    gets (w[0]);\n    for (int i = 0; i < 4 * n + 1; i++) gets (w[i]);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            g[i][j] = get (4 * i + 1, 4 * j + 1);\n        for (int j = 0; j < m; j++) {\n            can[j] = int (n % 2 == 0);\n            for (int i = 0; i < n; i++) can[j] &= int ((g[i][j] & 2) != 0);\n        }\n    for (int j = 0; j + 1 < m; j++) {\n        memset (cnt, 0, sizeof (cnt));\n        cnt[0] = 1;\n        for (int i = 0; i < n; i++) {\n            if (g[i][j] & g[i][j + 1] & 1)\n                cnt[i + 1] = (cnt[i + 1] + cnt[i]) % mod;\n            if (i + 1 < n && int (g[i][j] & g[i + 1][j] & g[i][j + 1] & g[i + 1][j + 1] & 2))   \n                cnt[i + 2] = (cnt[i + 2] + cnt[i]) % mod;\n        }\n        can2[j] = (cnt[n] - can[j] * can[j + 1] + mod) % mod;\n    }\n    memset (res, 0, sizeof (res));\n    res[0] = 1;\n    for (int j = 0; j < m; j++) {\n        if (can[j]) res[j + 1] = (res[j + 1] + res[j]) % mod;\n        if (j + 1 < m) res[j + 2] = (res[j + 2] + (ll)res[j] * can2[j]) % mod;\n    }\n    printf (\"%d\\n\", res[m]);\n    return 0;\n}"], "input": "", "output": "", "tags": ["dp", "implementation"], "dificulty": "2300", "interactive": false}