{
    "link": "https://codeforces.com//contest/498/problem/C",
    "problemId": "19901",
    "problem_idx": "C",
    "shortId": "498C",
    "contest_number": "498",
    "problem_submissions": {
        "E": [
            9254353,
            9255134,
            9255917,
            9257774,
            9256751,
            9258696,
            9256130,
            9254869,
            9255218,
            9257482,
            9259085,
            9259412,
            9293653
        ],
        "D": [
            9252551,
            9253707,
            9253982,
            9253218,
            9254235,
            9256783,
            9248603,
            9260246,
            9259443,
            9259317,
            9251692,
            9252178,
            9254847,
            9253161,
            9255257,
            9254544,
            9255567
        ],
        "C": [
            9251331,
            9245747,
            9250927,
            9247459,
            9249177,
            9251204,
            9249816,
            9248998,
            9251162,
            9248001,
            9250917,
            9253358
        ],
        "B": [
            9248724,
            9250737,
            9247577,
            9260817,
            9250130,
            9252321,
            9249119,
            9253380,
            9258038,
            9252693,
            9253079,
            9252863,
            9250195
        ],
        "A": [
            9245371,
            9251410,
            9245412,
            9245364,
            9247095,
            9245481,
            9245345,
            9245357,
            9245352,
            9245488,
            9245360,
            9245992,
            9246642,
            9245626
        ]
    },
    "name": "C. Array and Operations",
    "statement": "You have written on a piece of paper an array of positive integers and\r\npairs of integers . Each pair meets the following conditions: is an odd\r\nnumber and .In one operation you can perform a sequence of actions: take\r\none of the pairs and some integer (), which divides both numbers and ;\r\ndivide both numbers by , i. e. perform the assignments: and . Determine\r\nthe maximum number of operations you can sequentially perform on the\r\ngiven array. Note that one pair may be used several times in the\r\ndescribed operations.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME \"\"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\" #x \"] Time = %.3lfs\\n\",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nclass Solver {\n  struct Edge {\n    int to, w, ne;\n  };\n  vector<Edge> es;\n  vi firs;\n\n  vi was;\n  int wver;\n  int en;\n\n  bool dfs(int v) {\n    if (v == en) return true;\n    if (was[v] >= wver) return false;\n    was[v] = wver;\n    for (int i = firs[v]; i >= 0; i = es[i].ne) if (es[i].w > 0) {\n      if (dfs(es[i].to)) {\n        es[i].w--;\n        es[i ^ 1].w++;\n        return true;\n      }\n    }\n    return false;\n  }\n\npublic:\n  Solver() : wver(0) {}\n  void reset(int n) {\n    es.clear();\n    firs.resize(n);\n    fill(firs.begin(), firs.end(), -1);\n    was.resize(n);\n//    eprintf(\"reset %d\\n\", n);\n  }\n  void adde(int a, int b, int w) {\n    es.pb({ b, w, firs[a] }); firs[a] = sz(es) - 1;\n    es.pb({ a, 0, firs[b] }); firs[b] = sz(es) - 1;\n//    eprintf(\"%d-->%d (%d)\\n\", a, b, w);\n  }\n  int solve(int st, int _en) {\n    en = _en;\n    int res = 0;\n    for (;;) {\n      wver++;\n      if (!dfs(st)) break;\n      res++;\n    }\n//    eprintf(\"solve(%d..%d) = %d\\n\", st, en, res);\n    return res;\n  }\n};\n\nconst int FINF = 30;\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME\".in\",\"r\",stdin);\n  freopen(TASKNAME\".out\",\"w\",stdout);\n  #endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) == 2) {\n    vi as(n);\n    forn (i, n) scanf(\"%d\", &as[i]);\n\n    vector<pii> goods(m);\n    forn (i, m) {\n      scanf(\"%d%d\", &goods[i].first, &goods[i].second);\n      goods[i].first--, goods[i].second--;\n      if (goods[i].first & 1) {\n        swap(goods[i].first, goods[i].second);\n      }\n      assert(!(goods[i].first & 1));\n      assert( (goods[i].second & 1));\n    }\n\n    map<int, vector<pii>> byPs;\n    forn (i, n) {\n      int x = as[i];\n      for (int i2 = 2; i2 * i2 <= x; i2++) {\n        int cdeg = 0;\n        while (x % i2 == 0) {\n          x /= i2;\n          cdeg++;\n        }\n        if (cdeg) byPs[i2].pb(mp(i, cdeg));\n      }\n      if (x > 1) {\n        byPs[x].pb(mp(i, 1));\n      }\n    }\n\n    int ans = 0;\n    Solver s;\n\n    for (const auto &_curp : byPs) {\n      const vector<pii> &nums = _curp.second;\n//      eprintf(\"p=%d\\n\", _curp.first);\n\n      vi myId(n, -1);\n      forn (i, sz(nums)) {\n        myId[nums[i].first] = i;\n      }\n\n      s.reset(sz(nums) + 2);\n      const int st = sz(nums), en = sz(nums) + 1;\n      for (pii e : goods) {\n        int a = myId[e.first];\n        int b = myId[e.second];\n        if (a < 0 || b < 0) continue;\n//        eprintf(\"a=%d, b=%d (%d %d)\\n\", a, b, e.first, e.second);\n        s.adde(a, b, FINF);\n      }\n      forn (a, sz(nums)) {\n        if ((nums[a].first & 1) == 0) {\n          s.adde(st, a, nums[a].second);\n        } else {\n          s.adde(a, en, nums[a].second);\n        }\n      }\n      ans += s.solve(st, en);\n    }\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graph matchings",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Array and Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/15353",
    "editorial": "We will divide only by prime numbers. First, let\u00e2\u0080\u0099s build a graph, where\r\neach of numbers have own vertex group: Find all prime factors of current\r\nnumber. Every factor will have its own vertex in a group, furthermore,\r\nif some factor has power of in current number, it will have exactly\r\nvertexes in group. The number of vertexes in such graph is . Now we will\r\nmake edges in our graph: edge between two vertexes exists if and only if\r\nthere is a good pair (given in statement) of vertexes group numbers and\r\nthe prime values of a vertexes are the same. That means that we can\r\ndivide that group numbers by that prime. The number of edges is . Good\r\npairs are given the way that our graph is bipartite. After finding\r\nmaximum matching in this graph we represent the way of doing operations\r\nas described in the statement. As soon as solution is using Kuhn\u00e2\u0080\u0099s\r\nalgorithm, its complexity is . One could notice that some of the edges\r\nare useless and reduce it to .\r\n"
}