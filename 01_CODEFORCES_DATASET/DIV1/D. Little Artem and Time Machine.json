{
    "link": "https://codeforces.com//contest/668/problem/D",
    "problemId": "57062",
    "problem_idx": "D",
    "shortId": "668D",
    "contest_number": "668",
    "problem_submissions": {
        "F": [
            17499550,
            17496606,
            17499490,
            17520108,
            17532592,
            18501140,
            17506872
        ],
        "B": [
            17492263,
            17485934,
            18962334,
            18962098,
            17485171,
            17485437,
            17486714,
            17488923,
            17486945,
            17485337,
            17484629,
            17487464,
            17484958,
            17488407,
            17491479,
            17485748,
            17490028,
            17488673,
            17494403,
            17485637
        ],
        "D": [
            17490332,
            17487430,
            17490281,
            17491665,
            17491589,
            17491023,
            17492381,
            17491847,
            17510482,
            17491540,
            17491742,
            17492256,
            17492993,
            17492659,
            17489839,
            17492977,
            17494347,
            17514667,
            17493357,
            17493004,
            17491261
        ],
        "C": [
            17488542,
            17483428,
            17488211,
            17499595,
            17489413,
            17489671,
            17487966,
            17489865,
            17488377,
            17490380,
            17490343,
            17491934,
            17490751,
            17488239,
            17491003,
            17488540,
            17492291,
            17488705,
            17488521
        ],
        "A": [
            17482539,
            17489363,
            17482477,
            17482341,
            17484937,
            17482743,
            17482929,
            17482753,
            17482646,
            17483327,
            17482913,
            17484500,
            17493264,
            17483554,
            17483365,
            17482861,
            17485075,
            17503074
        ],
        "E": [
            17501421,
            17514396,
            17516687,
            17501875,
            18500143,
            17500162,
            17503103
        ]
    },
    "name": "D. Little Artem and Time Machine",
    "statement": "Little Artem has invented a time machine! He could go anywhere in time,\r\nbut all his thoughts of course are with computer science. He wants to\r\napply this time machine to a well-known data structure: .Artem wants to\r\ncreate a basic multiset of integers. He wants these structure to support\r\noperations of three types: Add integer to the multiset. Note that the\r\ndifference between set and multiset is that multiset may store several\r\ninstances of one integer. Remove integer from the multiset. Only one\r\ninstance of this integer is removed. Artem doesn\u2019t want to handle any\r\nexceptions, so he assumes that every time remove operation is called,\r\nthat integer is presented in the multiset. Count the number of instances\r\nof the given integer that are stored in the multiset. But what about\r\ntime machine? Artem doesn\u2019t simply apply operations to the multiset one\r\nby one, he now travels to different moments of time and apply his\r\noperation there. Consider the following example. First Artem adds\r\ninteger to the multiset at the -st moment of time. Then Artem adds\r\ninteger to the multiset at the moment . Then Artem asks how many are\r\nthere in the multiset at moment . The answer is . Then Artem returns\r\nback in time and asks how many integers are there in the set at moment .\r\nSince was added only at moment , the number of integers at moment equals\r\nto . Then Artem goes back in time again and removes from the multiset at\r\nmoment . Finally Artyom asks at moment how many integers are there in\r\nthe set. The result is , since we have removed at the moment . Note that\r\nArtem dislikes exceptions so much that he assures that after each change\r\nhe makes all delete operations are applied only to element that is\r\npresent in the multiset. The answer to the query of the third type is\r\ncomputed at the moment Artem makes the corresponding query and are not\r\naffected in any way by future changes he makes.Help Artem implement time\r\ntravellers multiset.\r\n",
    "solutions": [
        "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\n\nunsigned long long readTimeStampCounter() {\n\tunsigned a = 123456789, b = 987654321;\n#ifdef __GNUC__\n\tasm(\n\t\t\"rdtsc;\\n\\t\"\n\t\t: \"=d\" (a), \"=a\" (b)\n\t);\n#else\n\t__asm {\n\t\trdtsc;\n\t\tmov a, edx;\n\t\tmov b, eax;\n\t};\n#endif\n\treturn (unsigned long long)a << 32 | b;\n}\nunsigned xor128() {\n\tstatic unsigned x = 123456789, y = 362436069,\n\t\tz = (unsigned)(readTimeStampCounter() >> 32), w = (unsigned)readTimeStampCounter();\n\tunsigned t = x ^ (x << 11);\n\tx = y; y = z; z = w;\n\treturn w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n}\n\n\nstruct Node {\n\tstatic const int K = 3;\n\tstatic Node nullNode;\n\n\tNode *left, *right;\n\tint size;\n\tint pos;\n\tint val, sum;\n\n\tbool isNull() const { return this == &nullNode; }\n\n\tNode *set(int p, int v) {\n\t\tleft = right = &nullNode;\n\t\tpos = p;\n\t\tval = v;\n\t\treturn update();\n\t}\n\n\tinline Node *update() {\n\t\tassert(!isNull());\n\t\tsize = left->size + 1 + right->size;\n\t\tsum = left->sum + val + right->sum;\n\t\treturn this;\n\t}\n\tinline void propagate() {}\n\tinline Node *linkl(Node *c) {\n\t\tleft = c;\n\t\treturn update();\n\t}\n\tinline Node *linkr(Node *c) {\n\t\tright = c;\n\t\treturn update();\n\t}\n\tinline Node *linklr(Node *l, Node *r) {\n\t\tleft = l, right = r;\n\t\treturn update();\n\t}\n};\nNode Node::nullNode = {\n\t&nullNode, &nullNode,\n\t0, -1,\n\t0, 0\n};\n\nstruct RBST {\n\ttypedef Node *Ref;\n\tstatic const int MaxHeight = 32 * 4;\n\tstatic Ref join(Ref l, Ref r) {\n\t\tif(l->isNull()) return r;\n\t\tif(r->isNull()) return l;\n\t\tif((int)(xor128() % (l->size + r->size)) < l->size) {\n\t\t\tl->propagate();\n\t\t\treturn l->linkr(join(l->right, r));\n\t\t} else {\n\t\t\tr->propagate();\n\t\t\treturn r->linkl(join(l, r->left));\n\t\t}\n\t}\n\ttypedef pair<Ref, Ref> RefPair;\n\tstatic RefPair splitRemovePos(Ref t, int pos, bool remove) {\n\t\tif(t->isNull()) return RefPair(&Node::nullNode, &Node::nullNode);\n\t\tt->propagate();\n\t\tif(pos == t->pos && remove) {\n\t\t\tNode *l = t->left, *r = t->right;\n\t\t\t*t = Node::nullNode;\n\t\t\treturn RefPair(l, r);\n\t\t} else if(pos <= t->pos) {\n\t\t\tRefPair p = splitRemovePos(t->left, pos, remove);\n\t\t\treturn RefPair(p.first, t->linkl(p.second));\n\t\t} else {\n\t\t\tRefPair p = splitRemovePos(t->right, pos, remove);\n\t\t\treturn RefPair(t->linkr(p.first), p.second);\n\t\t}\n\t}\n\tstatic Ref insertPos(Ref t, Ref n) {\n\t\tif(xor128() % (t->size + 1) == 0 || n->pos == t->pos) {\n\t\t\tRefPair p = splitRemovePos(t, n->pos, true);\n\t\t\treturn n->linklr(p.first, p.second);\n\t\t}\n\t\tt->propagate();\n\t\tif(n->pos < t->pos)\n\t\t\treturn t->linkl(insertPos(t->left, n));\n\t\telse\n\t\t\treturn t->linkr(insertPos(t->right, n));\n\t}\n};\n\nint main() {\n\trep(k, 100) xor128();\n\tint Q;\n\twhile(~scanf(\"%d\", &Q)) {\n\t\tmap<int, int> valID;\n\t\tvector<Node> nodes(Q);\n\t\tvector<Node*> seqs(Q, &Node::nullNode);\n\t\tfor(int i = 0; i < Q; ++ i) {\n\t\t\tint ty;\n\t\t\tscanf(\"%d\", &ty);\n\t\t\tint t; int x;\n\t\t\tscanf(\"%d%d\", &t, &x);\n\t\t\tint k = valID.emplace(x, valID.size()).first->second;\n\t\t\tif(ty == 1) {\n\t\t\t\tNode *a = &nodes[i];\n\t\t\t\ta->set(t, 1);\n\t\t\t\tseqs[k] = RBST::insertPos(seqs[k], a);\n\t\t\t} else if(ty == 2) {\n\t\t\t\tNode *a = &nodes[i];\n\t\t\t\ta->set(t, -1);\n\t\t\t\tseqs[k] = RBST::insertPos(seqs[k], a);\n\t\t\t} else if(ty == 3) {\n\t\t\t\tauto p = RBST::splitRemovePos(seqs[k], t, false);\n\t\t\t\tint ans = p.first->sum;\n\t\t\t\tseqs[k] = RBST::join(p.first, p.second);\n\t\t\t\tprintf(\"%d\\n\", ans);\n\t\t\t} else abort();\n\t\t}\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Little Artem and Time Machine.json",
    "editorial_link": "https://codeforces.com//blog/entry/44538",
    "editorial": "There are many ways to solve this problem. One of the ways was SQRT-decomposition. First let's compress all times. Now for each block in the decomposition we will store for each element the balance in that block. So to answer the query we need to calculate sum of balances from first block to the block before the one where our element is located and then just process all requests in the current block.\n\nAnother way was to use data structure from std library, described here. For each element we have two trees: remove times and add times. Then by getting order of the time in remove and add tree we can calculate the answer."
}