{
    "link": "https://codeforces.com//contest/533/problem/D",
    "problemId": "26205",
    "problem_idx": "D",
    "shortId": "533D",
    "contest_number": "533",
    "problem_submissions": {
        "A": [
            10758806,
            41260125,
            10758808,
            10802245,
            10802137,
            10804672
        ],
        "F": [
            10756507,
            10757309,
            10756418,
            10756618,
            10756621,
            10756168,
            10757079,
            10756058,
            10757142,
            10756771,
            10757619,
            10759646,
            10756355,
            10754977,
            10755266,
            10757451,
            10757215
        ],
        "B": [
            10754115,
            10753181,
            10753247,
            10758386,
            10754046,
            10755412,
            10754879,
            10754156,
            10755561,
            10754427,
            10755399,
            10754294,
            10754859,
            10753587,
            10753864,
            10753648,
            10756961,
            10754716,
            10755774
        ],
        "E": [
            10753290,
            10754938,
            10754117,
            10754867,
            10757574,
            10755405,
            10753428,
            10753036,
            10753133,
            10753451,
            10753117,
            10753877,
            10753615,
            10753601,
            10754357,
            10753173,
            10756615,
            10756357,
            10753749,
            10753638
        ],
        "C": [
            10753054,
            10753925,
            10753515,
            10754395,
            10759452,
            10754436,
            10754096,
            10753898,
            10753485,
            10759228,
            10753726,
            10753443,
            10753028,
            10753108,
            10754551,
            10754248,
            10757723,
            10757684,
            10753241,
            10754870
        ],
        "D": [
            10759362,
            10758040,
            10759441,
            10756824,
            10799120,
            10799069
        ]
    },
    "name": "D. Landmarks",
    "statement": "We have an old building with columns in a row. These columns support the\r\nceiling. These columns are located in points with coordinates . The\r\nleftmost and the rightmost columns are special, we will call them , the\r\nother columns are . For each column we know its durability . Let\u2019s\r\nconsider an ordinary column with coordinate . Let\u2019s assume that the\r\ncoordinate of the closest to it column to the left (bearing or ordinary)\r\nis and the coordinate of the closest to it column to the right (also,\r\nbearing or ordinary) is . In this task let\u2019s assume that this column\r\nsupports the segment of the ceiling from point to point (here both\r\nfractions are considered as real division). If the length of the segment\r\nof the ceiling supported by the column exceeds , then the column cannot\r\nsupport it and it crashes after a while, and after that the load is\r\nbeing redistributeed between the neighbouring columns according to the\r\nsame principle. Thus, ordinary columns will be crashing for some time\r\nuntil the process stops at some state. One can prove that the set of the\r\nremaining columns doesn\u2019t depend on the order in which columns crash. If\r\nthere are only two bearing columns left in the end, then we assume that\r\nthe whole construction crashes under the weight of the roof. But if at\r\nleast one ordinary column stays in addition to the bearing ones, then\r\nthe building doesn\u2019t crash.To make the building stronger, we can add one\r\nextra ordinary column of arbitrary durability at any (not necessarily\r\ninteger) point . If point is already occupied by an ordinary column, it\r\nis replaced by a new one.Your task is to find out: what minimal\r\ndurability can the added column have so that the building doesn\u2019t crash?\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N; // 0 and N are strong\nll X;\nll x[100010],r[100010],l[100010];\nll d[100010];\nbool broken[100010];\n\nint sz;\nint id[100010];\n\nll func(void){\n    int i,j;\n    \n    r[0] = l[N] = X;\n//  for(i=0;i<=N;i++) cout << x[i] << ' ' << l[i] << ' ' << r[i] << endl;\n    \n    for(i=1;i<N;i++){\n        if(x[i] + r[i] >= X) return 0;\n        if(x[i] - l[i] <= 0) return 0;\n    }\n    \n    ll ans = INF;\n//  REP(i,N+1) REP(j,N+1) if(i < j && x[i] + r[i] >= x[j] - l[j]) ans = min(ans, x[j] - x[i]);\n\n    sz = 0;\n\n    for(j=1;j<=N;j++){\n        i = j - 1;\n        if(r[i] != 0){\n            while(1){\n                if(sz == 0) break;\n                int p = id[sz-1];\n                if(x[p] + r[p] > x[i] + r[i]) break;\n                sz--;\n            }\n            id[sz] = i;\n            sz++;\n        }\n        \n        if(l[j] != 0){\n            int low = 0, high = sz;\n            while(high - low > 1){\n                int mid = (low + high) / 2;\n                int p = id[mid];\n                if(x[p] + r[p] >= x[j] - l[j]) low = mid; else high = mid;\n            }\n            int q = id[low];\n            ans = min(ans, x[j] - x[q]);\n        }\n    }\n    \n    return ans;\n}\n\nint st[100010];\n\nvoid calc_r(void){\n    int i;\n    \n    sz = 1;\n    st[0] = 0;\n    \n    for(i=1;i<N;i++){\n        while(1){\n            if(sz < 2) break;\n            int p = st[sz-2], q = st[sz-1];\n            if(2 * d[q] >= x[i] - x[p]) break;\n            sz--;\n        }\n        r[i] = 2 * d[i] - (x[i] - x[st[sz-1]]);\n        if(r[i] <= 0) r[i] = 0;\n        st[sz] = i;\n        sz++;\n    }\n}\n\nvoid calc_l(void){\n    int i;\n    \n    sz = 1;\n    st[0] = N;\n    \n    for(i=N-1;i>=1;i--){\n        while(1){\n            if(sz < 2) break;\n            int p = st[sz-2], q = st[sz-1];\n            if(2 * d[q] >= x[p] - x[i]) break;\n            sz--;\n        }\n        l[i] = 2 * d[i] - (x[st[sz-1]] - x[i]);\n        if(l[i] <= 0) l[i] = 0;\n        st[sz] = i;\n        sz++;\n    }\n}\n\nint main(void){\n    int i;\n    \n    cin >> N;\n    REP(i,N+2){\n        int tmp;\n        scanf(\"%d\", &tmp);\n        x[i] = tmp;\n    }\n    for(i=1;i<=N;i++){\n        int tmp;\n        scanf(\"%d\", &tmp);\n        d[i] = tmp;\n    }\n    N++;\n    X = x[N];\n    \n    calc_r();\n    calc_l();\n    \n    ll ans = func();\n    printf(\"%.9f\\n\", ans / 2.0);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Landmarks.json",
    "editorial_link": "https://codeforces.com//blog/entry/17458",
    "editorial": "First observation: column crashes only if distance between its neighbours is greater than 2di so it doesn't matter where exactly is this column. The only important thing is how far are left and right neighbour of it.\n\nFor every column C let's calculate does there exist subset of columns on the left that everything is stable between C and leftmost bearing column. If answer is yes then how close can be left neighbour of C? Then we will know how far the right neighbour can be. We will use dynamic programming.\n\nSlow approach: For every previous column let's check if it can be neighbours with C. The closest column fulfilling this condition is best left neighbour of C.\n\nFaster approach: Let's denote far[i] as the biggest possible coordinate where right neighbour of column i can be. In our dp we need an extra stack with possible candidates for being left neighbour of new column. In this stack columns are sorted in ascending order by index (and coordinate) and in descending order by far[i]. For every new column we must remove from the top of stack columns which have too low far[i]. Then last column on stack is the best left neighbour and we can calculate value far for current column. It is O(n) algorithm.\n\nSome columns can't be connected with leftmost bearing column and for them we have far[i]?=?0. If there exists column with far[i] not less than coordinate of rightmost bearing column then we don't have to add new column and answer is 0.\n\nOk. Now let's run the same dp from right to the left. Some columns are connected with leftmost bearing column, some other columns with righmost one. And we will want to place new column somewhere between them. Brute force solution is to check every pair of columns and to say: we want these two columns to be neighbours of added column. With values far[i] calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns.\n\nHow to make this last part faster? We must create two stacks with best candidates for neighbours of new column. One stack with columns connected to the leftmost column, one with the ones connected to the rightmost one. On these stacks we can find answer with two pointers technique."
}