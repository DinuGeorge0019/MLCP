{
    "link": "https://codeforces.com//contest/1416/problem/C",
    "problemId": "740367",
    "problem_idx": "C",
    "shortId": "1416C",
    "contest_number": "1416",
    "problem_submissions": {
        "F": [
            94006266,
            94013395,
            94017337,
            94007333,
            94012350,
            94016693,
            94144598,
            94144345,
            94143862,
            94143815,
            94143507,
            94143372,
            94134107,
            94022751,
            94013371,
            94123054,
            93993751,
            93995209,
            94206946,
            94047832
        ],
        "D": [
            93996097,
            94002143,
            93994280,
            93996848,
            94000279,
            93995262,
            93992025,
            94030965,
            93988840,
            94001509,
            93996287,
            94006105,
            94007577,
            94017080,
            93995866,
            93997659,
            93998139,
            93997214,
            93995418,
            94000331,
            93999706
        ],
        "E": [
            93989598,
            93993245,
            94005344,
            94008684,
            94029993,
            94019586,
            94015916,
            94018911,
            94274661,
            94428216,
            94428140,
            94046134
        ],
        "B": [
            93977851,
            93981480,
            93977205,
            93989726,
            93978642,
            93985288,
            93976209,
            93981357,
            93985099,
            93999768,
            93994963,
            94270201,
            93976947,
            93987758,
            93986950,
            93981437,
            93979361,
            93987047,
            93979513
        ],
        "C": [
            93974213,
            93978374,
            93983878,
            93979532,
            94282160,
            93989242,
            93980978,
            93980593,
            93976201,
            93990186,
            93986370,
            93974300,
            93996660,
            94001007,
            93983516,
            93980305,
            93980649,
            93977960,
            93984553,
            93980471,
            93985644
        ],
        "A": [
            93970422,
            93970885,
            93970919,
            93970033,
            93971425,
            93971578,
            93970140,
            93970220,
            93970538,
            93970561,
            93981050,
            94269181,
            94002877,
            93970437,
            93972131,
            93974465,
            93974988,
            93972065,
            93971571,
            93970260
        ]
    },
    "name": "C. XOR Inverse",
    "statement": "You are given an array a consisting of n non-negative integers. You have\r\nto choose a non-negative integer x and form a new array b of size n\r\naccording to the following rule: for all i from 1 to n, b_i = a_i\r\noplus x (\r\noplus denotes the operation bitwise XOR).An inversion in the b array is\r\na pair of integers i and j such that 1\r\nle i < j\r\nle n and b_i > b_j.You should choose x in such a way that the number of\r\ninversions in b is minimized. If there are several options for x output\r\nthe smallest one.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.09.2020 18:09:48       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<tuple<int, int, int>> v(n);\n  long long ans = 0;\n  int x = 0;\n  for (int bit = 0; bit < 30; bit++) {\n    for (int i = 0; i < n; i++) {\n      v[i] = make_tuple(a[i] >> (bit + 1), i, (a[i] >> bit) & 1);\n    }\n    sort(v.begin(), v.end());\n    long long inv0 = 0;\n    long long inv1 = 0;\n    int beg = 0;\n    while (beg < n) {\n      int end = beg;\n      while (end + 1 < n && get<0>(v[end + 1]) == get<0>(v[end])) {\n        ++end;\n      }\n      int k0 = 0;\n      int k1 = 0;\n      for (int i = beg; i <= end; i++) {\n        int bit = get<2>(v[i]);\n        if (bit == 0) {\n          inv0 += k1;\n          k0 += 1;\n        } else {\n          inv1 += k0;\n          k1 += 1;\n        }\n      }\n      beg = end + 1;\n    }\n    if (inv0 <= inv1) {\n      ans += inv0;\n    } else {\n      ans += inv1;\n      x += (1 << bit);\n    }\n  }\n  cout << ans << \" \" << x << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy",
        "math",
        "sortings",
        "strings",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. XOR Inverse.json",
    "editorial_link": "https://codeforces.com//blog/entry/83036",
    "editorial": "Take any arbitrary integers and . It is a well-known fact that whether\r\nor depends only on one bit the highest bit which differs in both.So,\r\nlet\u00e2\u0080\u0099s construct a on our array integers. Represent each number as a\r\nbinary string from the highest bit () to the lowest bit (). Each leaf\r\nwill keep a corresponding index/indices from the array and each non-leaf\r\nnode will have at most two children one for -edge and one for -edge.\r\nLet\u00e2\u0080\u0099s denote as a sorted list of indices of all values in the subtree of\r\n. These lists can be easily maintained while inserting our numbers into\r\ntrie. Take any arbitrary vertex which has both children and has a depth\r\n(distance from root) of . Let and be its children. Here comes the most\r\nimportant thing to notice: If the -th highest bit of is toggled, lists\r\nand will change their relative order. Otherwise, it will not change.\r\nThus, exploiting the fact that both lists are sorted, we can efficiently\r\ncalculate the corresponding number of inversions between those lists and\r\nadd them to our values and . means the number of inversions we have to\r\nadd if -th highest bit of is equal to . After the calculation of our\r\ntable is done, the value of can be easily restored.Time complexity:\r\nMemory complexity:\r\n"
}