{
    "link": "https://codeforces.com//contest/1603/problem/A",
    "problemId": "1163969",
    "problem_idx": "A",
    "shortId": "1603A",
    "contest_number": "1603",
    "problem_submissions": {
        "D": [
            133678384,
            133698397,
            133689761,
            133665373,
            133663811,
            133667904,
            133870635,
            133666377,
            133712181,
            133672518,
            133669513,
            133671913,
            133674123,
            133668504,
            133670450,
            134053883,
            133670044
        ],
        "E": [
            133654251,
            133698597,
            133670917,
            133670921,
            133674718,
            133678832,
            133691448,
            133677480,
            133745184,
            133682168,
            158346606
        ],
        "C": [
            133634336,
            133654076,
            133641887,
            133643661,
            133700965,
            133639890,
            133639559,
            133648557,
            133635180,
            133642566,
            133633281,
            133658219,
            133645221,
            133638128,
            133655485,
            133647398,
            133646553,
            133645458,
            133645891,
            133650269,
            134161088,
            133646180
        ],
        "B": [
            133625504,
            133622630,
            133627460,
            133627705,
            133633891,
            133623525,
            133628792,
            133627917,
            133622898,
            133644787,
            133630406,
            133626809,
            133635643,
            133632995,
            133629432,
            133625758,
            133629935,
            133631448,
            134161095,
            133621172
        ],
        "A": [
            133616996,
            133617371,
            133618050,
            133618145,
            133618661,
            133618290,
            133617671,
            133620309,
            133617150,
            133619091,
            133618690,
            133618619,
            133622033,
            133621990,
            133618626,
            133617653,
            133618140,
            133620543,
            134161100,
            133617177
        ],
        "F": [
            133669341,
            133700346,
            133679782,
            133709673,
            133694728,
            133720215,
            133975676,
            134484874,
            158277914
        ]
    },
    "name": "A. Di-visible Confusion",
    "statement": "YouKn0wWho has an integer sequence a_1, a_2,\r\nldots, a_n. He will perform the following operation until the sequence\r\nbecomes empty: select an index i such that 1\r\nle i\r\nle |a| and a_i is divisible by (i + 1), and erase this element from the\r\nsequence. Here |a| is the length of sequence a at the moment of\r\noperation. Note that the sequence a changes and the next operation is\r\nperformed on this changed sequence.For example, if a=[3,5,4,5], then he\r\ncan select i = 2, because a_2 = 5 is not divisible by i+1 = 3. After\r\nthis operation the sequence is [3,4,5].Help YouKn0wWho determine if it\r\nis possible to erase the whole sequence using the aforementioned\r\noperation.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.10.2021 17:35:01       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    while (n > 0) {\n      int i = n - 1;\n      while (i >= 0 && a[i] % (i + 2) == 0) {\n        i -= 1;\n      }\n      if (i < 0) {\n        break;\n      }\n      a.erase(a.begin() + i);\n      n -= 1;\n    }\n    cout << (n == 0 ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Di-visible Confusion.json",
    "editorial_link": "https://codeforces.com//blog/entry/96460",
    "editorial": "Notice that we can erase at positions from to . So for each , there\r\nshould be at least one integer from to such that is not divisible by\r\nthat integer. If it is not satisfied for some integer , then there is no\r\nsolution for sure. Otherwise, it turns out that a solution always\r\nexists. Why?We can prove it by induction. Letâs say it is possible to\r\nerase the prefix containing elements. As can be erased at some position\r\nfrom to (letâs say ), then while erasing the prefix of elements, when\r\nthe prefix contains elements, then is at the -th position, so we can\r\nerase it at that position and erase the rest of the sequence\r\naccordingly.So we just have to check for all integers from to , if is\r\nnot divisible by at least one integer from to . Notice that if is\r\ndivisible by integers from to , then it means that is divisible by . But\r\nwhen , . So for , there will always be an integer from to which doesnât\r\ndivide . So we donât have to check for them. For , use bruteforce.\r\nComplexity: .\r\n",
    "hint": []
}