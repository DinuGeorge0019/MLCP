{
    "link": "https://codeforces.com//contest/933/problem/E",
    "problemId": "156722",
    "problem_idx": "E",
    "shortId": "933E",
    "contest_number": "933",
    "problem_submissions": {
        "E": [
            35263883,
            35251948,
            35268367,
            35268343,
            35258532,
            35265034,
            35258504,
            35265045
        ],
        "D": [
            35253928,
            35258185,
            35262993,
            35255562,
            35257209,
            35258119,
            35266124,
            35259046,
            35259628,
            35259700,
            35265335,
            35260449
        ],
        "B": [
            35233893,
            35242633,
            35232112,
            35233002,
            35238615,
            35243022,
            35243572,
            35238260,
            35247862,
            35234313,
            35245448,
            35242161,
            35237846,
            35238319,
            35230597,
            35242429,
            35250941,
            35238138,
            35236021
        ],
        "C": [
            35231166,
            35245330,
            35230279,
            35242029,
            49040337,
            35232953,
            35241307,
            35235433,
            36073540,
            35240997,
            35235741,
            35461289,
            35244755
        ],
        "A": [
            35230392,
            35232143,
            35233996,
            35230183,
            35230822,
            35233720,
            35235277,
            35231518,
            35235425,
            35231181,
            35231151,
            35232842,
            35231443,
            35233064,
            35232632,
            35243872,
            35232580,
            35231791,
            35232474,
            35231989
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/57763",
    "editorial": "Noticing that there are no two consecutive positive integers\nafter the game ends, the final sequence can be divided into some\nintervals which consist only zero elements such that the gap between\nevery two adjacent intervals is at most one element (may positive).Letâs\ntry to solve a general version of this problem first. In this version,\nwe donât need to decrease two consecutive positive integers by their\nminimum. We can decrease any two consecutive integers by many times\n(even if integers are negative) and our task is to eliminate all two\nconsecutive positive integers such that the cost as small as possible.We\ncan prove by contradiction or adjustment that there are no negative\nelements in the best solution for the general version (because the\noriginal elements are non-negative). Furthermore, the cost of the best\nsolution for the general version is less or equal to that of the best\nsolution for the original version.Letâs consider the cost for the\ngeneral version to make such an interval (i. e. ) become all\nnon-positive . Before concluding the formula, you may assume .Let . We\ncan construct a series of operations to make them become non-positive\nsuch that the cost can be represented as . Letâs call the cost of such\nan interval as . Similarly, we know the actual minimal cost is less or\nequal to .If the length of an interval is greater than , there is an\nobservation that which implies any interval whose length is greater than\ncan be replaced by the cases of length and .We can easily prove that is\nthe actual minimal cost in the cases of length and . In addition, if we\nget any of the best solutions for the general version, we can construct\na series of operations which is valid both in the general version and\nthe original version. So we can conclude that the cost of the best\nsolution for the general version is greater or equal to that for the\noriginal version. With one conclusion we mentioned above, we know that\nthe minimal costs for the original version and the general version are\nequivalent.Denote as the minimum cost the first elements have used if\nthe -th element is going to be the right endpoint of such an interval.\nItâs easy to compute in .After picking up all the intervals for the best\nsolution, construction can be implemented by greedy. For example,\nutilize the descensions at the inner of intervals first, and then make\nuse of the descensions at the edge of intervals.Please note that there\nmay be at most one element that belongs to no interval at the head or\nthe tail of the final sequence. Also, the descensions should operate on\nintegers.\n",
    "name": "E. A Preponderant Reunion",
    "statement": "After the reunion dinner, Little Tommy plays a game with the family.\r\nHere is a concise introduction to this game: There is a sequence of\r\nnon-negative integers in the beginning. It is ruled that each integer in\r\nthis sequence should be non-negative . You can select two integers in\r\nthis sequence, and , and then decrease them by their minimum (i. e. ),\r\nthe cost of this operation is equal to . We call such operation as a .\r\nThe game immediately ends when there are no two consecutive positive\r\nintegers. Your task is to end the game so that the total cost of your\r\noperations is as small as possible. Obviously, every game ends after at\r\nmost descensions. Please share your solution of this game with the\r\nlowest cost.\r\n",
    "solutions": [
        "#include <iostream>#include <cstdio>#include <cstdlib>#include <algorithm>#include <cmath>#include <vector>#include <set>#include <map>#include <unordered_set>#include <unordered_map>#include <queue>#include <ctime>#include <cassert>#include <complex>#include <string>#include <cstring>using namespace std; #ifdef LOCAL\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)#else\t#define eprintf(...) 42#endif typedef long long ll;typedef pair<int, int> pii;#define mp make_pair const ll INF = (ll)1e16;const int N = 900300;const int K = 40;int n;ll a[N];ll sum[N];ll dp[N][2];int par[N][2][3];int intPoint[N];int m;vector<int> ans; ll getCost(int L, int R, int f1, int f2) {\tint len = R - L;\tif (len == 1) {\t\tif (a[L] == 0) return 0;\t\tif (f1 == 0 || f2 == 0) return -1;\t\treturn a[L];\t}\tif (len == 2) {\t\tif (a[L] == a[L + 1]) return 0;\t\tif (a[L] < a[L + 1]) {\t\t\tif (f2 == 0) return -1;\t\t\treturn abs(a[L + 1] - a[L]);\t\t} else {\t\t\tif (f1 == 0) return -1;\t\t\treturn abs(a[L + 1] - a[L]);\t\t}\t}\tif (f1 == 0 && a[L] > a[L + 1]) return -1;\tif (f2 == 0 && a[R - 1] > a[R - 2]) return -1;\tll cost = abs(sum[R] - sum[L]);\tif (len == 3) {\t\tif (a[L] + a[L + 2] <= a[L + 1]) return cost;\t\tif (f1 == 1 && f2 == 1) return cost;\t\tif (f1 == 0 && f2 == 0) return -1;\t\treturn cost;\t}\treturn cost;} void restoreAns(int L, int R, int f1, int f2) {\t//eprintf(\"restore %d %d %d %d\\n\", L, R, f1, f2);\tint len = R - L;\tif (len == 1) {\t\treturn;\t}\tif (len == 2) {\t\tif (a[L] == 0 || a[L + 1] == 0) return;\t\tans.push_back(L);\t\treturn;\t}\tif (f1 == 0 && a[L] != 0 && a[L + 1] != 0) {\t\tll x = min(a[L], a[L + 1]);\t\tans.push_back(L);\t\ta[L] -= x;\t\ta[L + 1] -= x;\t}\tif (f2 == 0 && a[R - 1] != 0 && a[R - 2] != 0) {\t\tll x = min(a[R - 1], a[R - 2]);\t\tans.push_back(R - 2);\t\ta[R - 2] -= x;\t\ta[R - 1] -= x;\t}\tfor (int i = L; i < R - 1; i++) {\t\tif (a[i] != 0 && a[i + 1] != 0) {\t\t\tll x = min(a[i], a[i + 1]);\t\t\tans.push_back(i);\t\t\ta[i] -= x;\t\t\ta[i + 1] -= x;\t\t}\t}}\tint main(){//\tfreopen(\"input.txt\", \"r\", stdin);//\tfreopen(\"output.txt\", \"w\", stdout); \tscanf(\"%d\", &n);\tfor (int i = 0; i < n; i++) {\t\tscanf(\"%lld\", &a[i]);\t\tsum[i + 1] = sum[i];\t\tif (i % 2 == 0)\t\t\tsum[i + 1] += a[i];\t\telse\t\t\tsum[i + 1] -= a[i];\t}\tfor (int i = 0; i <= n; i++) {\t\tif (i < 5 || i > n - 5) {\t\t\tintPoint[m++] = i;\t\t\tcontinue;\t\t}\t\tif (a[i - 1] <= a[i - 2] || a[i] <= a[i + 1])\t\t\tintPoint[m++] = i;\t}\tfor (int i = 0; i <= m; i++)\t\tdp[i][0] = dp[i][1] = -INF;\tdp[0][0] = 0;\tdp[0][1] = 0;\tfor (int i = 0; i < m; i++)\t\tfor (int f1 = 0; f1 < 2; f1++) {\t\t\tif (dp[i][f1] < 0) continue;\t\t\tfor (int j = i + 1; j < min(m, i + K); j++) {\t\t\t\tfor (int f2 = 0; f2 < 2 - f1; f2++)\t\t\t\t\tfor (int f3 = 0; f3 < 2; f3++) {\t\t\t\t\t\tll cost = getCost(intPoint[i], intPoint[j], f2, f3);\t\t\t\t\t\tif (cost == -1) continue;\t\t\t\t\t\tif (dp[i][f1] + cost > dp[j][f3]) {\t\t\t\t\t\t\tdp[j][f3] = dp[i][f1] + cost;\t\t\t\t\t\t\tpar[j][f3][0] = i;\t\t\t\t\t\t\tpar[j][f3][1] = f1;\t\t\t\t\t\t\tpar[j][f3][2] = f2;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t}\t\t}\tint x = m - 1;\tint f = 0;\tif (dp[x][1] > dp[x][0])\t\tf = 1;\twhile(x > 0) {\t\trestoreAns(intPoint[par[x][f][0]], intPoint[x], par[x][f][2], f);\t\tint nx = par[x][f][0];\t\tf = par[x][f][1];\t\tx = nx;\t}\tprintf(\"%d\\n\", (int)ans.size());\tfor (int y : ans)\t\tprintf(\"%d\\n\", 1 + y); \treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. A Preponderant Reunion.json",
    "hint": []
}