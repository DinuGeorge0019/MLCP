{"link": "https://codeforces.com//contest/533/problem/E", "problemId": "26206", "problem_idx": "E", "shortId": "533E", "contest_number": "533", "problem_submissions": {"A": [10758806, 41260125, 10758808, 10802245, 10802137, 10804672], "F": [10756507, 10757309, 10756418, 10756618, 10756621, 10756168, 10757079, 10756058, 10757142, 10756771, 10757619, 10759646, 10756355, 10754977, 10755266, 10757451, 10757215], "B": [10754115, 10753181, 10753247, 10758386, 10754046, 10755412, 10754879, 10754156, 10755561, 10754427, 10755399, 10754294, 10754859, 10753587, 10753864, 10753648, 10756961, 10754716, 10755774], "E": [10753290, 10754938, 10754117, 10754867, 10757574, 10755405, 10753428, 10753036, 10753133, 10753451, 10753117, 10753877, 10753615, 10753601, 10754357, 10753173, 10756615, 10756357, 10753749, 10753638], "C": [10753054, 10753925, 10753515, 10754395, 10759452, 10754436, 10754096, 10753898, 10753485, 10759228, 10753726, 10753443, 10753028, 10753108, 10754551, 10754248, 10757723, 10757684, 10753241, 10754870], "D": [10759362, 10758040, 10759441, 10756824, 10799120, 10799069]}, "name": "E. Correcting Mistakes", "statement": "Analyzing the mistakes people make while typing search queries is a\r\ncomplex and an interesting work. As there is no guaranteed way to\r\ndetermine what the user originally meant by typing some query, we have\r\nto use different sorts of heuristics.Polycarp needed to write a code\r\nthat could, given two words, check whether they could have been obtained\r\nfrom the same word as a result of typos. Polycarpus suggested that the\r\nmost common typo is skipping exactly one letter as you type a\r\nword.Implement a program that can, given two distinct words and of the\r\nsame length determine how many words of length are there with such\r\nproperty that you can transform into both , and by deleting exactly one\r\ncharacter. Words and consist of lowercase English letters. Word also\r\nshould consist of lowercase English letters.\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100101\nint n;\nchar t[MAX],s[MAX];\nmain(){\n  make(n);\n  scanf(\"%s%s\",t,s);\n  int a = 0;\n  while(t[a] == s[a])a++;\n  int b = 0;\n  while(t[n-b-1] == s[n-b-1])b++;\n  int wyn = 0;\n  int il = n-a-b-1;\n  bool cz = 1;\n  R(i,il)if(t[a+i] != s[a+i+1])cz = 0;\n  if(cz)wyn ++;\n  cz = 1;\n  R(i,il)if(t[a+i+1] != s[a+i])cz = 0;\n  if(cz)wyn ++;\n  printf(\"%d\\n\",wyn);\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "greedy", "hashing", "strings", "two pointers"], "dificulty": "1800", "interactive": false}