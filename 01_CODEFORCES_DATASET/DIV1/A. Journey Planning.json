{
    "link": "https://codeforces.com//contest/1320/problem/A",
    "problemId": "551754",
    "problem_idx": "A",
    "shortId": "1320A",
    "contest_number": "1320",
    "problem_submissions": {
        "F": [
            72202332,
            72223011,
            72205107,
            72198337,
            72222998,
            72196293,
            72223902
        ],
        "E": [
            72193224,
            72190175,
            72191679,
            72192473,
            72195171,
            89517976,
            72207354,
            72207256,
            72196434,
            72194256,
            72192283,
            72199164,
            72195289,
            72197732,
            72223673,
            72193338,
            72195901,
            72200544,
            72200353,
            72200814,
            72198992,
            72200456
        ],
        "C": [
            72184867,
            72177670,
            72177948,
            72173628,
            72175737,
            72172966,
            72176352,
            72179230,
            72175568,
            72177066,
            72173843,
            72175840,
            72176052,
            72179445,
            72190361,
            72188981,
            72179839,
            72183510,
            72186001,
            72181401
        ],
        "B": [
            72179476,
            72169823,
            72171581,
            72177394,
            72169041,
            72168596,
            72168669,
            72172513,
            72171074,
            72169530,
            72169385,
            72171115,
            72178856,
            72172293,
            72186108,
            72169156,
            72173456,
            72185954,
            72172093,
            72178248
        ],
        "D": [
            72176425,
            72181800,
            72183448,
            72260282,
            72184393,
            72182092,
            72185033,
            72188594,
            72279361,
            72184633,
            72186338,
            72185288,
            72188013,
            72184398,
            72189053,
            72517140,
            72199444,
            72180732,
            72186150,
            72193094,
            72172140,
            72191769,
            72190479
        ],
        "A": [
            72166896,
            72166972,
            72167131,
            72166858,
            72166891,
            72166853,
            72166967,
            72167271,
            72166947,
            72166915,
            72167040,
            72167216,
            72167056,
            72167066,
            72166886,
            72170109,
            72167510,
            72181754,
            72167043,
            72167049
        ]
    },
    "name": "A. Journey Planning",
    "statement": "Tanya wants to go on a journey across the cities of Berland. There are n\r\ncities situated along the main railroad line of Berland, and these\r\ncities are numbered from 1 to n. Tanya plans her journey as follows.\r\nFirst of all, she will choose some city c_1 to start her journey. She\r\nwill visit it, and after that go to some other city c_2 > c_1, then to\r\nsome other city c_3 > c_2, and so on, until she chooses to end her\r\njourney in some city c_k > c_{k - 1}. So, the sequence of visited cities\r\n[c_1, c_2,\r\ndots, c_k] should be strictly increasing.There are some additional\r\nconstraints on the sequence of cities Tanya visits. Each city i has a\r\nbeauty value b_i associated with it. If there is only one city in\r\nTanya\u2019s journey, these beauty values imply no additional constraints.\r\nBut if there are multiple cities in the sequence, then for any pair of\r\nadjacent cities c_i and c_{i + 1}, the condition c_{i + 1} - c_i =\r\nb_{c_{i + 1}} - b_{c_i} must hold.For example, if n = 8 and b = [3, 4,\r\n4, 6, 6, 7, 8, 9], there are several three possible ways to plan a\r\njourney: c = [1, 2, 4]; c = [3, 5, 6, 8]; c = [7] (a journey consisting\r\nof one city is also valid). There are some additional ways to plan a\r\njourney that are not listed above.Tanya wants her journey to be as\r\nbeautiful as possible. The beauty value of the whole journey is the sum\r\nof beauty values over all visited cities. Can you help her to choose the\r\noptimal plan, that is, to maximize the beauty value of the journey?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmap<int, long long> a;\n\tint n;\n\tcin >> n;\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\ta[i-x] += x;\n\t\tans = max(ans, a[i-x]);\n\t}\n\tcout << ans << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Journey Planning.json",
    "editorial_link": "https://codeforces.com//blog/entry/74431",
    "editorial": "Let\u00e2\u0080\u0099s rewrite the equality given in the statement as . It means that all\r\ncities in our path will have the same value of ; furthermore, all cities\r\nwith the same such value can always be visited in ascending order.So we\r\nmay group cities by , compute the sum in each group and find the maximum\r\nover all groups. For example, this can be done by storing the sum for\r\neach in an array (be careful with negative values of , though!)\r\n"
}