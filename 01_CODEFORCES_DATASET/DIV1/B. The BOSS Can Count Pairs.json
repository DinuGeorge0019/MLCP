{
    "link": "https://codeforces.com//contest/1830/problem/B",
    "problemId": "1942556",
    "problem_idx": "B",
    "shortId": "1830B",
    "contest_number": "1830",
    "problem_submissions": {
        "F": [
            234326044,
            207652053,
            207663837,
            207807721,
            208075080,
            208075031,
            207678271
        ],
        "D": [
            207640246,
            207630410,
            207637627,
            207621354,
            207615321,
            207636175,
            207642613,
            207640107,
            207677598,
            207636486,
            207674640,
            207643231,
            207672649,
            207672513,
            207643891,
            207672422,
            207672033,
            207644310,
            207746469,
            207746389,
            207650197,
            207645186,
            207822601,
            207822565,
            207645978,
            207642565,
            207658410,
            207638831
        ],
        "C": [
            207608017,
            207600613,
            207612008,
            207600441,
            207604832,
            207598385,
            207603497,
            207608198,
            207613818,
            207614226,
            207616264,
            207606682,
            207610887,
            234877458,
            207617296,
            207626821,
            207621747,
            207647815,
            207622607,
            207619463
        ],
        "B": [
            207599759,
            207593405,
            207597186,
            207596843,
            207596098,
            207591556,
            207609227,
            207602206,
            207592261,
            207601856,
            207592644,
            207601118,
            207592805,
            207603544,
            207613114,
            207602486,
            207597786,
            207598115,
            207609684
        ],
        "A": [
            207586682,
            207582994,
            207583697,
            207581917,
            207581457,
            207583108,
            207588869,
            207586429,
            207584682,
            207584850,
            207583599,
            207583185,
            207584377,
            207587215,
            207597686,
            207589557,
            207585837,
            207585764,
            207588046
        ],
        "E": [
            207715760,
            207661818,
            207884996,
            207884714,
            207713105,
            208057779
        ]
    },
    "name": "B. The BOSS Can Count Pairs",
    "statement": "You are given two arrays a and b, both of length n.Your task is to count\r\nthe number of pairs of integers (i,j) such that 1\r\nleq i < j\r\nleq n and a_i\r\ncdot a_j = b_i+b_j.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\n#define rep1n(i, n) for (int i = 1; i <= (n); ++i)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define each(x, a) for (auto &x : a)\n#define ar array\n#define vec vector\n#define range(i, n) rep(i, n)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\n\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nint Bit(int mask, int b) { return (mask >> b) & 1; }\n\ntemplate<class T>\nbool ckmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool ckmax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int INFi = 1e9;\nconst ll INF = 3e18;\nconst int LG = 20;\nconst int maxN = 2e5 + 5;\n\nvoid solve() {\n    int n; cin >> n;\n    vi a(n), b(n);\n    rep(i, n) cin >> a[i];\n    rep(i, n) cin >> b[i];\n    vvi have(n + 1);\n    rep(i, n) have[a[i]].push_back(b[i]);\n    rep(i, n + 1) sort(all(have[i]));\n    ll ans = 0;\n    for(int x = 1; x <= n; ++x) {\n        if (have[x].empty()) continue;\n        for(int y = 1; y * x <= 2 * n && y <= x; ++y) {\n            if (have[y].empty()) continue;\n            int z = x * y;\n            if (x == y) {\n                ll cnt = 0;\n                for(auto &val : have[x]) {\n                    if (val * 2 == z) cnt--;\n                    cnt += lower_bound(all(have[y]), (z - val) + 1) - lower_bound(all(have[y]), z - val);\n                }\n                ans += cnt / 2;\n                continue;\n            }\n            if (have[x].size() < have[y].size()) {\n                for(auto &val : have[x]) {\n                    ans += lower_bound(all(have[y]), (z - val) + 1) - lower_bound(all(have[y]), z - val);\n                }\n            } else {\n                for(auto &val : have[y]) {\n                    ans += lower_bound(all(have[x]), (z - val) + 1) - lower_bound(all(have[x]), z - val);\n                }\n            }\n        }\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(12) << fixed;\n    int t = 1;\n    cin >> t;\n    rep(i, t) {\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. The BOSS Can Count Pairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "Solution Since and , . Therefore, .Let and be the number of pairs from\nthe input such that . A pair is good if it satisfies .Firstly, weâll\ncount the number of good pairs such that . Since , we can see that .This\nsum can be written as: The remaining good pairs will have , and instead\nof counting the pairs which have , we can count the pairs which have\n.Since , we can say that .Substituting for , this second sum can be\nwritten as: Since weâve already established that , calculating this sum\ntakes time.Be especially careful when calculating these sums, as and can\nend up being either negative or greater than .Time complexity per\ntestcase:\n",
    "hint": [
        "Hint 1 Since and , .",
        "Hint 2 Since , then ."
    ]
}