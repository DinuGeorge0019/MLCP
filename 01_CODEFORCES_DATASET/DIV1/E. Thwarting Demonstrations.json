{"link": "https://codeforces.com//contest/191/problem/E", "problemId": "1354", "problem_idx": "E", "shortId": "191E", "contest_number": "191", "problem_submissions": {"D": [1730940, 1730058, 1732061, 1732109, 1732464], "E": [1728781, 1730615, 1727981, 1728842, 1729175, 1728797, 1729393, 1729602, 1729222, 1729975, 1730220, 1730326, 1729991, 1730136, 1729526, 1730229, 1730018, 1730441, 1730472], "C": [1727557, 1727971, 1727279, 1727922, 1728193, 1726763, 1727330, 1728312, 1727749, 1728454, 1728335, 1728217, 1728234, 1728828, 1727958, 1728318, 1727470, 1728758, 1727987], "B": [1726383, 1726744, 1729343, 1727040, 1726927, 1730397, 1728304, 1726935, 1728912, 1727207, 1727504, 1727317, 1729119, 1727295, 1728990, 1727070, 1729275, 1727129, 1729072], "A": [1725547, 1725524, 1725641, 1725909, 1725741, 1725703, 1725714, 1725752, 1725615, 1725779, 1725777, 1725532, 1726185, 1725907, 1725443, 1725690, 1725534, 1725596, 1727248]}, "name": "E. Thwarting Demonstrations", "statement": "It is dark times in Berland. Berlyand opposition, funded from a\r\nneighboring state, has organized a demonstration in Berland capital\r\nBertown. Through the work of intelligence we know that the\r\ndemonstrations are planned to last for days.Fortunately, Berland has a\r\nspecial police unit, which can save the country. It has exactly soldiers\r\nnumbered from to . Berland general, the commander of the detachment,\r\nmust schedule the detachment\u2019s work in these difficult days. In each of\r\nthese days, the general must send a certain number of police officers to\r\ndisperse riots. Since the detachment is large and the general is not\r\nvery smart, he can only select a set of all soldiers numbered from to ,\r\ninclusive, where and are selected arbitrarily.Now the general has\r\nexactly two problems. First, he cannot send the same group twice then\r\nsoldiers get bored and they rebel. Second, not all soldiers are equally\r\nreliable. Every soldier has a reliability of . The reliability of the\r\ndetachment is counted as the sum of reliabilities of soldiers in it. The\r\nreliability of a single soldier can be negative, then when you include\r\nhim in the detachment, he will only spoil things. The general is\r\ndistinguished by his great greed and shortsightedness, so each day he\r\nsends to the dissolution the most reliable group of soldiers possible\r\n(that is, of all the groups that have not been sent yet).The Berland\r\nGovernment has decided to know what would be the minimum reliability of\r\nthe detachment, sent to disperse the demonstrations during these days.\r\nThe general himself can not cope with such a difficult task. Help him to\r\nnot embarrass himself in front of his superiors!\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"std\"\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst ll INF = 1e18;\nclass segm_tree {\n  const vll &vals;\n  int off;\n  vi tr;\n  \n  public:\n  segm_tree(const vll &_vals) : vals(_vals) {\n    off = 1; while (off < sz(vals)) off <<= 1;\n    tr = vi(2 * off);\n  }\n  void add(ll x, int v) {\n    x = lower_bound(vals.begin(), vals.end(), x) - vals.begin();\n    for (x += off; x >= 1; x >>= 1)\n      tr[x] += v;\n  }\n  int getCnt(ll l, ll r) {\n    l = lower_bound(vals.begin(), vals.end(), l) - vals.begin();\n    r = upper_bound(vals.begin(), vals.end(), r) - vals.begin() - 1;\n    l += off; r += off;\n    int res = 0;\n    while (l <= r) {\n      if (l & 1) res += tr[l++];\n      if (!(r & 1)) res += tr[r--];\n      l >>= 1; r >>= 1;\n    }\n    return res;\n  }\n};\n\nint n;\nvll ss;\nvll vals;\n\nll getCnt(ll maxs) {\n  segm_tree tr(vals);\n  for (int i = 0; i <= n; i++)\n    tr.add(ss[i], 1);\n  \n  ll res = 0;\n  for (int l = 0; l <= n; l++) {\n    tr.add(ss[l], -1);\n    // x - ss[l] >= maxs\n    // x <= maxs + ss[l]\n    res += tr.getCnt(maxs + ss[l], INF);\n  }\n  return res;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME \".in\", \"r\", stdin);\n  freopen(TASKNAME \".out\", \"w\", stdout);\n  #endif\n  \n  ll k;\n  while (scanf(\"%d%I64d\", &n, &k) >= 2) {\n    vll as(n);\n    for (int i = 0; i < n; i++)\n      scanf(\"%I64d\", &as[i]);\n      \n    ss = vll(n + 1);\n    for (int i = 0; i < n; i++)\n      ss[i + 1] = ss[i] + as[i];\n      \n    vals = ss;\n    sort(vals.begin(), vals.end());\n    vals.erase(unique(vals.begin(), vals.end()), vals.end());\n      \n    ll L = -INF, R = INF;\n    assert(getCnt(L) >= k);\n    assert(getCnt(R) < k);\n    while (L + 1 < R) {\n      ll M = (L + R) / 2;\n      if (getCnt(M) >= k) L = M;\n      else R = M;\n    }\n    printf(\"%I64d\\n\", L);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "trees"], "dificulty": "2200", "interactive": false}