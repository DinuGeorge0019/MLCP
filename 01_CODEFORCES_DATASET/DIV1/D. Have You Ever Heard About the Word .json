{"link": "https://codeforces.com//contest/319/problem/D", "problemId": "3258", "problem_idx": "D", "shortId": "319D", "contest_number": "319", "problem_submissions": {"D": [3948106, 3949160, 3951651, 3949707, 3949637, 3949775, 3962727, 3950884, 4081627, 3951853], "C": [3946594, 3947263, 3948244, 3948613, 3948176, 3945420, 3945758, 3945713, 3946296, 3946346, 3946524, 3946613, 3946482, 3945816, 3947039, 3946470], "B": [3944659, 3943682, 3946080, 3946044, 3946423, 3943572, 3944269, 3944276, 3944495, 3944694, 3944617, 3944629, 3943999, 3945031, 3943612, 3945716], "A": [3942928, 3944735, 3943181, 3943824, 3943092, 3942620, 3942968, 3942994, 3942953, 3943439, 3942852, 3943177, 3942732, 3944034, 3944966, 3944250], "E": [4934160]}, "name": "D. Have You Ever Heard About the Word ", "statement": "A of a string is a contiguous subsequence of that string. So, string is\r\nsubstring of string , but string is not.A is a string formed by\r\nconcatenating some string with itself. So, string is a repeating block,\r\nbut strings , are not.You\u2019ve got a sequence of Latin characters\r\n(string). At each step you find the shortest substring that is a\r\nrepeating block, if there exists more than one you must choose the\r\nleftmost. As the substring is of form ( some string) you replace this\r\nsubstring with , in other words you delete one of the substrings in the\r\nsubstring. You repeat this process until there remains no repeating\r\nblock in the string. How would the final string looks like? Look at the\r\nsample explanation to understand the statement more precise.\r\n", "solutions": ["#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\nconst double pi = acos(-1.0);\nconst int size = 50 * 1000 + 100;\n\nchar buf[size];\n\nint main() {\n\t/*\n\tfreopen(\"problem_d.in\", \"w\", stdout);\n\tfor (int i = 0; i < 12500; i++)\n\t\tprintf(\"ab\");\n\tfor (int i = 0; i < 25 * 1000; i++)\n\t\tprintf(\"a\");\n\tprintf(\"\\n\");\n\treturn 0;\n\t*/\n\t//freopen(\"problem_d.in\", \"r\", stdin);\n\t//freopen(\"problem_d.out\", \"w\", stdout);\n\t\n\tdouble sttm = clock();\n\tscanf(\"%s\", buf);\n\tint n = strlen(buf);\n\tint p;\n\tint ps;\n\tint len;\n\twhile (true) {\n\t\tps = -1;\n\t\tlen = -1;\n\t\tfor (int i = 1; i <= n / 2; i++) {\n\t\t\tint p = 0;\n\t\t\tint lim = n - 2 * i;\n\t\t\tfor (int j = 0; j <= lim; j++) {\n\t\t\t\twhile (p < i && buf[j + p] == buf[j + i + p])\n\t\t\t\t\tp++;\n\t\t\t\tif (p == i) {\n\t\t\t\t\tlen = i;\n\t\t\t\t\tps = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p > 0)\n\t\t\t\t\tp--;\n\t\t\t}\n\t\t\tif (ps != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ps == -1)\n\t\t\tbreak;\n\t\tfor (int j = ps + len; j < n - len; j++)\n\t\t\tbuf[j] = buf[j + len];\n\t\tn -= len;\n\t}\n\tbuf[n] = '\\0';\n\tprintf(\"%s\\n\", buf);\n\n\t//cout << (clock() - sttm) / CLOCKS_PER_SEC << endl;\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["greedy", "hashing", "string suffix structures", "strings"], "dificulty": "2800", "interactive": false}