{"link": "https://codeforces.com//contest/744/problem/E", "problemId": "85243", "problem_idx": "E", "shortId": "744E", "contest_number": "744", "problem_submissions": {"D": [23172550, 23101161, 23068735, 23073667, 23132587, 23132570, 23072938], "B": [23071347, 23055547, 23056640, 23057482, 23055511, 23066941, 23058988, 23055885, 23055635, 23056110, 23057772, 23056735, 23057617, 23056511, 23062111, 23062274, 23057681, 23057651, 23056286], "C": [23071345, 23057499, 23060727, 23060442, 23060420, 23066137, 23056758, 23059869, 23060628, 23060184, 23060124, 23061291, 23060827, 23061807, 23057367, 23057447, 23062076, 23060867, 23062926], "E": [23071342, 23063797, 23070592, 23069714, 23064327], "A": [23071326, 23052903, 23053379, 23054137, 23053853, 23053406, 23053000, 23053710, 23053750, 23054145, 23053643, 23053798, 23058381, 23059184, 23053344, 23054382, 23053476]}, "name": "E. Hongcow Masters the Cyclic Shift", "statement": "Hongcow\u2019s teacher heard that Hongcow had learned about the cyclic shift,\r\nand decided to set the following problem for him.You are given a list of\r\nstrings contained in the list .A list of strings is called if the\r\nfollowing condition holds.First, a is defined as a concatenation of some\r\nelements of the list . You can use an arbitrary element as many times as\r\nyou want, and you may concatenate these elements in any arbitrary order.\r\nLet denote the set of of all messages you can construct from the list.\r\nOf course, this set has infinite size if your list is nonempty.Call a\r\nsingle message if the following conditions hold: Suppose the message is\r\nthe concatenation of strings , where each is an element of . Consider\r\nthe cyclic shifts of the string. Let be the number of these cyclic\r\nshifts of the string that are elements of . A message is good if and\r\nonly if is exactly equal to . The list is called stable if and only if\r\nevery element of is good.Let be if is a stable list, and otherwise.Find\r\nthe sum of where is a nonempty of (there are contiguous sublists in\r\ntotal).\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nchar foo[42][N];\nint z[N];\nchar s[N];\n\nvoid build_z(int n) {\n  int l = 0, r = 0;\n  z[0] = n;\n  for (int i = 1; i < n; i++) {\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n}\n\nvector < pair <int, int> > edges[N];\nvector <int> g[N], gr[N];\n\nvoid add(int x, int y, int z) {\n//  cerr << \"adding \" << x << \" \" << y << \" \" << z << endl;\n  edges[x].push_back(make_pair(y, z));\n}\n\nbool was[N];\nint w[N], kw;\n\nvoid dfs1(int v) {\n  was[v] = true;\n  for (int j = 0; j < (int) g[v].size(); j++) {\n    int u = g[v][j];\n    if (!was[u]) {\n      dfs1(u);\n    }\n  }\n  w[kw++] = v;\n}\n\nint c[N];\nint of_c[N];\n\nvoid dfs2(int v) {\n  for (int j = 0; j < (int) gr[v].size(); j++) {\n    int u = gr[v][j];\n    if (c[u] == -1) {\n      c[u] = c[v];\n      of_c[c[u]]++;\n      dfs2(u);\n    }\n  }\n}\n\nbool loop[N];\nint start[N], finish[N];\nint flen[N];\nint vers;\n\nbool test(int from, int to) {\n  if (from > to) {\n    return true;\n  }\n  for (int i = 0; i < vers; i++) {\n    g[i].clear();\n    gr[i].clear();\n  }\n  for (int i = 0; i < vers; i++) {\n    was[i] = true;\n    loop[i] = false;\n  }\n  was[0] = false;\n  for (int j = 0; j < (int) edges[0].size(); j++) {\n    g[0].push_back(edges[0][j].first);\n    gr[edges[0][j].first].push_back(0);\n  }\n  for (int id = from; id <= to; id++) {\n    for (int i = start[id]; i < finish[id]; i++) {\n      was[i] = false;\n      for (int j = 0; j < (int) edges[i].size(); j++) {\n        int helper = edges[i][j].second;\n        if (helper < from || helper > to) {\n          continue;\n        }\n        if (i == edges[i][j].first) {\n          loop[i] = true;\n        }\n        g[i].push_back(edges[i][j].first);\n        gr[edges[i][j].first].push_back(i);\n      }\n    }\n  }\n  kw = 0;\n  for (int i = 0; i < vers; i++) {\n    if (was[i]) {\n      continue;\n    }\n    dfs1(i);\n  }\n  for (int i = 0; i < vers; i++) {\n    c[i] = -1;\n  }\n  int nc = 0;\n  for (int id = kw - 1; id >= 0; id--) {\n    int i = w[id];\n    if (c[i] == -1) {\n      of_c[nc] = 1;\n      c[i] = nc++;\n      dfs2(i);\n    }\n  }\n  for (int id = from; id <= to; id++) {\n    for (int i = start[id] + 1; i < finish[id]; i++) {\n      if (of_c[c[i]] > 1 || loop[i]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  int cnt;\n  scanf(\"%d\", &cnt);\n  vers = 1;\n  for (int i = 0; i < cnt; i++) {\n    scanf(\"%s\", foo[i]);\n    flen[i] = strlen(foo[i]);\n    start[i] = vers;\n    vers += flen[i];\n    finish[i] = vers;\n    add(0, start[i], -1);\n  }\n  for (int i = 0; i < cnt; i++) {\n    int n = 0;\n    for (int j = 0; j < flen[i]; j++) {\n      s[n++] = foo[i][j];\n    }\n    s[n++] = '#';\n    int from = n;\n    for (int q = 0; q < cnt; q++) {\n      n = from;\n      for (int j = 0; j < flen[q]; j++) {\n        s[n++] = foo[q][j];\n      }\n      build_z(n);\n      for (int j = 0; j < flen[q]; j++) {\n        int x = flen[i];\n        int y = flen[q] - j;\n        if (z[from + j] != min(x, y)) {\n          continue;\n        }\n//        cerr << \"hi! \" << i << \" \" << q << \" \" << j << \" \" << x << \" \" << y << \" \" << z[from + j] << endl;\n        if (x == y) {\n          add(start[q] + j, 0, i);\n        } else {\n          if (x < y) {\n            add(start[q] + j, start[q] + j + x, i);\n          } else {\n            add(start[q] + j, start[i] + y, i);\n          }\n        }\n      }\n    }\n  }\n  int j = -1;\n  int ans = 0;\n  for (int i = 0; i < cnt; i++) {\n    while (j + 1 < cnt) {\n      if (!test(i, j + 1)) {\n        break;\n      }\n      j++;\n    }\n    if (i <= j) {\n      ans += j - i + 1;\n    }\n//    cerr << i << \" -> \" << j << endl;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["strings", "two pointers"], "dificulty": "3200", "interactive": false}