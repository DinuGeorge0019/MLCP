{
    "link": "https://codeforces.com//contest/1416/problem/E",
    "problemId": "740369",
    "problem_idx": "E",
    "shortId": "1416E",
    "contest_number": "1416",
    "problem_submissions": {
        "F": [
            94006266,
            94013395,
            94017337,
            94007333,
            94012350,
            94016693,
            94144598,
            94144345,
            94143862,
            94143815,
            94143507,
            94143372,
            94134107,
            94022751,
            94013371,
            94123054,
            93993751,
            93995209,
            94206946,
            94047832
        ],
        "D": [
            93996097,
            94002143,
            93994280,
            93996848,
            94000279,
            93995262,
            93992025,
            94030965,
            93988840,
            94001509,
            93996287,
            94006105,
            94007577,
            94017080,
            93995866,
            93997659,
            93998139,
            93997214,
            93995418,
            94000331,
            93999706
        ],
        "E": [
            93989598,
            93993245,
            94005344,
            94008684,
            94029993,
            94019586,
            94015916,
            94018911,
            94274661,
            94428216,
            94428140,
            94046134
        ],
        "B": [
            93977851,
            93981480,
            93977205,
            93989726,
            93978642,
            93985288,
            93976209,
            93981357,
            93985099,
            93999768,
            93994963,
            94270201,
            93976947,
            93987758,
            93986950,
            93981437,
            93979361,
            93987047,
            93979513
        ],
        "C": [
            93974213,
            93978374,
            93983878,
            93979532,
            94282160,
            93989242,
            93980978,
            93980593,
            93976201,
            93990186,
            93986370,
            93974300,
            93996660,
            94001007,
            93983516,
            93980305,
            93980649,
            93977960,
            93984553,
            93980471,
            93985644
        ],
        "A": [
            93970422,
            93970885,
            93970919,
            93970033,
            93971425,
            93971578,
            93970140,
            93970220,
            93970538,
            93970561,
            93981050,
            94269181,
            94002877,
            93970437,
            93972131,
            93974465,
            93974988,
            93972065,
            93971571,
            93970260
        ]
    },
    "name": "E. Split",
    "statement": "One day, decided to play around with arrays and came up with the\r\nfollowing problem:You are given an array a, which consists of n positive\r\nintegers. The array is numerated 1 through n. You execute the following\r\nprocedure : You create a new array b which consists of 2n integers,\r\nwhere for each 1\r\nle i\r\nle n the condition b_{2i-1}+b_{2i} = a_i holds. For example, for the\r\narray a = [6, 8, 2] you can create b = [2, 4, 4, 4, 1, 1]. You merge\r\nconsecutive equal numbers in b. For example, b = [2, 4, 4, 4, 1, 1]\r\nbecomes b = [2, 4, 1]. Find and print value of |b| (size of b) which can\r\nbe achieved at the end of the procedure. It can be shown that under the\r\ngiven constraints there is at least one way to construct b.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.09.2020 18:32:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    const int inf = (int) 1.01e9;\n    long long L = 1;\n    long long R = inf;\n    set<long long> s;\n    long long sign = 1;\n    long long delta = 0;\n    int ans = 0;\n    for (int x : a) {\n      if (x % 2 == 1) {\n        swap(L, R);\n        L = max(x - L, 1LL);\n        R = min(x - R, x - 1LL);\n        sign *= -1;\n        delta *= -1;\n        delta += x;\n        while (!s.empty()) {\n          long long val = (*s.begin()) * sign + delta;\n          if (val < 1 || val >= x) {\n            s.erase(s.begin());\n          } else {\n            break;\n          }\n        }\n        while (!s.empty()) {\n          auto it = prev(s.end());\n          long long val = (*it) * sign + delta;\n          if (val < 1 || val >= x) {\n            s.erase(it);\n          } else {\n            break;\n          }\n        }\n        if (s.empty() && L > R) {\n          sign = 1;\n          delta = 0;\n          L = 1;\n          R = x - 1;\n        } else {\n          ans += 1;\n        }\n      } else {\n        swap(L, R);\n        L = max(x - L, 1LL);\n        R = min(x - R, x - 1LL);\n        sign *= -1;\n        delta *= -1;\n        delta += x;\n        if ((L <= x / 2 && x / 2 <= R) || s.find((x / 2 - delta) * sign) != s.end()) {\n          ans += 2;\n          s.clear();\n          sign = 1;\n          delta = 0;\n          L = x / 2;\n          R = x / 2;\n        } else {\n          while (!s.empty()) {\n            long long val = (*s.begin()) * sign + delta;\n            if (val < 1 || val >= x) {\n              s.erase(s.begin());\n            } else {\n              break;\n            }\n          }\n          while (!s.empty()) {\n            auto it = prev(s.end());\n            long long val = (*it) * sign + delta;\n            if (val < 1 || val >= x) {\n              s.erase(it);\n            } else {\n              break;\n            }\n          }\n          s.insert((x / 2 - delta) * sign);\n          ans += 1;\n        }\n      }\n    }\n    cout << 2 * n + 1 - ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Split.json",
    "editorial_link": "https://codeforces.com//blog/entry/83036",
    "editorial": "Note that minimizing is the same as maximizing the number of consecutive\r\nequal pairs. We will focus on the second version.Let\u00e2\u0080\u0099s forget about\r\nconstraints and consider the most naive solution with dynamic\r\nprogramming. will store the answer if we have already considered (, ...,\r\n) and our last element is equal to . Let\u00e2\u0080\u0099s get rid of our dimension and\r\nkeep our table by layers. Suppose that our current -th layer is called ,\r\nnext layer is called , and is called .After carefully analyzing our\r\ntransitions, we have the following observations: for any , , since we\r\nalways have a transition from our maximum. , since we can add at most\r\ntwo pairs. The case may occur only if is even. Moreover, will be the\r\nonly maximum element. For some suffix upto we always have a transition\r\nfrom to . If is even, instead of calculating separately, we can\r\ncalculate it as usual and increase its value by at the end. Using\r\neverything said above, we could replace our naive with the following: A\r\nvariable called the value of minimum of our current layer. A set called\r\nit keeps all indices such that . A variable called it is equal to or\r\ndepending on the parity of and the value of . Basically, we want to be\r\nable to: Erase some elements from the prefix/suffix of our set . Check\r\nif some number is in our set . Add a segment of values into out set .\r\nRotate all elements in our set by a pivot . That is, a number should\r\nturn into . We can efficiently process all queries by maintaining as a\r\nsimple set of non-intersecting segments. The rotation operation can be\r\ndone as follows: Suppose we had an integer at the beginning. We rotate\r\neverything by a pivot . becomes . We rotate everything by a pivot .\r\nbecomes . Following the logic, , , ... We can just maintain the sign of\r\nand a global pivot, which is the combination of all our rotation\r\noperations. Time complexity: Space complexity:\r\n"
}