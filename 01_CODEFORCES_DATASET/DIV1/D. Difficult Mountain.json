{
    "link": "https://codeforces.com//contest/1601/problem/D",
    "problemId": "1157780",
    "problem_idx": "D",
    "shortId": "1601D",
    "contest_number": "1601",
    "problem_submissions": {
        "F": [
            133036741,
            133030850,
            133053471,
            133036776,
            136096402,
            133146246
        ],
        "E": [
            133012503,
            133009950,
            133010165,
            133012509,
            133023042,
            133010446,
            133029069,
            133020546,
            133026708,
            133026848,
            133096129,
            133096027,
            133009106,
            133031363,
            133005130,
            133031540,
            133037221,
            133324190,
            133128643,
            133007675,
            133037406
        ],
        "D": [
            133003986,
            133005946,
            133003145,
            133019481,
            133007804,
            133008410,
            133020273,
            133009176,
            133009157,
            133008849,
            133009299,
            133026582,
            133008809,
            133014147,
            133008199,
            133009583,
            133010326,
            133056419,
            133004546,
            133008768
        ],
        "C": [
            132999482,
            132998781,
            132997710,
            132998487,
            133003047,
            133002651,
            133001118,
            133000071,
            133003217,
            132998126,
            133000279,
            133000540,
            133004698,
            133023294,
            133006018,
            133000684,
            132998660,
            133001622,
            133009000,
            133004643
        ],
        "B": [
            132991406,
            132991376,
            132992870,
            132992842,
            132992304,
            132995590,
            132995226,
            132992037,
            132995055,
            132990916,
            132993158,
            132995079,
            132994798,
            132993699,
            132996347,
            133113107,
            132993962,
            132993893,
            132997201,
            132995373,
            132994895
        ],
        "A": [
            132984771,
            132984572,
            132985020,
            132988648,
            132985081,
            132985096,
            132984905,
            132984874,
            132986113,
            132984658,
            132986695,
            132985767,
            132986320,
            132985605,
            132985251,
            132987796,
            132985532,
            132985036,
            132986108,
            132986609
        ]
    },
    "name": "D. Difficult Mountain",
    "statement": "A group of n alpinists has just reached the foot of the mountain. The\r\ninitial difficulty of climbing this mountain can be described as an\r\ninteger d.Each alpinist can be described by two integers s and a, where\r\ns is his skill of climbing mountains and a is his neatness.An alpinist\r\nof skill level s is able to climb a mountain of difficulty p only if p\r\nleq s. As an alpinist climbs a mountain, they affect the path and thus\r\nmay change mountain difficulty. Specifically, if an alpinist of neatness\r\na climbs a mountain of difficulty p the difficulty of this mountain\r\nbecomes\r\nmax(p, a). Alpinists will climb the mountain one by one. And before the\r\nstart, they wonder, what is the maximum number of alpinists who will be\r\nable to climb the mountain if they choose the right order. As you are\r\nthe only person in the group who does programming, you are to answer the\r\nquestion.Note that after the order is chosen, each alpinist who can\r\nclimb the mountain, must climb the mountain at that time.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m, d, s[500005], a[500005];\npair<PII, int> val[500005];\nint dp[500005];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &d);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &s[i], &a[i]);\n\t\tif(s[i] < d) continue;\n\t\tif(s[i] < a[i]) val[m ++] = MP(MP(a[i], s[i]), 0);\n\t\telse val[m ++] = MP(MP(s[i], a[i]), 1);\n\t}\n\tsort(val, val + m);\n\tint mx = 0, cnt = 0;\n\trep(i, m) {\n\t\tmx = max(mx, val[i].first.second);\n\t\tdp[i] = i == 0 ? 0 : dp[i - 1];\n\t\tif(val[i].second == 0) {\n\t\t\tif(mx <= val[i].first.second) dp[i] = max(dp[i], dp[upper_bound(val, val + m, MP(MP(val[i].first.second, INF), INF)) - val - 1] + 1);\n\t\t} else cnt ++;\n\t}\n\tprintf(\"%d\\n\", dp[m - 1] + cnt);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Difficult Mountain.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "First, discard all such that Instead of climbers, we will consider pairs\r\n, and also say that the set of pairs is correct if there is a\r\npermutation such that for every , which means that there is an order in\r\nwhich all climbers can climb.We will call a pair of indices incompatible\r\nif and and . - this means that the -th climber cannot climb after the\r\n-th and vice versa. Note that if the set does not have an incompatible\r\npair of indices, then it is correct. The suitable order for pairs can be\r\nreached by sorting them in increasing order of pairs . After sorting\r\neither -th climber can go after -th or the pair is incompatible. Let\u00e2\u0080\u0099s\r\nsolve the problem with an additional restriction first, namely: for each\r\n, In this case, you can use the following greedy solution:Let , find\r\namong the pairs such that , and among such pairs - the pair with the\r\nsmallest - it will be the next in our order. Replace by , increase the\r\nanswer by 1 and repeat the algorithm. If the pair with does not exist,\r\nterminate the algorithm. The correctness of such an algorithm is proved\r\nby induction.To effectively implement this solution, let\u00e2\u0080\u0099s sort all the\r\npairs in increasing order of Let\u00e2\u0080\u0099s go through the indices from 1 to If ,\r\nthen add 1 to the answer and replace with . Let\u00e2\u0080\u0099s get back to the main\r\nproblem:Consider a pair of indices such that Such a pair of indices is\r\nincompatible, and if the optimal answer contains , then it can be\r\nreplaced with and the sequence will not break. for any value of that\r\nmatches it matches . for any Therefore, for any such pair , the -th can\r\nbe excluded from the set of climbers and the answer will not worsen. To\r\neffectively remove all such pairs, we use the two-pointer method:Let\u00e2\u0080\u0099s\r\ntake out all such pairs that into the array. Let the remaining pairs be\r\nin the array. Let\u00e2\u0080\u0099s sort the array in increasing order of and the array\r\nin increasing order of . Let\u00e2\u0080\u0099s create an ordered set , which can store\r\nthe pairs in decreasing order of . Let\u00e2\u0080\u0099s create a pointer .Let\u00e2\u0080\u0099s go\r\nthrough the elements of the array with index i. For this item: While we\r\nwill add to the set Now while we will delete the first element M.Among\r\nthe elements of the array, the set and the remaining elements in the\r\narray, there are no more required pairs.Note that among the remaining\r\npairs , any pair of indices such that or is not incompatible.Now, if we\r\nfind the maximum correct subset of the pairs , such that and combine it\r\nwith the set of pairs , such that , we get the correct set, moreover,\r\nfor obvious reasons it has maximum size. Therefore, we will get the\r\nanswer to the problem.\r\n"
}