{"link": "https://codeforces.com//contest/1045/problem/E", "problemId": "223467", "problem_idx": "E", "shortId": "1045E", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "E. Ancient civilizations", "statement": "On the surface of a newly discovered planet, which we model by a plane,\r\nexplorers found remains of two different civilizations in various\r\nlocations. They would like to learn more about those civilizations and\r\nto explore the area they need to build roads between some of locations.\r\nBut as always, there are some restrictions: Every two locations of the\r\nsame civilization are connected by a unique path of roads No two\r\nlocations from different civilizations may have road between them\r\n(explorers don\u2019t want to accidentally mix civilizations they are\r\ncurrently exploring) Roads must be Since intersections are expensive to\r\nbuild, they don\u2019t want any two roads to intersect (that is, only common\r\npoint for any two roads may be at some of locations) Obviously all\r\nlocations are different points in the plane, but explorers found out one\r\nmore interesting information that may help you no three locations lie on\r\nthe same line!Help explorers and find a solution for their problem, or\r\nreport it is impossible.\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nstruct point {\n\tll x, y;\n\tint c;\n\tint n;\n\tpoint() {\n\t\tx = y = c = 0;\n\t}\n\tpoint(ll x, ll y): x(x), y(y) {}\n\tpoint operator-(point a) {\n\t\treturn point(x - a.x, y - a.y);\n\t}\n\tll operator*(point a) {\n\t\treturn x * a.y - y * a.x;\n\t}\n};\n\nconst int MAXN = 1200;\n\nint n;\npoint p[MAXN];\n\nbool bad(point a, point b, point c) {\n\treturn (b - a) * (c - a) < 0;\n}\nint ds[MAXN];\n\nvector<pair<int, int>> ans;\n\nbool in(point a, point b, point c, point d) {\n\tll go = abs((a - d) * (b - d)) + abs((b - d) * (c - d)) + abs((c - d) * (a - d)) - abs((b - a) * (c - a));\n\treturn go == 0;\n}\n\nvoid run(point a, point b, point c) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (p[i].c == c.c && in(a, b, c, p[i]) && p[i].n != c.n) {\n\t\t\tans.emplace_back(p[i].n, c.n);\n\t\t\trun(a, b, p[i]);\n\t\t\trun(p[i], c, a);\n\t\t\trun(p[i], c, b);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in(a, b, c, p[i]) && p[i].n != a.n && p[i].n != b.n && p[i].c == a.c)\n\t\t\tans.emplace_back(p[i].n, a.n);\n\t}\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[i].x >> p[i].y >> p[i].c;\n\t\tp[i].n = i;\n\t}\n\tsort(p, p + n, [] (point a, point b) {\n\t\t\treturn make_pair(a.x, a.y) < make_pair(b.x, b.y);\n\t\t\t});\n\tsort(p + 1, p + n, [] (point a, point b) {\n\t\t\t\treturn (a - p[0]) * (b - p[0]) > 0;\n\t\t\t});\n\tvector<point> st;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (st.size() >= 2 && bad(st[st.size() - 2], st.back(), p[i]))\n\t\t\tst.pop_back();\n\t\tst.push_back(p[i]);\n\t}\n\tfor (int i = 0; i + 1 < st.size(); ++i)\n\t\tif (st[i].c != st[i + 1].c) {\n\t\t\trotate(st.begin(), st.begin() + i + 1, st.end());\n\t\t\tbreak;\n\t\t}\n\tint cnt = 0;\n\tfor (int i = 0; i + 1 < st.size(); ++i) {\n\t\tif (st[i].c != st[i + 1].c)\n\t\t\t++cnt;\n\t}\n\tif (cnt > 1) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < st.size(); ++i)\n\t\tds[st[i].n] = 1;\n\tfor (int i = 0; i + 1 < st.size(); ++i)\n\t\tif (st[i].c == st[i + 1].c) {\n\t\t\tans.emplace_back(st[i].n, st[i + 1].n);\n\t\t}\n\tif (cnt == 0) {\n\t\tint gp = -1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (p[i].c != st[0].c) {\n\t\t\t\tgp = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (gp == -1) {\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tif (!ds[p[i].n])\n\t\t\t\t\tans.emplace_back(st[0].n, p[i].n);\n\t\t}\n\t\telse {\n\t\t\tst.push_back(st[0]);\n\t\t\tfor (int i = 0; i + 1 < st.size(); ++i)\n\t\t\t\trun(st[i], st[i + 1], p[gp]);\n\t\t\tst.pop_back();\n\t\t}\n\t}\n\telse {\n\t\tint now = 0;\n\t\twhile (st[now].c == st[0].c)\n\t\t\t++now;\n\t\tfor (int i = now; i + 1 < st.size(); ++i)\n\t\t\trun(st[i], st[i + 1], st[0]);\n\t\tfor (int i = 0; i + 1 < now; ++i)\n\t\t\trun(st[i], st[i + 1], st[now]);\n\t}\n\tcout << ans.size() << \"\\n\";\n\tfor (auto p: ans)\n\t\tcout << p.first << \" \" << p.second << \"\\n\";\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "geometry"], "dificulty": "3200", "interactive": false}