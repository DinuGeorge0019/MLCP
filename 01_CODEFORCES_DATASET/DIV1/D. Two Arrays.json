{
    "link": "https://codeforces.com//contest/1641/problem/D",
    "problemId": "1306247",
    "problem_idx": "D",
    "shortId": "1641D",
    "contest_number": "1641",
    "problem_submissions": {
        "D": [
            147518709,
            147518438,
            147518414,
            147427811,
            147454243,
            147448667,
            147443879,
            147448778,
            147461315,
            147449736,
            147438286,
            147472049,
            147446117,
            147443730,
            147449435,
            147452074,
            147451905,
            147452006,
            147454020,
            147456098,
            147454778,
            147430439
        ],
        "F": [
            147463572,
            147488364,
            147487709,
            147487635,
            147487566,
            147487511,
            147487448,
            147487273,
            147474513,
            147473910,
            147473584,
            147541615
        ],
        "E": [
            147445838,
            147446189,
            147454919,
            147456452,
            147460049,
            147450489,
            147462542,
            147543257,
            147542937,
            147453651,
            147456356,
            147459732,
            147462090,
            147455497,
            147527427,
            147590875
        ],
        "B": [
            147438181,
            147420165,
            147422523,
            147421140,
            147420036,
            147420813,
            147426049,
            147460937,
            147441628,
            147446219,
            147424792,
            147434886,
            147431843,
            147422293,
            147424883,
            147440401
        ],
        "C": [
            147435041,
            147431185,
            147429914,
            147434109,
            147426743,
            147452293,
            147436064,
            147458110,
            147432571,
            147432541,
            147431796,
            147432454,
            147435151,
            147433502,
            147424256,
            147417819,
            147434463,
            147437219,
            147451475
        ],
        "A": [
            147414901,
            147414810,
            147414544,
            147414530,
            147414675,
            147414742,
            147414833,
            147461626,
            147414843,
            147414962,
            147414590,
            147414549,
            147415904,
            147414474,
            147414750,
            147414483,
            147415173,
            147414668,
            147414647
        ]
    },
    "name": "D. Two Arrays",
    "statement": "Sam changed his school and on the first biology lesson he got a very\r\ninteresting task about genes.You are given n arrays, the i-th of them\r\ncontains m different integers a_{i,1}, a_{i,2},\r\nldots,a_{i,m}. Also you are given an array of integers w of length\r\nn.Find the minimum value of w_i + w_j among all pairs of integers (i, j)\r\n(1\r\nle i, j\r\nle n), such that the numbers a_{i,1}, a_{i,2},\r\nldots,a_{i,m}, a_{j,1}, a_{j,2},\r\nldots,a_{j,m} are distinct.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.02.2022 13:19:10       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<vector<int>> a(n, vector<int>(m + 1));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> a[i][j + 1];\n    }\n    cin >> a[i][0];\n  }\n  sort(a.begin(), a.end());\n  vector<int> w(n);\n  for (int i = 0; i < n; i++) {\n    w[i] = a[i][0];\n    a[i].erase(a[i].begin());\n  }\n  map<int, int> mp;\n  int t = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      auto it = mp.find(a[i][j]);\n      if (it == mp.end()) {\n        mp[a[i][j]] = t;\n        a[i][j] = t++;\n      } else {\n        a[i][j] = it->second;\n      }\n    }\n  }\n  vector<unsigned long long> mask(t, -1);\n  const unsigned long long one = 1;\n  const int inf = (int) 2.01e9;\n  int ans = inf;\n  for (int L = 0; L < n; L += 64) {\n    int R = min(L + 64, n);\n    unsigned long long init = 0;\n    for (int i = L; i < R; i++) {\n      init |= (one << (i - L));\n      for (int j = 0; j < m; j++) {\n        mask[a[i][j]] ^= (one << (i - L));\n      }\n    }\n    for (int i = L; i < n; i++) {\n      unsigned long long cur = init;\n      for (int j = 0; j < m; j++) {\n        cur &= mask[a[i][j]];\n      }\n      if (cur > 0) {\n        int id = L + __builtin_ctzll(cur);\n        ans = min(ans, w[i] + w[id]);\n      }\n    }\n    for (int i = L; i < R; i++) {\n      for (int j = 0; j < m; j++) {\n        mask[a[i][j]] ^= (one << (i - L));\n      }\n    }\n  }\n  cout << (ans == inf ? -1 : ans) << '\\n';\n  debug(clock());\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "greedy",
        "hashing",
        "math",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Two Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "Let's maintain a set of arrays of length m\n, add new arrays there, delete arrays from this set and understand if the set has a suitable pair for some array. To do this, let's consider a pair of sorted arrays a\n and b\n of length m\n. Let's write out all subsets of the array a\n. Then we start a counter count\n, and for each subset of the array b\n we add one to count\n, if the subset occurs in a\n and contains an odd number of elements, and subtract one if the subset occurs in a\n and contains an even number of elements. Note that if a\n and b\n have at least one element in common, then count\n will be equal to 1\n, otherwise it will be equal to 0\n. Thus, we can maintain a trie that contains all the subsets of each array in the set. Now any request to this trie is trivially done for 2m\n.\n\nNow let's sort the arrays by w\n and use our structure to find the first array that has a suitable pair. We can simply find the pair and maintain 2 pointers, l\n is equal to the first array in the pair, r\n is equal to the second array in the pair. Note that now we are only interested in pairs l1,r1\n such that l<l1<r1<r\n. Therefore, we will move l\n to the left only. When we moved it once again, we will see if there is a pair for it among l<i<r\n. If so, then we will move r\n to the left until there is a pair for l\n among l<i?r\n. After that we can update the answer with wl+wr\n. The solution works in O(n?2m)\n."
}