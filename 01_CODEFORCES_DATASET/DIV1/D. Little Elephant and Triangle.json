{
    "link": "https://codeforces.com//contest/220/problem/D",
    "problemId": "1620",
    "problem_idx": "D",
    "shortId": "220D",
    "contest_number": "220",
    "problem_submissions": {
        "D": [
            2080540,
            2080418,
            2074895,
            2078075,
            2079217,
            2081403,
            2081824,
            2081006,
            2076381,
            2093601,
            2093590,
            3084971,
            2086233
        ],
        "E": [
            2078891,
            2078702,
            2081885,
            2081411,
            2081777,
            2080333,
            2079988,
            2077021,
            2081284,
            2080936,
            2080773,
            2080185,
            2080971,
            2082030,
            2080110,
            2081659,
            2081994,
            2086312,
            2082178
        ],
        "C": [
            2077244,
            2077402,
            2078300,
            2079325,
            2076073,
            2077207,
            2078341,
            2080109,
            2076476,
            2078366,
            2079100,
            2080050,
            2078605,
            2081663,
            2079424,
            2078933,
            2080721
        ],
        "B": [
            2074621,
            2083029,
            2082854,
            2073372,
            2075693,
            2075380,
            2073348,
            2074150,
            2075655,
            2074877,
            2074146,
            2076125,
            2083532,
            2074043,
            2074785,
            2086353,
            2077672,
            2098154,
            2098144,
            2076395,
            2075929,
            2074543
        ],
        "A": [
            2072304,
            2072260,
            2072332,
            2072289,
            2079727,
            2072355,
            2072380,
            2072450,
            2072425,
            2072416,
            2072763,
            2072261,
            2072442,
            2073395,
            2073046,
            2072395,
            2072278
        ]
    },
    "name": "D. Little Elephant and Triangle",
    "statement": "The Little Elephant is playing with the Cartesian coordinates’ system.\r\nMost of all he likes playing with integer points. The Little Elephant\r\ndefines an integer point as a pair of integers , such that and . Thus,\r\nthe Little Elephant knows only distinct integer points.The Little\r\nElephant wants to paint a triangle with vertexes at integer points, the\r\ntriangle’s area must be a positive integer. For that, he needs to find\r\nthe number of groups of three points that form such triangle. At that,\r\nthe order of points in a group matters, that is, the group of three\r\npoints , , isn’t equal to the group , , .Help the Little Elephant to\r\nfind the number of groups of three integer points that form a\r\nnondegenerate triangle with integer area.\r\n",
    "solutions": [
        "// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nconst int mod=1000000007;\nint cnt[2][2];\nint ch[3][2];\ninline bool ver(){\n    int r=(ch[0][0]+ch[1][0]+ch[2][0])*(ch[0][1]+ch[1][1]+ch[2][1]);\n    for(int i=0;i<3;i++)r+=ch[i][0]*ch[i][1];\n    return r%2==0;\n}\ninline int add(int a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n    return a;\n}\ninline int dfs(int np){\n    if(np==3){\n        if(ver())return 1;\n        return 0;\n    }\n    long long ret=0;\n    for(ch[np][0]=0;ch[np][0]<=1;ch[np][0]++){  \n        for(ch[np][1]=0;ch[np][1]<=1;ch[np][1]++){\n            int a=ch[np][0],b=ch[np][1];\n            if(cnt[a][b]==0)continue;\n            long long k=cnt[a][b];\n            cnt[a][b]--;\n            ret=(ret+dfs(np+1)*k)%mod;\n            cnt[a][b]++;\n        }\n    }\n    return ret;\n}\nint gcds[4010][4010];\nint cc[4010][4010];\ninline int gcd(int a,int b){if(b)while((a%=b)&&(b%=a));return a+b;}\ninline int solve(int w,int h){\n    cnt[0][0]=((w/2+1ll)*(h/2+1ll))%mod;\n    cnt[0][1]=((w/2+1ll)*((h+1ll)/2))%mod;\n    cnt[1][0]=(((w+1ll)/2)*(h/2+1ll))%mod;\n    cnt[1][1]=(((w+1ll)/2)*((h+1ll)/2))%mod;\n    int ans=dfs(0);\n    for(int i=1;i<=4000;i++){\n        gcds[i][0]=i;\n        for(int j=1;j<=4000;j++){\n            gcds[i][j]=gcds[i][j-1]+gcd(i,j);\n        }\n    }\n    for(int i=0;i<=4000;i++){\n        cc[i][0]=0;\n        for(int j=1;j<=4000;j++){\n            cc[i][j]=add(cc[i][j-1],gcds[j][i]-i-1);\n        }\n    }\n    int s=0;\n    for(int i=0;i<=w;i++){\n        for(int j=0;j<=h;j++){\n            s=add(s,cc[h-j][w-i]);\n            s=add(s,cc[w-i][j]);\n        }\n    }\n    s=(s*6ll)%mod;\n    ans-=s;\n    if(ans<0)ans+=mod;\n    return ans;\n}\nint main(){\n    int w,h;\n    scanf(\"%d%d\",&w,&h);\n    printf(\"%d\\n\",solve(w,h));\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Little Elephant and Triangle.json",
    "editorial_link": "https://codeforces.com//blog/entry/5177",
    "editorial": "Let iterate all possible points that, as we consider, must be the first\r\npoint. Let it be . Let the second and the third points be and . Then the\r\ndoubled area is . We need this number to be even and nonzero. For first\r\nwe will find the number of groups of points that are even, after that\r\njust subtract the number of groups with area equal to zero. For the\r\nfirst subproblem, we need to rewrite our formula. It is equal to . Since\r\nwe know and and we just need to check parity, we can try all possible\r\nvalues of parity of , , and (let it be , , and , respectively). And\r\ncheck whether they will form a after multiplications and taking modulo .\r\nIf it froms a , then add to the answer value , where is equal to the\r\nnumber of integers between and , inclusve, that modulo are equal . is\r\nthe same but in range . Now we need to subtract bad groups the ones that\r\nhas the area equal to zero. This means that they will either form a dot\r\nor a segment. If it is segment, we can just iterate and instead of all 4\r\ncoordinates. Then the number of such segments on the plane will be .\r\nAlso for counting the number of triples of points on the segment you\r\nneed to find the number of integer coordinates on the segment. It is\r\nwell-know problem, and the answer is . This gives us, with some simple\r\noptimizations, and solution.\r\n",
    "hint": []
}