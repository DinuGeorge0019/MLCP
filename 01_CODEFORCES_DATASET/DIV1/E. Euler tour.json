{
    "link": "https://codeforces.com//contest/1053/problem/E",
    "problemId": "223968",
    "problem_idx": "E",
    "shortId": "1053E",
    "contest_number": "1053",
    "problem_submissions": {
        "D": [
            43320967,
            43321366,
            43322493,
            43325653,
            43328216,
            43329157,
            43314103,
            43329594,
            43327708,
            43331398,
            43331864,
            43331980,
            43333170,
            43320772,
            43321907,
            43347759,
            43334692,
            43316971,
            43343476,
            43341620,
            43339949,
            43337790
        ],
        "C": [
            43307138,
            43309894,
            43312505,
            43313721,
            43312808,
            43316109,
            43324397,
            43311885,
            43312845,
            43316905,
            43321077,
            43314278,
            43317163,
            43317332,
            43329507,
            43330889,
            43311412,
            43324598,
            43338761,
            46354235,
            44718358,
            43709718,
            43709703,
            43709682,
            43515057,
            43515052,
            43483892,
            43465752,
            43464250,
            43421524,
            43400433,
            43400425,
            43385421,
            43385407,
            43354392,
            43354373,
            43354256,
            43354129,
            43354084,
            43353946,
            43353875,
            43353862,
            43338127,
            43337856,
            43317491
        ],
        "B": [
            43302550,
            43398321,
            43398298,
            43302971,
            43303874,
            43305537,
            43304419,
            43304489,
            43303672,
            43303860,
            43307726,
            43304869,
            43306808,
            43305251,
            43304148,
            43307156,
            43307659,
            43324162,
            43300449,
            43315267,
            43326866,
            43338204,
            43337888,
            43307003
        ],
        "A": [
            43297754,
            43298564,
            43298952,
            43299495,
            43299534,
            43304596,
            43317168,
            43299723,
            43304344,
            43300713,
            43301168,
            43300378,
            43300680,
            43298079,
            43302518,
            43299165,
            43304630,
            43311156,
            43322106,
            43301598
        ],
        "E": [
            43366979,
            43333450,
            44387266,
            43369111
        ]
    },
    "name": "E. Euler tour",
    "statement": "Euler is a little, cute squirrel. When the autumn comes, he collects\r\nsome reserves for winter. The interesting fact is that Euler likes to\r\ncollect acorns in a specific way. A tree can be described as n acorns\r\nconnected by n - 1 branches, such that there is exactly one way between\r\neach pair of acorns. Let’s enumerate the acorns from 1 to n.The squirrel\r\nchooses one acorn (not necessary with number 1) as a start, and visits\r\nthem in a way called \"Euler tour\" (see notes), collecting each acorn\r\nwhen he visits it for the last time.Today morning Kate was observing\r\nEuler. She took a sheet of paper and wrote down consecutive indices of\r\nacorns on his path. Unfortunately, during her way to home it started\r\nraining and some of numbers became illegible. Now the girl is very sad,\r\nbecause she has to present the observations to her teacher.\"Maybe if I\r\nguess the lacking numbers, I’ll be able to do it!\" she thought. Help her\r\nand restore any valid Euler tour of some tree or tell that she must have\r\nmade a mistake.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  scanf(\"%d\", &n);\n  int m = (n << 1) - 1;\n  vector<int> a(m);\n  int first = -1;\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n    if (!~first && ~a[i]) {\n      first = i;\n    }\n  }\n  if (!~first) {\n    puts(\"yes\");\n    printf(\"1\");\n    for (int i = 1; i < n; ++i) {\n      printf(\" %d 1\", i + 1);\n    }\n    putchar(10);\n    return 0;\n  }\n  if (first) {\n    vector<int> temp;\n    for (int i = first; i < m; ++i) {\n      temp.push_back(a[i]);\n    }\n    for (int i = 0; i < first; ++i) {\n      temp.push_back(a[i]);\n    }\n    a = temp;\n  }\n\n  if (~a.back() && a.back() != a[0]) {\n    puts(\"no\");\n    return 0;\n  }\n  a.back() = a[0];\n  vector<int> free, parity(n, -1);\n  for (int i = 0; i < m; ++i) {\n    if (~a[i]) {\n      if (~parity[a[i]]) {\n        if (parity[a[i]] != (i & 1)) {\n          puts(\"no\");\n          return 0;\n        }\n      } else {\n        parity[a[i]] = i & 1;\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (!~parity[i]) {\n      free.push_back(i);\n    }\n  }\n\n  vector<int> prev(m), next(m);\n  for (int i = 0; i < m; ++i) {\n    prev[i] = i - 1;\n    next[i] = i + 1;\n  }\n\n  auto erase = [&](int x) {\n    if (next[x] != m) {\n      prev[next[x]] = prev[x];\n    }\n    if (~prev[x]) {\n      next[prev[x]] = next[x];\n    }\n  };\n\n  auto solve = [&](int l, int r) {\n    for (int i = next[l]; i < r; ) {\n      if (~a[i] && ~a[next[i]] && !~a[prev[i]]) {\n        a[prev[i]] = a[next[i]];\n        erase(i);\n        erase(next[i]);\n        i = prev[i];\n        if (i > l) {\n          i = prev[i];\n        }\n        if (i == l) {\n          i = next[i];\n        }\n      } else if (~a[i] && ~a[prev[i]] && !~a[next[i]]) {\n        a[next[i]] = a[prev[i]];\n        erase(i);\n        erase(next[i]);\n        i = prev[i];\n        if (i == l) {\n          i = next[i];\n        }\n      } else {\n        i = next[i];\n      }\n    }\n    for (int i = next[l]; i < r; i = next[i]) {\n      erase(i);\n    }\n    erase(r);\n  };\n\n  vector<bool> not_first(n), ban(n);\n  for (int i = 0; i < m; ++i) {\n    if (~a[i]) {\n      if (not_first[a[i]]) {\n        if (ban[a[i]]) {\n          puts(\"no\");\n          return 0;\n        }\n        int left = prev[i], right = i, numbers = 1, total = 1;\n        while (a[left] != a[right]) {\n          if (~a[left]) {\n            ban[a[left]] = true;\n            ++numbers;\n          }\n          ++total;\n          left = prev[left];\n        }\n        int need = (total >> 1) + 1 - numbers;\n        if (need < 0) {\n          puts(\"no\");\n          return 0;\n        }\n        for (int j = left; j < right; j = next[j]) {\n          if (!~a[j] && need) {\n            if (free.empty()) {\n              puts(\"no\");\n              return 0;\n            } else {\n              a[j] = free.back();\n              --need;\n              free.pop_back();\n            }\n          }\n        }\n        solve(left, right);\n      } else {\n        not_first[a[i]] = true;\n      }\n    }\n  }\n\n  puts(\"yes\");\n  if (first) {\n    vector<int> temp;\n    for (int i = m - 1 - first; i < m - 1; ++i) {\n      temp.push_back(a[i]);\n    }\n    for (int i = 0; i < m - 1 - first; ++i) {\n      temp.push_back(a[i]);\n    }\n    temp.push_back(a[m - 1 - first]);\n    a = temp;\n  }\n  for (int i = 0; i < m; ++i) {\n    printf(\"%d%c\", a[i] + 1, i == m - 1 ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Euler tour.json",
    "editorial_link": "https://codeforces.com//blog/entry/62013",
    "editorial": "First letâs try to find some conditions whether it is possible to\r\nrecover correct euler tour. Of course for every euler tour and (because\r\nwe start and finish in root). Moreover if there exist four index such\r\nthat and and than answer is (because vertex is an ancestor of another o\r\nthere is no relation between them). There is one more tricky condition -\r\nparity of positions of all occurences of element is the same. Also,\r\nbetween two equal elements with distance there can be at most distinct\r\nelements.It turns out that those conditions are sufficient - we will\r\nprove it by constructing an answer.So first letâs observe that if we\r\nhave to equal elements it means that there is subtree between them - we\r\ncan solve it independently from the rest of a tree and then forget about\r\nthis subtree. So as long as we have two equal elements than we can first\r\nsolve euler tour between them and then delete elements . So now we want\r\nto solve euler tour where no element occur more than once. Letâs say\r\nthat this tour has length then if we have less than elements we can\r\nreplace any with any unused elements.Now if there are three elements in\r\na row with values or than we can replace them with and forget about it.\r\nIf we get rid of all triplets like this than we have tour in form of .\r\nItâs easy to observe that we can replace every with our root (subtreeâs\r\nroot). There is a special case when we donât have any root (if solving\r\nfor whole tree), than we have to find any vertex which can be root and\r\nthen solve our problem. Straightforward implementation will be but it\r\ncan be easily reduced to and it can be even reduced to , but was enough\r\nto be accepted.More details about reducing to in code.\r\n",
    "hint": []
}