{
    "link": "https://codeforces.com//contest/634/problem/C",
    "problemId": "49946",
    "problem_idx": "C",
    "shortId": "634C",
    "contest_number": "634",
    "problem_submissions": {
        "E": [
            16414340,
            16416138,
            16413706,
            16414973,
            16415599,
            16414780,
            16415591,
            16416199,
            16416181,
            16416348,
            16415632,
            16415457,
            16416072,
            16413745,
            16466856,
            16413386
        ],
        "D": [
            16411007,
            16410815,
            16412075,
            16411999,
            16412771,
            16413214,
            16412917,
            16413088,
            16413557,
            16414243,
            16411968,
            16413070,
            16413608,
            16410814,
            16411583,
            16411708,
            16418042,
            16411828
        ],
        "C": [
            16409750,
            16409051,
            16410811,
            16409734,
            16410839,
            16411665,
            16411917,
            16411834,
            16411108,
            16413312,
            16410161,
            16411194,
            16417790,
            16416407,
            16409322,
            16410089,
            16410459,
            16409945,
            16409746,
            16410147
        ],
        "B": [
            16408395,
            16409662,
            16410216,
            16408841,
            16409386,
            16409860,
            16410585,
            16409660,
            16410064,
            16408757,
            16417413,
            16417828,
            16409703,
            16408566,
            16409147,
            16409169,
            16409287,
            16410817,
            16408754
        ],
        "A": [
            16407814,
            16407800,
            16408726,
            16407801,
            16408251,
            16407972,
            16407935,
            16408112,
            16408492,
            16407803,
            16407794,
            16408196,
            16407918,
            16407735,
            16407903,
            16407915,
            16407851,
            16408302,
            16407766
        ],
        "F": [
            16417401,
            17066904
        ]
    },
    "name": "C. Factory Repairs",
    "statement": "A factory produces thimbles in bulk. Typically, it can produce up to\r\nthimbles a day. However, some of the machinery is defective, so it can\r\ncurrently only produce thimbles each day. The factory intends to choose\r\na -day period to do maintenance and construction; it cannot produce any\r\nthimbles during this time, but will be restored to its full production\r\nof thimbles per day after the days are complete.Initially, no orders are\r\npending. The factory receives updates of the form , , indicating that\r\nnew orders have been placed for the -th day. Each order requires a\r\nsingle thimble to be produced on precisely the specified day. The\r\nfactory may opt to fill as many or as few of the orders in a single\r\nbatch as it likes.As orders come in, the factory owner would like to\r\nknow the maximum number of orders he will be able to fill if he starts\r\nrepairs on a given day . Help the owner answer his questions.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(\"%lf\", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c=='-') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>='0') && (c<='9'))\n\t\t\tx=x*10+c-'0',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nconst int MX = 5e5;\nconst int OFFS = 5;\n\nint n, k, q;\nll a, b;\n\nll ordered[MX];\nll bitA[MX], bitB[MX];\n\nvoid upd(ll* bit, int p, ll v)\n{\n\tp += OFFS;\n\tfor (int i = p; i < MX; i += i & -i)\n\t\tbit[i] += v;\n}\nll read(ll* bit, int p)\n{\n\tp += OFFS;\n\tll ans = 0;\n\tfor (int i = p; i; i -= i & -i)\n\t\tans += bit[i];\n\treturn ans;\n}\nll readRange(ll* bit, int p1, int p2)\n{\n\treturn read(bit, p2) - read(bit, p1-1);\n}\n\nint main()\n{\n\trint(n);\n\trint(k);\n\trint(a);\n\trint(b);\n\trint(q);\n\tswap(a, b);\n\twhile (q--)\n\t{\n\t\tint t;\n\t\trint(t);\n\t\tif (t == 1)\n\t\t{\n\t\t\tint di;\n\t\t\tll ai;\n\t\t\trint(di);\n\t\t\trint(ai);\n\t\t\tll deltaA = min(ordered[di] + ai, a) - min(ordered[di], a);\n\t\t\tll deltaB = min(ordered[di] + ai, b) - min(ordered[di], b);\n\t\t\tordered[di] += ai;\n\t\t\tupd(bitA, di, deltaA);\n\t\t\tupd(bitB, di, deltaB);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(t == 2);\n\t\t\tint pi;\n\t\t\trint(pi);\n\t\t\tll before = readRange(bitA, 1, pi-1);\n\t\t\tll after = readRange(bitB, pi + k, n);\n\t\t\tprintf(\"%lld\\n\", before + after);\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Factory Repairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/43467",
    "editorial": "Using two binary-indexed trees, we can maintain the prefix and suffix sums of the amounts we can produce with maximum production rates of B and A, respectively. Then we can just query the binary-indexed trees to find the maximum possible production given the start and end of the repairs.",
    "hint": []
}