{
    "link": "https://codeforces.com//contest/1010/problem/F",
    "problemId": "201807",
    "problem_idx": "F",
    "shortId": "1010F",
    "contest_number": "1010",
    "problem_submissions": {
        "B": [
            40799404,
            40801993,
            40788669,
            40787652,
            40789673,
            40789686,
            40789983,
            40785033,
            40792839,
            40805864,
            40788811,
            40787383,
            40789849,
            40789369,
            40787726,
            40805158,
            40792120,
            40788528
        ],
        "E": [
            40798849,
            40800058,
            40798099,
            40803219,
            40808162,
            40803215,
            40805435,
            40803779,
            40802990,
            40802895,
            40802904,
            40807344,
            40809272,
            40807596,
            40809118,
            40796705,
            40826253,
            40825565,
            40825440,
            40825326,
            40820969,
            40809148,
            40810854
        ],
        "D": [
            40790648,
            40792110,
            40793613,
            40792349,
            40794914,
            40795576,
            40794812,
            40796573,
            40795996,
            40791327,
            40795441,
            40794120,
            40793973,
            40796503,
            40791721,
            40802197,
            40794990,
            40796187
        ],
        "C": [
            40786265,
            40787662,
            40789931,
            40785223,
            40786749,
            40786331,
            40785962,
            40786363,
            40790435,
            40784715,
            40788036,
            40789805,
            40785906,
            40791178,
            40784561,
            40799332,
            40788152,
            40791287
        ],
        "A": [
            40783437,
            40783575,
            40783713,
            40784110,
            40784394,
            40784590,
            40783557,
            40784035,
            40783594,
            40783743,
            40791154,
            40783813,
            40784202,
            40785469,
            40783661,
            40798279,
            40784877,
            40785930
        ],
        "F": [
            40820195,
            40821625,
            40821278,
            40814070,
            40812966,
            47670616
        ]
    },
    "name": "F. Tree",
    "statement": "The Main Martian Tree grows on Mars. It is a binary tree (a rooted tree,\r\nwith no more than two sons at each vertex) with n vertices, where the\r\nroot vertex has the number 1. Its fruits are the Main Martian Fruits.\r\nIt’s summer now, so this tree does not have any fruit yet.Autumn is\r\ncoming soon, and leaves and branches will begin to fall off the tree. It\r\nis clear, that if a vertex falls off the tree, then its entire subtree\r\nwill fall off too. In addition, the root will remain on the tree.\r\nFormally: the tree will have some connected subset of vertices\r\ncontaining the root.After that, the fruits will grow on the tree (only\r\nat those vertices which remain). Exactly x fruits will grow in the root.\r\nThe number of fruits in each remaining vertex will be not less than the\r\nsum of the numbers of fruits in the remaining sons of this vertex. It is\r\nallowed, that some vertices will not have any fruits.Natasha wondered\r\nhow many tree configurations can be after the described changes. Since\r\nthis number can be very large, output it modulo 998244353.Two\r\nconfigurations of the resulting tree are considered different if one of\r\nthese two conditions is true: they have different subsets of remaining\r\nvertices; they have the same subset of remaining vertices, but there is\r\na vertex in this subset where they have a different amount of fruits.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = (119 << 23) + 1; // = 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nll po(ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nint mul(int a, int b) { return (ll)a*b%MOD; }\nint ad(int a, int b) { return (a+b)%MOD; }\nint sub(int a, int b) { return (a-b+MOD)%MOD; }\nint get(int s) { return s > 1 ? 32 - __builtin_clz(s - 1) : 0; }\n\nvi operator+(const vi& l, const vi& r) {\n    vi res(max(sz(l),sz(r)));\n    F0R(i,sz(l)) res[i] = l[i];\n    F0R(i,sz(r)) res[i] = ad(res[i],r[i]);\n    return res;\n}\n\nvi operator-(const vi& l, const vi& r) {\n    vi res(max(sz(l),sz(r)));\n    F0R(i,sz(l)) res[i] = l[i];\n    F0R(i,sz(r)) res[i] = sub(res[i],r[i]);\n    return res;\n}\n\nnamespace NTT {\n    const int root = 3; \n    // For p < 2^30 there is also e.g. (5 << 25, 3), (7 << 26, 3),\n    // (479 << 21, 3) and (483 << 21, 5). The last two are > 10^9.\n        \n    \n    vi ntt(vi& a) { \n        int n = a.size(), x = get(n); \n        vi res, RES(n), roots(n);\n        roots[0] = 1, roots[1] = po(root,(MOD-1)/n);\n        FOR(i,2,n) roots[i] = mul(roots[i-1],roots[1]);\n        \n        res = a;\n        FOR(i,1,x+1) {\n            int inc = n>>i;\n            F0R(j,inc) for (int k = 0; k < n; k += inc) {\n                int t = 2*k%n+j;\n                RES[k+j] = ad(res[t],mul(roots[k],res[t+inc]));\n            }\n            swap(res,RES);\n        }\n        \n        return res;\n    }\n    \n    vi ntt_rev(vi& a) {\n        vi res = ntt(a);\n        ll in = inv(sz(a));\n        F0R(i,sz(res)) res[i] = mul(res[i],in);\n        reverse(res.begin() + 1, res.end());\n        return res;\n    }\n    \n    vi brute(vi& a, vi& b) {\n        vi c(sz(a)+sz(b)-1);\n        F0R(i,sz(a)) F0R(j,sz(b)) c[i+j] = ad(c[i+j],mul(a[i],b[j]));\n        return c;\n    }\n    \n    vi conv(vi a, vi b) {\n        int s = sz(a)+sz(b)-1, L = get(s), n = 1<<L;\n        if (s <= 0) return {};\n        if (s <= 200) return brute(a,b);\n        \n        a.resize(n); a = ntt(a);\n        b.resize(n); b = ntt(b);\n        \n        F0R(i,n) a[i] = mul(a[i],b[i]);\n        a = ntt_rev(a);\n        \n        a.resize(s);\n        return a;\n    }\n    \n    pair<vi,vi> eval(vector<vi> a) { // a_1a_2a_3a_4+a_2a_3a_4+a_3a_4+a_4+1,a_1a_2a_3a_4\n        if (sz(a) == 1) {\n            auto A = a[0]; A[0] ++;\n            return {A,a[0]};\n        }\n        auto P = eval(vector<vi>(a.begin(),a.begin()+sz(a)/2));\n        auto Q = eval(vector<vi>(a.begin()+sz(a)/2,a.end()));\n        P.f[0] = sub(P.f[0],1);\n        return {NTT::conv(P.f,Q.s)+Q.f,NTT::conv(P.s,Q.s)};\n    }\n}\n\nint n, sz[MX];\nll x;\nvi adj[MX];\nvector<vi> dat[MX];\n\nvoid dfs(int a, int b) {\n    sz[a] ++;\n    \n    vi child;\n    for (int i: adj[a]) if (i != b) {\n        dfs(i,a);\n        sz[a] += sz[i];\n        child.pb(i);\n    }\n    \n    switch(sz(child)) {\n        case 0:\n            dat[a].pb({0,1});\n            break;\n        case 1:\n            swap(dat[a],dat[child[0]]);\n            dat[a].pb({0,1});\n            break;\n        default:\n            if (sz[child[0]] < sz[child[1]]) swap(child[0],child[1]);\n            swap(dat[child[0]],dat[a]);\n            auto x = NTT::eval(dat[child[1]]).f; x.insert(x.begin(),0);\n            dat[a].pb(x);\n            break;\n    }   \n    \n    /*cout << \"HI \" << a << \" \" << sz(child) << \"\\n\";\n    for (auto x: dat[a]) {\n        for (int y: x) cout << y << \" \";\n        cout << \"\\n\";\n    }\n    cout << \"----\\n\";*/\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x; x %= MOD;\n    F0R(i,n-1) {\n        int a,b; cin >> a >> b;\n        adj[a].pb(b), adj[b].pb(a);\n    }\n    dfs(1,0);\n    vi v = NTT::eval(dat[1]).f;\n    \n    int ans = 0, ccomb = 1;\n    FOR(i,1,n+1) {\n        ans = ad(ans,mul(v[i],ccomb));\n        ccomb = mul(ccomb,ad(x,i));\n        ccomb = mul(ccomb,inv(i));\n    }\n    cout << ans;\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "fft",
        "graphs",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/60851",
    "editorial": "Let , (for each , such that is a son of and tree have both vertices and\r\n), then all that we need is and , so for fixed subset of vertices number\r\nof ways to arrange weights is just number of ways to partite into such\r\nnumber of parts.So let be number of ways to choose connected subtree of\r\nvertices, that contains vertex , then answer is .Then we need to\r\ncalculate for each , and calculate for each .Letâs use generating\r\nfunctions to calc .Let be generating function of , (if we will assume\r\nthat root and we will look only at vertices inside subtree of ).Then if\r\nvertex leaf, then , if this vertex have one son, , and if two, then\r\n.Then let maintain as a sequence of polynomials , ).Then if we have the\r\nrepresentation of in such format, we can find the exact value of\r\npolynomial in the sum of sizes of polynomials .For it you can note, that\r\nis just .And then with FFT you can calculate value and multiplication\r\nfor left half ( ), and for right half ( ).Then , .So, you can calculate\r\nexact value of in (Where is sum of sizes of polynomials).Then if leaf\r\njust add into the sequence of polynomials.If have one son, then add into\r\nthe sequence of polynomials of a son, and take his sequence as a\r\nsequence for vertex .And if have two sons, Letâs take a son with the\r\nsmaller size of a subtree, find its exact value as written, and add it\r\ninto the sequence of another son.Sum of sizes of smaller subtrees is ,\r\nso we can find in .Note, that you can find similar value when the tree\r\nis not binary too, for it you can find the exact value of all children\r\nwithout largest, and multiply it in with D&C.To calculate for each you\r\ncan note, that when it is just , and to get a value for you need\r\nmultiply current value on and divide on .Then you can find scalar\r\nmultiplication of these two vectors, and solve the task in ).\r\n",
    "hint": []
}