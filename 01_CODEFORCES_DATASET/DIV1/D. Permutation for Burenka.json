{
    "link": "https://codeforces.com//contest/1718/problem/D",
    "problemId": "1509967",
    "problem_idx": "D",
    "shortId": "1718D",
    "contest_number": "1718",
    "problem_submissions": {
        "F": [
            168597010,
            168624668,
            173812548,
            173812098,
            168599096
        ],
        "D": [
            168565469,
            168586026,
            168571061,
            168581216,
            168578771,
            168572736,
            168587794,
            168591318,
            168592506,
            168597359,
            168590948,
            168600506,
            168597231,
            168582453,
            168687986
        ],
        "C": [
            168541281,
            168543939,
            168544627,
            168545043,
            168549826,
            168553177,
            168540235,
            168546151,
            168543268,
            168562740,
            168541559,
            168562194,
            168567397,
            168609760,
            168609209,
            168608717,
            168567701,
            168606687,
            168620286,
            168547337,
            168546667,
            168553348,
            168556898,
            168552397
        ],
        "B": [
            168533942,
            168529866,
            168534830,
            168535200,
            168537223,
            168547085,
            168528202,
            168537852,
            168530917,
            168805783,
            168550097,
            168530349,
            168548672,
            168547336,
            168549427,
            168545357,
            168535673,
            168532763,
            168537259,
            168542957,
            168536570
        ],
        "A2": [
            168516853,
            168520403,
            168525192,
            168517279,
            168521825,
            168526171,
            168517695,
            168521659,
            168518863,
            168529215,
            168520755,
            168523804,
            168536216,
            168521669,
            168523926,
            168522044,
            168518219,
            168525244,
            168524582,
            168517935
        ],
        "A1": [
            168516745,
            168520669,
            168524305,
            168517111,
            168521468,
            168525366,
            168517892,
            168521859,
            168518553,
            168529389,
            168520943,
            168523566,
            168536034,
            168521371,
            168523798,
            168521699,
            168516764,
            168524985,
            168524317,
            168517770
        ],
        "E": [
            168650929,
            168598643,
            168610266,
            173790812
        ]
    },
    "name": "D. Permutation for Burenka",
    "statement": "We call an array a if all elements in it are pairwise distinct. For\r\nexample, an array [1, 7, 9] is pure, [1, 3, 3, 7] isn’t, because 3\r\noccurs twice in it.A pure array b is to a pure array c if their lengths\r\nn are the same and for all pairs of indices l, r, such that 1\r\nle l\r\nle r\r\nle n, it’s true that\r\noperatorname{argmax}([b_l, b_{l + 1},\r\nldots, b_r]) =\r\noperatorname{argmax}([c_l, c_{l + 1},\r\nldots, c_r]), where\r\noperatorname{argmax}(x) is defined as the index of the largest element\r\nin x (which is unique for pure arrays). For example,\r\noperatorname{argmax}([3, 4, 2]) = 2,\r\noperatorname{argmax}([1337, 179, 57]) = 1.Recently, Tonya found out that\r\nBurenka really likes a permutation p of length n. Tonya decided to\r\nplease her and give her an array a to p. He already fixed some elements\r\nof a, but exactly k elements are missing (in these positions temporarily\r\na_i = 0). It is guaranteed that k\r\nge 2. Also, he has a set S of k - 1 numbers.Tonya realized that he was\r\nmissing one number to fill the empty places of a, so he decided to buy\r\nit. He has q options to buy. Tonya thinks that the number d suits him,\r\nif it is possible to replace all zeros in a with numbers from S and the\r\nnumber d, so that a becomes a array to p. For each option of d, output\r\nwhether this number is suitable for him or not.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.08.2022 18:22:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    int add = 0;\n    int mn = 0;\n    int pos = -1;\n\n    void apply(int l, int r, int v) {\n      if (l == r) {\n        pos = l;\n      }\n      add += v;\n      mn += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mn = min(a.mn, b.mn);\n    res.pos = (a.mn == res.mn ? a.pos : b.pos);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, q;\n    cin >> n >> q;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n      --p[i];\n    }\n    vector<int> a(n);\n    vector<int> nums;\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      --a[i];\n      if (a[i] != -1) {\n        nums.push_back(a[i]);\n      } else {\n        k += 1;\n      }\n    }\n    assert(k >= 2);\n    vector<int> s(k - 1);\n    for (int i = 0; i < k - 1; i++) {\n      cin >> s[i];\n      --s[i];\n      nums.push_back(s[i]);\n    }\n    vector<int> d(q);\n    for (int i = 0; i < q; i++) {\n      cin >> d[i];\n      --d[i];\n      nums.push_back(d[i]);\n    }\n    sort(nums.begin(), nums.end());\n    nums.resize(unique(nums.begin(), nums.end()) - nums.begin());\n    int sz = (int) nums.size();  \n    for (int i = 0; i < n; i++) {\n      if (a[i] != -1) {\n        a[i] = (int) (lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin());\n      }\n    }\n    for (int i = 0; i < k - 1; i++) {\n      s[i] = (int) (lower_bound(nums.begin(), nums.end(), s[i]) - nums.begin());\n    }\n    for (int i = 0; i < q; i++) {\n      d[i] = (int) (lower_bound(nums.begin(), nums.end(), d[i]) - nums.begin());\n    }\n    vector<int> ind(n);\n    iota(ind.begin(), ind.end(), 0);\n    SparseTable<int> ts(ind, [&](int i, int j) { return (p[i] > p[j] ? i : j); });\n    vector<int> pv(n);\n    vector<int> order;\n    function<void(int, int, int)> Dfs = [&](int l, int r, int pr) {\n      if (l > r) {\n        return;\n      }\n      int i = ts.get(l, r);\n      order.push_back(i);\n      pv[i] = pr;\n      Dfs(l, i - 1, i);\n      Dfs(i + 1, r, i);\n    };\n    Dfs(0, n - 1, -1);\n    vector<int> L(n), R(n);\n    for (int i = 0; i < n; i++) {\n      if (a[i] == -1) {\n        L[i] = 0;\n        R[i] = sz - 1;\n      } else {\n        L[i] = a[i];\n        R[i] = a[i];\n      }\n    }\n    for (int it = 1; it < n; it++) {\n      int i = order[it];\n      R[i] = min(R[i], R[pv[i]] - 1);\n    }\n    for (int it = n - 1; it >= 1; it--) {\n      int i = order[it];\n      L[pv[i]] = max(L[pv[i]], L[i] + 1);\n    }\n    bool fail = false;\n    for (int i = 0; i < n; i++) {\n      if (L[i] > R[i]) {\n        fail = true;\n        break;\n      }\n    }\n    if (fail) {\n      for (int i = 0; i < q; i++) {\n        cout << \"NO\" << '\\n';\n      }\n      continue;\n    }\n    vector<int> have(sz);\n    for (int i = 0; i < n; i++) {\n      if (a[i] != -1) {\n        have[a[i]] += 1;\n      }\n    }\n    for (int i = 0; i < k - 1; i++) {\n      have[s[i]] += 1;\n    }\n    vector<vector<int>> at(sz);\n    for (int i = 0; i < n; i++) {\n      at[L[i]].push_back(i);\n    }\n    int low = 0;\n    int high = sz - 1;\n    vector<int> zeros(sz);\n    segtree st(zeros);\n    for (int i = sz - 1; i >= 0; i--) {\n      for (int j : at[i]) {\n        st.modify(R[j], sz - 1, -1);\n      }\n      if (have[i] != 0) {\n        st.modify(i, sz - 1, have[i]);\n      }\n      auto nd = st.get(i, sz - 1);\n      if (nd.mn < -1) {\n        low = 1;\n        high = 0;\n        break;\n      }\n      if (nd.mn == -1) {\n        int j = nd.pos;\n        low = max(low, i);\n        high = min(high, j);\n      }\n    }\n    for (int i = 0; i < q; i++) {\n      cout << ((low <= d[i] && d[i] <= high) ? \"YES\" : \"NO\") << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graph matchings",
        "greedy",
        "math",
        "trees"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Permutation for Burenka.json",
    "editorial_link": "https://codeforces.com//blog/entry/106049",
    "editorial": "Tutorial Letâs build a tree recursively starting from the segment , at\neach step we will choose the root of the subtree , then recursively\nconstruct trees for subtrees if they are not empty, then create edges\nfrom the root to the roots of these subtrees. What we got is called a\nCartesian tree by array. This Cartesian tree will be mentioned further\nin the analysis.It is easy to see that Cartesian trees by arrays\ncoincide if and only if these arrays are similar. Then the necessary and\nsufficient condition for the array to be similar to is that for any pair\nsuch that is in the subtree , is satisfied, in other words is the\nmaximum among the numbers in the subtree of the vertex .Letâs call the\nposition initially empty if initially .Letâs call an array almost\nsimilar to if for any pair such that is in the subtree , is executed, or\nboth positions , are initially empty.Letâs prove that if there is a way\nto fill in the gaps in to get an array almost similar to , then there is\nalso a way to fill in the gaps to get a similar to array .Indeed, letâs\nlook at the array almost similar to . letâs walk through the tree\nrecursively starting from the root. At the step with the vertex , we\nfirst start recursively from all the children of , now it is true for\nthem that the maxima of their subtrees are in them, letâs look at the\nmaximum child , let it be , then if , then everything is fine, otherwise\nnote that is initially an empty position, because for all initially\nnon-empty positions it is true that they are maximums in their subtrees\n(this is easy to see in the definition), but is not. Note that is\ninitially an empty position. Otherwise, we have never changed and ,\ntherefore, in the original array almost similar to , contradiction was\nexecuted, it is contradiction. so are initially empty, we can perform\nand everything will be executed.After executing this algorithm, we\nchanged only the initially empty elements and got similar to . Q.E.D.How\nto check the existence of an array almost similar to ? Letâs call the\nnumber the minimum among all the numbers such that is in the subtree of\n. Letâs call the number the maximum among all the numbers such that is\nin the subtree of . it is easy to see that is almost similar to if and\nonly if for all , is satisfied.That sounds incredibly good. So, all we\nneed is to find a matching of the set and number and segments for that\nare initially empty. Now it is easy to prove that the suitable is a\ncontinuous segment (letâs say the answer is yes for , we donât know the\nanswer for , try looking at the alternating path from to in good\nmatching for , itâs easy to see that if there is such a path, then for\nthe answer is yes, otherwise, no. If you look at the structure of the\nmatching of points with segments, you can see that an alternating path\nexists for a continuous segment of values ). the boundaries can be found\nby binary search or by typing greedily twice.Final complexity is or\n",
    "hint": [
        "Hint 1 Try to reduce the task to a single array and tree.",
        "Hint 2 Try to reduce the tree to a match of bipartite graph. The first part: For each , a segment of suitable values. The second part: The set and the number .",
        "Hint 3 There exist and such that the answer to the query is ''YES'' if and only if ."
    ]
}