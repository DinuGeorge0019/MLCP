{"link": "https://codeforces.com//contest/1718/problem/D", "problemId": "1509967", "problem_idx": "D", "shortId": "1718D", "contest_number": "1718", "problem_submissions": {"F": [168597010, 168624668, 173812548, 173812098, 168599096], "D": [168565469, 168586026, 168571061, 168581216, 168578771, 168572736, 168587794, 168591318, 168592506, 168597359, 168590948, 168600506, 168597231, 168582453, 168687986], "C": [168541281, 168543939, 168544627, 168545043, 168549826, 168553177, 168540235, 168546151, 168543268, 168562740, 168541559, 168562194, 168567397, 168609760, 168609209, 168608717, 168567701, 168606687, 168620286, 168547337, 168546667, 168553348, 168556898, 168552397], "B": [168533942, 168529866, 168534830, 168535200, 168537223, 168547085, 168528202, 168537852, 168530917, 168805783, 168550097, 168530349, 168548672, 168547336, 168549427, 168545357, 168535673, 168532763, 168537259, 168542957, 168536570], "A2": [168516853, 168520403, 168525192, 168517279, 168521825, 168526171, 168517695, 168521659, 168518863, 168529215, 168520755, 168523804, 168536216, 168521669, 168523926, 168522044, 168518219, 168525244, 168524582, 168517935], "A1": [168516745, 168520669, 168524305, 168517111, 168521468, 168525366, 168517892, 168521859, 168518553, 168529389, 168520943, 168523566, 168536034, 168521371, 168523798, 168521699, 168516764, 168524985, 168524317, 168517770], "E": [168650929, 168598643, 168610266, 173790812]}, "name": "D. Permutation for Burenka", "statement": "We call an array a if all elements in it are pairwise distinct. For\r\nexample, an array [1, 7, 9] is pure, [1, 3, 3, 7] isn\u2019t, because 3\r\noccurs twice in it.A pure array b is to a pure array c if their lengths\r\nn are the same and for all pairs of indices l, r, such that 1\r\nle l\r\nle r\r\nle n, it\u2019s true that\r\noperatorname{argmax}([b_l, b_{l + 1},\r\nldots, b_r]) =\r\noperatorname{argmax}([c_l, c_{l + 1},\r\nldots, c_r]), where\r\noperatorname{argmax}(x) is defined as the index of the largest element\r\nin x (which is unique for pure arrays). For example,\r\noperatorname{argmax}([3, 4, 2]) = 2,\r\noperatorname{argmax}([1337, 179, 57]) = 1.Recently, Tonya found out that\r\nBurenka really likes a permutation p of length n. Tonya decided to\r\nplease her and give her an array a to p. He already fixed some elements\r\nof a, but exactly k elements are missing (in these positions temporarily\r\na_i = 0). It is guaranteed that k\r\nge 2. Also, he has a set S of k - 1 numbers.Tonya realized that he was\r\nmissing one number to fill the empty places of a, so he decided to buy\r\nit. He has q options to buy. Tonya thinks that the number d suits him,\r\nif it is possible to replace all zeros in a with numbers from S and the\r\nnumber d, so that a becomes a array to p. For each option of d, output\r\nwhether this number is suitable for him or not.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 16.08.2022 18:22:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    int add = 0;\n    int mn = 0;\n    int pos = -1;\n\n    void apply(int l, int r, int v) {\n      if (l == r) {\n        pos = l;\n      }\n      add += v;\n      mn += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mn = min(a.mn, b.mn);\n    res.pos = (a.mn == res.mn ? a.pos : b.pos);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, q;\n    cin >> n >> q;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n      --p[i];\n    }\n    vector<int> a(n);\n    vector<int> nums;\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      --a[i];\n      if (a[i] != -1) {\n        nums.push_back(a[i]);\n      } else {\n        k += 1;\n      }\n    }\n    assert(k >= 2);\n    vector<int> s(k - 1);\n    for (int i = 0; i < k - 1; i++) {\n      cin >> s[i];\n      --s[i];\n      nums.push_back(s[i]);\n    }\n    vector<int> d(q);\n    for (int i = 0; i < q; i++) {\n      cin >> d[i];\n      --d[i];\n      nums.push_back(d[i]);\n    }\n    sort(nums.begin(), nums.end());\n    nums.resize(unique(nums.begin(), nums.end()) - nums.begin());\n    int sz = (int) nums.size();  \n    for (int i = 0; i < n; i++) {\n      if (a[i] != -1) {\n        a[i] = (int) (lower_bound(nums.begin(), nums.end(), a[i]) - nums.begin());\n      }\n    }\n    for (int i = 0; i < k - 1; i++) {\n      s[i] = (int) (lower_bound(nums.begin(), nums.end(), s[i]) - nums.begin());\n    }\n    for (int i = 0; i < q; i++) {\n      d[i] = (int) (lower_bound(nums.begin(), nums.end(), d[i]) - nums.begin());\n    }\n    vector<int> ind(n);\n    iota(ind.begin(), ind.end(), 0);\n    SparseTable<int> ts(ind, [&](int i, int j) { return (p[i] > p[j] ? i : j); });\n    vector<int> pv(n);\n    vector<int> order;\n    function<void(int, int, int)> Dfs = [&](int l, int r, int pr) {\n      if (l > r) {\n        return;\n      }\n      int i = ts.get(l, r);\n      order.push_back(i);\n      pv[i] = pr;\n      Dfs(l, i - 1, i);\n      Dfs(i + 1, r, i);\n    };\n    Dfs(0, n - 1, -1);\n    vector<int> L(n), R(n);\n    for (int i = 0; i < n; i++) {\n      if (a[i] == -1) {\n        L[i] = 0;\n        R[i] = sz - 1;\n      } else {\n        L[i] = a[i];\n        R[i] = a[i];\n      }\n    }\n    for (int it = 1; it < n; it++) {\n      int i = order[it];\n      R[i] = min(R[i], R[pv[i]] - 1);\n    }\n    for (int it = n - 1; it >= 1; it--) {\n      int i = order[it];\n      L[pv[i]] = max(L[pv[i]], L[i] + 1);\n    }\n    bool fail = false;\n    for (int i = 0; i < n; i++) {\n      if (L[i] > R[i]) {\n        fail = true;\n        break;\n      }\n    }\n    if (fail) {\n      for (int i = 0; i < q; i++) {\n        cout << \"NO\" << '\\n';\n      }\n      continue;\n    }\n    vector<int> have(sz);\n    for (int i = 0; i < n; i++) {\n      if (a[i] != -1) {\n        have[a[i]] += 1;\n      }\n    }\n    for (int i = 0; i < k - 1; i++) {\n      have[s[i]] += 1;\n    }\n    vector<vector<int>> at(sz);\n    for (int i = 0; i < n; i++) {\n      at[L[i]].push_back(i);\n    }\n    int low = 0;\n    int high = sz - 1;\n    vector<int> zeros(sz);\n    segtree st(zeros);\n    for (int i = sz - 1; i >= 0; i--) {\n      for (int j : at[i]) {\n        st.modify(R[j], sz - 1, -1);\n      }\n      if (have[i] != 0) {\n        st.modify(i, sz - 1, have[i]);\n      }\n      auto nd = st.get(i, sz - 1);\n      if (nd.mn < -1) {\n        low = 1;\n        high = 0;\n        break;\n      }\n      if (nd.mn == -1) {\n        int j = nd.pos;\n        low = max(low, i);\n        high = min(high, j);\n      }\n    }\n    for (int i = 0; i < q; i++) {\n      cout << ((low <= d[i] && d[i] <= high) ? \"YES\" : \"NO\") << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "graph matchings", "greedy", "math", "trees"], "dificulty": "3300", "interactive": false}