{"link": "https://codeforces.com//contest/1423/problem/C", "problemId": "749083", "problem_idx": "C", "shortId": "1423C", "contest_number": "1423", "problem_submissions": {"J": [95462948, 95462931, 95462795, 95462776, 95462759, 95462752, 95462749, 95445856, 95445842, 95445741, 95445735, 95445720, 95436077, 95435983, 94779119, 94773285, 94770663, 94778562], "C": [94789081], "I": [94786050], "F": [94784528, 94776365, 94779778, 94781062], "H": [94781814, 94783650, 94777878, 94784871], "L": [94780014, 94780685, 94786643, 94773659], "B": [94771096, 94770153, 94772426, 94771466], "K": [94770723, 94771588, 94773427, 94774938], "A": []}, "name": "C. Du\u0161an s Railway", "statement": "As you may already know, Du an is keen on playing with railway models.\r\nHe has a big map with cities that are connected with railways. His map\r\ncan be seen as a graph where vertices are cities and the railways\r\nconnecting them are the edges. So far, the graph corresponding to his\r\nmap is a tree. As you already know, a tree is a connected acyclic\r\nundirected graph.He is curious to find out whether his railway can be\r\noptimized somehow. He wants to add so-called , which are also railways\r\nconnecting pairs of cities. This shortcut will the railways in the\r\nunique path in the tree between the pair of cities it connects. Since Du\r\nan doesn\u2019t like repeating the railways, he has also defined good paths\r\nin his newly obtained network (notice that after adding the shortcuts,\r\nhis graph is no more a tree). He calls a path , if no edge appears more\r\nthan once, either as a regular railway edge or as an edge represented by\r\nsome shortcut (Every shortcut in a good path has length 1, but uses up\r\nall the edges it represents - they can\u2019t appear again in that path).\r\nHaving defined good paths, he defines between two cities to be the\r\nlength of the shortest good path between them. Finally, the of his\r\nnetwork is the largest good distance between any two cities.Now he is\r\ncurious to find out whether it is possible to achieve shortcutting\r\ndiameter less or equal than k, while adding as few shortcuts as\r\npossible.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.10.2020 18:38:13       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<bool> alive(n, true);\n  vector<int> sz(n);\n  vector<int> pv(n);\n  vector<pair<int, int>> ret;\n  vector<int> all;\n  vector<int> tin(n);\n  vector<int> tout(n);\n  int T = -1;\n  function<void(int)> Dfs = [&](int v) {\n    all.push_back(v);\n    tin[v] = ++T;\n    sz[v] = 1;\n    for (int u : g[v]) {\n      if (alive[u] && u != pv[v]) {\n        pv[u] = v;\n        Dfs(u);\n        sz[v] += sz[u];\n      }\n    }\n    tout[v] = ++T;\n  };\n  function<void(int)> Solve = [&](int v) {\n    all.clear();\n    pv[v] = -1;\n    Dfs(v);\n    int total = sz[v];\n    while (true) {\n      bool found = false;\n      for (int u : g[v]) {\n        if (alive[u] && pv[u] == v && 2 * sz[u] >= total) {\n          v = u;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        break;\n      }\n    }\n    alive[v] = false;\n    set<int> best;\n    for (int u : g[v]) {\n      if (alive[u]) {\n        all.clear();\n        pv[u] = -1;\n        Dfs(u);\n        set<int> cur;\n        for (int w : g[u]) {\n          if (alive[w]) {\n            cur.insert(w);\n          }\n        }\n        if (cur.size() > best.size()) {\n          best = cur;\n        }\n      }\n    }\n    all.clear();\n    pv[v] = -1;\n    Dfs(v);\n    for (int u : all) {\n      if (u != v && pv[u] != v && best.find(u) == best.end()) {\n        ret.emplace_back(u, v);\n      }\n    }\n    vector<int> children;\n    for (int u : g[v]) {\n      if (alive[u]) {\n        children.push_back(u);\n      }\n    }\n    for (int u : children) {\n      Solve(u);\n    }\n  };\n  Solve(0);\n  assert((int) ret.size() <= 10 * n);\n//  ret.resize(min((int) ret.size(), 10 * n));\n  cout << ret.size() << '\\n';\n  for (auto& p : ret) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["divide and conquer", "graphs", "trees"], "dificulty": "3500", "interactive": false}