{
    "link": "https://codeforces.com//contest/1254/problem/C",
    "problemId": "475572",
    "problem_idx": "C",
    "shortId": "1254C",
    "contest_number": "1254",
    "problem_submissions": {
        "E": [
            65385076,
            65389059,
            65387406,
            65386461,
            65391860,
            65388358,
            65363435,
            65898589,
            65898484,
            65394164,
            65399861,
            66201727,
            65511222,
            65387985,
            65459118,
            65393939,
            65393500,
            65393329
        ],
        "D": [
            65367776,
            65371157,
            65363228,
            65371547,
            65376523,
            65913436,
            65376504,
            65392793,
            65392745,
            65392458,
            65378396,
            65374788,
            65374479,
            65375973,
            72224123,
            72224118,
            72222073,
            66201641,
            66201609,
            65765881,
            65505837,
            65498656,
            65498523,
            65498350,
            65448275,
            65421529,
            65421428,
            65420506,
            65420496,
            65420340,
            65420220,
            65419939,
            65419809,
            65419466,
            65419306,
            65410495,
            65410139,
            65394253,
            65394071,
            65393989,
            65393862,
            65393694,
            65393607,
            65393012,
            65391960,
            65391551,
            65372156,
            65379236,
            65379295,
            65458244,
            65380498,
            65379619,
            65398630,
            65392892,
            65392821,
            65392515,
            65379510,
            65376362,
            65378466,
            65385723
        ],
        "C": [
            65362906,
            65363606,
            65372750,
            65364742,
            65368283,
            65376926,
            65364286,
            65368353,
            65366513,
            65367352,
            65362577,
            65365184,
            65369353,
            65366181,
            65364840,
            65369974,
            65366318,
            65369506
        ],
        "B1": [
            65358065,
            65358880,
            65365540,
            65357743,
            65359033,
            65368715,
            65359200,
            65362593,
            65360678,
            65362903,
            65376471,
            65360693,
            65359085,
            65359111,
            65357280,
            65361721,
            65360645,
            65360620,
            65355048
        ],
        "B2": [
            65357919,
            65358760,
            65365394,
            65357802,
            65363382,
            65368676,
            65359261,
            65362680,
            65360774,
            65362731,
            65376512,
            65360901,
            65359018,
            65358907,
            65360708,
            65398529,
            65398522,
            65398389,
            65398370,
            65398329,
            65398291,
            65398212,
            65361653,
            65360607,
            65360509,
            65354503
        ],
        "A": [
            65355800,
            65355044,
            65354936,
            65355999,
            65356253,
            65372457,
            65355826,
            65357065,
            65357334,
            65359043,
            65356279,
            65357553,
            65355832,
            65355374,
            65354099,
            65354766,
            65367155,
            65356549,
            65357393
        ]
    },
    "name": "C. Point Ordering",
    "statement": "Khanh has n points on the Cartesian plane, denoted by a_1, a_2,\r\nldots, a_n. All points\u2019 coordinates are integers between -10^9 and 10^9,\r\ninclusive. No three points are collinear. He says that these points are\r\nvertices of a convex polygon; in other words, there exists a permutation\r\np_1, p_2,\r\nldots, p_n of integers from 1 to n such that the polygon a_{p_1} a_{p_2}\r\nldots a_{p_n} is convex and vertices are listed in counter-clockwise\r\norder.Khanh gives you the number n, but hides the coordinates of his\r\npoints. Your task is to guess the above permutation by asking multiple\r\nqueries. In each query, you give Khanh 4 integers t, i, j, k; where\r\neither t = 1 or t = 2; and i, j, k are three indices from 1 to n,\r\ninclusive. In response, Khanh tells you: if t = 1, the area of the\r\ntriangle a_ia_ja_k . if t = 2, the of the of two\r\noverrightarrow{a_ia_j} and\r\noverrightarrow{a_ia_k}. Recall that the of vector\r\noverrightarrow{a} = (x_a, y_a) and vector\r\noverrightarrow{b} = (x_b, y_b) is the x_a\r\ncdot y_b - x_b\r\ncdot y_a. The of a number is 1 it it is positive, and -1 otherwise. It\r\ncan be proven that the cross product obtained in the above queries can\r\nnot be 0.You can ask at most 3\r\ncdot n queries.Please note that Khanh fixes the coordinates of his\r\npoints and does not change it while answering your queries. You do not\r\nneed to guess the coordinates. In your permutation a_{p_1}a_{p_2}\r\nldots a_{p_n}, p_1 should be equal to 1 and the indices of vertices\r\nshould be .\r\n",
    "solutions": [
        "    //~ while (clock()<=69*CLOCKS_PER_SEC)\n    //~ #pragma comment(linker, \"/stack:200000000\")\n    #pragma GCC optimize(\"O3\")\n    //~ #pragma GCC optimize(\"Ofast\")\n    //~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n    //~ #pragma GCC optimize(\"unroll-loops\")\n    #include <bits/stdc++.h>\n    #include <ext/pb_ds/assoc_container.hpp>\n    #include <ext/pb_ds/tree_policy.hpp>\n     \n    using namespace __gnu_pbds;\n    using namespace std;\n     \n    template <typename T>\n    using ordered_set =\n        tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n     \n    #define sim template < class c\n    #define ris return * this\n    #define dor > debug & operator <<\n    #define eni(x) sim > typename \\\n      enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\n    sim > struct rge { c b, e; };\n    sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\n    sim > auto dud(c* x) -> decltype(cerr << *x, 0);\n    sim > char dud(...);\n    struct debug {\n    #ifdef LOCAL\n    ~debug() { cerr << endl; }\n    eni(!=) cerr << boolalpha << i; ris; }\n    eni(==) ris << range(begin(i), end(i)); }\n    sim, class b dor(pair < b, c > d) {\n      ris << \"(\" << d.first << \", \" << d.second << \")\";\n    }\n    sim dor(rge<c> d) {\n      *this << \"[\";\n      for (auto it = d.b; it != d.e; ++it)\n        *this << \", \" + 2 * (it == d.b) << *it;\n      ris << \"]\";\n    }\n    #else\n    sim dor(const c&) { ris; }\n    #endif\n    };\n    #define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n     \n    #define shandom_ruffle random_shuffle\n     \n    using ll=long long;\n    using pii=pair<int,int>;\n    using pll=pair<ll,ll>;\n    using vi=vector<int>;\n    using vll=vector<ll>;\n    const int nax=1000*1007;\n    const ll inf=1e18;\n     \n    void ff()\n    {\n    \tfflush(stdout);\n    }\n     \n    ll pyt1(int a, int b, int c)\n    {\n    \tprintf(\"1 %d %d %d\\n\", a, b, c);\n    \tff();\n    \tll x;\n    \tscanf(\"%lld\", &x);\n    \treturn x;\n    }\n     \n    int pyt2(int a, int b, int c)\n    {\n    \tprintf(\"2 %d %d %d\\n\", a, b, c);\n    \tff();\n    \tint x;\n    \tscanf(\"%d\", &x);\n    \treturn x;\n    }\n     \n    int n;\n     \n    vi licz(int a, int b, vi wek)\n    {\n    \tvector <pair<ll,int> > dos;\n    \tfor (int i : wek)\n    \t\tdos.push_back({pyt1(a, b, i), i});\n    \tsort(dos.begin(), dos.end());\n    \t\n    \tvi ret, pom;\n    \tint ost=dos.back().second;\n    \tfor (auto i : dos)\n    \t{\n    \t\tint v=i.second;\n    \t\tif (v==ost || pyt2(a, ost, v)==-1)\n    \t\t\tret.push_back(v);\n    \t\telse\n    \t\t\tpom.push_back(v);\n    \t}\n    \twhile(!pom.empty())\n    \t{\n    \t\tret.push_back(pom.back());\n    \t\tpom.pop_back();\n    \t}\n    \treturn ret;\n    }\n     \n    int main()\n    {\n    \tscanf(\"%d\", &n);\n    \tvi raz, dwa;\n    \tfor (int i=3; i<=n; i++)\n    \t{\n    \t\tif (pyt2(1, 2, i)==1)\n    \t\t\traz.push_back(i);\n    \t\telse\n    \t\t\tdwa.push_back(i);\n    \t}\n    \tvi w1=licz(2, 1, raz);\n    \tvi w2=licz(1, 2, dwa);\n    \tprintf(\"0\");\n    \tprintf(\" 1\");\n    \tfor (int i : w2)\n    \t\tprintf(\" %d\", i);\n    \tprintf(\"\\n\");\n    \tprintf(\" 2\");\n    \tfor (int i : w1)\n    \t\tprintf(\" %d\", i);\n    \tff();\n    \treturn 0;\n    }\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "geometry",
        "interactive",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Point Ordering.json",
    "editorial_link": "https://codeforces.com//blog/entry/71594",
    "editorial": "Let\u00e2\u0080\u0099s start by choosing vertices and as pivots.Recall that if the cross\r\nproduct of two vectors and is positive, point lies to the left of ; if\r\nthe product is negative, point lies to the right of ; and if the product\r\nis zero, the 3 points , , are collinear.With queries of type 2, we can\r\nknow which vertices lie to the left or to the right of edge and then\r\nsolve the two sides separately.Consider the left side and there are\r\nvertices lie to the left, we can use queries of type 1 to calculate the\r\ndistance from those vertices to edge (the distance from vertex to edge\r\nis twice the area of the triangle forms by , , , divides by the length\r\nof edge ). Let Y be the farthest from (there can be at most 2 such\r\nvertices). We can use queries of type 2 to see if the others vertices\r\nlie between or between , then sort them counter-clockwise with the asked\r\ndistances. So we will use queries to calculate the distances from\r\nvertices to edge and at most for the latter step. This solution uses at\r\nmost queries.Another solution is to find the vertex that is consecutive\r\nto in queries and do the same as the solution above.\r\n"
}