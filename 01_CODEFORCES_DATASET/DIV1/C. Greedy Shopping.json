{
    "link": "https://codeforces.com//contest/1439/problem/C",
    "problemId": "798717",
    "problem_idx": "C",
    "shortId": "1439C",
    "contest_number": "1439",
    "problem_submissions": {
        "E": [
            98736027,
            98740513,
            98743267,
            98751627,
            98746552,
            98793931,
            99104638
        ],
        "D": [
            98723891,
            98705229,
            98723612,
            98827591,
            98816648,
            98814032,
            98725036,
            98724071,
            98728933,
            98730831,
            98730544,
            98736469,
            98737101,
            98739698,
            98716903,
            98721633,
            98735777,
            98741204,
            98725990,
            98732940,
            98719637,
            98741795
        ],
        "C": [
            98717653,
            98714961,
            98717583,
            98709251,
            98712683,
            98710256,
            98709014,
            98716952,
            98723694,
            98722478,
            98723203,
            98711303,
            98733440,
            98725610,
            98728037,
            98706473,
            98717733,
            98731377,
            98715466,
            98722420
        ],
        "B": [
            98704771,
            98722470,
            98701689,
            98703648,
            98704924,
            98788376,
            98780895,
            98705172,
            98721750,
            98849262,
            98707321,
            98708231,
            98709710,
            98796719,
            98765489,
            98765480,
            98765433,
            98765408,
            98765370,
            98750864,
            98750749,
            98747376,
            98713010,
            98736680,
            98709620,
            98716637,
            98748644,
            114352814,
            99699811,
            98846560,
            98754739,
            98754712,
            98711616
        ],
        "A2": [
            98692587,
            98708717,
            98890116,
            98695391,
            98695058,
            98694605,
            98697338,
            98695371,
            98698896,
            98697020,
            98700533,
            98695246,
            98692759,
            98703206,
            98695281,
            98699389,
            98696575,
            98695659,
            98722036,
            98693365,
            98696174
        ],
        "A1": [
            98692484,
            98708569,
            98695320,
            98695174,
            98694699,
            98697254,
            98695563,
            98698871,
            98696932,
            98700473,
            98695187,
            98692661,
            98703311,
            98695126,
            98699325,
            98696645,
            98695725,
            98722109,
            98693254,
            98696254
        ]
    },
    "name": "C. Greedy Shopping",
    "statement": "You are given an array a_1, a_2,\r\nldots, a_n of integers. This array is .Let’s consider a line with n\r\nshops. The shops are numbered with integers from 1 to n from left to\r\nright. The cost of a meal in the i-th shop is equal to a_i.You should\r\nprocess q queries of two types: : for each shop 1\r\nleq i\r\nleq x set a_{i} = max(a_{i}, y). : let’s consider a hungry man with y\r\nmoney. He visits the shops from x-th shop to n-th and if he can buy a\r\nmeal in the current shop he buys one item of it. Find how many meals he\r\nwill purchase. The man can buy a meal in the shop i if he has at least\r\na_i money, and after it his money decreases by a_i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nnamespace seg_tree {\n\n// Floor of log_2(a); index of highest 1-bit\nint log_2(int a) {\n\treturn a ? (8 * sizeof(a)) - 1 - __builtin_clz(a) : -1;\n}\n\nint next_pow_2(int a) {\n\tassert(a > 0);\n\treturn 1 << log_2(2*a-1);\n}\n\ntemplate <typename F> void for_parents_up(int a, F f) {\n\ta >>= 1;\n\tfor (; a > 0; a >>= 1) {\n\t\tf(a);\n\t}\n}\n\ntemplate <typename F> void for_parents_down(int a, F f) {\n\ta >>= 1;\n\tfor (int L = log_2(a); L >= 0; L--) {\n\t\tf(a >> L);\n\t}\n}\n\ntemplate <typename F> void for_range_parents_up(std::array<int, 2> r, F f) {\n\tauto [a, b] = r;\n\tassert(a && b);\n\ta >>= __builtin_ctz(a);\n\tb >>= __builtin_ctz(b);\n\n\t// TODO: dedup\n\tfor_parents_up(a, f);\n\tfor_parents_up(b, f);\n}\n\ntemplate <typename F> void for_range_parents_down(std::array<int, 2> r, F f) {\n\tauto [a, b] = r;\n\tassert(a && b);\n\ta >>= __builtin_ctz(a);\n\tb >>= __builtin_ctz(b);\n\n\t// TODO: dedup\n\tfor_parents_down(a, f);\n\tfor_parents_down(b, f);\n}\n\ntemplate <typename F> void for_point(int a, F f) {\n\tfor (; a > 0; a >>= 1) {\n\t\tf(a);\n\t}\n}\n\ntemplate <typename F> void for_range(std::array<int, 2> r, F f) {\n\tauto [a, b] = r;\n\tassert(a <= b && b <= 2*a);\n\tfor (; a < b; a >>= 1, b >>= 1) {\n\t\tif (a & 1) f(a++, false);\n\t\tif (b & 1) f(--b, true);\n\t}\n}\n\nnamespace in_order {\n\nint get_point(int N, int a) {\n\tassert(0 <= a && a < N);\n\tint S = next_pow_2(N);\n\ta += S;\n\treturn a >= 2 * N ? a - N : a;\n}\n\nstd::array<int, 2> get_range(int N, std::array<int, 2> p) {\n\tauto [a, b] = p;\n\tassert(0 <= a && a <= b && b <= N);\n\tint S = next_pow_2(N);\n\ta += S, b += S;\n\treturn { (a >= 2 * N ? 2*(a-N) : a), (b >= 2 * N ? 2*(b-N) : b) };\n}\n\nint get_node_index(int N, int a) {\n\tassert(N <= a && a < 2 * N);\n\tint S = next_pow_2(N);\n\treturn (a < S ? a + N : a) - S;\n}\n\nstd::array<int, 2> get_node_bounds(int N, int a) {\n\tassert(1 <= a && a < 2 * N);\n\tint l = __builtin_clz(a) - __builtin_clz(2*N-1);\n\tint S = next_pow_2(N);\n\tint x = a << l, y = (a+1) << l;\n\tassert(S <= x && x < y && y <= 2*S);\n\treturn {(x >= 2 * N ? (x>>1) + N : x) - S, (y >= 2 * N ? (y>>1) + N : y) - S};\n}\n\nint get_node_size(int N, int a) {\n\tassert(1 <= a && a < 2 * N);\n\tauto [x, y] = get_node_bounds(N, a);\n\treturn y - x;\n}\n\n} // namespace in_order\n\nnamespace circular {\n\nint get_point(int N, int a) {\n\tassert(0 <= a && a < N);\n\treturn N + a;\n}\n\nstd::array<int, 2> get_range(int N, std::array<int, 2> p) {\n\tauto [a, b] = p;\n\tassert(0 <= a && a <= b && b <= N);\n\treturn { N + a, N + b };\n}\n\nint get_node_index(int N, int a) {\n\tassert(N <= a && a < 2 * N);\n\treturn a - N;\n}\n\nstd::array<int, 2> get_node_bounds(int N, int a) {\n\tassert(1 <= a && a < 2 * N);\n\tint l = __builtin_clz(a) - __builtin_clz(2*N-1);\n\tint S = next_pow_2(N);\n\tint x = a << l, y = (a+1) << l;\n\tassert(S <= x && x < y && y <= 2*S);\n\treturn {(x >= 2 * N ? x >> 1 : x) - N, (y >= 2 * N ? y >> 1 : y) - N};\n}\n\nint get_node_size(int N, int a) {\n\tassert(1 <= a && a < 2 * N);\n\treturn in_order::get_node_size(N, a);\n}\n\n} // namespace circular\n\n} // namespace seg_tree\n\nnamespace seg_tree { using namespace in_order; }\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, Q; cin >> N >> Q;\n\n\t// 0 is unset\n\tvector<int> lazy_set(2*N);\n\tvector<int64_t> sum(2*N);\n\tvector<int> min_val(2*N);\n\tvector<int> max_val(2*N);\n\n\tauto update_node = [&](int a) {\n\t\tif (lazy_set[a]) {\n\t\t\tmin_val[a] = max_val[a] = lazy_set[a];\n\t\t\tsum[a] = int64_t(lazy_set[a]) * seg_tree::get_node_size(N, a);\n\t\t} else {\n\t\t\tassert(a < N);\n\t\t\tassert(min_val[2*a] >= max_val[2*a+1]);\n\t\t\tmax_val[a] = max_val[2*a];\n\t\t\tmin_val[a] = min_val[2*a+1];\n\t\t\tsum[a] = sum[2*a] + sum[2*a+1];\n\t\t}\n\t};\n\n\tauto downdate_node = [&](int a) {\n\t\tif (a < N && lazy_set[a]) {\n\t\t\tlazy_set[2*a] = lazy_set[a];\n\t\t\tupdate_node(2*a);\n\t\t\tlazy_set[2*a+1] = lazy_set[a];\n\t\t\tupdate_node(2*a+1);\n\t\t\tlazy_set[a] = 0;\n\t\t}\n\t};\n\n\tauto try_set = std::y_combinator([&](auto self, int a, int v) -> void {\n\t\tif (v <= min_val[a]) {\n\t\t\t//cerr << \"not setting \" << a << ' ' << seg_tree::get_node_bounds(N, a)[0] << ' ' << seg_tree::get_node_bounds(N,a)[1] << '\\n';\n\t\t\t//cerr << v << ' ' << max_val[a] << ' ' << min_val[a] << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tif (v >= max_val[a]) {\n\t\t\t//cerr << \"setting \" << a << ' ' << seg_tree::get_node_bounds(N, a)[0] << ' ' << seg_tree::get_node_bounds(N,a)[1] << '\\n';\n\t\t\t//cerr << v << ' ' << max_val[a] << ' ' << min_val[a] << '\\n';\n\t\t\tlazy_set[a] = v;\n\t\t\tupdate_node(a);\n\t\t\treturn;\n\t\t}\n\t\tassert(min_val[a] < v && v < max_val[a]);\n\t\tassert(!lazy_set[a]);\n\t\tself(2*a, v);\n\t\tself(2*a+1, v);\n\t\tupdate_node(a);\n\t});\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint v; cin >> v;\n\t\tint a = seg_tree::get_point(N, i);\n\t\tlazy_set[a] = v;\n\t}\n\tfor (int a = 2*N-1; a > 0; a--) update_node(a);\n\n\twhile (Q--) {\n\t\tint t, x, y; cin >> t >> x >> y;\n\t\tx--;\n\t\tif (t == 1) {\n\t\t\tauto r = seg_tree::get_range(N, {0, x+1});\n\t\t\tseg_tree::for_range_parents_down(r, downdate_node);\n\t\t\tseg_tree::for_range(r, [&](int a, bool) {\n\t\t\t\ttry_set(a, y);\n\t\t\t});\n\t\t\tseg_tree::for_range_parents_up(r, update_node);\n\t\t} else if (t == 2) {\n\t\t\tint64_t tot_pref = y;\n\t\t\t{\n\t\t\t\tauto r = seg_tree::get_range(N, {0, x});\n\t\t\t\tseg_tree::for_range_parents_down(r, downdate_node);\n\t\t\t\tseg_tree::for_range(r, [&](int a, bool) {\n\t\t\t\t\ttot_pref += sum[a];\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t//cerr << tot_pref << '\\n';\n\n\t\t\tint ans = -x;\n\t\t\tstd::y_combinator([&](auto self, int a) -> void {\n\t\t\t\tif (tot_pref >= sum[a]) {\n\t\t\t\t\t//cerr << \"buying all of \" << a << ' ' << seg_tree::get_node_bounds(N, a)[0] << ' ' << seg_tree::get_node_bounds(N,a)[1] << '\\n';\n\t\t\t\t\t//cerr << tot_pref << ' ' << sum[a] << '\\n';\n\t\t\t\t\ttot_pref -= sum[a];\n\t\t\t\t\tans += seg_tree::get_node_size(N, a);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (tot_pref < min_val[a]) {\n\t\t\t\t\t//cerr << \"skipping \" << a << ' ' << seg_tree::get_node_bounds(N, a)[0] << ' ' << seg_tree::get_node_bounds(N,a)[1] << '\\n';\n\t\t\t\t\t//cerr << tot_pref << ' ' << min_val[a] << ' ' << max_val[a] << '\\n';\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (max_val[a] == min_val[a]) {\n\t\t\t\t\t//cerr << \"buying some of \" << a << ' ' << seg_tree::get_node_bounds(N, a)[0] << ' ' << seg_tree::get_node_bounds(N,a)[1] << '\\n';\n\t\t\t\t\t//cerr << tot_pref << ' ' << min_val[a] << '\\n';\n\t\t\t\t\tint64_t num_buy = tot_pref / min_val[a];\n\t\t\t\t\ttot_pref -= num_buy * min_val[a];\n\t\t\t\t\tans += int(num_buy);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tassert(!lazy_set[a]);\n\t\t\t\tself(2*a);\n\t\t\t\tself(2*a+1);\n\t\t\t})(1);\n\t\t\tcout << ans << '\\n';\n\t\t} else assert(false);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "greedy",
        "implementation"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Greedy Shopping.json",
    "editorial_link": "https://codeforces.com//blog/entry/84731",
    "editorial": "We can prove that the hungry man will eat at most continiuous\r\nsubsegments, where is the maximum amount of money possible. Why is that\r\nso? Suppose the hungry man buys a meal from the th shop but canât buy a\r\nmeal from the th one after that. Then, the money the hungry man had\r\nbefore buying the th food is at most twice the money he has after buying\r\nthe th food because . So every time he breaks the subsegment of shops,\r\nhis money is cut in at least half, so he will eat atmost continuous\r\nsubsegments.Now we need a data structure with the following queries:\r\nrange_max and range_sum. Since our array is non-increasing, a segment\r\ntree will suffice. The first type of query is just a range_max query.\r\nFor the second type of query you can find the first element that is\r\nequal to or smaller than the hungry manâs money and after that find the\r\nsegment that he will eat, in which we can use a binary-search on the\r\ntree to find these both. After that we can repeat this action untill we\r\nreach the end of the array, or until his money runs out.Time complexity:\r\n",
    "hint": []
}