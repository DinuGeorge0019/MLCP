{
    "link": "https://codeforces.com//contest/896/problem/C",
    "problemId": "137070",
    "problem_idx": "C",
    "shortId": "896C",
    "contest_number": "896",
    "problem_submissions": {
        "C": [
            32944802,
            32881577,
            32878510,
            32875053,
            32868262,
            32869520,
            32877475,
            32871462,
            32871613,
            32872946,
            32872899,
            32872163,
            32874463
        ],
        "E": [
            32884285,
            32880271,
            32868418,
            32902000,
            32901971,
            32890213,
            32889941,
            32889728,
            32871177,
            149032223,
            149032042
        ],
        "B": [
            32866795,
            32865695,
            32866037,
            32866388,
            32869687,
            32864715,
            32865144,
            32877783,
            32866364,
            32866670,
            32865961,
            32864186,
            32868170,
            32865590,
            32863874,
            32867553,
            32868641,
            32868643,
            32874386,
            32865418
        ],
        "A": [
            32864492,
            32863421,
            32863158,
            32862992,
            32872439,
            32862588,
            32863707,
            32870827,
            32864151,
            32863537,
            32862938,
            32861614,
            32863683,
            32863600,
            32866515,
            32863570,
            32865560,
            32869952,
            32863704,
            32863274
        ],
        "D": [
            32872283,
            32876145,
            32868178,
            32875381,
            32882890,
            32882835,
            32873963,
            32876341,
            144356577,
            32875993,
            32876631,
            32920532,
            32876942,
            32875664
        ]
    },
    "name": "C. Willem, Chtholly and Seniorious",
    "statement": "Seniorious is made by linking special talismans in particular\r\norder.After over 500 years, the carillon is now in bad condition, so\r\nWillem decides to examine it thoroughly.Seniorious has pieces of\r\ntalisman. Willem puts them in a line, the -th of which is an integer .In\r\norder to maintain it, Willem needs to perform operations.There are four\r\ntypes of operations: : For each such that , assign to . : For each such\r\nthat , assign to . : Print the -th smallest number in the index range ,\r\ni.e. the element at the -th position if all the elements such that are\r\ntaken and sorted into an array of non-decreasing integers. It’s\r\nguaranteed that . : Print the sum of the -th power of such that , modulo\r\n, i.e. .\r\n",
    "solutions": [
        "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define _CRT_SECURE_NO_WARNINGS\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n\n#ifdef LOCAL\n# include <opencv2/core/core.hpp>\n# include <opencv2/highgui/highgui.hpp>\n# include <opencv2/imgproc/imgproc.hpp>\n#endif\n\nusing namespace std;\n\n// Let's define unordered map\n# ifdef __GNUC__\n# if __cplusplus > 199711L\n# include <unordered_set>\n# include <unordered_map>\n# else\n# include <tr1/unordered_map>\n# include <tr1/unordered_set>\nusing namespace tr1;\n# endif\n# else\n# include <unordered_map>\n# include <unordered_set>\n# endif\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define DBN1(a)           cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBN2(a,b)         cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n#define DBN3(a,b,c)       cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\"\\n\"\n#define DBN4(a,b,c,d)     cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\"\\n\"\n#define DBN5(a,b,c,d,e)   cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\", \"<<#e<<\"=\"<<(e)<<\"\\n\"\n#define DBN6(a,b,c,d,e,f) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\", \"<<#e<<\"=\"<<(e)<<\", \"<<#f<<\"=\"<<(f)<<\"\\n\"\n#define DBN(...) macro_dispatcher(DBN, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,n) cerr<<#a<<\"=[\"; printarray(a,n); cerr<<\"]\\n\"\n#define DAR(a,n,s) cerr<<#a<<\"[\"<<s<<\"-\"<<n-1<<\"]=[\"; printarray(a,n,s); cerr<<\"]\\n\"\n\n#ifdef _MSC_VER\n#define PREFETCH(ptr, rw, level) ((void)0)\n#else\n#define PREFETCH(ptr, rw, level) __builtin_prefetch(ptr, rw, level)\n#endif\n\n#ifdef LOCAL\n#define CURTIME() cerr << clock() * 1.0 / CLOCKS_PER_SEC << endl\n#else\n#define CURTIME()\n#endif\n\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef int itn;\n\ntemplate<class T1, class T2, class T3>\nstruct triple{ T1 a; T2 b; T3 c; triple() : a(T1()), b(T2()), c(T3()) {}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };\ntemplate<class T1, class T2, class T3>\nbool operator<(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a<t2.a;else if(t1.b!=t2.b)return t1.b<t2.b;else return t1.c<t2.c;}\ntemplate<class T1, class T2, class T3>\nbool operator>(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a>t2.a;else if(t1.b!=t2.b)return t1.b>t2.b;else return t1.c>t2.c;}\n#define tri triple<int,int,int>\n#define trll triple<ll,ll,ll>\n\n#define FI(n) for(int i=0;i<(n);++i)\n#define FJ(n) for(int j=0;j<(n);++j)\n#define FK(n) for(int k=0;k<(n);++k)\n#define FL(n) for(int l=0;l<(n);++l)\n#define FQ(n) for(int q=0;q<(n);++q)\n#define FOR(i,a,b) for(int i = (a), __e = (int) (b); i < __e; ++i)\n#define all(a) std::begin(a), std::end(a)\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(1.0 * (x))\n#define pow(x, n) pow(1.0 * (x), n)\n\n#define COMPARE(obj) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b)\n#define COMPARE_BY(obj, field) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b) { return a.field < b.field; }\n\n#define checkbit(n, b) (((n) >> (b)) & 1)\n#define setbit(n, b) ((n) | (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define removebit(n, b) ((n) & ~(static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define flipbit(n, b) ((n) ^ (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\ninline int countBits(uint v){v=v-((v>>1)&0x55555555);v=(v&0x33333333)+((v>>2)&0x33333333);return((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24;}\ninline int countBits(ull v){uint t=v>>32;uint p=(v & ((1ULL << 32) - 1)); return countBits(t) + countBits(p); }\ninline int countBits(ll v){return countBits((ull)v); }\ninline int countBits(int v){return countBits((uint)v); }\nunsigned int reverseBits(uint x){ x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }\ntemplate<class T> inline int sign(T x){ return x > 0 ? 1 : x < 0 ? -1 : 0; }\ninline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }\nconstexpr ll power(ll x, int p) { return p == 0 ? 1 : (x * power(x, p - 1)); }\ntemplate<class T1, class T2, class T3> T1 inline clamp(T1 x, const T2& a, const T3& b) { if (x < a) return a; else if (x > b) return b; else return x; }\nunsigned long long rdtsc() { unsigned long long ret = 0;\n#ifdef __clang__\n    return __builtin_readcyclecounter();\n#endif\n#ifndef _MSC_VER\n    asm volatile(\"rdtsc\" : \"=A\" (ret) : :);\n#endif\n    return ret; }\n// Fast IO ********************************************************************************************************\nconst int __BS = 4096;\nstatic char __bur[__BS + 16], *__er = __bur + __BS, *__ir = __er;\ntemplate<class T = int> T readInt() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && (*__ir < '0' || *__ir > '9') && *__ir != '-') ++__ir; c();\n    bool m = false; if (*__ir == '-') ++__ir, c(), m = true;\n    T r = 0; while (*__ir >= '0' && *__ir <= '9') r = r * 10 + *__ir - '0', ++__ir, c();\n    ++__ir; return m ? -r : r;\n}\nstatic char __buw[__BS + 20], *__iw = __buw, *__ew = __buw + __BS;\ntemplate<class T>\nvoid writeInt(T x, char endc = '\\n') {\n    if (x < 0) *__iw++ = '-', x = -x; if (x == 0) *__iw++ = '0';\n    char* s = __iw;\n    while (x) { T t = x / 10; char c = x - 10 * t + '0'; *__iw++ = c; x = t; }\n    char* f = __iw - 1; while (s < f) swap(*s, *f), ++s, --f;\n    if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw;\n    *__iw++ = endc;\n}\ntemplate<class T>\nvoid writeStr(const T& str) {\n    int i = 0; while (str[i]) { *__iw++ = str[i++]; if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw; }\n}\nstruct __FL__ { ~__FL__() { if (__iw != __buw) cout.write(__buw, __iw - __buw); } };\nstatic __FL__ __flushVar__;\n\n//STL output *****************************************************************************************************\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p);\nTT1 ostream& operator << (ostream& os, const vector<T>& v);\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, const multiset<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v);\nTT1T2T3 ostream& operator << (ostream& os, const map<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const multimap<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t);\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<\"(\"<<p.first<<\", \"<< p.second<<\")\"; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << \"[\"; for (auto& ii : v) { if (!f)os << \", \"; os << \"(\" << ii.first << \" -> \" << ii.second << \") \"; f = 0; }return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << \"[\"; for (auto& ii : v) { if (!f)os << \", \"; os << \"(\" << ii.first << \" -> \" << ii.second << \") \"; f = 0; }return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << \"[\"; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << \", \"; f = 0; os << x; } return os << \"]\"; }\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t){ return os << \"(\" << t.a << \", \" << t.b << \", \" << t.c << \")\"; }\nTT1T2 void printarray(const T1& a, T2 sz, T2 beg = 0){ for (T2 i = beg; i<sz; i++) cout << a[i] << \" \"; cout << endl; }\n\n//STL input *****************************************************************************************************\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t);\nTT1T2 inline istream& operator >> (istream& os, pair<T1, T2>& p) { return os >> p.first >> p.second; }\nTT1 inline istream& operator >> (istream& os, vector<T>& v) {\n    if (v.size()) for (T& t : v) os >> t; else {\n        string s; T obj; while (s.empty()) {getline(os, s); if (!os) return os;}\n        stringstream ss(s); while (ss >> obj) v.push_back(obj);\n    }\n    return os;\n}\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t) { return os >> t.a >> t.b >> t.c; }\n\n//Pair magic *****************************************************************************************************\n#define PT1T2 pair<T1, T2>\nTT1T2 inline PT1T2 operator+(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first + p2.first, p1.second + p2.second); }\nTT1T2 inline PT1T2& operator+=(PT1T2 &p1 , const PT1T2 &p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\nTT1T2 inline PT1T2 operator-(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first - p2.first, p1.second - p2.second); }\nTT1T2 inline PT1T2& operator-=(PT1T2 &p1 , const PT1T2 &p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\n\n#undef TT1\n#undef TT1T2\n#undef TT1T2T3\n\n#define FREIN(FILE) freopen(FILE, \"rt\", stdin)\n#define FREOUT(FILE) freopen(FILE, \"wt\", stdout)\n#ifdef LOCAL\n#define BEGIN_PROFILE(idx, name) int profileIdx = idx; profileName[profileIdx] = name; totalTime[profileIdx] -= rdtsc() / 1e3;\n#define END_PROFILE totalTime[profileIdx] += rdtsc() / 1e3; totalCount[profileIdx]++;\n#else\n#define BEGIN_PROFILE(idx, name)\n#define END_PROFILE\n#endif\n\ntemplate<class T> inline void normmod(T &x, T m) { x %= m; if (x < 0) x += m; }\ntemplate<class T1, class T2> inline T2 summodfast(T1 x, T1 y, T2 m) { T2 res = x + y; if (res >= m) res -= m; return res; }\ntemplate<class T1, class T2, class T3> inline void addmodfast(T1 &x, T2 y, T3 m) { x += y; if (x >= m) x -= m; }\ntemplate<class T1, class T2, class T3> inline void submodfast(T1 &x, T2 y, T3 m) { x -= y; if (x < 0) x += m; }\n#if INTPTR_MAX == INT32_MAX or !defined(__SIZEOF_INT128__)\ninline ll mulmod(ll x, ll n, ll m){ ll r = 0; normmod(x, m); normmod(n, m); while (n) { if (n & 1) r += x; x += x; if (r >= m) r -= m; if (x >= m) x -= m; n /= 2; } return r; }\n#else\nusing int128 = __int128;\ninline ll mulmod(ll x, ll n, ll m){ return __int128(x) * n % m; }\n#endif\ninline ll powmod(ll x, ll n, ll m){ ll r = 1; normmod(x, m); while (n){ if (n & 1)r = (r*x) % m; x = (x*x) % m; n /= 2; }return r; }\ninline ll powmulmod(ll x, ll n, ll m) { ll res = 1; normmod(x, m); while (n){ if (n & 1)res = mulmod(res, x, m); x = mulmod(x, x, m); n /= 2; } return res; }\ntemplate<class T> inline T gcd(T a, T b) { while (b) { a %= b; T t = a; a = b; b = t; } return a; }\ninline ll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntemplate<class T> inline T gcd(T a, T b, T c){ return gcd(gcd(a, b), c); }\nll gcdex(ll a, ll b, ll& x, ll& y) {\n    if (!a) { x = 0; y = 1; return b; }\n    ll y1; ll d = gcdex(b % a, a, y, y1); x = y1 - (b / a) * y;\n    return d;\n}\ntemplate<class T> bool isPrime(T x) { if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n    for (T i = 5; i * i <= x; i += 6) if (x % i == 0 || x % (i + 2) == 0) return 0; return 1; }\nbool millerRabin(long long n) {\n    if (n <= 1000) return isPrime(n);\n    long long s = n - 1; int t = 0; while (s % 2 == 0) s /= 2, ++t;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) { if (!(a %= n)) return true;\n        long long f = powmulmod(a, s, n); if (f == 1 || f == n - 1) continue;\n        for (int i = 1; i < t; ++i) if ((f = mulmod(f, f, n)) == n - 1) goto nextp;\n        return false; nextp:;\n    } return true;\n}\n\n// Useful constants\n\n//int some_primes[7] = {24443, 100271, 1000003, 1000333, 5000321, 98765431, 1000000123};\n#define T9          1000000000\n#define T18         1000000000000000000LL\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define mod         1000000007\n#define EPS         (double)1e-10\n#define PI          3.14159265358979323846264\n#define link        asaxlajrewqwe\n#define rank        wahayawehasdakw\n//*************************************************************************************\n\nint32_t solve();\nint32_t main(int argc, char** argv) {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef LOCAL\n        FREIN(\"input.txt\");\n//        FREOUT(\"out.txt\");\n#endif\n    return solve();\n}\nint ap[101010];\nint seed;\nint rnd() {\n    int res = seed;\n    seed = (seed * 7LL + 13) % mod;\n    return res;\n}\nstruct Node {\n    ll same;\n};\nNode tr[404040];\nvoid build(int cur, int l, int r) {\n    if (l == r) {\n        tr[cur].same = ap[l];\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        build(dcur, l, m);\n        build(dcur + 1, m + 1, r);\n    }\n}\nvoid push(int cur, int l, int r) {\n    if (l == r) {\n        return;\n    }\n    if (tr[cur].same) {\n        for (int to : {cur + cur, cur + cur + 1}) {\n            tr[to].same = tr[cur].same;\n        }\n        tr[cur].same = 0;\n    }\n}\nvoid assign(int cur, int l, int r, int x, int y, int val) {\n    if (x > r || y < l) return;\n    if (x <= l && r <= y) {\n        tr[cur].same = val;\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        assign(dcur, l, m, x, y, val);\n        assign(dcur + 1, m + 1, r ,x, y, val);\n    }\n}\nvoid add(int cur, int l, int r, int x, int y, int val) {\n    if (x > r || y < l) return;\n    if (x <= l && r <= y && tr[cur].same) {\n        tr[cur].same += val;\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        add(dcur, l, m, x, y, val);\n        add(dcur + 1, m + 1, r ,x, y, val);\n    }\n}\nll getAns(int cur, int l, int r, int x, int y, int t, int p) {\n    if (x > r || y < l) return 0;\n    if (x <= l && r <= y && tr[cur].same) {\n        return powmod(tr[cur].same % p, t, p) * (r - l + 1LL) % p;\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        return (getAns(dcur, l, m, x, y, t, p) + getAns(dcur + 1, m + 1, r, x, y, t, p)) % p;\n    }\n    \n}\nvector<pair<ll, int>> st;\nvoid go(int cur, int l, int r, int x, int y) {\n    if (x > r || y < l) return;\n    if (tr[cur].same) {\n        st.push_back({tr[cur].same, min(r, y) - max(l, x) + 1});\n    } else {\n        int m = (l + r) / 2;\n        int dcur = cur + cur;\n        push(cur, l, r);\n        go(dcur, l, m, x, y);\n        go(dcur + 1, m + 1, r, x, y);\n    }\n}\n\n\nint solve() {\n    int n, m, v;\n    n = readInt();\n    m = readInt();\n    seed = readInt();\n    v = readInt();\n    FI(n) {\n        ap[i] = rnd() % v + 1;\n    }\n    build(1, 0, n - 1);\n    FI(m) {\n        int t = rnd() % 4 + 1;\n        int l = rnd() % n + 1;\n        int r = rnd() % n + 1;\n        if (l > r) {\n            swap(l, r);\n        }\n        int x, y = 0;\n        if (t == 3) {\n            x = rnd() % (r - l + 1) + 1;\n        } else {\n            x = rnd() % v + 1;\n        }\n        if (t == 4) {\n            y = rnd() % v + 1;\n        }\n        --l; --r;\n        if (t == 1) {\n            add(1, 0, n - 1, l, r, x);\n        } else if (t == 2) {\n            assign(1, 0, n - 1, l, r, x);\n        } else if (t == 3) {\n            st.clear();\n            go(1, 0, n - 1, l, r);\n            sort(all(st));\n            for (auto p : st) {\n                if (x <= p.second) {\n                    writeInt(p.first);\n                    break;\n                }\n                x -= p.second;\n            }\n        } else if (t == 4) {\n            auto res = getAns(1, 0, n - 1, l, r, x, y);\n            writeInt(res);\n        }\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Willem, Chtholly and Seniorious.json",
    "editorial_link": "https://codeforces.com//blog/entry/56135",
    "editorial": "This is an interesting algorithm which can easily deal with many data\r\nstructure problemsââif the data is random... I initially named it as\r\n\"Old Driver Tree\" ( Which is my codeforces ID ). (But now I call it\r\nChtholly TreeÂ ). We can find that there is an operation that makes a\r\nrange of number the same. We can use an interval tree (std::set is\r\nenough) to maintain every interval that consists of the same number. And\r\nfor operation , we destory all the intervals in range , and put in a new\r\ninterval into the interval tree. For operations , , , we can\r\nbrute-forcely walk on the tree, find every interval in range , and do\r\nthe required operation on it. Proof of time complexity: We suppose that\r\nwe have a randomly selected range now, and we randomly choose which\r\noperation it is, suppose that there are intervals in this range. 1/4\r\npossibility we use time to erase nodes. 2/4 possibility we use time to\r\nerase nothing. 1/4 possibility we use time to erase nothing and add 2\r\nnew nodes into the tree. So we are expected to use time to erase nodes.\r\nBy using interval tree to maintain, the time complexity of this problem\r\nis . If operation and are changed into output the sum of for every range\r\n, it seems that the time complexity may change into , but I do not know\r\nhow to prove it... Solution using map\r\n",
    "hint": []
}