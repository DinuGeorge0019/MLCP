{
    "link": "https://codeforces.com//contest/2023/problem/C",
    "problemId": "2964366",
    "problem_idx": "C",
    "shortId": "2023C",
    "contest_number": "2023",
    "problem_submissions": {
        "F": [
            287014608,
            287072234,
            299830672,
            287085195,
            287027962,
            287042299,
            287238133,
            287043650
        ],
        "E": [
            286990891,
            287003441,
            287204391,
            287202274,
            287014470,
            287010378,
            287009293,
            287034992,
            287190288,
            287004818,
            287142133
        ],
        "D": [
            286943910,
            286985197,
            287179114,
            287178062,
            286983477,
            286986708,
            286993474,
            286930212,
            286984453,
            286985894,
            286983025,
            286981875,
            287091406,
            286988866,
            286991623,
            286991730,
            286972363,
            290388826,
            290388744,
            286996161,
            286993279,
            287000155,
            287068676,
            287061033,
            286997472,
            287003784
        ],
        "C": [
            286925333,
            287063584,
            286928411,
            286930839,
            286944563,
            286945303,
            286973941,
            286936797,
            286923792,
            286935049,
            286934113,
            286960906,
            286944493,
            286935726,
            286931426,
            286988231,
            286961072,
            286929444,
            286959433,
            286973882,
            286960461
        ],
        "B": [
            286913842,
            286912400,
            286915696,
            286920706,
            286917936,
            286918820,
            286920898,
            286929873,
            286915247,
            286917134,
            286915488,
            286916176,
            286919025,
            286919305,
            286914068,
            286921817,
            286912738,
            286921828,
            286922164,
            286920262
        ],
        "A": [
            286905356,
            286905575,
            286907414,
            286907460,
            286908014,
            286911602,
            286910636,
            286905107,
            286906378,
            286906055,
            286906420,
            286919318,
            286909880,
            286905489,
            286910067,
            286910062,
            286905533,
            286909956,
            286907288,
            286911621
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "Consider a strongly connected graph in which the lengths of all cycles\r\nare multiples of . It can be observed that it is always possible to\r\ncolor this graph with colors in such a way that any edge connects a\r\nvertex of color to a vertex of color . It turns out that we can add\r\nedges to this graph only if they preserve the described color\r\ninvariant.Letâs make some colorings of the original graphs. With fixed\r\ncolorings, it is quite easy to check whether the required edges can be\r\nadded. To do this, we will create corresponding counting arrays for each\r\ncolor and each class of vertices, and then we will compare the elements\r\nof the arrays according to the criterion mentioned above. However, we\r\ncould have initially colored the second graph differently, for example,\r\nby adding to the color of each vertex modulo . It is not difficult to\r\nverify that all the values of the counting arrays for the second graph\r\nwould then shift by in a cycle. Similarly, depending on the coloring,\r\nall values could shift cyclically by an arbitrary amount. To solve this\r\nproblem, we will construct the initial arrays in such a way that, for\r\nfixed colorings, they need to be checked for equality. If equality is\r\nachieved for some coloring, it means that one array is a cyclic shift of\r\nthe other. This condition can be checked, for example, using the\r\nKnuth-Morris-Pratt algorithm.\r\n",
    "name": "C. C+K+S",
    "statement": "You are given two strongly connected^{\r\ndagger} directed graphs, each with exactly n vertices, but possibly\r\ndifferent numbers of edges. Upon closer inspection, you noticed an\r\nimportant feature the length of any cycle in these graphs is divisible\r\nby k.Each of the 2n vertices belongs to exactly one of two types: or .\r\nFor each vertex, its type is known to you.You need to determine whether\r\nit is possible to draw exactly n directed edges between the source\r\ngraphs such that the following four conditions are met: The ends of any\r\nadded edge lie in different graphs. From each outgoing vertex, exactly\r\none added edge originates. Into each incoming vertex, exactly one added\r\nedge enters. In the resulting graph, the length of any cycle is\r\ndivisible by k. ^{\r\ndagger}A strongly connected graph is a graph in which there is a path\r\nfrom every vertex to every other vertex.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long; void solve() {    int n, k;    std::cin >> n >> k;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }        std::vector<std::vector<std::array<int, 2>>> adj1(n);    int m1;    std::cin >> m1;    for (int i = 0; i < m1; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj1[u].push_back({v, 1});        adj1[v].push_back({u, k - 1});    }        std::vector<int> b(n);    for (int i = 0; i < n; i++) {        std::cin >> b[i];    }        std::vector<std::vector<std::array<int, 2>>> adj2(n);    int m2;    std::cin >> m2;    for (int i = 0; i < m2; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj2[u].push_back({v, 1});        adj2[v].push_back({u, k - 1});    }        std::vector<int> fa(n, -1), fb(n, -1);    std::queue<int> q;    q.push(0);    fa[0] = 0;    while (!q.empty()) {        int x = q.front();        q.pop();                for (auto [y, w] : adj1[x]) {            if (fa[y] == -1) {                fa[y] = (fa[x] + w) % k;                q.push(y);            }        }    }        q.push(0);    fb[0] = 0;    while (!q.empty()) {        int x = q.front();        q.pop();                for (auto [y, w] : adj2[x]) {            if (fb[y] == -1) {                fb[y] = (fb[x] + w) % k;                q.push(y);            }        }    }        int a0 = std::count(a.begin(), a.end(), 0);    int b1 = std::count(b.begin(), b.end(), 1);        if (a0 != b1) {        std::cout << \"NO\\n\";        return;    }        if (a0 == 0 || a0 == n) {        std::cout << \"YES\\n\";        return;    }        std::vector<i64> s(k), t(k);    for (int i = 0; i < n; i++) {        if (a[i] == 1) {            fa[i] = (fa[i] + 1) % k;            s[fa[i]] += n;        } else {            fa[i] = (fa[i] - 1 + k) % k;            s[fa[i]] += 1;        }        if (b[i] == 0) {            t[fb[i]] += n;        } else {            t[fb[i]] += 1;        }    }    s.push_back(-1);    s.insert(s.end(), t.begin(), t.end());    s.insert(s.end(), t.begin(), t.end());        std::vector<int> f(s.size() + 1);    for (int i = 1, j = 0; i < s.size(); i++) {        while (j && s[i] != s[j]) {            j = f[j];        }        j += (s[i] == s[j]);        if (j == k) {            std::cout << \"YES\\n\";            return;        }        f[i + 1] = j;    }    std::cout << \"NO\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);     int t;    std::cin >> t;     while (t--) {        solve();    }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "hashing",
        "implementation",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. C+K+S.json",
    "hint": []
}