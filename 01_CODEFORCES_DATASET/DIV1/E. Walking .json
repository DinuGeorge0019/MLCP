{"link": "https://codeforces.com//contest/578/problem/E", "problemId": "35420", "problem_idx": "E", "shortId": "578E", "contest_number": "578", "problem_submissions": {"D": [13043018, 13035846, 13036528, 13038587, 13044167, 13041175, 13037259, 13038897, 13041869, 13037673, 13043371, 13037414, 13050779, 13036416, 13040134, 13038396, 13039211], "E": [13038901, 13041994, 13043511, 13044723, 13047038, 13049049, 13049923, 13047637, 13049042, 13047937, 13049450, 13060851, 13041499, 13046763], "B": [13033269, 13029103, 13030026, 13030734, 13032310, 13031712, 13030424, 13048740, 13029417, 13030120, 13034104, 13030544, 13032556, 13030378, 13030241, 13028648, 13031292, 13033423], "C": [13032149, 13030512, 13032354, 13033188, 13037469, 13037436, 13032059, 13034534, 13040875, 13051722, 13037824, 13032969, 13057631, 13032320, 13033127, 13034805, 13035383, 13037049], "A": [13028273, 13027990, 13028573, 13030087, 13030676, 13029354, 13030453, 13032789, 13027838, 13031000, 13029241, 13029752, 13028730, 13028651, 13043323, 13029257, 13031415], "F": [13054189, 16905284, 13299937]}, "name": "E. Walking ", "statement": "There is a sand trail in front of Alice\u2019s home.In daytime, people walk\r\nover it and leave a footprint on the trail for their every single step.\r\nAlice cannot distinguish the order of the footprints, but she can tell\r\nwhether each footprint is made by left foot or right foot. Also she\u2019s\r\ncertain that all people are walking by alternating left foot and right\r\nfoot.For example, suppose that one person walked through the trail and\r\nleft some footprints. The footprints are in order along the trail (\u2019R\u2019\r\nmeans right foot and \u2019L\u2019 means left foot). You might think the outcome\r\nof the footprints is strange. But in fact, some steps are resulting from\r\nwalking backwards!There are some possible order of steps that produce\r\nthese footprints such as or (we suppose that the distance between two\r\nconsecutive steps can be arbitrarily long). The number of backward steps\r\nfrom above two examples are and separately.Alice is interested in these\r\nfootprints. Whenever there is a person walking trough the trail, she\r\ntakes a picture of all these footprints along the trail and erase all of\r\nthem so that next person will leave a new set of footprints. We know\r\nthat people walk by alternating right foot and left foot, but we don\u2019t\r\nknow if the first step is made by left foot or right foot.Alice wants to\r\nknow the minimum possible number of backward steps made by a person. But\r\nit\u2019s a little hard. Please help Alice to calculate it. You also need to\r\nconstruct one possible history of these footprints.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int N = 100100;\nstring s;\nint b[N];\nvector<int> a[N];\nvector<int> L, R;\nint sz;\nint n;\nvector<int> LL, LR, RL, RR;\n\nvoid print(int id)\n{\n    for (int x : a[id])\n        printf(\"%d \", x + 1);\n    return;\n}\n\nvoid printAnswer()\n{\n    if (RR.size() > LL.size())\n    {\n        for (int x : RL)\n            print(x);\n        for (int i = 0; i < (int)RR.size(); i++)\n        {\n            print(RR[i]);\n            if (i < (int)LL.size())\n                print(LL[i]);\n        }\n        for (int x : LR)\n            print(x);\n        printf(\"\\n\");\n        return;\n    }\n    if (RR.size() < LL.size())\n    {\n        for (int x : LR)\n            print(x);\n        for (int i = 0; i < (int)LL.size(); i++)\n        {\n            print(LL[i]);\n            if (i < (int)RR.size())\n                print(RR[i]);\n        }\n        for (int x : RL)\n            print(x);\n        printf(\"\\n\");\n        return;\n    }\n    if (!LL.empty())\n    {\n        for (int x : LR)\n            print(x);\n        print(LL[0]);\n        for (int x : RL)\n            print(x);\n        for (int i = 0; i < RR.size(); i++)\n        {\n            if (i != 0)\n                print(LL[i]);\n            print(RR[i]);\n        }\n        printf(\"\\n\");\n        return;\n    }\n    if (!RR.empty())\n    {\n        for (int x : RL)\n            print(x);\n        print(RR[0]);\n        for (int x : LR)\n            print(x);\n        for (int i = 0; i < LL.size(); i++)\n        {\n            if (i != 0)\n                print(RR[i]);\n            print(LL[i]);\n        }\n        printf(\"\\n\");\n        return;\n    }\n    throw;\n}\n\nint main()\n{\n    cin >> s;\n    n = (int)s.length();\n    sz = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] == 'L')\n        {\n            if (R.empty())\n            {\n                R.push_back(sz);\n                sz++;\n            }\n            int x = R.back();\n            R.pop_back();\n            a[x].push_back(i);\n            L.push_back(x);\n            b[i] = x;\n        }\n        else\n        {\n            if (L.empty())\n            {\n                L.push_back(sz);\n                sz++;\n            }\n            int x = L.back();\n            L.pop_back();\n            a[x].push_back(i);\n            R.push_back(x);\n            b[i] = x;\n        }\n    }\n    printf(\"%d\\n\", sz - 1);\n\n    for (int i = 0; i < sz; i++)\n    {\n        if (s[a[i][0]] == 'L')\n        {\n            if (s[a[i].back()] == 'L')\n                LL.push_back(i);\n            else\n                LR.push_back(i);\n        }\n        else\n        {\n            if (s[a[i].back()] == 'L')\n                RL.push_back(i);\n            else\n                RR.push_back(i);\n        }\n    }\n    if (LL.empty() && RR.empty())\n    {\n        if (LR.empty() || RL.empty())\n        {\n            for (int i = 0; i < sz; i++)\n                print(i);\n            printf(\"\\n\");\n            return 0;\n        }\n        if (s[n - 1] == 'L')\n        {\n            int x = b[n - 1];\n            a[x].pop_back();\n            int y = LR.back();\n            LR.pop_back();\n            a[y].push_back(n - 1);\n            LL.push_back(y);\n            RR.push_back(x);\n            for (int i = 0; i < (int)RL.size(); i++)\n            {\n                if (RL[i] == x)\n                {\n                    swap(RL[i], RL.back());\n                    RL.pop_back();\n                    break;\n                }\n            }\n        }\n        else\n        {\n            int x = b[n - 1];\n            a[x].pop_back();\n            int y = RL.back();\n            RL.pop_back();\n            a[y].push_back(n - 1);\n            RR.push_back(y);\n            LL.push_back(x);\n            for (int i = 0; i < (int)LR.size(); i++)\n            {\n                if (LR[i] == x)\n                {\n                    swap(LR[i], LR.back());\n                    LR.pop_back();\n                    break;\n                }\n            }\n        }\n    }\n\n    printAnswer();\n\n    return 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "2700", "interactive": false}