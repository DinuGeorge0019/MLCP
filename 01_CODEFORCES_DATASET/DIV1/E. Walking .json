{
    "link": "https://codeforces.com//contest/578/problem/E",
    "problemId": "35420",
    "problem_idx": "E",
    "shortId": "578E",
    "contest_number": "578",
    "problem_submissions": {
        "D": [
            13043018,
            13035846,
            13036528,
            13038587,
            13044167,
            13041175,
            13037259,
            13038897,
            13041869,
            13037673,
            13043371,
            13037414,
            13050779,
            13036416,
            13040134,
            13038396,
            13039211
        ],
        "E": [
            13038901,
            13041994,
            13043511,
            13044723,
            13047038,
            13049049,
            13049923,
            13047637,
            13049042,
            13047937,
            13049450,
            13060851,
            13041499,
            13046763
        ],
        "B": [
            13033269,
            13029103,
            13030026,
            13030734,
            13032310,
            13031712,
            13030424,
            13048740,
            13029417,
            13030120,
            13034104,
            13030544,
            13032556,
            13030378,
            13030241,
            13028648,
            13031292,
            13033423
        ],
        "C": [
            13032149,
            13030512,
            13032354,
            13033188,
            13037469,
            13037436,
            13032059,
            13034534,
            13040875,
            13051722,
            13037824,
            13032969,
            13057631,
            13032320,
            13033127,
            13034805,
            13035383,
            13037049
        ],
        "A": [
            13028273,
            13027990,
            13028573,
            13030087,
            13030676,
            13029354,
            13030453,
            13032789,
            13027838,
            13031000,
            13029241,
            13029752,
            13028730,
            13028651,
            13043323,
            13029257,
            13031415
        ],
        "F": [
            13054189,
            16905284,
            13299937
        ]
    },
    "name": "E. Walking ",
    "statement": "There is a sand trail in front of Alice’s home.In daytime, people walk\r\nover it and leave a footprint on the trail for their every single step.\r\nAlice cannot distinguish the order of the footprints, but she can tell\r\nwhether each footprint is made by left foot or right foot. Also she’s\r\ncertain that all people are walking by alternating left foot and right\r\nfoot.For example, suppose that one person walked through the trail and\r\nleft some footprints. The footprints are in order along the trail (’R’\r\nmeans right foot and ’L’ means left foot). You might think the outcome\r\nof the footprints is strange. But in fact, some steps are resulting from\r\nwalking backwards!There are some possible order of steps that produce\r\nthese footprints such as or (we suppose that the distance between two\r\nconsecutive steps can be arbitrarily long). The number of backward steps\r\nfrom above two examples are and separately.Alice is interested in these\r\nfootprints. Whenever there is a person walking trough the trail, she\r\ntakes a picture of all these footprints along the trail and erase all of\r\nthem so that next person will leave a new set of footprints. We know\r\nthat people walk by alternating right foot and left foot, but we don’t\r\nknow if the first step is made by left foot or right foot.Alice wants to\r\nknow the minimum possible number of backward steps made by a person. But\r\nit’s a little hard. Please help Alice to calculate it. You also need to\r\nconstruct one possible history of these footprints.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int N = 100100;\nstring s;\nint b[N];\nvector<int> a[N];\nvector<int> L, R;\nint sz;\nint n;\nvector<int> LL, LR, RL, RR;\n\nvoid print(int id)\n{\n    for (int x : a[id])\n        printf(\"%d \", x + 1);\n    return;\n}\n\nvoid printAnswer()\n{\n    if (RR.size() > LL.size())\n    {\n        for (int x : RL)\n            print(x);\n        for (int i = 0; i < (int)RR.size(); i++)\n        {\n            print(RR[i]);\n            if (i < (int)LL.size())\n                print(LL[i]);\n        }\n        for (int x : LR)\n            print(x);\n        printf(\"\\n\");\n        return;\n    }\n    if (RR.size() < LL.size())\n    {\n        for (int x : LR)\n            print(x);\n        for (int i = 0; i < (int)LL.size(); i++)\n        {\n            print(LL[i]);\n            if (i < (int)RR.size())\n                print(RR[i]);\n        }\n        for (int x : RL)\n            print(x);\n        printf(\"\\n\");\n        return;\n    }\n    if (!LL.empty())\n    {\n        for (int x : LR)\n            print(x);\n        print(LL[0]);\n        for (int x : RL)\n            print(x);\n        for (int i = 0; i < RR.size(); i++)\n        {\n            if (i != 0)\n                print(LL[i]);\n            print(RR[i]);\n        }\n        printf(\"\\n\");\n        return;\n    }\n    if (!RR.empty())\n    {\n        for (int x : RL)\n            print(x);\n        print(RR[0]);\n        for (int x : LR)\n            print(x);\n        for (int i = 0; i < LL.size(); i++)\n        {\n            if (i != 0)\n                print(RR[i]);\n            print(LL[i]);\n        }\n        printf(\"\\n\");\n        return;\n    }\n    throw;\n}\n\nint main()\n{\n    cin >> s;\n    n = (int)s.length();\n    sz = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (s[i] == 'L')\n        {\n            if (R.empty())\n            {\n                R.push_back(sz);\n                sz++;\n            }\n            int x = R.back();\n            R.pop_back();\n            a[x].push_back(i);\n            L.push_back(x);\n            b[i] = x;\n        }\n        else\n        {\n            if (L.empty())\n            {\n                L.push_back(sz);\n                sz++;\n            }\n            int x = L.back();\n            L.pop_back();\n            a[x].push_back(i);\n            R.push_back(x);\n            b[i] = x;\n        }\n    }\n    printf(\"%d\\n\", sz - 1);\n\n    for (int i = 0; i < sz; i++)\n    {\n        if (s[a[i][0]] == 'L')\n        {\n            if (s[a[i].back()] == 'L')\n                LL.push_back(i);\n            else\n                LR.push_back(i);\n        }\n        else\n        {\n            if (s[a[i].back()] == 'L')\n                RL.push_back(i);\n            else\n                RR.push_back(i);\n        }\n    }\n    if (LL.empty() && RR.empty())\n    {\n        if (LR.empty() || RL.empty())\n        {\n            for (int i = 0; i < sz; i++)\n                print(i);\n            printf(\"\\n\");\n            return 0;\n        }\n        if (s[n - 1] == 'L')\n        {\n            int x = b[n - 1];\n            a[x].pop_back();\n            int y = LR.back();\n            LR.pop_back();\n            a[y].push_back(n - 1);\n            LL.push_back(y);\n            RR.push_back(x);\n            for (int i = 0; i < (int)RL.size(); i++)\n            {\n                if (RL[i] == x)\n                {\n                    swap(RL[i], RL.back());\n                    RL.pop_back();\n                    break;\n                }\n            }\n        }\n        else\n        {\n            int x = b[n - 1];\n            a[x].pop_back();\n            int y = RL.back();\n            RL.pop_back();\n            a[y].push_back(n - 1);\n            RR.push_back(y);\n            LL.push_back(x);\n            for (int i = 0; i < (int)LR.size(); i++)\n            {\n                if (LR[i] == x)\n                {\n                    swap(LR[i], LR.back());\n                    LR.pop_back();\n                    break;\n                }\n            }\n        }\n    }\n\n    printAnswer();\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Walking .json",
    "editorial_link": "https://codeforces.com//blog/entry/20368",
    "editorial": "Since there is only one person, its not hard to show the difference between the number of left footprints and the number of right footprints is at most one.\n\nFor a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k?+?1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k?+?1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !\n\nNow we demostrate the process of combining those subsequences.\n\nWe only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).\n\nSuppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A?-?D)???1.\n\nWe can combine all RR, LL subsequeces in turn into one subsequenceswith at most A?+?D?-?1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.\n\nThen we can combine all RL subsequence into only one RL subsequence with at most A?-?1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.\n\nSo if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.\n\nNow we provide one possible greedy method:\n\nFirstly, we translate this problem to a maximum matching problem on bipartite graph as following:\n\nTake \"RLLRRL\" as example:\n\n   \n\nWe split each footprint into two vertices which on is in left part and another is in right part.\n\nIf two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints)  (value of matching).\n\nDue to the graphs produced by this problem is very special, we can solve this bipartite matching as following:\n\nIterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.\n\nIf we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.\n\nWhy the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<\n\nBy the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.",
    "hint": []
}