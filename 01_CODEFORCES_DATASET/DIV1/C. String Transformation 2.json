{
    "link": "https://codeforces.com//contest/1383/problem/C",
    "problemId": "681329",
    "problem_idx": "C",
    "shortId": "1383C",
    "contest_number": "1383",
    "problem_submissions": {
        "F": [
            87911622,
            87901413,
            87908295,
            87909079,
            87912863,
            87912844,
            87913228,
            87920937
        ],
        "C": [
            87903412,
            87908609,
            87920945,
            87921225,
            87936073,
            87936017,
            87923661,
            87919633,
            87920208,
            87928476,
            88561363,
            87907584
        ],
        "D": [
            87893217,
            87920512,
            87917720,
            87900472,
            88564499,
            87905800,
            87942673,
            87934937,
            87934603,
            87934354,
            87926585,
            87907511,
            87916069,
            87908438,
            87914997,
            87918050,
            87919666,
            87904890,
            87912187,
            87897729,
            87922544,
            87918917
        ],
        "E": [
            87883167,
            87893057,
            87896267,
            87890928,
            88564562,
            87897262,
            87898365,
            87901088,
            87901845,
            87906849,
            87898532,
            87900480,
            87902921,
            87905469,
            87912176,
            87897358,
            87922285,
            87909673,
            87899729,
            87921664
        ],
        "B": [
            87873092,
            87873731,
            87878338,
            87871770,
            88564467,
            87883802,
            87879305,
            87891950,
            87885163,
            87888568,
            87878119,
            87882001,
            87878631,
            87875818,
            87883310,
            87903746,
            87887725,
            87881741,
            87892008,
            87886946
        ],
        "A": [
            87871300,
            87878540,
            87872599,
            87873455,
            88564441,
            87872862,
            87887205,
            87872116,
            87872818,
            87877345,
            87871429,
            87873700,
            87872797,
            87871844,
            87872683,
            87874942,
            87874295,
            87872122,
            87878303,
            87875696
        ]
    },
    "name": "C. String Transformation 2",
    "statement": "Koa the Koala has two strings A and B of the same length n (|A|=|B|=n)\r\nconsisting of the first 20 lowercase English alphabet letters (ie. from\r\nto ).In one move Koa: selects some subset of positions p_1, p_2,\r\nldots, p_k (k\r\nge 1; 1\r\nle p_i\r\nle n; p_i\r\nneq p_j if i\r\nneq j) of A such that A_{p_1} = A_{p_2} =\r\nldots = A_{p_k} = x (ie. all letters on this positions are equal to some\r\nletter x). selects letter y (from the first 20 lowercase letters in\r\nEnglish alphabet). sets each letter in positions p_1, p_2,\r\nldots, p_k to letter y. More formally: for each i (1\r\nle i\r\nle k) Koa sets A_{p_i} = y. .Koa wants to know the smallest number of\r\nmoves she has to do to make strings equal to each other (A = B) or to\r\ndetermine that there is no way to make them equal. Help her!\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.07.2020 17:34:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int len;\n    cin >> len;\n    string a, b;\n    cin >> a >> b;\n    int n = 20;\n    dsu d(n);\n    for (int i = 0; i < len; i++) {\n      d.unite((int) (a[i] - 'a'), (int) (b[i] - 'a'));\n    }\n    vector<vector<int>> comps(n);\n    for (int i = 0; i < n; i++) {\n      comps[d.get(i)].push_back(i);\n    }\n    vector<int> mask_to(n);\n    for (int i = 0; i < len; i++) {\n      mask_to[(int) (b[i] - 'a')] |= (1 << ((int) (a[i] - 'a')));\n    }\n    int ans = 0;\n    for (auto& comp : comps) {\n      int cnt = (int) comp.size();\n      if (cnt == 0) {\n        continue;\n      }\n      vector<int> new_mask(cnt);\n      for (int i = 0; i < cnt; i++) {\n        for (int j = 0; j < cnt; j++) {\n          if (i == j) {\n            continue;\n          }\n          if (mask_to[comp[i]] & (1 << comp[j])) {\n            new_mask[i] |= (1 << j);\n          }\n        }\n      }\n      vector<int> dp(1 << cnt, 0);\n      dp[0] = 0;\n      for (int t = 0; t < (1 << cnt); t++) {\n        for (int i = 0; i < cnt; i++) {\n          if (t & (1 << i)) {\n            continue;\n          }\n          int ft = dp[t];\n          if ((new_mask[i] & t) == new_mask[i]) {\n            ft += 1;\n          }\n          dp[t | (1 << i)] = max(dp[t | (1 << i)], ft);\n        }\n      }\n//      debug(comp, dp.back());\n      ans += 2 * cnt - 1 - dp.back();\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. String Transformation 2.json",
    "editorial_link": "https://codeforces.com//blog/entry/80562",
    "editorial": "The only difference between this problem and the previous problem is\r\nthat the underlying graph might have cycles.Each weakly connected\r\ncomponent can be solved independently and the answer is where is the\r\nnumber of nodes in the component and is the size of the largest Directed\r\nAcyclic Graph.The largest directed acyclic graph can be computed using\r\ndynamic programming in .For every node store a mask with all nodes it\r\ncan reach directly. Then go through every possible mask from to and\r\ncheck whether this set of nodes is acyclic or not. It is acyclic if\r\nthere exists at least one node (the last node in one topological order)\r\nsuch that the set without this node is acyclic and this node doesn\u00e2\u0080\u0099t\r\nreach any other node in this set: is_dag[0] = 1for mask in 1..2^n-1 for\r\nu in mask: is_dag[mask] |= is_dag[mask ^ (1 u)] && ((mask & reach[u]) ==\r\n0))Proof by @eatmore:: Suppose that there is a weakly connected\r\ncomponent with vertices, and there is a solution with edges. Then, the\r\nsize of the largest DAG is at least . Proof: Let\u00e2\u0080\u0099s keep track of current\r\nweakly connected components. Also, in each of the components, let\u00e2\u0080\u0099s keep\r\ntrack of some DAG. Initially, each vertex is in a separate component,\r\nand each DAG consists of a single vertex. So, there are components, and\r\nthe total size of all DAGs is . Processing an edge : If and are in the\r\nsame component: if is in the DAG, remove it. Number of components is\r\nunchanged, the total size of all DAGs is decreased by at most 1. If and\r\nare in different components, join the components. Concatenate the DAGs\r\n(DAG of \u00e2\u0080\u0099s component comes before DAG of \u00e2\u0080\u0099s component). Number of\r\ncomponents decreases by , the total size of all DAGs is unchanged. At\r\nthe end, the number of components becomes , so edges are used to\r\ndecrease the number of components. The remaining edges could decrease\r\nthe size of DAGs, so the final size is at least . From we know that ,\r\nthen is minimized when the size of the final DAG is maximized.Time\r\ncomplexity: per test case\r\n"
}