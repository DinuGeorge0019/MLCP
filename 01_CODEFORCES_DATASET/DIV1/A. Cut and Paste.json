{"link": "https://codeforces.com//contest/1280/problem/A", "problemId": "495760", "problem_idx": "A", "shortId": "1280A", "contest_number": "1280", "problem_submissions": {"E": [66917544, 66918710, 66922267, 66921342, 66922263, 66926965, 66926660, 66927067, 66925334, 66928850, 66995264, 66984642, 66984352, 66984306, 66929552, 66927288, 66928819, 66918756, 67988551, 66935139, 67027185, 66930594], "D": [66910755, 66913056, 66911496, 66913696, 66913107, 66913708, 66913839, 66916865, 66916639, 66915491, 66986758, 66986656, 66986610, 66986506, 66986162, 66985974, 66985915, 66985866, 66985681, 66985603, 66985529, 66917639, 66918143, 66919046, 66912800, 66915483, 66915027, 67988467, 66920051, 66917432, 66918759, 66917692], "C": [66906002, 66909093, 66907333, 66908961, 66908129, 66909339, 66908240, 66909052, 66911854, 66908829, 66908393, 66909027, 66913164, 66908797, 66903678, 66908260, 67988454, 66908965, 66910137, 66910802, 66910959], "B": [66904540, 66906897, 66902891, 66906439, 66906232, 66906362, 66905756, 66906434, 66909740, 66905894, 66905319, 66906149, 66910474, 66930936, 66909557, 66906748, 67988445, 66907466, 66906183, 66908402, 66907579], "A": [66901496, 66903238, 66905004, 66902693, 66904062, 66902839, 66902110, 66903240, 66903755, 66903072, 66902272, 66903347, 66905647, 66902258, 66906539, 66904016, 67988407, 66934409, 66903855, 66903188, 66903009, 66902847], "F": [66936996, 66936445, 69949014, 71271095, 66930593, 67311416]}, "name": "A. Cut and Paste", "statement": "We start with a string s consisting only of the digits 1, 2, or 3. The\r\nlength of s is denoted by |s|. For each i from 1 to |s|, the i-th\r\ncharacter of s is denoted by s_i. There is one cursor. The cursor\u2019s\r\nlocation\r\nell is denoted by an integer in\r\n{0,\r\nldots, |s|\r\n}, with the following meaning: If\r\nell = 0, then the cursor is located before the first character of s. If\r\nell = |s|, then the cursor is located right after the last character of\r\ns. If 0 <\r\nell < |s|, then the cursor is located between s_\r\nell and s_{\r\nell+1}. We denote by s_\r\ntext{left} the string to the left of the cursor and s_\r\ntext{right} the string to the right of the cursor. We also have a string\r\nc, which we call our , which starts out as empty. There are three types\r\nof actions: . Move the cursor one step to the right. This increments\r\nell once. . Set c\r\nleftarrow s_\r\ntext{right}, then set s\r\nleftarrow s_\r\ntext{left}. . Append the value of c to the end of the string s. Note\r\nthat this doesn\u2019t modify c. The cursor initially starts at\r\nell = 0. Then, we perform the following procedure: Perform the Move\r\naction once. Perform the Cut action once. Perform the Paste action s_\r\nell times. If\r\nell = x, stop. Otherwise, return to step 1. You\u2019re given the initial\r\nstring s and the integer x. What is the length of s when the procedure\r\nstops? Since this value may be very large, only find it modulo 10^9 + 7.\r\nIt is guaranteed that\r\nell\r\nle |s| at any time.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<int(1e9)+7>;\n\nvoid solve(){\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tnum len = s.size();\n\tfor(int i = 0; i < n; i++){\n\t\tif(s.size() < n){\n\t\t\tstring g = s.substr(i+1);\n\t\t\tfor(int j = 0; j < s[i] - '1'; j++){\n\t\t\t\ts += g;\n\t\t\t}\n\t\t}\n\t\tlen = i + 1 + (len - (i + 1)) * (s[i] - '0');\n\t}\n\tcout << (int)len << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["implementation", "math"], "dificulty": "1700", "interactive": false}