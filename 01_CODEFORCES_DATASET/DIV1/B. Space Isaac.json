{"link": "https://codeforces.com//contest/1045/problem/B", "problemId": "223464", "problem_idx": "B", "shortId": "1045B", "contest_number": "1045", "problem_submissions": {"E": [43261410, 43577517], "J": [43258702, 43260133, 43575980, 43263093, 43266033], "A": [43255060, 43256216, 43263322, 43263783, 43258806, 43275613], "D": [43251490, 43264794, 43257475, 43253807, 43257410, 43253327, 43248880], "C": [43250229, 43244156, 43255852, 43252661, 43258515, 43251235, 43259397], "G": [43247867, 43248087, 43251069, 43250948, 43255077, 43249900, 43251360], "H": [43246289, 43252595, 43260022, 43258468, 43261064, 43264435, 43263084], "B": [43243648, 43248788, 43247063, 43264324, 43264189, 43246587, 43256450, 43248333, 43254638], "I": [43243009, 43244706, 43243112, 43242671, 43255452, 43243089, 43243594], "F": [43577952]}, "name": "B. Space Isaac", "statement": "Everybody seems to think that the Martians are green, but it turns out\r\nthey are metallic pink and fat. Ajs has two bags of distinct nonnegative\r\nintegers. The bags are disjoint, and the union of the sets of numbers in\r\nthe bags is\r\n{0,1, ,M-1\r\n}, for some positive integer M. Ajs draws a number from the first bag\r\nand a number from the second bag, and then sums them modulo M.What are\r\nthe residues modulo M that Ajs cannot obtain with this action?\r\n", "solutions": ["#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 410000;\nint n, m;\nint a[MAXN];\nint b[MAXN];\nint c[MAXN];\nint d[MAXN];\nint z1[MAXN];\nint z2[MAXN];\n\nvoid zf(int *a, int n, int *z) {\n\tint l = 0, r = 0;\n\tz[0] = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (i < r)\n\t\t\tz[i] = min(r - i, z[i - l]);\n\t\telse\n\t\t\tz[i] = 0;\n\t\twhile (i + z[i] < n && a[i + z[i]] == a[z[i]])\n\t\t\t++z[i];\n\t\tif (i + z[i] > r)\n\t\t\tr = i + z[i], l = i;\n\t}\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tll tmp = a[0];\n\tfor (int i = 0; i < n; ++i)\n\t\ta[i] -= tmp;\n\ta[n] = m;\n\tfor (int i = 0; i < n; ++i)\n\t\tb[i] = a[i + 1] - a[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = b[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tc[n + i] = b[n - 1 - i];\n\tzf(c, 2 * n, z1);\n\tfor (int i = 0; i < n; ++i)\n\t\td[i] = c[n + i];\n\tfor (int i = 0; i < n; ++i)\n\t\td[i + n] = c[i];\n\tzf(d, 2 * n, z2);\n\tvector<ll> ans;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (z1[n + n - i] >= i && z2[n + i] >= n - i)\n\t\t\tans.push_back((a[i] + 2 * tmp) % m);\n\t}\n\tsort(ans.begin(), ans.end());\n\tcout << ans.size() << \"\\n\";\n\tif (ans.size()) {\n\t\tfor (ll i: ans)\n\t\t\tcout << i << \" \";\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["hashing", "number theory"], "dificulty": "2400", "interactive": false}