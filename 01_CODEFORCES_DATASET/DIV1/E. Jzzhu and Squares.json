{
    "link": "https://codeforces.com//contest/449/problem/E",
    "problemId": "11569",
    "problem_idx": "E",
    "shortId": "449E",
    "contest_number": "449",
    "problem_submissions": {
        "E": [
            7172419,
            7172014,
            7174895,
            7169365,
            7240994,
            7177576,
            9954696,
            9954686
        ],
        "A": [
            7167638,
            7162064,
            7159189,
            7170577,
            7159566,
            7171912,
            7174755,
            7177754,
            7174429,
            7180997,
            7161684,
            7182849,
            7192923,
            7180517,
            7168378,
            7168819,
            7159358
        ],
        "C": [
            7166638,
            7168442,
            7168589,
            7167422,
            7169338,
            7166871,
            7167683,
            7167793,
            7161177,
            7181293,
            7173309,
            7170890,
            7173119,
            7170721,
            7171917,
            7171483,
            7167450,
            7178771,
            7171038
        ],
        "D": [
            7161895,
            7168837,
            7161219,
            7163790,
            7163207,
            7165070,
            7164972,
            7165472,
            7166314,
            7182041,
            7171873,
            7166502,
            7159887,
            7192953,
            7166535,
            7169239,
            7169537,
            7165449,
            7159363,
            7166505
        ],
        "B": [
            7159593,
            7164450,
            7164390,
            7162671,
            7166735,
            7162159,
            7160515,
            7161879,
            7168809,
            7176245,
            7164684,
            7165872,
            7161265,
            7163102,
            7161569,
            7175028,
            7162358,
            7183380
        ]
    },
    "name": "E. Jzzhu and Squares",
    "statement": "Jzzhu has two integers, and . He calls an integer point of a plane\r\nspecial if and . Jzzhu defines a unit square as a square with corners at\r\npoints , , , , where and are some integers.Letâ€™s look at all the squares\r\n(their sides not necessarily parallel to the coordinate axes) with\r\ncorners at the special points. For each such square Jzzhu paints a dot\r\nin every unit square that is fully inside it. After that some unit\r\nsquares can contain several dots. Now Jzzhu wonders, how many dots he\r\nhas painted on the plane. Find this number modulo .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64;\n\nint N, M;\ni64 tblX[1001001];\nint minp[1001001];\ni64 gs[1001001];\ni64 bsum[1001001];\n\ni64 bsums0[1001001];\ni64 bsums1[1001001];\ni64 bsums2[1001001];\n\ni64 linsum(i64 K)\n{\n\ti64 P = K, Q = K+1;\n\tif(P%2==0) P /= 2;\n\telse Q /= 2;\n\n\treturn (P * Q) % MOD;\n}\n\ni64 sqrsum(i64 K)\n{\n\ti64 ret = K;\n\tret = ret * (K+1) % MOD;\n\tret = ret * ((2*K+1) % MOD) % MOD;\n\n\treturn ret * ((MOD + 1) / 6) % MOD;\n}\n\nvoid erat()\n{\n\tfor(int i=0;i<=1000000;i++) minp[i] = -1;\n\tfor(int i=2;i<=1000000;i++) if(minp[i] == -1) {\n\t\tfor(int j=i;j<=1000000;j+=i) if(minp[j] == -1) minp[j] = i;\n\t}\n}\n\ni64 gcd(i64 a, i64 b)\n{\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\ni64 count(i64 a, i64 b)\n{\n\tif(min(N, M) <= a + b - 1) return 0;\n\ti64 pat = (i64)(N - (a + b - 1)) * (M - (a + b - 1)) % MOD;\n\n\ti64 ec = a*a + b*b - 2*(a+b) + 2*gcd(a, b);\n\tec %= MOD;\n\n\treturn pat * ec % MOD;\n}\n\nvoid calc_gs()\n{\n\tgs[1] = 1;\n\tfor(int i=2;i<=1000000;i++) {\n\t\tint p = i, q = i;\n\t\ti64 aux = 0;\n\t\tint ord = 0;\n\t\twhile(q % minp[i] == 0) {\n\t\t\t++ord;\n\t\t\tq /= minp[i];\n\t\t}\n\n\t\ti64 pow = 1;\n\t\tfor(int j=0;j<ord-1;j++) pow = (pow * minp[i]);\n\t\taux += pow * minp[i];\n\t\taux += pow * (minp[i]-1) * ord;\n\t\taux %= MOD;\n\n\t\taux = aux * gs[q] % MOD;\n\t\tgs[i] = aux;\n\n\t}\n}\n\nvoid calc_bsum()\n{\n\tbsum[0] = 0;\n\tfor(int i=1;i<=1000000;i++) {\n\t\ti64 tmp = sqrsum(i) + sqrsum(i-1) + 2 * MOD - (2 * i * (i64)i % MOD) + 2 * gs[i];\n\t\tbsum[i] = tmp % MOD;\n\t}\n}\n\nvoid totalize()\n{\n\tbsums0[0] = bsums1[0] = bsums2[0] = 0;\n\tfor(int i=1;i<=1000000;i++) {\n\t\tbsums0[i] = (bsums0[i-1] + bsum[i]) % MOD;\n\t\tbsums1[i] = (bsums1[i-1] + bsum[i] * i % MOD) % MOD;\n\t\tbsums2[i] = (bsums2[i-1] + bsum[i] * i % MOD * i % MOD) % MOD;\n\t}\n}\n\nint main()\n{\n\terat();\n\tcalc_gs();\n\tcalc_bsum();\n\ttotalize();\n\n\tint T;\n\tscanf(\"%d\", &T);\n\n\tfor(int i=0;i<T;i++) {\n\t\tscanf(\"%d%d\", &N, &M);\n\n\t\tif(N > M) swap(N, M);\n\n\t\ti64 ret = (i64)(N+1) * (M+1) % MOD * bsums0[N];\n\t\tret += MOD - ((i64)(N+M+2) * bsums1[N] % MOD);\n\t\tret += bsums2[N];\n\t\tret %= MOD;\n\n\t\tprintf(\"%d\\n\", (int) ret);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Jzzhu and Squares.json",
    "editorial_link": "https://codeforces.com//blog/entry/13112",
    "editorial": "Consider there is only one query. Let me descripe the picture above. A\r\ngrid-square can be exactly contained by a bigger square which coincide\r\nwith grid lines. Let be the length of a side of the bigger square. Let\r\nbe the minimum distance between a vertice of the grid-square and a\r\nvertice of the bigger square. Let be the number of cells which are fully\r\ncontained by the grid-square. We can divide a grid-square into four\r\nright triangles and a center square. For each right triangle, the number\r\nof cells which are crossed by an edge of the triangle is . Then, the\r\nnumber of cells which are fully contained by the triangle is . Firstly,\r\nwe enum from to . Then the task is to calculate . can be calculated by\r\nthe following steps: Enum all of the divisor of and the task is to\r\ncalculate the count of where . The count of where equals to . Finally, .\r\nIf there are multiple queries, we can calculate the prefix sum of , and\r\n, then we can answer each query in .\r\n",
    "hint": []
}