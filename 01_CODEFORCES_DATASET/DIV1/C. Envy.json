{"link": "https://codeforces.com//contest/891/problem/C", "problemId": "134542", "problem_idx": "C", "shortId": "891C", "contest_number": "891", "problem_submissions": {"D": [32405811, 32403732, 32402138, 32430714, 32405646], "B": [32397173, 32384884, 32383268, 32389067, 32402095, 32392144, 32390145, 32392706, 32386797, 32391950, 32394619, 32391275, 32387784, 32402908, 32394168, 32390852, 32393424, 32402498, 32390071, 32396268], "C": [32396218, 32388086, 32389360, 32395431, 32392168, 32396723, 32397239, 32390965, 32393675, 32398647, 32398521, 32396975, 32390007, 32404522, 32396953, 32387277, 32386884, 32403069], "A": [32391368, 32389450, 32385263, 32382597, 32388551, 32393309, 32385252, 32391318, 32384125, 32393321, 32386822, 32382673, 32385160, 32385074, 32382459, 32389480, 32400282, 32382452, 32383065], "E": [32389900, 32397841, 32401538, 32399718, 32400691, 32399515, 32401892, 32401660, 32405427, 32400764, 32394075, 32405328, 32405995, 32402118, 32511522, 32397327]}, "name": "C. Envy", "statement": "For a connected undirected weighted graph , MST (minimum spanning tree)\r\nis a subgraph of that contains all of \u2019s vertices, is a tree, and sum of\r\nits edges is minimum possible.You are given a graph . If you run a MST\r\nalgorithm on graph it would give you only one MST and it causes other\r\nedges to become jealous. You are given some queries, each query contains\r\na set of edges of graph , and you should determine whether there is a\r\nMST containing all these edges or not.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=501000;\n\nint n,m,u[N],v[N],w[N],f[N],p[N],mt[N],T,wa[N];\nint Q,k,id;\nvector<int> eg[N];\nvector<PII> qw[N];\n\nint find(int x) {\n\tif (f[x]!=x) return f[x]=find(f[x]); else return x;\n}\nint find2(int x) {\n\tif (mt[x]!=T) mt[x]=T,p[x]=f[x];\n\tif (p[x]!=x) return p[x]=find2(p[x]); else return x;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(\"%d%d%d\",u+i,v+i,w+i);\n\t\teg[w[i]].pb(i);\n\t}\n\trep(i,1,n+1) f[i]=i;\n\tscanf(\"%d\",&Q);\n\trep(i,0,Q) {\n\t\tscanf(\"%d\",&k);\n\t\trep(j,0,k) {\n\t\t\tscanf(\"%d\",&id);\n\t\t\t--id;\n\t\t\tqw[w[id]].pb(mp(i,id));\n\t\t}\n\t}\n\trep(i,1,500001) {\n\t\tsort(all(qw[i]));\n\t\trep(j,0,SZ(qw[i])) {\n\t\t\tint x=u[qw[i][j].se],y=v[qw[i][j].se];\n\t\t\tfind(x); find(y);\n\t\t}\n\t\trep(j,0,SZ(qw[i])) {\n\t\t\tif (j==0||qw[i][j].fi!=qw[i][j-1].fi) T++;\n\t\t\tint x=u[qw[i][j].se],y=v[qw[i][j].se];\n\t\t\tif (find2(x)==find2(y))\twa[qw[i][j].fi]=1;\n\t\t\tp[find2(x)]=find2(y);\n\t\t}\n\t\tfor (auto id:eg[i]) {\n\t\t\tint x=u[id],y=v[id];\n\t\t\tf[find(x)]=find(y);\n\t\t}\n\t}\n\trep(i,0,Q) puts(wa[i]?\"NO\":\"YES\");\n}\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "graphs"], "dificulty": "2300", "interactive": false}