{
    "link": "https://codeforces.com//contest/1817/problem/F",
    "problemId": "1897394",
    "problem_idx": "F",
    "shortId": "1817F",
    "contest_number": "1817",
    "problem_submissions": {
        "F": [
            204497444,
            204371393,
            203993098,
            203987643,
            204188728,
            204003142,
            203943098,
            204213507
        ],
        "D": [
            203955544,
            203961086,
            203937236,
            203945800,
            203945643,
            203942818,
            203943723,
            203947591,
            203989196,
            203948036,
            204052212,
            203947419,
            203952089,
            203947882,
            203954628
        ],
        "A": [
            203949751,
            203917796,
            203915319,
            203915702,
            203915256,
            203915135,
            203915119,
            203915216,
            203933837,
            203916532,
            203915895,
            203917033,
            203915580,
            203915390,
            203917321,
            203916497,
            203915656,
            203929967,
            203917829
        ],
        "E": [
            203947509,
            203943737,
            203948086,
            203949930,
            204001172,
            203962099,
            204158074,
            203951990,
            204009291,
            203987561,
            203984105,
            203980085,
            203953471,
            203990042,
            203976606,
            203976302,
            203953675,
            204066570,
            204065539,
            204106022
        ],
        "B": [
            203928063,
            203919631,
            203920186,
            203920581,
            203923300,
            203919216,
            203918930,
            203922691,
            203924157,
            203921090,
            203921763,
            203924664,
            203924354,
            203989898,
            203930016,
            203924048,
            203922828,
            203936658,
            203924723
        ],
        "C": [
            203916741,
            203929205,
            203922679,
            203923849,
            203928212,
            203926222,
            203931210,
            203933759,
            203932269,
            203931148,
            203930247,
            203931616,
            203931791,
            203922648,
            203924454,
            204016237,
            203932091,
            203930473,
            203925061,
            203933416
        ]
    },
    "name": "F. Entangled Substrings",
    "statement": "Quantum entanglement is when two particles link together in a certain\r\nway no matter how far apart they are in space.You are given a string s.\r\nA pair of its non-empty substrings (a, b) is called if there is a\r\n(possibly empty) link string c such that: Every occurrence of a in s is\r\nimmediately followed by cb; Every occurrence of b in s is immediately\r\npreceded by ac. In other words, a and b occur in s only as substrings of\r\nacb. Compute the total number of entangled pairs of substrings of s.A\r\nstring a is a substring of a string b if a can be obtained from b by the\r\ndeletion of several (possibly zero or all) characters from the beginning\r\nand several (possibly zero or all) characters from the end.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5+5;\nconst int K = 26;\n\nint child[N][K], lnk[N], len[N];\nint vtxs = 1, last = 0;\n\nvoid add(int c) {\n  int cur = vtxs++;\n  len[cur] = len[last]+1;\n  int p = last;\n  while (p != -1 && !child[p][c]) {\n    child[p][c] = cur;\n    p = lnk[p];\n  }\n  if (p == -1) lnk[cur] = 0;\n  else {\n    int q = child[p][c];\n    if (len[p]+1 == len[q]) lnk[cur] = q;\n    else {\n      int clone = vtxs++;\n      len[clone] = len[p]+1;\n      for (int i = 0; i < K; i++) child[clone][i] = child[q][i];\n      lnk[clone] = lnk[q];\n      while (p != -1 && child[p][c] == q) {\n        child[p][c] = clone;\n        p = lnk[p];\n      }\n      lnk[q] = lnk[cur] = clone;\n    }\n  }\n  last = cur;\n}\n\nbool terminal[N], is_root[N];\nint slope_delta[N], slope;\nlong long const_delta[N], constant, ans;\nvector<int> G[N];\n\nvoid dfs(int v, int dep = 0) {\n  slope += slope_delta[dep];\n  constant += const_delta[dep];\n  slope_delta[dep+len[lnk[v]]+1]++;\n  const_delta[dep+len[lnk[v]]+1] -= dep+len[lnk[v]];\n  ans += (1LL*slope*dep+constant)*(len[v]-len[lnk[v]]);\n  for (int u: G[v]) dfs(u, dep+1);\n  slope_delta[dep+len[lnk[v]]+1]--;\n  const_delta[dep+len[lnk[v]]+1] += dep+len[lnk[v]];\n  slope -= slope_delta[dep];\n  constant -= const_delta[dep];\n}\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  lnk[0] = -1;\n  string s;\n  cin >> s;\n  for (char c: s) add(c-'a');\n  for (int v = last; v != -1; v = lnk[v]) terminal[v] = 1;\n  for (int v = 0; v < vtxs; v++) {\n    if (terminal[v]) is_root[v] = 1;\n    else {\n      int c = -1;\n      for (int i = 0; i < K; i++) {\n        if (child[v][i]) {\n          if (c >= 0) c = -2;\n          else if (c == -1) c = i;\n        }\n      }\n      if (c >= 0) G[child[v][c]].push_back(v);\n      else is_root[v] = 1;\n    }\n  }\n  for (int v = 1; v < vtxs; v++) {\n    if (is_root[v] == 1) dfs(v);\n  }\n  cout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "string suffix structures",
        "strings"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Entangled Substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": ". For every substring of we can define the longest string such that only\r\noccurs in as a specific substring of . To find , we find the longest\r\nstrings and such that the occurrences of are always preceded by and\r\nalways succeeded by . Then, we can say that .If youâre familiar with\r\nsuffix structures you would recognize that in this terms, is the longest\r\nstring that belongs to the same state of the suffix automaton of as .\r\nKnowing that, how would we find ? When we add a new character at the end\r\nof a substring, we make a transition in the suffix automaton via this\r\ncharacter.Generally, if the state of the string has transitions via two\r\ndifferent characters, it would mean that the string is empty, as it\r\nmeans that different strings may succeed the occurrences of . Also, if\r\nthe state is terminal, it would mean that the last occurrence of is at\r\nthe suffix of and it can not be succeeded by any non-empty string. If\r\nthe state is not terminal, and its only transition is by a character ,\r\nit means that the string is always succeeded by .The facts above mean\r\nthat to find , we may start with the state of the suffix automaton that\r\ncorresponds to the string , and then, while the state is non-terminal,\r\nand it only has a single out-going transition, we move to a next state\r\nvia this transition. In the end, would be the longest string of the\r\nstate we ended up in.Now back to the problem. Note that if a string only\r\noccurs in as a substring of another string , it means that . In terms of\r\nthe strings , and from the statement it means that .Assume that we\r\ngrouped together the states of the suffix automaton that end up in the\r\nsame state if you follow unique out-going transitions from them until\r\nyou get into a state with two possible transitions, or a terminal state.\r\nEach group corresponds to a unique largest string such that any string\r\nthat belongs to any state from the group only occurs in as a specific\r\nsubstring of the largest string.Note that for strings that belong to the\r\nsame state of the suffix automaton, they also have the same string . The\r\nlength determines the unique position in which all the strings from the\r\nstate occur in the largest string as set of nested suffixes. So, for the\r\nlargest string , their right position of occurrences will be , and their\r\nlengths form the contiguous segment . Thus, the whole problem reduces\r\nfor each group of states to the following:We have a bunch of triplets .\r\nEach triple denotes a set of segments . You need to count the number of\r\nnon-overlapping pairs of segments. This can be done in with the help of\r\nsegment tree.. There is an alternative solution using suffix arrays\r\n(suggested by Dario).Let be the suffix array and be the longest common\r\nprefix of adjacent elements of the suffix array. We say that is good for\r\nlength if the positions are exactly the occurrences of a sub-string of\r\nlength . This is equivalent to and for all . There are at most good\r\nintervals (an interval is good if it is good for any length). Indeed\r\nthey are a subset of the sub-trees of the Cartesian tree of the array .\r\nNow we iterate over the good intervals. Let be a good intervals for the\r\nlengths . Consider a translation and check if by adding to all elements\r\none gets a good interval. This can be checked in . This check can be\r\ndone from to and one can stop as soon as a bad is found. If t is a good\r\ntranslation; then we can count in the corresponding good pairs of\r\nsub-strings . And this concludes the problem. It remains to perform\r\nquickly step 3. Given two good intervals we say that follows if\r\ncoincides with the array one obtains adding to all elements of . The\r\n\"following\" relationship creates a family of chains on the good\r\nintervals. One performs step 3 independently on the various chains.\r\n",
    "hint": []
}