{"link": "https://codeforces.com//contest/737/problem/F", "problemId": "81054", "problem_idx": "F", "shortId": "737F", "contest_number": "737", "problem_submissions": {"D": [22352998, 22361676, 22361660, 22352983, 22352295, 22352107, 22352670, 22355408, 22353859, 22355150, 22355124, 22355580, 22352603, 22354241, 22355135, 22367415, 22354851, 22353195, 22355191, 22354766, 22354567, 22355616, 22355720], "C": [22346894, 22348992, 22348428, 22346364, 22349019, 22347742, 22344273, 22349093, 22344153, 22348276, 22349914, 22349222, 22351285, 22350460, 22350277, 22351065, 22348263, 22347006, 22351260, 22349703], "B": [22345266, 22344047, 22346326, 22344623, 22347286, 22345951, 22346273, 22346654, 22345815, 22347161, 22347731, 22346343, 22348170, 22348193, 22348953, 22349108, 22345433, 22343951, 22343981, 22347679], "A": [22344335, 22346876, 22344812, 22348251, 22345241, 22344610, 22348244, 22344836, 22349514, 22345867, 22345524, 22349952, 22345718, 22346457, 22347708, 22346937, 22344148, 22348610, 22348383, 22345809], "F": [22363265, 22374526], "E": [22411333]}, "name": "F. Dirty plates", "statement": "After one of celebrations there is a stack of dirty plates in Nikita\u2019s\r\nkitchen. Nikita has to wash them and put into a dryer. In dryer, the\r\nplates should be also placed in a stack also, and the plates sizes\r\nshould increase down up. The sizes of all plates are distinct.Nikita has\r\nno so much free space, specifically, he has a place for only one more\r\nstack of plates. Therefore, he can perform only such two operations:\r\nTake any number of plates from to from the top of the dirty stack, wash\r\nthem and put them to the stack. Take any number of plates from to from\r\nthe top of the intermediate stack and put them to the stack in the\r\ndryer. Note that after performing each of the operations, the plates are\r\nput in the same order as they were before the operation.You are given\r\nthe sizes of the plates in the down up order in the dirty stack, and\r\nintegers and . All the sizes are distinct. Write a program that\r\ndetermines whether or not Nikita can put the plates in increasing down\r\nup order in the dryer. If he is able to do so, the program should find\r\nsome sequence of operations (not necessary optimal) to achieve it.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MAXN = 2100;\n\nint s0[MAXN];\nint s1[MAXN];\nint s2[MAXN];\nint pl[MAXN];\nint c0, c1, c2;\nvector<pair<int, int> > vv;\nint a, b;\nint n;\n\nvoid ex() {\n\tcout << \"NO\\n\";\n\texit(0);\n}\n\nvoid checks2() {\n\tfor (int i = 0; i < c2; ++i) {\n\t\tif (s2[i] != n - i - 1)\n\t\t\tex();\n\t}\n}\n\nvoid mv0(int x) {\n\tif (x == 0)\n\t\treturn;\n\tvv.push_back(make_pair(1, x));\n\tfor (int i = c0 - x; i < c0; ++i)\n\t\ts1[c1++] = s0[i], pl[s0[i]] = 1;\n\tc0 -= x;\n}\nvector<int> vp;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", s0 + i), --s0[i];\n\treverse(s0, s0 + n);\n\tc0 = n;\n\tc1 = 0;\n\tc2 = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (pl[i] == 2)\n\t\t\tcontinue;\n\t\tif (pl[i] == 1) {\n\t\t\tfor (int j = 0; j < c1; ++j) {\n\t\t\t\tif (s1[j] == i) {\n\t\t\t\t\tif (c1 - j > b)\n\t\t\t\t\t\tex();\n\t\t\t\t\tvv.push_back(make_pair(2, c1 - j));\n\t\t\t\t\tfor (int k = j; k < c1; ++k)\n\t\t\t\t\t\ts2[c2++] = s1[k], pl[s1[k]] = 2;;\n\t\t\t\t\tc1 = j;\n\t\t\t\t\tchecks2();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint pos = -1;\n\t\t\tfor (int j = 0; j < c0; ++j)\n\t\t\t\tif (s0[j] == i) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tint fl = 1;\n\t\t\twhile (fl) {\n\t\t\t\tfl = 0;\n\t\t\t\tint lst = -1;\n\t\t\t\tif (c1)\n\t\t\t\t\tlst = s1[c1 - 1];\n\t\t\t\tfor (int j = pos + 1; j < c0; ++j) {\n\t\t\t\t\tif (s0[j] == lst - 1) {\n\t\t\t\t\t\tif (c0 - j > a)\n\t\t\t\t\t\t\tex();\n\t\t\t\t\t\tvv.push_back(make_pair(1, c0 - j));\n\t\t\t\t\t\tfor (int k = j; k < c0; ++k)\n\t\t\t\t\t\t\ts1[c1++] = s0[k], pl[s0[k]] = 1;\n\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t\tc0 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mx = -1;\n\t\t\tfor (int j = 0; j < c1; ++j)\n\t\t\t\tmx = max(mx, s1[j]);\n\t\t\tint mn = n;\n\t\t\tfor (int j = pos; j < c0; ++j)\n\t\t\t\tmn = min(mn, s0[j]);\n\t\t\tif (mn < mx)\n\t\t\t\tex();\n\t\t\tfor (int j = c0 - 1; j > pos; --j) {\n\t\t\t\tif (j == pos + 1 || s0[j] < s0[j - 1] - 1) {\n\t\t\t\t\tvp.clear();\n\t\t\t\t\tfor (int k = c0 - 1; k >= j; --k)\n\t\t\t\t\t\tif (k == c0 - 1 || s0[k + 1] > s0[k])\n\t\t\t\t\t\t\tvp.push_back(k);\n\t\t\t\t\tvp.push_back(j - 1);\n\t\t\t\t\tif ((int)vp.size() == 2) {\n\t\t\t\t\t\tint nd = c0 - j;\n\t\t\t\t\t\twhile (nd) {\n\t\t\t\t\t\t\tint go = min(min(a, b), nd);\n\t\t\t\t\t\t\tmv0(go);\n\t\t\t\t\t\t\tnd -= go;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)vp.size() == 3 && s0[vp[0]] - 1 == s0[j]) {\n\t\t\t\t\t\tint len = c0 - j;\n\t\t\t\t\t\tint l2 = vp[0] - vp[1];\n\t\t\t\t\t\tif (l2 <= a && len - l2 <= a && len <= b) {\n\t\t\t\t\t\t\tmv0(l2);\n\t\t\t\t\t\t\tmv0(len - l2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint fl = 0;\n\t\t\t\t\t\tfor (int k = 0; k < len; ++k) {\n\t\t\t\t\t\t\tif (k <= a && (len - k) <= a && abs(k - l2) <= b && len - abs(k - l2) <= b) {\n\t\t\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t\t\t\tmv0(k);\n\t\t\t\t\t\t\t\tmv0(len - k);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fl)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < (int)vp.size() - 1; ++k) {\n\t\t\t\t\t\tif (vp[k] - vp[k + 1] > a)\n\t\t\t\t\t\t\tex();\n\t\t\t\t\t}\n\t\t\t\t\tint fl = 0;\n\t\t\t\t\tfor (int k = 0; k < (int)vp.size() - 2; ++k) {\n\t\t\t\t\t\tif (s0[vp[k]] - 1 != s0[vp[k + 2] + 1]) {\n\t\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!fl && c0 - j <= b) {\n\t\t\t\t\t\tfor (int k = 0; k < (int)vp.size() - 1; ++k)\n\t\t\t\t\t\t\tmv0(vp[k] - vp[k + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (c0 - j > a)\n\t\t\t\t\t\t\tex();\n\t\t\t\t\t\tmv0(c0 - j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmv0(1);\n\t\t\tvv.push_back(make_pair(2, 1));\n\t\t\ts2[c2++] = s1[c1 - 1];\n\t\t\tpl[s1[c1 - 1]] = 2;\n\t\t\t--c1;\n\t\t}\n\n\t}\n\tcout << \"YES\\n\";\n\tcout << vv.size() << \"\\n\";\n\tfor (int i = 0; i < (int)vv.size(); ++i) {\n\t\tcout << vv[i].first << \" \" << vv[i].second << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "3300", "interactive": false}