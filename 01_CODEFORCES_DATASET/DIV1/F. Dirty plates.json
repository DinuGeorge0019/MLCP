{
    "link": "https://codeforces.com//contest/737/problem/F",
    "problemId": "81054",
    "problem_idx": "F",
    "shortId": "737F",
    "contest_number": "737",
    "problem_submissions": {
        "D": [
            22352998,
            22361676,
            22361660,
            22352983,
            22352295,
            22352107,
            22352670,
            22355408,
            22353859,
            22355150,
            22355124,
            22355580,
            22352603,
            22354241,
            22355135,
            22367415,
            22354851,
            22353195,
            22355191,
            22354766,
            22354567,
            22355616,
            22355720
        ],
        "C": [
            22346894,
            22348992,
            22348428,
            22346364,
            22349019,
            22347742,
            22344273,
            22349093,
            22344153,
            22348276,
            22349914,
            22349222,
            22351285,
            22350460,
            22350277,
            22351065,
            22348263,
            22347006,
            22351260,
            22349703
        ],
        "B": [
            22345266,
            22344047,
            22346326,
            22344623,
            22347286,
            22345951,
            22346273,
            22346654,
            22345815,
            22347161,
            22347731,
            22346343,
            22348170,
            22348193,
            22348953,
            22349108,
            22345433,
            22343951,
            22343981,
            22347679
        ],
        "A": [
            22344335,
            22346876,
            22344812,
            22348251,
            22345241,
            22344610,
            22348244,
            22344836,
            22349514,
            22345867,
            22345524,
            22349952,
            22345718,
            22346457,
            22347708,
            22346937,
            22344148,
            22348610,
            22348383,
            22345809
        ],
        "F": [
            22363265,
            22374526
        ],
        "E": [
            22411333
        ]
    },
    "name": "F. Dirty plates",
    "statement": "After one of celebrations there is a stack of dirty plates in Nikita\u2019s\r\nkitchen. Nikita has to wash them and put into a dryer. In dryer, the\r\nplates should be also placed in a stack also, and the plates sizes\r\nshould increase down up. The sizes of all plates are distinct.Nikita has\r\nno so much free space, specifically, he has a place for only one more\r\nstack of plates. Therefore, he can perform only such two operations:\r\nTake any number of plates from to from the top of the dirty stack, wash\r\nthem and put them to the stack. Take any number of plates from to from\r\nthe top of the intermediate stack and put them to the stack in the\r\ndryer. Note that after performing each of the operations, the plates are\r\nput in the same order as they were before the operation.You are given\r\nthe sizes of the plates in the down up order in the dirty stack, and\r\nintegers and . All the sizes are distinct. Write a program that\r\ndetermines whether or not Nikita can put the plates in increasing down\r\nup order in the dryer. If he is able to do so, the program should find\r\nsome sequence of operations (not necessary optimal) to achieve it.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MAXN = 2100;\n\nint s0[MAXN];\nint s1[MAXN];\nint s2[MAXN];\nint pl[MAXN];\nint c0, c1, c2;\nvector<pair<int, int> > vv;\nint a, b;\nint n;\n\nvoid ex() {\n\tcout << \"NO\\n\";\n\texit(0);\n}\n\nvoid checks2() {\n\tfor (int i = 0; i < c2; ++i) {\n\t\tif (s2[i] != n - i - 1)\n\t\t\tex();\n\t}\n}\n\nvoid mv0(int x) {\n\tif (x == 0)\n\t\treturn;\n\tvv.push_back(make_pair(1, x));\n\tfor (int i = c0 - x; i < c0; ++i)\n\t\ts1[c1++] = s0[i], pl[s0[i]] = 1;\n\tc0 -= x;\n}\nvector<int> vp;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", s0 + i), --s0[i];\n\treverse(s0, s0 + n);\n\tc0 = n;\n\tc1 = 0;\n\tc2 = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif (pl[i] == 2)\n\t\t\tcontinue;\n\t\tif (pl[i] == 1) {\n\t\t\tfor (int j = 0; j < c1; ++j) {\n\t\t\t\tif (s1[j] == i) {\n\t\t\t\t\tif (c1 - j > b)\n\t\t\t\t\t\tex();\n\t\t\t\t\tvv.push_back(make_pair(2, c1 - j));\n\t\t\t\t\tfor (int k = j; k < c1; ++k)\n\t\t\t\t\t\ts2[c2++] = s1[k], pl[s1[k]] = 2;;\n\t\t\t\t\tc1 = j;\n\t\t\t\t\tchecks2();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint pos = -1;\n\t\t\tfor (int j = 0; j < c0; ++j)\n\t\t\t\tif (s0[j] == i) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tint fl = 1;\n\t\t\twhile (fl) {\n\t\t\t\tfl = 0;\n\t\t\t\tint lst = -1;\n\t\t\t\tif (c1)\n\t\t\t\t\tlst = s1[c1 - 1];\n\t\t\t\tfor (int j = pos + 1; j < c0; ++j) {\n\t\t\t\t\tif (s0[j] == lst - 1) {\n\t\t\t\t\t\tif (c0 - j > a)\n\t\t\t\t\t\t\tex();\n\t\t\t\t\t\tvv.push_back(make_pair(1, c0 - j));\n\t\t\t\t\t\tfor (int k = j; k < c0; ++k)\n\t\t\t\t\t\t\ts1[c1++] = s0[k], pl[s0[k]] = 1;\n\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t\tc0 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mx = -1;\n\t\t\tfor (int j = 0; j < c1; ++j)\n\t\t\t\tmx = max(mx, s1[j]);\n\t\t\tint mn = n;\n\t\t\tfor (int j = pos; j < c0; ++j)\n\t\t\t\tmn = min(mn, s0[j]);\n\t\t\tif (mn < mx)\n\t\t\t\tex();\n\t\t\tfor (int j = c0 - 1; j > pos; --j) {\n\t\t\t\tif (j == pos + 1 || s0[j] < s0[j - 1] - 1) {\n\t\t\t\t\tvp.clear();\n\t\t\t\t\tfor (int k = c0 - 1; k >= j; --k)\n\t\t\t\t\t\tif (k == c0 - 1 || s0[k + 1] > s0[k])\n\t\t\t\t\t\t\tvp.push_back(k);\n\t\t\t\t\tvp.push_back(j - 1);\n\t\t\t\t\tif ((int)vp.size() == 2) {\n\t\t\t\t\t\tint nd = c0 - j;\n\t\t\t\t\t\twhile (nd) {\n\t\t\t\t\t\t\tint go = min(min(a, b), nd);\n\t\t\t\t\t\t\tmv0(go);\n\t\t\t\t\t\t\tnd -= go;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)vp.size() == 3 && s0[vp[0]] - 1 == s0[j]) {\n\t\t\t\t\t\tint len = c0 - j;\n\t\t\t\t\t\tint l2 = vp[0] - vp[1];\n\t\t\t\t\t\tif (l2 <= a && len - l2 <= a && len <= b) {\n\t\t\t\t\t\t\tmv0(l2);\n\t\t\t\t\t\t\tmv0(len - l2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint fl = 0;\n\t\t\t\t\t\tfor (int k = 0; k < len; ++k) {\n\t\t\t\t\t\t\tif (k <= a && (len - k) <= a && abs(k - l2) <= b && len - abs(k - l2) <= b) {\n\t\t\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t\t\t\tmv0(k);\n\t\t\t\t\t\t\t\tmv0(len - k);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fl)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < (int)vp.size() - 1; ++k) {\n\t\t\t\t\t\tif (vp[k] - vp[k + 1] > a)\n\t\t\t\t\t\t\tex();\n\t\t\t\t\t}\n\t\t\t\t\tint fl = 0;\n\t\t\t\t\tfor (int k = 0; k < (int)vp.size() - 2; ++k) {\n\t\t\t\t\t\tif (s0[vp[k]] - 1 != s0[vp[k + 2] + 1]) {\n\t\t\t\t\t\t\tfl = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!fl && c0 - j <= b) {\n\t\t\t\t\t\tfor (int k = 0; k < (int)vp.size() - 1; ++k)\n\t\t\t\t\t\t\tmv0(vp[k] - vp[k + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (c0 - j > a)\n\t\t\t\t\t\t\tex();\n\t\t\t\t\t\tmv0(c0 - j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmv0(1);\n\t\t\tvv.push_back(make_pair(2, 1));\n\t\t\ts2[c2++] = s1[c1 - 1];\n\t\t\tpl[s1[c1 - 1]] = 2;\n\t\t\t--c1;\n\t\t}\n\n\t}\n\tcout << \"YES\\n\";\n\tcout << vv.size() << \"\\n\";\n\tfor (int i = 0; i < (int)vv.size(); ++i) {\n\t\tcout << vv[i].first << \" \" << vv[i].second << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Dirty plates.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "At first we wil try to solve the problem without taking the restrictions\r\nplaced on and into consideration. If we can\u00e2\u0080\u0099t solve the new problem, we\r\nsurely can\u00e2\u0080\u0099t solve the original one with the restrictions on .Let\u00e2\u0080\u0099s\r\nexamine the operations we can and can\u00e2\u0080\u0099t do. It\u00e2\u0080\u0099s easy to understand that\r\nwe can\u00e2\u0080\u0099t place any plates into the dryer which wouldn\u00e2\u0080\u0099t fit the\r\nsequence, because they can\u00e2\u0080\u0099t be removed from that stack. It is also\r\nclear that if we are able to take a sequence of plates from the top of\r\nthe intermediate stack onto the top of the dryer stack and they would\r\nfit the proper sequence in the dryer stack, it can be done immediately.\r\nThis statement is also right for the top of dirty stack, but it would\r\ntake two operations for the plates to end up in the drier. Alos, it\u00e2\u0080\u0099s\r\neasy to notice a situation which makes it impossible to reach the\r\nanswer: if there is a plate with the size right above the plate with the\r\nsize in the intermediate stack, and . Indeed, no sequence of operations\r\nwill allow us to insert the missing plates in between them. Let\u00e2\u0080\u0099s call\r\nthe state of the stacks a if this situation happens.Let\u00e2\u0080\u0099s call the\r\noperation which moves the plates into the dryer in the right sequence an\r\n. Because the can be done at any moment, let\u00e2\u0080\u0099s check the possibility of\r\nthe when we finish performing any operation and perform the whenever we\r\ncan. In the following paragraphs, we will examine the situations where\r\nthe is impossible. Let\u00e2\u0080\u0099s call the sequence of the plates an sequence if\r\nit consists of one or more sections and in every section the sizes of\r\nthe plates are consecutive natural numbers, and all plates in the\r\nfollowing sections are smaller than in the previous ones. To describe it\r\nin another way, this is how an sequence looks like: , where , and so on.\r\nLet\u00e2\u0080\u0099s examine the maximum sequence on the top of the dirty stack. It\u00e2\u0080\u0099s\r\neasy to see that before we move all plates from that sequence to the\r\nintermediate stack the operation which moves a plate that does not\r\nbelong to that sequence to the intermediate stack would create a ,\r\nbecause the size of the last plate in this sequence is at least less\r\nthan the size of the next plate. It\u00e2\u0080\u0099s also clear that we can\u00e2\u0080\u0099t perform\r\nan before moving all of the sequence into the intermediate stack. This\r\nmeans that the only actions we can perform will lead to all of the\r\nplates of this sequence ending up in the intermediate stack, but the\r\nquestion is in the order in which they will be placed. There are two\r\ncases possible: The sizes of the plates in this sequence form an\r\ncontinious segment of the natural number sequence, which means that ,\r\nand so on. In this situation we can move sections one-by-one onto the\r\nintermediate stack to be able to move all of it to the dryer later at\r\nonce. It\u00e2\u0080\u0099s obvious that there wouldn\u00e2\u0080\u0099t be a inside of the sequence. If\r\nthe situation happened on a junction with the lower plates in this\r\nstack, it would have happened no matter the way we move the sequence. A\r\nsimiliar statement can be said about the junction with the plates that\r\nwould later appear on the top of this sequence. This means that our way\r\nof moving plates is optimal, therefore let\u00e2\u0080\u0099s perform it. There are holes\r\nin the set of plate sizes in the sequence. Then we can notice that if we\r\nwon\u00e2\u0080\u0099t move the sequence to the intermediate stack with one operation, we\r\nwill arrive at the if we try to move this sequence with any other set of\r\noperations. This can be shown more formally by assuming we moved a part\r\nof sequence that was higher than hole below it or vice-versa, the part\r\nthat was below the hole above it. In this situation, we have no choice\r\nbut to move a sequence as a whole. We found an optimal operation for\r\nevery situation and that means we can solve the problem with by\r\nmodelling an optimal turn by using time, or if we want so. If all plates\r\nend up in the dryer, our order of operations is the solution, otherwise\r\nthere\u00e2\u0080\u0099s no solution.Let\u00e2\u0080\u0099s now discuss how to incorporate our solution\r\nfor to our problem with finite and . The from the dirty stack can still\r\nbe performed by moving plates one-by-one to the intermediate stack and\r\nthen moving them from the intermediate stack one-by-one. from the\r\nintermediate stack isn\u00e2\u0080\u0099t always possible, and because of this you have\r\nto keep an eye on the size of the sections in the intermediate stack.\r\nHowever, if an exists that is possible to perform, we must perform it,\r\nand if it isn\u00e2\u0080\u0099t possible, we won\u00e2\u0080\u0099t be able to put the plates into the\r\ncorrect order. Due to this we assume that all possible are done. Again\r\nwe will examine the maximum sequence on the top of the dirty stack and\r\nthere are again two similiar cases:: If holes exist, the only possible\r\noperation, as discussed earlier, is to move the whole sequence. If the\r\nlength of this sequence exceeds , we have no way to place the plates in\r\nthe right order at all. If there are no holes , there are several\r\npossibilities. The length of the sections is now important and that\r\nmeans it isn\u00e2\u0080\u0099t always optimal to put the plates into the ascending\r\norder. Let\u00e2\u0080\u0099s consider several cases: If and are big enough to be able to\r\ndo the same operations with it as if they were infinite. Then we need to\r\ndo it because if any other section would join this one from above or\r\nbelow this would be the only situation that wouldn\u00e2\u0080\u0099t be a . Otherwise we\r\nwould be able to this sequence by using a single operation, and because\r\nof the fact that its size does not exceed it would be a possible and\r\noptimal operation. In any other situation we have to move this sequence\r\nto the intermediate stack in some other way. Let\u00e2\u0080\u0099s consider the case\r\nwhere the length of the sequence exceeds . There are several cases: If\r\nthe sequence consists of a lone section, we need to move it so the sizes\r\nof plates in the section would form a descending sequence in the\r\nintermediate stack by moving the plates one-by-one. Indeed, there\u00e2\u0080\u0099s no\r\nway to make the smallest plate the top one or to make the biggest plate\r\nthe bottom one (it would allow our sequence to join other blocks)\r\nwithout meeting a or making a section with its length bigger than , so\r\nit\u00e2\u0080\u0099s optimal to make all sections as short as possible (length ) so we\r\nwould certainly be able to them. In the case of the sequence having more\r\nthan two sections, the only way to move them without creating a is to\r\nmove the section as a whole. If it\u00e2\u0080\u0099s impossible, there\u00e2\u0080\u0099s no solution.\r\nThe only case left here is the case of the sequence consisting of two\r\nsections. There are only two ways to move those sections without meeting\r\na we either move the part of the top section and then we move everything\r\nelse, or we move the first section and the part of the second and then\r\nwe move the remaining part of the second section. We have to make the\r\nlength of the parts we move to be no more than and the length of the\r\nresulting sections to be no more than . It\u00e2\u0080\u0099s easy to write the\r\ninequalities which describe whether these operations are possible. It\u00e2\u0080\u0099s\r\nalso easy to check that we can\u00e2\u0080\u0099t make the smallest plate the top one or\r\nto make the biggest plate the bottom one and that means our sections\r\nwouldn\u00e2\u0080\u0099t join any other sections. Because of this, any sequence of moves\r\nwhich satisfies the inequalities would suit us. Let\u00e2\u0080\u0099s now assume that is\r\nlarge enough to move the whole sequence at once, but is smaller than the\r\nsize of a particular section and so we are unable to sort the sequence\r\ninto the ascending order. If there is only one section, we can just move\r\nthem one-by-one as discussed earlier. If there are more than two\r\nsections, we are unable to move them without meeting a If there are two\r\nsections, the situation is similiar to the situation where we couldn\u00e2\u0080\u0099t\r\nperform our operations due to being too small, although we don\u00e2\u0080\u0099t have to\r\nlimit the length of the section after moving our plates to the\r\nintermediate stack (because it would be less than ). As we can see,\r\nthere\u00e2\u0080\u0099s an optimal operation on an every step. The solution is to model\r\nthe optimal operations. A program that would solve this problem in time\r\ncould be written, but the constraints were set which allowed to write\r\nthe solution which would run in time so as not to complicate matters\r\nwith extra operations.\r\n"
}