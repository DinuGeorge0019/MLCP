{
    "link": "https://codeforces.com//contest/444/problem/D",
    "problemId": "11253",
    "problem_idx": "D",
    "shortId": "444D",
    "contest_number": "444",
    "problem_submissions": {
        "B": [
            7031130,
            7030965,
            7024958,
            7024676,
            7030446,
            7027559,
            7026989,
            7029436,
            7032613,
            7026604,
            7041433,
            7024980
        ],
        "C": [
            7029407,
            7026783,
            7028625,
            7029070,
            7027854,
            7035787,
            7035783,
            7031351,
            7029689,
            7028909,
            7032738,
            7033609,
            7027863,
            7030366,
            7026206,
            7047158,
            7029026,
            7027864
        ],
        "A": [
            7026572,
            7023113,
            7022682,
            7021917,
            7022193,
            7021891,
            7023277,
            7021994,
            7023490,
            7022290,
            7021818,
            7029841,
            7024232,
            7028150,
            7022608,
            7022804
        ],
        "E": [
            7025382,
            7029973,
            7031979,
            7031957,
            7039984,
            7039647,
            7030433,
            7029905,
            7030939,
            7032469,
            7032562,
            7035736,
            7041366,
            7041365,
            7041358,
            7041326,
            7036608
        ],
        "D": [
            7030340,
            7032449,
            7029379,
            7031920,
            7032235,
            7032726,
            7027353,
            7024739,
            7032806,
            7032764,
            7032749,
            7032739,
            7032700,
            7031354,
            7029340,
            7031710,
            7032104
        ]
    },
    "name": "D. DZY Loves Strings",
    "statement": "In China, many people like to use strings containing their names’\r\ninitials, for example: , , , .Once DZY found a lucky string . A lot of\r\npairs of good friends came to DZY when they heard about the news. The\r\nfirst member of the -th pair has name , the second one has name . Each\r\npair wondered if there is a substring of the lucky string containing\r\nboth of their names. If so, they want to find the one with minimum\r\nlength, which can give them good luck and make their friendship last\r\nforever.Please help DZY for each pair find the minimum length of the\r\nsubstring of that contains both and , or point out that such substring\r\ndoesn’t exist.A substring of is a string for some integers . The length\r\nof such the substring is .A string contains some another string if there\r\nis a substring of equal to .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define repi(i, a) for(typeof((a).begin()) i = (a).begin(), _##i = (a).end(); i != _##i; ++i)\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100100;\nconst int MAXP = 1000100;\n\nint A[MAXN];\nint B[MAXN];\n\nvector<int> occ[MAXP];\n\nint Q;\nchar str[MAXN];\nchar a[MAXN], b[MAXN];\n\nmap<pii, int> dp;\n\nint conv(char *s, int l) {\n  int ret = 0;\n  for(int i = 0; i < l; ++i) {\n    ret = ret * 27 + s[i] - 'a' + 1;\n  }\n\n  return ret;\n}\n\nint N;\n\nint go(vector<int> &a, vector<int> &b, int x, int y) {\n  int ans = -1;\n  repi(i, a) {\n    int l = *i;\n    int r = *i + x;\n\n    int p = int(lower_bound(b.begin(), b.end(), l) - b.begin()); // b[p] >= l\n    if (p < b.size()) {\n      int rr = b[p] + y;\n      if (r > rr) rr = r;\n      int len = rr - l;\n      if (len < ans || ans == -1) ans = len;\n    }\n    --p; // b[p] < l\n    if (p >= 0) {\n      int rr = p + y;\n      if (r > rr) rr = r;\n      int len = rr - b[p];\n      if (len < ans || ans == -1) ans = len;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  scanf(\"%s\", str);\n  N = strlen(str);\n  scanf(\"%d\", &Q);\n\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j <= N && j <= i + 4; ++j) {\n      int k = conv(str + i, j - i);\n      occ[k].push_back(i);\n    }\n  }\n\n  for(int q = 0; q < Q; ++q) {\n    scanf(\"%s %s\", a, b);\n    int l1 = strlen(a), l2 = strlen(b);\n    int x = conv(a, l1);\n    int y = conv(b, l2);\n    if (occ[x].size() > occ[y].size() || (occ[x].size() == occ[y].size() && x > y)) {\n      swap(x, y);\n      swap(l1, l2);\n    }\n\n    int &ans = dp[pii(x, y)];\n    if (!ans) ans = go(occ[x], occ[y], l1, l2);\n    printf(\"%d\\n\", ans);\n  }\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "hashing",
        "strings",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. DZY Loves Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/12959",
    "editorial": "We can solve a subproblem in which all the query strings are characters\r\nonly first. The problem becomes calculating the shortest substring\r\ncontaining two given characters. If character appears more than times in\r\n, use brute force with time complexity to calculate all the queries\r\ncontaining . Obviously, there are at most such in . Otherwise, we\r\nconsider two sorted sequences, just merge them with time complexity\r\n(Both of the two characters appear at most times). Being merging, you\r\ncan get the answer. So the complexity is . We can choose , then the\r\ncomplexity is . And short substring is almost the same with characters.\r\nCheck the C++ code here.\r\n",
    "hint": []
}