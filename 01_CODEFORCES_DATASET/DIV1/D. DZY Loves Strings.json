{"link": "https://codeforces.com//contest/444/problem/D", "problemId": "11253", "problem_idx": "D", "shortId": "444D", "contest_number": "444", "problem_submissions": {"B": [7031130, 7030965, 7024958, 7024676, 7030446, 7027559, 7026989, 7029436, 7032613, 7026604, 7041433, 7024980], "C": [7029407, 7026783, 7028625, 7029070, 7027854, 7035787, 7035783, 7031351, 7029689, 7028909, 7032738, 7033609, 7027863, 7030366, 7026206, 7047158, 7029026, 7027864], "A": [7026572, 7023113, 7022682, 7021917, 7022193, 7021891, 7023277, 7021994, 7023490, 7022290, 7021818, 7029841, 7024232, 7028150, 7022608, 7022804], "E": [7025382, 7029973, 7031979, 7031957, 7039984, 7039647, 7030433, 7029905, 7030939, 7032469, 7032562, 7035736, 7041366, 7041365, 7041358, 7041326, 7036608], "D": [7030340, 7032449, 7029379, 7031920, 7032235, 7032726, 7027353, 7024739, 7032806, 7032764, 7032749, 7032739, 7032700, 7031354, 7029340, 7031710, 7032104]}, "name": "D. DZY Loves Strings", "statement": "In China, many people like to use strings containing their names\u2019\r\ninitials, for example: , , , .Once DZY found a lucky string . A lot of\r\npairs of good friends came to DZY when they heard about the news. The\r\nfirst member of the -th pair has name , the second one has name . Each\r\npair wondered if there is a substring of the lucky string containing\r\nboth of their names. If so, they want to find the one with minimum\r\nlength, which can give them good luck and make their friendship last\r\nforever.Please help DZY for each pair find the minimum length of the\r\nsubstring of that contains both and , or point out that such substring\r\ndoesn\u2019t exist.A substring of is a string for some integers . The length\r\nof such the substring is .A string contains some another string if there\r\nis a substring of equal to .\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define repi(i, a) for(typeof((a).begin()) i = (a).begin(), _##i = (a).end(); i != _##i; ++i)\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100100;\nconst int MAXP = 1000100;\n\nint A[MAXN];\nint B[MAXN];\n\nvector<int> occ[MAXP];\n\nint Q;\nchar str[MAXN];\nchar a[MAXN], b[MAXN];\n\nmap<pii, int> dp;\n\nint conv(char *s, int l) {\n  int ret = 0;\n  for(int i = 0; i < l; ++i) {\n    ret = ret * 27 + s[i] - 'a' + 1;\n  }\n\n  return ret;\n}\n\nint N;\n\nint go(vector<int> &a, vector<int> &b, int x, int y) {\n  int ans = -1;\n  repi(i, a) {\n    int l = *i;\n    int r = *i + x;\n\n    int p = int(lower_bound(b.begin(), b.end(), l) - b.begin()); // b[p] >= l\n    if (p < b.size()) {\n      int rr = b[p] + y;\n      if (r > rr) rr = r;\n      int len = rr - l;\n      if (len < ans || ans == -1) ans = len;\n    }\n    --p; // b[p] < l\n    if (p >= 0) {\n      int rr = p + y;\n      if (r > rr) rr = r;\n      int len = rr - b[p];\n      if (len < ans || ans == -1) ans = len;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  scanf(\"%s\", str);\n  N = strlen(str);\n  scanf(\"%d\", &Q);\n\n  for(int i = 0; i < N; ++i) {\n    for(int j = i + 1; j <= N && j <= i + 4; ++j) {\n      int k = conv(str + i, j - i);\n      occ[k].push_back(i);\n    }\n  }\n\n  for(int q = 0; q < Q; ++q) {\n    scanf(\"%s %s\", a, b);\n    int l1 = strlen(a), l2 = strlen(b);\n    int x = conv(a, l1);\n    int y = conv(b, l2);\n    if (occ[x].size() > occ[y].size() || (occ[x].size() == occ[y].size() && x > y)) {\n      swap(x, y);\n      swap(l1, l2);\n    }\n\n    int &ans = dp[pii(x, y)];\n    if (!ans) ans = go(occ[x], occ[y], l1, l2);\n    printf(\"%d\\n\", ans);\n  }\n\n}\n"], "input": "", "output": "", "tags": ["binary search", "hashing", "strings", "two pointers"], "dificulty": "2500", "interactive": false}