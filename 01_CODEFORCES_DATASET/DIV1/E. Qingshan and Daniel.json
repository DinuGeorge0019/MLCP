{
    "link": "https://codeforces.com//contest/1495/problem/E",
    "problemId": "920578",
    "problem_idx": "E",
    "shortId": "1495E",
    "contest_number": "1495",
    "problem_submissions": {
        "F": [
            109612449,
            109607835,
            109606482,
            109609150,
            109620903,
            109726650,
            109627363,
            109621999
        ],
        "E": [
            109601349,
            109614588,
            109615437,
            109622017,
            109595998,
            109609900,
            109608272,
            109611154,
            109618626,
            109616350,
            109613793,
            109616566,
            109663705,
            109745948
        ],
        "D": [
            109585527,
            109580228,
            109579316,
            109589541,
            109578458,
            109566916,
            109575841,
            109594019,
            109596254,
            109599839,
            109603208,
            109598498,
            109595100,
            109579185,
            109589312,
            109591284,
            109598520,
            109583665,
            109585365
        ],
        "C": [
            109580634,
            109591405,
            109587970,
            109577744,
            109586320,
            109593422,
            109611088,
            109582953,
            109580883,
            109580583,
            109587448,
            109605186,
            109581328,
            109584227,
            109579041,
            109577709,
            109589629,
            109602493
        ],
        "B": [
            109568471,
            109565101,
            109584053,
            109566115,
            109569156,
            109574304,
            109563074,
            109573615,
            109567542,
            109575207,
            109571021,
            109587658,
            109567505,
            109566798,
            109566339,
            109589966,
            109570284,
            109566248
        ],
        "A": [
            109557502,
            109557307,
            109557290,
            109557352,
            109558084,
            109569473,
            109557547,
            109559952,
            109558698,
            109558154,
            109557812,
            109558270,
            109557945,
            109558879,
            109557971,
            109558445,
            109560880,
            109558343,
            109559119
        ]
    },
    "name": "E. Qingshan and Daniel",
    "statement": "Qingshan and Daniel are going to play a card game. But it will be so\r\nboring if only two persons play this. So they will make n robots in\r\ntotal to play this game automatically. Robots made by Qingshan belong to\r\nthe team 1, and robots made by Daniel belong to the team 2. Robot i\r\nbelongs to team t_i. Before the game starts, a_i cards are given for\r\nrobot i.The rules for this card game are simple: Before the start, the\r\nrobots are arranged in a circle in the order or their indices. The\r\nrobots will discard cards in some order, in each step one robot discards\r\na single card. When the game starts, robot 1 will discard one of its\r\ncards. After that, robots will follow the following rules: If robot i\r\ndiscards the card last, the nearest robot whose team is opposite from\r\ni\u2019s will discard the card next. In another word j will discard a card\r\nright after i, if and only if among all j that satisfy t_i\r\nne t_j, dist(i,j) (definition is below) is minimum. The robot who has no\r\ncards should quit the game immediately. This robot won\u2019t be considered\r\nin the next steps. When no robot can discard the card next, the game\r\nends. We define the distance from robot x to robot y as\r\ndist(x,y)=(y-x+n)\r\nbmod n. It is similar to the oriented distance on the circle.For\r\nexample, when n=5, the distance from 1 to 3 is dist(1,3)=(3-1+5)\r\nbmod 5=2, the distance from 3 to 1 is dist(3,1)=(1-3+5)\r\nbmod 5 =3.Later, Qingshan finds out that it will take so much time to\r\nsee how robots play. She wants to know the result as quickly as\r\npossible. You, as Qingshan\u2019s fan, are asked to calculate an array\r\n[ans_1,ans_2,\r\nldots,ans_n] ans_i is equal to the number of cards, that i-th robot will\r\ndiscard during the game. You need to hurry!To avoid the large size of\r\nthe input, the team and the number of cards of each robot will be\r\ngenerated in your code with some auxiliary arrays.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=5000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\n\nint team[nax];\nll tab[nax];\n\nll seed;\nll base;\n\nll ans[nax];\n\nll rnd()\n{\n\tll ret=seed;\n\tseed=(seed*base+233)%mod;\n\treturn ret;\n}\n\nvoid gener()\n{\n\tint m;\n\tscanf(\"%d\", &m);\n\tint ost=0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint ter;\n\t\tll k;\n\t\tscanf(\"%d%lld%lld%lld\", &ter, &k, &seed, &base);\n\t\tfor (int j=ost+1; j<=ter; j++)\n\t\t{\n\t\t\tteam[j]=rnd()%2+1;\n\t\t\ttab[j]=rnd()%k+1;\n\t\t}\n\t\t\n\t\tost=ter;\n\t}\n}\n\nll ma[nax];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tgener();\n\t\n\tif (team[1]==2)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tteam[i]^=3;\n\t}\n\t//~ debug() << range(team+1, team+1+n);\n\t//~ debug() << range(tab+1, tab+1+n);\n\t\n\t\n\t\n\t\n\tll su[]={0, 0, 0};\n\tfor (int i=1; i<=n; i++)\n\t\tsu[team[i]]+=tab[i];\n\tdebug() << imie(su[1]) << imie(su[2]);\n\tint bierze;\n\tif (su[1]<=su[2])\n\t{\n\t\tbierze=2;\n\t}\n\telse\n\t{\n\t\tbierze=1;\n\t\tans[1]=1;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (team[i]!=bierze)\n\t\t{\n\t\t\tans[i]=tab[i];\n\t\t\tma[i]=tab[i];\n\t\t}\n\t}\n\tll s=0;\n\tfor (int h=0; h<3; h++)\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (team[i]==bierze)\n\t\t{\n\t\t\tll x=min(tab[i]-ans[i], s);\n\t\t\tans[i]+=x;\n\t\t\ts-=x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts+=ma[i];\n\t\t\tma[i]=0;\n\t\t}\n\t}\n\t//~ debug() << range(ans+1, ans+1+n);\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ assert(ans[i]==(i==1));\n\t\n\tll wyn=1;\n\tfor (ll i=1; i<=n; i++)\n\t{\n\t\tll x=(ans[i]^(i*i))+1;\n\t\tx%=mod;\n\t\twyn=(wyn*x)%mod;\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Qingshan and Daniel.json",
    "editorial_link": "https://codeforces.com//blog/entry/88533",
    "editorial": "We can consider that the robots are standing on a cycle. The game ends\r\nup with at least one team having no cards. Let the team having no cards\r\nin the end be team and let the other be team . If two teams both use up\r\ntheir cards, the first robot\u00e2\u0080\u0099s team is . For team , we\u00e2\u0080\u0099ve already known\r\nhow many cards will its robots discard, because they will discard all\r\ntheir cards. But how to calculate the answer for team ?Let\u00e2\u0080\u0099s look at the\r\nprocess of the game. Obviously, robots in and robots in will discard\r\ncards alternatively. In another word, if we write down the team of\r\nrobots who discard cards in time order, it will form a sequence or . For\r\nthe second type (starting with ), we can just use brute-force to discard\r\nthe first card and then find the next . So there is only one\r\ncircumstance: . Note that in the sequence every is followed by exactly\r\none . So the length of the sequence is the number of cards of team\r\nmultiplying .Currently, we are not able to figure out which robot is\r\nexactly represented by a particular or in the sequence. Luckily, we\r\ndon\u00e2\u0080\u0099t need to know it. What we care about is only how many cards the\r\nrobot in team discards. You can consider every is the sequence as a\r\nquery and change operation \"In the current game, some robot in team will\r\nfind the first robot in team on its right, and change to \". It\u00e2\u0080\u0099s a very\r\nimportant limit here because some robot will quit the game halfway\r\naccording to the statement.But on the contrary, an interesting fact is\r\nthat the \"important\" limit is not important at all. We can make the\r\nquery and the change in any order and it won\u00e2\u0080\u0099t change the answer!So you\r\njust need to iterate the array and maintain a variable the number of\r\noperations that are visited but not performed. If the team of the\r\ncurrent robot is , assign to . Otherwise, you can perform operations\r\nnow, and assign to . Since robots are standing on a cycle, you need to\r\niterate the array times.So the time complexity is .\r\n"
}