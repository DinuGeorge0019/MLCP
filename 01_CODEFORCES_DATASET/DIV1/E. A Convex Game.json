{"link": "https://codeforces.com//contest/1434/problem/E", "problemId": "773402", "problem_idx": "E", "shortId": "1434E", "contest_number": "1434", "problem_submissions": {"E": [96677024, 96703305, 96695061, 105543081, 96703526, 96698372], "C": [96660091, 96659353, 96663643, 96664995, 96666231, 96665833, 96660295, 96665975, 96667697, 96663270, 96667899, 96671631, 96669472, 96667880, 96663509, 96656865, 96675583, 96671215, 96671994, 96665979], "B": [96653756, 96655206, 96656896, 96653660, 96657305, 96660070, 96656102, 96658196, 96659133, 96653643, 96661876, 96658486, 96660839, 96661406, 96658185, 96654001, 96679983, 96658727, 96658564, 96660622], "A": [96649454, 96650673, 96653179, 96660619, 96651935, 96654803, 96651530, 96652454, 96653264, 96657461, 96658652, 96653143, 96656680, 96654396, 96655185, 96650897, 96672264, 96652811, 96654828, 96652745], "D": [96673411, 96677110, 96683665, 96678842, 96678338, 96679519, 96679771, 96683979, 96680244, 96683615, 96681902, 96685151, 96688093, 96669235, 96686214, 96686134, 96682142]}, "name": "E. A Convex Game", "statement": "Shikamaru and Asuma like to play different games, and sometimes they\r\nplay the following: given an increasing list of numbers, they take turns\r\nto move. Each move consists of picking a number from the list.Assume the\r\npicked numbers are v_{i_1}, v_{i_2},\r\nldots, v_{i_k}. The following conditions must hold: i_{j} < i_{j+1} for\r\nall 1\r\nleq j\r\nleq k-1; v_{i_{j+1}} - v_{i_j} < v_{i_{j+2}} - v_{i_{j+1}} for all 1\r\nleq j\r\nleq k-2. However, it\u2019s easy to play only one instance of game, so today\r\nShikamaru and Asuma decided to play n simultaneous games. They agreed on\r\ntaking turns as for just one game, . At each turn, the player performs a\r\nvalid move in any single game. The player who cannot move loses. Find\r\nout who wins, provided that both play optimally.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 25.10.2020 14:45:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nconst int MAX = 100010;\nint bound[MAX];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  int x = 0;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n      cin >> v[i];\n    }\n    {\n      int ptr = -1;\n      for (int val = 0; val < MAX; val++) {\n        if (ptr + 1 < n && v[ptr + 1] == val) {\n          ++ptr;\n        }\n        bound[val] = ptr;\n      }\n    }\n    vector<vector<int>> who(1, vector<int>(n, -1));\n    vector<dsu> d(1, dsu(n + 1));\n    vector<bool> seen;\n    for (int i = n - 1; i >= 0; i--) {\n      int start = 0;\n      int j = 0;\n      while (start < i) {\n        if (j == (int) who.size()) {\n          who.emplace_back(n, -1);\n          d.emplace_back(n + 1);\n        }\n        int finish = i - 1;\n        int tmp = who[j][i];\n        if (tmp != -1) {\n          int val = v[i] - (v[tmp] - v[i]);\n          finish = (val <= 0 ? -1 : bound[val]);\n        }\n//        debug(i, j, start, finish);\n        if (start <= finish) {\n          int pos = d[j].get(start);\n          while (pos <= finish) {\n            who[j][pos] = i;\n            d[j].unite(pos, pos + 1);\n            pos = d[j].get(pos);\n          }\n          start = finish + 1;\n        }\n        ++j;\n      }\n      int g = 0;\n      while (g < (int) who.size() && who[g][i] != -1) {\n        ++g;\n      }\n      if (g >= (int) seen.size()) {\n        seen.resize(g + 1);\n      }\n      seen[g] = true;\n    }\n    int g = 0;\n    while (g < (int) seen.size() && seen[g]) {\n      ++g;\n    }\n    x ^= g;\n    debug(g);\n  }\n  cout << (x > 0 ? \"YES\" : \"NO\") << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dsu", "games"], "dificulty": "3500", "interactive": false}