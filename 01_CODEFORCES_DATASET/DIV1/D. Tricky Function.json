{
    "link": "https://codeforces.com//contest/429/problem/D",
    "problemId": "9405",
    "problem_idx": "D",
    "shortId": "429D",
    "contest_number": "429",
    "problem_submissions": {
        "E": [
            6595809,
            6600093,
            6592978,
            6601793,
            6652557,
            6599111,
            6619551,
            6619545,
            6597254,
            6597744
        ],
        "C": [
            6593728,
            6600070,
            6592280,
            6592740,
            6600977,
            6600868,
            6594386,
            6592397,
            6594791,
            6593656,
            6596025,
            6593807,
            6593862,
            6598107,
            6594449,
            6598559,
            6594937,
            6592148,
            6594524,
            6592432,
            6594909,
            6590473
        ],
        "D": [
            6591664,
            6600092,
            6591240,
            6590624,
            6590639,
            6591834,
            6591461,
            6591644,
            6590500,
            6592190,
            6591828,
            6591578,
            6591777,
            6592587,
            27994201,
            6591983,
            6594641,
            6604627,
            6593023,
            6594793,
            6591937,
            6593041
        ],
        "B": [
            6589690,
            6600091,
            6589488,
            6589367,
            6588962,
            6590036,
            6588367,
            6590786,
            6591308,
            6589466,
            6590642,
            6589551,
            6589761,
            6589966,
            6589108,
            6590082,
            6589028,
            6590294,
            6589190,
            6595125
        ],
        "A": [
            6588164,
            6600088,
            6588109,
            6588114,
            6588105,
            6588288,
            6588966,
            6588346,
            6592136,
            6588117,
            6588421,
            6588130,
            6588989,
            6588112,
            27994125,
            6589842,
            6588200,
            6588169,
            6588529,
            6590124,
            6593587
        ]
    },
    "name": "D. Tricky Function",
    "statement": "Iahub and Sorin are the best competitive programmers in their town.\r\nHowever, they can\u2019t both qualify to an important contest. The selection\r\nwill be made with the help of a single problem. Blatnatalag, a friend of\r\nIahub, managed to get hold of the problem before the contest. Because he\r\nwants to make sure Iahub will be the one qualified, he tells Iahub the\r\nfollowing task.You\u2019re given an (1-based) array with elements. Let\u2019s\r\ndefine function as . Function g is calculated by the following\r\npseudo-code:int g(int i, int j) { int sum = 0; for (int k = min(i, j) +\r\n1; k <= max(i, j); k = k + 1) sum = sum + a[k]; return sum;}Find a value\r\n.Probably by now Iahub already figured out the solution to this problem.\r\nCan you?\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint a[100500];\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf(\"%d\", &n);\n\tforn(i, n)\n\t\tscanf(\"%d\", &a[i]);\n\tint ans = 1 + a[1] * a[1];\n\tfor (int d = 1; d < n; d++) {\n\t\tif (d * d >= ans) break;\n\t\tint s = 0;\n\t\tint q = inf;\n\t\tint l = 1;\n\t\tint r = d + 1;\n\t\tforn (j, d)\n\t\t\ts += a[j + 1];\n\t\tq = min(q, abs(s));\n\t\twhile (r < n) {\n\t\t\ts -= a[l];\n\t\t\ts += a[r];\n\t\t\tl++;\n\t\t\tr++;\n\t\t\tq = min(q, abs(s));\n\t\t}\n\t\tif ((int64)q * q + (int64)d * d < ans)\n\t\t\tans = q * q + d * d;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "geometry"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Tricky Function.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "Let s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i j) ^\r\n2 + (S[i] S[j]) ^ 2. Trying to minimize this function seems complicated,\r\nso we need to manipulate the formula more. We know from the maths that\r\nif f(i, j) is minimized, then also f (i, j) = sqrt ( (i j) ^ 2 + (S[i]\r\nS[j]) ^ 2) is also minimized. Does this function look familiar to you?\r\nSuppose you get two points in 2D plane: one having coordinates (i, S[i])\r\nand the other one having coordinates (j, S[j]). One can see that f (i,\r\nj) is exactly euclidean distance of those points. So, if f (i, j) is a\r\ndistance between two points in plane, when is achieved minimal f (i, j)?\r\nFor the closest two points in plane (the points which are located at\r\nminimal distance). So, having set of points (i, S[i]), we need to\r\ncompute closest two points from this plane. There is a classical\r\nalgorithm that does this in O(n * logn).\r\n"
}