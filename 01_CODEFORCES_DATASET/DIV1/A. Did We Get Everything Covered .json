{
    "link": "https://codeforces.com//contest/1924/problem/A",
    "problemId": "2447857",
    "problem_idx": "A",
    "shortId": "1924A",
    "contest_number": "1924",
    "problem_submissions": {
        "E": [
            243630255,
            243625417,
            243831471,
            243819146,
            243638029,
            243635094,
            243635575,
            243643653,
            243641448,
            243654047,
            243642725,
            243655474,
            243640193,
            243642282,
            243738773,
            243738280,
            243737868,
            243737472,
            243736583,
            243647040,
            243643392,
            243656506,
            243623598,
            243647525,
            243642926
        ],
        "D": [
            243610539,
            243613703,
            243615017,
            243615468,
            243616484,
            243609433,
            243612607,
            243604919,
            243590030,
            243626983,
            243620249,
            243611671,
            243630742,
            243627184,
            243647496,
            243637086,
            243615081
        ],
        "C": [
            243600996,
            243608465,
            243605004,
            243605423,
            243609031,
            243624334,
            243598851,
            243618516,
            243614897,
            243607146,
            243609954,
            243605925,
            243615697,
            243614877,
            243629728,
            243619721,
            243625857
        ],
        "B": [
            243576284,
            243596345,
            243574522,
            243584076,
            243591802,
            243608792,
            243595388,
            243582812,
            243591583,
            243581060,
            243590774,
            243588502,
            243614602,
            243593249,
            243586709,
            243594966,
            243581169,
            243586114
        ],
        "A": [
            243557786,
            243557461,
            243557951,
            243558389,
            243559700,
            243571068,
            243569238,
            243556739,
            243561136,
            243559764,
            243556383,
            243563507,
            243559787,
            243566206,
            243566244,
            243561059,
            243558400,
            243589028
        ],
        "F": [
            243674865,
            243667546,
            243888054,
            243737554,
            246427685
        ]
    },
    "name": "A. Did We Get Everything Covered ",
    "statement": "You are given two integers n and k along with a string s.Your task is to\r\ncheck whether all possible strings of length n that can be formed using\r\nthe first k lowercase English alphabets occur as a subsequence of s. If\r\nthe answer is , you also need to print a string of length n that can be\r\nformed using the first k lowercase English alphabets which does not\r\noccur as a subsequence of s.If there are multiple answers, you may print\r\nany of them. A string a is called a subsequence of another string b if a\r\ncan be obtained by deleting some (possibly zero) characters from b\r\nwithout changing the order of the remaining characters.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k, m;\n    std::cin >> n >> k >> m;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::string t;\n    int j = 0;\n    bool ok = true;\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        std::vector<int> occ(k);\n        while (cnt < k && j < m) {\n            cnt += !occ[s[j] - 'a'];\n            occ[s[j] - 'a'] = 1;\n            j += 1;\n        }\n        if (cnt < k) {\n            ok = false;\n            for (int x = 0; x < k; x++) {\n                if (!occ[x]) {\n                    t += 'a' + x;\n                    break;\n                }\n            }\n        } else {\n            t += s[j - 1];\n        }\n    }\n    \n    if (ok) {\n        std::cout << \"YES\\n\";\n    } else {\n        std::cout << \"NO\\n\";\n        std::cout << t << \"\\n\";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "shortest paths",
        "strings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Did We Get Everything Covered .json",
    "editorial_link": "https://codeforces.com//blog/entry/125137",
    "editorial": "We will try to construct a counter-case. If we can\u00e2\u0080\u0099t the answer\nis YES otherwise NO.We will greedily construct the counter-case. It is\nalways optimal to choose the first character of our counter-case as the\ncharacter (among the first English alphabets) whose first index of\noccurrence in is the highest. Add this character to our counter-case,\nremove the prefix up to this character from and repeat until the length\nof the counter-case reaches or we reach the end of .If the length of the\ncounter-case is less than , find a character which does not appear in\nthe last remaining suffix of . Keep adding this character to the\ncounter-case until its length becomes . This is a valid string which\ndoes not occur as a subsequence of .Otherwise, all possible strings of\nlength formed using the first English alphabets occur as a subsequence\nof .\n"
}