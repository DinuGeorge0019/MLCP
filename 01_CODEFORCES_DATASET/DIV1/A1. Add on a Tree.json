{
    "link": "https://codeforces.com//contest/1188/problem/A1",
    "problemId": "366819",
    "problem_idx": "A1",
    "shortId": "1188A1",
    "contest_number": "1188",
    "problem_submissions": {
        "A2": [
            56584964,
            56567602,
            56566524,
            56572382,
            56589644,
            56583972,
            56579938,
            56582233,
            56570590,
            56576661,
            56589231,
            56587448,
            56570901,
            56587024,
            56574198,
            56581669,
            56571222
        ],
        "E": [
            56582671,
            56589474,
            56589239,
            141774833,
            57345099,
            56596996,
            56642394
        ],
        "D": [
            56576903,
            56585842,
            56583846,
            56589764,
            56584452,
            56586331,
            56584084,
            56596587,
            56577947,
            56602284
        ],
        "C": [
            56571735,
            56576008,
            56572799,
            56580329,
            56577305,
            56572037,
            56574271,
            56570306,
            56577496,
            56576142,
            56583479,
            56585009,
            56584467,
            56575353,
            56583067,
            56585221,
            56572902,
            56587295,
            56575946,
            56586708
        ],
        "B": [
            56568214,
            56570555,
            56562488,
            56571471,
            56575984,
            56607436,
            56565158,
            56574148,
            56570733,
            56572983,
            56567704,
            56568743,
            56568263,
            56575440,
            56583939,
            56576017,
            56588907,
            56575865
        ],
        "A1": [
            56561659,
            56562944,
            56561298,
            56564728,
            56563727,
            56577205,
            56564216,
            56561247,
            56563294,
            56561568,
            56563293,
            56566261,
            56569194,
            56564914,
            56561283,
            56572778,
            56565086,
            56564073,
            56561536,
            56563748
        ]
    },
    "name": "A1. Add on a Tree",
    "statement": "You are given a tree with n nodes. In the beginning, 0 is written on all\r\nedges. In one operation, you can choose any 2 distinct u, v and any\r\nnumber x and add x to values written on all edges on the simple path\r\nbetween u and v.For example, on the picture below you can see the result\r\nof applying two operations to the graph: adding 2 on the path from 7 to\r\n6, and then adding -0.5 on the path from 4 to 5. Is it true that for any\r\nconfiguration of real numbers written on edges, we can achieve it with a\r\nfinite number of operations?Leaf is a node of a tree of degree 1. Simple\r\npath is a path that doesn\u2019t contain any node twice.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nint n;\nint deg[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tdeg[v]++;\n\t\tdeg[u]++;\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tif (deg[v] == 2) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A1. Add on a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/68079",
    "editorial": "We claim, that the answer is YES iff there is no vertex with degree 2. After this, it's easy to get a solution for first subtask in O(n)\n.\n\nBecause all numbers are different, in the second subtask if we have a vertex with degree 2\n then answer is NO. If there is no such then construction also follows from proof. Indeed, if we can add on any path to leaf, then we can add on one edge. So, consider any edge uv\n and suppose we want to add x\n on this edge. Let's find any leaf in a subtree of vertex u\n, which doesn't contain v\n, let's name it l\n. If l=u\n, just add x\n on path uv\n. Else, add x\n on path vl\n and ?x\n on path ul\n. It's clear, that after this two operations we've added x\n on edge uv\n and didn't add anything on other edges. Then, just add on each edge needed number.\n\nIn the end, let's talk about implementation. To add on the path to leaf it's sufficient to find a leaf in the subtree. We can do it naively in O(n)\n, then complexity is O(n2)\n. Also, we can precalculate leaves in each subtree and, for example, root tree at some leaf. Then, it's possible to do all operations in O(1)\n, and complexity is O(n)\n, but it wasn't needed."
}