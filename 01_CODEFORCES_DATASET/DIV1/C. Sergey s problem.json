{
    "link": "https://codeforces.com//contest/1019/problem/C",
    "problemId": "207015",
    "problem_idx": "C",
    "shortId": "1019C",
    "contest_number": "1019",
    "problem_submissions": {
        "D": [
            41494541,
            41486235,
            41489624,
            41496428,
            41482324,
            41485058,
            41485821,
            41503084,
            41488961,
            41490515,
            41488550,
            41488663,
            41486677,
            41490916,
            41491659,
            41491114,
            41488916,
            41491612,
            41493392
        ],
        "C": [
            41485063,
            41566656,
            41496194,
            41491682,
            41552113,
            41499582,
            41487460,
            41530705,
            41652339,
            205457358
        ],
        "A": [
            41477821,
            41473071,
            41475477,
            41477205,
            41474279,
            41472040,
            41473278,
            41472687,
            41471212,
            41472351,
            41478347,
            41474071,
            41472848,
            41472443,
            41471416,
            41473130,
            41524142,
            41480834,
            41476724,
            41472604
        ],
        "B": [
            41472593,
            41477785,
            41479330,
            41486699,
            41478688,
            41476845,
            41477610,
            41476296,
            41475985,
            41478284,
            41482245,
            41489236,
            41477340,
            41477044,
            41480533,
            41484731,
            41486696,
            41478640
        ],
        "E": [
            41541275,
            41536720,
            41496541,
            41519405,
            41505368,
            41533475
        ]
    },
    "name": "C. Sergey s problem",
    "statement": "Sergey just turned five years old! When he was one year old, his parents\r\ngave him a number; when he was two years old, his parents gave him an\r\narray of integers. On his third birthday he received a string. When he\r\nwas four, his mother woke him up in a quiet voice, wished him to be a\r\ngood boy and gave him a rooted tree. Today he celebrates his birthday\r\nagain! He found a directed graph without loops as a present from his\r\nparents.Since Sergey is a very curious boy, he immediately came up with\r\na thing to do. He decided to find a set Q of vertices in this graph,\r\nsuch that no two vertices x, y\r\nin Q are connected by an edge, and it is possible to reach any vertex z\r\nnotin Q from some vertex of Q in no more than two moves. After a little\r\nthought, Sergey was able to solve this task. Can you solve it too?A\r\nvertex y is reachable from a vertex x in at most two moves if either\r\nthere is a directed edge (x,y), or there exist two directed edges (x,z)\r\nand (z, y) for some vertex z.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 1e6 + 1;\nint n,m;\nvector<int> d[MAX];\nint res[MAX];\nint deg[MAX];\nint nie[MAX];\nvoid take(int v){\n  res[v] = 1;\n  for(int el:d[v]){\n    if(res[el]){\n      deg[el]++;\n    }else{\n      res[el] = 2;\n    }\n  }\n}\nvector<int> out;\nvoid dfs(int v){\n  if(res[v] != 1 || deg[v] != 0)return;\n  deg[v] = -1;\n  if(!nie[v])out.PB(v);\n  for(int el:d[v]){\n    if(!nie[v]){\n      nie[el] = 1;\n    }\n    deg[el]--;\n    dfs(el);\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m;\n  R(i,m){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    d[a].PB(b);\n  }\n  R(i,n)if(res[i] == 0){\n    take(i);\n  }\n  R(i,n)dfs(i);\n  \n  cout << SZ(out) << \"\\n\";\n  for(int el:out){\n    cout << el+1 << \" \";\n  }\n  cout << \"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Sergey s problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/61161",
    "editorial": "Let\u00e2\u0080\u0099s build the solution by induction. Suppose we have to solve the\r\nproblem for vertices and we can solve this problem for all (). Take an\r\narbitrary vertex . Remove from the graph, as well as all vertices that\r\nhas an outgoing edge to. Resulting graph has less than vertices, so by\r\ninduction, we can build the solution for it. Let\u00e2\u0080\u0099s call the answer set\r\nfor the new graph . After this we have two cases: either there is an\r\nedge from set to vertex or there is not. If there is an edge from to ,\r\nthen is a correct answer for initial graph, because every removed vertex\r\ncan be reached from in at most two steps. Otherwise, we can add to and,\r\nagain, this set will satisfy the required condition. This also proves\r\nthe answer always exists.How to implement it? Let\u00e2\u0080\u0099s iterate over all\r\nvertices in order from to and remember whether each vertex is currently\r\npresent in the graph or not. Whenever we encounter a currently present\r\nvertex , we save and mark and all vertices reachable from in one step as\r\nremoved. After that, we go over all saved vertices in reverse order and\r\nadd them to answer set if it\u00e2\u0080\u0099s not reachable from the answer set in one\r\nstep.This solutions works in time and space.\r\n"
}