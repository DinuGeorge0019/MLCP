{
    "link": "https://codeforces.com//contest/1086/problem/F",
    "problemId": "273656",
    "problem_idx": "F",
    "shortId": "1086F",
    "contest_number": "1086",
    "problem_submissions": {
        "F": [
            47429292,
            47449995,
            47444202
        ],
        "E": [
            47422474,
            47423961,
            47424550,
            47426933,
            47428109,
            47426232,
            47427511,
            47426695,
            47427218,
            47427849,
            47427630,
            47511510,
            47428346,
            47425158,
            47429712,
            47428661,
            47421857,
            47429322,
            47440462,
            63950917
        ],
        "D": [
            47415205,
            47413571,
            47418835,
            47417078,
            47414191,
            47418078,
            47418526,
            47419686,
            47418954,
            47419229,
            47421725,
            47466322,
            47418774,
            47416004,
            47420225,
            47422460,
            47411471,
            47420807,
            47421473,
            47423600,
            47420881
        ],
        "C": [
            47410346,
            47408923,
            47412203,
            47411518,
            47409578,
            47407257,
            47412943,
            47414708,
            47412730,
            47413883,
            47416006,
            47414439,
            47428921,
            47417547,
            47419740,
            47412059,
            47415581,
            47415787
        ],
        "B": [
            47402010,
            47400574,
            47400073,
            47401453,
            47402762,
            47411548,
            47405929,
            47406096,
            47405616,
            47407353,
            47404186,
            47400750,
            47404258,
            47404681,
            47402882,
            47426003,
            47408582,
            47404099,
            47404538,
            47406586
        ],
        "A": [
            47400483,
            47400094,
            47413170,
            47400357,
            47400599,
            47410258,
            47403179,
            47403378,
            47401193,
            47402951,
            47401486,
            47403915,
            47400561,
            47403260,
            47400323,
            47425175,
            47409292,
            47400702,
            47401450,
            47402988
        ]
    },
    "name": "F. Forest Fires",
    "statement": "Berland forest was planted several decades ago in a formation of an\r\ninfinite grid with a single tree in every cell. Now the trees are grown\r\nup and they form a pretty dense structure.So dense, actually, that the\r\nfire became a real danger for the forest. This season had been\r\nabnormally hot in Berland and some trees got caught on fire! The second\r\nfire started is considered the second 0. Every second fire lit up all\r\nintact neightbouring trees to every currently burning tree. The tree is\r\nneighbouring if it occupies adjacent cell. Luckily, after t seconds\r\nBerland fire department finally reached the location of fire and\r\ninstantaneously extinguished it all.Now they want to calculate the\r\ndestructive power of the fire. Let val_{x, y} be the second the tree in\r\ncell (x, y) got caught on fire. The destructive power is the sum of\r\nval_{x, y} over all (x, y) of burnt trees.Clearly, all the workers of\r\nfire department are firefighters, not programmers, thus they asked you\r\nto help them calculate the destructive power of the fire.The result can\r\nbe rather big, so print it modulo 998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int Mod = 998'244'353;\n\nint PowMod(int a, int n) {\n  int r = 1;\n  while (n) {\n    if (n & 1) { r = (LL)r * a % Mod; }\n    n >>= 1;\n    a = (LL)a * a % Mod;\n  }\n  return r;\n}\n\nstruct Point {\n  int x, y;\n};\n\nconst int MaxN = 64;\n\nPoint pts[MaxN];\nint N, T;\n\nLL GetNumCovered(int tm) {\n  struct Event {\n    int x;\n    int y1, y2;\n    int coef;\n\n    bool operator<(const Event &other) const {\n      return x < other.x;\n    }\n  };\n  \n  vector<int> all_ys;\n\n  vector<Event> events;\n  for (int i = 0; i < N; ++i) {\n    events.push_back(Event{pts[i].x - tm, pts[i].y - tm, pts[i].y + tm + 1, 1});\n    events.push_back(Event{pts[i].x + tm + 1, pts[i].y - tm, pts[i].y + tm + 1, -1});\n    all_ys.PB(pts[i].y + tm + 1);\n    all_ys.PB(pts[i].y - tm);\n  }\n\n  sort(ALL(events));\n  sort(ALL(all_ys));\n  all_ys.resize(unique(ALL(all_ys)) - all_ys.begin());\n  vector<int> count_covers(SZ(all_ys));\n\n  int last_x = -1e9;\n  LL answer = 0;\n  LL total_y = 0;\n\n  for (auto &event : events) {\n    const int x = event.x;\n    answer += (x - last_x) * total_y;\n    last_x = x;\n\n    const int start_y = lower_bound(ALL(all_ys), event.y1) - all_ys.begin();\n    const int end_y = lower_bound(ALL(all_ys), event.y2) - all_ys.begin();\n    \n    for (int i = start_y; i < end_y; ++i)\n      count_covers[i] += event.coef;\n\n    total_y = 0;\n    for (int i = 0; i < SZ(all_ys) - 1; ++i) {\n      if (count_covers[i]) {\n        total_y += all_ys[i + 1] - all_ys[i];\n      }\n    }\n\n    //debug(all_ys, count_covers);\n  }\n\n  return answer;\n}\n\nLL GetIncrNumCovered(int tm) {\n  return GetNumCovered(tm) - GetNumCovered(tm - 1);\n}\n\nconst int Inv2 = PowMod(2, Mod - 2);\nconst int Inv6 = PowMod(6, Mod - 2);\n\nint SumQuad(int A, int B, int C, int n) {\n  LL ans = (LL)C * n % Mod;\n  LL bcoef = (n * (n + 1)) % Mod * Inv2 % Mod;\n  ans = (ans + bcoef * B) % Mod;\n  LL acoef = (n * (n + 1)) % Mod * (2 * n + 1) % Mod * Inv6 % Mod;\n  ans = (ans + acoef * A) % Mod;\n  return ans;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> T;\n  for (int i = 0; i < N; ++i) {\n    cin >> pts[i].x >> pts[i].y;\n  }\n\n  int cur_tm = 2;\n  LL p0 = GetIncrNumCovered(2);\n  LL p1 = GetIncrNumCovered(1);\n  debug(p0, p1);\n  LL answer = 0;\n  if (T >= 1) { answer = (answer + p1) % Mod; }\n  if (T >= 2) { answer = (answer + 2LL * p0) % Mod; }\n  if (T <= 2) {\n    cout << answer << \"\\n\";\n    return 0;\n  }\n  \n  while (cur_tm < T) {\n    int left_lin = cur_tm;\n    int right_lin = T;\n\n    while (right_lin - left_lin > 1) {\n      const int mid_lin = (left_lin + right_lin) / 2;\n      const LL pmid = GetIncrNumCovered(mid_lin);\n      debug(p0, p1, mid_lin, pmid);\n\n      if (p0 + (mid_lin - cur_tm) * (p0 - p1) == pmid) {\n        left_lin = mid_lin;\n      } else {\n        right_lin = mid_lin;\n      }\n    }\n\n    debug(left_lin);\n    const LL A = (p0 - p1) % Mod;\n    const LL B = (p0 + cur_tm * (p0 - p1)) % Mod;\n    const LL C = (p0 % Mod) * cur_tm % Mod;\n\n    debug(A, B, C);\n    answer = (answer + SumQuad(A, B, C, left_lin - cur_tm)) % Mod;\n\n    p1 = GetIncrNumCovered(left_lin);\n    p0 = GetIncrNumCovered(left_lin + 1);\n    cur_tm = left_lin + 1;\n    answer = (answer + (LL)(p0 % Mod * cur_tm)) % Mod;\n    debug(cur_tm, answer);\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Forest Fires.json",
    "editorial_link": "https://codeforces.com//blog/entry/64078",
    "editorial": "Let be the total number of trees burnt during first seconds. The answer\r\ncan be represented as . Computing one value of can be done in or with\r\nscanline or something like that.Letâs analyze how the value of this\r\nfunction is changed as time goes. In the beginning, only initial trees\r\nare burnt, then the zones around their position, expand, and so on,\r\nuntil two zones start intersecting. Then again, until another pair of\r\nzones starts intersecting. And so on. Let be the sorted sequence of\r\nmoments when two zones start intersecting (this sequence has no more\r\nthan elements and can easily be computed in ). Letâs analyze the\r\nbehavior of the function on segments and so on.Why are we interested in\r\nsuch segments? Because for each such segment, can be represented as a\r\npolynomial. This can be proven with the help of inclusion-exclusion: for\r\neach subset of zones, the intersection of zones is either empty or a\r\nrectangle. And if we expand the rectangle, then during second its area\r\nis , during second , during second , itâs a -nd degree polynomial. So if\r\nwe would try to compute the area of affected land through\r\ninclusion-exclusion formula, we would get a sum of no more than\r\npolynomials, each having degree no more than , so the result is also a\r\n-nd degree polynomial. We can actually compute the coefficients of this\r\npolynomial by interpolation or just some pen and paper work. And is a\r\npolynomial of -rd degree, which can be computed using some more pen and\r\npaper work.So, to conclude, the solution consists of two steps: find all\r\nthe moments when two zones affected by different trees start\r\nintersecting; consider the function on the segments when it behaves as a\r\npolynomial.\r\n",
    "hint": []
}