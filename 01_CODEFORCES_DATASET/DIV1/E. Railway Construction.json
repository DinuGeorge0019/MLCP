{"link": "https://codeforces.com//contest/1580/problem/E", "problemId": "1124758", "problem_idx": "E", "shortId": "1580E", "contest_number": "1580", "problem_submissions": {"B": [130368546, 130343157, 130344628, 130363173, 130349401, 130355243, 130367468, 130348461, 130361528, 130349821, 130353521, 130358877, 130349956, 130352430, 130351206, 130360978, 130375295, 130370586, 130394237, 130361703], "F": [130365168, 131645253, 131635746, 130511674, 130411823, 130434722, 130858441, 130432452], "D": [130353694, 130351879, 130354504, 130348465, 130361242, 130356218, 130400584, 130360744, 130356043, 130858484, 130362840, 130366863, 130368106, 130352099, 130366694, 130365720, 130365962, 130368047, 130360831, 130353993, 130370294], "C": [130347074, 130348749, 130348466, 130344529, 130355623, 130348660, 130349751, 130374035, 130353918, 130350011, 130356865, 130358625, 130355024, 130348708, 130393503, 130361958, 130360836, 130360159, 130358052, 130357895, 130349443, 130349567], "A": [130339939, 130502005, 130339930, 130348093, 130341897, 130340621, 130340244, 130356449, 130343417, 130342143, 130341207, 130340481, 130341559, 130340530, 130339691, 130340905, 130340089, 130340579, 130352882], "E": [130370647, 130421659]}, "name": "E. Railway Construction", "statement": "Because the railway system in Gensokyo is often congested, as an\r\nenthusiastic engineer, Kawasiro Nitori plans to construct more railway\r\nto ease the congestion.There are n stations numbered from 1 to n and m\r\ntwo-way railways in Gensokyo. Every two-way railway connects two\r\ndifferent stations and has a positive integer length d. No two two-way\r\nrailways connect the same two stations. Besides, it is possible to\r\ntravel from any station to any other using those railways. Among these n\r\nstations, station 1 is the main station. You can get to any station from\r\nany other station using only two-way railways.Because of the\r\ntechnological limitation, Nitori can only construct one-way railways,\r\nwhose length can be arbitrary positive integer. Constructing a one-way\r\nrailway from station u will costs w_u units of resources, no matter\r\nwhere the railway ends. To ease the congestion, Nitori plans that after\r\nconstruction there are at least two shortest paths from station 1 to any\r\nother station, and these two shortest paths do not pass the same station\r\nexcept station 1 and the terminal. Besides, Nitori also does not want to\r\nchange the distance of the shortest path from station 1 to any other\r\nstation.Due to various reasons, sometimes the cost of building a new\r\nrailway will increase uncontrollably. There will be a total of q\r\noccurrences of this kind of incident, and the i-th event will add\r\nadditional amount of x_i to the cost of building a new railway from the\r\nstation k_i.To save resources, before all incidents and after each\r\nincident, Nitori wants you to help her calculate the minimal cost of\r\nrailway construction.\r\n", "solutions": ["#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//merge \u3067\u7247\u65b9\u304c inactive \u306e\u3068\u304d\u306f\u3082\u3046\u7247\u65b9\u3092\u305d\u306e\u307e\u307e\u8fd4\u3059\uff0c\n//\u3068\u3044\u3063\u305f\u3068\u304d\u306b\uff0clazy \u306e\u60c5\u5831\u307e\u3067\u30b3\u30d4\u30fc\u3057\u3066\u6e21\u3055\u306a\u3044\u3088\u3046\u306b\u3059\u308b\n\n//get \u306e\u6700\u5f8c\u306e\u5f15\u6570\u306f\u5358\u4f4d\u5143\u3068\u53e3\u3067\u306f\u8a00\u3044\u3064\u3064\u30fb\u30fb\u30fb\uff1f\n//\u305f\u3068\u3048\u3070 min \u3067\u6700\u5f8c\u306e\u5f15\u6570\u3092 0 \u306b\u3057\u3066\u3082 1 \u3068\u304b\u304c\u8fd4\u3063\u3066\u304f\u308b\u3053\u3068\u306f\u3042\u308b\uff08\u4e00\u6557\uff09\n\n//VERIFY: yosupo\n//KUPC2017I\n//HDU 5306 Gorgeous Sequence\n//findmin/max CF458E\ntemplate<class N>\nstruct segbeats{\n\tvc<N> x;\n\tint s;\n\tsegbeats(){}\n\ttemplate<class T>\n\tsegbeats(const vc<T>& a){\n\t\tint n=a.size();\n\t\ts=1;\n\t\twhile(s<n)s*=2;\n\t\tx.resize(s*2);\n\t\trep(i,n)\n\t\t\tx[s+i]=N(a[i]);\n\t\tgnr(i,1,s)\n\t\t\tupd(i);\n\t}\n\tvoid push(int i){\n\t\tx[i].push(x[i*2],x[i*2+1]);\n\t}\n\tvoid upd(int i){\n\t\tx[i]=N::merge(x[i*2],x[i*2+1]);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid chr(int l,int r,int i,int b,int e,F f,Args&&... args){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(b<=l&&r<=e&&(x[i].*f)(forward<Args>(args)...))\n\t\t\treturn;\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tchr(l,m,i*2,b,e,f,forward<Args>(args)...);\n\t\tchr(m,r,i*2+1,b,e,f,forward<Args>(args)...);\n\t\tupd(i);\n\t}\n\ttemplate<class F,class... Args>\n\tvoid ch(int b,int e,F f,Args&&... args){\n\t\tassert(b<=e);\n\t\tchr(0,s,1,b,e,f,forward<Args>(args)...);\n\t}\n\t//use decltype((declval<N>().*F())()) for old-fashioned judges\n\ttemplate<class F,class G,class H>\n\tauto getr(int l,int r,int i,int b,int e,F f,G g,H h){\n\t\tif(e<=l||r<=b)\n\t\t\treturn h;\n\t\tif(b<=l&&r<=e)\n\t\t\treturn (x[i].*f)();\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\treturn g(getr(l,m,i*2,b,e,f,g,h),getr(m,r,i*2+1,b,e,f,g,h));\n\t}\n\ttemplate<class F,class G,class H>\n\tauto get(int b,int e,F f,G g,H h){\n\t\tassert(b<=e);\n\t\treturn getr(0,s,1,b,e,f,g,h);\n\t}\n\tauto compositer(int l,int r,int i,int b,int e){\n\t\tif(e<=l||r<=b)assert(0);\n\t\tif(b<=l&&r<=e)\n\t\t\treturn x[i];\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tif(e<=m)return compositer(l,m,i*2,b,e);\n\t\tif(m<=b)return compositer(m,r,i*2+1,b,e);\n\t\treturn N::merge(compositer(l,m,i*2,b,e),compositer(m,r,i*2+1,b,e));\n\t}\n\t//work without identity node\n\tauto composite(int b,int e){\n\t\tassert(b<e);\n\t\treturn compositer(0,s,1,b,e);\n\t}\n\tN getall(){return x[1];}\n\t//return minimum index\n\ttemplate<class F,class...Args>\n\tpair<int,N> findminr(int i,int l,int r,int b,int e,F f,Args&&...args){\n\t\tif(e<=l||r<=b)return {e,N()};\n\t\tif(b<=l&&r<=e){\n\t\t\tif(!(x[i].*f)(forward<Args>(args)...))return {e,N()};\n\t\t\tif(r-l==1)return {l,x[i]};\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tauto a=findminr(i*2,l,m,b,e,f,forward<Args>(args)...);\n\t\tif(a.a<e)return a;\n\t\treturn findminr(i*2+1,m,r,b,e,f,forward<Args>(args)...);\n\t}\n\ttemplate<class F,class...Args>\n\tpair<int,N> findmin(int b,int e,F f,Args&&...args){\n\t\tassert(b<=e);\n\t\treturn findminr(1,0,s,b,e,f,forward<Args>(args)...);\n\t}\n\t//return maximum index\n\ttemplate<class F,class...Args>\n\tpair<int,N> findmaxr(int i,int l,int r,int b,int e,F f,Args&&...args){\n\t\tif(e<=l||r<=b)return {b-1,N()};\n\t\tif(b<=l&&r<=e){\n\t\t\tif(!(x[i].*f)(forward<Args>(args)...))return {b-1,N()};\n\t\t\tif(r-l==1)return {l,x[i]};\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tauto a=findmaxr(i*2+1,m,r,b,e,f,forward<Args>(args)...);\n\t\tif(a.a>=b)return a;\n\t\treturn findmaxr(i*2,l,m,b,e,f,forward<Args>(args)...);\n\t}\n\ttemplate<class F,class...Args>\n\tpair<int,N> findmax(int b,int e,F f,Args&&...args){\n\t\tassert(b<=e);\n\t\treturn findmaxr(1,0,s,b,e,f,forward<Args>(args)...);\n\t}\n\tvoid enumerater(int l,int r,int i,int b,int e,vc<N>&dst){\n\t\tif(e<=l||r<=b)\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.pb(x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerater(l,m,i*2,b,e,dst);\n\t\tenumerater(m,r,i*2+1,b,e,dst);\n\t}\n\tvoid enumerate(int b,int e,vc<N>&dst){\n\t\tassert(b<=e);\n\t\treturn enumerater(0,s,1,b,e,dst);\n\t}\n\t\n\t//KUPC 2020 G\n\ttemplate<class F,class...Args>\n\tvoid enumerate_by_findr(int l,int r,int i,int b,int e,vc<pair<int,N>>&dst,F f,Args&&...args){\n\t\tif(e<=l||r<=b||!(x[i].*f)(forward<Args>(args)...))\n\t\t\treturn;\n\t\tif(l+1==r){\n\t\t\tdst.eb(l,x[i]);\n\t\t\treturn;\n\t\t}\n\t\tpush(i);\n\t\tint m=(l+r)/2;\n\t\tenumerate_by_findr(l,m,i*2,b,e,dst,f,forward<Args>(args)...);\n\t\tenumerate_by_findr(m,r,i*2+1,b,e,dst,f,forward<Args>(args)...);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid enumerate_by_find(int b,int e,vc<pair<int,N>>&dst,F f,Args&&...args){\n\t\tassert(b<=e);\n\t\tenumerate_by_findr(0,s,1,b,e,dst,f,forward<Args>(args)...);\n\t}\n\tvoid prepare(int i){\n\t\tif(i/=2){\n\t\t\tprepare(i);\n\t\t\tpush(i);\n\t\t}\n\t}\n\t//point_update \u3068 lazy \u3092\u7d44\u307f\u5408\u308f\u305b\u305f\u3089\u3069\u3046\u306a\u308b\u304b\u306f\uff0c\u308f\u304b\u3089\u306a\u3044\u30fb\u30fb\u30fb\n\tvoid point_set(int i,N w){\n\t\ti+=s;\n\t\tprepare(i);\n\t\tx[i]=w;\n\t\twhile(i/=2)\n\t\t\tupd(i);\n\t}\n\ttemplate<class F,class...Args>\n\tvoid point_change(int i,F f,Args&&...args){\n\t\ti+=s;\n\t\tprepare(i);\n\t\t(x[i].*f)(forward<Args>(args)...);\n\t\twhile(i/=2)\n\t\t\tupd(i);\n\t}\n\t//not verified\n\tN point_get(int i){\n\t\ti+=s;\n\t\tprepare(i);\n\t\treturn x[i];\n\t}\n};\n\n//N::push\n//push\u3057\u305f\u3042\u3068\u306fclear\u3059\u308b\n//N::merge\n\nstruct N{\n\tull mx,cnt,sec,sum,lz;\n\tN(ull v=0):mx(v),cnt(1),sec(0),sum(v),lz(-1){}\n\tbool setlim(ull v){\n\t\tif(mx<=v){\n\t\t\tchmin(lz,v);\n\t\t\treturn true;\n\t\t}\n\t\tif(sec<v){\n\t\t\tchmin(lz,v);\n\t\t\tsum-=(mx-v)*cnt;\n\t\t\tmx=v;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tvoid push(N&x,N&y){\n\t\tbool tmp=x.setlim(lz);\n\t\tassert(tmp);\n\t\ttmp=y.setlim(lz);\n\t\tassert(tmp);\n\t\tlz=-1;\n\t}\n\tstatic N merge(N x,N y){\n\t\tN res;\n\t\tres.mx=max(x.mx,y.mx);\n\t\tres.sec=max(x.sec,y.sec);\n\t\tres.cnt=0;\n\t\tif(res.mx==x.mx)res.cnt+=x.cnt;\n\t\telse chmax(res.sec,x.mx);\n\t\tif(res.mx==y.mx)res.cnt+=y.cnt;\n\t\telse chmax(res.sec,y.mx);\n\t\tres.sum=x.sum+y.sum;\n\t\treturn res;\n\t}\n};\n\ntemplate<class E,class D=ll>\npair<vc<D>,vi> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,infLL);\n\tvi from(n,-1);\n\tconst auto ar=[&](int v,D d,int f){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.emplace(d,v);\n\t\t\tfrom[v]=f;\n\t\t}\n\t};\n\tar(s,0,-1);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tif(dist[v]!=d)continue;\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost,v);\n\t}\n\treturn mp(dist,from);\n}\n\nstruct E{\n\tint to,cost;\n\toperator int()const{return to;}\n};\n\nvoid slv(){\n\tint n,m,q;cin>>n>>m>>q;\n\tvi w=readvi(n);\n\tvvc<E> g(n);\n\trep(_,m){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\ta--;b--;\n\t\tg[a].pb({b,c});\n\t\tg[b].pb({a,c});\n\t}\n\tvi dist=dijkstra(g,0).a;\n\tvc<pi> qs(q);\n\trep(i,q){\n\t\tqs[i]=readpi();\n\t\tqs[i].a--;\n\t\tw[qs[i].a]+=qs[i].b;\n\t}\n\tvi ls,cnt(n),idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return dist[i]<dist[j];});\n\tvi pos(n);\n\trep(i,n)pos[idx[i]]=i;\n\trep(i,n){\n\t\tfor(auto e:g[i]){\n\t\t\tif(dist[e.to]==dist[i]+e.cost){\n\t\t\t\tcnt[e.to]++;\n\t\t\t}\n\t\t}\n\t}\n\tvi lds;\n\tfor(auto i:idx){\n\t\tif(cnt[i]==1){\n\t\t\tls.pb(pos[i]);\n\t\t\tlds.pb(dist[i]);\n\t\t}\n\t}\n\tassert(is_sorted(all(ls)));\n\tassert(is_sorted(all(lds)));\n\tvvc<pi> zs(n);\n\trep(i,n){\n\t\tvi cut{lwb(lds,dist[i]+1)-1,si(ls)};\n\t\tif(i)for(auto e:g[i]){\n\t\t\tif(dist[e.to]==dist[i]+e.cost){\n\t\t\t\tauto itr=lower_bound(all(ls),pos[e.to]);\n\t\t\t\tif(itr!=ls.ed&&*itr==pos[e.to]&&cut[0]<itr-ls.bg)\n\t\t\t\t\tcut.pb(itr-ls.bg);\n\t\t\t}\n\t\t}\n\t\tsort(all(cut));\n\t\trep(j,si(cut)-1)if(cut[j]+1<cut[j+1]){\n\t\t\tzs[i].eb(cut[j]+1,cut[j+1]);\n\t\t}\n\t}\n\t//Broken Time Complexity\n\t//I hope weak tests\n\tsegbeats<N> seg(vi(si(ls),*max_element(all(w))));\n\tauto upd=[&](int i,int val){\n\t\tfor(const auto&[l,r]:zs[i])\n\t\t\tseg.ch(l,r,&N::setlim,val);\n\t};\n\tvc<ull> tmp;\n\tauto output=[&](){\n\t\ttmp.pb(seg.x[1].sum);\n\t};\n\trep(i,n)upd(i,w[i]);\n\toutput();\n\tper(i,q){\n\t\tupd(qs[i].a,w[qs[i].a]-=qs[i].b);\n\t\toutput();\n\t}\n\treverse(all(tmp));\n\tfor(auto val:tmp)print(val);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "data structures", "graphs", "shortest paths"], "dificulty": "3400", "interactive": false}