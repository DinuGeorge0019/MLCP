{
    "link": "https://codeforces.com//contest/1444/problem/D",
    "problemId": "781577",
    "problem_idx": "D",
    "shortId": "1444D",
    "contest_number": "1444",
    "problem_submissions": {
        "E": [
            177060864,
            97660118,
            97359218,
            97528673,
            105295397,
            97391457,
            107899094
        ],
        "D": [
            97340003,
            97340266,
            97342285,
            97342896,
            97337709,
            97340895,
            97341601,
            97345333,
            97349700,
            97373326,
            97348927,
            97326702,
            97346935,
            97347842,
            97348566,
            97344354,
            97348921,
            97341198,
            97348249,
            97341495,
            97349542
        ],
        "C": [
            97320701,
            97319171,
            97319507,
            97327690,
            97320892,
            97327102,
            97328013,
            97321796,
            97328337,
            97336256,
            97330742,
            97325357,
            97336388,
            97333742,
            97327914,
            97322996,
            97331358,
            99653258,
            97349832,
            97328361
        ],
        "B": [
            97309345,
            97307941,
            97312731,
            97313742,
            97309124,
            97318228,
            97312056,
            97312423,
            97316008,
            97338138,
            97314968,
            97311029,
            97312318,
            97313371,
            97314101,
            97346837,
            97315650,
            97314655,
            97317415
        ],
        "A": [
            97303759,
            97308441,
            97306115,
            97307464,
            97305751,
            97307808,
            97306079,
            97306446,
            97310249,
            97339306,
            97309724,
            97306667,
            97305992,
            97307462,
            97306550,
            97306839,
            97306977,
            97308612,
            97308951
        ]
    },
    "name": "D. Rectangular Polyline",
    "statement": "One drew a closed polyline on a plane, that consisted only of vertical\r\nand horizontal segments (parallel to the coordinate axes). The segments\r\nalternated between horizontal and vertical ones (a horizontal segment\r\nwas always followed by a vertical one, and vice versa). The polyline did\r\nnot contain strict self-intersections, which means that in case any two\r\nsegments shared a common point, that point was an endpoint for both of\r\nthem (please consult the examples in the notes section).Unfortunately,\r\nthe polyline was erased, and you only know the lengths of the horizonal\r\nand vertical segments. Please construct any polyline matching the\r\ndescription with such segments, or determine that it does not exist.\r\n",
    "solutions": [
        "#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> bool chmin(T &t, const T &f) { if (t > f) { t = f; return true; } return false; }\ntemplate <class T> bool chmax(T &t, const T &f) { if (t < f) { t = f; return true; } return false; }\n\nconstexpr int MAX_N = 1010;\nconstexpr int MAX_M = 1000 * 1000 / 2 / 2 + 10;\n\nint N[2];\nint A[2][MAX_N];\n\nbitset<MAX_M> dp[MAX_N];\nvector<pair<int, int>> ans;\n\nbool solve() {\n  if (N[0] != N[1]) {\n    return false;\n  }\n  \n  int ls[2] = {};\n  vector<int> bsss[2][2];\n  for (int h = 0; h < 2; ++h) {\n    for (int i = 0; i < N[h]; ++i) {\n      ls[h] += A[h][i];\n    }\n    if (ls[h] % 2 != 0) {\n      return false;\n    }\n    ls[h] /= 2;\n    for (int i = 0; i <= N[h]; ++i) {\n      dp[i].reset();\n    }\n    dp[0][0] = true;\n    for (int i = 0; i < N[h]; ++i) {\n      dp[i + 1] = dp[i] | dp[i] << A[h][i];\n    }\n    if (!dp[N[h]][ls[h]]) {\n      return false;\n    }\n    int l = ls[h];\n    for (int i = N[h]; i--; ) {\n      if (dp[i][l]) {\n        bsss[h][0].push_back(A[h][i]);\n      } else {\n        bsss[h][1].push_back(A[h][i]);\n        l -= A[h][i];\n        assert(dp[i][l]);\n      }\n    }\n    assert(l == 0);\n// for(int s=0;s<2;++s){cerr<<h<<\" \"<<s<<\": \";pv(bsss[h][s].begin(),bsss[h][s].end());}\n  }\n  \n  \n  if (bsss[0][0].size() > bsss[0][1].size()) {\n    swap(bsss[0][0], bsss[0][1]);\n  }\n  if (bsss[1][0].size() < bsss[1][1].size()) {\n    swap(bsss[1][0], bsss[1][1]);\n  }\n  assert(bsss[0][0].size() <= bsss[1][0].size());\n  assert(bsss[0][1].size() >= bsss[1][1].size());\n  for (int s = 0; s < 2; ++s) {\n    sort(bsss[0][s].begin(), bsss[0][s].end(), greater<int>());\n    sort(bsss[1][s].begin(), bsss[1][s].end());\n  }\n  ans.clear();\n  int xs[2] = {};\n  for (int j = 0; j < N[0]; ++j) {\n    for (int h = 0; h < 2; ++h) {\n      ans.emplace_back(xs[0], xs[1]);\n      if (j < (int)bsss[h][0].size()) {\n        xs[h] += bsss[h][0][j];\n      } else {\n        xs[h] -= bsss[h][1][j - (int)bsss[h][0].size()];\n      }\n    }\n  }\n  assert(xs[0] == 0);\n  assert(xs[1] == 0);\n// cerr<<\"ans = \";pv(ans.begin(),ans.end());\n  \n  /*\n  set<pair<int, int>> ss;\n  for (const auto &p : ans) {\n    if (!ss.insert(p).second) {\n      return false;\n    }\n  }\n  */\n  return true;\n}\n\nint main() {\n  int numCases;\n  for (; ~scanf(\"%d\", &numCases); ) {\n    for (int caseId = 0; caseId < numCases; ++caseId) {\n      for (int h = 0; h < 2; ++h) {\n        scanf(\"%d\", &N[h]);\n        for (int i = 0; i < N[h]; ++i) {\n          scanf(\"%d\", &A[h][i]);\n        }\n      }\n      \n      const bool res = solve();\n      if (res) {\n        puts(\"Yes\");\n        for (const auto &p : ans) {\n          printf(\"%d %d\\n\", p.first, p.second);\n        }\n      } else {\n        puts(\"No\");\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "geometry"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Rectangular Polyline.json",
    "editorial_link": "https://codeforces.com//blog/entry/84248",
    "editorial": "First, note that in a correct polyline, since the horizontal and\nvertical segments alternate, : if this equality does not hold, the\nanswer is negative. Now let\u00e2\u0080\u0099s fix a vertex and go around the polyline in\nsome direction. Then in the process of traversin, we will move in one of\nfour possible directions: up, down, right or left. Since the polyline is\nclosed, this means that we will move to the left in total by the same\ndistance as we will move to the left in total. The same is true for\nmoving up and down.This means that if we split all the segments into\nfour sets named , , , , then the total length of the segments in will be\nequal to the total length of the segments in , and the total length of\nthe segments in will be equal to the total length of the segments in .\nBut it means that the set of lengths of all horizontal segments can be\ndivided into two sets with the same sum. The same should hold for\nvertical segments.Let\u00e2\u0080\u0099s check whether it is possible to divide the set\nof lengths of horizontal segments into two sets of the same sum. This\nclassic problem can be solved by applying the dynamic programming method\nto solve the backpack problem. The complexity of this solution will be\nIf it is impossible to split horizontal or vertical lengths into two\nsets of equal length, the answer is . Now we will show how to construct\na correct answer if such divisions exist.Let us divide all horizontal\nlengths into two sets of equal total length. We denote the smaller set\nas , and the larger set as . We will do the same with the set of lengths\nof vertical segments: we will denote the smaller set as , and the larger\none as . Since , . Similarly, we have , which follows that , .Now let\u00e2\u0080\u0099s\ndivide all the segments into pairs as follows: each segment of , we\nmatch with a segment from . All remaining segments of are matched with\none of the remaining vertical segments. Thus, we have divided all these\nsegments into three sets of pairs: in the first one, a segment from is\npaired with a segment from . In the second set a segment from is paired\nwith a segment from . In the third set a segment from is paired with a\nsegment from . From the first set of pairs, we make up the set of\nvectors directed up and to the right (from the pair (r, u), we construct\nthe vector (r, u)). This way we can construct a set of vectors . We will\ndo the same with the second set of pairs (constructing a set of vectors\n) and the third set of pairs (constructing a set of vectors ). for a\nbetter understanding, see the picture above. Note that the set may be\nempty, while the other two can not.Let\u00e2\u0080\u0099s make a convex polyline from the\nvectors of . In order to do this, sort them in ascending order by the\npolar angle and make a polyline from them in this order (see the picture\nbelow).Now we will replace each of the vectors of our polyline with two\nvectors: one vector directed to the right and one vector directed\nupwards. We will do the same for vectors from : sort them in ascending\norder by the polar angle and make a convex polyline from them: Let\u00e2\u0080\u0099s\ncombine these two polylines so that the first one goes from the point to\nthe point and the second one goes from the point to the point : We don\u00e2\u0080\u0099t\nhave much left to do: we hate to connect the points and using vectors\nfrom the set . Let\u00e2\u0080\u0099s take these vectors (directed up and to the left) in\nany arbitrary order, then, since the sum of all vectors is 0, the\nresulting polyline, if you draw it with the beginning at the point ,\nwill end at the point . Since the first two polylines were convex, this\nmeans that none of the points of the first two polylines will lie\nstrictly inside the angle , which means that if you replace each of the\nvectors of the third polyline with two vectors, one directed to the left\nand one directed upwards, the resulting closed polyline will not contain\nself-intersections. It is easy to show that the resulting polyline will\nbe closed and will satisfy all the conditions of the problem:\n"
}