{"link": "https://codeforces.com//contest/1444/problem/D", "problemId": "781577", "problem_idx": "D", "shortId": "1444D", "contest_number": "1444", "problem_submissions": {"E": [177060864, 97660118, 97359218, 97528673, 105295397, 97391457, 107899094], "D": [97340003, 97340266, 97342285, 97342896, 97337709, 97340895, 97341601, 97345333, 97349700, 97373326, 97348927, 97326702, 97346935, 97347842, 97348566, 97344354, 97348921, 97341198, 97348249, 97341495, 97349542], "C": [97320701, 97319171, 97319507, 97327690, 97320892, 97327102, 97328013, 97321796, 97328337, 97336256, 97330742, 97325357, 97336388, 97333742, 97327914, 97322996, 97331358, 99653258, 97349832, 97328361], "B": [97309345, 97307941, 97312731, 97313742, 97309124, 97318228, 97312056, 97312423, 97316008, 97338138, 97314968, 97311029, 97312318, 97313371, 97314101, 97346837, 97315650, 97314655, 97317415], "A": [97303759, 97308441, 97306115, 97307464, 97305751, 97307808, 97306079, 97306446, 97310249, 97339306, 97309724, 97306667, 97305992, 97307462, 97306550, 97306839, 97306977, 97308612, 97308951]}, "name": "D. Rectangular Polyline", "statement": "One drew a closed polyline on a plane, that consisted only of vertical\r\nand horizontal segments (parallel to the coordinate axes). The segments\r\nalternated between horizontal and vertical ones (a horizontal segment\r\nwas always followed by a vertical one, and vice versa). The polyline did\r\nnot contain strict self-intersections, which means that in case any two\r\nsegments shared a common point, that point was an endpoint for both of\r\nthem (please consult the examples in the notes section).Unfortunately,\r\nthe polyline was erased, and you only know the lengths of the horizonal\r\nand vertical segments. Please construct any polyline matching the\r\ndescription with such segments, or determine that it does not exist.\r\n", "solutions": ["#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing Int = long long;\n\ntemplate <class T1, class T2> ostream &operator<<(ostream &os, const pair<T1, T2> &a) { return os << \"(\" << a.first << \", \" << a.second << \")\"; };\ntemplate <class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cerr << *i << \" \"; cerr << endl; }\ntemplate <class T> bool chmin(T &t, const T &f) { if (t > f) { t = f; return true; } return false; }\ntemplate <class T> bool chmax(T &t, const T &f) { if (t < f) { t = f; return true; } return false; }\n\nconstexpr int MAX_N = 1010;\nconstexpr int MAX_M = 1000 * 1000 / 2 / 2 + 10;\n\nint N[2];\nint A[2][MAX_N];\n\nbitset<MAX_M> dp[MAX_N];\nvector<pair<int, int>> ans;\n\nbool solve() {\n  if (N[0] != N[1]) {\n    return false;\n  }\n  \n  int ls[2] = {};\n  vector<int> bsss[2][2];\n  for (int h = 0; h < 2; ++h) {\n    for (int i = 0; i < N[h]; ++i) {\n      ls[h] += A[h][i];\n    }\n    if (ls[h] % 2 != 0) {\n      return false;\n    }\n    ls[h] /= 2;\n    for (int i = 0; i <= N[h]; ++i) {\n      dp[i].reset();\n    }\n    dp[0][0] = true;\n    for (int i = 0; i < N[h]; ++i) {\n      dp[i + 1] = dp[i] | dp[i] << A[h][i];\n    }\n    if (!dp[N[h]][ls[h]]) {\n      return false;\n    }\n    int l = ls[h];\n    for (int i = N[h]; i--; ) {\n      if (dp[i][l]) {\n        bsss[h][0].push_back(A[h][i]);\n      } else {\n        bsss[h][1].push_back(A[h][i]);\n        l -= A[h][i];\n        assert(dp[i][l]);\n      }\n    }\n    assert(l == 0);\n// for(int s=0;s<2;++s){cerr<<h<<\" \"<<s<<\": \";pv(bsss[h][s].begin(),bsss[h][s].end());}\n  }\n  \n  \n  if (bsss[0][0].size() > bsss[0][1].size()) {\n    swap(bsss[0][0], bsss[0][1]);\n  }\n  if (bsss[1][0].size() < bsss[1][1].size()) {\n    swap(bsss[1][0], bsss[1][1]);\n  }\n  assert(bsss[0][0].size() <= bsss[1][0].size());\n  assert(bsss[0][1].size() >= bsss[1][1].size());\n  for (int s = 0; s < 2; ++s) {\n    sort(bsss[0][s].begin(), bsss[0][s].end(), greater<int>());\n    sort(bsss[1][s].begin(), bsss[1][s].end());\n  }\n  ans.clear();\n  int xs[2] = {};\n  for (int j = 0; j < N[0]; ++j) {\n    for (int h = 0; h < 2; ++h) {\n      ans.emplace_back(xs[0], xs[1]);\n      if (j < (int)bsss[h][0].size()) {\n        xs[h] += bsss[h][0][j];\n      } else {\n        xs[h] -= bsss[h][1][j - (int)bsss[h][0].size()];\n      }\n    }\n  }\n  assert(xs[0] == 0);\n  assert(xs[1] == 0);\n// cerr<<\"ans = \";pv(ans.begin(),ans.end());\n  \n  /*\n  set<pair<int, int>> ss;\n  for (const auto &p : ans) {\n    if (!ss.insert(p).second) {\n      return false;\n    }\n  }\n  */\n  return true;\n}\n\nint main() {\n  int numCases;\n  for (; ~scanf(\"%d\", &numCases); ) {\n    for (int caseId = 0; caseId < numCases; ++caseId) {\n      for (int h = 0; h < 2; ++h) {\n        scanf(\"%d\", &N[h]);\n        for (int i = 0; i < N[h]; ++i) {\n          scanf(\"%d\", &A[h][i]);\n        }\n      }\n      \n      const bool res = solve();\n      if (res) {\n        puts(\"Yes\");\n        for (const auto &p : ans) {\n          printf(\"%d %d\\n\", p.first, p.second);\n        }\n      } else {\n        puts(\"No\");\n      }\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "geometry"], "dificulty": "2900", "interactive": false}