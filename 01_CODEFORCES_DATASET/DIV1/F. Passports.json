{
    "link": "https://codeforces.com//contest/1012/problem/F",
    "problemId": "203196",
    "problem_idx": "F",
    "shortId": "1012F",
    "contest_number": "1012",
    "problem_submissions": {
        "D": [
            40965345,
            40960627,
            40962755,
            40958672,
            40960130,
            40960868,
            40957816,
            40962185,
            40977537,
            40977026,
            40958559,
            40961785,
            40963025,
            40963296,
            40964134,
            40968496,
            40964728
        ],
        "E": [
            40960617,
            40966609,
            40966430,
            40968315,
            40959955,
            40968344,
            41293524,
            40971324,
            40961945,
            40965219,
            40964178,
            40964935,
            40966686
        ],
        "C": [
            40946223,
            40950962,
            40949847,
            40947169,
            40948884,
            40951113,
            40948032,
            40950863,
            40949840,
            40948978,
            40950249,
            40944733,
            40947497,
            40951510,
            40946864,
            40950557,
            40948982,
            40953572,
            40952480,
            40955310
        ],
        "B": [
            40942792,
            40947068,
            40945179,
            40941414,
            40943485,
            40944363,
            40943466,
            40948512,
            40943709,
            40942617,
            40946516,
            40941822,
            40945156,
            40945233,
            40943297,
            40953601,
            40943064,
            40946807,
            40947838,
            40944988
        ],
        "A": [
            40940407,
            40940426,
            40944393,
            40940053,
            40941238,
            40941590,
            40941675,
            40939828,
            40941205,
            40939974,
            40940704,
            40939790,
            40943152,
            40941982,
            40942155,
            40942198,
            40952349,
            40943555,
            40944486,
            40941409
        ],
        "F": [
            41294072,
            40975225,
            40975082,
            48927133,
            48926928,
            48926890,
            48926661,
            48926482,
            48926274,
            48926240,
            48926110,
            48925986,
            48925954,
            48925448,
            48924606
        ]
    },
    "name": "F. Passports",
    "statement": "Gleb is a famous competitive programming teacher from Innopolis. He is\r\nplanning a trip to programming camps in the nearest future. Each camp\r\nwill be held in a different country. For each of them, Gleb needs to\r\napply for a visa. For each of these trips Gleb knows three integers: the\r\nnumber of the first day of the trip , the length of the trip in days ,\r\nand the number of days this country\u2019s consulate will take to process a\r\nvisa application and stick a visa in a passport. Gleb has () valid\r\npassports and is able to decide which visa he wants to put in which\r\npassport.For each trip, Gleb will have a flight to that country early in\r\nthe morning of the day and will return back late in the evening of the\r\nday .To apply for a visa on the day , Gleb needs to be in Innopolis in\r\nthe middle of this day. So he can\u2019t apply for a visa while he is on a\r\ntrip, including the first and the last days. If a trip starts the next\r\nday after the end of the other one, Gleb can\u2019t apply for a visa between\r\nthem as well. The earliest Gleb can apply for a visa is day 1.After\r\napplying for a visa of country on day , Gleb will get his passport back\r\nin the middle of the day . Consulates use delivery services, so Gleb can\r\nget his passport back even if he is not in Innopolis on this day. Gleb\r\ncan apply for another visa on the same day he received his passport\r\nback, if he is in Innopolis this day. Gleb will not be able to start his\r\ntrip on day if he doesn\u2019t has a passport with a visa for the\r\ncorresponding country in the morning of day . In particular, the\r\npassport should not be in another country\u2019s consulate for visa\r\nprocessing.Help Gleb to decide which visas he needs to receive in which\r\npassport, and when he should apply for each visa.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = INT_MAX;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  vector<int> s(n), length(n), t(n), by_s(n), by_t(n), by(n), day(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d %d\", &s[i], &length[i], &t[i]);\n    by_s[i] = by_t[i] = i;\n  }\n  vector<int> f(1 << n, inf);\n  vector<pair<int, int>> from(1 << n);\n  f[0] = 1;\n  sort(by_s.begin(), by_s.end(), [&](const int &x, const int &y) {\n    return s[x] < s[y];\n  });\n  sort(by_t.begin(), by_t.end(), [&](const int &x, const int &y) {\n    return t[x] < t[y];\n  });\n  for (int i = 0; i < 1 << n; ++i) {\n    if (f[i] != inf) {\n      int pointer = 0, value = f[i];\n      for (auto j : by_t) {\n        if (!(i >> j & 1)) {\n          while (pointer < n && value + t[j] >= s[by_s[pointer]]) {\n            int p = by_s[pointer++];\n            if ((i >> p & 1) || value >= s[p]) {\n              value = max(value, s[p] + length[p]);\n            }\n          }\n          if (value + t[j] < s[j] && f[i | 1 << j] > value + t[j]) {\n            f[i | 1 << j] = value + t[j];\n            from[i | 1 << j] = make_pair(j, value);\n          }\n        }\n      }\n    }\n  }\n  function<void(int, int)> rec = [&](int x, int type) {\n    if (!x) {\n      return;\n    }\n    int i = from[x].first;\n    by[i] = type;\n    day[i] = from[x].second;\n    rec(x ^ 1 << i, type);\n  };\n  if (m == 1) {\n    if (f[(1 << n) - 1] != inf) {\n      puts(\"YES\");\n      rec((1 << n) - 1, 1);\n      for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", by[i], day[i]);\n      }\n    } else {\n      puts(\"NO\");\n    }\n  } else {\n    int p = -1;\n    for (int i = 0; i < (1 << n); ++i) {\n      if (f[i] != inf && f[(1 << n) - 1 ^ i] != inf) {\n        p = i;\n        break;\n      }\n    }\n    if (!~p) {\n      puts(\"NO\");\n    } else {\n      puts(\"YES\");\n      rec(p, 1);\n      rec((1 << n) - 1 ^ p, 2);\n      for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", by[i], day[i]);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Passports.json",
    "editorial_link": "https://codeforces.com/blog/entry/60920",
    "editorial": "Let\u00e2\u0080\u0099s solve the case first. We\u00e2\u0080\u0099ll use dynamic programming on subsets.\r\nLet\u00e2\u0080\u0099s try to add visas to subset in order of application. Notice that if\r\nwe only have one passport, every visa processing segment should lie\r\nbetween some two consecutive trips. For convenience, let\u00e2\u0080\u0099s find all\r\nthese segments beforehand.Define as the minimum day, before which all\r\nvisas from set can be acquired. Try all possible as a visa which Gleb\r\nwill apply for next. Now we have to find minimum possible day of\r\napplication , such that , segment does not intersect with any trip, and\r\n. Such can be found in by a linear search over precalculated free\r\nsegment. Relax the value of with . If then there is a solution that can\r\nbe restored using standard techniques. Total time complexity is , that\r\ncan be too slow for . Let\u00e2\u0080\u0099s generalize this solution for . Still, Gleb\r\ncan apply for a visa only when he is in Innopolis. However, the last day\r\nof visa processing can be during some trip, but only if all trips\r\nbetween the day of visa application and the day of visa acquisition use\r\nanother passport. We will slightly change the definition of : now this\r\nvalue is equal to the minimum possible day, by which it\u00e2\u0080\u0099s possible to\r\nfinish processing all visas from set with one passport, assuming all\r\ntrips not from use another passport. By this definition, calculation of\r\nDP transition is a little bit different: when trying to add visa we have\r\nto find minimum , such that , during day Gleb is in Innopolis, and\r\nsegment does not intersect with half-closed intervals for all . This can\r\nbe implemented similarly to the first part in . Total running time is ,\r\nthat can pass system tests with some optimizations.We\u00e2\u0080\u0099ll optimize the\r\nsolution down to . To do that, we process all transition from set in\r\ntotal time. Sort all visas in order of increasing . Then the optimal\r\nvisa application day will be increasing if visa processing time\r\nincreases. Now we can apply two pointers technique to get total\r\nprocessing time for one set and for all sets.After calculating for all\r\nsubsets, we have to try all partitions of into two sets and and check if\r\nboth and can be done with one passport each. This is equivalent to . If\r\nthere are two such sets that and , then we have found the answer,\r\notherwise there is no answer.\r\n"
}