{"link": "https://codeforces.com//contest/1012/problem/F", "problemId": "203196", "problem_idx": "F", "shortId": "1012F", "contest_number": "1012", "problem_submissions": {"D": [40965345, 40960627, 40962755, 40958672, 40960130, 40960868, 40957816, 40962185, 40977537, 40977026, 40958559, 40961785, 40963025, 40963296, 40964134, 40968496, 40964728], "E": [40960617, 40966609, 40966430, 40968315, 40959955, 40968344, 41293524, 40971324, 40961945, 40965219, 40964178, 40964935, 40966686], "C": [40946223, 40950962, 40949847, 40947169, 40948884, 40951113, 40948032, 40950863, 40949840, 40948978, 40950249, 40944733, 40947497, 40951510, 40946864, 40950557, 40948982, 40953572, 40952480, 40955310], "B": [40942792, 40947068, 40945179, 40941414, 40943485, 40944363, 40943466, 40948512, 40943709, 40942617, 40946516, 40941822, 40945156, 40945233, 40943297, 40953601, 40943064, 40946807, 40947838, 40944988], "A": [40940407, 40940426, 40944393, 40940053, 40941238, 40941590, 40941675, 40939828, 40941205, 40939974, 40940704, 40939790, 40943152, 40941982, 40942155, 40942198, 40952349, 40943555, 40944486, 40941409], "F": [41294072, 40975225, 40975082, 48927133, 48926928, 48926890, 48926661, 48926482, 48926274, 48926240, 48926110, 48925986, 48925954, 48925448, 48924606]}, "name": "F. Passports", "statement": "Gleb is a famous competitive programming teacher from Innopolis. He is\r\nplanning a trip to programming camps in the nearest future. Each camp\r\nwill be held in a different country. For each of them, Gleb needs to\r\napply for a visa. For each of these trips Gleb knows three integers: the\r\nnumber of the first day of the trip , the length of the trip in days ,\r\nand the number of days this country\u2019s consulate will take to process a\r\nvisa application and stick a visa in a passport. Gleb has () valid\r\npassports and is able to decide which visa he wants to put in which\r\npassport.For each trip, Gleb will have a flight to that country early in\r\nthe morning of the day and will return back late in the evening of the\r\nday .To apply for a visa on the day , Gleb needs to be in Innopolis in\r\nthe middle of this day. So he can\u2019t apply for a visa while he is on a\r\ntrip, including the first and the last days. If a trip starts the next\r\nday after the end of the other one, Gleb can\u2019t apply for a visa between\r\nthem as well. The earliest Gleb can apply for a visa is day 1.After\r\napplying for a visa of country on day , Gleb will get his passport back\r\nin the middle of the day . Consulates use delivery services, so Gleb can\r\nget his passport back even if he is not in Innopolis on this day. Gleb\r\ncan apply for another visa on the same day he received his passport\r\nback, if he is in Innopolis this day. Gleb will not be able to start his\r\ntrip on day if he doesn\u2019t has a passport with a visa for the\r\ncorresponding country in the morning of day . In particular, the\r\npassport should not be in another country\u2019s consulate for visa\r\nprocessing.Help Gleb to decide which visas he needs to receive in which\r\npassport, and when he should apply for each visa.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = INT_MAX;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  vector<int> s(n), length(n), t(n), by_s(n), by_t(n), by(n), day(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d %d\", &s[i], &length[i], &t[i]);\n    by_s[i] = by_t[i] = i;\n  }\n  vector<int> f(1 << n, inf);\n  vector<pair<int, int>> from(1 << n);\n  f[0] = 1;\n  sort(by_s.begin(), by_s.end(), [&](const int &x, const int &y) {\n    return s[x] < s[y];\n  });\n  sort(by_t.begin(), by_t.end(), [&](const int &x, const int &y) {\n    return t[x] < t[y];\n  });\n  for (int i = 0; i < 1 << n; ++i) {\n    if (f[i] != inf) {\n      int pointer = 0, value = f[i];\n      for (auto j : by_t) {\n        if (!(i >> j & 1)) {\n          while (pointer < n && value + t[j] >= s[by_s[pointer]]) {\n            int p = by_s[pointer++];\n            if ((i >> p & 1) || value >= s[p]) {\n              value = max(value, s[p] + length[p]);\n            }\n          }\n          if (value + t[j] < s[j] && f[i | 1 << j] > value + t[j]) {\n            f[i | 1 << j] = value + t[j];\n            from[i | 1 << j] = make_pair(j, value);\n          }\n        }\n      }\n    }\n  }\n  function<void(int, int)> rec = [&](int x, int type) {\n    if (!x) {\n      return;\n    }\n    int i = from[x].first;\n    by[i] = type;\n    day[i] = from[x].second;\n    rec(x ^ 1 << i, type);\n  };\n  if (m == 1) {\n    if (f[(1 << n) - 1] != inf) {\n      puts(\"YES\");\n      rec((1 << n) - 1, 1);\n      for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", by[i], day[i]);\n      }\n    } else {\n      puts(\"NO\");\n    }\n  } else {\n    int p = -1;\n    for (int i = 0; i < (1 << n); ++i) {\n      if (f[i] != inf && f[(1 << n) - 1 ^ i] != inf) {\n        p = i;\n        break;\n      }\n    }\n    if (!~p) {\n      puts(\"NO\");\n    } else {\n      puts(\"YES\");\n      rec(p, 1);\n      rec((1 << n) - 1 ^ p, 2);\n      for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", by[i], day[i]);\n      }\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "implementation"], "dificulty": "3400", "interactive": false}