{
    "link": "https://codeforces.com//contest/375/problem/D",
    "problemId": "4238",
    "problem_idx": "D",
    "shortId": "375D",
    "contest_number": "375",
    "problem_submissions": {
        "E": [
            5516578,
            5543517,
            7404743,
            7404550
        ],
        "D": [
            5508327,
            5506241,
            5508178,
            5506936,
            5508210,
            5509728,
            5509565,
            5509786,
            5510266,
            5509657,
            5507662,
            5512033,
            5510626,
            5507997,
            5508460,
            5508656,
            5508269,
            5508332,
            5508891
        ],
        "C": [
            5505383,
            5509032,
            5505557,
            5508883,
            5509512,
            5507599,
            5508675,
            5508564,
            5508334,
            5508031,
            5521682,
            5507298,
            5515252
        ],
        "B": [
            5503331,
            5504049,
            5503218,
            5504342,
            5504635,
            5505593,
            5504545,
            5506014,
            5505956,
            5506155,
            5504757,
            5503899,
            5502860,
            5504310,
            5504273,
            5505401,
            5504620,
            5504706
        ],
        "A": [
            5502699,
            5502984,
            5506272,
            5503668,
            5503511,
            5502852,
            5503508,
            5504680,
            5504651,
            5505085,
            5503979,
            5502926,
            5504511,
            5503159,
            5503448,
            5504768,
            5503302,
            5503553
        ]
    },
    "name": "D. Tree and Queries",
    "statement": "You have a rooted tree consisting of vertices. Each vertex of the tree\r\nhas some color. We will assume that the tree vertices are numbered by\r\nintegers from 1 to . Then we represent the color of vertex as . The tree\r\nroot is a vertex with number 1.In this problem you need to answer to\r\nqueries. Each query is described by two integers . The answer to query\r\nis the number of such colors of vertices , that the subtree of vertex\r\ncontains at least vertices of color .You can find the definition of a\r\nrooted tree by the following link: .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\n\nstruct TA {\n\tvector<int> a;\n\tint n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\ta.assign(n, 0);\n\t}\n\tvoid add(int p, int x) {\n\t\tfor (p++; p <= n; p += p & -p)\n\t\t\ta[p - 1] += x;\n\t}\n\tint get(int p) {\n\t\tint r = 0;\n\t\tfor (p++; p; p -= p & -p)\n\t\t\tr += a[p - 1];\n\t\treturn r;\n\t}\n};\n\nstruct Data {\n\tTA ta;\n\tvector<int> a;\n\tint n, tot;\n\n\tData() {\n\t\tn = 1;\n\t\ta.resize(n);\n\t\tta.init(n);\n\t\ttot = 0;\n\t}\n\n\tvoid grow() {\n\t\tta.init(2 * n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tta.add(i, a[i]);\n\t\t}\n\t\ta.resize(2 * n);\n\t\tn <<= 1;\n\t}\n\n\tvoid add(int p, int x) {\n\t\twhile (p >= n)\n\t\t\tgrow();\n\t\tta.add(p, x), tot += x;\n\t\ta[p] += x;\n\t}\n\n\tint get(int p) { //<=p\n\t\tp = min(p, n - 1);\n\t\treturn ta.get(p);\n\t}\n};\n\nint n, m;\nint c[MAX_N];\nvector<int> E[MAX_N];\n\nvector<pair<int, int> > by[MAX_N];\nint ans[MAX_N];\nint L[MAX_N], R[MAX_N], seq[MAX_N], pt;\nvector<int> color[MAX_N];\n\nint size[MAX_N];\n\nvoid dfs1(int u, int par) {\n\tL[u] = pt, seq[pt++] = u, size[u] = 1;\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (*e != par) {\n\t\t\tdfs1(*e, u);\n\t\t\tsize[u] += size[*e];\n\t\t}\n\tR[u] = pt;\n}\n\nint mask[MAX_N], cmask;\n\nint calc(int v, int L, int R) { //v occur in [L,R)\n\tvector<int>&arr = color[v];\n\treturn lower_bound(arr.begin(), arr.end(), R)\n\t\t\t- lower_bound(arr.begin(), arr.end(), L);\n}\n\nvoid update(Data*me, int v, int L, int R, int pL, int pR) {\n\tif (mask[v] == cmask)\n\t\treturn;\n\tmask[v] = cmask;\n\tint old = calc(v, pL, pR), now = calc(v, L, R);\n\tif (old == now)\n\t\treturn;\n\tif (old == 0) {\n\t\tme->add(now, 1);\n\t} else {\n\t\tme->add(old, -1);\n\t\tme->add(now, 1);\n\t}\n}\n\nData*dfs2(int u, int par) {\n\tint v = -1;\n\tData*me = 0;\n\n\tfor (vector<int>::iterator e = E[u].begin(); e != E[u].end(); ++e)\n\t\tif (*e != par) {\n\t\t\tData*c = dfs2(*e, u);\n\t\t\tif (v == -1 || size[*e] > size[v]) {\n\t\t\t\tif (me != 0)\n\t\t\t\t\tdelete me;\n\t\t\t\tv = *e, me = c;\n\t\t\t} else\n\t\t\t\tdelete c;\n\t\t}\n\n\tif (me == 0) {\n\t\tme = new Data;\n\t\tme->add(1, 1);\n\t} else {\n\t\t//update it!\n\t\t++cmask;\n\t\tint L = ::L[u], R = ::R[u];\n\t\tint pL = ::L[v], pR = ::R[v];\n\n\t\tfor (int i = L; i < pL; ++i) {\n\t\t\tupdate(me, c[seq[i]], L, R, pL, pR);\n\t\t}\n\n\t\tfor (int i = pR; i < R; ++i) {\n\t\t\tupdate(me, c[seq[i]], L, R, pL, pR);\n\t\t}\n\t}\n\n\tfor (vector<pair<int, int> >::iterator e = by[u].begin(); e != by[u].end();\n\t\t\t++e) {\n\t\tans[e->second] = me->tot - me->get(e->first - 1);\n\t}\n\treturn me;\n}\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", c + i);\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b), --a, --b;\n\t\tE[a].push_back(b), E[b].push_back(a);\n\t}\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint v, k;\n\t\tscanf(\"%d%d\", &v, &k), --v;\n\t\tby[v].push_back(make_pair(k, i));\n\t}\n\n\tdfs1(0, -1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint u = seq[i];\n\t\tcolor[c[u]].push_back(i);\n\t}\n\n\tData*me = dfs2(0, -1);\n//\tfor (int i = 0; i < me->a.size(); ++i) {\n//\t\tcout << i << \":\" << me->a[i] << endl;\n//\t}\n////\tcout << me->tot << endl;\n//\tcout << me->get(1) << endl;\n\n//\tdelete dfs2(0, -1);\n\tdelete me;\n\tfor (int i = 0; i < m; ++i) {\n\t\tprintf(\"%d\\n\", ans[i]);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Tree and Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/10084",
    "editorial": "Use binary search tree and merge\nthem by rank. Use binary search tree that supports O(n) merging to get\nO(nlogn) solution. O(n*sqrt(n)): Dfs the tree to transform the problem\nto: To solve this problem:\n",
    "hint": []
}