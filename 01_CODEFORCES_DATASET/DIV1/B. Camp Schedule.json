{
    "link": "https://codeforces.com//contest/1137/problem/B",
    "problemId": "309118",
    "problem_idx": "B",
    "shortId": "1137B",
    "contest_number": "1137",
    "problem_submissions": {
        "C": [
            51278692,
            51013174,
            51012138,
            51014594,
            51060015,
            51011758,
            51015377,
            51058095,
            51060423,
            51013462,
            51011929,
            51013820,
            51016620,
            51021729,
            51016142,
            51022376,
            51017039,
            51022733
        ],
        "D": [
            51022280,
            51016149,
            51021902,
            51016444,
            51017886,
            51022110,
            51022575,
            51017121,
            51017510,
            51026190,
            51017887,
            51020056,
            51071936,
            51020439,
            51057402,
            51015057,
            51021542,
            51016650
        ],
        "F": [
            51021456,
            51151872,
            51044265,
            208399382,
            208399328,
            51370362,
            51370305,
            56076657,
            51062431,
            51062375,
            51201422,
            51152102
        ],
        "E": [
            51015510,
            51019659,
            51017815,
            51022086,
            51024208,
            51025483,
            51015317,
            51021155,
            51026207,
            51019242,
            51116875,
            51022655,
            51043942,
            51019234,
            51021992,
            51040600
        ],
        "B": [
            51007898,
            51008699,
            51007790,
            51010637,
            51008661,
            51008854,
            51009928,
            51010030,
            51008543,
            51011271,
            51008351,
            51008938,
            51007902,
            51007130,
            51009176,
            51009835,
            51007086,
            51008751,
            51007248
        ],
        "A": [
            51006589,
            51007409,
            51005936,
            51007585,
            51007232,
            51007035,
            51007494,
            51006878,
            51006201,
            51013385,
            51006659,
            51007366,
            51005796,
            51010835,
            51007279,
            51007757,
            51009144,
            51007439,
            51005946
        ]
    },
    "name": "B. Camp Schedule",
    "statement": "The new camp by widely-known over the country Spring Programming Camp is\r\ngoing to start soon. Hence, all the team of friendly curators and\r\nteachers started composing the camp’s schedule. After some continuous\r\ndiscussion, they came up with a schedule s, which can be represented as\r\na binary string, in which the i-th symbol is ” if students will write\r\nthe contest in the i-th day and ” if they will have a day off.At the\r\nlast moment Gleb said that the camp will be the most productive if it\r\nruns with the schedule t (which can be described in the same format as\r\nschedule s). Since the number of days in the current may be different\r\nfrom number of days in schedule t, Gleb required that the camp’s\r\nschedule must be altered so that the number of occurrences of t in it as\r\na substring is maximum possible. At the same time, , only their order\r\nmay change.Could you rearrange the schedule in the best possible way?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nvector<int> kmp(const T &a) {\n  int n = a.size();\n  vector<int> fail(n);\n  fail[0] = -1;\n  for (int i = 1; i < n; ++i) {\n    fail[i] = fail[i - 1];\n    while (~fail[i] && a[fail[i] + 1] != a[i]) {\n      fail[i] = fail[fail[i]];\n    }\n    if (a[fail[i] + 1] == a[i]) {\n      ++fail[i];\n    }\n  }\n  return fail;\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  string s, t;\n  cin >> s >> t;\n  int zero = 0, one = 0;\n  for (auto c : s) {\n    if (c == '0') {\n      ++zero;\n    } else {\n      ++one;\n    }\n  }\n  vector<int> fail = kmp(t);\n  int cur = 0;\n  while (zero || one) {\n    if (!zero) {\n      cout << 1;\n      --one;\n    } else if (!one) {\n      cout << 0;\n      --zero;\n    } else {\n      cout << t[cur];\n      if (t[cur] == '0') {\n        --zero;\n      } else {\n        --one;\n      }\n      ++cur;\n      if (cur == (int) t.size()) {\n        cur = fail.back() + 1;\n      }\n    }\n  }\n  cout << \"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "hashing",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Camp Schedule.json",
    "editorial_link": "https://codeforces.com/blog/entry/65825",
    "editorial": "If we canât make any occurrences of string in string just output any\r\npermutation of . Otherwise, we can show that there is an optimal answer\r\n, such that it starts with a string .Suppose the opposite, then remove\r\nall characters of the string before the first occurrence of the string\r\nand insert them to the end. The number of occurrences clearly didnât\r\ndecreased.Obviously, we want to make the next occurrence of string in\r\nstring as left as possible. If we decide to make it somewhere else, we\r\ncan move out the extra characters and try to improve the answer. To\r\nachieve this, we need to find the largest suffix of the string that\r\nmatches the prefix of string of the same length. It can be found by\r\nusing the prefix function, z-function or hashes.\r\n",
    "hint": []
}