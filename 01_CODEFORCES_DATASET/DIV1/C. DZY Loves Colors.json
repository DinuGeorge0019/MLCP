{"link": "https://codeforces.com//contest/444/problem/C", "problemId": "11252", "problem_idx": "C", "shortId": "444C", "contest_number": "444", "problem_submissions": {"B": [7031130, 7030965, 7024958, 7024676, 7030446, 7027559, 7026989, 7029436, 7032613, 7026604, 7041433, 7024980], "C": [7029407, 7026783, 7028625, 7029070, 7027854, 7035787, 7035783, 7031351, 7029689, 7028909, 7032738, 7033609, 7027863, 7030366, 7026206, 7047158, 7029026, 7027864], "A": [7026572, 7023113, 7022682, 7021917, 7022193, 7021891, 7023277, 7021994, 7023490, 7022290, 7021818, 7029841, 7024232, 7028150, 7022608, 7022804], "E": [7025382, 7029973, 7031979, 7031957, 7039984, 7039647, 7030433, 7029905, 7030939, 7032469, 7032562, 7035736, 7041366, 7041365, 7041358, 7041326, 7036608], "D": [7030340, 7032449, 7029379, 7031920, 7032235, 7032726, 7027353, 7024739, 7032806, 7032764, 7032749, 7032739, 7032700, 7031354, 7029340, 7031710, 7032104]}, "name": "C. DZY Loves Colors", "statement": "On a colorful day, DZY gets a colorful ribbon, which consists of units\r\n(they are numbered from to from left to right). The color of the -th\r\nunit of the ribbon is at first. It is colorful enough, but we still\r\nconsider that the colorfulness of each unit is at first.DZY loves\r\npainting, we know. He takes up a paintbrush with color and uses it to\r\ndraw a line on the ribbon. In such a case some contiguous units are\r\npainted. Imagine that the color of unit currently is . When it is\r\npainted by this paintbrush, the color of the unit becomes , and the\r\ncolorfulness of the unit increases by .DZY wants to perform operations,\r\neach operation can be one of the following: Paint all the units with\r\nnumbers between and (both inclusive) with color . Ask the sum of\r\ncolorfulness of the units between and (both inclusive). Can you help\r\nDZY?\r\n", "solutions": ["#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define M 1000000007\n#define N 411111\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m;\nlong long sum[N], add[N];\nset<pair<pt, int> > W;\nset<pair<pt, int> > :: iterator it;\n\nvoid mod(int pos, int l, int r, int ll, int rr, long long v) {\n\tll = max(ll, l);\n\trr = min(rr, r);\n\tif (ll > rr) return;\n\tif (l == ll && r == rr) {\n\t\tsum[pos] += (r - l + 1) * v;\n\t\tadd[pos] += v;\n\t\treturn;\n\t}\n\tif (add[pos] != 0) {\n\t\tmod(pos + pos, l, (l + r) / 2, l, r, add[pos]);\n\t\tmod(pos + pos + 1, (l + r) / 2 + 1, r, l, r, add[pos]);\n\t\tadd[pos] = 0;\n\t}\n\tmod(pos + pos, l, (l + r) / 2, ll, rr, v);\n\tmod(pos + pos + 1, (l + r) / 2 + 1, r, ll, rr, v);\n\tsum[pos] = sum[pos + pos] + sum[pos + pos + 1];\n}\n\nlong long fin(int pos, int l, int r, int ll, int rr) {\n\tll = max(ll, l);\n\trr = min(rr, r);\n\tif (ll > rr) return 0;\n\tif (l == ll && r == rr) return sum[pos];\n\tif (add[pos] != 0) {\n\t\tmod(pos + pos, l, (l + r) / 2, l, r, add[pos]);\n\t\tmod(pos + pos + 1, (l + r) / 2 + 1, r, l, r, add[pos]);\n\t\tadd[pos] = 0;\n\t}\n\tlong long q1 = fin(pos + pos, l, (l + r) / 2, ll, rr);\n\tlong long q2 = fin(pos + pos + 1, (l + r) / 2 + 1, r, ll, rr);\n\treturn q1 + q2;\n}\n\nvoid di(int x) {\n\tit = W.lower_bound(mp(mp(x + 1, x), 0));\n\tif (it == W.begin()) return;\n\tit--;\n\tint ll = (*it).F.F;\n\tint rr = (*it).F.S;\n\tint col = (*it).S;\n\tif (x >= ll && x < rr) {\n\t\tW.erase(it);\n\t\tW.insert(mp(mp(ll, x), col));\n\t\tW.insert(mp(mp(x + 1, rr), col));\t\t\n\t}\n}\n\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\t\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) W.insert(mp(mp(i, i), i));\n\twhile (m--) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\t\tif (type == 1) {\n\t\t\tint l, r, x;\n\t\t\tscanf(\"%d%d%d\", &l, &r, &x);\n\t\t\tl--;\n\t\t\tr--;\n\t\t\tx--;\n\t\t\tdi(l - 1);\n\t\t\tdi(r);\n\t\t\tfor(;;) {\n\n\t\t\t\tit = W.lower_bound(mp(mp(l, l), 0));\n\t\t\t\tif (it == W.end() || (*it).F.F > r) break;\n\n\t\t\t\tint dif = abs(x - (*it).S);\n\t\t\t\tmod(1, 0, n - 1, (*it).F.F, (*it).F.S, dif);\n\t\t\t\tW.erase(it);\n\t\t\t}\n\t\t\tW.insert(mp(mp(l, r), x));\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d%d\", &l, &r);\n\t\t\tl--;\n\t\t\tr--;\n\t\t\tprintf(\"%I64d\\n\", fin(1, 0, n - 1, l, r)); \n\t\t}\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2400", "interactive": false}