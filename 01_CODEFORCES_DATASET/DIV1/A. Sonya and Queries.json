{
    "link": "https://codeforces.com//contest/713/problem/A",
    "problemId": "71345",
    "problem_idx": "A",
    "shortId": "713A",
    "contest_number": "713",
    "problem_submissions": {
        "C": [
            26460974,
            20575910,
            20583094,
            20581559,
            20581733,
            20583408,
            20579455,
            20582507,
            20580790,
            20585663,
            37183524,
            20586646,
            20578141,
            20587141,
            20583393,
            20576023,
            20577632,
            20581746,
            20588485,
            80008205,
            79474335,
            20583081,
            20586247,
            20589607
        ],
        "D": [
            20589016,
            20588044,
            20589791,
            20590045,
            20590281,
            20591597,
            20591896,
            20601734,
            20601720,
            20594132,
            20593560,
            20593079,
            20596440,
            20593442,
            20596199,
            20584415,
            20594603,
            20595698,
            20593723,
            20595881,
            24960690,
            20593574
        ],
        "B": [
            20583151,
            20580004,
            20578178,
            20578836,
            20578366,
            20585770,
            20579555,
            20576646,
            20583230,
            20581847,
            20589836,
            20583553,
            20579782,
            20588723,
            20589144,
            20578568,
            20589488,
            20583796,
            20583317
        ],
        "A": [
            20572754,
            20572042,
            20571909,
            20572204,
            20571875,
            20571504,
            20584123,
            20571416,
            20574058,
            20587954,
            20571916,
            20573302,
            20574693,
            20573904,
            20589571,
            20575437,
            20571888,
            20573337,
            20572118,
            20572133
        ],
        "E": [
            20940861,
            20595260
        ]
    },
    "name": "A. Sonya and Queries",
    "statement": "Today Sonya learned about long integers and invited all her friends to\r\nshare the fun. Sonya has an initially empty multiset with integers.\r\nFriends give her queries, each of one of the following type: add\r\nnon-negative integer to the multiset. Note, that she has a multiset,\r\nthus there may be many occurrences of the same integer. delete a single\r\noccurrence of non-negative integer from the multiset. It’s guaranteed,\r\nthat there is at least one in the multiset. count the number of integers\r\nin the multiset (with repetitions) that match some pattern consisting of\r\nand . In the pattern, stands for the even digits, while stands for the\r\nodd. Integer matches the pattern , if the parity of the -th from the\r\nright digit in decimal notation matches the -th from the right digit of\r\nthe pattern. If the pattern is shorter than this integer, it’s\r\nsupplemented with -s from the left. Similarly, if the integer is shorter\r\nthan the pattern its decimal notation is supplemented with the -s from\r\nthe left. For example, if the pattern is , than integers , , and match\r\nthe pattern, while integers , , and do not.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, ap[(1 << 19) + 2];\nchar sir[30];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\\n\", &M);\nwhile (M --)\n{\n    char type;\n    scanf (\"%c \", &type);\n    if (type == '+' || type == '-')\n    {\n        long long x;\n        scanf (\"%I64d\\n\", &x);\n        long long msk = 0;\n        for (int i=18; i>=0; i--)\n        {\n            int dig = x % 10;\n            if (dig & 1) msk |= 1 << i;\n            x /= 10;\n        }\n        if (type == '+') ap[msk] ++;\n        else ap[msk] --;\n        continue;\n    }\n    gets (sir + 1), N = strlen (sir + 1);\n    int j = N, msk = 0;\n    for (int i=18; i>=0; i--)\n    {\n        bool curr = 0;\n        if (j >= 1) curr = sir[j] - '0', j --;\n        if (curr) msk |= 1 << i;\n    }\n    printf (\"%d\\n\", ap[msk]);\n}\n\nreturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Sonya and Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/47094",
    "editorial": "Lets exchange every digit by value of digit modulo and receive binary\r\nstring. We will convert it to binary form in number . array for counts.\r\nIf we have â+â query we increase []. If we have â-â query we decrease\r\n[]. Otherwise we output [].\r\n",
    "hint": []
}