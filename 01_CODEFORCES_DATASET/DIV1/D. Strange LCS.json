{
    "link": "https://codeforces.com//contest/1588/problem/D",
    "problemId": "1186193",
    "problem_idx": "D",
    "shortId": "1588D",
    "contest_number": "1588",
    "problem_submissions": {
        "D": [
            135372629,
            135381098,
            135359109,
            135369800,
            135370088,
            135380867,
            135357823,
            135362201,
            135366407,
            135370846,
            135374380,
            135373580,
            135374295,
            135373419,
            135378493,
            135376601,
            135375978,
            135382040
        ],
        "C": [
            135363142,
            135352112,
            135379109,
            135361010,
            135362653,
            135375549,
            135350810,
            135353082,
            135359513,
            135351205,
            135365941,
            135366190,
            135366197,
            135366261,
            135798161,
            135798159,
            135798156,
            135798153,
            135793795,
            135353318,
            135359719,
            135363580,
            135376282,
            135360557
        ],
        "B": [
            135354041,
            135372942,
            135367733,
            135353235,
            135382607,
            135353847,
            135347088,
            135367644,
            135348462,
            135359847,
            135354086,
            135351940,
            135356516,
            135347194,
            135365557,
            135349342,
            135357424,
            135354885,
            135351181
        ],
        "A": [
            135347972,
            135342643,
            135342911,
            135343015,
            135342760,
            135342918,
            135342730,
            135343666,
            135342808,
            135352544,
            135343056,
            135344466,
            135342657,
            135342700,
            135342859,
            135345441,
            135343145,
            135343927,
            135342677
        ],
        "E": [
            135346443,
            135364189,
            135371530,
            135382787,
            135381160,
            135387683,
            135507210,
            135399676,
            135412491,
            135411131,
            135507958,
            135387301
        ],
        "F": [
            135608326,
            135531498,
            135406993,
            135398120,
            135395364
        ]
    },
    "name": "D. Strange LCS",
    "statement": "You are given n strings s_1, s_2,\r\nldots, s_n, each consisting of lowercase and uppercase English letters.\r\nIn addition, it\u2019s guaranteed that each character occurs in each string .\r\nFind the longest common subsequence of these strings.A string t is a\r\nsubsequence of a string s if t can be obtained from s by deletion of\r\nseveral (possibly, zero or all) symbols.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 1600;\n\nint nxt[11][111][52];\nvector<int> occur[11][52];\n\nint dp[105][512];\npi trk[105][512];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tmemset(nxt, 0, sizeof(nxt));\n\t\tfor(int i = 0; i < 11; i++){\n\t\t\tfor(int j = 0; j < 52; j++){\n\t\t\t\toccur[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tint n; cin >> n;\n\t\tvector<string> s(n);\n\t\tlint prominent = (1ll << 52) - 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\tlint msk = 0;\n\t\t\tfor(auto &j : s[i]){\n\t\t\t\tif(isupper(j)) j -= 'A';\n\t\t\t\telse j -= 'a' - 26;\n\t\t\t\tmsk |= (1ll << j);\n\t\t\t}\n\t\t\tprominent &= msk;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstring t;\n\t\t\tfor(auto &j : s[i]){\n\t\t\t\tif((prominent >> j) & 1) t.push_back(j);\n\t\t\t}\n\t\t\ts[i] = t;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < sz(s[i]); j++){\n\t\t\t\tfor(int k = 0; k < 52; k++){\n\t\t\t\t\tif(s[i][j] == k) nxt[i][j][k] = j;\n\t\t\t\t\telse nxt[i][j][k] = (j == 0 ? -1 : nxt[i][j - 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < sz(s[i]); j++){\n\t\t\t\toccur[i][s[i][j]].push_back(j);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tint tot = 0;\n\t\tpi stpos(-1, -1);\n\t\tfor(int i = 0; i < sz(s[n - 1]); i++){\n\t\t\tchar c = s[n - 1][i];\n\t\t\tfor(int j = 0; j < (1<<(n - 1)); j++){\n\t\t\t\tbool ok = 1;\n\t\t\t\tvector<int> pos(n); pos[n - 1] = i;\n\t\t\t\tfor(int k = 0; k < n-1; k++){\n\t\t\t\t\tif((j >> k) & 1){\n\t\t\t\t\t\tif(sz(occur[k][c]) == 1){\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[k] = occur[k][c][(j >> k) & 1];\n\t\t\t\t}\n\t\t\t\tif(ok == 0) continue;\n\t\t\t\tfor(int k = 0; k < 52; k++){\n\t\t\t\t\tvector<int> nxtpos(n);\n\t\t\t\t\tfor(int x = 0; x < n; x++){\n\t\t\t\t\t\tif(pos[x] == 0) nxtpos[x] = -1;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnxtpos[x] = nxt[x][pos[x] - 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(count(all(nxtpos), -1)) continue;\n\t\t\t\t\tint msk = 0;\n\t\t\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\t\t\tif(occur[x][k][0] != nxtpos[x]) msk |= (1<<x);\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i][j] < dp[nxtpos[n - 1]][msk]){\n\t\t\t\t\t\tdp[i][j] = dp[nxtpos[n - 1]][msk];\n\t\t\t\t\t\ttrk[i][j] = pi(nxtpos[n - 1], msk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j]++;\n\t\t\t\tif(dp[i][j] > tot){\n\t\t\t\t\ttot = dp[i][j];\n\t\t\t\t\tstpos = pi(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(tot == 0) cout << \"0\\n\\n\";\n\t\telse{\n\t\t\tcout << tot << \"\\n\";\n\t\t\tvector<int> v;\n\t\t\tfor(int i = 0; i < tot; i++){\n\t\t\t\tv.push_back(s[n - 1][stpos.first]);\n\t\t\t\tstpos = trk[stpos.first][stpos.second];\n\t\t\t}\n\t\t\treverse(all(v));\n\t\t\tfor(auto &i : v){\n\t\t\t\tif(i < 26) cout << (char)(i + 'A');\n\t\t\t\telse cout << (char)(i - 26 + 'a');\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t}\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "graphs",
        "strings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Strange LCS.json",
    "editorial_link": "https://codeforces.com//blog/entry/96953",
    "editorial": "Let's define efinegraph with vertexes (c\n, msk\n), where chr\n denoting some character, ans mask\n is n\n-bit mask of occasions (i\n-th bit is set to 1\n if and only if we consider second occasion of c\n in i\n-th string). Not all mask\n are possible for some c\n since there could be less than 2\n occasions. Note: vertex define choise of character and positions of this character in all strings.\n\nNote, that graph has O(|?|?2n)\n vertices.\n\nLet's define strict comparison (<) of vertices:(chr1\n, msk1\n) < (char2\n, msk2\n) if and only if positions chosen by first vertex are stricly lefter than ones chosen by second (for all strings). Let's define another comparison (?\n) the same way, but allow some position to be equal. Note: strict comparison is anti-reflexive, both comparison are transitive and this stands (a\n ?\n b\n < c\n ?\n a\n < c\n).\n\nGraph contains directed edges from one vertex to another, if and only if first is smaller by defined comparison. Note: graph is acyclic, because of transitivity of pair comparison.\n\nNote: that for every common subsequence there is unique corresponding path in defined graph and vice versa. So we need to find longest path in this graph. Vertex-length of path will be equal to the length of corresponding subsequence.\n\nWe want to calculate dp\n(c\n, msk\n) \u0096 length of longest path starting from this vertex. This dp\n is easy to calulate on DAG, but number of edges is too big. We want to remove some edges without changing values of dp\n. Note: if removal of edge doesn't change dp\n of its starting point, when it doesn't change dp\n at all.\n\nLet's look at arbitrary vertex (c,msk)\n, that has at least one outgoing edge and some longest path starting from it (it has at least one edge): [(c,msk)?(c2,msk2)?\u0085\n]. Suppose there exists mask MidMsk?msk2\n, such that: (c, mask) < (c2\n, MidMsk\n) ?\n (c2\n, msk2\n). By the qualities of defined comparisons, we can change second vertex in longest path to (c2\n, MidMsk\n).\n\nNow let's find mask for fixed c2\n which correspond to choise of leftmost positions righter than positions chosen by (c\n, msk\n). It can be found in O(n)\n time. As we notices earlier, without loss of generality, longest path (with fixed c2\n) goes through this vertex , so we can harmlessly remove all edges going from current vertex to the vertices with character c2\n, but diffrent mask. This can be done for every character.\n\nNow graph each vertex has O(|?|)\n outgoing edges, so dp\n can be calculated fast enough. Subsequence itself can be easily found now.\n\nNote: there is no need for graph in solution, it's just abstraction for better understanding.\n\nNote: we don't have to calculate dp\n for all vertices, we only need to find dp(c,0)\n for all c\n, it can be proven by applying same logic."
}