{
    "link": "https://codeforces.com//contest/860/problem/A",
    "problemId": "122864",
    "problem_idx": "A",
    "shortId": "860A",
    "contest_number": "860",
    "problem_submissions": {
        "E": [
            30442338,
            30439610,
            30443019,
            30443046,
            30440508,
            30432483,
            30439294,
            30445411,
            30436063,
            30437142,
            30437221,
            30481068,
            30480696,
            30454225,
            30453851,
            30453830,
            30453714,
            30453688,
            30451950,
            30438289,
            30430653,
            30450525
        ],
        "C": [
            30436281,
            30442840,
            30434064,
            30433549,
            30444395,
            30448672,
            30433775,
            30432045,
            30440377,
            30451948,
            30455922,
            30438248,
            30440061,
            30440352,
            30434684,
            30440440,
            30440439,
            30441823
        ],
        "D": [
            30433124,
            30431343,
            30438212,
            30436898,
            30431927,
            30428404,
            30445018,
            30435042,
            30427155,
            30430494,
            30439252,
            30433856,
            31966531,
            30430878,
            30431992,
            30442376,
            30442582,
            30437824,
            30433265,
            30433563,
            30431407
        ],
        "B": [
            30425955,
            30423718,
            30424479,
            30425464,
            30424782,
            30426033,
            30423375,
            30424915,
            30427560,
            30426303,
            30423664,
            30424888,
            30426149,
            30428815,
            30436103,
            30426185,
            30427070,
            30426587,
            30424713
        ],
        "A": [
            30423599,
            30422216,
            30422379,
            30422507,
            30422342,
            30423247,
            30422321,
            30422663,
            30422437,
            30424719,
            30423379,
            30422275,
            30422538,
            30422660,
            30423270,
            30433600,
            30422460,
            30423290,
            30423757,
            30422708
        ]
    },
    "name": "A. Did you mean...",
    "statement": "Beroffice text editor has a wide range of features that help working\r\nwith text. One of the features is an automatic search for typos and\r\nsuggestions of how to fix them.Beroffice works only with small English\r\nletters (i.e. with 26 letters from to ). Beroffice thinks that a word is\r\ntyped with a typo if there are three or more consonants in a row in the\r\nword. The only exception is that if the block of consonants has all\r\nletters the same, then this block (even if its length is greater than\r\nthree) is not considered a typo. Formally, a word is typed with a typo\r\nif there is a block of not less that three consonants in a row, and\r\nthere are at least two different letters in this block.For example: the\r\nfollowing words have typos: \"\", \"\" and \"\"; the following words don\u2019t\r\nhave typos: \"\", \"\" and \"\". When Beroffice editor finds a word with a\r\ntypo, it inserts as little as possible number of spaces in this word\r\n(dividing it into several words) in such a way that each of the\r\nresulting words is typed without any typos.Implement this feature of\r\nBeroffice editor. Consider the following letters as the only vowels: \u201d,\r\n\u201d, \u201d, \u201d and \u201d. All the other letters are consonants in this problem.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring S;\n\nint cons[256];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tFOR(i,256) cons[i]=1;\n\tcons['a']=0;\n\tcons['i']=0;\n\tcons['u']=0;\n\tcons['e']=0;\n\tcons['o']=0;\n\t\n\t\n\tcin>>S;\n\tstring T;\n\tint hoge=0;\n\tFOR(i,S.size()) {\n\t\tchar c=S[i];\n\t\tif(cons[c]==0) hoge=0;\n\t\telse hoge++;\n\t\tif(hoge>=3) {\n\t\t\tif(S[i]==S[i-1] && S[i]==S[i-2]) {\n\t\t\t\thoge=3;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thoge=1;\n\t\t\t\tT+=' ';\n\t\t\t}\n\t\t}\n\t\tT+=c;\n\t}\n\tcout<<T<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Did you mean....json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "We will solve the problem greedily. Let's find the leftmost typo. It will be three consecutive characters si?-?1,?si and si?+?1 such that all of them are consonants and there are at least two diffirent letters. It is clear that we can cut this string after position i, because prefix will be correct and we will leave only one letter in the remaining part of the string. So each time we find the leftmost typo and cut out the prefix. Remember that after cutting the prefix you have to continue checking from index i?+?2, not i?+?1."
}