{"link": "https://codeforces.com//contest/1628/problem/E", "problemId": "1270547", "problem_idx": "E", "shortId": "1628E", "contest_number": "1628", "problem_submissions": {"F": [143704137, 143703628, 143702221, 143703556, 147001965], "E": [143675713, 143683767, 143678064, 143684015, 143703839, 143703586, 143684851, 143683465, 143685498, 143691038, 143689260, 143676465, 143693250, 143684297, 143687706, 143698977, 143697149, 143693737, 143726859, 143698932, 143695817, 143695968], "D2": [143658634, 143670285, 143666637, 143665499, 143666995, 143667409, 143672399, 143672413, 143661151, 143647661, 143658816, 143673791, 143659789, 143650476, 143675004, 143660718, 143676678, 143684084, 143660907], "D1": [143652051, 143661015, 143649637, 143665355, 143640835, 143647447, 143672291, 143669534, 143658393, 143632054, 143652557, 143673638, 143659662, 143650805, 143669620, 143647751, 143667415, 143668369, 143654580], "C": [143648600, 143653504, 143662609, 143671130, 143659087, 143671994, 143662240, 143665901, 143679854, 143654744, 143666734, 143658744, 143650933, 143640762, 143660335, 143673771, 143662259, 143663580, 143684690], "B": [143641041, 143647996, 143687560, 143645776, 143664691, 143661275, 143640613, 143649322, 143664737, 143644329, 143690738, 143695054, 143657006, 143653454, 143666253, 143657114, 143649062, 143668019], "A": [143633679, 143636764, 143632428, 143638866, 143635799, 143637277, 143632341, 143633434, 143635604, 143658928, 143634190, 143633884, 143633848, 143634819, 143640442, 143650623, 143643930, 143639364, 143636998]}, "name": "E. Groceries in Meteor Town", "statement": "The town has n buildings numbered from 1 to n. Some buildings have roads\r\nbetween them, and there is exactly 1 simple path from any building to\r\nany other building. Each road has a certain meteor danger level. The\r\nbuildings all have grocery stores, but Mihai only cares about the open\r\nones, of course. Initially, all the grocery stores are closed.You are\r\ngiven q queries of three types: Given the integers l and r, the\r\nbuildings numbered from l to r open their grocery stores (nothing\r\nhappens to buildings in the range that already have an open grocery\r\nstore). Given the integers l and r, the buildings numbered from l to r\r\nclose their grocery stores (nothing happens to buildings in the range\r\nthat didn\u2019t have an open grocery store). Given the integer x, find the\r\nmaximum meteor danger level on the simple path from x to open grocery\r\nstore, or -1 if there is no edge on any simple path to an open store.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 22.01.2022 18:17:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable() {}\n\n  void init(const vector<T>& a, const F& f) {\n    func = f;\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nfunction<int(int, int)> GetMax;\n\nSparseTable<int> saux;\n\nclass segtree {\n public:\n  struct node {\n    int mx = -1;\n    int put = 0;\n    int L = -1;\n    int R = -1;\n\n    void apply(int l, int r, int v) {\n      if (v == -1) {\n        mx = put = L = R = -1;\n      } else {\n        assert(v == 1);\n        mx = (l == r ? -1 : saux.get(l, r - 1));\n        put = 1;\n        L = l;\n        R = r;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    res.L = (a.L != -1 ? a.L : b.L);\n    res.R = (b.R != -1 ? b.R : a.R);\n    if (a.R != -1 && b.L != -1) {\n      res.mx = max(res.mx, GetMax(a.R, b.L));\n    }\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].put != 0) {\n      tree[x + 1].apply(l, y, tree[x].put);\n      tree[z].apply(y + 1, r, tree[x].put);\n      tree[x].put = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\n\nnamespace bam {\n\nconst int N = 600010;\n\nint dsu[N];\n\nint get(int v) {\n  if (v == dsu[v]) {\n    return v;\n  } else {\n    return dsu[v] = get(dsu[v]);\n  }\n}\n\nvector<int> st[N];\nvector<int> w[N];\n\nvoid uni(int u, int v, int i) {\n  u = get(u), v = get(v);\n  if (st[u].size() > st[v].size()) {\n    swap(u, v);\n  }\n  w[v].push_back(i);\n  for (int x : w[u]) {\n    w[v].push_back(x);\n  }\n  for (int x : st[u]) {\n    st[v].push_back(x);\n  }\n  dsu[u] = v;\n}\n  \n} // bam\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  forest<int> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    g.add(x, y, z);\n  }\n  vector<int> order(n - 1);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    return g.edges[i].cost < g.edges[j].cost;\n  });\n  for (int i = 0; i < n; i++) {\n    bam::dsu[i] = i;\n    bam::st[i].push_back(i);\n  }\n  for (int i : order) {\n    bam::uni(g.edges[i].from, g.edges[i].to, g.edges[i].cost);\n  }\n  int root = bam::get(0);\n  vector<int> ind(n);\n  for (int i = 0; i < n; i++) {\n    ind[bam::st[root][i]] = i;\n  }\n  vector<int> ws(n, -1);\n  for (int i = 0; i < n - 1; i++) {\n    ws[i] = bam::w[root][i];\n  }\n  SparseTable<int> sm;\n  sm.init(ws, [&](int i, int j) { return max(i, j); });\n  GetMax = [&](int u, int v) {\n    int L = ind[u];\n    int R = ind[v];\n    if (L > R) {\n      swap(L, R);\n    }\n    if (L == R) {\n      return -1;\n    }\n    return sm.get(L, R - 1);\n  };\n  vector<int> vaux(n, -1);\n  for (int i = 0; i < n - 1; i++) {\n    vaux[i] = GetMax(i, i + 1);\n  }\n  saux.init(vaux, [&](int i, int j) { return max(i, j); });\n  segtree st(n);\n  while (tt--) {\n    int op;\n    cin >> op;\n    if (op == 1 || op == 2) {\n      int l, r;\n      cin >> l >> r;\n      --l; --r;\n      st.modify(l, r, op == 1 ? 1 : -1);\n    }\n    if (op == 3) {\n      int x;\n      cin >> x;\n      --x;\n      auto nd = st.get(0, n - 1);\n      int mx = nd.mx;\n      if (nd.L != -1) {\n        mx = max(mx, GetMax(x, nd.L));\n      }\n      cout << mx << '\\n';\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "dsu", "trees"], "dificulty": "3100", "interactive": false}