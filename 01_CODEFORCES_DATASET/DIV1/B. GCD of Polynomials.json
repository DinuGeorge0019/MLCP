{"link": "https://codeforces.com//contest/901/problem/B", "problemId": "139713", "problem_idx": "B", "shortId": "901B", "contest_number": "901", "problem_submissions": {"D": [33426443, 33425255, 33425405, 33421002, 33428722, 33432497, 33430107, 33431968, 33434361, 33433853, 33432628, 33428305, 33435534, 33423537, 33424117, 33433491, 33424011, 33435055], "C": [33423246, 33421544, 33420578, 33429910, 33422327, 33425977, 33426202, 33427669, 33422440, 33429447, 33429169, 33424756, 33430999, 33430059, 33430695, 33420864, 33434365, 33425416], "B": [33419337, 33427579, 33429052, 33425071, 33431946, 33418047, 33432302, 33420475, 33497315, 33497308, 33496921, 33426321, 33423681, 33433893, 33426136, 33434123], "A": [33414182, 33413377, 33413379, 33422716, 33415121, 33413643, 33413547, 33414284, 33415005, 33416374, 33419687, 33414307, 33415289, 33414435, 33420715, 33423860, 33425257, 33413347], "E": [36988410]}, "name": "B. GCD of Polynomials", "statement": "Suppose you have two polynomials and . Then polynomial can be uniquely\r\nrepresented in the following way:This can be done using long division.\r\nHere, denotes the degree of polynomial . is called the remainder of\r\ndivision of polynomial by polynomial , it is also denoted as . Since\r\nthere is a way to divide polynomials with remainder, we can define\r\nEuclid\u2019s algorithm of finding the greatest common divisor of two\r\npolynomials. The algorithm takes two polynomials . If the polynomial is\r\nzero, the result is , otherwise the result is the value the algorithm\r\nreturns for pair . On each step the degree of the second argument\r\ndecreases, so the algorithm works in finite number of steps. But how\r\nlarge that number could be? You are to answer this question. You are\r\ngiven an integer . You have to build two polynomials with degrees not\r\ngreater than , such that their coefficients are integers not exceeding\r\nby their absolute value, the leading coefficients (ones with the\r\ngreatest power of ) are equal to one, and the described Euclid\u2019s\r\nalgorithm performs exactly steps finding their greatest common divisor.\r\nMoreover, the degree of the first polynomial should be greater than the\r\ndegree of the second. By a step of the algorithm we mean the transition\r\nfrom pair to pair .\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <int> Vl[155];\nint main() {\n\tVl[0].push_back(1);\n\tVl[1].push_back(0);\n\tVl[1].push_back(1);\n\n\tint i, j;\n\tfor (i = 2; i <= 150; i++) {\n\t\tVl[i].push_back(0);\n\t\tfor (auto it : Vl[i - 1]) Vl[i].push_back(it);\n\n\t\tfor (j = 0; j < Vl[i - 2].size(); j++) Vl[i][j] += Vl[i - 2][j];\n\t\tfor (j = 0; j < Vl[i].size(); j++) if (abs(Vl[i][j]) >= 2) break;\n\t\tif (j >= Vl[i].size()) continue;\n\t\tfor (j = 0; j < Vl[i - 2].size(); j++) Vl[i][j] -= 2 * Vl[i - 2][j];\n\t\tfor (j = 0; j < Vl[i].size(); j++) if (abs(Vl[i][j]) >= 2) break;\n\t\tif (j >= Vl[i].size()) continue;\n\t}\n\n\tint N;\n\tscanf(\"%d\", &N);\n\tprintf(\"%d\\n\", Vl[N].size()-1);\n\tfor (auto it : Vl[N]) printf(\"%d \", it);\n\tprintf(\"\\n\");\n\tprintf(\"%d\\n\", Vl[N - 1].size()-1);\n\tfor (auto it : Vl[N - 1]) printf(\"%d \", it);\n\tprintf(\"\\n\");\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "math"], "dificulty": "2200", "interactive": false}