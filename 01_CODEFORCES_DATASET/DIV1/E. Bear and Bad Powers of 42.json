{
    "link": "https://codeforces.com//contest/679/problem/E",
    "problemId": "61898",
    "problem_idx": "E",
    "shortId": "679E",
    "contest_number": "679",
    "problem_submissions": {
        "D": [
            18322762,
            18323626,
            18322971,
            18323450,
            18324701,
            18327443,
            18345837,
            18345768,
            18345680,
            18345642,
            18327111,
            18328820,
            18327048,
            18328042,
            18328483,
            18329243,
            18329178,
            18324869,
            18324693
        ],
        "B": [
            18314677,
            18309080,
            18312175,
            18311888,
            18312358,
            18312942,
            18316455,
            18317342,
            18309354,
            18307663,
            18316385,
            18308970,
            18308226,
            18309465,
            18308416,
            18312030,
            18314147
        ],
        "C": [
            18310021,
            18317790,
            18318340,
            18317148,
            18319639,
            18318992,
            18320837,
            18322274,
            18315941,
            18322904,
            18316017,
            18318363,
            18318389,
            18317725,
            18315473,
            18314694
        ],
        "A": [
            18303717,
            18304196,
            18305388,
            18304702,
            18306194,
            18307513,
            18307982,
            18303929,
            18304410,
            18304102,
            18305596,
            18304174,
            18305099,
            18303722,
            18303574,
            18304076,
            18305438,
            18304649
        ],
        "E": [
            200103409,
            18853172,
            18325979,
            18447386,
            188767815
        ]
    },
    "name": "E. Bear and Bad Powers of 42",
    "statement": "Limak, a bear, isn’t good at handling queries. So, he asks you to do\r\nit.We say that powers of (numbers ) are . Other numbers are .You are\r\ngiven a sequence of good integers . Your task is to handle queries of\r\nthree types: print in a separate line. for set to . It’s guaranteed that\r\nis a good number. for increase by . After this repeat the process while\r\nat least one is bad. You can note that after each query all are good.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\ntypedef long long ll;\n#define inf ll(1e18)\n\ntypedef pair<ll,int> dstwt;\ndstwt dinf = dstwt(inf, -1);\n\nvector<ll> pws = {1, 42, 1764, 74088, 3111696, 130691232, 5489031744, 230539333248, 9682651996416, 406671383849472, 17080198121677824, 717368321110468608};\n\ndstwt recompd(dstwt a) {\n    while (a.first < 0) {\n        int pi = a.second;\n        ll nd = pws[pi+1] - pws[pi];\n        a.first += nd;\n        a.second++;\n    }\n    return a;\n}\n\nstruct stb {\n    // upds\n    // 1) a[i] = d,np\n    // 2) a[i].d -= x\n    // and: go to ranges of constant np where d < 0\n\n    struct nd {\n        dstwt mnd, smnd; \n        ll add;\n        dstwt set;\n        bool lset;\n\n        nd(dstwt a = dinf) {\n            mnd = a;\n            smnd = dinf;\n            add = 0; \n            lset = true;\n            set = a;\n        }\n    };\n\n    nd rt[400005];\n\n    void apply(int i, int op, dstwt x) {\n        nd &r = rt[i];\n        if (op == 1) {\n            ll y = x.first;\n            // add y\n            r.mnd.first -= y;\n            if (r.smnd != dinf) r.smnd.first -= y;\n            if (r.lset) r.set.first -= y;\n            else r.add += y;\n        } else if (op == 2) {\n            // set to x\n            r.mnd = x;\n            r.smnd = dinf;\n            r.add = 0;\n            r.lset = true;\n            r.set = x;\n        }\n    }\n\n    void merge(int i) {\n        nd &p = rt[i];\n        const nd &l = rt[2*i+1]; \n        const nd &r = rt[2*i+2];\n\n        p.mnd = min(l.mnd, r.mnd);\n        p.smnd = min(l.mnd == p.mnd ? l.smnd : l.mnd, r.mnd == p.mnd ? r.smnd : r.mnd);\n        p.add = 0;\n        p.lset = false;\n    }\n\n    void push(int i) {\n        const nd &r = rt[i];\n        if (r.lset) {\n            apply(2*i+1, 2, r.set);\n            apply(2*i+2, 2, r.set);\n        } else if (r.add) {\n            apply(2*i+1, 1, dstwt(r.add,0));\n            apply(2*i+2, 1, dstwt(r.add,0));\n        }\n        merge(i);\n    }\n\n    void upd(int i, int nl, int nr, int ql, int qr, int op, dstwt x) {\n        if (nl == ql && nr == qr) apply(i, op, x);\n        else {\n            push(i);\n            int nmd = (nl+nr)/2;\n            if (ql < nmd) upd(2*i+1, nl, nmd, ql, min(qr, nmd), op, x);\n            if (qr > nmd) upd(2*i+2, nmd, nr, max(ql, nmd), qr, op, x);\n            merge(i);\n        }\n    }\n\n    void recomp(int i, int nl, int nr) {\n        if (rt[i].mnd.first >= 0) return;\n        else if (rt[i].smnd == dinf) {\n            rt[i].mnd = recompd(rt[i].mnd);\n            rt[i].smnd = dinf;\n            rt[i].add = 0;\n            rt[i].lset = true;\n            rt[i].set = rt[i].mnd;\n        } else {\n            push(i);\n            int nmd = (nl+nr)/2;\n            recomp(2*i+1, nl, nmd);\n            recomp(2*i+2, nmd, nr);\n            merge(i);\n        }\n    }\n\n    ll qu(int i, int nl, int nr, int qi) {\n        if (rt[i].lset) return pws[rt[i].set.second] - rt[i].set.first;\n        push(i);\n        int nmd = (nl+nr)/2;\n        if (qi < nmd) return qu(2*i+1, nl, nmd, qi);\n        else return qu(2*i+2, nmd, nr, qi);\n    }\n\n    void set(int n, int ql, int qr, ll x) {\n        dstwt ux = recompd({1-x,0});\n        upd(0, 0, n, ql, qr, 2, ux);\n    }\n\n    void add(int n, int ql, int qr, ll x) {\n        dstwt ux(x,-1);\n        while (true) {\n            upd(0, 0, n, ql, qr, 1, ux);\n            recomp(0, 0, n);\n            if (rt[0].mnd.first > 0) break;\n            assert(rt[0].mnd.first == 0);\n        }\n    }\n\n    void init(int i, int nl, int nr, ll *v) {\n        if (nl+1 == nr) {\n            rt[i] = recompd({1-v[nl],0});\n        } else {\n            int nmd = (nl + nr) / 2;\n            init(2*i+1, nl, nmd, v);\n            init(2*i+2, nmd, nr, v);\n            merge(i);\n        }\n    }\n};\n\nstb s;\nll a[200005];\nint n, q;\n\nint main() {\n    scanf(\"%d %d\", &n, &q);\n    fo(i,0,n) scanf(\"%lld\", a+i);\n    s.init(0, 0, n, a);\n    fo(_,0,q) {\n        int qt;\n        scanf(\"%d\", &qt);\n        if (qt == 1) {\n            int qi; scanf(\"%d\", &qi); qi--;\n            printf(\"%lld\\n\", s.qu(0, 0, n, qi));\n        } else {\n            int ql, qr;\n            ll x;\n            scanf(\"%d %d %lld\", &ql, &qr, &x); ql--;\n            if (qt == 2) s.set(n, ql, qr, x);\n            else s.add(n, ql, qr, x);\n        }\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bear and Bad Powers of 42.json",
    "editorial_link": "https://codeforces.com//blog/entry/45310",
    "editorial": "The only special thing in numbers was that there are only few such\r\nnumbers (in the possible to achieve range, so up to about ). Letâs first\r\nsolve the problem without queries \"in the interval change all numbers to\r\nx\". Then, we can make a tree with operations (possible with lazy\r\npropagation): In a tree for each index letâs keep the distance to the\r\nnext power of 42. After each \"add on the interval\" we should find the\r\nminimum and check if itâs positive. If not then we should change value\r\nof the closest power of for this index, and change the value in the\r\ntree. Then, we should again find the minimum in the tree, and so on. The\r\namortized complexity is . It can be proved that numbers wonât exceed .\r\nNow letâs think about the remaining operation of changing all interval\r\nto some value. We can set only one number (the last one) to the given\r\nvalue, and set other values to INF. We want to guarantee that if then\r\nthe -th value is correctly represented in the tree. Otherwise, it can be\r\nINF instead (or sometimes it may be correctly represented, it doesnât\r\nbother me). When we have the old query of type \"add something to\r\ninterval \" then if index or index contains INF in the tree then we\r\nshould first retrieve the true value there. You can see that each\r\noperation changes values from INF to something finite. So, the amortized\r\ncomplexity is still . One thing regarding implementation. In my solution\r\nthere is \"\" containing indices with INF value. I think itâs easier to\r\nimplemement the solution with this set. code1\r\n",
    "hint": []
}