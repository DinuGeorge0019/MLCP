{"link": "https://codeforces.com//contest/679/problem/E", "problemId": "61898", "problem_idx": "E", "shortId": "679E", "contest_number": "679", "problem_submissions": {"D": [18322762, 18323626, 18322971, 18323450, 18324701, 18327443, 18345837, 18345768, 18345680, 18345642, 18327111, 18328820, 18327048, 18328042, 18328483, 18329243, 18329178, 18324869, 18324693], "B": [18314677, 18309080, 18312175, 18311888, 18312358, 18312942, 18316455, 18317342, 18309354, 18307663, 18316385, 18308970, 18308226, 18309465, 18308416, 18312030, 18314147], "C": [18310021, 18317790, 18318340, 18317148, 18319639, 18318992, 18320837, 18322274, 18315941, 18322904, 18316017, 18318363, 18318389, 18317725, 18315473, 18314694], "A": [18303717, 18304196, 18305388, 18304702, 18306194, 18307513, 18307982, 18303929, 18304410, 18304102, 18305596, 18304174, 18305099, 18303722, 18303574, 18304076, 18305438, 18304649], "E": [200103409, 18853172, 18325979, 18447386, 188767815]}, "name": "E. Bear and Bad Powers of 42", "statement": "Limak, a bear, isn\u2019t good at handling queries. So, he asks you to do\r\nit.We say that powers of (numbers ) are . Other numbers are .You are\r\ngiven a sequence of good integers . Your task is to handle queries of\r\nthree types: print in a separate line. for set to . It\u2019s guaranteed that\r\nis a good number. for increase by . After this repeat the process while\r\nat least one is bad. You can note that after each query all are good.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\ntypedef long long ll;\n#define inf ll(1e18)\n\ntypedef pair<ll,int> dstwt;\ndstwt dinf = dstwt(inf, -1);\n\nvector<ll> pws = {1, 42, 1764, 74088, 3111696, 130691232, 5489031744, 230539333248, 9682651996416, 406671383849472, 17080198121677824, 717368321110468608};\n\ndstwt recompd(dstwt a) {\n    while (a.first < 0) {\n        int pi = a.second;\n        ll nd = pws[pi+1] - pws[pi];\n        a.first += nd;\n        a.second++;\n    }\n    return a;\n}\n\nstruct stb {\n    // upds\n    // 1) a[i] = d,np\n    // 2) a[i].d -= x\n    // and: go to ranges of constant np where d < 0\n\n    struct nd {\n        dstwt mnd, smnd; \n        ll add;\n        dstwt set;\n        bool lset;\n\n        nd(dstwt a = dinf) {\n            mnd = a;\n            smnd = dinf;\n            add = 0; \n            lset = true;\n            set = a;\n        }\n    };\n\n    nd rt[400005];\n\n    void apply(int i, int op, dstwt x) {\n        nd &r = rt[i];\n        if (op == 1) {\n            ll y = x.first;\n            // add y\n            r.mnd.first -= y;\n            if (r.smnd != dinf) r.smnd.first -= y;\n            if (r.lset) r.set.first -= y;\n            else r.add += y;\n        } else if (op == 2) {\n            // set to x\n            r.mnd = x;\n            r.smnd = dinf;\n            r.add = 0;\n            r.lset = true;\n            r.set = x;\n        }\n    }\n\n    void merge(int i) {\n        nd &p = rt[i];\n        const nd &l = rt[2*i+1]; \n        const nd &r = rt[2*i+2];\n\n        p.mnd = min(l.mnd, r.mnd);\n        p.smnd = min(l.mnd == p.mnd ? l.smnd : l.mnd, r.mnd == p.mnd ? r.smnd : r.mnd);\n        p.add = 0;\n        p.lset = false;\n    }\n\n    void push(int i) {\n        const nd &r = rt[i];\n        if (r.lset) {\n            apply(2*i+1, 2, r.set);\n            apply(2*i+2, 2, r.set);\n        } else if (r.add) {\n            apply(2*i+1, 1, dstwt(r.add,0));\n            apply(2*i+2, 1, dstwt(r.add,0));\n        }\n        merge(i);\n    }\n\n    void upd(int i, int nl, int nr, int ql, int qr, int op, dstwt x) {\n        if (nl == ql && nr == qr) apply(i, op, x);\n        else {\n            push(i);\n            int nmd = (nl+nr)/2;\n            if (ql < nmd) upd(2*i+1, nl, nmd, ql, min(qr, nmd), op, x);\n            if (qr > nmd) upd(2*i+2, nmd, nr, max(ql, nmd), qr, op, x);\n            merge(i);\n        }\n    }\n\n    void recomp(int i, int nl, int nr) {\n        if (rt[i].mnd.first >= 0) return;\n        else if (rt[i].smnd == dinf) {\n            rt[i].mnd = recompd(rt[i].mnd);\n            rt[i].smnd = dinf;\n            rt[i].add = 0;\n            rt[i].lset = true;\n            rt[i].set = rt[i].mnd;\n        } else {\n            push(i);\n            int nmd = (nl+nr)/2;\n            recomp(2*i+1, nl, nmd);\n            recomp(2*i+2, nmd, nr);\n            merge(i);\n        }\n    }\n\n    ll qu(int i, int nl, int nr, int qi) {\n        if (rt[i].lset) return pws[rt[i].set.second] - rt[i].set.first;\n        push(i);\n        int nmd = (nl+nr)/2;\n        if (qi < nmd) return qu(2*i+1, nl, nmd, qi);\n        else return qu(2*i+2, nmd, nr, qi);\n    }\n\n    void set(int n, int ql, int qr, ll x) {\n        dstwt ux = recompd({1-x,0});\n        upd(0, 0, n, ql, qr, 2, ux);\n    }\n\n    void add(int n, int ql, int qr, ll x) {\n        dstwt ux(x,-1);\n        while (true) {\n            upd(0, 0, n, ql, qr, 1, ux);\n            recomp(0, 0, n);\n            if (rt[0].mnd.first > 0) break;\n            assert(rt[0].mnd.first == 0);\n        }\n    }\n\n    void init(int i, int nl, int nr, ll *v) {\n        if (nl+1 == nr) {\n            rt[i] = recompd({1-v[nl],0});\n        } else {\n            int nmd = (nl + nr) / 2;\n            init(2*i+1, nl, nmd, v);\n            init(2*i+2, nmd, nr, v);\n            merge(i);\n        }\n    }\n};\n\nstb s;\nll a[200005];\nint n, q;\n\nint main() {\n    scanf(\"%d %d\", &n, &q);\n    fo(i,0,n) scanf(\"%lld\", a+i);\n    s.init(0, 0, n, a);\n    fo(_,0,q) {\n        int qt;\n        scanf(\"%d\", &qt);\n        if (qt == 1) {\n            int qi; scanf(\"%d\", &qi); qi--;\n            printf(\"%lld\\n\", s.qu(0, 0, n, qi));\n        } else {\n            int ql, qr;\n            ll x;\n            scanf(\"%d %d %lld\", &ql, &qr, &x); ql--;\n            if (qt == 2) s.set(n, ql, qr, x);\n            else s.add(n, ql, qr, x);\n        }\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3100", "interactive": false}