{"link": "https://codeforces.com//contest/83/problem/D", "problemId": "445", "problem_idx": "D", "shortId": "83D", "contest_number": "83", "problem_submissions": {"E": [451947, 450977, 459818, 465914], "D": [449763, 448488, 452955, 452808, 452804, 448288, 449164, 450962, 452221, 451606, 451773, 451891, 450141, 449774, 449599, 450292, 449258, 450035, 450619], "C": [448521, 455889, 451494, 451794, 449865, 450165, 450276, 450602, 449657, 452977, 452829, 452759], "B": [447440, 452573, 449754, 447625, 448201, 447469, 450579, 448308, 447785, 447475, 447853, 448099, 447816, 448223, 447713, 447775], "A": [446362, 452366, 446401, 446361, 446485, 446374, 446375, 446560, 446585, 446384, 446420, 446524, 446437, 447399, 446502, 446789]}, "name": "D. Numbers", "statement": "Valera\u2019s home task has only one problem, which, though formulated in a\r\nvery simple way, has not a trivial solution. Its statement looks as\r\nfollows: if we consider all positive integers in the interval then it is\r\nrequired to count the amount of such numbers in this interval that their\r\nwill be a certain integer . In other words, you should count the amount\r\nof such numbers from the interval , that are not divisible by any number\r\nbetween and and yet are divisible by .\r\n", "solutions": ["#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint a, b, k;\nvector <int> P;\n\nbool prime (int x) {\n\tfor (int i = 2; i * i <= x; i ++)\n\t\tif (x % i == 0)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint calc (int b, int n) {\n\tif (n < 0)\n\t\treturn 0;\n\tif (b < P[n])\n\t\treturn 0;\n\tb /= P[n];\n\tint64 res = b;\n\tforn (i, n)\n\t\tres -= calc (b, i);\n\treturn res;\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tcin >> a >> b >> k;\n\tif (!prime (k)) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif (((int64)k) * ((int64)k) > b) {\n\t\tif (a <= k && k <= b)\n\t\t\tcout << 1 << endl;\n\t\telse\n\t\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tP.clear ();\n\tfor (int i = 2; i < k; i ++)\n\t\tif (prime (i))\n\t\t\tP.pb (i);\n\tP.pb (k);\n\tcout << calc (b, P.size() - 1) - calc (a-1, P.size() - 1) << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "math", "number theory"], "dificulty": "2400", "interactive": false}