{
    "link": "https://codeforces.com//contest/1528/problem/E",
    "problemId": "994166",
    "problem_idx": "E",
    "shortId": "1528E",
    "contest_number": "1528",
    "problem_submissions": {
        "F": [
            117241784,
            117237625,
            117249711,
            117251014,
            117237719,
            117247531,
            117250487,
            117296792,
            117362083
        ],
        "C": [
            117229826,
            117199788,
            117206577,
            117201851,
            117204674,
            117206245,
            117218212,
            117196904,
            117210131,
            117210736,
            117206890,
            117212730,
            117208145,
            117211669,
            117203428,
            117211467,
            117203007,
            117206081,
            117210746,
            117210824
        ],
        "E": [
            117212844,
            117230561,
            117222959,
            117226469,
            117224989,
            117238353,
            117239558,
            117216115,
            117234224,
            117239827,
            117237600,
            117238423,
            117244129,
            117238121,
            117240390,
            117239904,
            117240349,
            117240625,
            117238487,
            117240173
        ],
        "D": [
            117201259,
            117208270,
            117212623,
            117211738,
            117242708,
            117216479,
            117225362,
            117203170,
            117222650,
            117216984,
            117223735,
            117223429,
            117215498,
            117223732,
            117224661,
            117222534,
            117223454,
            117224387,
            117255573,
            117255349,
            117255220,
            117226605,
            117221662
        ],
        "B": [
            117190972,
            117190286,
            117191599,
            117193984,
            117197139,
            117198582,
            117200082,
            117188842,
            117200429,
            117191737,
            117195913,
            117196829,
            117195712,
            117199801,
            117193006,
            117201359,
            117211353,
            117194542,
            117198721,
            117194778
        ],
        "A": [
            117185385,
            117182301,
            117183363,
            117182330,
            117185042,
            117182254,
            117192623,
            117181878,
            117188021,
            117186007,
            117186714,
            117183913,
            117183194,
            117189883,
            117184967,
            117183486,
            117187212,
            117183227,
            117187339,
            117198905
        ]
    },
    "name": "E. Mashtali and Hagh Trees",
    "statement": "Today is Mashtali\u2019s birthday! He received a tree from Haj Davood as his\r\nbirthday present!A directed tree is called a tree iff: The length of the\r\nlongest directed path in it is exactly n. Every vertex has attached to\r\nit independent of their orientation. Let\u2019s call vertices u and v friends\r\nif one of them has a directed path to the other. For every pair of\r\nvertices u and v that are not friends, there should exist a vertex w\r\nthat is friends with both u and v (a mutual friend). After opening his\r\ngift, Mashtali found out that the labels on the vertices were\r\ngone.Immediately, he asked himself: how many different unlabeled Hagh\r\ntrees are there? That is, how many possible trees could he have received\r\nas his birthday present?At the first glance, the number of such trees\r\nseemed to be infinite since there was no limit on the number of\r\nvertices; but then he solved the problem and proved that Amazed by this\r\nfact, he shared the task with you so that you could enjoy solving it as\r\nwell. Since the answer can be rather large he asked you to find the\r\nnumber of different unlabeled Hagh trees modulo 998244353.Here two trees\r\nare considered different, if they are not isomorphic: if there is no way\r\nto map nodes of one tree to the second tree, so that edges are mapped to\r\nedges preserving the orientation.Some examples for n = 2: Directed trees\r\nD and E are Hagh. C is not Hagh because it has a vertex with 4 edges\r\nattached to it. A and B are not Hagh because their longest directed\r\npaths are not equal to n. Also in B the leftmost and rightmost vertices\r\nare not friends neither do they have a mutual friend.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n;\n\tcin >> n;\n\tvector<num> trees(n+1);\n\tvector<num> psums(n+1);\n\ttrees[0] = 1;\n\tpsums[0] = trees[0];\n\tnum inv2 = num(1) / num(2);\n\tnum inv6 = num(1) / num(6);\n\tfor(int k = 1; k <= n; k++){\n\t\tnum good = psums[k-1] + 1;\n\t\tnum bad = psums[k-1] - trees[k-1] + 1;\n\t\tnum res = good * (good+1) * inv2 - bad * (bad+1) * inv2;\n\t\ttrees[k] = res;\n\t\tpsums[k] = psums[k-1] + trees[k];\n\t}\n\tnum ans = 0;\n\tans += trees[n];\n\t{\n\t\tnum good = psums[n-1];\n\t\tnum bad = psums[n-1] - trees[n-1];\n\t\tans += (good * (good + 1) * (good + 2) * inv6 - bad * (bad + 1) * (bad + 2) * inv6) * 2;\n\t}\n\tfor(int t = 1; t <= n; t++){\n\t\tnum good = psums[t-1];\n\t\tnum bad = psums[t-1] - trees[t-1];\n\t\tnum top = good * (good + 1) * inv2 - bad * (bad + 1) * inv2;\n\t\tans += top * (t == n ? 1 : trees[n-1-t]);\n\t}\n\tcout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Mashtali and Hagh Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "Let be the answer for all trees such that there exists a root and all\r\nedges are directed in the same direction from root and the root has at\r\nmost children. We transition: where .Then let be the same as except the\r\nroot must have exactly children. So .The answer for these cases is:.This\r\nis because holds the answer for at most children and the other section\r\naccounts for the rest. We multiply by to account for both edges\r\ndirections, and subtract because a single path is isomorphic.This\r\nobviously doesn\u00e2\u0080\u0099t handle all cases, but all other cases can be found in\r\nthe following form. Let be a tree where the root has children and the\r\nedges are directed up and the longest path is , and let be a tree where\r\nthe root has children and the edges are directed down and the longest\r\npath is . Then all other cases are which exists on some path of length\r\nto and connects to .We can count every other case as This works because\r\nwe pretend the path is always length , then if we do we handle all cases\r\nexcept for when the is empty, and that only happens once.\r\n"
}