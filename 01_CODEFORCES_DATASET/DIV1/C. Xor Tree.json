{
    "link": "https://codeforces.com//contest/1446/problem/C",
    "problemId": "797257",
    "problem_idx": "C",
    "shortId": "1446C",
    "contest_number": "1446",
    "problem_submissions": {
        "D2": [
            98488179,
            98479602,
            98464320,
            98467493,
            98464495,
            98464291,
            98477056,
            98482171,
            98496133,
            98469225,
            98470769,
            98488185,
            98481918,
            98482926,
            98479038
        ],
        "F": [
            98482236,
            98470414,
            98500090,
            98497700,
            98476856,
            98476210,
            98484136,
            98489678,
            98481827,
            98491554,
            98484171,
            98504348,
            98502497,
            98493379,
            98482100,
            98486768,
            98492674,
            98490163,
            98501084
        ],
        "E": [
            98475344,
            98498258,
            98500804,
            98495217,
            115705388,
            106404746
        ],
        "D1": [
            98457158,
            98460382,
            98456556,
            98456978,
            98464440,
            98464426,
            98466567,
            98470196,
            98464176,
            98472990,
            98478320,
            98479479,
            98482287,
            98493368,
            98460232,
            98466662,
            98460275,
            98466691,
            98472979,
            98478998
        ],
        "C": [
            98450996,
            98452840,
            98450218,
            98453943,
            98450946,
            98452214,
            98452223,
            98455447,
            98455497,
            98455239,
            98461758,
            98461392,
            98466665,
            98466780,
            98453580,
            98454283,
            98455611,
            98457408,
            98454698,
            98458074
        ],
        "B": [
            98446682,
            98448334,
            98447974,
            98447142,
            98452896,
            98448193,
            98448567,
            98451491,
            98449697,
            98450934,
            98454616,
            98452183,
            98446811,
            98455267,
            98447295,
            98450250,
            98449344,
            98450158,
            98450376,
            98449480
        ],
        "A": [
            98444992,
            98445944,
            98444925,
            98445065,
            98445347,
            98445666,
            98444771,
            98446535,
            98446420,
            98447534,
            98447441,
            98445935,
            98450208,
            98461593,
            98445099,
            98445257,
            98445487,
            98446333,
            98447509,
            98445254
        ]
    },
    "name": "C. Xor Tree",
    "statement": "For a given sequence of non-negative integers (b_1, b_2,\r\ndots, b_k) we determine if it is in the following way: Consider a graph\r\non k nodes, with numbers from b_1 to b_k written on them. For every i\r\nfrom 1 to k: find such j (1\r\nle j\r\nle k, j\r\nneq i), for which (b_i\r\noplus b_j) among all such j, where\r\noplus denotes the operation of bitwise XOR\r\n(https://en.wikipedia.org/wiki/Bitwise_operation#XOR). Next, draw an\r\nedge between vertices with numbers b_i and b_j in this graph. We say\r\nthat the sequence is if and only if the resulting graph forms a (is\r\nconnected and doesnâ€™t have any simple cycles). It is possible that for\r\nsome numbers b_i and b_j, you will try to add the edge between them\r\ntwice. Nevertheless, you will add this edge only once.You can find an\r\nexample below (the picture corresponding to the first test case).\r\nSequence (0, 1, 5, 2, 6) good as we reach 1 from 5.However, sequence (0,\r\n1, 5, 2) good. You are given a sequence (a_1, a_2,\r\ndots, a_n) of non-negative integers. You would like to remove some of\r\nthe elements (possibly none) to make the sequence good. What is the\r\nminimum possible number of removals required to achieve this goal?It can\r\nbe shown that for any sequence, we can remove some number of elements,\r\nleaving at least 2, so that the remaining sequence is good.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int S = (int)7e6;\nconst int K = 30;\nint g[S][2];\nint n, m = 1;\nint ans = 1;\n\nvoid dfs(int v, int x) {\n\tif (g[v][0] == 0 && g[v][1] == 0) {\n\t\tans = max(ans, x);\n\t\treturn;\n\t}\n\tif (g[v][0] != 0 && g[v][1] != 0) x++;\n\tfor (int c = 0; c < 2; c++) {\n\t\tif (g[v][c] != 0)\n\t\t\tdfs(g[v][c], x);\n\t}\n} \n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tint v = 0;\n\t\tfor (int k = K - 1; k >= 0; k--) {\n\t\t\tint c = (x >> k) & 1;\n\t\t\tif (g[v][c] == 0) g[v][c] = m++;\n\t\t\tv = g[v][c];\n\t\t}\n\t}\n\tdfs(0, 1);\n\tprintf(\"%d\\n\", n - ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "divide and conquer",
        "dp",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Xor Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/82067",
    "editorial": "Let F(S)\n be the maximum possible number of values we can take from S\n so that they form a good sequence. Divide the numbers into S0\n and S1\n as above. If S0\n or S1\n is empty, strip the most significant bit and solve the problem recursively. Otherwise, the result is 1+max(F(S0),F(S1))\n. Straightforward recursive calculation of this formula gives the runtime of (n?30)\n, as all numbers are smaller than 230\n.",
    "hint": []
}