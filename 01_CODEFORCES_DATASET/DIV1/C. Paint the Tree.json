{
    "link": "https://codeforces.com//contest/1240/problem/C",
    "problemId": "432408",
    "problem_idx": "C",
    "shortId": "1240C",
    "contest_number": "1240",
    "problem_submissions": {
        "E": [
            62021022,
            62035875,
            62035850,
            62028210,
            62027934,
            62027922,
            62020968,
            62019492,
            62018107,
            62027376,
            62027344,
            62027323,
            62027283,
            62027247,
            62024590,
            62019193,
            62026365,
            62033510,
            66614259
        ],
        "F": [
            62015871,
            62023134,
            62022377,
            62098107,
            62038718,
            62038624,
            62038494,
            62038407,
            62038292,
            74689890,
            62022214
        ],
        "C": [
            62011492,
            62004160,
            62005302,
            62005113,
            62008834,
            61997769,
            62007006,
            62008153,
            62005139,
            62004806,
            62004551,
            62010900,
            62006495,
            62006440,
            62005717,
            62009451,
            62008088,
            62007344,
            62007020,
            62010351
        ],
        "D": [
            62009147,
            62009402,
            62014575,
            62037666,
            62037540,
            62037485,
            62037237,
            62030534,
            62030405,
            62030387,
            62030368,
            62030266,
            62027938,
            62013459,
            62012657,
            62006383,
            62007439,
            62012558,
            62014620,
            62005092,
            62013564,
            62012342,
            62013093,
            62013916,
            62013931,
            62014362,
            62014894
        ],
        "B": [
            61999051,
            61998153,
            62000446,
            61993443,
            62005202,
            62003856,
            62003729,
            61994391,
            61998951,
            61998615,
            61999693,
            62002895,
            62001444,
            62001486,
            61999611,
            62004268,
            62001331,
            62002370,
            62000744,
            61994760
        ],
        "A": [
            61993335,
            61995494,
            62011119,
            61998900,
            61995613,
            62001949,
            61995342,
            62005037,
            61996323,
            61994369,
            61994535,
            62007707,
            61995405,
            61994877,
            61995746,
            61997040,
            61995992,
            61997766,
            61995459,
            62004034
        ]
    },
    "name": "C. Paint the Tree",
    "statement": "You are given a weighted tree consisting of n vertices. Recall that a\r\ntree is a connected graph without cycles. Vertices u_i and v_i are\r\nconnected by an edge with weight w_i.Let\u2019s define the k-coloring of the\r\ntree as an assignment of exactly k colors to vertex, so that each color\r\nis used no more than two times. You can assume that you have infinitely\r\nmany colors available. We say that an edge is in the given k-coloring if\r\nits endpoints share at least one color (i.e. there exists a color that\r\nis assigned to both endpoints).Let\u2019s also define the of a k-coloring as\r\nthe sum of weights of edges.Please calculate the maximum possible of a\r\nk-coloring of the given tree.You have to answer q independent queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=501000;\nint n,k,_;\nll dp[N][2];\nvector<PII> e[N];\nvoid dfs(int u,int f) {\n\tll sm=0;\n\tvector<ll> dd;\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (v==f) continue;\n\t\tdfs(v,u);\n\t\t// 0 <=k 1 <= k-1\n\t\tll w0=dp[v][0],w1=dp[v][1]+p.se;\n\t\tsm+=w0;\n\t\tdd.pb(w1-w0);\n\t}\n\tsort(all(dd)); reverse(all(dd));\n\tdp[u][0]=dp[u][1]=sm;\n\trep(i,0,SZ(dd)) {\n\t\tsm+=max(dd[i],0ll);\n\t\tif (i+1<k) dp[u][1]=max(dp[u][1],sm);\n\t\tif (i+1<=k) dp[u][0]=max(dp[u][0],sm);\n\t}\n//\tprintf(\"gg %d %lld %lld\\n\",u,dp[u][0],dp[u][1]);\n}\n\nvoid solve() {\n\tscanf(\"%d%d\",&n,&k);\n\trep(i,1,n+1) e[i].clear();\n\trep(i,1,n) {\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\te[u].pb(mp(v,w)); e[v].pb(mp(u,w));\n\t}\n\tdfs(1,0);\n\tprintf(\"%lld\\n\",dp[1][0]);\n}\n\nint main() {\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "sortings",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Paint the Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/70358",
    "editorial": "It is obvious that if we paint two vertices in the same color, they should be adjacent to each other \u0097 otherwise we could paint them in different colors, and the answer would not be worse. So we can reduce the problem to the following: choose a set of edges with maximum cost such that no vertex is adjacent to more than k\n chosen edges. This problem is very similar to maximum weighted matching on the tree, and we can try to use some methods that allow us to solve that problem.\n\nLet's solve the problem using dynamic programming dpv,f\n \u0097 the answer to the problem for the subtree of the vertex v\n, f\n is the flag that denotes whether the edge from v\n to its parent is chosen. Depending on the flag f\n, we can choose k\n or k?1\n edges connecting our vertex to its children (let's denote the maximum number of edges we can choose as t\n).\n\nWe have to select no more than t\n child nodes of the vertex v\n. If we choose an edge leading to node u\n, then dpu,1+wv,u\n is added to the dp\n value we are currently calculating; otherwise, dpu,0\n is added.\n\nBased on this formula, you have to choose no more than t\n child nodes of vertex v\n for which the total sum of dpu,1+wv,u?dpu,0\n is maximum."
}