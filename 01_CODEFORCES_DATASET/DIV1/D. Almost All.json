{
    "link": "https://codeforces.com//contest/1205/problem/D",
    "problemId": "390600",
    "problem_idx": "D",
    "shortId": "1205D",
    "contest_number": "1205",
    "problem_submissions": {
        "B": [
            59042855,
            59008277,
            59009392,
            59009099,
            59017750,
            59011582,
            59017246,
            59016172,
            59010044,
            59012507,
            59016410,
            59014372,
            59018459,
            59016311,
            59014609,
            59017774,
            59016256,
            59018790,
            59017251,
            59019103
        ],
        "F": [
            59040509,
            83365787,
            73837920,
            59054768,
            59706336,
            59497174,
            59084173,
            59131512
        ],
        "E": [
            59035128,
            59036458,
            59034704,
            59041033,
            59039150,
            59045402,
            59080765,
            59062429
        ],
        "D": [
            59016188,
            59026535,
            59028832,
            59032222,
            59023841,
            59032667,
            59050800,
            59047976,
            59037746,
            59038899,
            59036700,
            59037946,
            59034393,
            59042000,
            59040164,
            59037017,
            59039734,
            59041481,
            59041292,
            59040370,
            59040328
        ],
        "A": [
            59004226,
            59002142,
            59002328,
            59003907,
            59002592,
            59003675,
            59003063,
            59008409,
            59005394,
            59004820,
            59012388,
            59002589,
            59006476,
            59006648,
            59014700,
            59002817,
            59005001,
            59008957,
            59004360,
            59003394
        ],
        "C": [
            59022089,
            59020944,
            59025032,
            59033727,
            59026494,
            59026517,
            59028041,
            59025931,
            59027756,
            59033147,
            59024700,
            59031289,
            59032853,
            59030231,
            59031302,
            59030790,
            59030100,
            59029442,
            59031718
        ]
    },
    "name": "D. Almost All",
    "statement": "You are given a tree with n nodes. You have to write non-negative\r\nintegers on its edges so that the following condition would be\r\nsatisfied:For every two nodes i, j, look at the path between them and\r\ncount the sum of numbers on the edges of this path. Write all obtained\r\nsums on the blackboard. Then every integer from 1 to\r\nlfloor\r\nfrac{2n^2}{9}\r\nrfloor has to be written on the blackboard at least once. It is\r\nguaranteed that such an arrangement exists.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,x[SZ],y[SZ],fa[SZ],fe[SZ]; Edgc\nint sz[SZ],mi=2e9,u;\nvoid dd(int w,int f=0)\n{\n\tsz[w]=1; fa[w]=f;\n\tint mx=0;\n\tfor esb(w,e,b) if(b!=f)\n\t{\n\t\tdd(b,w); sz[w]+=sz[b];\n\t\tmx=max(mx,sz[b]);\n\t}\n\tmx=max(mx,n-sz[w]);\n\tif(mx<mi) mi=mx,u=w;\n}\nvoid go(int x,int l,ll s)\n{\n\tfe[x]=l*(ll)s; l=1;\n\tfor esb(x,e,b) if(b!=fa[x])\n\t\tgo(b,l,s),l+=sz[b];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t\tscanf(\"%d%d\",x+i,y+i),\n\t\tadde(x[i],y[i],i);\n\tdd(1);\n\tint U=u; dd(u); u=U;\n\tvector<pii> s;\n\tfor esb(u,e,b)\n\t\ts.pb(pii(sz[b],b));\n\tsort(s.begin(),s.end());\n\tll mx=-1; int I,l,r;\n\t{\n\tint L=0,R=n-1;\n\tfor(int i=0;i<=s.size();++i)\n\t{\n\t\tif(i) L+=s[i-1].fi,R-=s[i-1].fi;\n\t\tll u=(L+1)*ll(R+1);\n\t\tif(u>mx) mx=u,I=i,l=L,r=R;\n\t}\n\t}\n\tint cl=1;\n\tfor(int i=0;i<I;++i)\n\t{\n\t\tint t=s[i].fi;\n\t\tgo(s[i].se,cl,1);\n\t\tcl+=t;\n\t}\n\tcl=1;\n\tfor(int i=I;i<s.size();++i)\n\t{\n\t\tint t=s[i].fi;\n\t\tgo(s[i].se,cl,l+1);\n\t\tcl+=t;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(i!=u)\n\t\t\tprintf(\"%d %d %d\\n\",i,fa[i],fe[i]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Almost All.json",
    "editorial_link": "https://codeforces.com/blog/entry/69158",
    "editorial": "First we prove the following lemma:Suppose that there are vertices in\r\nthe tree with the root . Let also be any different positive numbers.\r\nThen we can arrange non-negative integers on the edges of so that the\r\ndistances from to the remaining vertices of the tree are in some\r\norder.Proof: for example, by induction. Let be some child of in whose\r\nsubtree, including , there are vertices. Then we write on the edge\r\nbetween , and solve the problem for the subtree and the numbers . After\r\nthat, we discard the subtree of from consideration and fill in the\r\nremaining edges for the numbers .Thus, the lemma is proved.Now let be\r\nthe centroid of tree. Root the tree from and let be the sizes of the\r\nsubtrees of his childs (as we know, ). Divide the subtrees of the childs\r\ninto two groups so that size of each group is at least . It is possible:\r\nwhile there are at least subtrees, there are two for which there are no\r\nmore than vertices in total, then we unite them. When we have subtrees\r\nleft, we will unite two smaller ones into one group. It is easy to see\r\nthat in each of the two groups there will be at least vertices.Let the\r\nfirst group have vertices and the second . Then, using the lemma, we put\r\nthe numbers on the edges in and between and so that the distances from\r\nto the vertices of the first group are . Similarly, we make the distance\r\nfrom to the vertices of the second group equal to . Then each number\r\nfrom to can be obtained as the distance between some vertex from the\r\nfirst group and some from the second. It is easy to show that for and\r\ncannot be less than . (For example, we can say that this value is\r\nminimized at and get for (the case of is obvious)).Asymptotics (but a\r\nchecker takes )\r\n"
}