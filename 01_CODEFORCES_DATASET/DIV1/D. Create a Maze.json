{"link": "https://codeforces.com//contest/715/problem/D", "problemId": "71753", "problem_idx": "D", "shortId": "715D", "contest_number": "715", "problem_submissions": {"C": [20696388, 20695004, 21061298, 20699940, 20701250, 20701868, 20701116, 20702792, 20705491, 20706113, 20706200, 20706281, 20707436, 24089587, 24089381, 24088919, 20705717, 20710613, 20711318, 20708989, 20702215], "B": [20690967, 20701021, 20694773, 20689928, 20695175, 20694958, 20694279, 20691617, 20695201, 20696087, 20696649, 20697145, 20700774, 20699191, 20696353, 20693835, 20699900, 20710746], "A": [20686008, 20686996, 20686577, 20686363, 20687890, 20687984, 20686198, 20687360, 20686283, 20689813, 20687583, 20686153, 20687354, 20704067, 20689971, 20689194, 20690664, 20687863, 20690670, 20692537], "D": [20709863, 20712963, 20746777, 20704223, 20700524]}, "name": "D. Create a Maze", "statement": "ZS the Coder loves mazes. Your job is to create one so that he can play\r\nwith it. A maze consists of rooms, and the rooms are arranged in rows\r\n(numbered from the top to the bottom starting from ) and columns\r\n(numbered from the left to the right starting from ). The room in the\r\n-th row and -th column is denoted by . A player starts in the room and\r\nwants to reach the room .Each room has four doors (except for ones at\r\nthe maze border), one on each of its walls, and two adjacent by the wall\r\nrooms shares the same door. Some of the doors are locked, which means it\r\nis impossible to pass through the door. For example, if the door\r\nconnecting and is locked, then we can\u2019t go from to . Also, one can only\r\ntravel between the rooms downwards (from the room to the room ) or\r\nrightwards (from the room to the room ) provided the corresponding door\r\nis not locked. ZS the Coder considers a maze to have if there is exactly\r\nways of travelling from the room to the room . Two ways are considered\r\ndifferent if they differ by the sequence of rooms visited while\r\ntravelling.Your task is to create a maze such that its difficulty is\r\nexactly equal to . In addition, ZS the Coder doesn\u2019t like large mazes,\r\nso the size of the maze and the number of locked doors are limited.\r\nSounds simple enough, right?\r\n", "solutions": ["// Coding on my mac\n// My mac doesn't have bits/stdc++.h\n// http://codeforces.com/blog/entry/47152 looks helpful\n// If only I could be bothered setting things up\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nvector<pair<pair<int, int>, pair<int, int> > > ans;\nbool open[52][52][2];\n\nint main()\n{\n\tcout << 42 << ' ' << 50 << '\\n';\n\tcin.sync_with_stdio(false); cin.tie(0);\n\tll n; cin >> n;\n\tfor (int i = 0;i < 52;i++) for (int j = 0;j < 52;j++) open[i][j][0] = open[i][j][1] = true;\n\tfor (int i = 0;i < 13;i++)\n\t{\n\t\tint r = 3*i+3, c = 3*i+11;\n\t\topen[r][c+3][0] = false;\n\t\topen[r+1][c+3][0] = false;\n\t\topen[r+2][c+3][0] = false;\n\t\topen[r+3][c][1] = false;\n\t\topen[r+3][c+1][1] = false;\n\t\topen[r+3][c+2][1] = false;\n\t}\n\tint from = 1;\n\tfor (int i = 1;i <= 42;i++)\n\t{\n\t\topen[i][from][0] = false;\n\t\tif (i >= 7 && i%3 == 1)\n\t\t{\n\t\t\topen[i][from][0] = true;\n\t\t\topen[i][from][1] = false;\n\t\t\topen[i][from+1][1] = false;\n\t\t\topen[i][from+2][1] = false;\n\t\t\topen[i][from+3][0] = false;\n\t\t\tfrom += 3;\n\t\t}\n\t}\n\tfor (int i = 12;i >= -1;i--)\n\t{\n\t\tint r = 3*i+3, c = 3*i+11;\n\t\tint va = n%20; n /= 20;\n\t\tif (va == 0) continue;\n\t\tint bone = c - 10;\n\t\tif (bone <= 0) bone = 1;\n\t\tfor (int j = bone+1;j < c+3;j++) open[r+3][j][1] = false;\n\t\topen[r+3][bone][0] = true;\n\t\tif (va == 1) continue;\n\t\topen[r+2][bone][0] = true;\n\t\tif (va <= 10) open[r+2][bone+va-1][0] = false;\n\t\telse\n\t\t{\n\t\t\topen[r+2][bone+9][0] = false;\n\t\t\tint wh = bone + 20 - va;\n\t\t\topen[r+1][bone][0] = true;\n\t\t\tfor (int j = bone+1;j < wh;j++) open[r+1][j][1] = false;\n\t\t\topen[r+1][wh][0] = false;\n\t\t}\n\t}\n\tfor (int i = 1;i <= 42;i++) for (int j = 1;j <= 50;j++)\n\t{\n\t\tif (!open[i][j][0] && j != 50)\n\t\t\tans.push_back({{i, j}, {i, j+1}});\n\t\tif (!open[i][j][1] && i != 42)\n\t\t\tans.push_back({{i, j}, {i+1, j}});\n\t}\n\tcout << ans.size() << '\\n';\n\tfor (auto u: ans) cout << u.first.first << ' ' << u.first.second << ' ' << u.second.first << ' ' << u.second.second << '\\n';\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "3100", "interactive": false}