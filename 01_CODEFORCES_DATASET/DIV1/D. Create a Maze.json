{
    "link": "https://codeforces.com//contest/715/problem/D",
    "problemId": "71753",
    "problem_idx": "D",
    "shortId": "715D",
    "contest_number": "715",
    "problem_submissions": {
        "C": [
            20696388,
            20695004,
            21061298,
            20699940,
            20701250,
            20701868,
            20701116,
            20702792,
            20705491,
            20706113,
            20706200,
            20706281,
            20707436,
            24089587,
            24089381,
            24088919,
            20705717,
            20710613,
            20711318,
            20708989,
            20702215
        ],
        "B": [
            20690967,
            20701021,
            20694773,
            20689928,
            20695175,
            20694958,
            20694279,
            20691617,
            20695201,
            20696087,
            20696649,
            20697145,
            20700774,
            20699191,
            20696353,
            20693835,
            20699900,
            20710746
        ],
        "A": [
            20686008,
            20686996,
            20686577,
            20686363,
            20687890,
            20687984,
            20686198,
            20687360,
            20686283,
            20689813,
            20687583,
            20686153,
            20687354,
            20704067,
            20689971,
            20689194,
            20690664,
            20687863,
            20690670,
            20692537
        ],
        "D": [
            20709863,
            20712963,
            20746777,
            20704223,
            20700524
        ]
    },
    "name": "D. Create a Maze",
    "statement": "ZS the Coder loves mazes. Your job is to create one so that he can play\r\nwith it. A maze consists of rooms, and the rooms are arranged in rows\r\n(numbered from the top to the bottom starting from ) and columns\r\n(numbered from the left to the right starting from ). The room in the\r\n-th row and -th column is denoted by . A player starts in the room and\r\nwants to reach the room .Each room has four doors (except for ones at\r\nthe maze border), one on each of its walls, and two adjacent by the wall\r\nrooms shares the same door. Some of the doors are locked, which means it\r\nis impossible to pass through the door. For example, if the door\r\nconnecting and is locked, then we can’t go from to . Also, one can only\r\ntravel between the rooms downwards (from the room to the room ) or\r\nrightwards (from the room to the room ) provided the corresponding door\r\nis not locked. ZS the Coder considers a maze to have if there is exactly\r\nways of travelling from the room to the room . Two ways are considered\r\ndifferent if they differ by the sequence of rooms visited while\r\ntravelling.Your task is to create a maze such that its difficulty is\r\nexactly equal to . In addition, ZS the Coder doesn’t like large mazes,\r\nso the size of the maze and the number of locked doors are limited.\r\nSounds simple enough, right?\r\n",
    "solutions": [
        "// Coding on my mac\n// My mac doesn't have bits/stdc++.h\n// http://codeforces.com/blog/entry/47152 looks helpful\n// If only I could be bothered setting things up\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nvector<pair<pair<int, int>, pair<int, int> > > ans;\nbool open[52][52][2];\n\nint main()\n{\n\tcout << 42 << ' ' << 50 << '\\n';\n\tcin.sync_with_stdio(false); cin.tie(0);\n\tll n; cin >> n;\n\tfor (int i = 0;i < 52;i++) for (int j = 0;j < 52;j++) open[i][j][0] = open[i][j][1] = true;\n\tfor (int i = 0;i < 13;i++)\n\t{\n\t\tint r = 3*i+3, c = 3*i+11;\n\t\topen[r][c+3][0] = false;\n\t\topen[r+1][c+3][0] = false;\n\t\topen[r+2][c+3][0] = false;\n\t\topen[r+3][c][1] = false;\n\t\topen[r+3][c+1][1] = false;\n\t\topen[r+3][c+2][1] = false;\n\t}\n\tint from = 1;\n\tfor (int i = 1;i <= 42;i++)\n\t{\n\t\topen[i][from][0] = false;\n\t\tif (i >= 7 && i%3 == 1)\n\t\t{\n\t\t\topen[i][from][0] = true;\n\t\t\topen[i][from][1] = false;\n\t\t\topen[i][from+1][1] = false;\n\t\t\topen[i][from+2][1] = false;\n\t\t\topen[i][from+3][0] = false;\n\t\t\tfrom += 3;\n\t\t}\n\t}\n\tfor (int i = 12;i >= -1;i--)\n\t{\n\t\tint r = 3*i+3, c = 3*i+11;\n\t\tint va = n%20; n /= 20;\n\t\tif (va == 0) continue;\n\t\tint bone = c - 10;\n\t\tif (bone <= 0) bone = 1;\n\t\tfor (int j = bone+1;j < c+3;j++) open[r+3][j][1] = false;\n\t\topen[r+3][bone][0] = true;\n\t\tif (va == 1) continue;\n\t\topen[r+2][bone][0] = true;\n\t\tif (va <= 10) open[r+2][bone+va-1][0] = false;\n\t\telse\n\t\t{\n\t\t\topen[r+2][bone+9][0] = false;\n\t\t\tint wh = bone + 20 - va;\n\t\t\topen[r+1][bone][0] = true;\n\t\t\tfor (int j = bone+1;j < wh;j++) open[r+1][j][1] = false;\n\t\t\topen[r+1][wh][0] = false;\n\t\t}\n\t}\n\tfor (int i = 1;i <= 42;i++) for (int j = 1;j <= 50;j++)\n\t{\n\t\tif (!open[i][j][0] && j != 50)\n\t\t\tans.push_back({{i, j}, {i, j+1}});\n\t\tif (!open[i][j][1] && i != 42)\n\t\t\tans.push_back({{i, j}, {i+1, j}});\n\t}\n\tcout << ans.size() << '\\n';\n\tfor (auto u: ans) cout << u.first.first << ' ' << u.first.second << ' ' << u.second.first << ' ' << u.second.second << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Create a Maze.json",
    "editorial_link": "https://codeforces.com//blog/entry/47169",
    "editorial": "Prerequisites : None The solution to this problem is quite simple, if\r\nyou get the idea. Thanks to danilka.pro for improving the solution to\r\nthe current constraints which is much harder than my original proposal.\r\nNote that to calculate the difficulty of a given maze, we can just use\r\ndp. We write on each square (room) the number of ways to get from the\r\nstarting square to it, and the number written on will be the sum of the\r\nnumbers written on and , and the edge between and is blocked, we donât\r\nadd the number written on and similarly for . Weâll call the rooms\r\nsquares and the doors as edges. Weâll call locking doors as edge\r\ndeletions. First, we look at several attempts that do not work. Write in\r\nits binary representation. To solve the problem, we just need to know\r\nhow to construct a maze with difficulty and from a given maze with\r\ndifficulty . The most direct way to get from to is to increase both\r\ndimensions of the maze by . Letâs say the bottom right square of the\r\ngrid was and increased to . So, the number is written at . Then, we can\r\nblock off the edge to the left of and above . This will make the numbers\r\nin these two squares equal to , so the number in square would be , as\r\ndesired. To create from , we can increase both dimensions by , remove\r\nedges such that contains while contains (this requires deleting most of\r\nthe edges joining the -th column and -th column. Thus, the number in\r\nwould be . This wouldâve used way too many edge deletions and the size\r\nof the grid would be too large. This was the original proposal. Thereâs\r\nanother way to do it with binary representation. We construct a grid\r\nwith difficulty and from a grid with difficulty . The key idea is to\r\nmake use of surrounding s and maintaining it with some walls so that can\r\nbe easily constructed. This method is shown in the picture below. This\r\nmethod wouldâve used around grid and edge deletions, which is too large\r\nto pass. Now, what follows is the AC solution. Since itâs quite easy\r\nonce you get the idea, I recommend you to try again after reading the\r\nhint. To read the full solution, click on the spoiler tag. Hint : Binary\r\ncanât work since there can be up to binary digits for and our grid size\r\ncan be at most . In our binary solution we used a grid to multiply the\r\nnumber of ways by . What about using other grid sizes instead? Full\r\nSolutionOur AC solution uses base instead of binary. Write in base .\r\nNote that has at most digits in base , so to add a new digit we can\r\nincrease the dimensions by and the number of deleted edges can be up to\r\nper digit. Weâll construct such a way. This method is explained in the\r\npicture below. The key is to first construct a grid which has in it,\r\nthen find a way to get for all from by maintaining a wall of s around\r\nthe squares. This method uses a grid and at most edge deletions and will\r\nget AC.\r\n",
    "hint": []
}