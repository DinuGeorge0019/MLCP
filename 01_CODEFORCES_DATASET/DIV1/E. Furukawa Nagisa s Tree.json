{
    "link": "https://codeforces.com//contest/434/problem/E",
    "problemId": "9716",
    "problem_idx": "E",
    "shortId": "434E",
    "contest_number": "434",
    "problem_submissions": {
        "D": [
            6699538,
            6706635,
            6706622,
            6706591,
            6706589,
            6795823,
            6704699,
            6708335,
            6707919
        ],
        "C": [
            6697907,
            6699177,
            6698487,
            6699311,
            6699392,
            6797515,
            6797483,
            6718935,
            6697269,
            6700102,
            6699851,
            6696039,
            6700493,
            6700403,
            6700591,
            6698358,
            6698258,
            6700561,
            6698389
        ],
        "B": [
            6695587,
            6696287,
            6694622,
            6695678,
            6696514,
            6695797,
            6699364,
            6695860,
            6695864,
            6699676,
            6699377,
            6696715,
            6697097,
            6695263,
            6696899,
            6700084,
            6700621,
            6697368,
            6695731
        ],
        "A": [
            6692446,
            6694191,
            6692438,
            6693456,
            6692853,
            6692909,
            6693769,
            6692709,
            6691931,
            6694014,
            6700765,
            6693088,
            6694404,
            6692737,
            6695761,
            6695148,
            6698289,
            6693859,
            6708768
        ],
        "E": [
            6711897
        ]
    },
    "name": "E. Furukawa Nagisa s Tree",
    "statement": "One day, Okazaki Tomoya has bought a tree for Furukawa Nagisa’s\r\nbirthday. The tree is so strange that every node of the tree has a\r\nvalue. The value of the -th node is . Now Furukawa Nagisa and Okazaki\r\nTomoya want to play a game on the tree.Let be the path from node to node\r\n, we can write down the sequence of the values of nodes on path , and\r\ndenote this sequence as . We define the value of the sequence as\r\nfollows. Suppose that the sequence is , where is the length of the\r\nsequence. We define . If the path satisfies , then the path belongs to\r\nFurukawa Nagisa, otherwise it belongs to Okazaki Tomoya.Calculating who\r\nhas more paths is too easy, so they want to play something more\r\ndifficult. Furukawa Nagisa thinks that if paths and belong to her, then\r\npath belongs to her as well. Also, she thinks that if paths and belong\r\nto Okazaki Tomoya, then path belongs to Okazaki Tomoya as well. But in\r\nfact, this conclusion isn’t always right. So now Furukawa Nagisa wants\r\nto know how many triplets are correct for the conclusion, and this is\r\nyour task.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <map>\n\nusing namespace std;\n\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n\ntypedef long long llint;\n\nconst int MAXN = 100100;\n\nint pw[MAXN], inv[MAXN];\nint mod, xmod, k;\n\nint add(int x, int y) {\n  return x+y >= mod ? x+y-mod : x+y;\n}\nint sub(int x, int y) {\n  return x >= y ? x-y : x-y+mod;\n}\nint mul(int x, int y) {\n  return (llint(x)*y)%mod;\n}\n\nint powmod(int a, int b) {\n  if (b == 0) return 1;\n  if (b&1) return mul(a, powmod(a, b-1));\n  return powmod(mul(a, a), b/2);\n}\n\ntypedef pair<int, int> par;\n#define id first\n#define off second\n\nstruct data {\n  map<int, vector<par>> V;\n  map<int, int> M;\n  int p, a;\n  \n  int eval(int x) { return add(mul(x, pw[p]), a); }\n  int rev(int x) { return mul(sub(x, a), inv[p]); }  \n  void mulK(int d) {\n    p += d;\n    if (d < 0) a = mul(a, inv[-d]); else\n      a = mul(a, pw[d]);\n  }\n  void addA(int d) {\n    if (d < 0) a = sub(a, -d); else\n      a = add(a, d);\n  }\n  \n  void insert(int x, int id, int d) {\n    x = rev(x);\n    if (!M.count(x)) {\n      M[x] = 0;\n      V[x] = vector<par>();\n    }\n    V[x].push_back({id, d-M[x]});\n  }\n  \n  int count(int x, int d) {\n    x = rev(x);\n    if (!M.count(x)) return 0;\n    M[x] += d;\n    return V[x].size();\n  }\n\n  void clear(int *in) {\n    for (auto &v: V) {\n      int cnt = M[v.first];\n      for (auto &p: v.second)\n        in[p.id] += cnt + p.off;\n    }\n    p = a = 0;\n    M.clear();\n    V.clear();\n  }\n} mem[MAXN];\ndata *alloc = mem;\n\ndata *d[MAXN];\nint val[MAXN];\nint in[MAXN], out[MAXN];\nint sz[MAXN], m[MAXN];\nvector<int> E[MAXN];\n\nvoid dfs(int x, int dad) {\n  m[x] = -1, sz[x] = 1;\n  for (int y: E[x])\n    if (y != dad) {\n      dfs(y, x);\n      sz[x] += sz[y];\n      if (m[x] == -1 || sz[y] > sz[m[x]]) m[x] = y;\n    }\n  if (dad != -1) E[x].erase(find(E[x].begin(), E[x].end(), dad));\n  if (m[x] != -1) E[x].erase(find(E[x].begin(), E[x].end(), m[x]));\n}\n\nvoid go(int x, data *good, data *bad) {\n  good->mulK(+1), good->addA(+val[x]);\n  bad->mulK(+1), bad->addA(+val[x]);\n\n  out[x] += good->count(xmod, +1);\n  out[x] -= bad->count(xmod, -1);\n\n  for (int y: E[x]) go(y, good, bad);\n  if (m[x] != -1) go(m[x], good, bad);\n\n  good->addA(-val[x]), good->mulK(-1);\n  bad->addA(-val[x]), bad->mulK(-1);\n}\n  \nvoid solveDown(int x) {\n  if (m[x] == -1) d[x] = alloc++; else {\n    solveDown(m[x]);\n    d[x] = d[m[x]];\n  }\n\n  d[x]->mulK(1);\n  d[x]->insert(0, x, 0);\n  d[x]->addA(val[x]);\n\n  for (int y: E[x]) {\n    solveDown(y);\n    d[y]->mulK(1), d[y]->addA(val[x]);\n    for (auto &v: d[y]->V) {\n      int real_v = d[y]->eval(v.first);\n      for (auto &p: v.second)\n        d[x]->insert(real_v, p.id, 0);\n    }\n  }\n  \n  for (int y: E[x]) { \n    go(y, d[x], d[y]);\n    d[y]->clear(in);\n  }\n\n  out[x] += d[x]->count(xmod, +1);\n}\n\nvoid fill(int x, int cur, int len, data *d) {\n  cur = add(cur, mul(val[x], pw[len]));\n  d->insert(cur, x, 0);\n  for (int y: E[x])\n    fill(y, cur, len+1, d);\n  if (m[x] != -1) fill(m[x], cur, len+1, d);\n}\n\nvoid solveUp(int x) {\n  d[x]->mulK(1), d[x]->addA(val[x]);\n  for (int y: E[x]) {\n    d[y] = alloc++; // prazno\n    go(y, d[x], d[y]);\n    solveUp(y);\n    d[y]->clear(in);\n  }\n\n  out[x] += d[x]->count(xmod, +1);  \n  d[x]->insert(val[x], x, 0);\n\n  if (m[x] != -1) {\n    for (int y: E[x])\n      fill(y, val[x], 1, d[x]);\n    d[m[x]] = d[x];\n    solveUp(m[x]);\n  }\n}\n\nint main(void) {\n  int n;\n  scanf(\"%d %d %d %d\", &n, &mod, &k, &xmod);\n  REP(i, n) scanf(\"%d\", val+i);\n  REP(i, n-1) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b); --a, --b;\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  pw[0] = inv[0] = 1;\n  REP(i, n) {\n    pw[i+1] = mul(pw[i], k);\n    inv[i+1] = powmod(pw[i+1], mod-2);\n  }\n\n  dfs(0, -1);\n\n  solveDown(0);\n  d[0]->clear(in); alloc = mem;\n  \n  d[0] = alloc++;\n  solveUp(0);\n  d[0]->clear(in); alloc = mem;\n\n  llint bad = 0;\n  REP(i, n) {\n    llint in1 = in[i], in0 = n - in[i];\n    llint out1 = out[i], out0 = n - out[i];\n    bad += 2*in1*in0 + in1*out0 + 2*out1*out0 + out1*in0;\n  }\n\n  llint ans = llint(n)*n*n - bad/2;\n  cout << ans << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "divide and conquer",
        "sortings",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Furukawa Nagisa s Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/12397",
    "editorial": "In order not to mess things up, we use capital letters , and to denote\r\nthe values in the original problem. First, we can build a directed graph\r\nwith edges. Let be the edge from node to node . If path is good, the\r\ncolor of is , otherwise it is . We want to calculate the number of\r\ntriplets that satisfies , and are all good or all not good. It equals\r\nthe number of directed triangles, the color of whose three edges are the\r\nsame. (The triangle is like: ) Calculating this is difficult, so let us\r\ncalculate the number of directed triangles whose three edges are not all\r\nthe same. Let be the number of in-edges of node whose color is .\r\nSimilarly define , , . Let We can see that the answer is twice the\r\nnumber of triangles whose three edges are not all the same. So we can\r\nsee the answer of the original problem is . Itâs certain that , so we\r\nonly need to calculate out0 and in0. Let us calculate first. We can use\r\nthe \"Divide and Conquer on trees\" algorithm to solve this in time.\r\nChoose a root and get its subtree, we can get all the values of the\r\npaths from a node in the subtree to node . We save the values and the\r\nlengths of the paths. For a path from node with value and length , we\r\nwant to find a node which makes . Let be the sequence of the value of\r\nnodes on except node , then As , so . As is a prime number, we can get\r\neasily. Let , then the problem becomes that we need to calculate how\r\nmany paths from node to a node in the subtree except node , whose value\r\nis , this can be done by doing binary search on a sorted array. So we\r\ncan get , and likewise. With these two arrays we can calculate the\r\nanswer. The total complexity is . Solution: 6707988, 6712931\r\n",
    "hint": []
}