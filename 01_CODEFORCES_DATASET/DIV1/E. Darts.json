{"link": "https://codeforces.com//contest/107/problem/E", "problemId": "566", "problem_idx": "E", "shortId": "107E", "contest_number": "107", "problem_submissions": {"D": [631074, 632228, 633629, 632921, 633464, 632054, 631978, 632641, 632457, 632305, 633703, 632778, 632827], "C": [629632, 632720, 632094, 632639, 634261, 630830, 636165, 633949], "B": [628278, 628879, 628954, 627989, 629002, 630226, 628861, 629530, 628650, 628939, 628920, 629402, 628525, 629206, 629445, 629058, 629408], "A": [627482, 627526, 628267, 627433, 628167, 627658, 627777, 628413, 627577, 628188, 628306, 630891, 627548, 627550, 629729, 627698, 627546], "E": [633956]}, "name": "E. Darts", "statement": "The night after the graduation ceremony graduate students of German\r\nUniversity in Cairo (GUC) are playing darts. As there\u2019s no real dart\r\nboard available, the photographs of members of the GUC upper management\r\nare being used.So, rectangular photos are placed on the wall. They can\r\noverlap arbitrary and even coincide. The photos are not necessarily\r\nplaced horizontally or vertically, they could also be rotated before\r\nbeing pinned to the wall.The score of one dart throw is simply the\r\nnumber of photos the dart went through.Fatma has made a throw but her\r\nscore was not recorded. She only remembers that she did make it into at\r\nleast one photo.Assuming that the probability distribution of the throw\r\nis equal across the whole wall, what would be the expectation of Fatma\u2019s\r\nscore?\r\n", "solutions": ["#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <cstdlib>\n#include <map>\n\n#define y0 y63475625\n#define y1 y28435\n#define sqr(x) ((x)*(x))\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define re return\n\n#ifdef ONLINE_JUDGE\n#pragma comment(linker, \"/STACK:16777216\")\n#endif\n\nusing namespace std;\n\ntypedef vector <int> vi;\ntypedef vector <vi> vvi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> ii;\ntypedef vector <ii> vii;\n\ntemplate <class T> T abs(const T & a) {\n    return a > 0 ? a : -a;\n}\n\ntemplate <class T> int sgn(const T & a) {\n    return a > 0 ? 1 : (a < 0 ? -1 : 0);\n}\n\nconst double PI = 2.0 * acos(1.0);\n\nstruct point {\n    double x, y;\n};\n\npoint operator - (point a, point b) {\n    a.x -= b.x;\n    a.y -= b.y;\n    re a;\n}\n\npoint operator + (point a, point b) {\n    a.x += b.x;\n    a.y += b.y;\n    re a;\n}\n\ndouble operator * (point a, point b) {\n    re a.x * b.x + a.y * b.y;\n}\n\ndouble operator ^ (point a, point b) {\n    re a.x * b.y - a.y * b.x;\n}\n\npoint operator * (point a, double b) {\n    a.x *= b;\n    a.y *= b;\n    re a;\n}\n\nint n;\npoint p[500][4];\n\nbool inside(point a, int k) {\n    for (int i = 0; i < 4; i++) {\n        point A = p[k][i];\n        point B = p[k][(i + 1) % 4];\n        if (abs((A - a) ^ (B - a)) < 1e-9) {\n            re ((A - a) * (B - a) <= 0.0);\n        }\n        if (((A - a) ^ (B - a)) < 0.0) re false;\n    }\n    re true;\n}\n\nint main()\n{\n    cin >> n;\n    double S = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) cin >> p[i][j].x >>  p[i][j].y;\n        if (((p[i][1] - p[i][0]) ^ (p[i][3] - p[i][0])) < 0) {\n            reverse(p[i], p[i] + 4);\n        }\n        S += (p[i][1] - p[i][0]) ^ (p[i][3] - p[i][0]);\n    }\n    double SS = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 4; j++) {\n            point A = p[i][j], B = p[i][(j + 1) % 4];\n            vector <pair <double, int> > t;\n            t.pb(mp(1.0, -1.0));\n            \n            for (int k = 0; k < n; k++) if (k != i) {\n                vector <pair <double, int> > q;\n                bool onborder = false;\n                for (int l = 0; l < 4; l++) {\n                    point C = p[k][l], D = p[k][(l + 1) % 4];\n                    if (abs((A - B) ^ (C - D)) < 1e-9) {\n                        if (abs((C - A) ^ (B - A)) > 1e-9) continue;\n                        if ((B - A) * (D - C) < 0) continue;\n                        /*(if (i == 0 && B.x == 2 && B.y == 2 && k == 2) {\n                            cerr << \"sdfjkg\\n\";\n                            cerr << C.x << ' ' << C.y << ' ' << D.x << ' ' << D.y << endl;\n                        }*/\n                        onborder = true;\n                        if (i < k) continue;\n                        point v = (B - A);\n                        double ta = (A - A) * v;\n                        double tb = (B - A) * v;\n                        double tc = (C - A) * v;\n                        double td = (D - A) * v;\n                        double l = max(ta, tc);\n                        double r = min(tb, td);\n                        if (l >= r) continue;\n                        q.clear();\n                        q.pb(mp(l / sqr(v), 1));\n                        q.pb(mp(r / sqr(v), -1));\n                        break;\n                    }\n                    double t = ((C - A) ^ (D - C)) / ((B - A) ^ (D - C));\n                    double s = ((A - C) ^ (B - A)) / ((D - C) ^ (B - A));\n                    if (0 < t && t < 1 && 0 < s && s < 1) {\n                        point N = D - C;\n                        swap(N.x, N.y);\n                        N.x = -N.x;\n                        q.pb(mp(t, sgn((B - A) * N)));\n                    }\n                }\n                if (q.size() == 1) {\n                    if (q[0].se < 0) q.pb(mp(0, 1)); else q.pb(mp(1.0, -1));\n                }\n                if (q.size() == 0 && !onborder) {\n                    if (inside(A, k) && inside(B, k)) {\n                        q.pb(mp(0.0, 1.0));\n                        q.pb(mp(1.0, -1.0));\n                    }\n                }\n                if (q.size() > 2) {\n                    while (1);\n                }\n                \n                /*if (i == 0 && B.x == 2 && B.y == 2 && k == 2) {\n                    cerr << A.x << ' ' << A.y << ' ' << onborder << endl;\n                    cerr << q.size() << endl;\n                }*/\n\n                while (q.size()) {\n                    t.pb(q.back());\n                    q.pop_back();\n                }\n                \n            }\n            sort(t.begin(), t.end());\n            point last = A;\n            int c = 0;\n            for (int k = 0; k < (int)t.size(); k++) {\n                point cur = A + (B - A) * t[k].fi;\n                if (c <= 0) {\n                    //cerr << last.x << ' ' << last.y << ' ' << cur.x << ' ' << cur.y << endl;\n                    SS += last ^ cur;\n                }\n                c += t[k].se;\n                last = cur;\n            }\n        }\n    }\n    SS = abs(SS / 2.0);\n    //cerr << S << ' ' << SS << endl;\n    printf(\"%.10lf\\n\", S / SS);\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["geometry", "probabilities"], "dificulty": "2700", "interactive": false}