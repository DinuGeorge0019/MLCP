{
    "link": "https://codeforces.com//contest/578/problem/F",
    "problemId": "35421",
    "problem_idx": "F",
    "shortId": "578F",
    "contest_number": "578",
    "problem_submissions": {
        "D": [
            13043018,
            13035846,
            13036528,
            13038587,
            13044167,
            13041175,
            13037259,
            13038897,
            13041869,
            13037673,
            13043371,
            13037414,
            13050779,
            13036416,
            13040134,
            13038396,
            13039211
        ],
        "E": [
            13038901,
            13041994,
            13043511,
            13044723,
            13047038,
            13049049,
            13049923,
            13047637,
            13049042,
            13047937,
            13049450,
            13060851,
            13041499,
            13046763
        ],
        "B": [
            13033269,
            13029103,
            13030026,
            13030734,
            13032310,
            13031712,
            13030424,
            13048740,
            13029417,
            13030120,
            13034104,
            13030544,
            13032556,
            13030378,
            13030241,
            13028648,
            13031292,
            13033423
        ],
        "C": [
            13032149,
            13030512,
            13032354,
            13033188,
            13037469,
            13037436,
            13032059,
            13034534,
            13040875,
            13051722,
            13037824,
            13032969,
            13057631,
            13032320,
            13033127,
            13034805,
            13035383,
            13037049
        ],
        "A": [
            13028273,
            13027990,
            13028573,
            13030087,
            13030676,
            13029354,
            13030453,
            13032789,
            13027838,
            13031000,
            13029241,
            13029752,
            13028730,
            13028651,
            13043323,
            13029257,
            13031415
        ],
        "F": [
            13054189,
            16905284,
            13299937
        ]
    },
    "name": "F. Mirror Box",
    "statement": "You are given a box full of mirrors. Box consists of grid of size . Each\r\ncell of the grid contains a mirror put in the shape of \u201d or \u201d ( degree\r\nto the horizontal or vertical line). But mirrors in some cells have been\r\ndestroyed. You want to put new mirrors into these grids so that the\r\nfollowing two conditions are satisfied: If you put a light ray\r\nhorizontally/vertically into the middle of any unit segment that is side\r\nof some border cell, the light will go out from the neighboring unit\r\nsegment to the segment you put the ray in. each unit segment of the grid\r\nof the mirror box can be penetrated by at least one light ray\r\nhorizontally/vertically put into the box according to the rules of the\r\nprevious paragraph After you tried putting some mirrors, you find out\r\nthat there are many ways of doing so. How many possible ways are there?\r\nThe answer might be large, so please find the result modulo prime number\r\n.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\ni64 P;\nstring f[101];\nint comp[111][111];\nint vis[111][111];\n\nint N, M;\n\nbool dfs(int x, int y, int px, int py, int c) {\n    if (x == px && y == py) return true;\n    if (vis[x][y] == 1) return false;\n    if (vis[x][y] == 2) return true;\n    comp[x][y] = c;\n    vis[x][y] = 1;\n    if (x < N && y < M && f[x][y] == '\\\\' && mp(x + 1, y + 1) != mp(px, py)) {\n        if (!dfs(x + 1, y + 1, x, y, c)) return false;\n    }\n    if (x < N && y > 0 && f[x][y - 1] == '/' && mp(x + 1, y - 1) != mp(px, py)) {\n        if (!dfs(x + 1, y - 1, x, y, c)) return false;\n    }\n    if (x > 0 && y < M && f[x - 1][y] == '/' && mp(x - 1, y + 1) != mp(px, py)) {\n        if (!dfs(x - 1, y + 1, x, y, c)) return false;\n    }\n    if (x > 0 && y > 0 && f[x - 1][y - 1] == '\\\\' && mp(x - 1, y - 1) != mp(px, py)) {\n        if (!dfs(x - 1, y - 1, x, y, c)) return false;\n    }\n    vis[x][y] = 2;\n    return true;\n}\n\ni64 deg(i64 x, i64 d) {\n    d %= P - 1;\n    if (d < 0) d += P - 1;\n    i64 y = 1;\n    while (d) {\n        if (d & 1) y *= x, y %= P;\n        d /= 2;\n        x *= x, x %= P;\n    }\n    return y;\n}\n\ni64 det(vvi64 a) {\n    int n = a.size();\n    i64 q = 1;\n    forn(i, n) {\n        int m = -1;\n        for (int j = i; j < n; ++j) {\n            if (a[j][i]) {\n                m = j;\n                break;\n            }\n        }\n        if (m < 0) return 0;\n        if (m != i) {\n            swap(a[m], a[i]);\n            q = -q;\n        }\n        i64 w = deg(a[i][i], -1);\n        for (int j = i + 1; j < n; ++j) {\n            i64 t = a[j][i] * w % P;\n            for (int k = i; k < n; ++k) {\n                a[j][k] -= t * a[i][k];\n                a[j][k] %= P;\n            }\n        }\n        q *= a[i][i];\n        q %= P;\n    }\n    return q;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    cin >> N >> M >> P;\n    forn(i, N) cin >> f[i];\n    forn(i, N + 1) forn(j, M + 1) comp[i][j] = -1;\n    int cc = 0;\n    forn(i, N + 1) forn(j, M + 1) {\n        if (vis[i][j]) continue;\n        if (!dfs(i, j, -1, -1, cc++)) {\n            cout << 0 << '\\n';\n            return 0;\n        }\n    }\n    i64 ans = 0;\n    forn(t, 2) {\n        map<int, int> en;\n        forn(x, N + 1) forn(y, M + 1) {\n            if (((x + y) & 1) != t) continue;\n            if (en.count(comp[x][y])) continue;\n            int z = en.size();\n            en[comp[x][y]] = z;\n        }\n        int K = en.size();\n        vvi64 a(K, vi64(K));\n        forn(x, N + 1) forn(y, M + 1) {\n            if (((x + y) & 1) != t) continue;\n            if (x < N && y < M && f[x][y] == '*') {\n                int c1 = en[comp[x][y]], c2 = en[comp[x + 1][y + 1]];\n                if (c1 != c2) --a[c1][c2], ++a[c1][c1];\n            }\n            if (x < N && y > 0 && f[x][y - 1] == '*') {\n                int c1 = en[comp[x][y]], c2 = en[comp[x + 1][y - 1]];\n                if (c1 != c2) --a[c1][c2], ++a[c1][c1];\n            }\n            if (x > 0 && y < M && f[x - 1][y] == '*') {\n                int c1 = en[comp[x][y]], c2 = en[comp[x - 1][y + 1]];\n                if (c1 != c2) --a[c1][c2], ++a[c1][c1];\n            }\n            if (x > 0 && y > 0 && f[x - 1][y - 1] == '*') {\n                int c1 = en[comp[x][y]], c2 = en[comp[x - 1][y - 1]];\n                if (c1 != c2) --a[c1][c2], ++a[c1][c1];\n            }\n        }\n        forn(i, K) forn(j, K) a[i][j] %= P;\n        a.resize(K - 1);\n        forn(i, K - 1) a[i].resize(K - 1);\n        i64 res = det(a);\n        cerr << res << '\\n';\n        ans += res;\n    }\n    ans %= P;\n    if (ans < 0) ans += P;\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "matrices",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Mirror Box.json",
    "editorial_link": "https://codeforces.com//blog/entry/20368",
    "editorial": "If we view the grid intersections alternatively colored by blue and red like this:\n\n \n\nThen we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.\n\nWe can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff\u0092s theorem.\n\nSince there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix."
}