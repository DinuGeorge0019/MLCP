{
    "link": "https://codeforces.com//contest/1874/problem/C",
    "problemId": "2236838",
    "problem_idx": "C",
    "shortId": "1874C",
    "contest_number": "1874",
    "problem_submissions": {
        "F": [
            226041334,
            226055202,
            226083158,
            226054781,
            226061315,
            226045179,
            226057161,
            226024417,
            226094016,
            226151126,
            226979730,
            226372437,
            226704730,
            226099033,
            226098861,
            226001871
        ],
        "B": [
            225998357,
            225944596,
            225961498,
            226022662,
            225970503,
            226048661,
            225965106,
            225956535,
            225974109,
            226024200,
            226979960,
            226057337,
            225972372,
            225968693,
            225962068,
            226040739,
            225981051,
            226047279,
            226046003,
            225948785
        ],
        "D": [
            225989950,
            226004287,
            225983656,
            225994935,
            225998958,
            226008015,
            225977564,
            226002115,
            225985427,
            226003081,
            225989658,
            226979804,
            225989175,
            226003010,
            226023529,
            226002830,
            226078484,
            226078353,
            226002716,
            226024255,
            226018418,
            226137164,
            225986804
        ],
        "E": [
            225973607,
            225981897,
            226000134,
            225978662,
            226074388,
            226073614,
            226073223,
            226072631,
            226071563,
            226069387,
            226068777,
            226021358,
            225958738,
            226070894,
            225983588,
            226039851,
            226021998,
            226007010,
            226979776,
            226006499,
            226036184,
            226038920,
            226053631,
            226068817,
            226063126,
            226059742,
            226057237
        ],
        "C": [
            225967620,
            225968755,
            225972644,
            225961410,
            225983858,
            225989707,
            225987635,
            225970993,
            225986658,
            225975231,
            226979908,
            225973609,
            225986638,
            225980254,
            225971024,
            227431342,
            225959672,
            225996237,
            225972869,
            226057682,
            225972171
        ],
        "A": [
            225936409,
            225922035,
            225921764,
            225934682,
            225931922,
            225937474,
            225923760,
            225922674,
            225923828,
            225922214,
            226979999,
            225944454,
            225937163,
            225922982,
            225921695,
            226083093,
            226083061,
            225937017,
            225941961,
            225925562,
            226022851,
            225923156
        ],
        "G": [
            226095099,
            226164597,
            226979660,
            226967841,
            230907178
        ]
    },
    "name": "C. Jellyfish and EVA",
    "statement": "Monsters have invaded the town again! Asuka invites her good friend,\r\nJellyfish, to drive EVA with her.There are n cities in the town. All the\r\nmonsters are in city n. Jellyfish and Asuka are currently in city 1 and\r\nneed to move to city n to defeat the monsters.There are m roads. The\r\ni-th road allows one to travel from city a_i to city b_i. All the roads\r\nare . That is, one cannot travel from city b_i to a_i using the i-th\r\nroad. Interestingly, all roads satisfy a_i<b_i.Driving EVA requires two\r\npeople to work together. However, Asuka and Jellyfish have not done any\r\ntraining together before.Suppose that EVA is currently in city u.\r\nJellyfish and Asuka will both choose an undestroyed road that starts at\r\ncity u. Suppose Jellyfish and Asuka choose roads that end at cities v_1\r\nand v_2 respectively. If v_1 = v_2, EVA moves to city v_1 successfully.\r\nOtherwise, EVA stays in city u and both roads that they have chosen will\r\nbe destroyed.It is possible that EVA is currently in city u (u\r\nneq n) and there are no undestroyed roads that start at city u. In that\r\ncase, the mission will be a failure. Otherwise, if they reach city n in\r\nthe end, the mission is considered a success.Every time they choose the\r\nroads, Jellyfish knows that Asuka will choose a road randomly. Now,\r\nJellyfish wants to know, if she chooses the roads optimally, what is the\r\nmaximum probability of the mission being successful.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7, M = 5007;\nint n, m;\nvi e[N];\ndouble dp[N];\ndouble ww[N];\ndouble f[M][M], lock[M];\nint top;\nvoid Main() {\n\tcin >> n >> m;\n\tL(i, 1, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\te[u].emplace_back(v);\n\t}\n\tL(cnt, 1, n) {\n\t\tL(i, 0, cnt) {\n\t\t\tf[cnt][i] = 0;\n\t\t}\n\t\tf[cnt][1] = 1. / cnt;\n\t\tL(i, 2, cnt) \n\t\t\tf[cnt][i] = (f[cnt - 2][i - 1] * (cnt - i) + f[cnt - 2][i - 2] * (i - 2)) / cnt;\n//\t\tL(i, 1, cnt) {\n//\t\t\tcout << f[cnt][i] << ' ';\n//\t\t}\n//\t\tcout << endl;\n\t}\n\t\n\tL(i, 0, n) {\n\t\tdp[i] = 0;\n\t}\n\tdp[n] = 1;\n\tR(i, n - 1, 1) {\n\t\ttop = 0;\n\t\tfor(auto&to : e[i]) {\n\t\t\tww[++top] = dp[to];\n\t\t}\n\t\tsort(ww + 1, ww + top + 1);\n\t\treverse(ww + 1, ww + top + 1);\n\t\tL(j, 1, top) {\n\t\t\tdp[i] += ww[j] * f[top][j];\n\t\t}\n\t}\n\t\n\tcout << dp[1] << '\\n';\n\tL(i, 1, n) {\n\t\te[i].clear();\n\t} \n}\nint main() {\n\tcout.precision(12); cout << fixed;\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Jellyfish and EVA.json",
    "editorial_link": "https://codeforces.com//blog/entry/120943",
    "editorial": "Tutorial Let\u00e2\u0080\u0099s solve this problem by dynamic programming, Let represents\nthe max probability of reaching city starting from city .The problem is\nhow to transition. for city , we assume that there are roads from city ,\nthe -th road from city is to city .Let\u00e2\u0080\u0099s sort by using as the keyword,\nwith with the larger coming first.Let\u00e2\u0080\u0099s define an array of elements\nequals to , according to the definition, is non-increasing.That is, next\nwe want to find an optimal solution such that the probability of going\nto city is , maximizing the value of .Tips: the sum of may not be ,\nbecause it is possible to stay at city when is even.For two choices of ,\nand , Sometimes we can\u00e2\u0080\u0099t which is better, for example:when , is better\nthan . But when , is better than .Tips. In fact, when , has only one\nchoice , the above is just a hypothetical to illustrate the problem.So\nwhen can we say, is always not worse than ?Lemma. If there are two\narrays and , satisfying , is always not worse than .Proof. Let\u00e2\u0080\u0099s\nconsider as and define , and , then , Because is non-increasing, so ,\nand we have , so .Now the problem is, there is whether an array not\nworse than any other arrays for for all .For , satisfies the\ncondition.For , satisfies the condition.What about ? After they choose\nthe roads for the first time, The size of the problem will become .For\nexample, when , Let\u00e2\u0080\u0099s assume Jellyfish choose for the first time, then\nthere will be situations: When Asuka chooses they will go to . When\nAsuka chooses , the problem changes into the subproblem with . When\nAsuka chooses , the problem changes into the subproblem with . When\nAsuka chooses , the problem changes into the subproblem with . By\ncalculating, , it also satisfies the condition.Let\u00e2\u0080\u0099s define as the best\narray when , as the the probabilities of going to cities except the city\nJellyfish choose for the first time. By recursion, we can get from .\nAfter that, we insert into , keeping it non-increasing, we will get .By\ncalculating, we will find is always the first element in . So when , we\nhave the following transition: In the above we consider as for all or\n.Because satisfies the condition, by greedy and induction we can show\nthat satisfies the condition.Time complexity: for preprocessing and per\ntest case.Memory complexity: for preprocessing and per test case.\n"
}