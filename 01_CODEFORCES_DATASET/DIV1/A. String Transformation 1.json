{
    "link": "https://codeforces.com//contest/1383/problem/A",
    "problemId": "681327",
    "problem_idx": "A",
    "shortId": "1383A",
    "contest_number": "1383",
    "problem_submissions": {
        "F": [
            87911622,
            87901413,
            87908295,
            87909079,
            87912863,
            87912844,
            87913228,
            87920937
        ],
        "C": [
            87903412,
            87908609,
            87920945,
            87921225,
            87936073,
            87936017,
            87923661,
            87919633,
            87920208,
            87928476,
            88561363,
            87907584
        ],
        "D": [
            87893217,
            87920512,
            87917720,
            87900472,
            88564499,
            87905800,
            87942673,
            87934937,
            87934603,
            87934354,
            87926585,
            87907511,
            87916069,
            87908438,
            87914997,
            87918050,
            87919666,
            87904890,
            87912187,
            87897729,
            87922544,
            87918917
        ],
        "E": [
            87883167,
            87893057,
            87896267,
            87890928,
            88564562,
            87897262,
            87898365,
            87901088,
            87901845,
            87906849,
            87898532,
            87900480,
            87902921,
            87905469,
            87912176,
            87897358,
            87922285,
            87909673,
            87899729,
            87921664
        ],
        "B": [
            87873092,
            87873731,
            87878338,
            87871770,
            88564467,
            87883802,
            87879305,
            87891950,
            87885163,
            87888568,
            87878119,
            87882001,
            87878631,
            87875818,
            87883310,
            87903746,
            87887725,
            87881741,
            87892008,
            87886946
        ],
        "A": [
            87871300,
            87878540,
            87872599,
            87873455,
            88564441,
            87872862,
            87887205,
            87872116,
            87872818,
            87877345,
            87871429,
            87873700,
            87872797,
            87871844,
            87872683,
            87874942,
            87874295,
            87872122,
            87878303,
            87875696
        ]
    },
    "name": "A. String Transformation 1",
    "statement": "Koa the Koala has two strings A and B of the same length n (|A|=|B|=n)\r\nconsisting of the first 20 lowercase English alphabet letters (ie. from\r\nto ).In one move Koa: selects some subset of positions p_1, p_2,\r\nldots, p_k (k\r\nge 1; 1\r\nle p_i\r\nle n; p_i\r\nneq p_j if i\r\nneq j) of A such that A_{p_1} = A_{p_2} =\r\nldots = A_{p_k} = x (ie. all letters on this positions are equal to some\r\nletter x). selects a letter y (from the first 20 lowercase letters in\r\nEnglish alphabet) such that y>x (ie. letter y is alphabetically than x).\r\nsets each letter in positions p_1, p_2,\r\nldots, p_k to letter y. More formally: for each i (1\r\nle i\r\nle k) Koa sets A_{p_i} = y. .Koa wants to know the smallest number of\r\nmoves she has to do to make strings equal to each other (A = B) or to\r\ndetermine that there is no way to make them equal. Help her!\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 24.07.2020 17:34:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string a, b;\n    cin >> a >> b;\n    dsu d(26);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] > b[i]) {\n        ans = -1;\n        break;\n      }\n      if (d.unite((int) (a[i] - 'a'), (int) (b[i] - 'a'))) {\n        ++ans;\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "graphs",
        "greedy",
        "sortings",
        "strings",
        "trees",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. String Transformation 1.json",
    "editorial_link": "https://codeforces.com//blog/entry/80562",
    "editorial": "First of all, if there exists some such that there isnât a\r\nsolution.Otherwise, create a graph where every character is a node, and\r\nput a directed edge between node and node if character must be\r\ntransformed into character (ie. from to for all ). We must select a list\r\nwith minimum number of operations such that if there is an edge from\r\nnode to node , then it must exist a subsequence of the operations in the\r\nlist that transforms into .Each weakly connected component can be solved\r\nindependently and the answer for each component is . So total answer is\r\nwhere is the number of weakly connected components in the\r\ngraph.Proof:Each weakly connected component requires at least operations\r\n(because they are connected). Since there are no cycles in the graph a\r\ntopological order exists. Find one and select each pair of consecutive\r\nnodes in this order as the list of operations.Time complexity: per test\r\ncase where denotes size of alphabet\r\n",
    "hint": []
}