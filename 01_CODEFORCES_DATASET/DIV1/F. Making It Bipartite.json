{
    "link": "https://codeforces.com//contest/1630/problem/F",
    "problemId": "1276001",
    "problem_idx": "F",
    "shortId": "1630F",
    "contest_number": "1630",
    "problem_submissions": {
        "E": [
            144224769,
            144215907,
            144221628,
            144228274,
            144219804,
            144218158,
            144225764,
            144238591,
            144210990,
            144217838,
            144226182,
            144224358,
            144225778,
            144221770,
            144226514,
            144222722,
            144227026,
            144226268,
            144232930
        ],
        "F": [
            144210863,
            144246407,
            144239829,
            144237561,
            144242088,
            144244711,
            144244456,
            144246802,
            144259720,
            144255927,
            144333444,
            144255940,
            144608342,
            148502898,
            148434493,
            148432956
        ],
        "D": [
            144197307,
            144203996,
            144209276,
            144205176,
            144207016,
            144204010,
            144211325,
            144216890,
            144199054,
            144199808,
            144201432,
            144206931,
            144201023,
            144209262,
            144204729,
            144211122,
            144210123,
            144205407,
            144205842
        ],
        "C": [
            144191312,
            144195772,
            144199628,
            144200731,
            144196919,
            144198723,
            144205328,
            144206861,
            144191587,
            144193957,
            144195705,
            144198126,
            144190461,
            144203715,
            144198045,
            144205577,
            144200182,
            144197491,
            144198438
        ],
        "B": [
            144182123,
            144182453,
            144193080,
            144189508,
            144185231,
            144186871,
            144189030,
            144188822,
            144178499,
            144179435,
            144183325,
            144180542,
            144180237,
            144181268,
            144190041,
            144176578,
            144186138,
            144190693,
            144189698
        ],
        "A": [
            144175474,
            144175629,
            144182481,
            144180498,
            144176716,
            144180161,
            144180336,
            144179468,
            144172483,
            144171609,
            144171918,
            144172250,
            144173608,
            144173794,
            144181834,
            144190017,
            144177869,
            144180828,
            144177686
        ]
    },
    "name": "F. Making It Bipartite",
    "statement": "You are given an undirected graph of n vertices indexed from 1 to n,\r\nwhere vertex i has a value a_i assigned to it and all values a_i are .\r\nThere is an edge between two vertices u and v if either a_u divides a_v\r\nor a_v divides a_u.Find the minimum number of vertices to remove such\r\nthat the remaining graph is bipartite, when you remove a vertex you\r\nremove all the edges incident to it.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst int INF = (int)1e6;\nstruct Dinic {\n\tstruct Edge {\n\t\tint v, to;\n\t\tint cap;\n\n\t\tEdge() : v(), to(), cap() {}\n\t\tEdge (int _v, int _to, int _cap) : v(_v), to(_to), cap(_cap) {}\n\t};\n\tvector<Edge> ed;\n\tvector<vector<int>> g;\n\tint S, T;\n\tint n;\n\tvector<int> dist;\n\tvector<int> idx;\n\n\tDinic() : ed(), g(), S(), T() {}\n\tDinic(int _n, int _S, int _T) {\n\t\tn = _n;\n\t\tS = _S;\n\t\tT = _T;\n\t\tg.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i].clear();\n\t\ted = vector<Edge>();\n\t}\n\n\tvoid addEdge(int v, int to, int cap) {\n\t\tg[v].push_back((int)ed.size());\n\t\ted.push_back(Edge(v, to, cap));\n\t\tg[to].push_back((int)ed.size());\n\t\ted.push_back(Edge(to, v, 0));\n\t}\n\n\tbool BFS() {\n\t\tdist.resize(n);\n\t\tvector<int> q;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tdist[i] = n;\n\t\tq.push_back(S);\n\t\tdist[S] = 0;\n\t\tfor (int i = 0; i < (int)q.size(); i++) {\n\t\t\tint v = q[i];\n\t\t\tfor (int id : g[v]) {\n\t\t\t\tEdge e = ed[id];\n\t\t\t\tif (e.cap <= 0) continue;\n\t\t\t\tint u = e.to;\n\t\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\tq.push_back(u);\n\t\t\t}\n\t\t}\n\t\treturn dist[T] < n;\n\t}\n\n\tll dfs(int v, int flow) {\n\t\tif (v == T || flow == 0) return flow;\n\t\tint res = 0;\n\t\tfor (int &i = idx[v]; i < (int)g[v].size(); i++) {\n\t\t\tint id = g[v][i];\n\t\t\tEdge e = ed[id];\n\t\t\tint to = e.to;\n\t\t\tif (dist[to] != dist[v] + 1) continue;\n\t\t\tll df = dfs(to, min(flow, e.cap));\n\t\t\tflow -= df;\n\t\t\tres += df;\n\t\t\ted[id].cap -= df;\n\t\t\ted[id ^ 1].cap += df;\n\t\t\tif (flow == 0) return res;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint Flow() {\n\t\tidx.resize(n);\n\t\tint res = 0;\n\t\twhile(BFS()) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tidx[i] = 0;\n\t\t\tres += dfs(S, INF);\n\t\t}\n\t\treturn res;\n\t}\n} G;\n\nconst int N = 50500;\nint id[N];\nvector<int> d[N];\nint s, t, n;\nint a[N];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tid[a[i]] = i;\n\t}\n\ts = 4 * n;\n\tt = s + 1;\n\tG = Dinic(4 * n + 2, s, t);\n\tfor (int i = 0; i < n; i++) {\n\t\tG.addEdge(s, 4 * i, 1);\n\t\tG.addEdge(4 * i + 1, 4 * i + 2, 1);\n\t\tG.addEdge(4 * i + 3, t, 1);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int x : d[a[i]]) {\n\t\t\tint v = id[x];\n\t\t\tif (v == -1) continue;\n\t\t\tG.addEdge(4 * i, 4 * v + 1, 1);\n\t\t\tG.addEdge(4 * i + 2, 4 * v + 3, 1);\n\t\t}\n\tint ans = G.Flow();\n\tfor (int i = 0; i < n; i++)\n\t\tid[a[i]] = -1;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int i = 0; i < N; i++)\n\t\tid[i] = -1;\n\tfor (int x = 1; x < N; x++)\n\t\tfor (int y = 2 * x; y < N; y += x)\n\t\t\td[y].push_back(x);\n\n\tint z;\n\tscanf(\"%d\", &z);\n\twhile(z--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graph matchings",
        "graphs",
        "number theory"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Making It Bipartite.json",
    "editorial_link": "https://codeforces.com//blog/entry/99384",
    "editorial": "SolutionFirst of all, letâs analyze what happens when there are vertices\r\n, and such that , and , if this happens then the graph cannot be\r\nbipartite because there would be a cycle of size , therefore there\r\ncannot be such a triple (, , ), this condition, besides to being\r\nnecessary, is sufficient since we can separate the graph into two sets,\r\nset : vertices that have edges towards multiples, set : vertices that\r\nhave edges towards divisors, keep in mind that a vertex cannot exist in\r\ntwo sets at the same time if the condition is fulfilled, now note that\r\nthere are no edges between elements of the same set because if this\r\nhappens it would mean that they belong to different sets and it would be\r\na contradiction, then the problem is to find the minimum number of\r\nvertices to remove such that in the remaining vertices there is no such\r\ntriple of numbers (, , ). Now instead of minimizing the number of\r\nvertices to remove, letâs try to maximize the number of vertices that\r\nwill remain in the graph.Let us define the directed graph as the graph\r\nformed by vertices, and directed edges (, ) such that , now the problem\r\nis reduced to finding the maximum number of vertices such that in the\r\ngraph formed among them, no vertex has ingoing edges and outgoing edges\r\nat the same time, formally for each vertex the following property must\r\nbe kept or , in this way we guarantee that there is no triple (, , )\r\nsuch that , and .Now letâs define the graph as a copy of the graph .\r\nFormally for each directed edge (, ) in the graph there is an directed\r\nedge (, ) in the graph . On the other hand, letâs define the graph and\r\nwe will also add new directed edges (, ), this graph is a , it is easy\r\nto see that the edges always go from a vertex to a vertex only if ,\r\nexcept for the edges (, ), which in this case , these edges are the ones\r\nthat connect to , but since they always go in one direction pointing\r\ntowards , the property of is still fulfilled.Now the only thing we have\r\nto do is find the largest antichain in the graph , this can be done\r\nusing the Dilworthâs Theorem, modeling the problem as a bipartite\r\nmatching, we can use some flow algorithm such as Dinicâs Algorithm, or\r\nHopcroft Karpâs Algorithm, which is specific to find the maximum\r\nbipartite matching.Proof:First of all we realize that the graph is a\r\nspecial graph since if there is an indirect path from a vertex to a\r\nvertex then there is always a direct edge between them, this is true\r\nbecause if we have vertices , and such that and then always . With this\r\nwe can say that two elements are not reachable with each other if and\r\nonly if there are no edges between them. Now letâs say that all the\r\nvertices in the graph are white and all the vertices in the graph are\r\nblack, let us denote a function such that , where the vertex from the\r\ngraph is the projection of the vertex from the graph . Now letâs divide\r\nthe proof into two parts.First part:Lemma 1: Every antichain of can be\r\ntransformed into a valid set of vertices such that they form a bipartite\r\ngraph.Proof of Lemma 1: Letâs divide the antichain of into two sets,\r\nwhite vertices and black vertices, Let us define the set of white\r\nvertices as and the set of all black vertices as , now we will create a\r\nset = { | }. It is easy to see that no element in belongs to since if\r\nthis happens it would mean that there is an element such that belongs to\r\nand belongs to and by the concept of antichain that would not be\r\npossible. It is also easy to see that the elements of the set are an\r\nantichain since the set is a projection of vertices from the set of the\r\ngraph on . Now we have that there are no edges between the vertices of\r\nthe set and there are no edges between the vertices of the set , with\r\nthis it is proved that the graph is bipartite.Second part:Lemma 2: Every\r\nvalid set of vertices such that they form a bipartite graph can be\r\ntransformed into an antichain of .Proof of Lemma 2: Let us denote a\r\nfunction such that , where vertex from graph is the projection of vertex\r\nfrom graph . Let us denote the set as all vertices that have greater\r\nthan and to all vertices that have greater than , now we will create a\r\nset = { | }, It is easy to see that set is an antichain since if one\r\nvertex has an edge to another vertex then some of them would have\r\ngreater than and would contradict the definition of set , we can also\r\nsee that the elements in set are an antichain since all the elements\r\nhave so no vertex point towards any other vertex, with this we can\r\ndefine that all the elements in are an antichain since they are a\r\nprojection of vertices of the set from the graph on , Now we want to\r\nproof that the union of set and is an antichain, this is very simple to\r\nsee since the vertices of set belong to and the vertices of belong to ,\r\ntherefore there is no edge from any vertex in to a vertex in since there\r\nare no edges from to . Now it only remains to proof that from set no\r\nvertex of set can be reached, this is proved taking into account that\r\nthe vertices reachable from the set in the graph are the same that the\r\nvertices reachable from the set in the graph , and as no vertex of has\r\nedges towards , this cannot happen. Therefore the union of the sets and\r\nis an antichain of .Then we can say that the two problems are equivalent\r\nand it is shown that finding the maximum antichain we obtain the largest\r\nbipartite graph.The graph contains vertices and around edges (since the\r\nnumbers are different and the sum of the divisors from to is around ).\r\nThe graph is a duplicate of then we would have edges and vertices, if we\r\nuse the Hopcroft Karp algorithm we would obtain a time complexity of and\r\na space complexity of . Code\r\n",
    "hint": [
        "Hint 1 Think about the directed graph where there is an directed edge from to if and only if",
        "Hint 2 Let us define the above graph as , make a duplicate graph from , and then add directed edges for each node of the graph . What happens in this graph?",
        "Hint 3 Maximum Antichain"
    ]
}