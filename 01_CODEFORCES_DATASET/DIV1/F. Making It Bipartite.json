{"link": "https://codeforces.com//contest/1630/problem/F", "problemId": "1276001", "problem_idx": "F", "shortId": "1630F", "contest_number": "1630", "problem_submissions": {"E": [144224769, 144215907, 144221628, 144228274, 144219804, 144218158, 144225764, 144238591, 144210990, 144217838, 144226182, 144224358, 144225778, 144221770, 144226514, 144222722, 144227026, 144226268, 144232930], "F": [144210863, 144246407, 144239829, 144237561, 144242088, 144244711, 144244456, 144246802, 144259720, 144255927, 144333444, 144255940, 144608342, 148502898, 148434493, 148432956], "D": [144197307, 144203996, 144209276, 144205176, 144207016, 144204010, 144211325, 144216890, 144199054, 144199808, 144201432, 144206931, 144201023, 144209262, 144204729, 144211122, 144210123, 144205407, 144205842], "C": [144191312, 144195772, 144199628, 144200731, 144196919, 144198723, 144205328, 144206861, 144191587, 144193957, 144195705, 144198126, 144190461, 144203715, 144198045, 144205577, 144200182, 144197491, 144198438], "B": [144182123, 144182453, 144193080, 144189508, 144185231, 144186871, 144189030, 144188822, 144178499, 144179435, 144183325, 144180542, 144180237, 144181268, 144190041, 144176578, 144186138, 144190693, 144189698], "A": [144175474, 144175629, 144182481, 144180498, 144176716, 144180161, 144180336, 144179468, 144172483, 144171609, 144171918, 144172250, 144173608, 144173794, 144181834, 144190017, 144177869, 144180828, 144177686]}, "name": "F. Making It Bipartite", "statement": "You are given an undirected graph of n vertices indexed from 1 to n,\r\nwhere vertex i has a value a_i assigned to it and all values a_i are .\r\nThere is an edge between two vertices u and v if either a_u divides a_v\r\nor a_v divides a_u.Find the minimum number of vertices to remove such\r\nthat the remaining graph is bipartite, when you remove a vertex you\r\nremove all the edges incident to it.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst int INF = (int)1e6;\nstruct Dinic {\n\tstruct Edge {\n\t\tint v, to;\n\t\tint cap;\n\n\t\tEdge() : v(), to(), cap() {}\n\t\tEdge (int _v, int _to, int _cap) : v(_v), to(_to), cap(_cap) {}\n\t};\n\tvector<Edge> ed;\n\tvector<vector<int>> g;\n\tint S, T;\n\tint n;\n\tvector<int> dist;\n\tvector<int> idx;\n\n\tDinic() : ed(), g(), S(), T() {}\n\tDinic(int _n, int _S, int _T) {\n\t\tn = _n;\n\t\tS = _S;\n\t\tT = _T;\n\t\tg.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i].clear();\n\t\ted = vector<Edge>();\n\t}\n\n\tvoid addEdge(int v, int to, int cap) {\n\t\tg[v].push_back((int)ed.size());\n\t\ted.push_back(Edge(v, to, cap));\n\t\tg[to].push_back((int)ed.size());\n\t\ted.push_back(Edge(to, v, 0));\n\t}\n\n\tbool BFS() {\n\t\tdist.resize(n);\n\t\tvector<int> q;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tdist[i] = n;\n\t\tq.push_back(S);\n\t\tdist[S] = 0;\n\t\tfor (int i = 0; i < (int)q.size(); i++) {\n\t\t\tint v = q[i];\n\t\t\tfor (int id : g[v]) {\n\t\t\t\tEdge e = ed[id];\n\t\t\t\tif (e.cap <= 0) continue;\n\t\t\t\tint u = e.to;\n\t\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\tq.push_back(u);\n\t\t\t}\n\t\t}\n\t\treturn dist[T] < n;\n\t}\n\n\tll dfs(int v, int flow) {\n\t\tif (v == T || flow == 0) return flow;\n\t\tint res = 0;\n\t\tfor (int &i = idx[v]; i < (int)g[v].size(); i++) {\n\t\t\tint id = g[v][i];\n\t\t\tEdge e = ed[id];\n\t\t\tint to = e.to;\n\t\t\tif (dist[to] != dist[v] + 1) continue;\n\t\t\tll df = dfs(to, min(flow, e.cap));\n\t\t\tflow -= df;\n\t\t\tres += df;\n\t\t\ted[id].cap -= df;\n\t\t\ted[id ^ 1].cap += df;\n\t\t\tif (flow == 0) return res;\n\t\t}\n\t\treturn res;\n\t}\n\n\tint Flow() {\n\t\tidx.resize(n);\n\t\tint res = 0;\n\t\twhile(BFS()) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tidx[i] = 0;\n\t\t\tres += dfs(S, INF);\n\t\t}\n\t\treturn res;\n\t}\n} G;\n\nconst int N = 50500;\nint id[N];\nvector<int> d[N];\nint s, t, n;\nint a[N];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tid[a[i]] = i;\n\t}\n\ts = 4 * n;\n\tt = s + 1;\n\tG = Dinic(4 * n + 2, s, t);\n\tfor (int i = 0; i < n; i++) {\n\t\tG.addEdge(s, 4 * i, 1);\n\t\tG.addEdge(4 * i + 1, 4 * i + 2, 1);\n\t\tG.addEdge(4 * i + 3, t, 1);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int x : d[a[i]]) {\n\t\t\tint v = id[x];\n\t\t\tif (v == -1) continue;\n\t\t\tG.addEdge(4 * i, 4 * v + 1, 1);\n\t\t\tG.addEdge(4 * i + 2, 4 * v + 3, 1);\n\t\t}\n\tint ans = G.Flow();\n\tfor (int i = 0; i < n; i++)\n\t\tid[a[i]] = -1;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tfor (int i = 0; i < N; i++)\n\t\tid[i] = -1;\n\tfor (int x = 1; x < N; x++)\n\t\tfor (int y = 2 * x; y < N; y += x)\n\t\t\td[y].push_back(x);\n\n\tint z;\n\tscanf(\"%d\", &z);\n\twhile(z--) solve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graph matchings", "graphs", "number theory"], "dificulty": "3400", "interactive": false}