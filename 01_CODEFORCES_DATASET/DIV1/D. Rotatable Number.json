{"link": "https://codeforces.com//contest/303/problem/D", "problemId": "2986", "problem_idx": "D", "shortId": "303D", "contest_number": "303", "problem_submissions": {"D": [3709553, 3709363, 3711716, 3706959, 3711238, 3710228, 3710306, 3708941, 3711129, 3709516], "C": [3708423, 3712044, 3708743, 3711908, 3708382, 3713447, 3708443, 3708735, 3709727, 3721641, 3721639, 3708625, 9135696, 3709288, 3710050, 3710908, 3710008], "B": [3707219, 3707849, 3707392, 3708158, 3707654, 3707136, 3707080, 3707477, 3707196, 3707562, 3707548, 3709279, 3718742, 3707141, 3707469, 3706781, 3708750, 3708294], "A": [3706160, 3706280, 3706779, 3706051, 3706066, 3706259, 3706288, 3706277, 3707619, 3706249, 3706193, 3706655, 3706132, 3706057, 3706549, 3706144, 3707218, 3706263, 3706997]}, "name": "D. Rotatable Number", "statement": "Bike is a smart boy who loves math very much. He invented a number\r\ncalled \"Rotatable Number\" inspired by . As you can see, is a magic\r\nnumber because any of its rotatings can be got by multiplying that\r\nnumber by (numbers from one to number\u2019s length). Rotating a number means\r\nputting its last several digit into first. For example, by rotating\r\nnumber you can obtain any numbers: . It\u2019s worth mentioning that are\r\nallowed. So both and can be obtained by rotating . You can see why\r\nsatisfies the condition. All of the equations are under base . ; ; ; ; ;\r\n. Now, Bike has a problem. He extends \"Rotatable Number\" under any base\r\n. As is mentioned above, is a \"Rotatable Number\" under base . Another\r\nexample is under base 2. All of the equations are under base . ; ; ; .\r\nSo, he wants to find the largest so that there is a \"Rotatable Number\"\r\n(leading-zeroes allowed) of length under base .Note that any time you\r\nmultiply a rotatable number by numbers from 1 to its length you should\r\nget a rotating of that number.\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nvector<int> factors(int x) {\n    vector<int> res;\n    for (int i = 2; i <= x; ++i) {\n        if (x % i == 0) {\n            res.PB(i);\n        }\n        while (x % i == 0) {\n            x /= i;\n        }\n    }\n    return res;\n}\n\nvector<int> f;\n\nint p;\n\nint pot(int a, int b) {\n    int res = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) {\n            res = (res * (LL) a) % p;\n        }\n        a = (a * (LL) a) % p;\n    }\n    return res;\n}\n\nbool check(int x) {\n    if (x < 2 || x > p - 1) {\n        return false;\n    }\n    FORE (it, f) {\n        if (pot(x, (p - 1) / *it) == 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint gcd(int a, int b) {\n    while (a && b) {\n        a > b ? a %= b : b %= a;\n    }\n    return a + b;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n, x;\n    cin >> n >> x;\n    if (x == 2) {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (n == 1) {\n        cout << x - 1 << endl;\n        return 0;\n    }\n    if (factors(n + 1)[0] != n + 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n    p = n + 1;\n    f = factors(n);\n    int g = 1;\n    while (!check(g)) {\n        g = rand() % p;\n    }\n    int res = -1;\n    int c = 1;\n    for (int i = 1; i < p; ++i) {\n        c = (c * (LL) g) % p;\n        if (gcd(p - 1, i) == 1) {\n            if (x > c) {\n                res = max(res, c + ((x - c - 1) / p) * p);\n            }\n        }\n    }\n    cout << res << endl;\n}\n"], "input": "", "output": "", "tags": ["math", "number theory"], "dificulty": "2600", "interactive": false}