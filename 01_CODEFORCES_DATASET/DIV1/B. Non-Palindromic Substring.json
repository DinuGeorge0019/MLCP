{
    "link": "https://codeforces.com//contest/1943/problem/B",
    "problemId": "2535040",
    "problem_idx": "B",
    "shortId": "1943B",
    "contest_number": "1943",
    "problem_submissions": {
        "E2": [
            251755986,
            251774166,
            251721110,
            251772938,
            251976046,
            251850394,
            251783692,
            252482559,
            251768795,
            251806219,
            251801786,
            251784602,
            251808955,
            251786442,
            251790915,
            251791945,
            252167133,
            254017076,
            252396752,
            251948632
        ],
        "E1": [
            251743400,
            251761808,
            251720570,
            251764606,
            251765135,
            251768616,
            251774247,
            251768081,
            251767041,
            251779764,
            251763055,
            251770682,
            251776382,
            251772657,
            253458372,
            251772270,
            251777192,
            251779122,
            251781255
        ],
        "D2": [
            251730537,
            251743841,
            251769783,
            251827860,
            251827638,
            251812685,
            251750876,
            251749250,
            251743677,
            251754133,
            251758370,
            251752785,
            251846892,
            251763163,
            251753145,
            251743858,
            251746564,
            251754334,
            251790796,
            253458316,
            251757628,
            251757687,
            251759092,
            251761488
        ],
        "D1": [
            251727886,
            251730644,
            251753185,
            251730641,
            251733326,
            251727921,
            251742335,
            251739558,
            251743910,
            251737861,
            251737457,
            251736749,
            251746112,
            251745451,
            251785836,
            252959932,
            251749532,
            251743349,
            251754372,
            251751101
        ],
        "C": [
            251715534,
            251721073,
            251747865,
            251720444,
            251722988,
            251756982,
            251730923,
            251730217,
            251735041,
            251727939,
            251724586,
            251722879,
            251721249,
            251735499,
            251732028,
            252959913,
            251731321,
            251736408,
            251741233,
            251741283
        ],
        "B": [
            251709195,
            251712754,
            251737904,
            251712353,
            251714193,
            252482757,
            251715199,
            251720530,
            251721280,
            251721320,
            251719084,
            251718139,
            251714047,
            251713923,
            251720644,
            251719922,
            252531274,
            251717454,
            251716526,
            251722194,
            252064777,
            251726935
        ],
        "A": [
            251701793,
            251702717,
            251723885,
            251701730,
            251702780,
            251702880,
            251702623,
            251701902,
            251707932,
            251702391,
            251707705,
            251702309,
            251701731,
            251703701,
            251706521,
            252531268,
            251732626,
            251703091,
            251704741,
            251703882
        ],
        "F": [
            251801182,
            252436931,
            251845260,
            251783880
        ]
    },
    "name": "B. Non-Palindromic Substring",
    "statement": "A string t is said to be k-good if there exists at least one substring^\r\ndagger of length k which is not a palindrome^\r\nddagger. Let f(t) denote the sum of all values of k such that the string\r\nt is k-good.You are given a string s of length n. You will have to\r\nanswer q of the following queries: Given l and r (l < r), find the value\r\nof f(s_ls_{l + 1}\r\nldots s_r). ^\r\ndagger A substring of a string z is a contiguous segment of characters\r\nfrom z. For example, \"\r\nmathtt{defor}\", \"\r\nmathtt{code}\" and \"\r\nmathtt{o}\" are all substrings of \"\r\nmathtt{codeforces}\" while \"\r\nmathtt{codes}\" and \"\r\nmathtt{aaa}\" are not.^\r\nddagger A palindrome is a string that reads the same backwards as\r\nforwards. For example, the strings \"\r\ntexttt{z}\", \"\r\ntexttt{aa}\" and \"\r\ntexttt{tacocat}\" are palindromes while \"\r\ntexttt{codeforces}\" and \"\r\ntexttt{ab}\" are not.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.03.2024 10:38:04\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> manacher(int n, const T &s) {\n  if (n == 0) {\n    return vector<int>();\n  }\n  vector<int> res(2 * n - 1, 0);\n  int l = -1, r = -1;\n  for (int z = 0; z < 2 * n - 1; z++) {\n    int i = (z + 1) >> 1;\n    int j = z >> 1;\n    int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));\n    while (j + p + 1 < n && i - p - 1 >= 0) {\n      if (!(s[j + p + 1] == s[i - p - 1])) {\n        break;\n      }\n      p++;\n    }\n    if (j + p > r) {\n      l = i - p;\n      r = j + p;\n    }\n    res[z] = p;\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<int> manacher(const T &s) {\n  return manacher((int) s.size(), s);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, q;\n    cin >> n >> q;\n    string s;\n    cin >> s;\n    vector<int> p1(n + 2);\n    vector<int> p2(n + 2);\n    for (int i = n + 1; i >= 0; i--) {\n      if (i >= n) {\n        p1[i] = p2[i] = i;\n      } else {\n        if (i + 1 < n && s[i] != s[i + 1]) {\n          p1[i] = i;\n        } else {\n          p1[i] = p1[i + 1];\n        }\n        if (i + 2 < n && s[i] != s[i + 2]) {\n          p2[i] = i;\n        } else {\n          p2[i] = p2[i + 1];\n        }\n      }\n    }\n    auto pal = manacher(s);\n    while (q--) {\n      int l, r;\n      cin >> l >> r;\n      --l; --r;\n      int64_t len = r - l + 1;\n      if (p1[l] >= r) {\n        cout << 0 << '\\n';\n        continue;\n      }\n      if (p2[l] >= r - 1) {\n        int64_t k = len / 2;\n        cout << k * (k + 1) << '\\n';\n        continue;\n      }\n      auto ans = len * (len + 1) / 2 - 1;\n      if (pal[l + r] >= len / 2) {\n        ans -= len;\n      }\n      cout << ans << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "implementation",
        "math",
        "strings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Non-Palindromic Substring.json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "We first try to find the answer for a stringLet , -> I and -> II\nare both palindromes.Then (due to I) (due to II) (due to I) (due to\nII)and so on.... you can see that it forces . A similiar reasoning gives\nyou .Further, if is even, and have different parities, but implies that\nall characters must be equal actually.We mentioned that the edge cases\nare and , but why exactly? How does the analysis fail for them?(Left as\na exercise)So, the condition for a string to be -good can be written as\nfollows : : never possible, odd : not an alternating string, even : not\nall characters same : non-palindromic stringNow onto substring queries.\nThe second and third things are easy to handle, you can store the next\nposition where and respectively. Checking if a substring is a palindrome\nis standard with various methods such as string hashing or manacher\u00e2\u0080\u0099s\nalgorithm.\n"
}