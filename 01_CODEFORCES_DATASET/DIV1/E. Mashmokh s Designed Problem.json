{
    "link": "https://codeforces.com//contest/414/problem/E",
    "problemId": "7960",
    "problem_idx": "E",
    "shortId": "414E",
    "contest_number": "414",
    "problem_submissions": {
        "D": [
            6280858,
            6280337,
            6280214,
            6277452,
            6281468,
            6278870,
            6280873,
            6276141,
            6280994,
            6282343,
            6281729,
            6278507,
            6283035,
            6279945,
            6282736,
            6282676,
            6281489
        ],
        "C": [
            6277588,
            6279411,
            6276895,
            6277328,
            6280737,
            6277280,
            6281276,
            6277935,
            6281181,
            6277366,
            6279038,
            6277230,
            6283028,
            6279514,
            6282968,
            6280049,
            6278467,
            6279593
        ],
        "B": [
            6274271,
            6272525,
            6274152,
            6274024,
            6273769,
            6273466,
            6273735,
            6274465,
            6277446,
            6272443,
            6274075,
            6274094,
            6274028,
            6273244,
            6273032,
            6273491,
            6273690,
            6273419
        ],
        "A": [
            6272689,
            6271872,
            6273297,
            6273349,
            6273033,
            6272772,
            6272076,
            6273686,
            6278378,
            6271786,
            6272244,
            6273646,
            6273040,
            6272099,
            6272030,
            6272106,
            6272639,
            6272717
        ],
        "E": [
            6287011,
            6619052
        ]
    },
    "name": "E. Mashmokh s Designed Problem",
    "statement": "After a lot of trying, Mashmokh designed a problem and it’s your job to\r\nsolve it.You have a tree with vertices. Each vertex has a unique index\r\nfrom 1 to . The root of has index . For each vertex of this tree , you\r\nare given a list of its children in a specific order. You must perform\r\nthree types of query on this tree: find distance (the number of edges in\r\nthe shortest path) between and ; given and , disconnect from its father\r\nand connect it to its -th ancestor; more formally, let’s denote the path\r\nfrom to the root by , so that and is root; disconnect from its father ()\r\nand connect it to ; vertex must be added to the end of the child-list of\r\nvertex ; in the vertex sequence produced by calling function dfs(root)\r\nfind the latest vertex that has distance from the root. The pseudo-code\r\nof function dfs(v): // ls[v]: list of children of vertex v // its i-th\r\nelement is ls[v][i]// its size is size(ls[v])sequence result = empty\r\nsequence;void dfs(vertex now){ add now to end of result; for(int i = 1;\r\ni <= size(ls[v]); i = i + 1) //loop from i = 1 to i = size(ls[v])\r\ndfs(ls[v][i]);}\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(s) int((s).size())\n#define len(s) int((s).size())\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n#if _WIN32 || __WIN32__\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n#define next _next\n#define prev _prev\n#define rank _rank\n#define hash _hash\n#define y0 yy0\n#define y1 yy1\n#define link _link\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef unsigned long long ullong;\ntypedef unsigned long long lint;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(double(1));\nconst int N = int(1e5) + 100;\n\nstruct node {\n\t\n\tint ver, val, minVal, maxVal, add;\n\tint h, sz, p, l, r;\n\t\n\tnode() {\n\t\tminVal = inf;\n\t\tmaxVal = -inf;\n\t\tsz = 0;\n\t}\n\t\n\tnode(int ver, int val) {\n\t\tthis->ver = ver;\n\t\tthis->val = minVal = maxVal = val;\n\t\tadd = 0;\n\t\th = (rand() << 16) | rand();\n\t\tsz = 1;\n\t\tp = l = r = 0;\n\t}\n\t\n};\n\nint sz, root;\nint first[N], last[N];\nvi sons[N];\nnode d[5 * N];\n\ninline void push(int v) {\n\tif (v == 0 || d[v].add == 0) {\n\t\treturn;\n\t}\n\td[v].val += d[v].add;\n\td[v].minVal += d[v].add;\n\td[v].maxVal += d[v].add;\n\tif (d[v].l > 0) {\n\t\td[d[v].l].add += d[v].add;\n\t}\n\tif (d[v].r > 0) {\n\t\td[d[v].r].add += d[v].add;\n\t}\n\td[v].add = 0;\n}\t\n\ninline void calc(int v) {\n\tpush(v);\n\tpush(d[v].l);\n\tpush(d[v].r);\n\td[v].sz = d[d[v].l].sz + d[d[v].r].sz + 1;\n\td[v].minVal = min(d[v].val, min(d[d[v].l].minVal, d[d[v].r].minVal));\n\td[v].maxVal = max(d[v].val, max(d[d[v].l].maxVal, d[d[v].r].maxVal));\n\td[v].p = 0;\n\tif (d[v].l > 0) {\n\t\td[d[v].l].p = v;\n\t}\n\tif (d[v].r > 0) {\n\t\td[d[v].r].p = v;\n\t}\n}\n\nint merge(int l, int r) {\n\tpush(l);\n\tpush(r);\n\tif (l == 0) {\n\t\treturn r;\n\t}\n\tif (r == 0) {\n\t\treturn l;\n\t}\n\tint res;\n\tif (d[l].h > d[r].h) {\n\t\td[l].r = merge(d[l].r, r);\n\t\tres = l;\n\t}\n\telse {\n\t\td[r].l = merge(l, d[r].l);\n\t\tres = r;\n\t}\n\tcalc(res);\n\treturn res;\n}\n\nvoid dfs(int v, int ch = 0) {\n\td[++sz] = node(v, ch);\n\troot = merge(root, sz);\n\tfirst[v] = sz;\n\tfor (int i = 0; i < sz(sons[v]); ++i) {\n\t\tdfs(sons[v][i], ch + 1);\n\t\td[++sz] = node(v, ch);\n\t\troot = merge(root, sz);\n\t}\n\td[++sz] = node(v, ch);\n\troot = merge(root, sz);\n\tlast[v] = sz;\n}\n\ninline int getNum(int v) {\n\tint res = d[d[v].l].sz + 1;\n\twhile (d[v].p > 0) {\n\t\tint pv = d[v].p;\n\t\tif (d[pv].r == v) {\n\t\t\tres += d[d[pv].l].sz + 1;\n\t\t}\n\t\tv = pv;\n\t}\n\treturn res;\n}\n\ninline int getPos(int v) {\n\treturn getNum(first[v]);\n}\n\ninline int getVal(int v, int num) {\n\tpush(v);\n\tif (d[d[v].l].sz + 1 == num) {\n\t\treturn d[v].val;\n\t}\n\tif (d[d[v].l].sz + 1 > num) {\n\t\treturn getVal(d[v].l, num);\n\t}\n\telse {\n\t\treturn getVal(d[v].r, num - d[d[v].l].sz - 1);\n\t}\n}\n\ninline int getVal(int v) {\n\treturn getVal(root, getNum(first[v]));\n}\n\nvoid splitSize(int v, int sz, int &l, int &r) {\n\tpush(v);\n\tif (v == 0) {\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\tif (d[d[v].l].sz + 1 <= sz) {\n\t\tsplitSize(d[v].r, sz - d[d[v].l].sz - 1, d[v].r, r);\n\t\tl = v;\n\t}\n\telse {\n\t\tsplitSize(d[v].l, sz, l, d[v].l);\n\t\tr = v;\n\t}\n\tcalc(v);\n}\n\ninline int getDist(int v, int u) {\n\tint l = getPos(v), r = getPos(u);\n\tif (l > r) {\n\t\tswap(l, r);\n\t}\n\tint p1, p2, p3;\n\tsplitSize(root, r, p1, p3);\n\tsplitSize(p1, l - 1, p1, p2);\n\tint res = d[p2].minVal;\n\troot = merge(p1, merge(p2, p3));\n\treturn getVal(v) + getVal(u) - 2 * res;\n}\n\ninline int findKth(int v, int k) {\n\tpush(v);\n\tif (v == 0) {\n\t\treturn -1;\n\t}\n\tif (d[v].val == k) {\n\t\tint res = findKth(d[v].r, k);\n\t\tif (res == -1) {\n\t\t\tres = d[v].ver;\n\t\t}\n\t\treturn res;\n\t}\n\tpush(d[v].r);\n\tif (d[v].r > 0 && d[d[v].r].minVal <= k && d[d[v].r].maxVal >= k) {\n\t\treturn findKth(d[v].r, k);\n\t}\n\treturn findKth(d[v].l, k);\n}\n\nvoid write(int v) {\n\tpush(v);\n\tif (v == 0) {\n\t\treturn;\n\t}\n\twrite(d[v].l);\n\tcerr << \"(\" << d[v].ver << \", \" << d[v].val << \") \";\n\twrite(d[v].r);\n}\n\ninline void move(int v, int k) {\n\tint h = getVal(v);\n\tint p1, p2, p3;\n\tsplitSize(root, getPos(v) - 1, p1, p2);\n\tint pv = findKth(p1, h - k);\n\tsplitSize(p2, getNum(last[v]), p2, p3);\n\td[p2].add -= (k - 1);\n\tpush(p2);\n\troot = merge(p1, p3);\n\tsplitSize(root, getNum(last[pv]) - 1, p1, p3);\n\td[++sz] = node(pv, h - k);\n\tp2 = merge(p2, sz);\n\troot = merge(p1, merge(p2, p3));\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint sz;\n\t\tscanf(\"%d\", &sz);\n\t\tfor (int j = 0; j < sz; ++j) {\n\t\t\tint cur;\n\t\t\tscanf(\"%d\", &cur);\n\t\t\t--cur;\n\t\t\tsons[i].pb(cur);\n\t\t}\n\t}\n\tsz = root = 0;\n\tdfs(0);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint v, u;\n\t\t\tscanf(\"%d %d\", &v, &u);\n\t\t\t--v;\n\t\t\t--u;\n\t\t\tprintf(\"%d\\n\", getDist(v, u));\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == 2) {\n\t\t\tint v, h;\n\t\t\tscanf(\"%d %d\", &v, &h);\n\t\t\t--v;\n\t\t\tmove(v, h);\n\t\t\tcontinue;\n\t\t}\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tprintf(\"%d\\n\", findKth(root, k) + 1);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Mashmokh s Designed Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/11470",
    "editorial": "Letâs define the dfs-order of a tree as the sequence created by calling\r\nfunction dfs(root). Weâll build another sequence from a dfs-order by\r\nreplacing each vertex in dfs-order by â+1â and inserting a â-1â after\r\nthe last vertex of its subtree. Note that all vertices of a particular\r\nsubtree are a continuous part of dfs-order of that tree. Also note that\r\nfor each vertex if the +1 corresponding to it is the -th element of\r\nsequence, then âs distance from root(which weâll denote by height of )\r\nis equal to sum of elements . Suppose we can perform the following\r\noperations on such sequence: For each , find sum of the elements . For\r\neach find the biggest so that sum of elements of the sequence equals .\r\nUsing these two operations we can find LCA of two vertices and , so\r\nsince distance of and equals to we can answer the second query. Also the\r\nthird query can be answered using the second operation described above.\r\nAs for the first query it cuts a continuous part of sequence and insert\r\nit in another place. This operation can be done using implicit treap.\r\nAlso we can use the treap as a segment tree to store the following\r\nvalues for each vertex . Then using these values the operations\r\ndescribed above can be done. All of these operation can be done in . Sum\r\nof the elements in its subtree(each vertex in the treap has a value\r\nequal to +1 or -1 since it corresponds to an element of the sequence.)\r\nLetâs write the values of each vertex in the subtree of in the order\r\nthey appear in the sequence. Then lets denote sum of the first numbers\r\nwe wrote as and call elements of ps, prefix sums of the subtree of .\r\nThen we store the maximum number amongst the prefix sums. Also weâll\r\nstore the minimum number amongst prefix sums.\r\n",
    "hint": []
}