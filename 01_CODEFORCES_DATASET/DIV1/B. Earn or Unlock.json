{
    "link": "https://codeforces.com//contest/1854/problem/B",
    "problemId": "2119349",
    "problem_idx": "B",
    "shortId": "1854B",
    "contest_number": "1854",
    "problem_submissions": {
        "F": [
            216373971,
            217354172,
            217397292
        ],
        "D": [
            216310150,
            216289199,
            216321960,
            216339370,
            216308614,
            216330486,
            216327260,
            216330943,
            216339614,
            216349670,
            216345647,
            216345106,
            224815766,
            216547574,
            216366587
        ],
        "E": [
            216288237,
            216300028,
            216302036,
            216268441,
            216334493,
            216313354,
            216348664,
            216267007,
            216336955,
            216296297,
            216300153,
            216312130,
            216307051,
            216317337,
            216275749,
            216320776,
            216324267,
            216319909,
            216313856
        ],
        "C": [
            216273942,
            216261365,
            216266654,
            216275371,
            216264423,
            216276518,
            216281959,
            216283401,
            216256269,
            216270575,
            216274010,
            216274561,
            216269163,
            216301579,
            216282188,
            216295268,
            216271804,
            216301995
        ],
        "A2": [
            216264333,
            216379126,
            216379111,
            216318393,
            216275667,
            216295850,
            216251357,
            216257398,
            216276514,
            216268588,
            216307226,
            216280080,
            216286828,
            216278270,
            216337810,
            216308708,
            216280874,
            216295056,
            216275828
        ],
        "A1": [
            216258579,
            216252405,
            216255683,
            216241030,
            216251535,
            216248642,
            216276758,
            216268768,
            216282006,
            216259868,
            216249337,
            216287041,
            216244661,
            216249684,
            216243548,
            216258618,
            216238489,
            216275974
        ],
        "B": [
            216248516,
            216256912,
            216241500,
            216256089,
            216258617,
            216267337,
            216293058,
            216272552,
            216268356,
            216253180,
            216258044,
            216262545,
            216263544,
            216287092,
            216255748,
            216251265,
            216280599,
            216287965
        ]
    },
    "name": "B. Earn or Unlock",
    "statement": "Andrea is playing the game . He has a deck of n cards with values a_1,\r\nldots, a_n from top to bottom. Each card can be either locked or\r\nunlocked. Initially, only the topmost card is unlocked. The game\r\nproceeds in turns. In each turn, Andrea chooses an unlocked card in the\r\ndeck the value written on the card is v and performs exactly one of the\r\nfollowing two operations: Unlock the first v cards in the deck from the\r\ntop. If there are less than v locked cards in the deck, then unlock all\r\nthe locked cards. Earn v . In both cases, after performing the\r\noperation, he removes the card from the deck.The game ends when all the\r\ncards remaining in the deck are locked, or there are no more cards in\r\nthe deck.What is the maximum number of victory points Andrea can earn?\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=200*1007;\nusing bn=bitset<nax>;\n\nint n;\n\nint tab[nax];\nbn dp;\n\nll wyn;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t}\n\tll s=0;\n\tdp[1]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ts+=tab[i];\n\t\tdp=dp>>1;\n\t\tif (dp[0])\n\t\t\twyn=max(wyn, s-i+1);\n\t\tdp=(dp|(dp<<tab[i]));\n\t}\n\tfor (int i=0; i<nax; i++)\n\t{\n\t\tif (dp[i])\n\t\t{\n\t\t\t//~ debug() << i << \" \" << s << \" \" << s-n-i;\n\t\t\twyn=max(wyn, s-n-i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//~ debug() << wyn;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Earn or Unlock.json",
    "editorial_link": "https://codeforces.com//blog/entry/118540",
    "editorial": "First, note that the order of used cards doesn\u00e2\u0080\u0099t matter. If you\nuse at least once a card that is not on the top on the deck, you can\nprove that using the cards in order (from the top) would give the same\nnumber of victory points.Let\u00e2\u0080\u0099s add cards with value at the end of the\ndeck. Then, it\u00e2\u0080\u0099s optimal to unlock cards, and use cards , getting\npoints.Let\u00e2\u0080\u0099s find the reachable . Let be a bitset that stores the\nreachable after using the first cards. Base case: . Transitions: first,\n|= << . If , you can update the answer with , but you can\u00e2\u0080\u0099t unlock any\nother card, so you have to set before transitioning to . Complexity:\n"
}