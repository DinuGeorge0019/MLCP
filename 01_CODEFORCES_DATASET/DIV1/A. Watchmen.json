{
    "link": "https://codeforces.com//contest/650/problem/A",
    "problemId": "50872",
    "problem_idx": "A",
    "shortId": "650A",
    "contest_number": "650",
    "problem_submissions": {
        "E": [
            16578790,
            16577272,
            16578590,
            16579959,
            16637208,
            16582561,
            16619834,
            16591408,
            16757704
        ],
        "D": [
            16571229,
            16573705,
            16576122,
            16578304,
            16576176,
            16577509,
            16577016,
            16576771,
            16578407,
            16577295,
            16573405,
            16578398,
            16577971,
            16579415,
            16579518,
            16578322,
            16579977,
            16579420,
            16579068
        ],
        "B": [
            16567529,
            16566753,
            16570863,
            16566306,
            16567392,
            16570268,
            16568199,
            16568212,
            16566872,
            16566001,
            16578738,
            16567371,
            16573291,
            16569824,
            16567006,
            16572578,
            16570591,
            16567965,
            16566091
        ],
        "C": [
            16565085,
            16569140,
            16568520,
            16573461,
            16571216,
            16572854,
            16571058,
            16570678,
            16571485,
            16571831,
            16567202,
            16572160,
            16568367,
            16566170,
            16572982,
            16567681,
            16567338,
            16571921,
            16572363
        ],
        "A": [
            16562732,
            16562808,
            16562782,
            16562889,
            16563014,
            16563492,
            16563086,
            16563133,
            16562823,
            16562796,
            16575057,
            16563813,
            16563019,
            16567243,
            16562986,
            16569600,
            16562758,
            16562970,
            16562962
        ]
    },
    "name": "A. Watchmen",
    "statement": "Watchmen are in a danger and Doctor Manhattan together with his friend\r\nDaniel Dreiberg should warn them as soon as possible. There are watchmen\r\non a plane, the -th watchman is located at point .They need to arrange a\r\nplan, but there are some difficulties on their way. As you know, Doctor\r\nManhattan considers the distance between watchmen and to be . Daniel, as\r\nan ordinary person, calculates the distance using the formula .The\r\nsuccess of the operation relies on the number of pairs (), such that the\r\ndistance between watchman and watchmen calculated by Doctor Manhattan is\r\nequal to the distance between them calculated by Daniel. You were asked\r\nto compute the number of such pairs.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  map <int, int> xs;\n  map <int, int> ys;\n  map < pair <int, int>, int > zs;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    ans += (xs[x]++);\n    ans += (ys[y]++);\n    ans -= (zs[make_pair(x, y)]++);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "geometry",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Watchmen.json",
    "editorial_link": "https://codeforces.com//blog/entry/43677",
    "editorial": "When Manhattan distance\nequals to Euclidean distance? So it is true only when or . This means\nthat to count the number of such pair we need to calculate number of\npoints on each horizontal line and each vertical line. We can do that\neasily with the use of std::map/TreeMap/HashMap/Dictionary, or just by\nsorting all coordinates. If we have points on one horizontal or vertical\nline they will add pairs to the result. But if we have several points in\none place we will count their pairs twice, so we need to subtract from\nanswer number of pairs of identical points which we can calculate with\nthe same formula and using the same method of finding equal values as\nbefore. If we use TreeMap/sort then solution will run in and if\nunordered_map/HashMap then in .\n"
}