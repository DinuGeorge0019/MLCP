{
    "link": "https://codeforces.com//contest/1641/problem/B",
    "problemId": "1306245",
    "problem_idx": "B",
    "shortId": "1641B",
    "contest_number": "1641",
    "problem_submissions": {
        "D": [
            147518709,
            147518438,
            147518414,
            147427811,
            147454243,
            147448667,
            147443879,
            147448778,
            147461315,
            147449736,
            147438286,
            147472049,
            147446117,
            147443730,
            147449435,
            147452074,
            147451905,
            147452006,
            147454020,
            147456098,
            147454778,
            147430439
        ],
        "F": [
            147463572,
            147488364,
            147487709,
            147487635,
            147487566,
            147487511,
            147487448,
            147487273,
            147474513,
            147473910,
            147473584,
            147541615
        ],
        "E": [
            147445838,
            147446189,
            147454919,
            147456452,
            147460049,
            147450489,
            147462542,
            147543257,
            147542937,
            147453651,
            147456356,
            147459732,
            147462090,
            147455497,
            147527427,
            147590875
        ],
        "B": [
            147438181,
            147420165,
            147422523,
            147421140,
            147420036,
            147420813,
            147426049,
            147460937,
            147441628,
            147446219,
            147424792,
            147434886,
            147431843,
            147422293,
            147424883,
            147440401
        ],
        "C": [
            147435041,
            147431185,
            147429914,
            147434109,
            147426743,
            147452293,
            147436064,
            147458110,
            147432571,
            147432541,
            147431796,
            147432454,
            147435151,
            147433502,
            147424256,
            147417819,
            147434463,
            147437219,
            147451475
        ],
        "A": [
            147414901,
            147414810,
            147414544,
            147414530,
            147414675,
            147414742,
            147414833,
            147461626,
            147414843,
            147414962,
            147414590,
            147414549,
            147415904,
            147414474,
            147414750,
            147414483,
            147415173,
            147414668,
            147414647
        ]
    },
    "name": "B. Repetitions Decoding",
    "statement": "Olya has an array of integers a_1, a_2,\r\nldots, a_n. She wants to split it into tandem repeats. Since itâ€™s rarely\r\npossible, before that she wants to perform the following operation\r\nseveral (possibly, zero) number of times: insert a pair of equal numbers\r\ninto an arbitrary position. Help her!More formally: A tandem repeat is a\r\nsequence x of even length 2k such that for each 1\r\nle i\r\nle k the condition x_i = x_{i + k} is satisfied. An array a could be\r\nsplit into tandem repeats if you can split it into several parts, each\r\nbeing a subsegment of the array, such that each part is a tandem repeat.\r\nIn one operation you can choose an arbitrary letter c and insert [c, c]\r\nto any position in the array (at the beginning, between any two\r\nintegers, or at the end). You are to perform several operations and\r\nsplit the array into tandem repeats or determine that it is impossible.\r\nPlease note that you do have to minimize the number of operations.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.02.2022 13:49:47       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<pair<int, int>> ops;\n    vector<int> lens;\n    bool fail = false;\n    while (!a.empty()) {\n      int n = (int) a.size();\n      int i = n - 1;\n      int j = i - 1;\n      while (j >= 0 && a[j] != a[i]) {\n        j -= 1;\n      }\n      if (j == -1) {\n        fail = true;\n        break;\n      }\n      int ptr = j;\n      for (int k = i - 1; k >= j + 1; k--) {\n        ops.emplace_back(ptr, a[k]);\n        ptr += 1;\n      }\n      lens.push_back(2 * (i - j));\n      a.erase(a.begin() + i);\n      a.erase(a.begin() + j);\n      reverse(a.begin() + j, a.end());\n    }\n    if (fail) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    cout << ops.size() << '\\n';\n    for (auto& op : ops) {\n      cout << op.first << \" \" << op.second << '\\n';\n    }\n    reverse(lens.begin(), lens.end());\n    cout << lens.size() << '\\n';\n    for (int i = 0; i < (int) lens.size(); i++) {\n      cout << lens[i] << \" \\n\"[i == (int) lens.size() - 1];\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Repetitions Decoding.json",
    "editorial_link": "https://codeforces.com//blog/entry/100249",
    "editorial": "Let's prove that we can turn the array into a concatenation of tandem repeats using the operations given if and only if every letter occurs an even number of times\n\nIf there is such letter x\n that it occurs an odd number of times there is no such sequence of operations, since the parity of the number of occurrences if letter x\n stays the same. If we insert a different letter, the number of occurrences of letter x\n does not change, if we insert letter x\n, we add 2 occurrences of it. Thus, it will be impossible to split the array into tandem repeats.\n\nIf we have an array s1s2...sn\n, and we want to reverse its prefix of length k?n\n, we can insert a pair of letters equal to s1\n after the k\n-th symbol, a pair of letters equal to s2\n after (k+1)\n-th symbol and etc.\n\ns1s2...sksk+1...sn\n\ns1s2...sks1s1sk+1...sn\n\ns1s2...sks1s2s2s1sk+1...sn\n\n...\n\ns1s2...sks1s2...sksk...s2s1sk+1...sn\n\nIt is obvious that the first 2k\n symbols of the array form a tandem repeat. We can add it to our division and cut it out from the array. The array will now have its prefix of length k\n reversed. Thus, we can move any element to the beginning of the array, so we can simply sort it. Since every element occurs an even number of times, the resulting string will be a concatenation of tandem repeats consisting of the same letters.",
    "hint": []
}