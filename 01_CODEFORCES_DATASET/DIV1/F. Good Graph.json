{"link": "https://codeforces.com//contest/1835/problem/F", "problemId": "1971172", "problem_idx": "F", "shortId": "1835F", "contest_number": "1835", "problem_submissions": {"F": [210161299, 210152027, 210200486, 210168915, 210168905, 210234528, 210498721], "E": [210154409, 210139670, 210181918, 210167680, 210186364, 210186293, 211288903, 210214448, 210232344], "D": [210137478, 210145210, 210140448, 210146614, 210150836, 210149175, 210153170, 210140966, 210145335, 210157557, 210152881, 210158282, 210161722, 210158416, 210154492, 210150489, 210158944, 210157853, 210161077, 210159964], "C": [210128217, 210152796, 210132819, 210132907, 210137216, 210139416, 210142582, 210132889, 210151723, 210144494, 210144705, 210148053, 210147474, 210148947, 210144617, 210156201, 210143729, 210131342, 210153921, 210147904], "A": [210111447, 210110992, 210111020, 210113789, 210120090, 210112664, 210112565, 210111866, 210115344, 210112666, 210121548, 210113387, 210112454, 210112268, 210111369, 210114825, 210112488, 210116562, 210113331, 210116729], "B": [210161645, 210167670, 210167549, 210140435, 210129507, 210130424, 210124576, 210153636, 210135720, 210132356, 210134355, 210136221, 210133381, 210135165, 210136236, 210132156, 210131717, 210148804, 210140447, 210134819]}, "name": "F. Good Graph", "statement": "You are given a bipartite graph G with the vertex set in the left part\r\nL, in the right part R, and m edges connecting these two sets. We know\r\nthat |L| = |R| = n.For any subset S\r\nsubseteq L, let N(S) denote the set of all neighbors of vertices in S.\r\nWe say that a subset S\r\nsubseteq L in graph G is if |S| = |N(S)|. We say that graph G is if\r\nforall_{S\r\nsubseteq L}, |S|\r\nleq |N(S)|.Your task is to verify whether the graph is good and, if so,\r\nto optimize it. If the graph is not good, find a subset S\r\nsubseteq L such that |S| > |N(S)|. However, if the graph is good, your\r\ntask is to find a good bipartite graph G\u2019 with the same set of vertices\r\nL\r\ncup R, in which\r\nforall_{S\r\nsubseteq L}, S is tight in G if and only if S is tight in G\u2019. If there\r\nare multiple such graphs, choose one with the smallest possible number\r\nof edges. If there are still multiple such graphs, print any.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 1010;\nint n, m;\nbool G[N][N];\nint mt[N];\nbool used[N];\nvector<int> g[N], rg[N];\nint ord[N];\nint ordSz;\nint col[N];\nint id[N];\nint a[N];\nvector<int> forCol[N];\n\nvoid addEdge(int v, int u) {\n\tg[v].push_back(u);\n\trg[u].push_back(v);\n}\n\nvoid dfsOrd(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) if (!used[u])\n\t\tdfsOrd(u);\n\tord[ordSz++] = v;\n}\nvoid dfsCol(int v) {\n\tcol[v] = m;\n\tfor (int u : rg[v]) if (col[u] == 0)\n\t\tdfsCol(u);\n}\n\nbool dfs(int x) {\n\teprintf(\"dfs %d\\n\", x);\n\tif (used[x]) return false;\n\tused[x] = 1;\n\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\tif (mt[y] == -1) {\n\t\t\tmt[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\tif (dfs(mt[y])) {\n\t\t\tmt[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\twhile(m--) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty -= n + 1;\n\t\tG[x][y] = 1;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tmt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tused[j] = 0;\n\t\tif (dfs(i)) continue;\n\t\tprintf(\"NO\\n\");\n\t\tvector<int> w;\n\t\tfor (int j = 0; j < n; j++) if (used[j])\n\t\t\tw.push_back(j);\n\t\tprintf(\"%d\\n\", (int)w.size());\n\t\tfor (int x : w)\n\t\t\tprintf(\"%d \", x + 1);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(\"mt %d %d\\n\", mt[i], i);\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\t\tif (mt[y] == x) continue;\n\t\t\taddEdge(x, mt[y]);\n\t\t}\n\tfor (int v = 0; v < n; v++)\n\t\tused[v] = 0;\n\tfor (int v = 0; v < n; v++) if (!used[v])\n\t\tdfsOrd(v);\n\treverse(ord, ord + ordSz);\n\tm = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tif (col[v] != 0) continue;\n\t\tm++;\n\t\tdfsCol(v);\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tcol[v]--;\n\t\tforCol[col[v]].push_back(v);\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tG[i][j] = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u : g[v]) {\n\t\t\tif (col[v] != col[u])\n\t\t\t\tG[col[v]][col[u]] = 1;\n\t\t}\n\tfor (int k = 0; k < m; k++)\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tG[i][j] |= G[i][k] & G[k][j];\n\tvector<pii> ans;\n\tfor (int i = 0; i < n; i++)\n\t\tans.push_back(mp(i, i));\n\tfor (int c = 0; c < m; c++) if ((int)forCol[c].size() > 1) {\n\t\tfor (int i = 0; i < (int)forCol[c].size() - 1; i++)\n\t\t\tans.push_back(mp(forCol[c][i], forCol[c][i + 1]));\n\t\tans.push_back(mp(forCol[c].back(), forCol[c][0]));\n\t}\n\tfor (int v = 0; v < m; v++)\n\t\tfor (int u = 0; u < m; u++) if (G[v][u]) {\n\t\t\tbool ok = true;\n\t\t\tfor (int w = 0; w < m; w++)\n\t\t\t\tif (G[v][w] && G[w][u])\n\t\t\t\t\tok = false;\n\t\t\tif (ok) ans.push_back(mp(forCol[v].back(), forCol[u].back()));\n\t\t}\n\tprintf(\"YES\\n\");\n\tprintf(\"%d\\n\", (int)ans.size());\n\tfor (pii e : ans)\n\t\tprintf(\"%d %d\\n\", 1 + e.first, n + 1 + e.second);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "dfs and similar", "graph matchings", "graphs", "implementation"], "dificulty": "3500", "interactive": false}