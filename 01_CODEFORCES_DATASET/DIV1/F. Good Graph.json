{
    "link": "https://codeforces.com//contest/1835/problem/F",
    "problemId": "1971172",
    "problem_idx": "F",
    "shortId": "1835F",
    "contest_number": "1835",
    "problem_submissions": {
        "F": [
            210161299,
            210152027,
            210200486,
            210168915,
            210168905,
            210234528,
            210498721
        ],
        "E": [
            210154409,
            210139670,
            210181918,
            210167680,
            210186364,
            210186293,
            211288903,
            210214448,
            210232344
        ],
        "D": [
            210137478,
            210145210,
            210140448,
            210146614,
            210150836,
            210149175,
            210153170,
            210140966,
            210145335,
            210157557,
            210152881,
            210158282,
            210161722,
            210158416,
            210154492,
            210150489,
            210158944,
            210157853,
            210161077,
            210159964
        ],
        "C": [
            210128217,
            210152796,
            210132819,
            210132907,
            210137216,
            210139416,
            210142582,
            210132889,
            210151723,
            210144494,
            210144705,
            210148053,
            210147474,
            210148947,
            210144617,
            210156201,
            210143729,
            210131342,
            210153921,
            210147904
        ],
        "A": [
            210111447,
            210110992,
            210111020,
            210113789,
            210120090,
            210112664,
            210112565,
            210111866,
            210115344,
            210112666,
            210121548,
            210113387,
            210112454,
            210112268,
            210111369,
            210114825,
            210112488,
            210116562,
            210113331,
            210116729
        ],
        "B": [
            210161645,
            210167670,
            210167549,
            210140435,
            210129507,
            210130424,
            210124576,
            210153636,
            210135720,
            210132356,
            210134355,
            210136221,
            210133381,
            210135165,
            210136236,
            210132156,
            210131717,
            210148804,
            210140447,
            210134819
        ]
    },
    "name": "F. Good Graph",
    "statement": "You are given a bipartite graph G with the vertex set in the left part\r\nL, in the right part R, and m edges connecting these two sets. We know\r\nthat |L| = |R| = n.For any subset S\r\nsubseteq L, let N(S) denote the set of all neighbors of vertices in S.\r\nWe say that a subset S\r\nsubseteq L in graph G is if |S| = |N(S)|. We say that graph G is if\r\nforall_{S\r\nsubseteq L}, |S|\r\nleq |N(S)|.Your task is to verify whether the graph is good and, if so,\r\nto optimize it. If the graph is not good, find a subset S\r\nsubseteq L such that |S| > |N(S)|. However, if the graph is good, your\r\ntask is to find a good bipartite graph G\u2019 with the same set of vertices\r\nL\r\ncup R, in which\r\nforall_{S\r\nsubseteq L}, S is tight in G if and only if S is tight in G\u2019. If there\r\nare multiple such graphs, choose one with the smallest possible number\r\nof edges. If there are still multiple such graphs, print any.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 1010;\nint n, m;\nbool G[N][N];\nint mt[N];\nbool used[N];\nvector<int> g[N], rg[N];\nint ord[N];\nint ordSz;\nint col[N];\nint id[N];\nint a[N];\nvector<int> forCol[N];\n\nvoid addEdge(int v, int u) {\n\tg[v].push_back(u);\n\trg[u].push_back(v);\n}\n\nvoid dfsOrd(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) if (!used[u])\n\t\tdfsOrd(u);\n\tord[ordSz++] = v;\n}\nvoid dfsCol(int v) {\n\tcol[v] = m;\n\tfor (int u : rg[v]) if (col[u] == 0)\n\t\tdfsCol(u);\n}\n\nbool dfs(int x) {\n\teprintf(\"dfs %d\\n\", x);\n\tif (used[x]) return false;\n\tused[x] = 1;\n\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\tif (mt[y] == -1) {\n\t\t\tmt[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\tif (dfs(mt[y])) {\n\t\t\tmt[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\twhile(m--) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty -= n + 1;\n\t\tG[x][y] = 1;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tmt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tused[j] = 0;\n\t\tif (dfs(i)) continue;\n\t\tprintf(\"NO\\n\");\n\t\tvector<int> w;\n\t\tfor (int j = 0; j < n; j++) if (used[j])\n\t\t\tw.push_back(j);\n\t\tprintf(\"%d\\n\", (int)w.size());\n\t\tfor (int x : w)\n\t\t\tprintf(\"%d \", x + 1);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(\"mt %d %d\\n\", mt[i], i);\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\t\tif (mt[y] == x) continue;\n\t\t\taddEdge(x, mt[y]);\n\t\t}\n\tfor (int v = 0; v < n; v++)\n\t\tused[v] = 0;\n\tfor (int v = 0; v < n; v++) if (!used[v])\n\t\tdfsOrd(v);\n\treverse(ord, ord + ordSz);\n\tm = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tif (col[v] != 0) continue;\n\t\tm++;\n\t\tdfsCol(v);\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tcol[v]--;\n\t\tforCol[col[v]].push_back(v);\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tG[i][j] = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u : g[v]) {\n\t\t\tif (col[v] != col[u])\n\t\t\t\tG[col[v]][col[u]] = 1;\n\t\t}\n\tfor (int k = 0; k < m; k++)\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tG[i][j] |= G[i][k] & G[k][j];\n\tvector<pii> ans;\n\tfor (int i = 0; i < n; i++)\n\t\tans.push_back(mp(i, i));\n\tfor (int c = 0; c < m; c++) if ((int)forCol[c].size() > 1) {\n\t\tfor (int i = 0; i < (int)forCol[c].size() - 1; i++)\n\t\t\tans.push_back(mp(forCol[c][i], forCol[c][i + 1]));\n\t\tans.push_back(mp(forCol[c].back(), forCol[c][0]));\n\t}\n\tfor (int v = 0; v < m; v++)\n\t\tfor (int u = 0; u < m; u++) if (G[v][u]) {\n\t\t\tbool ok = true;\n\t\t\tfor (int w = 0; w < m; w++)\n\t\t\t\tif (G[v][w] && G[w][u])\n\t\t\t\t\tok = false;\n\t\t\tif (ok) ans.push_back(mp(forCol[v].back(), forCol[u].back()));\n\t\t}\n\tprintf(\"YES\\n\");\n\tprintf(\"%d\\n\", (int)ans.size());\n\tfor (pii e : ans)\n\t\tprintf(\"%d %d\\n\", 1 + e.first, n + 1 + e.second);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "graph matchings",
        "graphs",
        "implementation"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Good Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/117394",
    "editorial": "According to Hall\u00e2\u0080\u0099s theorem, a graph is good if and only if a perfect\r\nmatching exists. We run any reasonable algorithm to find a perfect\r\nmatching (e.g. the Hopcroft-Karp\u00e2\u0080\u0099s algorithm). We call the found\r\nmatching (any perfect matching is fine).We look for a counterexample if\r\nwe do not find a perfect matching. One way to find it is to run s\r\nsimilar DFS as in the Hopcroft-Karp algorithm from any unmatched vertex\r\non the left side. As a reminder, we visit all neighbours of vertices on\r\nthe left side and only the vertex with which we are matched for vertices\r\non the right side. As we won\u00e2\u0080\u0099t see any unmatched vertex on the right\r\nside (otherwise, we\u00e2\u0080\u0099d found an augmenting path), the set of visited\r\nvertices on the left side has fewer neighbours than its size we found\r\nour counterexample.As our graph is good, we should examine the\r\nconstruction of tight sets.Function is submodular.Consider two sets and\r\na vertex . For each vertex , we know that and , thus, . We conclude that\r\n; thus, the function is submodular.Tight sets are closed under\r\nintersection and sum.Consider two tight sets, and . From , we get that ,\r\nwhere the last inequality results from the graph being good. As we get\r\nthe same value on both sides, all inequalities become equalities. In\r\nparticular, with the graph being good, we get that and . That proves\r\nthat sets , and are tight.We define as the minimal tight set containing\r\nvertex . We know such a set exists as tight sets are closed under the\r\nintersection. From that, we can conclude that any tight set can be\r\nrepresented as a sum of minimal tight sets. Thus, we are only interested\r\nin keeping the same minimal tight sets. We can find the minimal tight\r\nsets using the same DFS algorithm as for finding a counterexample. As\r\nthe graph is large, use bitsets to optimise it.To find the smallest\r\ngraph, we analyse these sets in order of nondecreasing sizes. For\r\nsimplicity, we erase duplicates. When we analyse the set, we distinguish\r\nthe new vertices (the ones that haven\u00e2\u0080\u0099t been touched yet). There is\r\nalways a new vertex, as this is the minimal tight set for at least one\r\nvertex (and we removed duplicates). If there is only one new vertex , we\r\ncan add an edge from to . Otherwise, we have to connect these vertices\r\ninto a cycle we create edges . If we have less than edges, then there\r\nexists a vertex with a degree equal to we could pick this vertex, and\r\nit\u00e2\u0080\u0099d create a minimal tight set.We still have to handle other vertices\r\nin this (i.e. the ones which are not new). We pick a representative for\r\nour cycle, which will become a representative for this set. Similarly,\r\nwe have a representative for other sets. We find a partition of these\r\nvertices into a minimal number of tight sets. We add an edge between\r\nthese representatives and our vertex . We use a similar argument as\r\nbefore if we didn\u00e2\u0080\u0099t add this edge, we would find different minimal tight\r\nsets. To handle representatives, we use a disjoint set union structure.\r\nThe final complexity of this algorithm is .\r\n"
}