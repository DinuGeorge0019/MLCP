{
    "link": "https://codeforces.com//contest/356/problem/A",
    "problemId": "3676",
    "problem_idx": "A",
    "shortId": "356A",
    "contest_number": "356",
    "problem_submissions": {
        "D": [
            4794974,
            4796940,
            4801750,
            4797879,
            4794633,
            4794914,
            4800192,
            4799081,
            4798608,
            4796033,
            4796373,
            5586844,
            4848850,
            4848737
        ],
        "C": [
            4792387,
            4791833,
            4794313,
            4794230,
            4792849,
            4796109,
            4790890,
            4794074,
            4792572,
            4798707,
            4793084,
            4793173,
            4792457,
            4794510,
            4793687,
            4793583
        ],
        "A": [
            4790471,
            4798737,
            4789838,
            4789461,
            4789429,
            4789788,
            4789491,
            4792712,
            4789440,
            4789650,
            4790200,
            4790207,
            4789553,
            4789481,
            4790643,
            4790114,
            4791900,
            4790345
        ],
        "B": [
            4789769,
            4790832,
            4793129,
            4799391,
            4791122,
            4791172,
            4791264,
            4792100,
            4790127,
            4791066,
            4791524,
            4791678,
            4791801,
            4791270,
            4793238,
            4792003,
            4791083,
            4792077
        ],
        "E": [
            4808374,
            4805352
        ]
    },
    "name": "A. Knight Tournament",
    "statement": "Hooray! Berl II, the king of Berland is making a knight tournament. The\r\nking has already sent the message to all knights in the kingdom and they\r\nin turn agreed to participate in this grand event.As for you, you’re\r\njust a simple peasant. There’s no surprise that you slept in this\r\nmorning and were late for the tournament (it was a weekend, after all).\r\nNow you are really curious about the results of the tournament. This\r\ntime the tournament in Berland went as follows: There are knights\r\nparticipating in the tournament. Each knight was assigned his unique\r\nnumber an integer from 1 to . The tournament consisted of fights, in the\r\n-th fight the knights that were still in the game with numbers at least\r\nand at most have fought for the right to continue taking part in the\r\ntournament. After the -th fight among all participants of the fight only\r\none knight won the knight number , he continued participating in the\r\ntournament. Other knights left the tournament. The winner of the last\r\n(the -th) fight (the knight number ) became the winner of the\r\ntournament. You fished out all the information about the fights from\r\nyour friends. Now for each knight you want to know the name of the\r\nknight he was conquered by. We think that the knight number was\r\nconquered by the knight number , if there was a fight with both of these\r\nknights present and the winner was the knight number .Write the code\r\nthat calculates for each knight, the name of the knight that beat him.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 600010;\n\nint n, m;\nint s[N], ans[N];\n\nvoid modify(int x, int v) {\n  while (x <= n) {\n    s[x] += v;\n    x = (x | (x - 1)) + 1;\n  }\n}\n\nint findsum(int x) {\n  int v = 0;\n  while (x > 0) {\n    v += s[x];\n    x &= x - 1;\n  }\n  return v;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; i++) s[i] = 0;\n  for (int i = 1; i <= n; i++) modify(i, 1);\n  for (int i = 1; i <= n; i++) ans[i] = 0;\n  while (m--) {\n    int from, to, win;\n    scanf(\"%d %d %d\", &from, &to, &win);\n    int dec = findsum(from - 1);\n    int add = findsum(to);\n    while (add > dec) {\n      int ll = from, rr = to;\n      while (ll < rr) {\n        int mid = (ll + rr) >> 1;\n        if (findsum(mid) == dec) ll = mid + 1;\n        else rr = mid;\n      }\n      ans[ll] = win;\n      modify(ll, -1);\n      add--;\n    }\n    ans[win] = 0;\n    modify(win, 1);\n  }\n  for (int i = 1; i < n; i++) printf(\"%d \", ans[i]);\n  printf(\"%d\\n\", ans[n]);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Knight Tournament.json",
    "editorial_link": "https://codeforces.com/blog/entry/9210",
    "editorial": "Letâs the current fight consists of knights fighting. Then all we have\r\nto do is to find all these knights in time or . There are several ways\r\nto do that, letâs consider some of them. The first way is to store the\r\nnumbers of all alive knights in std::set (C++) or TreeSet (Java). Then\r\nin C++ we can use lower_bound method to find the first knight in the\r\nfight that is alive, and to iterate over this set, each time moving to\r\nthe next alive knight. In Java we should use subSet method. The second\r\nway is to define array next with the following meaning: To find the\r\nfirst alive knight starting from the knight we need to follow this links\r\nuntil we find the first knight with . In order not to pass the same\r\nlinks too many times, we will use the trick known as path compression\r\n(it is used in Disjoint Set Union). Note that you should handle the case\r\nwhen the current knight is the last knight and is out of tournament.\r\n",
    "hint": []
}