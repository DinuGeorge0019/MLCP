{"link": "https://codeforces.com//contest/700/problem/D", "problemId": "66135", "problem_idx": "D", "shortId": "700D", "contest_number": "700", "problem_submissions": {"E": [24594748, 158561725, 158550290], "C": [19345625, 19382048, 19338136, 19340095, 19340301, 19337933, 19340888, 19340881, 19340439, 19343320, 19342147, 19343241, 19336239, 19344979, 19337688, 19345735, 19344599], "D": [19338795, 19343784, 19338575, 19351010, 19367015, 19366989, 19347563, 19447172, 19403026, 19402917, 19402596, 19384510, 157407262], "B": [19331219, 19332414, 19339798, 19330514, 19333849, 19334131, 19329268, 19335879, 19332140, 19330791, 19333504, 19333302, 19336092, 19330270, 19335712, 19342616, 19337619, 19335938], "A": [19329325, 19331230, 19341005, 19330573, 19330510, 19343948, 19331088, 19333400, 19345881, 19331775, 19336434, 19335266, 19334161, 19341301, 19332102, 19332761]}, "name": "D. Huffman Coding on Segment", "statement": "Alice wants to send an important message to Bob. Message is a sequence\r\nof positive integers ().To compress the message Alice wants to use\r\nbinary Huffman coding. We recall that , or is a function , that maps\r\neach letter that appears in the string to some binary string (that is,\r\nstring consisting of characters \u201d and \u201d only) such that for each pair of\r\ndifferent characters and string is not a prefix of (and vice versa). The\r\nresult of the encoding of the message is the concatenation of the\r\nencoding of each character, that is the string . Huffman codes are very\r\nuseful, as the compressed message can be easily and uniquely\r\ndecompressed, if the function is given. Code is usually chosen in order\r\nto minimize the total length of the compressed message, i.e. the length\r\nof the string .Because of security issues Alice doesn\u2019t want to send the\r\nwhole message. Instead, she picks some substrings of the message and\r\nwants to send them separately. For each of the given substrings she\r\nwants to know the minimum possible length of the Huffman coding. Help\r\nher solve this problem.\r\n", "solutions": ["#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define pii pair<int,int>\nusing namespace std;\nvector<pii>E[100100];\npriority_queue<int>PQ;\nint C[100100], CC[100100];\nint In[101000], L[1010], CL, R[2010];\nint n, w[101000], Q, cnt;\nlong long Ans[101000];\nvoid Ins(int a, int b){\n    CC[C[a]]--;\n    C[a]+=b;\n    CC[C[a]]++;\n    if(C[a] >= 600 && !In[a]){\n        In[a] = 1;\n        L[++CL] = a;\n    }\n}\nvoid Do(int pb, int b, int num){\n    int i, j;\n    for(i=pb;i<b;i++){\n        Ins(w[i],-1);\n    }\n    for(i=1;i<=CL;i++){\n        if(C[L[i]] >= 600){\n            PQ.push(-C[L[i]]);\n        }\n    }\n    long long Res = 0;\n    for(i=1;i<600;i++){\n        R[i] = CC[i];\n    }\n    for(i=600;i<=1200;i++)R[i] = 0;\n    for(i=1;i<600;i++){\n        R[i*2] += R[i]/2;\n        Res += (R[i]/2)*2*i;\n        R[i]%=2;\n        if(R[i]){\n            for(j=i+1;j<600;j++)if(R[j])break;\n            if(j != 600){\n                R[j]--;R[i]--;\n                R[i+j]++;\n                Res += i+j;\n                i = j-1;\n                continue;\n            }\n            else{\n                PQ.push(-i);\n                break;\n            }\n        }\n    }\n    for(i=600;i<=1200;i++){\n        while(R[i]){\n            R[i]--;\n            PQ.push(-i);\n        }\n    }\n    while(PQ.size() > 1){\n        int t1 = PQ.top();\n        PQ.pop();\n        int t2 = PQ.top();\n        PQ.pop();\n        Res += (-t1-t2);\n        PQ.push(t1+t2);\n    }\n    while(!PQ.empty())PQ.pop();\n    Ans[num] = Res;\n    for(i=pb;i<b;i++){\n        Ins(w[i],1);\n    }\n}\nint main(){\n    int i, b, e, j, k;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&w[i]);\n    }\n    scanf(\"%d\",&Q);\n    for(i=1;i<=Q;i++){\n        scanf(\"%d%d\",&b,&e);\n        E[e].push_back(pii(b,i));\n    }\n    for(i=1;i<=n;i+=300){\n        for(j=0;j<=100000;j++)C[j] = CC[j] = In[j] = 0;\n        CL = 0;\n        for(j=i;j<=n;j++){\n            Ins(w[j], 1);\n            for(k=0;k<E[j].size();k++){\n                if(E[j][k].first >= i && E[j][k].first < i+300){\n                    Do(i, E[j][k].first, E[j][k].second);\n                }\n            }\n        }\n    }\n    for(i=1;i<=Q;i++){\n        printf(\"%lld\\n\",Ans[i]);\n    }\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "3100", "interactive": false}