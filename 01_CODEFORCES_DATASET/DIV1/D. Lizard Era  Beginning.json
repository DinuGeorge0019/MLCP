{
    "link": "https://codeforces.com//contest/585/problem/D",
    "problemId": "37967",
    "problem_idx": "D",
    "shortId": "585D",
    "contest_number": "585",
    "problem_submissions": {
        "E": [
            13568408,
            13565539,
            13570428,
            13569433,
            13562876,
            13568414,
            13569561,
            13572183,
            16851653,
            13569075,
            13575618,
            14433103,
            14433079,
            13586801,
            14994906
        ],
        "D": [
            13563803,
            13560460,
            13565708,
            13598452,
            13575351,
            13570446,
            13565845,
            13564574,
            13569714,
            13567701,
            13566576,
            13567580,
            13566498,
            13559261,
            13566963,
            13566457,
            13569728,
            13568576
        ],
        "C": [
            13561640,
            13569007,
            13569377,
            13560848,
            13567147,
            13570951,
            13564734,
            13564195,
            13562727,
            13563205,
            13570079,
            13563945,
            13564180,
            13570698,
            13565134,
            13564377
        ],
        "B": [
            13558808,
            13566721,
            13560966,
            13559388,
            13575429,
            13561963,
            13558427,
            13563703,
            16850949,
            13561366,
            13561440,
            13558802,
            13567542,
            13562248,
            13560363,
            13561318,
            13562539
        ],
        "A": [
            13556266,
            13558452,
            13556785,
            13558546,
            13586871,
            13556142,
            16850921,
            13556990,
            13562212,
            13561943,
            13585791,
            13560017,
            13556037,
            13558619,
            13558552
        ],
        "F": [
            13587655,
            13575255,
            13575217,
            16850828,
            24552744,
            14433355
        ]
    },
    "name": "D. Lizard Era  Beginning",
    "statement": "In the game Lizard Era: Beginning the protagonist will travel with three\r\ncompanions: Lynn, Meliana and Worrigan. Overall the game has mandatory\r\nquests. To perform each of them, you need to take companions.The\r\nattitude of each of the companions to the hero is an integer. Initially,\r\nthe attitude of each of them to the hero of neutral and equal to 0. As\r\nthe hero completes quests, he makes actions that change the attitude of\r\nthe companions, whom he took to perform this task, in positive or\r\nnegative direction.Tell us what companions the hero needs to choose to\r\nmake their attitude equal after completing all the quests. If this can\r\nbe done in several ways, choose the one in which the value of resulting\r\nattitude is greatest possible.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n#define mp make_pair\n#define X first\n#define Y second\n\nconst int INF = (int)1e9;\nconst int N = 30;\nint n;\nint a[N][3];\nmap<pii, pii> mapchik;\nint p[N];\nint ansVal = -INF;\npii ans;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    p[0] = 1;\n    for (int i = 1; i <= n; i++)\n        p[i] = p[i - 1] * 3;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < 3; j++)\n            scanf(\"%d\", &a[i][j]);\n    int m = (n + 1) / 2;\n    for (int mask = 0; mask < p[m]; mask++)\n    {\n        int b[3];\n        b[0] = b[1] = b[2] = 0;\n        int mm = mask;\n        for (int i = 0; i < m; i++)\n        {\n            int x = mm % 3;\n            mm /= 3;\n            for (int j = 0; j < 3; j++)\n                b[j] += a[i][j];\n            b[x] -= a[i][x];\n        }\n        int val = b[0];\n        for (int j = 0; j < 3; j++)\n            b[j] -= val;\n        pii key = mp(-b[1], -b[2]);\n        if (mapchik.count(key) == 0)\n            mapchik[key] = mp(val, mask);\n        else\n        {\n            pii v = mapchik[key];\n            if (val > v.X)\n                mapchik[key] = mp(val, mask);\n        }\n    }\n    for (int mask = 0; mask < p[n - m]; mask++)\n    {\n        int b[3];\n        b[0] = b[1] = b[2] = 0;\n        int mm = mask;\n        for (int i = m; i < n; i++)\n        {\n            int x = mm % 3;\n            mm /= 3;\n            for (int j = 0; j < 3; j++)\n                b[j] += a[i][j];\n            b[x] -= a[i][x];\n        }\n        int val = b[0];\n        for (int j = 0; j < 3; j++)\n            b[j] -= val;\n        pii key = mp(b[1], b[2]);\n        if (mapchik.count(key) == 0)\n            continue;\n        else\n        {\n            pii v = mapchik[key];\n            val += v.X;\n            if (val > ansVal)\n            {\n                ansVal = val;\n                ans = mp(v.Y, mask);\n            }\n        }\n    }\n    if (ansVal == -INF)\n        printf(\"Impossible\\n\");\n    else\n    {\n        int mm = ans.X;\n        for (int i = 0; i < m; i++)\n        {\n            int x = mm % 3;\n            mm /= 3;\n            if (x == 0)\n                printf(\"MW\\n\");\n            else if (x == 1)\n                printf(\"LW\\n\");\n            else\n                printf(\"LM\\n\");\n        }\n        mm = ans.Y;\n        for (int i = m; i < n; i++)\n        {\n            int x = mm % 3;\n            mm /= 3;\n            if (x == 0)\n                printf(\"MW\\n\");\n            else if (x == 1)\n                printf(\"LW\\n\");\n            else\n                printf(\"LM\\n\");\n        }\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "meet-in-the-middle"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Lizard Era  Beginning.json",
    "editorial_link": "https://codeforces.com//blog/entry/20898",
    "editorial": "The problem has been prepared by danilka.pro. To solve the problem we\r\nwill use meet-in-the-middle approach. For we should consider all\r\nvariants. Let in some variant approval values of three companions are\r\nrespectively. If we will consider some variant from other half (there\r\nare of them) and approval values, then to âmergeâ such two parts\r\ncorrectly, two conditions must be true ( is true), and the value we are\r\nmaximizing is . This way, to solve the task one could consider every\r\nvariant from the first half and store for every possible pair the\r\nmaximum value achievable (using, for example, the structure or any fast\r\nsorting algorithm). If one would then consider every variant from the\r\nsecond half, he just need to find pair in the structure to get the\r\nmaximum value if possible and update answer with value. Answer restoring\r\nis pretty same to the algorithm above. Such solution has complexity.\r\n",
    "hint": []
}