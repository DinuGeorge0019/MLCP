{"link": "https://codeforces.com//contest/1495/problem/A", "problemId": "920574", "problem_idx": "A", "shortId": "1495A", "contest_number": "1495", "problem_submissions": {"F": [109612449, 109607835, 109606482, 109609150, 109620903, 109726650, 109627363, 109621999], "E": [109601349, 109614588, 109615437, 109622017, 109595998, 109609900, 109608272, 109611154, 109618626, 109616350, 109613793, 109616566, 109663705, 109745948], "D": [109585527, 109580228, 109579316, 109589541, 109578458, 109566916, 109575841, 109594019, 109596254, 109599839, 109603208, 109598498, 109595100, 109579185, 109589312, 109591284, 109598520, 109583665, 109585365], "C": [109580634, 109591405, 109587970, 109577744, 109586320, 109593422, 109611088, 109582953, 109580883, 109580583, 109587448, 109605186, 109581328, 109584227, 109579041, 109577709, 109589629, 109602493], "B": [109568471, 109565101, 109584053, 109566115, 109569156, 109574304, 109563074, 109573615, 109567542, 109575207, 109571021, 109587658, 109567505, 109566798, 109566339, 109589966, 109570284, 109566248], "A": [109557502, 109557307, 109557290, 109557352, 109558084, 109569473, 109557547, 109559952, 109558698, 109558154, 109557812, 109558270, 109557945, 109558879, 109557971, 109558445, 109560880, 109558343, 109559119]}, "name": "A. Diamond Miner", "statement": "Diamond Miner is a game that is similar to Gold Miner, but there are n\r\nminers instead of 1 in this game.The mining area can be described as a\r\nplane. The n miners can be regarded as n points . There are n diamond\r\nmines in the mining area. We can regard them as n points . For some\r\nreason, (point (0, 0)). Every miner should mine one diamond mine. Every\r\nminer has a hook, which can be used to mine a diamond mine. If a miner\r\nat the point (a,b) uses his hook to mine a diamond mine at the point\r\n(c,d), he will spend\r\nsqrt{(a-c)^2+(b-d)^2} energy to mine it (the distance between these\r\npoints). The miners can\u2019t move or help each other.The object of this\r\ngame is to minimize that miners spend. Can you find this minimum?\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvll raz, dwa;\n\nvoid test()\n{\n\traz.clear();\n\tdwa.clear();\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=2*n; i++)\n\t{\n\t\tll a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\tif (!a)\n\t\t\traz.push_back(abs(b));\n\t\telse\n\t\t\tdwa.push_back(abs(a));\n\t}\n\tsort(raz.begin(), raz.end());\n\tsort(dwa.begin(), dwa.end());\n\t//~ reverse(dwa.begin(), dwa.end());\n\tdouble wyn=0;\n\tfor (int i=0; i<n; i++)\n\t\twyn+=sqrt((double)(raz[i]*raz[i]+dwa[i]*dwa[i]));\n\tprintf(\"%.11lf\\n\", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["geometry", "greedy", "math", "sortings"], "dificulty": "1200", "interactive": false}