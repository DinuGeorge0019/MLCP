{
    "link": "https://codeforces.com//contest/634/problem/F",
    "problemId": "49953",
    "problem_idx": "F",
    "shortId": "634F",
    "contest_number": "634",
    "problem_submissions": {
        "E": [
            16414340,
            16416138,
            16413706,
            16414973,
            16415599,
            16414780,
            16415591,
            16416199,
            16416181,
            16416348,
            16415632,
            16415457,
            16416072,
            16413745,
            16466856,
            16413386
        ],
        "D": [
            16411007,
            16410815,
            16412075,
            16411999,
            16412771,
            16413214,
            16412917,
            16413088,
            16413557,
            16414243,
            16411968,
            16413070,
            16413608,
            16410814,
            16411583,
            16411708,
            16418042,
            16411828
        ],
        "C": [
            16409750,
            16409051,
            16410811,
            16409734,
            16410839,
            16411665,
            16411917,
            16411834,
            16411108,
            16413312,
            16410161,
            16411194,
            16417790,
            16416407,
            16409322,
            16410089,
            16410459,
            16409945,
            16409746,
            16410147
        ],
        "B": [
            16408395,
            16409662,
            16410216,
            16408841,
            16409386,
            16409860,
            16410585,
            16409660,
            16410064,
            16408757,
            16417413,
            16417828,
            16409703,
            16408566,
            16409147,
            16409169,
            16409287,
            16410817,
            16408754
        ],
        "A": [
            16407814,
            16407800,
            16408726,
            16407801,
            16408251,
            16407972,
            16407935,
            16408112,
            16408492,
            16407803,
            16407794,
            16408196,
            16407918,
            16407735,
            16407903,
            16407915,
            16407851,
            16408302,
            16407766
        ],
        "F": [
            16417401,
            17066904
        ]
    },
    "name": "F. Orchestra",
    "statement": "Paul is at the orchestra. The string section is arranged in an\r\nrectangular grid and is filled with violinists with the exception of\r\nviolists. Paul really likes violas, so he would like to take a picture\r\nincluding at least of them. Paul can take a picture of any axis-parallel\r\nrectangle in the orchestra. Count the number of possible pictures that\r\nPaul can take.Two pictures are considered to be different if the\r\ncoordinates of corresponding rectangles are different.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nconst int N = 3005;\nconst int K = 12;\n\nint n, m, k, bl[N][K], br[N][K], cl[K], cr[K], tl[K], tr[K];\nLL ans;\n\n\nchar a[2][N][N];\nint s[2][N][N];\n\ninline void work(int u, int d, int l, int r, int id){\n    if (s[id][d][r] - s[id][u - 1][r] - s[id][d][l - 1] + s[id][u - 1][l - 1] == 0) {\n        ans += (d - u + 2) * (d - u + 1) * 1ll * (r - l + 2) * (r - l + 1) / 4;\n        return;\n    }\n    if (d-u > r-l) {\n        swap(u, l);\n        swap(d, r);\n        id ^= 1;\n    }\n\n    int m(l+r>>1);\n    FOR(i,u,d){\n        int t(0);\n        bl[i][0] = m;\n        char * T = a[id][i];\n        ROF(j,m,l){\n            if (T[j]) bl[i][++t] = j;\n            if (t == k+1) break;\n        }\n        while (t < k+1) bl[i][++t] = l-1;\n        t = 0;\n        br[i][0] = m;\n\n        FOR(j,m+1,r){\n            if (T[j]) br[i][++t] = j;\n            if (t == k+1) break;\n        }\n        while (t < k+1) br[i][++t] = r+1;\n    }\n    FOR(i,u,d){\n        cl[0] = cr[0] = m;\n        REP(t,k+1) cl[t] = l-1, cr[t] = r+1;\n        FOR(j,i,d){\n            FOR(t,0,k+1) tl[t] = cl[t], tr[t] = cr[t];\n            int p(1), q(1);\n            REP(t,k+1)\n                if (tl[p] > bl[j][q]) cl[t] = tl[p++]; else cl[t] = bl[j][q++];\n            p = 1, q = 1;\n            REP(t,k+1)\n                if (tr[p] < br[j][q]) cr[t] = tr[p++]; else cr[t] = br[j][q++];\n            FOR(t,0,k) ans += (cl[t]-cl[t+1])*(cr[k-t+1]-cr[0]);\n        }\n\n    }\n    if (l < m) work(u, d, l, m-1, id);\n    if (m < r) work(u, d, m+1, r, id);\n}\n\n\nint main(){\n    int u;\n    scanf(\"%d%d%d%d\", &n, &m, &u, &k);\n\n    for (int i = 0; i < u; ++i) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        a[0][x][y] = 1;\n        a[1][y][x] = 1;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            a[1][j][i] = a[0][i][j];\n        }\n    }\n    for (int t = 0; t < 2; ++t) {\n        for (int i = 1; i < N; ++i) {\n            for (int j = 1; j < N; ++j) {\n                s[t][i][j] = a[t][i][j] + s[t][i - 1][j] + s[t][i][j - 1] - s[t][i - 1][j - 1];\n            }\n        }\n    }\n    --k;\n    work(1, n, 1, m, 0);\n    long long ans2 = ans;\n    cout << 1ll * (n + 1) * n / 2 * (m + 1) * m / 2 - ans2 << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Orchestra.json",
    "editorial_link": "https://codeforces.com//blog/entry/43467",
    "editorial": "We can think of a rectangle in the grid as a pair of an (xlo,?xhi) interval and a (ylo,?yhi) interval. Suppose we fix the x-interval and want to determine the number of corresponding y intervals which create rectangles containing at least k violists. Given a sorted list of the y-coordinates of all violists in the range, this is simple: m violists split the y-coordinates into m?+?1 (possibly empty) intervals that span all the columns, and the number of total intervals that work is simply the number of pairs of points that are at least k intervals apart.\n\nAs we sweep over the xhi coordinate and maintain the list of violists, we want to insert each violist into a sorted list and look at its k nearest neighbors to determine the change in number of intervals. Inserting violists into a sorted list, however, is difficult to do in constant time. Instead, we sweep in reverse. Start with xhi?=?r and a linked list containing all the desired violists; decrementing xhi is now a simple process of removing the necessary elements from a linked list and examining their neighbors as we do so.",
    "hint": []
}