{
    "link": "https://codeforces.com//contest/1458/problem/F",
    "problemId": "837947",
    "problem_idx": "F",
    "shortId": "1458F",
    "contest_number": "1458",
    "problem_submissions": {
        "C": [
            101749748,
            101754548,
            101742006,
            101765508,
            101760904,
            101735121,
            101758711,
            101733697,
            101742587,
            101742771,
            101744109,
            101764706,
            101753517,
            101758458,
            103876484,
            101781534
        ],
        "D": [
            101742255,
            101733305,
            101750551,
            101754872,
            101747447,
            101747468,
            101737535,
            101761632,
            101756331,
            101755812,
            102023685,
            101761131,
            101768544,
            101764759,
            103932701,
            101747159
        ],
        "E": [
            101737863,
            101746540,
            101766037,
            101749099,
            101757343,
            101752859,
            101763081,
            101766464,
            101774328,
            101752190,
            101746555,
            101751393,
            101757105
        ],
        "B": [
            101728732,
            101721253,
            101733062,
            101725510,
            101763762,
            101727209,
            101722722,
            101732397,
            101727564,
            101724112,
            101730858,
            101735965,
            101740443,
            101732340,
            101727159,
            101744347,
            101723637,
            101730363,
            101730317
        ],
        "A": [
            101720547,
            101718495,
            101723686,
            101718493,
            101718664,
            101719145,
            101718463,
            101718584,
            101718634,
            101718787,
            101720142,
            101718675,
            101719084,
            101722215,
            101718515,
            101719224,
            101718795,
            101718781,
            101721089
        ],
        "F": [
            102925392,
            102542392,
            102542303,
            103841307
        ]
    },
    "name": "F. Range Diameter Sum",
    "statement": "You are given a tree with n vertices numbered 1,\r\nldots, n. A tree is a connected simple graph without cycles.Let\r\nmathrm{dist}(u, v) be the number of edges in the unique simple path\r\nconnecting vertices u and v.Let\r\nmathrm{diam}(l, r) =\r\nmax\r\nmathrm{dist}(u, v) over all pairs u, v such that l\r\nleq u, v\r\nleq r.Compute\r\nsum_{1\r\nleq l\r\nleq r\r\nleq n}\r\nmathrm{diam}(l, r).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//Ofast,unroll-loops でちょい速くなる\n\n//VERIFY:\n//spaceships\n//do_use_segment_tree\n//CF679D\n//CF564E\n//TTPC2019M\n\n//splay tree の左側が根の方のノードに対応している\n//頂点と辺がそれぞれノードを持つ\n//light edge だけ特別扱いしている\n//それ以外のやつは，普通の頂点倍加 LCT のような感じ (c[0],c[1])\n//頂点由来のノードであれば，c[2] に light edges の情報が入る\n//light edge の部分のやつは，light edge 内の splay tree をつくる (c[0],c[2])\n//ただし c[1] にはぶら下がるパス部分の情報が入る\ntemplate<class N>\nstruct toptree{\n\tstruct node{\n\t\t//t==0 vertex\n\t\t//t==1 path edge\n\t\t//t==2 light edge\n\t\tN d;\n\t\tbool rev;\n\t\tint c[3],p;\n\t\tnode(char tt=-1):rev(false),c{-1,-1,-1},p(-1){d.t=tt;}\n\t\tvoid show(){\n\t\t\tcerr<<int(d.t)<<\" \"<<\"(\"<<c[0]<<\",\"<<c[1]<<\",\"<<c[2]<<\") \"<<p<<endl;\n\t\t}\n\t};\n\tusing np=node*;\n\tint n;\n\tvc<node> x;\n\t//unused に入ってるノードの情報は clean とは限らない\n\tvi unused;\n\ttoptree(int nn):n(nn),x(n*2-1){\n\t\tgnr(i,n,n*2-1)unused.pb(i);\n\t}\n\t//reverse が呼ばれるのは path node のみ\n\t//light edge なら rev は常に false\n\tinline void reverse(int v){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t<2);\n\t\tx[v].rev^=1;\n\t\tx[v].d.reverse();\n\t\tswap(x[v].c[0],x[v].c[1]);\n\t}\n\t//v は valid\n\t//link は張り替えるが update はしない\n\tinline void set_child(int v,int k,int c){\n\t\tassert(v!=-1);\n\t\tassert(inc(0,k,2));\n\t\tx[v].c[k]=c;\n\t\tif(c!=-1)x[c].p=v;\n\t}\n\tinline void set_light_left(int v,int c){set_child(v,0,c);}\n\tinline void set_light_right(int v,int c){set_child(v,2,c);}\n\tinline void set_path_left(int v,int c){set_child(v,0,c);}\n\tinline void set_path_right(int v,int c){set_child(v,1,c);}\n\t//v,c は valid\n\t//link は張り替えるが update はしない\n\tinline void insert_light(int v,int c){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t==0);\n\t\tassert(c!=-1);\n\t\tassert(x[c].d.t==2);\n\t\tset_light_right(c,x[v].c[2]);\n\t\tx[v].c[2]=c;\n\t\tx[c].p=v;\n\t}\n\tinline void make_path_vertex(int v){assert(inc(0,v,n-1));x[v].d.t=0;}\n\tinline void make_path_edge(int v){assert(inc(n,v,n*2-2));x[v].d.t=1;}\n\tinline void make_light(int v){assert(inc(n,v,n*2-2));assert(!x[v].rev);x[v].d.t=2;}\n\tvoid update(int v){\n\t\tassert(v!=-1);\n\t\tassert(!x[v].rev);\n\t\tx[v].d.single();\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].c[2]!=-1)x[v].d.update_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.update_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.update_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.update_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid downdate(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].rev){\n\t\t\t\tx[v].rev=false;\n\t\t\t\trep(k,2)if(x[v].c[k]!=-1)reverse(x[v].c[k]);\n\t\t\t}\n\t\t\tif(x[v].c[2]!=-1)x[v].d.push_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.push_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(!x[v].rev);\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.push_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.push_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t\tx[v].d.clear_lazy();\n\t}\n\t//0,z の辺を使って rotate\n\tvoid rotate(int v,int z){\n\t\tassert(v!=-1);\n\t\tint p=x[v].p,c;\n\t\tassert(p!=-1);\n\t\tif(x[p].c[0]==v){\n\t\t\tc=x[v].c[z];\n\t\t\tx[v].c[z]=p;\n\t\t\tx[p].c[0]=c;\n\t\t}else{\n\t\t\tc=x[v].c[0];\n\t\t\tx[v].c[0]=p;\n\t\t\tx[p].c[z]=c;\n\t\t}\n\t\tif(c!=-1)x[c].p=p;\n\t\tx[v].p=x[p].p;\n\t\tx[p].p=v;\n\t\tif(x[v].p!=-1){\n\t\t\trep(k,3)if(x[x[v].p].c[k]==p)\n\t\t\t\tx[x[v].p].c[k]=v;\n\t\t}\n\t\tupdate(p);\n\t\t//cerr<<\"After Rotate \"<<v<<endl;\n\t\t//show();\n\t}\n\t//void rotate_path(int v){rotate(v,1);}\n\t//void rotate_light(int v){rotate(v,2);}\n\t//親を辿れるだけたどり，downdate する\n\t//このあと何らかの操作で頂点 v を上に持ってこないと，計算量が崩壊する\n\tvoid prepare(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].p!=-1)prepare(x[v].p);\n\t\tdowndate(v);\n\t}\n\t//prepare されていることが前提\n\t//path/light 内で回せるだけ回す\n\t//違う種類の親との間のリンクに注意しようね\n\tvoid splay(int v){\n\t\tassert(v!=-1);\n\t\tint z=x[v].d.t<2?1:2;\n\t\twhile(1){\n\t\t\tint p=x[v].p;\n\t\t\tif(p==-1||(x[p].d.t<2)^(x[v].d.t<2))break;\n\t\t\tint q=x[p].p;\n\t\t\tif(q==-1||(x[q].d.t<2)^(x[v].d.t<2)){\n\t\t\t\trotate(v,z);\n\t\t\t}else{\n\t\t\t\tif((x[p].c[0]==v&&x[q].c[0]==p)||(x[p].c[z]==v&&x[q].c[z]==p))\n\t\t\t\t\trotate(p,z);\n\t\t\t\telse\n\t\t\t\t\trotate(v,z);\n\t\t\t\trotate(v,z);\n\t\t\t}\n\t\t}\n\t\tupdate(v);\n\t}\n\tint go_deep(int v,int k){\n\t\tassert(v!=-1);\n\t\twhile(1){\n\t\t\tdowndate(v);\n\t\t\tif(x[v].c[k]!=-1)v=x[v].c[k];\n\t\t\telse return v;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid expose(int v){\n\t\tassert(v!=-1);\n\t\tprepare(v);\n\t\tfor(int a=v;a!=-1;a=x[a].p)\n\t\t\tsplay(a);\n\t\tfor(int a=v;a!=-1;a=x[a].p){\n\t\t\tif(x[a].d.t==2){\n\t\t\t\tint b=x[a].p;\n\t\t\t\tassert(b!=-1);\n\t\t\t\tif(x[b].c[1]==-1){\n\t\t\t\t\tint l=x[a].c[0],r=x[a].c[2];\n\t\t\t\t\tif(l!=-1){\n\t\t\t\t\t\tx[l].p=-1;\n\t\t\t\t\t\tl=go_deep(l,2);\n\t\t\t\t\t\tsplay(l);\n\t\t\t\t\t\tset_light_right(l,r);\n\t\t\t\t\t\tupdate(l);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl=r;\n\t\t\t\t\t}\n\t\t\t\t\tset_light_right(b,l);\n\t\t\t\t}else{\n\t\t\t\t\tint c=x[b].c[1];\n\t\t\t\t\tx[c].p=-1;\n\t\t\t\t\tc=go_deep(c,0);\n\t\t\t\t\tsplay(c);\n\t\t\t\t\tassert(!x[c].rev);\n\t\t\t\t\tmake_light(c);\n\t\t\t\t\tset_light_left(c,x[a].c[0]);\n\t\t\t\t\tset_light_right(c,x[a].c[2]);\n\t\t\t\t\tset_light_right(b,c);\n\t\t\t\t\t//b,c は子ノードの情報を反映していない\n\t\t\t\t\tupdate(c);\n\t\t\t\t\t//c は子ノードの情報を反映した\n\t\t\t\t}\n\t\t\t\tx[a].c[0]=x[a].c[2]=-1;\n\t\t\t\tmake_path_edge(a);\n\t\t\t\tset_path_right(b,a);\n\t\t\t}\n\t\t}\n\t\t//cerr<<\"Before Splay \"<<v<<endl;\n\t\t//show();\n\t\tsplay(v);\n\t\t//cerr<<\"After Expose \"<<v<<endl;\n\t\t//show();\n\t}\n\ttemplate<class...Args>\n\tvoid init_vertex(int v,Args&&...args){\n\t\tassert(inc(0,v,n-1));\n\t\tx[v]=node(0);\n\t\tx[v].d.init_vertex(v,forward<Args>(args)...);\n\t}\n\ttemplate<class...Args>\n\tvoid init_edge(int v,char t,int a,int b,Args&&...args){\n\t\tx[v]=node(t);\n\t\tx[v].d.init_edge(a,b,forward<Args>(args)...);\n\t}\n\tvoid evert(int v){\n\t\tassert(inc(0,v,n-1));\n\t\texpose(v);\n\t\tif(x[v].c[0]!=-1){\n\t\t\tint c=x[v].c[0];\n\t\t\tx[v].c[0]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,1);\n\t\t\tsplay(c);\n\t\t\treverse(c);\n\t\t\tassert(x[c].rev);\n\t\t\tx[c].rev=false;\n\t\t\treverse(x[c].c[1]);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(v,c);\n\t\t\t//v,c は子ノードの情報を反映していない\n\t\t\tupdate(c);\n\t\t\tupdate(v);\n\t\t\t//v,c は子ノードの情報を反映した\n\t\t}\n\t}\n\t//a と b を辺で結び (a が親側)，辺の index を返す\n\t//もしもともと連結であれば，-1 を返す\n\ttemplate<class...Args>\n\tint link(int a,int b,Args&&...args){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\tevert(b);\n\t\tif(x[a].p==-1){\n\t\t\tassert(si(unused));\n\t\t\tint e=unused.back();unused.pop_back();\n\t\t\tinit_edge(e,2,a,b,forward<Args>(args)...);\n\t\t\tset_path_right(e,b);\n\t\t\tinsert_light(a,e);\n\t\t\t//a,e は子ノードの情報を反映していない\n\t\t\tupdate(e);\n\t\t\tupdate(a);\n\t\t\t//a,e は子ノードの情報を反映した\n\t\t\treturn e;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t//cut したあとの木のノードのペア(親，子)を返す\n\tpi cut(int e){\n\t\tassert(inc(n,e,n*2-2));\n\t\texpose(e);\n\t\tpi res(x[e].c[0],x[e].c[1]);\n\t\tif(res.a!=-1)x[res.a].p=-1;\n\t\tif(res.b!=-1)x[res.b].p=-1;\n\t\tx[e].d.t=-1;\n\t\tunused.pb(e);\n\t\treturn res;\n\t}\n\tint lca(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\texpose(b);\n\t\tif(x[a].p==-1)return -1;\n\t\tint d=a;\n\t\twhile(a!=b){\n\t\t\tint p=x[a].p;\n\t\t\tif(x[a].d.t==2&&x[p].d.t<2)d=p;\n\t\t\telse if(p==b&&x[p].c[1]==a)d=b;\n\t\t\ta=p;\n\t\t}\n\t\tassert(inc(0,d,n-1));\n\t\treturn d;\n\t}\n\tvoid expose_path(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\tevert(a);\n\t\texpose(b);\n\t\tint c=x[b].c[1];\n\t\tif(c!=-1){\n\t\t\tx[b].c[1]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,0);\n\t\t\tsplay(c);\n\t\t\tassert(!x[c].rev);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(b,c);\n\t\t\tupdate(c);\n\t\t\tupdate(b);\n\t\t}\n\t}\n\tN&operator[](int i){return x[i].d;}\n\tvoid show(){\n\t\trep(i,n*2-1)if(x[i].d.t!=-1){\n\t\t\tcerr<<i<<\" \";\n\t\t\tx[i].show();\n\t\t}\n\t}\n\t//init_vertex は終了しているとする\n\t//E.idx が必要．これに従って辺に id を振る\n\ttemplate<class H> void init_from_hld(const H&hld){\n\t\tunused.clear();\n\t\tauto subtree=[&](auto subtree_self,int root)->int{\n\t\t\tauto path=[&](auto path_self,int l,int r)->int{\n\t\t\t\tif(r<l)return -1;\n\t\t\t\tconst int m=(l+r)/2;\n\t\t\t\tint v=hld.ni[(m+1)/2],z;\n\t\t\t\tif(m%2==0){\n\t\t\t\t\tz=v;\n\t\t\t\t\tauto light=[&](auto light_self,int a,int b)->int{\n\t\t\t\t\t\tif(b<a)return -1;\n\t\t\t\t\t\tconst int c=(a+b)/2;\n\t\t\t\t\t\tint u=hld.g[v][c],w=hld.pe[u].idx+n;\n\t\t\t\t\t\tinit_edge(w,2,v,u,hld.pe[u]);\n\t\t\t\t\t\tset_path_right(w,subtree_self(subtree_self,u));\n\t\t\t\t\t\tset_light_left(w,light_self(light_self,a,c-1));\n\t\t\t\t\t\tset_light_right(w,light_self(light_self,c+1,b));\n\t\t\t\t\t\tupdate(w);\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t};\n\t\t\t\t\tset_light_right(z,light(light,1,si(hld.g[v])-1));\n\t\t\t\t}else{\n\t\t\t\t\tz=hld.pe[v].idx+n;\n\t\t\t\t\tinit_edge(z,1,hld.par[v],v,hld.pe[v]);\n\t\t\t\t}\n\t\t\t\tset_path_left(z,path_self(path_self,l,m-1));\n\t\t\t\tset_path_right(z,path_self(path_self,m+1,r));\n\t\t\t\tupdate(z);\n\t\t\t\treturn z;\n\t\t\t};\n\t\t\treturn path(path,hld.in[root]*2,(hld.in[root]+hld.hei[root]-1)*2);\n\t\t};\n\t\tsubtree(subtree,hld.rt);\n\t}\n};\n\n//内部でグラフをいじるから in,out を使うときは注意\n//hei[v] -> heavy edge で潜っていった時，自分含めて何個あるか\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\tvi index;\n\t//vs を含む virtual tree を返す\n\t//返すのは virtual tree に使われた頂点と，辺の集合\n\t//辺の端点は，virtual tree における番号\n\t//元の木における番号を virtual tree の頂点番号に写すのが，index という変数\n\t//辺は ch->par の順\n\t//virtual tree は行き掛け順で番号がついている\n\t//特に，頂点 0 が根になるようにできている\n\tpair<vi,vc<pi>> tree_compress(vi vs){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tvc<pi> es;\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\treturn mp(vs,es);\n\t}\n};\n\n//Lyft Level 5 Challenge 2018 - Final F\n//CF635F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\nstruct E{\n\tint to,idx;\n\toperator int()const{return to;}\n};\n//init_from_hld(HLD<E>(t,0)) とかにつかう\n\n//まず rep(i,n)t.init_vertex(i) を最初にやる\n\n//init_vertex(v,...): 頂点に対応するノードを初期化する\n//init_edge(a,b,...): 辺に対応するノードを初期化する，a が親側\n//single(): そのノード単体だけの情報に更新する(部分木の情報を忘れる)\n//reverse(): 反転\n//update_path(k,N): path 上で，(k==0?左:右)に path ノードを追加する\n//=compress\n//update_light: light ツリー上でノードを追加する（原理的に左右の区別がない）\n//=rake\n//これは，頂点単体のノードにその部分木の情報を伝える際にも呼ばれる\n//これで実用上は困らないはずだけど，もしそうでなければ，ごめん\n//push_path(k,N), push_light(N): push する，update と同様\n//clear_lazy(): lazy 系のデータを clear する \n\n//木が固定されている場合\n//ノードのマージされ方が限定され，実装が楽になるケースがある\n//vertex は, light -> path の順でマージしてる\n//light edge は，path -> light の順でマージしてる\n\n//t がノードの状態を表す変数で，絶対必要\n//これをうっかり書き換えるなどのミスが予想される\n//t==0 vertex\n//t==1 path edge\n//t==2 light edge\n\n//CF691F\n//activeな頂点への距離の総和を求めるやつ\n//木が static だと思いこんでいる\n//flip のあと update しないとね\nstruct N{\n\tchar t;\n\tint rw,cnt,len[2];\n\tll ans,s[2];\n\tvoid init_vertex(int){\n\t\trw=0;\n\t\tsingle();\n\t}\n\tvoid init_edge(int,int){\n\t\trw=0;\n\t\tsingle();\n\t}\n\tvoid init_edge(int a,int b,const E&){\n\t\tinit_edge(a,b);\n\t}\n\tvoid single(){\n\t\tif(t==0){\n\t\t\tcnt=rw;\n\t\t\tlen[0]=len[1]=0;\n\t\t\tans=0;\n\t\t\ts[0]=s[1]=0;\n\t\t}\n\t\telse{\n\t\t\tcnt=rw;\n\t\t\tlen[0]=len[1]=1;\n\t\t\tans=0;\n\t\t\ts[0]=s[1]=cnt;\n\t\t}\n\t}\n\tvoid reverse(){assert(false);}\n\tvoid update_path(int dir,const N&x_){\n\t\tN x[2]{x_,*this};\n\t\tif(dir)swap(x[0],x[1]);\n\t\tcnt=x[0].cnt+x[1].cnt;\n\t\trep(k,2)len[k]=x[k].len[k];\n\t\tlen[dir]+=x[0].len[1]+x[1].len[0];\n\t\tans+=x[dir].s[dir^1]+ll(x[dir^1].len[dir])*x[dir].cnt;\n\t\trep(k,2)s[k]=x[k].s[k]+x[k^1].s[k]+ll(x[k].len[0]+x[k].len[1])*x[k^1].cnt;\n\t}\n\tvoid update_light(const N& x){\n\t\tcnt+=x.cnt;\n\t\tans+=x.s[0]+ll(len[0])*x.cnt;\n\t\ts[0]+=x.s[0];\n\t\ts[1]+=x.s[0]+ll(len[0]+len[1])*x.cnt;\n\t}\n\tvoid push_path(int,N&){\n\t}\n\tvoid push_light(N&){\n\t}\n\tvoid clear_lazy(){\n\t}\n\t\n\tvoid add(int v){\n\t\trw+=v;\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<E> t(n);\n\tvvc<int> dt(n*2-1);\n\trep(i,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb({b,i});\n\t\tt[b].pb({a,i});\n\t\tdt[a].pb(n+i);\n\t\tdt[b].pb(n+i);\n\t\tdt[n+i].pb(a);\n\t\tdt[n+i].pb(b);\n\t}\n\tdoubling<int> dd(dt,0);\n\ttoptree<N> x(n);\n\trep(i,n)x.init_vertex(i);\n\tx.init_from_hld(HLD<E>(t,0));\n\tll ans=0;\n\tauto mg=[&](pi a,pi b){\n\t\tint d=dd.len(a.a,b.a);\n\t\tif(a.b>=d+b.b)return a;\n\t\tif(b.b>=d+a.b)return b;\n\t\tint w=d+a.b+b.b;\n\t\tassert(w%2==0);\n\t\tw/=2;\n\t\tint z=w-a.b;\n\t\treturn pi(dd.jump(a.a,b.a,z),w);\n\t};\n\tauto getmax=[&](pi a,pi b){\n\t\tint d=dd.len(a.a,b.a);\n\t\treturn max({a.b*2,b.b*2,a.b+d+b.b});\n\t};\n\tvi unko(n*2-1);\n\tauto upd=[&](int v,int w){\n\t\tunko[v]+=w;\n\t\t\n\t\tx.expose(v);\n\t\tx[v].add(w);\n\t\tx.update(v);\n\t};\n\tauto getsum=[&](int v){\n\t\tx.expose(v);\n\t\t\n\t\t#ifdef LOCAL\n\t\tint res=0;\n\t\t{\n\t\t\tauto rec=[&](auto self,int i,int p,int d)->void{\n\t\t\t\tif(unko[i])res+=d*unko[i];\n\t\t\t\tfor(auto to:dt[i])if(to!=p)\n\t\t\t\t\tself(self,to,i,d+1);\n\t\t\t};\n\t\t\trec(rec,v,-1,0);\n\t\t}\n\t\tassert(res==x[v].ans);\n\t\t#endif\n\t\t\n\t\treturn x[v].ans;\n\t};\n\tvc<pi> w(n);\n\tvc<ll> sum(n+1);\n\tauto rec=[&](auto self,int l,int r)->void{\n\t\tif(l+1==r)return;\n\t\tint m=(l+r)/2;\n\t\tw[m]=pi(m,0);\n\t\trng(i,m+1,r)w[i]=mg(pi(i,0),w[i-1]);\n\t\tsum[m]=0;\n\t\trng(i,m,r)sum[i+1]=sum[i]+w[i].b;\n\t\tpi cur;\n\t\tint b=m,e=m;\n\t\tgnr(i,l,m){\n\t\t\tif(i==m-1){\n\t\t\t\tcur=pi(i,0);\n\t\t\t}else{\n\t\t\t\tcur=mg(pi(i,0),cur);\n\t\t\t}\n\t\t\twhile(e<r){\n\t\t\t\tif(getmax(cur,w[e])>w[e].b*2){\n\t\t\t\t\tupd(w[e++].a,1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(b<e){\n\t\t\t\tif(cur.b*2>=getmax(cur,w[b])){\n\t\t\t\t\tupd(w[b++].a,-1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=cur.b*2*ll(b-m);\n\t\t\tans+=cur.b*ll(e-b);\n\t\t\tans+=sum[e]-sum[b];\n\t\t\tans+=getsum(cur.a);\n\t\t\tans+=(sum[r]-sum[e])*2;\n\t\t\t/*vi baka(n*2-1);\n\t\t\trng(j,m,r){\n\t\t\t\tint val=getmax(cur,w[j]);\n\t\t\t\tans+=val;\n\t\t\t\tif(j<b){\n\t\t\t\t\tassert(val==cur.b*2);\n\t\t\t\t}else if(j<e){\n\t\t\t\t\tint tmp=cur.b+w[j].b+dd.len(cur.a,w[j].a);\n\t\t\t\t\tassert(val==tmp);\n\t\t\t\t\tans-=+dd.len(cur.a,w[j].a);\n\t\t\t\t\tbaka[w[j].a]=1;\n\t\t\t\t}else{\n\t\t\t\t\tassert(val==w[j].b*2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(unko!=baka){\n\t\t\t\tdmp2(b,e);\n\t\t\t\tdmp(unko);\n\t\t\t\tdmp(baka);\n\t\t\t}\n\t\t\tassert(unko==baka);*/\n\t\t}\n\t\twhile(b<e)upd(w[b++].a,-1);\n\t\tself(self,l,m);\n\t\tself(self,m,r);\n\t};\n\trec(rec,0,n);\n\tprint(ans/2);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Range Diameter Sum.json",
    "editorial_link": "https://codeforces.com//blog/entry/85750",
    "editorial": "Please bear with my formal style for this one as my hand-waving skills\r\nare too weak to explain this properly.Weâll use the \"divide-and-conquer\"\r\nstrategy. Let us implement a recursive procedure that will compute the\r\nsum . It will do so as follows: If , then answer is trivially .\r\nOtherwise, choose , and compute the following sum: . The only entries\r\nthat are not accounted for satisfy either or . Compute their total as ,\r\nand return the total answer.Of course, is the tricky part. Weâll need\r\nsome preparation to compute it. To make arguments cleaner, let us\r\nintroduce an vertex in the middle of every edge, subdividing it into\r\ntwo. Weâll refer to new vertices as vertices, and the old vertices as\r\nvertices. Since all distances are doubled, we will have to divide the\r\nanswer by two in the end.We will define a in the tree as the set of all\r\nvertices at distance at most from the vertex . We also assume that if\r\nthere are at least vertices in exactly at distance from , otherwise\r\ndecrease accordingly.For a set of vertices we define as a circle of\r\nsmallest radius containing all vertices of . If we assume that all\r\nvertices of are , then is unique. Indeed, after subdividing all\r\ndistances among are even, thus in we must have , and is the unique\r\ndiameter midpoint. We can see that if , then has at least two vertices\r\nat distance from the covering circle center , namely, the diameter\r\nendpoints. If a circle contains two proper vertices , then it also\r\ncontains the midpoint on the path between , and further . Say, for the\r\nvertex we have . This inequality is strict: only when and are in the\r\nsame subtree with respect to . If we assume that respective inequalities\r\nfor are both strict, then both are in the same subtree of , in which\r\ncase can not be the midpoint. Otherwise, say, for we have , and by\r\nsimple rearrangement.An immediate of this lemma is this: if a circle\r\ncontains a set of proper vertices , it also contains . We apply the\r\nlemma to the midpoint of , which is also the center of , to establish .\r\nThen, for any vertex of we , thus . Let , be two non-empty sets of\r\nproper vertices. Then the smallest covering circle can be found by only\r\nknowing and , by the following rule: If , then . If , then . Let none of\r\nand contain the other one. Then, has radius equal to (which is asserted\r\nto be an integer), and its center is located on the unique path at\r\ndistance (which is asserted to be an integer) from . The first two cases\r\nare somewhat easy. Say, in the first case has to contain , then it must\r\ncontain , and then it contains by default.Now, assume the latter case.\r\nAny two vertices , satisfy , thus . Now, let and be diameter endpoints\r\nof and respectively. Here we can even choose, say, outside of , since ,\r\nsimilarly choose . We then must have , thus has radius at least half of\r\nthat, and is the only possible center candidate.When one or both of and\r\nhas zero radius, the claim can established pretty much directly.The last\r\nlemma allows us to maintain for any set , and further \"merge\" and to\r\nobtain , since all we need is distances between vertices, and finding a\r\nvertex on a at certain distance from . We can also efficiently check if\r\ncontains by verifying . All of that can be done with binary lifting and\r\nLCA manipulations in per operation.At last, letâs get back to the\r\ndivide-and-conquer step. Let us find circles , and for all relevant . We\r\nhave , and is a merge of and for any smaller ; similar for .Now, letâs\r\nconsider the sum for some . is equal to twice the radius of the merge of\r\nand . Consider increasing from to . Since for any , we have three\r\ninteresting ranges for , in order from left to right: : ; : and are not\r\ncontained in each other; : .In the first range , and in the third range\r\n. If we know the boundaries and , then these can be accounted for with\r\nprefix sums on (and simple multiplcation for ).In the second range we\r\nhave to sum up . Again, summands and are accounted in the same way. Only\r\nremains.Instead of computing this directly right now, consider how and\r\nchange as decreases from to . We have , thus we can conclude that and\r\nboth , and the range is a \"sliding window\" with both endpoints moving to\r\nthe right. Boundaries and can thus be maintained with the two-pointers\r\napproach, and vertices in the range can be maintained with a queue,\r\nwhere vertices enter from the right and leave from the left.On top of\r\nthe queue that supports \"push-back\" and \"pop-front\", weâd also like to\r\nquery \"sum of distances from an arbitrary vertex to all vertices in the\r\nqueue\". To this end (and only this), we will have to use in its most\r\nbasic form. Itâs fair to say that the margins of this explanation are\r\nalready too crowded for a proper explanation of this. In short, we can\r\nadd/remove vertices and query the distance sum in time. This concludes\r\nthe divide-and-conquer step description.With the usual\r\ndivide-and-conquer time analysis we arrive at an solution.\r\n",
    "hint": []
}