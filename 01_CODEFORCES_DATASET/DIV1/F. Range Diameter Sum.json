{"link": "https://codeforces.com//contest/1458/problem/F", "problemId": "837947", "problem_idx": "F", "shortId": "1458F", "contest_number": "1458", "problem_submissions": {"C": [101749748, 101754548, 101742006, 101765508, 101760904, 101735121, 101758711, 101733697, 101742587, 101742771, 101744109, 101764706, 101753517, 101758458, 103876484, 101781534], "D": [101742255, 101733305, 101750551, 101754872, 101747447, 101747468, 101737535, 101761632, 101756331, 101755812, 102023685, 101761131, 101768544, 101764759, 103932701, 101747159], "E": [101737863, 101746540, 101766037, 101749099, 101757343, 101752859, 101763081, 101766464, 101774328, 101752190, 101746555, 101751393, 101757105], "B": [101728732, 101721253, 101733062, 101725510, 101763762, 101727209, 101722722, 101732397, 101727564, 101724112, 101730858, 101735965, 101740443, 101732340, 101727159, 101744347, 101723637, 101730363, 101730317], "A": [101720547, 101718495, 101723686, 101718493, 101718664, 101719145, 101718463, 101718584, 101718634, 101718787, 101720142, 101718675, 101719084, 101722215, 101718515, 101719224, 101718795, 101718781, 101721089], "F": [102925392, 102542392, 102542303, 103841307]}, "name": "F. Range Diameter Sum", "statement": "You are given a tree with n vertices numbered 1,\r\nldots, n. A tree is a connected simple graph without cycles.Let\r\nmathrm{dist}(u, v) be the number of edges in the unique simple path\r\nconnecting vertices u and v.Let\r\nmathrm{diam}(l, r) =\r\nmax\r\nmathrm{dist}(u, v) over all pairs u, v such that l\r\nleq u, v\r\nleq r.Compute\r\nsum_{1\r\nleq l\r\nleq r\r\nleq n}\r\nmathrm{diam}(l, r).\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//Ofast,unroll-loops \u3067\u3061\u3087\u3044\u901f\u304f\u306a\u308b\n\n//VERIFY:\n//spaceships\n//do_use_segment_tree\n//CF679D\n//CF564E\n//TTPC2019M\n\n//splay tree \u306e\u5de6\u5074\u304c\u6839\u306e\u65b9\u306e\u30ce\u30fc\u30c9\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\n//\u9802\u70b9\u3068\u8fba\u304c\u305d\u308c\u305e\u308c\u30ce\u30fc\u30c9\u3092\u6301\u3064\n//light edge \u3060\u3051\u7279\u5225\u6271\u3044\u3057\u3066\u3044\u308b\n//\u305d\u308c\u4ee5\u5916\u306e\u3084\u3064\u306f\uff0c\u666e\u901a\u306e\u9802\u70b9\u500d\u52a0 LCT \u306e\u3088\u3046\u306a\u611f\u3058 (c[0],c[1])\n//\u9802\u70b9\u7531\u6765\u306e\u30ce\u30fc\u30c9\u3067\u3042\u308c\u3070\uff0cc[2] \u306b light edges \u306e\u60c5\u5831\u304c\u5165\u308b\n//light edge \u306e\u90e8\u5206\u306e\u3084\u3064\u306f\uff0clight edge \u5185\u306e splay tree \u3092\u3064\u304f\u308b (c[0],c[2])\n//\u305f\u3060\u3057 c[1] \u306b\u306f\u3076\u3089\u4e0b\u304c\u308b\u30d1\u30b9\u90e8\u5206\u306e\u60c5\u5831\u304c\u5165\u308b\ntemplate<class N>\nstruct toptree{\n\tstruct node{\n\t\t//t==0 vertex\n\t\t//t==1 path edge\n\t\t//t==2 light edge\n\t\tN d;\n\t\tbool rev;\n\t\tint c[3],p;\n\t\tnode(char tt=-1):rev(false),c{-1,-1,-1},p(-1){d.t=tt;}\n\t\tvoid show(){\n\t\t\tcerr<<int(d.t)<<\" \"<<\"(\"<<c[0]<<\",\"<<c[1]<<\",\"<<c[2]<<\") \"<<p<<endl;\n\t\t}\n\t};\n\tusing np=node*;\n\tint n;\n\tvc<node> x;\n\t//unused \u306b\u5165\u3063\u3066\u308b\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u306f clean \u3068\u306f\u9650\u3089\u306a\u3044\n\tvi unused;\n\ttoptree(int nn):n(nn),x(n*2-1){\n\t\tgnr(i,n,n*2-1)unused.pb(i);\n\t}\n\t//reverse \u304c\u547c\u3070\u308c\u308b\u306e\u306f path node \u306e\u307f\n\t//light edge \u306a\u3089 rev \u306f\u5e38\u306b false\n\tinline void reverse(int v){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t<2);\n\t\tx[v].rev^=1;\n\t\tx[v].d.reverse();\n\t\tswap(x[v].c[0],x[v].c[1]);\n\t}\n\t//v \u306f valid\n\t//link \u306f\u5f35\u308a\u66ff\u3048\u308b\u304c update \u306f\u3057\u306a\u3044\n\tinline void set_child(int v,int k,int c){\n\t\tassert(v!=-1);\n\t\tassert(inc(0,k,2));\n\t\tx[v].c[k]=c;\n\t\tif(c!=-1)x[c].p=v;\n\t}\n\tinline void set_light_left(int v,int c){set_child(v,0,c);}\n\tinline void set_light_right(int v,int c){set_child(v,2,c);}\n\tinline void set_path_left(int v,int c){set_child(v,0,c);}\n\tinline void set_path_right(int v,int c){set_child(v,1,c);}\n\t//v,c \u306f valid\n\t//link \u306f\u5f35\u308a\u66ff\u3048\u308b\u304c update \u306f\u3057\u306a\u3044\n\tinline void insert_light(int v,int c){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t==0);\n\t\tassert(c!=-1);\n\t\tassert(x[c].d.t==2);\n\t\tset_light_right(c,x[v].c[2]);\n\t\tx[v].c[2]=c;\n\t\tx[c].p=v;\n\t}\n\tinline void make_path_vertex(int v){assert(inc(0,v,n-1));x[v].d.t=0;}\n\tinline void make_path_edge(int v){assert(inc(n,v,n*2-2));x[v].d.t=1;}\n\tinline void make_light(int v){assert(inc(n,v,n*2-2));assert(!x[v].rev);x[v].d.t=2;}\n\tvoid update(int v){\n\t\tassert(v!=-1);\n\t\tassert(!x[v].rev);\n\t\tx[v].d.single();\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].c[2]!=-1)x[v].d.update_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.update_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.update_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.update_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid downdate(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].rev){\n\t\t\t\tx[v].rev=false;\n\t\t\t\trep(k,2)if(x[v].c[k]!=-1)reverse(x[v].c[k]);\n\t\t\t}\n\t\t\tif(x[v].c[2]!=-1)x[v].d.push_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.push_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(!x[v].rev);\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.push_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.push_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t\tx[v].d.clear_lazy();\n\t}\n\t//0,z \u306e\u8fba\u3092\u4f7f\u3063\u3066 rotate\n\tvoid rotate(int v,int z){\n\t\tassert(v!=-1);\n\t\tint p=x[v].p,c;\n\t\tassert(p!=-1);\n\t\tif(x[p].c[0]==v){\n\t\t\tc=x[v].c[z];\n\t\t\tx[v].c[z]=p;\n\t\t\tx[p].c[0]=c;\n\t\t}else{\n\t\t\tc=x[v].c[0];\n\t\t\tx[v].c[0]=p;\n\t\t\tx[p].c[z]=c;\n\t\t}\n\t\tif(c!=-1)x[c].p=p;\n\t\tx[v].p=x[p].p;\n\t\tx[p].p=v;\n\t\tif(x[v].p!=-1){\n\t\t\trep(k,3)if(x[x[v].p].c[k]==p)\n\t\t\t\tx[x[v].p].c[k]=v;\n\t\t}\n\t\tupdate(p);\n\t\t//cerr<<\"After Rotate \"<<v<<endl;\n\t\t//show();\n\t}\n\t//void rotate_path(int v){rotate(v,1);}\n\t//void rotate_light(int v){rotate(v,2);}\n\t//\u89aa\u3092\u8fbf\u308c\u308b\u3060\u3051\u305f\u3069\u308a\uff0cdowndate \u3059\u308b\n\t//\u3053\u306e\u3042\u3068\u4f55\u3089\u304b\u306e\u64cd\u4f5c\u3067\u9802\u70b9 v \u3092\u4e0a\u306b\u6301\u3063\u3066\u3053\u306a\u3044\u3068\uff0c\u8a08\u7b97\u91cf\u304c\u5d29\u58ca\u3059\u308b\n\tvoid prepare(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].p!=-1)prepare(x[v].p);\n\t\tdowndate(v);\n\t}\n\t//prepare \u3055\u308c\u3066\u3044\u308b\u3053\u3068\u304c\u524d\u63d0\n\t//path/light \u5185\u3067\u56de\u305b\u308b\u3060\u3051\u56de\u3059\n\t//\u9055\u3046\u7a2e\u985e\u306e\u89aa\u3068\u306e\u9593\u306e\u30ea\u30f3\u30af\u306b\u6ce8\u610f\u3057\u3088\u3046\u306d\n\tvoid splay(int v){\n\t\tassert(v!=-1);\n\t\tint z=x[v].d.t<2?1:2;\n\t\twhile(1){\n\t\t\tint p=x[v].p;\n\t\t\tif(p==-1||(x[p].d.t<2)^(x[v].d.t<2))break;\n\t\t\tint q=x[p].p;\n\t\t\tif(q==-1||(x[q].d.t<2)^(x[v].d.t<2)){\n\t\t\t\trotate(v,z);\n\t\t\t}else{\n\t\t\t\tif((x[p].c[0]==v&&x[q].c[0]==p)||(x[p].c[z]==v&&x[q].c[z]==p))\n\t\t\t\t\trotate(p,z);\n\t\t\t\telse\n\t\t\t\t\trotate(v,z);\n\t\t\t\trotate(v,z);\n\t\t\t}\n\t\t}\n\t\tupdate(v);\n\t}\n\tint go_deep(int v,int k){\n\t\tassert(v!=-1);\n\t\twhile(1){\n\t\t\tdowndate(v);\n\t\t\tif(x[v].c[k]!=-1)v=x[v].c[k];\n\t\t\telse return v;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid expose(int v){\n\t\tassert(v!=-1);\n\t\tprepare(v);\n\t\tfor(int a=v;a!=-1;a=x[a].p)\n\t\t\tsplay(a);\n\t\tfor(int a=v;a!=-1;a=x[a].p){\n\t\t\tif(x[a].d.t==2){\n\t\t\t\tint b=x[a].p;\n\t\t\t\tassert(b!=-1);\n\t\t\t\tif(x[b].c[1]==-1){\n\t\t\t\t\tint l=x[a].c[0],r=x[a].c[2];\n\t\t\t\t\tif(l!=-1){\n\t\t\t\t\t\tx[l].p=-1;\n\t\t\t\t\t\tl=go_deep(l,2);\n\t\t\t\t\t\tsplay(l);\n\t\t\t\t\t\tset_light_right(l,r);\n\t\t\t\t\t\tupdate(l);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl=r;\n\t\t\t\t\t}\n\t\t\t\t\tset_light_right(b,l);\n\t\t\t\t}else{\n\t\t\t\t\tint c=x[b].c[1];\n\t\t\t\t\tx[c].p=-1;\n\t\t\t\t\tc=go_deep(c,0);\n\t\t\t\t\tsplay(c);\n\t\t\t\t\tassert(!x[c].rev);\n\t\t\t\t\tmake_light(c);\n\t\t\t\t\tset_light_left(c,x[a].c[0]);\n\t\t\t\t\tset_light_right(c,x[a].c[2]);\n\t\t\t\t\tset_light_right(b,c);\n\t\t\t\t\t//b,c \u306f\u5b50\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u3092\u53cd\u6620\u3057\u3066\u3044\u306a\u3044\n\t\t\t\t\tupdate(c);\n\t\t\t\t\t//c \u306f\u5b50\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u3092\u53cd\u6620\u3057\u305f\n\t\t\t\t}\n\t\t\t\tx[a].c[0]=x[a].c[2]=-1;\n\t\t\t\tmake_path_edge(a);\n\t\t\t\tset_path_right(b,a);\n\t\t\t}\n\t\t}\n\t\t//cerr<<\"Before Splay \"<<v<<endl;\n\t\t//show();\n\t\tsplay(v);\n\t\t//cerr<<\"After Expose \"<<v<<endl;\n\t\t//show();\n\t}\n\ttemplate<class...Args>\n\tvoid init_vertex(int v,Args&&...args){\n\t\tassert(inc(0,v,n-1));\n\t\tx[v]=node(0);\n\t\tx[v].d.init_vertex(v,forward<Args>(args)...);\n\t}\n\ttemplate<class...Args>\n\tvoid init_edge(int v,char t,int a,int b,Args&&...args){\n\t\tx[v]=node(t);\n\t\tx[v].d.init_edge(a,b,forward<Args>(args)...);\n\t}\n\tvoid evert(int v){\n\t\tassert(inc(0,v,n-1));\n\t\texpose(v);\n\t\tif(x[v].c[0]!=-1){\n\t\t\tint c=x[v].c[0];\n\t\t\tx[v].c[0]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,1);\n\t\t\tsplay(c);\n\t\t\treverse(c);\n\t\t\tassert(x[c].rev);\n\t\t\tx[c].rev=false;\n\t\t\treverse(x[c].c[1]);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(v,c);\n\t\t\t//v,c \u306f\u5b50\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u3092\u53cd\u6620\u3057\u3066\u3044\u306a\u3044\n\t\t\tupdate(c);\n\t\t\tupdate(v);\n\t\t\t//v,c \u306f\u5b50\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u3092\u53cd\u6620\u3057\u305f\n\t\t}\n\t}\n\t//a \u3068 b \u3092\u8fba\u3067\u7d50\u3073 (a \u304c\u89aa\u5074)\uff0c\u8fba\u306e index \u3092\u8fd4\u3059\n\t//\u3082\u3057\u3082\u3068\u3082\u3068\u9023\u7d50\u3067\u3042\u308c\u3070\uff0c-1 \u3092\u8fd4\u3059\n\ttemplate<class...Args>\n\tint link(int a,int b,Args&&...args){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\tevert(b);\n\t\tif(x[a].p==-1){\n\t\t\tassert(si(unused));\n\t\t\tint e=unused.back();unused.pop_back();\n\t\t\tinit_edge(e,2,a,b,forward<Args>(args)...);\n\t\t\tset_path_right(e,b);\n\t\t\tinsert_light(a,e);\n\t\t\t//a,e \u306f\u5b50\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u3092\u53cd\u6620\u3057\u3066\u3044\u306a\u3044\n\t\t\tupdate(e);\n\t\t\tupdate(a);\n\t\t\t//a,e \u306f\u5b50\u30ce\u30fc\u30c9\u306e\u60c5\u5831\u3092\u53cd\u6620\u3057\u305f\n\t\t\treturn e;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t//cut \u3057\u305f\u3042\u3068\u306e\u6728\u306e\u30ce\u30fc\u30c9\u306e\u30da\u30a2(\u89aa\uff0c\u5b50)\u3092\u8fd4\u3059\n\tpi cut(int e){\n\t\tassert(inc(n,e,n*2-2));\n\t\texpose(e);\n\t\tpi res(x[e].c[0],x[e].c[1]);\n\t\tif(res.a!=-1)x[res.a].p=-1;\n\t\tif(res.b!=-1)x[res.b].p=-1;\n\t\tx[e].d.t=-1;\n\t\tunused.pb(e);\n\t\treturn res;\n\t}\n\tint lca(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\texpose(b);\n\t\tif(x[a].p==-1)return -1;\n\t\tint d=a;\n\t\twhile(a!=b){\n\t\t\tint p=x[a].p;\n\t\t\tif(x[a].d.t==2&&x[p].d.t<2)d=p;\n\t\t\telse if(p==b&&x[p].c[1]==a)d=b;\n\t\t\ta=p;\n\t\t}\n\t\tassert(inc(0,d,n-1));\n\t\treturn d;\n\t}\n\tvoid expose_path(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\tevert(a);\n\t\texpose(b);\n\t\tint c=x[b].c[1];\n\t\tif(c!=-1){\n\t\t\tx[b].c[1]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,0);\n\t\t\tsplay(c);\n\t\t\tassert(!x[c].rev);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(b,c);\n\t\t\tupdate(c);\n\t\t\tupdate(b);\n\t\t}\n\t}\n\tN&operator[](int i){return x[i].d;}\n\tvoid show(){\n\t\trep(i,n*2-1)if(x[i].d.t!=-1){\n\t\t\tcerr<<i<<\" \";\n\t\t\tx[i].show();\n\t\t}\n\t}\n\t//init_vertex \u306f\u7d42\u4e86\u3057\u3066\u3044\u308b\u3068\u3059\u308b\n\t//E.idx \u304c\u5fc5\u8981\uff0e\u3053\u308c\u306b\u5f93\u3063\u3066\u8fba\u306b id \u3092\u632f\u308b\n\ttemplate<class H> void init_from_hld(const H&hld){\n\t\tunused.clear();\n\t\tauto subtree=[&](auto subtree_self,int root)->int{\n\t\t\tauto path=[&](auto path_self,int l,int r)->int{\n\t\t\t\tif(r<l)return -1;\n\t\t\t\tconst int m=(l+r)/2;\n\t\t\t\tint v=hld.ni[(m+1)/2],z;\n\t\t\t\tif(m%2==0){\n\t\t\t\t\tz=v;\n\t\t\t\t\tauto light=[&](auto light_self,int a,int b)->int{\n\t\t\t\t\t\tif(b<a)return -1;\n\t\t\t\t\t\tconst int c=(a+b)/2;\n\t\t\t\t\t\tint u=hld.g[v][c],w=hld.pe[u].idx+n;\n\t\t\t\t\t\tinit_edge(w,2,v,u,hld.pe[u]);\n\t\t\t\t\t\tset_path_right(w,subtree_self(subtree_self,u));\n\t\t\t\t\t\tset_light_left(w,light_self(light_self,a,c-1));\n\t\t\t\t\t\tset_light_right(w,light_self(light_self,c+1,b));\n\t\t\t\t\t\tupdate(w);\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t};\n\t\t\t\t\tset_light_right(z,light(light,1,si(hld.g[v])-1));\n\t\t\t\t}else{\n\t\t\t\t\tz=hld.pe[v].idx+n;\n\t\t\t\t\tinit_edge(z,1,hld.par[v],v,hld.pe[v]);\n\t\t\t\t}\n\t\t\t\tset_path_left(z,path_self(path_self,l,m-1));\n\t\t\t\tset_path_right(z,path_self(path_self,m+1,r));\n\t\t\t\tupdate(z);\n\t\t\t\treturn z;\n\t\t\t};\n\t\t\treturn path(path,hld.in[root]*2,(hld.in[root]+hld.hei[root]-1)*2);\n\t\t};\n\t\tsubtree(subtree,hld.rt);\n\t}\n};\n\n//\u5185\u90e8\u3067\u30b0\u30e9\u30d5\u3092\u3044\u3058\u308b\u304b\u3089 in,out \u3092\u4f7f\u3046\u3068\u304d\u306f\u6ce8\u610f\n//hei[v] -> heavy edge \u3067\u6f5c\u3063\u3066\u3044\u3063\u305f\u6642\uff0c\u81ea\u5206\u542b\u3081\u3066\u4f55\u500b\u3042\u308b\u304b\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\tvi index;\n\t//vs \u3092\u542b\u3080 virtual tree \u3092\u8fd4\u3059\n\t//\u8fd4\u3059\u306e\u306f virtual tree \u306b\u4f7f\u308f\u308c\u305f\u9802\u70b9\u3068\uff0c\u8fba\u306e\u96c6\u5408\n\t//\u8fba\u306e\u7aef\u70b9\u306f\uff0cvirtual tree \u306b\u304a\u3051\u308b\u756a\u53f7\n\t//\u5143\u306e\u6728\u306b\u304a\u3051\u308b\u756a\u53f7\u3092 virtual tree \u306e\u9802\u70b9\u756a\u53f7\u306b\u5199\u3059\u306e\u304c\uff0cindex \u3068\u3044\u3046\u5909\u6570\n\t//\u8fba\u306f ch->par \u306e\u9806\n\t//virtual tree \u306f\u884c\u304d\u639b\u3051\u9806\u3067\u756a\u53f7\u304c\u3064\u3044\u3066\u3044\u308b\n\t//\u7279\u306b\uff0c\u9802\u70b9 0 \u304c\u6839\u306b\u306a\u308b\u3088\u3046\u306b\u3067\u304d\u3066\u3044\u308b\n\tpair<vi,vc<pi>> tree_compress(vi vs){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tvc<pi> es;\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\treturn mp(vs,es);\n\t}\n};\n\n//Lyft Level 5 Challenge 2018 - Final F\n//CF635F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\nstruct E{\n\tint to,idx;\n\toperator int()const{return to;}\n};\n//init_from_hld(HLD<E>(t,0)) \u3068\u304b\u306b\u3064\u304b\u3046\n\n//\u307e\u305a rep(i,n)t.init_vertex(i) \u3092\u6700\u521d\u306b\u3084\u308b\n\n//init_vertex(v,...): \u9802\u70b9\u306b\u5bfe\u5fdc\u3059\u308b\u30ce\u30fc\u30c9\u3092\u521d\u671f\u5316\u3059\u308b\n//init_edge(a,b,...): \u8fba\u306b\u5bfe\u5fdc\u3059\u308b\u30ce\u30fc\u30c9\u3092\u521d\u671f\u5316\u3059\u308b\uff0ca \u304c\u89aa\u5074\n//single(): \u305d\u306e\u30ce\u30fc\u30c9\u5358\u4f53\u3060\u3051\u306e\u60c5\u5831\u306b\u66f4\u65b0\u3059\u308b(\u90e8\u5206\u6728\u306e\u60c5\u5831\u3092\u5fd8\u308c\u308b)\n//reverse(): \u53cd\u8ee2\n//update_path(k,N): path \u4e0a\u3067\uff0c(k==0?\u5de6:\u53f3)\u306b path \u30ce\u30fc\u30c9\u3092\u8ffd\u52a0\u3059\u308b\n//=compress\n//update_light: light \u30c4\u30ea\u30fc\u4e0a\u3067\u30ce\u30fc\u30c9\u3092\u8ffd\u52a0\u3059\u308b\uff08\u539f\u7406\u7684\u306b\u5de6\u53f3\u306e\u533a\u5225\u304c\u306a\u3044\uff09\n//=rake\n//\u3053\u308c\u306f\uff0c\u9802\u70b9\u5358\u4f53\u306e\u30ce\u30fc\u30c9\u306b\u305d\u306e\u90e8\u5206\u6728\u306e\u60c5\u5831\u3092\u4f1d\u3048\u308b\u969b\u306b\u3082\u547c\u3070\u308c\u308b\n//\u3053\u308c\u3067\u5b9f\u7528\u4e0a\u306f\u56f0\u3089\u306a\u3044\u306f\u305a\u3060\u3051\u3069\uff0c\u3082\u3057\u305d\u3046\u3067\u306a\u3051\u308c\u3070\uff0c\u3054\u3081\u3093\n//push_path(k,N), push_light(N): push \u3059\u308b\uff0cupdate \u3068\u540c\u69d8\n//clear_lazy(): lazy \u7cfb\u306e\u30c7\u30fc\u30bf\u3092 clear \u3059\u308b \n\n//\u6728\u304c\u56fa\u5b9a\u3055\u308c\u3066\u3044\u308b\u5834\u5408\n//\u30ce\u30fc\u30c9\u306e\u30de\u30fc\u30b8\u3055\u308c\u65b9\u304c\u9650\u5b9a\u3055\u308c\uff0c\u5b9f\u88c5\u304c\u697d\u306b\u306a\u308b\u30b1\u30fc\u30b9\u304c\u3042\u308b\n//vertex \u306f, light -> path \u306e\u9806\u3067\u30de\u30fc\u30b8\u3057\u3066\u308b\n//light edge \u306f\uff0cpath -> light \u306e\u9806\u3067\u30de\u30fc\u30b8\u3057\u3066\u308b\n\n//t \u304c\u30ce\u30fc\u30c9\u306e\u72b6\u614b\u3092\u8868\u3059\u5909\u6570\u3067\uff0c\u7d76\u5bfe\u5fc5\u8981\n//\u3053\u308c\u3092\u3046\u3063\u304b\u308a\u66f8\u304d\u63db\u3048\u308b\u306a\u3069\u306e\u30df\u30b9\u304c\u4e88\u60f3\u3055\u308c\u308b\n//t==0 vertex\n//t==1 path edge\n//t==2 light edge\n\n//CF691F\n//active\u306a\u9802\u70b9\u3078\u306e\u8ddd\u96e2\u306e\u7dcf\u548c\u3092\u6c42\u3081\u308b\u3084\u3064\n//\u6728\u304c static \u3060\u3068\u601d\u3044\u3053\u3093\u3067\u3044\u308b\n//flip \u306e\u3042\u3068 update \u3057\u306a\u3044\u3068\u306d\nstruct N{\n\tchar t;\n\tint rw,cnt,len[2];\n\tll ans,s[2];\n\tvoid init_vertex(int){\n\t\trw=0;\n\t\tsingle();\n\t}\n\tvoid init_edge(int,int){\n\t\trw=0;\n\t\tsingle();\n\t}\n\tvoid init_edge(int a,int b,const E&){\n\t\tinit_edge(a,b);\n\t}\n\tvoid single(){\n\t\tif(t==0){\n\t\t\tcnt=rw;\n\t\t\tlen[0]=len[1]=0;\n\t\t\tans=0;\n\t\t\ts[0]=s[1]=0;\n\t\t}\n\t\telse{\n\t\t\tcnt=rw;\n\t\t\tlen[0]=len[1]=1;\n\t\t\tans=0;\n\t\t\ts[0]=s[1]=cnt;\n\t\t}\n\t}\n\tvoid reverse(){assert(false);}\n\tvoid update_path(int dir,const N&x_){\n\t\tN x[2]{x_,*this};\n\t\tif(dir)swap(x[0],x[1]);\n\t\tcnt=x[0].cnt+x[1].cnt;\n\t\trep(k,2)len[k]=x[k].len[k];\n\t\tlen[dir]+=x[0].len[1]+x[1].len[0];\n\t\tans+=x[dir].s[dir^1]+ll(x[dir^1].len[dir])*x[dir].cnt;\n\t\trep(k,2)s[k]=x[k].s[k]+x[k^1].s[k]+ll(x[k].len[0]+x[k].len[1])*x[k^1].cnt;\n\t}\n\tvoid update_light(const N& x){\n\t\tcnt+=x.cnt;\n\t\tans+=x.s[0]+ll(len[0])*x.cnt;\n\t\ts[0]+=x.s[0];\n\t\ts[1]+=x.s[0]+ll(len[0]+len[1])*x.cnt;\n\t}\n\tvoid push_path(int,N&){\n\t}\n\tvoid push_light(N&){\n\t}\n\tvoid clear_lazy(){\n\t}\n\t\n\tvoid add(int v){\n\t\trw+=v;\n\t}\n};\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<E> t(n);\n\tvvc<int> dt(n*2-1);\n\trep(i,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb({b,i});\n\t\tt[b].pb({a,i});\n\t\tdt[a].pb(n+i);\n\t\tdt[b].pb(n+i);\n\t\tdt[n+i].pb(a);\n\t\tdt[n+i].pb(b);\n\t}\n\tdoubling<int> dd(dt,0);\n\ttoptree<N> x(n);\n\trep(i,n)x.init_vertex(i);\n\tx.init_from_hld(HLD<E>(t,0));\n\tll ans=0;\n\tauto mg=[&](pi a,pi b){\n\t\tint d=dd.len(a.a,b.a);\n\t\tif(a.b>=d+b.b)return a;\n\t\tif(b.b>=d+a.b)return b;\n\t\tint w=d+a.b+b.b;\n\t\tassert(w%2==0);\n\t\tw/=2;\n\t\tint z=w-a.b;\n\t\treturn pi(dd.jump(a.a,b.a,z),w);\n\t};\n\tauto getmax=[&](pi a,pi b){\n\t\tint d=dd.len(a.a,b.a);\n\t\treturn max({a.b*2,b.b*2,a.b+d+b.b});\n\t};\n\tvi unko(n*2-1);\n\tauto upd=[&](int v,int w){\n\t\tunko[v]+=w;\n\t\t\n\t\tx.expose(v);\n\t\tx[v].add(w);\n\t\tx.update(v);\n\t};\n\tauto getsum=[&](int v){\n\t\tx.expose(v);\n\t\t\n\t\t#ifdef LOCAL\n\t\tint res=0;\n\t\t{\n\t\t\tauto rec=[&](auto self,int i,int p,int d)->void{\n\t\t\t\tif(unko[i])res+=d*unko[i];\n\t\t\t\tfor(auto to:dt[i])if(to!=p)\n\t\t\t\t\tself(self,to,i,d+1);\n\t\t\t};\n\t\t\trec(rec,v,-1,0);\n\t\t}\n\t\tassert(res==x[v].ans);\n\t\t#endif\n\t\t\n\t\treturn x[v].ans;\n\t};\n\tvc<pi> w(n);\n\tvc<ll> sum(n+1);\n\tauto rec=[&](auto self,int l,int r)->void{\n\t\tif(l+1==r)return;\n\t\tint m=(l+r)/2;\n\t\tw[m]=pi(m,0);\n\t\trng(i,m+1,r)w[i]=mg(pi(i,0),w[i-1]);\n\t\tsum[m]=0;\n\t\trng(i,m,r)sum[i+1]=sum[i]+w[i].b;\n\t\tpi cur;\n\t\tint b=m,e=m;\n\t\tgnr(i,l,m){\n\t\t\tif(i==m-1){\n\t\t\t\tcur=pi(i,0);\n\t\t\t}else{\n\t\t\t\tcur=mg(pi(i,0),cur);\n\t\t\t}\n\t\t\twhile(e<r){\n\t\t\t\tif(getmax(cur,w[e])>w[e].b*2){\n\t\t\t\t\tupd(w[e++].a,1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(b<e){\n\t\t\t\tif(cur.b*2>=getmax(cur,w[b])){\n\t\t\t\t\tupd(w[b++].a,-1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=cur.b*2*ll(b-m);\n\t\t\tans+=cur.b*ll(e-b);\n\t\t\tans+=sum[e]-sum[b];\n\t\t\tans+=getsum(cur.a);\n\t\t\tans+=(sum[r]-sum[e])*2;\n\t\t\t/*vi baka(n*2-1);\n\t\t\trng(j,m,r){\n\t\t\t\tint val=getmax(cur,w[j]);\n\t\t\t\tans+=val;\n\t\t\t\tif(j<b){\n\t\t\t\t\tassert(val==cur.b*2);\n\t\t\t\t}else if(j<e){\n\t\t\t\t\tint tmp=cur.b+w[j].b+dd.len(cur.a,w[j].a);\n\t\t\t\t\tassert(val==tmp);\n\t\t\t\t\tans-=+dd.len(cur.a,w[j].a);\n\t\t\t\t\tbaka[w[j].a]=1;\n\t\t\t\t}else{\n\t\t\t\t\tassert(val==w[j].b*2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(unko!=baka){\n\t\t\t\tdmp2(b,e);\n\t\t\t\tdmp(unko);\n\t\t\t\tdmp(baka);\n\t\t\t}\n\t\t\tassert(unko==baka);*/\n\t\t}\n\t\twhile(b<e)upd(w[b++].a,-1);\n\t\tself(self,l,m);\n\t\tself(self,m,r);\n\t};\n\trec(rec,0,n);\n\tprint(ans/2);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "3500", "interactive": false}