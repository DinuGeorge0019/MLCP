{
    "link": "https://codeforces.com//contest/521/problem/E",
    "problemId": "23442",
    "problem_idx": "E",
    "shortId": "521E",
    "contest_number": "521",
    "problem_submissions": {
        "D": [
            10114323,
            10113689,
            10119859,
            10119855,
            10119796,
            10113492,
            10113596,
            10116089,
            10113726,
            10114226,
            10114023,
            10114948,
            10114997,
            10118008,
            10116808,
            10115969,
            10115919,
            115640381
        ],
        "B": [
            10109892,
            10107901,
            10108581,
            10107819,
            10114473,
            10108104,
            10108433,
            10109077,
            10107764,
            10108790,
            10107608,
            10107745,
            10107578,
            10110313,
            10108219,
            10110179,
            10111006
        ],
        "C": [
            10109219,
            10110415,
            10110107,
            10111080,
            10109986,
            10110836,
            10111159,
            10109138,
            10106797,
            10109327,
            10109438,
            10109146,
            10106442,
            10110202,
            10108389,
            10108555
        ],
        "A": [
            10105003,
            10105742,
            10105267,
            10111233,
            10104462,
            10105194,
            10105511,
            10104861,
            10104854,
            10104826,
            10105033,
            10104516,
            10107256,
            10104819,
            10105232,
            10104822
        ],
        "E": [
            10113230,
            10117526,
            249300397
        ]
    },
    "name": "E. Cycling City",
    "statement": "You are organizing a cycling race on the streets of the city. The city\r\ncontains junctions, some pairs of them are connected by roads; on each\r\nroad you can move in any direction. No two roads connect the same pair\r\nof intersections, and no road connects the intersection with itself.You\r\nwant the race to be open to both professional athletes and beginner\r\ncyclists, and that’s why you will organize the race in three\r\nnominations: easy, moderate and difficult; each participant will choose\r\nthe more suitable nomination. For each nomination you must choose the\r\nroute the chain of junctions, consecutively connected by roads. Routes\r\nmust meet the following conditions: all three routes should start at the\r\nsame intersection, and finish at the same intersection (place of start\r\nand finish can’t be the same); to avoid collisions, no two routes can\r\nhave common junctions (except for the common start and finish), and can\r\nnot go along the same road (irrespective of the driving direction on the\r\nroad for those two routes); no route must pass twice through the same\r\nintersection or visit the same road twice (irrespective of the driving\r\ndirection on the road for the first and second time of visit).Preparing\r\nfor the competition is about to begin, and you need to determine the\r\nroutes of the race as quickly as possible. The length of the routes is\r\nnot important, it is only important that all the given requirements were\r\nmet.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint N,M;\n\nvector <int> graph[200010];\nvector <int> child[200010];\nint parent[200010];\nbool used[200010];\nint aa[200010],bb[200010];\nint cnt[200010];\nint depth[200010];\nint gparent[20][200010];\n\nint lca(int x, int y){\n    int i;\n    \n    if(depth[x] > depth[y]) swap(x, y);\n    int diff = depth[y] - depth[x];\n    for(i=19;i>=0;i--) if((1<<i) <= diff){\n        diff -= (1<<i);\n        y = gparent[i][y];\n    }\n    \n    if(x == y) return x;\n    \n    for(i=19;i>=0;i--){\n        int x2 = gparent[i][x];\n        int y2 = gparent[i][y];\n        if(x2 != y2){\n            x = x2;\n            y = y2;\n        }\n    }\n    \n    return parent[x];\n}\n\nvector <int> get_path(int t, int s){\n    vector <int> ans;\n    int x = t;\n    ans.push_back(x);\n    while(1){\n        if(x == s) break;\n        x = parent[x];\n        ans.push_back(x);\n    }\n    return ans;\n}\n\nvector <int> merge(vector <int> &v1, vector <int> &v2){\n    vector <int> v;\n    int i;\n    REP(i,v1.size()) v.push_back(v1[i]);\n    REP(i,v2.size()) v.push_back(v2[i]);\n    return v;\n}\n\nvoid print(vector <int> v){\n    int i;\n    cout << v.size();\n    REP(i,v.size()) printf(\" %d\", v[i]+1);\n    printf(\"\\n\");\n}\n\nvoid construct(int s, int t){\n    int i;\n    int s1 = -1, t1 = -1, s2 = -1, t2 = -1;\n    \n//  cout << s << ' ' << t << endl;\n    \n    REP(i,M){\n        int ss = aa[i], tt = bb[i];\n        if(depth[ss] > depth[tt]) swap(ss, tt);\n        if(ss == s && tt == t) continue;\n        if(lca(s, ss) == ss && lca(t, tt) == t){\n            if(s1 == -1){\n                s1 = ss;\n                t1 = tt;\n            } else {\n                s2 = ss;\n                t2 = tt;\n                break;\n            }\n        }\n    }\n    \n    s = s1 + s2 - lca(s1, s2);\n    t = lca(t1, t2);\n    \n//  cout << s << ' ' << t << ' ' << s1 << ' ' << t1 << ' ' << s2 << ' ' << t2 << endl;\n    \n    vector <int> v1 = get_path(t, s);\n    vector <int> v2 = get_path(t1, t);\n    reverse(v2.begin(),v2.end());\n    vector <int> v3 = get_path(s, s1);\n    reverse(v3.begin(),v3.end());\n    vector <int> v4 = merge(v2, v3);\n    vector <int> v5 = get_path(t2, t);\n    reverse(v5.begin(),v5.end());\n    vector <int> v6 = get_path(s, s2);\n    reverse(v6.begin(),v6.end());\n    vector <int> v7 = merge(v5, v6);\n    \n    print(v1);\n    print(v4);\n    print(v7);\n}\n\nvoid dfs(int x, int d){\n    int i;\n    used[x] = true;\n    depth[x] = d;\n    REP(i,graph[x].size()){\n        int y = graph[x][i];\n        if(!used[y]){\n            dfs(y, d+1);\n            child[x].push_back(y);\n            parent[y] = x;\n        }\n    }\n}\n\nint dfs2(int x){\n    int i;\n    REP(i,child[x].size()) cnt[x] += dfs2(child[x][i]);\n    return cnt[x];\n}\n\nvoid check(int a, int b){\n    if(parent[a] == b || parent[b] == a) return;\n    if(depth[a] < depth[b]) swap(a, b);\n    cnt[a]++;\n    cnt[b]--;\n}\n\nint main(void){\n    int i,j;\n    \n    cin >> N >> M;\n    REP(i,M){\n        int a,b;\n        scanf(\"%d%d\", &a, &b);\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        aa[i] = a; bb[i] = b;\n    }\n    \n    REP(i,N) parent[i] = -1;\n    REP(i,N) if(!used[i]) dfs(i, 0);\n    \n    REP(i,N) gparent[0][i] = parent[i];\n    for(i=1;i<20;i++) REP(j,N){\n        int tmp = gparent[i-1][j];\n        gparent[i][j] = ((tmp == -1) ? -1 : gparent[i-1][tmp]);\n    }\n    \n    REP(i,M) check(aa[i], bb[i]);\n    REP(i,N) if(parent[i] == -1) dfs2(i);\n    \n    int x = -1;\n    REP(i,N) if(cnt[i] >= 2) x = i;\n    if(x == -1){\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    \n    cout << \"YES\" << endl;\n    construct(parent[x], x);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cycling City.json",
    "editorial_link": "https://codeforces.com//blog/entry/16736",
    "editorial": "We have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.\n\nFirst of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.\n\nNow, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.\n\nOtherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.\n\nWhat if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.\n\nFinally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n?+?m) solution; a few logarithmic factors for simplification here and there are also allowed.",
    "hint": []
}