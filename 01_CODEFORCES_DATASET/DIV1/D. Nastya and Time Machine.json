{
    "link": "https://codeforces.com//contest/1340/problem/D",
    "problemId": "599368",
    "problem_idx": "D",
    "shortId": "1340D",
    "contest_number": "1340",
    "problem_submissions": {
        "F": [
            77861280,
            77852254,
            77849797,
            78528429,
            78527982,
            77845721,
            77870771,
            77870728,
            77870667,
            77809735,
            77844929,
            78038847,
            77865877,
            77864401,
            77864363,
            77862346,
            77862326
        ],
        "D": [
            77814886,
            77820644,
            77812632,
            77817969,
            78526970,
            77818222,
            77825103,
            77825677,
            77810183,
            77803432,
            77810910,
            77812394,
            77816455,
            77825551,
            77843873,
            77828804,
            77822663,
            77822063
        ],
        "C": [
            77795843,
            77812380,
            77824845,
            77823255,
            78526952,
            77799809,
            77811601,
            77834672,
            77830782,
            77811370,
            77793451,
            77808028,
            77797811,
            77795450,
            77802848,
            77796169,
            77858001,
            77810294,
            77809842
        ],
        "A": [
            77782251,
            77771158,
            77774810,
            77787508,
            78526918,
            78526910,
            77776379,
            77774309,
            77776029,
            77816613,
            77771928,
            77777830,
            77775868,
            77773607,
            77771508,
            77776009,
            77776621,
            77773349,
            77795835,
            77779579,
            77772710,
            77776861
        ],
        "B": [
            77777625,
            77796394,
            77787259,
            77781233,
            78526935,
            77868779,
            77790975,
            77793147,
            77821618,
            77789026,
            77773962,
            77770331,
            77782427,
            77780486,
            77790796,
            77783960,
            77786770,
            77783985,
            77790124,
            77791298,
            77788341
        ],
        "E": [
            77836196,
            77868575,
            77868568,
            77868546,
            77868525,
            77868496,
            77845628,
            77864964,
            77846936,
            77902183,
            77902167,
            77902121,
            77902068,
            77902045,
            77901978,
            77850099,
            77859253,
            77828316,
            77849841,
            77848435,
            77856908,
            77842257
        ]
    },
    "name": "D. Nastya and Time Machine",
    "statement": "The map of the city where they live has a lot of squares, some of which\r\nare connected by roads. There is exactly one way between each pair of\r\nsquares which does not visit any vertex twice. It turns out that the\r\ngraph of the city is a tree.Denis is located at vertex 1 at the time 0.\r\nHe wants to visit every vertex at least once and get back as soon as\r\npossible.Denis can walk one road in 1 time. Unfortunately, the city is\r\nso large that it will take a very long time to visit all squares.\r\nTherefore, Denis took a desperate step. He pulled out his pocket time\r\nmachine, which he constructed in his basement. With its help, Denis can\r\nchange the time to any non-negative time, which is less than the current\r\ntime.But the time machine has one feature. If the hero finds himself in\r\nthe same place and at the same time twice, there will be an explosion of\r\nuniversal proportions and Nastya will stay unhappy. Therefore, Denis\r\nasks you to find him a route using a time machine that he will get\r\naround all squares and will return to the first and at the same time the\r\nmaximum time in which he visited any square will be minimal.Formally,\r\nDenis\u2019s route can be represented as a sequence of pairs:\r\n{v_1, t_1\r\n},\r\n{v_2, t_2\r\n},\r\n{v_3, t_3\r\n},\r\nldots,\r\n{v_k, t_k\r\n}, where v_i is number of square, and t_i is time in which the boy is\r\nnow.The following conditions must be met: The route starts on square 1\r\nat time 0, i.e. v_1 = 1, t_1 = 0 and ends on the square 1, i.e. v_k = 1.\r\nAll transitions are divided into two types: Being in the square change\r\nthe time:\r\n{ v_i, t_i\r\n}\r\nto\r\n{ v_{i+1}, t_{i+1}\r\n} : v_{i+1} = v_i, 0\r\nleq t_{i+1} < t_i. Walk along one of the roads:\r\n{ v_i, t_i\r\n}\r\nto\r\n{ v_{i+1}, t_{i+1}\r\n}. Herewith, v_i and v_{i+1} are connected by road, and t_{i+1} = t_i +\r\n1 All pairs\r\n{ v_i, t_i\r\n} must be different. All squares are among v_1, v_2,\r\nldots, v_k. You need to find a route such that the maximum time in any\r\nsquare will be minimal, that is, the route for which\r\nmax{(t_1, t_2,\r\nldots, t_k)} will be the minimum possible.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint N; cin >> N;\n\tvector<vector<int>> adj(N);\n\tfor (int e = 0; e < N-1; e++) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tvector<pair<int, int>> ops;\n\tstd::y_combinator([&](auto self, int cur, int prv, int t) -> int {\n\t\tops.emplace_back(cur, t);\n\t\tint d = int(adj[cur].size());\n\t\tbool subtracted = false;\n\t\tif (!subtracted && t >= d) {\n\t\t\tt -= d;\n\t\t\tops.emplace_back(cur, t);\n\t\t\tsubtracted = true;\n\t\t}\n\t\tfor (int nxt : adj[cur]) {\n\t\t\tif (nxt == prv) continue;\n\t\t\tt = self(nxt, cur, t+1);\n\t\t\tops.emplace_back(cur, t);\n\t\t\tif (!subtracted && t >= d) {\n\t\t\t\tt -= d;\n\t\t\t\tops.emplace_back(cur, t);\n\t\t\t\tsubtracted = true;\n\t\t\t}\n\t\t}\n\t\treturn t+1;\n\t})(0, -1, 0);\n\n\tops.pop_back();\n\n\tcout << ops.size() << '\\n';\n\tfor (auto it : ops) {\n\t\tcout << it.first+1 << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Nastya and Time Machine.json",
    "editorial_link": "https://codeforces.com//blog/entry/76479",
    "editorial": "Lemma: The maximum time that Denis will visit will be at least maxv=1ndegv=T\n\nProof: consider an arbitrary vertex v\n. We will visit her degv?1\n times when we will bypass all her neighbors and another 1\n when we return to her ancestor. But we can't go to vertex at 0 time. So, we need degv\n moments more than 0.\n\nWe construct a graph traversal with a maximum time equal to T\n. Let us now stand at v\n at a time t\n and v\n has an un visited son u\n. We want to go to u\n, go around its entire subtree and return to v\n at time t+1\n. That is, the route will be something like this: (v,t)?(u,t+1)?\u0085?(u,t)?(v,t+1)\n.\n\nLet k=degu?1\n, for wi\n we denote the i\n th son of u\n. If t+1?T?k\n, then there are no problems, we will move back in time at the very end of the route: (v,t)\n ?\n (u,t+1)\n ?\n (w1,t+2)\n ?\n \u0085\n ?\n (u,t+2)\n ?\n \u0085\n ?\n (wk,t+k+1)\n ?\n \u0085\n ?\n (u,t+k)\n ?\n (u,t)\n ?\n (v,t+1)\n.\n\nOtherwise, you have to go back in time in the middle of the route (exactly when we get to T) so that after the last visit we will be in (v,t+1)\n, that is: (v,t)\n ?\n (u,t+1)\n ?\n (w1,t+2)\n ?\n \u0085\n ?\n (u,t+2)\n ?\n \u0085\n ?\n (u,T)\n ?\n (u,t?)\n ?\n \u0085\n (wk,t+k+1)\n ?\n \u0085\n ?\n (u,t+k)\n ?\n (u,t)\n ?\n (v,t+1)\n , where t?\n can be easily calculated by the number of not visited sons."
}