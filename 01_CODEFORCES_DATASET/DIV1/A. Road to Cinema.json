{
    "link": "https://codeforces.com//contest/737/problem/A",
    "problemId": "81049",
    "problem_idx": "A",
    "shortId": "737A",
    "contest_number": "737",
    "problem_submissions": {
        "D": [
            22352998,
            22361676,
            22361660,
            22352983,
            22352295,
            22352107,
            22352670,
            22355408,
            22353859,
            22355150,
            22355124,
            22355580,
            22352603,
            22354241,
            22355135,
            22367415,
            22354851,
            22353195,
            22355191,
            22354766,
            22354567,
            22355616,
            22355720
        ],
        "C": [
            22346894,
            22348992,
            22348428,
            22346364,
            22349019,
            22347742,
            22344273,
            22349093,
            22344153,
            22348276,
            22349914,
            22349222,
            22351285,
            22350460,
            22350277,
            22351065,
            22348263,
            22347006,
            22351260,
            22349703
        ],
        "B": [
            22345266,
            22344047,
            22346326,
            22344623,
            22347286,
            22345951,
            22346273,
            22346654,
            22345815,
            22347161,
            22347731,
            22346343,
            22348170,
            22348193,
            22348953,
            22349108,
            22345433,
            22343951,
            22343981,
            22347679
        ],
        "A": [
            22344335,
            22346876,
            22344812,
            22348251,
            22345241,
            22344610,
            22348244,
            22344836,
            22349514,
            22345867,
            22345524,
            22349952,
            22345718,
            22346457,
            22347708,
            22346937,
            22344148,
            22348610,
            22348383,
            22345809
        ],
        "F": [
            22363265,
            22374526
        ],
        "E": [
            22411333
        ]
    },
    "name": "A. Road to Cinema",
    "statement": "Vasya is currently at a car rental service, and he wants to reach\r\ncinema. The film he has bought a ticket for starts in minutes. There is\r\na straight road of length from the service to the cinema. Let\u2019s\r\nintroduce a coordinate system so that the car rental service is at the\r\npoint , and the cinema is at the point .There are gas stations along the\r\nroad, and at each of them you can fill a car with any amount of fuel for\r\nfree! Consider that this operation doesn\u2019t take any time, i.e. is\r\ncarried out instantly.There are cars in the rental service, -th of them\r\nis characterized with two integers and the price of this car rent and\r\nthe capacity of its fuel tank in liters. It\u2019s not allowed to fuel a car\r\nwith more fuel than its tank capacity . All cars are completely fueled\r\nat the car rental service.Each of the cars can be driven in one of two\r\nspeed modes: normal or accelerated. In the normal mode a car covers\r\nkilometer in minutes, and consumes liter of fuel. In the accelerated\r\nmode a car covers kilometer in minutes, but consumes liters of fuel. The\r\ndriving mode can be changed at any moment and any number of times.Your\r\ntask is to choose a car with minimum price such that Vasya can reach the\r\ncinema before the show starts, i.e. not later than in minutes. Assume\r\nthat all cars are completely fueled initially.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n#include <utility>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\nusing namespace std;\nclass TaskA {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n, k, s, t;\n\t\tin >> n >> k >> s >> t;\n\t\tvector<pair<int, int>> v(n);\n\t\tfor(int i: range(n)) {\n\t\t\tin >> v[i].first >> v[i].second;\n\t\t}\n\n\t\tvector<int> p(k + 2);\n\t\tfor (int i: inclusiveRange(1, k)) {\n\t\t\tin >> p[i];\n\t\t}\n\t\tp.back() = s;\n\n\t\tsort(p);\n\n\t\tauto can = [&](int tank) {\n\t\t\tint needTime = 0;\n\t\t\tfor (int i: range(1, (int)p.size())) {\n\t\t\t\tint d = p[i] - p[i - 1];\n\t\t\t\tif (tank < d) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (tank >= 2 * d) {\n\t\t\t\t\tneedTime += d;\n\t\t\t\t} else {\n\t\t\t\t\tneedTime += (2 * d - tank) + d;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn needTime <= t;\n\t\t};\n\n\t\tif (!can(1000000000)) {\n\t\t\tout << -1;\n\t\t\treturn;\n\t\t}\n\n\t\tint l = 0, r = 1000000000;\n\t\twhile (r - l > 1) {\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (can(m)) {\n\t\t\t\tr = m;\n\t\t\t} else {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\n\n\t\tint ans = std::numeric_limits<int>::max();\n\t\tbool found = false;\n\n\t\tfor (int i: range(n)) {\n\t\t\tif (v[i].second >= r) {\n\t\t\t\tans = min(ans, v[i].first);\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tout << -1;\n\t\t\treturn;\n\t\t}\n\n\t\tout << ans << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Road to Cinema.json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "Let's note that there is a value for the fuel tank capacity (call it w), that if the car has the fuel tank capacity equal or more than w it will be able to reach the cinema if time, else \u0097 will not be able.\n\nThe value w can be found with help of binary search because the function can(w) (it is possible and it has enough time for such cur) is monotonic \u0097 in the beginning all values of this function is false, but after some moment the values of this function is always true.\n\nAfter we found w it remain only to choose the cheapest car from the cars which fuel tank capacity equal or more than w.\n\nThe function can(w) can be realized with greedy algorithm. It is easy to write down the formula for find the number of kilometers which we can ride in fast mode if the nearest gas station is on the distance x and we have f liters of fuel in fuel tank:\n\nif x?>?f, then it is impossible to reach the nearest gas station and can(w) must return false,\nif x???f, then it is possible to ride in the fast mode min(x, f?-?x) kilometers.\nSo, now we know how to find the value can(w) in one iterate through the array of gas stations in the increasing order of their positions."
}