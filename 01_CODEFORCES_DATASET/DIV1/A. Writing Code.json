{
    "link": "https://codeforces.com//contest/543/problem/A",
    "problemId": "27497",
    "problem_idx": "A",
    "shortId": "543A",
    "contest_number": "543",
    "problem_submissions": {
        "C": [
            11031273,
            11032297,
            11028921,
            11027662,
            11035224,
            11032105,
            11026578,
            11030569,
            11027731,
            11030889,
            11031150,
            11032259,
            11039311,
            11029744,
            11031844,
            11033030,
            11027751,
            11027833,
            11030513
        ],
        "D": [
            11026961,
            11027152,
            11029036,
            11027586,
            11028656,
            11027275,
            11031263,
            11026257,
            11029360,
            11029505,
            11032424,
            11028940,
            11031163,
            11035849,
            11028432
        ],
        "B": [
            11024775,
            11024536,
            11030599,
            11035262,
            11024794,
            11024869,
            11025321,
            11028836,
            11028474,
            11031647,
            11025986,
            11024625,
            11027272,
            11029817,
            11024295,
            11024309
        ],
        "A": [
            11022855,
            11023048,
            11023174,
            11022792,
            11022796,
            11023075,
            11030178,
            11022790,
            11023930,
            11023772,
            11022768,
            11023607,
            11023159,
            11022742,
            11022813,
            11022885
        ]
    },
    "name": "A. Writing Code",
    "statement": "Programmers working on a large project have just received a task to\r\nwrite exactly lines of code. There are programmers working on a project,\r\nthe -th of them makes exactly bugs in every line of code that he writes.\r\nLet\u2019s call a sequence of non-negative integers a , if . The programmers\r\nfollow the plan like that: in the beginning the first programmer writes\r\nthe first lines of the given task, then the second programmer writes\r\nmore lines of the given task, and so on. In the end, the last programmer\r\nwrites the remaining lines of the code. Let\u2019s call a plan , if all the\r\nwritten lines of the task contain at most bugs in total.Your task is to\r\ndetermine how many distinct plans are there. As the number of plans can\r\nbe large, print the remainder of this number modulo given positive\r\ninteger .\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD \"%I64d\"\n#else\n#define LLD \"%lld\"\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(\"rdtsc\" : \"=A\"(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME \"text\"\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nint MOD;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= MOD) {\n    x -= MOD;\n  }\n}\n\nint n, m, b;\n\nconst int maxn = 500 + 10;\nint a[maxn];\n\nbool read() {\n  if (scanf(\"%d%d%d%d\", &n, &m, &b, &MOD) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", &a[i]);\n  }\n  return 1;\n}\n\nint d[maxn][maxn];\n\nvoid solve() {\n  for (int sv = 0; sv <= m; ++sv) {\n    for (int sva = 0; sva <= b; ++sva) {\n      d[sv][sva] = 0;\n    }\n  }\n  d[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int sv = 0; sv < m; ++sv) {\n      for (int sva = 0; sva <= b; ++sva) {\n        int nsv = sv + 1;\n        int nsva = sva + a[i];\n        if (nsva > b) {\n          break;\n        }\n        add(d[nsv][nsva], d[sv][sva]);\n      }\n    }\n  }\n  int res = 0;\n  for (int sva = 0; sva <= b; ++sva) {\n    add(res, d[m][sva]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME\".out\", \"w\", stdout);\n  assert(freopen(TASKNAME\".in\", \"r\", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"%.18lf\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Writing Code.json",
    "editorial_link": "https://codeforces.com//blog/entry/17773",
    "editorial": "Let\u00e2\u0080\u0099s create the solution, which will work too slow, but after that we\r\nwill improve it. Let\u00e2\u0080\u0099s calculate the following dynamic programming\r\nanswer to the problem, if we already used exactly programmers, writed\r\nexactly lines of code, and there are exactly bugs. How we can do\r\ntransitions in such dp? We can suppose that we -th programmer will write\r\nlines of code, then we should add to value But let\u00e2\u0080\u0099s look at transitions\r\nfrom the other side. It\u00e2\u0080\u0099s clear, that there are exactly 2 cases. The\r\nfirst case, we will give any task for -th programmer. So, we should add\r\nto value . The second case, is to give at least one task to -th\r\nprogrammer. So, this value will be included in that state: . In that\r\nsolution we use same idea, which is used to calculate binomial\r\ncoefficients using Pascal\u00e2\u0080\u0099s triangle. So overall solution will have\r\ncomplexity: The jury solution: 11035704\r\n"
}