{
    "link": "https://codeforces.com//contest/674/problem/D",
    "problemId": "59815",
    "problem_idx": "D",
    "shortId": "674D",
    "contest_number": "674",
    "problem_submissions": {
        "F": [
            17795703,
            17796640,
            17795248,
            17796731,
            17795284,
            17786875,
            17793312,
            17799447,
            17799059,
            17796927,
            17809648
        ],
        "E": [
            17791802,
            17792589,
            17793136,
            17792993,
            17792579,
            17790993,
            17797689,
            17793850,
            17793986,
            17790505,
            17793423,
            17807249,
            17795195,
            17795763,
            17827053,
            17796913
        ],
        "C": [
            17789698,
            17787708,
            17787067,
            17789946,
            17787511,
            17796571,
            17795757,
            17788550,
            17790663,
            17794959,
            17792670,
            17795899,
            17791267,
            17793511,
            17791551,
            17791808
        ],
        "B": [
            17783364,
            17783002,
            17794015,
            17783259,
            17783884,
            17783532,
            17788831,
            17784932,
            17787141,
            17784301,
            17785005,
            17785023,
            17784292,
            17783013,
            17783128,
            17786182,
            17784522
        ],
        "A": [
            17780055,
            17780264,
            17780741,
            17780847,
            17780248,
            17780121,
            17787726,
            17781230,
            17780294,
            17782551,
            17782250,
            17781088,
            17780155,
            17780065,
            17780569,
            17780629,
            17781843
        ],
        "D": [
            17798492,
            17808237
        ],
        "G": [
            17818293,
            17796240,
            17798313
        ]
    },
    "name": "D. Bearish Fanpages",
    "statement": "There is a social website with fanpages, numbered through . There are\r\nalso companies, and the -th company owns the -th fanpage.Recently, the\r\nwebsite created a feature called following. Each fanpage must choose\r\nexactly one other fanpage to follow.The website doesn t allow a\r\nsituation where follows and at the same time follows . Also, a fanpage\r\ncan’t follow itself.Let s say that fanpage follows some other fanpage .\r\nAlso, let s say that is followed by other fanpages . Then, when people\r\nvisit fanpage they see ads from distinct companies: . Exactly people\r\nsubscribe (like) the -th fanpage, and each of them will click exactly\r\none add. For each of companies , exactly people will click their ad.\r\nRemaining people will click an ad from company (the owner of the\r\nfanpage).The total income of the company is equal to the number of\r\npeople who click ads from this copmany.Limak and Radewoosh ask you for\r\nhelp. Initially, fanpage follows fanpage . Your task is to handle\r\nqueries of three types: fanpage follows fanpage from now. It’s\r\nguaranteed that didn’t follow just before the query. Note an extra\r\nconstraint for the number of queries of this type (below, in the Input\r\nsection). print the total income of the -th company. print two integers:\r\nthe smallest income of one company and the biggest income of one\r\ncompany.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\n\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint p[MX];\nint deg[MX];\nll t[MX];\nll d[MX];\nmultiset<ll> mas;\nmultiset<ll> nas[MX];\n\ninline ll s(int v) { return t[v]/deg[v];}\ninline ll ss(int v) { return t[v]-s(v)*(deg[v]-1);}\ninline void del(multiset<ll>& s, ll x, ll y) {\n  ll l = *(s.begin());\n  ll r = *(s.rbegin());\n  s.erase(s.find(x));\n  if (sz(s)) {\n    ll nl = *(s.begin());\n    ll nr = *(s.rbegin());\n    if (l != nl) {\n      mas.erase(mas.find(l+y));\n      mas.insert(nl+y);\n    }\n    if (r != nr) {\n      mas.erase(mas.find(r+y));\n      mas.insert(nr+y);\n    }\n  } else {\n    mas.erase(mas.find(l+y));\n    mas.erase(mas.find(r+y));\n  }\n}\ninline void add(multiset<ll>& s, ll x, ll y) {\n  if (sz(s)) {\n    ll l = *(s.begin());\n    ll r = *(s.rbegin());\n    s.insert(x);\n    ll nl = *(s.begin());\n    ll nr = *(s.rbegin());\n    if (l != nl) {\n      mas.erase(mas.find(l+y));\n      mas.insert(nl+y);\n    }\n    if (r != nr) {\n      mas.erase(mas.find(r+y));\n      mas.insert(nr+y);\n    }\n  } else {\n    s.insert(x);\n    ll nl = *(s.begin());\n    ll nr = *(s.rbegin());\n    mas.insert(nl+y);\n    mas.insert(nr+y);\n  }\n}\nvoid sp(int v, int sg) {\n  int u = p[v];\n  if (u != -1) {\n    if (p[u] != -1) del(nas[p[u]],d[u],s(p[u]));\n    d[u] += s(v)*sg;\n    if (p[u] != -1) add(nas[p[u]],d[u],s(p[u]));\n  }\n  if (u != -1) del(nas[u],d[v],s(u));\n  d[v] += ss(v)*sg;\n  if (u != -1) add(nas[u],d[v],s(u));\n}\nvoid f(int v, ll x) {\n  ll y = s(v);\n  if (sz(nas[v])) {\n    ll l = *(nas[v].begin());\n    ll r = *(nas[v].rbegin());\n    mas.erase(mas.find(l+x));\n    mas.erase(mas.find(r+x));\n    mas.insert(l+y);\n    mas.insert(r+y);\n  }\n}\nvoid discon(int v) {\n  int u = p[v];\n  if (u == -1) return;\n  sp(u,-1); sp(v,-1);\n  ll au = s(u), av = s(v);\n  deg[v]--; deg[u]--;\n  f(u,au); f(v,av);\n  del(nas[u],d[v],s(u));\n  p[v] = -1;\n  sp(u,1); sp(v,1);\n}\nvoid con(int v, int u) {\n  discon(v);\n  sp(u,-1); sp(v,-1);\n  p[v] = u;\n  add(nas[u],d[v],s(u));\n  ll au = s(u), av = s(v);\n  deg[v]++; deg[u]++;\n  f(u,au); f(v,av);\n  sp(u,1); sp(v,1);\n}\n\nint main() {\n  int n, q;\n  scanf(\"%d%d\",&n,&q);\n  rep(i,n) scanf(\"%I64d\",&t[i]);\n  rep(i,n) p[i] = -1;\n  rep(i,n) deg[i] = 1;\n  rep(i,n) d[i] = ss(i);\n  rep(i,n) {\n    int a;\n    scanf(\"%d\",&a); --a;\n    con(i,a);\n  }\n  rep(qi,q) {\n    int ty;\n    scanf(\"%d\",&ty);\n    if (ty == 1) {\n      int a, b;\n      scanf(\"%d%d\",&a,&b); --a; --b;\n      con(a,b);\n    } else if (ty == 2) {\n      int a;\n      scanf(\"%d\",&a); --a;\n      printf(\"%I64d\\n\",d[a]+s(p[a]));\n    } else {\n      ll l = *(mas.begin());\n      ll r = *(mas.rbegin());\n      printf(\"%I64d %I64d\\n\",l,r);\n    }\n  }\n  return 0;\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bearish Fanpages.json",
    "editorial_link": "https://codeforces.com//blog/entry/44754",
    "editorial": null
}