{
    "link": "https://codeforces.com//contest/329/problem/E",
    "problemId": "3358",
    "problem_idx": "E",
    "shortId": "329E",
    "contest_number": "329",
    "problem_submissions": {
        "D": [
            4118984,
            4120313,
            4119660,
            4116785,
            4117605,
            4120902,
            4120215,
            4118708,
            4120010,
            4137748,
            4119968,
            4119996,
            4119672,
            4121809
        ],
        "C": [
            4117113,
            4117558,
            4116367,
            4121523,
            4143349,
            4121550,
            4117988,
            4118184,
            4122060,
            4117812,
            4137746,
            4121987,
            4121389,
            4120201,
            4115159,
            4117962,
            4119458,
            4118596
        ],
        "B": [
            4114305,
            4114368,
            4113665,
            4115021,
            4115525,
            4115412,
            4114479,
            4114580,
            4118395,
            4137745,
            4114685,
            4117097,
            4121085,
            4123377,
            4114997,
            4115233,
            4115579
        ],
        "A": [
            4112796,
            4112854,
            4120598,
            4113396,
            4112888,
            4113555,
            4112601,
            4113197,
            4113479,
            4137744,
            4112411,
            4113271,
            4115572,
            4112548,
            4113837,
            4113786,
            4113898
        ],
        "E": [
            4137719
        ]
    },
    "name": "E. Evil",
    "statement": "There are cities on a two dimensional Cartesian plane. The distance\r\nbetween two cities is equal to the Manhattan distance between them (see\r\nthe Notes for definition). A Hamiltonian cycle of the cities is defined\r\nas a permutation of all cities. The length of this Hamiltonian cycle is\r\ndefined as the sum of the distances between adjacent cities in the\r\npermutation plus the distance between the first and final city in the\r\npermutation. Please compute the longest possible length of a Hamiltonian\r\ncycle of the given cities.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\n\nint N;\npair <int, int> city[MAXN];\nint xval[MAXN], yval[MAXN];\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> city[i].first >> city[i].second;\n\t\t\n\t\txval[i] = city[i].first;\n\t\tyval[i] = city[i].second;\n\t}\n\t\n\tsort (xval, xval + N);\n\tsort (yval, yval + N);\n\t\n\tll tot = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (i * 2 < N - 1)\n\t\t\ttot -= xval[i] + yval[i];\n\t\tif (i * 2 > N - 1)\n\t\t\ttot += xval[i] + yval[i];\n\t}\n\ttot *= 2;\n\t\n\tif (N % 2 == 0)\n\t{\n\t\tbool bad1 = false, bad2 = false;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (city[i].first <= xval[N / 2 - 1] && city[i].second >= yval[N / 2])\n\t\t\t\tbad1 = true;\n\t\t\tif (city[i].first >= xval[N / 2] && city[i].second <= yval[N / 2 - 1])\n\t\t\t\tbad1 = true;\n\t\t\t\n\t\t\tif (city[i].first <= xval[N / 2 - 1] && city[i].second <= yval[N / 2 - 1])\n\t\t\t\tbad2 = true;\n\t\t\tif (city[i].first >= xval[N / 2] && city[i].second >= yval[N / 2])\n\t\t\t\tbad2 = true;\n\t\t}\n\t\t\n\t\tif (bad1 && bad2)\n\t\t\ttot -= 2 * min (xval[N / 2] - xval[N / 2 - 1], yval[N / 2] - yval[N / 2 - 1]);\n\t\t\n\t\tcout << tot << \"\\n\";\n\t}\n\telse\n\t{\n\t\tbool good = false, bad1 = false, bad2 = false;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (city[i].first < xval[N / 2] && city[i].second > yval[N / 2])\n\t\t\t\tbad1 = true;\n\t\t\tif (city[i].first > xval[N / 2] && city[i].second < yval[N / 2])\n\t\t\t\tbad1 = true;\n\t\t\t\n\t\t\tif (city[i].first < xval[N / 2] && city[i].second < yval[N / 2])\n\t\t\t\tbad2 = true;\n\t\t\tif (city[i].first > xval[N / 2] && city[i].second > yval[N / 2])\n\t\t\t\tbad2 = true;\n\t\t\t\n\t\t\tif (city[i].first == xval[N/2] && city[i].second != yval[N/2])\n\t\t\t\tgood = true;\n\t\t\tif (city[i].first != xval[N/2] && city[i].second == yval[N/2])\n\t\t\t\tgood = true;\n\t\t}\n\t\t\n\t\tif (!good && bad1 && bad2)\n\t\t\ttot -= 2 * min (min (xval[N / 2] - xval[N / 2 - 1], xval[N / 2 + 1] - xval[N / 2]),\n\t\t\t\t\t\t\tmin (yval[N / 2] - yval[N / 2 - 1], yval[N / 2 + 1] - yval[N / 2]));\n\t\t\n\t\tcout << tot << \"\\n\";\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Evil.json",
    "editorial_link": "https://codeforces.com//blog/entry/8417",
    "editorial": "The solution to this problem is actually quite simple: 4122927 This\r\nproblem asks us to prove something very long (the proof below is of 80+\r\nlines). Assume that the number of cities is at least 4. The case where\r\nitâs less than 4 is trivial. First, we will assume that no two cities\r\nwill have same X or Y coordinates. To get this assumption, we can\r\njuxtapose every city very slightly that it will not change the answer.\r\nThe keys are : A) \"Manhattan Distance\", B) the tour starts and ends at\r\nthe same city. Suppose we know a tour. The total distance traveled will\r\nbe |X1 X2| + |Y1 Y2| + |X3 X2| + |Y3 Y2| ... Letâs separate the X and Y\r\ncoordinates for simplicity. Note that each city will contribute twice to\r\nthis value, for example X2 was in |X1 X2| and |X3 X2| in the example\r\nabove. Manhattan distance implies that each of these values will either\r\nbe multiplied by +1 or -1, depending on the other coordinate being\r\ncompared in the absolute term. Furthermore, the number of values that\r\nare multiplied by +1 must equal the number of values that are multiplied\r\nby -1 (since in each absolute term, one is multiplied by +1 and the\r\nother by -1). This directly implies an upper bound on the maximum length\r\nof the tour. If we list all the X coordinates of the cities, and we put\r\neach of them twice in this list, and sort them, the maximum will be\r\ngained if we multiply the last half by +1 and the first half by -1, and\r\nfinally summing them up. Note that all of these reasoning applies to the\r\nY coordinate, and summing both maximum of X and Y, we receive an upper\r\nbound on the length of the tour. If we can find a tour with this length,\r\nour job is done. In some case, itâs possible. Letâs investigate! First,\r\nif we have the medians of the X and the Ys as in the list above, we can\r\nseparated the field like below : The lines corresponds to the median for\r\nboth X and Y. At most one city will lie on each of the median lines\r\n(recall our assumption that X and Ys are distinct). Letâs call each A B\r\nC and D as boxes. Below, we will refer box A as simply A (applies to B,\r\nC, and D too) To obtain the value above, from a city in B we must go to\r\na city in C. Same reasoning yields : B->C, C->B, A->D, D->A. Here, pairs\r\nof cities become apparrent, A and D are paired as well as B and C.\r\nFirst, if either A+D is empty or B+C is empty, then we can obtain the\r\nupper bound above. We simply alternates between the two remaining pair.\r\nSo letâs assume that A+D is not empty and B+C is not empty. First, letâs\r\ninvestigate the relationship between B and C (A and B will also exhibits\r\nthis relationship). Theorem 1: |B C| <= 1. Why: First, if there are no\r\ncities in the medians or there is a single city in the center of the\r\nmedian : A median divides the region into two areas with the same number\r\nof cities, so we have: substituting A from a to b yields : And the\r\ntheorem follows. Next, suppose there are two cities in the median, one\r\nfor each median line : Letâs suppose the median is one above and one on\r\nthe right. All other cases will be similar. By definition of median...\r\nSubstituing a into b yields which also implies A = D Applying the same\r\ntechnique to other cases will give: And the theorem follows. Note also\r\nthat the one with the extra 1 city will be the one that is not adjacent\r\nto any median city (adjacent being the city lies in the boundary of the\r\nbox) OK, so in the following observations, we will assume the upper\r\nbound (that is, the sorted list of both X and Ys have their first half\r\nmultiplied by -1 while the rest by +1), and trying to find a solution\r\nthatâs as close as possible to this upper bound. The following will be\r\nanother case analysis. Theorem 2: If there are two cities in the medians\r\n(that is, one in each median line), then the upper bound can be\r\nachieved. Why: We use pair of boxes to denote either A and D or B and C.\r\nFrom the second part of the proof for theorem 1, there will be a pair of\r\nboxes that contain different number of cities. Letâs pick this pair, and\r\nstart at the one with the most boxes. We keep alternating with its pair\r\nuntil we end up back in our starting box. Then, we simply move to either\r\nof the median city. From there we move to the other pair of box, the\r\nfarthest one of the two. Alternate between the two, go to the other\r\nmedian city, and return to the starting city. Itâs easy to see that this\r\nwill be optimal and have the upper bound as its value. Now, letâs see if\r\nthere are no cities in the medians. First of all, this implies that the\r\nnumber of cities is even. Second, this implies that our upper bound\r\nwhich has the X and Y lists as -1 -1 -1 ... -1 1 ... 1 1 1 will not work\r\n(since this implies we have to continuously alternate between the two\r\npairs of boxes, however, we canât switch between the pair of boxes). So,\r\nat least a modification would be required. The smallest possible\r\nmodification is obtained by swapping the medians, that is, it becomes :\r\n-1 -1 -1 ... -1 -1 1 -1 1 1 ... 1 1 1. This is sufficient. Why? So,\r\nthere are two cities that changes since the number of cities is even.\r\nFurthermore, these two cities will be the closest to the median line\r\n(letâs assume these coordinates are X, that is, theyâre the closest to\r\nthe vertical median line) and lies at two different boxes. Then, we\r\nproceed as follows. We start at one of these two cities. Alternate and\r\nend at the other side. If the other city is at that box, we make it so\r\nthat we end at that city, and in this case, we can move to a city in the\r\nother box pair while respecting the list of X coordinates (we can do so\r\nsince this city is the closest to the median line). Otherwise, the city\r\nwill be in the other pair of boxes. We simply move there and it can be\r\nshown that we still respect the list of X coordinates. Alternate and at\r\nthe end, go back to the starting city. All of these can be shown to\r\nstill respect the list above. This is optimal since this is the next\r\nlargest possible upper bound if upper bound cannot be achieved. Now, if\r\nthere is a single city in the center of both medians, then the upper\r\nbound cannot be achieved. To see this, the upper bound can only be\r\nachieved if from a city in a box we move to another city in its box pair\r\nor to the center city. However, since both pair of boxes contains a\r\ncity, we will need to move at least twice between them. Since thereâs\r\nonly one center city, this is not possible. Observe that this case\r\nimplies an odd number of cities. Hence, we canât simply swap the median\r\nsince it swaps the x coordinates of the same median city. Instead, we do\r\nthis : -1 -1 ... -1 -1 1 1 -1 1 ... 1 1 or -1 -1 ... -1 1 -1 -1 1 1 ...\r\n1 1 That is, we swap to either one of the neighboring city. With the\r\nsame reasoning as above, we can show that we respect this list of X\r\ncoordinates. To achieve O(N) expected performance, note that the only\r\noperations we need are : grouping elements into boxes and median\r\nfinding. Both can be done in expected O(N) time (expected since although\r\nthere is a worst-case O(N) selection algorithm, itâs ugly). Thoughts:\r\nActually I intended to reword this into a three-paragraph weird story,\r\nbut that seems a little too evil >:), so it was left out.\r\n",
    "hint": []
}