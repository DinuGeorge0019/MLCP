{"link": "https://codeforces.com//contest/329/problem/E", "problemId": "3358", "problem_idx": "E", "shortId": "329E", "contest_number": "329", "problem_submissions": {"D": [4118984, 4120313, 4119660, 4116785, 4117605, 4120902, 4120215, 4118708, 4120010, 4137748, 4119968, 4119996, 4119672, 4121809], "C": [4117113, 4117558, 4116367, 4121523, 4143349, 4121550, 4117988, 4118184, 4122060, 4117812, 4137746, 4121987, 4121389, 4120201, 4115159, 4117962, 4119458, 4118596], "B": [4114305, 4114368, 4113665, 4115021, 4115525, 4115412, 4114479, 4114580, 4118395, 4137745, 4114685, 4117097, 4121085, 4123377, 4114997, 4115233, 4115579], "A": [4112796, 4112854, 4120598, 4113396, 4112888, 4113555, 4112601, 4113197, 4113479, 4137744, 4112411, 4113271, 4115572, 4112548, 4113837, 4113786, 4113898], "E": [4137719]}, "name": "E. Evil", "statement": "There are cities on a two dimensional Cartesian plane. The distance\r\nbetween two cities is equal to the Manhattan distance between them (see\r\nthe Notes for definition). A Hamiltonian cycle of the cities is defined\r\nas a permutation of all cities. The length of this Hamiltonian cycle is\r\ndefined as the sum of the distances between adjacent cities in the\r\npermutation plus the distance between the first and final city in the\r\npermutation. Please compute the longest possible length of a Hamiltonian\r\ncycle of the given cities.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\n\nint N;\npair <int, int> city[MAXN];\nint xval[MAXN], yval[MAXN];\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> city[i].first >> city[i].second;\n\t\t\n\t\txval[i] = city[i].first;\n\t\tyval[i] = city[i].second;\n\t}\n\t\n\tsort (xval, xval + N);\n\tsort (yval, yval + N);\n\t\n\tll tot = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (i * 2 < N - 1)\n\t\t\ttot -= xval[i] + yval[i];\n\t\tif (i * 2 > N - 1)\n\t\t\ttot += xval[i] + yval[i];\n\t}\n\ttot *= 2;\n\t\n\tif (N % 2 == 0)\n\t{\n\t\tbool bad1 = false, bad2 = false;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (city[i].first <= xval[N / 2 - 1] && city[i].second >= yval[N / 2])\n\t\t\t\tbad1 = true;\n\t\t\tif (city[i].first >= xval[N / 2] && city[i].second <= yval[N / 2 - 1])\n\t\t\t\tbad1 = true;\n\t\t\t\n\t\t\tif (city[i].first <= xval[N / 2 - 1] && city[i].second <= yval[N / 2 - 1])\n\t\t\t\tbad2 = true;\n\t\t\tif (city[i].first >= xval[N / 2] && city[i].second >= yval[N / 2])\n\t\t\t\tbad2 = true;\n\t\t}\n\t\t\n\t\tif (bad1 && bad2)\n\t\t\ttot -= 2 * min (xval[N / 2] - xval[N / 2 - 1], yval[N / 2] - yval[N / 2 - 1]);\n\t\t\n\t\tcout << tot << \"\\n\";\n\t}\n\telse\n\t{\n\t\tbool good = false, bad1 = false, bad2 = false;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (city[i].first < xval[N / 2] && city[i].second > yval[N / 2])\n\t\t\t\tbad1 = true;\n\t\t\tif (city[i].first > xval[N / 2] && city[i].second < yval[N / 2])\n\t\t\t\tbad1 = true;\n\t\t\t\n\t\t\tif (city[i].first < xval[N / 2] && city[i].second < yval[N / 2])\n\t\t\t\tbad2 = true;\n\t\t\tif (city[i].first > xval[N / 2] && city[i].second > yval[N / 2])\n\t\t\t\tbad2 = true;\n\t\t\t\n\t\t\tif (city[i].first == xval[N/2] && city[i].second != yval[N/2])\n\t\t\t\tgood = true;\n\t\t\tif (city[i].first != xval[N/2] && city[i].second == yval[N/2])\n\t\t\t\tgood = true;\n\t\t}\n\t\t\n\t\tif (!good && bad1 && bad2)\n\t\t\ttot -= 2 * min (min (xval[N / 2] - xval[N / 2 - 1], xval[N / 2 + 1] - xval[N / 2]),\n\t\t\t\t\t\t\tmin (yval[N / 2] - yval[N / 2 - 1], yval[N / 2 + 1] - yval[N / 2]));\n\t\t\n\t\tcout << tot << \"\\n\";\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["math"], "dificulty": "3100", "interactive": false}