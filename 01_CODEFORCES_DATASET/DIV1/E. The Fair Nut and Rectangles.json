{
    "link": "https://codeforces.com//contest/1083/problem/E",
    "problemId": "268425",
    "problem_idx": "E",
    "shortId": "1083E",
    "contest_number": "1083",
    "problem_submissions": {
        "F": [
            46915087,
            46876311,
            46868384,
            46877366,
            46879128,
            46934792,
            46934770,
            46934758,
            46934487,
            46934473,
            46934346,
            46934338,
            46934202,
            46933927,
            46928101,
            46927984,
            46927894,
            46927871,
            46927855,
            46927824,
            46927737,
            46927669,
            46927614,
            46881270
        ],
        "E": [
            46869370,
            46871694,
            46869499,
            46863810,
            46865492,
            46873246,
            46870302,
            46870225,
            46877380,
            73537754,
            46882329,
            46878807,
            46866936,
            46868963,
            46871231,
            46872499,
            46871547,
            46871489,
            46871036,
            46871727,
            46869495,
            50322936,
            50315966,
            49844673,
            49844653,
            46872514
        ],
        "C": [
            46867095,
            46877292,
            47334658,
            46890375,
            46870788,
            46950972,
            46950940,
            46950838,
            46877308,
            46877619,
            46875434,
            46987974,
            46883043,
            46874242,
            46882744,
            46942133
        ],
        "B": [
            46861840,
            46872617,
            46861528,
            46859342,
            46860406,
            46863456,
            46865386,
            46864693,
            46865545,
            46861409,
            46863762,
            46864513,
            46863287,
            46861669,
            46861388,
            46863642,
            46862875,
            46865443,
            46861004,
            46867808
        ],
        "A": [
            46860516,
            46860277,
            46860154,
            46866668,
            46859314,
            46876109,
            46860042,
            46861931,
            46860073,
            46859289,
            46859440,
            46860646,
            46859325,
            46859654,
            46859377,
            46861868,
            46860315,
            46863438,
            46865470,
            46859724
        ],
        "D": [
            46882403,
            46994123
        ]
    },
    "name": "E. The Fair Nut and Rectangles",
    "statement": "The Fair Nut got stacked in planar world. He should solve this task to\r\nget out.You are given n rectangles with vertexes in (0, 0), (x_i, 0),\r\n(x_i, y_i), (0, y_i). For each rectangle, you are also given a number\r\na_i. Choose some of them that the area of union minus sum of a_i of the\r\nchosen ones is maximum.It is guaranteed that there are no nested\r\nrectangles.Nut has no idea how to find the answer, so he asked for your\r\nhelp.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1200*1007;\nusing mag=long double;\n\nint n;\n\npair <pll,ll> tab[nax];\n\npll operator - (pll a, pll b)\n{\n\treturn {a.first-b.first, a.second-b.second};\n}\n\nmag ilowek(pll s, pll a, pll b)\n{\n\ta=a-s;\n\tb=b-s;\n\treturn a.first*(mag)b.second-a.second*(mag)b.first;\n}\n\nll wyn;\nll dp[nax];\n\nvector <pll> oto;\n\nvoid wrzuc(pll v)\n{\n\tint r=oto.size();\n\twhile(r>=2 && ilowek(oto[r-2], oto[r-1], v)<=0)\n\t{\n\t\tr--;\n\t\toto.pop_back();\n\t}\n\toto.push_back(v);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld%lld%lld\", &tab[i].first.first, &tab[i].first.second, &tab[i].second);\n\tsort(tab+1, tab+1+n);\n\tint l=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twrzuc({dp[i-1], tab[i-1].first.first});\n\t\tll x=tab[i].first.first;\n\t\tll y=tab[i].first.second;\n\t\tl=min(l, (int)oto.size()-1);\n\t\twhile(l+1<(int)oto.size() && oto[l+1].first-oto[l+1].second*y>=oto[l].first-oto[l].second*y)\n\t\t\tl++;\n\t\tdp[i]=oto[l].first+y*(x-oto[l].second)-tab[i].second;\n\t\twyn=max(wyn, dp[i]);\n\t\t//~ debug() << tab[i] << \" \" << dp[i] << \" \" << oto;\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "geometry"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. The Fair Nut and Rectangles.json",
    "editorial_link": "https://codeforces.com/blog/entry/63753?locale=en",
    "editorial": "Letâs order rectangles by , so will be increasing. If the is increasing,\r\nis decreasing, because there are no nested rectangles. Then lets define\r\nas the maximum value, which can be acheived by choosing some subset of\r\nfirst rectangles which contains the -th rectangle. It can be calculated\r\nby , where is the previous chosen rectangle (we subtract because it is\r\ncommon square of the subset for and -th rectangle). This formula can be\r\noptimized using convex hull trick and calculated in or in if rectangles\r\nare already sorted.\r\n",
    "hint": []
}