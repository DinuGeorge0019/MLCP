{
    "link": "https://codeforces.com//contest/103/problem/E",
    "problemId": "546",
    "problem_idx": "E",
    "shortId": "103E",
    "contest_number": "103",
    "problem_submissions": {
        "E": [
            594225,
            596662,
            39448090,
            39427579,
            39399437,
            595910,
            123375307,
            5405441
        ],
        "D": [
            592292,
            591569,
            591484,
            596181,
            596133,
            591648,
            592548,
            593008,
            592069,
            594057,
            593198,
            593774,
            593994,
            594003,
            593751,
            594358,
            594503,
            597893,
            597881,
            596124,
            595932,
            594188,
            592900,
            594112
        ],
        "C": [
            591729,
            592936,
            593120,
            596123,
            592928,
            591746,
            593864,
            593657,
            591747,
            592188,
            592501,
            592689,
            592235,
            591907,
            592739,
            592446,
            593652,
            592453
        ],
        "B": [
            589933,
            589502,
            590203,
            596103,
            590318,
            590585,
            590813,
            590526,
            590500,
            590943,
            590147,
            591873,
            590310,
            590700,
            590283,
            591089,
            590343,
            590573,
            591133
        ],
        "A": [
            589329,
            591835,
            589264,
            596085,
            589350,
            589466,
            589313,
            589253,
            593567,
            589432,
            589509,
            590045,
            589561,
            589677,
            589370,
            589409,
            590491
        ]
    },
    "name": "E. Buying Sets",
    "statement": "The Hexadecimal virus loves playing with number sets intersecting them,\r\nuniting them. One beautiful day she was surprised to find out that\r\nScuzzy, her spherical pet cat, united all sets in one and ate the\r\nresult! Something had to be done quickly and Hexadecimal rushed to the\r\nmarket.The market has sets of numbers on sale. The virus wants to buy\r\nthe following collection of sets: the number of sets in the collection\r\nshould be exactly the same as the number of numbers in the union of all\r\nbought sets. Moreover, Hexadecimal wants to buy the cheapest suitable\r\ncollection of set.Yet nothing\u2019s so easy! As Mainframe is a kingdom of\r\npure rivalry markets, we know that the union of any sets contains no\r\nless than distinct numbers (for every positive integer ).Help the virus\r\nchoose the suitable collection of sets. The collection can be empty.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nstruct rec {\n\tint v, c, f, next;\n};\n\nint n, list, iter;\nint u[310];\nint ma[300];\nint a[300][300];\nint ver[302];\nrec reb[200000];\nint cost[300], S, T;\nint minC;\n\nbool go (int v) {\n\tif (u[v])\n\t\treturn 0;\n\tu[v] = 1;\n\tforn (i, n)\n\t\tif (a[v][i])\n\t\t\tif (ma[i] == -1 || go (ma[i])) {\n\t\t\t\tma[i] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\treturn 0;\n}\n\nvoid push_ (int v1, int v2, int c) {\n\tlist ++;\n\treb[list].v = v2;\n\treb[list].next = ver[v1];\n\treb[list].f = 0;\n\treb[list].c = c;\n\tver[v1] = list;\n}\n\nvoid push (int v1, int v2, int c) {\n\tpush_ (v1, v2, c);\n\tpush_ (v2, v1, 0);\n}\n\nint dfs (int v, int cur) {\n\tif (u[v] == iter)\n\t\treturn 0;\n\tif (v == T)\n\t\treturn cur;\n\tu[v] = iter;\n\tfor (int ptr = ver[v]; ptr != -1; ptr = reb[ptr].next)\n\t\tif (reb[ptr].c - reb[ptr].f >= minC) {\n\t\t\tint f = dfs (reb[ptr].v, min (cur, reb[ptr].c-reb[ptr].f));\n\t\t\tif (f) {\n\t\t\t\treb[ptr].f += f;\n\t\t\t\treb[ptr^1].f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nint max_flow () {\n\tminC = 1 << 25;\n\tint res = 0;\n\tseta (u, 0);\n\titer = 0;\n\twhile (minC > 0) {\n\t\titer ++;\n\t\tint f;\n\t\twhile (f = dfs (S, inf)) {\n\t\t\tres += f;\n\t\t\titer ++;\n\t\t}\n\t\tminC /= 2;\n\t}\n\treturn res;\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tseta (a, 0);\n\tscanf (\"%d\", &n);\n\tforn (i, n) {\n\t\tint k;\n\t\tscanf (\"%d\", &k);\n\t\tforn (j, k) {\n\t\t\tint x;\n\t\t\tscanf (\"%d\", &x);\n\t\t\tx --;\n\t\t\ta[i][x] = 1;\n\t\t}\n\t}\n\tforn (i, n)\n\t\tscanf (\"%d\", &cost[i]);\n\tseta (ma, 255);\n\tforn (i, n) {\n\t\tseta (u, 0);\n\t\tgo (i);\n\t}\n\tseta (ver, 255);\n\tlist = -1;\n\tforn (i, n) {\n\t\tseta (u, 0);\n\t\tgo (i);\n\t\tforn (j, n)\n\t\t\tif (u[j])\n\t\t\t\tpush (i, j, inf);\n\t}\n\tint left = 0;\n\tS = n;\n\tT = n+1;\n\tforn (i, n)\n\t\tif (cost[i] < 0) {\n\t\t\tleft += -cost[i];\n\t\t\tpush (S, i, -cost[i]);\n\t\t} else\n\t\t\tpush (i, T, cost[i]);\n\tcout << max_flow () - left << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graph matchings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Buying Sets.json",
    "editorial_link": "https://codeforces.com/blog/entry/2426?locale=en",
    "editorial": "Construct bipartite graph G1 with available sets on the left side and the numbers on the right side. We put an edge from a set to all the numbers contained in it. By Hall's theorem it follows from \"the union of any k sets contains no less than k distinct numbers (for every positive integer k)\" that there exists perfect matching of all the elements in the bipartite graph (in fact the theorem states that there exists matching including all set vertices, but as the numbers are also restricted by n, this means that there exists perfect matching).\n\nAfter this observation we find whichever perfect matching in G1, let's denote it by M?=?{(ui,?vi)}. Now we construct second oriented graph G2 with vertices corresponding to the available sets and edges (ui???uj) for each edge (ui,?vj) from G1 that do not occur in M (Note that the matching sets the indices of v's and thus we consider them, not the values of the corresponding numbers). Now for every suitable collection of size k there should be no outgoing edge to other set in G2 (otherwise the numbers included in the sets of the collection will be k plus the additional few numbers from the corresponding outgoing edges and the collection will not be suitable - more numbers than sets).\n\nThus our problem has been transformed to the following equivalent: in an oriented graph with weight of vertices find subset S of the vertices with minimum sum of weights and without outgoing edge with other end not in S. This problem is known to be equivalent to finding minimum cut (I wasn't able to prove the equivalence, didn't know it by heart either, but I found it even easier to prove if I consider the task as just max flow) .\n\nAssign to the edges of G2 infinite weights, add additional vertices s and t,. Now for every set ui with weight w add edge ui???t with weight w iff w?>?0 and edge s???ui with weight ?-?w iff w?<?0. The part of the minimum cut of s and t in the constructed graph that contains s is the sought optimal collection (in fact what I did was sum the outgoing weights from s after computing max flow in the graph; I was able to prove this is the required number)."
}