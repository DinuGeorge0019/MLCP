{"link": "https://codeforces.com//contest/739/problem/D", "problemId": "81535", "problem_idx": "D", "shortId": "739D", "contest_number": "739", "problem_submissions": {"C": [22442698, 22439403, 22439035, 22441010, 22452684, 22437700, 22438882, 22439230, 22438925, 22440648, 22439930, 22440447, 22440445, 22442265, 22442505, 22443020, 22443464, 22471543], "A": [22439350, 22427880, 22428059, 22427929, 22427879, 22427835, 22427894, 22569748, 22427875, 22427910, 22428905, 22428165, 22427839, 22428416, 22427876, 22427815, 22428207, 22427895, 22461370, 22461352, 22428531], "B": [22438821, 22430420, 22433537, 22432542, 22430611, 22432279, 22431221, 22432719, 22432020, 22433235, 22432524, 22433360, 22434177, 22433963, 22430137, 22435255, 22433707, 22459456, 22459424, 22459398, 22442832], "E": [22435846, 23367614, 23367585, 23236778, 22443543, 31723439, 22934699, 22934399, 22516029, 22515992, 22463839, 22463413, 22443763, 22446956, 22453608, 22445886, 22461332, 22692840, 22455977, 22471655, 22471636, 22461535, 22447302], "D": [22462793, 22462750, 22462690, 22450389, 22469047, 22498066]}, "name": "D. Recover a functional graph", "statement": "Functional graph is a directed graph in which all vertices have\r\noutdegree equal to . Loops are allowed.Some vertices of a functional\r\ngraph lay on a cycle. From the others we can come to a cycle by making a\r\nfinite number of steps along the edges (we consider only finite\r\nfunctional graphs in this problem).Let\u2019s compute two values for each\r\nvertex. is the amount of edges we should pass to get to a vertex which\r\nis a part of some cycle (zero, if itself lies on a cycle), is the length\r\nof the cycle we get to.You are given the information about these values\r\nfor some functional graph. For each vertex you know the values and ,\r\nhowever, instead of some values there can be the question mark. It means\r\nthat these values are unknown.Build any functional graph that suits the\r\ndescription or determine that there is no such graph.\r\n", "solutions": ["#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <ctime>\n#include <map>\n#include <math.h>\n#include <cstdio>\n#include <set>\n#include <deque>\n#include <memory.h>\n#include <queue>\n\n#pragma comment(linker, \"/STACK:64000000\")\ntypedef long long ll;\n#define tm ttm\n\nusing namespace std;\n\nconst int MAXK = -1;\nconst int MAXN = 602;\nconst int MOD = 1; // 1000 * 1000 * 1000 + 7;\n\nint n;\nint pc[MAXN];\nint c[MAXN];\nint nxt[MAXN];\n\nvoid read(int &x) {\n\tstring s;\n\tcin >> s;\n\tif (s == \"?\") {\n\t\tx = -1;\n\t\treturn;\n\t}\n\tstringstream ss;\n\tss << s;\n\tss >> x;\n}\nvector<pair<int, int> > o;\n\nbool eq(int x, int y) {\n\treturn x == y || y == -1;\n}\n\nvector<int> e[MAXN];\nint mt[MAXN], tm[MAXN];\nint vis[MAXN], tmr;\n\nbool dfs(int v) {\n\tif (vis[v] == tmr) return 0;\n\tvis[v] = tmr;\n\tfor (int to : e[v]) {\n\t\tif (mt[to] == -1) {\n\t\t\tmt[to] = v;\n\t\t\ttm[v] = to;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor (int to : e[v]) {\n\t\tif (dfs(mt[to])) {\n\t\t\tmt[to] = v;\n\t\t\ttm[v] = to;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\n\twhile (cin >> n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tread(pc[i]);\n\t\t\tread(c[i]);\n\t\t\tnxt[i] = -1;\n\t\t}\n\t\tmap<int, map<int, vector<int> > > mp;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmp[c[i]][pc[i]].push_back(i);\n\t\t}\n\n\t\tbool ok = 0;\n\n\t\tint nmx = 0;\n\t\tif (mp.count(-1)) {\n\t\t\tnmx = max(0, mp[-1].rbegin()->first);\n\t\t}\n\n\t\tvector<int> mx(n + 1, -1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!mp.count(i)) continue;\n\t\t\tmx[i] = mp[i].rbegin()->first;\n\t\t}\n\n\t\tfor (int nc = 1; nc <= n; nc++) {\n\t\t\tbool wasnt = !mp.count(nc);\n\t\t\tmp[nc];\n\t\t\tint old = mx[nc];\n\t\t\tmx[nc] = max(mx[nc], nmx);\n\n\t\t\to.clear();\n\t\t\tfor (int cc = 1; cc <= n; cc++) {\n\t\t\t\tif (!mp.count(cc)) continue;\n\t\t\t\tvector<int> vct = mp[cc][0];\n\t\t\t\tvector<int> vv;\n\t\t\t\tvector<vector<int> > cycles;\n\t\t\t\tfor (int x : vct) {\n\t\t\t\t\tif (vv.size() == cc) {\n\t\t\t\t\t\tfor (int i = 0; i < (int)vv.size(); i++) nxt[vv[i]] = vv[(i + 1) % vv.size()];\n\t\t\t\t\t\tcycles.push_back(vv);\n\t\t\t\t\t\tvv.clear();\n\t\t\t\t\t}\n\t\t\t\t\tvv.push_back(x);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < cc - (int)vv.size(); i++) {\n\t\t\t\t\to.push_back(make_pair(0, cc));\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= mx[cc]; i++) {\n\t\t\t\t\tif (!mp[cc].count(i)) {\n\t\t\t\t\t\to.push_back(make_pair(i, cc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint m = o.size();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\te[i].clear();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif ((pc[i] == -1 || c[i] == -1) && eq(o[j].first, pc[i]) && eq(o[j].second, c[i])) {\n\t\t\t\t\t\t//e[i].push_back(j);\n\t\t\t\t\t\te[j].push_back(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmt[i] = -1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\ttm[i] = -1;\n\t\t\t}\n\t\t\t/*bool cok = 1;\n\t\t\tfor (int i = 0; cok && i < m; i++) {\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tcok &= dfs(i);\n\t\t\t}*/\n\t\t\tfor (int run = 1; run;) {\n\t\t\t\trun = 0;\n\t\t\t\ttmr++;\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tif (tm[i] == -1 && dfs(i)) {\n\t\t\t\t\t\trun = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool cok = 1;\n\t\t\tfor (int i = 0; i < m; i++) cok &= tm[i] != -1;\n\n\t\t\tif (cok) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t//pc[mt[i]] = o[i].first;\n\t\t\t\t\t//c[mt[i]] = o[i].second;\n\t\t\t\t\tif (mt[i] != -1) {\n\t\t\t\t\t\tpc[i] = o[mt[i]].first;\n\t\t\t\t\t\tc[i] = o[mt[i]].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmx[nc] = old;\n\t\t\tif (wasnt) mp.erase(nc);\n\t\t}\n\n\t\tif (ok) {\n\t\t\tvector<vector<int> > vv(n + 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (nxt[i] == -1 && pc[i] == 0 && c[i] != -1) {\n\t\t\t\t\tvv[c[i]].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j < (int)vv[i].size(); j++) {\n\t\t\t\t\tnxt[vv[i][j]] = vv[i][(j + 1) % vv[i].size()];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mxc = 0;\n\t\t\tfor (int i = 0; i <= n; i++) if (mx[i] > mx[mxc]) mxc = i;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (nxt[i] != -1) continue;\n\t\t\t\tif ((c[i] == -1 || c[i] == 1) && pc[i] == 0) {\n\t\t\t\t\tnxt[i] = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pc[i] == -1) pc[i] = 1;\n\t\t\t\tif (c[i] == -1) {\n\t\t\t\t\t//c[i] = mp.rbegin()->first;\n\t\t\t\t\tc[i] = mxc;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (c[j] == c[i] && pc[j] + 1 == pc[i]) {\n\t\t\t\t\t\tnxt[i] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(nxt[i] != -1);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) cout << nxt[i] + 1 << \" \\n\"[i + 1 == n];\n\t\t}\n\t\telse {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["graph matchings"], "dificulty": "3400", "interactive": false}