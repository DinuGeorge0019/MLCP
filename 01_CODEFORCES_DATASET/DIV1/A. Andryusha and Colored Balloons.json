{
    "link": "https://codeforces.com//contest/781/problem/A",
    "problemId": "96949",
    "problem_idx": "A",
    "shortId": "781A",
    "contest_number": "781",
    "problem_submissions": {
        "B": [
            25258392,
            25257297,
            25250177,
            25250748,
            25251116,
            25249653,
            25250716,
            25250834,
            25250705,
            25251947,
            25250575,
            31121662,
            25252893,
            25252683,
            25253146,
            25255775,
            25252991,
            25253498
        ],
        "E": [
            25256397,
            25254067,
            25258825,
            25260075,
            26145785,
            25259028,
            25259758,
            25260563,
            25260848,
            25261488,
            25260086,
            25703349,
            25261912,
            25262169,
            25262264,
            25261946,
            25261665,
            25262876,
            25262009
        ],
        "D": [
            25252423,
            25259248,
            25255529,
            25254368,
            25256042,
            25256267,
            25256774,
            25256075,
            25254834,
            25256057,
            25266603,
            25256151,
            25257817,
            25258124,
            25258109,
            25258052,
            25258679,
            25258333
        ],
        "C": [
            25249500,
            25249747,
            25251802,
            25252056,
            25252378,
            25250971,
            25252726,
            25253382,
            25252087,
            25253151,
            25252105,
            25254478,
            25253975,
            25254827,
            25254070,
            25255284,
            25254950
        ],
        "A": [
            25247143,
            25247027,
            25247783,
            25247695,
            25248775,
            25247133,
            25247620,
            25248678,
            25249108,
            25249147,
            25247139,
            25249553,
            25248502,
            25248323,
            25249740,
            25249518,
            25247402
        ],
        "F": [
            25268984,
            25267317,
            25271843,
            25271410,
            25271394,
            25271157,
            25270611,
            26202615
        ]
    },
    "name": "A. Andryusha and Colored Balloons",
    "statement": "Andryusha goes through a park each day. The squares and paths between\r\nthem look boring to Andryusha, so he decided to decorate them.The park\r\nconsists of squares connected with bidirectional paths in such a way\r\nthat any square is reachable from any other using these paths. Andryusha\r\ndecided to hang a colored balloon at each of the squares. The baloons\u2019\r\ncolors are described by positive integers, starting from . In order to\r\nmake the park varicolored, Andryusha wants to choose the colors in a\r\nspecial way. More precisely, he wants to use such colors that if , and\r\nare distinct squares that and have a direct path between them, and and\r\nhave a direct path between them, then balloon colors on these three\r\nsquares are distinct.Andryusha wants to use as little different colors\r\nas possible. Help him to choose the colors!\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:1000000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n\n\nconst int MAXN = 200001;\nvector <int> e[MAXN];\nint ans[MAXN];\n\nvoid dfs(int v, int p)\n{\n\tint c = 0;\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tint u = e[v][i];\n\t\tif (u == p) continue;\n\t\tc++;\n\t\twhile ((c == ans[v]) || (c == ans[p])) c++;\n\t\tans[u] = c;\n\t\tdfs(u, v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tint n;\n\tcin >> n;\n\tint mv = 1;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\t\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tif (e[i].size() > e[mv].size()) mv = i;\n\t}\n\tans[mv] = 1;\n\tfor (int i = 0; i < e[mv].size(); i++)\n\t{\n\t\tans[e[mv][i]] = i + 2;\n\t\tdfs(e[mv][i], mv);\n\t}\n\tcout << e[mv].size() + 1 << endl;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Andryusha and Colored Balloons.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "If is a vertex of degree , then the answer is at least . Indeed, any two\r\nneighbours of can be connected by a path of length three via vertex .\r\nAlso, lies on a common three-vertex path with any of its neighbours\r\n(possibly using a non-neighbour vertex). It follows that and all of its\r\nneighbours must have pairwise distinct colors.Let us show that the\r\nstrongest of these estimates is best possible, that is, construct a\r\ncoloring with colors, where is the maximal degree. Root the tree at\r\narbitrary vertex, and color the root with color 1, also color its\r\nchildren with subsequent colors. All the rest vertices will be colored\r\nas follows: if a vertex is colored , and its parent is colored , then\r\nfor the children of we will use numbers starting from 1 skipping and .\r\nOne can check that no color with number larger than shall be used.\r\nImplementation-wise, this is a simple DFS procedure.Complexity: time and\r\nmemory.\r\n"
}