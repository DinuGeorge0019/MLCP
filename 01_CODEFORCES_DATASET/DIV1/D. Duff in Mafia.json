{
    "link": "https://codeforces.com//contest/587/problem/D",
    "problemId": "38261",
    "problem_idx": "D",
    "shortId": "587D",
    "contest_number": "587",
    "problem_submissions": {
        "B": [
            13648546,
            13631319,
            13641731,
            13630364,
            13633855,
            13635275,
            13633091,
            13631092,
            13632489,
            13636118,
            13634961,
            13633410,
            13637437,
            13631295,
            13631061,
            13631176,
            13632360,
            13636955,
            13631513,
            13651693
        ],
        "F": [
            13647165,
            15306413,
            17349765,
            13654656
        ],
        "E": [
            13635518,
            13645026,
            13634711,
            13645375,
            13645998,
            13646627,
            13648041,
            13649025,
            13654642,
            13649552,
            13647771,
            13647562,
            13649838,
            13647318,
            13650802,
            13654796,
            13653392,
            13655928
        ],
        "A": [
            13627098,
            13626726,
            13642310,
            13627311,
            13628719,
            13627650,
            13627049,
            13626772,
            13626754,
            13627918,
            13626713,
            13628042,
            13629897,
            13626736,
            13627142,
            13626620,
            13626815,
            13629767,
            13626766,
            13627175
        ],
        "C": [
            13638605,
            13644702,
            13638823,
            13638488,
            13639824,
            13640040,
            13637207,
            13636153,
            13640829,
            13642556,
            13639860,
            13642332,
            13636367,
            13653829,
            13637091,
            13635819,
            13636868,
            13633329,
            13636406,
            13632991
        ],
        "D": [
            16774884,
            14175098,
            13654446,
            13648717
        ]
    },
    "name": "D. Duff in Mafia",
    "statement": "Duff is one if the heads of Mafia in her country, Andarz Gu. Andarz Gu\r\nhas cities (numbered from 1 to ) connected by bidirectional roads\r\n(numbered by to ).Each road has a destructing time, and a color. -th\r\nroad connects cities and and its color is and its destructing time is\r\n.Mafia wants to destruct a in Andarz Gu. A is a subset of roads such\r\nthat no two roads in this subset has common endpoint. They can destruct\r\nthese roads in parallel, i. e. the total destruction time is a maximum\r\nover destruction times of all selected roads. They want two conditions\r\nto be satisfied: The remaining roads form a . Destructing time of this\r\nmatching is minimized. The remaining roads after destructing this\r\nmatching form a if and only if no two roads of the same color have same\r\nendpoint, or, in the other words, edges of each color should form a\r\n.There is no programmer in Mafia. Thatâ€™s why Duff asked for your help.\r\nPlease help her and determine which matching to destruct in order to\r\nsatisfied those conditions (or state that this is not possible).\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define pi ((db)3.14159265358979323846264338327950288L)\n#define buli __builtin_popcountll\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nint inf=0x3f3f3f3f;\ndb eps=1e-6;\nint mo=1000000007;\nint qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\nnamespace sat{\n\n\tconst int SAT_MAXV=300000+5;\n\tconst int SAT_MAXE=300000+5;\n\tstruct edge{int v,next;}e[SAT_MAXE*4];int g[SAT_MAXV*2],etot;\n\tint vtot;\n\tvoid ae(int u,int v){\n\t\te[etot].v=v;e[etot].next=g[u];g[u]=etot++;\n\t\tupmax(vtot,(max(u,v)+1)>>1);\n\t}\n\tint dfn[SAT_MAXV*2],low[SAT_MAXV*2],stk[SAT_MAXV*2];bool inst[SAT_MAXV*2];int ind,top,scctot,sccid[SAT_MAXV*2],seq[SAT_MAXV*2],seqtot;\n\tint tmpans[SAT_MAXV*2],ans[SAT_MAXV];\n\tvoid dfs(int u){\n\t\tdfn[u]=low[u]=++ind;\n\t\tinst[stk[++top]=u]=1;\n\t\tfor (int i=g[u];~i;i=e[i].next)\n\t\t\tif(!dfn[e[i].v]){\n\t\t\t\tdfs(e[i].v);\n\t\t\t\tlow[u]=min(low[u],low[e[i].v]);\n\t\t\t}else if(inst[e[i].v])\n\t\t\t\tlow[u]=min(low[u],dfn[e[i].v]);\n\t\tif(low[u]==dfn[u]){\n\t\t\t++scctot;\n\t\t\twhile(1){\n\t\t\t\tbool bo=stk[top]==u;\n\t\t\t\tseq[++seqtot]=stk[top];\n\t\t\t\tsccid[stk[top]]=scctot;\n\t\t\t\tinst[stk[top--]]=0;\n\t\t\t\tif(bo)break;\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs2(int u){\n\t\ttmpans[u]=1;\n\t\tfor (int i=g[u];~i;i=e[i].next)if(!~tmpans[e[i].v])dfs2(e[i].v);\n\t}\n\tbool sat(){\n\t\trep(i,1,2*vtot+1)if(!dfn[i])dfs(i);\n\t\trep(i,1,vtot+1)if(sccid[2*i-1]==sccid[2*i])return 0;\n\t\treturn 1;\n\t}\n\tvoid getsol(){\n\t\trep(i,1,2*vtot+1)tmpans[i]=-1;\n\t\tper(i,1,2*vtot+1){\n\t\t\tint u=seq[i];\n\t\t\tif(!~tmpans[u]){\n\t\t\t\ttmpans[u]=0;\n\t\t\t\tif(u&1)u++;\n\t\t\t\telse u--;\n\t\t\t\tdfs2(u);\n\t\t\t}\n\t\t}\n\t\trep(i,1,vtot+1)ans[i]=tmpans[i*2-1];\n\t}\n\tvoid make(int i,bool v){\n\t\tif(v)ae(i*2,i*2-1);\n\t\telse ae(i*2-1,i*2);\n\t}\n\tvoid makenot(int i,bool v,int j,bool w){\n\t\tae(i*2-v,j*2-(!w)),ae(j*2-w,i*2-(!v));\n\t}\n\tvoid makeand(int i,int j,bool v){\n\t\tif(v)make(i,1),make(j,1);\n\t\telse makenot(i,1,j,1);\n\t}\n\tvoid makeor(int i,int j,bool v){\n\t\tif(!v)make(i,0),make(j,0);\n\t\telse makenot(i,0,j,0);\n\t}\n\tvoid makexor(int i,int j,bool v){\n\t\tif(v)makenot(i,0,j,0),makenot(i,1,j,1);\n\t\telse makenot(i,1,j,0),makenot(i,0,j,1);\n\t}\n\tvoid sat_init(){\n\t\tstatic bool ini=0;\n\t\tif(!ini){\n\t\t\tini=1;\n\t\t\tmemset(g,-1,sizeof(g));\n\t\t}else{\n\t\t\tfor (int i=0;i<=2*vtot;i++)g[i]=-1,dfn[i]=low[i]=sccid[i]=0;\n\t\t}\n\t\tvtot=etot=scctot=ind=seqtot=0;\n\t}\n\n};\n\n\nvi ad[55555];\nint n,m;\nstruct edge{\n\tint u,v,c,t,id;\n}e[55555];\nmap<int,int>ma;\nint check(int T){\n\tint ndtot=m;\n\tsat::sat_init();\n\tfor (int u=1;u<=n;u++){\n\t\tint bo=0;\n\t\tma.clear();\n\t\tfor (int i=0;i<siz(ad[u]);i++){\n\t\t\tint id=ad[u][i];\n\t\t\tif(ma[e[id].c]){\n\t\t\t\tif(bo)return 0;\n\t\t\t\tbo=e[id].c;\n\t\t\t}\n\t\t\tma[e[id].c]++;\n\t\t}\n\t\tif(bo){\n\t\t\tint x=0,y=0;\n\t\t\trep(i,0,siz(ad[u])){\n\t\t\t\tint id=ad[u][i];\n\t\t\t\tif(e[id].c!=bo)sat::make(id,0);\n\t\t\t\telse {\n\t\t\t\t\tif(x==0)x=id;\n\t\t\t\t\telse y=id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsat::makexor(x,y,1);\n\t\t}else{\n\t\t\trep(i,0,siz(ad[u])){\n\t\t\t\tint id=ad[u][i];\n\t\t\t\tsat::makenot(id,1,ndtot+i+1,0);\n\t\t\t\tif(i){\n\t\t\t\t\tsat::makenot(ndtot+i+1-1,1,ndtot+i+1,0);\n\t\t\t\t\tsat::makeand(ndtot+i+1-1,id,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tndtot+=siz(ad[u]);\n\t\t}\n\t}\n\trep(i,1,m+1)if(e[i].t>T)sat::make(i,0);\n\treturn sat::sat();\n}\n\nint main()\n{\n#ifdef JCVB\n\tfreopen(\"1.in\",\"r\",stdin);\n\tfreopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(m);\n\trep(i,1,m+1){\n\t\tint u,v,c,t;\n\t\tgn(u);gn(v);gn(c);gn(t);\n\t\te[i]=(edge){u,v,c,t,i};\n\t\tad[u].pb(i);\n\t\tad[v].pb(i);\n\t}\n\tif(!check(2e9)){\n\t\tprintf(\"No\\n\");\n\t}else{\n\t\tint l=0,r=1e9,mid;\n\t\twhile(l<=r){\n\t\t\tmid=l+r>>1;\n\t\t\tif(check(mid))r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tcheck(l);\n\t\tsat::getsol();\n\t\tint su=0;\n\t\trep(i,1,m+1)if(sat::ans[i])su++;\n\t\tprintf(\"Yes\\n%d %d\\n\",l,su);\n\t\trep(i,1,m+1)if(sat::ans[i])printf(\"%d \",i);\n\t}\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "binary search"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Duff in Mafia.json",
    "editorial_link": "https://codeforces.com//blog/entry/20971",
    "editorial": "Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):\n\nFirst of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".\n\nUse 2-Sat. Consider a literal for each edge e (xe). If xe?=?TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions:\n\nFor each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause .\n\nFor each vertex v, if the edges connected to it are e1,?e2,?...,?ek, we should make sure that there is no pair (i,?j) where 1???i?<?j???k and xe1?=?xe2?=?True. The naive approach is to add a clause  for each pair. But it's not efficient.\n\n \n\nThe efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1,?p2,?...,?pk and for each j???i, make sure . To make sure about this, we can add two clauses for each pi:  and  (the second one is only for i?>?1).\n\nAnd the only thing left is to make sure  (there are no two TRUE edges).\n\nThis way the number of literals and clauses are .\n\nSo, after binary search is over, we should run check(t) to get a sample matching.",
    "hint": []
}