{
    "link": "https://codeforces.com//contest/2023/problem/F",
    "problemId": "2964369",
    "problem_idx": "F",
    "shortId": "2023F",
    "contest_number": "2023",
    "problem_submissions": {
        "F": [
            287014608,
            287072234,
            299830672,
            287085195,
            287027962,
            287042299,
            287238133,
            287043650
        ],
        "E": [
            286990891,
            287003441,
            287204391,
            287202274,
            287014470,
            287010378,
            287009293,
            287034992,
            287190288,
            287004818,
            287142133
        ],
        "D": [
            286943910,
            286985197,
            287179114,
            287178062,
            286983477,
            286986708,
            286993474,
            286930212,
            286984453,
            286985894,
            286983025,
            286981875,
            287091406,
            286988866,
            286991623,
            286991730,
            286972363,
            290388826,
            290388744,
            286996161,
            286993279,
            287000155,
            287068676,
            287061033,
            286997472,
            287003784
        ],
        "C": [
            286925333,
            287063584,
            286928411,
            286930839,
            286944563,
            286945303,
            286973941,
            286936797,
            286923792,
            286935049,
            286934113,
            286960906,
            286944493,
            286935726,
            286931426,
            286988231,
            286961072,
            286929444,
            286959433,
            286973882,
            286960461
        ],
        "B": [
            286913842,
            286912400,
            286915696,
            286920706,
            286917936,
            286918820,
            286920898,
            286929873,
            286915247,
            286917134,
            286915488,
            286916176,
            286919025,
            286919305,
            286914068,
            286921817,
            286912738,
            286921828,
            286922164,
            286920262
        ],
        "A": [
            286905356,
            286905575,
            286907414,
            286907460,
            286908014,
            286911602,
            286910636,
            286905107,
            286906378,
            286906055,
            286906420,
            286919318,
            286909880,
            286905489,
            286910067,
            286910062,
            286905533,
            286909956,
            286907288,
            286911621
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135341",
    "editorial": "To begin, letâs solve the problem for a single query, where and .We will\r\nintroduce an additional constraint the dump truck must start on the\r\nfirst segment and finish on the last one. We will calculate the prefix\r\nsums of the array , denoted as . If , then the answer is , as there\r\nwonât be enough sand to cover all ; otherwise, an answer exists. Let be\r\nthe number of times the dump truck travels between segments and (in\r\neither direction). Notice that if , then . Since the dump truck starts\r\nto the left of segment , it will have to pass through once.\r\nAdditionally, since , it will have to return to the prefix to balance it\r\nout (it wonât have enough sand to cover the negative ). Then it will\r\nhave to pass through a third time, as the dump truck must finish its\r\njourney to the right of segment . The dump truck can travel such that\r\nwhen , , and when , . To achieve this, it simply needs to travel from\r\nleft to right, and if , it just returns left while traversing the\r\nnegative prefix sums, nullifying the negative . If it reaches , then the\r\nentire prefix to the left of it has already been nullified (we maintain\r\nthis invariant), and it simply returns right to . The entire prefix is\r\nnullified. With this algorithm, we achieve when and otherwise, which is\r\nthe optimal answer to the problem.Now, letâs remove the constraint on\r\nthe starting and ending positions of the dump truck. Let the dump truck\r\nstart at segment and finish at segment , with . Then, if , , since the\r\ndump truck starts and finishes to the right of segment , meaning it\r\nneeds to reach it and then return right. Similarly, if , then . For all\r\n, the constraints on described earlier still hold. How can we now\r\nachieve optimal ? Let the dump truck travel from to , nullifying all and\r\ncollecting sand, and then travel right to , covering all (here we used\r\nthe fact that , which we will prove later). From to , the dump truck\r\nfollows the previously described algorithm for and . Next, it will\r\ntravel from to , nullifying , and then return to , covering . Thus, we\r\nhave obtained optimal . We still need to understand why . Suppose this\r\nis not the case; then, according to our estimates, . But if we increase\r\nby , this estimate will decrease to , meaning we have no reason to\r\nconsider this . If we cannot increase by , it means that . Then for all\r\n, we have the estimate . But then we can simply traverse all segments\r\nfrom right to left and then from left to right, resulting in all . The\r\ncase has been analyzed. If , we simply need to reverse the array and\r\ntransition to the case .Letâs try to better understand what we have\r\nactually done by removing the constraints on the starting and ending\r\npositions of the dump truck. Letâs look at the array . Initially, it\r\ncontains and ; we can replace some prefix and suffix with . The answer\r\nto the problem is the sum of the resulting array. First, letâs\r\nunderstand how to recalculate and . We will sort the queries by\r\n(assuming ). Letâs consider the segment . Its prefix sums are . Notice\r\nthat as increases, the values will decrease. Therefore, if we consider\r\nthe queries in increasing order of , initially for any , and then they\r\ngradually become (when becomes less than ). We need to come up with a\r\nstructure that can efficiently find the optimal replacement over a\r\nsegment. We can simply use a Segment Tree, where each node will store\r\nvalues the sum over the segment without replacements; the sum over the\r\nsegment if everything is replaced; the sum over the segment if the\r\nprefix is optimally replaced; the sum over the segment if the suffix is\r\noptimally replaced; and the sum over the segment if both the prefix and\r\nsuffix are optimally replaced. It is not difficult to figure out how to\r\ncombine segments (this problem is very similar to the well-known problem\r\nof finding the maximum subarray of ones in a binary array). To solve the\r\nproblem, we just need to make replacements of with at a point and make a\r\nquery over the segment in this Segment Tree. This solution needs to be\r\nrun times, once for the original array and once for its reversed\r\nversion. The answer to the query is the minimum of the two obtained\r\nresults.The complexity of the solution is time and space.\r\n",
    "name": "F. Hills and Pits",
    "statement": "In a desert city with a hilly landscape, the city hall decided to level\r\nthe road surface by purchasing a dump truck. The road is divided into n\r\nsections, numbered from 1 to n from left to right. The height of the\r\nsurface in the i-th section is equal to a_i. If the height of the i-th\r\nsection is greater than 0, then the dump truck must take sand from the\r\ni-th section of the road, and if the height of the i-th section is less\r\nthan 0, the dump truck must fill the pit in the i-th section of the road\r\nwith sand. It is guaranteed that the initial heights are not equal to\r\n0.When the dump truck is in the i-th section of the road, it can either\r\ntake away x units of sand, in which case the height of the surface in\r\nthe i-th section will decrease by x, or it can fill in x units of sand\r\n(provided that it currently has at least x units of sand in its bed), in\r\nwhich case the height of the surface in the i-th section of the road\r\nwill increase by x.The dump truck can start its journey from any section\r\nof the road. Moving to an adjacent section on the left or right takes 1\r\nminute, and the time for loading and unloading sand can be neglected.\r\nThe dump truck has an infinite capacity and is initially empty.You need\r\nto find the minimum time required for the dump truck to level the sand\r\nso that the height in each section becomes equal to 0. Note that after\r\nall movements, the dump truck . You need to solve this problem for the\r\nsegments numbered from l_i to r_i. Sand outside the segment cannot be\r\nused.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long; constexpr int inf = 1E9;template<class Info>struct SegmentTree {    int n;    std::vector<Info> info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template<class T>    SegmentTree(std::vector<T> init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template<class T>    void init(std::vector<T> init_) {        n = init_.size();        info.assign(4 << std::__lg(n), Info());        std::function<void(int, int, int)> build = [&](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x < m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l >= y || r <= x) {            return Info();        }        if (l >= x && r <= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template<class F>    int findFirst(int p, int l, int r, int x, int y, F &&pred) {        if (l >= y || r <= x) {            return -1;        }        if (l >= x && r <= y && !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template<class F>    int findFirst(int l, int r, F &&pred) {        return findFirst(1, 0, n, l, r, pred);    }    template<class F>    int findLast(int p, int l, int r, int x, int y, F &&pred) {        if (l >= y || r <= x) {            return -1;        }        if (l >= x && r <= y && !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template<class F>    int findLast(int l, int r, F &&pred) {        return findLast(1, 0, n, l, r, pred);    }}; struct Info {    int a[3][3];    Info() {        for (int i = 0; i < 3; i++) {            for (int j = 0; j < 3; j++) {                a[i][j] = (i == j ? 0 : inf);            }        }    }}; Info operator+(const Info &a, const Info &b) {    Info c;    for (int i = 0; i < 3; i++) {        for (int j = 0; j < 3; j++) {            c.a[i][j] = inf;        }    }    for (int i = 0; i < 3; i++) {        for (int j = i; j < 3; j++) {            for (int k = j; k < 3; k++) {                c.a[i][k] = std::min(c.a[i][k], a.a[i][j] + b.a[j][k]);            }        }    }    return c;} void solve() {    int n, q;    std::cin >> n >> q;        std::vector<int> a(n);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }        std::vector<int> ans(q, inf);    std::vector<int> l(q), r(q);    for (int i = 0; i < q; i++) {        std::cin >> l[i] >> r[i];        l[i]--;    }        auto work = [&]() {        std::vector<i64> pre(n + 1);        for (int i = 0; i < n; i++) {            pre[i + 1] = pre[i] + a[i];        }                std::vector<int> ord;        for (int i = 0; i < q; i++) {            if (pre[r[i]] < pre[l[i]]) {                continue;            }            ord.push_back(i);        }        std::sort(ord.begin(), ord.end(),            [&](int i, int j) {                return pre[l[i]] > pre[l[j]];            });        std::vector<int> p(n + 1);        std::iota(p.begin(), p.end(), 0);        std::sort(p.begin(), p.end(),            [&](int i, int j) {                return pre[i] > pre[j];            });                SegmentTree<Info> seg(n + 1);        for (int j = 0; auto i : ord) {            while (j <= n && pre[p[j]] >= pre[l[i]]) {                Info c;                c.a[1][1] = -2;                c.a[0][1] = -p[j];                c.a[1][2] = p[j];                c.a[0][2] = 2;                seg.modify(p[j], c);                j++;            }            auto c = seg.rangeQuery(l[i] + 1, r[i]);            ans[i] = std::min(ans[i], std::min({c.a[0][2] - 4, c.a[1][2] - 2 - l[i], c.a[0][1] - 2 + r[i], c.a[1][1] + r[i] - l[i] - 2}) + 2 * (r[i] - l[i]) - 1);        }    };        work();    std::reverse(a.begin(), a.end());    for (int i = 0; i < q; i++) {        std::tie(l[i], r[i]) = std::make_pair(n - r[i], n - l[i]);    }    work();        for (int i = 0; i < q; i++) {        if (ans[i] == inf) {            ans[i] = -1;        }        std::cout << ans[i] << \"\\n\";    }} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }     return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math",
        "matrices"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Hills and Pits.json",
    "hint": []
}