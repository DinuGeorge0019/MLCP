{"link": "https://codeforces.com//contest/1477/problem/F", "problemId": "879400", "problem_idx": "F", "shortId": "1477F", "contest_number": "1477", "problem_submissions": {"F": [106163553, 106080431, 106150219, 105761318, 105790194, 105781844], "E": [105766462, 105760921, 105747638, 105773646, 105773472, 105764661, 105770759, 105771270, 105749455, 107250678, 107250631, 105808122], "D": [105731973, 105737956, 105755294, 105737357, 105717044, 105720581, 105719208, 105736745, 105737576, 105738580, 105738914, 105740692, 105740131, 105745290, 105736926, 105743296, 105740891, 105744844], "C": [105691291, 105711864, 105715665, 105695858, 105694977, 105690018, 105684885, 105689512, 105691536, 105703366, 105691967, 105704561, 105705153, 105695098, 105696313, 105696567, 105685916, 105688953, 105706121, 105699876], "B": [105686611, 105689935, 105698256, 105689750, 105687613, 105687015, 105689324, 105687283, 105688577, 105688486, 105689038, 105688335, 105694661, 105689327, 105691535, 105686246, 105746534, 105716194, 105694969, 105691857], "A": [105676617, 105680391, 105688488, 105677583, 105677613, 105677290, 105676167, 105677997, 105678469, 105681155, 105678265, 105679581, 105683427, 105682439, 105681417, 105677926, 105677952, 105676881, 105698728, 105687449]}, "name": "F. Nezzar and Chocolate Bars", "statement": "Nezzar buys his favorite snack n chocolate bars with lengths l_1,l_2,\r\nldots,l_n. However, chocolate bars might be too long to store them\r\nproperly! In order to solve this problem, Nezzar designs an interesting\r\nprocess to divide them into small pieces. Firstly, Nezzar puts all his\r\nchocolate bars into a black box. Then, he will perform the following\r\noperation repeatedly until the maximum length over all chocolate bars\r\ndoes not exceed k. Nezzar picks a chocolate bar from the box with\r\nprobability proportional to its length x. After step 1, Nezzar uniformly\r\npicks a real number r\r\nin (0,x) and divides the chosen chocolate bar into two chocolate bars\r\nwith lengths r and x-r. Lastly, he puts those two new chocolate bars\r\ninto the black box. Nezzar now wonders, what is the expected number of\r\noperations he will perform to divide his chocolate bars into small\r\npieces.It can be shown that the answer can be represented as\r\nfrac{P}{Q}, where P and Q are coprime integers and Q\r\nnot\r\nequiv 0 (\r\nbmod 998\r\n,244\r\n,353). Print the value of P\r\ncdot Q^{-1}\r\nmod 998\r\n,244\r\n,353.\r\n", "solutions": ["#ifndef LOCAL\n#pragma GCC optimize (\"-Ofast\")\n#pragma GCC optimize (\"-unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107 \u306f verify \u3057\u3066\u306d\u3048\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\n#ifdef USE_GOOD_MOD\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tvc<mint> z(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\n\n#else\n\n//59501818244292734739283969-1=5.95*10^25 \u307e\u3067\u306e\u5024\u3092\u6b63\u3057\u304f\u8a08\u7b97\n//\u6700\u7d42\u7684\u306a\u5217\u306e\u5927\u304d\u3055\u304c 2^24 \u307e\u3067\u306a\u3089\u52d5\u304f\n//\u6700\u7d42\u7684\u306a\u5217\u306e\u5927\u304d\u3055\u304c 2^20 \u4ee5\u4e0b\u306e\u3068\u304d\u306f\uff0c\u4e0b\u306e 3 \u3064\u306e\u7d20\u6570\u3092\u4f7f\u3063\u305f\u307b\u3046\u304c\u901f\u3044\uff08\u306f\uff1f\uff09\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\t//constexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\t//constexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\t//constexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\textern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\textern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\textern constexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n}\nusing arbitrary_convolution::multiply;\n\n#endif\n\nnamespace integer_convolution{\n\textern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\textern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\ttemplate<class t>\n\tvc<t> sub(const vi&x,const vi&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i];\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i];\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\tvi multiply(const vi&x,const vi&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tconst mint1 r=mint1(mint0::mod).inv();\n\t\tint n=si(d0);\n\t\tvi res(n);\n\t\trep(i,n){\n\t\t\tres[i]=d0[i].v+(r*(d1[i]-d0[i].v)).v*(ull)mint0::mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n//\u6700\u5927\u3067 1<<mx \u306e\u30b5\u30a4\u30ba\u306e fft \u304c\u767b\u5834\uff01\ntemplate<class mint>\nvc<mint> large_convolution(const vc<mint>&a,const vc<mint>&b,int mx){\n\tint n=si(a),m=si(b);\n\tvc<mint> c(n+m-1);\n\tint len=1<<(mx-1);\n\tfor(int i=0;i<n;i+=len){\n\t\tfor(int j=0;j<n;j+=len){\n\t\t\tint x=min(len,n-i),y=min(len,m-j);\n\t\t\tauto d=multiply(vc<mint>(a.bg+i,a.bg+i+x),vc<mint>(b.bg+j,b.bg+j+y));\n\t\t\trep(k,si(d))\n\t\t\t\tc[i+j+k]+=d[k];\n\t\t}\n\t}\n\treturn c;\n}\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\n//UOJ Round18 B\n//UOJ Long Round C\nvvc<mint> convolute2d(const vvc<mint>&x,const vvc<mint>&y){\n\tint n1=si(x),m1=si(x[0]);\n\tint n2=si(y),m2=si(y[0]);\n\tint n=n1+n2-1,m=m1+m2-1;\n\tint s=1;\n\twhile(s<n*m)s*=2;\n\tvc<mint> p(s),q(s);\n\trep(i,n1)rep(j,m1)p[i*m+j]=x[i][j];\n\trep(i,n2)rep(j,m2)q[i*m+j]=y[i][j];\n\tinplace_fmt(p,false);\n\tinplace_fmt(q,false);\n\trep(i,s)p[i]*=q[i];\n\tinplace_fmt(p,true);\n\tvvc<mint> res(n,vc<mint>(m));\n\trep(i,n)rep(j,m)res[i][j]=p[i*m+j];\n\treturn res;\n}\n\n// f \u306f k \u6b21\u591a\u9805\u5f0f\u3092 0 \u304b\u3089 k \u3067\u8a55\u4fa1\u3057\u305f\u5024\u304c\u5165\u308b\n//sum {0<=i<=inf} a^i f[i]\nmint exp_poly_sum_limit(const mint a,const vc<mint>&f){\n\tassert(a!=1);\n\tint k=si(f)-1;\n\tif(a==0){\n\t\treturn f[0];\n\t}else{\n\t\tvc<mint> g(k+1);\n\t\t{\n\t\t\tmint r=1;\n\t\t\trep(i,k+1){\n\t\t\t\tg[i]=f[i]*r;\n\t\t\t\tr*=a;\n\t\t\t}\n\t\t}\n\t\tmint c;\n\t\t{\n\t\t\tmint w,r=1;\n\t\t\trep(i,k+1){\n\t\t\t\tw+=choose(k+1,i)*r;\n\t\t\t\tr*=-a;\n\t\t\t\tc+=g[k-i]*w;\n\t\t\t}\n\t\t\tc/=mint(1-a).pow(k+1);\n\t\t}\n\t\treturn c;\n\t}\n}\n\n//exp(ax)*f \u306e k \u6b21\u306e\u4fc2\u6570\u306b k! \u3092\u304b\u3051\u305f\u3082\u306e\n//\u306e sum \u304c\u6c42\u307e\u3063\u3066\u3057\u307e\u3046\nmint exp_gen_coeff_sum(mint a,vc<mint> f){\n\t/*int n=si(f)-1;\n\tvc<mint> g(fact,fact+2*n+1);\n\treverse(all(f));\n\tauto h=multiply(f,g);\n\tvc<mint> vs(n+1);\n\trep(i,n+1)vs[i]=h[n+i]*finv[i];\n\treturn exp_poly_sum_limit(a,vs);*/\n\tmint ans;\n\tmint w=(1-a).inv(),cur=1;\n\trep(k,si(f)){\n\t\tcur*=w;\n\t\tans+=fact[k]*cur*f[k];\n\t}\n\treturn ans;\n}\n\nint getsz(const vvc<mint>&x){\n\treturn si(x)+si(x[0]);\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvi ls=readvi(n);\n\tint tot=accumulate(all(ls),0);\n\tvc<vvc<mint>> buf(n);\n\trep(idx,n){\n\t\tint s=(ls[idx]-1)/k+1;\n\t\tvvc<mint> f(s,vc<mint>(2));\n\t\trep(num,s){\n\t\t\tmint w=mint(ls[idx]-k*num)/tot;\n\t\t\tif(num)f[num][0]=w.pow(num-1)*finv[num-1];\n\t\t\tf[num][1]=w.pow(num)*finv[num];\n\t\t}\n\t\tbuf[idx].swap(f);\n\t}\n\tpriority_queue<pi,vc<pi>,greater<pi>> pq;\n\trep(i,n)pq.emplace(getsz(buf[i]),i);\n\trep(_,n-1){\n\t\tint i=pq.top().b;pq.pop();\n\t\tint j=pq.top().b;pq.pop();\n\t\tbuf[i]=convolute2d(buf[i],buf[j]);\n\t\tvvc<mint>().swap(buf[j]);\n\t\tpq.emplace(getsz(buf[i]),i);\n\t}\n\tconst auto&ans=buf[pq.top().b];\n\tmint sum;\n\trng(num,1,si(ans)){\n\t\tvc<mint> f(num+1);\n\t\tassert(si(ans[num])==n+1);\n\t\trep(i,n+1){\n\t\t\tif(i+num-n>=0)f[i+num-n]=ans[num][i];\n\t\t\telse assert(ans[num][i]==0);\n\t\t}\n\t\tmint w=mint(tot-num*k)/tot;\n\t\tmint val=exp_gen_coeff_sum(w,f);\n\t\tif(num%2==0)val=-val;\n\t\tsum+=val;\n\t}\n\tprint(sum);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "fft", "math", "probabilities"], "dificulty": "3500", "interactive": false}