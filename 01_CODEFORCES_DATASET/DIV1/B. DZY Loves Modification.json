{
    "link": "https://codeforces.com//contest/446/problem/B",
    "problemId": "11400",
    "problem_idx": "B",
    "shortId": "446B",
    "contest_number": "446",
    "problem_submissions": {
        "D": [
            7086133,
            7088502,
            7303572,
            7094524,
            7087369,
            7108964,
            7108953,
            7108945,
            7108928,
            7108912,
            7089186,
            7086153,
            7256786,
            7256781,
            7111708
        ],
        "B": [
            7082083,
            7079232,
            7078714,
            7083465,
            7077013,
            7081087,
            7303292,
            7079381,
            7081269,
            7080767,
            7080268,
            7085675,
            7089437,
            7079048,
            7081011,
            7082061,
            7081382,
            7083005,
            7082149
        ],
        "C": [
            7079856,
            7085393,
            7084759,
            7079794,
            7695226,
            7082368,
            7303421,
            7094356,
            7085833,
            7086068,
            7088271,
            7087032,
            7088166,
            7086187,
            7087998,
            7087654,
            7091193,
            7088707
        ],
        "A": [
            7075913,
            7076352,
            7074747,
            7080779,
            7084765,
            7075635,
            7303252,
            7075476,
            7075873,
            7075184,
            7076974,
            7078214,
            7075141,
            7075542,
            7077127,
            7075653,
            7075563,
            7076924,
            7075972
        ],
        "E": [
            7093796,
            7093681
        ]
    },
    "name": "B. DZY Loves Modification",
    "statement": "As we know, DZY loves playing games. One day DZY decided to play with a\r\nmatrix. To be more precise, he decided to modify the matrix with exactly\r\noperations.Each modification is one of the following: Pick some row of\r\nthe matrix and decrease each element of the row by . This operation\r\nbrings to DZY the value of pleasure equal to the sum of elements of the\r\nrow before the decreasing. Pick some column of the matrix and decrease\r\neach element of the column by . This operation brings to DZY the value\r\nof pleasure equal to the sum of elements of the column before the\r\ndecreasing. DZY wants to know: what is the largest total value of\r\npleasure he could get after performing exactly modifications? Please,\r\nhelp him to calculate this value.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n#include <cassert>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n#define prev PREV\n#define j0 j1347829\n#define j1 j234892\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nint n;\nint m;\nint k, p;\nll row[1000];\nll col[1000];\nll sumcol[1000001];\nll sumrow[1000001];\nmultiset<ll> rows, cols;\nll colsub, rowsub;\n\nint main () {\n    scanf (\"%d%d%d%d\", &n, &m, &k, &p);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n            int x;\n            scanf (\"%d\", &x);\n            row[i] += x;\n            col[j] += x;\n        }\n    for (int i = 0; i < n; i++) rows.insert (-row[i]);\n    for (int i = 0; i < m; i++) cols.insert (-col[i]);\n    ll ans = -1e18, srow = 0, scol = 0;\n    for (int i = 0; i < k; i++) {\n        {\n            ll tmp = -(*rows.begin());\n            rows.erase (rows.begin ());\n            rows.insert (-(tmp - m * p));\n            srow += tmp;\n            sumrow[i + 1] = srow;\n        }   \n        {\n            ll tmp = -(*cols.begin());\n            cols.erase (cols.begin ());\n            cols.insert (-(tmp - n * p));\n            scol += tmp;\n            sumcol[i + 1] = scol;\n        }\n    }\n    for (int i = 0; i <= k; i++) {\n        ll cur = sumrow[i] + sumcol[k - i] - (ll)i * (k - i) * p;\n        ans = max (ans, cur);\n    }\n    cout << ans << endl;        \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. DZY Loves Modification.json",
    "editorial_link": "https://codeforces.com//blog/entry/13036",
    "editorial": "If , apperently the best choice is choosing the row or column which can\r\ngive greatest pleasure value each time. Ignore first,then we can get a\r\ngreatest number . Then if we choose rows for times, choose columns for\r\ntimes, should subtract . So we could enumerate i form 0 to k and\r\ncalculate each time, max is the maximum possible pleasure value DZY\r\ncould get. Let be the maximum pleasure value we can get after choosing\r\nrows and be the maximum pleasure value we can get after choosing\r\ncolumns. Then . We can use two priority queues to calculate and quickly.\r\n",
    "hint": []
}