{
    "link": "https://codeforces.com//contest/1603/problem/C",
    "problemId": "1163971",
    "problem_idx": "C",
    "shortId": "1603C",
    "contest_number": "1603",
    "problem_submissions": {
        "D": [
            133678384,
            133698397,
            133689761,
            133665373,
            133663811,
            133667904,
            133870635,
            133666377,
            133712181,
            133672518,
            133669513,
            133671913,
            133674123,
            133668504,
            133670450,
            134053883,
            133670044
        ],
        "E": [
            133654251,
            133698597,
            133670917,
            133670921,
            133674718,
            133678832,
            133691448,
            133677480,
            133745184,
            133682168,
            158346606
        ],
        "C": [
            133634336,
            133654076,
            133641887,
            133643661,
            133700965,
            133639890,
            133639559,
            133648557,
            133635180,
            133642566,
            133633281,
            133658219,
            133645221,
            133638128,
            133655485,
            133647398,
            133646553,
            133645458,
            133645891,
            133650269,
            134161088,
            133646180
        ],
        "B": [
            133625504,
            133622630,
            133627460,
            133627705,
            133633891,
            133623525,
            133628792,
            133627917,
            133622898,
            133644787,
            133630406,
            133626809,
            133635643,
            133632995,
            133629432,
            133625758,
            133629935,
            133631448,
            134161095,
            133621172
        ],
        "A": [
            133616996,
            133617371,
            133618050,
            133618145,
            133618661,
            133618290,
            133617671,
            133620309,
            133617150,
            133619091,
            133618690,
            133618619,
            133622033,
            133621990,
            133618626,
            133617653,
            133618140,
            133620543,
            134161100,
            133617177
        ],
        "F": [
            133669341,
            133700346,
            133679782,
            133709673,
            133694728,
            133720215,
            133975676,
            134484874,
            158277914
        ]
    },
    "name": "C. Extreme Extension",
    "statement": "For an array b of n integers, the of this array is the minimum number of\r\ntimes (possibly, zero) the following operation has to be performed to\r\nmake b : Select an index i such that 1\r\nle i\r\nle |b|, where |b| is the current length of b. Replace b_i with two\r\nelements x and y such that x and y both are integers and x + y = b_i.\r\nThis way, the array b changes and the next operation is performed on\r\nthis modified array. For example, if b = [2, 4, 3] and index 2 gets\r\nselected, then the possible arrays after this operation are [2,\r\nunderline{1},\r\nunderline{3}, 3], [2,\r\nunderline{2},\r\nunderline{2}, 3], or [2,\r\nunderline{3},\r\nunderline{1}, 3]. And consequently, for this array, this single\r\noperation is enough to make it non-decreasing: [2, 4, 3]\r\nrightarrow [2,\r\nunderline{2},\r\nunderline{2}, 3].It\u2019s easy to see that every array of positive integers\r\ncan be made non-decreasing this way.YouKn0wWho has an array a of n\r\nintegers. Help him find the sum of of all nonempty subarrays of a modulo\r\n998\r\n,244\r\n,353. If a subarray appears in a multiple times, its extreme value\r\nshould be counted the number of times it appears.An array d is a\r\nsubarray of an array c if d can be obtained from c by deletion of\r\nseveral (possibly, zero or all) elements from the beginning and several\r\n(possibly, zero or all) elements from the end.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.10.2021 17:48:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    Mint ans = 0;\n    vector<pair<int, int>> v;\n    for (int i = n - 1; i >= 0; i--) {\n      vector<pair<int, int>> new_v;\n      int x = 1;\n      int ptr = 0;\n      while (x <= a[i]) {\n        int r = (a[i] + x - 1) / x;\n        int till = (r == 1 ? a[i] : (a[i] - 1) / (r - 1));\n        int cnt = 0;\n        while (ptr < (int) v.size() && v[ptr].first >= r) {\n          cnt += v[ptr].second;\n          ptr += 1;\n        }\n        if (x == 1) {\n          cnt += 1;\n        }\n        if (cnt > 0) {\n          ans += Mint(cnt) * (x - 1) * (i + 1);\n          if (!new_v.empty() && new_v.back().first == a[i] / x) {\n            new_v.back().second += cnt;\n          } else {\n            new_v.emplace_back(a[i] / x, cnt);\n          }\n        }\n        x = till + 1;\n      }\n      swap(v, new_v);\n//      debug(i, a[i], v, ans);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Extreme Extension.json",
    "editorial_link": "https://codeforces.com//blog/entry/96460",
    "editorial": "Let\u00e2\u0080\u0099s find out how to calculate the of an array of integers. It turns\r\nout that a greedy solution exists! Consider the rightmost index such\r\nthat . So we must split into new (let\u00e2\u0080\u0099s say ) elements such that .\r\nNotice that because . But it is always optimal to make as large as\r\npossible. It is not hard to see that the smaller the , the bigger the we\r\ncan achieve. So let\u00e2\u0080\u0099s set . Now, notice that . So let\u00e2\u0080\u0099s set . So we have\r\nperformed operations and will solve the problem analogously for the\r\nprevious indices after replacing by . To sum it all up, we can calculate\r\nthe in the following procedure: Iterator from to . Add to the answer.\r\nSet . Pretty elegant! Let\u00e2\u0080\u0099s call it from now on.So we can calculate the\r\nof an array of integers in .To solve it for all subarrays in , we need\r\nto fix a prefix and solve each suffix of this prefix in a total of\r\noperations. We can do that easily because the procedure to calculate the\r\nstarts from the end, so we can sum up the contributions on the run.How\r\nto solve the problem faster?Think dp.Let be the count of subarrays such\r\nthat and after the becomes the first element of the final version of\r\nthat subarray. We only care about the s for which is non-zero. How many\r\ndifferent is possible?Well, it can be up to , right? Wrong!Let\u00e2\u0080\u0099s go back\r\nto our once again. For the time being, let\u00e2\u0080\u0099s say for all to , is\r\nnon-zero. So for each , we will add to .But there can be at most\r\ndistinct values in the sequence . Check this for a proof.So there can be\r\ndistinct s for which is non-zero. So we can solve this dp in . To\r\noptimize the space-complexity we can observe that we only need the dp\r\nvalues of . So we can use only two arrays to maintain everything. Check\r\nmy solution for more clarity. To get the final answer, we will use the\r\ncontribution technique. To be precise, for each we will add to our\r\nanswer and its not hard to see this. Here, is the number of arrays where\r\nthe -th element will be set to in the and is the number of operations\r\nthat will be performed for the same.Overall time complexity will be and\r\nspace complexity will be .\r\n"
}