{"link": "https://codeforces.com//contest/240/problem/F", "problemId": "1968", "problem_idx": "F", "shortId": "240F", "contest_number": "240", "problem_submissions": {"E": [27068673, 2369567, 6952646, 2369757, 2372786, 5412996, 2514695], "F": [2367683, 2368675, 2369245, 2369452, 2368590, 2369852, 2369859, 5410059, 2375572, 2369032, 2369175, 2372869, 2372867, 2372756, 2381339, 2372940, 2385773, 2373920, 2373882, 2373878, 2373867], "D": [2366591, 2366807, 2363963, 2366681, 2367043, 2367828, 2368196, 2368922, 2368559, 2366576, 2366169, 2366259, 2366076, 2366376, 2367080, 2367061, 2367534, 2366309], "B": [2364839, 2363209, 2363076, 2364268, 2364613, 2366303, 2366338, 2365433, 2365795, 2362822, 2364543, 2364502, 2364524, 2365151, 2363226, 2365069, 2363254, 2365130], "C": [2364074, 2363771, 2362766, 2363402, 2365229, 2364773, 2365070, 2366607, 2366758, 2363283, 2363525, 2363778, 2363522, 2364178, 2364017, 2363965, 2364497, 2363876], "A": [2363037, 2364923, 2364871, 2365199, 2363710, 2364055, 2364242, 2363918, 2364327, 2364439, 2363218, 2363258, 2363183, 2363585, 2365038, 2363271, 2365712, 2363292]}, "name": "F. TorCoder", "statement": "A boy named Leo doesn\u2019t miss a single TorCoder contest round. On the\r\nlast TorCoder round number 100666 Leo stumbled over the following\r\nproblem. He was given a string , consisting of lowercase English\r\nletters, and queries. Each query is characterised by a pair of integers\r\n. We\u2019ll consider the letters in the string numbered from 1 to from left\r\nto right, that is, . After each query he must swap letters with indexes\r\nfrom to inclusive in string so as to make substring a palindrome. If\r\nthere are multiple such letter permutations, you should choose the one\r\nwhere string will be lexicographically minimum. If no such permutation\r\nexists, you should ignore the query (that is, not change string\r\n).Everybody knows that on TorCoder rounds input line and array size\r\nlimits never exceed , so Leo solved this problem easily. Your task is to\r\nsolve the problem on a little bit larger limits. Given string and\r\nqueries, print the string that results after applying all queries to\r\nstring .\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nconst int MAX_N = int(1e5) + 10;\n\nstruct Tree {\n\tTree*pl, *pr;\n\tint l, r;\n\tint cnt[26];\n\n\tint same;\n\n\tvoid apply(int s) {\n\t\tsame = s;\n\t\tmemset(cnt, 0, sizeof cnt);\n\t\tcnt[same] = r - l;\n\t}\n\n\tvoid relax() {\n\t\tif (same != -1 && pl) {\n\t\t\tpl->apply(same);\n\t\t\tpr->apply(same);\n\t\t\tsame = -1;\n\t\t}\n\t}\n\n\tvoid update() {\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tcnt[i] = pl->cnt[i] + pr->cnt[i];\n\t\t}\n\t}\n\n\tTree(int _l, int _r, char buf[]) :\n\t\t\tl(_l), r(_r) {\n\t\tsame = -1;\n\t\tif (l + 1 == r) {\n\t\t\tmemset(cnt, 0, sizeof cnt);\n\t\t\tcnt[buf[l] - 'a']++;\n\t\t\tpl = pr = 0;\n\t\t\treturn;\n\t\t}\n\t\tpl = new Tree(l, l + r >> 1, buf);\n\t\tpr = new Tree(l + r >> 1, r, buf);\n\t\tupdate();\n\t}\n\n\tvoid collect(int L, int R, int my[]) {\n\t\tif (L >= r || l >= R)\n\t\t\treturn;\n\t\tif (L <= l && R >= r) {\n\t\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\t\tmy[i] += cnt[i];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\trelax();\n\t\tpl->collect(L, R, my);\n\t\tpr->collect(L, R, my);\n\t}\n\n\tvoid makeSame(int L, int R, int s) {\n\t\tif (L >= r || l >= R)\n\t\t\treturn;\n\t\tif (L <= l && R >= r) {\n\t\t\tapply(s);\n\t\t\treturn;\n\t\t}\n\t\trelax();\n\t\tpl->makeSame(L, R, s);\n\t\tpr->makeSame(L, R, s);\n\t\tupdate();\n\t}\n\tvoid restore(char buf[]) {\n\t\tif (l + 1 == r) {\n\t\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\t\tif (cnt[i] == 1) {\n\t\t\t\t\tbuf[l] = 'a' + i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\trelax();\n\t\tpl->restore(buf);\n\t\tpr->restore(buf);\n\t}\n}*root;\nint n, m;\nchar buf[MAX_N];\n\nvoid doit(int l, int r) {\n\tstatic int cnt[26];\n\tmemset(cnt, 0, sizeof cnt);\n\troot->collect(l, r + 1, cnt);\n\tint nOdd = 0;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (cnt[i] % 2 == 1)\n\t\t\t++nOdd;\n\t}\n\tint len = r - l + 1;\n\tif (nOdd > 1)\n\t\treturn;\n\tif (nOdd != len % 2)\n\t\treturn;\n\tint who = -1;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (cnt[i] % 2 == 1) {\n\t\t\twho = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (who != -1)\n\t\tcnt[who]--;\n\tint cur = l;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tint a = cnt[i] / 2;\n\t\tif (a > 0) {\n\t\t\troot->makeSame(cur, cur + a, i);\n\t\t}\n\t\tcur += a;\n\t}\n\tif (who != -1) {\n\t\troot->makeSame(cur, cur + 1, who);\n\t\tcur += 1;\n\t}\n\tfor (int i = 26 - 1; i >= 0; --i) {\n\t\tint a = cnt[i] / 2;\n\t\tif (a > 0) {\n\t\t\troot->makeSame(cur, cur + a, i);\n\t\t}\n\t\tcur += a;\n\t}\n}\n\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tcin >> n >> m;\n\tscanf(\" \");\n\tscanf(\"%s\", buf);\n\troot = new Tree(0, n, buf);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tdoit(l - 1, r - 1);\n\t}\n\troot->restore(buf);\n\tbuf[n] = 0;\n\tputs(buf);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2600", "interactive": false}