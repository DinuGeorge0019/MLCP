{"link": "https://codeforces.com//contest/1548/problem/B", "problemId": "1062383", "problem_idx": "B", "shortId": "1548B", "contest_number": "1548", "problem_submissions": {"D2": [124590154, 124570151, 124631052, 124579457, 124595552, 124599986, 124598663, 124601582, 124596908, 124589080, 124589208, 124632567, 124602573], "E": [124581595, 124597899, 124590654, 124596843, 124594126, 124591964, 124592242, 124592323, 124856732, 124577426, 124619322, 124665492], "D1": [124546605, 124538296, 124561771, 124569958, 124572244, 124572070, 124558486, 124552145, 124565483, 124565312, 124554771, 124568265, 124563802, 124595327, 124572767, 124574319, 124573078, 124560440, 124570173, 124568828], "C": [124538722, 124546717, 124543126, 124552919, 124545964, 124599486, 124550051, 124554662, 124555634, 124559563, 124538097, 124558973, 124554365, 124565653, 124542584, 124561525, 124550009], "B": [124529066, 124526158, 124527209, 124533998, 124528094, 124540501, 124535175, 124539779, 124535743, 124537844, 124538815, 124529079, 124550340, 124533987, 124531668, 124543431, 124533588, 124530735, 124554398, 124534276], "A": [124521888, 124519192, 124532449, 124525950, 124521506, 124523964, 124524094, 124520315, 124522449, 124524250, 124550070, 124520590, 124556679, 124524509, 124523057, 124525430, 124522685, 124522322, 124531504, 124524318]}, "name": "B. Integers Have Friends", "statement": "British mathematician John Littlewood once said about Indian\r\nmathematician Srinivasa Ramanujan that \"every positive integer was one\r\nof his personal friends.\"It turns out that positive integers can also be\r\nfriends with each other! You are given an array a of distinct positive\r\nintegers. Define a a_i, a_{i+1},\r\nldots, a_j to be a if and only if there exists an integer m\r\nge 2 such that a_i\r\nbmod m = a_{i+1}\r\nbmod m =\r\nldots = a_j\r\nbmod m, where x\r\nbmod y denotes the remainder when x is divided by y.Your friend Gregor\r\nwants to know the size of the largest friend group in a.\r\n", "solutions": ["//\u522b\u4e22\u5305\u4e86\uff01\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nll a[maxn];\nll gcd(ll a, ll b) {\n    if (!b) return a;\n    return gcd(b, a % b);\n}\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n        if (n == 1) printf(\"1\\n\");\n        else {\n            vector<pair<ll, int> > cur;\n            int ans = 1;\n            for (int i = n; i >= 2; i--) {\n                ll h = abs(a[i] - a[i - 1]);\n                for (int i = 0; i < cur.size(); i++) {\n                    cur[i].fi = gcd(cur[i].fi, h);\n                    cur[i].se += 1;\n                }\n                cur.pb(mp(h, 2));\n                vector<pair<ll, int> > nx;\n                for (int i = 0; i < cur.size(); i++) {\n                    if (cur[i].fi == 1) continue;\n                    chkmax(ans, cur[i].se);\n                    if (i == 0 || cur[i].fi != cur[i - 1].fi)\n                        nx.pb(cur[i]);\n                }\n                cur = nx;\n            }\n            printf(\"%d\\n\", ans);\n        }\n    }\n    return (0-0); //<3\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "divide and conquer", "math", "number theory", "two pointers"], "dificulty": "1800", "interactive": false}