{
    "link": "https://codeforces.com//contest/668/problem/F",
    "problemId": "57064",
    "problem_idx": "F",
    "shortId": "668F",
    "contest_number": "668",
    "problem_submissions": {
        "F": [
            17499550,
            17496606,
            17499490,
            17520108,
            17532592,
            18501140,
            17506872
        ],
        "B": [
            17492263,
            17485934,
            18962334,
            18962098,
            17485171,
            17485437,
            17486714,
            17488923,
            17486945,
            17485337,
            17484629,
            17487464,
            17484958,
            17488407,
            17491479,
            17485748,
            17490028,
            17488673,
            17494403,
            17485637
        ],
        "D": [
            17490332,
            17487430,
            17490281,
            17491665,
            17491589,
            17491023,
            17492381,
            17491847,
            17510482,
            17491540,
            17491742,
            17492256,
            17492993,
            17492659,
            17489839,
            17492977,
            17494347,
            17514667,
            17493357,
            17493004,
            17491261
        ],
        "C": [
            17488542,
            17483428,
            17488211,
            17499595,
            17489413,
            17489671,
            17487966,
            17489865,
            17488377,
            17490380,
            17490343,
            17491934,
            17490751,
            17488239,
            17491003,
            17488540,
            17492291,
            17488705,
            17488521
        ],
        "A": [
            17482539,
            17489363,
            17482477,
            17482341,
            17484937,
            17482743,
            17482929,
            17482753,
            17482646,
            17483327,
            17482913,
            17484500,
            17493264,
            17483554,
            17483365,
            17482861,
            17485075,
            17503074
        ],
        "E": [
            17501421,
            17514396,
            17516687,
            17501875,
            18500143,
            17500162,
            17503103
        ]
    },
    "name": "F. Little Artem and Graph",
    "statement": "Little Artem is given a graph, constructed as follows: start with some\r\n-clique, then add new vertices one by one, connecting them to already\r\nexisting vertices that form a -clique.Artem wants to count the number of\r\nspanning trees in this graph modulo .\r\n",
    "solutions": [
        "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <random>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\n////////////////////////////////////////////////////////\n//ModInt\n\ninline void fasterLLDivMod(unsigned long long x, unsigned y, unsigned &out_d, unsigned &out_m) {\n\tunsigned xh = (unsigned)(x >> 32), xl = (unsigned)x, d, m;\n#ifdef __GNUC__\n\tasm(\n\t\t\"divl %4; \\n\\t\"\n\t\t: \"=a\" (d), \"=d\" (m)\n\t\t: \"d\" (xh), \"a\" (xl), \"r\" (y)\n\t);\n#else\n\t__asm {\n\t\tmov edx, dword ptr[xh];\n\t\tmov eax, dword ptr[xl];\n\t\tdiv dword ptr[y];\n\t\tmov dword ptr[d], eax;\n\t\tmov dword ptr[m], edx;\n\t};\n#endif\n\tout_d = d; out_m = m;\n}\n\n//x / y < 2^32 !\ninline unsigned fasterLLMod(unsigned long long x, unsigned y) {\n\tunsigned dummy, r;\n\tfasterLLDivMod(x, y, dummy, r);\n\treturn r;\n}\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) {\n\t\tunsigned dummy;\n\t\tfasterLLDivMod((unsigned long long)x * that.x, MOD, dummy, x);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const {\n\t\tModInt res;\n\t\tunsigned dummy;\n\t\tfasterLLDivMod((unsigned long long)x * that.x, MOD, dummy, res.x);\n\t\treturn res;\n\t}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n\n\tModInt inverse() const {\n\t\tsigned a = x, b = MOD, u = 1, v = 0;\n\t\twhile(b) {\n\t\t\tsigned t = a / b;\n\t\t\ta -= t * b; std::swap(a, b);\n\t\t\tu -= t * v; std::swap(u, v);\n\t\t}\n\t\tif(u < 0) u += Mod;\n\t\tModInt res; res.x = (unsigned)u;\n\t\treturn res;\n\t}\n\n\tbool operator==(ModInt that) const { return x == that.x; }\n\tbool operator!=(ModInt that) const { return x != that.x; }\n\tModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntypedef ModInt<1000000007> mint;\n\n////////////////////////////////////////////////////////\n//Black box linear algebra\n\ntypedef unsigned long long ull;\n\nmint dot(const mint *a, const mint *b, int n) {\n\tconst int K = 16;\n\tstatic_assert((ull)mint::Mod * mint::Mod < ~0ULL / (K + 1), \"K is too large\");\n\tull sum = 0;\n\tint i;\n\tfor(i = 0; i + K <= n; ) {\n\t\trep(j, K) {\n\t\t\tsum += (ull)a[i].x * b[i].x;\n\t\t\t++ i;\n\t\t}\n\t\tsum %= mint::Mod;\n\t}\n\tfor(; i < n; ++ i)\n\t\tsum += (ull)a[i].x * b[i].x;\n\treturn mint((int)(sum % mint::Mod));\n}\n\n//Berlekamp-Massey algorithm\n//(\\sum_{j=0}^L C[j] s[i + L - j]) = 0 for all 0 <= i < N - L\n//\u3068\u306a\u308b\u3088\u3046\u306a\u6700\u5c0f\u306e L, C \u3092\u8fd4\u3059\u3002C[0] = 1 \u3067\u3042\u308b\nint berlekampMessey(vector<mint> s, vector<mint> &C) {\n\tint N = (int)s.size();\n\treverse(s.begin(), s.end());\t//\u9006\u9806\u306b\u3057\u3066\u304a\u304f\n\tC.assign(N + 1, mint());\n\tvector<mint> B(N + 1, mint());\n\tC[0] = B[0] = 1;\n\tint degB = 0;\n\tvector<mint> T;\n\tint L = 0, m = 1;\n\tmint b = 1;\n\tfor(int n = 0; n < N; ++ n) {\n\t\tmint d = s[N - 1 - n];\n\t\tif(L > 0) d += dot(&C[1], &s[N - 1 - n + 1], L);\n\t\tif(d == mint()) {\n\t\t\t++ m;\n\t\t} else {\n\t\t\tif(2 * L <= n)\n\t\t\t\tT.assign(C.begin(), C.begin() + (L + 1));\n\t\t\tmint coeff = -d * b.inverse();\n\t\t\tfor(int i = 0; i <= degB; ++ i)\n\t\t\t\tC[m + i].x = fasterLLMod(C[m + i].x + (ull)coeff.x * B[i].x, mint::Mod);\n\t\t\tif(2 * L <= n) {\n\t\t\t\tL = n + 1 - L;\n\t\t\t\tB.swap(T);\n\t\t\t\tdegB = (int)B.size() - 1;\n\t\t\t\tb = d;\n\t\t\t\tm = 1;\n\t\t\t} else {\n\t\t\t\t++ m;\n\t\t\t}\n\t\t}\n\t}\n\tC.resize(L + 1);\n\treturn L;\n}\n\n\n//\u4f53\u4e0a\u306e\u6570\u5217\u306eminimum polynomial\u3092\u8a08\u7b97\u3059\u308b\u3002\n//(\\sum_{j=0}^d phi[j] s[i + j]) = 0 for all i\nvoid computeMinimumPolynomialForLinearlyRecurrentSequence(const vector<mint> &a, vector<mint> &phi) {\n\tint n2 = (int)a.size(), n = n2 / 2;\n\tassert(n2 % 2 == 0);\n\tint L = berlekampMessey(a, phi);\n\treverse(phi.begin(), phi.begin() + (L + 1));\n}\n\nstruct RandomModInt {\n\tdefault_random_engine re;\n\tuniform_int_distribution<int> dist;\n#ifndef _DEBUG\n\tRandomModInt() : re(random_device{}()), dist(1, mint::Mod - 1) {}\n#else\n\tRandomModInt() : re(), dist(1, mint::Mod - 1) {}\n#endif\n\tmint operator()() {\n\t\tmint r;\n\t\tr.x = dist(re);\n\t\treturn r;\n\t}\n} randomModInt;\n\nvoid randomModIntVector(vector<mint> &v) {\n\tint n = (int)v.size();\n\tfor(int i = 0; i < n; ++ i)\n\t\tv[i] = randomModInt();\n}\n\nmint computeDeterminant(int N, const vector<mint> &diag, const vector<pair<int, int> > &validEdges) {\n\tint n = N - 1;\n\tif(n == 0)\n\t\treturn 1;\n\tvector<mint> D(n);\n\tvector<mint> m;\n\trandomModIntVector(D);\n\tvector<mint> u(n), b(n);\n\tvector<ull> tmp(n);\n\trandomModIntVector(u);\n\trandomModIntVector(b);\n\n\tvector<mint> uTAib(n * 2);\n\tuTAib[0] = dot(&u[0], &b[0], n);\n\n\tvector<pair<short, short> > edges(validEdges.begin(), validEdges.end());\n\n\tfor(int k = 1; k < n * 2; ++ k) {\n\t\ttmp.assign(n, 0);\n\n\t\trep(i, n)\n\t\t\tb[i] *= D[i];\n\n\t\tfor(auto e : edges)\n\t\t\ttmp[e.first] += b[e.second].x;\n\n\t\trep(i, n)\n\t\t\tb[i].x = fasterLLMod(tmp[i] + (ull)diag[i].x * b[i].x, mint::Mod);\n\n\t\tuTAib[k] = dot(&u[0], &b[0], n);\n\t}\n\n\tcomputeMinimumPolynomialForLinearlyRecurrentSequence(uTAib, m);\n\t//\u904b\u304c\u60aa\u3044\u5834\u5408\u306f\u3084\u308a\u76f4\u3059\n\t//m = char(AD)\n\tif(m.empty() || m[0] == mint())\n\t\treturn mint();\n\tif(m.size() != n + 1 || m.back() != mint(1))\n\t\treturn computeDeterminant(N, diag, validEdges);\n\tmint detD = 1;\n\tfor(int i = 0; i < n; ++ i)\n\t\tdetD *= D[i];\n\tmint invdetD = detD.inverse();\n\tmint detA = m[0] * invdetD;\n\tif(n % 2 == 1)\n\t\tdetA = mint() - detA;\n\treturn detA;\n}\n\nmint countSpanningTrees(int N, const vector<pair<int, int> > &edges) {\n\tassert(N > 0);\n\n\tvector<int> deg(N, 0);\n\n\tfor(auto e : edges) {\n\t\t++ deg[e.first];\n\t\t++ deg[e.second];\n\t}\n\n\tvector<pair<int, int> > validEdges;\n\tfor(auto e : edges) if(e.first < N - 1 && e.second < N - 1 && e.first != e.second) {\n\t\tvalidEdges.push_back(e);\n\t\tvalidEdges.push_back(make_pair(e.second, e.first));\n\t}\n\n\tsort(validEdges.begin(), validEdges.end());\n\n\tvector<mint> diag(N - 1);\n\trep(i, N - 1)\n\t\tdiag[i] = -deg[i];\n\n\tmint res = computeDeterminant(N, diag, validEdges);\n\tif((N - 1) % 2 != 0)\n\t\tres = -res;\n\treturn res;\n}\n\nint main() {\n\tint n; int k;\n\twhile(~scanf(\"%d%d\", &n, &k)) {\n\t\tvector<pii> edges;\n\t\trep(i, k) reu(j, i + 1, k)\n\t\t\tedges.emplace_back(i, j);\n\t\tfor(int i = k; i < n; ++ i) {\n\t\t\trep(j, k) {\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a), -- a;\n//\t\t\t\ta = rand() % i;\n\t\t\t\tedges.emplace_back(a, i);\n\t\t\t}\n\t\t}\n\t\tmint ans = countSpanningTrees(n, edges);\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Little Artem and Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/44538",
    "editorial": "Let's define k-clique B the descendant of k-clique A, if B could be produced from A with the sequence of the following steps: add vertex to the clique, connected with all clique vertices in the graph description and remove exactly one other vertex. Let's calculate the DP with states (k-clique, separation its vertices to the components) \u0097 number of spanning forests int the graph, induced by the clique and all its descendants so that clique will be divided to different connected components according to the defined vertices separation (all of the rest vertices will be connected with some of these components). To calculate that we need to precalculate all separations from k to k+1 elements and transitions:\n\n1) (separation of k+1 vertices) x (separation k+1 vertices) -> (separation k+1 vertices | null), transform pair of separations \u0097 forests to the set of connected components of their union or null if there appears a cycle.\n\n2) (separation of k+1 vertices) x (vertex) -> (separation of k+1 vertices | null), transform forest to the new forest, generated by adding new edge from vertex to vertex k+1 (or null, if there appears a cycle)\n\n3) (separation of k+1 vertices) -> (separation of k vertices | null), projecting the separation on the first k vertices (or null, if k+1-th vertex creates a separate component)"
}