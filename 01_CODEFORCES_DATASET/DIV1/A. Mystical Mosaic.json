{
    "link": "https://codeforces.com//contest/956/problem/A",
    "problemId": "168079",
    "problem_idx": "A",
    "shortId": "956A",
    "contest_number": "956",
    "problem_submissions": {
        "D": [
            36593366,
            36588204,
            36587496,
            36592289,
            36586754,
            36588274,
            36591263,
            36589846,
            36592464,
            36590122,
            36593976,
            36596887,
            36592121,
            36596341,
            36592513,
            36595632,
            36591303,
            36590631,
            36596259,
            36591080
        ],
        "E": [
            36587738,
            36592013,
            36593444,
            36590601,
            36594002,
            36595759,
            36595160,
            36598384,
            36593817,
            36599462,
            36596926,
            36592533,
            36598235,
            36594351,
            36597963,
            36598842,
            36597808,
            36592935,
            36598993,
            36594463
        ],
        "C": [
            36581505,
            36582901,
            36583070,
            36583190,
            36582332,
            36585605,
            36587197,
            36582980,
            36586547,
            36582470,
            36583990,
            36584599,
            36584812,
            36584631,
            36582176,
            36583908,
            36599080,
            36588304,
            36587864
        ],
        "B": [
            36579923,
            36581052,
            36580935,
            36580991,
            36579886,
            36580741,
            36581673,
            36580683,
            36585379,
            36580850,
            36580955,
            36581441,
            36582530,
            36579783,
            36580793,
            36581999,
            36586325,
            36601723,
            36601691,
            36582893
        ],
        "A": [
            36579305,
            36579264,
            36579274,
            36579533,
            36579182,
            36584111,
            36579353,
            36579190,
            36580060,
            36579611,
            36579457,
            36579222,
            36580218,
            36579198,
            36579466,
            36579242,
            36580204,
            36579496,
            36579376
        ],
        "F": [
            36617999
        ]
    },
    "name": "A. Mystical Mosaic",
    "statement": "There is a rectangular grid of rows of initially-white cells each.Arkady\r\nperformed a certain number (possibly zero) of operations on it. In the\r\n-th operation, a non-empty subset of rows and a non-empty subset of\r\ncolumns are chosen. For each row in and each column in , the\r\nintersection of row and column is coloured black.There\u2019s another\r\nconstraint: a row or a column can only be chosen at most once among all\r\noperations. In other words, it means that no pair of () exists such that\r\nor , where denotes intersection of sets, and denotes the empty set.You\r\nare to determine whether a valid sequence of operations exists that\r\nproduces a given final grid.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 55;\nchar s[N][N];\nbool u1[N], u2[N];\nint n, m;\nbool a[N], b[N];\n\nvoid dfsX(int x);\nvoid dfsY(int y);\n\nvoid dfsX(int x) {\n\tu1[x] = 1;\n\ta[x] = 1;\n\tfor (int y = 0; y < m; y++)\n\t\tif (!u2[y] && s[x][y] == '#')\n\t\t\tdfsY(y);\n}\nvoid dfsY(int y) {\n\tu2[y] = 1;\n\tb[y] = 1;\n\tfor (int x = 0; x < n; x++)\n\t\tif (!u1[x] && s[x][y] == '#')\n\t\t\tdfsX(x);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%s\", s[i]);\n\tfor (int x = 0; x < n; x++) {\n\t\tif (u1[x]) continue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tb[i] = 0;\n\t\tdfsX(x);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (!a[i] || !b[j]) continue;\n\t\t\t\tif (s[i][j] != '#') {\n\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Mystical Mosaic.json",
    "editorial_link": "https://codeforces.com//blog/entry/58544",
    "editorial": "No row or column can be selected more than once, hence whenever a row r is selected in an operation, all cells in it uniquely determine the set of columns that need to be selected \u0097 let's call it Sr.\n\nLet's assume a valid set of operations exists. Take out any two rows, i and j. If rows i and j are selected in the same operation, we can deduce that Si?=?Sj; if they're in different operations, we get . Therefore, if Si???Sj and  hold for any pair of rows (i,?j), no valid operation sequence can be found.\n\nOtherwise (no pair violates the condition above), a valid sequence of operations can be constructed: group all rows with the same S's and carry out an operation with each group.\n\nThus, it's a necessary and sufficient condition for the answer to be \"Yes\", that for each pair of rows (i,?j), either Si?=?Sj or  holds.\n\nThe overall complexity is O(n2m). It can be divided by the system's word size if you're a bitset enthusiast, and a lot more if hashes and hash tables release their full power."
}