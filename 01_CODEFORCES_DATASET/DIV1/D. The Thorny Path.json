{"link": "https://codeforces.com//contest/1464/problem/D", "problemId": "839213", "problem_idx": "D", "shortId": "1464D", "contest_number": "1464", "problem_submissions": {"D": [101893944, 101884165, 101894987, 101897288, 101893426, 101899167, 101898742, 101897221, 101904879, 101902404, 101904041, 101898196, 101901056, 101893113, 101900043, 101901977, 101879521, 101891500], "E": [101884958, 101888698, 101880762, 101885481, 101895459, 101874392, 101918343, 101889791, 101890948, 101887375, 142038158, 102279161, 102087511, 101887630, 101883023, 101908666, 101908552, 101908506, 101893369, 101884575, 101899034, 101888272, 101881773, 101903223, 101903745, 101882555], "C": [101877309, 101876849, 101885303, 101878303, 101875140, 101886810, 101875737, 101878040, 101880124, 101880970, 101877103, 101881975, 101878148, 101882821, 101880363, 101877971, 101885296, 101877773, 101876637], "B": [101870508, 101872024, 101876423, 101872980, 101870882, 101883179, 101870101, 101869654, 101875498, 101874908, 101869353, 101877667, 101902344, 101877756, 101876619, 101904584, 101891390, 101873346, 101870962], "A": [101862412, 101862840, 101865321, 101865985, 101861233, 101876553, 101861535, 101873147, 101867432, 101867877, 101872819, 101866189, 101865464, 101863366, 101870449, 101865209, 101894436, 101867001, 101859824], "F": [101921592, 101921489, 101921368, 101920713, 113148352, 197483789, 101923610, 101916398, 101915019, 107239743, 103939202]}, "name": "D. The Thorny Path", "statement": "According to a legend the Hanoi Temple holds a permutation of integers\r\nfrom 1 to n. There are n stones of distinct colors lying in one line in\r\nfront of the temple. Monks can perform the following operation on\r\nstones: choose a position i (1\r\nle i\r\nle n) and cyclically shift stones at positions i, p[i], p[p[i]], ....\r\nThat is, a stone from position i will move to position p[i], a stone\r\nfrom position p[i] will move to position p[p[i]], and so on, a stone\r\nfrom position j, such that p[j] = i, will move to position i.Each day\r\nthe monks must obtain a new arrangement of stones using an arbitrary\r\nnumber of these operations. When all possible arrangements will have\r\nbeen obtained, the world will end. You are wondering, what if some\r\nelements of the permutation could be swapped just before the beginning?\r\nHow many days would the world last?You want to get a permutation that\r\nwill allow the world to last as long as possible, using the minimum\r\nnumber of exchanges of two elements of the permutation.Two arrangements\r\nof stones are considered different if there exists a position i such\r\nthat the colors of the stones on that position are different in these\r\narrangements.\r\n", "solutions": ["#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 1000005;\nconst ll MOD = 1000000007;\n\nint T,n,tot;\nint p[MAXN];\nint c[MAXN];\n\nbool vis[MAXN];\nmap<int,int> f[MAXN][3];\n\nint solve(int c3,int c2)\n{\n\tint res = 1e9;\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= 2;j++)\n\t\t\tf[i][j].clear();\n\tf[0][0][0] = -1e9;\n\tfor (int i = 0;i <= tot;i++)\n\t\tfor (int j = 0;j <= c2;j++)\n\t\t{\n\t\t\tfor (map<int,int>::iterator it = f[i][j].begin();it != f[i][j].end();it++)\n\t\t\t{\n\t\t\t\tint k = it->first,V = it->second;\n\t\t\t\tif (i == tot)\n\t\t\t\t{\n\t\t\t\t\tif (c2 - j == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k >= 0)\n\t\t\t\t\t\t\tres = min(res,V + k / 3 * 2);\n\t\t\t\t\t\tif (k < 0)\n\t\t\t\t\t\t\tres = min(res,V - k);\n\t\t\t\t\t}\n\t\t\t\t\tif (c2 - j == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k >= 2)\n\t\t\t\t\t\t\tres = min(res,V + (k - 2) / 3 * 2 + 1);\n\t\t\t\t\t\tif (k <= -1)\n\t\t\t\t\t\t\tres = min(res,V + (-k - 1));\n\t\t\t\t\t}\n\t\t\t\t\tif (c2 - j == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k == 1)\n\t\t\t\t\t\t\tres = min(res,V + 1);\n\t\t\t\t\t\tif (k >= 4)\n\t\t\t\t\t\t\tres = min(res,V + (k - 4) / 3 * 2 + 2);\n\t\t\t\t\t\tif (k <= -2)\n\t\t\t\t\t\t\tres = min(res,V + (-k - 2));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int l = 0;j + l <= c2;l++)\n\t\t\t\t\tif (l * 2 <= c[i + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tint t = (c[i + 1] - l * 2) / 3,el = (c[i + 1] - l * 2) % 3;\n\t\t\t\t\t\tint tim = (l + t + (bool)el - (l == 2) - 1);\n\t\t\t\t\t\tif (!el)\n\t\t\t\t\t\t\tf[i + 1][j + l][k] = min(f[i + 1][j + l][k],V + tim);\n\t\t\t\t\t\tif (el == 1)\n\t\t\t\t\t\t\tf[i + 1][j + l][k + 1] = min(f[i + 1][j + l][k + 1],V + tim + (k < 0));\n\t\t\t\t\t\tif (el == 2)\n\t\t\t\t\t\t\tf[i + 1][j + l][k - 1] = min(f[i + 1][j + l][k - 1],V + tim + (k > 0));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn res + 1e9;\n}\n\nint main()\n{\n\tscanf(\"%d\",&T);\n\twhile (T--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor (int i = 1;i <= n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t\tvis[i] = 0;\n\t\t}\n\t\ttot = 0;\n\t\tfor (int i = 1;i <= n;i++)\n\t\t{\n\t\t\tint u = i,len = 0;\n\t\t\tif (vis[u])\n\t\t\t\tcontinue;\n\t\t\twhile (!vis[u])\n\t\t\t{\n\t\t\t\tvis[u] = 1;\n\t\t\t\tu = p[u];\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tc[++tot] = len;\n\t\t}\n\t\tll ans = 1;\n\t\tint ans2 = 0;\n\t\tfor (int i = 0;i <= 2;i++)\n\t\t\tif ((n - i * 2) % 3 == 0)\n\t\t\t{\n\t\t\t\tint t = (n - i * 2) / 3;\n\t\t\t\tfor (int j = 1;j <= t;j++)\n\t\t\t\t\t(ans *= 3) %= MOD;\n\t\t\t\tfor (int j = 1;j <= i;j++)\n\t\t\t\t\t(ans *= 2) %= MOD;\n\t\t\t\tans2 = solve(t,i);\n\t\t\t}\n\t\tprintf(\"%lld %d\\n\",ans,ans2);\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["greedy", "implementation", "math"], "dificulty": "3000", "interactive": false}