{
    "link": "https://codeforces.com//contest/896/problem/D",
    "problemId": "137069",
    "problem_idx": "D",
    "shortId": "896D",
    "contest_number": "896",
    "problem_submissions": {
        "C": [
            32944802,
            32881577,
            32878510,
            32875053,
            32868262,
            32869520,
            32877475,
            32871462,
            32871613,
            32872946,
            32872899,
            32872163,
            32874463
        ],
        "E": [
            32884285,
            32880271,
            32868418,
            32902000,
            32901971,
            32890213,
            32889941,
            32889728,
            32871177,
            149032223,
            149032042
        ],
        "B": [
            32866795,
            32865695,
            32866037,
            32866388,
            32869687,
            32864715,
            32865144,
            32877783,
            32866364,
            32866670,
            32865961,
            32864186,
            32868170,
            32865590,
            32863874,
            32867553,
            32868641,
            32868643,
            32874386,
            32865418
        ],
        "A": [
            32864492,
            32863421,
            32863158,
            32862992,
            32872439,
            32862588,
            32863707,
            32870827,
            32864151,
            32863537,
            32862938,
            32861614,
            32863683,
            32863600,
            32866515,
            32863570,
            32865560,
            32869952,
            32863704,
            32863274
        ],
        "D": [
            32872283,
            32876145,
            32868178,
            32875381,
            32882890,
            32882835,
            32873963,
            32876341,
            144356577,
            32875993,
            32876631,
            32920532,
            32876942,
            32875664
        ]
    },
    "name": "D. Nephren Runs a Cinema",
    "statement": "Lakhesh loves to make movies, so Nephren helps her run a cinema. We may\r\ncall it No. 68 Cinema.However, one day, the No. 68 Cinema runs out of\r\nchanges (they don’t have 50- notes currently), but Nephren still wants\r\nto start their business. (Assume that is a kind of currency in Regulu\r\nEre.)There are three types of customers: some of them bring exactly a\r\n50- note; some of them bring a 100- note and Nephren needs to give a 50-\r\nnote back to him/her; some of them bring VIP cards so that they don’t\r\nneed to pay for the ticket.Now customers are waiting outside in queue.\r\nNephren wants to know how many possible queues are there that they are\r\nable to run smoothly (i.e. every customer can receive his/her change),\r\nand that the number of 50- notes they have after selling tickets to all\r\nthese customers is between and , inclusive. Two queues are considered\r\ndifferent if there exists a customer whose type is different in two\r\nqueues. As the number can be large, please output the answer modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n// Undefined sign for negative inputs\ntemplate<typename T>\nstatic T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n// m must be positive\ntemplate<typename T>\nstatic T mod(T a, T m)\n{\n    a %= m;\n    if (a < 0)\n        a += m;\n    return a;\n}\n\n// a must be relatively prime to m\ntemplate<typename T>\nstatic T inverse(T a, T m)\n{\n    a = mod(a, m);\n    if (a <= 1)\n        return a;\n    return mod((1 - inverse(m, a) * m) / a, m);\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic ll P;\nstatic vi F;\n\nstatic ll pmod(ll a, ll b)\n{\n    if (b == 0)\n        return 1;\n    else if (b & 1)\n        return a * pmod(a, b - 1) % P;\n    else\n    {\n        ll t = pmod(a, b / 2);\n        return t * t % P;\n    }\n}\n\nstruct number\n{\n    ll rel;\n    array<int, 10> ex;\n\n    number() : rel(1), ex{{}} {}\n\n    number operator *(const number &b) const\n    {\n        number out;\n        out.rel = rel * b.rel % P;\n        for (int i = 0; i < SZ(F); i++)\n            out.ex[i] = ex[i] + b.ex[i];\n        return out;\n    }\n\n    number operator /(const number &b) const\n    {\n        number out;\n        out.rel = rel * inverse(b.rel, P) % P;\n        for (int i = 0; i < SZ(F); i++)\n            out.ex[i] = ex[i] - b.ex[i];\n        return out;\n    }\n\n    ll eval() const\n    {\n        ll ans = rel;\n        for (int i = 0; i < SZ(F); i++)\n        {\n            ll f = pmod(F[i], ex[i]);\n            ans = ans * f % P;\n        }\n        return ans;\n    }\n};\n\nstatic vi factors(int P)\n{\n    int s = int(sqrt(P) + 1);\n    vi ans;\n    for (int i = 2; i <= s; i++)\n    {\n        if (P % i == 0)\n        {\n            ans.push_back(i);\n            while (P % i == 0)\n                P /= i;\n        }\n    }\n    if (P > 1)\n        ans.push_back(P);\n    return ans;\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    ll N, l, r;\n    cin >> N >> P >> l >> r;\n\n    F = factors(P);\n    vector<int> d1(N + 1, -1);\n    for (int i = 0; i < SZ(F); i++)\n        for (int j = F[i]; j <= N; j += F[i])\n            d1[j] = i;\n\n    vector<number> fact(N + 1);\n    for (int i = 2; i <= N; i++)\n    {\n        number cur;\n        ll rel = i;\n        while (d1[rel] != -1)\n        {\n            cur.ex[d1[rel]]++;\n            rel /= F[d1[rel]];\n        }\n        cur.rel = rel % P;\n        assert(gcd(rel, P) == 1);\n        fact[i] = fact[i - 1] * cur;\n    }\n\n    auto choose = [&](ll n, ll r)\n    {\n        number ans = fact[n] / (fact[r] * fact[n - r]);\n        return ans.eval();\n    };\n\n    ll ans = 0;\n    for (int k = l; k <= N; k++)\n    {\n        ll x = (k - l) / 2;\n        ll y = (k - r + 1) / 2;\n        ll term = choose(k, x);\n        if (y > 0)\n            term -= choose(k, y - 1);\n        term %= P;\n        term = term * choose(N, k) % P;\n        ans = (ans + term) % P;\n    }\n    ans %= P;\n    if (ans < 0)\n        ans += P;\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "chinese remainder theorem",
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Nephren Runs a Cinema.json",
    "editorial_link": "https://codeforces.com//blog/entry/56135",
    "editorial": "First letâs consider a simpler problem that there are no customers with\r\nVIP cards and there are no 50- notes left. For convinence, we suppose\r\nthat is an even number. The situation that is an odd number will be\r\nsimilar. By defining points (number of customers currently, number of\r\n50- note left) on a 2d-plane, the answer to our second question is the\r\nways of drawing lines from (0,0) to (n,0), such that two adjacent\r\npointsâ y-axis have a difference of 1, and that all the points are above\r\nthe x-axis. The total routes will be , but some of them are invalid.\r\nConsider another route starting from (0,-2). For each invalid way in the\r\nprevious route, consider the first point (x,y) that y<0 (y=-1). By\r\ncreating a symmetry route with y=-1 for the route before this point,\r\nthis route will become exactly one route starting from (0,-2), and every\r\nroute starting from (0,-2) will become an invalid route in a similar\r\nway. So the number of invalid routes is (that is the number of routes\r\nfrom (0,-2) to (n,0)). Thus the answer will be . Similarly if there are\r\n[l,r] 50- notes left, the answer will be . Now letâs enumerate how many\r\ncustomers are there with VIP cards. If there are of them, the answer\r\nwill time a factor . One last question is about the modulo number. First\r\nseparate it into forms like ... where are primes. We can calculate how\r\nmany factor are there in , and the modulo value of the remaining ones.\r\nEach time we take out a facter in , and it becomes some product of\r\nnumbers that are not divisble by as well as a remaining part . For\r\nexample, we want to calculate the number of factor 3 in (16!), and the\r\nproduct of numbers that are not divisble by 3 in (16!) mod (3^2). Then\r\nwe have: 16! = (1 * 2 * 4 * 5 * 7 * 8 * 10 * 11 * 13 * 14 * 16) * (1 *\r\n2 * 3 * 4 * 5) * (3^5) The first part are not divisble by 3, so we can\r\ncalculate their value (mod 3^2) in advance, the second part is a smaller\r\nproblem (5!), so we can solve it recursively. For the number of factor\r\n3, just add 5 in this case and solve it recursively. After calculating\r\nhow many factor in and the modulo value of the remaining ones, we can\r\ncalculate the combnation numbers correctly. Finally use Chinese\r\nRemainder Algorithm to combine them.\r\n",
    "hint": []
}