{"link": "https://codeforces.com//contest/414/problem/D", "problemId": "7959", "problem_idx": "D", "shortId": "414D", "contest_number": "414", "problem_submissions": {"D": [6280858, 6280337, 6280214, 6277452, 6281468, 6278870, 6280873, 6276141, 6280994, 6282343, 6281729, 6278507, 6283035, 6279945, 6282736, 6282676, 6281489], "C": [6277588, 6279411, 6276895, 6277328, 6280737, 6277280, 6281276, 6277935, 6281181, 6277366, 6279038, 6277230, 6283028, 6279514, 6282968, 6280049, 6278467, 6279593], "B": [6274271, 6272525, 6274152, 6274024, 6273769, 6273466, 6273735, 6274465, 6277446, 6272443, 6274075, 6274094, 6274028, 6273244, 6273032, 6273491, 6273690, 6273419], "A": [6272689, 6271872, 6273297, 6273349, 6273033, 6272772, 6272076, 6273686, 6278378, 6271786, 6272244, 6273646, 6273040, 6272099, 6272030, 6272106, 6272639, 6272717], "E": [6287011, 6619052]}, "name": "D. Mashmokh and Water Tanks", "statement": "Mashmokh is playing a new game. In the beginning he has liters of water\r\nand coins. Additionally he has a rooted tree (an undirected connected\r\nacyclic graph) that consists of vertices. Each vertex of the tree\r\ncontains a water tank that is empty in the beginning.The game begins\r\nwith the fact that Mashmokh chooses some (no more than ) of these tanks\r\n(except the root) and pours into each of them exactly liter of water.\r\nThen the following process is performed until there is no water remained\r\nin tanks. The process consists of several steps. At the beginning of\r\neach step Mashmokh opens doors of all tanks. Then Mashmokh closes doors\r\nof some tanks (he is not allowed to close door of tank in the root) for\r\nthe duration of this move. Let\u2019s denote the number of liters in some\r\ntank with closed door as , Mashmokh pays coins for the closing of that\r\ntank during this move. Let\u2019s denote by as the list of vertices of the\r\ntree sorted (nondecreasing) by their depth. The vertices from this list\r\nshould be considered one by one in the order. Firstly vertex (which is\r\nthe root itself) is emptied. Then for each vertex , if its door is\r\nclosed then skip the vertex else move all the water from the tank of\r\nvertex to the tank of its father (even if the tank of the father is\r\nclosed). Suppose moves were made until the tree became empty. Let\u2019s\r\ndenote the amount of water inside the tank of the root after the -th\r\nmove by then Mashmokh will win dollars. Mashmokh wanted to know what is\r\nthe maximum amount of dollars he can win by playing the above game. He\r\nasked you to find this value for him.\r\n", "solutions": ["#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define forint(i, a, b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define forintdown(i, a, b) for(int i=(int)(a); i>=(int)(b); --i)\n#define forn(i, n) forint(i, 0, (n)-1)\n#define forndown(i, n) forintdown(i, (n)-1, 0)\n#define fillchar(a, x) memset(a, x, sizeof(a))\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPI;\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n\nconst int MAXN=100010;\n\nint g[MAXN], g_lnk[MAXN*2], g_nxt[MAXN*2];\nint n, k, p;\n\nLL a[MAXN], s[MAXN], t[MAXN];\n\nvoid dfs(int dep, int x, int fa) {\n\ta[dep]++;\n\tfor(int e=g[x]; e; e=g_nxt[e])\n\t\tif(g_lnk[e]!=fa)\n\t\t\tdfs(dep+1, g_lnk[e], x);\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&k,&p);\n\tfillchar(g, 0);\n\tforint(i, 1, n-1) {\n\t\tint a, b; scanf(\"%d%d\", &a,&b);\n\t\tint e=i*2-1;\n\t\tg_lnk[++e]=b, g_nxt[e]=g[a], g[a]=e;\n\t\tg_lnk[++e]=a, g_nxt[e]=g[b], g[b]=e;\n\t}\n\n\tfillchar(a, 0);\n\tdfs(0, 1, 0);\n\ta[0]=0;\n\ts[0]=0; forint(i, 1, n) s[i]=a[i]+s[i-1];\n\tt[0]=0; forint(i, 1, n) t[i]=t[i-1]+LL(n-i)*a[i];\n\tLL ans=0;\n\tfor(int i=n, j=n; j>=1; --j) {\n\t\twhile(i>0) {\n\t\t\tLL sum=s[j]-s[i-1];\n\t\t\tif(sum>k) break;\n\t\t\tLL st=t[j]-t[i-1];\n\t\t\tst-=(n-j)*sum;\n\t\t\tif(st>p) break;\n\t\t\t--i;\n\t\t}\n\t\tLL sum=s[j]-s[i];\n\t\tLL st=t[j]-t[i]-(n-j)*sum;\n\t\tLL addi=min(a[i], LL(k)-sum);\n\t\tif(i<j) addi=min(addi, LL(p-st)/LL(j-i));\n\t\tans=max(ans, sum+addi);\n\t}\n\tprintf(\"%I64d\\n\", (ans));\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "greedy", "trees", "two pointers"], "dificulty": "2300", "interactive": false}