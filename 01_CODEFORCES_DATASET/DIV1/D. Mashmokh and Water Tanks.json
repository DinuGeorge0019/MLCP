{
    "link": "https://codeforces.com//contest/414/problem/D",
    "problemId": "7959",
    "problem_idx": "D",
    "shortId": "414D",
    "contest_number": "414",
    "problem_submissions": {
        "D": [
            6280858,
            6280337,
            6280214,
            6277452,
            6281468,
            6278870,
            6280873,
            6276141,
            6280994,
            6282343,
            6281729,
            6278507,
            6283035,
            6279945,
            6282736,
            6282676,
            6281489
        ],
        "C": [
            6277588,
            6279411,
            6276895,
            6277328,
            6280737,
            6277280,
            6281276,
            6277935,
            6281181,
            6277366,
            6279038,
            6277230,
            6283028,
            6279514,
            6282968,
            6280049,
            6278467,
            6279593
        ],
        "B": [
            6274271,
            6272525,
            6274152,
            6274024,
            6273769,
            6273466,
            6273735,
            6274465,
            6277446,
            6272443,
            6274075,
            6274094,
            6274028,
            6273244,
            6273032,
            6273491,
            6273690,
            6273419
        ],
        "A": [
            6272689,
            6271872,
            6273297,
            6273349,
            6273033,
            6272772,
            6272076,
            6273686,
            6278378,
            6271786,
            6272244,
            6273646,
            6273040,
            6272099,
            6272030,
            6272106,
            6272639,
            6272717
        ],
        "E": [
            6287011,
            6619052
        ]
    },
    "name": "D. Mashmokh and Water Tanks",
    "statement": "Mashmokh is playing a new game. In the beginning he has liters of water\r\nand coins. Additionally he has a rooted tree (an undirected connected\r\nacyclic graph) that consists of vertices. Each vertex of the tree\r\ncontains a water tank that is empty in the beginning.The game begins\r\nwith the fact that Mashmokh chooses some (no more than ) of these tanks\r\n(except the root) and pours into each of them exactly liter of water.\r\nThen the following process is performed until there is no water remained\r\nin tanks. The process consists of several steps. At the beginning of\r\neach step Mashmokh opens doors of all tanks. Then Mashmokh closes doors\r\nof some tanks (he is not allowed to close door of tank in the root) for\r\nthe duration of this move. Let’s denote the number of liters in some\r\ntank with closed door as , Mashmokh pays coins for the closing of that\r\ntank during this move. Let’s denote by as the list of vertices of the\r\ntree sorted (nondecreasing) by their depth. The vertices from this list\r\nshould be considered one by one in the order. Firstly vertex (which is\r\nthe root itself) is emptied. Then for each vertex , if its door is\r\nclosed then skip the vertex else move all the water from the tank of\r\nvertex to the tank of its father (even if the tank of the father is\r\nclosed). Suppose moves were made until the tree became empty. Let’s\r\ndenote the amount of water inside the tank of the root after the -th\r\nmove by then Mashmokh will win dollars. Mashmokh wanted to know what is\r\nthe maximum amount of dollars he can win by playing the above game. He\r\nasked you to find this value for him.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define forint(i, a, b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define forintdown(i, a, b) for(int i=(int)(a); i>=(int)(b); --i)\n#define forn(i, n) forint(i, 0, (n)-1)\n#define forndown(i, n) forintdown(i, (n)-1, 0)\n#define fillchar(a, x) memset(a, x, sizeof(a))\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPI;\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n\nconst int MAXN=100010;\n\nint g[MAXN], g_lnk[MAXN*2], g_nxt[MAXN*2];\nint n, k, p;\n\nLL a[MAXN], s[MAXN], t[MAXN];\n\nvoid dfs(int dep, int x, int fa) {\n\ta[dep]++;\n\tfor(int e=g[x]; e; e=g_nxt[e])\n\t\tif(g_lnk[e]!=fa)\n\t\t\tdfs(dep+1, g_lnk[e], x);\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&k,&p);\n\tfillchar(g, 0);\n\tforint(i, 1, n-1) {\n\t\tint a, b; scanf(\"%d%d\", &a,&b);\n\t\tint e=i*2-1;\n\t\tg_lnk[++e]=b, g_nxt[e]=g[a], g[a]=e;\n\t\tg_lnk[++e]=a, g_nxt[e]=g[b], g[b]=e;\n\t}\n\n\tfillchar(a, 0);\n\tdfs(0, 1, 0);\n\ta[0]=0;\n\ts[0]=0; forint(i, 1, n) s[i]=a[i]+s[i-1];\n\tt[0]=0; forint(i, 1, n) t[i]=t[i-1]+LL(n-i)*a[i];\n\tLL ans=0;\n\tfor(int i=n, j=n; j>=1; --j) {\n\t\twhile(i>0) {\n\t\t\tLL sum=s[j]-s[i-1];\n\t\t\tif(sum>k) break;\n\t\t\tLL st=t[j]-t[i-1];\n\t\t\tst-=(n-j)*sum;\n\t\t\tif(st>p) break;\n\t\t\t--i;\n\t\t}\n\t\tLL sum=s[j]-s[i];\n\t\tLL st=t[j]-t[i]-(n-j)*sum;\n\t\tLL addi=min(a[i], LL(k)-sum);\n\t\tif(i<j) addi=min(addi, LL(p-st)/LL(j-i));\n\t\tans=max(ans, sum+addi);\n\t}\n\tprintf(\"%I64d\\n\", (ans));\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "trees",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Mashmokh and Water Tanks.json",
    "editorial_link": "https://codeforces.com//blog/entry/11470",
    "editorial": "Letâs suppose instead of a tank there is a pile at each vertex and\r\ninstead of water the game is played on tiles. Letâs denote distance of\r\neach vertex from the root by . Also Letâs label each tile with number of\r\nthe vertex it was initially put on. Suppose initially there was a tile\r\nat each of vertices and and after some move tile and are in the same\r\nvertexâs pile. Then one can prove that there were exactly moves at which\r\nvertex containing the tile at vertex with less depth was closed and the\r\nvertex containing the other tile wasnât. Suppose after -th move, there\r\nwas tiles inside the rootâs pile and is the maximum among these numbers.\r\nSuppose tiles were on the root after -th move. Then the other tiles that\r\nwe put inside the tree at the beginning have no effect in the final\r\nresult. Then we can suppose that only these tiles were initially put on\r\ntree. So we can assume that all tiles we place at the beginning will\r\nreach to the root together. Suppose of these tiles were put at a vertex\r\nwith depth and is the maximum depth that there is at least a tile in\r\nthat depth. So as to these tiles reach to the root together we must pay\r\n. Then we want to minimize the number of needed coins so at the\r\nbeginning there must not be two consecutive depth and that and there is\r\na tile at depth and an empty vertex at depth . In other words if we\r\ndenote the minimum depth that initially there is a tile inside it as\r\nthen there must be a tile at each vertex with depth more than and less\r\nthan or equal to . Letâs iterate over . Then for each we can calculate ,\r\nthe minimum depth that we can pay the needed price if we put a tile at\r\neach vertex with depth at least and at most . Letâs denote this needed\r\nprice as . Then we can also put at depth . So we can calculate maximum\r\nnumber of tiles that we can put on the tree so that they all reach to\r\nroot together for a fixed . So the maximum of these numbers for all\r\npossible will be the answer. Since by increasing , wonât decrease one\r\ncan use two-pointers to update while iterating over . Letâs denote\r\nnumber of the vertices with depth as . Then we can save and update the\r\nfollowing values. Then the needed price is equal to . So as long as we\r\nmust increase . This yields an solution.\r\n",
    "hint": []
}