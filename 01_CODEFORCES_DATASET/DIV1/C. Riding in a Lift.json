{
    "link": "https://codeforces.com//contest/480/problem/C",
    "problemId": "15740",
    "problem_idx": "C",
    "shortId": "480C",
    "contest_number": "480",
    "problem_submissions": {
        "E": [
            8311013,
            8313055,
            8314156,
            8325797,
            8315473,
            8325232,
            11709971,
            8353321
        ],
        "C": [
            8305908,
            8306095,
            8306489,
            8305168,
            8306046,
            8307120,
            8307521,
            8307102,
            8305050,
            8306309,
            8306145,
            8307452,
            8307404,
            8307470,
            8307938,
            8306829,
            8309720,
            8308359
        ],
        "A": [
            8304671,
            8302322,
            8301986,
            8303885,
            8302500,
            8302484,
            8302315,
            8302995,
            8305921,
            8302490,
            8302288,
            8303565,
            8303850,
            8303423,
            8302746,
            8302974,
            8303485,
            8317285
        ],
        "B": [
            8303927,
            8304607,
            8304712,
            8306656,
            8304745,
            8305167,
            8304670,
            8305422,
            8307631,
            8304999,
            8304658,
            8305487,
            8305732,
            8314422,
            8305673,
            8308163,
            8305105,
            8306250
        ],
        "D": [
            8310575,
            8311382,
            8313441,
            8312962,
            8315083,
            8315272,
            8314092,
            8316276,
            8315227,
            8311890,
            8317405,
            8315325,
            8316637
        ]
    },
    "name": "C. Riding in a Lift",
    "statement": "Imagine that you are in a building that has exactly floors. You can move\r\nbetween the floors in a lift. Let’s number the floors from bottom to top\r\nwith integers from to . Now you’re on the floor number . You are very\r\nbored, so you want to take the lift. Floor number has a secret lab, the\r\nentry is forbidden. However, you already are in the mood and decide to\r\nmake consecutive trips in the lift.Let us suppose that at the moment you\r\nare on the floor number (initially, you were on floor ). For another\r\ntrip between floors you choose some floor with number () and the lift\r\ntravels to this floor. As you cannot visit floor with the secret lab,\r\nyou decided that the distance from the current floor to the chosen must\r\nbe strictly less than the distance from the current floor to floor with\r\nthe secret lab. Formally, it means that the following inequation must\r\nfulfill: . After the lift successfully transports you to floor , you\r\nwrite down number in your notepad.Your task is to find the number of\r\ndistinct number sequences that you could have written in the notebook as\r\nthe result of trips in the lift. As the sought number of trips can be\r\nrather large, find the remainder after dividing the number by ().\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\ntemplate<typename T, T Modulus>\nclass MR\n{\nprivate:\n    struct tag_plus {}; // indicates value is in range [0, 2 * Modulus)\n    struct tag_minus {}; // indicates value is in range (-Modulus, Modulus)\n\n    T value;\n\n    enum\n    {\n        ASSERT_FALSE = 0,\n        ASSERT_TEST = (T(1) << (std::numeric_limits<T>::digits - 1)) / Modulus / Modulus > 0 ? 1 : 0\n    };\n\n    void reduce()\n    {\n        value %= Modulus;\n        if (value < 0)\n            value += Modulus;\n    }\n\n    void reduce(tag_plus)\n    {\n        if (value >= Modulus)\n            value -= Modulus;\n    }\n\n    void reduce(tag_minus)\n    {\n        if (value < 0)\n            value += Modulus;\n    }\n\npublic:\n    typedef T value_type;\n    static const T modulus = Modulus;\n\n    MR() : value(0) {}\n    MR(T value) : value(value) { reduce(); }\n    template<typename tag_t>\n    MR(T value, tag_t tag) : value(value) { reduce(tag); }\n\n    MR &operator=(T value) { this->value = value; reduce(); return *this; }\n\n    MR operator +(MR b) const { return MR(value + b.value, tag_plus()); }\n    MR operator -(MR b) const { return MR(value - b.value, tag_minus()); }\n    MR operator *(MR b) const { return MR(value * b.value); }\n    MR operator -() const { return MR(-value); }\n\n    MR &operator +=(MR b) { value += b.value; reduce(tag_plus()); return *this; }\n    MR &operator -=(MR b) { value -= b.value; reduce(tag_minus()); return *this; }\n    MR &operator *=(MR b) { value *= b.value; reduce(); return *this; }\n\n    bool operator==(MR b) const { return value == b.value; }\n    bool operator!=(MR b) const { return value != b.value; }\n\n    T get() const { return value; }\n};\n\nstatic void redirect(int argc, const char **argv)\n{\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntypedef MR<ll, 1000000007> mr;\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, a, b, K;\n    cin >> N >> a >> b >> K;\n    a--;\n    b--;\n\n    vector<mr> dp(N, 1);\n    dp[b] = 0;\n\n    for (int k = 0; k < K; k++)\n    {\n        vector<mr> sum(N + 1);\n        partial_sum(RA(dp), sum.begin() + 1);\n        for (int i = 0; i < N; i++)\n            if (i != b)\n            {\n                int d = abs(i - b) - 1;\n                int low = max(i - d, 0);\n                int high = min(i + d + 1, N);\n                dp[i] = sum[high] - sum[low] - dp[i];\n            }\n    }\n    cout << dp[a].get() << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Riding in a Lift.json",
    "editorial_link": "https://codeforces.com//blog/entry/14351",
    "editorial": "The task is solved by a dynamic programming. State is a pair , where is\r\nthe number of trips made, and is the current floor. Initial state is ,\r\nfinal states are , where is any floor (except ). It is easy to see the\r\ntransitions: to calculate , let s see what can be the previous floor. It\r\nturns out that all possible previous floors form a contiguous segment\r\n(with a hole at position , because we can t visit the same floor twice\r\nin a row). So, is almost equal to the sum of values , where belongs to\r\nsome segment (the values of and can be easily derived from the\r\nconditions from the problem statement). Using pretty standard technique\r\ncalled partial sums we can compute in , so overall complexity is . Jury\r\nsolution: 8322623\r\n",
    "hint": []
}