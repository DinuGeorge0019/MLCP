{
    "link": "https://codeforces.com//contest/1545/problem/B",
    "problemId": "1042718",
    "problem_idx": "B",
    "shortId": "1545B",
    "contest_number": "1545",
    "problem_submissions": {
        "D": [
            122107122,
            122101318,
            122112155,
            122104020,
            122109653,
            122107428,
            122115750,
            122116493,
            122121641,
            122123526,
            122112699,
            122120695,
            122128586,
            122117389,
            122107326,
            122130554,
            122090817,
            122093272,
            122093535
        ],
        "C": [
            122095530,
            122110873,
            122098409,
            122112986,
            122088985,
            122122234,
            122107021,
            122110115,
            122100227,
            122102454,
            122124600,
            122110793,
            122110757,
            122109117,
            122128432,
            122119096,
            122155152,
            122213467
        ],
        "A": [
            122082186,
            122076078,
            122075671,
            122076509,
            122122714,
            122075627,
            122075591,
            122075678,
            122076215,
            122076949,
            122075854,
            122076317,
            122085649,
            122075796,
            122075639,
            122080513,
            122075936,
            122075621,
            122078770
        ],
        "B": [
            122079612,
            122088170,
            122082472,
            122119780,
            122079771,
            122077496,
            122090297,
            122081981,
            122082032,
            122084749,
            122098370,
            122095139,
            122093255,
            122128209,
            122084402,
            122088184,
            122078878,
            122077599,
            122119388
        ],
        "F": [
            122258728,
            122258683,
            122258676,
            122258661,
            122258513,
            122258288,
            122147603,
            122158393,
            122158209
        ],
        "E2": [
            122155943,
            122135135
        ],
        "E1": [
            122155936,
            122155364,
            122153713,
            122135243
        ]
    },
    "name": "B. AquaMoon and Chess",
    "statement": "Cirno gave AquaMoon a chessboard of size 1\r\ntimes n. Its cells are numbered with integers from 1 to n from left to\r\nright. In the beginning, some of the cells are occupied with at most one\r\npawn, and other cells are unoccupied.In each operation, AquaMoon can\r\nchoose a cell i with a pawn, and do of the following (if possible): Move\r\npawn from it to the (i+2)-th cell, if i+2\r\nleq n and the (i+1)-th cell is occupied and the (i+2)-th cell is\r\nunoccupied. Move pawn from it to the (i-2)-th cell, if i-2\r\ngeq 1 and the (i-1)-th cell is occupied and the (i-2)-th cell is\r\nunoccupied. You are given an initial state of the chessboard. AquaMoon\r\nwants to count the number of states reachable from the initial state\r\nwith some sequence of operations. But she is not good at programming.\r\nCan you help her? As the answer can be large find it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pi;\ntypedef vector<int>vi;\nconst int maxn=1e6+10;\nconst int M=998244353;\nint f[maxn],nf[maxn],inv[maxn];\nint _,n,a[maxn],t,d,b;\nchar s[maxn];\nvoid init(){\n    inv[1]=1; for (int i=2;i<maxn;i++) inv[i]=M-1ll*(M/i)*inv[M%i]%M;\n    f[0]=nf[0]=1; for (int i=1;i<maxn;i++) f[i]=1ll*f[i-1]*i%M,nf[i]=1ll*nf[i-1]*inv[i]%M;\n}\nint C(int x,int y){return 1ll*f[x]*nf[y]%M*nf[x-y]%M;}\nvoid solve(){\n    scanf(\"%d%s\",&n,s);\n    t=0; d=0; b=0;\n    for (int i=0;i<n;i++){\n        a[++t]=s[i]-'0';\n        if (t>=2&&a[t]==1&&a[t-1]==1) t-=2,d++;\n    }\n    a[t+1]=0;\n    for (int i=0;i<=t;i++) if (!a[i]&&!a[i+1]) b++;\n    for (int i=1;i<=t;i++) if (a[i]) b++;\n    printf(\"%d\\n\",C(b-1+d,d));\n}\nint main(){\n    init();\n    scanf(\"%d\",&_);\n    while (_--) solve();\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. AquaMoon and Chess.json",
    "editorial_link": "https://codeforces.com//blog/entry/92739",
    "editorial": "We enumerate i\n from 1\n to n\n. If position i?1\n and i\n both contain a chess and i?1\n is not in other groups, then we divide them into one group.\n\nWe can change the operation a little: Each time we can swap the two consecutive 1\n and the element to their left or right. It's easy to see this operation equals to the initial one.\n\nSo that means we can take out the groups (two consecutive 1\n) and insert them to any position of the chessboard. So let the number of groups be m\n, the number of zeros be n\n, it's easy to find that the answer is (n+mm)\n(Since inserting one group to the left of some 1\n or to the right of it are the same).",
    "hint": []
}