{"link": "https://codeforces.com//contest/827/problem/E", "problemId": "113849", "problem_idx": "E", "shortId": "827E", "contest_number": "827", "problem_submissions": {"F": [28447535, 28704912], "B": [28442493, 28434829, 28432891, 28434941, 28434124, 28440743, 28434219, 28434038, 28435758, 28436170, 28442340, 28436191, 28436588, 28434003, 28436389, 28434757, 28437055, 28448594, 28438989], "C": [28440487, 28438660, 28438441, 28438938, 28437666, 28446435, 28437809, 28439569, 28439405, 28439836, 28438472, 28441170, 28440770, 28437931, 28442353, 28442274, 28441410, 28437286, 28455031, 28442955], "E": [28436548, 28441080, 28466758, 28444795, 28441962, 28439200, 28445462, 28450329, 28446470, 28443820, 28444149, 28441607, 28444424, 28451564, 28465030, 28453083, 28453061, 28452855, 28445979, 28445398, 28447328, 28450262, 28443711, 28447639], "A": [28432871, 28432173, 28431465, 28433215, 28452981, 28437424, 28432872, 28451754, 28432696, 28432687, 28432382, 28432827, 28432606, 28431751, 28435184, 28437702, 28433063, 28446111, 28434053], "D": [28445554, 28441989, 28447486, 28446928, 28441195, 28445740, 28448719, 28454047, 28460505, 28543175, 28454400, 28446342, 28447977, 29638472, 28445305, 28443739]}, "name": "E. Rusty String", "statement": "Grigory loves strings. Recently he found a metal strip on a loft. The\r\nstrip had length and consisted of letters \"\" and \"\". Unfortunately, rust\r\nhas eaten some of the letters so that it\u2019s now impossible to understand\r\nwhich letter was written.Grigory couldn\u2019t understand for a long time\r\nwhat these letters remind him of, so he became interested in the\r\nfollowing question: if we put a letter \"\" or \"\" on each unreadable\r\nposition, which values can the period of the resulting string be equal\r\nto?A period of a string is such an integer from to the length of the\r\nstring that if we put the string shifted by positions to the right on\r\nitself, then all overlapping letters coincide. For example, and are\r\nperiods of \"\".\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst double PI=3.14159265358979323;\nconst in mxcis=1<<20; // sum of sizes of arrays you're convoluting\nstruct comp{\n  double re,im;\n  comp(double a=0, double b=0){\n    re=a;\n    im=b;\n  }\n  comp conj()const{\n    return comp(re,-im);\n  }\n  comp operator+(const comp cp)const{\n    return comp(re+cp.re,im+cp.im);\n  }\n  comp operator-(const comp cp)const{\n    return comp(re-cp.re,im-cp.im);\n  }\n  comp operator*(const comp cp)const{\n    return comp(re*cp.re-im*cp.im,re*cp.im+im*cp.re);\n  }\n  comp operator*(const double cp)const{\n    return comp(re*cp,im*cp);\n  }\n  comp operator/(const double cp)const{\n    return comp(re/cp,im/cp);\n  }\n  comp& operator/=(const double cp){\n    re/=cp;\n    im/=cp;\n    return *this;\n  }\n  double sqn()const{\n    return ((*this)*(conj())).re;\n  }\n  comp operator/(const comp cp)const{\n    return (*this)*cp.conj()/cp.sqn();\n  }\n  comp& operator+=(const comp cp){\n    return (*this)=(*this)+cp;\n  }\n  comp& operator-=(const comp cp){\n    return (*this)=(*this)-cp;\n  }\n  comp& operator*=(const comp cp){\n    return (*this)=(*this)*cp;\n  }\n};\nconst comp iot(0,1);\nconst comp one(1,0);\nvector<comp> cissv;\ncomp cis(double a){\n  return comp(cos(a),sin(a));\n}\nvector<comp> ret(mxcis);\nvoid pm(vector<comp>& v, in& n){\n  forn(i,n/2){\n    ret[i]=v[2*i];\n    ret[i+n/2]=v[2*i+1];\n  }\n  forn(i,n)\n    v[i]=ret[i];\n}\nconst in brlm=10;\nvector<comp> tv(brlm);\nconst in MXDPT=30;\nvector<comp> v1[MXDPT];\nvoid fft(vector<comp>& v,in infc,in dpt,bool ntdv=1){\n  in n=sz(v);\n  if(n==1)\n    return;\n  in divc=mxcis/n;\n  if(n<=brlm){\n    forn(i,n){\n      tv[i]=v[i];\n      v[i]=0;\n    }\n    if(infc==1){\n      forn(i,n){\n\tforn(j,n){\n\t  v[i]+=tv[j]*cissv[mxcis-divc*i*j%mxcis];\n\t}\n      }\n    }\n    else{\n      forn(i,n){\n\tforn(j,n){\n\t  v[i]+=tv[j]*cissv[divc*i*j%mxcis];\n\t}\n      }\n    }\n    if(ntdv){\n      double sq=sqrt(n);\n      forn(i,n)\n\tv[i]/=sq;\n    }\n    return;\n  }\n  assert(n%2==0);\n  pm(v,n);\n  assert(dpt<MXDPT);\n  v1[dpt].resize(n/2);\n  forn(i,n/2)\n    v1[dpt][i]=v[i];\n  fft(v1[dpt],infc,dpt+1,0);\n  forn(i,n/2){\n    swap(v[i+n/2],v1[dpt][i]);\n    v[i]=v[i+n/2];\n  }\n  fft(v1[dpt],infc,dpt+1,0);\n  comp tm;\n  if(infc==1){\n    forn(i,n/2){\n      tm=v1[dpt][i]*cissv[mxcis-divc*i];\n      v[i]+=tm;\n      v[i+n/2]-=tm;\n    }\n  }\n  else{\n    forn(i,n/2){\n      tm=v1[dpt][i]*cissv[divc*i];\n      v[i]+=tm;\n      v[i+n/2]-=tm;\n    }\n  }\n  if(ntdv){\n    double sq=sqrt(n);\n    forn(i,n)\n      v[i]/=sq;\n  }\n}\nin rnd(double a){\n  if(a>0)\n    return a+0.5;\n  return a-0.5;\n}\nVI conv(VI a, VI b){\n  if(sz(cissv)==0){\n    cissv.resize(mxcis+1);\n    forv(i,cissv){\n      cissv[i]=cis(i*2*PI/double(mxcis));\n    }\n  }\n  in n=sz(a);\n  in m=sz(b);\n  if(n+m<=1000){\n    VI ans(n+m-1);\n    in lm,um;\n    in c;\n    forv(i,ans){\n      lm=min(i+1,n);\n      um=max(i-m+1,0);\n      c=0;\n      for(in x=um;x<lm;++x){\n\tc+=a[x]*b[i-x];\n      }\n      ans[i]=c;\n    }\n    return ans;\n  }\n  in np2=1;\n  while(np2<n+m)\n    np2*=2;\n  double sq=sqrt(np2);\n  vector<comp> c1,c2;\n  c1.resize(np2);\n  c2.resize(np2);\n  forn(i,n)\n    c1[i]=comp(a[n-1-i],0);\n  for(in i=n-1;i<n+m-1;i++)\n    c2[i]=comp(b[i-n+1],0);\n  fft(c1,1,0);\n  fft(c2,1,0);\n  forn(i,np2)\n    c2[i]*=c1[i].conj()*sq;\n  fft(c2,-1,0);\n  VI rt(np2);\n  forn(i,np2)\n    rt[i]=rnd(c2[i].re);\n  for(in i=n+m-1;i<np2;++i)\n    assert(rt[i]==0);\n  assert(rt[n-1+m-1]==a[n-1]*b[m-1]);\n  assert(rt[0]==a[0]*b[0]);\n  rt.resize(n+m-1);\n  return rt;\n}\nin ab(in a){\n  return a<0?-a:a;\n}\nstring s;\nVI posv,posk,con;\nVI ans;\nVI bad;\nvoid dot(){\n  in n;\n  cin>>n;\n  cin>>s;\n  posv.resize(n);\n  posk.resize(n);\n  forn(i,n){\n    posv[i]=(s[i]=='V');\n    posk[i]=(s[n-1-i]=='K');\n  }\n  con=conv(posv,posk);\n  bad.resize(n);\n  forn(i,n)\n    bad[i]=0;\n  forv(i,con){\n    if(con[i])\n      bad[ab(n-1-i)]=1;\n  }\n  ans.clear();\n  for(in i=1;i<=n;++i){\n    bool ok=1;\n    for(in j=i;j<n;j+=i){\n      if(bad[j])\n\tok=0;\n    }\n    if(ok)\n      ans.PB(i);\n  }\n  cout<<sz(ans)<<\"\\n\";\n  forv(i,ans)\n    cout<<ans[i]<<\" \";\n  cout<<\"\\n\";\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in t;\n  cin>>t;\n  forn(z,t){\n    dot();\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["fft", "math", "strings"], "dificulty": "2700", "interactive": false}