{
    "link": "https://codeforces.com//contest/1074/problem/E",
    "problemId": "249090",
    "problem_idx": "E",
    "shortId": "1074E",
    "contest_number": "1074",
    "problem_submissions": {
        "E": [
            45303620,
            45300249,
            45344571,
            45304718,
            45304862,
            45306309,
            45306510,
            45315681,
            45302002,
            45303642
        ],
        "F": [
            45297925,
            45302412,
            45298748,
            45300083,
            45299480,
            45298818,
            45299827,
            45300561,
            45300985,
            45300910,
            45302087,
            45302359,
            45302549,
            45302342,
            45306149,
            45302208,
            45303449,
            45304102,
            45303226
        ],
        "D": [
            45294973,
            45293128,
            45295261,
            45296109,
            45292313,
            45291734,
            45297119,
            45297694,
            45297259,
            45298710,
            45297635,
            45297369,
            45298399,
            45297846,
            45294290,
            45297091,
            45296770,
            45296596,
            45297365,
            45299859
        ],
        "C": [
            45293553,
            45291475,
            45293844,
            45294044,
            45293914,
            45294012,
            45293608,
            45295772,
            45294886,
            45297284,
            45296110,
            45294396,
            45293720,
            45296080,
            45292596,
            45294430,
            45294994,
            45295210,
            45294620,
            45296058
        ],
        "B": [
            45292377,
            45294890,
            45292284,
            45297195,
            45296274,
            45295787,
            45291944,
            45293450,
            45293244,
            45294291,
            45295233,
            45293263,
            45291573,
            45294870,
            45303353,
            45293540,
            45298407,
            45293034,
            45292582,
            45292571
        ],
        "A": [
            45289520,
            45289825,
            45289616,
            45289578,
            45294985,
            45294783,
            45289998,
            45290374,
            45289949,
            45291060,
            45291837,
            45290090,
            45295330,
            45290627,
            45290102,
            45291029,
            45290582,
            45297889,
            45289941,
            45289786
        ]
    },
    "name": "E. Grid Sort",
    "statement": "You are given an n\r\ntimes m grid. Each grid cell is filled with a unique integer from 1 to\r\nnm so that each integer appears exactly once.In one operation, you can\r\nchoose an arbitrary cycle of the grid and move all integers along that\r\ncycle one space over. Here, a cycle is any sequence that satisfies the\r\nfollowing conditions: There are at least four squares. Each square\r\nappears at most once. Every pair of adjacent squares, and also the first\r\nand last squares, share an edge. For example, if we had the following\r\ngrid: We can choose an arbitrary cycle like this one: To get the\r\nfollowing grid: In this particular case, the chosen cycle can be\r\nrepresented as the sequence [1, 2, 3, 6, 5, 8, 7, 4], the numbers are in\r\nthe direction that we want to rotate them in.Find any sequence of\r\noperations to sort the grid so that the array created by concatenating\r\nthe rows from the highest to the lowest is sorted (look at the first\r\npicture above).Note you do not need to minimize number of operations or\r\nsum of cycle lengths. The only constraint is that the sum of all cycles\r\nlengths must not be greater than 10^5. We can show that an answer always\r\nexists under the given constraints. Output any valid sequence of moves\r\nthat will sort the grid.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=107;\n\nint n, m;\n\nint tab[nax][nax];\nint musz[nax][nax];\n\nvector <vi> wyn;\n\npii fast[nax*nax];\n\ninline pii gdz(const int &v)\n{\n\treturn fast[v];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (tab[i][j]==v)\n\t\t\t\treturn {i, j};\n\tassert(0);\n}\n\ninline int &war(const pii &v)\n{\n\treturn tab[v.first][v.second];\n}\n\nvoid zrob(const vi &wek)\n{\n\tvector <pii> poz(wek.size());\n\t//~ for (int i : wek)\n\t\t//~ poz.push_back(gdz(i));\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t\tpoz[i]=gdz(wek[i]);\n\t//~ debug() << poz;\n\tfor (int i=(int)poz.size()-1; i>0; i--)\n\t{\n\t\tpii a=poz[i];\n\t\tpii b=poz[i-1];\n\t\tswap(tab[a.first][a.second], tab[b.first][b.second]);\n\t\tswap(fast[tab[a.first][a.second]], fast[tab[b.first][b.second]]);\n\t\t\n\t\t//~ swap(war(poz[i]), war(poz[i-1]));\n\t\t//~ swap(fast[war(poz[i])], fast[war(poz[i-1])]);\n\t}\n\twyn.push_back(wek);\n}\n\nvoid cofnij()\n{\n\tassert(!wyn.empty());\n\tvi wez=wyn.back();\n\treverse(wez.begin(), wez.end());\n\tzrob(wez);\n\twyn.pop_back();\n\twyn.pop_back();\n}\n\nvi daj_kwa(pii v)\n{\n\tvi ret;\n\tret.push_back(tab[v.first][v.second]);\n\tret.push_back(tab[v.first][v.second+1]);\n\tret.push_back(tab[v.first+1][v.second+1]);\n\tret.push_back(tab[v.first+1][v.second]);\n\treturn ret;\n}\n\nvi daj_kwa2(pii v)\n{\n\tvi ret=daj_kwa(v);\n\treverse(ret.begin(), ret.end());\n\treturn ret;\n}\n\nint chce[nax*nax];\n\nvi los(int a, int b)\n{\n\t//~ if (rand()&1)\n\t//~ {\n\t\tif (rand()&1)\n\t\t\treturn daj_kwa({a+(rand()&1), b+(rand()&1)});\n\t\telse\n\t\t\treturn daj_kwa2({a+(rand()&1), b+(rand()&1)});\n\t//~ }\n}\n\nvoid solve(int a, int b, int lim)\n{\n\twhile(1)\n\t{\n\t\tfor (int h=0; h<lim/4; h++)\n\t\t{\n\t\t\tint czy=1;\n\t\t\tfor (int i=0; i<3 && czy; i++)\n\t\t\t\tfor (int j=0; j<3 && czy; j++)\n\t\t\t\t\tif (chce[musz[a+i][b+j]] && musz[a+i][b+j]!=tab[a+i][b+j])\n\t\t\t\t\t\tczy=0;\n\t\t\tif (czy)\n\t\t\t\treturn;\n\t\t\tzrob(los(a, b));\n\t\t}\n\t\t\n\t\t\n\t\tfor (int i=0; i<lim/4; i++)\n\t\t\tcofnij();\n\t}\n}\n\nint przelicz()\n{\n\tint ret=0;\n\tfor (vi i : wyn)\n\t\tret+=i.size();\n\treturn ret;\n}\n\nbool mniej(pii a, pii b)\n{\n\treturn a.second>b.second;\n}\n\nconst int magic=1200;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tmusz[i][j]=m*(i-1)+j;\n\t\t\tscanf(\"%d\", &tab[i][j]);\n\t\t\tfast[tab[i][j]]={i, j};\n\t\t}\n\t}\n\tint pn=n;\n\twhile(pn>3)\n\t{\n\t\t//~ debug() << \"a\";\n\t\tfor (int i=m; i>1; i--)\n\t\t{\n\t\t\tint tutaj=musz[pn][i];\n\t\t\twhile(gdz(tutaj)!=make_pair(pn, i))\n\t\t\t{\n\t\t\t\tpii x=gdz(tutaj);\n\t\t\t\tif (x.second!=i)\n\t\t\t\t{\n\t\t\t\t\tif (x.second<i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (x.first<pn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa(x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa2({x.first-1, x.second}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (x.first<pn-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa2({x.first, x.second-1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa({x.first-1, x.second-1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzrob(daj_kwa({x.first, x.second-1}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint tutaj=musz[pn][1];\n\t\twhile(gdz(tutaj).first<pn-1)\n\t\t{\n\t\t\tpii x=gdz(tutaj);\n\t\t\tif (x.second>1)\n\t\t\t{\n\t\t\t\tzrob(daj_kwa({x.first, x.second-1}));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzrob(daj_kwa2(x));\n\t\t\t}\n\t\t}\n\t\twhile(gdz(tutaj).second>3)\n\t\t{\n\t\t\tpii x=gdz(tutaj);\n\t\t\tzrob(daj_kwa({x.first-1, x.second-1}));\n\t\t}\n\t\t\n\t\tchce[musz[pn][1]]=chce[musz[pn][2]]=chce[musz[pn][3]]=1;\n\t\tsolve(pn-2, 1, magic);\n\t\tpn--;\n\t}\n\t\n\tint pm=m;\n\twhile(pm>3)\n\t{\n\t\tvector <pii> poz;\n\t\tfor (int i=1; i<=3; i++)\n\t\t\tpoz.push_back(gdz(musz[i][pm]));\n\t\tsort(poz.begin(), poz.end(), mniej);\n\t\tint czy=0;\n\t\tfor (int i=0; i<3; i++)\n\t\t{\n\t\t\tif (poz[i].second>=pm-i)\n\t\t\t\tcontinue;\n\t\t\tczy=1;\n\t\t\tpii x=poz[i];\n\t\t\tif (x.first==1)\n\t\t\t\tzrob(daj_kwa(x));\n\t\t\telse\n\t\t\t\tzrob(daj_kwa2({x.first-1, x.second}));\n\t\t\tbreak;\n\t\t}\n\t\tif (czy)\n\t\t\tcontinue;\n\t\t\n\t\tchce[musz[1][pm]]=chce[musz[2][pm]]=chce[musz[3][pm]]=1;\n\t\tsolve(1, pm-2, magic);\n\t\tpm--;\n\t}\n\tint resz=99*1000-przelicz();\n\tfor (int i=1; i<=3; i++)\n\t\tfor (int j=1; j<=3; j++)\n\t\t\tchce[musz[i][j]]=1;\n\tsolve(1, 1, resz);\n\t\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ debug() << range(tab[i]+1, tab[i]+1+m);\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tassert(musz[i][j]==tab[i][j]);\n\tdebug() << imie(przelicz());\n\t\n\t//~ return 0;\n\tprintf(\"%d\\n\", (int)wyn.size());\n\tfor (vi i : wyn)\n\t{\n\t\tprintf(\"%d\", (int)i.size());\n\t\tfor (int j : i)\n\t\t\tprintf(\" %d\", j);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Grid Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/62985",
    "editorial": "The solution is more of a coding one than an algorithmic one. There are\r\nmany different approaches, and itâs important to be careful in how it is\r\nimplemented. Iâll explain one of the implementations.First, we can\r\nalways move a particular block left, up, down, or right with an\r\nappropriate 2x2 square around it. Letâs code some functions that let us\r\ndo that for each direction.Next is to make sure that these moves donât\r\nmess up previous block spaces as we move blocks to the correct place. We\r\ncan almost place blocks correctly in their spaces one by one in row\r\nmajor order, but there are some special cases.- We can do all blocks\r\nexcept the last two rows, which weâll handle separately (in paragraph\r\nbelow) - For each row, we can correctly place all blocks except the last\r\none. The last one requires a bit more careful work, but is easy to\r\nhandle if we have at least two free rows.For the last two rows, we can\r\nfill it in column by column from left to right. This is a similar\r\nstartegy to fitting in the last column of the previous rows. We can\r\nalmost do this except for the last 2x2 square.For the last 2x2 square,\r\nwe can use the following sequence of moves to swap two\r\nblocks:123456413526421563213456Thus, we can shift the last block into\r\nthe right position, then do at most three swaps (using the above\r\nsequence of moves) to fix the remaining blocks.The number of moves for\r\nthis strategy can be computed and estimated to be about 50k in the worst\r\ncase.\r\n",
    "hint": []
}