{
    "link": "https://codeforces.com//contest/1588/problem/E",
    "problemId": "1186194",
    "problem_idx": "E",
    "shortId": "1588E",
    "contest_number": "1588",
    "problem_submissions": {
        "D": [
            135372629,
            135381098,
            135359109,
            135369800,
            135370088,
            135380867,
            135357823,
            135362201,
            135366407,
            135370846,
            135374380,
            135373580,
            135374295,
            135373419,
            135378493,
            135376601,
            135375978,
            135382040
        ],
        "C": [
            135363142,
            135352112,
            135379109,
            135361010,
            135362653,
            135375549,
            135350810,
            135353082,
            135359513,
            135351205,
            135365941,
            135366190,
            135366197,
            135366261,
            135798161,
            135798159,
            135798156,
            135798153,
            135793795,
            135353318,
            135359719,
            135363580,
            135376282,
            135360557
        ],
        "B": [
            135354041,
            135372942,
            135367733,
            135353235,
            135382607,
            135353847,
            135347088,
            135367644,
            135348462,
            135359847,
            135354086,
            135351940,
            135356516,
            135347194,
            135365557,
            135349342,
            135357424,
            135354885,
            135351181
        ],
        "A": [
            135347972,
            135342643,
            135342911,
            135343015,
            135342760,
            135342918,
            135342730,
            135343666,
            135342808,
            135352544,
            135343056,
            135344466,
            135342657,
            135342700,
            135342859,
            135345441,
            135343145,
            135343927,
            135342677
        ],
        "E": [
            135346443,
            135364189,
            135371530,
            135382787,
            135381160,
            135387683,
            135507210,
            135399676,
            135412491,
            135411131,
            135507958,
            135387301
        ],
        "F": [
            135608326,
            135531498,
            135406993,
            135398120,
            135395364
        ]
    },
    "name": "E. Eligible Segments",
    "statement": "You are given n points p_1, p_2,\r\nldots, p_n on the plane and a positive integer R. Find the number of\r\npairs of indices (i, j) such that 1\r\nle i < j\r\nle n, and for every possible k (1\r\nle k\r\nle n) the distance from the point p_k to the between points p_i and p_j\r\nis at most R.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing real_t = long double;\nusing pi = pair<real_t, real_t>;\nconst int MAXN = 3005;\nconst real_t PI = acos(-1.0L);\nconst real_t eps = 1e-8L;\n\nbool go[MAXN][MAXN];\nint n, d;\n\ncomplex<real_t> a[MAXN];\n\nreal_t norm(real_t x){\n\treturn fmod(x + 4 * PI, 2 * PI);\n}\n\n// it is quite similar to NEERC 2015 northern kingdom trip\n\nint main(){\n\tcin >> n >> d;\n\tfor(int i=0; i<n; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = complex<real_t>(x, y);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tpi rng(-1e9, 1e9);\n\t\treal_t rot;\n\t\tbool fucked = 0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(rng.first < -1e8){\n\t\t\t\tif(abs(a[j] - a[i]) <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trot = PI - arg(a[j] - a[i]);\n\t\t\t}\n\t\t\tauto dir = norm(arg(a[j] - a[i]) + rot);\n\t\t\tauto dist = abs(a[j] - a[i]);\n\t\t\tif(dist <= d) continue;\n\t\t\tauto ang = asin(d / dist);\n\t\t\tauto bound_l = norm(dir - ang);\n\t\t\tauto bound_r = norm(dir + ang);\n\t\t\tif(bound_l > bound_r){\n\t\t\t\tif(bound_l < rng.second){\n\t\t\t\t\trng.first = max(rng.first, bound_l);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trng.second = min(rng.second, bound_r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trng.first = max(rng.first, bound_l);\n\t\t\t\trng.second = min(rng.second, bound_r);\n\t\t\t}\n\t\t\tif(rng.first > rng.second ){\n\t\t\t\tfucked = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fucked) continue;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(rng.first < -1e8){\n\t\t\t\tauto dist = abs(a[j] - a[i]);\n\t\t\t\tassert(dist <= d);\n\t\t\t\tgo[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto dir = norm(arg(a[j] - a[i]) + rot);\n\t\t\tif(rng.first <= dir && dir <= rng.second){\n\t\t\t\tgo[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(go[i][j] && go[j][i]) ret++;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "two pointers"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Eligible Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/96953",
    "editorial": "The distance from point P\n to segment [AB]\n is equal to the maximum of the distance from point P\n to ray [AB)\n and the distance from point P\n to ray [BA)\n.\n\nLet's fix a point Pi\n. Now we have to find all points Pj\n such that distance from every point Pk(1?k?n)\n to the ray [Pi,Pj)\n is less than R\n.\n\nFor every point Pk\n let's build two tangents from point Pi\n to the circle with the center in the point Pk\n and radius R\n. These tangents form an angle Ak\n. The distance from the point Pk(1?k?n)\n to the ray [Pi,Pj)\n is less than R\n iff the ray [Pi,Pj)\n lies inside the angle Ak\n. So we can build all these angles Ak\n and intersect them, after that, we only have to check that the ray [Pi,Pj)\n lies inside the intersection of all angles for all 1?j?n\n."
}