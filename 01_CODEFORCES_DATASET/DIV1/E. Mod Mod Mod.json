{
    "link": "https://codeforces.com//contest/889/problem/E",
    "problemId": "133722",
    "problem_idx": "E",
    "shortId": "889E",
    "contest_number": "889",
    "problem_submissions": {
        "D": [
            32268277,
            32261782,
            32262346,
            32267448,
            32264912,
            32270286,
            32262994,
            32270235,
            32268920
        ],
        "E": [
            32261080,
            32269250,
            42287448
        ],
        "C": [
            32258949,
            32258309,
            32261571,
            32258724,
            32261718,
            32260558,
            32259837,
            32261642,
            32262113,
            32268280,
            32263105,
            32260984,
            32260094,
            32262538,
            32263363,
            32275764,
            32267069,
            32261624,
            32263229
        ],
        "B": [
            32252734,
            32253330,
            32255576,
            32255239,
            32254428,
            32258155,
            32254407,
            32256519,
            32255311,
            32263055,
            32253848,
            32255572,
            32252983,
            32255704,
            32255404,
            32253464,
            32255981
        ],
        "A": [
            32248128,
            32248978,
            32250463,
            32251033,
            32250128,
            32254306,
            32249854,
            32249329,
            32248510,
            32248897,
            32270420,
            32248851,
            32248699,
            32248336,
            32249379,
            32249111,
            32248222,
            32250477
        ]
    },
    "name": "E. Mod Mod Mod",
    "statement": "You are given a sequence of integers . Let , and for . Here, denotes the\r\nmodulus operation. Find the maximum value of over all nonnegative\r\nintegers .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\nconst ll INF = (1ll << 50);\n\nset <pair <ll, ll>> s;\n\nvoid ins(ll x, ll y) {\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n;\n    cin >> n;\n\n    ll p = INF;\n\n    s.emplace(p - 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        ll x;\n        cin >> x;\n\n        if (x >= p) {\n            continue;\n        }\n\n        p = x;\n\n        vector<pair<ll, ll>> rmed;\n        while (!s.empty()) {\n            auto val = *s.rbegin();\n            if (val.first < x - 1) {\n                break;\n            }\n\n            s.erase(val);\n            rmed.push_back(val);\n        }\n\n\n        pair<ll, ll> tmp{ x, -1 };\n        s.emplace(tmp);\n\n        ll last = 0;\n\n        for (auto& val : rmed) {\n            ll dv = val.first / x;\n            last = max(last, val.second + x * (dv - 1) * i);\n            ll md = val.first % x;\n            ll nvl = x * dv * i + val.second;\n            auto it = s.lower_bound(pair<ll, ll>{md, nvl});\n\n            if (it->second >= nvl) {\n                continue;\n            }\n\n            auto lit = it;\n            while (lit != s.begin()) {\n                auto nit = lit;\n                --nit;\n                if (nit->second > nvl) {\n                    break;\n                }\n                lit = nit;\n            }\n\n            s.erase(lit, it);\n            s.emplace(md, nvl);\n        }\n\n        while (!s.empty() && s.rbegin()->second <= last) {\n            auto it = s.end();\n            --it;\n            s.erase(it);\n        }\n\n        s.emplace(x - 1, last);\n    }\n\n    ll ans = 0;\n\n    for (auto& val : s) {\n        ans = max(ans, val.first * n + val.second);\n    }\n\n    cout << ans << \"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Mod Mod Mod.json",
    "editorial_link": "https://codeforces.com//blog/entry/55734",
    "editorial": "let . Can you define some segments of value ? think of some dp. once you\r\nget the dp in , to speed it up, note the following fact: if , then\r\neither or . let\u00e2\u0080\u0099s call , in other words, it\u00e2\u0080\u0099s the part of answer we gain\r\nfrom summands from to . For the following is true: can be any number\r\nfrom to , and .Suppose for some we have the following option: can be any\r\nnumber from to , and in this case . We can describe this situation by\r\ntriple . We will show that this triple will produce at most two such\r\ntriples for . Indeed, we can have many triples with different and one\r\ntriple . However, we can note that among triplets of the first type we\r\ncan leave only one with maximum , because we\u00e2\u0080\u0099re interested in maximum\r\nanswer. This will equal . Thus, we have two transitions from each\r\ntriple, that leads us to bruteforce solution. when we have a bruteforce,\r\nwe (almost) always can think of a dp. Indeed, we have triples, among\r\nthose with equal and let\u00e2\u0080\u0099s keep only one with the largest . There are at\r\nmost such triples on step : on each step half of the generated triples\r\nhave , so we can merge them. This leads us to dp in . Okay, what does\r\nthe third hint say? It basically says that a number can only be taken by\r\nmodulo times until it becomes zero, where is the bound of its initial\r\nvalue. What do we get from this? We can note that if , we can just leave\r\na triple untouched except changing to . Let\u00e2\u0080\u0099s then keep pairs , assuming\r\ntriples , where changes in a cycle. On each step we should change all\r\npairs such that , possibly adding one more pair with . But when we\r\nchange a pair, is get by modulo, so this won\u00e2\u0080\u0099t happen with a pair more\r\nthan times! Overall, the total number of times we touch a pair is\r\nbounded by . Adding for map in which we keeps the pairs, we obtain the\r\nfinal complexity . Also, map can be replaced with binary search, but the\r\ncomplexity remains the same.\r\n"
}