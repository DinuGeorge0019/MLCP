{
    "link": "https://codeforces.com//contest/573/problem/B",
    "problemId": "34311",
    "problem_idx": "B",
    "shortId": "573B",
    "contest_number": "573",
    "problem_submissions": {
        "E": [
            12759251,
            12766903,
            12766685,
            12854212
        ],
        "C": [
            12753961,
            12751834,
            12752631,
            12751871,
            12753878,
            12754621,
            12753383,
            12752808,
            12753460,
            12750581,
            12750687,
            12754051,
            12757263,
            12753734,
            12752897,
            12751281,
            12753745,
            12753332
        ],
        "B": [
            12746992,
            12747515,
            12746798,
            12748316,
            12747498,
            12747954,
            12747704,
            12747330,
            12747866,
            12747572,
            12747495,
            12748230,
            12747423,
            12748530,
            12748216,
            12747086,
            12747056,
            12748571
        ],
        "A": [
            12746189,
            12746077,
            12746084,
            12746660,
            12746402,
            12746165,
            12746157,
            12746206,
            12746195,
            12746103,
            12746141,
            12746264,
            12746158,
            12746252,
            12746081,
            12746225,
            12746120,
            12746512
        ],
        "D": [
            12760293,
            12767357,
            12767345,
            12767321,
            12767302,
            12767261,
            12766285,
            12766274,
            12759069,
            12759185,
            12761792,
            12787796,
            12787738,
            12787732,
            12762112,
            12766448,
            12762456,
            12761429,
            12791178,
            12769647,
            12769635
        ]
    },
    "name": "B. Bear and Blocks",
    "statement": "Limak is a little bear who loves to play. Today he is playing by\r\ndestroying block towers. He built towers in a row. The -th tower is made\r\nof identical blocks. For clarification see picture for the first\r\nsample.Limak will repeat the following operation till everything is\r\ndestroyed.Block is called internal if it has all four neighbors, i.e. it\r\nhas each side (top, left, down and right) adjacent to other block or to\r\nthe floor. Otherwise, block is boundary. In one operation Limak destroys\r\nall boundary blocks. His paws are very fast and he destroys all those\r\nblocks at the same time.Limak is ready to start. You task is to count\r\nhow many operations will it take him to destroy all towers.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint n;\nint t[MAX];\nint w1[MAX],w2[MAX];\nmain(){\n  make(n);\n  R(i,n)make(t[i]);\n  R(i,n)w1[i+1] = min(w1[i]+1,t[i]);\n  FD(i,n)w2[i] = min(w2[i+1]+1,t[i]);\n  int wyn = 0;\n  R(i,n)MA(wyn,min(w1[i+1],w2[i]));\n  printf(\"%d\\n\",wyn);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Bear and Blocks.json",
    "editorial_link": "https://codeforces.com//blog/entry/20040",
    "editorial": "In one operation the highest block in each tower disappears. So do all blocks above heights of neighbour towers. And all other blocks remain. It means that in one operation all heights change according to formula hi?=?min(hi?-?1,?hi?-?1,?hi?+?1) where h0?=?hn?+?1?=?0. By using this formula two times we get height after two operations: hi?=?max(0,?min(hi?-?2,?hi?-?1?-?1,?hi?-?2,?hi?+?1?-?1,?hi?+?2)) and so on. From now I will omit max(0,?...) part to make it easier to read.\n\nAfter k operations we get hi?=?min(Left,?Right) where Left?=?min(hi?-?j?-?(k?-?j))?=?min(hi?-?j?+?j?-?k) for  and Right is defined similarly. hi becomes zero when Left or Right becomes zero. And Left becomes zero when k?=?min(hi?-?j?+?j) \u0097 we will find this value for all i. If you are now lost in this editorial, try to draw some test and analyze my formulas with it."
}