{
    "link": "https://codeforces.com//contest/1483/problem/F",
    "problemId": "931275",
    "problem_idx": "F",
    "shortId": "1483F",
    "contest_number": "1483",
    "problem_submissions": {
        "F": [
            110657198,
            110657366,
            110680394,
            110676074,
            110665233,
            113439308,
            113059400,
            111430671,
            111430417
        ],
        "D": [
            110640647,
            110642867,
            110640739,
            110649362,
            110656109,
            110648351,
            110669875,
            110646025,
            110641671,
            110641253,
            110642818,
            110645567,
            110644771,
            110644923,
            110644779,
            110648343,
            110645625,
            110649200,
            110647913
        ],
        "C": [
            110637482,
            110639495,
            110638107,
            110639034,
            110636245,
            110643783,
            110646712,
            110639119,
            110637748,
            110637078,
            110639242,
            110639215,
            110640002,
            110638528,
            110640575,
            110640398,
            110641125,
            110641145,
            110641078,
            110642087
        ],
        "B": [
            110634536,
            110634072,
            110635529,
            110635361,
            110642670,
            110636167,
            110639544,
            110634766,
            110633516,
            110637084,
            110643607,
            110635632,
            110634992,
            110636625,
            110637243,
            110635431,
            110638777,
            110635673,
            110637846
        ],
        "A": [
            110629442,
            110628350,
            110629067,
            110628964,
            110631520,
            110629138,
            110634726,
            110632933,
            110628500,
            110629504,
            110630632,
            110632453,
            110628740,
            110630017,
            110629975,
            110630962,
            110628508,
            110633725,
            110630402,
            110630508
        ],
        "E": [
            110660726,
            110669157,
            204375141,
            110665918,
            110662689,
            110666386,
            110657015,
            113441196,
            113891758,
            110672789,
            111426124,
            110692107
        ]
    },
    "name": "F. Exam",
    "statement": "This year a Chunin Selection Exam is held again in Konoha, and taking\r\npart in it are n ninjas named s_1, s_2, ..., s_n. All names are\r\ndistinct. One of the exam stages consists of fights between the\r\nparticipants. This year the rules determining the ninjas for each fight\r\nare the following: ninjas i and j fight against each other if the\r\nfollowing conditions are held: i\r\nneq j; s_{j} is a substring of s_{i}; there is no k except i and j that\r\ns_{j} is a substring of s_{k}, and s_{k} is a substring of s_{i}. A\r\nstring a is a substring of a string b if a can be obtained from b by\r\ndeletion of several (possibly, zero or all) characters from the\r\nbeginning and several (possibly, zero or all) characters from the\r\nend.Your task is to find out how many fights are going to take place\r\nthis year.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n/** Binary-indexed tree\n *\n *  A binary indexed tree with N nodes of type T provides the\n *  following two functions for 0 <= i <= N:\n *\n *      prefix(int i) -> prefix_iterator<T>\n *      suffix(int i) -> suffix_iterator<T>\n *\n *  such that size(suffix(i) intersect prefix(j)) = (1 if i < j else 0).\n *  Furthermore, the resulting lists always have size at most log_2(N).\n *\n *  This can be used to implement either point-update/(prefix|suffix)-query or\n *  (prefix|suffix)-update/point-query over a virtual array of size N of a\n *  commutative monoid. This can be generalized to implement\n *  point-update/range-query or range-update/point-query over a virtual array\n *  of size N of a commutative group.\n *\n *  With 0-indexed data, prefixes are more natural:\n *   * For range update/query, use for_prefix for the ranges and for_suffix for the points.\n *   * For prefix update/query, no change.\n *   * For suffix update/query, use for_prefix(point + 1); 1-index the data.\n */\ntemplate <typename T> class binary_indexed_tree {\nprivate:\n\tstd::vector<T> dat;\npublic:\n\tbinary_indexed_tree() {}\n\texplicit binary_indexed_tree(size_t N) : dat(N) {}\n\tbinary_indexed_tree(size_t N, const T& t) : dat(N, t) {}\n\n\tsize_t size() const { return dat.size(); }\n\tconst std::vector<T>& data() const { return dat; }\n\tstd::vector<T>& data() { return dat; }\n\nprivate:\n\ttemplate <typename I, typename S = I> struct iterator_range {\n\tprivate:\n\t\tI begin_;\n\t\tS end_;\n\tpublic:\n\t\titerator_range() : begin_(), end_() {}\n\t\titerator_range(const I& begin__, const S& end__) : begin_(begin__), end_(end__) {}\n\t\titerator_range(I&& begin__, S&& end__) : begin_(begin__), end_(end__) {}\n\t\tI begin() const { return begin_; }\n\t\tS end() const { return end_; }\n\t};\n\npublic:\n\tclass const_suffix_iterator {\n\tprivate:\n\t\tconst T* dat;\n\t\tint a;\n\t\tconst_suffix_iterator(const T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const const_suffix_iterator& i, const const_suffix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a < j.a;\n\t\t}\n\t\tconst_suffix_iterator& operator ++ () {\n\t\t\ta |= a+1;\n\t\t\treturn *this;\n\t\t}\n\t\tconst T& operator * () const {\n\t\t\treturn dat[a];\n\t\t}\n\t};\n\tusing const_suffix_range = iterator_range<const_suffix_iterator>;\n\tconst_suffix_range suffix(int a) const {\n\t\tassert(0 <= a && a <= int(dat.size()));\n\t\treturn const_suffix_range{const_suffix_iterator{dat.data(), a}, const_suffix_iterator{nullptr, int(dat.size())}};\n\t}\n\n\tclass suffix_iterator {\n\tprivate:\n\t\tT* dat;\n\t\tint a;\n\t\tsuffix_iterator(T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const suffix_iterator& i, const suffix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a < j.a;\n\t\t}\n\t\tsuffix_iterator& operator ++ () {\n\t\t\ta |= a+1;\n\t\t\treturn *this;\n\t\t}\n\t\tT& operator * () const {\n\t\t\treturn dat[a];\n\t\t}\n\t};\n\tusing suffix_range = iterator_range<suffix_iterator>;\n\tsuffix_range suffix(int a) {\n\t\tassert(0 <= a && a <= int(dat.size()));\n\t\treturn suffix_range{suffix_iterator{dat.data(), a}, suffix_iterator{nullptr, int(dat.size())}};\n\t}\n\n\tclass const_prefix_iterator {\n\tprivate:\n\t\tconst T* dat;\n\t\tint a;\n\t\tconst_prefix_iterator(const T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const const_prefix_iterator& i, const const_prefix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a > 0;\n\t\t}\n\t\tconst_prefix_iterator& operator ++ () {\n\t\t\ta &= a-1;\n\t\t\treturn *this;\n\t\t}\n\t\tconst T& operator * () const {\n\t\t\treturn dat[a-1];\n\t\t}\n\t};\n\tusing const_prefix_range = iterator_range<const_prefix_iterator>;\n\tconst_prefix_range prefix(int a) const {\n\t\treturn const_prefix_range{const_prefix_iterator{dat.data(), a}, const_prefix_iterator{nullptr, 0}};\n\t}\n\n\tclass prefix_iterator {\n\tprivate:\n\t\tT* dat;\n\t\tint a;\n\t\tprefix_iterator(T* dat_, int a_) : dat(dat_), a(a_) {}\n\t\tfriend class binary_indexed_tree;\n\tpublic:\n\t\tfriend bool operator != (const prefix_iterator& i, const prefix_iterator& j) {\n\t\t\tassert(j.dat == nullptr);\n\t\t\treturn i.a > 0;\n\t\t}\n\t\tprefix_iterator& operator ++ () {\n\t\t\ta &= a-1;\n\t\t\treturn *this;\n\t\t}\n\t\tT& operator * () const {\n\t\t\treturn dat[a-1];\n\t\t}\n\t};\n\tusing prefix_range = iterator_range<prefix_iterator>;\n\tprefix_range prefix(int a) {\n\t\treturn prefix_range{prefix_iterator{dat.data(), a}, prefix_iterator{nullptr, 0}};\n\t}\n};\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N; cin >> N;\n\tvector<string> W(N);\n\tint totL = 0;\n\tfor (auto& w : W) {\n\t\tcin >> w;\n\t\ttotL += int(w.size());\n\t}\n\n\tvector<array<int, 26>> ch; ch.reserve(totL+1);\n\tvector<int> is_end; is_end.reserve(totL+1);\n\tch.emplace_back(); ch.back().fill(0); is_end.push_back(-1);\n\tfor (int i = 0; i < N; i++) {\n\t\tint cur = 0;\n\t\tfor (char c : W[i]) {\n\t\t\tif (!ch[cur][c-'a']) {\n\t\t\t\tch[cur][c-'a'] = int(ch.size());\n\t\t\t\tch.emplace_back(); ch.back().fill(0); is_end.push_back(-1);\n\t\t\t}\n\t\t\tcur = ch[cur][c-'a'];\n\t\t}\n\t\tis_end[cur] = i;\n\t}\n\n\tint V = int(ch.size());\n\tvector<int> fail(V);\n\tfail[0] = -1;\n\tvector<int> fail_end(V);\n\n\tvector<int> fail_par(N);\n\tvector<vector<int>> fail_ch(N+1);\n\n\tvector<int> q; q.reserve(V);\n\tq.push_back(0);\n\tfor (int z = 0; z < V; z++) {\n\t\tassert(z < int(q.size()));\n\t\tint cur = q[z];\n\t\tfor (int c = 0; c < 26; c++) {\n\t\t\tint fail_val = cur == 0 ? 0 : ch[fail[cur]][c];\n\t\t\tif (ch[cur][c]) {\n\t\t\t\tfail[ch[cur][c]] = fail_val;\n\t\t\t\tq.push_back(ch[cur][c]);\n\t\t\t} else {\n\t\t\t\tch[cur][c] = fail_val;\n\t\t\t}\n\t\t}\n\n\t\tif (is_end[cur] != -1) {\n\t\t\tfail_end[cur] = is_end[cur];\n\n\t\t\tint p = fail_end[fail[cur]];\n\t\t\tfail_par[is_end[cur]] = p;\n\t\t\tfail_ch[p].push_back(is_end[cur]);\n\t\t\t//cerr << \"parent of \" << is_end[cur] << \" \" << W[is_end[cur]] << \" is \" << p << '\\n';\n\t\t} else if (cur == 0) {\n\t\t\tfail_end[cur] = N;\n\t\t} else {\n\t\t\tfail_end[cur] = fail_end[fail[cur]];\n\t\t}\n\t}\n\n\tvector<array<int, 2>> bounds(N+1);\n\t{\n\t\tint cur_idx = 0;\n\t\tstd::y_combinator([&](auto self, int cur) -> void {\n\t\t\tbounds[cur][0] = cur_idx;\n\t\t\tcur_idx++;\n\t\t\tfor (int nxt : fail_ch[cur]) {\n\t\t\t\tself(nxt);\n\t\t\t}\n\t\t\tbounds[cur][1] = cur_idx;\n\t\t})(N);\n\t}\n\n\tbinary_indexed_tree<int> bit(N+1);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < N; i++) {\n\t\t//cerr << \"running word \" << i << ' ' << W[i] << '\\n';\n\n\t\tint L = int(W[i].size());\n\t\tvector<int> states(L+1);\n\t\tstates[0] = 0;\n\t\tfor (int z = 0; z < L; z++) {\n\t\t\tstates[z+1] = ch[states[z]][W[i][z]-'a'];\n\t\t}\n\t\tvector<int> bads; bads.reserve(L);\n\t\tvector<int> cnds; cnds.reserve(L);\n\t\tint best_start = L;\n\t\tfor (int z = L; z >= 0; z--) {\n\t\t\tint m = fail_end[states[z]];\n\t\t\tif (z == L) {\n\t\t\t\tassert(m == i);\n\t\t\t\tm = fail_par[m];\n\t\t\t}\n\t\t\tif (m == N) continue;\n\t\t\tint start = z - int(W[m].size());\n\t\t\tif (start < best_start) {\n\t\t\t\tbest_start = start;\n\t\t\t\tcnds.push_back(m);\n\t\t\t\tm = fail_par[m];\n\t\t\t}\n\t\t\tif (m == N) continue;\n\t\t\tbads.push_back(m);\n\t\t}\n\n\t\t//for (int v : bads) { cerr << \"bad \" << v << ' ' << W[v] << '\\n'; }\n\t\t//for (int v : cnds) { cerr << \"cnd \" << v << ' ' << W[v] << '\\n'; }\n\n\t\tfor (int v : bads) {\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a++;\n\t\t}\n\t\tfor (int v : cnds) {\n\t\t\tint cnt = 0;\n\t\t\tfor (auto a : bit.prefix(bounds[v][0])) cnt -= a;\n\t\t\tfor (auto a : bit.prefix(bounds[v][1])) cnt += a;\n\t\t\tif (!cnt) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a++;\n\t\t}\n\n\t\tfor (int v : bads) {\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a--;\n\t\t}\n\t\tfor (int v : cnds) {\n\t\t\tfor (auto& a : bit.suffix(bounds[v][0])) a--;\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "string suffix structures",
        "trees"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Exam.json",
    "editorial_link": "https://codeforces.com//blog/entry/88963",
    "editorial": "Fix a particular string s\n and find all edges outgoing from it. For each position i\n of the string let's find the value of lefti\n being the starting position of the longest substring which ends at the position i\n and is one of the strings sj\n. It's easy to see that such strings are the only ones where the outgoing edges from s\n can lead to. What remains is to find out which of them need to be excluded.\n\nA string needs to be excluded if there is an occurrence of it into s\n which is entirely covered by an occurrence of another substring. So let indi=min{leftj?j>i}\n. Then the strings to be excluded are precisely the strings among sj\n's which are suffixes of the substring [indi,i]\n for some i\n. This can be found via the Aho-Corasick structure. Since its suffix links represent a tree, one can find the vertices corresponding to the substrings [indi,i]\n and mark the way to the root in the suffix links tree. After this one can just check if the vertices of [lefti,i]\n are marked. To mark paths efficiently one can use segment trees or std::set. The overall complexity is O(nlogn)\n.",
    "hint": []
}