{
    "link": "https://codeforces.com//contest/1142/problem/A",
    "problemId": "322161",
    "problem_idx": "A",
    "shortId": "1142A",
    "contest_number": "1142",
    "problem_submissions": {
        "D": [
            52052698,
            52044696,
            52050424,
            52048816,
            52048203,
            52050242,
            52051279,
            52044155,
            52053707,
            52051199,
            52050499,
            52052944,
            52052302,
            52053535,
            52051490,
            52049907
        ],
        "E": [
            52047622,
            52057339,
            52048974,
            77087643,
            52277900,
            52277787,
            52050784
        ],
        "C": [
            52040660,
            52041212,
            52036496,
            52039629,
            52044262,
            52039609,
            52039348,
            52038404,
            52053341,
            52038044,
            52046718,
            52044023,
            52041812,
            52045982,
            52050483,
            52043132,
            52044496,
            52082020
        ],
        "B": [
            52036028,
            52037384,
            52034327,
            52035419,
            52038173,
            52037529,
            52042911,
            52035003,
            52038458,
            52035088,
            52037475,
            52037895,
            52038479,
            52041354,
            52037902,
            52038519,
            52055164,
            52037338
        ],
        "A": [
            52032007,
            52031522,
            52030850,
            52033382,
            52032139,
            52033225,
            52032107,
            52040214,
            52033698,
            52034088,
            52034385,
            52034757,
            52033255,
            52055588,
            52032995,
            52035070
        ]
    },
    "name": "A. The Beatles",
    "statement": "Recently a Golden Circle of Beetlovers was found in Byteland. It is a\r\ncircle route going through n\r\ncdot k cities. The cities are numerated from 1 to n\r\ncdot k, the distance between the neighboring cities is exactly 1\r\nkm.Sergey does not like beetles, he loves burgers. Fortunately for him,\r\nthere are n fast food restaurants on the circle, they are located in the\r\n1-st, the (k + 1)-st, the (2k + 1)-st, and so on, the ((n-1)k + 1)-st\r\ncities, i.e. the distance between the neighboring cities with fast food\r\nrestaurants is k km.Sergey began his journey at some city s and traveled\r\nalong the circle, making stops at cities each l km (l > 0), until he\r\nstopped in s once again. Sergey then forgot numbers s and l, but he\r\nremembers that the distance from the city s to the nearest fast food\r\nrestaurant was a km, and the distance from the city he stopped at after\r\ntraveling the first l km from s to the nearest fast food restaurant was\r\nb km. Sergey always traveled in the same direction along the circle, but\r\nwhen he calculated distances to the restaurants, he considered both\r\ndirections.Now Sergey is interested in two integers. The first integer x\r\nis the minimum number of stops (excluding the first) Sergey could have\r\ndone before returning to s. The second integer y is the maximum number\r\nof stops (excluding the first) Sergey could have done before returning\r\nto s.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tll n, k, a, b;\n\tcin >> n >> k >> a >> b;\n\tll ans1 = n * k + 1, ans2 = 0;\n\n\tfor (int f = 0; f < 2; f++)\n\t\tfor (int g = 0; g < 2; g++) {\n\t\t\tll x = a, y = b;\n\t\t\tif (f == 1) x = (k - a) % k;\n\t\t\tif (g == 1) y = (k - b) % k;\n\t\t\tx -= y;\n\t\t\tif (x < 0) x += k;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ty = x + i * k;\t\n\t\t\t\ty = gcd(y, n * k);\n\t\t\t\ty = (n * k) / y;\n\t\t\t\tans1 = min(ans1, y);\n\t\t\t\tans2 = max(ans2, y);\n\t\t\t}\n\t\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. The Beatles.json",
    "editorial_link": "https://codeforces.com//blog/entry/66301",
    "editorial": "Let\u00e2\u0080\u0099s assume that we know the length of the jump, and it is equal to .\r\nThen, in order to be back at the starting point, Sergey will need to\r\nmake exactly moves, where is the greatest common divider. Let , where\r\nand are non-negative integers. So, if we know and , than can only take\r\nvalues: , where means modulo . It is clear that only can be considered.\r\nThen we iterate over all the variants of the pair , and for each we find\r\nthe number of moves to the starting point. The minimum and maximum of\r\nthe resulting numbers will be the answer.\r\n"
}