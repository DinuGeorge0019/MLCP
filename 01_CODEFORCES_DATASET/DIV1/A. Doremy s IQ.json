{
    "link": "https://codeforces.com//contest/1707/problem/A",
    "problemId": "1465653",
    "problem_idx": "A",
    "shortId": "1707A",
    "contest_number": "1707",
    "problem_submissions": {
        "E": [
            164603668,
            164525375,
            164669454,
            185901683,
            185901618,
            185901333,
            164563417
        ],
        "D": [
            164511528,
            164496478,
            164493571,
            164495095,
            164501925,
            164506638,
            166069487,
            164497571,
            164507609,
            166120309,
            166120066,
            164509308,
            164956360,
            164507471,
            164489918,
            164511025,
            164904470,
            164514319,
            164514325,
            164497954,
            164519148,
            164515594,
            164518158,
            164516720,
            164511294
        ],
        "B": [
            164484745,
            164460975,
            164467918,
            164471533,
            164466867,
            164467580,
            164475668,
            164466783,
            166120253,
            166119986,
            164469792,
            164956306,
            164468045,
            164461021,
            164475290,
            164475116,
            164472236,
            164466401,
            164463086,
            164472164,
            164472283,
            164465112,
            164479683
        ],
        "C": [
            164479539,
            164485229,
            164482780,
            164482216,
            164481698,
            164485751,
            164487589,
            164482127,
            166120011,
            164486694,
            164956347,
            164484482,
            164472573,
            164487921,
            164484938,
            164484181,
            164511081,
            164483634,
            164483996,
            164493834,
            164499762,
            164491460
        ],
        "A": [
            164463335,
            164470733,
            164464634,
            164464640,
            164458756,
            164460631,
            164457208,
            164456721,
            166119954,
            164458999,
            164956326,
            164457788,
            164466493,
            164459761,
            164467279,
            164469592,
            164460485,
            164464829,
            164460707,
            164471416,
            164466775
        ],
        "F": [
            164529829,
            164530227,
            165361670,
            165361592,
            165360981,
            165360617,
            164565887,
            164565715
        ]
    },
    "name": "A. Doremy s IQ",
    "statement": "Doremy is asked to test n contests. Contest i can only be tested on day\r\ni. The difficulty of contest i is a_i. Initially, Doremy\u2019s IQ is q. On\r\nday i Doremy will choose whether to test contest i or not. She can only\r\ntest a contest if her current IQ is strictly greater than 0.If Doremy\r\nchooses to test contest i on day i, the following happens: if a_i>q,\r\nDoremy will feel she is not wise enough, so q decreases by 1; otherwise,\r\nnothing changes. If she chooses not to test a contest, nothing\r\nchanges.Doremy wants to test as many contests as possible. Please give\r\nDoremy a solution.\r\n",
    "solutions": [
        "#include <cstdio>\n\nint n,t,a[100001],q;\nbool vis[100001];\nint main(){\n\tscanf(\"%d\",&t);\n\tfor(int fd=1;fd<=t;++fd){\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tscanf(\"%d\",a+i);\n\t\t\tvis[i]=0;\n\t\t}\n\t\tfor(int i=n,t=0;i;--i){\n\t\t\tif(t<q&&a[i]>=t+1)++t,vis[i]=1;\n\t\t\telse if(a[i]<=t)vis[i]=1;\n\t\t}\n\t\tfor(int i=1;i<=n;++i)printf(\"%d\",vis[i]);putchar('\\n');\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Doremy s IQ.json",
    "editorial_link": "https://codeforces.com//blog/entry/104930",
    "editorial": "We call contests that will decrease Doremy\u00e2\u0080\u0099s IQ contests and the other\r\ncontests.In the best solution(testing the maximum number of contests),\r\nthere is always an index . Contest () is tested, if Contest is good;\r\nContest () is tested, no matter what kind of contest it is. How to prove\r\nthat this conclusion? For any choice, we can find the last contest that\r\nis not tested and the first bad contest that is tested. If , we can give\r\nup contest and choose to test contest , and the number of contests that\r\nis tested does not change. If , there is already an valid .When is\r\nsmallest, you can get the best solution. And we can find the smallest by\r\nbinary search.Time complexity .Consider everything in the reverse\r\norder.Assume that Doremy has IQ in the end. Consider whether a contest\r\nshould be tested in the reverse order. . Doremy should tested the\r\ncontest because there is no decrease in her IQ. and . If Doremy tests\r\nthe contest, her IQ will decrease by , so in the reverse order, her IQ\r\nincreases by ; otherwise she just skipped the contest and nothing\r\nhappened. Doremy can test at most contest with the property. But if\r\nDoremy gets more IQ, she can participate more previous good contests. So\r\nshe should test this contest. If and , Doremy cannot test the contest\r\nbecause her IQ is not enough. So you can determine whether every contest\r\nshould be tested.Time complexity .\r\n"
}