{
    "link": "https://codeforces.com//contest/1477/problem/C",
    "problemId": "879397",
    "problem_idx": "C",
    "shortId": "1477C",
    "contest_number": "1477",
    "problem_submissions": {
        "F": [
            106163553,
            106080431,
            106150219,
            105761318,
            105790194,
            105781844
        ],
        "E": [
            105766462,
            105760921,
            105747638,
            105773646,
            105773472,
            105764661,
            105770759,
            105771270,
            105749455,
            107250678,
            107250631,
            105808122
        ],
        "D": [
            105731973,
            105737956,
            105755294,
            105737357,
            105717044,
            105720581,
            105719208,
            105736745,
            105737576,
            105738580,
            105738914,
            105740692,
            105740131,
            105745290,
            105736926,
            105743296,
            105740891,
            105744844
        ],
        "C": [
            105691291,
            105711864,
            105715665,
            105695858,
            105694977,
            105690018,
            105684885,
            105689512,
            105691536,
            105703366,
            105691967,
            105704561,
            105705153,
            105695098,
            105696313,
            105696567,
            105685916,
            105688953,
            105706121,
            105699876
        ],
        "B": [
            105686611,
            105689935,
            105698256,
            105689750,
            105687613,
            105687015,
            105689324,
            105687283,
            105688577,
            105688486,
            105689038,
            105688335,
            105694661,
            105689327,
            105691535,
            105686246,
            105746534,
            105716194,
            105694969,
            105691857
        ],
        "A": [
            105676617,
            105680391,
            105688488,
            105677583,
            105677613,
            105677290,
            105676167,
            105677997,
            105678469,
            105681155,
            105678265,
            105679581,
            105683427,
            105682439,
            105681417,
            105677926,
            105677952,
            105676881,
            105698728,
            105687449
        ]
    },
    "name": "C. Nezzar and Nice Beatmap",
    "statement": "Nezzar loves the game osu!.osu! is played on beatmaps, which can be seen\r\nas an array consisting of points on a plane. A beatmap is called nice if\r\nfor any three consecutive points A,B,C listed in order, the angle\r\nbetween these three points, centered at B, is 90 degrees. Now Nezzar has\r\na beatmap of n points A_1,A_2,\r\nldots,A_n. Nezzar would like to reorder these n points so that the\r\nresulting beatmap is nice.Formally, you are required to find a\r\npermutation p_1,p_2,\r\nldots,p_n of integers from 1 to n, such that beatmap A_{p_1},A_{p_2},\r\nldots,A_{p_n} is nice. If it is impossible, you should determine it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nint dist(pi a,pi b){\n\treturn sq(a.a-b.a)+sq(a.b-b.b);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> xy(n);\n\trep(i,n)xy[i]=readpi();\n\tvi used(n);\n\tused[0]=1;\n\tvi ans{0};\n\trep(i,n-1){\n\t\tint cur=ans[i];\n\t\tint f=-1;\n\t\trep(nx,n)if(!used[nx]){\n\t\t\tif(f==-1||dist(xy[cur],xy[f])<dist(xy[cur],xy[nx]))\n\t\t\t\tf=nx;\n\t\t}\n\t\tused[f]=1;\n\t\tans.pb(f);\n\t}\n\tfor(auto&v:ans)v++;\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "geometry",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Nezzar and Nice Beatmap.json",
    "editorial_link": "https://codeforces.com//blog/entry/87294",
    "editorial": "There are two different approaches to solve this task.Pick an arbitrary\r\npoint, and in each iteration, select the furthest point from previously\r\nchosen point among all available points. Indeed, we can prove the\r\ncorrectness by contradiction.Notice that in any triangle (possibly\r\ndegenerate), there exists at most one obtuse angle or right angle in\r\nthis triangle. Therefore, we may build our permutation using modified\r\nversion of insertion sort (it suffices to substitute comparing\r\noperator).We believe that time complexity for the latter approach is\r\nbetter than . However, we fail to find a proof or counterexample for it.\r\nIt would be grateful if someone could figure it out and inform us about\r\nit!\r\n",
    "hint": []
}