{"link": "https://codeforces.com//contest/815/problem/E", "problemId": "110363", "problem_idx": "E", "shortId": "815E", "contest_number": "815", "problem_submissions": {"B": [27864858, 27859364, 27903526, 27860492, 27852460, 27855418, 27859767, 27852085, 27859930, 27859903, 27854384, 27858144, 27855716, 27857016, 27852895, 27853886], "E": [27862063, 27864392, 27859827, 27862681, 27864496, 27861206, 27867128, 27865357, 27880319, 27880161], "D": [27858987, 27856145, 27857852, 27860187, 27858848, 27861659, 27861479, 27862104, 27862042, 27861841, 27863258, 27862833, 27864478, 27862444, 27863816, 27862729], "C": [27854913, 27853891, 27854000, 27853599, 27853527, 27856985, 27855683, 27858430, 27852703, 27859114, 27854140, 27852346, 27858894, 27853926, 27859017, 27859597, 27856510, 27857717], "A": [27848955, 27860238, 27848568, 27848584, 27855106, 27849560, 27848196, 27849865, 27848239, 27854177, 27850649, 27854333, 27856456, 27849527, 27857857]}, "name": "E. Karen and Neighborhood", "statement": "It\u2019s been long after the events of the previous problems, and Karen has\r\nnow moved on from student life and is looking to relocate to a new\r\nneighborhood. The neighborhood consists of houses in a straight line,\r\nlabelled to from left to right, all an equal distance apart.Everyone in\r\nthis neighborhood loves peace and quiet. Because of this, whenever a new\r\nperson moves into the neighborhood, he or she always chooses the house\r\nwhose minimum distance to any occupied house is maximized. If there are\r\nmultiple houses with the maximum possible minimum distance, he or she\r\nchooses the leftmost one.Note that the first person to arrive always\r\nmoves into house .Karen is the -th person to enter this neighborhood. If\r\neveryone, including herself, follows this rule, which house will she\r\nmove into?\r\n", "solutions": ["//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\n\nmap < ll , vector < pair <ll,ll> > > mapa;\n\nvoid liczwek(ll n)\n{\n\tif (!n || mapa.count(n))\n\t\treturn;\n\tll s=(n+1)/2;\n\tliczwek(s-1);\n\tliczwek(n-s);\n\t\n\tvector < pair <ll,ll> > wek, pom;\n\tfor (auto i : mapa[s-1])\n\t\twek.push_back(i);\n\tfor (auto i : mapa[n-s])\n\t\twek.push_back(i);\n\twek.push_back({s-1, 1LL});\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\tfor (auto i : wek)\n\t{\n\t\tif (pom.empty() || pom.back().first!=i.first)\n\t\t\tpom.push_back({i.first, 0LL});\n\t\tpom.back().second+=i.second;\n\t}\n\t\n\tmapa[n]=pom;\n}\n\nll liczpos(ll n, ll k)\n{\n\tll s=(n+1)/2;\n\tif (k==1)\n\t\treturn s;\n\tliczwek(n);\n\tll jak=0;\n\tll kk=k-1;\n\tll juzl=0;\n\tll juzp=0;\n\t\n\tvector < pair < pair <ll,int> , ll > > wek;\n\tfor (auto i : mapa[s-1])\n\t\twek.push_back({{i.first, 1}, i.second});\n\tfor (auto i : mapa[n-s])\n\t\twek.push_back({{i.first, 0}, i.second});\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\t\n\t//debug() << \"cisne \" << n << \" \" << k;\n\t\n\tfor (auto i : wek)\n\t{\n\t\t//debug() << i;\n\t\tif (i.second<kk)\n\t\t{\n\t\t\tkk-=i.second;\n\t\t\tif (i.first.second)\n\t\t\t\tjuzl+=i.second;\n\t\t\telse\n\t\t\t\tjuzp+=i.second;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i.first.second)\n\t\t\treturn liczpos(s-1, k-juzp-1);\n\t\telse\n\t\t\treturn s+liczpos(n-s, k-juzl-1);\n\t}\n}\n\nint main()\n{\n\tll n, k;\n\tscanf(\"%lld%lld\", &n, &k);\n\tif (k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tif (k==2)\n\t{\n\t\tprintf(\"%lld\\n\", n);\n\t\treturn 0;\n\t}\n\tprintf(\"%lld\\n\", 1+liczpos(n-2, k-2));\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "implementation"], "dificulty": "2900", "interactive": false}