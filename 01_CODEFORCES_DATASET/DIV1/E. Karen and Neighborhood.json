{
    "link": "https://codeforces.com//contest/815/problem/E",
    "problemId": "110363",
    "problem_idx": "E",
    "shortId": "815E",
    "contest_number": "815",
    "problem_submissions": {
        "B": [
            27864858,
            27859364,
            27903526,
            27860492,
            27852460,
            27855418,
            27859767,
            27852085,
            27859930,
            27859903,
            27854384,
            27858144,
            27855716,
            27857016,
            27852895,
            27853886
        ],
        "E": [
            27862063,
            27864392,
            27859827,
            27862681,
            27864496,
            27861206,
            27867128,
            27865357,
            27880319,
            27880161
        ],
        "D": [
            27858987,
            27856145,
            27857852,
            27860187,
            27858848,
            27861659,
            27861479,
            27862104,
            27862042,
            27861841,
            27863258,
            27862833,
            27864478,
            27862444,
            27863816,
            27862729
        ],
        "C": [
            27854913,
            27853891,
            27854000,
            27853599,
            27853527,
            27856985,
            27855683,
            27858430,
            27852703,
            27859114,
            27854140,
            27852346,
            27858894,
            27853926,
            27859017,
            27859597,
            27856510,
            27857717
        ],
        "A": [
            27848955,
            27860238,
            27848568,
            27848584,
            27855106,
            27849560,
            27848196,
            27849865,
            27848239,
            27854177,
            27850649,
            27854333,
            27856456,
            27849527,
            27857857
        ]
    },
    "name": "E. Karen and Neighborhood",
    "statement": "It\u2019s been long after the events of the previous problems, and Karen has\r\nnow moved on from student life and is looking to relocate to a new\r\nneighborhood. The neighborhood consists of houses in a straight line,\r\nlabelled to from left to right, all an equal distance apart.Everyone in\r\nthis neighborhood loves peace and quiet. Because of this, whenever a new\r\nperson moves into the neighborhood, he or she always chooses the house\r\nwhose minimum distance to any occupied house is maximized. If there are\r\nmultiple houses with the maximum possible minimum distance, he or she\r\nchooses the leftmost one.Note that the first person to arrive always\r\nmoves into house .Karen is the -th person to enter this neighborhood. If\r\neveryone, including herself, follows this rule, which house will she\r\nmove into?\r\n",
    "solutions": [
        "//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\n\nmap < ll , vector < pair <ll,ll> > > mapa;\n\nvoid liczwek(ll n)\n{\n\tif (!n || mapa.count(n))\n\t\treturn;\n\tll s=(n+1)/2;\n\tliczwek(s-1);\n\tliczwek(n-s);\n\t\n\tvector < pair <ll,ll> > wek, pom;\n\tfor (auto i : mapa[s-1])\n\t\twek.push_back(i);\n\tfor (auto i : mapa[n-s])\n\t\twek.push_back(i);\n\twek.push_back({s-1, 1LL});\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\tfor (auto i : wek)\n\t{\n\t\tif (pom.empty() || pom.back().first!=i.first)\n\t\t\tpom.push_back({i.first, 0LL});\n\t\tpom.back().second+=i.second;\n\t}\n\t\n\tmapa[n]=pom;\n}\n\nll liczpos(ll n, ll k)\n{\n\tll s=(n+1)/2;\n\tif (k==1)\n\t\treturn s;\n\tliczwek(n);\n\tll jak=0;\n\tll kk=k-1;\n\tll juzl=0;\n\tll juzp=0;\n\t\n\tvector < pair < pair <ll,int> , ll > > wek;\n\tfor (auto i : mapa[s-1])\n\t\twek.push_back({{i.first, 1}, i.second});\n\tfor (auto i : mapa[n-s])\n\t\twek.push_back({{i.first, 0}, i.second});\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\t\n\t//debug() << \"cisne \" << n << \" \" << k;\n\t\n\tfor (auto i : wek)\n\t{\n\t\t//debug() << i;\n\t\tif (i.second<kk)\n\t\t{\n\t\t\tkk-=i.second;\n\t\t\tif (i.first.second)\n\t\t\t\tjuzl+=i.second;\n\t\t\telse\n\t\t\t\tjuzp+=i.second;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i.first.second)\n\t\t\treturn liczpos(s-1, k-juzp-1);\n\t\telse\n\t\t\treturn s+liczpos(n-s, k-juzl-1);\n\t}\n}\n\nint main()\n{\n\tll n, k;\n\tscanf(\"%lld%lld\", &n, &k);\n\tif (k==1)\n\t{\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tif (k==2)\n\t{\n\t\tprintf(\"%lld\\n\", n);\n\t\treturn 0;\n\t}\n\tprintf(\"%lld\\n\", 1+liczpos(n-2, k-2));\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Karen and Neighborhood.json",
    "editorial_link": "https://codeforces.com//blog/entry/52742",
    "editorial": "Surprisingly, it is possible to solve this problem without knowledge of\r\nany sophisticated algorithms or data structures; this problem can be\r\nsolved completely through observations, brutal case analysis and grunt\r\nwork, which we will try to summarize here.The first and most obvious\r\nobservation: the first person always goes to house , and the second\r\nperson always goes to house . Consider these two guys as special cases;\r\nnow, we\u00e2\u0080\u0099re solving the problem on a segment of length .Note how we\r\ndefine segments here; a segment of length is a row of unoccupied houses,\r\nwith the two houses just before and after both endpoints occupied.Notice\r\nthat, for any segment, if a person moves into any house in this segment\r\nit will be the middle one; if there are two middles, it will be the left\r\nof the two middles. So, if we have a length segment, the person will\r\nmove into the -nd house in the segment. If we have a length segment, the\r\nperson will move into the -rd house in the segment, and so on.When a\r\nperson moves into a house in a given segment of length , if , it will\r\nalso create segments; the left segment will be length and the right\r\nsegment will be length .Let\u00e2\u0080\u0099s write down the segments in a binary tree,\r\nwhere the -th layer contains all segments spawned by the -th layer, and\r\nthe first layer contains precisely the segment of length .For example,\r\nconsider . The binary tree will look like this: From this, we can make a\r\nnumber of observations.We can see that there are at most different\r\nsegment lengths in any layer. Additionally, these values are always and\r\n, where is the smaller one.Let the two lengths in a given layer be and\r\n(if there is only one, it\u00e2\u0080\u0099s just ). Now, consider the following: If is\r\nodd, the segments of length and will be processed in order from left to\r\nright. If is even, all segments of length will be processed first, from\r\nleft to right, then all segments of length will be processed, also from\r\nleft to right. This makes sense; the \"minimum distance\" is actually just\r\nthe smaller of the two children, and you can observe that in the above\r\nfirst case, the smaller of the two children is equal, while in the\r\nsecond case, the smaller of the two children of is smaller than the\r\nsmaller of the two children of .Additionally, all segments in any\r\nparticular layer are always processed before the segments in the next\r\nlayer (except in the case we will discuss the special cases later.) We\r\ncan therefore determine, rather straightforwardly, what layer the -th\r\nsegment is. Since all the layers above this layer are now irrelevant, we\r\ncan just subtract all the taken layers from . Now, the problem has been\r\nreduced to finding what house the -th guy in a fixed layer moves\r\ninto.How will we find this? Well, note that there is exactly one house\r\nseparating any two segments in a given layer. If we go to the -th\r\nsegment, the label of the house we actually went into is (number of\r\nhouses occupied on previous layers), plus the total length of segments\r\n(unoccupied houses before this one), plus (the middle house in the -th\r\nsegment).It is easy to determine and the number of length and length\r\nsegments for any particular layer. What\u00e2\u0080\u0099s harder to compute are two\r\ncrucial details: What\u00e2\u0080\u0099s the relative position of the -th processed\r\nsegment in this layer? How many layers have length before the segment at\r\nthis relative position? If we can answer these two questions\r\nefficiently, we are basically done with the core of the solution, and\r\njust have to handle special cases.Let\u00e2\u0080\u0099s answer the first question. If is\r\nodd, this is trivial; the -th processed segment is precisely that at\r\nposition .If is even, things get a lot trickier. Luckily, we can perform\r\nmore observations. Draw the tree with root segment , and observe the\r\nfourth row. Now, draw the trees with root segments .Observe how the\r\nfourth row changes from root segment to : Root segment is : Root segment\r\nis : Root segment is : Root segment is : Root segment is : Root segment\r\nis : Root segment is : Root segment is : Root segment is : In what order\r\nare the numbers increased? It\u00e2\u0080\u0099s not immediately obvious, but we can try\r\nto write down the binary representations of the (zero-indexed) positions\r\nin the order they are increased: : : : : : : : : Actually, this is just\r\nthe reversed binary numbers in reverse order! Remember that our goal is\r\nto find the relative position of the -th processed element. Without loss\r\nof generality, suppose that the -th processed element is of length (the\r\nanalysis when it is length is almost the same.)This is equivalent to\r\nasking for the -th smallest element among the first numbers in that list\r\n( is the number of segments in the given layer, which is easy to\r\ncompute).Let\u00e2\u0080\u0099s take root segment equal to , as in the illustration\r\nearlier. Let\u00e2\u0080\u0099s say we want the position of the -th occurrence of .\r\nThat\u00e2\u0080\u0099s equivalent to finding the -th smallest element in this list\r\n(obviously we never get to generate this list explicitly): : : : : :\r\nConsider these binary numbers digit by digit starting from the largest.\r\nNotice that, at any point, the number of ones is always equal to or one\r\nmore than the number of zeroes; above, there are ones and zeroes.We want\r\nthe -th smallest, and there are only zeroes, so we know it has to start\r\nwith . We throw out (again, not explicitly) all the numbers that start\r\nwith zero, and we are now left with finding the -nd smallest in this\r\nlist:Our number so far: : : : Now, there are ones and zero. We want the\r\n-nd smallest, and there is only zero, so we know the next digit is . We\r\nthrow out all the numbers that start with zero, and we are now left with\r\nfinding the -st smallest in this list:Our number so far: : : Now, there\r\nis one and zero. We want the -st smallest, and there is zero, which is\r\nenough. So, this is the next digit. The final number is , which means\r\nthat the position of the -th is at . ( if one-indexed).This process\r\nworks for any arbitrary numbers in , and now we are able to answer the\r\nfirst required question in just time.Now, we need to answer the second\r\nquestion. How many layers have length before the segment at this\r\nrelative position?Actually, this question can be solved using almost the\r\nexact same binary digit analysis! The problem is equivalent to asking\r\nfor how many numbers, among the first numbers in the earlier list, have\r\na position less than . We will omit the analysis here for brevity, but\r\nit uses virtually the same idea and also solves this question in .Now,\r\nwe have solved both questions, and have essentially finished the core of\r\nthe problem. But we\u00e2\u0080\u0099re not yet done! We still have to handle the corner\r\ncases.There are actually only two corner cases: and .When , note that\r\nevery segment of length is basically treated as two segments of length\r\n.When , segments of length are handled first, each creating segments of\r\nlength . Then, the segments of length and are treated like with ,\r\ndespite the segments of length technically being on the next layer.Both\r\nof these cases can be solved using the same binary digit analysis, with\r\nsome grunt-work formulas that can be a bit hard to get precisely\r\ncorrect. These cases can also be solved in .Overall, the runtime of the\r\nsolution is just .\r\n"
}