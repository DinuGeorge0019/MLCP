{
    "link": "https://codeforces.com//contest/679/problem/D",
    "problemId": "61897",
    "problem_idx": "D",
    "shortId": "679D",
    "contest_number": "679",
    "problem_submissions": {
        "D": [
            18322762,
            18323626,
            18322971,
            18323450,
            18324701,
            18327443,
            18345837,
            18345768,
            18345680,
            18345642,
            18327111,
            18328820,
            18327048,
            18328042,
            18328483,
            18329243,
            18329178,
            18324869,
            18324693
        ],
        "B": [
            18314677,
            18309080,
            18312175,
            18311888,
            18312358,
            18312942,
            18316455,
            18317342,
            18309354,
            18307663,
            18316385,
            18308970,
            18308226,
            18309465,
            18308416,
            18312030,
            18314147
        ],
        "C": [
            18310021,
            18317790,
            18318340,
            18317148,
            18319639,
            18318992,
            18320837,
            18322274,
            18315941,
            18322904,
            18316017,
            18318363,
            18318389,
            18317725,
            18315473,
            18314694
        ],
        "A": [
            18303717,
            18304196,
            18305388,
            18304702,
            18306194,
            18307513,
            18307982,
            18303929,
            18304410,
            18304102,
            18305596,
            18304174,
            18305099,
            18303722,
            18303574,
            18304076,
            18305438,
            18304649
        ],
        "E": [
            200103409,
            18853172,
            18325979,
            18447386,
            188767815
        ]
    },
    "name": "D. Bear and Chase",
    "statement": "Bearland has cities, numbered through . There are bidirectional roads.\r\nThe -th road connects two distinct cities and . No two roads connect the\r\nsame pair of cities. It’s possible to get from any city to any other\r\ncity (using one or more roads).The distance between cities and is\r\ndefined as the minimum number of roads used to travel between and .Limak\r\nis a grizzly bear. He is a criminal and your task is to catch him, or at\r\nleast to try to catch him. You have only two days (today and tomorrow)\r\nand after that Limak is going to hide forever.Your main weapon is BCD\r\n(Bear Criminal Detector). Where you are in some city, you can use BCD\r\nand it tells you the distance between you and a city where Limak\r\ncurrently is. Unfortunately, BCD can be used only once a day.You don’t\r\nknow much about Limak’s current location. You assume that he is in one\r\nof cities, chosen uniformly at random (each city with probability ). You\r\ndecided for the following plan: Choose one city and use BCD there. After\r\nusing BCD you can try to catch Limak (but maybe it isn’t a good idea).\r\nIn this case you choose one city and check it. You win if Limak is\r\nthere. Otherwise, Limak becomes more careful and you will never catch\r\nhim (you loose). Wait hours to use BCD again. You know that Limak will\r\nchange his location during that time. In detail, he will choose\r\nuniformly at random one of roads from his initial city, and he will use\r\nthe chosen road, going to some other city. Tomorrow, you will again\r\nchoose one city and use BCD there. Finally, you will try to catch Limak.\r\nYou will choose one city and check it. You will win if Limak is there,\r\nand loose otherwise. Each time when you choose one of cities, you can\r\nchoose any of cities. Let’s say it isn’t a problem for you to quickly\r\nget somewhere.What is the probability of finding Limak, if you behave\r\noptimally?\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint w[410][410], D[410][410], Deg[410], L[410];\nbool v[410];\ndouble Res, P[410], MM[410];\nint n, m;\nvoid Do(int a){\n    int i, j, k;\n    double S=0.0;\n    for(i=0;i<n;i++){\n        int cnt = 0, cnt2 = 0;\n        double Mx = 0.0, SS;\n        for(j=1;j<=n;j++){\n            P[j] = 0.0;\n            v[j]=false;\n        }\n        for(j=1;j<=n;j++){\n            if(D[a][j] == i){\n                cnt++;\n                double tp = 1.0/Deg[j]/n;\n                for(k=1;k<=n;k++){\n                    if(w[j][k]){\n                        P[k] += tp;\n                        v[k] = true;\n                    }\n                }\n            }\n        }\n        if(cnt){\n            Mx = max(Mx,1.0/n);\n        }\n        for(j=1;j<=n;j++){\n            if(v[j]){\n                L[++cnt2] = j;\n            }\n        }\n        for(j=1;j<=n;j++){\n            SS = 0.0;\n            for(k=1;k<=cnt2;k++){\n                MM[D[j][L[k]]]=max(MM[D[j][L[k]]],P[L[k]]);\n            }\n            for(k=1;k<=cnt2;k++){\n                SS += MM[D[j][L[k]]];\n                MM[D[j][L[k]]]=0.0;\n            }\n            Mx = max(Mx,SS);\n        }\n        S+=Mx;\n    }\n    Res = max(Res,S);\n}\nint main(){\n    int i, j, a, b, k;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            if(i!=j)D[i][j]=9999999;\n        }\n    }\n    for(i=0;i<m;i++){\n        scanf(\"%d%d\",&a,&b);\n        Deg[a]++,Deg[b]++;\n        D[a][b]=D[b][a]=1;\n        w[a][b]=w[b][a]=1;\n    }\n    for(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++)D[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n    for(i=1;i<=n;i++){\n        Do(i);\n    }\n    printf(\"%.11lf\\n\",Res);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "implementation",
        "math",
        "probabilities"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Bear and Chase.json",
    "editorial_link": "https://codeforces.com//blog/entry/45310",
    "editorial": "Check my code below, because it has a lot of comments. First, in or\r\nfaster find all distances between pairs of cities. Iterate over all the\r\nfirst city in which you use the BCD. Then, for iterate over all the\r\ndistance you get. Now, for all cities calculate the probability that\r\nLimak will be there in the second day (details in my code below). Also,\r\nin a vector interesting letâs store all cities that are at distance from\r\ncity . Then, iterate over all the second city in which you use the BCD.\r\nFor cities from interesting, we want to iterate over them and for each\r\ndistinct distance from to choose the biggest probability (because we\r\nwill make the best guess there is). Magic: the described approach has\r\nfour loops (one in the other) but itâs . Proof is very nice and I\r\nencourage you to try to get it yourself. Proof hereAfter fixing g1\r\ndivide cities by their distance from g1. Then, when we get distance d1\r\nin the first day, then in the second day all possible cities are at\r\ndistance d1-1, d1 and d1+1. So, we will consider each city at most three\r\ntimes.\r\n",
    "hint": []
}