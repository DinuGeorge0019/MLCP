{
    "link": "https://codeforces.com//contest/1286/problem/F",
    "problemId": "509645",
    "problem_idx": "F",
    "shortId": "1286F",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "F. Harry The Potter",
    "statement": "To defeat Lord Voldemort, Harry needs to destroy all horcruxes first.\r\nThe last horcrux is an array a of n integers, which also needs to be\r\ndestroyed. The array is considered destroyed if all its elements are\r\nzeroes. To destroy the array, Harry can perform two types of operations:\r\nchoose an index i (1\r\nle i\r\nle n), an integer x, and subtract x from a_i. choose two indices i and j\r\n(1\r\nle i, j\r\nle n; i\r\nne j), an integer x, and subtract x from a_i and x + 1 from a_j. Note\r\nthat x does not have to be positive.Harry is in a hurry, please help him\r\nto find the minimum number of operations required to destroy the array\r\nand exterminate Lord Voldemort.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\t// for a tree of N items, you use N-1 edges, so parity must be N-1 total\n\t// If you just subtract 1, then the parity must be 1\n\tint N; cin >> N;\n\tvector<ll> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == 0) {\n\t\t\tA.erase(A.begin() + i);\n\t\t\tN--, i--;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tassert(A[i]);\n\t}\n\n\tvector<ll> Asum(1<<N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int m = 0; m < (1<<i); m++) {\n\t\t\tAsum[m|(1<<i)] = Asum[m] + A[i];\n\t\t}\n\t}\n\n\tvector<bool> isTree(1<<N);\n\t{\n\t\tint L = int(N * 0.77);\n\t\tassert(0 <= L && L <= N);\n\n\t\t{\n\t\t\tvector<ll> sums;\n\t\t\tsums.reserve(1<<L);\n\t\t\tfor (int ml = 0; ml < (1 << L); ml++) {\n\t\t\t\tsums.clear();\n\t\t\t\tfor (int v = ml&(ml-1); v; --v &= ml) {\n\t\t\t\t\tassert(0 < v && v < ml);\n\t\t\t\t\tsums.push_back(Asum[ml] - 2 * Asum[v]);\n\t\t\t\t}\n\t\t\t\tsort(sums.begin(), sums.end());\n\t\t\t\tfor (int mr = 0; mr < (1<<N); mr += (1<<L)) {\n\t\t\t\t\tint n = __builtin_popcount(ml | mr);\n\t\t\t\t\tif (n <= 1) continue;\n\t\t\t\t\tif ((Asum[ml] ^ Asum[mr] ^ n ^ 1) & 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tbool isGood = false;\n\t\t\t\t\tfor (int v = mr; true; --v &= mr) {\n\t\t\t\t\t\tll val = Asum[mr] - 2 * Asum[v];\n\t\t\t\t\t\tif ((ml || v < mr) && v) {\n\t\t\t\t\t\t\tif (abs(val + Asum[ml]) <= n-1) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((ml || v) && v < mr) {\n\t\t\t\t\t\t\tif (abs(val - Asum[ml]) <= n-1) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tauto it = lower_bound(sums.begin(), sums.end(), -val);\n\t\t\t\t\t\tif (it != sums.end()) {\n\t\t\t\t\t\t\tif (*it + val <= n-1) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (it != sums.begin()) {\n\t\t\t\t\t\t\t--it;\n\t\t\t\t\t\t\tif (*it + val >= -(n-1)) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (isGood) {\n\t\t\t\t\t\tisTree[ml | mr] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tauto fft = [&](vector<uint32_t>& v) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int mb = 0; mb < (1 << N); mb += (2<<i)) {\n\t\t\t\tfor (int m = 0; m < (1 << i); m++) {\n\t\t\t\t\tfor (int c = 0; c <= N; c++) {\n\t\t\t\t\t\tv[(mb+(1<<i)+m)*(N+1)+c] += v[(mb+m)*(N+1)+c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tauto ifft = [&](vector<uint32_t>& v) -> bool {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int mb = 0; mb < (1 << N); mb += (2<<i)) {\n\t\t\t\tfor (int m = 0; m < (1 << i); m++) {\n\t\t\t\t\tfor (int c = 0; c <= N; c++) {\n\t\t\t\t\t\tv[(mb+(1<<i)+m)*(N+1)+c] -= v[(mb+m)*(N+1)+c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool has = false;\n\t\tfor (int m = 0; m < (1<<N); m++) {\n\t\t\thas += (v[m*(N+1) + __builtin_popcount(m)] = bool(v[m*(N+1) + __builtin_popcount(m)]));\n\t\t\tfor (int c = __builtin_popcount(m)+1; c <= N; c++) {\n\t\t\t\tv[m*(N+1)+c] = 0;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t};\n\tauto mul = [&](const vector<uint32_t>& a, const vector<uint32_t>& b, vector<uint32_t>& v) {\n\t\tfor (int m = 0; m < (1<<N); m++) {\n\t\t\tfor (int c = N; c >= 0; c--) {\n\t\t\t\tuint32_t val = 0;\n\t\t\t\tfor (int c1 = 0; c1 <= c; c1++) {\n\t\t\t\t\tval += a[m*(N+1)+c1] * b[m*(N+1)+c-c1];\n\t\t\t\t}\n\t\t\t\tv[m*(N+1)+c] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\tvector<vector<uint32_t>> p2fft;\n\tp2fft.emplace_back((1<<N) * (N+1));\n\tbool hasTree = false;\n\tfor (int m = 0; m < (1 << N); m++) {\n\t\tif (isTree[m]) {\n\t\t\thasTree = true;\n\t\t\tp2fft[0][m*(N+1) + __builtin_popcount(m)] = 1;\n\t\t}\n\t}\n\n\tif (!hasTree) {\n\t\tcout << N << '\\n';\n\t\texit(0);\n\t}\n\n\tint l = 0;\n\twhile (true) {\n\t\tfft(p2fft[l]);\n\t\tl++;\n\n\t\tif (2 * (1 << l) > N) {\n\t\t\t// no point in adding the next one, we'll just kill it\n\t\t\tbreak;\n\t\t}\n\n\t\tp2fft.emplace_back((1<<N) * (N+1));\n\t\tmul(p2fft[l-1], p2fft[l-1], p2fft[l]);\n\n\t\tif (!ifft(p2fft[l])) {\n\t\t\tp2fft.pop_back();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tassert(l == int(p2fft.size()));\n\n\tint ans = N;\n\tl--;\n\tans -= (1 << l);\n\tvector<uint32_t> curVec = p2fft[l];\n\tvector<uint32_t> nVec((1<<N)*(N+1));\n\twhile (l > 0) {\n\t\tl--;\n\n\t\tmul(curVec, p2fft[l], nVec);\n\n\t\tif (ifft(nVec)) {\n\t\t\tans -= (1 << l);\n\t\t\tswap(curVec, nVec);\n\t\t\tfft(curVec);\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "fft",
        "implementation",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Harry The Potter.json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "Assume that we have done queries of the second type. On the th query we\r\nsubtracted from and from . Let\u00e2\u0080\u0099s construct undirected graph on vertices\r\nwith edges . Assume we have a cycle in this graph, then, we can replace\r\nqueries along this cycle with single queries of the first type to each\r\nvertex. Therefore, in an optimal answer queries of the second type form\r\na forest. Let\u00e2\u0080\u0099s call subset if it size is and it can be destroyed with\r\noperations of the second type. So, the problem is equivalent to grouping\r\nsome of the elements of into maximal number of disjoint subsets.\r\nElements that do not belong to any set can be destroyed with operations\r\nof the first type.Let\u00e2\u0080\u0099s find out whether a subset is or not. Let\u00e2\u0080\u0099s\r\nforget about + 1 in a query(e.g. we subtract and ). Consider a sequence\r\nof queries , , that destroys and form a connected tree. Let\u00e2\u0080\u0099s select an\r\narbitrary vertex of this tree as a root. Then, it is easy to see that\r\nfor each vertex only its height modulo 2 is matter. Therefore, we can\r\nconsider only trees of the following structure:The elements with the\r\neven height contribute positive change to the root, the elements with\r\nthe odd height contribute negative change to the root. So, our problem\r\nis equivalent to finding the set such that and .Now we subtract and . It\r\nturns out that it changes the above condition to and .Such set can be\r\nfound with MITM in time (knapsack in over all subsets).So, now we know\r\nall subsets. Let if is a subset and otherwise. Let\u00e2\u0080\u0099s denote operation as\r\n. Suppose is a minimum integer such that (e.g. all values of the product\r\narray are zero). It is clear that is a minimal number of operations\r\nrequired to destroy the array. can be done in time and the minimal power\r\ncan be estimated in time. Also, this part can be done with dynamic\r\nprogramming on subsets in time which some participants managed to\r\nsqueeze.So, the total time complexity is .\r\n"
}