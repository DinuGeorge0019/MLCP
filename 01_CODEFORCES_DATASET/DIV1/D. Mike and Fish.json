{"link": "https://codeforces.com//contest/547/problem/D", "problemId": "28332", "problem_idx": "D", "shortId": "547D", "contest_number": "547", "problem_submissions": {"A": [11306176, 11281663, 11286152, 11283154, 11300410, 11282966, 11282839, 11284240, 11282987, 11283935, 11284453, 11283105, 11302976, 11296402, 11304989], "E": [11300374, 11295900, 11296096, 11332517, 11332504, 11301614, 11329764, 11329670, 11329557, 11302402, 11296504, 11303628, 11310167, 11310570, 11335792, 11334862, 11310094, 11298023, 11289647], "D": [11290397, 11311418, 11289189, 11307197, 11288244, 11306223, 11292199, 11318433, 11338617, 11294617, 11298075, 11296934, 11291997, 11293528, 11292331, 11330482], "C": [11288602, 11286288, 11282036, 11285135, 11284518, 11286983, 11288810, 11287248, 11292291, 11290371, 11293842, 11290787, 11289508, 11302378, 11289341, 11290547, 11300174], "B": [11284410, 11282963, 11283861, 11287519, 11281935, 11284503, 11284754, 11285157, 11286946, 11285798, 11286796, 11285456, 11285604, 11286200, 11285607, 11286328, 11292395]}, "name": "D. Mike and Fish", "statement": "As everyone knows, bears love fish. But Mike is a strange bear; He hates\r\nfish! The even more strange thing about him is he has an infinite number\r\nof blue and red fish. He has marked distinct points in the plane. -th\r\npoint is point . He wants to put exactly one fish in each of these\r\npoints such that the difference between the number of red fish and the\r\nblue fish on each horizontal or vertical line is at most 1.He can\u2019t find\r\na way to perform that! Please help him.\r\n", "solutions": ["#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint ans[800005];\n\nstruct Edge {\n    int v, way, no;\n    Edge(int _v = 0, int _way = 0, int _no = 0): v(_v), way(_way), no(_no) {}\n};\n\nstruct Element {\n    int v, deg;\n    Element(int _v = 0, int _deg = 0) : v(_v), deg(_deg) {}\n    bool operator<(const Element &cmp) const {\n        return deg > cmp.deg;\n    }\n};\n\nstd::priority_queue<Element> Q;\n\nint N, M, K;\n\nstd::vector<Edge> graph[400005];\nint now[400005];\nint d[400005];\nbool vst[400005];\n\nvoid DFS(int v, int from) {\n    //printf(\"now %d\\n\", v);\n    if (d[v] == 1 && from != -1) return;\n    for ( ; now[v] < graph[v].size(); ) {\n        Edge tmp = graph[v][now[v]];\n        ++now[v];\n        if (tmp.v == from || ans[tmp.no] != -1) continue;\n        //printf(\"%d -- %d\\n\", v, tmp.v);\n        DFS(tmp.v, v);\n        Q.push(Element(v, --d[v]));\n        Q.push(Element(tmp.v, --d[tmp.v]));\n        ans[tmp.no] = tmp.way;\n        return;\n    } \n    return;\n}\n\nint killCycle(int v, int from) {\n    //printf(\"kill %d\\n\", v);\n    if (vst[v]) return v;\n    vst[v] = true;\n    for (; now[v] < graph[v].size(); ) {\n        Edge tmp = graph[v][now[v]];\n        ++now[v];\n        if (tmp.no == from || ans[tmp.no] != -1) continue;\n        //printf(\"go %d %d\\n\", v, tmp.v);\n        int ret = killCycle(tmp.v, tmp.no);\n        if (ret != -1) {\n            //printf(\"%d = %d\\n\", v, tmp.v);\n            ans[tmp.no] = tmp.way;\n            d[v] -= 2;\n            if (ret != v) {\n                vst[v] = false;\n                return ret;\n            }\n        }\n    } \n    return -1;\n}\n\nint main() {\n    int T=1;\n    while (T--) {\n        N=400000;\n        scanf(\"%d\", &M);\n        for (int i = 0; i < N; ++i) {\n            graph[i].clear();\n            now[i] = 0;\n            vst[i] = false;\n        }\n        for (int i = 0; i < M; ++i) {\n            ans[i] = -1;\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            a--;b--;b+=200000;\n            graph[a].push_back(Edge(b, 1, i));\n            graph[b].push_back(Edge(a, 0, i));\n            ++d[a]; ++d[b];\n        }\n        //puts(\"kill cycle\");\n        for (int i = 0; i < N; ++i) {\n            //printf(\"orzzzzzzzzzzzzzzzzzzzzzzzzzzzzz: %d\\n\", i);\n            killCycle(i, -1);\n        }\n        //puts(\"DFS\");\n        for (int i = 0; i < N; ++i) {\n            Q.push(Element(i, d[i]));\n            now[i] = 0;\n        }\n        while (!Q.empty()) {\n            Element tmp = Q.top();\n            Q.pop();\n            if (tmp.deg != d[tmp.v]) continue;\n            if (tmp.deg == 1) {\n                DFS(tmp.v, -1);\n            }\n        }\n        for (int i = 0; i < M; ++i) \n            printf(\"%c\", ans[i]?'b':'r');\n        putchar('\\n');\n    }\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "graphs"], "dificulty": "2600", "interactive": false}