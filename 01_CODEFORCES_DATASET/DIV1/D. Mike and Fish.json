{
    "link": "https://codeforces.com//contest/547/problem/D",
    "problemId": "28332",
    "problem_idx": "D",
    "shortId": "547D",
    "contest_number": "547",
    "problem_submissions": {
        "A": [
            11306176,
            11281663,
            11286152,
            11283154,
            11300410,
            11282966,
            11282839,
            11284240,
            11282987,
            11283935,
            11284453,
            11283105,
            11302976,
            11296402,
            11304989
        ],
        "E": [
            11300374,
            11295900,
            11296096,
            11332517,
            11332504,
            11301614,
            11329764,
            11329670,
            11329557,
            11302402,
            11296504,
            11303628,
            11310167,
            11310570,
            11335792,
            11334862,
            11310094,
            11298023,
            11289647
        ],
        "D": [
            11290397,
            11311418,
            11289189,
            11307197,
            11288244,
            11306223,
            11292199,
            11318433,
            11338617,
            11294617,
            11298075,
            11296934,
            11291997,
            11293528,
            11292331,
            11330482
        ],
        "C": [
            11288602,
            11286288,
            11282036,
            11285135,
            11284518,
            11286983,
            11288810,
            11287248,
            11292291,
            11290371,
            11293842,
            11290787,
            11289508,
            11302378,
            11289341,
            11290547,
            11300174
        ],
        "B": [
            11284410,
            11282963,
            11283861,
            11287519,
            11281935,
            11284503,
            11284754,
            11285157,
            11286946,
            11285798,
            11286796,
            11285456,
            11285604,
            11286200,
            11285607,
            11286328,
            11292395
        ]
    },
    "name": "D. Mike and Fish",
    "statement": "As everyone knows, bears love fish. But Mike is a strange bear; He hates\r\nfish! The even more strange thing about him is he has an infinite number\r\nof blue and red fish. He has marked distinct points in the plane. -th\r\npoint is point . He wants to put exactly one fish in each of these\r\npoints such that the difference between the number of red fish and the\r\nblue fish on each horizontal or vertical line is at most 1.He can\u2019t find\r\na way to perform that! Please help him.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint ans[800005];\n\nstruct Edge {\n    int v, way, no;\n    Edge(int _v = 0, int _way = 0, int _no = 0): v(_v), way(_way), no(_no) {}\n};\n\nstruct Element {\n    int v, deg;\n    Element(int _v = 0, int _deg = 0) : v(_v), deg(_deg) {}\n    bool operator<(const Element &cmp) const {\n        return deg > cmp.deg;\n    }\n};\n\nstd::priority_queue<Element> Q;\n\nint N, M, K;\n\nstd::vector<Edge> graph[400005];\nint now[400005];\nint d[400005];\nbool vst[400005];\n\nvoid DFS(int v, int from) {\n    //printf(\"now %d\\n\", v);\n    if (d[v] == 1 && from != -1) return;\n    for ( ; now[v] < graph[v].size(); ) {\n        Edge tmp = graph[v][now[v]];\n        ++now[v];\n        if (tmp.v == from || ans[tmp.no] != -1) continue;\n        //printf(\"%d -- %d\\n\", v, tmp.v);\n        DFS(tmp.v, v);\n        Q.push(Element(v, --d[v]));\n        Q.push(Element(tmp.v, --d[tmp.v]));\n        ans[tmp.no] = tmp.way;\n        return;\n    } \n    return;\n}\n\nint killCycle(int v, int from) {\n    //printf(\"kill %d\\n\", v);\n    if (vst[v]) return v;\n    vst[v] = true;\n    for (; now[v] < graph[v].size(); ) {\n        Edge tmp = graph[v][now[v]];\n        ++now[v];\n        if (tmp.no == from || ans[tmp.no] != -1) continue;\n        //printf(\"go %d %d\\n\", v, tmp.v);\n        int ret = killCycle(tmp.v, tmp.no);\n        if (ret != -1) {\n            //printf(\"%d = %d\\n\", v, tmp.v);\n            ans[tmp.no] = tmp.way;\n            d[v] -= 2;\n            if (ret != v) {\n                vst[v] = false;\n                return ret;\n            }\n        }\n    } \n    return -1;\n}\n\nint main() {\n    int T=1;\n    while (T--) {\n        N=400000;\n        scanf(\"%d\", &M);\n        for (int i = 0; i < N; ++i) {\n            graph[i].clear();\n            now[i] = 0;\n            vst[i] = false;\n        }\n        for (int i = 0; i < M; ++i) {\n            ans[i] = -1;\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            a--;b--;b+=200000;\n            graph[a].push_back(Edge(b, 1, i));\n            graph[b].push_back(Edge(a, 0, i));\n            ++d[a]; ++d[b];\n        }\n        //puts(\"kill cycle\");\n        for (int i = 0; i < N; ++i) {\n            //printf(\"orzzzzzzzzzzzzzzzzzzzzzzzzzzzzz: %d\\n\", i);\n            killCycle(i, -1);\n        }\n        //puts(\"DFS\");\n        for (int i = 0; i < N; ++i) {\n            Q.push(Element(i, d[i]));\n            now[i] = 0;\n        }\n        while (!Q.empty()) {\n            Element tmp = Q.top();\n            Q.pop();\n            if (tmp.deg != d[tmp.v]) continue;\n            if (tmp.deg == 1) {\n                DFS(tmp.v, -1);\n            }\n        }\n        for (int i = 0; i < M; ++i) \n            printf(\"%c\", ans[i]?'b':'r');\n        putchar('\\n');\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Mike and Fish.json",
    "editorial_link": "https://codeforces.com/blog/entry/18126",
    "editorial": "Consider a bipartite graph. In each part (we call them first and second\r\npart) there are vertices numbered from to . For each point add an edge\r\nbetween vertex number from the first part and vertex number from the\r\nsecond part. In this problem, we want to color edges with two colors so\r\nthat the difference between the number of blue edges connected to a\r\nvertex and the number of red edges connected to it be at most 1. Doing\r\nsuch thing is always possible. We prove this and solve the problem at\r\nthe same time with induction on the number of edges : If all vertices\r\nhave even degree, then for each component there is an Eulerian circuit,\r\nfind it and color the edges alternatively_ with blue and red. Because\r\ngraph is bipartite, then our circuit is an even walk and so, the\r\ndifference between the number of blue and red edges connected to a\r\nvertex will be 0. Otherwise, if a vertex like has odd degree, consider a\r\nvertex like that there is and edge between and . Delete this edge and\r\nsolve the problem for the rest of the edges (with the induction\r\ndefinition) and then add this edge and if the number of red edges\r\nconnected to is more than the blue ones, then color this edge with blue,\r\notherwise with red. You can handle this add/delete edge requests and\r\nfind odd vertices with a simple set. So, Time complexity: C++ Code by\r\nPrinceOfPersia C++ Code by Haghani Java Code by Zlobober\r\n"
}