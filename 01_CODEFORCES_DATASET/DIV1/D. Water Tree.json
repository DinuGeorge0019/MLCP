{
    "link": "https://codeforces.com//contest/343/problem/D",
    "problemId": "3470",
    "problem_idx": "D",
    "shortId": "343D",
    "contest_number": "343",
    "problem_submissions": {
        "E": [
            31188435,
            31188116,
            31188087,
            31187398,
            31187368,
            31187305,
            31187274,
            31186747,
            31186631,
            31186607,
            31177883,
            31177811,
            31177677,
            31177529,
            31177512,
            31177472,
            31174332,
            31174236,
            31174170,
            31174117,
            31174081,
            31173996,
            31173900,
            31173784,
            31168439,
            31168047,
            31166077,
            31166040,
            31165937,
            31165886,
            31165811,
            31165582,
            4470358,
            4472396,
            4467502,
            4481337,
            4469008,
            4469285,
            4479327,
            4479319
        ],
        "D": [
            4464141,
            4463979,
            4464572,
            4466164,
            4464136,
            4464708,
            4465038,
            4464000,
            4465958,
            4466077,
            4464624,
            4465035,
            4466293,
            4465384,
            4466009,
            4465578,
            4464050,
            4465103
        ],
        "C": [
            4460935,
            4462263,
            4462661,
            4463142,
            4461571,
            4460298,
            4462624,
            4461379,
            4461808,
            4462541,
            4462074,
            4461269,
            4462489,
            4463445,
            4463917,
            4463308,
            4465676,
            4463306
        ],
        "B": [
            4459735,
            4460433,
            4460596,
            4461468,
            4460532,
            4461066,
            4460953,
            4459496,
            4459676,
            4461679,
            4460850,
            4460112,
            4461095,
            4461548,
            4461352,
            4461258,
            4460882,
            4461288
        ],
        "A": [
            4458959,
            4458766,
            4460268,
            4460108,
            4459407,
            4461767,
            4460061,
            4464549,
            4459033,
            4459762,
            4460186,
            4459277,
            4459980,
            4460247,
            4461189,
            4460304,
            4459784,
            4460498
        ]
    },
    "name": "D. Water Tree",
    "statement": "Mad scientist Mike has constructed a rooted tree, which consists of\r\nvertices. Each vertex is a reservoir which can be either empty or filled\r\nwith water.The vertices of the tree are numbered from 1 to with the root\r\nat vertex 1. For each vertex, the reservoirs of its children are located\r\nbelow the reservoir of this vertex, and the vertex is connected with\r\neach of the children by a pipe through which water can flow\r\ndownwards.Mike wants to do the following operations with the tree: Fill\r\nvertex with water. Then and all its children are filled with water.\r\nEmpty vertex . Then and all its ancestors are emptied. Determine whether\r\nvertex is filled with water at the moment. Initially all vertices of the\r\ntree are empty.Mike has already compiled a full list of operations that\r\nhe wants to perform in order. Before experimenting with the tree Mike\r\ndecided to run the list through a simulation. Help Mike determine what\r\nresults will he get after performing all the operations.\r\n",
    "solutions": [
        "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint pz[N], pv[N], fin[N];\nint s[N], val[N];\nint kw, w[N];\nint ss[2 * N], ff[2 * N], pred[2 * N], last[N];\n\nvoid dfs(int v, int pr) {\n  w[++kw] = v;\n  pz[v] = kw;\n  int j = last[v];\n  while (j > 0) {\n    if (ff[j] != pr) {\n      pv[ff[j]] = v;\n      dfs(ff[j], v);\n    }\n    j = pred[j];\n  }\n  fin[v] = kw;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int m = n - 1;\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d %d\", ss + i, ff + i);\n    ss[i + m] = ff[i];\n    ff[i + m] = ss[i];\n  }\n  for (int i = 1; i <= n; i++) last[i] = 0;\n  for (int i = 1; i <= m + m; i++) {\n    pred[i] = last[ss[i]];\n    last[ss[i]] = i;\n  }\n  kw = 0;\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) s[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i]++;\n    int j = (i | (i - 1)) + 1;\n    if (j <= n) s[j] += s[i];\n    val[i] = 1;\n  }\n  int tt;\n  scanf(\"%d\", &tt);\n  while (tt--) {\n    int com, v;\n    scanf(\"%d %d\", &com, &v);\n    if (com == 1) {\n      int sum = 0;\n      int x = pz[v] - 1;\n      while (x > 0) {\n        sum += s[x];\n        x &= x - 1;\n      }\n      int cur = 0;\n      x = fin[v];\n      while (x > 0) {\n        cur += s[x];\n        x &= x - 1;\n      }\n      if (cur == sum) continue;\n      int last = pz[v] - 1;\n      while (cur > sum) {\n        int ll = last + 1, rr = fin[v];\n        while (ll < rr) {\n          int mid = (ll + rr) >> 1;\n          x = mid;\n          int q = 0;\n          while (x > 0) {\n            q += s[x];\n            x &= x - 1;\n          }\n          if (q > sum) rr = mid;\n          else ll = mid + 1;\n        }\n        x = ll;\n        val[x] = 0;\n        while (x <= n) {\n          s[x]--;\n          x = (x | (x - 1)) + 1;\n        }\n        last = ll;\n        cur--;\n      }\n      if (v != 1) {\n        int x = pz[pv[v]];\n        if (val[x] == 0) {\n          val[x] = 1;\n          while (x <= n) {\n            s[x]++;\n            x = (x | (x - 1)) + 1;\n          }\n        }\n      }\n    } else\n    if (com == 2) {\n      if (val[pz[v]] == 0) {\n        int x = pz[v];\n        val[x] = 1;\n        while (x <= n) {\n          s[x]++;\n          x = (x | (x - 1)) + 1;\n        }\n      }\n    } else {\n      int sum = 0;\n      int x = fin[v];\n      while (x > 0) {\n        sum += s[x];\n        x &= x - 1;\n      }\n      x = pz[v] - 1;\n      while (x > 0) {\n        sum -= s[x];\n        x &= x - 1;\n      }\n      if (sum > 0) printf(\"0\\n\");\n      else printf(\"1\\n\");\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Water Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/8860",
    "editorial": "Let\u00e2\u0080\u0099s learn how to color a whole subtree. For that enumerate all\r\nvertices in post-order DFS. Then each subtree covers a single continious\r\nvertex number segment. For each vertex we store the bounds of such\r\nsegment for a subtree with a root in this vertex. Then to color a\r\nsubtree means to color a segment in a segment tree. Then create a\r\nsegment tree that has a following property: if a vertex was emptied, and\r\nis still empty, then this vertex is colored in the segment tree. In the\r\nbeginning \"empty\" all the vertices. That is, color all the vertices in\r\nthe segment tree. With this tree we can efficiently process the queries:\r\nFill a vertex . Clean the interval for the subtree of . If before that\r\nsome vertex of a subtree was empty, color the parent of . Empty a vertex\r\n. Color the vertex in the segment tree. Reply whether a vertex is\r\nfilled. If in the segment tree at least one vertex is colored, then\r\nthere is such a descendant of that is empty now, so the vertex is not\r\nfilled. Shtrix noted that essentially the same solution can be\r\nimplemented with only a single set. Solution complexity: . Problem\r\nauthor: gen. Bonus: Some participants could see the similarities with a\r\nproblem Ball Machine from BOI 2013, but the solutions to the both\r\nproblems are quite different.\r\n"
}