{
    "link": "https://codeforces.com//contest/1063/problem/A",
    "problemId": "236985",
    "problem_idx": "A",
    "shortId": "1063A",
    "contest_number": "1063",
    "problem_submissions": {
        "F": [
            44321779,
            44310989,
            44539942,
            44524512,
            44473039,
            44472562,
            50480317,
            51150998,
            44317621,
            44317615,
            44312825,
            44373124
        ],
        "D": [
            44311197,
            44305997,
            44303323,
            44313702,
            44361765,
            44361136,
            44376357,
            44376258,
            44307498,
            44337552,
            44311559,
            44305058,
            44311516,
            44304459,
            44311498,
            44312697,
            44315110
        ],
        "E": [
            44305503,
            44313651,
            44315069,
            44307031,
            44313364,
            44308262,
            44337210,
            44313717,
            44317640,
            44314472,
            44311650
        ],
        "C": [
            44298733,
            44296257,
            44305349,
            44298667,
            44298705,
            44299697,
            44299069,
            44300205,
            44299465,
            44299657,
            44301626,
            44302301,
            44304486,
            44306960,
            44302436,
            44309287,
            44301972,
            44304513,
            44301966
        ],
        "A": [
            44295781,
            44291759,
            44291627,
            44296582,
            44291453,
            44291198,
            44292770,
            44291128,
            44296111,
            44296432,
            44292644,
            44293693,
            44292723,
            44296227,
            44292099,
            44305135,
            44297417,
            44292247,
            44291472
        ],
        "B": [
            44295123,
            44298986,
            44296043,
            44295205,
            44297251,
            44302092,
            44296710,
            44297936,
            44295873,
            44297588,
            44298080,
            44299136,
            44294684,
            44297166,
            44295722,
            44296834,
            44296659,
            44296927
        ]
    },
    "name": "A. Oh Those Palindromes",
    "statement": "A non-empty string is called , if it reads the same from the left to the\r\nright and from the right to the left. For example, \"\", \"\", and \"\" are\r\npalindromes, while \"\" and \"\" are not.A string is called a of another\r\nstring, if it can be obtained from that string by dropping some\r\n(possibly zero) number of characters from the beginning and from the end\r\nof it. For example, \"\", \"\", and \"\" are substrings of the string \"\",\r\nwhile \"\" and \"\" are not.Letâ€™s define a of the string as the number of\r\nits substrings that are palindromes. For example, the palindromic count\r\nof the string \"\" is 6 because all its substrings are palindromes, and\r\nthe palindromic count of the string \"\" is 3 because only its substrings\r\nof length 1 are palindromes.You are given a string s. You can\r\narbitrarily rearrange its characters. You goal is to obtain a string\r\nwith the maximum possible value of palindromic count.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N;\n  string s;\n  cin >> N >> s;\n\n  sort(ALL(s));\n  cout << s << \"\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Oh Those Palindromes.json",
    "editorial_link": "https://codeforces.com/blog/entry/62455",
    "editorial": "One possible solution is just to sort the string.Why so?Note that each\r\npalindrome have equal character at their ends. Suppose this character is\r\nwith number of occurences. Then there are at most palindromes with this\r\ncharacter.So we have a clear upper bound on answer. It is easy to see,\r\nthat the sorted string fulfills that bound and hence it is the optimal\r\nanswer.\r\n",
    "hint": []
}