{"link": "https://codeforces.com//contest/930/problem/E", "problemId": "162262", "problem_idx": "E", "shortId": "930E", "contest_number": "930", "problem_submissions": {"E": [35937874, 35940246, 35942003, 35941857, 35942922, 35943711, 35940428, 35939130, 35941409, 35945119, 35945455, 35938266, 35942264, 35942725], "D": [35934631, 35937311, 35938039, 35939179, 35937578, 35934166, 35942235, 35945157, 35944906, 35941913, 35941573, 35937960, 35938844, 35940488, 35939332, 35939670], "C": [35931048, 35931464, 35931854, 35931257, 35932262, 35938659, 35933325, 35930949, 35933516, 35933919, 35936875, 35931415, 35932526, 35933702, 35934204, 35934502, 35932728, 35934206, 35934527], "B": [35928663, 35929193, 35929409, 35928730, 35929849, 35928584, 35929521, 35928824, 35930726, 35930401, 35933251, 35929420, 35929927, 35930360, 35932014, 35931682, 35930124, 35931864, 35931720], "A": [35926805, 35926962, 35927064, 35926854, 35927078, 35929726, 35930445, 35926856, 35927823, 35927432, 35928757, 35926924, 35926883, 35927329, 35927301, 35927988, 35927191, 35927741, 35928171]}, "name": "E. Coins Exhibition", "statement": "Arkady and Kirill visited an exhibition of rare coins. The coins were\r\nlocated in a row and enumerated from left to right from to , each coin\r\neither was laid with its obverse (front) side up, or with its reverse\r\n(back) side up.Arkady and Kirill made some photos of the coins, each\r\nphoto contained a segment of neighboring coins. Akrady is interested in\r\nobverses, so on each photo made by him there is at least one coin with\r\nobverse side up. On the contrary, Kirill is interested in reverses, so\r\non each photo made by him there is at least one coin with its reverse\r\nside up.The photos are lost now, but Arkady and Kirill still remember\r\nthe bounds of the segments of coins each photo contained. Given this\r\ninformation, compute the remainder of division by of the number of ways\r\nto choose the upper side of each coin in such a way, that on each\r\nArkady\u2019s photo there is at least one coin with obverse side up, and on\r\neach Kirill\u2019s photo there is at least one coin with reverse side up.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 600001;\n\nconst ll MOD = static_cast<ll>(1e9 + 7);\n\nll pw(ll a, ll b) {\n    if (!b) {\n        return 1;\n    }\n\n    ll v = pw(a, b / 2);\n    v = (v * v) % MOD;\n\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\n\nvoid add(ll& x, ll y) {\n    x = (x + y) % MOD;\n}\n\nvoid sub(ll& x, ll y) {\n    x -= y;\n    x %= MOD;\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\nvector<ll> xs;\n\n\nint la[MAXN];\nint ra[MAXN];\nint lb[MAXN];\nint rb[MAXN];\n\nll f[2][MAXN];\nll tot[2];\nint req[2][MAXN];\nint p[2];\n\nint gt(int x) {\n    return lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n}\n\nvoid ad(int x, int y, ll z) {\n    add(tot[x], z);\n    add(f[x][y], z);\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int k, n, m;\n    cin >> k >> n >> m;\n    xs = { 0, k };\n    for (int i = 0; i < n; ++i) {\n        cin >> la[i] >> ra[i];\n        xs.push_back(--la[i]);\n        xs.push_back(ra[i]);\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        cin >> lb[i] >> rb[i];\n        xs.push_back(--lb[i]);\n        xs.push_back(rb[i]);\n    }\n\n    xs.push_back(-1);\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    int c = xs.size() - 1;\n\n    ad(0, 0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        int& x = req[0][gt(ra[i])];\n        x = max(x, gt(la[i]));\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int& x = req[1][gt(rb[i])];\n        x = max(x, gt(lb[i]));\n    }\n\n    for (int i = 1; i < c; ++i) {\n        ll good = pw(2, xs[i + 1] - xs[i]);\n        ll t[2] = { tot[0], tot[1] };\n\n        good -= 2;\n        if (good < 0) {\n            good += MOD;\n        }\n\n        good = (good * (t[0] + t[1])) % MOD;\n        ad(0, i, good);\n\n        for (int j = 0; j < 2; ++j) {\n            int rj = j ^ 1;\n            ad(j, i - 1, t[rj]);\n\n            while (p[j] < req[rj][i + 1]) {\n                sub(tot[j], f[j][p[j]++]);\n            }\n        }\n    }\n\n    cout << (tot[0] + tot[1]) % MOD;\n}"], "input": "", "output": "", "tags": ["data structures", "dp", "math"], "dificulty": "2900", "interactive": false}