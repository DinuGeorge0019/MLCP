{
    "link": "https://codeforces.com//contest/930/problem/E",
    "problemId": "162262",
    "problem_idx": "E",
    "shortId": "930E",
    "contest_number": "930",
    "problem_submissions": {
        "E": [
            35937874,
            35940246,
            35942003,
            35941857,
            35942922,
            35943711,
            35940428,
            35939130,
            35941409,
            35945119,
            35945455,
            35938266,
            35942264,
            35942725
        ],
        "D": [
            35934631,
            35937311,
            35938039,
            35939179,
            35937578,
            35934166,
            35942235,
            35945157,
            35944906,
            35941913,
            35941573,
            35937960,
            35938844,
            35940488,
            35939332,
            35939670
        ],
        "C": [
            35931048,
            35931464,
            35931854,
            35931257,
            35932262,
            35938659,
            35933325,
            35930949,
            35933516,
            35933919,
            35936875,
            35931415,
            35932526,
            35933702,
            35934204,
            35934502,
            35932728,
            35934206,
            35934527
        ],
        "B": [
            35928663,
            35929193,
            35929409,
            35928730,
            35929849,
            35928584,
            35929521,
            35928824,
            35930726,
            35930401,
            35933251,
            35929420,
            35929927,
            35930360,
            35932014,
            35931682,
            35930124,
            35931864,
            35931720
        ],
        "A": [
            35926805,
            35926962,
            35927064,
            35926854,
            35927078,
            35929726,
            35930445,
            35926856,
            35927823,
            35927432,
            35928757,
            35926924,
            35926883,
            35927329,
            35927301,
            35927988,
            35927191,
            35927741,
            35928171
        ]
    },
    "name": "E. Coins Exhibition",
    "statement": "Arkady and Kirill visited an exhibition of rare coins. The coins were\r\nlocated in a row and enumerated from left to right from to , each coin\r\neither was laid with its obverse (front) side up, or with its reverse\r\n(back) side up.Arkady and Kirill made some photos of the coins, each\r\nphoto contained a segment of neighboring coins. Akrady is interested in\r\nobverses, so on each photo made by him there is at least one coin with\r\nobverse side up. On the contrary, Kirill is interested in reverses, so\r\non each photo made by him there is at least one coin with its reverse\r\nside up.The photos are lost now, but Arkady and Kirill still remember\r\nthe bounds of the segments of coins each photo contained. Given this\r\ninformation, compute the remainder of division by of the number of ways\r\nto choose the upper side of each coin in such a way, that on each\r\nArkady\u2019s photo there is at least one coin with obverse side up, and on\r\neach Kirill\u2019s photo there is at least one coin with reverse side up.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 600001;\n\nconst ll MOD = static_cast<ll>(1e9 + 7);\n\nll pw(ll a, ll b) {\n    if (!b) {\n        return 1;\n    }\n\n    ll v = pw(a, b / 2);\n    v = (v * v) % MOD;\n\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\n\nvoid add(ll& x, ll y) {\n    x = (x + y) % MOD;\n}\n\nvoid sub(ll& x, ll y) {\n    x -= y;\n    x %= MOD;\n    if (x < 0) {\n        x += MOD;\n    }\n}\n\nvector<ll> xs;\n\n\nint la[MAXN];\nint ra[MAXN];\nint lb[MAXN];\nint rb[MAXN];\n\nll f[2][MAXN];\nll tot[2];\nint req[2][MAXN];\nint p[2];\n\nint gt(int x) {\n    return lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n}\n\nvoid ad(int x, int y, ll z) {\n    add(tot[x], z);\n    add(f[x][y], z);\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int k, n, m;\n    cin >> k >> n >> m;\n    xs = { 0, k };\n    for (int i = 0; i < n; ++i) {\n        cin >> la[i] >> ra[i];\n        xs.push_back(--la[i]);\n        xs.push_back(ra[i]);\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        cin >> lb[i] >> rb[i];\n        xs.push_back(--lb[i]);\n        xs.push_back(rb[i]);\n    }\n\n    xs.push_back(-1);\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    int c = xs.size() - 1;\n\n    ad(0, 0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        int& x = req[0][gt(ra[i])];\n        x = max(x, gt(la[i]));\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int& x = req[1][gt(rb[i])];\n        x = max(x, gt(lb[i]));\n    }\n\n    for (int i = 1; i < c; ++i) {\n        ll good = pw(2, xs[i + 1] - xs[i]);\n        ll t[2] = { tot[0], tot[1] };\n\n        good -= 2;\n        if (good < 0) {\n            good += MOD;\n        }\n\n        good = (good * (t[0] + t[1])) % MOD;\n        ad(0, i, good);\n\n        for (int j = 0; j < 2; ++j) {\n            int rj = j ^ 1;\n            ad(j, i - 1, t[rj]);\n\n            while (p[j] < req[rj][i + 1]) {\n                sub(tot[j], f[j][p[j]++]);\n            }\n        }\n    }\n\n    cout << (tot[0] + tot[1]) % MOD;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "math"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Coins Exhibition.json",
    "editorial_link": "https://codeforces.com//blog/entry/58177",
    "editorial": "Denote obverse-up coin as 0 and reverse-up coin as 1. Then we are to compute the number of binary strings of length k such that n of the given segments have atleast one 0 and other m ones \u0097 atleast one 1.\n\nLet dp[i][l0][l1] be the number of binary strings of length i such that the last zero is at position l0, the last one is at l1 and all restrictions are satisfied for all segments with right borders not exceeding i. The transitions then are straighforward: check all possible values for position i?+?1 and relax l0 and l1 accordingly. Let the new values be l0' and l1'. Now consider all segments ending at i?+?1. If there are such [l,?r] among them demanding zero while l?>?l0' or demanding one while l?>?l1', this continuation doesn't suit. Otherwise add dp[i][l0][l1] to dp[i?+?1][l0'][l1']. This works in O(k3?+?n?+?m) if we precompute all segments ending in r for all r. Anyway, this is too slow.\n\nThe first thing to enhance is to notice that either l0?=?i or l1?=?i. Then we have to deal with dp0[i][l1] (implying l0?=?i) and dp1[i][l0] (implying l1?=?i). The transitions are the same, and the complexity becomes O(k2?+?n?+?m). Still too slow :(\n\nThe further improvement is that all positions with no segments endings can be treated similarly since the transitions are equal. At the same time it doesn't matter whether the last zero is at l0 or l0?+?1 if there are no segments beginning at l0?+?1. Same applies to l1. Let's compress coordinates then, i.e. find all xi such that xi and xi?+?1 are covered by different sets of segments.\n\nNow it's time to slightly change the dp definition: let dp0[i][l1]be the number of binary strings of length xi such that the last digit is 0, the last 1 is somewhere between xl1?-?1?+?1 and xl1 and all restrictions are satisfied for all segments with endings not exceeding xi. dp1[i][l0] is denoted in a similar fashion.\n\nConsider the possible transitions. Without loss of generality we'll account for transitions from dp0[i][l1] to some dp?[i?+?1][?]. The goal is to somehow append a binary string of length (xi?+?1?-?xi) to the existing one. There are three major cases:\n\nAll additional digits are 0, then we jump to dp0[i?+?1][l1] with coefficient 1 (there's only one way to construct a string of zeros).\nAll additional digits are 1, then we jump to dp1[i?+?1][i] with coefficient 1. Note that the last zero remains at xi.\nThere are some 0 and some 1. Then the jump is to dp0[i?+?1][i?+?1] and dp1[i?+?1][i?+?1] with coefficients equal to 2xi?+?1?-?xi?-?1?-?1 since only the last digit if fixed. This is possible iff xi?+?1?-?xi?>?1.\nMoreover, we have to consider all segments ending at xi?+?1 and discard those not satisfying the restrictions. This works in  (extra logarithm is for fast powers).\n\nThere's only one step left to a full solution. Note that in the dp above you can separate digit-adding from constraint-accounting transitions and treat them one after another. That means that you can first apply all transitions from  to  disregarding segments endings at xi?+?1 and then null dp0[i?+?1][l1], where l1?<?l, where [l,?xi] is an arbitrary segment applying 1-constraint and null dp1[i?+?1][l0], where l0?<?l, where [l,?xi] is an arbitrary segment applying 0-constraint. Futhermore note that transitions with coeffitients not equal to 1 are applied only to  and  while values of  where j?<?i are either  or 0. That means we can store two arrays dp0[l1] and dp1[l0], implying i being equal to the current value. Now when jumping from i to i?+?1 we have to relax  and , and null some prefix of dp0 and some prefix of dp1 depending on beginnins of segments ending at xi. The new values of  and  are easy to obtain via sum of elements in this arrays and xi?+?1?-?xi. With a properly chosen data structure the complexity becomes  with O(n?+?m) memory. This is now enough to get ac.\n\nThere's an alternative approach: you can just keep track of the first non-nulled element since it can only increase. This also helps maintain the current sum of values without using specific data structures. This works in  (including sort)."
}