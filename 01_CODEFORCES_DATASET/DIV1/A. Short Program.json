{
    "link": "https://codeforces.com//contest/878/problem/A",
    "problemId": "130657",
    "problem_idx": "A",
    "shortId": "878A",
    "contest_number": "878",
    "problem_submissions": {
        "E": [
            31763989,
            31766344,
            32084568
        ],
        "D": [
            31756901,
            31762689,
            31754129,
            31756452,
            31772004,
            31761487,
            31761339,
            31761633,
            31767096,
            31789313,
            31769411,
            31767240,
            31764633,
            31929002,
            31911110,
            31754793
        ],
        "C": [
            31752735,
            31757112,
            31751479,
            31747354,
            31752922,
            31752815,
            31757860,
            31761336,
            31759682,
            31761695,
            31751021,
            31760902,
            31758288,
            31764916,
            31764825,
            31755837
        ],
        "B": [
            31745139,
            31746290,
            31753553,
            31777437,
            31754012,
            31756298,
            31752132,
            31754987,
            31751846,
            31753351,
            31760932,
            31770059,
            31750086,
            31755233,
            31753552,
            31762144
        ],
        "A": [
            31741277,
            31741357,
            31741777,
            31741474,
            31742096,
            31741956,
            31741731,
            31741469,
            31743565,
            31743908,
            31741393,
            31741983,
            31741174,
            31745067,
            31741499,
            31745657,
            31745328,
            31741742,
            31742765
        ]
    },
    "name": "A. Short Program",
    "statement": "Petya learned a new programming language CALPAS. A program in this\r\nlanguage always takes one non-negative integer and returns one\r\nnon-negative integer as well.In the language, there are only three\r\ncommands: apply a bitwise operation AND, OR or XOR with a given constant\r\nto the current integer. A program can contain an arbitrary sequence of\r\nthese operations with arbitrary constants from to . When the program is\r\nrun, all operations are applied (in the given order) to the argument and\r\nin the end the result integer is returned.Petya wrote a program in this\r\nlanguage, but it turned out to be too long. Write a program in CALPAS\r\nthat does the same thing as the Petya\u2019s program, and consists of no more\r\nthan lines. Your program should return the same integer as Petya\u2019s\r\nprogram for all arguments from to .\r\n",
    "solutions": [
        "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n\nint v[10];\nint main() {\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\n\tfor (i = 0; i < 10; i++) v[i] = 2;\n\twhile (N--) {\n\t\tchar c[2];\n\t\tint t;\n\t\tscanf(\"%s %d\", c, &t);\n\n\t\tif (c[0] == '|') {\n\t\t\tfor (i = 0; i < 10; i++) if (t & (1 << i)) v[i] = 1;\n\t\t}\n\t\tif (c[0] == '&') {\n\t\t\tfor (i = 0; i < 10; i++) if (!(t & (1 << i))) v[i] = 0;\n\t\t}\n\t\tif (c[0] == '^') for (i = 0; i < 10; i++) if(t & (1<<i)) v[i] ^= 1;\n\t}\n\n\tint v1 = 0, v2 = 0, v3 = 0;\n\tfor (i = 0; i < 10; i++) {\n\t\tif (v[i] == 0) v1 |= (1 << i);\n\t\tif (v[i] == 1) v2 |= (1 << i);\n\t\tif (v[i] == 3) v3 |= (1 << i);\n\t}\n\tprintf(\"3\\n\");\n\tprintf(\"| %d\\n\", v2);\n\tprintf(\"& %d\\n\", 1023 ^ v1);\n\tprintf(\"^ %d\\n\", v3);\n\treturn 0;\n}\n\t"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Short Program.json",
    "editorial_link": "https://codeforces.com//blog/entry/55435",
    "editorial": "Let\u00e2\u0080\u0099s see what happens with a single bit. All operations work with each\r\nbit separately, so each bit of output depends only on the corresponding\r\nbit of input.There are only four options: bit doesn\u00e2\u0080\u0099t change, bit always\r\nchanges, bit is set to 0, bit is set to 1. For each bit it\u00e2\u0080\u0099s easy to\r\nfind which of these options happens to it.Now let\u00e2\u0080\u0099s write a program of\r\nthree lines: Use XOR with a number that has ones in bits that must be\r\nreversed. Use OR with a number that has ones in bits which must be set\r\nto 1. Use AND with a number that has zeroes in bits that must be set to\r\n0. It\u00e2\u0080\u0099s easy to see that this program is equivalent to Petya\u00e2\u0080\u0099s\r\nprogram.Depending on the implementation, it may works in or .BONUS:\r\nsolve a problem using at most two commands.\r\n"
}