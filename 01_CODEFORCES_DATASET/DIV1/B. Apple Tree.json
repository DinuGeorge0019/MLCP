{
    "link": "https://codeforces.com//contest/348/problem/B",
    "problemId": "3552",
    "problem_idx": "B",
    "shortId": "348B",
    "contest_number": "348",
    "problem_submissions": {
        "C": [
            4588342,
            4590159,
            4593135,
            4588912,
            4585853,
            4589632,
            4585524,
            4586580,
            4585883,
            4581239,
            4588365,
            4618235
        ],
        "B": [
            4580097,
            4582356,
            4579942,
            4582963,
            4589468,
            4587659,
            4577354,
            4585315,
            4580326,
            4582274,
            4579794,
            4606814,
            4580277,
            4584510,
            4582530,
            4581233,
            4588037,
            4582260,
            4589608
        ],
        "A": [
            4576873,
            4574641,
            4574230,
            4576431,
            4576985,
            4585961,
            4574860,
            4576105,
            4577005,
            4576961,
            4574398,
            4574642,
            4577358,
            4575644,
            4582569,
            4583556,
            4575731,
            4575526
        ],
        "D": [
            4576020,
            4578123,
            4580839,
            4584931,
            4582728,
            4580253,
            4592562,
            4587185,
            4588035,
            4587652,
            4587737,
            4590796,
            4582015
        ],
        "E": [
            4583454,
            4855776,
            4616595,
            4820950,
            4618329
        ]
    },
    "name": "B. Apple Tree",
    "statement": "You are given a rooted tree with vertices. In each leaf vertex there\u2019s a\r\nsingle integer the number of apples in this vertex. The of a subtree is\r\nthe sum of all numbers in this subtree leaves. For instance, the weight\r\nof a subtree that corresponds to some leaf is the number written in the\r\nleaf.A tree is if for every vertex of the tree all its subtrees,\r\ncorresponding to the children of vertex , are of equal weight. Count the\r\nminimum number of apples that you need to remove from the tree\r\n(specifically, from some of its leaves) in order to make the tree\r\nbalanced. Notice that you can always achieve the goal by just removing\r\nall apples.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nbool overflow = false;\n\nint N;\nint a[100010];\nvector <int> graph[100010];\nll cap[100010],mul[100010];\n\nll prod(ll x, ll y){\n    if(x == 0 || y == 0) return 0;\n    if(x > INF / y){\n        overflow = true;\n        return INF;\n    }\n    return x * y;\n}\n\nll gcd(ll x, ll y){\n    return x ? gcd(y%x, x) : y;\n}\n\nll lcm(ll x, ll y){\n    if(x == 0 || y == 0) return x + y;\n    ll g = gcd(x, y);\n    return prod(x / g, y);\n}\n\nvoid dfs(int p, int x){\n    int i,deg=0;\n    \n    REP(i,graph[x].size()){\n        int y = graph[x][i];\n        if(y != p){\n            deg++;\n            dfs(x, y);\n        }\n    }\n    \n    if(deg == 0){\n        cap[x] = a[x];\n        mul[x] = 1;\n        return;\n    }\n    \n    ll tmp = 0;\n    REP(i,graph[x].size()){\n        int y = graph[x][i];\n        if(y != p) tmp = lcm(tmp, mul[y]);\n    }\n    \n    ll tmp2 = INF;\n    REP(i,graph[x].size()){\n        int y = graph[x][i];\n        if(y != p) tmp2 = min(tmp2, cap[y] / tmp * tmp);\n    }\n    \n    cap[x] = prod(tmp2, deg);\n    mul[x] = prod(tmp, deg);\n}\n\nint main(void){\n    int i;\n    \n    cin >> N;\n    REP(i,N) scanf(\"%d\", &a[i]);\n    REP(i,N-1){\n        int x,y;\n        scanf(\"%d%d\", &x, &y); x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    \n    dfs(-1, 0);\n    \n    ll ans = 0;\n    REP(i,N) ans += a[i];\n    if(!overflow) ans -= cap[0];\n    cout << ans << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "number theory",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Apple Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/9031",
    "editorial": "In the problem you need to find out minimal number of apples that you\r\nneed to remove in order to make tree balanced. Notice, that if we know\r\nthe value in the root then we know values in all other vertices. The\r\nvalue in the leaf is equal to the value in the root divided to the\r\nproduct of the powers of all vertices on the path between root and leaf.\r\nFor every vertex let\u00e2\u0080\u0099s calculate minimal number in that vertex (not\r\nzero) in order to make tree balanced. For leaves , for all other\r\nvertices is equal to , where sons of the vertex . Let\u00e2\u0080\u0099s calculate sum in\r\nthe subtree of the vertex . All that can be done using one depth first\r\nsearch from the root of the tree. Using second depth first search one\r\ncan calculate for every vertex maximal number that we can write in it\r\nand satisfty all conditions. More precisely, given vertex and of its\r\nsons . Then if and minimal number, that we can write to the sons of\r\nvertex , then it\u00e2\u0080\u0099s worth to write numbers to the sons of vertex .\r\nRemains we add to the answer.\r\n"
}