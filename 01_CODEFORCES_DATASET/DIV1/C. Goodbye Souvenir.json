{"link": "https://codeforces.com//contest/848/problem/C", "problemId": "120619", "problem_idx": "C", "shortId": "848C", "contest_number": "848", "problem_submissions": {"D": [29984461, 29984526, 29990531, 29990452, 29983235, 29986841, 30011180, 30054712, 29986436, 29991292, 29988130, 30025667], "C": [29981953, 29979998, 29991414, 29985145, 29986831, 29981161, 30023429, 30739183, 30739016, 29983074, 29985177, 29986148, 29992066, 29984922, 29985048, 30004311, 29986150, 29985850, 29985839, 29985353, 29988848], "B": [29977726, 29987077, 29983009, 29978119, 29977288, 29977302, 29978411, 29979022, 29978648, 29977708, 29980992, 29981154, 29978110, 29977941, 29980264, 29977663, 29981248, 29982355, 29978027], "A": [29975110, 29976090, 29975270, 29974910, 29974992, 29974976, 29975582, 29975367, 29976038, 29974917, 29976913, 29976388, 29974989, 29978589, 29977088, 29975038, 29977707, 29977980, 29974970], "E": [31234259]}, "name": "C. Goodbye Souvenir", "statement": "A string of beads is left as the message of leaving. The beads are\r\nnumbered from to from left to right, each having a shape numbered by\r\nintegers between and inclusive. Some beads may have the same shapes.The\r\nof a shape in a certain subsegment of beads, is defined to be the\r\ndifference between the last position and the first position that shape\r\nappears in the segment. The of a subsegment is the sum of over all\r\nshapes that occur in it.From time to time, shapes of beads change as\r\nwell as the . Sometimes, the past secreted in subsegments are being\r\nrecalled, and you are to find the for each of them.\r\n", "solutions": ["#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nclass Node {\npublic:\n\tvector <int> Vx;\n\tvector <ll> bit;\n\tint it_max;\n\tNode() {\n\t\tVx.clear();\n\t\tbit.clear();\n\t}\n\tvoid update(int p, int v) {\n\t\tp = lower_bound(all(Vx), p) - Vx.begin() + 1;\n\t\tfor (; p <= it_max; p += p & (-p)) bit[p] += v;\n\t}\n\tll getsum(int x) {\n\t\tx = lower_bound(all(Vx), x + 1) - Vx.begin();\n\n\t\tll rv = 0;\n\t\tfor (; x; x -= x & (-x)) rv += bit[x];\n\t\treturn rv;\n\t}\n};\nNode indt[300000];\nint val[300000];\nvoid update(int p, int v) {\n\tif (v == INF) v = 0;\n\tif (val[p] != 0) for (int i = IT_MAX + p - 1; i; i /= 2) indt[i].update(val[p], p - val[p]);\n\tif (v != 0) for (int i = IT_MAX + p - 1; i; i /= 2) indt[i].update(v, v - p);\n\tval[p] = v;\n}\nll getsum(int p1, int p2) {\n\tint op1 = p1, op2 = p2;\n\tp1 += IT_MAX - 1, p2 += IT_MAX - 1;\n\tll rv = 0;\n\tfor (; p1 <= p2; p1 /= 2, p2 /= 2) {\n\t\tif (p1 % 2 == 1) rv += indt[p1++].getsum(op2);\n\t\tif (p2 % 2 == 0) rv += indt[p2--].getsum(op2);\n\t}\n\treturn rv;\n}\n\nint OA[100050];\nint A[100050];\nset <int> Sp[100050];\nint getnxt(int p) {\n\tauto it = Sp[A[p]].lower_bound(p + 1);\n\tif (it == Sp[A[p]].end()) return INF;\n\telse return *it;\n}\nint Qu[100050][3];\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tOA[i] = A[i];\n\t}\n\tfor (i = 1; i <= M; i++) scanf(\"%d %d %d\", &Qu[i][0], &Qu[i][1], &Qu[i][2]);\n\n\tfor (i = 1; i <= N; i++) Sp[A[i]].insert(i);\n\tfor (i = 1; i <= N; i++) {\n\t\tint p = getnxt(i);\n\t\tif (p == INF) continue;\n\t\tfor (j = IT_MAX + i - 1; j >= 1; j /= 2) indt[j].Vx.push_back(p);\n\t}\n\tfor (i = 1; i <= M; i++) {\n\t\tif (Qu[i][0] == 2) continue;\n\t\tint p = Qu[i][1], x = Qu[i][2];\n\t\t\n\t\tauto it = Sp[A[p]].lower_bound(p);\n\t\tif (it != Sp[A[p]].begin()) {\n\t\t\tauto it2 = it;\n\t\t\tit2++;\n\t\t\tit--;\n\t\t\tif (it2 != Sp[A[p]].end()) {\n\t\t\t\tint y = *it, z = *it2;\n\t\t\t\tfor (j = IT_MAX + y - 1; j >= 1; j /= 2) indt[j].Vx.push_back(z);\n\t\t\t}\n\t\t}\n\t\tSp[A[p]].erase(p);\n\t\tA[p] = x;\n\t\tSp[A[p]].insert(p);\n\n\t\tit = Sp[A[p]].lower_bound(p);\n\t\tif (it != Sp[A[p]].begin()) {\n\t\t\tit--;\n\t\t\tint y = *it;\n\t\t\tfor (j = IT_MAX + y - 1; j >= 1; j /= 2) indt[j].Vx.push_back(p);\n\t\t}\n\t\tint p2 = getnxt(p);\n\t\tif (p2 == INF) continue;\n\t\tfor (j = IT_MAX + p - 1; j >= 1; j /= 2) indt[j].Vx.push_back(p2);\n\t}\n\tfor (i = 1; i < IT_MAX * 2; i++) {\n\t\tsort(all(indt[i].Vx));\n\t\tindt[i].Vx.erase(unique(all(indt[i].Vx)), indt[i].Vx.end());\n\t\t\n\t\tint x;\n\t\tfor (x = 2; x < indt[i].Vx.size(); x *= 2);\n\t\tindt[i].it_max = x;\n\t\tindt[i].bit.resize(x + 1);\n\t}\n\n\tfor (i = 1; i <= N; i++) A[i] = OA[i];\n\tfor (i = 1; i <= N; i++) Sp[i].clear();\n\tfor (i = 1; i <= N; i++) Sp[A[i]].insert(i);\n\n\tfor (i = 1; i <= N; i++) {\n\t\tint p = getnxt(i);\n\t\tif (p != INF) update(i, p);\n\t}\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1 = Qu[i][0], t2 = Qu[i][1], t3 = Qu[i][2];\n\t\tif (t1 == 1) {\n\t\t\tint p = t2, x = t3;\n\n\t\t\tauto it = Sp[A[p]].lower_bound(p);\n\t\t\tif (it != Sp[A[p]].begin()) {\n\t\t\t\tint v = INF;\n\t\t\t\tauto it2 = it;\n\t\t\t\tit2++;\n\t\t\t\tit--;\n\t\t\t\tif (it2 != Sp[A[p]].end()) v = *it2;\n\t\t\t\tupdate(*it, v);\n\t\t\t}\n\t\t\tSp[A[p]].erase(p);\n\t\t\tA[p] = x;\n\t\t\tSp[A[p]].insert(p);\n\n\t\t\tit = Sp[A[p]].lower_bound(p);\n\t\t\tif (it != Sp[A[p]].begin()) {\n\t\t\t\tit--;\n\t\t\t\tupdate(*it, p);\n\t\t\t}\n\t\t\tupdate(p, getnxt(p));\n\t\t}\n\t\telse printf(\"%lld\\n\", getsum(t2, t3));\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer"], "dificulty": "2600", "interactive": false}