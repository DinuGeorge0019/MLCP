{
    "link": "https://codeforces.com//contest/277/problem/C",
    "problemId": "2669",
    "problem_idx": "C",
    "shortId": "277C",
    "contest_number": "277",
    "problem_submissions": {
        "E": [
            16290898,
            3212642,
            3214277,
            3216560,
            3217192,
            3212882,
            3213203,
            3212293,
            3216557,
            3218831,
            3213358,
            3688854,
            3214438,
            3216817,
            3212334,
            3216978,
            3215195,
            3212023,
            3214481
        ],
        "C": [
            3217751,
            3214405,
            3212237,
            3213774,
            3214065,
            3216032,
            3215933,
            3219588,
            3213776,
            3213602,
            3234441,
            3220825,
            3214706,
            3214937,
            3218190
        ],
        "D": [
            3215251,
            3217272,
            3218795,
            3236907,
            3258757
        ],
        "A": [
            3211100,
            3209085,
            3208310,
            3208691,
            3208408,
            3209073,
            3209691,
            3209304,
            3209119,
            3208608,
            3209266,
            3209939,
            3210030,
            3208575,
            3209624,
            3209909,
            3208646,
            3209846
        ],
        "B": [
            3210150,
            3226761,
            3211703,
            3216606,
            3211138,
            3211051,
            3213290,
            3212043,
            3215513,
            3212912,
            3218799,
            3212960,
            3216246
        ]
    },
    "name": "C. Game",
    "statement": "Two players play the following game. Initially, the players have a knife\r\nand a rectangular sheet of paper, divided into equal square grid cells\r\nof unit size. The players make moves in turn, the player who can\u2019t make\r\na move loses. In one move, a player can take the knife and cut the paper\r\nalong any segment of the grid line (not necessarily from border to\r\nborder). The part of the paper, that touches the knife at least once, is\r\nconsidered cut. There is one limit not to turn the game into an infinite\r\ncycle: each move has to cut the paper, that is the knife has to touch\r\nthe part of the paper that is not cut before.Obviously, the game ends\r\nwhen the entire sheet is cut into blocks. During the game, the pieces of\r\nthe sheet are not allowed to move. It is also prohibited to cut along\r\nthe border. The coordinates of the ends of each cut must be integers.You\r\nare given an piece of paper, somebody has already made cuts there. Your\r\ntask is to determine who will win if the players start to play on this\r\nsheet. You can consider that both players play optimally well. If the\r\nfirst player wins, you also need to find the winning first move.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nmap <int, vector <pair <int, int> > > mx,my;\nmap <int, int> mp;\n\nvector <pair <int, int> > event; // coord, diff\nvector <pair <int, int> > vx,vy;\n\nvoid func(int type, int id, int X, vector <pair <int, int> > v){\n    int i;\n    \n    event.clear();\n    event.push_back(make_pair(0, 1));\n    event.push_back(make_pair(X, -1));\n    REP(i,v.size()){\n        event.push_back(make_pair(v[i].first, -1));\n        event.push_back(make_pair(v[i].second, 1));\n    }\n    \n    int total = 0;\n    int cur = 0;\n    int sz = event.size();\n    \n    sort(event.begin(),event.end());\n    REP(i,sz-1){\n        cur += event[i].second;\n        if(cur > 0) total += event[i+1].first - event[i].first;\n    }\n    \n    if(type == 0){\n        vx.push_back(make_pair(id, total));\n    } else {\n        vy.push_back(make_pair(id, total));\n    }\n    \n    mp[X]--;\n    mp[total]++;\n}\n\nint cut_x(int x, int target){\n    int i;\n    \n    vector <pair <int, int> > v = mx[x];\n    \n    event.clear();\n    event.push_back(make_pair(0, 1));\n    event.push_back(make_pair(1000000000, -1));\n    REP(i,v.size()){\n        event.push_back(make_pair(v[i].first, -1));\n        event.push_back(make_pair(v[i].second, 1));\n    }\n    \n    int total = 0;\n    int cur = 0;\n    int sz = event.size();\n    \n    sort(event.begin(),event.end());\n    REP(i,sz-1){\n        cur += event[i].second;\n        if(cur > 0){\n            int d = event[i+1].first - event[i].first;\n            if(d >= target){\n                return event[i].first + target;\n            } else {\n                target -= d;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint cut_y(int y, int target){\n    int i;\n    \n    vector <pair <int, int> > v = my[y];\n    \n    event.clear();\n    event.push_back(make_pair(0, 1));\n    event.push_back(make_pair(1000000000, -1));\n    REP(i,v.size()){\n        event.push_back(make_pair(v[i].first, -1));\n        event.push_back(make_pair(v[i].second, 1));\n    }\n    \n    int total = 0;\n    int cur = 0;\n    int sz = event.size();\n    \n    sort(event.begin(),event.end());\n    REP(i,sz-1){\n        cur += event[i].second;\n        if(cur > 0){\n            int d = event[i+1].first - event[i].first;\n            if(d >= target){\n                return event[i].first + target;\n            } else {\n                target -= d;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint freex(int X){\n    int i;\n    for(i=1;i<X;i++){\n        if(i > 100010) break;\n        if(mx.find(i) == mx.end()) return i;\n    }\n    return -1;\n}\n\nint freey(int Y){\n    int i;\n    for(i=1;i<Y;i++){\n        if(i > 100010) break;\n        if(my.find(i) == my.end()) return i;\n    }\n    return -1;\n}\n\nint main(void){\n    int X,Y,N,x1,x2,y1,y2,i;\n    \n    cin >> X >> Y >> N;\n    REP(i,N){\n        scanf(\"%d%d%d%d\", &x1,&y1,&x2,&y2);\n        if(x1 == x2){\n            if(y1 > y2) swap(y1,y2);\n            mx[x1].push_back(make_pair(y1, y2));\n        } else {\n            if(x1 > x2) swap(x1,x2);\n            my[y1].push_back(make_pair(x1, x2));\n        }\n    }\n    \n    mp[X] += Y - 1;\n    mp[Y] += X - 1;\n    \n    snuke(mx,itr) func(0, (itr->first), Y, (itr->second));\n    snuke(my,itr) func(1, (itr->first), X, (itr->second));\n    \n    int nim = 0;\n    snuke(mp,itr) if((itr->second) % 2 == 1) nim ^= (itr->first);\n    \n    if(nim == 0){\n        cout << \"SECOND\" << endl;\n        return 0;\n    }\n    \n    cout << \"FIRST\" << endl;\n    \n    int tmp = freex(X);\n    if(tmp != -1 && (Y ^ nim) < Y){\n        cout << tmp << ' ' << 0 << ' ' << tmp << ' ' << Y - (Y ^ nim) << endl;\n        return 0;\n    }\n    \n    tmp = freey(Y);\n    if(tmp != -1 && (X ^ nim) < X){\n        cout << 0 << ' ' << tmp << ' ' << X - (X ^ nim) << ' ' << tmp << endl;\n        return 0;\n    }\n    \n    REP(i,vx.size()){\n        int x = vx[i].first;\n        int total = vx[i].second;\n        if((total ^ nim) < total){\n            int tmp = cut_x(x, total - (total ^ nim));\n            cout << x << ' ' << 0 << ' ' << x << ' ' << tmp << endl;\n            return 0;\n        }\n    }\n    \n    REP(i,vy.size()){\n        int y = vy[i].first;\n        int total = vy[i].second;\n        if((total ^ nim) < total){\n            int tmp = cut_y(y, total - (total ^ nim));\n            cout << 0 << ' ' << y << ' ' << tmp << ' ' << y << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"failed\" << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/6815",
    "editorial": "At first, notice that horizontal and vertical cuts are independent.\r\nConsider a single horizontal line. It contains unit segments. And in any\r\ngame state it\u00e2\u0080\u0099s always possible to decrease the number of uncut units as\r\nthe player wants. Imagine, that she starts growing a segment from a\r\nborder, increasing it\u00e2\u0080\u0099s length by 1 at a time. Each time the total uncut\r\nlength decreases by either 0 or 1. In the end it obviously reaches 0.\r\nThe same holds for vertical lines as well. So if there are no initial\r\ncuts, the game is a nim with piles of stones and piles of stones. Could\r\nbe solved with simple formula. Initial cuts should be just a technical\r\ndifficulty. For any vertical/horizontal line, which contains at least\r\none of the cuts, it\u00e2\u0080\u0099s pile size should be decreased by the total length\r\nof all segments on this line. How to make a first move in nim: let is\r\nthe result of state (grundy function), and is the size of the -th pile.\r\nThen the result of the game without -th pile is . We want to replace\r\nwith some , so that . Obviously, the only possible . The resulting\r\nsolution: find a pile for which , and decrease it downto .\r\n"
}