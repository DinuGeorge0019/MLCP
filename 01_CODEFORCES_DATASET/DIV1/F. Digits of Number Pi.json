{"link": "https://codeforces.com//contest/585/problem/F", "problemId": "37969", "problem_idx": "F", "shortId": "585F", "contest_number": "585", "problem_submissions": {"E": [13568408, 13565539, 13570428, 13569433, 13562876, 13568414, 13569561, 13572183, 16851653, 13569075, 13575618, 14433103, 14433079, 13586801, 14994906], "D": [13563803, 13560460, 13565708, 13598452, 13575351, 13570446, 13565845, 13564574, 13569714, 13567701, 13566576, 13567580, 13566498, 13559261, 13566963, 13566457, 13569728, 13568576], "C": [13561640, 13569007, 13569377, 13560848, 13567147, 13570951, 13564734, 13564195, 13562727, 13563205, 13570079, 13563945, 13564180, 13570698, 13565134, 13564377], "B": [13558808, 13566721, 13560966, 13559388, 13575429, 13561963, 13558427, 13563703, 16850949, 13561366, 13561440, 13558802, 13567542, 13562248, 13560363, 13561318, 13562539], "A": [13556266, 13558452, 13556785, 13558546, 13586871, 13556142, 16850921, 13556990, 13562212, 13561943, 13585791, 13560017, 13556037, 13558619, 13558552], "F": [13587655, 13575255, 13575217, 16850828, 24552744, 14433355]}, "name": "F. Digits of Number Pi", "statement": "Vasily has recently learned about the amazing properties of number . In\r\none of the articles it has been hypothesized that, whatever the sequence\r\nof numbers we have, in some position, this sequence is found among the\r\ndigits of number . Thus, if you take, for example, the epic novel \"War\r\nand Peace\" of famous Russian author Leo Tolstoy, and encode it with\r\nnumbers, then we will find the novel among the characters of number\r\n.Vasily was absolutely delighted with this, because it means that all\r\nthe books, songs and programs have already been written and encoded in\r\nthe digits of . Vasily is, of course, a bit wary that this is only a\r\nhypothesis and it hasn\u2019t been proved, so he decided to check it out.To\r\ndo this, Vasily downloaded from the Internet the archive with the\r\nsequence of digits of number , starting with a certain position, and\r\nbegan to check the different strings of digits on the presence in the\r\ndownloaded archive. Vasily quickly found short strings of digits, but\r\neach time he took a longer string, it turned out that it is not in the\r\narchive. Vasily came up with a definition that a string of length is a\r\nif it contains a substring of length of at least , which occurs in the\r\narchive.To complete the investigation, Vasily took large numbers () with\r\nthe same number of digits and now he wants to find the number of numbers\r\nin the interval from to , which are in the archive. Help Vasily\r\ncalculate this value modulo .\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nint nxt[1005*55][10];\nint n;\n\nchar s[1005];\nint ln;\nint loc[1005][1005];\nint dep[1005*55];\n\nchar x[55];\nint d;\nbool alloweq;\n\n#define MOD 1000000007\nint cache[55][1005*55][2][2];\n\nint go(int di, int nd, int md, int ce) {\n    md |= dep[nd] >= d/2;\n    if (di == d) return md && (alloweq || ce == 0);\n    if (cache[di][nd][md][ce] != -1) return cache[di][nd][md][ce];\n    int uv = 9;\n    if (ce) uv = x[di]-'0';\n    long long res = 0;\n    FO(v,0,uv+1) res += go(di+1, nxt[nd][v], md, ce && v==uv);\n    return cache[di][nd][md][ce] = res % MOD;\n}\n\nint main() {\n    scanf(\" %s\", s);\n    ln = strlen(s);\n    FO(i,0,ln) {\n        int c = 0;\n        FO(j,i,ln) {\n            int v = s[j]-'0';\n            if (!nxt[c][v]) {\n                nxt[c][v] = ++n;\n            }\n            c = nxt[c][v];\n            loc[i][j] = c;\n            dep[c] = j-i+1;\n            if (dep[c] > 50) break;\n        }\n    }\n    FO(dij,0,ln+1) FO(i,0,ln) {\n        int j = i+dij;\n        if (j < ln) {\n            FO(v,0,10) {\n                if (!nxt[loc[i][j]][v]) {\n                    nxt[loc[i][j]][v] = nxt[loc[i+1][j]][v];\n                }\n            }\n        }\n    }\n    scanf(\" %s\", x);\n    d = strlen(x);\n    memset(cache,-1,sizeof cache);\n    alloweq = false;\n    int tmp = go(0,0,0,1);\n    scanf(\" %s\", x);\n    memset(cache,-1,sizeof cache);\n    alloweq = true;\n    int tmp2 = go(0,0,0,1);\n\n    printf(\"%d\\n\", (tmp2-tmp+MOD)%MOD);\n}\n\n"], "input": "", "output": "", "tags": ["dp", "implementation", "strings"], "dificulty": "3200", "interactive": false}