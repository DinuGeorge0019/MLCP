{"link": "https://codeforces.com//contest/1943/problem/E2", "problemId": "2535045", "problem_idx": "E2", "shortId": "1943E2", "contest_number": "1943", "problem_submissions": {"E2": [251755986, 251774166, 251721110, 251772938, 251976046, 251850394, 251783692, 252482559, 251768795, 251806219, 251801786, 251784602, 251808955, 251786442, 251790915, 251791945, 252167133, 254017076, 252396752, 251948632], "E1": [251743400, 251761808, 251720570, 251764606, 251765135, 251768616, 251774247, 251768081, 251767041, 251779764, 251763055, 251770682, 251776382, 251772657, 253458372, 251772270, 251777192, 251779122, 251781255], "D2": [251730537, 251743841, 251769783, 251827860, 251827638, 251812685, 251750876, 251749250, 251743677, 251754133, 251758370, 251752785, 251846892, 251763163, 251753145, 251743858, 251746564, 251754334, 251790796, 253458316, 251757628, 251757687, 251759092, 251761488], "D1": [251727886, 251730644, 251753185, 251730641, 251733326, 251727921, 251742335, 251739558, 251743910, 251737861, 251737457, 251736749, 251746112, 251745451, 251785836, 252959932, 251749532, 251743349, 251754372, 251751101], "C": [251715534, 251721073, 251747865, 251720444, 251722988, 251756982, 251730923, 251730217, 251735041, 251727939, 251724586, 251722879, 251721249, 251735499, 251732028, 252959913, 251731321, 251736408, 251741233, 251741283], "B": [251709195, 251712754, 251737904, 251712353, 251714193, 252482757, 251715199, 251720530, 251721280, 251721320, 251719084, 251718139, 251714047, 251713923, 251720644, 251719922, 252531274, 251717454, 251716526, 251722194, 252064777, 251726935], "A": [251701793, 251702717, 251723885, 251701730, 251702780, 251702880, 251702623, 251701902, 251707932, 251702391, 251707705, 251702309, 251701731, 251703701, 251706521, 252531268, 251732626, 251703091, 251704741, 251703882], "F": [251801182, 252436931, 251845260, 251783880]}, "name": "E2. MEX Game 2  Hard Version ", "statement": "Alice and Bob play yet another game on an array a of size n. Alice\r\nstarts with an empty array c. Both players take turns playing, with\r\nAlice starting first.On Alice\u2019s turn, she picks one element from a,\r\nappends that element to c, and then deletes it from a.On Bob\u2019s turn, he\r\npicks at most k elements from a, and then deletes it from a. The game\r\nends when the array a is empty. Alice\u2019s score is defined to be the MEX^\r\ndagger of c. Alice wants to maximize her score while Bob wants to\r\nminimize it. Find Alice\u2019s final score if both players play optimally.The\r\narray will be given in compressed format. Instead of giving the elements\r\npresent in the array, we will be giving their frequencies. Formally, you\r\nwill be given m, the maximum element in the array, and then m + 1\r\nintegers f_0, f_1,\r\nldots, f_{m}, where f_i represents the number of times i occurs in the\r\narray a.^\r\ndagger The\r\noperatorname{MEX} (minimum excludant) of an array of integers is defined\r\nas the smallest non-negative integer which does not occur in the array.\r\nFor example: The MEX of [2,2,1] is 0, because 0 does not belong to the\r\narray. The MEX of [3,1,0,1] is 2, because 0 and 1 belong to the array,\r\nbut 2 does not. The MEX of [0,3,1,2] is 4, because 0, 1, 2 and 3 belong\r\nto the array, but 4 does not.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 16.03.2024 11:13:36\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int m, k;\n    cin >> m >> k;\n    vector<int> f(m + 1);\n    for (int i = 0; i <= m; i++) {\n      cin >> f[i];\n    }\n    const int64_t inf = int64_t(1e18);\n    vector<int64_t> limit(m + 5);\n    limit[1] = k;\n    for (int i = 2; i < int(limit.size()); i++) {\n      int64_t low = k;\n      int64_t high = inf;\n      while (low < high) {\n        int64_t mid = (low + high + 1) >> 1;\n        auto x = mid;\n        x -= k;\n        x -= x / i;\n        if (x <= limit[i - 1]) {\n          low = mid;\n        } else {\n          high = mid - 1;\n        }\n      }\n      limit[i] = low;      \n    }\n    int low = 0, high = m + 1;\n    while (low < high) {\n      int mid = (low + high + 1) >> 1;\n      vector<int> a(f.begin(), f.begin() + mid);\n      sort(a.begin(), a.end());\n      vector<int64_t> psum(mid + 1);\n      for (int i = 0; i < mid; i++) {\n        psum[i + 1] = psum[i] + a[i];\n      }\n      bool win = true;\n      for (int pref = 2; pref <= mid; pref++) {\n        int l = 0, r = pref - 2;\n        while (l < r) {\n          int c = (l + r) >> 1;\n          int64_t sum = (psum[pref] - psum[c + 1]) - int64_t(a[c + 1]) * (pref - (c + 1));\n          if (sum >= int64_t(c + 1) * k) {\n            l = c + 1;\n          } else {\n            r = c;\n          }\n        }\n        int c = l;\n        int64_t sum = (psum[pref] - psum[c + 1]) - int64_t(c) * k;\n        int els = pref - 1 - c;\n        if (sum <= limit[els]) {\n          win = false;\n          break;\n        }\n      }\n      if (win) {\n        low = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    cout << low << '\\n';\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "greedy", "two pointers"], "dificulty": "3300", "interactive": false}