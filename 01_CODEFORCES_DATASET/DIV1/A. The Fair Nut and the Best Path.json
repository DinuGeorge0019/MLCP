{
    "link": "https://codeforces.com//contest/1083/problem/A",
    "problemId": "268421",
    "problem_idx": "A",
    "shortId": "1083A",
    "contest_number": "1083",
    "problem_submissions": {
        "F": [
            46915087,
            46876311,
            46868384,
            46877366,
            46879128,
            46934792,
            46934770,
            46934758,
            46934487,
            46934473,
            46934346,
            46934338,
            46934202,
            46933927,
            46928101,
            46927984,
            46927894,
            46927871,
            46927855,
            46927824,
            46927737,
            46927669,
            46927614,
            46881270
        ],
        "E": [
            46869370,
            46871694,
            46869499,
            46863810,
            46865492,
            46873246,
            46870302,
            46870225,
            46877380,
            73537754,
            46882329,
            46878807,
            46866936,
            46868963,
            46871231,
            46872499,
            46871547,
            46871489,
            46871036,
            46871727,
            46869495,
            50322936,
            50315966,
            49844673,
            49844653,
            46872514
        ],
        "C": [
            46867095,
            46877292,
            47334658,
            46890375,
            46870788,
            46950972,
            46950940,
            46950838,
            46877308,
            46877619,
            46875434,
            46987974,
            46883043,
            46874242,
            46882744,
            46942133
        ],
        "B": [
            46861840,
            46872617,
            46861528,
            46859342,
            46860406,
            46863456,
            46865386,
            46864693,
            46865545,
            46861409,
            46863762,
            46864513,
            46863287,
            46861669,
            46861388,
            46863642,
            46862875,
            46865443,
            46861004,
            46867808
        ],
        "A": [
            46860516,
            46860277,
            46860154,
            46866668,
            46859314,
            46876109,
            46860042,
            46861931,
            46860073,
            46859289,
            46859440,
            46860646,
            46859325,
            46859654,
            46859377,
            46861868,
            46860315,
            46863438,
            46865470,
            46859724
        ],
        "D": [
            46882403,
            46994123
        ]
    },
    "name": "A. The Fair Nut and the Best Path",
    "statement": "The Fair Nut is going to travel to the Tree Country, in which there are\r\nn cities. Most of the land of this country is covered by forest.\r\nFurthermore, the local road system forms a tree (connected graph without\r\ncycles). Nut wants to rent a car in the city u and go by a simple path\r\nto city v. He hasn\u2019t determined the path, so it\u2019s time to do it. Note\r\nthat chosen path can consist of only one vertex.A filling station is\r\nlocated in every city. Because of strange law, Nut can buy only w_i\r\nliters of gasoline in the i-th city. We can assume, that he has . Each\r\nroad has a length, and as soon as Nut drives through this road, the\r\namount of gasoline decreases by length. Of course, Nut can\u2019t choose a\r\npath, which consists of roads, where he runs out of gasoline. He can buy\r\ngasoline in visited city, even in and .He also wants to find the maximum\r\namount of gasoline that he can have at the end of the path. Help him:\r\ncount it.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nll tab[nax];\n\nll wyn;\n\nvector <pair <int,ll> > graf[nax];\n\nll dfs(int v, int oj)\n{\n\tll ret=tab[v];\n\twyn=max(wyn, tab[v]);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj)\n\t\t\tcontinue;\n\t\tll w=dfs(i.first, v)-i.second;\n\t\twyn=max(wyn, ret+w);\n\t\tret=max(ret, w+tab[v]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld\", &tab[i]);\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tgraf[a].push_back({b, c});\n\t\tgraf[b].push_back({a, c});\n\t}\n\tdfs(1, 0);\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "trees"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. The Fair Nut and the Best Path.json",
    "editorial_link": "https://codeforces.com/blog/entry/63753?locale=en",
    "editorial": "Let\u00e2\u0080\u0099s write on edge with length number . Let sum on the path be sum of\r\namounts of gasoline, which can be bought in cities on this path plus sum\r\nof the numbers, which were written on its edges.If we don\u00e2\u0080\u0099t run out of\r\ngasoline on some path, sum on it will be equal to amount of gasoline at\r\nthe end of way. If we run out of gasoline on a path, we can start from\r\nthe next city after the road, where it happened, and sum on the path\r\nwon\u00e2\u0080\u0099t decrease. So, there is a path with maximal sum, where we don\u00e2\u0080\u0099t run\r\nout of gasoline. This sum is answer to the problem. How to find it? Let\r\nis maximal sum on vertical way, which starts in vertex . It is not\r\ndifficult to calculate , using values for children of vertex . Every way\r\ncan be divided to two vertical ways, so we can calculate answer by\r\nturning over , which is the highest vertex of a path, and taking the two\r\nbiggest vertical ways, which starts from vertex .\r\n"
}