{"link": "https://codeforces.com//contest/1835/problem/D", "problemId": "1971170", "problem_idx": "D", "shortId": "1835D", "contest_number": "1835", "problem_submissions": {"F": [210161299, 210152027, 210200486, 210168915, 210168905, 210234528, 210498721], "E": [210154409, 210139670, 210181918, 210167680, 210186364, 210186293, 211288903, 210214448, 210232344], "D": [210137478, 210145210, 210140448, 210146614, 210150836, 210149175, 210153170, 210140966, 210145335, 210157557, 210152881, 210158282, 210161722, 210158416, 210154492, 210150489, 210158944, 210157853, 210161077, 210159964], "C": [210128217, 210152796, 210132819, 210132907, 210137216, 210139416, 210142582, 210132889, 210151723, 210144494, 210144705, 210148053, 210147474, 210148947, 210144617, 210156201, 210143729, 210131342, 210153921, 210147904], "A": [210111447, 210110992, 210111020, 210113789, 210120090, 210112664, 210112565, 210111866, 210115344, 210112666, 210121548, 210113387, 210112454, 210112268, 210111369, 210114825, 210112488, 210116562, 210113331, 210116729], "B": [210161645, 210167670, 210167549, 210140435, 210129507, 210130424, 210124576, 210153636, 210135720, 210132356, 210134355, 210136221, 210133381, 210135165, 210136236, 210132156, 210131717, 210148804, 210140447, 210134819]}, "name": "D. Doctor s Brown Hypothesis", "statement": "The rebels have been crushed in the most recent battle with the imperial\r\nforces, but there is a ray of new hope.Meanwhile, on one of the\r\nconquered planets, Luke was getting ready for an illegal street race\r\n(which should come as no surprise, given his family history). Luke\r\narrived at the finish line with 88 miles per hour on his speedometer.\r\nAfter getting out of the car, he was greeted by a new reality. It turns\r\nout that the battle has not happened yet and will start in exactly k\r\nhours.The rebels have placed a single battleship on each of the n\r\nplanets. m unidirectional wormholes connect the planets. Traversing each\r\nwormhole takes exactly one hour. Generals of the Imperium have planned\r\nthe battle precisely, but their troops cannot dynamically adapt to\r\nchanging circumstances. Because of this, it is enough for the rebels to\r\nmove some ships around before the battle to confuse the enemy, secure\r\nvictory and change the galaxy\u2019s fate.Owing to numerous strategical\r\nconsiderations, which we now omit, the rebels would like to choose two\r\nships that will switch places so that both of them will be on the move\r\nfor the whole time (exactly k hours). In other words, rebels look for\r\ntwo planets, x and y, such that paths of length k exist from x to y and\r\nfrom y to x.Because of the limited fuel supply, choosing one ship would\r\nalso be acceptable. This ship should fly through the wormholes for k\r\nhours and then return to its initial planet.How many ways are there to\r\nchoose the ships for completing the mission?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n, m;\nll T;\nvector<int> g[N], rg[N];\nvector<pii> G[N];\nbool used[N];\nint ord[N];\nint ordSz;\nint col[N];\nint id[N];\nint a[N];\nvector<int> forCol[N];\nint GCD;\nll cntLen[N];\n\nvoid dfsOrd(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) if (!used[u])\n\t\tdfsOrd(u);\n\tord[ordSz++] = v;\n}\nvoid dfsCol(int v) {\n\tcol[v] = m;\n\tfor (int u : rg[v]) if (col[u] == 0)\n\t\tdfsCol(u);\n}\nvoid dfsVal(int v) {\n\tfor (pii e : G[v]) {\n\t\tint u = e.first;\n\t\tint x = a[v] + e.second;\n\t\tif (a[u] == -1) {\n\t\t\ta[u] = x;\n\t\t\tdfsVal(u);\n\t\t} else {\n\t\t\tx = abs(x - a[u]);\n\t\t\tif (x != 0) GCD = gcd(GCD, x);\n\t\t}\n\t}\n}\n\nll solve(int sz) {\n\tif (sz == 1) {\n\t\tif (G[0].empty()) return 0;\n\t\treturn 1;\n\t}\n\tfor (int i = 0; i < sz; i++)\n\t\ta[i] = -1;\n\ta[0] = N;\n\tGCD = 0;\n\tdfsVal(0);\n\tassert(GCD != 0);\n\tassert(GCD <= sz);\n\tfor (int i = 0; i < GCD; i++)\n\t\tcntLen[i] = 0;\n\tfor (int i = 0; i < sz; i++)\n\t\tcntLen[a[i] % GCD]++;\n\tll ans = 0;\n\tif (T % GCD == 0) {\n\t\tfor (int i = 0; i < GCD; i++)\n\t\t\tans += cntLen[i] * (cntLen[i] + 1) / 2;\n\t} else if ((2 * T) % GCD == 0) {\n\t\tfor (int i = 0; i < GCD / 2; i++)\n\t\t\tans += cntLen[i] * cntLen[i + GCD / 2];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%lld\", &n, &m, &T);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\trg[u].push_back(v);\n\t}\n\tfor (int v = 0; v < n; v++) if (!used[v])\n\t\tdfsOrd(v);\n\tm = 0;\n\treverse(ord, ord + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tif (col[v] != 0) continue;\n\t\tm++;\n\t\tdfsCol(v);\n\t}\n\tfor (int v = 0; v < n; v++)\n\t\tforCol[col[v] - 1].push_back(v);\n\tll ans = 0;\n\tfor (int c = 0; c < m; c++) {\n\t\tint sz = (int)forCol[c].size();\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tG[i].clear();\n\t\t\tid[forCol[c][i]] = i;\n\t\t}\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tint v = forCol[c][i];\n\t\t\tfor (int u : g[v]) {\n\t\t\t\tif (col[u] != col[v]) continue;\n\t\t\t\tG[i].push_back(mp(id[u], 1));\n\t\t\t\tG[id[u]].push_back(mp(i, -1));\n\t\t\t}\n\t\t}\n\t\tans += solve(sz);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "math", "number theory"], "dificulty": "2900", "interactive": false}