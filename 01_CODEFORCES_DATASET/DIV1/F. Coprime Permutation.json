{"link": "https://codeforces.com//contest/698/problem/F", "problemId": "65781", "problem_idx": "F", "shortId": "698F", "contest_number": "698", "problem_submissions": {"A": [19255240, 19238333, 19233487, 19233309, 19234715, 19232234, 19232460, 19232250, 19232256, 19233295, 19249652, 19232146, 19232208, 19232154, 19232533], "B": [19254561, 19237012, 19237862, 19236769, 19233173, 19239263, 19235681, 19237484, 19241788, 19236331, 19248894, 19236580, 19234441, 19235605, 19239046], "D": [19253572, 19249527, 19248444, 19246796, 19251047, 19251739], "C": [19248258, 19234132, 19243267, 19241700, 19248574, 19235387, 19239629, 19241130, 19239485, 19252239, 19235095, 19245084, 19242311, 19243465, 19252785], "F": [19242723, 19251904, 19301612, 19253678, 19251067, 19249915, 19278249, 19257429, 19255248], "E": [19254153, 19262072, 19250384, 19249636]}, "name": "F. Coprime Permutation", "statement": "Two positive integers are coprime if and only if they don\u2019t have a\r\ncommon divisor greater than .Some bear doesn\u2019t want to tell Radewoosh\r\nhow to solve some algorithmic problem. So, Radewoosh is going to break\r\ninto that bear\u2019s safe with solutions. To pass through the door, he must\r\nenter a permutation of numbers through . The door opens if and only if\r\nan entered permutation satisfies:In other words, two different elements\r\nare coprime if and only if their indices are coprime. Some elements of a\r\npermutation may be already fixed. In how many ways can Radewoosh fill\r\nthe remaining gaps so that the door will open? Print the answer modulo .\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\n/*int n,p[1010];\nmap<VI,int> hs;\nVI v;\nbool check() {\n\trep(p1,1,n+1) rep(p2,p1+1,n+1) if ((__gcd(p1,p2)==1)!=(__gcd(p[p1],p[p2])==1)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}*/\n\ntypedef pair<ll,ll> PLL;\nnamespace Factor {\n\tconst int N=1010000;\n\tll C,fac[10010],n,mut,a[1001000];\n\tint T,cnt,i,l,prime[N],p[N],psize,_cnt;\n\tll _e[100],_pr[100];\n\tvector<ll> d;\n\tinline ll mul(ll a,ll b,ll p) {\n\t\tif (p<=1000000000) return a*b%p;\n\t\telse if (p<=1000000000000ll) return (((a*(b>>20)%p)<<20)+(a*(b&((1<<20)-1))))%p;\n\t\telse {\n\t\t\tll d=(ll)floor(a*(long double)b/p+0.5);\n\t\t\tll ret=(a*b-d*p)%p;\n\t\t\tif (ret<0) ret+=p;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid prime_table(){\n\t\tint i,j,tot,t1;\n\t\tfor (i=1;i<=psize;i++) p[i]=i;\n\t\tfor (i=2,tot=0;i<=psize;i++){\n\t\t\tif (p[i]==i) prime[++tot]=i;\n\t\t\tfor (j=1;j<=tot && (t1=prime[j]*i)<=psize;j++){\n\t\t\t\tp[t1]=prime[j];\n\t\t\t\tif (i%prime[j]==0) break;\n\t\t\t}\n\t\t}\n\t}\n\tvoid init(int ps) {\n\t\tpsize=ps;\n\t\tprime_table();\n\t}\n\tll powl(ll a,ll n,ll p) {\n\t\tll ans=1;\n\t\tfor (;n;n>>=1) {\n\t\t\tif (n&1) ans=mul(ans,a,p);\n\t\t\ta=mul(a,a,p);\n\t\t}\n\t\treturn ans;\n\t}\n\tbool witness(ll a,ll n) {\n\t\tint t=0;\n\t\tll u=n-1;\n\t\tfor (;~u&1;u>>=1) t++;\n\t\tll x=powl(a,u,n),_x=0;\n\t\tfor (;t;t--) {\n\t\t\t_x=mul(x,x,n);\n\t\t\tif (_x==1 && x!=1 && x!=n-1) return 1;\n\t\t\tx=_x;\n\t\t}\n\t\treturn _x!=1;\n\t}\n\tbool miller(ll n) {\n\t\tif (n<2) return 0;\n\t\tif (n<=psize) return p[n]==n;\n\t\tif (~n&1) return 0;\n\t\tfor (int j=0;j<=7;j++) if (witness(rand()%(n-1)+1,n)) return 0;\n\t\treturn 1;\n\t}\n\tll gcd(ll a,ll b) {\n\t\tll ret=1;\n\t\twhile (a!=0) {\n\t\t\tif ((~a&1) && (~b&1)) ret<<=1,a>>=1,b>>=1;\n\t\t\telse if (~a&1) a>>=1; else if (~b&1) b>>=1;\n\t\t\telse {\n\t\t\t\tif (a<b) swap(a,b);\n\t\t\t\ta-=b;\n\t\t\t}\n\t\t}\n\t\treturn ret*b;\n\t}\n\tll rho(ll n) {\n\t\tfor (;;) {\n\t\t\tll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY;\n\t\t\tint tmp=20;\n\t\t\tC=rand()%10+3;\n\t\t\tX=mul(X,X,n)+C;*(lY++)=X;lX++;\n\t\t\tY=mul(X,X,n)+C;*(lY++)=Y;\n\t\t\tfor(;X!=Y;) {\n\t\t\t\tll t=X-Y+n;\n\t\t\t\tZ=mul(T,t,n);\n\t\t\t\tif(Z==0) return gcd(T,n);\n\t\t\t\ttmp--;\n\t\t\t\tif (tmp==0) {\n\t\t\t\t\ttmp=20;\n\t\t\t\t\tZ=gcd(Z,n);\n\t\t\t\t\tif (Z!=1 && Z!=n) return Z;\n\t\t\t\t}\n\t\t\t\tT=Z;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tX=*(lX++);\n\t\t\t}\n\t\t}\n\t}\n\tvoid _factor(ll n) {\n\t\tfor (int i=0;i<cnt;i++) {\n\t\t\tif (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];}\n\t\tif (n<=psize) {\n\t\t\tfor (;n!=1;n/=p[n]) fac[cnt++]=p[n];\n\t\t\treturn;\n\t\t}\n\t\tif (miller(n)) fac[cnt++]=n;\n\t\telse {\n\t\t\tll x=rho(n);\n\t\t\t_factor(x);_factor(n/x);\n\t\t}\n\t}\n\tvoid dfs(ll x,int dep) {\n\t\tif (dep==_cnt) d.pb(x);\n\t\telse {\n\t\t\tdfs(x,dep+1);\n\t\t\tfor (int i=1;i<=_e[dep];i++) dfs(x*=_pr[dep],dep+1);\n\t\t}\n\t}\n\tvoid norm() {\n\t\tsort(fac,fac+cnt);\n\t\t_cnt=0;\n\t\trep(i,0,cnt) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1;\n\t\t\telse _e[_cnt-1]++;\n\t}\n\tvector<ll> getd() {\n\t\td.clear();\n\t\tdfs(1,0);\n\t\treturn d;\n\t}\n\tvector<ll> factor(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\treturn getd();\n\t}\n\tvector<PLL> factorG(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\tvector<PLL> d;\n\t\trep(i,0,_cnt) d.pb(mp(_pr[i],_e[i]));\n\t\treturn d;\n\t}\n\tbool is_primitive(ll a,ll p) {\n\t\tassert(miller(p));\n\t\tvector<PLL> D=factorG(p-1);\n\t\trep(i,0,SZ(D)) if (powl(a,(p-1)/D[i].fi,p)==1) return 0;\n\t\treturn 1;\n\t}\n\tll simplify(ll n) {\n\t\tvector<PLL> d=factorG(n);\n\t\tll c=1;\n\t\tfor (auto p:d) c=c*p.fi;\n\t\treturn c;\n\t}\n}\n\n\nconst int N=1010000;\nint n,v[N],simp[N],tr[N];\nmap<PII,int> hs;\nmap<int,int> h2;\nPII big[N];\n\nint main() {\n\tFactor::init(1000000);\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",v+i);\n\trep(i,1,n+1) if ((ll)i*i>n&&Factor::miller(i)) {\n\t\tfor (int j=i;j<=n;j+=i) big[j]=mp(i,j/i);\n\t}\n\trep(i,1,n+1) simp[i]=Factor::simplify(i);\n\tbig[1]=mp(1,1);\n\trep(i,1,n+1) {\n\t\tif (big[i]==mp(0,0)) hs[mp(0,simp[i])]++;\n\t\telse {\n\t\t\ths[mp(big[i].fi,simp[big[i].se])]++;\n\t\t\tif (big[i].se==1) {\n\t\t\t\tint c=n/i; if (i==1) c=1;\n\t\t\t\th2[c]++;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n+1) if (v[i]!=0) {\n\t\t// big prime\n\t\tif ((big[i]==mp(0,0))!=(big[v[i]]==mp(0,0))) {\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (big[i]==mp(0,0)&&big[v[i]]==mp(0,0)) {\n\t\t\tif (simp[i]!=simp[v[i]]) { puts(\"0\"); return 0; }\n\t\t\ths[mp(0,simp[i])]--;\n\t\t\t// add case 0 i->v[i]\n\t\t} else {\n\t\t\tassert(big[i]!=mp(0,0)&&big[v[i]]!=mp(0,0));\n\t\t\tint p1=big[i].fi,p2=big[v[i]].fi;\n\t\t\tint c1=n/p1; if (p1==1) c1=1;\n\t\t\tint c2=n/p2; if (p2==1) c2=1;\n\t\t\tif (c1!=c2) { puts(\"0\"); return 0; }\n\t\t\tif (tr[p1]!=0&&tr[p1]!=p2) { puts(\"0\"); return 0; }\n\t\t\tif (tr[p1]==0) h2[c1]--,tr[p1]=p2;\n\t\t\tif (simp[big[i].se]!=simp[big[v[i]].se]) { puts(\"0\"); return 0; }\n\t\t\ths[mp(big[i].fi,simp[big[i].se])]--;\n\t\t\t// add case i i->v[i]\n\t\t}\n\t}\n\t// count\n\tll way=1;\n\tfor (auto p:hs) {\n//\t\tprintf(\"%d %d %d\\n\",p.fi.fi,p.fi.se,p.se);\n\t\trep(i,1,p.se+1) way=way*i%mod;\n\t}\n\t// prime converge\n\tfor (auto p:h2) {\n//\t\tprintf(\"%d %d\\n\",p.fi,p.se);\n\t\trep(i,1,p.se+1) way=way*i%mod;\t\t\n\t}\n\tprintf(\"%lld\\n\",way);\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "number theory"], "dificulty": "3000", "interactive": false}