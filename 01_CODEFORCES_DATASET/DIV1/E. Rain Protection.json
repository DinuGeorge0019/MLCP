{
    "link": "https://codeforces.com//contest/1071/problem/E",
    "problemId": "240850",
    "problem_idx": "E",
    "shortId": "1071E",
    "contest_number": "1071",
    "problem_submissions": {
        "D": [
            44637237,
            44635977,
            44641232,
            44642034,
            44645226,
            44644969,
            44641119,
            44687822,
            44647598,
            44647731,
            44636247,
            44657719,
            44657573,
            44656873,
            44656778,
            44656490,
            44656434,
            44656391,
            44656371,
            44656287,
            44656203,
            44656003,
            44655947,
            44655816,
            44655752,
            44655740,
            44655723,
            44655702,
            44655688,
            44655676,
            44655623,
            44655613,
            44655594,
            44655569,
            44655560,
            44655438,
            44655419,
            44655291,
            44647784,
            44642810,
            44645755,
            44645396,
            44646118,
            44644322,
            44654399
        ],
        "C": [
            44633806,
            44636722,
            44637213,
            44636382,
            44638429,
            44646089,
            44638832,
            44640208,
            44642096,
            44639762,
            44646904,
            44636416,
            44638641,
            44637725
        ],
        "B": [
            44628020,
            44627991,
            44628766,
            44629645,
            44629488,
            44629819,
            44628230,
            44629653,
            44629034,
            44630394,
            44631138,
            44629791,
            44632540,
            44629581,
            44629264,
            44627767,
            44636293,
            44628785
        ],
        "A": [
            44624756,
            44630092,
            44624598,
            44626465,
            44625487,
            44624461,
            44624565,
            44624711,
            44624763,
            44626685,
            44624210,
            44625000,
            44627102,
            44624838,
            44625068,
            44629237,
            44625506,
            44625349
        ],
        "E": [
            44647746,
            45395419,
            45395353,
            44682935,
            44682924
        ]
    },
    "name": "E. Rain Protection",
    "statement": "A lot of people dream of convertibles (also often called cabriolets).\r\nSome of convertibles, however, don\u2019t have roof at all, and are\r\nvulnerable to rain. This is why Melon Ask, the famous inventor, decided\r\nto create a rain protection mechanism for convertibles.The workplace of\r\nthe mechanism is a part of plane just above the driver. Its functional\r\npart consists of two rails with sliding endpoints of a piece of\r\nstretching rope. For the sake of simplicity we can consider this as a\r\npair of parallel segments in a plane with the rope segment, whose\r\nendpoints we are free to choose as any points on these rails segments.\r\nThe algorithmic part of the mechanism detects each particular raindrop\r\nand predicts when and where it reaches the plane. At this exact moment\r\nthe rope segment must contain the raindrop point (so the rope adsorbs\r\nthe raindrop).You are given the initial position of the rope endpoints\r\nand all information about raindrops. You are to choose the minimal\r\npossible speed v of the endpoints sliding (both endpoints can slide in\r\nany direction along their segments independently of each other) in such\r\na way that it is possible to catch all raindrops moving both endpoints\r\nwith speed not greater than v, or find out that it\u2019s impossible no\r\nmatter how high the speed is.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n;\ndouble W, H;\nstruct point{\n\tdouble x, y, z;\n\tbool operator <(const point &p) {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tpoint() {\n\n\t}\n\tpoint(double x_, double y_, double z_=  1.0) {\n\t\tx = x_, y = y_, z = z_;\n\t}\n\tpoint operator +(const point &p)const {\n\t\treturn { x + p.x,y + p.y};\n\t}\n\tpoint operator -(const point &p)const {\n\t\treturn { x - p.x,y - p.y };\n\t}\n\tpoint To2D() {\n\t\treturn { x / z,y / z };\n\t}\n\tdouble SZ() {\n\t\treturn sqrt(x*x + y*y);\n\t}\n}st,P[20], TP[20];\nstruct Input {\n\tpoint A, B;\n\tint T;\n}w[101000];\nint cnt = 0;\nint ccw(point a, point b, point c) {\n\tpoint tb = b - a, tc = c - a;\n\tdouble t = tb.x*tc.y - tb.y*tc.x;\n\t\n\tif (abs(t / (tb.SZ() + tc.SZ())) < 1e-8)return 0;\n\tif (t > 0)return 1;\n\tif (t < 0)return -1;\n}\npoint Seg(point a, point b) {\n\treturn { b.y - a.y, a.x - b.x, -a.x*b.y + a.y*b.x };\n}\npoint Cross(point a, point b) {\n\treturn { a.y*b.z - b.y*a.z, a.z*b.x - a.x*b.z, a.x*b.y - b.x*a.y };\n}\n\nbool Get2(point &rA, point &rB, point b, point e, point A, point B) {\n\tint ck1 = ccw(b, e, A);\n\tint ck2 = ccw(b, e, B);\n\tif (ck1 >= 0 && ck2 >= 0) {\n\t\trA = A, rB = B;\n\t\treturn true;\n\t}\n\tif (ck1 < 0 && ck2 < 0) {\n\t\treturn false;\n\t}\n\tif (ck1 < 0) {\n\t\tswap(A, B);\n\t}\n\trA = A;\n\trB = Cross(Seg(A, B), Seg(b, e)).To2D();\n\treturn true;\n}\n\nbool Get(point &rA, point &rB, point b, point e) {\n\tint i;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (!Get2(b, e, P[i], P[(i + 1) % cnt], b, e))return false;\n\t}\n\trA = b, rB = e;\n\treturn true;\n}\n\nvoid Make(int pv, double x, double y) {\n\tpoint P1 = { 0.0, H*x / y };\n\tpoint P2 = { W, (H*x + (y - H)*W) / y };\n\tcnt = 0;\n\tP[cnt++] = { 0,0 };\n\tP[cnt++] = { W,0 };\n\tP[cnt++] = { W,W };\n\tP[cnt++] = { 0,W };\n\tGet(w[pv].A, w[pv].B, P1, P2);\n}\ndouble KK;\nint stk[20];\nvoid GetHull(point A, point B, double t) {\n\tint m = 0;\n\tdouble l = t*KK;\n\tTP[m++] = { A.x - l,A.y - l };\n\tTP[m++] = { A.x - l,A.y + l };\n\tTP[m++] = { A.x + l,A.y - l };\n\tTP[m++] = { A.x + l,A.y + l };\n\tTP[m++] = { B.x - l,B.y - l };\n\tTP[m++] = { B.x - l,B.y + l };\n\tTP[m++] = { B.x + l,B.y - l };\n\tTP[m++] = { B.x + l,B.y + l };\n\tsort(TP, TP + m);\n\tint top = 0, i;\n\tfor (i = 0; i < m; i++) {\n\t\twhile (top > 1 && ccw(TP[stk[top - 1]], TP[stk[top]], TP[i]) <= 0)top--;\n\t\tstk[++top] = i;\n\t}\n\tcnt = 0;\n\tfor (i = 1; i < top; i++)P[cnt++] = TP[stk[i]];\n\ttop = 0;\n\n\tfor (i = 0; i < m; i++) {\n\t\twhile (top > 1 && ccw(TP[stk[top - 1]], TP[stk[top]], TP[i]) >= 0)top--;\n\t\tstk[++top] = i;\n\t}\n\tfor (i = top; i > 1; i--)P[cnt++] = TP[stk[i]];\n}\n\nbool Pos(double K) {\n\tKK = K;\n\tint i, curT = 0;\n\tpoint A = st, B = st;\n\tdouble eps = 1e-7;\n\tfor (i = 1; i <= n; i++) {\n\t\tGetHull(A, B, w[i].T - curT + eps);\n\t\tif (!Get(A, B, w[i].A, w[i].B))return false;\n\t\tcurT = w[i].T;\n\t}\n\treturn true;\n}\nint main() {\n\tint i, j;\n\tdouble x, y;\n\tscanf(\"%d%lf%lf\", &n, &W, &H);\n\tscanf(\"%lf%lf\", &st.x, &st.y);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i].T);\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tMake(i, x, y);\n\t}\n\tdouble INF = 1e5;\n\tdouble b = 0.0, e = INF, mid;\n\tfor (i = 0; i < 35; i++) {\n\t\tmid = (b + e)*0.5;\n\t\tif (Pos(mid)) e = mid;\n\t\telse b = mid;\n\t}\n\tif (b > INF*0.8) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tprintf(\"%.10f\\n\", (b + e)*0.5);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "geometry"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Rain Protection.json",
    "editorial_link": "https://codeforces.com//blog/entry/62612",
    "editorial": "First, let\u00e2\u0080\u0099s find out if we can catch all raindrops for a fixed speed\r\n.Assume that the endpoints are at and at any moment. Consider the point\r\nfor this state (we call it the state point for this state). From now on\r\nwe work with these points. We know that this state point can move with\r\nspeed at most in both directions independently, that is, if the state\r\npoint is at the moment , then it\u00e2\u0080\u0099ll be in at the moment .It turns out\r\nthat for each one of the following takes place: we cannot catch\r\nraindrops from to ; we can catch these raindrops and there is exactly\r\none possible option for the state point at the moment ; we can catch\r\nthese raindrops and there is a segment on the plane such that the state\r\npoint at the moment can be in any point of this segment and nowhere\r\nelse. Indeed, we prove this by induction. Its basis for is trivial.\r\nLet\u00e2\u0080\u0099s prove its step. If we cannot catch raindrops from to then we\r\ncannot catch all raindrops from to . If there is some segment where the\r\nstate point can be at (possibly a segment of length ) then at the moment\r\nthe state point can be anywhere inside the convex hull of the union of\r\ntwo squares. The squares are for the endpoints of the segment at , and\r\nhere is .But we also know that the rope must contain one particular\r\npoint at the moment , which can be expressed as a linear equation of the\r\nstate point at the moment . So to obtain the required segment for one\r\nshould intersect a line with a convex hull of points (which is in fact\r\nno more than a hexagon).However, it\u00e2\u0080\u0099s not all: the endpoints of the rope\r\nmustn\u00e2\u0080\u0099t leave the rails which means that the convex hull should be first\r\nintersected with the rectangle . However, it can be done after\r\nintersecting with the required line. So the solution now is the\r\nfollowing: First we check if the answer is . This is the case when there\r\nis a triple of non-collinear raindrop points which should be on the rope\r\nsimultaneously or there is a raindrop which is not on the rope at the\r\nmoment , while it should be. The simplest way to check it is to check if\r\nwe can catch all raindrops with speed . First, it involves no case\r\nhandling; second, we will use this function later anyway. After this we\r\nrun a binary search to find the minimal possible value for speed in such\r\na way that it\u00e2\u0080\u0099s possible to catch all the raindrops. That\u00e2\u0080\u0099s the idea of\r\nthe solution. Now let\u00e2\u0080\u0099s consider precision issues.The explanation below\r\ncontains some notions which may be new for a particular reader. Please\r\ndon\u00e2\u0080\u0099t be afraid of them, I explain what they mean right after\r\nintroducing them. I refer to them by their names first for readers\r\nfamiliar with these notions to get the point faster and maybe skip the\r\nexplanation which follows. For anyone who doesn\u00e2\u0080\u0099t want to read the full\r\nproof and wants to know the summary: long double precision should be\r\nenough to get AC with the solution above (handling lines intersections\r\nproperly).Define a function as the -diameter of the set of possible\r\nlocations of the state point at the moment for the speed , that is, if\r\nthis set is empty or consists of a single point; if this set is a\r\nsegment between and . In other words, every time we calculate the length\r\nof any segment, we do it in this metric, since it\u00e2\u0080\u0099ll be convenient for\r\nour purposes.Let be the correct answer, and let be a sufficiently small\r\npositive number (but still much bigger than the machine epsilon, of\r\ncourse).One can see that all -s can be divided into two groups which\r\ndiffer a lot by their meaning: those for which we must catch one\r\nraindrop at this moment (or many equal raindrops, which doesn\u00e2\u0080\u0099t matter),\r\nthose for which we must catch more than one raindrop at this moment. For\r\nthe first ones we basically need to intersect a polygon with a line, but\r\nfor the second ones the state point at can be determined and doesn\u00e2\u0080\u0099t\r\ndepend on the speed (or such -s force our algorithm to tell that the\r\ngoal is impossible in the very beginning). Let\u00e2\u0080\u0099s call the raindrops with\r\nof the first type , and the others .Let\u00e2\u0080\u0099s prove the following lemmas:\r\nOne can see that proving these lemmas is sufficient to validate the\r\nsolution. Indeed, comparing all intersections with quite good precision\r\nwill move the binary search borders into the interval which is enough to\r\nstop for some . Fix . We know that the -th set of possible state points\r\nfor is not empty (from the definition of ). It\u00e2\u0080\u0099s clear that the -th set\r\nfor is a superset of , because we can move no faster than with the speed\r\nof . To get , we move from no more than . This finishes the proof of 1b.\r\nSince is also not empty, is at least the segment plus all the points on\r\nthe corresponding line at the distance no more than , that is, at least\r\nlonger than , hence is at least long, qed. Assume our algorithm made at\r\nleast iterations. Consider the corresponding polygon at the moment . We\r\nknow that for this polygon intersects the required line/point, but its\r\ninterior doesn\u00e2\u0080\u0099t. That means that each point of the possible set of\r\nstate points at the moment isn\u00e2\u0080\u0099t inside the polygon. That means that if\r\nwe reduce by then the distance from every point of this set to the\r\npolygon is at least , qed.To summarize, the only precision issue we can\r\nmeet is when we intersect two or more lines for complicated raindrops.\r\nThis part can be implemented in integers, but let\u00e2\u0080\u0099s dive into this\r\nanyway.One can see that catching raindrop at means thatorSince the\r\ncoefficients of this line equation are of order , the coordinates of its\r\nsolution are some rationals with the denominator of order . If we then\r\nwant to check if such point belongs to another line, we want to compare\r\nsome integer divided by another integer which is with the third integer,\r\nso we need an epsilon less than .\r\n"
}