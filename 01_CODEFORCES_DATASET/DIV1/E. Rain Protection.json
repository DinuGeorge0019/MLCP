{"link": "https://codeforces.com//contest/1071/problem/E", "problemId": "240850", "problem_idx": "E", "shortId": "1071E", "contest_number": "1071", "problem_submissions": {"D": [44637237, 44635977, 44641232, 44642034, 44645226, 44644969, 44641119, 44687822, 44647598, 44647731, 44636247, 44657719, 44657573, 44656873, 44656778, 44656490, 44656434, 44656391, 44656371, 44656287, 44656203, 44656003, 44655947, 44655816, 44655752, 44655740, 44655723, 44655702, 44655688, 44655676, 44655623, 44655613, 44655594, 44655569, 44655560, 44655438, 44655419, 44655291, 44647784, 44642810, 44645755, 44645396, 44646118, 44644322, 44654399], "C": [44633806, 44636722, 44637213, 44636382, 44638429, 44646089, 44638832, 44640208, 44642096, 44639762, 44646904, 44636416, 44638641, 44637725], "B": [44628020, 44627991, 44628766, 44629645, 44629488, 44629819, 44628230, 44629653, 44629034, 44630394, 44631138, 44629791, 44632540, 44629581, 44629264, 44627767, 44636293, 44628785], "A": [44624756, 44630092, 44624598, 44626465, 44625487, 44624461, 44624565, 44624711, 44624763, 44626685, 44624210, 44625000, 44627102, 44624838, 44625068, 44629237, 44625506, 44625349], "E": [44647746, 45395419, 45395353, 44682935, 44682924]}, "name": "E. Rain Protection", "statement": "A lot of people dream of convertibles (also often called cabriolets).\r\nSome of convertibles, however, don\u2019t have roof at all, and are\r\nvulnerable to rain. This is why Melon Ask, the famous inventor, decided\r\nto create a rain protection mechanism for convertibles.The workplace of\r\nthe mechanism is a part of plane just above the driver. Its functional\r\npart consists of two rails with sliding endpoints of a piece of\r\nstretching rope. For the sake of simplicity we can consider this as a\r\npair of parallel segments in a plane with the rope segment, whose\r\nendpoints we are free to choose as any points on these rails segments.\r\nThe algorithmic part of the mechanism detects each particular raindrop\r\nand predicts when and where it reaches the plane. At this exact moment\r\nthe rope segment must contain the raindrop point (so the rope adsorbs\r\nthe raindrop).You are given the initial position of the rope endpoints\r\nand all information about raindrops. You are to choose the minimal\r\npossible speed v of the endpoints sliding (both endpoints can slide in\r\nany direction along their segments independently of each other) in such\r\na way that it is possible to catch all raindrops moving both endpoints\r\nwith speed not greater than v, or find out that it\u2019s impossible no\r\nmatter how high the speed is.\r\n", "solutions": ["#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n;\ndouble W, H;\nstruct point{\n\tdouble x, y, z;\n\tbool operator <(const point &p) {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tpoint() {\n\n\t}\n\tpoint(double x_, double y_, double z_=  1.0) {\n\t\tx = x_, y = y_, z = z_;\n\t}\n\tpoint operator +(const point &p)const {\n\t\treturn { x + p.x,y + p.y};\n\t}\n\tpoint operator -(const point &p)const {\n\t\treturn { x - p.x,y - p.y };\n\t}\n\tpoint To2D() {\n\t\treturn { x / z,y / z };\n\t}\n\tdouble SZ() {\n\t\treturn sqrt(x*x + y*y);\n\t}\n}st,P[20], TP[20];\nstruct Input {\n\tpoint A, B;\n\tint T;\n}w[101000];\nint cnt = 0;\nint ccw(point a, point b, point c) {\n\tpoint tb = b - a, tc = c - a;\n\tdouble t = tb.x*tc.y - tb.y*tc.x;\n\t\n\tif (abs(t / (tb.SZ() + tc.SZ())) < 1e-8)return 0;\n\tif (t > 0)return 1;\n\tif (t < 0)return -1;\n}\npoint Seg(point a, point b) {\n\treturn { b.y - a.y, a.x - b.x, -a.x*b.y + a.y*b.x };\n}\npoint Cross(point a, point b) {\n\treturn { a.y*b.z - b.y*a.z, a.z*b.x - a.x*b.z, a.x*b.y - b.x*a.y };\n}\n\nbool Get2(point &rA, point &rB, point b, point e, point A, point B) {\n\tint ck1 = ccw(b, e, A);\n\tint ck2 = ccw(b, e, B);\n\tif (ck1 >= 0 && ck2 >= 0) {\n\t\trA = A, rB = B;\n\t\treturn true;\n\t}\n\tif (ck1 < 0 && ck2 < 0) {\n\t\treturn false;\n\t}\n\tif (ck1 < 0) {\n\t\tswap(A, B);\n\t}\n\trA = A;\n\trB = Cross(Seg(A, B), Seg(b, e)).To2D();\n\treturn true;\n}\n\nbool Get(point &rA, point &rB, point b, point e) {\n\tint i;\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (!Get2(b, e, P[i], P[(i + 1) % cnt], b, e))return false;\n\t}\n\trA = b, rB = e;\n\treturn true;\n}\n\nvoid Make(int pv, double x, double y) {\n\tpoint P1 = { 0.0, H*x / y };\n\tpoint P2 = { W, (H*x + (y - H)*W) / y };\n\tcnt = 0;\n\tP[cnt++] = { 0,0 };\n\tP[cnt++] = { W,0 };\n\tP[cnt++] = { W,W };\n\tP[cnt++] = { 0,W };\n\tGet(w[pv].A, w[pv].B, P1, P2);\n}\ndouble KK;\nint stk[20];\nvoid GetHull(point A, point B, double t) {\n\tint m = 0;\n\tdouble l = t*KK;\n\tTP[m++] = { A.x - l,A.y - l };\n\tTP[m++] = { A.x - l,A.y + l };\n\tTP[m++] = { A.x + l,A.y - l };\n\tTP[m++] = { A.x + l,A.y + l };\n\tTP[m++] = { B.x - l,B.y - l };\n\tTP[m++] = { B.x - l,B.y + l };\n\tTP[m++] = { B.x + l,B.y - l };\n\tTP[m++] = { B.x + l,B.y + l };\n\tsort(TP, TP + m);\n\tint top = 0, i;\n\tfor (i = 0; i < m; i++) {\n\t\twhile (top > 1 && ccw(TP[stk[top - 1]], TP[stk[top]], TP[i]) <= 0)top--;\n\t\tstk[++top] = i;\n\t}\n\tcnt = 0;\n\tfor (i = 1; i < top; i++)P[cnt++] = TP[stk[i]];\n\ttop = 0;\n\n\tfor (i = 0; i < m; i++) {\n\t\twhile (top > 1 && ccw(TP[stk[top - 1]], TP[stk[top]], TP[i]) >= 0)top--;\n\t\tstk[++top] = i;\n\t}\n\tfor (i = top; i > 1; i--)P[cnt++] = TP[stk[i]];\n}\n\nbool Pos(double K) {\n\tKK = K;\n\tint i, curT = 0;\n\tpoint A = st, B = st;\n\tdouble eps = 1e-7;\n\tfor (i = 1; i <= n; i++) {\n\t\tGetHull(A, B, w[i].T - curT + eps);\n\t\tif (!Get(A, B, w[i].A, w[i].B))return false;\n\t\tcurT = w[i].T;\n\t}\n\treturn true;\n}\nint main() {\n\tint i, j;\n\tdouble x, y;\n\tscanf(\"%d%lf%lf\", &n, &W, &H);\n\tscanf(\"%lf%lf\", &st.x, &st.y);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i].T);\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tMake(i, x, y);\n\t}\n\tdouble INF = 1e5;\n\tdouble b = 0.0, e = INF, mid;\n\tfor (i = 0; i < 35; i++) {\n\t\tmid = (b + e)*0.5;\n\t\tif (Pos(mid)) e = mid;\n\t\telse b = mid;\n\t}\n\tif (b > INF*0.8) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tprintf(\"%.10f\\n\", (b + e)*0.5);\n}"], "input": "", "output": "", "tags": ["binary search", "geometry"], "dificulty": "3500", "interactive": false}