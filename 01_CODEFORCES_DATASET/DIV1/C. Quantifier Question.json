{"link": "https://codeforces.com//contest/1344/problem/C", "problemId": "600703", "problem_idx": "C", "shortId": "1344C", "contest_number": "1344", "problem_submissions": {"E": [79212522, 79191531, 80590953, 79212872, 79212690, 79200320, 79201434, 79211282, 79212433, 79201854], "F": [79198229, 79194392, 79201012, 79200076, 79187834, 79207199, 79809754, 79207634, 79321670, 79237209], "D": [79171968, 79177519, 79172745, 79182190, 79179127, 79200953, 79290388, 79290327, 79290278, 79290202, 79290106, 79289995, 79289887, 79289860, 79289837, 79289762, 79289686, 79289607, 79289576, 79289521, 79289422, 79289347, 79289280, 79289191, 79289098, 79289025, 79288951, 79288889, 79288802, 79288740, 79288714, 79288657, 79288619, 79288562, 79288537, 79288505, 79288461, 79288426, 79288386, 79288343, 79288285, 79288204, 79288164, 79288116, 79288088, 79288039, 79288012, 79287980, 79287919, 79287860, 79287808, 79287736, 79287668, 79287637, 79287604, 79287566, 79287547, 79287511, 79287459, 79287434, 79287397, 79287350, 79287296, 79287262, 79287211, 79287167, 79287127, 79287079, 79286996, 79286949, 79286890, 79286845, 79286781, 79286728, 79286696, 79286656, 79286614, 79286579, 79286534, 79286474, 79286420, 79286389, 79286352, 79286300, 79286206, 79286092, 79286033, 79286000, 79285960, 79285920, 79285841, 79285783, 79285724, 79285687, 79285642, 79285596, 79285548, 79285495, 79285449, 79285406, 79285333, 79285275, 79285210, 79285148, 79285111, 79285080, 79284856, 79284810, 79284730, 79284667, 79284608, 79284558, 79284511, 79284467, 79284408, 79284359, 79276900, 79215004, 79179390, 79207200, 79185960, 79183492, 79185743, 79185899, 79187272, 79188204, 79183059, 79193595, 79192774, 79231073, 79194712, 79198266], "C": [79163958, 79167940, 79163314, 79167454, 79171067, 79172648, 79188375, 79171587, 79170701, 79174750, 79169461, 79175789, 79173516, 79172995, 79172803, 79176868, 79181841, 79172312, 79173542, 79175559], "B": [79155063, 79159060, 79154263, 79156872, 79158896, 79185288, 79162853, 79161753, 79161038, 79159421, 79159787, 79164882, 79163754, 79164480, 79160984, 79160540, 79164542, 79181585, 79178109, 79166538], "A": [79148759, 79148909, 79148790, 79148832, 79148971, 79151724, 79149355, 79151000, 79150191, 79163668, 79149361, 79149785, 79152609, 79150965, 79162044, 79148915, 79156438, 79149648, 79150451, 79148779]}, "name": "C. Quantifier Question", "statement": "Logical quantifiers are very useful tools for expressing claims about a\r\nset. For this problem, let\u2019s focus on the set of real numbers\r\nspecifically. There are two kinds of quantifiers: universal (\r\nforall) and existential (\r\nexists). You can read more about them here.The universal quantifier is\r\nused to make a claim that a statement holds . For example:\r\nforall x,x<100 is read as: for all real numbers x, x is less than 100.\r\nThis statement is false.\r\nforall x,x>x-1 is read as: for all real numbers x, x is greater than\r\nx-1. This statement is true. The existential quantifier is used to make\r\na claim that for which the statement holds. For example:\r\nexists x,x<100 is read as: there exists a real number x such that x is\r\nless than 100. This statement is true.\r\nexists x,x>x-1 is read as: there exists a real number x such that x is\r\ngreater than x-1. This statement is true. Moreover, these quantifiers\r\ncan be nested. For example:\r\nforall x,\r\nexists y,x<y is read as: for all real numbers x, there exists a real\r\nnumber y such that x is less than y. This statement is true since for\r\nevery x, there exists y=x+1.\r\nexists y,\r\nforall x,x<y is read as: there exists a real number y such that for all\r\nreal numbers x, x is less than y. This statement is false because it\r\nclaims that there is a maximum real number: a number y larger than every\r\nx. There are n variables x_1,x_2,\r\nldots,x_n, and you are given some formula of the form f(x_1,\r\ndots,x_n):=(x_{j_1}<x_{k_1})\r\nland (x_{j_2}<x_{k_2})\r\nland\r\ncdots\r\nland (x_{j_m}<x_{k_m}), where\r\nland denotes logical AND. That is, f(x_1,\r\nldots, x_n) is true if every inequality x_{j_i}<x_{k_i} holds.\r\nOtherwise, if at least one inequality does not hold, then f(x_1,\r\nldots,x_n) is false.Your task is to assign quantifiers Q_1,\r\nldots,Q_n to either universal (\r\nforall) or existential (\r\nexists) so that the statement Q_1 x_1, Q_2 x_2,\r\nldots, Q_n x_n, f(x_1,\r\nldots, x_n) is true, and , or determine that the statement is false for\r\nevery possible assignment of quantifiers. For example, if\r\nf(x_1,x_2):=(x_1<x_2) then you are not allowed to make x_2 appear first\r\nand use the statement\r\nforall x_2,\r\nexists x_1, x_1<x_2. If you assign Q_1=\r\nexists and Q_2=\r\nforall, it will be interpreted as\r\nexists x_1,\r\nforall x_2,x_1<x_2.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: sorts vertices such that if there exists an edge x->y, then x goes before y\n * Source: KACTL\n * Verification: https://open.kattis.com/problems/quantumsuperposition\n */\n\ntemplate<int SZ> struct TopoSort {\n\tint N, in[SZ];\n\tvi res, adj[SZ];\n\tvoid ae(int x, int y) { adj[x].pb(y), in[y] ++; }\n\tbool sort(int _N) {\n\t\tN = _N; queue<int> todo;\n\t\tFOR(i,1,N+1) if (!in[i]) todo.push(i);\n\t\twhile (sz(todo)) {\n\t\t\tint x = todo.front(); todo.pop(); res.pb(x);\n\t\t\ttrav(i,adj[x]) if (!(--in[i])) todo.push(i);\n\t\t}\n\t\treturn sz(res) == N;\n\t}\n};\n\nTopoSort<MX> T;\nint n,m,mn[MX], mn2[MX];\n\nint main() {\n\tsetIO(); re(n,m);\n\tF0R(i,m) {\n\t\tint j,k; re(j,k);\n\t\tT.ae(j,k);\n\t}\n\tif (!T.sort(n)) {\n\t\tps(-1);\n\t\texit(0);\n\t}\n\tFOR(i,1,n+1) mn[i] = mn2[i] = i;\n\ttrav(t,T.res) {\n\t\ttrav(u,T.adj[t]) ckmin(mn[u],mn[t]);\n\t}\n\treverse(all(T.res));\n\ttrav(t,T.res) {\n\t\ttrav(u,T.adj[t]) ckmin(mn2[t],mn2[u]);\n\t}\n\tstr ans;\n\tint cnt = 0;\n\tFOR(i,1,n+1) if (min(mn[i],mn2[i]) >= i) {\n\t\tans += \"A\";\n\t\tcnt ++;\n\t} else ans += \"E\";\n\tps(cnt); ps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "math"], "dificulty": "2600", "interactive": false}