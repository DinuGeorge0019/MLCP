{
    "link": "https://codeforces.com//contest/1276/problem/C",
    "problemId": "495590",
    "problem_idx": "C",
    "shortId": "1276C",
    "contest_number": "1276",
    "problem_submissions": {
        "D": [
            66855093,
            66857065,
            66845974,
            66997276,
            66858540,
            66861684,
            66862730,
            66868898,
            66866703,
            66862266,
            66863710,
            66863337,
            66865506,
            66863170,
            66863353,
            66867792,
            66869234,
            66868492,
            66866182,
            66863049
        ],
        "C": [
            66843940,
            66846263,
            66855304,
            66856299,
            66850349,
            66850097,
            66849241,
            66845111,
            66840733,
            66851808,
            66846583,
            66853445,
            66848190,
            66854997,
            66857353,
            66855797,
            66855510,
            66860652,
            66856100,
            66851090
        ],
        "B": [
            66838883,
            66837202,
            66851887,
            66837950,
            66845504,
            66843521,
            66841052,
            66839337,
            66846582,
            66845011,
            66837082,
            66842169,
            66845204,
            66846655,
            66853297,
            66842949,
            66842748,
            66847818,
            66847458,
            66873447,
            66868214
        ],
        "A": [
            66836393,
            66834386,
            66848931,
            66834574,
            66835090,
            66834499,
            66835628,
            66834748,
            66844259,
            66835765,
            66834448,
            66836891,
            66834649,
            66835369,
            66834624,
            66839341,
            66838551,
            66839846,
            66837852,
            66838233
        ],
        "F": [
            66875333,
            66866989,
            68039784,
            67198171,
            67466141
        ],
        "E": [
            93753835,
            67190434,
            67455260,
            81662494
        ]
    },
    "name": "C. Beautiful Rectangle",
    "statement": "You are given n integers. You need to choose a subset and put the chosen\r\nnumbers in a beautiful rectangle (rectangular matrix). Each chosen\r\nnumber should occupy one of its rectangle cells, each cell must be\r\nfilled with exactly one chosen number. Some of the n numbers may not be\r\nchosen.A rectangle (rectangular matrix) is called beautiful if in each\r\nrow and in each column all values are different.What is the largest (by\r\nthe total number of cells) beautiful rectangle you can construct? Print\r\nthe rectangle itself.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define N_ 401000\nusing namespace std;\nint n, w[N_];\n\nstruct AA {\n\tint c, a;\n\tbool operator <(const AA &p)const {\n\t\treturn c < p.c;\n\t}\n}U[N_];\n\nint A, B;\n\nvoid UDT(int x, int y) {\n\tif (A*B<x*y) {\n\t\tA = x, B = y;\n\t}\n}\n\nvoid Solve() {\n\tint i, j;\n\tmap<int, int>Map;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tMap[w[i]]++;\n\t}\n\tint cnt = 0;\n\tfor (auto &t : Map) {\n\t\tcnt++;\n\t\tU[cnt] = { t.second,t.first };\n\t}\n\tsort(U + 1, U + cnt + 1);\n\tint pv = 0, s = 0;\n\tfor (i = 1; i*i <= n; i++) {\n\t\twhile (pv + 1 <= cnt && U[pv + 1].c <= i) {\n\t\t\ts += U[pv + 1].c;\n\t\t\tpv++;\n\t\t}\n\t\tint tot = (cnt - pv) * i + s;\n\t\tif (tot >= i * i) {\n\t\t\tUDT(i, tot/i);\n\t\t}\n\t}\n\ts = A * B;\n\tfor (i = 1; i <= cnt; i++) {\n\t\tif (U[i].c > A) U[i].c = A;\n\t\tU[i].c = min(U[i].c, s);\n\t\ts -= U[i].c;\n\t}\n\tprintf(\"%d\\n%d %d\\n\", A*B, A, B);\n\tvector<vector<int>>V;\n\tV.resize(A);\n\tfor (i = 0; i < A; i++)V[i].resize(B);\n\tsort(U + 1, U + cnt + 1);\n\tint x = 0, y = 0;\n\tfor (i = cnt; i >= 1; i--) {\n\t\twhile (U[i].c) {\n\t\t\tV[x][y%B] = U[i].a;\n\t\t\tU[i].c--;\n\t\t\tx++, y++;\n\t\t\tif (x >= A) {\n\t\t\t\tx -= A;\n\t\t\t\ty -= A - 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < A; i++) {\n\t\tfor (j = 0; j < B; j++) {\n\t\t\tprintf(\"%d \", V[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tint TC = 1;\n\twhile (TC--) {\n\t\tSolve();\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Beautiful Rectangle.json",
    "editorial_link": "https://codeforces.com//blog/entry/72239",
    "editorial": "First, let's formulate the criteria that from the given set of numbers x1,x2,,xk\n we can create a beautiful rectangle a×b\n (where a?b=k,a?b\n). Obviously, if some number occurs more than a\n times, then among a\n rows there will be such row that will contain two or more occurrences of the number (pigeonhole principle).\n\nLet's prove that if all numbers in x[1k]\n occur no more than a\n times, we can create a beautiful rectangle a×b\n (where a?b=k,a?b\n).\n\nWe will numerate cells from the upper left corner in the order from one, moving diagonally each time. Assume rows are numerated from 0\n to a?1\n and columns are numerated from 0\n to b?1\n. Let's begin from the cell (0,0\n) and move right-down each time. If we face to a border, we will move cyclically. Thus, from the cell (i,j\n) we will move to the cell ((i+1)moda,(j+1)modb)\n each time (where pmodq\n is the remainder when divided p\n by q\n). If we are going to move to a visited cell, before moving let's assign i:=(i+1)moda\n.\n\nExample of the numeration for rectangles 3×3\n and 4×6\n.\nWe can also prove that while such numeration each row and each column contain numbers that differ by no less than a?1\n (if we are on a row/column, we will make a turn before we will be on the row/column again). Moreover, the difference reaches a?1\n (not a\n) when we move to the previously visited cell and assign i:=(i+1)moda\n. So, we can prove that the lengths of such orbits are equal lcm(a,b)\n (lcm\n is a least common multiple). Consequently, they are divided by a\n. It means that if we will arrange the numbers from x\n in the order from the most common (at worst case those that meet a\n times) to the least common, each row and each column will always contain different numbers.\n\nThus, we have a plan of the solution: find optimal a\n and b\n so that the answer is the largest rectangle a×b\n (a?b\n). For this we will iterate over all possible candidates in a\n and for each candidate each number v\n from x\n we will use it no more than min(cv,a)\n times where cv\n is a number of occurrences v\n in the given sequence. So, if we choose a\n, the upper bound of a rectangle area is ?min(cv,a)\n for all possible different numbers v\n from the given sequence. Consequently, the maximal value of b\n is ?min(cv,a)/a\n. And let's update the answer if for current iteration a?b\n is larger than previously found answer (still consider that a?b\n).\n\nWe can maintain the value ?min(cv,a)\n while a\n is incremented by one. For doing this we should each time add geq[a]\n to this value, where geq[a]\n is a number of different numbers in the given sequence, which occurs at least a\n times (we can precalculate this array).",
    "hint": []
}