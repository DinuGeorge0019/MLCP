{
    "link": "https://codeforces.com//contest/1242/problem/C",
    "problemId": "461421",
    "problem_idx": "C",
    "shortId": "1242C",
    "contest_number": "1242",
    "problem_submissions": {
        "D": [
            64429860,
            64401395,
            64404795,
            64415190,
            64415054,
            64417615,
            65038601,
            64421033
        ],
        "E": [
            64409298,
            64420461,
            64419778,
            64424736,
            64419348,
            64414319,
            64418306,
            64411659,
            85134215,
            64416609
        ],
        "C": [
            64384054,
            64387078,
            64388913,
            64394464,
            64389930,
            64394199,
            64391758,
            64389823,
            64419752,
            64392841,
            64389286,
            64389598,
            64391081,
            64391511,
            64389424,
            64390727,
            64393812,
            64387821,
            64392710
        ],
        "B": [
            64375742,
            64376014,
            64376258,
            64379755,
            64379732,
            64382090,
            64380230,
            64379007,
            64378437,
            64381299,
            64377955,
            64379394,
            64386968,
            64379314,
            64379387,
            64378002,
            64378249,
            64378976,
            64378094,
            64382011
        ],
        "A": [
            64373553,
            64378605,
            64373529,
            64375482,
            64375227,
            64375209,
            64374548,
            64373968,
            64380733,
            64373781,
            64373964,
            64373921,
            64376154,
            64374077,
            64374590,
            64374513,
            64373655,
            64375273,
            64373875,
            64376239
        ]
    },
    "name": "C. Sum Balance",
    "statement": "Ujan has a lot of numbers in his boxes. He likes order and balance, so\r\nhe decided to reorder the numbers.There are k boxes numbered from 1 to\r\nk. The i-th box contains n_i integer numbers. The integers can be\r\nnegative. Ujan is lazy, so he will do the following reordering of the\r\nnumbers . He will pick a single integer from each of the boxes, k\r\nintegers in total. Then he will insert the chosen numbers one integer in\r\neach of the boxes, so that the number of integers in each box is the\r\nsame as in the beginning. Note that he may also insert an integer he\r\npicked from a box back into the same box.Ujan will be happy if the sum\r\nof the integers in each box is the same. Can he achieve this and make\r\nthe boxes perfectly balanced, like all things should be?\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint k;\nvi a[15];\nvi ok[1<<15];\nll avg, sum[15];\nmap<ll,int> m;\nint pre[1<<15];\n\nvoid bad() {\n\tps(\"No\");\n\texit(0);\n}\n\nvoid makeCyc(int a, int b) {\n\tvi res(k,MOD);\n\tpi ori = {a,b}; res[a] = b;\n\twhile (1) {\n\t\tll nex = avg-(sum[a]-b);\n\t\tif (m.count(nex)) {\n\t\t\ttie(a,b) = mp(m[nex],nex);\n\t\t\tif (res[a] == MOD) res[a] = b;\n\t\t\telse {\n\t\t\t\tif (a == ori.f && b == ori.s) {\n\t\t\t\t\tint mask = 0;\n\t\t\t\t\tF0R(i,k) if (res[i] != MOD) mask ^= 1<<i;\n\t\t\t\t\tok[mask] = res;\n\t\t\t\t\t// ps(\"WUT\",mask,res);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else return;\n\t}\n}\n\nint main() {\n\tsetIO(); re(k);\n\tF0R(i,k) {\n\t\tint n; re(n); a[i].rsz(n); re(a[i]);\n\t\ttrav(t,a[i]) {\n\t\t\tm[t] = i;\n\t\t\tsum[i] += t;\n\t\t}\n\t\tavg += sum[i];\n\t}\n\tif (avg%k != 0) bad();\n\tavg /= k;\n\tF0R(i,k) trav(t,a[i]) makeCyc(i,t);\n\tF0R(i,1<<k) pre[i] = MOD;\n\tpre[0] = -1;\n\tFOR(i,1,1<<k) {\n\t\tint j = i;\n\t\twhile (j) {\n\t\t\tj = (j-1)&i;\n\t\t\tif (sz(ok[i^j]) && pre[j] != MOD) pre[i] = j;\n\t\t}\n\t}\n\tint cur = (1<<k)-1;\n\tif (pre[cur] == MOD) bad();\n\tps(\"Yes\");\n\tvi tmp(k,MOD);\n\twhile (cur != 0) {\n\t\tF0R(i,sz(ok[cur^pre[cur]])) ckmin(tmp[i],ok[cur^pre[cur]][i]);\n\t\tcur = pre[cur];\n\t}\n\tF0R(i,k) sum[i] -= tmp[i];\n\tF0R(i,k) {\n\t\tint ind = 0;\n\t\twhile (sum[ind] != avg-tmp[i]) ind ++;\n\t\tps(tmp[i],ind+1);\n\t}\n\t// ps(\"HA\",avg,ok[(1<<3)-1]);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Sum Balance.json",
    "editorial_link": "https://codeforces.com//blog/entry/71216",
    "editorial": "First, calculate the total average sum . If the answer is positive, the\r\nsum of integers in each box must be equal to after reordering. If is not\r\ninteger, then the answer is immediately negative.Now, suppose that an\r\ninteger is taken out of some box . Then we know that it should be\r\nreplaced by . We then construct a graph where all of the given integers\r\nare vertices, and we draw a directed edge from to .Note that we obtain a\r\nfunctional graph. Examine all of the cycles of this graph; since this a\r\nfunctional graph, no two cycles share the same vertex. Let , then the\r\ntotal number of cycles is at most .Examine any valid reordering. It is\r\neasy to see that it is a collection of cycles from the obtained graph\r\nsuch that each box is visited by some cycle exactly once. Therefore,\r\nlets extract all of the cycles from our graph such that do not pass\r\nthrough the same box twice. A valid reordering then is some subset of\r\nthese cycles that visit all of the boxes exactly once.We can also\r\nreformulate this problem in the following way: each of the extracted\r\ncycles visits some set of boxes . Find all of such subsets ; the number\r\nof such subsets is at most . Now, the problem is reduced to exactly\r\ncovering the set with some subset of such sets.This is a classical\r\nproblem that can be solved in using dynamic programming. For a subset of\r\n, define to be if can be exactly covered, and otherwise. Firstly, . To\r\nfind for , iterate over all subsets of , and check whether is visited by\r\nsome cycle and can be covered (e.g., is ). Then the answer is . This\r\nalgorithm can be implemented with complexity , you can read about it\r\nhere:https://cp-algorithms.com/algebra/all-submasks.html. The reordering\r\ncan be restored from this DP table.The total complexity of the\r\nalgorithm: .\r\n"
}