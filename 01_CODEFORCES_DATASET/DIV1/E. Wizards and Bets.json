{
    "link": "https://codeforces.com//contest/167/problem/E",
    "problemId": "1064",
    "problem_idx": "E",
    "shortId": "167E",
    "contest_number": "167",
    "problem_submissions": {
        "E": [
            1429386,
            1431660,
            1430538,
            1430207,
            1479431,
            1430621,
            1507864,
            1489249
        ],
        "A": [
            1426561,
            1425295,
            1423883,
            1423692,
            1423784,
            1423907,
            1423753,
            1427774,
            1424703,
            1425193,
            1423661,
            1424092,
            1424249,
            1423770,
            1424171,
            1423924
        ],
        "B": [
            1425782,
            1424634,
            1425254,
            1432486,
            1425184,
            1425747,
            1425398,
            1426194,
            1432748,
            1426937,
            1424930,
            1425807,
            1425826,
            1425888,
            1426390,
            1425899
        ],
        "C": [
            1424483,
            1428090,
            1428465,
            1428006,
            1427996,
            1428587,
            1429943,
            1429298,
            1431073,
            1428990,
            1428193,
            1428363,
            1428419,
            1429448,
            1428344,
            1428582
        ],
        "D": [
            1430967,
            2861371,
            1479835,
            1433356,
            1432586,
            1508890
        ]
    },
    "name": "E. Wizards and Bets",
    "statement": "In some country live wizards. They like to make weird bets.Two wizards\r\ndraw an acyclic directed graph with vertices and edges (the graph\u2019s\r\nvertices are numbered from to ). A is a vertex with no incoming edges,\r\nand a is the vertex with no outgoing edges. Note that a vertex could be\r\nthe sink and the source simultaneously. In the wizards\u2019 graph the number\r\nof the sinks and the sources is the same.Wizards numbered the sources in\r\nthe order of increasing numbers of the vertices from to . The sinks are\r\nnumbered from to in the similar way.To make a bet, they, as are real\r\nwizards, cast a spell, which selects a set of paths from all sources to\r\nthe sinks in such a way that no two paths intersect at the vertices. In\r\nthis case, each sink has exactly one path going to it from exactly one\r\nsource. Let\u2019s suppose that the -th sink has a path going to it from the\r\n\u2019s source. Then let\u2019s call pair an if and . If the number of inversions\r\namong all possible pairs , such that , is even, then the first wizard\r\nwins (the second one gives him one magic coin). Otherwise, the second\r\nwizard wins (he gets one magic coin from the first one).Our wizards are\r\ncaptured with feverish excitement, so they kept choosing new paths again\r\nand again for so long that eventually they have chosen every possible\r\nset of paths for exactly once. The two sets of non-intersecting pathes\r\nare considered to be different, if and only if there is an edge, which\r\nlies at some path in one set and doesn\u2019t lie at any path of another set.\r\nTo check their notes, they asked you to count the total winnings of the\r\nfirst player for all possible sets of paths modulo a prime number .\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\nint P;\n\nint N;\nvector <int> graph[610]; // edge_from\nint indeg[610],outdeg[610];\nvector <int> source,sink;\nint dp[610];\n\nint dfs(int x){\n    int i;\n    \n    if(dp[x] != -1) return dp[x];\n    \n    int ans = 0;\n    REP(i,graph[x].size()){\n        ans += dfs(graph[x][i]);\n        if(ans >= P) ans -= P;\n    }\n    \n    return dp[x] = ans;\n}\n\nint D;\nll a[310][310];\n\nll power(ll x, ll n){\n    if(n == 0) return 1;\n    ll y = power(x,n/2);\n    y = y * y % P;\n    if(n%2 == 1) y = y * x % P;\n    return y;\n}\n\nll func(void){\n    int i,j,k;\n    \n/*  REP(i,D){\n        REP(j,D) cout << a[i][j] << ' ';\n        cout << endl;\n    }\n*/\n\n    bool neg = false;\n    \n    REP(j,D){\n        for(i=j;i<D;i++) if(a[i][j] != 0) break;\n        if(i == D) return 0;\n        if(i != j){\n            neg = !neg;\n            REP(k,D) swap(a[i][k],a[j][k]);\n        }\n        \n        for(i=j+1;i<D;i++){\n            ll coef = (P - a[i][j]) * power(a[j][j],P-2) % P;\n            for(k=j;k<D;k++) a[i][k] = (a[i][k] + a[j][k] * coef) % P;\n        }\n    }\n    \n    ll ans = (neg ? (P - 1) : 1);\n    REP(i,D) ans = ans * a[i][i] % P;\n    return ans;\n}\n\nint main(void){\n    int M,x,y,i,j;\n    \n    scanf(\"%d%d%d\",&N,&M,&P);\n    REP(i,M){\n        scanf(\"%d%d\",&x,&y);\n        x--; y--;\n        indeg[y]++; outdeg[x]++;\n        graph[y].push_back(x);\n    }\n    \n    REP(i,N){\n        if(indeg[i] > 0 && outdeg[i] == 0) sink.push_back(i);\n        if(indeg[i] == 0 && outdeg[i] > 0) source.push_back(i);\n    }\n    \n    D = sink.size();\n    REP(i,D){\n        REP(j,N) dp[j] = -1;\n        dp[source[i]] = 1;\n        REP(j,D) a[i][j] = dfs(sink[j]);\n    }\n    \n    ll ans = func();\n    \n    bool neg = false;\n    REP(i,N) if(indeg[i] == 0 && outdeg[i] == 0){\n        int cnt1 = 0, cnt2 = 0;\n        REP(j,D) if(sink[j] < i) cnt1++;\n        REP(j,D) if(source[j] < i) cnt2++;\n        if(cnt1 % 2 != cnt2 % 2) neg = !neg;\n    }\n    if(neg) ans = (P - ans) % P;\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "math",
        "matrices"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Wizards and Bets.json",
    "editorial_link": "https://codeforces.com//blog/entry/4214",
    "editorial": "This task was about the pathes from the sources to sinks. For this\r\npathes there was a condition which made them dependent they should not\r\ninterfere at vertexes. But in any combinatorics is much easier when\r\neverything is independent. So we should try to get rid of the condition\r\nof the absence of crossings at the vertices. It is very easy just forget\r\nabout it. Lets understand why the answer will not change: Suppose that a\r\ncertain set of ways in which the two paths intersect. We show that\r\ntaking into account this way, we at the same time take into account an\r\nanother with the opposite sign. To do this, change the endings for paths\r\nthat intersect. The signum of the permutation in this case has changed,\r\nso this set of paths is taken into account with the opposite sign and\r\ntheir sum is 0. How can it helps us? If we fix the permutation, the\r\nnumber of sets of paths that it corresponds well to the product of the\r\nnumber of paths for each pair of corresponding source and sink. Suppose\r\nthat from the i-th source in the j-th sink there are paths. This value\r\ncan be calculated by depth-first-search and simple dynamic. Then the\r\nanswer is . This value is called the determinant of matrix cnt, which\r\ncan be calculated using Gauss method in time where S is the number of\r\nsinks and sources. And we had to remember about isolated vertexes.\r\nDeleting one of them either do not change the answer or multiply the\r\nanswer by -1. It remains to see that after deleting all isolated\r\nvertexes , and fine fits into TL.\r\n"
}