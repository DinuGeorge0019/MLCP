{"link": "https://codeforces.com//contest/167/problem/E", "problemId": "1064", "problem_idx": "E", "shortId": "167E", "contest_number": "167", "problem_submissions": {"E": [1429386, 1431660, 1430538, 1430207, 1479431, 1430621, 1507864, 1489249], "A": [1426561, 1425295, 1423883, 1423692, 1423784, 1423907, 1423753, 1427774, 1424703, 1425193, 1423661, 1424092, 1424249, 1423770, 1424171, 1423924], "B": [1425782, 1424634, 1425254, 1432486, 1425184, 1425747, 1425398, 1426194, 1432748, 1426937, 1424930, 1425807, 1425826, 1425888, 1426390, 1425899], "C": [1424483, 1428090, 1428465, 1428006, 1427996, 1428587, 1429943, 1429298, 1431073, 1428990, 1428193, 1428363, 1428419, 1429448, 1428344, 1428582], "D": [1430967, 2861371, 1479835, 1433356, 1432586, 1508890]}, "name": "E. Wizards and Bets", "statement": "In some country live wizards. They like to make weird bets.Two wizards\r\ndraw an acyclic directed graph with vertices and edges (the graph\u2019s\r\nvertices are numbered from to ). A is a vertex with no incoming edges,\r\nand a is the vertex with no outgoing edges. Note that a vertex could be\r\nthe sink and the source simultaneously. In the wizards\u2019 graph the number\r\nof the sinks and the sources is the same.Wizards numbered the sources in\r\nthe order of increasing numbers of the vertices from to . The sinks are\r\nnumbered from to in the similar way.To make a bet, they, as are real\r\nwizards, cast a spell, which selects a set of paths from all sources to\r\nthe sinks in such a way that no two paths intersect at the vertices. In\r\nthis case, each sink has exactly one path going to it from exactly one\r\nsource. Let\u2019s suppose that the -th sink has a path going to it from the\r\n\u2019s source. Then let\u2019s call pair an if and . If the number of inversions\r\namong all possible pairs , such that , is even, then the first wizard\r\nwins (the second one gives him one magic coin). Otherwise, the second\r\nwizard wins (he gets one magic coin from the first one).Our wizards are\r\ncaptured with feverish excitement, so they kept choosing new paths again\r\nand again for so long that eventually they have chosen every possible\r\nset of paths for exactly once. The two sets of non-intersecting pathes\r\nare considered to be different, if and only if there is an edge, which\r\nlies at some path in one set and doesn\u2019t lie at any path of another set.\r\nTo check their notes, they asked you to count the total winnings of the\r\nfirst player for all possible sets of paths modulo a prime number .\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\nint P;\n\nint N;\nvector <int> graph[610]; // edge_from\nint indeg[610],outdeg[610];\nvector <int> source,sink;\nint dp[610];\n\nint dfs(int x){\n    int i;\n    \n    if(dp[x] != -1) return dp[x];\n    \n    int ans = 0;\n    REP(i,graph[x].size()){\n        ans += dfs(graph[x][i]);\n        if(ans >= P) ans -= P;\n    }\n    \n    return dp[x] = ans;\n}\n\nint D;\nll a[310][310];\n\nll power(ll x, ll n){\n    if(n == 0) return 1;\n    ll y = power(x,n/2);\n    y = y * y % P;\n    if(n%2 == 1) y = y * x % P;\n    return y;\n}\n\nll func(void){\n    int i,j,k;\n    \n/*  REP(i,D){\n        REP(j,D) cout << a[i][j] << ' ';\n        cout << endl;\n    }\n*/\n\n    bool neg = false;\n    \n    REP(j,D){\n        for(i=j;i<D;i++) if(a[i][j] != 0) break;\n        if(i == D) return 0;\n        if(i != j){\n            neg = !neg;\n            REP(k,D) swap(a[i][k],a[j][k]);\n        }\n        \n        for(i=j+1;i<D;i++){\n            ll coef = (P - a[i][j]) * power(a[j][j],P-2) % P;\n            for(k=j;k<D;k++) a[i][k] = (a[i][k] + a[j][k] * coef) % P;\n        }\n    }\n    \n    ll ans = (neg ? (P - 1) : 1);\n    REP(i,D) ans = ans * a[i][i] % P;\n    return ans;\n}\n\nint main(void){\n    int M,x,y,i,j;\n    \n    scanf(\"%d%d%d\",&N,&M,&P);\n    REP(i,M){\n        scanf(\"%d%d\",&x,&y);\n        x--; y--;\n        indeg[y]++; outdeg[x]++;\n        graph[y].push_back(x);\n    }\n    \n    REP(i,N){\n        if(indeg[i] > 0 && outdeg[i] == 0) sink.push_back(i);\n        if(indeg[i] == 0 && outdeg[i] > 0) source.push_back(i);\n    }\n    \n    D = sink.size();\n    REP(i,D){\n        REP(j,N) dp[j] = -1;\n        dp[source[i]] = 1;\n        REP(j,D) a[i][j] = dfs(sink[j]);\n    }\n    \n    ll ans = func();\n    \n    bool neg = false;\n    REP(i,N) if(indeg[i] == 0 && outdeg[i] == 0){\n        int cnt1 = 0, cnt2 = 0;\n        REP(j,D) if(sink[j] < i) cnt1++;\n        REP(j,D) if(source[j] < i) cnt2++;\n        if(cnt1 % 2 != cnt2 % 2) neg = !neg;\n    }\n    if(neg) ans = (P - ans) % P;\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "math", "matrices"], "dificulty": "2900", "interactive": false}