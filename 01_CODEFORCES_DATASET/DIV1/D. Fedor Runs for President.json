{"link": "https://codeforces.com//contest/1179/problem/D", "problemId": "361547", "problem_idx": "D", "shortId": "1179D", "contest_number": "1179", "problem_submissions": {"E": [55903813, 55902523, 55901885, 55909022, 55905388, 56432061, 75942632, 56023295], "D": [55893003, 55895931, 55888725, 55893104, 71080559, 71080196, 71080163, 71080130, 71080072, 71080060, 55893173, 55892658, 55908319, 55894131, 55894542, 55893763, 55896830, 56019124, 55897859, 55895869, 55954689, 55895158, 55899492, 55899301, 55888559, 55898280, 55898257, 55896770], "C": [55884160, 55884795, 55882131, 55884686, 55905440, 55885364, 55885156, 55885262, 55885328, 55886216, 55885322, 55883584, 55886444, 55954679, 55890192, 55886511, 55887224, 55900785, 55886889, 55887130, 55889061], "B": [55880474, 55886283, 55907977, 55879717, 55880717, 55880688, 55881071, 55881636, 55881390, 55878893, 55881077, 55881153, 55954669, 55881453, 55881368, 55881391, 55880057, 55884243, 55877081, 55883081], "A": [55876049, 55878221, 55877438, 55877168, 55878263, 55877701, 55876941, 55878391, 55879288, 55877277, 55877221, 55878361, 55954661, 55878330, 55878077, 55877852, 55877332, 55880624, 55880725, 55879783]}, "name": "D. Fedor Runs for President", "statement": "Fedor runs for president of Byteland! In the debates, he will be asked\r\nhow to solve Byteland\u2019s transport problem. It\u2019s a really hard problem\r\nbecause of Byteland\u2019s transport system is now a tree (connected graph\r\nwithout cycles). Fedor\u2019s team has found out in the ministry of transport\r\nof Byteland that there is money in the budget only for one additional\r\nroad. In the debates, he is going to say that he will build this road as\r\na way to maximize the number of distinct simple paths in the country. A\r\nsimple path is a path which goes through every vertex no more than once.\r\nTwo simple paths are named distinct if sets of their edges are distinct.\r\nBut Byteland\u2019s science is deteriorated, so Fedor\u2019s team hasn\u2019t succeeded\r\nto find any scientists to answer how many distinct simple paths they can\r\nachieve after adding exactly one edge on the transport system?Help Fedor\r\nto solve it.An edge can be added between vertices that are already\r\nconnected, but it can\u2019t be a loop.In this problem, we consider only\r\nsimple paths of length at least two.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\nusing ld=long double;\n\n//~ const ll is_query = -(1LL << 62);\n//~ struct Line {\n\t//~ ll m, b;\n\t//~ mutable function<const Line *()> succ;\n\t//~ bool operator<(const Line &rhs) const {\n\t\t//~ if (rhs.b != is_query) return m < rhs.m;\n\t\t//~ const Line *s = succ();\n\t\t//~ if (!s) return 0;\n\t\t//~ ll x = rhs.m;\n\t\t//~ return b - s->b < (s->m - m) * (ld)x;//ld?\n\t//~ }\n//~ };\n//~ struct HullDynamic : public multiset<Line> {\n\t//~ bool bad(iterator y) {\n\t\t//~ auto z = next(y);\n\t\t//~ if (y == begin()) {\n\t\t\t//~ if (z == end()) return 0;\n\t\t\t//~ return y->m == z->m && y->b <= z->b;\n\t\t//~ }\n\t\t//~ auto x = prev(y);\n\t\t//~ if (z == end()) return y->m == x->m && y->b <= x->b;\n\t\t//~ return (x->b - y->b) * (ld)(z->m - y->m) >= (y->b - z->b) * (ld)(y->m - x->m);//ld?\n\t//~ }\n\t//~ void insert_line(ll m, ll b) {\n\t\t//~ auto y = insert({m, b});\n\t\t//~ y->succ = [=] { return next(y) == end() ? 0 : &*next(y); };\n\t\t//~ if (bad(y)) {\n\t\t\t//~ erase(y);\n\t\t\t//~ return;\n\t\t//~ }\n\t\t//~ while (next(y) != end() && bad(next(y))) erase(next(y));\n\t\t//~ while (y != begin() && bad(prev(y))) erase(prev(y));\n\t//~ }\n\t//~ ll eval(ll x) {\n\t\t//~ auto l = *lower_bound((Line) {x, is_query});\n\t\t//~ return l.m * x + l.b;\n\t//~ }\n//~ };\n\nint n;\n\nvi graf[nax];\nll wyn;\n\nint roz[nax];\n\nll dp[nax];\n\nll po2[nax];\n\nvoid dfs1(int v, int oj)\n{\n\troz[v]=1;\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs1(i, v);\n\t\troz[v]+=roz[i];\n\t}\n}\n\nint czas;\n\nint kied[nax];\nll mini1[nax];\nll mini2[nax];\n\nvi wek;\n\nvoid cons(int v, ll w)\n{\n\tif (kied[v]!=czas)\n\t{\n\t\twek.push_back(v);\n\t\tkied[v]=czas;\n\t\tmini1[v]=inf;\n\t\tmini2[v]=inf;\n\t}\n\tif (w<mini1[v])\n\t{\n\t\tmini2[v]=mini1[v];\n\t\tmini1[v]=w;\n\t}\n\telse\n\t{\n\t\tif (w<mini2[v])\n\t\t{\n\t\t\tmini2[v]=w;\n\t\t}\n\t}\n}\n\nvoid dfs2(int v, int oj)\n{\n\tdp[v]=po2[roz[v]];\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs2(i, v);\n\t\tdp[v]=min(dp[v], dp[i]+po2[roz[v]-roz[i]]);\n\t}\n\twyn=min(wyn, dp[v]+po2[n-roz[v]]);\n\tczas++;\n\twek.clear();\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tcons(roz[i], dp[i]);\n\t}\n\tfor (const int &i : wek)\n\t{\n\t\tif (mini2[i]!=inf)\n\t\t\twyn=min(wyn, mini1[i]+mini2[i]+po2[n-i-i]);\n\t\tfor (const int &j : wek)\n\t\t{\n\t\t\tif (i==j)\n\t\t\t\tbreak;\n\t\t\twyn=min(wyn, mini1[i]+mini1[j]+po2[n-i-j]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor (int i=0; i<nax; i++)\n\t\tpo2[i]=(i*(i-1LL))/2;\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tif (n==2)\n\t{\n\t\tprintf(\"2\\n\");\n\t\treturn 0;\n\t}\n\twyn=inf;\n\tint korz=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif ((int)graf[i].size()>1)\n\t\t\tkorz=i;\n\tassert(korz);\n\tdfs1(korz, 0);\n\tdfs2(korz, 0);\n\t\n\t\n\twyn=n*(n-1LL)-wyn;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dp", "trees"], "dificulty": "2700", "interactive": false}