{
    "link": "https://codeforces.com//contest/1109/problem/F",
    "problemId": "298874",
    "problem_idx": "F",
    "shortId": "1109F",
    "contest_number": "1109",
    "problem_submissions": {
        "E": [
            50026873,
            50038594,
            50033088,
            50025271,
            50029128,
            50029427,
            50028676,
            50028977,
            50035588,
            50034800,
            50030219,
            50030201,
            50018221,
            50030444,
            50031682,
            50021323,
            50035024,
            50031663,
            50032167,
            50027503
        ],
        "C": [
            50018224,
            50032258,
            50027083,
            50523597,
            50061049,
            50019096,
            50015185
        ],
        "D": [
            50006360,
            50006283,
            50016138,
            50011686,
            50015522,
            50017005,
            50014754,
            50017015,
            50015842,
            50036394,
            50036291,
            50035638,
            50015625,
            50018432,
            50025929,
            50017587,
            50016208,
            50029181,
            50013944,
            50013609,
            50026717,
            50030603,
            50031093
        ],
        "B": [
            50001043,
            50019350,
            50007187,
            50004994,
            50003589,
            50005230,
            50000704,
            50008934,
            50007447,
            50003085,
            50002442,
            50022126,
            50007014,
            50005280,
            50003394,
            50003776,
            50016263,
            50000661,
            50002322,
            50006926
        ],
        "A": [
            49999265,
            49999276,
            50001550,
            50004725,
            49999432,
            50001055,
            49999266,
            50001592,
            49999413,
            50035642,
            49999326,
            49999231,
            50019325,
            50000549,
            50000251,
            49999282,
            49999284,
            49999278,
            49999235,
            49999298,
            49999812
        ],
        "F": [
            50024623,
            158339458,
            50027544,
            50158209,
            95343531
        ]
    },
    "name": "F. Sasha and Algorithm of Silence s Sounds",
    "statement": "One fine day Sasha went to the park for a walk. In the park, he saw that\r\nhis favorite bench is occupied, and he had to sit down on the\r\nneighboring one. He sat down and began to listen to the silence.\r\nSuddenly, he got a question: what if in different parts of the park, the\r\nsilence sounds in different ways? So it was. Let’s divide the park into\r\n1\r\ntimes 1 meter squares and call them , and numerate rows from 1 to n from\r\nup to down, and columns from 1 to m from left to right. And now, every\r\ncell can be described with a pair of two integers (x, y), where x the\r\nnumber of the row, and y the number of the column. Sasha knows that the\r\nlevel of silence in the cell (i, j) equals to f_{i,j}, and all f_{i,j}\r\nform a permutation of numbers from 1 to n\r\ncdot m. Sasha decided to count, how many are there segments of\r\nsilence?Let’s take some segment [l\r\nldots r]. Denote S as the set of cells (i, j) that l\r\nle f_{i,j}\r\nle r. Then, the segment of silence [l\r\nldots r] is if there is only path between every pair of cells from S\r\n(path can’t contain cells, which are not in S). In other words, set S\r\nshould look like a tree on a plain. Sasha has done this task pretty\r\nquickly, and called the algorithm \"algorithm of silence’s sounds\".Time\r\npassed, and the only thing left from the algorithm is a legend. To prove\r\nthe truthfulness of this story, you have to help Sasha and to find the\r\nnumber of segments of silence. Two segments [l_1\r\nldots r_1], [l_2\r\nldots r_2] are different, if l_1\r\nneq l_2 or r_1\r\nneq r_2 or both at the same time.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=210000;\nstruct node {\n\tnode *s[2],*f;\n\tbool rev;\n\tbool isr() { return !f||(f->s[0]!=this && f->s[1]!=this);}\n\tbool dir() { return f->s[1]==this;}\n\tvoid setc(node *c,int d) { s[d]=c;if (c) c->f=this;}\n\tvoid upd() {\n\n\t}\n\tvoid push() {\n\t\tif (rev) { swap(s[0],s[1]); rep(i,0,2) if (s[i]) s[i]->rev^=1;} rev=0;\n\t}\n}nd[N],*cur;\nstack<node*> sta;\nvoid rot(node *x) {\n\tnode *p=x->f;bool d=x->dir();\n\tif (!p->isr()) p->f->setc(x,p->dir()); else x->f=p->f;\n\tp->setc(x->s[!d],d);x->setc(p,!d);\n\tp->upd();\n}\nvoid splay(node *x) {\n\tnode *q=x;\n\twhile (1) { sta.push(q);if (q->isr()) break; q=q->f; }\n\twhile (!sta.empty()) sta.top()->push(),sta.pop();\n\twhile (!x->isr()) {\n\t\tif (x->f->isr()) rot(x);\n\t\telse if (x->dir()==x->f->dir()) rot(x->f),rot(x);\n\t\telse rot(x),rot(x);\n\t}\n\tx->upd();\n}\nnode *expose(node *x) {\n\tnode *q=NULL;\n\tfor (;x;x=x->f) splay(x),x->s[1]=q,(q=x)->upd();\n\treturn q;\n}\nnode *findr(node *x) {\n\tnode *q=expose(x);\n\twhile (q->s[0]) q=q->s[0];\n\tsplay(q);\n\treturn q;\n}\n\nvoid evert(node *x) { expose(x); splay(x); x->rev^=1; x->push();}\nvoid expose(node *x,node *y) { evert(x); expose(y); splay(x);}\nvoid link(node *x,node *y) {\n//\tprintf(\"link %d %d\\n\",x-nd,y-nd);\n\tevert(x); evert(y); x->setc(y,1);}\nvoid cut(node *x,node *y) {\n//\tprintf(\"cut %d %d\\n\",x-nd,y-nd);\n\texpose(x,y); x->s[1]=y->f=NULL;}\n\nnamespace segt {\nstruct node {\n\tint fg;\n\tPII s;\n}nd[4*N];\nPII operator + (const PII &a, const PII &b) {\n\tPII c(0,0); c.fi=min(a.fi,b.fi);\n\tif (a.fi==c.fi) c.se+=a.se;\n\tif (b.fi==c.fi) c.se+=b.se;\n\treturn c;\n}\nvoid upd(int p) {\n\tnd[p].s=nd[p+p].s+nd[p+p+1].s;\n}\nvoid setf(int p,int v) {\n\tnd[p].fg+=v;\n\tnd[p].s.fi+=v;\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t\tnd[p].s=mp(0,1);\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nPII query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return query(p+p,l,md,tl,md)+query(p+p+1,md+1,r,md+1,tr);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,int v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n}\n\nconst int M=1010;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint r,c,f[M][M],n;\nPII pos[N];\nVI eg[N];\n\nint main() {\n\tscanf(\"%d%d\",&r,&c);\n\tn=r*c;\n\tll ans=0;\n\trep(i,1,r+1) rep(j,1,c+1) {\n\t\tscanf(\"%d\",&f[i][j]);\n\t\tpos[f[i][j]]=mp(i,j);\n\t}\n\tint pr=0;\n\tsegt::build(1,1,n);\n\trep(i,1,r*c+1) {\n\t\tif (pr<i) {\n\t\t\tpr=i;\n\t\t\tsegt::modify(1,1,n,i,n,1);\n\t\t}\n\t\twhile (pr<n) {\n\t\t\tint z=pr+1;\n\t\t\tint x=pos[z].fi,y=pos[z].se;\n\t\t\tVI ta;\n\t\t\tvector<node*> cc;\n\t\t\trep(k,0,4) {\n\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\tif (nx>=1&&nx<=r&&ny>=1&&ny<=c&&f[nx][ny]>=i&&f[nx][ny]<z) {\n\t\t\t\t\tta.pb(f[nx][ny]);\n\t\t\t\t\tcc.pb(findr(nd+f[nx][ny]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool succ=1;\n\t\t\trep(k,0,SZ(cc)) rep(j,k+1,SZ(cc)) if (cc[k]==cc[j]) {\n\t\t\t\tsucc=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (succ) {\n\t\t\t\t++pr;\n\t\t\t\tsegt::modify(1,1,n,pr,n,1);\n\t\t\t\trep(k,0,SZ(ta)) {\n\t\t\t\t\tlink(nd+pr,nd+ta[k]);\n\t\t\t\t\teg[ta[k]].pb(pr);\n\t\t\t\t\tsegt::modify(1,1,n,pr,n,-1);\n\t\t\t\t}\n\t\t\t} else break;\n\t\t}\n\t\tPII cc=segt::query(1,1,n,i,pr);\n//\t\tprintf(\"gg %d %d\\n\",i,pr);\n//\t\tprintf(\"cc %d %d\\n\",cc.fi,cc.se);\n\t\tif (cc.fi==1) ans+=cc.se;\n\t\tsegt::modify(1,1,n,i,n,-1);\n\t\tfor (auto v:eg[i]) {\n\t\t\tsegt::modify(1,1,n,v,n,1);\n\t\t\tcut(nd+i,nd+v);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Sasha and Algorithm of Silence s Sounds.json",
    "editorial_link": "https://codeforces.com//blog/entry/65295",
    "editorial": "A range a tree, if the graph formated by it doenât have any cycle and\r\nthere is only one connected component in this graph. Letâs be such\r\nminimal position, that doenât contain cycles (forest). It is obvous that\r\n. Suppose for each we find . Then the task now is to count the number of\r\nsuch that graph formated by the range consists of one connected\r\ncomponent.How to find for each . Letâs move two pointers: and . For each\r\nmoment we store a graph formated by that range. If you add to one of the\r\npointers then you should add/delete up to edges to the graph. Before\r\nadding an edge check whether two verticies are in different components\r\n(not to form a cycle), and if they are in one component, then it is\r\nneeded to delete some edges move the first pointer. So now we need some\r\nstructure that can process types of queries online: add an edge, delete\r\nan edge, check if two verticies are in one connected component. As long\r\nas the graph will never have a cycle, so it is possible to answer\r\nqueries using link-cut tree ( for one query).It is left to count the\r\nnumber of suitable () for each . Letâs iterate from to and maintain the\r\nnumber of connected components for . Then for a fixed you should add to\r\nthe answer the number of such that and . What is going on when we move\r\nand add some edge at that moment. Letâs that edge be and (if then you\r\ncan skip this edge). For , for which , wonât change after you add an\r\nedge, but for two trees merge in one decreases by . Letâs have a segtree\r\nto store , then decreasing by is equivalent to adding on a range, and\r\nthe number of on a range is the number of minimums. All such queries can\r\nbe done in .The total complexity is .\r\n",
    "hint": []
}