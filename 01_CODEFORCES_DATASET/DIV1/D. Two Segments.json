{"link": "https://codeforces.com//contest/193/problem/D", "problemId": "1407", "problem_idx": "D", "shortId": "193D", "contest_number": "193", "problem_submissions": {"E": [1760964, 1761121, 1761512], "D": [1760240, 1762133], "C": [1758660, 1761664, 1756861, 1760385, 1757547, 1757786, 1758601, 1759415, 1759294, 1758335, 1759388, 1758973, 1758915, 1759895, 1758129, 1758643], "B": [1755241, 1755126, 1757246, 1755771, 1756101, 1755179, 1755123, 1755569, 1759901, 1755152, 1756669, 1756100, 1755910, 1760390, 1760344], "A": [1754055, 1754254, 1754686, 1754344, 1754275, 1758932, 1756481, 1757287, 1754744, 1756492, 1755198, 1754933, 1754369, 1755466]}, "name": "D. Two Segments", "statement": "Nick has some permutation consisting of integers from to . A segment ()\r\nis a set of elements satisfying .Nick calls a pair of segments and ()\r\ngood if all their elements, when sorted in ascending order, form an\r\narithmetic progression with a difference of . That is, when they sorted\r\nin ascending order, the elements are in the form , for some and .Your\r\ntask is to find the number of distinct pairs of good segments in the\r\ngiven permutation. Two pairs of segments are considered distinct if the\r\nsets of elements contained in these pairs of segments are distinct. For\r\nexample, any segment can be represented as a pair of segments, as and\r\n(). As all these pairs consist of the same set of elements, they are\r\nconsidered identical.See the notes accompanying the sample tests for\r\nclarification.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nclass Solver {\n  struct Data {\n    pii vals[3];\n\n    Data() { for (int i = 0; i < 3; i++) vals[i] = mp(INF, 0); }\n    Data(int x) { for (int i = 1; i < 3; i++) vals[i] = mp(INF, 0); vals[0] = mp(x, 1); }\n    void operator+=(const Data &d2) {\n      int p1 = 0, p2 = 0;\n      pii vals2[3];\n\n      for (int p3 = 0; p3 < 3; p3++) {\n        assert(p1 < 3 && p2 < 3);\n        int cmp = vals[p1].first - d2.vals[p2].first;\n        if (cmp < 0) vals2[p3] = vals[p1++];\n        else if (cmp > 0) vals2[p3] = d2.vals[p2++];\n        else {\n          vals2[p3] = mp(vals[p1].first, vals[p1].second + d2.vals[p2].second);\n          p1++; p2++;\n        }\n      }\n      for (int i = 0; i < 3; i++) vals[i] = vals2[i];\n    }\n  };\n\n  vector<Data> tr;\n  vi tradd;\n  int off;\n\n  void norm(int v) {\n    if (!tradd[v]) return;\n    if (v < off) {\n      tradd[2 * v] += tradd[v];\n      tradd[2 * v + 1] += tradd[v];\n    }\n    for (int i = 0; i < 3; i++) tr[v].vals[i].first += tradd[v];\n    tradd[v] = 0;\n  }\n\n  int lr, rr, vr;\n  void _add(int v, int lt, int rt) {\n    if (rt < lr || rr < lt) return;\n    if (lr <= lt && rt <= rr) {\n      tradd[v] += vr;\n      return;\n    }\n    norm(v);\n    int mt = (lt + rt) / 2;\n    _add(2 * v, lt, mt); norm(2 * v);\n    _add(2 * v + 1, mt + 1, rt); norm(2 * v + 1);\n    tr[v] = tr[2 * v];\n    tr[v] += tr[2 * v + 1];\n  }\n\n  public:\n  Solver(int n) {\n    off = 1; while (off < n) off <<= 1;\n    tr = vector<Data>(2 * off);\n    tradd = vi(2 * off, 0);\n\n    for (int i = 0; i < n; i++) {\n      tr[off + i] = 0;\n    }\n    for (int i = off - 1; i >= 1; i--) {\n      tr[i] = tr[2 * i];\n      tr[i] += tr[2 * i + 1];\n    }\n  }\n  int calc() {\n    norm(1);\n    int ans = 0;\n    for (int i = 0; i < 3; i++) {\n      assert(tr[1].vals[i].first >= 0);\n      assert(tr[1].vals[i].second >= 0);\n      if (tr[1].vals[i].first <= 2)\n        ans += tr[1].vals[i].second;\n    }\n    return ans;\n  }\n  void add(int l, int r, int v) {\n    lr = l; rr = r; vr = v;\n    return _add(1, 0, off - 1);\n  }\n};\n\nconst int MAXN = 3e5 + 1e3;\nint n;\nint as[MAXN], pos[MAXN];\n\ninline int calcNeigh(int x, int l) {\n  int cp = pos[x];\n  int ans = 0;\n  if (cp > 0) ans += as[cp - 1] >= l && as[cp - 1] < as[cp];\n  if (cp + 1 < n) ans += as[cp + 1] >= l && as[cp + 1] < as[cp];\n  return ans;\n}\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  while (scanf(\"%d\", &n) >= 1) {\n    for (int i = 0; i < n; i++)\n      scanf(\"%d\", &as[i]), pos[--as[i]] = i;\n\n    ll ans = 0;\n    Solver s(n);\n    {\n      for (int r = 0; r < n; r++)\n        s.add(r, n - 1, -calcNeigh(r, 0) + 1);\n    }\n    for (int l = 0; l < n; l++) {\n      ans += s.calc() - 1 - l;\n      s.add(l, n - 1, calcNeigh(l, l) - 1);\n\n      for (int x = max(0, pos[l] - 1); x < n && x <= pos[l] + 1; x++) if (as[x] != l) {\n        int r = as[x];\n        int oval = -calcNeigh(r, l) + 1;\n        int nval = -calcNeigh(r, l + 1) + 1;\n        s.add(r, n - 1, nval - oval);\n      }\n    }\n    printf(\"%I64d\\n\", ans);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2900", "interactive": false}