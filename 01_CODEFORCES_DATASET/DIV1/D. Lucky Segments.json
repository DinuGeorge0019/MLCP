{
    "link": "https://codeforces.com//contest/121/problem/D",
    "problemId": "645",
    "problem_idx": "D",
    "shortId": "121D",
    "contest_number": "121",
    "problem_submissions": {
        "E": [
            813184,
            803481,
            804722,
            807180,
            805935,
            810990,
            806927,
            805358,
            806319,
            806698,
            840501,
            806868,
            805056,
            812302,
            812293,
            806675,
            806432,
            806020,
            808900,
            807365
        ],
        "D": [
            805974,
            806976,
            804593,
            807857,
            805817,
            819735,
            813011,
            812998,
            837217,
            803664,
            808156,
            805706,
            805598
        ],
        "C": [
            802677,
            802018,
            801698,
            801546,
            802560,
            819807,
            803535,
            802530,
            801865,
            801880,
            802443,
            803919,
            803381,
            804324,
            802973,
            804478,
            802405,
            803458
        ],
        "B": [
            801179,
            800708,
            801605,
            800499,
            800562,
            802015,
            800515,
            800124,
            800949,
            800846,
            801743,
            801824,
            801868,
            801182,
            802657,
            801227,
            800781
        ],
        "A": [
            799835,
            799318,
            799152,
            799351,
            799213,
            800618,
            799387,
            799038,
            799161,
            799506,
            799375,
            800196,
            800336,
            799657,
            799505,
            799863,
            799637
        ]
    },
    "name": "D. Lucky Segments",
    "statement": "Petya has number segments , , ..., . During one move Petya can take any\r\nsegment (let it be segment number ) and replace it with segment or . In\r\nother words, during one move Petya can shift any segment to the left or\r\nto the right by a unit distance. Petya calls a number if it belongs to\r\neach segment. That is, number is full if for any the condition is\r\nfulfilled.Petya makes no more than moves. After that he counts the\r\nquantity of full lucky numbers. Find the maximal quantity that he can\r\nget.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <assert.h>\n#include <sstream>\n#include <complex>\n#include <numeric>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define all(a)\t\t\t(a).begin(), (a).end()\n#define sz(a)\t\t\tint((a).size())\n#define FOR(i, a, b)\tfor (int i(a); i < b; ++i)\n#define REP(i, n)\t\tFOR(i, 0, n)\n#define UN(v)\t\t\tsort(all(v)), (v).erase(unique((v).begin(), (v).end()), (v).end())\n#define CL(a, b)\t\tmemset(a, b, sizeof a)\n#define pb\t\t\t\tpush_back\n#define X\t\t\t\tfirst\n#define Y\t\t\t\tsecond\n\ntypedef long long ll;\ntypedef vector <int> vi;\ntypedef pair <int, int> pii;\n\nint n, m;\nll lim, w;\nvector<ll> lucky;\nvector<ll> L, R;\n\ninline ll add(ll x, ll y) {\n\treturn min(x + y, 1000000000000000001);\n}\n\ninline ll mul(ll x, int k) {\n\tll y = 0;\n\tfor (; k; k /= 2) {\n\t\tif (k & 1) y = add(y, x);\n\t\tx = add(x, x);\n\t}\n\treturn y;\n}\n\nvoid go(unsigned long long x) {\n\tif (x > 0 && x <= 2000000000000000000)\n\t\tlucky.pb(x);\n\tif (x <= -1ull / 10) {\n\t\tgo(x * 10 + 4);\n\t\tgo(x * 10 + 7);\n\t}\n}\n\nll x[100500], y[100500];\n\nbool check(int k) {\n\tint i = 0, j = k - 1;\n\tfor (; j < m; ++i, ++j) {\n\t\tif (lucky[j] - lucky[i] <= w && L[i] + R[j] <= lim) \n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tgo(0);\n\tsort(all(lucky));\n\tm = sz(lucky);\n\tL.resize(m);\n\tR.resize(m);\n\tcin >> n >> lim;\n\tw = -1ull/2;\n\tREP (i, n) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t\tw = min(w, y[i] - x[i]);\n\t}\n\tsort(x, x + n);\n\tsort(y, y + n);\n\tint i = 0, j = 0, k = 0;\n\tll s = 0;\n\tfor (; i < m; ++i) {\n\t\tif (k) s = add(s, mul(lucky[i] - lucky[i - 1], k));\n\t\tfor (; j < n && y[j] < lucky[i]; ++j, ++k) {\n\t\t\ts = add(s, lucky[i] - y[j]);\n\t\t}\n\t\tR[i] = s;\n\t}\n\ti = m - 1;\n\tj = n - 1;\n\tk = 0;\n\ts = 0;\n\tfor (; i >= 0; --i) {\n\t\tif (k) s = add(s, mul(lucky[i + 1] - lucky[i], k));\n\t\tfor (; j >= 0 && x[j] > lucky[i]; --j, ++k) {\n\t\t\ts = add(s, x[j] - lucky[i]);\n\t\t}\n\t\tL[i] = s;\n\t}\n\tint l = 1, r = m;\n\tfor (; l <= r; ) {\n\t\tint k = (l + r) / 2;\n\t\tcheck(k) ? l = k + 1 : r = k - 1;\n\t}\n\tcout << r << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Lucky Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/2956",
    "editorial": "Lei calculate arrays L and R. Let for all lucky i, L[i] = number of operation needed to move every segment, which's right end is to left from i to i. R[i] = number of operation needed to move every segment which left end is to right to i. How to calculate such array? Just use a sorting. Let arrange array A of pairs of integers, first - number, second equals to 0, if that number end of some segment, 1 if that number is lucky. Then, iterate from left to right, counting number of segment end we counted and si, si?=?si?-?1?+?(Ai?-?Ai?-?1)?*?ci. The same way you can use to R. Now, to find the answer we must find (using method of two pointers of binary search) pair of indexes x and y, such that  i???j, Lj?+?Ri???k, Luckyj?-?Luckyi?+?1??? min_size_of_input_segment. Also, is this problem you should arrange function Mul(a,?b), which return min(a?*?b,?INF). Since simple multiplication overflows, then you can use multipling modulo 264 or double or min-long-arithmetic.",
    "hint": []
}