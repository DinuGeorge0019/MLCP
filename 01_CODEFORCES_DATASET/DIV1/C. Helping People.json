{
    "link": "https://codeforces.com//contest/494/problem/C",
    "problemId": "19366",
    "problem_idx": "C",
    "shortId": "494C",
    "contest_number": "494",
    "problem_submissions": {
        "D": [
            9118626,
            9110497,
            9186603,
            9121795,
            9113766,
            9135685,
            9135672,
            9135646,
            9135644,
            9118440,
            9118021,
            9114872
        ],
        "C": [
            9115660,
            9117032,
            9115729,
            9112157,
            9113416,
            9118088,
            9112989,
            9113678,
            9114840,
            9114457,
            9115024,
            9116699,
            9114578,
            9115874,
            9153533
        ],
        "E": [
            9112090,
            9123061,
            9123029,
            9114944,
            9811638
        ],
        "B": [
            9104681,
            9106022,
            9107594,
            9107713,
            9107377,
            9105960,
            9107410,
            9107902,
            9108808,
            9108302,
            9109468,
            9108127,
            9106911,
            9107132,
            9108038,
            9109018
        ],
        "A": [
            9103881,
            9104046,
            9103935,
            9104128,
            9103929,
            9104036,
            9104015,
            9104004,
            9104614,
            9104250,
            9104342,
            9104831,
            9104167,
            9104248,
            9104541,
            9104804
        ]
    },
    "name": "C. Helping People",
    "statement": "Malek is a rich man. He also is very generous. That’s why he decided to\r\nsplit his money between poor people. A charity institute knows poor\r\npeople numbered from to . The institute gave Malek recommendations. A\r\nrecommendation is a segment of people like which means the institute\r\nrecommended that Malek gives one dollar to every person whose number is\r\nin this segment.However this charity has very odd rules about the\r\nrecommendations. Because of those rules the recommendations are given in\r\nsuch a way that for every two recommendation and one of the following\r\nconditions holds: The two segments are completely disjoint. More\r\nformally either or One of the two segments are inside another. More\r\nformally either or . The of a charity is the value of maximum money a\r\nperson has after Malek finishes giving his money. The institute knows\r\nfor each recommendation what is the probability that Malek will accept\r\nit. They want to know the expected value of of this charity. So they\r\nasked you for help.You have been given the list of recommendations and\r\nfor each recommendation the probability of it being accepted by Malek.\r\nYou have also been given how much money each person initially has. You\r\nmust find the expected value of .\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX = 200010;\n\nint a[MAX];\n\nconst int N = 5010;\n\nvector <int> g[N];\nvector <double> f[N];\nint start[N], finish[N];\ndouble prob[N];\nint from[N], to[N];\n\nvoid solve(int i) {\n  int sz = g[i].size();\n  from[i] = 0;\n  if (sz == 0) {\n    for (int pos = start[i]; pos <= finish[i]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n  } else {\n    for (int pos = start[i]; pos < start[g[i][0]]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n    for (int j = 0; j + 1 < sz; j++) {\n      for (int pos = finish[g[i][j]] + 1; pos < start[g[i][j + 1]]; pos++) {\n        if (a[pos] > from[i]) {\n          from[i] = a[pos];\n        }\n      }\n    }\n    for (int pos = finish[g[i][sz - 1]] + 1; pos <= finish[i]; pos++) {\n      if (a[pos] > from[i]) {\n        from[i] = a[pos];\n      }\n    }\n  }\n  to[i] = from[i];\n  for (int j = 0; j < sz; j++) {\n    int u = g[i][j];\n    solve(u);\n    if (from[u] > from[i]) {\n      from[i] = from[u];\n    }\n    if (to[u] > to[i]) {\n      to[i] = to[u];\n    }\n  }\n  f[i].resize(to[i] - from[i] + 1);\n  for (int v = to[i]; v >= from[i]; v--) {\n    double cur = 1.0;\n    for (int j = 0; j < sz; j++) {\n      int u = g[i][j];\n      if (to[u] >= v) {\n        cur *= (1.0 - f[u][v - from[u]]);\n      }\n    }\n    f[i][v - from[i]] = 1.0 - cur;\n  }\n  f[i][0] = 1.0;\n  f[i].push_back(f[i][to[i] - from[i]] * prob[i]);\n  for (int v = to[i]; v > from[i]; v--) {\n    f[i][v - from[i]] = f[i][v - from[i]] * (1 - prob[i]) + f[i][v - from[i] - 1] * prob[i];\n  }\n  to[i]++;\n}\n\nint st[N];\npair < pair <int, int>, int > adds[N];\n\nint main() {\n  int n, q;\n  scanf(\"%d %d\", &n, &q);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  q++;\n  for (int i = 0; i < q; i++) {\n    if (i == q - 1) {\n      start[i] = 1;\n      finish[i] = n + 1;\n      prob[i] = 0.0;\n    } else {\n      scanf(\"%d %d %lf\", start + i, finish + i, prob + i);\n    }\n    adds[i] = make_pair(make_pair(start[i], -finish[i]), i);\n  }\n  sort(adds, adds + q);\n  for (int i = 0; i < q; i++) {\n    g[i].clear();\n  }\n  int e = 0;\n  for (int id = 0; id < q; id++) {\n    int i = adds[id].second;\n    while (e > 0 && finish[st[e - 1]] < start[i]) {\n      e--;\n    }\n    if (e > 0) {\n      g[st[e - 1]].push_back(i);\n    }\n    st[e++] = i;\n  }\n  finish[q - 1] = n;\n  solve(q - 1);\n  double ans = from[q - 1];\n  for (int j = from[q - 1] + 1; j <= to[q - 1]; j++) {\n    ans += f[q - 1][j - from[q - 1]];\n  }\n  printf(\"%.17f\\n\", ans);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Helping People.json",
    "editorial_link": "https://codeforces.com/blog/entry/15148",
    "editorial": "Weâll first create a rooted tree from the given segments which each node\r\nrepresents a segment. Weâll solve the problem using dynamic programming\r\non this tree. First of all letâs add a segment with probability of being\r\nchosen by Malek equal to . The node representing this segment will be\r\nthe root of the tree. Please note by adding this segment the rules\r\ndescribed in the statements are still in place. Letâs sort the rest of\r\nsegments according to their starting point increasing and in case of\r\nequality according to their finishing point decreasing. Then weâll put\r\nthe segment we added in the beginning. A segmentâs father is the\r\nright-most segment which comes before that segment and contains it.\r\nPlease note that since we added segment to the beginning every segment\r\nexcept the added segment has a father. We build the tree by putting a\r\nsegmentâs node child of its fatherâs node. In this tree for each two\r\nnodes and which none of them are in the subtree on another the segments\r\nrepresenting these two nodes will not overlap. Also for each two nodes\r\nand which is in subtree of segment representing node will be inside(not\r\nnecessarily strictly) segment representing node . We define as the\r\nmaximum money a person in the segment initially has. can be calculated\r\nusing RMQ. Letâs define as the probability of that after Malek finishes\r\ngiving his money the maximum in the segment is at most . The properties\r\nof the tree we built allows us to calculate for every and in (since ).\r\nIf number of the segment we added is then the answer will be .\r\nCalculating is described below: Suppose is a child of and suppose Malek\r\ndoesnât accept the -th recommendation. Then since we want the maximum\r\nnumber after money spreading to be at most in segment and since is\r\ninside we want the maximum number after money spreading to be at most .\r\nIf Malek accepts the recommendation then we want it to be at most . So\r\nif probability of -th recommendation being accepted by Malek be equal to\r\nthen . Using this formula we can calculate recursively and calculate the\r\nanswer from it in . The overall complexity will be . for creating RMQ\r\nused for calculating the array and for the rest of the algorithm.\r\n",
    "hint": []
}