{"link": "https://codeforces.com//contest/737/problem/E", "problemId": "81053", "problem_idx": "E", "shortId": "737E", "contest_number": "737", "problem_submissions": {"D": [22352998, 22361676, 22361660, 22352983, 22352295, 22352107, 22352670, 22355408, 22353859, 22355150, 22355124, 22355580, 22352603, 22354241, 22355135, 22367415, 22354851, 22353195, 22355191, 22354766, 22354567, 22355616, 22355720], "C": [22346894, 22348992, 22348428, 22346364, 22349019, 22347742, 22344273, 22349093, 22344153, 22348276, 22349914, 22349222, 22351285, 22350460, 22350277, 22351065, 22348263, 22347006, 22351260, 22349703], "B": [22345266, 22344047, 22346326, 22344623, 22347286, 22345951, 22346273, 22346654, 22345815, 22347161, 22347731, 22346343, 22348170, 22348193, 22348953, 22349108, 22345433, 22343951, 22343981, 22347679], "A": [22344335, 22346876, 22344812, 22348251, 22345241, 22344610, 22348244, 22344836, 22349514, 22345867, 22345524, 22349952, 22345718, 22346457, 22347708, 22346937, 22344148, 22348610, 22348383, 22345809], "F": [22363265, 22374526], "E": [22411333]}, "name": "E. Tanya is 5 ", "statement": "Tanya is now five so all her friends gathered together to celebrate her\r\nbirthday. There are children on the celebration, including Tanya.The\r\ncelebration is close to its end, and the last planned attraction is\r\ngaming machines. There are machines in the hall, they are numbered\r\nthrough . Each of the children has a list of machines he wants to play\r\non. Moreover, for each of the machines he knows the exact time he wants\r\nto play on it. For every machine, no more than one child can play on\r\nthis machine at the same time.It is evening already, so every adult\r\nwants to go home. To speed up the process, you can additionally rent\r\nsecond copies of each of the machines. To rent the second copy of the\r\n-th machine, you have to pay burles. After you rent a machine, you can\r\nuse it for as long as you want.How long it will take to make every child\r\nplay according to his plan, if you have a budget of burles for renting\r\nadditional machines? There is only one copy of each machine, so it\u2019s\r\nimpossible to rent a third machine of the same type.The children can\r\ninterrupt the game in any moment and continue it later. If the -th child\r\nwants to play on the -th machine, it is allowed after you rent the copy\r\nof the -th machine that this child would play some part of the time on\r\nthe -th machine and some part of the time on its copy (each of these\r\nparts could be empty). The interruptions and changes take no time and\r\ncan be performed in any integer moment of time. Of course, a child can\u2019t\r\nplay on more than one machine at the same time.Remember, that it is not\r\nneeded to save money (no one saves money at the expense of children\r\nhappiness!), it is needed to minimize the latest moment of time some\r\nchild ends his game.\r\n", "solutions": ["#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 45;\nint n, m, b;\nint c[maxn];\nint w[maxn][maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &b) < 3) {\n    return false;\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2 * m; j++) {\n      w[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for (int j = 0; j < k; j++) {\n      int id, t;\n      scanf(\"%d%d\", &id, &t);\n      id--;\n      w[i][2 * id] = t;\n    }\n  }\n  return true;\n}\n\nint maxdeg;\nint take[maxn];\nvector< pair<pair<int, int>, pair<int, int> > > ans;\nvector<int> g[2][maxn];\nint p[2][maxn];\nint deg[2][maxn];\nint used[maxn];\n\nbool dfs(int t, int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[t][v]); i++) {\n    int u = g[t][v][i];\n    if (p[!t][u] == -1 || deg[t][p[!t][u]] < maxdeg) {\n      if (p[!t][u] != -1) {\n        p[t][p[!t][u]] = -1;\n      }\n      p[!t][u] = v;\n      p[t][v] = u;\n      return true;\n    }\n  }\n  for (int i = 0; i < sz(g[t][v]); i++) {\n    int u = g[t][v][i];\n    if (!used[p[!t][u]] && dfs(t, p[!t][u])) {\n      p[!t][u] = v;\n      p[t][v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve() {\n  for (int i = 0; i < m; i++) {\n    take[i] = false;\n  }\n  while (true) {\n    bool change = false;\n    int t = 0;\n    for (int i = 0; i < n; i++) {\n      int cur = 0;\n      for (int j = 0; j < 2 * m; j++) {\n        cur += w[i][j];\n      }\n      t = max(t, cur);\n    }\n    for (int i = 0; i < 2 * m; i++) {\n      int cur = 0;\n      for (int j = 0; j < n; j++) {\n        cur += w[j][i];\n      }\n      t = max(t, cur);\n    }\n    for (int i = 0; i < m; i++) {\n      if (take[i] || c[i] > b) {\n        continue;\n      }\n      int cur = 0;\n      for (int j = 0; j < n; j++) {\n        cur += w[j][2 * i];\n      }\n      if (cur < t) {\n        continue;\n      }\n      int tomove = t / 2;\n      for (int j = 0; j < n; j++) {\n        int x = min(tomove, w[j][2 * i]);\n        w[j][2 * i] -= x;\n        w[j][2 * i + 1] += x;\n        tomove -= x;\n      }\n      take[i] = true;\n      b -= c[i];\n      change = true;\n    }\n    if (!change) {\n      break;\n    }\n  }\n  ans.clear();\n  int t = 0;\n  while (true) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < max(n, 2 * m); j++) {\n        g[i][j].clear();\n        p[i][j] = -1;\n        deg[i][j] = 0;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 2 * m; j++) {\n        deg[0][i] += w[i][j];\n        deg[1][j] += w[i][j];\n        if (w[i][j]) {\n          g[0][i].push_back(j);\n          g[1][j].push_back(i);\n        }\n      }\n    }\n    maxdeg = 0;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < max(n, 2 * m); j++) {\n        maxdeg = max(maxdeg, deg[i][j]);\n      }\n    }\n    if (!maxdeg) {\n      break;\n    }\n    for (int i = 0; i < 2; i++) {\n      int vs = (i ? 2 * m : n);\n      for (int j = 0; j < vs; j++) {\n        if (deg[i][j] == maxdeg && p[i][j] == -1) {\n          for (int k = 0; k < vs; k++) {\n            used[k] = false;\n          }\n          dfs(i, j);\n        }\n      }\n    }\n    int ndeg = 0;\n    for (int i = 0; i < 2; i++) {\n      int vs = (i ? 2 * m : n);\n      for (int j = 0; j < vs; j++) {\n        if (p[i][j] == -1) {\n          ndeg = max(ndeg, deg[i][j]);\n        }\n      }\n    }\n    int minw = inf;\n    for (int i = 0; i < n; i++) {\n      if (p[0][i] != -1) {\n        minw = min(minw, w[i][p[0][i]]);\n      }\n    }\n    int curt = min(minw, maxdeg - ndeg);\n    for (int i = 0; i < n; i++) {\n      if (p[0][i] != -1) {\n        ans.push_back(make_pair(make_pair(i + 1, p[0][i] / 2 + 1), make_pair(t, curt)));\n        w[i][p[0][i]] -= curt;\n      }\n    }\n    t += curt;\n  }\n  printf(\"%d\\n\", t);\n  for (int i = 0; i < m; i++) {\n    printf(\"%d\", take[i]);\n  }\n  printf(\"\\n%d\\n\", sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d %d %d\\n\", ans[i].first.first, ans[i].first.second, ans[i].second.first, ans[i].second.second);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n\n"], "input": "", "output": "", "tags": ["graph matchings", "graphs", "greedy", "schedules"], "dificulty": "3300", "interactive": false}