{
    "link": "https://codeforces.com//contest/737/problem/E",
    "problemId": "81053",
    "problem_idx": "E",
    "shortId": "737E",
    "contest_number": "737",
    "problem_submissions": {
        "D": [
            22352998,
            22361676,
            22361660,
            22352983,
            22352295,
            22352107,
            22352670,
            22355408,
            22353859,
            22355150,
            22355124,
            22355580,
            22352603,
            22354241,
            22355135,
            22367415,
            22354851,
            22353195,
            22355191,
            22354766,
            22354567,
            22355616,
            22355720
        ],
        "C": [
            22346894,
            22348992,
            22348428,
            22346364,
            22349019,
            22347742,
            22344273,
            22349093,
            22344153,
            22348276,
            22349914,
            22349222,
            22351285,
            22350460,
            22350277,
            22351065,
            22348263,
            22347006,
            22351260,
            22349703
        ],
        "B": [
            22345266,
            22344047,
            22346326,
            22344623,
            22347286,
            22345951,
            22346273,
            22346654,
            22345815,
            22347161,
            22347731,
            22346343,
            22348170,
            22348193,
            22348953,
            22349108,
            22345433,
            22343951,
            22343981,
            22347679
        ],
        "A": [
            22344335,
            22346876,
            22344812,
            22348251,
            22345241,
            22344610,
            22348244,
            22344836,
            22349514,
            22345867,
            22345524,
            22349952,
            22345718,
            22346457,
            22347708,
            22346937,
            22344148,
            22348610,
            22348383,
            22345809
        ],
        "F": [
            22363265,
            22374526
        ],
        "E": [
            22411333
        ]
    },
    "name": "E. Tanya is 5 ",
    "statement": "Tanya is now five so all her friends gathered together to celebrate her\r\nbirthday. There are children on the celebration, including Tanya.The\r\ncelebration is close to its end, and the last planned attraction is\r\ngaming machines. There are machines in the hall, they are numbered\r\nthrough . Each of the children has a list of machines he wants to play\r\non. Moreover, for each of the machines he knows the exact time he wants\r\nto play on it. For every machine, no more than one child can play on\r\nthis machine at the same time.It is evening already, so every adult\r\nwants to go home. To speed up the process, you can additionally rent\r\nsecond copies of each of the machines. To rent the second copy of the\r\n-th machine, you have to pay burles. After you rent a machine, you can\r\nuse it for as long as you want.How long it will take to make every child\r\nplay according to his plan, if you have a budget of burles for renting\r\nadditional machines? There is only one copy of each machine, so it\u2019s\r\nimpossible to rent a third machine of the same type.The children can\r\ninterrupt the game in any moment and continue it later. If the -th child\r\nwants to play on the -th machine, it is allowed after you rent the copy\r\nof the -th machine that this child would play some part of the time on\r\nthe -th machine and some part of the time on its copy (each of these\r\nparts could be empty). The interruptions and changes take no time and\r\ncan be performed in any integer moment of time. Of course, a child can\u2019t\r\nplay on more than one machine at the same time.Remember, that it is not\r\nneeded to save money (no one saves money at the expense of children\r\nhappiness!), it is needed to minimize the latest moment of time some\r\nchild ends his game.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 45;\nint n, m, b;\nint c[maxn];\nint w[maxn][maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &m, &b) < 3) {\n    return false;\n  }\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d\", &c[i]);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2 * m; j++) {\n      w[i][j] = 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for (int j = 0; j < k; j++) {\n      int id, t;\n      scanf(\"%d%d\", &id, &t);\n      id--;\n      w[i][2 * id] = t;\n    }\n  }\n  return true;\n}\n\nint maxdeg;\nint take[maxn];\nvector< pair<pair<int, int>, pair<int, int> > > ans;\nvector<int> g[2][maxn];\nint p[2][maxn];\nint deg[2][maxn];\nint used[maxn];\n\nbool dfs(int t, int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[t][v]); i++) {\n    int u = g[t][v][i];\n    if (p[!t][u] == -1 || deg[t][p[!t][u]] < maxdeg) {\n      if (p[!t][u] != -1) {\n        p[t][p[!t][u]] = -1;\n      }\n      p[!t][u] = v;\n      p[t][v] = u;\n      return true;\n    }\n  }\n  for (int i = 0; i < sz(g[t][v]); i++) {\n    int u = g[t][v][i];\n    if (!used[p[!t][u]] && dfs(t, p[!t][u])) {\n      p[!t][u] = v;\n      p[t][v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve() {\n  for (int i = 0; i < m; i++) {\n    take[i] = false;\n  }\n  while (true) {\n    bool change = false;\n    int t = 0;\n    for (int i = 0; i < n; i++) {\n      int cur = 0;\n      for (int j = 0; j < 2 * m; j++) {\n        cur += w[i][j];\n      }\n      t = max(t, cur);\n    }\n    for (int i = 0; i < 2 * m; i++) {\n      int cur = 0;\n      for (int j = 0; j < n; j++) {\n        cur += w[j][i];\n      }\n      t = max(t, cur);\n    }\n    for (int i = 0; i < m; i++) {\n      if (take[i] || c[i] > b) {\n        continue;\n      }\n      int cur = 0;\n      for (int j = 0; j < n; j++) {\n        cur += w[j][2 * i];\n      }\n      if (cur < t) {\n        continue;\n      }\n      int tomove = t / 2;\n      for (int j = 0; j < n; j++) {\n        int x = min(tomove, w[j][2 * i]);\n        w[j][2 * i] -= x;\n        w[j][2 * i + 1] += x;\n        tomove -= x;\n      }\n      take[i] = true;\n      b -= c[i];\n      change = true;\n    }\n    if (!change) {\n      break;\n    }\n  }\n  ans.clear();\n  int t = 0;\n  while (true) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < max(n, 2 * m); j++) {\n        g[i][j].clear();\n        p[i][j] = -1;\n        deg[i][j] = 0;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 2 * m; j++) {\n        deg[0][i] += w[i][j];\n        deg[1][j] += w[i][j];\n        if (w[i][j]) {\n          g[0][i].push_back(j);\n          g[1][j].push_back(i);\n        }\n      }\n    }\n    maxdeg = 0;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < max(n, 2 * m); j++) {\n        maxdeg = max(maxdeg, deg[i][j]);\n      }\n    }\n    if (!maxdeg) {\n      break;\n    }\n    for (int i = 0; i < 2; i++) {\n      int vs = (i ? 2 * m : n);\n      for (int j = 0; j < vs; j++) {\n        if (deg[i][j] == maxdeg && p[i][j] == -1) {\n          for (int k = 0; k < vs; k++) {\n            used[k] = false;\n          }\n          dfs(i, j);\n        }\n      }\n    }\n    int ndeg = 0;\n    for (int i = 0; i < 2; i++) {\n      int vs = (i ? 2 * m : n);\n      for (int j = 0; j < vs; j++) {\n        if (p[i][j] == -1) {\n          ndeg = max(ndeg, deg[i][j]);\n        }\n      }\n    }\n    int minw = inf;\n    for (int i = 0; i < n; i++) {\n      if (p[0][i] != -1) {\n        minw = min(minw, w[i][p[0][i]]);\n      }\n    }\n    int curt = min(minw, maxdeg - ndeg);\n    for (int i = 0; i < n; i++) {\n      if (p[0][i] != -1) {\n        ans.push_back(make_pair(make_pair(i + 1, p[0][i] / 2 + 1), make_pair(t, curt)));\n        w[i][p[0][i]] -= curt;\n      }\n    }\n    t += curt;\n  }\n  printf(\"%d\\n\", t);\n  for (int i = 0; i < m; i++) {\n    printf(\"%d\", take[i]);\n  }\n  printf(\"\\n%d\\n\", sz(ans));\n  for (int i = 0; i < sz(ans); i++) {\n    printf(\"%d %d %d %d\\n\", ans[i].first.first, ans[i].first.second, ans[i].second.first, ans[i].second.second);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graph matchings",
        "graphs",
        "greedy",
        "schedules"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Tanya is 5 .json",
    "editorial_link": "https://codeforces.com//blog/entry/48501",
    "editorial": "At first let\u00e2\u0080\u0099s solve this problem in simplified form: let there is no\r\nduplicate machines (in the other word it does not enough the budget to\r\nrent any duplicate).We consider, that each kid would like to play in\r\neach machine. Let in such case. So, we consider, that the values of is a\r\nrectangular table for each pair kid/machine in the cell written down the\r\ntime of the game.Note that minimal time when all games will ended does\r\nnot less than sum of values in each row . Similarly, the minimal time\r\nwhen all games will ended does not less than the sum in each column ,\r\nbecause on each machine in one moment of time can play no more than one\r\nkid.Because of that the minimal time does not less than . Note that\r\nthere is always such a schedule that needed minimal time equals to\r\nmaximum of all rows sums and all columns sums. Let\u00e2\u0080\u0099s call this value\r\n.Now we need to show this fact and consider the way to get this\r\nschedule.Let\u00e2\u0080\u0099s build the weighted bipartite graph. In each part of this\r\ngraph is vertices. Let\u00e2\u0080\u0099s assume that each machine has a fake kid (i. e.\r\nnow we have kids) real and fake kids. The vertices from the first part\r\nwill for kids: for real kids and for fake kids, and is a fake kid for\r\nthe machine .Similarly, let consider that each kid has a fake machine\r\n(totally there will be machines). The vertices from the second part will\r\nfor machines: the first vertices is for real machines (), and following\r\nfor fakt machines (). The vertex will for the fake machine of kid .Let\u00e2\u0080\u0099s\r\nmake the edges. We will have 4 types of edges: between the real kids and\r\nthe real machines, between the fake kids and the real machines, between\r\nthe real kids and the fake machines, between the fake kids and the fake\r\nmachines. We need to make the edges in such a way that the sum of\r\nweights of incident edges for each vertex is equals to .The edges of\r\ntype 1. Let\u00e2\u0080\u0099s add the edge between and , if . the weight is . This edge\r\nmeans that the kid must play on the machine needed number of minutes.The\r\nedges of type 2. This edges mean that the machine will has downtime\r\nequals to some number of minutes (in the other words in downtime the\r\nfake kid will play on this machine). For all from 1 to let\u00e2\u0080\u0099s find . If\r\nsuch vertices is positive, then we need to add edge between with such\r\nweight.The edges of type 3. This edges mean that the kid will have time,\r\nwhen he does not play (we consider that in this time the kid play on the\r\nfake machine). For all from 1 to let\u00e2\u0080\u0099s find . If this value is positive\r\nwe add edge between and with such weight.The edges of type 4. After we\r\nadded the edges of types 1-3 it is easy to show that the sum of weights\r\nof incident edges equal to . For the vertices this sum now less or equal\r\nto . Let\u00e2\u0080\u0099s add remaining edges to make this sums equal to . It\u00e2\u0080\u0099s always\r\npossible if we add this edges in greedy way.We know the following fact:\r\nin any regular bipartite graph there is a perfect matching (a\r\nconsequence of the Hall\u00e2\u0080\u0099s theorem).If we look on the given graph like on\r\nthe unweighted multigraph where the weight of the edge in our graph\r\nequals to the number of edges between the pair of vertices, then the\r\nresulting graph will be regular graph and for it will be correct\r\ndescribed fact (i. e. there is perfect matching in this graph).Let\u00e2\u0080\u0099s\r\nfind the perfect matching with help of the Kuhn\u00e2\u0080\u0099s algorithm in weighted\r\ngraph. Let\u00e2\u0080\u0099s choose the weight of the minimal edge and it is equals to .\r\nThen let\u00e2\u0080\u0099s appoint kids on machines for each edge between the vertices\r\non the time . Also let\u00e2\u0080\u0099s subtract from the weight of each edge of the\r\nmatching. If the weight of the edge became 0, we delete this edge.After\r\nthat it is correct the sum for each vertices is a constant. It means\r\nthat the remaining graph has the perfect matching. We need to make with\r\nthis graph similar operations, which was described above.Let\u00e2\u0080\u0099s do it\r\nuntil the graph contains at least one edge. So we found needed\r\nschedule.To make the solution faster we can rebuild the matching from\r\nthe unsaturated vertices from the first part if such vertices exist.\r\nThis algorithm will works totally in , where is the number of edges in\r\nthe beginning, i. e. , so the asymptotic behavior is ). In this problem\r\nthere were small restricts so we could build the matching with Kuhn\u00e2\u0080\u0099s\r\nalgorithm.By the way we build the optimal painting of the bipartite\r\ngraph. Here we can use the well known algorithm (read about the optimal\r\npainting of the bipartite graph).So, we solved the problem without rent\r\nthe duplicates. Besides it, the value of the answer is a maximum from\r\nall sums of rows and columns of the table with times for pairs\r\nkid/machine.If we have a duplicated it equals to adding the column in\r\nwhich we can partially distribute the values from this column. Of\r\ncourse, it is profitably to make it with columns which sum (i. e. the\r\nanswer rests in this column). This operation makes sense only if we make\r\nit for all columns with simultaneously.The algorithm to choose of\r\nmachines to rent follows. Let\u00e2\u0080\u0099s find the sum of rent for all machines\r\nwith . If this value less or equal to the budget than we must rent this\r\nmachines. Then add the appropriate columns in the table and put as\r\nevenly as possible the values of the duplicated columns. Recalculate .\r\nRepeat the process and end it when the sum of rent for each operation\r\nbecame more than .\r\n"
}