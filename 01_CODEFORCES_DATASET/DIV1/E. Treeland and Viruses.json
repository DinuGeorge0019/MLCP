{"link": "https://codeforces.com//contest/1320/problem/E", "problemId": "551757", "problem_idx": "E", "shortId": "1320E", "contest_number": "1320", "problem_submissions": {"F": [72202332, 72223011, 72205107, 72198337, 72222998, 72196293, 72223902], "E": [72193224, 72190175, 72191679, 72192473, 72195171, 89517976, 72207354, 72207256, 72196434, 72194256, 72192283, 72199164, 72195289, 72197732, 72223673, 72193338, 72195901, 72200544, 72200353, 72200814, 72198992, 72200456], "C": [72184867, 72177670, 72177948, 72173628, 72175737, 72172966, 72176352, 72179230, 72175568, 72177066, 72173843, 72175840, 72176052, 72179445, 72190361, 72188981, 72179839, 72183510, 72186001, 72181401], "B": [72179476, 72169823, 72171581, 72177394, 72169041, 72168596, 72168669, 72172513, 72171074, 72169530, 72169385, 72171115, 72178856, 72172293, 72186108, 72169156, 72173456, 72185954, 72172093, 72178248], "D": [72176425, 72181800, 72183448, 72260282, 72184393, 72182092, 72185033, 72188594, 72279361, 72184633, 72186338, 72185288, 72188013, 72184398, 72189053, 72517140, 72199444, 72180732, 72186150, 72193094, 72172140, 72191769, 72190479], "A": [72166896, 72166972, 72167131, 72166858, 72166891, 72166853, 72166967, 72167271, 72166947, 72166915, 72167040, 72167216, 72167056, 72167066, 72166886, 72170109, 72167510, 72181754, 72167043, 72167049]}, "name": "E. Treeland and Viruses", "statement": "There are n cities in Treeland connected with n - 1 bidirectional roads\r\nin such that a way that any city is reachable from any other; in other\r\nwords, the graph of cities and roads is a tree. Treeland is preparing\r\nfor a seasonal virus epidemic, and currently, they are trying to\r\nevaluate different infection scenarios.In each scenario, several cities\r\nare initially infected with different virus species. Suppose that there\r\nare k_i virus species in the i-th scenario. Let us denote v_j the\r\ninitial city for the virus j, and s_j the propagation speed of the virus\r\nj. The spread of the viruses happens in turns: first virus 1 spreads,\r\nfollowed by virus 2, and so on. After virus k_i spreads, the process\r\nstarts again from virus 1.A spread turn of virus j proceeds as follows.\r\nFor each city x not infected with any virus at the start of the turn, at\r\nthe end of the turn it becomes infected with virus j if and only if\r\nthere is such a city y that: city y was infected with virus j at the\r\nstart of the turn; the path between cities x and y contains at most s_j\r\nedges; all cities on the path between cities x and y (excluding y) were\r\nuninfected with any virus at the start of the turn.Once a city is\r\ninfected with a virus, it stays infected indefinitely and can not be\r\ninfected with any other virus. The spread stops once all cities are\r\ninfected.You need to process q independent scenarios. Each scenario is\r\ndescribed by k_i virus species and m_i important cities. For each\r\nimportant city determine which the virus it will be infected by in the\r\nend.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate<class T>\nstruct RMQ {\n\tvector<vector<T>> jmp;\n\n\tRMQ(const vector<T>& V) {\n\t\tint N = sz(V), on = 1, depth = 1;\n\t\twhile (on < sz(V)) on *= 2, depth++;\n\t\tjmp.assign(depth, V);\n\t\trep(i,0,depth-1) rep(j,0,N)\n\t\t\tjmp[i+1][j] = min(jmp[i][j],\n\t\t\tjmp[i][min(N - 1, j + (1 << i))]);\n\t}\n\n\tT query(int a, int b) {\n\t\tassert(a < b); // or return inf if a == b\n\t\tint dep = 31 - __builtin_clz(b - a);\n\t\treturn min(jmp[dep][a], jmp[dep][b - (1 << dep)]);\n\t}\n};\n\ntypedef vector<pii> vpi;\ntypedef vector<vpi> graph;\n\nstruct LCA {\n\tvi time;\n\tvector<ll> dist;\n\tRMQ<pii> rmq;\n\n\tLCA(graph& C) : time(sz(C), -99), dist(sz(C)), rmq(dfs(C)) {}\n\n\tvpi dfs(graph& C) {\n\t\tvector<tuple<int, int, int, ll>> q(1);\n\t\tvpi ret;\n\t\tint T = 0, v, p, d; ll di;\n\t\twhile (!q.empty()) {\n\t\t\ttie(v, p, d, di) = q.back();\n\t\t\tq.pop_back();\n\t\t\tif (d) ret.emplace_back(d, p);\n\t\t\ttime[v] = T++;\n\t\t\tdist[v] = di;\n\t\t\ttrav(e, C[v]) if (e.first != p)\n\t\t\t\tq.emplace_back(e.first, v, d+1, di + e.second);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint query(int a, int b) {\n\t\tif (a == b) return a;\n\t\ta = time[a], b = time[b];\n\t\treturn rmq.query(min(a, b), max(a, b)).second;\n\t}\n\tll distance(int a, int b) {\n\t\tint lca = query(a, b);\n\t\treturn dist[a] + dist[b] - 2 * dist[lca];\n\t}\n};\n\nvpi compressTree(LCA& lca, const vi& subset) {\n\tstatic vi rev; rev.resize(sz(lca.dist));\n\tvi li = subset, &T = lca.time;\n\tauto cmp = [&](int a, int b) { return T[a] < T[b]; };\n\tsort(all(li), cmp);\n\tint m = sz(li)-1;\n\trep(i,0,m) {\n\t\tint a = li[i], b = li[i+1];\n\t\tli.push_back(lca.query(a, b));\n\t}\n\tsort(all(li), cmp);\n\tli.erase(unique(all(li)), li.end());\n\trep(i,0,sz(li)) rev[li[i]] = i;\n\tvpi ret = {pii(0, li[0])};\n\trep(i,0,sz(li)-1) {\n\t\tint a = li[i], b = li[i+1];\n\t\tret.emplace_back(rev[lca.query(a, b)], b);\n\t}\n\treturn ret;\n}\n\nconst int MAXN = 1e6;\nint which_v[MAXN];\nint which_c[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph g(n);\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].push_back({v, 1});\n\t\tg[v].push_back({u, 1});\n\t}\n\tLCA lca(g);\n\tint Q;\n\tcin >> Q;\n\tfor(int _ = 0; _ < Q; _++){\n\t\tint k, m;\n\t\tcin >> k >> m;\n\t\tvector<int> vst(k);\n\t\tvector<int> speed(k);\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tcin >> vst[i] >> speed[i];\n\t\t\tvst[i]--;\n\t\t}\n\t\tvector<int> city(m);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> city[i];\n\t\t\tcity[i]--;\n\t\t}\n\n\t\tvector<int> subset(k+m);\n\t\tfor(int i = 0; i < k; i++){\n\t\t\twhich_v[vst[i]] = i;\n\t\t\tsubset[i] = vst[i];\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\twhich_c[city[i]] = i;\n\t\t\tsubset[i+k] = city[i];\n\t\t};\n\n\t\tvector<pair<int,int> > ct = compressTree(lca, subset);\n\t\tint z = (int)ct.size();\n\t\tvector<vector<int> > cte(z);\n\t\tfor(int i = 0; i < z; i++){\n\t\t\tif(ct[i].first != -1){\n\t\t\t\tcte[ct[i].first].push_back(i);\n\t\t\t\tcte[i].push_back(ct[i].first);\n\t\t\t}\n\t\t}\n\n\t\tvector<int> infect(z, -1);\n\t\tpriority_queue<pair<ll, int> > pq; // time, id, v\n\t\tconst ll B = 1e7;\n\t\tfor(int i = 0; i < z; i++){\n\t\t\tint r = which_v[ct[i].second];\n\t\t\tif(r < 0 || r >= k || vst[r] != ct[i].second) continue;\n\t\t\tpq.push({-(B * 0 + r), i});\n\t\t}\n\t\twhile(!pq.empty()){\n\t\t\tpair<ll, int> x = pq.top();\n\t\t\tpq.pop();\n\t\t\tint v = x.second;\n\t\t\tif(infect[v] != -1) continue;\n\t\t\tint id = (-x.first) % B;\n\t\t\tinfect[v] = id;\n\t\t\tfor(int w : cte[v]){\n\t\t\t\tint time = 1 + (lca.distance(vst[id], ct[w].second) - 1) / speed[id];\n\t\t\t\tpq.push({-(B * time + id), w});\n\t\t\t}\n\t\t}\n\t\tvector<int> ans(m, -1);\n\t\tfor(int i = 0; i < z; i++){\n\t\t\tint r = which_c[ct[i].second];\n\t\t\tif(r < 0 || r >= m || city[r] != ct[i].second) continue;\n\t\t\tans[r] = infect[i];\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcout << ans[i] + 1 << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dp", "shortest paths", "trees"], "dificulty": "3000", "interactive": false}