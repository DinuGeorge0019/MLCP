{
    "link": "https://codeforces.com//contest/111/problem/D",
    "problemId": "586",
    "problem_idx": "D",
    "shortId": "111D",
    "contest_number": "111",
    "problem_submissions": {
        "D": [
            662767,
            662482,
            660714,
            662088,
            661622,
            661475,
            663213,
            662999,
            665139,
            663475,
            663580,
            663102,
            662156,
            662688,
            662062,
            663791,
            664321,
            664054,
            663134
        ],
        "C": [
            661017,
            660823,
            662136,
            659868,
            659913,
            660005,
            659563,
            660967,
            661428,
            660790,
            660974,
            661489,
            661410,
            663647,
            661449,
            661359,
            661322,
            659593
        ],
        "B": [
            658508,
            658276,
            660241,
            658067,
            658492,
            662345,
            658611,
            659356,
            658769,
            658223,
            658207,
            662686,
            663419,
            662647,
            660010,
            659052,
            661996,
            664110
        ],
        "A": [
            657728,
            657568,
            657631,
            658791,
            657382,
            657971,
            657490,
            657859,
            657378,
            659022,
            657338,
            658706,
            657670,
            657472,
            659525,
            659462,
            664166
        ]
    },
    "name": "D. Petya and Coloring",
    "statement": "Little Petya loves counting. He wants to count the number of ways to\r\npaint a rectangular checkered board of size ( rows, columns) in colors.\r\nBesides, the coloring should have the following property: for any\r\nvertical line that passes along the grid lines and divides the board in\r\ntwo non-empty parts the number of distinct colors in both these parts\r\nshould be the same. Help Petya to count these colorings.\r\n",
    "solutions": [
        "// Authored by dolphinigle\n// CodeForces 83\n// 3 Sep 2011\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define FORN(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define DEBUG(x) cout << '>' << #x << ':' << x << '\\n';\n\n#define REP(X,Y,Z) for (int (X) = (Y);(X) < (Z);++(X))\n#define RESET(Z,Y) memset(Z,Y,sizeof(Z))\n\n#define SZ(Z) ((int)Z.size())\n#define ALL(W) W.begin(), W.end()\n#define PB push_back\n\n#define MP make_pair\n#define A first\n#define B second\n\n#define INF 1023123123\n#define EPS 1e-11\n\n#define MX(Z,Y) Z = max((Z),(Y))\n#define MN(X,Y) X = min((X),(Y))\n\n#define FORIT(X,Y) for(typeof((Y).begin()) X = (Y).begin();X!=(Y).end();X++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\n\n//(number**exponent) % ivalue;\nll Power(ll number,ll exponent,ll ivalue) {\n\tll ret = 1;\n\tll multiplier = number;\n\twhile (exponent > 0LL) {\n\t\tif (exponent % 2LL) {\n      ret = (ret * multiplier) % ivalue;\n    }\n\t\texponent /= 2LL;\n\t\tmultiplier = (multiplier * multiplier) % ivalue;\n  }\n\treturn ret;\n}\n\n//works if modulo >= 2\nll MultiplicativeInverse(ll number, ll ivalue) {\n\treturn Power(number, ivalue - 2LL, ivalue);\n}\n\nll FastCombination(ll from, ll pick, ll ivalue, bool reset = false) {\n  static vector<ll> fact, rfact;\n  if (reset) fact = rfact = vector<ll>(0);\n  if (SZ(fact) == 0LL) {\n    fact.PB(1LL);\n    rfact.PB(1LL);\n  }\n  if (pick > from) return 0LL;\n  ll table_size = max(from, max(pick, from-pick));\n  while (SZ(fact) <= table_size) {\n    fact.PB((fact.back() * (ll)SZ(fact)) % ivalue);\n    rfact.PB(MultiplicativeInverse(fact.back(), ivalue));\n  }\n\tll jahja = (fact[from] * rfact[pick]) % ivalue;\n  return (jahja * rfact[from-pick]) % ivalue;\n}\n// O(max(from, pick)).\n// Assumes that ivalue will always be the same. To reset, use the\n// reset flag.\n\nvector<ll> Factorial(ll number, ll ivalue) {\n  vector<ll> factorial;\n  factorial.PB(1LL);\n  for (int i = 1; i <= number; ++i) {\n    factorial.PB((factorial.back() * (ll)i) % ivalue);\n  }\n  return factorial;\n}\n// vector<ll> fact = Factorial(4, 20);\n// fact[3] == 6 % 20 == 6\n// fact[4] == 24 % 20 == 4\n\nll modu = 1000000007LL;\n\nll dp[1050][1050]; // rows, distinct colors\n\n\n\nint main() {\n\n  int row, col, colors;\n  cin >> row >> col >> colors;\n  if (col == 1) {\n    cout << Power(colors, row, modu) << endl;\n    return 0;\n  }\n\n  FORN(i, 1050) FORN(j, 1050) dp[i][j] = 0LL;\n  dp[0][0] = 1LL;\n  for (int i = 0; i < 1040; ++i) for (int j = 0; j < 1040; ++j) {\n    if (dp[i][j] == 0LL) continue;\n    // reuse\n    dp[i+1][j] = (dp[i+1][j] + ((dp[i][j] * (ll)j) % modu)) % modu;\n    // new\n    dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % modu;\n  }\n\n  if (col == 2) {\n    ll ret = 0LL;\n    ll mult = 1LL;\n    for (ll i = 1; i <= min(row, colors); ++i) {\n      mult *= (ll)(colors - i + 1);\n      mult %= modu;\n      ll sol = mult * dp[row][i];\n      sol %= modu;\n      sol *= sol;\n      sol %= modu;\n      ret += sol;\n      ret %= modu;\n    }\n    cout << ret << endl;\n    return 0;\n  }\n\n  vector<ll> fact = Factorial(1050, modu);\n\n  ll midtot = row * (col-2);\n\n  vector<ll> pangkat1000;\n  FORN(i, 1050) {\n    pangkat1000.push_back(Power(i, midtot, modu));\n  }\n\n  ll ret = 0;\n  for (ll total = 1; total <= min(row, colors); ++total) {\n    for (ll equal = 1; equal <= total; ++equal) {\n      ll distinct = total - equal;\n      if (distinct + distinct + equal > colors) continue;\n      ll sol = 1LL;\n      // ambil yg distinct, distinct, sama equal\n      sol *= FastCombination(colors, distinct, modu);\n      sol %= modu;\n      sol *= FastCombination(colors-distinct, distinct, modu);\n      sol %= modu;\n      sol *= FastCombination(colors-distinct-distinct, equal, modu);\n      sol %= modu;\n      // urutan buat yg kiri sama kanan\n      sol *= fact[distinct + equal];\n      sol %= modu;\n      sol *= fact[distinct + equal];\n      sol %= modu;\n      sol *= dp[row][distinct + equal];\n      sol %= modu;\n      sol *= dp[row][distinct + equal];\n      sol %= modu;\n      // yg tengah2\n      sol *= pangkat1000[equal];\n      sol %= modu;\n      ret += sol;\n      ret %= modu;\n    }\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Petya and Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/2616",
    "editorial": "One can notice that if m?=?1 then the answer is kn, because all colorings are possible.\nNow well assume that m > 1. Lets look on the first column of the board (i.e. the vertical cut will be made right next to the first column). Suppose there are x distinct colors in this column. Then in the rest of the board there are also x colors. If we move the vertical line by one unit to the right, the number of different colors to the left of it will not decrease and the number of colors to the right of it wont increase. It means that the number of different colors in both parts of the board will be also x. We can repeat this process until the line reaches the rightmost column, which means that the number of distinct colors in it is also x. It is easy to see that we can only use colors which belong to the intersection of sets of colors in the leftmost and rightmost columns in the rest of the board.\n\n\nLets iterate over all values of x and y, where x is the number of colors in the leftmost column and y is the number of elements in intersection of sets of colors in the rightmost and leftmost columns. It is easy to see that x is limited by the number of rows in the board and y cant be greater than x. Lets find the answer for all such pairs of x and y and at the end well add them up together.\n\n \n\nSuppose x and y are fixed. We first need to choose (2x - y) colors from the given k colors, which we will use, which means that the answer for will be multiplied by C(k, 2x  y). After that well choose (x-y) unique colors which will be used in the first column, which means that the answer will be also multiplied by C(2x-y, x-y). Then well choose x-y colors for the rightmost column and multiply the answer by C(x, x-y). Now all we need to know is how many ways of coloring n cells into x colors are there. Well use a dynamic programming approach to solve this sub-problem.\n\n \n\nLet d[i][j] be the number of ways to color a rectangle of unit width and length i into colors, numerated from 1 to j with the following restriction: if a < b then the first appearence of color a in the rectangle will be before the first appearence of color b.\nThen we can calculate this function using the following recurrence:\n\nd[i][j] = j * d[i  1][j] + d[i  1][j  1].\n\nAfter we finish calculating d[i][j], we need to multiply the answer by d[n][x]2 (to color the first and the last columns). Now we need to notice that we can reorder all colors in the first and the last columns in arbitrary way, which means that the answer should be multiplied by (x!)2. Finally, we need to multiply the answer by yn(m-2), which correspond to coloring the rest of our board.",
    "hint": []
}