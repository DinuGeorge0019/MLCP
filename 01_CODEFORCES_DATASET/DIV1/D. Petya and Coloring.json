{"link": "https://codeforces.com//contest/111/problem/D", "problemId": "586", "problem_idx": "D", "shortId": "111D", "contest_number": "111", "problem_submissions": {"D": [662767, 662482, 660714, 662088, 661622, 661475, 663213, 662999, 665139, 663475, 663580, 663102, 662156, 662688, 662062, 663791, 664321, 664054, 663134], "C": [661017, 660823, 662136, 659868, 659913, 660005, 659563, 660967, 661428, 660790, 660974, 661489, 661410, 663647, 661449, 661359, 661322, 659593], "B": [658508, 658276, 660241, 658067, 658492, 662345, 658611, 659356, 658769, 658223, 658207, 662686, 663419, 662647, 660010, 659052, 661996, 664110], "A": [657728, 657568, 657631, 658791, 657382, 657971, 657490, 657859, 657378, 659022, 657338, 658706, 657670, 657472, 659525, 659462, 664166]}, "name": "D. Petya and Coloring", "statement": "Little Petya loves counting. He wants to count the number of ways to\r\npaint a rectangular checkered board of size ( rows, columns) in colors.\r\nBesides, the coloring should have the following property: for any\r\nvertical line that passes along the grid lines and divides the board in\r\ntwo non-empty parts the number of distinct colors in both these parts\r\nshould be the same. Help Petya to count these colorings.\r\n", "solutions": ["// Authored by dolphinigle\n// CodeForces 83\n// 3 Sep 2011\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define FORN(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define DEBUG(x) cout << '>' << #x << ':' << x << '\\n';\n\n#define REP(X,Y,Z) for (int (X) = (Y);(X) < (Z);++(X))\n#define RESET(Z,Y) memset(Z,Y,sizeof(Z))\n\n#define SZ(Z) ((int)Z.size())\n#define ALL(W) W.begin(), W.end()\n#define PB push_back\n\n#define MP make_pair\n#define A first\n#define B second\n\n#define INF 1023123123\n#define EPS 1e-11\n\n#define MX(Z,Y) Z = max((Z),(Y))\n#define MN(X,Y) X = min((X),(Y))\n\n#define FORIT(X,Y) for(typeof((Y).begin()) X = (Y).begin();X!=(Y).end();X++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\n\n//(number**exponent) % ivalue;\nll Power(ll number,ll exponent,ll ivalue) {\n\tll ret = 1;\n\tll multiplier = number;\n\twhile (exponent > 0LL) {\n\t\tif (exponent % 2LL) {\n      ret = (ret * multiplier) % ivalue;\n    }\n\t\texponent /= 2LL;\n\t\tmultiplier = (multiplier * multiplier) % ivalue;\n  }\n\treturn ret;\n}\n\n//works if modulo >= 2\nll MultiplicativeInverse(ll number, ll ivalue) {\n\treturn Power(number, ivalue - 2LL, ivalue);\n}\n\nll FastCombination(ll from, ll pick, ll ivalue, bool reset = false) {\n  static vector<ll> fact, rfact;\n  if (reset) fact = rfact = vector<ll>(0);\n  if (SZ(fact) == 0LL) {\n    fact.PB(1LL);\n    rfact.PB(1LL);\n  }\n  if (pick > from) return 0LL;\n  ll table_size = max(from, max(pick, from-pick));\n  while (SZ(fact) <= table_size) {\n    fact.PB((fact.back() * (ll)SZ(fact)) % ivalue);\n    rfact.PB(MultiplicativeInverse(fact.back(), ivalue));\n  }\n\tll jahja = (fact[from] * rfact[pick]) % ivalue;\n  return (jahja * rfact[from-pick]) % ivalue;\n}\n// O(max(from, pick)).\n// Assumes that ivalue will always be the same. To reset, use the\n// reset flag.\n\nvector<ll> Factorial(ll number, ll ivalue) {\n  vector<ll> factorial;\n  factorial.PB(1LL);\n  for (int i = 1; i <= number; ++i) {\n    factorial.PB((factorial.back() * (ll)i) % ivalue);\n  }\n  return factorial;\n}\n// vector<ll> fact = Factorial(4, 20);\n// fact[3] == 6 % 20 == 6\n// fact[4] == 24 % 20 == 4\n\nll modu = 1000000007LL;\n\nll dp[1050][1050]; // rows, distinct colors\n\n\n\nint main() {\n\n  int row, col, colors;\n  cin >> row >> col >> colors;\n  if (col == 1) {\n    cout << Power(colors, row, modu) << endl;\n    return 0;\n  }\n\n  FORN(i, 1050) FORN(j, 1050) dp[i][j] = 0LL;\n  dp[0][0] = 1LL;\n  for (int i = 0; i < 1040; ++i) for (int j = 0; j < 1040; ++j) {\n    if (dp[i][j] == 0LL) continue;\n    // reuse\n    dp[i+1][j] = (dp[i+1][j] + ((dp[i][j] * (ll)j) % modu)) % modu;\n    // new\n    dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % modu;\n  }\n\n  if (col == 2) {\n    ll ret = 0LL;\n    ll mult = 1LL;\n    for (ll i = 1; i <= min(row, colors); ++i) {\n      mult *= (ll)(colors - i + 1);\n      mult %= modu;\n      ll sol = mult * dp[row][i];\n      sol %= modu;\n      sol *= sol;\n      sol %= modu;\n      ret += sol;\n      ret %= modu;\n    }\n    cout << ret << endl;\n    return 0;\n  }\n\n  vector<ll> fact = Factorial(1050, modu);\n\n  ll midtot = row * (col-2);\n\n  vector<ll> pangkat1000;\n  FORN(i, 1050) {\n    pangkat1000.push_back(Power(i, midtot, modu));\n  }\n\n  ll ret = 0;\n  for (ll total = 1; total <= min(row, colors); ++total) {\n    for (ll equal = 1; equal <= total; ++equal) {\n      ll distinct = total - equal;\n      if (distinct + distinct + equal > colors) continue;\n      ll sol = 1LL;\n      // ambil yg distinct, distinct, sama equal\n      sol *= FastCombination(colors, distinct, modu);\n      sol %= modu;\n      sol *= FastCombination(colors-distinct, distinct, modu);\n      sol %= modu;\n      sol *= FastCombination(colors-distinct-distinct, equal, modu);\n      sol %= modu;\n      // urutan buat yg kiri sama kanan\n      sol *= fact[distinct + equal];\n      sol %= modu;\n      sol *= fact[distinct + equal];\n      sol %= modu;\n      sol *= dp[row][distinct + equal];\n      sol %= modu;\n      sol *= dp[row][distinct + equal];\n      sol %= modu;\n      // yg tengah2\n      sol *= pangkat1000[equal];\n      sol %= modu;\n      ret += sol;\n      ret %= modu;\n    }\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2300", "interactive": false}