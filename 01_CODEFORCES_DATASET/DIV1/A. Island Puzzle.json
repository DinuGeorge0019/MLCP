{
    "link": "https://codeforces.com//contest/634/problem/A",
    "problemId": "49944",
    "problem_idx": "A",
    "shortId": "634A",
    "contest_number": "634",
    "problem_submissions": {
        "E": [
            16414340,
            16416138,
            16413706,
            16414973,
            16415599,
            16414780,
            16415591,
            16416199,
            16416181,
            16416348,
            16415632,
            16415457,
            16416072,
            16413745,
            16466856,
            16413386
        ],
        "D": [
            16411007,
            16410815,
            16412075,
            16411999,
            16412771,
            16413214,
            16412917,
            16413088,
            16413557,
            16414243,
            16411968,
            16413070,
            16413608,
            16410814,
            16411583,
            16411708,
            16418042,
            16411828
        ],
        "C": [
            16409750,
            16409051,
            16410811,
            16409734,
            16410839,
            16411665,
            16411917,
            16411834,
            16411108,
            16413312,
            16410161,
            16411194,
            16417790,
            16416407,
            16409322,
            16410089,
            16410459,
            16409945,
            16409746,
            16410147
        ],
        "B": [
            16408395,
            16409662,
            16410216,
            16408841,
            16409386,
            16409860,
            16410585,
            16409660,
            16410064,
            16408757,
            16417413,
            16417828,
            16409703,
            16408566,
            16409147,
            16409169,
            16409287,
            16410817,
            16408754
        ],
        "A": [
            16407814,
            16407800,
            16408726,
            16407801,
            16408251,
            16407972,
            16407935,
            16408112,
            16408492,
            16407803,
            16407794,
            16408196,
            16407918,
            16407735,
            16407903,
            16407915,
            16407851,
            16408302,
            16407766
        ],
        "F": [
            16417401,
            17066904
        ]
    },
    "name": "A. Island Puzzle",
    "statement": "A remote island chain contains islands, labeled through . Bidirectional\r\nbridges connect the islands to form a simple cycle a bridge connects\r\nislands and , islands and , and so on, and additionally a bridge\r\nconnects islands and . The center of each island contains an identical\r\npedestal, and all but one of the islands has a fragile, uniquely colored\r\nstatue currently held on the pedestal. The remaining island holds only\r\nan empty pedestal.The islanders want to rearrange the statues in a new\r\norder. To do this, they repeat the following process: First, they choose\r\nan island directly adjacent to the island containing an empty pedestal.\r\nThen, they painstakingly carry the statue on this island across the\r\nadjoining bridge and place it on the empty pedestal.Determine if it is\r\npossible for the islanders to arrange the statues in the desired order.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(\"%lf\", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c=='-') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>='0') && (c<='9'))\n\t\t\tx=x*10+c-'0',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nint main()\n{\n\tint n;\n\trint(n);\n\tVI a(n), b(n);\n\tji(n) rint(a[i]);\t\n\tji(n) rint(b[i]);\n\ta.erase(find(a.begin(), a.end(), 0));\n\tb.erase(find(b.begin(), b.end(), 0));\n\tn--;\n\tint idx = 0;\n\twhile (b[idx] != a[0])\n\t\t++idx;\n\tji(n)\n\t{\n\t\tif (a[i] != b[(idx+i)%n])\n\t\t{\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Island Puzzle.json",
    "editorial_link": "https://codeforces.com//blog/entry/43467",
    "editorial": "Notice that, as we move the empty pedestal around the circle, we\r\ncyclically permute the statues (and the empty pedestal can be anywhere).\r\nThus, we can reach one state from another if and only if, after removing\r\nthe empty pedestal, they are cyclic shifts of each other. The starting\r\nand ending configurations are permutations, so we can check this in\r\nlinear time. Runtime:\r\n"
}