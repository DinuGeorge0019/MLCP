{
    "link": "https://codeforces.com//contest/109/problem/D",
    "problemId": "576",
    "problem_idx": "D",
    "shortId": "109D",
    "contest_number": "109",
    "problem_submissions": {
        "E": [
            648441
        ],
        "D": [
            646409,
            647170,
            646652,
            646695,
            646352,
            645873,
            645392,
            646870,
            646386,
            646289,
            645803,
            647324,
            646355,
            647745,
            646444,
            645672
        ],
        "B": [
            644873,
            644785,
            645061,
            644222,
            644364,
            643745,
            643698,
            644283,
            643725,
            646460,
            646874,
            647648,
            646835,
            644816,
            646998,
            647078
        ],
        "C": [
            643742,
            645980,
            645707,
            645639,
            645273,
            644937,
            644325,
            645865,
            644801,
            645032,
            644836,
            644580,
            644697,
            646773,
            644867,
            646558
        ],
        "A": [
            642201,
            642453,
            642373,
            642819,
            642224,
            642165,
            642161,
            642217,
            642304,
            642733,
            643129,
            642289,
            642251,
            642497,
            642687,
            647423
        ]
    },
    "name": "D. Lucky Sorting",
    "statement": "Petya got an array consisting of numbers, it is the gift for his\r\nbirthday. Now he wants to sort it in the non-decreasing order. However,\r\na usual sorting is boring to perform, thatâ€™s why Petya invented the\r\nfollowing limitation: one can swap any two numbers but only if at least\r\none of them is lucky. Your task is to sort the array according to the\r\nspecified limitation. Find any possible sequence of the swaps (the\r\nnumber of operations in the sequence should not exceed ).\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint N;\nint a[100010];\nvector <pair <int, int> > p;\nint to[100010],ot[100010];\n\nbool used[100010];\nvector <pair <int, int> > ans;\n\nbool lucky(int n){\n    while(n > 0){\n        if(n%10 != 4 && n%10 != 7) return false;\n        n /= 10;\n    }\n    return true;\n}\n\nvoid func(int x, int init){\n    if(ot[init] == init){\n        used[init] = true;\n        return;\n    }\n    \n    int cur = init;\n    ans.push_back(make_pair(x,cur));\n    \n    while(1){\n        used[cur] = true;\n        int next = ot[cur];\n        if(next == init){\n            ans.push_back(make_pair(cur,x));\n            break;\n        }\n        ans.push_back(make_pair(cur,next));\n        cur = next;\n    }\n}\n\nint main(void){\n    int i;\n    \n    scanf(\"%d\",&N);\n    REP(i,N) scanf(\"%d\",&a[i]);\n    \n    bool sorted = true;\n    REP(i,N-1) if(a[i] > a[i+1]) sorted = false;\n    if(sorted){\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    int x = -1;\n    REP(i,N) if(lucky(a[i])) x = i;\n    if(x == -1){\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    REP(i,N) p.push_back(make_pair(a[i],i));\n    sort(p.begin(),p.end());\n    REP(i,N) to[p[i].second] = i;\n    REP(i,N) ot[i] = p[i].second;\n    \n    int y = to[x];\n    if(y != x){\n        ans.push_back(make_pair(x,y));\n        int z = to[y];\n        to[x] = z; ot[z] = x; to[y] = y; ot[y] = y;\n        x = y;\n    }\n    \n    used[x] = true;\n    REP(i,N) if(!used[i]) func(x,i);\n    \n    int K = ans.size();\n    printf(\"%d\\n\",K);\n    REP(i,K) printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Lucky Sorting.json",
    "editorial_link": "https://codeforces.com/blog/entry/2547",
    "editorial": "At first, if our array is already sorted, just return 0. Otherwise, if there is no lucky number in A, then output ?-?1. Otherwise, let B is sorted A (array from input). Now, for all numbers in A we know a final position in B. Let k is an index of minimal lucky number in A. If we want to place integer from position i to j, we need A[j] to be lucky number. If is not so, we just Swap(A[j],?A[k]), then A[j] contains lucky number. After that we can Swap(A[i],?A[j]) and number A[i] is on position j. So, to place one number to it's position in B, we need at most two operations and total number that replacements will be not more than n, so answer'll contain at most 2n operations.",
    "hint": []
}