{
    "link": "https://codeforces.com//contest/1314/problem/A",
    "problemId": "547036",
    "problem_idx": "A",
    "shortId": "1314A",
    "contest_number": "1314",
    "problem_submissions": {
        "F": [
            71726158,
            71718843,
            74749593,
            74749152,
            72292726,
            72292697,
            72292343,
            72291510,
            71844196,
            71723876,
            71715422
        ],
        "B": [
            71718479,
            71829904,
            71711385,
            71709524,
            71707913,
            71711558,
            71720310,
            71713846,
            71720222,
            71715032,
            71716531,
            71717545,
            71717755,
            71716805,
            71725696,
            71868147
        ],
        "D": [
            71714124,
            71712892,
            71733906,
            71707801,
            71745171,
            71710988,
            71712453,
            71713369,
            71709321,
            71710231,
            71720852,
            71726797,
            71713255,
            71704334,
            71710718,
            71710921,
            71711996,
            71765821,
            71712181,
            71712148,
            71712872,
            71716965,
            71711644
        ],
        "C": [
            71711319,
            71864827,
            71714264,
            71722928,
            71716523,
            71714295,
            71721162,
            71720891,
            71720482,
            71720726,
            71723585,
            71724431,
            71726919,
            71725565,
            71714331
        ],
        "A": [
            71703192,
            71704610,
            71703253,
            71706188,
            71703791,
            71704145,
            71707166,
            71705278,
            71704520,
            71703175,
            71715214,
            71703215,
            71703413,
            71707725,
            71704018,
            71704745,
            71703715,
            71704666,
            71704097
        ],
        "E": [
            71722513,
            71724911,
            71718902,
            71725474,
            71727007,
            71717687,
            71725550,
            71726599,
            71726820,
            71859582,
            71935297,
            71720287,
            71723370
        ]
    },
    "name": "A. Recommendations",
    "statement": "VK news recommendation system daily selects interesting publications of\r\none of n disjoint categories for each user. Each publication belongs to\r\nexactly one category. For each category i batch algorithm selects a_i\r\npublications.The latest A/B test suggests that users are reading\r\nrecommended publications more actively if each category has a different\r\nnumber of publications within daily recommendations. The targeted\r\nalgorithm can find a single interesting publication of i-th category\r\nwithin t_i seconds. What is the minimum total time necessary to add\r\npublications to the result of batch algorithm execution, so all\r\ncategories have a different number of publications? You can’t remove\r\npublications recommended by the batch algorithm.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<pair<int, int>> p(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i].first;\n  }\n  for (int i = 0; i < n; ++i) {\n    cin >> p[i].second;\n  }\n  sort(p.begin(), p.end());\n  long long ans = 0;\n  for (int i = 0; i < n; ) {\n    priority_queue<int> q;\n    q.push(p[i].second);\n    long long sum = p[i].second;\n    int cur = p[i].first;\n    int j = i + 1;\n    while (true) {\n      while (j < n && p[j].first <= cur) {\n        q.push(p[j].second);\n        sum += p[j++].second;\n      }\n      if ((int) q.size() == 1) {\n        break;\n      }\n      sum -= q.top();\n      ans += sum;\n      q.pop();\n      ++cur;\n    }\n    i = j;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Recommendations.json",
    "editorial_link": "https://codeforces.com//blog/entry/74214",
    "editorial": "In this problem we have an array a1,,an\n, we can increase each ai\n by one with cost ti\n, and we want to make all ai\n different with minimal total cost.\n\nLet's sort ai\n in a non-decreasing way (and permute the t\n in a corresponding way). Let's see at the minimal number, a1\n. If it is unique, e.g. a1?a2\n, then we don't need to change a1\n  it is already unique, and it can't get equal to something else if we don't increase it. In this case, we can just skip a1\n and solve the smaller problem without a1\n.\n\nOtherwise, suppose there is some j>1\n such that a1=a2==aj\n. Obviously, we should leave at most one of them with the current value, and increase other j?1\n numbers by one. Which one should be not increased? We shouldn't increase the al\n (1?l?j\n) with the maximal tl\n because it minimizes the total cost. So, we should remove the maximal value tl\n among all elements with minimal al\n, and increase all other by one. This effectively reduces our problem to the smaller one, decreasing n\n by one.\n\nThis gives us a O(n2)\n solution  n\n times we discard one minimum from the array and increase all other minimums by one. We can further optimize it by using a multiset of values tl\n for all minimal al\n and its sum. At each iteration, we should (probably) add some values to a multiset, if the number of minimums in array increases, discard one maximum from multiset and add the current sum to the answer. Continue the process until the array becomes empty. This is an O(nlogn)\n solution.",
    "hint": []
}