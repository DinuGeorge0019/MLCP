{"link": "https://codeforces.com//contest/778/problem/D", "problemId": "95644", "problem_idx": "D", "shortId": "778D", "contest_number": "778", "problem_submissions": {"D": [25045880, 25060354, 25044951, 25042270, 25047480, 25048926, 25045795, 25045544, 25045486, 25047721, 25047363, 25048949, 25046309, 25047075, 25047917, 25047905, 25036950, 25042732], "E": [25042969, 25046345, 25048943, 25037368, 25230220, 25046363, 25054654, 25048918, 25047591, 25047081], "A": [25035252, 25031242, 25245410, 25036410, 25031451, 25031235, 25031489, 25038781, 25031419, 25031309, 25031692, 25032018, 25031359, 25031871, 25031264, 25031548, 25034117, 25032346, 25031343, 25041816, 25031435], "B": [25034518, 25033704, 25035119, 25035355, 25034840, 25040894, 25042142, 25035930, 25034089, 25038221, 25035530, 25036277, 25035911, 25033345, 25036435, 25039201, 25037280, 25038965, 25040791, 25035608], "C": [25038188, 25041985, 25049416, 25045342, 25039545, 25046412, 25037203, 25040856, 25043392, 25042924, 25041581, 25064524, 25064516, 25064118, 25050637, 25050497, 25042489, 25043145, 25043153, 25044553, 25044592, 25043572, 25044608, 25050488, 25049895]}, "name": "D. Parquet Re-laying", "statement": "Peter decided to lay a parquet in the room of size , the parquet\r\nconsists of tiles of size . When the workers laid the parquet, it became\r\nclear that the tiles pattern looks not like Peter likes, and workers\r\nwill have to re-lay it.The workers decided that removing entire parquet\r\nand then laying it again is very difficult task, so they decided to make\r\nsuch an operation every hour: remove two tiles, which form a square,\r\nrotate them 90 degrees and put them back on the same place. They have no\r\nidea how to obtain the desired configuration using these operations, and\r\nwhether it is possible at all.Help Peter to make a plan for the workers\r\nor tell that it is impossible. The plan should contain at most commands.\r\n", "solutions": ["#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstruct domino\n{\n    int r[2], c[2];\n    domino(int r0, int c0, int r1, int c1)\n    {\n        r[0] = r0;\n        r[1] = r1;\n        c[0] = c0;\n        c[1] = c1;\n    }\n};\n\nstatic vector<pair<int, int>> solve(int R, int C, vector<domino> &dom)\n{\n    int D = SZ(dom);\n    vector<vector<int>> rev(R, vector<int>(C, -1));\n    for (int i = 0; i < D; i++)\n        for (int s = 0; s < 2; s++)\n            rev[dom[i].r[s]][dom[i].c[s]] = i;\n    vector<pair<int, int>> out;\n\n    auto rotate = [&] (int r, int c)\n    {\n        assert(r < R - 1 && c < C - 1);\n        assert((rev[r][c] == rev[r + 1][c] && rev[r][c + 1] == rev[r + 1][c + 1])\n               || (rev[r][c] == rev[r][c + 1] && rev[r + 1][c] == rev[r + 1][c + 1]));\n        int d0 = rev[r][c];\n        int d1 = rev[r + 1][c];\n        if (d1 == d0)\n            d1 = rev[r][c + 1];\n        swap(dom[d0].r[1], dom[d1].r[0]);\n        swap(dom[d0].c[1], dom[d1].c[0]);\n        swap(rev[r][c + 1], rev[r + 1][c]);\n        out.emplace_back(r, c);\n    };\n\nrestart:\n    for (int i = 0; i < R - 1; i++)\n        for (int j = 0; j < C; j++)\n        {\n            int d = rev[i][j];\n            if (dom[d].c[0] == j && dom[d].c[1] == j + 1)\n            {\n                int b0 = rev[i + 1][j];\n                int b1 = rev[i + 1][j + 1];\n                if (b0 == b1)\n                {\n                    rotate(i, j);\n                    goto restart;\n                }\n                else if (dom[b0].r[1] == i + 2\n                         && dom[b1].r[1] == i + 2)\n                {\n                    rotate(i + 1, j);\n                    rotate(i, j);\n                    goto restart;\n                }\n            }\n        }\n    return out;\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int R, C;\n    cin >> R >> C;\n    vector<domino> dom[2];\n    for (int pass = 0; pass < 2; pass++)\n    {\n        for (int i = 0; i < R; i++)\n        {\n            string line;\n            cin >> line;\n            for (int j = 0; j < C; j++)\n            {\n                if (line[j] == 'U')\n                    dom[pass].emplace_back(i, j, i + 1, j);\n                else if (line[j] == 'L')\n                    dom[pass].emplace_back(i, j, i, j + 1);\n            }\n        }\n    }\n\n    bool flip = false;\n    if (R & 1)\n    {\n        swap(R, C);\n        for (int pass = 0; pass < 2; pass++)\n            for (auto &d : dom[pass])\n            {\n                swap(d.r[0], d.c[0]);\n                swap(d.r[1], d.c[1]);\n            }\n        flip = true;\n    }\n\n    auto path0 = solve(R, C, dom[0]);\n    auto path1 = solve(R, C, dom[1]);\n    copy(path1.rbegin(), path1.rend(), back_inserter(path0));\n    cout << SZ(path0) << '\\n';\n    for (const auto &item : path0)\n    {\n        int r = item.first + 1;\n        int c = item.second + 1;\n        if (flip)\n            swap(r, c);\n        cout << r << ' ' << c << '\\n';\n    }\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms"], "dificulty": "2700", "interactive": false}