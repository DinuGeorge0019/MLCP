{
    "link": "https://codeforces.com//contest/866/problem/E",
    "problemId": "125344",
    "problem_idx": "E",
    "shortId": "866E",
    "contest_number": "866",
    "problem_submissions": {
        "G": [
            48042764,
            48042747,
            48042330,
            48042234,
            48042200,
            30882226,
            30888984,
            57250068
        ],
        "D": [
            31044799,
            30877994,
            30876120,
            30879768,
            30877841,
            30935417,
            30935391,
            30878366,
            82427005,
            30877626,
            30880014,
            30879034,
            30880919,
            30880306,
            30879681,
            30881205,
            30880292,
            30878146,
            30881085,
            30880894
        ],
        "F": [
            30883978,
            30915539,
            30915526,
            30915506,
            30915496,
            30915492,
            30915483,
            30915431,
            30915401,
            30915351,
            30915334,
            30888671,
            30882806,
            57257664
        ],
        "C": [
            30875892,
            30877179,
            30883361,
            30877278,
            30966883,
            30966734,
            30935175,
            30876872,
            30891743,
            30891736,
            30880301,
            30877644,
            30878514,
            30877044,
            30878539,
            30877470,
            30877525,
            30878653,
            30881355,
            30877891,
            31274174,
            30878115
        ],
        "B": [
            30874326,
            30883354,
            30901870,
            30876267,
            30875622,
            30878803,
            30876656,
            30875923,
            30874820,
            30876008,
            30875772,
            30876212,
            30875972,
            30876853,
            30876928,
            30876128,
            30876479
        ],
        "A": [
            30872518,
            30872539,
            30872760,
            30872739,
            30875884,
            30873740,
            30872744,
            30872982,
            30875680,
            30874617,
            30872755,
            30881297,
            30873075,
            30873379,
            30873703,
            30873164,
            30874384
        ],
        "E": [
            30957127,
            30884728,
            30888758,
            30909701
        ]
    },
    "name": "E. Hex Dyslexia",
    "statement": "Copying large hexadecimal (base 16) strings by hand can be error prone,\r\nbut that doesn\u2019t stop people from doing it. You\u2019ve discovered a bug in\r\nthe code that was likely caused by someone making a mistake when copying\r\nsuch a string. You suspect that whoever copied the string did not change\r\nany of the digits in the string, nor the length of the string, but may\r\nhave permuted the digits arbitrarily. For example, if the original\r\nstring was they may have changed it to or , but not or .Unfortunately\r\nyou don\u2019t have access to the original string nor the copied string, but\r\nyou do know the length of the strings and their numerical absolute\r\ndifference. You will be given this difference as a hexadecimal string ,\r\nwhich has been zero-extended to be equal in length to the original and\r\ncopied strings. Determine the smallest possible numerical value of the\r\noriginal string.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nchar dig(int a){\n\tif(a <= 9){\n\t\treturn (char)(a + '0');\n\t}\n\treturn (char)(a - 10 + 'a');\n}\nint main(){\n\tstring r;\n\tcin >> r;\n\tLL n = r.size();\n\tLL num[n];\n\tfor(int i = 0; i < n; i++){\n\t\tif(r[i] >= '0' && r[i] <= '9'){\n\t\t\tnum[i] = r[i] - '0';\n\t\t} else {\n\t\t\tnum[i] = r[i] - 'a' + 10;\n\t\t}\n\t}\n\tLL ans = 1e17;\n\tfor(int c = 0; c < (1<<n); c++){\n\t\tint ok[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tok[i] = 0;\n\t\t\tif(c & (1 << i)) ok[i] = 1;\n\t\t}\n\t\tif(ok[0]) continue;\n\t\tint newnum[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnewnum[i] = num[i];\n\t\t}\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(ok[i]){\n\t\t\t\tnewnum[i] -= 16;\n\t\t\t\tnewnum[i-1] += 1;\n\t\t\t}\n\t\t}\n\t\tLL numsum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnumsum += newnum[i];\n\t\t}\n\t\tif(numsum != 0) continue;\n\t\tint bad = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(newnum[i] >= 16 || newnum[i] <= -16){\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tif(bad) continue;\n\t\treverse(newnum, newnum + n);\n\t\t/*for(int i = 0; i < n; i++){\n\t\t\tcout << newnum[i] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\n\t\tLL b[(1<<n)]; // best mask for\n\t\tLL sum[(1<<n)];\n\t\tfor(int i = 0; i < (1<<n); i++){\n\t\t\tb[i] = 1e17;\n\t\t\tsum[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < (1<<n); i++){\n\t\t\tif(i == 0){\n\t\t\t\tb[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tint c = i ^ (1<<j);\n\t\t\t\tif(c > i) continue;\n\t\t\t\tsum[i] = newnum[j] + sum[c];\n\t\t\t\tif(sum[c] < 0 || sum[c] >= 16) continue;\n\t\t\t\tb[i] = min(b[i], b[c] + (sum[c] << (4LL*j)) );\n\t\t\t}\n\t\t}\n\t\t/*if(b[(1<<n)-1] != 1e17){\n\t\t\tcout << b[(1<<n)-1] << endl;\n\t\t}*/\n\t\tans = min(ans, b[(1<<n)-1]);\n\t}\n\tif(ans == 1e17){\n\t\tcout << \"NO\" << endl;\n\t} else {\n\t\tstring f;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf += dig(ans % 16);\n\t\t\tans /= 16;\n\t\t}\n\t\treverse(f.begin(), f.end());\n\t\tcout << f << endl;\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Hex Dyslexia.json",
    "editorial_link": "https://codeforces.com//blog/entry/54888",
    "editorial": "First, observe that for a solution to exist, the sum of the digits in the input must be divisible by 15. This is because of the Casting out Nines rule, but applied in base 16. Furthermore, the sum of digits, when divided by 15, tells us how many carries must be performed when adding the answer to the input. We can try every possible set of positions for the carries, of which there are at most  ways. Once the carries are fixed, for each position we know the exact difference between the original digit in that position and the permuted digit in that position.\n\nNow let's consider the permutation itself. Any permutation can be decomposed into cycles. Because we're looking for the minimum solution, it must be the case that every cycle in the permutation contains a zero. If there were a cycle without a zero, we could reduce every number in the cycle by the minimum value and produce a smaller solution. Furthermore, because every cycle contains a common element, that means the permutation can be written as a single cycle, since two cycles with a common element can be merged into one cycle using that element.\n\nTo build such a cycle, we can start at a zero, and when we add a digit to the path we know based on its position what the difference must be between it and the previous digit. For each of the 2|S| subsets of positions we can compute the minimum value that corresponds to a path through those positions. This step is O(|S|\u00b72|S|).\n\nSide note: the answer, if it exists, always begins with 0. There are 2 cases to consider. If S begins with an 'f', then the only possible solutions begin with a 0. Otherwise, the value given by  is a valid solution, and starts with 0."
}