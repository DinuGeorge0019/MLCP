{
    "link": "https://codeforces.com//contest/1034/problem/D",
    "problemId": "222953",
    "problem_idx": "D",
    "shortId": "1034D",
    "contest_number": "1034",
    "problem_submissions": {
        "E": [
            43279785,
            43212413,
            43229978,
            43294521,
            43208696,
            43220993,
            84865485,
            43443164,
            43443120,
            43443018,
            43216190
        ],
        "D": [
            43250433,
            43221298,
            43215071,
            43392001,
            47789625
        ],
        "B": [
            43205891,
            43195267,
            43193943,
            43195031,
            43196760,
            43197157,
            43191231,
            43195573,
            43213572,
            43195172,
            43208923,
            43193201,
            43202069,
            43195780,
            43197206,
            43192315,
            43197387,
            43207849,
            43201323,
            43198501
        ],
        "C": [
            43201825,
            43200815,
            43202708,
            43202190,
            43201916,
            43202773,
            43198929,
            43200220,
            43198793,
            43202127,
            43201792,
            43209061,
            43203518,
            43208155,
            43197731,
            43206185,
            43207426
        ],
        "A": [
            43186061,
            43219248,
            43187942,
            43187082,
            43188745,
            43197770,
            43193324,
            43188028,
            43186801,
            43186422,
            43193256,
            43186588,
            43188667,
            43226991,
            43226928,
            43187156,
            43187973,
            43187877,
            43186866,
            43188894,
            43192595
        ]
    },
    "name": "D. Intervals of Intervals",
    "statement": "Little D is a friend of Little C who loves intervals very much instead\r\nof number \"3\".Now he has n intervals on the number axis, the i-th of\r\nwhich is [a_i,b_i].Only the n intervals can not satisfy him. He defines\r\nthe value of an [l,r] (1\r\nleq l\r\nleq r\r\nleq n, l and r are both integers) as the total length of the union of\r\nintervals from the l-th to the r-th.He wants to select exactly k\r\ndifferent such that the sum of their values is maximal. Please help him\r\ncalculate the maximal sum.\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<set>\nconst int maxn=300010;\nint n,k,a[maxn],b[maxn];\nstruct event{int i,t,x;bool operator<(const event&e)const{return x<e.x||x==e.x&&t<e.t;}}ev[maxn*4],*ne=ev;\nstruct seg{int i,l,r;bool operator<(const seg&s)const{return l<s.l;}};\nint rt[maxn],add[maxn],lt[maxn];\nlong long rs[maxn];\nvoid cmin(int&a,int b){b<a?a=b:1;}\nvoid cmax(int&a,int b){b>a?a=b:1;}\nlong long chk(int L){\n\tfor(int i=0;i<=n;i++)add[i]=0;\n\tevent*e=ev;\n\tlong long c=0;\n\tfor(int i=n,j=n-1,val=0;i--;){\n\t\tfor(;e<ne&&e->i==i;e++)add[e->t]+=e->x,j>=e->t?val+=e->x:1;\n\t\twhile(j&&val-add[j]>=L)val-=add[j--];\n\t\trt[i]=val<L?n+1:j+1;\n\t\tc+=n-rt[i]+1;\n\t}\n\treturn c;\n}\nstd::set<seg>A;\nstd::set<seg>::iterator spl(int x){\n\tstd::set<seg>::iterator it=A.lower_bound((seg){0,x,x});--it;\n\tif(it->l==x)return it;\n\tseg s=*it;A.erase(it);\n\tA.insert((seg){s.i,s.l,x});\n\treturn A.insert((seg){s.i,x,s.r}).first;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=0;i<n;i++)scanf(\"%d%d\",a+i,b+i);\n\tA.insert((seg){n,0,1000000001});\n\tfor(int i=n;i--;){\n\t\tstd::set<seg>::iterator ir=spl(b[i]),il=spl(a[i]),it;\n\t\twhile(il!=ir){\n\t\t\tit=il++;\n\t\t\t*ne++=(event){i,it->i,it->l-it->r};\n\t\t\tA.erase(it);\n\t\t}\n\t\t*ne++=(event){i,i,b[i]-a[i]}; \n\t\tA.insert((seg){i,a[i],b[i]});\n\t}\n\tint L=0,R=1000000001,mid;\n\twhile(R-L>1)chk(mid=L+R>>1)>k?L=mid:R=mid;\n\tlong long K=chk(R),cur=0,ans=0,tmp;\n\tfor(int i=0;i<n;i++)rs[i+1]=rs[i]+rt[i];\n\tfor(int i=0,j=0;j<=n+1;j++){\n\t\twhile(i<n&&rt[i]<j)i++;\n\t\tlt[j]=i;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tev[i*2]=(event){i,0,a[i]};\n\t\tev[i*2+1]=(event){i,1,b[i]};\n\t}\n\tstd::sort(ev,ev+n*2);\n\tstd::set<int>B;\n\tB.insert(-1);\n\tB.insert(n);\n\tfor(int i=0;i+1<n*2;i++){\n\t\tstd::set<int>::iterator it=ev[i].t?B.find(ev[i].i):B.insert(ev[i].i).first;\n\t\tint l=1+*--it;++it;\n\t\tint m=1+ev[i].i,r=1+*++it;--it;\n\t\tint x=lt[m],y=lt[r];\n\t\tcmax(x,l);cmax(y,l);\n\t\tcmin(x,m);cmin(y,m);\n\t\ttmp=(x-l)*1ll*(r-m)-rs[y]+rs[x]+(y-x)*1ll*r;\n\t\tev[i].t?cur-=tmp:cur+=tmp;\n\t\tans+=cur*(ev[i+1].x-ev[i].x);\n\t\tif(ev[i].t)B.erase(it);\n\t}\n\tprintf(\"%lld\\n\",ans+(k-K)*L);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "two pointers"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Intervals of Intervals.json",
    "editorial_link": "https://codeforces.com//blog/entry/61993",
    "editorial": "First we consider how to calculate the value of an interval of\nintervals . We can consider intervals in order from to and, for each\nposition on the axis, maintain a timestamp denoting the last time it was\ncovered. When the -th interval is taken into consideration, the\ntimestamps for positions should all be updated to . Right after that,\nthe desired answer of a query is the number of positions whose timestamp\nis not smaller than .We would like to, for each , keep the desired\nanswer for every . To achieve this, when we change the timestamps of\npositions from to , the answers for in should each be increased by .To\ndo it fast, we can merge consecutive positions with the same timestamp\ninto a segment, and use a balanced tree (e.g. std::set) to maintain the\nsegments. new segments appear when adding an interval, and when a\nsegment is completely covered by later intervals, it will be deleted. By\namortized analysis, the total number of balanced tree operations and the\nnumber of range modifications of answers (see above) are both . We spend\ntime in this part.Now we consider how to get the answer. It\u00e2\u0080\u0099s obvious\nthat we will select the largest values. We can use binary search to find\nthe minimum we finally select, i.e. we should, for several integers ,\ncount how many values of are not smaller than and count the sum of these\nvalues by the way to get the answer.For each , we will select all \u00e2\u0080\u0099s\nsuch that their interval of intervals values is not smaller than . As\nthe value of is not smaller than or , it\u00e2\u0080\u0099s obvious that all \u00e2\u0080\u0099s smaller\nthan an integer will be taken and will be not smaller than . Now we can\niterate from to , maintaining the sum of values of () and the value of\nby maintaining the difference between the answers for and (in this way\nwe carry out a range increment in time). Similar to the sliding-window\nmethod, we try to increase when changes to . Therefore, we spend time\nfor each we check with.Summing everything up, the total time complexity\nof this problem is .\n"
}