{
    "link": "https://codeforces.com//contest/947/problem/E",
    "problemId": "164141",
    "problem_idx": "E",
    "shortId": "947E",
    "contest_number": "947",
    "problem_submissions": {
        "C": [
            36173454,
            36158955,
            36159580,
            36159099,
            36160344,
            36163522,
            36159314,
            36160080,
            36160850,
            36161300,
            36159923,
            36161359,
            36160490,
            36159503,
            36160981,
            36162645,
            36160904,
            36159951,
            36161496
        ],
        "E": [
            36168563,
            36236455,
            36170443,
            39088009
        ],
        "B": [
            36164839,
            36156882,
            36157486,
            36156947,
            36158529,
            36159543,
            36158110,
            36157900,
            36155578,
            36159650,
            36157136,
            36158516,
            36157266,
            36157820,
            36159109,
            36159552,
            36158553,
            36157744,
            36159160
        ],
        "D": [
            36162982,
            36163865,
            36166846,
            36164126,
            36164997,
            36171948,
            36177192,
            36164630,
            36165682,
            36165588,
            36166182,
            36171226,
            36166510,
            36166759,
            36167046,
            36167052,
            36169076,
            36165891,
            36168487
        ],
        "A": [
            36160906,
            36154995,
            36155654,
            36155514,
            36156087,
            36157563,
            36155459,
            36156152,
            36158089,
            36157373,
            36155161,
            36155827,
            36155589,
            36156282,
            36157634,
            36156202,
            36156868,
            36156079,
            36157276
        ],
        "F": [
            36230948
        ]
    },
    "name": "E. Perpetual Subtraction",
    "statement": "There is a number initially written on a blackboard. You repeat the\r\nfollowing action a fixed amount of times: take the number currently\r\nwritten on a blackboard and erase it select an integer uniformly at\r\nrandom from the range inclusive, and write it on the blackboard\r\nDetermine the distribution of final number given the distribution of\r\ninitial number and the number of steps.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#define REP(i, x, y) for(int i = (int)x; i <= (int)y; i ++)\n#define FOR(i, x, y) for(int i = (int)x; i <  (int)y; i ++)\n#define PER(i, x, y) for(int i = (int)x; i >= (int)y; i --)\nusing namespace std;\ntypedef long long LL;\nconst int N = 300005;\nconst int P = 998244353;\nconst int inf = 1e9;\nconst LL Inf = 1e18;\n\nint Pow(int x, LL y, int p){\n\tint an = 1;\n\tfor(; y; y >>= 1, x = (LL)x * x % p) if(y & 1) an = (LL)an * x % p;\n\treturn an;\n}\n\nvoid renew(int &x, int y){\n\tx += y;\n\tif(x < 0) x += P;\n\telse if(x >= P) x -= P;\n}\n\ntemplate<typename T> inline void chkmin(T &a, const T &b) {if(a > b) a = b;}\ntemplate<typename T> inline void chkmax(T &a, const T &b) {if(a < b) a = b;}\n\nint n,p[N],rev[N];\nLL k;\nconst int G=3;\nint w[2][N],tn,tl;\n\nvoid dft(int *a,int f){\n\tFOR(i,0,tn) if(i<rev[i]) swap(a[i],a[rev[i]]);\n\n\tfor(int i=1;i<tn;i<<=1)\n\tfor(int j=0,t=tn/(i<<1);j<tn;j+=i<<1)\n\tfor(int k=0,l=0;k<i;k++,l+=t){\n\t\tint x=a[j+k];\n\t\tint y=(LL)a[j+k+i]*w[f][l]%P;\n\t\ta[j+k]=(x+y)%P;\n\t\ta[j+k+i]=(x+P-y)%P;\n\t}\n\n\tif(f){\n\t\tint rn=Pow(tn,P-2,P);\n\t\tFOR(i,0,tn) a[i]=(LL)a[i]*rn%P;\n\t}\n}\n\nint A[N],B[N],fac[N],ifac[N],T[N];\n\nvoid prep(int n){\n\tfor(tn=1,tl=-1;tn<=(n*2);tn<<=1,tl++);\n\n\tw[0][0]=w[1][0]=1;\n\tint ng=Pow(3,(P-1)/tn,P);\n\tFOR(i,1,tn){\n\t\tw[0][i]=(LL)w[0][i-1]*ng%P;\n\t\tw[1][i]=Pow(w[0][i],P-2,P);\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)<<tl);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%I64d\",&n,&k);\n\tREP(i,0,n) scanf(\"%d\",p+i);\n\treverse(p,p+n+1);\n\tprep(n);\n\n\n\tfac[0]=ifac[0]=1;\n\tREP(i,1,n) fac[i]=(LL)fac[i-1]*i%P;\n\tREP(i,1,n) ifac[i]=Pow(fac[i],P-2,P);\n\n\tmemset(A,0,sizeof A);\n\tmemset(B,0,sizeof B);\n\tREP(i,0,n) A[i]=(LL)p[n-i]*fac[i]%P,B[n-i]=ifac[i];\n\tdft(A,0); dft(B,0);\n\tFOR(i,0,tn) A[i]=(LL)A[i]*B[i]%P;\n\tdft(A,1);\n\n\tmemset(T,0,sizeof T);\n\tREP(i,0,n) T[i]=(LL)A[i+n]*ifac[i]%P;\n\tFOR(i,0,tn) T[i]=(LL)T[i]*Pow(Pow(i+1,P-2,P),k,P)%P;\n\n\tmemset(A,0,sizeof A);\n\tmemset(B,0,sizeof B);\n\tREP(i,0,n) A[i]=(LL)T[i]*fac[i]%P,B[n-i]=(i&1?P-ifac[i]:ifac[i]);\n\tdft(A,0); dft(B,0);\n\tFOR(i,0,tn) A[i]=(LL)A[i]*B[i]%P;\n\tdft(A,1);\n\n\tREP(i,0,n) T[n-i]=(LL)A[i+n]*ifac[i]%P;\n\n\treverse(T,T+n+1);\n\tREP(i,0,n){\n\t\tprintf(\"%d \",T[i]);\n\t}\n\tputs(\"\");\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "fft",
        "math",
        "matrices"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Perpetual Subtraction.json",
    "editorial_link": "https://codeforces.com//blog/entry/58286",
    "editorial": "We can model this process as a Markov chain with N?+?1 states with transition matrix\n\n\n\nThe task is to find R?=?AM·P. A naive solution using Matrix exponentiation is obviously too slow, as it uses  time. We need to improve upon it and we look for eigenvalue decomposition.\n\nThis is a triangular matrix, thus its eigenvalues are the elements on the main diagonal. Hence\n\n\n\nWe can show that the eigenvector corresponding to  is  (consult proof at the end).\n\nThus, we have \n\nTo finalise the eigenvalue decomposition, we need to find the inverse of Q. It can be shown Q and Q?-?1 are the same up to the sign (consult proof at the end): \n\nThe advantage of eigendecomposition is that AM?=?Q·?M·Q?-?1,? where the diagonal matrix ? can be exponentiated in .\n\nWe can calculate the result as R?=?AM·P?=?Q·(?M·(Q?-?1·P))?.\n\nPerformed naively, this runs in , which is still too slow. We obviously need to multiply with Q (and its inverse) faster.\n\nFortunately, both linear functions Q and Q?-?1 are a convolution and we can compute the multiplication in  using FFT, which is a bit hinted by the modulus in which to compute the answer.\n\nProof of the eigenvectors\n\nWe show that  it holds\n\n\n\nwhere the fifth equality can be proven by induction on i?-?k.\n\nProof of the inverse\n\nDenote P?=?QQ?-?1.\n\nFirst, we show that the diagonal of the product only contains ones. This is easy, since the i-th row of Q has zeroes until i?-?1-th column, i-th column of Q?-?1 has zeroes starting from i?+?1-th row, and Qi,?i?=?Q?-?1i,?i?=?1. Thus, Pi,?i?=?1. Next we show that the Pi,?j?=?0 for i???j. When i?>?j, all the summands in the inner product are zero. It remains to show the claim for i?<?j.\n\n\n\nProof that Q and Q?-?1 are convolutions\n\nPut y?=?Q?-?1x. We want to show that y can be computed by convolution. See that\n\n\n\nhence y is a convolution of functions f and g up to some multiplicative factors.\n\nThe proof for Q is similar, we can just remove all the (?-?1)? terms.",
    "hint": []
}