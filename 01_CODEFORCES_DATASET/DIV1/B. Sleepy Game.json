{
    "link": "https://codeforces.com//contest/936/problem/B",
    "problemId": "159977",
    "problem_idx": "B",
    "shortId": "936B",
    "contest_number": "936",
    "problem_submissions": {
        "E": [
            35712266,
            35727991,
            35725013,
            35707211,
            35770218
        ],
        "D": [
            35700007,
            35702585,
            35703968,
            35704322,
            35707565,
            35707992,
            35703995,
            35707242,
            35706026,
            35706184,
            35705316
        ],
        "C": [
            35693639,
            35697250,
            35695166,
            35695586,
            35697018,
            35695913,
            35698664,
            35705647,
            35697865,
            35699503,
            35697044,
            35700894,
            35699052,
            35698193,
            35698295,
            35698757,
            35697398,
            35701177
        ],
        "B": [
            35691090,
            35691407,
            35691792,
            35691438,
            35690313,
            35691314,
            35691290,
            35690630,
            35698924,
            35693457,
            35691128,
            35693732,
            35690660,
            35690004,
            35694559,
            35691031,
            35692920
        ],
        "A": [
            35689192,
            35689253,
            35688351,
            35690016,
            35688869,
            35688655,
            35688920,
            35688825,
            35690115,
            35690230,
            35697676,
            35690493,
            35688221,
            35691287,
            35688663,
            35690989,
            35689298,
            35689878
        ]
    },
    "name": "B. Sleepy Game",
    "statement": "Petya and Vasya arranged a game. The game runs by the following rules.\r\nPlayers have a directed graph consisting of vertices and edges. One of\r\nthe vertices contains a chip. Initially the chip is located at vertex .\r\nPlayers take turns moving the chip along some edge of the graph. Petya\r\ngoes first. Player who can\u2019t move the chip loses. If the game lasts for\r\nturns the draw is announced.Vasya was performing big laboratory work in\r\n\"Spelling and parts of speech\" at night before the game, so he fell\r\nasleep at the very beginning of the game. Petya decided to take the\r\nadvantage of this situation and make both Petya\u2019s and Vasya\u2019s moves.Your\r\ntask is to help Petya find out if he can win the game or at least draw a\r\ntie.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nint N, M, S;\nvector<int> Adj[MaxN];\n\nbool Reachable[MaxN][2];\nint PrevVert[MaxN][2];\n\nvoid dfs(int v, int x) {\n  Reachable[v][x] = true;\n  for (int s : Adj[v])\n    if (!Reachable[s][x ^ 1]) {\n      PrevVert[s][x ^ 1] = v;\n      dfs(s, x ^ 1);\n    }\n}\n\nint Vis[MaxN];\n\nbool dfsCycle(int v) {\n  Vis[v] = 1;\n  for (int s : Adj[v]) {\n    if (Vis[s] == 1) { return true; }\n    if (Vis[s] == 0 && dfsCycle(s))\n      return true;\n  }\n\n  Vis[v] = 2;\n  return false;\n}\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> M;\n  for (int i = 1; i <= N; ++i) {\n    int c; cin >> c;\n    for (int j = 0; j < c; ++j) {\n      int v;\n      cin >> v;\n      Adj[i].PB(v);\n    }\n  }\n\n  cin >> S;\n  dfs(S, 0);\n\n  for (int i = 1; i <= N; ++i) {\n    if (SZ(Adj[i]) == 0 && Reachable[i][1]) {\n      cout << \"Win\\n\";\n      vector<int> Res;\n      int v = i, x = 1;\n      Res.push_back(v);\n      while (v != S || x != 0) {\n        v = PrevVert[v][x];\n        x ^= 1;\n        Res.push_back(v);\n      }\n\n      reverse(ALL(Res));\n      for (int s : Res) { cout << s << \" \"; }\n      cout << \"\\n\";\n      return 0;\n    }\n  }\n\n  if (dfsCycle(S))\n    cout << \"Draw\\n\";\n  else\n    cout << \"Lose\\n\";\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "games",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Sleepy Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/58056",
    "editorial": "Note that the answer is sequence of adjacent vertices of even length\r\nsuch that the last vertex of this sequence has no outgoing edges.Build\r\nstate graph as follows:State is pair , where is vertex of initial graph\r\nand is parity of count of vertices on path from to . For every edge of\r\ninitial graph add edges and in state graph. So there exists path from to\r\nif and only if there exists path from to in initial graph of parity\r\n.Lets find all reachable from states using BFS or DFS. If there is state\r\namong them such that has no outgoing edges in initial graph, then Petya\r\ncan win. He can move along vertices in path from to in state\r\ngraph.Otherwise we need to check if Petya can make moves for drawing a\r\ntie. If there is a tie then the chip visited some vertex twice, because\r\n. Therefore it is sufficient to check if there is a cycle in initial\r\ngraph reachable from . In this case Petya can play as follows: move to\r\nany vertex of cycle and then move along the cycle as long as it requires\r\nto draw a tie.\r\n"
}