{
    "link": "https://codeforces.com//contest/429/problem/B",
    "problemId": "9403",
    "problem_idx": "B",
    "shortId": "429B",
    "contest_number": "429",
    "problem_submissions": {
        "E": [
            6595809,
            6600093,
            6592978,
            6601793,
            6652557,
            6599111,
            6619551,
            6619545,
            6597254,
            6597744
        ],
        "C": [
            6593728,
            6600070,
            6592280,
            6592740,
            6600977,
            6600868,
            6594386,
            6592397,
            6594791,
            6593656,
            6596025,
            6593807,
            6593862,
            6598107,
            6594449,
            6598559,
            6594937,
            6592148,
            6594524,
            6592432,
            6594909,
            6590473
        ],
        "D": [
            6591664,
            6600092,
            6591240,
            6590624,
            6590639,
            6591834,
            6591461,
            6591644,
            6590500,
            6592190,
            6591828,
            6591578,
            6591777,
            6592587,
            27994201,
            6591983,
            6594641,
            6604627,
            6593023,
            6594793,
            6591937,
            6593041
        ],
        "B": [
            6589690,
            6600091,
            6589488,
            6589367,
            6588962,
            6590036,
            6588367,
            6590786,
            6591308,
            6589466,
            6590642,
            6589551,
            6589761,
            6589966,
            6589108,
            6590082,
            6589028,
            6590294,
            6589190,
            6595125
        ],
        "A": [
            6588164,
            6600088,
            6588109,
            6588114,
            6588105,
            6588288,
            6588966,
            6588346,
            6592136,
            6588117,
            6588421,
            6588130,
            6588989,
            6588112,
            27994125,
            6589842,
            6588200,
            6588169,
            6588529,
            6590124,
            6593587
        ]
    },
    "name": "B. Working out",
    "statement": "Summer is coming! It\u2019s time for Iahub and Iahubina to work out, as they\r\nboth want to look hot at the beach. The gym where they go is a matrix\r\nwith lines and columns. Let number represents the calories burned by\r\nperforming workout at the cell of gym in the -th line and the -th\r\ncolumn.Iahub starts with workout located at line and column . He needs\r\nto finish with workout . After finishing workout , he can go to workout\r\nor . Similarly, Iahubina starts with workout and she needs to finish\r\nwith workout . After finishing workout from cell , she goes to either or\r\n. There is one additional condition for their training. They have to\r\nmeet in exactly one cell of gym. At that cell, none of them will work\r\nout. They will talk about fast exponentiation (pretty odd small talk)\r\nand then both of them will move to the next workout.If a workout was\r\ndone by either Iahub or Iahubina, it counts as total gain. Please plan a\r\nworkout for Iahub and Iahubina such as total gain to be as big as\r\npossible. Note, that Iahub and Iahubina can perform workouts with\r\ndifferent speed, so the number of cells that they use to reach meet cell\r\nmay differs.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint t[4][1050][1050];\nint n, m;\nint a[1050][1050];\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tscanf(\"%d%d\", &n, &m);\n\tforn(i, n)\n\t\tforn(j, m)\n\t\t\tscanf(\"%d\", &a[i + 1][j + 1]);\n\tseta(t, 0);\t\t\t\t\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tt[0][i][j] = max(t[0][i-1][j], t[0][i][j-1]) + a[i][j];\n\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = m; j >= 1; j--)\n\t\t\tt[1][i][j] = max(t[1][i-1][j], t[1][i][j+1]) + a[i][j];\n\n\tfor (int i = n; i >= 1; i--)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tt[2][i][j] = max(t[2][i+1][j], t[2][i][j-1]) + a[i][j];\n\n\tfor (int i = n; i >= 1; i--)\n\t\tfor (int j = m; j >= 1; j--)\n\t\t\tt[3][i][j] = max(t[3][i+1][j], t[3][i][j+1]) + a[i][j];\n\t\n\n\tint ans = 0;\n\tfor (int i = 2; i <= n-1; i++)\n\t\tfor (int j = 2; j <= m-1; j++) {\n\t\t\tans = max(ans, t[0][i-1][j] + t[3][i+1][j] + t[2][i][j-1] + t[1][i][j+1]);\n\n\t\t\tans = max(ans, t[0][i][j-1] + t[3][i][j+1] + t[2][i+1][j] + t[1][i-1][j]);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Working out.json",
    "editorial_link": "https://codeforces.com//blog/entry/12265",
    "editorial": "The particularity of this problem which makes it different by other\r\nproblem of this kind is that paths need to cross exactly one cell and\r\nIahub can go only right and down, Iahubina can go only right and up.\r\nLet\u00e2\u0080\u0099s try to come up with a solution based on these facts. A good start\r\nis to analyze configurations possible for meeting cell. Iahub can come\r\neither from right or down and Iahubina can come either from right or up.\r\nHowever, if both Iahub and Iahubina come from right, they must have met\r\nin other cell as well before (the cell in the left of the meet one).\r\nSimilarly, if one comes from up and other one from down, their paths\r\nwill cross either on upper cell, lower cell or right cell. Only 2\r\npossible cases are: Iahub comes from right, Iahubina comes from up or\r\nIahub comes from down, Iahubina comes from right. By drawing some\r\nskatches on paper, you\u00e2\u0080\u0099ll see next cell visited after meeting one will\r\nhave the same direction for both of them. More, they will never meet\r\nagain. So Iahub comes from right, goes to right, Iahubina comes from up,\r\ngoes to up or Iahub comes from down, goes to down and Iahubina comes\r\nfrom right, goes to right. In the drawing, Iahub\u00e2\u0080\u0099s possible visited\r\ncells are blue, Iahubina\u00e2\u0080\u0099s possible visited cells are red and meeting\r\ncell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes\r\nfrom (1, 1) to (X, Y 1) by going down or right. Next, he goes from (X,\r\nY + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to\r\n(X + 1, Y) by going up or right and then from (X 1, Y) to (1, M) by\r\ngoing with same directions. In second case, Iahub goes from (1, 1) to (X\r\n1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1)\r\nto (X, Y 1) and then from (X, Y + 1) to (1, M). We can precalculate for\r\ndynamic programming matrixes and we\u00e2\u0080\u0099re done. dp1[i][j] = maximal cost of\r\na path going from (1, 1) to (i, j) only down and right. dp2[i][j] =\r\nmaximal cost of a path from (i, j) to (1, m) going only up and right.\r\ndp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up\r\nand right. dp4[i][j] = maximal cost of a path from (i, j) to (n, m)\r\ngoing only down or right. And here is my full implementation of\r\nrecurrences (C++ only): Also, pay attention that meeting points can be\r\ncells (i, j) with 1 < i < n and 1 < j < m. (why?)\r\n"
}