{"link": "https://codeforces.com//contest/1667/problem/E", "problemId": "1373072", "problem_idx": "E", "shortId": "1667E", "contest_number": "1667", "problem_submissions": {"D": [154110050, 154103852, 154103937, 154115479, 154155764, 154115906, 154106152, 154122484, 154113686, 154108338, 154128689, 154128856, 154111430, 154129489, 154120823, 154116376, 154123174, 154132994, 154140447], "E": [154098159, 154112243, 154113395, 154103015, 154110907, 154132981, 154119331, 154111400, 154101121, 154121934, 154125339, 154115657, 154116667, 154129397, 154116608, 154116404, 154106393, 154102336, 154119279, 154115571, 154118773], "C": [154085084, 154086351, 154093926, 154092233, 154091477, 154093338, 154099548, 154094249, 154095983, 154097356, 154101589, 154106382, 154103698, 154128503, 154096518, 154099179, 154101629, 154094236], "B": [154081270, 154079749, 154080732, 154084177, 154082008, 154087816, 154084920, 154081329, 154079918, 154089467, 154085121, 154087842, 154083998, 154085563, 154088975, 154094350, 154109646, 154150216, 154080315, 154083438], "A": [154078911, 154089336, 154078854, 154078866, 154112501, 154079024, 154078951, 154078873, 154079568, 154078977, 154079611, 154079048, 154078916, 154078899, 154081306, 154078922, 154079058, 154082401, 154078903]}, "name": "E. Centroid Probabilities", "statement": "Consider every tree (connected undirected acyclic graph) with n vertices\r\n(, vertices numbered from 1 to n), and for each 2\r\nle i\r\nle n the i-th vertex is adjacent to exactly one vertex with a smaller\r\nindex.For each i (1\r\nle i\r\nle n) calculate the number of trees for which the i-th vertex will be\r\nthe centroid. The answer can be huge, output it modulo 998\r\n,244\r\n,353.A vertex is called a centroid if its removal splits the tree into\r\nsubtrees with at most (n-1)/2 vertices each.\r\n", "solutions": ["//answer is p-recursive, but i choose to fft.\n \n#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int RT = 3;\n\nconst int MAXT = 20;\nconst int MAXL = 1100000;\n\nint fac[MAXL + 5], ifac[MAXL + 5], inv[MAXL + 5];\nint rg[MAXT + 5];\n\nint ub2(int n)\n{\n\tint ret = 0;\n\twhile((1 << ret) < n) ret ++;\n\treturn ret;\n}\n\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1LL * ret * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint cr[MAXL + 5];\nvoid dft(int arr[], int siz, int dir)\n{\n\tif(dir == -1) reverse(arr + 1, arr + (1 << siz));\n\tint cur = 0;\n\tfor(int i = 0; i < (1 << siz); i ++) {\n\t\tif(cur < i) swap(arr[cur], arr[i]);\n\t\tfor(int j = siz - 1; j >= 0; j --) {\n\t\t\tcur ^= 1 << j;\n\t\t\tif(cur >> j & 1) break;\n\t\t}\n\t}\n\trep1(d, siz) {\n\t\tint pr = rg[d];\n\t\tcr[0] = 1;\n\t\tfor(int i = 1; i < (1 << (d - 1)); i ++) cr[i] = 1LL * cr[i - 1] * pr % MOD;\n\t\tfor(int i = 0; i < (1 << siz); i += 1 << d) rep(j, 1 << (d - 1)) {\n\t\t\tint ev = arr[i + j], od = 1LL * arr[i + j + (1 << (d - 1))] * cr[j] % MOD;\n\t\t\tarr[i + j] = ev + od - (ev + od >= MOD ? MOD : 0);\n\t\t\tarr[i + j + (1 << (d - 1))] = ev - od + (ev - od < 0 ? MOD : 0);\n\t\t}\n\t}\n\tif(dir == -1) {\n\t\tint invn = inv[1 << siz];\n\t\trep(i, 1 << siz) arr[i] = 1LL * arr[i] * invn % MOD;\n\t}\n}\n\nint tmp0[MAXL + 5], tmp1[MAXL + 5];\nvoid poly_mul(int A[], int B[], int ret[], int siz)\n{\n\trep(i, 1 << (siz + 1)) tmp0[i] = i >> siz ? 0 : A[i];\n\trep(i, 1 << (siz + 1)) tmp1[i] = i >> siz ? 0 : B[i];\n\tdft(tmp0, siz + 1, 1);\n\tdft(tmp1, siz + 1, 1);\n\trep(i, 1 << (siz + 1)) ret[i] = 1LL * tmp0[i] * tmp1[i] % MOD;\n\tdft(ret, siz + 1, -1);\n}\n\nvoid poly_inv(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) tmp1[i] = i == 0 ? power(A[0], MOD - 2) : 0;\n\trep1(i, siz) {\n\t\trep(j, 1 << (i + 1)) tmp0[j] = j >> i ? 0 : A[j];\n\t\trep(j, 1 << (i + 1)) tmp1[j] = j >> (i - 1) ? 0 : tmp1[j];\n\t\tdft(tmp0, i + 1, 1);\n\t\tdft(tmp1, i + 1, 1);\n\t\trep(j, 1 << (i + 1)) tmp1[j] = (2 + 1LL * (MOD - tmp0[j]) * tmp1[j] % MOD) * tmp1[j] % MOD;\n\t\tdft(tmp1, i + 1, -1);\n\t}\n\trep(i, 1 << siz) ret[i] = tmp1[i];\n}\n\nint tmp2[MAXL + 5];\nvoid poly_ln(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) if(i > 0) tmp2[i - 1] = 1LL * A[i] * i % MOD;\n\tpoly_inv(A, ret, siz);\n\tpoly_mul(ret, tmp2, ret, siz);\n\tfor(int i = (1 << siz) - 1; i >= 0; i --) ret[i] = i == 0 ? 0 : 1LL * inv[i] * ret[i - 1] % MOD;\n}\n\nint tmp3[MAXL + 5], tmp4[MAXL + 5];\nvoid poly_exp(int A[], int ret[], int siz)\n{\n\trep(i, 1 << siz) tmp3[i] = i == 0;\n\trep1(i, siz) {\n\t\tpoly_ln(tmp3, tmp4, i);\n\t\trep(j, 1 << i) tmp4[j] = ((j == 0) + A[j] - tmp4[j] + MOD) % MOD;\n\t\tpoly_mul(tmp3, tmp4, tmp3, i);\n\t}\n\trep(i, 1 << siz) ret[i] = tmp3[i];\n}\n\nvoid init()\n{\n\trg[0] = 1;\n\trep1(i, MAXT) rg[i] = power(RT, (MOD - 1) >> i);\n\tfac[0] = 1;\n\trep1(i, MAXL) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\tifac[MAXL] = power(fac[MAXL], MOD - 2);\n\tfor(int i = MAXL; i >= 1; i --) ifac[i - 1] = 1LL * ifac[i] * i % MOD;\n\trep1(i, MAXL) inv[i] = 1LL * ifac[i] * fac[i - 1] % MOD;\n}\n\nint n, ans[524295], rsum[500005], p[524295], q[524295];\nint main()\n{\n\tinit();\n\tscanf(\"%d\", &n);\n\n\trep1(i, n) p[i] = ifac[n - i];\n\tfor(int i = n / 2; i <= n - 2; i ++) q[n - i] = fac[n - 2 - i];\n\tpoly_mul(p, q, p, 19);\n\tfor(int i = 2; i <= n; i ++) ans[i] = 1ULL * fac[n - i] * p[n + i] % MOD * ifac[i - 2] % MOD;\n\tans[1] = fac[n - 1];\n\t\n\trep1(i, n) ans[i] = 1ULL * fac[i - 1] * ans[i] % MOD;\n\tfor(int i = n; i >= 1; i --) rsum[i - 1] = (rsum[i] + 1ULL * ans[i] * inv[i - 1]) % MOD;\n\trep1(i, n) ans[i] = (ans[i] - rsum[i] + MOD) % MOD;\n\trep1(i, n) printf(\"%d \", ans[i]);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "fft", "math"], "dificulty": "3000", "interactive": false}