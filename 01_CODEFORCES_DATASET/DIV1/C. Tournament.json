{
    "link": "https://codeforces.com//contest/878/problem/C",
    "problemId": "130659",
    "problem_idx": "C",
    "shortId": "878C",
    "contest_number": "878",
    "problem_submissions": {
        "E": [
            31763989,
            31766344,
            32084568
        ],
        "D": [
            31756901,
            31762689,
            31754129,
            31756452,
            31772004,
            31761487,
            31761339,
            31761633,
            31767096,
            31789313,
            31769411,
            31767240,
            31764633,
            31929002,
            31911110,
            31754793
        ],
        "C": [
            31752735,
            31757112,
            31751479,
            31747354,
            31752922,
            31752815,
            31757860,
            31761336,
            31759682,
            31761695,
            31751021,
            31760902,
            31758288,
            31764916,
            31764825,
            31755837
        ],
        "B": [
            31745139,
            31746290,
            31753553,
            31777437,
            31754012,
            31756298,
            31752132,
            31754987,
            31751846,
            31753351,
            31760932,
            31770059,
            31750086,
            31755233,
            31753552,
            31762144
        ],
        "A": [
            31741277,
            31741357,
            31741777,
            31741474,
            31742096,
            31741956,
            31741731,
            31741469,
            31743565,
            31743908,
            31741393,
            31741983,
            31741174,
            31745067,
            31741499,
            31745657,
            31745328,
            31741742,
            31742765
        ]
    },
    "name": "C. Tournament",
    "statement": "Recently a tournament in kinds of sports has begun in Berland. Vasya\r\nwants to make money on the bets.The scheme of the tournament is very\r\nmysterious and not fully disclosed. Competitions are held back to back,\r\neach of them involves two sportsmen who have not left the tournament\r\nyet. Each match can be held in any of the kinds of sport. Loser leaves\r\nthe tournament. The last remaining sportsman becomes the winner. Apart\r\nof this, the scheme can be arbitrary, it is not disclosed in\r\nadvance.Vasya knows powers of sportsmen in each kind of sport. He\r\nbelieves that the sportsmen with higher power always wins.The tournament\r\nis held every year, and each year one new participant joins it. In the\r\nfirst tournament, only one sportsman has participated, in the second\r\nthere were two sportsmen, and so on. Vasya has been watching the\r\ntournament for the last years. Help him to find the number of possible\r\nwinners for each of the tournaments.\r\n",
    "solutions": [
        "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n\nint K;\nint u[10];\nclass datax {\npublic:\n\tint a[10];\n\tint b[10];\n\tint c;\n\tdatax() {\n\t\tfor (int i = 0; i < K; i++) a[i] = b[i] = u[i];\n\t\tc = 1;\n\t}\n\tdatax operator + (const datax &l) const {\n\t\tdatax rv;\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\trv.a[i] = min(a[i], l.a[i]);\n\t\t\trv.b[i] = max(b[i], l.b[i]);\n\t\t}\n\t\trv.c = c + l.c;\n\t\treturn rv;\n\t}\n\tbool operator < (const datax &l) const {\n\t\treturn a[0] < l.a[0];\n\t}\n};\n\nset <datax> Sx;\nint main() {\n\tint N, i, j;\n\tscanf(\"%d %d\", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j < K; j++) scanf(\"%d\", &u[j]);\n\n\t\tdatax cur = datax();\n\t\twhile (!Sx.empty()) {\n\t\t\tauto it = Sx.lower_bound(cur);\n\t\t\tif (it != Sx.begin()) {\n\t\t\t\tit--;\n\t\t\t\tbool c1 = false, c2 = false;\n\t\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\t\tif (it->b[i] > cur.a[i]) c1 = true;\n\t\t\t\t\tif (cur.b[i] > it->a[i]) c2 = true;\n\t\t\t\t}\n\t\t\t\tif (c1 && c2) {\n\t\t\t\t\tcur = cur + *it;\n\t\t\t\t\tSx.erase(it);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tit = Sx.lower_bound(cur);\n\t\t\tif (it != Sx.end()) {\n\t\t\t\tbool c1 = false, c2 = false;\n\t\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\t\tif (it->b[i] > cur.a[i]) c1 = true;\n\t\t\t\t\tif (cur.b[i] > it->a[i]) c2 = true;\n\t\t\t\t}\n\t\t\t\tif (c1 && c2) {\n\t\t\t\t\tcur = cur + *it;\n\t\t\t\t\tSx.erase(it);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tSx.insert(cur);\n\t\tauto it = Sx.end();\n\t\tit--;\n\t\tprintf(\"%d\\n\", it->c);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Tournament.json",
    "editorial_link": "https://codeforces.com//blog/entry/55435",
    "editorial": "Imagine a directed graph, in which the vertices are participants, and\r\nthe edge means that one participant can win the other in some kind of\r\nsports. A participant can win a tournament if there is a directed tree\r\nin this graph that contains all vertices, and this player is a\r\nroot.Consider the condensation of this graph. Since for any two vertices\r\nthere is an edge at least in one direction, condensation is a path. It\r\nis clear that the required tree exists if and only if the root lies in\r\nthe first strongly connected component.We will maintain these strongly\r\nconnected components. For each of them we will store its size, the\r\ngreatest power and the smallest power in each kind of sports.What\r\nhappens when the new sportsman is added? He can defeat the component if\r\nin some kind of sports he is stronger than the minimum in this\r\ncomponent. Similarly, he can lose to a component if in some kind of\r\nsports he is weaker than the maximum in this component. We need to find\r\nthe weakest of those components that he can lose, and the strongest of\r\nthose components that he can defeat. If the first component is stronger\r\nthan the second, the new sportsman forms a new component. Otherwise, all\r\nthe components between the first and the second merge into one, and the\r\nnew sportsman joins it.How to do it effectively? We will store the\r\ncomponents in a some search tree and use the comparison by minimum in\r\nthe first kind of sports as a comparator. It\u00e2\u0080\u0099s easy to see that if you\r\ntake any other sport or replace a minimum with a maximum, any two\r\ncomponents will be compared in the same way. All we need is binsearch by\r\none of the mentioned comparators: minimum or maximum for one of the\r\nkinds of sports.At each step the number of operations with the tree is +\r\nnumber of components merged into one. At each step at most one component\r\ncan be added, so the amortized time of one step is .Overall time\r\ncomplexity is .\r\n"
}