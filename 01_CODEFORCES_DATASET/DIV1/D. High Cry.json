{
    "link": "https://codeforces.com//contest/875/problem/D",
    "problemId": "128561",
    "problem_idx": "D",
    "shortId": "875D",
    "contest_number": "875",
    "problem_submissions": {
        "E": [
            31401553,
            31405129,
            31392967,
            31402730,
            31406263,
            31406095,
            31408958,
            31406910,
            31404200,
            32046810,
            31410002,
            31402646,
            31408382,
            31408030,
            31409057,
            31407519,
            31408444,
            31409422,
            31410812
        ],
        "F": [
            31398084,
            31399145,
            31396559,
            31395380,
            31403081,
            31400082,
            31403804,
            31406312,
            31396246,
            31399556,
            31401521,
            31404590,
            31400144,
            31400447,
            31405585,
            31400568,
            31400491
        ],
        "D": [
            31396611,
            31396495,
            31401963,
            31398464,
            31393353,
            31401930,
            31397316,
            31400838,
            31400178,
            31401960,
            31405520,
            31403500,
            31399600,
            31393212,
            31397813,
            31402582,
            31404085,
            31402819
        ],
        "C": [
            31393812,
            31393863,
            31406345,
            31407198,
            31398483,
            31396625,
            31396317,
            31397236,
            31394681,
            31407238,
            31393913,
            31402010,
            31410726,
            31409259,
            31398396,
            31400696,
            31397975
        ],
        "B": [
            31389883,
            31401063,
            31407394,
            31393529,
            31395934,
            31391146,
            31390806,
            31391837,
            31403535,
            31403703,
            31396960,
            31396617,
            31395546,
            31393934,
            31392682,
            31393141,
            31391081
        ],
        "A": [
            31388853,
            31388828,
            31407811,
            31389006,
            31389634,
            31389036,
            31388899,
            31388792,
            31388831,
            31388861,
            31388768,
            31390308,
            31389965,
            31388888,
            31389164,
            31388787,
            31388820
        ]
    },
    "name": "D. High Cry",
    "statement": "Rick and Morty like to go to the ridge High Cry for crying loudly there\r\nis an extraordinary echo. Recently they discovered an interesting\r\nacoustic characteristic of this ridge: if Rick and Morty begin crying\r\nsimultaneously from different mountains, their cry would be heard\r\nbetween these mountains up to the height equal the bitwise OR of\r\nmountains theyâ€™ve climbed and all the mountains between them. Bitwise OR\r\nis a binary operation which is determined the following way. Consider\r\nrepresentation of numbers and in binary numeric system (probably with\r\nleading zeroes) and . Then is defined following way: , where , if or ,\r\nand otherwise. In the other words, digit of bitwise OR of two numbers\r\nequals zero if and only if digits at corresponding positions is both\r\nnumbers equals zero. For example bitwise OR of numbers and equals . In\r\nprogramming languages C/C++/Java/Python this operation is defined as ,\r\nand in Pascal as .Help Rick and Morty calculate the number of ways they\r\ncan select two mountains in such a way that if they start crying from\r\nthese mountains their cry will be heard above these mountains and all\r\nmountains between them. More formally you should find number of pairs\r\nand () such that bitwise OR of heights of all mountains between and\r\n(inclusive) is larger than the height of any mountain at this interval.\r\n",
    "solutions": [
        "#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<map>\n#define L long long\nusing namespace std;\nint n,x[200010],a[40],l[200010],r[200010];\nmap<int,int> f;\nL p;\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&x[i]);\n\tp=(L)n*(n+1)/2;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   l[i]=f[x[i]]+1;\n\t   f[x[i]]=i;\n\t   for(j=0;j<30;j++)\n\t     if(!(x[i]&(1<<j)))\n\t       l[i]=max(l[i],a[j]+1);\n\t     else\n\t       a[j]=i;\n\t  }\n\tfor(i=0;i<30;i++)\n\t  a[i]=n+1;\n\tfor(i=n;i>0;i--)\n\t  {\n\t   r[i]=n+1;\n\t   for(j=0;j<30;j++)\n\t     if(!(x[i]&(1<<j)))\n\t       r[i]=min(r[i],a[j]-1);\n\t     else\n\t       a[j]=i;\n\t   p-=(L)(i-l[i]+1)*(r[i]-i+1);\n\t  }\n\tcout<<p;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "combinatorics",
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. High Cry.json",
    "editorial_link": "https://codeforces.com//blog/entry/55233",
    "editorial": "First we find for each element the nearest element on the left and on\r\nthe right more than it. It can be done by many ways, for example using\r\nstack. Then you find for each element the nearest on the left and on the\r\nright element so that . For this note that in must be some bit set,\r\nwhich is not set in . So you can just pass from left to the right (and\r\nthen from right to the left) along the array, calculating the nearest on\r\nthe left (on the right) element in which the bit equals .We fix the\r\nmountain which will be the highest on the segment from the answer (if\r\nthe heights are equal the most left, for example). Then the segment must\r\nbe completely nested in the segment on which the given mountain is the\r\nhighest and must cross at least one element, OR with which our element\r\nis greater than the element itself. This solution works in .\r\n",
    "hint": []
}