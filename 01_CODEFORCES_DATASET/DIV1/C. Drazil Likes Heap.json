{"link": "https://codeforces.com//contest/1329/problem/C", "problemId": "582575", "problem_idx": "C", "shortId": "1329C", "contest_number": "1329", "problem_submissions": {"E": [75408443, 75525199, 75525023, 75681621, 76019995, 76016936, 75967053, 75966418], "D": [75389063, 75398925, 75385191, 75401307, 75408075, 75405008, 75403445, 75404364, 75403371, 75659972, 75411387, 75407920, 75411250, 75412465, 75413663, 75407247, 75409435, 75922378, 75921522, 75921098, 75920566, 75920416, 75919758, 75919734, 75806069, 75805925, 75803536, 75803307, 75803058, 75802910, 75800662, 75395261, 75399040], "C": [75374256, 75371549, 75396568, 75381813, 75372171, 75376833, 75380449, 75377512, 75386022, 75659958, 75378281, 75378362, 75487924, 75487540, 75487429, 75487406, 75386768, 75380568, 75386156, 75382219, 75387697, 75369638, 76036841, 75372968, 75421067], "B": [75357516, 75353754, 75360937, 75361445, 75363313, 75362516, 75363699, 75367490, 75367087, 75659949, 75361718, 75364241, 75358119, 75363158, 75368163, 75368647, 75364635, 75360193, 76036829, 75359511, 75363649, 75368965], "A": [75354673, 75356344, 75356602, 75357362, 75359450, 75355169, 75357071, 75359811, 75354137, 75659929, 75354669, 75356764, 75372979, 75355330, 75359586, 75360814, 75615883, 75354430, 76036826, 75355988, 75360416, 75354524]}, "name": "C. Drazil Likes Heap", "statement": "Drazil likes heap very much. So he created a problem with heap:There is\r\na max heap with a height h implemented on the array. The details of this\r\nheap are the following:This heap contains exactly 2^h - 1 positive\r\nnon-zero integers. All integers are distinct. These numbers are stored\r\nin the array a indexed from 1 to 2^h-1. For any 1 < i < 2^h, a[i] < a[\r\nleft\r\nlfloor{\r\nfrac{i}{2}}\r\nright\r\nrfloor].Now we want to reduce the height of this heap such that the\r\nheight becomes g with exactly 2^g-1 numbers in heap. To reduce the\r\nheight, we should perform the following action 2^h-2^g times:Choose an\r\nindex i, which contains an element and call the following function f in\r\nindex i:Note that we suppose that if a[i]=0, then index i don\u2019t contain\r\nan element.After all operations, the remaining 2^g-1 element must be\r\nlocated in indices from 1 to 2^g-1. Now Drazil wonders what\u2019s the\r\nminimum possible sum of the remaining 2^g-1 elements. Please find this\r\nsum and find a sequence of the function calls to achieve this value.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 20) + 7;\nint ord[N];\nint myPos[N];\nint bal[N];\nint a[2 * N];\nint ans[N];\nint ansSz;\nint n, m;\n\nvoid solve() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tmyPos[a[i]] = i;\n\t\tord[i - 1] = a[i];\n\t\tint v = i;\n\t\tint k = 0;\n\t\twhile(v > 1) {\n\t\t\tv /= 2;\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (int i = (1 << n); i < (1 << (n + 1)); i++)\n\t\ta[i] = 0;\n\tsort(ord, ord + (1 << n) - 1);\n\treverse(ord, ord + (1 << n) - 1);\n\tll sum = 0;\n\tansSz = 0;\n\tfor (int i = 0; i < (1 << n) - 1; i++) {\n\t\tint x = ord[i];\n\t\tint v = myPos[x];\n\t\twhile(a[v] > 0) {\n\t\t\tv *= 2;\n\t\t\tif (a[v] < a[v + 1]) v++;\n\t\t}\n\t\tv /= 2;\n\t\tif (v < (1 << m)) {\n\t\t\tsum += x;\n\t\t\tcontinue;\n\t\t}\n\t\tv = myPos[x];\n\t\tans[ansSz++] = v;\n\t\twhile(a[v] > 0) {\n\t\t\tv *= 2;\n\t\t\tif (a[v] < a[v + 1]) v++;\n\t\t\tif (a[v] > 0) myPos[a[v]] = v / 2;\n\t\t\ta[v / 2] = a[v];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "greedy", "implementation"], "dificulty": "2400", "interactive": false}