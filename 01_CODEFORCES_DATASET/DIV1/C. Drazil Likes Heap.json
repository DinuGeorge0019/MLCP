{
    "link": "https://codeforces.com//contest/1329/problem/C",
    "problemId": "582575",
    "problem_idx": "C",
    "shortId": "1329C",
    "contest_number": "1329",
    "problem_submissions": {
        "E": [
            75408443,
            75525199,
            75525023,
            75681621,
            76019995,
            76016936,
            75967053,
            75966418
        ],
        "D": [
            75389063,
            75398925,
            75385191,
            75401307,
            75408075,
            75405008,
            75403445,
            75404364,
            75403371,
            75659972,
            75411387,
            75407920,
            75411250,
            75412465,
            75413663,
            75407247,
            75409435,
            75922378,
            75921522,
            75921098,
            75920566,
            75920416,
            75919758,
            75919734,
            75806069,
            75805925,
            75803536,
            75803307,
            75803058,
            75802910,
            75800662,
            75395261,
            75399040
        ],
        "C": [
            75374256,
            75371549,
            75396568,
            75381813,
            75372171,
            75376833,
            75380449,
            75377512,
            75386022,
            75659958,
            75378281,
            75378362,
            75487924,
            75487540,
            75487429,
            75487406,
            75386768,
            75380568,
            75386156,
            75382219,
            75387697,
            75369638,
            76036841,
            75372968,
            75421067
        ],
        "B": [
            75357516,
            75353754,
            75360937,
            75361445,
            75363313,
            75362516,
            75363699,
            75367490,
            75367087,
            75659949,
            75361718,
            75364241,
            75358119,
            75363158,
            75368163,
            75368647,
            75364635,
            75360193,
            76036829,
            75359511,
            75363649,
            75368965
        ],
        "A": [
            75354673,
            75356344,
            75356602,
            75357362,
            75359450,
            75355169,
            75357071,
            75359811,
            75354137,
            75659929,
            75354669,
            75356764,
            75372979,
            75355330,
            75359586,
            75360814,
            75615883,
            75354430,
            76036826,
            75355988,
            75360416,
            75354524
        ]
    },
    "name": "C. Drazil Likes Heap",
    "statement": "Drazil likes heap very much. So he created a problem with heap:There is\r\na max heap with a height h implemented on the array. The details of this\r\nheap are the following:This heap contains exactly 2^h - 1 positive\r\nnon-zero integers. All integers are distinct. These numbers are stored\r\nin the array a indexed from 1 to 2^h-1. For any 1 < i < 2^h, a[i] < a[\r\nleft\r\nlfloor{\r\nfrac{i}{2}}\r\nright\r\nrfloor].Now we want to reduce the height of this heap such that the\r\nheight becomes g with exactly 2^g-1 numbers in heap. To reduce the\r\nheight, we should perform the following action 2^h-2^g times:Choose an\r\nindex i, which contains an element and call the following function f in\r\nindex i:Note that we suppose that if a[i]=0, then index i don\u2019t contain\r\nan element.After all operations, the remaining 2^g-1 element must be\r\nlocated in indices from 1 to 2^g-1. Now Drazil wonders what\u2019s the\r\nminimum possible sum of the remaining 2^g-1 elements. Please find this\r\nsum and find a sequence of the function calls to achieve this value.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 20) + 7;\nint ord[N];\nint myPos[N];\nint bal[N];\nint a[2 * N];\nint ans[N];\nint ansSz;\nint n, m;\n\nvoid solve() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tmyPos[a[i]] = i;\n\t\tord[i - 1] = a[i];\n\t\tint v = i;\n\t\tint k = 0;\n\t\twhile(v > 1) {\n\t\t\tv /= 2;\n\t\t\tk++;\n\t\t}\n\t}\n\tfor (int i = (1 << n); i < (1 << (n + 1)); i++)\n\t\ta[i] = 0;\n\tsort(ord, ord + (1 << n) - 1);\n\treverse(ord, ord + (1 << n) - 1);\n\tll sum = 0;\n\tansSz = 0;\n\tfor (int i = 0; i < (1 << n) - 1; i++) {\n\t\tint x = ord[i];\n\t\tint v = myPos[x];\n\t\twhile(a[v] > 0) {\n\t\t\tv *= 2;\n\t\t\tif (a[v] < a[v + 1]) v++;\n\t\t}\n\t\tv /= 2;\n\t\tif (v < (1 << m)) {\n\t\t\tsum += x;\n\t\t\tcontinue;\n\t\t}\n\t\tv = myPos[x];\n\t\tans[ansSz++] = v;\n\t\twhile(a[v] > 0) {\n\t\t\tv *= 2;\n\t\t\tif (a[v] < a[v + 1]) v++;\n\t\t\tif (a[v] > 0) myPos[a[v]] = v / 2;\n\t\t\ta[v / 2] = a[v];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum);\n\tfor (int i = 0; i < ansSz; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Drazil Likes Heap.json",
    "editorial_link": "https://codeforces.com//blog/entry/75559",
    "editorial": "The property of heap we concern in this problem mainly are: 1. The tree\r\nis a binary tree, each node has a weight value.2. The weight of a node\r\nis always larger than the weight of its children.3. We use to record the\r\nweight of vertex , and the number of its children are and vertex (if\r\nexist). Another key point we should consider seriously is before all\r\noperations and after all operations, the tree must be a perfect binary\r\ntree. Many contestants didn\u00e2\u0080\u0099t notice the constraint during the contest.\r\nI think there are two different thinking directions for this problem.\r\nOne is considering node from bottom to top. Another one is considering\r\nnode from top to bottom. For me, from bottom to top is more\r\nintuitive.Now we talk about \"from bottom to top\" first, it means we\r\nconsider node from larger index to smaller index in the tree after all\r\noperations (call it final tree after). For the leaves in the final tree,\r\nit\u00e2\u0080\u0099s not hard to know, the minimum possible final weight of each leaf is\r\nthe minimum weight of nodes in its subtree before all operations (call\r\nit beginning tree after). For the other nodes in the final tree, its\r\nweight must satisfy two constraints, one is it should be larger than the\r\nfinal weight of his children, another is the weight should exist in its\r\nsubtree of the beginning tree. Luckily, these lower bounds are all\r\nconstraints we should consider to get the answer. For each leaf in the\r\nfinal tree, we maintain a data structure that stores all weight of its\r\nsubtree in the beginning tree. Then the minimum value in this data\r\nstructure is its final weight. For other nodes in the final tree, we\r\nmerge the two data structures of its children. the remove all value\r\nwhich is less than the final weight of his children. There are many data\r\nstructure can do these operations, such as min heap(author\u00e2\u0080\u0099s code) or\r\nsorted array(isaf27\u00e2\u0080\u0099s code). With the above method, we get the minimum\r\npossible sum of the remaining elements. But we still don\u00e2\u0080\u0099t know how to\r\nconstruct it. All we know is which weight values are reaming in the\r\nfinal tree. Now I want to prove that no matter how the order I call the\r\nfunction , if the remaining weight values set is the same, the final\r\nshape of the final tree will be the same. This time I prove it from top\r\nto bottom. We only know which weight values set to remain in the final,\r\nThen We iterate node from smallest index to the larger one. We always\r\ncan determine the weight value of the iterated node, because the weight\r\nvalue only can be the maximum value in its subtree. This trait also can\r\nlet us know that the final tree we get in our method is a perfect binary\r\ntree.Conclude all things above. after we can apply the function from\r\nbottom to top on these nodes with weight value doesn\u00e2\u0080\u0099t exist in the\r\nfinal tree.In the \"from bottom to top\" method, it has some thinking\r\nlevel difference between calculating the minimum sum and constructing a\r\nlist of possible operations. So I determine let competitors output the\r\noperations. - - -Now we talk about the \"from top to bottom\" method. The\r\nmain idea of this method is iterating index from to and in each\r\niteration, applying the function on -th node until the shape of the\r\nfinal tree is impossible to become a perfect binary tree. The method is\r\nquite easy to write and almost has no difference when asking you to\r\noutput the operations. But I think it\u00e2\u0080\u0099s hard to prove. Evenly, I think\r\nthe solution should be wrong until I write this solution and test\r\nit.Firstly I want to prove the minimum possible final weight value of\r\nnode is the same as the above \"from top to bottom\" method get. We call\r\nthe value as . If some algorithm can get more small weight value in the\r\nfinal tree, It means all weight values which are not smaller than\r\ndisappear. But according to the conclusion \"if the remaining weight\r\nvalues set is the same, the final shape of the final tree will be the\r\nsame.\". the final tree generated by can also get with firstly applying\r\nthe function on node at least one more time than above \"from top to\r\nbottom\" algorithm, and do some other operations. But it will make the\r\nfinal tree is impossible to be the perfect binary tree. Now we disprove\r\nit.Now we want to prove the final weight value of node () is the same as\r\nthe above \"from top to bottom\" method get. Only when applying function\r\non ancestors and descendants of node will affect the final weight value\r\nof node . And when we apply on its ancestors, the may recursively apply\r\non at most once. So each time applies on its ancestors is equivalent to\r\napply on itself once or do nothing. Therefore, The proof can be don as\r\nwhat we do on node just by only considering the subtree of node . Now,\r\nwe have proved the \"top to bottom\" algorithm can make each node of the\r\nfinal tree has the minimum possible weight value. When I found the \"top\r\nto bottom\" algorithm during preparing the contest, I ever consider\r\nchanging the problem to something else because the method is too easy to\r\nguess and to write. But I have no other more proper problem that can be\r\nused. It\u00e2\u0080\u0099s a little pity for me.\r\n"
}