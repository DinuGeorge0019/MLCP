{
    "link": "https://codeforces.com//contest/2066/problem/F",
    "problemId": "3199294",
    "problem_idx": "F",
    "shortId": "2066F",
    "contest_number": "2066",
    "problem_submissions": {
        "F": [
            305961929,
            305711209,
            305793569
        ],
        "E": [
            305671371,
            305674660,
            305665469,
            305684205,
            305683469,
            310345727,
            310345697,
            310345040,
            310344970,
            310344497,
            305694481,
            305692759,
            305693640,
            305681002,
            305696381,
            305695872,
            305686452,
            305675358,
            305680777,
            305683070,
            305690451,
            305694177,
            305728015,
            305696099
        ],
        "D2": [
            305648746,
            305651253,
            305683341,
            305658883,
            305667318,
            305671414,
            305677452,
            305675429,
            305693750,
            305670413,
            305682081,
            305674110,
            305707013,
            305819437,
            305673972,
            305704574
        ],
        "D1": [
            305641952,
            305650970,
            305646344,
            305645126,
            305659222,
            305663013,
            305661891,
            305665940,
            305665958,
            305662965,
            305663912,
            305674196,
            305649164,
            305650961,
            305657269,
            305647121,
            305660139,
            305661141,
            305667237
        ],
        "C": [
            305634452,
            305633837,
            305639878,
            305638169,
            305653394,
            305631789,
            305636828,
            305651476,
            305661411,
            305643169,
            305658240,
            305653292,
            305630480,
            305641469,
            305649547,
            305637115,
            305653856,
            305647798,
            305652374
        ],
        "B": [
            305627289,
            305635243,
            305623300,
            305628744,
            305647081,
            305643811,
            305641796,
            305631285,
            305634558,
            305631722,
            305638100,
            305660386,
            305639015,
            305628890,
            305637597,
            305626680,
            305646425,
            305631817,
            305639727
        ],
        "A": [
            305621144,
            305616029,
            305632571,
            305622624,
            305643284,
            305653176,
            305619400,
            305618136,
            305626320,
            305627945,
            305642775,
            305657405,
            305632785,
            305618364,
            305626420,
            305620045,
            305626552,
            305622482,
            305623998
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139415?locale=en",
    "editorial": "the maximum sum of a non-empty subarray .A detailed proof of the\r\nsolution will be at the end of the analysis.First, we need to\r\ncharacterize all arrays reachable from through operations. Often, in\r\nsuch cases, we want to find some property that remains unchanged during\r\noperations or changes in a predictable way (for example, only\r\nincreases). However, in this problem, neither the elements nor the\r\nlength of the array are constant, so at first glance, it is unclear what\r\nkind of invariant we want to find.Let’s consider a minimal example where\r\nnot all arrays are explicitly reachable from the original one, and there\r\nare some restrictions. Let . In the first operation, we replace one of\r\nthe s. If we replace it with an array with a maximum subarray sum , we\r\nare then obliged to replace something inside that subarray. If we\r\nreplace it with an array with a maximum subarray sum , we must also\r\nreplace either strictly inside that array or the second . Thus, all\r\nchanges occur either in the array generated by the first or the second .\r\nWe can represent a barrier between the elements of the array: . Any\r\nreplacement of a subarray will never cross this barrier.It turns out\r\nthat, in general, we can set such barriers that will never be crossed\r\nduring operations in a fairly intuitive way.For the array , we define a\r\nof the array into subsegments recursively: The cool partition of an\r\nempty array is empty. We find any segment such that . Then the cool\r\npartition will consist of the segments of the cool partition , the\r\nsegment , and the segments of the cool partition . It is not difficult\r\nto prove that the cool partition is uniquely defined for each array. It\r\nturns out that if we represent barriers between neighboring segments of\r\nthe cool partition, these barriers will never be crossed during\r\noperations. Moreover, the cool partition of any array obtained from\r\nthrough operations will contain at least the same barriers as .At the\r\nsame time, due to the properties of construction, one operation in the\r\narray completely replaces one of the segments of the cool partition with\r\nthe maximum sum. It turns out that all arrays reachable from must have\r\nthe following structure: Any number is chosen from the sums of the\r\nsegments of the cool partition of . Among the segments of the cool\r\npartition of , those segments whose sum is remain unchanged. Among the\r\nremaining segments: one is replaced with an arbitrary non-empty array,\r\nand all others with an arbitrary non-empty array such that . The\r\nsequence of operations is as follows: we replace all segments in\r\ndescending order of their sums. The segment we want to replace with an\r\narbitrary array is first replaced with . After all segments are\r\nreplaced, the last operation replaces this with an arbitrary\r\narray.Knowing this, we can solve the problem using dynamic programming\r\nin .We will precompute the cool partition of the array . Then we can\r\niterate over the separator value in , and for each such value, we will\r\nrun the dynamic programming whether it is possible to match a prefix of\r\nthe first segments of the special partition to the prefix , where\r\nindicates whether we have already used a replacement with an arbitrary\r\nnon-empty array, or all current replacements were with arrays with .\r\nNaively, the recalculation will work in , but with some simple\r\noptimizations, it is easy to achieve a total asymptotic complexity of\r\nrecalculation for all states of , and then the entire dynamic\r\nprogramming will work in , and the whole solution in .Now, here is the\r\ncomplete proof of the solution.Given an array of integers.The following\r\noperation is given: Choose any pair such that , and is maximum among all\r\nnumbers of the form . Replace the subarray with an arbitrary non-empty\r\narray. That is, replace the working array with , where and are chosen by\r\nyou, and the numbers are integers. Goal: characterize all arrays\r\nreachable from through unlimited applications of such operations.\r\ndenotes the subarray . denotes .A segment will be called if: is maximum\r\namong all segments. it holds that . If operations are applied only to\r\nsegments, the set of reachable arrays will not change.Proof:If the\r\nsegment is not cool, then such that and is cool. Then applying the\r\noperation to with the array can be replaced by applying the operation to\r\nwith the array , and the array after replacement will remain the\r\nsame.Therefore, any operation with a non-cool segment can be freely\r\nreplaced with an operation with a cool one, which proves the claim.Two\r\ndifferent cool segments do not intersect. That is, if and are cool\r\nsegments, and , it follows that .Proof:Assume that there are\r\nintersecting cool segments. We will consider two cases: intersection and\r\nnesting. We can consider the union and intersection of our segments. The\r\nsum of the union and intersection then equals the sums of our cool\r\nsegments. Thus, either the sum of the union is not less, and the\r\nsegments are not cool, since they can be expanded. Or the sum of the\r\nintersection is greater, and the segments are not cool, since there\r\nexists one with a greater sum. Nesting is impossible, as the smaller\r\nsegment could then be expanded to a larger one, meaning by definition it\r\nis not cool. Let’s introduce the concept of partitioning the array into\r\ncool segments: a cool partition.For the array , we define a cool\r\npartition recursively: If is a cool segment, then the cool partition\r\nwill consist of one segment . Otherwise, we find any cool segment . Then\r\nthe cool partition will consist of the segments of the cool partition ,\r\nthe segment , and the segments of the cool partition . It is easy to see\r\nthat the cool partition is uniquely defined. This follows from Claim\r\n3.In one operation, one of the segments of the cool partition with the\r\nmaximum sum is completely replaced.It is obvious that we literally\r\ndefined the cool partition such that all cool segments of the original\r\narray are included, and we replace only cool segments.The existing\r\nboundaries of the cool partition will necessarily remain the same after\r\nthe operation.That is, if our array and its cool partition are: And we\r\nreplace the cool segment with maximum sum with some , then after the\r\noperation, the cool partition of the array will continue to contain all\r\nthe same segments to the left and right of the replaced one. That is,\r\nthe cool partition of the new array will look like: Where is the cool\r\npartition of the array .Proof:Any subarray from the cool partition has\r\nthe property that all sums of subarrays of do not exceed the sum of .\r\nOtherwise, a subsegment with a greater sum would have been chosen\r\ninstead of in the cool partition.Also, we note that , since otherwise\r\nwould not be a cool segment, as it could be expanded to the left without\r\nlosing its sum. Similarly, it follows that .Therefore, the boundaries\r\naround the old cool segment will necessarily be preserved. If any of\r\nthem is violated, the intersecting boundary array will have a prefix or\r\nsuffix with a negative sum, which violates the property of the subarray\r\nfrom the cool partition, as the complement of this prefix/suffix would\r\nhave a greater sum than the subarray itself.Since the boundaries hold,\r\nthe cool partition in 3 parts will be independent of each other, and\r\nthus it will remain the same on the left and right as before, while\r\ninside will be .The scale of the operation replacing the segment will be\r\ncalled .A finite sequence of operations will be called reasonable if the\r\nsequence of of the operations is strictly . That is, for all , where is\r\nthe scale of the -th operation.If we consider only reasonable sequences\r\nof operations, the set of reachable arrays will remain the same.If there\r\nis some unreasonable sequence of operations, then it has .This means\r\nthat during the -th operation, the maximum sum of the cool segment\r\nincreased. But as we know, the old segments all remained, and only is\r\nnew. Thus, the next operation will be entirely within . But then we\r\ncould have made this replacement in the previous operation immediately,\r\nresulting in one less operation.Therefore, the shortest path to each\r\nreachable array is reasonable, as any unreasonable one can be shortened\r\nby one operation. Thus, any reachable array is necessarily reachable by\r\nreasonable sequences of operations.Now we are ready to formulate and\r\nprove the necessary condition for a reachable array.Let the sums in the\r\nsegments of the cool partition of the original array be: .It is claimed\r\nthat all reachable arrays must have the following form (necessary\r\ncondition): Some integer is chosen. Among the segments of the cool\r\npartition, those segments whose sum is remain unchanged. Among the\r\nremaining segments: one chosen segment is replaced with an arbitrary\r\nnon-empty array, and all others with an arbitrary non-empty array such\r\nthat the sum of its maximum subarray . And the reachable array =\r\nconcatenation of these segments.Let’s show that any finite reasonable\r\nsequence of operations must lead us to an array of the described form.We\r\nhave the initial boundaries of the cool partition of the given array. As\r\nwe know, they will remain with us forever. Also, the sums in these\r\nsegments cannot increase BEFORE the last operation is applied, as we are\r\nonly considering reasonable sequences. The very last operation can, of\r\ncourse, increase the sum.Therefore, let us say that in the last\r\noperation we replace the subarray with scale .We look at the state of\r\nour array before this last operation.The segments of the cool partition\r\nwith a sum could not have changed, again because we are only considering\r\nreasonable sequences, and since is the scale of the last operation, ALL\r\noperations had a scale of at least .In the segments of the cool\r\npartition with a sum , now between these same boundaries, the sum of the\r\nmaximum subarray must be . New boundaries of the cool partition may have\r\nappeared, but this is not important to us. We are only looking at the\r\noriginal boundaries and the sums between them.Thus, it turns out to be a\r\ndescription as above. And in the last operation, one of the segments is\r\nreplaced with an arbitrary array. This last segment must also lie\r\nentirely within the boundaries of one of the segments of the original\r\ncool partition. Therefore, we can safely say that the entire\r\ncorresponding cool segment was replaced, as in the claimed\r\ndescription.In the end, any sequence of operations must fit the\r\ndescription.And it remains to show the sufficiency: that any array from\r\nthe description is reachable.We simply take and replace the cool\r\nsegments with the desired arrays in descending order of their sums. The\r\none we plan to replace last, with an arbitrary array, is first replaced\r\nsimply with , and then when we replace everything we wanted, we replace\r\nit last with an arbitrary array.Thus, the proposed description is indeed\r\nthe description of all reachable arrays.\r\n",
    "name": "F. Curse",
    "statement": "You are given two arrays of integers: a_1, a_2,\r\nldots, a_n and b_1, b_2,\r\nldots, b_m.You need to determine if it is possible to transform array a\r\ninto array b using the following operation several (possibly, zero)\r\ntimes. Among all non-empty subarrays^{\r\ntext{ }} of a, choose any with the maximum sum, and replace this\r\nsubarray with an arbitrary non-empty integer array.If it is possible,\r\nyou need to construct any possible sequence of operations. Constraint:\r\nin your answer, the sum of the lengths of the arrays used as\r\nreplacements must not exceed n + m across all operations. The numbers\r\nmust not exceed 10^9 in absolute value.^{\r\ntext{ }}An array a is a subarray of an array b if a can be obtained from\r\nb by the deletion of several (possibly, zero or all) elements from the\r\nbeginning and several (possibly, zero or all) elements from the end.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Curse.json",
    "hint": []
}