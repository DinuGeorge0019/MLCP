{"link": "https://codeforces.com//contest/997/problem/E", "problemId": "194454", "problem_idx": "E", "shortId": "997E", "contest_number": "997", "problem_submissions": {"D": [39842612, 39837685, 39842379, 39838295, 39837935, 39842740, 39843076, 39859781, 39844833, 39844190, 39833354, 39839922, 39854124, 39853938, 39841292, 39838113, 39841101, 39836594, 39854271, 39854180, 39841626], "E": [39838988, 39839303, 40677876, 39860384, 216157458, 207265582], "C": [39833262, 39841343, 39842130, 39832983, 39840312, 39831596, 39835919, 39837971, 39858804, 39838178, 39837144, 39850195, 39850032, 39850007, 39849997, 39849695, 39849346, 39849204, 39848619, 39840597, 39849012, 39851642, 39851588, 39851576, 39851518, 39851506, 39851317, 39851202, 39850994, 39850828, 39850773, 39850608, 39850592, 39850571, 39850194, 39850131, 39850042, 39850008, 39849917, 39849907, 39849611, 39849473, 39849310, 39849195, 39849073, 39849029, 39848917, 39848844, 39833638], "B": [39825922, 39826364, 39827934, 39825576, 39828070, 39839886, 39829927, 39831407, 39858660, 39828494, 39832160, 39839554, 39828743, 39833583, 39835350, 39842444, 39828730, 39826817], "A": [39823476, 39823484, 39823390, 39823892, 39823506, 39823245, 39824375, 39824053, 39858605, 39823570, 39823352, 39837740, 39823612, 39823561, 39841314, 39824552, 39838338, 39823711, 39823355]}, "name": "E. Good Subsegments", "statement": "A permutation p of length n is a sequence p_1, p_2,\r\nldots, p_n consisting of n distinct integers, each of which from 1 to n\r\n(1\r\nleq p_i\r\nleq n) .Let\u2019s call the subsegment [l,r] of the permutation if all\r\nnumbers from the minimum on it to the maximum on this subsegment occur\r\namong the numbers p_l, p_{l+1},\r\ndots, p_r.For example, good segments of permutation [1, 3, 2, 5, 4] are:\r\n[1, 1], [1, 3], [1, 5], [2, 2], [2, 3], [2, 5], [3, 3], [4, 4], [4, 5],\r\n[5, 5]. You are given a permutation p_1, p_2,\r\nldots, p_n.You need to answer q queries of the form: find the number of\r\ngood subsegments of the given segment of permutation.In other words, to\r\nanswer one query, you need to calculate the number of good subsegments\r\n[x\r\ndots y] for some given segment [l\r\ndots r], such that l\r\nleq x\r\nleq y\r\nleq r.\r\n", "solutions": ["#pragma GCC optimize(\"-O3\",\"-funroll-all-loops\")\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,p[SZ],q,ls[SZ],rs[SZ];\nvector<int> v[SZ];\nint s1[SZ],n1,s2[SZ],n2;\n//sqrt-blocking works better than segment tree\nconst int S=350;\n#define B S\ntypedef pair<ll,ll> pll;\ninline pll operator + (pll a,pll b)\n{\n\tif(!a.se) return b;\n\tif(!b.se) return a;\n\tif(a.fi<b.fi) return a;\n\tif(a.fi>b.fi) return b;\n\treturn pll(a.fi,a.se+b.se);\n}\nll x[SZ]; pll bmi[SZ],bmt[SZ],emi[SZ];\nll ba[SZ],bt[SZ];\nvoid pd(int b)\n{\n\tif(!bt[b]&&!bmt[b].se) return;\n\tbmi[b]=mp(8e18,0);\n\tfor(int j=b*S;j<b*S+S;++j)\n\t{\n\t\temi[j]=emi[j]+pll(bmt[b].fi+x[j],bmt[b].se);\n\t\tx[j]+=bt[b]; bmi[b]=bmi[b]+pll(x[j],1);\n\t}\n\tbmt[b]=mp(0,0); bt[b]=0;\n}\nvoid fedt(int b,int l,int r,int v)\n{\n\tfor(int j=max(b*S,l);j<b*S+S&&j<=r;++j) x[j]+=v;\n\tbmi[b]=mp(8e18,0);\n\tfor(int j=b*S;j<b*S+S;++j)\n\t\tbmi[b]=bmi[b]+pll(x[j],1);\n}\nvoid edt(int l,int r,int x)\n{\n\tpd(l/B),fedt(l/B,l,r,x);\n\tif(l/B!=r/B) pd(r/B),fedt(r/B,l,r,x);\n\tfor(int s=l/B+1;s<r/B;++s)\n\t\tbt[s]+=x;\n}\nvoid pr()\n{\n\tfor(int s=0;s<=n/B;++s)\n\t{\n\t\tif(bmi[s].fi+bt[s]==-1) ba[s]+=bmi[s].se;\n\t\tbmt[s]=bmt[s]+pll(bt[s],1);\n\t}\n}\nll qry(int l)\n{\n\tint bl=l/B;\n\tpd(bl); ll ans=0;\n\tfor(int t=l;t/B==bl;++t)\n\t\tans+=(emi[t].fi==-1)?emi[t].se:0;\n\tfor(int t=bl+1;t<=n/B;++t)\n\t\tans+=ba[t];\n\treturn ans;\n}\nll ans[SZ];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",p+i);\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;++i)\n\t\tscanf(\"%d%d\",ls+i,rs+i),v[rs[i]].pb(i);\n\t//max-min-len>=0, required:=0\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\twhile(n1&&p[s1[n1]]<p[i])\n\t\t\tedt(s1[n1-1]+1,s1[n1],p[i]-p[s1[n1]]),--n1;\n\t\twhile(n2&&p[s2[n2]]>p[i])\n\t\t\tedt(s2[n2-1]+1,s2[n2],p[s2[n2]]-p[i]),--n2;\n\t\ts1[++n1]=i; s2[++n2]=i;\n\t\tedt(1,i,-1); pr();\n\t\tfor(auto p:v[i])\n\t\t\tans[p]=qry(ls[p]);\n\t}\n\tfor(int i=1;i<=q;++i)\n\t\tprintf(\"%lld\\n\",ans[i]);\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3000", "interactive": false}