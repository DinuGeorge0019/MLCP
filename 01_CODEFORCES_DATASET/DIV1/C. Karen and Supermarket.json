{
    "link": "https://codeforces.com//contest/815/problem/C",
    "problemId": "110361",
    "problem_idx": "C",
    "shortId": "815C",
    "contest_number": "815",
    "problem_submissions": {
        "B": [
            27864858,
            27859364,
            27903526,
            27860492,
            27852460,
            27855418,
            27859767,
            27852085,
            27859930,
            27859903,
            27854384,
            27858144,
            27855716,
            27857016,
            27852895,
            27853886
        ],
        "E": [
            27862063,
            27864392,
            27859827,
            27862681,
            27864496,
            27861206,
            27867128,
            27865357,
            27880319,
            27880161
        ],
        "D": [
            27858987,
            27856145,
            27857852,
            27860187,
            27858848,
            27861659,
            27861479,
            27862104,
            27862042,
            27861841,
            27863258,
            27862833,
            27864478,
            27862444,
            27863816,
            27862729
        ],
        "C": [
            27854913,
            27853891,
            27854000,
            27853599,
            27853527,
            27856985,
            27855683,
            27858430,
            27852703,
            27859114,
            27854140,
            27852346,
            27858894,
            27853926,
            27859017,
            27859597,
            27856510,
            27857717
        ],
        "A": [
            27848955,
            27860238,
            27848568,
            27848584,
            27855106,
            27849560,
            27848196,
            27849865,
            27848239,
            27854177,
            27850649,
            27854333,
            27856456,
            27849527,
            27857857
        ]
    },
    "name": "C. Karen and Supermarket",
    "statement": "On the way home, Karen decided to stop by the supermarket to buy some\r\ngroceries. She needs to buy a lot of goods, but since she is a student\r\nher budget is still quite limited. In fact, she can only spend up to\r\ndollars.The supermarket sells goods. The -th good can be bought for\r\ndollars. Of course, each good can only be bought once.Lately, the\r\nsupermarket has been trying to increase its business. Karen, being a\r\nloyal customer, was given coupons. If Karen purchases the -th good, she\r\ncan use the -th coupon to decrease its price by . Of course, a coupon\r\ncannot be used without buying the corresponding good.There is, however,\r\na constraint with the coupons. For all , in order to use the -th coupon,\r\nKaren must also use the -th coupon (which may mean using even more\r\ncoupons to satisfy the requirement for that coupon).Karen wants to know\r\nthe following. What is the maximum number of goods she can buy, without\r\nexceeding her budget ?\r\n",
    "solutions": [
        "//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=5007;\nconst long long inf=1000*1000*1000+7;\n\nint n;\nlong long b;\n\nlong long c[nax];\nlong long d[nax];\nint oj[nax];\nvector <int> graf[nax];\n\nint roz[nax];\nlong long dpkup[nax][nax];\nlong long dpbez[nax][nax];\n\nvoid dfs(int v)\n{\n\tfor (int i=0; i<=n; i++)\n\t\tdpkup[v][i]=dpbez[v][i]=inf;\n\t\n\troz[v]=0;\n\t\n\tdpkup[v][0]=0;\n\tdpbez[v][0]=0;\n\t\n\tfor (int i : graf[v])\n\t{\n\t\tdfs(i);\n\t\t\n\t\tfor (int j=roz[v]; j>=0; j--)\n\t\t{\n\t\t\tfor (int l=roz[i]; l>=0; l--)\n\t\t\t{\n\t\t\t\tdpkup[v][j+l]=min(dpkup[v][j+l], dpkup[v][j]+min(dpkup[i][l], dpbez[i][l]));\n\t\t\t\tdpbez[v][j+l]=min(dpbez[v][j+l], dpbez[v][j]+dpbez[i][l]);\n\t\t\t}\n\t\t}\n\t\troz[v]+=roz[i];\n\t}\n\tfor (int i=roz[v]; i>=0; i--)\n\t\tdpkup[v][i+1]=dpkup[v][i]+c[v]-d[v];\n\tfor (int i=roz[v]; i>=0; i--)\n\t\tdpbez[v][i+1]=min(dpbez[v][i+1], dpbez[v][i]+c[v]);\n\troz[v]++;\n}\n\nint main()\n{\n\tscanf(\"%d%lld\", &n, &b);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld%lld\", &c[i], &d[i]);\n\t\tif (i>1)\n\t\t{\n\t\t\tscanf(\"%d\", &oj[i]);\n\t\t\tgraf[oj[i]].push_back(i);\n\t\t}\n\t}\n\t\n\tdfs(1);\n\t\n\tfor (int i=1; 1; i++)\n\t{\n\t\tif (i>n || ( dpbez[1][i]>b && dpkup[1][i]>b ))\n\t\t{\n\t\t\tprintf(\"%d\\n\", i-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Karen and Supermarket.json",
    "editorial_link": "https://codeforces.com//blog/entry/52742",
    "editorial": "Instead of asking for the maximum number of items we can buy with\r\ndollars, letâs ask instead for the minimum cost to buy items for all .\r\nAfterwards, we can simply brute force all to find the largest that still\r\nfits within her budget .Note this problem is actually on a rooted tree,\r\nwith root at node ; the constraint guarantees there are no cycles in\r\nthis problem. The coupon requirement essentially means that if we buy\r\ngood at the discounted price, we also need to buy good at the discounted\r\nprice, and so on. If we donât buy at discounted price there are no\r\nconstraints (except that Karen can afford it. Unfortunately, she isnât a\r\ncriminal.)There is a rather straightforward dynamic programming solution\r\nto this problem, as follows:Let be the minimum cost to buy items in the\r\nsubtree of if we can still use coupons, and the minimum cost to buy\r\nitems in the subtree of if we cannot use any more coupons.We know that\r\nfor all leaves, and .We can compute for all nodes as well; this is\r\nsimply the sum of the smallest âs in the subtree of . This can be done\r\nstraightforwardly in or .To compute this for some non-leaf node , we\r\nshould initialize .Now, we can add each of the children of one by one,\r\nand try each . Suppose we take elements from one of the children. Then\r\nwe have . We just have to make sure to implement it in a way that we\r\ndonât inadvertently take elements multiple times, usually by making an\r\nauxiliary array.Finally, we set to consider not using the coupons. Note\r\nthat we canât do this at the start, because otherwise it could cause\r\nconflicts.This runs in , which is too slow. This is because there are\r\nnodes, and to compute for all in that node, it takes where is the set of\r\nall of the children of , and is the subtree size of node . This sum\r\nturns out to be , and so the final runtime is .How could we make it\r\nfaster? Take the largest (in terms of nodes) child of subtree . Can we\r\navoid iterating through this?Yes, we can! Suppose our tree was binary.\r\nNow, we can compute , where and are the subtrees of , with . This skips\r\niterating through the larger subtree .We can extend this to non-binary\r\ntrees, too; just do this to skip the largest subtree, and then add the\r\nrest like before.The runtime of the transition is now , which turns out\r\nto be just . The final runtime is hence (or , depending on the algorithm\r\nused for the greedy portion.) This is sufficient to solve this problem.\r\n",
    "hint": []
}