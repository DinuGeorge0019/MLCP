{"link": "https://codeforces.com//contest/815/problem/C", "problemId": "110361", "problem_idx": "C", "shortId": "815C", "contest_number": "815", "problem_submissions": {"B": [27864858, 27859364, 27903526, 27860492, 27852460, 27855418, 27859767, 27852085, 27859930, 27859903, 27854384, 27858144, 27855716, 27857016, 27852895, 27853886], "E": [27862063, 27864392, 27859827, 27862681, 27864496, 27861206, 27867128, 27865357, 27880319, 27880161], "D": [27858987, 27856145, 27857852, 27860187, 27858848, 27861659, 27861479, 27862104, 27862042, 27861841, 27863258, 27862833, 27864478, 27862444, 27863816, 27862729], "C": [27854913, 27853891, 27854000, 27853599, 27853527, 27856985, 27855683, 27858430, 27852703, 27859114, 27854140, 27852346, 27858894, 27853926, 27859017, 27859597, 27856510, 27857717], "A": [27848955, 27860238, 27848568, 27848584, 27855106, 27849560, 27848196, 27849865, 27848239, 27854177, 27850649, 27854333, 27856456, 27849527, 27857857]}, "name": "C. Karen and Supermarket", "statement": "On the way home, Karen decided to stop by the supermarket to buy some\r\ngroceries. She needs to buy a lot of goods, but since she is a student\r\nher budget is still quite limited. In fact, she can only spend up to\r\ndollars.The supermarket sells goods. The -th good can be bought for\r\ndollars. Of course, each good can only be bought once.Lately, the\r\nsupermarket has been trying to increase its business. Karen, being a\r\nloyal customer, was given coupons. If Karen purchases the -th good, she\r\ncan use the -th coupon to decrease its price by . Of course, a coupon\r\ncannot be used without buying the corresponding good.There is, however,\r\na constraint with the coupons. For all , in order to use the -th coupon,\r\nKaren must also use the -th coupon (which may mean using even more\r\ncoupons to satisfy the requirement for that coupon).Karen wants to know\r\nthe following. What is the maximum number of goods she can buy, without\r\nexceeding her budget ?\r\n", "solutions": ["//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=5007;\nconst long long inf=1000*1000*1000+7;\n\nint n;\nlong long b;\n\nlong long c[nax];\nlong long d[nax];\nint oj[nax];\nvector <int> graf[nax];\n\nint roz[nax];\nlong long dpkup[nax][nax];\nlong long dpbez[nax][nax];\n\nvoid dfs(int v)\n{\n\tfor (int i=0; i<=n; i++)\n\t\tdpkup[v][i]=dpbez[v][i]=inf;\n\t\n\troz[v]=0;\n\t\n\tdpkup[v][0]=0;\n\tdpbez[v][0]=0;\n\t\n\tfor (int i : graf[v])\n\t{\n\t\tdfs(i);\n\t\t\n\t\tfor (int j=roz[v]; j>=0; j--)\n\t\t{\n\t\t\tfor (int l=roz[i]; l>=0; l--)\n\t\t\t{\n\t\t\t\tdpkup[v][j+l]=min(dpkup[v][j+l], dpkup[v][j]+min(dpkup[i][l], dpbez[i][l]));\n\t\t\t\tdpbez[v][j+l]=min(dpbez[v][j+l], dpbez[v][j]+dpbez[i][l]);\n\t\t\t}\n\t\t}\n\t\troz[v]+=roz[i];\n\t}\n\tfor (int i=roz[v]; i>=0; i--)\n\t\tdpkup[v][i+1]=dpkup[v][i]+c[v]-d[v];\n\tfor (int i=roz[v]; i>=0; i--)\n\t\tdpbez[v][i+1]=min(dpbez[v][i+1], dpbez[v][i]+c[v]);\n\troz[v]++;\n}\n\nint main()\n{\n\tscanf(\"%d%lld\", &n, &b);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld%lld\", &c[i], &d[i]);\n\t\tif (i>1)\n\t\t{\n\t\t\tscanf(\"%d\", &oj[i]);\n\t\t\tgraf[oj[i]].push_back(i);\n\t\t}\n\t}\n\t\n\tdfs(1);\n\t\n\tfor (int i=1; 1; i++)\n\t{\n\t\tif (i>n || ( dpbez[1][i]>b && dpkup[1][i]>b ))\n\t\t{\n\t\t\tprintf(\"%d\\n\", i-1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "trees"], "dificulty": "2400", "interactive": false}