{"link": "https://codeforces.com//contest/542/problem/E", "problemId": "27153", "problem_idx": "E", "shortId": "542E", "contest_number": "542", "problem_submissions": {"E": [10988594, 10988662, 10988040, 10988519, 10989472, 10986646, 10986386, 10987525, 10987889, 10997446, 10987208, 10988323, 10987814], "A": [10988183, 10988073, 10988917, 10988039, 10988066, 10988030, 10988339, 10987042, 10988676, 10988761, 10989522, 10985841, 10987459, 10994455], "D": [10986695, 10987150, 10987152, 10986150, 10986231, 10986943, 10990837, 10988365, 10989849, 10993982, 11035792, 11035777, 11035767, 11035727, 10990386, 10992159, 10990340, 10990120, 10987703, 10987627], "F": [10986005, 10986369, 10987577, 10990309, 10986553, 10985927, 10987236, 10985531, 10987038, 10986965, 10986721, 10986640, 10986454, 10985938, 10985827, 10985838, 10986342, 10986368], "C": [10985518, 10985721, 10985435, 10985462, 10985406, 10986200, 10986782, 10986530, 10985521, 10986222, 10986134, 10985353, 10985405, 10985560, 10985649, 10985787], "B": [10996302, 11060742, 11054057]}, "name": "E. Playing on Graph", "statement": "Vova and Marina love offering puzzles to each other. Today Marina\r\noffered Vova to cope with the following task.Vova has a non-directed\r\ngraph consisting of vertices and edges without loops and multiple edges.\r\nLet\u2019s define the operation of two vertices and that are . As a result of\r\nthis operation vertices and are deleted and instead of them a new vertex\r\nis added into the graph, and also edges are drawn from it to all\r\nvertices that were connected with or with (specifically, if the vertex\r\nwas connected with both and , then also exactly one edge is added from\r\nto it). Thus, as a result of again a non-directed graph is formed, it\r\ncontains no loops nor multiple edges, and it contains vertices.Vova must\r\nperform the an arbitrary number of times to transform the given graph\r\ninto a of the maximum length. A of length () is a connected graph whose\r\nvertices can be numbered with integers from to so that the edges of the\r\ngraph connect all pairs of vertices () and only them. Specifically, the\r\ngraph that consists of one vertex is a chain of length . The vertices\r\nthat are formed as a result of the are allowed to be used in the\r\nfollowing operations of . Help Vova cope with his girlfriend\u2019s task.\r\nFind the maximum length of the chain that can be obtained from the\r\nresulting graph or else determine that it is impossible to obtain the\r\nchain.\r\n", "solutions": ["#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1100;\n\nint N, M;\nvector <int> edge[MAXN];\nbool seen[MAXN];\nbool bad;\nint par[MAXN];\n\nvector <int> cvert;\nint dist[MAXN];\n\nvoid flood (int cloc, int cpar)\n{\n    if (par[cloc] == 1 - cpar)\n    {\n        bad = true;\n        return;\n    }\n    \n    if (seen[cloc])\n        return;\n    seen[cloc] = true;\n    par[cloc] = cpar;\n    cvert.push_back (cloc);\n    \n    for (int i = 0; i < edge[cloc].size(); i++)\n        flood (edge[cloc][i], 1 - cpar);\n}\n\nvector <int> q;\n\nint solve (int start)\n{\n    cvert.clear();\n    flood (start, 0);\n    \n    int res = 0;\n    for (int i = 0; i < cvert.size(); i++)\n    {\n        int cloc = cvert[i];\n        \n        for (int j = 0; j < N; j++)\n            dist[j] = 1e9;\n        \n        dist[cloc] = 0;\n        q.clear();\n        q.push_back (cloc);\n        \n        for (int j = 0; j < q.size(); j++)\n        {\n            int x = q[j];\n            for (int k = 0; k < edge[x].size(); k++)\n            {\n                int neigh = edge[x][k];\n                if (dist[neigh] > dist[x] + 1)\n                {\n                    dist[neigh] = dist[x] + 1;\n                    \n                    //cout << i << \" \" << neigh << \" \" << dist[neigh] << \"\\n\";\n                    res = max (res, dist[neigh]);\n                    q.push_back (neigh);\n                }\n            }\n        }\n    }\n    \n    //cout << start << \" \" << res << \"\\n\";\n    return res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    \n    cin >> N >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        edge[a].push_back (b);\n        edge[b].push_back (a);\n    }\n    \n    for (int i = 0; i < N; i++)\n    {\n        seen[i] = false;\n        par[i] = 2;\n    }\n    bad = false;\n    \n    int ans = 0;\n    for (int i = 0; i < N; i++)\n        if (!seen[i])\n            ans += solve (i);\n    \n    if (bad)\n        cout << \"-1\\n\";\n    else\n        cout << ans << \"\\n\";\n    return 0;\n}"], "input": "", "output": "", "tags": ["graphs", "shortest paths"], "dificulty": "2600", "interactive": false}