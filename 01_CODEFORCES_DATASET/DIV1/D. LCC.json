{
    "link": "https://codeforces.com//contest/1286/problem/D",
    "problemId": "509643",
    "problem_idx": "D",
    "shortId": "1286D",
    "contest_number": "1286",
    "problem_submissions": {
        "E": [
            68277312,
            68282070,
            68274194,
            68303699,
            68303260,
            68305269,
            68280891,
            68275520,
            68485018,
            68484885,
            68281607,
            68589901,
            71865785,
            101133015,
            68300396
        ],
        "C2": [
            68266879,
            68290041,
            68261617,
            68262301,
            68264579,
            68294367,
            68270650,
            68281404,
            68295029,
            68426335,
            68286377,
            68264588,
            68267031
        ],
        "D": [
            68263572,
            68264108,
            68884999,
            68884847,
            68884788,
            68283246,
            68268908,
            68270542,
            68266913,
            68271305,
            68294377,
            68276847,
            68262972,
            68265436,
            68273176,
            68274949,
            68277188,
            68266253,
            68271981,
            68278589,
            68338459,
            68281162,
            68264815
        ],
        "C1": [
            68253495,
            68254635,
            68259019,
            68259783,
            68260037,
            68294288,
            68263649,
            68253659,
            68276644,
            68259313,
            68260800,
            68257683,
            68278462,
            68275645,
            68260838,
            68264488,
            68260121
        ],
        "B": [
            68249656,
            68250720,
            68252206,
            68250842,
            68249851,
            68249360,
            68294267,
            68254854,
            68250823,
            68250630,
            68252322,
            68250475,
            68253134,
            68252948,
            68253877,
            68249986,
            68255559,
            68256077,
            68252468,
            68253101,
            68252113
        ],
        "A": [
            68245108,
            68248019,
            68248101,
            68248225,
            68245837,
            68246154,
            68294224,
            68250492,
            68248558,
            68247246,
            68248005,
            68247110,
            68249600,
            68246667,
            68250822,
            68253310,
            68252365,
            68251609,
            68247685,
            68248520,
            68246550
        ],
        "F": [
            68288717,
            68426651,
            68284858,
            68284592,
            68283300,
            68321599,
            68593980,
            68272947,
            68281697,
            68274721,
            75028012
        ]
    },
    "name": "D. LCC",
    "statement": "An infinitely long Line Chillland Collider (LCC) was built in Chillland.\r\nThere are n pipes with coordinates x_i that are connected to LCC. When\r\nthe experiment starts at time 0, i-th proton flies from the i-th pipe\r\nwith speed v_i. It flies to the right with probability p_i and flies to\r\nthe left with probability (1 - p_i). The is determined as the time of\r\nthe first collision of any two protons. In case there is no collision,\r\nthe duration of the experiment is considered to be zero.Find the\r\nexpected value of the duration of the experiment.Illustration for the\r\nfirst example\r\n",
    "solutions": [
        "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define SZ 131072\nusing namespace std;\nlong long Mod = 998244353, TP[2][2];\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r * a%Mod;\n\t\ta = a * a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint n;\nstruct point {\n\tlong long d, v;\n\tint x, c1, c2;\n\tbool operator <(const point &p)const {\n\t\treturn d * p.v < p.d*v;\n\t}\n}w[401000];\nlong long X[101000], V[101000], P[101000], gg;\nstruct Tree {\n\tlong long R[SZ+SZ][2][2];\n\tvoid UDT(int nd) {\n\t\tint i, j, k;\n\t\tfor (i = 0; i < 2; i++)for (j = 0; j < 2; j++)R[nd][i][j] = 0;\n\t\tfor (i = 0; i < 2; i++)for (k = 0; k < 2; k++)for (j = 0; j < 2; j++)R[nd][i][j] = (R[nd][i][j] + R[nd * 2][i][k] * R[nd * 2 + 1][k][j]) % Mod;\n\t}\n\tvoid init(int nd, int b, int e) {\n\t\tif (b == e) {\n\t\t\tR[nd][0][0] = R[nd][1][0] = (Mod + 1 - P[b])%Mod;\n\t\t\tR[nd][0][1] = R[nd][1][1] = P[b];\n\t\t\tif (b == 1)R[nd][1][0] = R[nd][1][1] = 0;\n\t\t\treturn;\n\t\t}\n\t\tint m = (b + e) >> 1;\n\t\tinit(nd * 2, b, m);\n\t\tinit(nd * 2 + 1, m + 1, e);\n\t\tUDT(nd);\n\t}\n\tvoid Del(int nd, int b, int e, int x, int c1, int c2, int ck) {\n\t\tif (b == e) {\n\t\t\tif (ck) {\n\t\t\t\tfor (int i = 0; i < 2; i++){\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tif (i != c1 || j != c2) {\n\t\t\t\t\t\t\tTP[i][j] = R[nd][i][j];\n\t\t\t\t\t\t\tR[nd][i][j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tif (i != c1 || j != c2) {\n\t\t\t\t\t\t\tR[nd][i][j] = TP[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse R[nd][i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint m = (b + e) >> 1;\n\t\tif (x <= m)Del(nd * 2, b, m, x, c1, c2,ck);\n\t\telse Del(nd * 2 + 1, m + 1, e, x, c1, c2,ck);\n\t\tUDT(nd);\n\t}\n}T;\nint main() {\n\tint i, cnt = 0, j, k;\n\tscanf(\"%d\", &n);\n\tlong long i100 = Pow(100, Mod - 2);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld%lld\", &X[i], &V[i], &P[i]);\n\t\tP[i] = P[i] * i100%Mod;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tw[cnt++] = { X[i + 1] - X[i], V[i] + V[i + 1], i, 1,0 };\n\t\tif (V[i] < V[i + 1]) {\n\t\t\tw[cnt++] = { X[i + 1] - X[i], V[i + 1] - V[i], i, 0,0 };\n\t\t}\n\t\telse {\n\t\t\tw[cnt++] = { X[i + 1] - X[i], V[i] - V[i + 1], i, 1,1 };\n\t\t}\n\t}\n\tsort(w, w + cnt);\n\tT.init(1, 1, n);\n\tlong long res = 0;\n\tfor (i = 0; i < cnt; i++) {\n\t\tlong long l = w[i].d*Pow(w[i].v, Mod - 2) % Mod;\n\t\tint x = w[i].x;\n\n\t\tT.Del(1, 1, n, x+1, w[i].c1, w[i].c2, 1);\n\n\t\tres = (res + (T.R[1][0][0] + T.R[1][0][1])*l) % Mod;\n\t\tT.Del(1, 1, n, x+1, w[i].c1, w[i].c2, 0);\n\n\t\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math",
        "matrices",
        "probabilities"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. LCC.json",
    "editorial_link": "https://codeforces.com//blog/entry/72867",
    "editorial": "Note, that the first collision will occur between two neighboring\r\nparticles in the original array. These two particles have 3 options to\r\ncollide: both particles move to the right, both move to the left, they\r\nmove towards each other. Let\u00e2\u0080\u0099s go through these options and calculate\r\nthe time of the collision. Let\u00e2\u0080\u0099s do this for each pair of neighboring\r\nvertices and sort them by the collision time. Then the probability that\r\nth will occur first is equal to the probability that the first\r\ncollisions will not occur minus the probability that the first i will\r\nnot occur. To find these probabilities we can use the Segment Tree. In\r\neach of its vertices, we will maintain an answer for four masks on which\r\nway the first and the last particle of the segment are moving. The\r\nanswer for the mask is the probability that none of the first collisions\r\nwill not occur, and the extreme ones move in accordance with the mask.\r\nThen to add a ban for the th collision, it is enough to make an update\r\nat the point. The final asymptotic is\r\n"
}