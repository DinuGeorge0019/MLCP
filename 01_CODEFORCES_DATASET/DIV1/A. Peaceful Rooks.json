{
    "link": "https://codeforces.com//contest/1464/problem/A",
    "problemId": "839210",
    "problem_idx": "A",
    "shortId": "1464A",
    "contest_number": "1464",
    "problem_submissions": {
        "D": [
            101893944,
            101884165,
            101894987,
            101897288,
            101893426,
            101899167,
            101898742,
            101897221,
            101904879,
            101902404,
            101904041,
            101898196,
            101901056,
            101893113,
            101900043,
            101901977,
            101879521,
            101891500
        ],
        "E": [
            101884958,
            101888698,
            101880762,
            101885481,
            101895459,
            101874392,
            101918343,
            101889791,
            101890948,
            101887375,
            142038158,
            102279161,
            102087511,
            101887630,
            101883023,
            101908666,
            101908552,
            101908506,
            101893369,
            101884575,
            101899034,
            101888272,
            101881773,
            101903223,
            101903745,
            101882555
        ],
        "C": [
            101877309,
            101876849,
            101885303,
            101878303,
            101875140,
            101886810,
            101875737,
            101878040,
            101880124,
            101880970,
            101877103,
            101881975,
            101878148,
            101882821,
            101880363,
            101877971,
            101885296,
            101877773,
            101876637
        ],
        "B": [
            101870508,
            101872024,
            101876423,
            101872980,
            101870882,
            101883179,
            101870101,
            101869654,
            101875498,
            101874908,
            101869353,
            101877667,
            101902344,
            101877756,
            101876619,
            101904584,
            101891390,
            101873346,
            101870962
        ],
        "A": [
            101862412,
            101862840,
            101865321,
            101865985,
            101861233,
            101876553,
            101861535,
            101873147,
            101867432,
            101867877,
            101872819,
            101866189,
            101865464,
            101863366,
            101870449,
            101865209,
            101894436,
            101867001,
            101859824
        ],
        "F": [
            101921592,
            101921489,
            101921368,
            101920713,
            113148352,
            197483789,
            101923610,
            101916398,
            101915019,
            107239743,
            103939202
        ]
    },
    "name": "A. Peaceful Rooks",
    "statement": "You are given a n\r\ntimes n chessboard. Rows and columns of the board are numbered from 1 to\r\nn. Cell (x, y) lies on the intersection of column number x and row\r\nnumber y.Rook is a chess piece, that can in one turn move any number of\r\ncells vertically or horizontally. There are m rooks (m < n) placed on\r\nthe chessboard in such a way that no pair of rooks attack each other.\r\nI.e. there are no pair of rooks that share a row or a column.In one turn\r\nyou can move one of the rooks any number of cells vertically or\r\nhorizontally. Additionally, it shouldn\u2019t be attacked by any other rook\r\nafter movement. What is the minimum number of moves required to place\r\nall the rooks on the main diagonal?The main diagonal of the chessboard\r\nis all the cells (i, i), where 1\r\nle i\r\nle n.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint T,n,m,ans;\nint fa[MAXN];\n\nint getroot(int u)\n{\n\treturn u == fa[u] ? u : fa[u] = getroot(fa[u]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&T);\n\twhile (T--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor (int i = 1;i <= n;i++)\n\t\t\tfa[i] = i;\n\t\tans = m;\n\t\tfor (int u,v,i = 1;i <= m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tif (u == v)\n\t\t\t{\n\t\t\t\tans--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ru = getroot(u),rv = getroot(v);\n\t\t\tif (ru == rv)\n\t\t\t\tans++;\n\t\t\telse\n\t\t\t\tfa[ru] = rv;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Peaceful Rooks.json",
    "editorial_link": "https://codeforces.com//blog/entry/85792",
    "editorial": "Consider rooks as edges in a graph. The position (x,y)\n will correspond to an edge (x?y)\n. From the condition that there're at most one edge exits leading from each vertex and at most one edge leading to each vertex, it follows that the graph decomposes into cycles, paths, and loops (edges of type v?v\n).\n\nWhat happens to the graph when we move the rook? The edge changes exactly one of its endpoints. By such operations, we must turn all edges into loops, and the constraint on the number of edges going in and out of a vertex must be satisfied. A path is quite easy to turn into loops, just start from one end. A cycle must first be turned into a path, which is always possible. We've only spent one extra move, it's not hard to see that this is optimal.\n\nThe answer is the number of rooks minus the number of loops plus the number of cycles."
}