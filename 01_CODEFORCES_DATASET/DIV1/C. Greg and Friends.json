{"link": "https://codeforces.com//contest/295/problem/C", "problemId": "2836", "problem_idx": "C", "shortId": "295C", "contest_number": "295", "problem_submissions": {"E": [3511398, 3511419, 3511437, 3511617, 3512460, 3509679, 3512315, 3510900, 3508827, 3511729, 3510067, 3513473, 3512096, 3510503, 3513504, 3513446, 3513998, 3513357, 3512431], "D": [3509428, 3508084, 3508466, 3509763, 3509435, 3512601, 3509591, 3512430, 3510879, 3510319, 3512308, 3511034, 3506982, 3509190, 3509840, 3509472, 3580137], "C": [3508174, 3509402, 3509512, 3507449, 3507654, 3508191, 3508111, 3508096, 3513124, 3512841, 3513121, 3508464, 3508663, 3507348, 3507241, 3508781, 3507476, 3507076, 3507577, 3507688], "B": [3506807, 3505379, 3506165, 3505888, 3506089, 3506387, 3506261, 3505484, 3505919, 3507043, 3506794, 3509222, 3505786, 3505827, 3505874, 3505560, 3506566, 3506119], "A": [3505050, 3504656, 3505453, 3504455, 3504863, 3505059, 3505155, 3504693, 3504542, 3504788, 3504749, 3508036, 3504910, 3507685, 3504620, 3504661, 3556448, 3505140, 3504565]}, "name": "C. Greg and Friends", "statement": "One day Greg and his friends were walking in the forest. Overall there\r\nwere people walking, including Greg. Soon he found himself in front of a\r\nriver. The guys immediately decided to get across the river. Luckily,\r\nthere was a boat by the river bank, just where the guys were standing.\r\nWe know that the boat can hold people with the total weight of at most\r\nkilograms.Greg immediately took a piece of paper and listed there the\r\nweights of all people in his group (including himself). It turned out\r\nthat each person weights either 50 or 100 kilograms. Now Greg wants to\r\nknow what minimum number of times the boat needs to cross the river to\r\ntransport the whole group to the other bank. The boat needs at least one\r\nperson to navigate it from one bank to the other. As the boat crosses\r\nthe river, it can have any non-zero number of passengers as long as\r\ntheir total weight doesn\u2019t exceed .Also Greg is wondering, how many ways\r\nthere are to transport everybody to the other side in the minimum number\r\nof boat rides. Two ways are considered distinct if during some ride they\r\nhave distinct sets of people on the boat.Help Greg with this problem.\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstring>\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define fup FOR\n#define fdo FORD\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define siz SZ\n#define CLR(x) memset((x), 0, sizeof(x))\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second \n#define FI X\n#define SE Y\n#define SQR(a) ((a)*(a))\n#define DEBUG 1\n#define debug(x) {if (DEBUG)cerr <<#x <<\" = \" <<x <<endl; }\n#define debugv(x) {if (DEBUG) {cerr <<#x <<\" = \"; FORE(it, (x)) cerr <<*it <<\", \"; cout <<endl; }}\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int>P;\ntypedef vector<int>VI;\nconst int INF=1E9+7;\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n#define MAXN 57\n\nint n,k,a[MAXN],dp[507][MAXN][MAXN],small,big,res;\nbool is;\nint dw[MAXN][MAXN];\n\n\nint main(){\nREP(n,MAXN){\n    dw[n][0]=1;\n    FOR(k,1,n) dw[n][k]=(dw[n-1][k-1]+dw[n-1][k])%INF;\n}\n\tios_base::sync_with_stdio(false);\n    cout << setprecision(15) << fixed;\n\t//in\n    cin >> n >> k;\n    REP(i,n) cin >> a[i];\n    k /= 50;\n    REP(i,n) (a[i] == 100 ? big : small)++;\n\t//sol\n    dp[0][0][0] = 1;\n    REP(f,500) {\n        REP(s,small+1) REP(b,big+1) if(dp[f][s][b]) {\n            if(s == small && b == big) {\n                cout << f << endl << dp[f][s][b] << endl;\n                return 0;\n            }\n            int sogr = (f&1 ? s : small-s);\n            int bogr = (f&1 ? b : big-b);\n            REP(ss,sogr+1) REP(bb,bogr+1)\n                if(ss + bb > 0 && ss+2*bb <= k) {\n                    int news = s + ss * (f&1 ? -1 : 1);\n                    int newb = b + bb * (f&1 ? -1 : 1);\n                    LL ile = dp[f][s][b];\n                    ile *= dw[sogr][ss]; ile %= INF;\n                    ile *= dw[bogr][bb]; ile %= INF;\n//                    cout << dw[sogr][ss] << endl;\n                    dp[f+1][news][newb] += ile;\n                    dp[f+1][news][newb] %= INF;\n                }\n        }\n    }\n\t//out\n    cout << -1 << endl << 0 << endl;\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "graphs", "shortest paths"], "dificulty": "2100", "interactive": false}