{
    "link": "https://codeforces.com//contest/1074/problem/C",
    "problemId": "249088",
    "problem_idx": "C",
    "shortId": "1074C",
    "contest_number": "1074",
    "problem_submissions": {
        "E": [
            45303620,
            45300249,
            45344571,
            45304718,
            45304862,
            45306309,
            45306510,
            45315681,
            45302002,
            45303642
        ],
        "F": [
            45297925,
            45302412,
            45298748,
            45300083,
            45299480,
            45298818,
            45299827,
            45300561,
            45300985,
            45300910,
            45302087,
            45302359,
            45302549,
            45302342,
            45306149,
            45302208,
            45303449,
            45304102,
            45303226
        ],
        "D": [
            45294973,
            45293128,
            45295261,
            45296109,
            45292313,
            45291734,
            45297119,
            45297694,
            45297259,
            45298710,
            45297635,
            45297369,
            45298399,
            45297846,
            45294290,
            45297091,
            45296770,
            45296596,
            45297365,
            45299859
        ],
        "C": [
            45293553,
            45291475,
            45293844,
            45294044,
            45293914,
            45294012,
            45293608,
            45295772,
            45294886,
            45297284,
            45296110,
            45294396,
            45293720,
            45296080,
            45292596,
            45294430,
            45294994,
            45295210,
            45294620,
            45296058
        ],
        "B": [
            45292377,
            45294890,
            45292284,
            45297195,
            45296274,
            45295787,
            45291944,
            45293450,
            45293244,
            45294291,
            45295233,
            45293263,
            45291573,
            45294870,
            45303353,
            45293540,
            45298407,
            45293034,
            45292582,
            45292571
        ],
        "A": [
            45289520,
            45289825,
            45289616,
            45289578,
            45294985,
            45294783,
            45289998,
            45290374,
            45289949,
            45291060,
            45291837,
            45290090,
            45295330,
            45290627,
            45290102,
            45291029,
            45290582,
            45297889,
            45289941,
            45289786
        ]
    },
    "name": "C. Optimal Polygon Perimeter",
    "statement": "You are given n points on the plane. The polygon formed from all the n\r\npoints is , that is, the polygon is convex, and there are no three\r\ncollinear points (i.e. lying in the same straight line). The points are\r\nnumbered from 1 to n, in clockwise order.We define the distance between\r\ntwo points p_1 = (x_1, y_1) and p_2 = (x_2, y_2) as their Manhattan\r\ndistance: d(p_1, p_2) = |x_1 - x_2| + |y_1 - y_2|.Furthermore, we define\r\nthe perimeter of a polygon, as the sum of Manhattan distances between\r\nall adjacent pairs of points on it; if the points on the polygon are\r\nordered as p_1, p_2,\r\nldots, p_k (k\r\ngeq 3), then the perimeter of the polygon is d(p_1, p_2) + d(p_2, p_3) +\r\nldots + d(p_k, p_1).For some parameter k, let’s consider all the\r\npolygons that can be formed from the given set of points, having k\r\nvertices, such that the polygon is self-intersecting. For each such\r\npolygon, let’s consider its perimeter. Over all such perimeters, we\r\ndefine f(k) to be the maximal perimeter.Please note, when checking\r\nwhether a polygon is self-intersecting, that the edges of a polygon are\r\nstill drawn as straight lines. For instance, in the following pictures:\r\nIn the middle polygon, the order of points (p_1, p_3, p_2, p_4) is not\r\nvalid, since it is a self-intersecting polygon. The right polygon (whose\r\nedges resemble the Manhattan distance) has the same order and is not\r\nself-intersecting, but we consider edges as straight lines. The correct\r\nway to draw this polygon is (p_1, p_2, p_3, p_4), which is the left\r\npolygon.Your task is to compute f(3), f(4),\r\nldots, f(n). In other words, find the maximum possible perimeter for\r\neach possible number of points (i.e. 3 to n).\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e12;\n\nint n;\npll tab[nax];\n\nll wyn[nax];\n\nvector <pll> wek;\n\nint mf, ms;\n\nll f(pll v)\n{\n\treturn v.first*mf+v.second*ms;\n}\n\nbool mniej(pll a, pll b)\n{\n\treturn f(a)>f(b);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld%lld\", &tab[i].first, &tab[i].second);\n\tfor (int i=-1; i<=1; i++)\n\t{\n\t\tfor (int j=-1; j<=1; j++)\n\t\t{\n\t\t\tmf=i;\n\t\t\tms=j;\n\t\t\tsort(tab+1, tab+1+n, mniej);\n\t\t\twek.push_back(tab[1]);\n\t\t}\n\t}\n\tfor (int i=1; i<(1<<((int)wek.size())); i++)\n\t{\n\t\tvll x;\n\t\tvll y;\n\t\tfor (int j=0; j<(int)wek.size(); j++)\n\t\t{\n\t\t\tif (i&(1<<j))\n\t\t\t{\n\t\t\t\tx.push_back(wek[j].first);\n\t\t\t\ty.push_back(wek[j].second);\n\t\t\t}\n\t\t}\n\t\tsort(x.begin(), x.end());\n\t\tsort(y.begin(), y.end());\n\t\twyn[__builtin_popcount(i)]=max(wyn[__builtin_popcount(i)], x.back()-x[0]+y.back()-y[0]);\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t\twyn[i]=max(wyn[i-1], wyn[i]);\n\tfor (int i=3; i<=n; i++)\n\t\tprintf(\"%lld \", wyn[i]*2);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "geometry"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Optimal Polygon Perimeter.json",
    "editorial_link": "https://codeforces.com//blog/entry/62985",
    "editorial": "I will show 2 solutions, both of which work in time. First, it is not\r\nhard to notice that we can only consider polygons that are\r\nconvex.Observation: For a convex polygon, the given definition of\r\n\"polygon perimeter\" is equivalent to the perimeter of the bounding\r\nrectangle (aligned with the axis), of our polygon. If we look at some\r\nconvex polygon, and 4 values representing the maximal coordinate of a\r\npoint, minimal , maximal and minimal , then the perimeter of the\r\nbounding rectangle is simply .This simple rephrase gives us a bonus, and\r\ncrucial observation: It is enough for us to take 4 points from the\r\ninput, such that the perimeter of their polygon is the maximal possible\r\n(and is equal to the perimeter of the polygon formed from points). We\r\nwill consider these the points. Note that after taking the extreme\r\npoints, it does not matter which other points we take. So, this solves\r\nall .We are left with to compute (maximal triangle perimeter). Following\r\nare 2 solutions to do it: Letâs show that the optimal triangle uses at\r\nleast 2 of the extreme points. Imagine some optimal triangle, and its\r\nbounding rectangle. Notice that since each edge of the bounding\r\nrectangle must touch some vertex of the triangle (it is bounding after\r\nall), and we have 4 edges and 3 vertices, then there must be some vertex\r\nof the triangle that touches 2 edges of the rectangle (so it coincides\r\nwith a rectangle vertex). If this is the case, we know that in\r\ncomparison with the 2 other vertices, this vertex has \"extremal\" X and Y\r\ncoordinates (minimal/maximal X, and minimal/maximal Y). Without loss of\r\ngenerality, assume this vertex has maximum X and Y. Then to optimize the\r\nperimeter, the other two vertices should have smallest possible X and\r\nsmallest possible Y. We can pick these 2 vertices to be 2 of the extreme\r\npoints (one with minimal X and one with minimal Y). So, this shows we\r\njust need to iterate over every adjacent pair of extreme vertices, and\r\nover all other points as the last vertex. This takes . This solution is\r\nmore general, and is an extension of the problem to find the 2 most\r\ndistant points (manhattan distance). The triangle perimeter is an\r\nexpression with 6 terms: . We wish the maximize this expression, but the\r\nabsolute value is troubling us. For each term, there are 2 cases: either\r\nit is positive, so the absolute value does nothing, or it is negative,\r\nso the absolute value negates it. In total, for the 6 terms we have\r\noptions to place signs between them. We will call such option a .For any\r\nsetting, the advantage now is that we can accumulate terms: For example\r\nthe setting , evaluates the expression to: We solve every setting by its\r\nown, and over all settings we take the maximal answer., that this\r\nstrategy only works to find the maximal value of the expression, not\r\nminimal. The proof of this is left as an exercise to the reader :) (I\r\npromise it is not difficult).Given 6 constants , we want to find 3\r\nindicies to maximize: . We define 3 arrays: And so we want to maximize .\r\nThis can be done in with simple dynamic programming.So this whole\r\nsolution is , with a constant of 64. In general, to compute this\r\nsolution takes time, without any observations.\r\n",
    "hint": []
}