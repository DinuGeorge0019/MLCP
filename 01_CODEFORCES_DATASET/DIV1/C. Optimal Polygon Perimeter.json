{"link": "https://codeforces.com//contest/1074/problem/C", "problemId": "249088", "problem_idx": "C", "shortId": "1074C", "contest_number": "1074", "problem_submissions": {"E": [45303620, 45300249, 45344571, 45304718, 45304862, 45306309, 45306510, 45315681, 45302002, 45303642], "F": [45297925, 45302412, 45298748, 45300083, 45299480, 45298818, 45299827, 45300561, 45300985, 45300910, 45302087, 45302359, 45302549, 45302342, 45306149, 45302208, 45303449, 45304102, 45303226], "D": [45294973, 45293128, 45295261, 45296109, 45292313, 45291734, 45297119, 45297694, 45297259, 45298710, 45297635, 45297369, 45298399, 45297846, 45294290, 45297091, 45296770, 45296596, 45297365, 45299859], "C": [45293553, 45291475, 45293844, 45294044, 45293914, 45294012, 45293608, 45295772, 45294886, 45297284, 45296110, 45294396, 45293720, 45296080, 45292596, 45294430, 45294994, 45295210, 45294620, 45296058], "B": [45292377, 45294890, 45292284, 45297195, 45296274, 45295787, 45291944, 45293450, 45293244, 45294291, 45295233, 45293263, 45291573, 45294870, 45303353, 45293540, 45298407, 45293034, 45292582, 45292571], "A": [45289520, 45289825, 45289616, 45289578, 45294985, 45294783, 45289998, 45290374, 45289949, 45291060, 45291837, 45290090, 45295330, 45290627, 45290102, 45291029, 45290582, 45297889, 45289941, 45289786]}, "name": "C. Optimal Polygon Perimeter", "statement": "You are given n points on the plane. The polygon formed from all the n\r\npoints is , that is, the polygon is convex, and there are no three\r\ncollinear points (i.e. lying in the same straight line). The points are\r\nnumbered from 1 to n, in clockwise order.We define the distance between\r\ntwo points p_1 = (x_1, y_1) and p_2 = (x_2, y_2) as their Manhattan\r\ndistance: d(p_1, p_2) = |x_1 - x_2| + |y_1 - y_2|.Furthermore, we define\r\nthe perimeter of a polygon, as the sum of Manhattan distances between\r\nall adjacent pairs of points on it; if the points on the polygon are\r\nordered as p_1, p_2,\r\nldots, p_k (k\r\ngeq 3), then the perimeter of the polygon is d(p_1, p_2) + d(p_2, p_3) +\r\nldots + d(p_k, p_1).For some parameter k, let\u2019s consider all the\r\npolygons that can be formed from the given set of points, having k\r\nvertices, such that the polygon is self-intersecting. For each such\r\npolygon, let\u2019s consider its perimeter. Over all such perimeters, we\r\ndefine f(k) to be the maximal perimeter.Please note, when checking\r\nwhether a polygon is self-intersecting, that the edges of a polygon are\r\nstill drawn as straight lines. For instance, in the following pictures:\r\nIn the middle polygon, the order of points (p_1, p_3, p_2, p_4) is not\r\nvalid, since it is a self-intersecting polygon. The right polygon (whose\r\nedges resemble the Manhattan distance) has the same order and is not\r\nself-intersecting, but we consider edges as straight lines. The correct\r\nway to draw this polygon is (p_1, p_2, p_3, p_4), which is the left\r\npolygon.Your task is to compute f(3), f(4),\r\nldots, f(n). In other words, find the maximum possible perimeter for\r\neach possible number of points (i.e. 3 to n).\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e12;\n\nint n;\npll tab[nax];\n\nll wyn[nax];\n\nvector <pll> wek;\n\nint mf, ms;\n\nll f(pll v)\n{\n\treturn v.first*mf+v.second*ms;\n}\n\nbool mniej(pll a, pll b)\n{\n\treturn f(a)>f(b);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld%lld\", &tab[i].first, &tab[i].second);\n\tfor (int i=-1; i<=1; i++)\n\t{\n\t\tfor (int j=-1; j<=1; j++)\n\t\t{\n\t\t\tmf=i;\n\t\t\tms=j;\n\t\t\tsort(tab+1, tab+1+n, mniej);\n\t\t\twek.push_back(tab[1]);\n\t\t}\n\t}\n\tfor (int i=1; i<(1<<((int)wek.size())); i++)\n\t{\n\t\tvll x;\n\t\tvll y;\n\t\tfor (int j=0; j<(int)wek.size(); j++)\n\t\t{\n\t\t\tif (i&(1<<j))\n\t\t\t{\n\t\t\t\tx.push_back(wek[j].first);\n\t\t\t\ty.push_back(wek[j].second);\n\t\t\t}\n\t\t}\n\t\tsort(x.begin(), x.end());\n\t\tsort(y.begin(), y.end());\n\t\twyn[__builtin_popcount(i)]=max(wyn[__builtin_popcount(i)], x.back()-x[0]+y.back()-y[0]);\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t\twyn[i]=max(wyn[i-1], wyn[i]);\n\tfor (int i=3; i<=n; i++)\n\t\tprintf(\"%lld \", wyn[i]*2);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "geometry"], "dificulty": "2100", "interactive": false}