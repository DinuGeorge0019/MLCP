{
    "link": "https://codeforces.com//contest/1168/problem/C",
    "problemId": "349590",
    "problem_idx": "C",
    "shortId": "1168C",
    "contest_number": "1168",
    "problem_submissions": {
        "D": [
            54689933,
            54709717,
            54687414,
            54689247,
            54692817,
            54690951,
            54687623,
            54690825,
            54690084,
            54693991,
            54691003,
            54691066,
            54691626,
            54692507,
            54689961,
            54693988,
            54752028,
            54747584,
            54782050,
            54716017,
            54694558
        ],
        "B": [
            54688206,
            54684470,
            54672670,
            54675422,
            54672484,
            54674963,
            54674803,
            54682027,
            54675650,
            54680245,
            54677508,
            54680443,
            54678955,
            54683400,
            54673481,
            54675324,
            54675597,
            54675910,
            54676117
        ],
        "A": [
            54679849,
            54670251,
            54678124,
            54670773,
            54670009,
            54671023,
            54672077,
            54670763,
            54669908,
            54672903,
            54670896,
            54674583,
            54671922,
            54670734,
            54670514,
            54670263,
            54670924,
            54670411,
            54671870
        ],
        "C": [
            54678044,
            54685816,
            54846089,
            54676677,
            54679735,
            54675366,
            54680183,
            54677459,
            54678103,
            54681414,
            54678145,
            54682238,
            54682671,
            54681429,
            54681732,
            54676972,
            54678213,
            54678234,
            54678543,
            54679007
        ],
        "E": [
            54672350,
            54679530,
            156967221,
            54891863,
            54891597
        ]
    },
    "name": "C. And Reachability",
    "statement": "Toad Pimple has an array of integers a_1, a_2,\r\nldots, a_n.We say that y is reachable from x if x<y and there exists an\r\ninteger array p such that x = p_1 < p_2 <\r\nldots < p_k=y, and a_{p_i}\r\n,\r\n&\r\n, a_{p_{i+1}} > 0 for all integers i such that 1\r\nleq i < k.Here\r\n& denotes the bitwise AND operation.You are given q pairs of indices,\r\ncheck reachability for each of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\n#define maxN 323456\n\nconst int kM = 19;\n\nint n, q, dis[40], ans[maxN];\nint a[maxN], g[40][40];\nvector<pair<int, int>> query[maxN];\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tquery[y - 1].push_back(make_pair(x - 1, i));\n\t}\n\tfor (int i = 0; i < kM; i++)\n\t\tfor (int j = 0; j < kM; j++)\n\t\t\tg[i][j] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> dig;\n\t\tfor (int j = 0; j < kM; j++)\n\t\t\tif (a[i] & (1 << j))\n\t\t\t\tdig.push_back(j);\n\t\tfor (int j = 0; j < kM; j++)\n\t\t\tdis[j] = -1;\n\t\tfor (auto x : dig) {\n\t\t\tdis[x] = i;\n\t\t\tfor (int j = 0; j < kM; j++)\n\t\t\t\tdis[j] = max(dis[j], g[x][j]);\n\t\t}\n\t\tfor (auto x : dig) {\n\t\t\tfor (int j = 0; j < kM; j++)\n\t\t\t\tg[x][j] = max(g[x][j], dis[j]);\n\t\t}\n\t\tfor (auto p : query[i]) {\n\t\t\tauto solve = [&] {\n\t\t\t\tint l = p.first;\n\t\t\t\tfor (int x = 0; x < kM; x++)\n\t\t\t\t\tif (a[i] & (1 << x))\n\t\t\t\t\t\tfor (int y = 0; y < kM; y++)\n\t\t\t\t\t\t\tif (a[l] & (1 << y) && g[x][y] >= l)\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t\tans[p.second] = solve();\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tif (ans[i]) {\n\t\t\tputs(\"Shi\");\n\t\t} else {\n\t\t\tputs(\"Fou\");\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. And Reachability.json",
    "editorial_link": "https://codeforces.com//blog/entry/67241",
    "editorial": "Let's calculate goi,k\n Â— the smallest j\n, such that aj\n contains bit k\n, which is reachable from i\n.\n\nHow to recalculate it? Let lasti,k\n is the smallest j>i\n, such that aj\n contains bit k\n.\n\nThen, I claim that goi,k\n is equal to the i\n or to the min(golasti,j,k)\n for all bits j\n that ai\n contains.\n\nWhy? Because if you go from i\n to some number, which has bit j\n in the intersection, it is useless to go to the number which is not equal to lasti,j\n, because from lasti,j\n you can go to all numbers that have bit j\n and that positioned farther.\n\nSo in O(nlog)\n you can calculate all these values, and then to answer the query you can check that there exists some bit j\n in ay\n such that gox,j?y\n.",
    "hint": []
}