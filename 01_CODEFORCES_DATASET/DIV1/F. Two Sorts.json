{
    "link": "https://codeforces.com//contest/1601/problem/F",
    "problemId": "1157782",
    "problem_idx": "F",
    "shortId": "1601F",
    "contest_number": "1601",
    "problem_submissions": {
        "F": [
            133036741,
            133030850,
            133053471,
            133036776,
            136096402,
            133146246
        ],
        "E": [
            133012503,
            133009950,
            133010165,
            133012509,
            133023042,
            133010446,
            133029069,
            133020546,
            133026708,
            133026848,
            133096129,
            133096027,
            133009106,
            133031363,
            133005130,
            133031540,
            133037221,
            133324190,
            133128643,
            133007675,
            133037406
        ],
        "D": [
            133003986,
            133005946,
            133003145,
            133019481,
            133007804,
            133008410,
            133020273,
            133009176,
            133009157,
            133008849,
            133009299,
            133026582,
            133008809,
            133014147,
            133008199,
            133009583,
            133010326,
            133056419,
            133004546,
            133008768
        ],
        "C": [
            132999482,
            132998781,
            132997710,
            132998487,
            133003047,
            133002651,
            133001118,
            133000071,
            133003217,
            132998126,
            133000279,
            133000540,
            133004698,
            133023294,
            133006018,
            133000684,
            132998660,
            133001622,
            133009000,
            133004643
        ],
        "B": [
            132991406,
            132991376,
            132992870,
            132992842,
            132992304,
            132995590,
            132995226,
            132992037,
            132995055,
            132990916,
            132993158,
            132995079,
            132994798,
            132993699,
            132996347,
            133113107,
            132993962,
            132993893,
            132997201,
            132995373,
            132994895
        ],
        "A": [
            132984771,
            132984572,
            132985020,
            132988648,
            132985081,
            132985096,
            132984905,
            132984874,
            132986113,
            132984658,
            132986695,
            132985767,
            132986320,
            132985605,
            132985251,
            132987796,
            132985532,
            132985036,
            132986108,
            132986609
        ]
    },
    "name": "F. Two Sorts",
    "statement": "Integers from 1 to n (inclusive) were sorted lexicographically\r\n(considering integers as strings). As a result, array a_1, a_2,\r\ndots, a_n was obtained.Calculate value of (\r\nsum_{i = 1}^n ((i - a_i)\r\nmod 998244353))\r\nmod 10^9 + 7.x\r\nmod y here means the remainder after division x by y. This remainder is\r\nalways non-negative and doesn’t exceed y - 1. For example, 5\r\nmod 3 = 2, (-1)\r\nmod 6 = 5.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int P = 998244353;\nconst int MOD = 1e9 + 7;\nconst int B = 1000000; \n\nint xmod(LL d)\n{\n\tint ret = d % P;\n\treturn ret < 0 ? ret + P : ret;\n}\nLL n, cnt;\nint ans;\nvector<int> hv[7];\nLL sum[7];\nvoid dfs0(int dep, LL val)\n{\n\tcnt ++;\n\thv[dep].push_back(xmod(cnt - val));\n\tif(dep == 6) return;\n\trep(i, 10) dfs0(dep + 1, val * 10 + i);\n}\nint calc(int id, int coef)\n{\n\tint pos = lower_bound(hv[id].begin(), hv[id].end(), P - coef) - hv[id].begin();\n\treturn (1LL * coef * (int)hv[id].size() + sum[id] - 1LL * P * ((int)hv[id].size() - pos)) % MOD;\n}\nvoid dfs1(int dep, LL val)\n{\n\tif(val > n) return;\n\tif(dep >= 1) {\n\t\tif(val * B > n / 10 && val * B + B - 1 <= n) {\n\t\t\tint tmp = 1;\n\t\t\trep(i, 7) {\n\t\t\t\tans = (ans + calc(i, xmod(cnt - val * tmp))) % MOD; tmp *= 10;\n\t\t\t}\n\t\t\trep(i, 7) cnt += hv[i].size();\n\t\t\treturn;\n\t\t}\n\t\tcnt ++; ans = (ans + xmod(cnt - val)) % MOD;\n\t}\n\tfor(int i = !dep; i < 10; i ++) dfs1(dep + 1, val * 10 + i);\n}\n\nint main()\n{\n\tscanf(\"%lld\", &n);\n\tdfs0(0, 0);\n\trep(i, 7) {\n\t\tsort(hv[i].begin(), hv[i].end());\n\t\trep(j, hv[i].size()) sum[i] += hv[i][j];\n\t}\n\tcnt = 0;\n\tdfs1(0, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "math",
        "meet-in-the-middle"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Two Sorts.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "Suppose is an inverse permutation of , that is , that is is an index of\r\nin the lexicographical sorting. Rewrite desired sum replacing : .First,\r\nwe need to understand how to calculate âs. Observe that equals plus\r\nnumber of integers () so that . These integers are of two possible\r\nkinds: own prefixes of (the number of such depends only on the length of\r\n) and integers having a common prefix with of some length and a smaller\r\ndigit in -th index.If we fix values of , , length of , we have a \"mask\"\r\nof the following kind: \"\", and we are interested in the number of\r\nmatching this mask. This number almost always depends on the number of\r\n\"\" with minor exceptions concerning . E. g. consider for the example\r\nabove.So in the desired sum, we group summands by the following markers\r\nof (brute force the value of these markers): Length of , Position of\r\nfirst digit different in and (cases, where is an own prefix of , shall\r\nbe considered separately). The value of this digit. So we know\r\ndescription of of the following kind: , where are fixed, and are\r\narbitrary integer variables in . Observe that both and are linear\r\ncombination of variables and , so is also a linear combination of them.\r\nThe only issue is computing modulo .To do summing over all we use the\r\nmeet-in-the-middle method: bruteforce separately the values for the\r\nfirst half and the second half, and then match one with another.If , the\r\nsolution works in , or .\r\n",
    "hint": []
}