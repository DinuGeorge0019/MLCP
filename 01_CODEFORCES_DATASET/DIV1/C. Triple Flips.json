{
    "link": "https://codeforces.com//contest/1071/problem/C",
    "problemId": "240848",
    "problem_idx": "C",
    "shortId": "1071C",
    "contest_number": "1071",
    "problem_submissions": {
        "D": [
            44637237,
            44635977,
            44641232,
            44642034,
            44645226,
            44644969,
            44641119,
            44687822,
            44647598,
            44647731,
            44636247,
            44657719,
            44657573,
            44656873,
            44656778,
            44656490,
            44656434,
            44656391,
            44656371,
            44656287,
            44656203,
            44656003,
            44655947,
            44655816,
            44655752,
            44655740,
            44655723,
            44655702,
            44655688,
            44655676,
            44655623,
            44655613,
            44655594,
            44655569,
            44655560,
            44655438,
            44655419,
            44655291,
            44647784,
            44642810,
            44645755,
            44645396,
            44646118,
            44644322,
            44654399
        ],
        "C": [
            44633806,
            44636722,
            44637213,
            44636382,
            44638429,
            44646089,
            44638832,
            44640208,
            44642096,
            44639762,
            44646904,
            44636416,
            44638641,
            44637725
        ],
        "B": [
            44628020,
            44627991,
            44628766,
            44629645,
            44629488,
            44629819,
            44628230,
            44629653,
            44629034,
            44630394,
            44631138,
            44629791,
            44632540,
            44629581,
            44629264,
            44627767,
            44636293,
            44628785
        ],
        "A": [
            44624756,
            44630092,
            44624598,
            44626465,
            44625487,
            44624461,
            44624565,
            44624711,
            44624763,
            44626685,
            44624210,
            44625000,
            44627102,
            44624838,
            44625068,
            44629237,
            44625506,
            44625349
        ],
        "E": [
            44647746,
            45395419,
            45395353,
            44682935,
            44682924
        ]
    },
    "name": "C. Triple Flips",
    "statement": "You are given an array a of length n that consists of zeros and ones.You\r\ncan perform the following operation multiple times. The operation\r\nconsists of two steps: Choose three integers 1\r\nle x < y < z\r\nle n, that form an arithmetic progression (y - x = z - y). Flip the\r\nvalues a_x, a_y, a_z (i.e. change 1 to 0, change 0 to 1). Determine if\r\nit is possible to make all elements of the array equal to zero. If yes,\r\nprint the operations that lead the the all-zero state. Your solution\r\nshould not contain more than (\r\nlfloor\r\nfrac{n}{3}\r\nrfloor + 12) operations. Here\r\nlfloor q\r\nrfloor denotes the number q rounded down. We can show that it is\r\npossible to make all elements equal to zero in no more than this number\r\nof operations whenever it is possible to do so at all.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n\nint n;\nint tab[nax];\n\nvector <vi> wyn;\n\nvoid nope()\n{\n\tprintf(\"NO\\n\");\n\texit(0);\n}\n\nvoid zrob(int a, int b, int c)\n{\n\ttab[a]^=1;\n\ttab[b]^=1;\n\ttab[c]^=1;\n\twyn.push_back({a, b, c});\n}\n\nvoid zrob(int a, int b)\n{\n\tif ((a&1)==(b&1))\n\t\tzrob(a, (a+b)/2, b);\n}\n\nvoid zbruc(int a, int b)\n{\n\tvector <vi> moz;\n\tfor (int i=a; i<=b; i++)\n\t\tfor (int j=i+1; j+j-i<=b; j++)\n\t\t\tmoz.push_back({i, j, j+j-i});\n\t//~ debug() << imie(moz.size());\n\tint pot=0;\n\tfor (int i=a; i<=b; i++)\n\t\tpot^=(tab[i]<<(i-a));\n\tint k=moz.size();\n\tfor (int i=0; i<(1<<k); i++)\n\t{\n\t\tint mas=0;\n\t\tfor (int j=0; j<k; j++)\n\t\t\tif (i&(1<<j))\n\t\t\t\tfor (int l : moz[j])\n\t\t\t\t\tmas^=(1<<(l-a));\n\t\tif (mas==pot)\n\t\t{\n\t\t\t//~ debug() << range(tab+a, tab+b+1);\n\t\t\tfor (int j=0; j<k; j++)\n\t\t\t\tif (i&(1<<j))\n\t\t\t\t\tzrob(moz[j][0], moz[j][1], moz[j][2]);\n\t\t\treturn;\n\t\t}\n\t}\n\tnope();\n}\n\nvoid rek(int a, int b)\n{\n\tif (a>b)\n\t\treturn;\n\tif (b-a<=7)\n\t{\n\t\tzbruc(a, b);\n\t\treturn;\n\t}\n\tif (!tab[a])\n\t{\n\t\trek(a+1, b);\n\t\treturn;\n\t}\n\tif (!tab[b])\n\t{\n\t\trek(a, b-1);\n\t\treturn;\n\t}\n\tif (!tab[b-1])\n\t{\n\t\tif (tab[b-2])\n\t\t\tzrob(b-4, b-2, b);\n\t\telse\n\t\t\tzrob(b-6, b-3, b);\n\t\trek(a, b);\n\t\treturn;\n\t}\n\tif (!tab[a+1])\n\t{\n\t\tif (tab[a+2])\n\t\t\tzrob(a, a+2, a+4);\n\t\telse\n\t\t\tzrob(a, a+3, a+6);\n\t\trek(a, b);\n\t\treturn;\n\t}\n\tif (tab[b-2])\n\t{\n\t\tzrob(b-2, b-1, b);\n\t\trek(a, b);\n\t\treturn;\n\t}\n\tif (tab[a+2])\n\t{\n\t\tzrob(a, a+1, a+2);\n\t\trek(a, b);\n\t\treturn;\n\t}\n\tzrob(a, b);\n\tzrob(a, b-1);\n\tzrob(a+1, b);\n\tzrob(a+1, b-1);\n\trek(a, b);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\t\t//~ tab[i]=rand()%2;\n\t\t//~ tab[i]=1;\n\trek(1, n);\n\tfor (int i=1; i<=n; i++)\n\t\tassert(!tab[i]);\n\t\n\tprintf(\"YES\\n\");\n\tprintf(\"%d\\n\", (int)wyn.size());\n\tfor (vi &i : wyn)\n\t{\n\t\tsort(i.begin(), i.end());\n\t\tprintf(\"%d %d %d\\n\", i[0], i[1], i[2]);\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Triple Flips.json",
    "editorial_link": "https://codeforces.com//blog/entry/62612",
    "editorial": "This problem has a lot of solutions including those ones which are difficult to prove. Let's describe one of the author's solutions.\n\nWe can find answer with bruteforce if size of array is rather small. For example we can check all combinations of arithmetic progressions with length equals to three.\n\nWe can find by hand or bruteforce that for 3?n?7\n arrays with no solution exists but for n=8\n (and consequently for n?8\n) we always can make all elements be equal to zero.\n\nWe want solution with such steps:\n\nIf n\n is small just run bruteforce\nElse try to make all elements besides the first k\n (k?8\n) be equal to zero\nRun bruteforce on the first k\n elements.\nHow to make the second step? Let's try to make three last elements of array be equal to zero with only one operation. We can use previous elements. So if we have array \u0085,0,0,1\n we can change values of the first, the fourth and the seventh elements from the end. But \u0085,0,1,1\n is counter-example.\n\nOk, let's try to make six last elements of array be equal to zero with two operations. We can check by hand or bruteforce that it can be done and n?11\n is enough.\n\nSo we have such solution:\n\nLet k\n is the number of first elements of array which we didn't try to make be equal to zero. In the start k=n\nWhile k?11\n make k\n-th, (k?1)\n-th,.., (k?5)\n-th elements be equal to zero. Subtract 6 from k\n.\nIf k?10\n run bruteforce on the first 10\n elements or on the whole array if n<10\n.\nHow many operations will be done?\n\nIn the second item the number of operations is less or equal than 2??n6???n3?\nIn the third item the number of operations is less or equal than 6 (can be checked by hand or bruteforce)\nSo the total number of operations is less or equal than ?n3?+6\n, what is good enough."
}