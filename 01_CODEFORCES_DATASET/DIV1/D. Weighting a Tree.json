{
    "link": "https://codeforces.com//contest/901/problem/D",
    "problemId": "139715",
    "problem_idx": "D",
    "shortId": "901D",
    "contest_number": "901",
    "problem_submissions": {
        "D": [
            33426443,
            33425255,
            33425405,
            33421002,
            33428722,
            33432497,
            33430107,
            33431968,
            33434361,
            33433853,
            33432628,
            33428305,
            33435534,
            33423537,
            33424117,
            33433491,
            33424011,
            33435055
        ],
        "C": [
            33423246,
            33421544,
            33420578,
            33429910,
            33422327,
            33425977,
            33426202,
            33427669,
            33422440,
            33429447,
            33429169,
            33424756,
            33430999,
            33430059,
            33430695,
            33420864,
            33434365,
            33425416
        ],
        "B": [
            33419337,
            33427579,
            33429052,
            33425071,
            33431946,
            33418047,
            33432302,
            33420475,
            33497315,
            33497308,
            33496921,
            33426321,
            33423681,
            33433893,
            33426136,
            33434123
        ],
        "A": [
            33414182,
            33413377,
            33413379,
            33422716,
            33415121,
            33413643,
            33413547,
            33414284,
            33415005,
            33416374,
            33419687,
            33414307,
            33415289,
            33414435,
            33420715,
            33423860,
            33425257,
            33413347
        ],
        "E": [
            36988410
        ]
    },
    "name": "D. Weighting a Tree",
    "statement": "You are given a connected undirected graph with vertices and edges. The\r\nvertices are enumerated from to . You are given integers , each of them\r\nis between and , inclusive. It is also guaranteed that the parity of\r\nequals the parity of degree of vertex . The degree of a vertex is the\r\nnumber of edges connected to it.You are to write a weight between and\r\n(inclusive) on each edge in such a way, that for each vertex the sum of\r\nweights on edges connected to this vertex is equal to , or determine\r\nthat this is impossible.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nclass edge {\npublic:\n\tint s, e;\n\tedge() {\n\t\t*this = edge(0, 0);\n\t}\n\tedge(int s, int e) : s(s), e(e) {}\n};\nvector <edge> Ve;\nvector <int> conn[300050];\nvoid epush(int s, int e) {\n\tconn[s].push_back(Ve.size());\n\tconn[e].push_back(Ve.size());\n\tVe.emplace_back(s, e);\n}\n\nll in[100050];\nll ans[300050];\n\nint dep[100050];\npii par[100050];\nbool dchk[100050];\nvector <int> Vb;\nvector <int> son[100050];\nvoid DFS(int n) {\n\tdchk[n] = true;\n\tfor (auto it : conn[n]) {\n\t\tedge &ed = Ve[it];\n\t\tint x = ed.s ^ ed.e ^ n;\n\t\tif (x == par[n].second) continue;\n\t\tif (dchk[x]) Vb.push_back(it);\n\t\telse {\n\t\t\tdep[x] = dep[n] + 1;\n\t\t\tpar[x] = pii(it, n);\n\t\t\tson[n].push_back(x);\n\t\t\tDFS(x);\n\t\t\t\n\t\t}\n\t}\n}\nvoid DFS2(int n) {\n\tfor (auto it : son[n]) {\n\t\tDFS2(it);\n\t\tin[n] -= ans[par[it].first];\n\t}\n\tif (n != 1) ans[par[n].first] = in[n];\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= N; i++) scanf(\"%lld\", &in[i]);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tepush(t1, t2);\n\t}\n\tDFS(1);\n\n\tll s[2] = { 0,0 };\n\tfor (i = 1; i <= N; i++) s[dep[i] % 2] += in[i];\n\n\tif ((s[0] - s[1]) % 2) return !printf(\"NO\\n\");\n\n\tsort(all(Vb));\n\tVb.erase(unique(all(Vb)), Vb.end());\n\tfor (auto it : Vb) {\n\t\tint x = Ve[it].s, y = Ve[it].e;\n\t\tif (dep[x] % 2 != dep[y] % 2) continue;\n\n\t\tint z = dep[x] % 2;\n\t\tll a = (s[z] - s[1 - z]) / 2;\n\t\tin[x] -= a, in[y] -= a;\n\t\tans[it] = a;\n\t\ts[z] -= 2 * a;\n\t}\n\tif (s[0] != s[1]) return !printf(\"NO\\n\");\n\tDFS2(1);\n\t\n\tprintf(\"YES\\n\");\n\tfor (i = 0; i < M; i++) printf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Weighting a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/56478",
    "editorial": "Let\u00e2\u0080\u0099s solve two cases.First case is when graph is the bipartite\r\ngraphThen the sum of weights of the left part should be equal to the sum\r\nof weights of the right part (because each edge will bring an equal\r\ncontribution to the sums of both part).We will leave any spanning tree\r\nof this graph, then for it the solution is unique (take the edges\r\nentering the leafs, their weights are uniquely determined, subtract\r\nweights from weights of the second ends of this edges, delete the leafs,\r\nrecursively) this solution can be found with dfs, then in the end, the\r\nroot will has weight 0 (because sum of weights of the left part equal to\r\nthe sum of weights of the right part) Thus, the answer exists when the\r\nsum of the weights of the left part is equal to the sum of the weights\r\nof the right part.Second case when graph has the odd cycle.We find an\r\nodd cycle, root the tree for any of its vertices, solve the tree. Then,\r\nwe add to the weights of the edges of the cycle adjacent to the root\r\nminus its weight divided by 2 (it is even, because it is the sum of the\r\nweights of all vertices (with different signs) equal to the sum of the\r\ndegrees of vertices by modulo 2). , and for all others we alternate the\r\nsigns with which we add this value, then for all vertices except the\r\nroot the sum does not change, but for the root we get the required\r\nvalue.Example code: https://pastebin.com/b2bGp4Bh\r\n"
}