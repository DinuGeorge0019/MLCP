{
    "link": "https://codeforces.com//contest/1442/problem/F",
    "problemId": "782911",
    "problem_idx": "F",
    "shortId": "1442F",
    "contest_number": "1442",
    "problem_submissions": {
        "F": [
            97498578,
            135803098
        ],
        "E": [
            97475216,
            97479604,
            97479996,
            97476389,
            97475771,
            97482490,
            97482122,
            97486462,
            97481313,
            97514122,
            97491110,
            97570605,
            97570447,
            97483367,
            97482486,
            97530901,
            97530677,
            97490693,
            97491170,
            97483183,
            97744761,
            97465807,
            97518516,
            97525092
        ],
        "D": [
            97466130,
            97467957,
            97470622,
            97481203,
            97465568,
            97454688,
            97470507,
            97479495,
            97471531,
            97513997,
            97513923,
            97474497,
            97524422,
            97524418,
            97524414,
            97523769,
            97523651,
            97523580,
            97514880,
            97514861,
            97470422,
            97454149,
            97469561,
            97480908,
            97475630,
            97456546,
            97494847,
            97472947,
            97473292
        ],
        "C": [
            97461787,
            97460269,
            97457703,
            97453909,
            97462173,
            97474564,
            97455050,
            97455856,
            97466820,
            97514136,
            97458387,
            97515471,
            97514818,
            97514812,
            97514752,
            97514717,
            97462625,
            97478118,
            97463398,
            97456934,
            97468590,
            97472482,
            97456397,
            97465702,
            97461718
        ],
        "B": [
            97444657,
            97444364,
            97444049,
            97441804,
            97446454,
            97444215,
            97443077,
            97445131,
            97444667,
            97514148,
            97444728,
            97447073,
            97465519,
            97447003,
            97445633,
            97445150,
            97448727,
            97454658,
            97448347,
            97442585
        ],
        "A": [
            97436722,
            97436568,
            97436299,
            97438819,
            97440488,
            97436328,
            97437458,
            97436707,
            97440205,
            97514153,
            97437001,
            97448738,
            97444789,
            97436058,
            97438579,
            97436174,
            97437755,
            97436528,
            97438505,
            97439502
        ]
    },
    "name": "F. Differentiating Games",
    "statement": "Ginny is taking an exam on game theory. The professor is tired of\r\nhearing the same answers over and over again, so he offered Ginny to\r\nplay a game instead of a standard exam. As known from the course, a\r\ncombinatorial game on a graph with multiple starting positions is a game\r\nwith a directed graph and multiple starting vertices holding a token\r\neach. Two players take turns moving one of the tokens along the graph\r\nedges on each turn. The player who can’t make a move loses the game. If\r\nboth players can play an infinitely long game without losing, a draw is\r\ncalled.For the exam, the professor drew an acyclic directed graph and\r\nchose one of its vertices. Ginny needs to guess the vertex the professor\r\nchose. To do so, Ginny can choose a multiset of vertices S several times\r\nand ask the professor: \"If I put one token in each vertex of the given\r\ngraph for each occurrence of the vertex in the multiset S, and then one\r\nmore in the selected vertex, what would be the result of the\r\ncombinatorial game?\". Having given the task, the professor left the room\r\nto give Ginny some time to prepare for the game. Ginny thinks that she’s\r\nbeing tricked because the problem is impossible to solve. Therefore,\r\nwhile the professor is away, she wants to add or remove several edges\r\nfrom the graph. Even though the original graph was acyclic, edges could\r\nbe added to the graph to make cycles appear.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn't exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { cout << endl; } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr(\" \"); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << \", \";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: sorts vertices such that if there exists an edge x->y, then x goes before y\n * Source: KACTL\n * Verification: https://open.kattis.com/problems/quantumsuperposition\n */\n\ntemplate<int SZ> struct TopoSort {\n\tint N, in[SZ];\n\tvi res, adj[SZ];\n\tvoid ae(int x, int y) { adj[x].pb(y), in[y] ++; }\n\tbool sort(int _N) {\n\t\tN = _N; queue<int> todo;\n\t\tFOR(i,1,N+1) if (!in[i]) todo.push(i);\n\t\twhile (sz(todo)) {\n\t\t\tint x = todo.front(); todo.pop(); res.pb(x);\n\t\t\ttrav(i,adj[x]) if (!(--in[i])) todo.push(i);\n\t\t}\n\t\treturn sz(res) == N;\n\t}\n};\n\nTopoSort<MX> TS;\nint N,M,T;\nint ind;\nset<int> adj[MX];\n\n\nV<pair<char,pi>> eds;\n\nvoid de(int a, int b) {\n\teds.pb({'-',{a,b}});\n}\n\nvoid ae(int a, int b) {\n\teds.pb({'+',{a,b}});\n}\n\nmap<int,int> done;\n\nvoid rem_edges() {\n\tint num = sz(TS.res)-ind;\n\tauto ins = [&](int _, int mask, int xo) {\n\t\tmask ^= xo;\n\t\tif (done.count(mask)) return 0;\n\t\tdone[mask] = _;\n\t\tmask ^= xo;\n\t\tF0R(i,num) if (xo&(1<<i)) {\n\t\t\tif (mask&(1<<i)) {\n\t\t\t\tde(_,TS.res[ind+i]);\n\t\t\t} else {\n\t\t\t\tae(_,TS.res[ind+i]);\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t};\n\tauto ad = [&](int _) {\n\t\tae(_,_);\n\t\tint mask = 0;\n\t\tF0R(i,num)\n\t\t\tif (adj[_].count(TS.res[ind+i]))\n\t\t\t\tmask ^= 1<<i;\n\t\tif (ins(_,mask,0)) return;\n\t\tF0R(i,num) if (ins(_,mask,1<<i)) return;\n\t\tF0R(i,num) FOR(j,i+1,num)\n\t\t\tif (ins(_,mask,(1<<i)^(1<<j))) return;\n\t\tF0R(i,num) FOR(j,i+1,num) FOR(k,j+1,num)\n\t\t\tif (ins(_,mask,(1<<i)^(1<<j)^(1<<k))) return;\n\t\tassert(0);\n\t};\n\tF0R(_,ind) ad(TS.res[_]);\n}\n\nvoid interact() {\n\tint mask = 0;\n\tFOR(i,ind,sz(TS.res)) {\n\t\tps(\"?\",1,TS.res[i]);\n\t\tstr res; re(res);\n\t\tif (res == \"Lose\") {\n\t\t\tps(\"!\",TS.res[i]);\n\t\t\tre(res);\n\t\t\treturn;\n\t\t}\n\t\tif (res == \"Win\") mask ^= 1<<(i-ind);\n\t}\n\tassert(done.count(mask));\n\tps(\"!\",done[mask]);\n\tstr res; re(res);\n}\n\nint main() {\n\tsetIO(); re(N,M,T);\n\tF0R(i,M) {\n\t\tint a,b; re(a,b);\n\t\tTS.ae(a,b);\n\t\tadj[a].ins(b);\n\t}\n\tTS.sort(N);\n\t// ps(TS.res);\n\tind = max(sz(TS.res)-20,0);\n\tFOR(i,ind,sz(TS.res)) FOR(j,i+1,sz(TS.res)) {\n\t\tae(TS.res[i],TS.res[j]);\n\t}\n\trem_edges();\n\tps(sz(eds));\n\ttrav(t,eds) ps(t.f,t.s.f,t.s.s);\n\tF0R(_,T) interact();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "interactive"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Differentiating Games.json",
    "editorial_link": "https://codeforces.com//blog/entry/84298",
    "editorial": "Letâs first solve the problem for an empty graph. To do this we need to\r\nbuild a construction with not too many edges, where all vertices are\r\npairwise not equivalent. For acyclic graph, there is not such\r\nconstruction. All Grundy functions of vertices should be different, so\r\nthey must be integers from 0 to . The only such graph is full, and it\r\nhas quadratic number of edges. Moreover, if there is a part from which\r\nno cycles are reachable, it must be full acyclic graph, so it canât be\r\ntoo big. So, how can other graph look? No vertices can be equivalent to\r\nany of vertices in acyclic part. The easiest way to achieve it is to add\r\na loop to every vertex. Letâs note, that after doing so all this\r\nvertices canât be losing in sum with any other game, because we can just\r\ngo through loop and donât change anything. So, this games differ from\r\neach other be set of games in sum with which they would be winning, not\r\ndraw. One can see, that such a game would be winning with any acyclic\r\ngame, it have a move to, because we can go to it, and this will be move\r\nto acyclic game with Grundy function 0. The game would be draw with any\r\nother acyclic game (and with not acyclic too, but this is not important\r\nfor solution). This is true, because if we donât move in game with loop,\r\nresulting position is not winning. Therefore, to win we must go out from\r\nloop vertex. But than we come into acyclic game with non-zero Grundy\r\nfunction, and itâs winning, so we canât win. And we can go through loop,\r\nachieving a draw. So, we need to build a graph, with acyclic part of\r\nfull graph on vertices, and all other vertices should have a loop and\r\nsome edges to this vertices, and all vertices should have different set\r\nof edges. If done, all vertices would be pairwise distinguishable by\r\nqueries for each acyclic part vertex. If any of them is lost, this\r\nvertex is chosen. If all of them is winning or draw, than the vertex\r\nwith loop, which have an edge if and only if sum with this vertex is\r\nwinning, is chosen. In opposite to acyclic case, we can distinguish\r\nexponentially many vertices. Returning to the initial problem, one can\r\nget , and get all subsets of size 0, 1 and 2, and required part of\r\nsubsets of size . In such a graph there would be edges. The only\r\nremaining part is to understand what to do with existing edges. One can\r\nnot, then in built construction any edges between vertices with loops\r\ncan be added, because they change nothing. If position is winning, then\r\nafter first move they become unreachable, and doesnât change anything.\r\nIf it was draw, they canât change anything too, because they are led to\r\nvertex with loop, which canât be losing. Letâs use 20 vertices, which\r\nhave no edges outside of this set as vertices of acyclic part. Initial\r\ngraph was acyclic, so we can find such vertices. Letâs add loop to all\r\nother vertices. Now, we need to modify graph in a way that all sets of\r\nedges to acyclic part would be different. Letâs go through vertices in\r\nany order, and change minimal possible number of edges, so, that this\r\nvertex set would not be equal to any of previous. For first vertex we\r\nwonât do anything. For next 20 vertices, we would need to change at most\r\n1 edge. For next 190 vertices, we would need to change at most 2 edges,\r\nand at most 3 for others. This led us to the same 3877 edges to change.\r\nIn general case we can do either edges changes and queries or edges\r\nchanges and queries. For this problem we need d = 3.\r\n",
    "hint": []
}