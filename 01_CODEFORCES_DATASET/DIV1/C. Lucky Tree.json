{
    "link": "https://codeforces.com//contest/109/problem/C",
    "problemId": "574",
    "problem_idx": "C",
    "shortId": "109C",
    "contest_number": "109",
    "problem_submissions": {
        "E": [
            648441
        ],
        "D": [
            646409,
            647170,
            646652,
            646695,
            646352,
            645873,
            645392,
            646870,
            646386,
            646289,
            645803,
            647324,
            646355,
            647745,
            646444,
            645672
        ],
        "B": [
            644873,
            644785,
            645061,
            644222,
            644364,
            643745,
            643698,
            644283,
            643725,
            646460,
            646874,
            647648,
            646835,
            644816,
            646998,
            647078
        ],
        "C": [
            643742,
            645980,
            645707,
            645639,
            645273,
            644937,
            644325,
            645865,
            644801,
            645032,
            644836,
            644580,
            644697,
            646773,
            644867,
            646558
        ],
        "A": [
            642201,
            642453,
            642373,
            642819,
            642224,
            642165,
            642161,
            642217,
            642304,
            642733,
            643129,
            642289,
            642251,
            642497,
            642687,
            647423
        ]
    },
    "name": "C. Lucky Tree",
    "statement": "One day Petya encountered a tree with vertexes. Besides, the tree was\r\nweighted, i. e. each edge of the tree has weight (a positive integer).\r\nAn edge is lucky if its weight is a lucky number. Note that a is an\r\nundirected connected graph that has exactly edges.Petya wondered how\r\nmany vertex triples exists that on the way from to , as well as on the\r\nway from to there must be at least one lucky edge (all three vertexes\r\nare pairwise distinct). The order of numbers in the triple matters, that\r\nis, the triple is not equal to the triple and is not equal to the triple\r\n. Find how many such triples of vertexes exist.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\n#define MAXV 100010\nint parent[MAXV],rank[MAXV];\n\nstruct UnionFind{\n\n    UnionFind(int n){\n        int i;\n        REP(i,n) {parent[i] = i; rank[i] = 1;}\n    }\n\n    int root(int x){\n        if(parent[x] != x) parent[x] = root(parent[x]);\n        return parent[x];\n    }\n\n    void connect(int x, int y){\n        int rx=root(x),ry=root(y);\n        if(rx == ry) return;\n        if(rank[rx] > rank[ry]) {parent[ry] = rx; rank[rx] += rank[ry];}\n        if(rank[rx] <= rank[ry]) {parent[rx] = ry; rank[ry] += rank[rx];}\n    }\n    \n    int getsize(int x){\n        int rx = root(x);\n        return rank[rx];\n    }\n    \n};\n\nbool lucky(int n){\n    while(n > 0){\n        if(n%10 != 4 && n%10 != 7) return false;\n        n /= 10;\n    }\n    return true;\n}\n\nint main(void){\n    int N,a,b,c,i;\n    \n    scanf(\"%d\",&N);\n    UnionFind uf(N);\n    REP(i,N-1){\n        scanf(\"%d%d%d\",&a,&b,&c);\n        if(!lucky(c)) uf.connect(a-1,b-1);\n    }\n    \n    ll ans = 0;\n    REP(i,N){\n        ll tmp = N - uf.getsize(i);\n        ans += tmp * (tmp - 1);\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "dsu",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Lucky Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/2547",
    "editorial": "Solve this problem using dynamic programming. Consider that root of a tree is vertex with number 1. Let F(x) - number of vertex in subtree of vertex x for which there is a path containing lucky edge. We will calculate F(x) using recursion. If x is a leaf, than F(x)?=?0. Else, if there is an edge from x that leads to y and this edge is lucky, then to F(x) we need to add C(y), otherwise we add F(y), here C(y) - number of vertex in subtree of y, including y. But, to solve this problem we need to know also F'(x) - number of vertex which are not in subtree of x and there exits a path from x to that vertex that contains lucky edge. For a root of tree, F'(x) equals to 0. We should go recursive from root, and if we are in vertex x now, we suppose that F'(x) is already calculated. If from x we can directly go to y and that edge is lucky, then F'(y)?=?C(0)?-?C(y), otherwise F'(y)?=?F'(x)?+?F(x)?-?F(y).\n\nAfter that, result equals to .",
    "hint": []
}