{
    "link": "https://codeforces.com//contest/1817/problem/D",
    "problemId": "1897392",
    "problem_idx": "D",
    "shortId": "1817D",
    "contest_number": "1817",
    "problem_submissions": {
        "F": [
            204497444,
            204371393,
            203993098,
            203987643,
            204188728,
            204003142,
            203943098,
            204213507
        ],
        "D": [
            203955544,
            203961086,
            203937236,
            203945800,
            203945643,
            203942818,
            203943723,
            203947591,
            203989196,
            203948036,
            204052212,
            203947419,
            203952089,
            203947882,
            203954628
        ],
        "A": [
            203949751,
            203917796,
            203915319,
            203915702,
            203915256,
            203915135,
            203915119,
            203915216,
            203933837,
            203916532,
            203915895,
            203917033,
            203915580,
            203915390,
            203917321,
            203916497,
            203915656,
            203929967,
            203917829
        ],
        "E": [
            203947509,
            203943737,
            203948086,
            203949930,
            204001172,
            203962099,
            204158074,
            203951990,
            204009291,
            203987561,
            203984105,
            203980085,
            203953471,
            203990042,
            203976606,
            203976302,
            203953675,
            204066570,
            204065539,
            204106022
        ],
        "B": [
            203928063,
            203919631,
            203920186,
            203920581,
            203923300,
            203919216,
            203918930,
            203922691,
            203924157,
            203921090,
            203921763,
            203924664,
            203924354,
            203989898,
            203930016,
            203924048,
            203922828,
            203936658,
            203924723
        ],
        "C": [
            203916741,
            203929205,
            203922679,
            203923849,
            203928212,
            203926222,
            203931210,
            203933759,
            203932269,
            203931148,
            203930247,
            203931616,
            203931791,
            203922648,
            203924454,
            204016237,
            203932091,
            203930473,
            203925061,
            203933416
        ]
    },
    "name": "D. Toy Machine",
    "statement": "There is a toy machine with toys arranged in two rows of n cells each (n\r\nis odd). Initially, n-2 toys are placed in the non-corner cells of the\r\ntop row. The bottom row is initially empty, and its leftmost, rightmost,\r\nand central cells are blocked. There are 4 buttons to control the toy\r\nmachine: left, right, up, and down marked by the letters , , , and\r\ncorrespondingly.When pressing , , , or , all the toys will be moved\r\nsimultaneously in the corresponding direction and will only stop if they\r\npush into another toy, the wall or a blocked cell. Your goal is to move\r\nthe k-th toy into the leftmost cell of the top row. The toys are\r\nnumbered from 1 to n-2 from left to right. Given n and k, find a\r\nsolution that uses at most 1\r\n,000\r\n,000 button presses.To test out the toy machine, a is available that\r\nlets you play the game in real time.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  if (k <= n/2) {\n    for (int i = 0; i < n/4; i++) cout << \"LDLU\";\n    for (int i = 0; i < k-1; i++) cout << \"DRUL\";\n    cout << '\\n';\n  }\n  else {\n    for (int i = 0; i < n/4; i++) cout << \"RDRU\";\n    for (int i = 0; i < (k == n-2 ? n/2 : n-2-k); i++) cout << \"DLUR\";\n    for (int i = 0; i < n/2; i++) cout << \"LDLU\";\n    cout << \"RDL\";\n    cout << '\\n';\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "games",
        "implementation"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Toy Machine.json",
    "editorial_link": "https://codeforces.com//blog/entry/115586",
    "editorial": "Similar to the Huffman encoding, the process described in the statement\r\ncan be represented as constructing a tree, in which on every step we\r\ntake two trees with weights and , and connect them with a shared root\r\ninto a single tree with weight .In the end of the process, we have two\r\ntrees with weights and , and we want to maximize . In these trees, let\r\nbe the height of the leaf corresponding to . Then contributes to the\r\nfinal answer with the coefficient either , or , depending on which tree\r\nit is in.If we fix any set and would need to distribute between the\r\nheights, assuming , it would always be better to send smaller numbers to\r\nthe -tree and bigger numbers to the -tree, so that the positive impact\r\nbelongs to bigger numbers and the negative impact belongs to the smaller\r\nnumbers. That being said, if , it is always optimal to choose a number\r\nand send to the -tree, while sending to the -tree. Now we need to\r\nunderstand, how to pick an optimal and how to construct optimal trees\r\nwith a fixed .Assume that will all go to the -tree, for which we want to\r\nminimize the weight. What is the optimal distribution of ? Turns out,\r\nthere always exists an optimal configuration, in which the constructed\r\ntree is very skewed, in a way that each vertex has at most child that is\r\nnot a leaf.Indeed, consider a vertex which has two children and , both\r\nof which have children of its own. Let be a leaf with the smallest\r\nweight in the whole sub-tree of (without loss of generality, assume that\r\nit\u00e2\u0080\u0099s a descendant of ). If we swap with , we will effectively swap\r\ncoefficients with which and contribute to the weight of overall.In other\r\nwords, if the initial contribution was , it will become . Note that and\r\n. As a consequence, the later sum is not worse than the former and it\u00e2\u0080\u0099s\r\nalways optimal to swap and due to the rearrangement inequality.Similar\r\nargument works for the tree , except for we want to maximize sum in it,\r\nrather than minimize it.With this in mind, if the split is and , then\r\nthe heights are for the first block, and similar (but reversed) for the\r\nsecond block. This allows us to find a specific value of for each\r\nspecific in .How to improve from that? We suggest two possible\r\napproaches here.. Assume that the optimal belongs to the interval . In\r\nthis case, all numbers outside the interval will have the same\r\ncoefficients regardless of specific , as long as itself is from the\r\ninterval. This means that we can solve the problem with divide and\r\nconquer approach: Let ; Find best recursively on and ; Compare them on\r\nthe whole , and return the best of them. Which makes overall\r\ncomplexity.. Let\u00e2\u0080\u0099s compare the distribution of coefficients for and : As\r\nyou see, almost all coefficients stay the same, except for coefficients\r\nnear , and : Therefore, let be the optimal answer for , and let , we may\r\nsay thatOr, multiplying it with we getWe can sum it up to get the\r\ndifference between and for arbitrary :where . Then, assuming , we can\r\nbound it asThe later means that when , which is the case when and . By\r\nthe same argument, we may show that when and . In other words, it means\r\nthat one of the following holds for the value , on which the maximum\r\nvalue of is achieved: is the first position in the array, at which , is\r\nthe last position in the array, at which , belongs to the segment .\r\nTherefore, there are at most positions of interest in the array which\r\ncan be checked manually. Moreover, optimal value in the segment can be\r\nfound by checking every possible position while ignoring all the\r\nelements outside of the segment (due to the result from the divide and\r\nconquer approach). This allows, assuming , to resolve the problem in .\r\n"
}