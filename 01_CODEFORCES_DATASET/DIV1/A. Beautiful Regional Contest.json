{"link": "https://codeforces.com//contest/1264/problem/A", "problemId": "486700", "problem_idx": "A", "shortId": "1264A", "contest_number": "1264", "problem_submissions": {"B": [66341401, 66322874, 66336572, 66329159, 66325790, 66330100, 66345009, 66330236, 66376038, 66331864, 66336631, 66328124, 66347648, 66329347, 66322983, 66344650, 66327116, 66327090, 66332056], "D2": [66339545, 66335577, 66343751, 66352069, 66344993, 66344301, 66348378, 66362083, 66352256, 66376168, 66345089, 138527512, 66378228, 66393120, 66349950, 66338137, 66353567, 66351786], "D1": [66334941, 66334668, 66343694, 66345117, 66344078, 66344165, 66344520, 66350440, 66349159, 66376114, 66339049, 66358201, 66357642, 66351611, 66357362, 66352980, 66346482, 66338263, 66345809, 66347614], "A": [66330725, 66323882, 66323064, 66323750, 66337390, 66323088, 66323240, 66323608, 66323803, 66375789, 66323639, 66328235, 66324332, 66323365, 66323990, 66326030, 66323496, 66322830, 66323987, 66323760], "C": [66326327, 66330012, 66334720, 66339910, 66341281, 66334697, 66340151, 66333112, 66337232, 66376069, 66331626, 66349943, 66341121, 66340814, 66329673, 66346210, 66334293, 66333006, 66337575, 66339417, 66355906], "E": [66322750, 66338115, 66328737, 66333356, 66334932, 66353827, 66331679, 66338428, 66427601, 66422500, 66422400, 66421563, 66419015, 66419013, 66380135, 66362673, 66361972, 66357957, 66377834, 66346874, 66338003, 66349170, 66358017, 66342846, 66355768, 66361241, 66346679], "F": [66498558, 115183857]}, "name": "A. Beautiful Regional Contest", "statement": "So the Beautiful Regional Contest (BeRC) has come to an end! n students\r\ntook part in the contest. The final standings are already known: the\r\nparticipant in the i-th place solved p_i problems. Since the\r\nparticipants are primarily sorted by the number of solved problems, then\r\np_1\r\nge p_2\r\nge\r\ndots\r\nge p_n.Help the jury distribute the gold, silver and bronze medals. Let\r\ntheir numbers be g, s and b, respectively. Here is a list of\r\nrequirements from the rules, which all must be satisfied: for each of\r\nthe three types of medals, at least one medal must be awarded (that is,\r\ng>0, s>0 and b>0); the number of gold medals must be strictly less than\r\nthe number of silver and the number of bronze (that is, g<s and g<b, but\r\nthere are no requirements between s and b); each gold medalist must\r\nsolve strictly more problems than any awarded with a silver medal; each\r\nsilver medalist must solve strictly more problems than any awarded a\r\nbronze medal; each bronze medalist must solve strictly more problems\r\nthan any participant not awarded a medal; the total number of medalists\r\ng+s+b should not exceed half of all participants (for example, if n=21,\r\nthen you can award a maximum of 10 participants, and if n=26, then you\r\ncan award a maximum of 13 participants). The jury wants to reward with\r\nmedals the total number participants (i.e. to maximize g+s+b) so that\r\nall of the items listed above are fulfilled. Help the jury find such a\r\nway to award medals.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nint n,x,m,_;\nint cnt[N];\nvoid solve() {\n\tscanf(\"%d\",&n);\n\tmap<int,int> hs;\n\trep(i,0,n) {\n\t\tscanf(\"%d\",&x);\n\t\ths[x]++;\n\t}\n\tm=0;\n\tfor (auto p:hs) {\n\t\tcnt[m++]=p.se;\n\t}\n\treverse(cnt,cnt+m);\n\trep(i,1,m) cnt[i]+=cnt[i-1];\n\tVI ans{0,0,0,0};\n\trep(i,0,m) {\n\t\t// g  cnt[i]\n\t\tint a=lower_bound(cnt,cnt+m,2*cnt[i]+1)-cnt;\n\t\tif (a==m) continue;\n\t\tint f1=cnt[a]-cnt[i];\n\t\tint b=upper_bound(cnt,cnt+m,n/2)-cnt-1;\n\t\tint f2=cnt[b]-f1-cnt[i];\n\t\tif (f1>cnt[i]&&f2>cnt[i]) {\n\t\t\tans=max(ans,VI{cnt[i]+f1+f2,cnt[i],f1,f2});\n\t\t}\n\t\t// b 2*cnt[i]+1\n\t}\n\tprintf(\"%d %d %d\\n\",ans[1],ans[2],ans[3]);\n}\n\nint main() {\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n"], "input": "", "output": "", "tags": ["greedy", "implementation"], "dificulty": "1500", "interactive": false}