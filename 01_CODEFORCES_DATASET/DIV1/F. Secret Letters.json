{
    "link": "https://codeforces.com//contest/1120/problem/F",
    "problemId": "306946",
    "problem_idx": "F",
    "shortId": "1120F",
    "contest_number": "1120",
    "problem_submissions": {
        "E": [
            50758414,
            50756395,
            51349737
        ],
        "F": [
            50755440,
            50756775,
            50756923,
            50745238,
            50757783,
            50769406,
            57326050
        ],
        "D": [
            50750764,
            50751956,
            50743562,
            50751566,
            50752777,
            50751884,
            50753994,
            50750618,
            50751945,
            50752229,
            50752378,
            50752892,
            50753276,
            50756304,
            50749029,
            50755638,
            50755384,
            50755602,
            50754622
        ],
        "C": [
            50742812,
            50748170,
            50742079,
            50747757,
            50746596,
            50747930,
            50749515,
            50746554,
            50746940,
            50749954,
            50748511,
            50747866,
            50749223,
            50751278,
            50750205,
            50750042,
            50750814,
            50749510,
            50744496
        ],
        "B": [
            50741885,
            50746393,
            50748182,
            50754599,
            50753894,
            50755398,
            50768361,
            50757846,
            50749483,
            57329791
        ],
        "A": [
            50743197,
            50749514,
            50746437,
            50743945,
            50745821,
            50745101,
            50745374,
            50743501,
            50746721,
            50745328,
            50746455,
            73355086,
            50745671,
            50745395,
            50746139
        ]
    },
    "name": "F. Secret Letters",
    "statement": "Little W and Little P decided to send letters to each other regarding\r\nthe most important events during a day. There are n events during a day:\r\nat time moment t_i something happens to the person p_i (p_i is either or\r\n, denoting Little W and Little P, respectively), so he needs to\r\nimmediately send a letter to the other person. They can send a letter\r\nusing one of the two ways: Ask Friendly O to deliver the letter\r\ndirectly. Friendly O takes d acorns for each letter. Leave the letter at\r\nWise R’s den. Wise R values free space, so he takes c\r\ncdot T acorns for storing a letter for a time segment of length T. The\r\nrecipient can take a letter from Wise R either when he leaves his own\r\nletter at Wise R’s den, or at time moment t_{n + 1}, when everybody\r\ncomes to Wise R for a tea. It is not possible to take a letter from Wise\r\nR’s den at other time moments. The friends can store as many letters at\r\nWise R’s den as they want, paying for each one separately. Help the\r\nfriends determine the minimum possible total cost of sending all\r\nletters.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\nconst ll inf=1e18;\n\nint n;\nll c, d;\nll tab[nax];\nint kto[nax];\n\nll dp[nax];\nll wyn=inf;\n\nll ile[nax][2];\nll sum[nax][2];\n\nint najd[nax];\n\n//~ ll koszt(int i, int j)\n//~ {\n\t//~ int x=kto[i];\n\t//~ return dp[j]+(ile[i][x^1]-ile[j][x^1])*d+((sum[i][x]-sum[j][x])-(tab[n+1]-tab[j])*(ile[i][x]-ile[j][x]))*c;\n//~ }\n\nll koszt(int i, int j)\n{\n\tint x=kto[i];\n\tll ret=dp[j]+(ile[i][x^1]-ile[j][x^1])*d;\n\tret+=(tab[j]-tab[i])*c;\n\ti++;\n\tif (i<najd[j])\n\t{\n\t\tret+=(ile[i][x]-ile[najd[j]][x])*d;\n\t\ti=najd[j];\n\t}\n\tret+=((sum[i][x]-sum[j][x])-(tab[n+1]-tab[j])*(ile[i][x]-ile[j][x]))*c;\n\treturn ret;\n}\n\nvi poz[2];\nvi pot[2];\n\nvoid mini(ll &a, ll b)\n{\n\ta=min(a, b);\n}\n\nvoid rek2(int h, int a, int b, int c, int d)\n{\n\tif (a>b || c>d)\n\t\treturn;\n\tint s=(a+b)>>1;\n\tint g=-1;\n\tll war=inf;\n\tfor (int i=c; i<=d; i++)\n\t{\n\t\tll w=koszt(poz[h][s], pot[h][i]);\n\t\tif (w<war)\n\t\t{\n\t\t\twar=w;\n\t\t\tg=i;\n\t\t}\n\t}\n\tmini(dp[poz[h][s]], war);\n\tassert(g>=0);\n\trek2(h, a, s-1, c, g);\n\trek2(h, s+1, b, g, d);\n}\n\nvoid rek1(int a, int b)\n{\n\tif (a>=b)\n\t\treturn;\n\tint s=(a+b)>>1;\n\trek1(s+1, b);\n\t\n\tpoz[0].clear();\n\tpoz[1].clear();\n\tpot[0].clear();\n\tpot[1].clear();\n\tfor (int i=a; i<=s; i++)\n\t\tpoz[kto[i]].push_back(i);\n\tfor (int i=s+1; i<=b; i++)\n\t\tfor (int h=0; h<2; h++)\n\t\t\tif (h!=kto[i])\n\t\t\t\tpot[h].push_back(i);\n\t\n\tfor (int h=0; h<2; h++)\n\t\trek2(h, 0, (int)poz[h].size()-1, 0, (int)pot[h].size()-1);\n\t\n\t\n\trek1(a, s);\n}\n\nint main()\n{\n\tscanf(\"%d%lld%lld\", &n, &c, &d);\n\tfor (int i=1; i<=n+1; i++)\n\t{\n\t\ttab[i]=i;\n\t\tscanf(\"%lld\", &tab[i]);\n\t\tif (i<=n)\n\t\t{\n\t\t\tchar x;\n\t\t\tscanf(\" %c\", &x);\n\t\t\tkto[i]=(x=='P');\n\t\t\t//~ kto[i]=rand()&1;\n\t\t}\n\t\telse\n\t\t\tkto[i]=2;\n\t}\n\t//~ debug() << range(tab+1, tab+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tdp[i]=inf;\n\t//~ debug() << imie(n) << imie(dp[6]);\n\tfor (int i=n; i; i--)\n\t{\n\t\tfor (int h=0; h<2; h++)\n\t\t{\n\t\t\tile[i][h]=ile[i+1][h];\n\t\t\tsum[i][h]=sum[i+1][h];\n\t\t}\n\t\tile[i][kto[i]]++;\n\t\tsum[i][kto[i]]+=(tab[n+1]-tab[i]);\n\t}\n\t\n\tfor (int i=1; i<=n+1; i++)\n\t{\n\t\tnajd[i]=max(najd[i-1], 1);\n\t\twhile(d<c*(tab[i]-tab[najd[i]]))\n\t\t\tnajd[i]++;\n\t}\n\t//~ debug() << range(najd+1, najd+1+n);\n\t\n\t//~ for (int i=n; i; i--)\n\t\t//~ for (int j=i+1; j<=n+1; j++)\n\t\t\t//~ if (kto[i]!=kto[j])\n\t\t\t\t//~ dp[i]=min(dp[i], koszt(i, j));\n\t\n\trek1(1, n+1);\n\t//~ for (int i=n; i; i--)\n\t//~ {\n\t\t//~ for (int j=i+1; j<=n+1; j++)\n\t\t//~ {\n\t\t\t//~ if (kto[i]==kto[j])\n\t\t\t\t//~ continue;\n\t\t\t//~ ll trz=dp[j];\n\t\t\t//~ for (int l=i; l<j; l++)\n\t\t\t//~ {\n\t\t\t\t//~ if (kto[l]==kto[i])\n\t\t\t\t//~ {\n\t\t\t\t\t//~ if (l==i)\n\t\t\t\t\t\t//~ trz+=c*(tab[j]-tab[l]);\n\t\t\t\t\t//~ else\n\t\t\t\t\t\t//~ trz+=min(c*(tab[j]-tab[l]), d);\n\t\t\t\t//~ }\n\t\t\t\t//~ else\n\t\t\t\t\t//~ trz+=d;\n\t\t\t//~ }\n\t\t\t//~ dp[i]=min(dp[i], trz);\n\t\t//~ }\n\t//~ }\n\t//~ debug() << range(dp+1, dp+1+n+1);\n\t\n\tfor (int i=1; i<=n+1; i++)\n\t\twyn=min(wyn, dp[i]+(i-1)*d);\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Secret Letters.json",
    "editorial_link": "https://codeforces.com//blog/entry/65679",
    "editorial": "Consider any optimal solution. Consider all letters of W between two\r\ntimes when P visits R. Itâs clear that maybe the first of these messages\r\nis sent via R, some of the last messages are also sent via R, all other\r\nmessages are sent via O. The sense behind shipping the first message via\r\nR is to obtain all messages which are currently stored there. If the\r\nfirst message is sent via O, and some of the others is sent via R, then\r\nwe can swap them thus paying less. On the other hand, once we got all\r\nthese letters, it makes sense to send something through R iff where is\r\nthe time between the moments when we send this message and when P visits\r\nR to obtain it. The same holds if we swap W and P.Denote by the minimal\r\npossible cost of the first letters if the -th is sent through R.Also\r\ndenote by the minimal possible cost of the first letters if the -th is\r\nsent through R . To calculate these values we can each time try every\r\npossible number of last letters sent through R. This takes time.One can\r\nobserve that if we fix the left bound of letters sent through R then the\r\ncost depends linearly on the time which we are calculating this for, and\r\nsince we need the minimum of linear functions each time then we can use\r\nconvex-hull trick which gives us or complexity.\r\n",
    "hint": []
}