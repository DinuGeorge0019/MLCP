{"link": "https://codeforces.com//contest/1830/problem/F", "problemId": "1942560", "problem_idx": "F", "shortId": "1830F", "contest_number": "1830", "problem_submissions": {"F": [234326044, 207652053, 207663837, 207807721, 208075080, 208075031, 207678271], "D": [207640246, 207630410, 207637627, 207621354, 207615321, 207636175, 207642613, 207640107, 207677598, 207636486, 207674640, 207643231, 207672649, 207672513, 207643891, 207672422, 207672033, 207644310, 207746469, 207746389, 207650197, 207645186, 207822601, 207822565, 207645978, 207642565, 207658410, 207638831], "C": [207608017, 207600613, 207612008, 207600441, 207604832, 207598385, 207603497, 207608198, 207613818, 207614226, 207616264, 207606682, 207610887, 234877458, 207617296, 207626821, 207621747, 207647815, 207622607, 207619463], "B": [207599759, 207593405, 207597186, 207596843, 207596098, 207591556, 207609227, 207602206, 207592261, 207601856, 207592644, 207601118, 207592805, 207603544, 207613114, 207602486, 207597786, 207598115, 207609684], "A": [207586682, 207582994, 207583697, 207581917, 207581457, 207583108, 207588869, 207586429, 207584682, 207584850, 207583599, 207583185, 207584377, 207587215, 207597686, 207589557, 207585837, 207585764, 207588046], "E": [207715760, 207661818, 207884996, 207884714, 207713105, 208057779]}, "name": "F. The Third Grace", "statement": "You are given n intervals and m points on the number line. The i-th\r\nintervals covers coordinates [l_i,r_i] and the i-th point is on\r\ncoordinate i and has coefficient p_i.Initially, all points are not\r\nactivated. You should choose a subset of the m points to activate. For\r\neach of n interval, we define its as: 0, if there are no activated\r\npoints in the interval; the coefficient of the activated point with the\r\nwithin it, otherwise. Your task is to maximize the sum of the costs of\r\nall intervals by choosing which points to activate.\r\n", "solutions": ["#include \"bits/stdc++.h\"\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define ar array\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing pi = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nconst int INFi = 2e9;\nconst ll INF = 2e18;\n\nstruct Line {\n    ll k, b;\n\n    ll get(ll x) { return k * x + b; }\n\n    // returns the x-intercept of intersection \"strictly\" larger than T\n    ll cross_after(Line &L, ll T) {\n        assert(L.get(T) >= get(T));\n        if (L.k >= k) return INF;\n        if (L.b >= b) return (L.b - b + (k - L.k)) / (k - L.k);\n        return (L.b - b + 1) / (k - L.k);\n    }\n\n    Line(ll k_ = 0, ll b_ = INF) : k(k_), b(b_) {}\n};\n\nstruct KineticSegTree { // min kinetic segment tree\n    struct Node {\n        Line best;\n        ll melt;\n        ar<ll, 2> upd; // upd[0] - heaten, upd[1] - add x\n\n        Node() : best(), melt(INF), upd({0, 0}) {}\n    };\n\n    ll T;\n    int n;\n    vector<Node> t;\n\n    void apply(int v, ar<ll, 2> x) {\n        t[v].upd[0] += x[0];\n        t[v].upd[1] += x[1];\n        t[v].best.b += x[0] * t[v].best.k + x[1];\n        t[v].melt -= x[0];\n    }\n\n    bool IsBetter(Line &a, Line &b) {\n        ll l = a.get(T), r = b.get(T);\n        if (l != r)\n            return l < r;\n        return a.k < b.k;\n    }\n\n    void pull(int v) {\n        Line A = t[v << 1].best;\n        Line B = t[v << 1 | 1].best;\n        t[v].melt = min(t[v << 1].melt, t[v << 1 | 1].melt);\n        if (IsBetter(B, A)) swap(A, B);\n        t[v].best = A;\n        t[v].melt = min(t[v].melt, A.cross_after(B, T));\n    }\n\n    void init(vector<Line> &l, ll TT = 0) {\n        n = l.size();\n        T = TT;\n        t.resize(n * 4);\n        init(1, 0, n, l);\n    }\n\n    void init(int v, int l, int r, vector<Line> &lines) {\n        if (l + 1 == r) {\n            t[v].best = lines[l];\n            return;\n        }\n        init(v << 1, l, (l + r) >> 1, lines);\n        init(v << 1 | 1, (l + r) >> 1, r, lines);\n        pull(v);\n    }\n\n    void push(int v) {\n        if (!t[v].upd[0] && !t[v].upd[1]) return;\n        apply(v << 1, t[v].upd);\n        apply(v << 1 | 1, t[v].upd);\n        t[v].upd[0] = t[v].upd[1] = 0;\n    }\n\n    void propagate(int v) {\n        if (t[v].melt > 0) return;\n        push(v);\n        propagate(v << 1);\n        propagate(v << 1 | 1);\n        pull(v);\n    }\n\n    ll get(int v, int l, int r, int lq, int rq) {\n        if (rq <= l || r <= lq) return INF;\n        if (lq <= l && r <= rq) {\n            return t[v].best.get(T);\n        }\n        push(v);\n        return min(get(v << 1, l, (l + r) >> 1, lq, rq), get(v << 1 | 1, (l + r) >> 1, r, lq, rq));\n    }\n\n    ll get(int lq, int rq) {\n        return get(1, 0, n, lq, rq);\n    }\n\n    void upd(int v, int l, int r, int lq, int rq, ar<ll, 2> &x) {\n        if (rq <= l || r <= lq) return;\n        if (lq <= l && r <= rq) {\n            apply(v, x);\n            propagate(v);\n            return;\n        }\n        push(v);\n        upd(v << 1, l, (l + r) >> 1, lq, rq, x);\n        upd(v << 1 | 1, (l + r) >> 1, r, lq, rq, x);\n        pull(v);\n    }\n\n    void upd(int lq, int rq, ar<ll, 2> x) {\n        upd(1, 0, n, lq, rq, x);\n    }\n\n    void heaten(int lq, int rq, ll x) {\n        upd(lq, rq, {x, 0});\n    }\n\n    void add(int lq, int rq, ll x) {\n        upd(lq, rq, {0, x});\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int m;\n    cin >> m;\n    vi l(n), r(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i];\n    }\n    vector<Line> a(m + 1, {0, 0});\n    for (int i = 1; i <= m; ++i) {\n        cin >> a[i].k;\n        a[i].k *= -1;\n    }\n    KineticSegTree kst;\n    kst.init(a, 0);\n    vi ord(n);\n    iota(all(ord), 0);\n    sort(all(ord), [&](const int &i, const int &j) { return r[i] < r[j]; });\n    int j = 0;\n    for (int i = 1; i <= m; ++i) {\n        ll ans = kst.get(0, i);\n        kst.add(i, i + 1, ans);\n        while (j < n && r[ord[j]] == i) {\n            kst.heaten(l[ord[j]], r[ord[j]] + 1, 1);\n            j++;\n        }\n    }\n    cout << -kst.get(0, m + 1) << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n     cin >> t;\n    rep(_, t) {\n        solve();\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dp"], "dificulty": "3200", "interactive": false}