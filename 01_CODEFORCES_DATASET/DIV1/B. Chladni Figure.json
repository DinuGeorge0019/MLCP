{
    "link": "https://codeforces.com//contest/1161/problem/B",
    "problemId": "339899",
    "problem_idx": "B",
    "shortId": "1161B",
    "contest_number": "1161",
    "problem_submissions": {
        "F": [
            53909371,
            114209812,
            53863200
        ],
        "E": [
            53757964,
            53756987,
            53756569,
            53759204,
            53758710,
            53758335,
            53759423,
            53759655,
            53759053,
            53758599,
            53760097,
            53761659,
            53757322,
            53759810
        ],
        "D": [
            53752102,
            53753035,
            53753793,
            53751800,
            53753429,
            53754722,
            87768256,
            53755219,
            53754639,
            53755997,
            53749499,
            53756338,
            53756778,
            53758722,
            53757091,
            53754786,
            53751937,
            53753965,
            53753805,
            53754929
        ],
        "C": [
            53750364,
            53751704,
            53751645,
            53749841,
            53749214,
            53750926,
            53751458,
            53755261,
            53754114,
            53751399,
            53756883,
            53754076,
            53759235,
            53760202,
            53749644,
            53749593,
            53751107,
            53750858
        ],
        "B": [
            53748059,
            53750584,
            53750568,
            53748260,
            53748334,
            53748600,
            53749151,
            53749091,
            53748293,
            53760218,
            53747945,
            53749635,
            53748265,
            53747869,
            53748914,
            53748572,
            53749307,
            53749491
        ],
        "A": [
            53746899,
            53747514,
            53747934,
            53746630,
            53746650,
            53747171,
            53747667,
            53746731,
            53746977,
            53759102,
            53746696,
            53748269,
            53748575,
            53751158,
            53747184,
            53746584,
            53747125,
            53747652
        ]
    },
    "name": "B. Chladni Figure",
    "statement": "Inaka has a disc, the circumference of which is n units. The\r\ncircumference is equally divided by n points numbered clockwise from 1\r\nto n, such that points i and i + 1 (1\r\nleq i < n) are adjacent, and so are points n and 1.There are m straight\r\nsegments on the disc, the endpoints of which are all among the\r\naforementioned n points.Inaka wants to know if her image is , i.e. if\r\nthere is an integer k (1\r\nleq k < n), such that if all segments are rotated clockwise around the\r\ncenter of the circle by k units, the new image will be the same as the\r\noriginal one.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n,m;\nvpi v;\nnamespace basicFactor {\n    template<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine\n        vector<pair<T,int>> pri;\n\n        for (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n            int t = 0;\n            while (x % i == 0) x /= i, t ++;\n            pri.pb({i,t});\n        }\n\n        if (x > 1) pri.pb({x,1});\n        return pri;\n    }\n\n    /* Note:\n     * number of operations needed s.t.\n     *                phi(phi(...phi(n)...))=1\n     * is O(log n).\n     * Euler's theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1\n     */\n\n    ll phi(ll x) {\n        trav(a,factor(x)) x /= a.f, x *= a.f-1;\n        return x;\n    }\n\n    template<class T> void tour(vector<pair<T,int>>& v, vector<T>& V, int ind, T cur) {\n        if (ind == sz(v)) V.pb(cur);\n        else {\n            T mul = 1;\n            F0R(i,v[ind].s+1) {\n                tour(v,V,ind+1,cur*mul);\n                mul *= v[ind].f;\n            }\n        }\n    }\n\n    template<class T> vector<T> getDivi(T x) {\n        auto v = factor(x);\n        vector<T> V; tour(v,V,0,(T)1); sort(all(V));\n        return V;\n    }\n}\n\nusing namespace basicFactor;\n\nvpi nor(vpi x) {\n    trav(t,x) {\n        t.f %= n, t.s %= n;\n        if (t.f > t.s) swap(t.f,t.s);\n    }\n    sort(all(x));\n    return x;\n}\n\nvoid test(int x) {\n    vpi V; trav(t,v) V.pb({t.f+x,t.s+x});\n    if (nor(V) == v) {\n        ps(\"Yes\");\n        exit(0);\n    }\n}\n\nint main() {\n    setIO(); re(n,m);\n    v.resz(m); re(v); v = nor(v);\n    auto v = factor(n);\n    trav(t,v) test(n/t.f);\n    ps(\"No\");\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "implementation",
        "strings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Chladni Figure.json",
    "editorial_link": "https://codeforces.com//blog/entry/66878",
    "editorial": "Let's brute force the value of k\n and check if it's possible to rotate the image by k\n to get the same image. We can do this by iterating through all segments (a,b)\n, and checking that (a+k,b+k)\n is a segment (the endpoints taken modulo n\n if needed).\n\nThis gives an O(nm)\n solution, however, you can notice that we only need to check divisors of n\n rather than all values from 1\n to n\n. This is because the set of segments (a,b),(a+k,b+k),(a+2k,b+2k),\n is exactly equal to (a,b),(a+gcd(n,k),b+gcd(n,k)),(a+2gcd(n,k),b+2gcd(n,k)),\n. Thus, this take O(m?d(n))\n, where d(n)\n denotes the number of divisors of n\n, which is fast enough to pass this problem.\n\nThere is also a faster linear time solution. We can reduce this to a problem of finding the largest period of a string. For every point, we can sort the length of the segments starting from that point (length in this case refers to clockwise distance). We also add some null character to denote a point. For instance, the first sample case's string might start like 2,?1,?1,4,8,10,?1,\n that represent the points from 1\n to 3\n. Such a string can be computed in O(mlogm)\n time. Then, after finding this string, we just want to check the period is bigger than 1\n. Let w\n be the length of the string. We can find this by concatenating the string to itself, then use z-algorithm to check if there is any is any index i\n from 1\n to w?1\n that is at least w\n.",
    "hint": []
}