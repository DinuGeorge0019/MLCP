{"link": "https://codeforces.com//contest/1648/problem/E", "problemId": "1318593", "problem_idx": "E", "shortId": "1648E", "contest_number": "1648", "problem_submissions": {"E": [148585486, 148584955, 148581597, 148589473, 148591135, 148593463, 148593416, 148597505, 148594995, 148595032, 148597135, 148605923, 148598836, 148596396, 148600942, 148602000, 148600796, 148581620, 148583646, 148661874, 148661844, 148587369], "D": [148564585, 148566578, 148571497, 148568116, 148573822, 148573519, 148574211, 148573964, 148574945, 148580191, 148578139, 148578497, 148607894, 148582725, 148577475, 148577301, 148585962, 148619534, 148575997, 148608357], "C": [148552509, 148552464, 148553813, 148558198, 148558432, 148554501, 148557954, 148555117, 148558520, 148556243, 148554082, 148553770, 148555702, 148554883, 148560099, 148557117, 148552206, 148558570, 148554233, 148559666], "B": [148545010, 148546110, 148555976, 148548495, 148550449, 148545480, 148551044, 148549564, 148551420, 148544796, 148546968, 148558793, 148547056, 148545781, 148549549, 148547973, 148544722, 148548048, 148546238, 148550231], "A": [148541636, 148541670, 148541532, 148543210, 148543257, 148541615, 148546248, 148544655, 148547990, 148541584, 148542460, 148542006, 148542056, 148542119, 148542975, 148543237, 148541644, 148542337, 148541655, 148542140], "F": [148613542, 151414821, 211208832, 211208769, 211208727, 211208586]}, "name": "E. Air Reform", "statement": "Berland is a large country with developed airlines. In total, there are\r\nn cities in the country that are historically served by the Berlaflot\r\nairline. The airline operates bi-directional flights between m pairs of\r\ncities, i-th of them connects cities with numbers a_i and b_i and has a\r\nprice c_i for a flight in both directions.It is known that Berlaflot\r\nflights can be used to get from any city to any other (possibly with\r\ntransfers), and the cost of any route that consists of several\r\nconsequent flights is equal to the cost of the most expensive of them.\r\nMore formally, the cost of the route from a city t_1 to a city t_k with\r\n(k-2) transfers using cities t_2,\r\nt_3,\r\nt_4,\r\nldots,\r\nt_{k - 1} is equal to the maximum cost of flights from t_1 to t_2, from\r\nt_2 to t_3, from t_3 to t_4 and so on until the flight from t_{k - 1} to\r\nt_k. Of course, all these flights must be operated by Berlaflot.A new\r\nairline, S8 Airlines, has recently started operating in Berland. This\r\nairline provides bi-directional flights between all pairs of cities that\r\nare not connected by Berlaflot direct flights. Thus, between each pair\r\nof cities there is a flight of either Berlaflot or S8 Airlines.The cost\r\nof S8 Airlines flights is calculated as follows: for each pair of cities\r\nx and y that is connected by a S8 Airlines flight, the cost of this\r\nflight is equal to the minimum cost of the route between the cities x\r\nand y at Berlaflot according to the pricing described earlier.It is\r\nknown that with the help of S8 Airlines flights you can get from any\r\ncity to any other with possible transfers, and, similarly to Berlaflot,\r\nthe cost of a route between any two cities that consists of several S8\r\nAirlines flights is equal to the cost of the most expensive flight.Due\r\nto the increased competition with S8 Airlines, Berlaflot decided to\r\nintroduce an air reform and change the costs of its flights. Namely, for\r\nthe i-th of its flight between the cities a_i and b_i, Berlaflot wants\r\nto make the cost of this flight equal to the minimum cost of the route\r\nbetween the cities a_i and b_i at S8 Airlines. Help Berlaflot managers\r\ncalculate new flight costs.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<std::array<int, 4>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        std::cin >> a >> b >> c;\n        a--;\n        b--;\n        edges[i] = {c, a, b, i};\n    }\n    \n    std::sort(edges.begin(), edges.end());\n    \n    std::vector<std::array<int, 3>> edges2;\n    \n    DSU g1(n), g2(n);\n    \n    std::vector<std::set<int>> comps(n), verts(n), adj(n);\n    \n    for (int i = 0; i < n; i++) {\n        comps[i].insert(i);\n        verts[i].insert(i);\n    }\n    for (auto [c, a, b, i] : edges) {\n        adj[a].insert(b);\n        adj[b].insert(a);\n    }\n    \n    for (auto [c, a, b, i] : edges) {\n        if (g1.same(a, b)) {\n            continue;\n        }\n        \n        a = g1.leader(a);\n        b = g1.leader(b);\n        for (auto x : comps[a]) {\n            auto s = comps[b];\n            for (auto y : s) {\n                bool ok = false;\n                for (auto u : verts[x]) {\n                    for (auto v : verts[y]) {\n                        if (!adj[u].count(v)) {\n                            ok = true;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        break;\n                    }\n                }\n                if (ok) {\n                    int v = g2.leader(x);\n                    edges2.push_back({c, v, y});\n                    \n                    g2.merge(y, v);\n                    if (g1.leader(v) == b) {\n                        if (verts[v].size() > verts[y].size()) {\n                            std::swap(verts[v], verts[y]);\n                        }\n                        for (auto u : verts[v]) {\n                            verts[y].insert(u);\n                        }\n                        verts[v].clear();\n                    }\n                }\n            }\n            comps[b].clear();\n            for (auto y : s) {\n                if (g2.leader(y) == y) {\n                    comps[b].insert(y);\n                }\n            }\n        }\n        \n        g1.merge(b, a);\n        for (auto x : comps[a]) {\n            if (g2.leader(x) == x) {\n                comps[b].insert(x);\n            } else {\n                int y = g2.leader(x);\n                if (verts[x].size() > verts[y].size()) {\n                    std::swap(verts[x], verts[y]);\n                }\n                for (auto u : verts[x]) {\n                    verts[y].insert(u);\n                }\n                verts[x].clear();\n            }\n        }\n        \n        comps[a].clear();\n    }\n    \n    std::vector<int> l(m, 0), r(m, n - 2);\n    \n    while (true) {\n        bool ok = true;\n        \n        for (auto [c, a, b, i] : edges) {\n            if (l[i] < r[i]) {\n                ok = false;\n            }\n        }\n        \n        if (ok) {\n            break;\n        }\n        \n        std::sort(edges.begin(), edges.end(), [&](auto a, auto b) {\n            return l[a[3]] + r[a[3]] < l[b[3]] + r[b[3]];\n        });\n        \n        DSU g(n);\n        int j = 0;\n        for (auto [c, a, b, i] : edges) {\n            if (l[i] == r[i]) {\n                continue;\n            }\n            \n            int mid = (l[i] + r[i]) / 2;\n            \n            while (j <= mid) {\n                g.merge(edges2[j][1], edges2[j][2]);\n                j++;\n            }\n            \n            if (g.same(a, b)) {\n                r[i] = mid;\n            } else {\n                l[i] = mid + 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        std::cout << edges2[l[i]][0] << \" \\n\"[i == m - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "divide and conquer", "dsu", "graphs", "implementation", "trees"], "dificulty": "3200", "interactive": false}