{
    "link": "https://codeforces.com//contest/696/problem/A",
    "problemId": "65168",
    "problem_idx": "A",
    "shortId": "696A",
    "contest_number": "696",
    "problem_submissions": {
        "E": [
            20498917,
            19122817,
            19128171,
            19128416,
            19128548,
            19128551,
            19129321,
            142908498,
            19129056,
            19129065,
            19148528,
            19121431
        ],
        "A": [
            19119258,
            19112517,
            19113245,
            19130646,
            19113356,
            19114035,
            19112027,
            19112329,
            19113544,
            19115943,
            19114049,
            19111947,
            19112445,
            19112591,
            19113340,
            19112458,
            19127604,
            19113354,
            19112419,
            19122807
        ],
        "B": [
            19118714,
            19115949,
            19116617,
            19115367,
            19115254,
            19116922,
            19113777,
            19114248,
            19115893,
            19113611,
            19114745,
            19113499,
            19115275,
            19114851,
            19115798,
            19115867,
            19113047,
            19115983,
            19115146,
            19124178
        ],
        "D": [
            19117852,
            19121638,
            19123814,
            19122693,
            19131199,
            19131585,
            19120524,
            19123388,
            19122212,
            19124637,
            19122311,
            19124184,
            19125355,
            19124738,
            19124393,
            19125186,
            19123099,
            19124323,
            19124512,
            19154347
        ],
        "C": [
            19113058,
            19119301,
            19121245,
            19119819,
            19118377,
            19124627,
            19116332,
            19120250,
            19118573,
            19118620,
            19122282,
            19118411,
            19120542,
            19120806,
            19119142,
            19121243,
            19119728,
            19127751
        ],
        "F": [
            19223787,
            19134194
        ]
    },
    "name": "A. Lorenzo Von Matterhorn",
    "statement": "Barney lives in NYC. NYC has infinite number of intersections numbered\r\nwith positive integers starting from 1. There exists a bidirectional\r\nroad between intersections and and another road between and for every\r\npositive integer . You can clearly see that there exists a unique\r\nshortest path between any two intersections. Initially anyone can pass\r\nany road for free. But since SlapsGiving is ahead of us, there will\r\nconsecutive events happen soon. There are two types of events:1.\r\nGovernment makes a new rule. A rule can be denoted by integers , and .\r\nAs the result of this action, the passing fee of all roads on the\r\nshortest path from to increases by dollars. 2. Barney starts moving from\r\nsome intersection and goes to intersection where there\u2019s a girl he wants\r\nto cuddle (using his fake name Lorenzo Von Matterhorn). He always uses\r\nthe shortest path (visiting minimum number of intersections or roads)\r\nbetween two intersections.Government needs your calculations. For each\r\ntime Barney goes to cuddle a girl, you need to tell the government how\r\nmuch money he should pay (sum of passing fee of all roads he passes).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nmap<ll,ll> dp;\nint q,ty,w;\nll u,v;\nint main() {\n\tscanf(\"%d\",&q);\n\trep(i,0,q) {\n\t\tscanf(\"%d%lld%lld\",&ty,&u,&v);\n\t\tif (ty==1) {\n\t\t\tscanf(\"%d\",&w);\n\t\t\twhile (u!=v) {\n\t\t\t\tif (u>v) swap(u,v);\n\t\t\t\tdp[v]+=w; v/=2;\n\t\t\t}\n\t\t} else {\n\t\t\tll s=0;\n\t\t\twhile (u!=v) {\n\t\t\t\tif (u>v) swap(u,v);\n\t\t\t\ts+=dp[v]; v/=2;\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",s);\n\t\t}\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Lorenzo Von Matterhorn.json",
    "editorial_link": "https://codeforces.com//blog/entry/46031",
    "editorial": "Do what problem wants from you. The only thing is to find the path between the two vertices (or LCA) in the tree. You can do this in  since the height of the tree is . You can keep edge weights in a map and get/set the value whenever you want. Here's a code for LCA:"
}