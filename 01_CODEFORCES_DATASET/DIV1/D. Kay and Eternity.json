{
    "link": "https://codeforces.com//contest/685/problem/D",
    "problemId": "63495",
    "problem_idx": "D",
    "shortId": "685D",
    "contest_number": "685",
    "problem_submissions": {
        "D": [
            18684968,
            18683037,
            18681924,
            18684130,
            18684858,
            18675255,
            18679526,
            18679808,
            18682052,
            18681014,
            18682178,
            18675901,
            18679039,
            18766980,
            18685989,
            18678764,
            18679061
        ],
        "E": [
            18680021,
            18684845,
            18678334,
            18685890,
            18682877,
            18680554,
            18681882,
            18681692,
            18684390,
            18678520,
            18684936,
            18720222,
            18691735,
            18673504,
            18680472,
            18683676
        ],
        "C": [
            18677291,
            18679523,
            18681119,
            18679602,
            18685346,
            19679131,
            18684317,
            18682713,
            18688360
        ],
        "B": [
            18672960,
            18674692,
            18671800,
            18672771,
            18680872,
            18678053,
            18673109,
            18673699,
            18678361,
            18684612,
            18675812,
            18678146,
            19679139,
            19641621,
            18676260,
            18675658,
            18675674,
            18671554,
            18673419,
            18674754,
            18676154
        ],
        "A": [
            18671402,
            18670567,
            18669065,
            18670159,
            18670329,
            18681950,
            18668946,
            18671121,
            18669783,
            18686475,
            18678918,
            18676980,
            19641683,
            18673416,
            18767003,
            18671711,
            18682810,
            18674563,
            18668359,
            18672213
        ]
    },
    "name": "D. Kay and Eternity",
    "statement": "Snow Queen told Kay to form a word \"eternity\" using pieces of ice. Kay\r\nis eager to deal with the task, because he will then become free, and\r\nSnow Queen will give him all the world and a pair of skates.Behind the\r\npalace of the Snow Queen there is an infinite field consisting of cells.\r\nThere are pieces of ice spread over the field, each piece occupying\r\nexactly one cell and no two pieces occupying the same cell. To estimate\r\nthe difficulty of the task Kay looks at some squares of size cells, with\r\ncorners located at the corners of the cells and sides parallel to\r\ncoordinate axis and counts the number of pieces of the ice inside\r\nthem.This method gives an estimation of the difficulty of some part of\r\nthe field. However, Kay also wants to estimate the total difficulty, so\r\nhe came up with the following criteria: for each () he wants to count\r\nthe number of squares of size , such that there are exactly pieces of\r\nthe ice inside.Please, help Kay estimate the difficulty of the task\r\ngiven by the Snow Queen.\r\n",
    "solutions": [
        "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define lld \"%I64d\"\n#else\n    #define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n,k;\nstruct pkt{\n\tint x,y;\n\tvoid read(){\n\t}\n}a[111111];\nset<int> se;\nint num[222222],sum[222222];\nint totnum;\nmap<int,int>id;\nint back[222222];\nint xtot=0;\n\nint le[222222],ri[222222];\n\nvoid add(int x,int sumdel,int numdel){\n\tint ii=id[x];\n\n\tsum[ii]+=sumdel;\n\tnum[ii]+=numdel;\n\ttotnum+=numdel;\n\n\tif(num[ii]==0 && numdel==-1){\n\t\tse.erase(x);\n\t\tle[ri[ii]]=le[ii];\n\t\tri[le[ii]]=ri[ii];\n\t}else if(num[ii]==1 && numdel==1){\n\t\tset<int>::iterator it=se.lower_bound(x);\n\t\tint rig=*it;\n\t\tit--;\n\t\tint lef=*it;\n\t\tse.insert(x);\n\t\tri[id[lef]]=ii;le[ii]=id[lef];\n\t\tle[id[rig]]=ii;ri[ii]=id[rig];\n\t}\n}\nstruct seg{\n\tint l,r;\n\tint y;\n\tint del;\n}ss[222222];int sstot=0;\nint cmpy(const seg&a,const seg&b){\n\treturn a.y<b.y;\n}\n\nll ans[111111];\n\nvoid tongji(){\n\n\tint u=ri[1];\n\tint su=sum[u];\n\n\twhile(u!=xtot){\n\t\tint v=ri[u];\n\n\t\tans[su]+=back[v]-back[u];\n\t\tsu+=sum[v];\n\t\tu=v;\n\t}\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);gn(k);\n\trep(i,1,n+1){\n\t\tint x,y;\n\t\tgn(x);gn(y);\n\t\tss[++sstot]=(seg){x-k,x,y-k,+1};\n\t\tss[++sstot]=(seg){x-k,x,y,-1};\n\t\tid[x-k],id[x];\n\t}\n\tid[-inf];id[inf];\n\tse.insert(-inf);se.insert(inf);\n\tforeach(it,id)back[it->se=++xtot]=it->fi;\n\tri[1]=xtot;le[xtot]=1;\n\tsort(ss+1,ss+1+sstot,cmpy);\n\n\n\tint cur=1;\n\tfor (int y=-inf;cur<=sstot;y++){\n\t\twhile(cur<=sstot && ss[cur].y==y){\n\t\t\tif(ss[cur].del==1){\n\t\t\t\tadd(ss[cur].l,1,1);\n\t\t\t\tadd(ss[cur].r,-1,1);\n\t\t\t}else {\n\t\t\t\tadd(ss[cur].l,-1,-1);\n\t\t\t\tadd(ss[cur].r,1,-1);\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\ttongji();\n\t\tif(cur>sstot)break;\n\t\tif(totnum==0){\n\t\t\ty=ss[cur].y-1;\n\t\t}\n\t}\n\trep(i,1,n+1)printf(\"%I64d \",ans[i]);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "sortings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Kay and Eternity.json",
    "editorial_link": "https://codeforces.com//blog/entry/45558",
    "editorial": "Let's solve this problem with scanline. Go through all rows from left to right and maintain the array in which in j index we will store the number of points in a square with bottom left coordinate (i,?j), where i is current row of scanline.\n\nThis takes O(MAXCORD2) time. Note that the set of squares that contain some of the shaded points is not very large, namely \u0097 if the point has coordinates (x,?y), then the set of left bottom corners of square is defined as {(a,?b)|x?-?k?+?1?<??=?a?<??=?x,?y?-?k?+?1?<??=?b?<??=?y}. Let's consider each point (x,?y) as the 2 events:\nAdd one to the all elements with indexes from y?-?k?+?1 to y on the row x?-?k?+?1 and take one at the same interval on the row x?+?1. How to calculate answer? Suppose we update the value of a cell on the row a, and before it was updated the value x on the row b. Let add to the answer for the number of squares containing x points value a?-?b. We can implement the addition of the segment directly and have O(nk) for processing all the events that fit in time limit. To get rid of O(MAXCORD) memory, we need to write all interested in the coordinates before processing events (them no more than nk) and reduce the coordinates in the events. It takes  time and O(nk) memory. Now we can execute the previous point in O(nk) memory.\nComplexity is  time and O(nk) memory."
}