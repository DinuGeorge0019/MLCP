{"link": "https://codeforces.com//contest/1246/problem/D", "problemId": "451070", "problem_idx": "D", "shortId": "1246D", "contest_number": "1246", "problem_submissions": {"F": [63515154, 63481339, 63483227, 63527437], "E": [63477457, 63471160, 63477982, 63475906, 63518064, 63483383, 63518604, 97691403, 63517633, 63488500], "D": [63464099, 63460604, 63460125, 63467192, 63463968, 63466889, 63467829, 63473013, 63471128, 63459892, 63474479, 63467875, 63476603, 63468880, 63466274, 63468455, 63468377, 63471942, 63478598, 63471593], "C": [63452409, 63454665, 63454015, 63456906, 63457379, 63460403, 63458338, 63462999, 63457035, 63454754, 63459839, 63457021, 63458327, 63457758, 63458226, 63460931, 63460824, 63461992, 63467689, 63460739], "B": [63442019, 63440659, 63440705, 63445485, 63449371, 63449831, 63445799, 63449601, 63451011, 63449141, 63439490, 63447371, 63445988, 63447815, 63451910, 63451605, 63453470, 63443287, 63451810, 63450686], "A": [63437903, 63456370, 63443580, 63437815, 63442162, 63437666, 63439166, 63442383, 63492730, 63442467, 63438366, 63445898, 63440290, 63439417, 63440796, 63444393, 63441301, 63442558, 63437991, 63443933, 63444495]}, "name": "D. Tree Factory", "statement": "Bytelandian Tree Factory produces trees for all kinds of industrial\r\napplications. You have been tasked with optimizing the production of a\r\ncertain type of tree for an especially large and important order.The\r\ntree in question is a rooted tree with n vertices labelled with distinct\r\nintegers from 0 to n - 1. The vertex labelled 0 is the root of the tree,\r\nand for any non-root vertex v the label of its parent p(v) is less than\r\nthe label of v.All trees at the factory are made from bamboo blanks. A\r\nis a rooted tree such that each vertex has exactly one child, except for\r\na single leaf vertex with no children. The vertices of a bamboo blank\r\ncan be labelled arbitrarily before its processing is started.To process\r\na bamboo into another tree a single type of operation can be made:\r\nchoose an arbitrary non-root vertex v such that its parent p(v) is not a\r\nroot either. The operation consists of changing the parent of v to its\r\nparent\u2019s parent p(p(v)). Note that parents of all other vertices remain\r\nunchanged, in particular, the subtree of v does not change.Efficiency is\r\ncrucial, hence you have to minimize the number of operations to make the\r\ndesired tree from a bamboo blank. Construct any optimal sequence of\r\noperations to produce the desired tree.Note that the labelling of the\r\nresulting tree has to coincide with the labelling of the desired tree.\r\nFormally, the labels of the roots have to be equal, and for non-root\r\nvertices with the same label the labels of their parents should be the\r\nsame.It is guaranteed that for any test present in this problem an\r\nanswer exists, and further, an optimal sequence contains at most 10^6\r\noperations. Note that .\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? \"true\" : \"false\"); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void pr(const T& x) { \n        pr(\"{\"); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    \n    void ps() { pr(\"\\n\"); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n    }\n    \n    void pc() { pr(\"]\\n\"); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n    }\n    #define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n, p[MX], des[MX], depth[MX], maxDepth[MX];\nvi child[MX];\nvi boo, op;\n\nvoid dfs(int x) {\n\tmaxDepth[x] = depth[x];\n\ttrav(c,child[x]) {\n\t\tdepth[c] = depth[x]+1; dfs(c);\n\t\tckmax(maxDepth[x], maxDepth[c]);\n\t}\n}\n\nvoid mov(int x) {\n\tassert(p[x] != -1);\n\tp[x] = p[p[x]]; op.pb(x);\n}\n\nvoid genBoo(int x) {\n\tif (sz(boo)) p[x] = boo.back();\n\telse p[x] = -1;\n\tboo.pb(x);\n\twhile (p[x] != des[x]) mov(x);\n\ttrav(c,child[x]) genBoo(c);\n}\n\nint main() {\n\tsetIO(); re(n); \n\tdes[0] = -1;\n\tFOR(i,1,n) {\n\t\tre(des[i]);\n\t\tchild[des[i]].pb(i);\n\t}\n\tdfs(0);\n\tF0R(i,n) sort(all(child[i]),[](int a, int b) { return maxDepth[a] < maxDepth[b]; });\n\t\n\tgenBoo(0);\n\tFOR(i,1,n) assert(p[i] == des[i]);\n\ttrav(t,boo) pr(t,' ');\n\tps();\n\tps(sz(op));\n\ttrav(t,op) pr(t,' ');\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n"], "input": "", "output": "", "tags": ["constructive algorithms", "divide and conquer", "greedy", "trees"], "dificulty": "2500", "interactive": false}