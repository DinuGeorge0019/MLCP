{
    "link": "https://codeforces.com//contest/1889/problem/F",
    "problemId": "2253923",
    "problem_idx": "F",
    "shortId": "1889F",
    "contest_number": "1889",
    "problem_submissions": {
        "F": [
            230286542,
            230266065,
            230262442
        ],
        "E": [
            230256898,
            230246832
        ],
        "D": [
            230235941,
            230232857,
            230224566,
            230272022,
            230272005,
            230271882,
            230271768,
            230230795,
            230267581,
            230266453,
            230266166,
            230265951,
            230226552,
            230234432,
            230236469,
            230251974,
            230254932,
            230230502,
            230243460,
            230250152,
            230249726,
            230244428,
            230257470,
            230253116,
            230249203,
            230254701,
            230259645,
            230251139
        ],
        "C2": [
            230210010,
            230217978,
            230434330,
            230213058,
            230214943,
            230216126,
            230223427,
            230223092,
            230233645,
            230213601,
            230231558,
            230237014,
            230233479,
            230223561,
            230227068,
            230237154,
            230230576,
            230236721,
            230222800,
            230220319
        ],
        "C1": [
            230200664,
            230217626,
            230211402,
            230212701,
            230201726,
            230298285,
            230199777,
            230209649,
            230223226,
            230202866,
            230195160,
            230217294,
            230211164,
            230200107,
            230209171,
            230227585,
            230205456,
            230230794,
            230222696,
            230222982,
            230220187
        ],
        "B": [
            230195225,
            230190509,
            230206755,
            230191485,
            230197446,
            230193895,
            230198878,
            230202551,
            230190822,
            230262085,
            230199606,
            230196726,
            230195700,
            230203093,
            230203643,
            230199184,
            230213572,
            230204206,
            230194309,
            230191500
        ],
        "A": [
            230190808,
            230198511,
            230201631,
            230187953,
            230191913,
            230188070,
            230191494,
            230197747,
            230187919,
            230186845,
            230194401,
            230191161,
            230186018,
            230251033,
            230195006,
            230188313,
            230193522,
            230193269,
            230187554,
            230187719
        ]
    },
    "name": "F. Doremy s Average Tree",
    "statement": "Doremy has a rooted tree of size n whose root is vertex r. Initially\r\nthere is a number w_i written on vertex i. Doremy can use her power to\r\nperform this operation k times: Choose a vertex x (1\r\nleq x\r\nleq n). Let s =\r\nfrac{1}{|T|}\r\nsum_{i\r\nin T} w_i where T is the set of all vertices in xâ€™s subtree. For all i\r\nin T, assign w_i := s. Doremy wants to know what is the\r\nlexicographically smallest^\r\ndagger array w after performing all the operations. Can you help her?If\r\nthere are multiple answers, you may output any one.^\r\ndagger For arrays a and b both of length n, a is lexicographically\r\nsmaller than b if and only if there exist an index i (1\r\nleq i\r\nle n) such that a_i < b_i and for all indices j such that j<i, a_j=b_j\r\nis satisfied.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng(0);\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"\\033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"\\033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\n\t     << \" | \"\n\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\n\t     << \":\"\n\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\n\t     << \" - \"\n\t     << \"[\" << args << \"] = \";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: Generate various types of trees.\n * Source: Own + Dhruv Rohatgi\n */\n\n////////////// DISTRIBUTIONS\n\n// return int in [L,R] inclusive\nint rng_int(int L, int R) {\n\tassert(L <= R);\n\treturn uniform_int_distribution<int>(L, R)(rng);\n}\nll rng_ll(ll L, ll R) {\n\tassert(L <= R);\n\treturn uniform_int_distribution<ll>(L, R)(rng);\n}\n\n// return double in [L,R] inclusive\ndb rng_db(db L, db R) {\n\tassert(L <= R);\n\treturn uniform_real_distribution<db>(L, R)(rng);\n}\n\n// http://cplusplus.com/reference/random/geometric_distribution/geometric_distribution/\n// flip a coin which is heads with probability p until you flip heads\n// mean value of c is 1/p-1\nint rng_geo(db p) {\n\tassert(0 < p && p <= 1);  // p large -> closer to 0\n\treturn geometric_distribution<int>(p)(rng);\n}\n\n////////////// VECTORS + PERMS\n\n// shuffle a vector\ntemplate <class T> void shuf(vector<T> &v) { shuffle(all(v), rng); }\n\n// generate random permutation of [0,N-1]\nvi randPerm(int N) {\n\tvi v(N);\n\tiota(all(v), 0);\n\tshuf(v);\n\treturn v;\n}\n\n// random permutation of [0,N-1] with first element 0\nvi randPermZero(int N) {\n\tvi v(N - 1);\n\tiota(all(v), 1);\n\tshuf(v);\n\tv.ins(bg(v), 0);\n\treturn v;\n}\n\n// shuffle permutation of [0,N-1]\nvi shufPerm(vi v) {\n\tint N = sz(v);\n\tvi key = randPerm(N);\n\tvi res(N);\n\tF0R(i, N) res[key[i]] = key[v[i]];\n\treturn res;\n}\n\n// vector with all entries in [L,R]\nvi rng_vec(int N, int L, int R) {\n\tvi res;\n\tF0R(_, N) res.pb(rng_int(L, R));\n\treturn res;\n}\n\n// vector with all entries in [L,R], unique\nvi rng_vec_unique(int N, int L, int R) {\n\tset<int> so_far;\n\tvi res;\n\tF0R(_, N) {\n\t\tint x;\n\t\tdo { x = rng_int(L, R); } while (so_far.count(x));\n\t\tso_far.ins(x);\n\t\tres.pb(x);\n\t}\n\treturn res;\n}\n\n////////////// GRAPHS\n\n// relabel edges ed according to perm, shuffle\nvpi relabelAndShuffle(vpi ed, vi perm) {\n\teach(t, ed) {\n\t\tt.f = perm[t.f], t.s = perm[t.s];\n\t\tif (rng() & 1) swap(t.f, t.s);\n\t}\n\tshuf(ed);\n\treturn ed;\n}\n\n// shuffle graph with vertices [0,N-1]\nvpi shufGraph(int N, vpi ed) {  // randomly swap endpoints, rearrange labels\n\treturn relabelAndShuffle(ed, randPerm(N));\n}\nvpi shufGraphZero(int N, vpi ed) {\n\treturn relabelAndShuffle(ed, randPermZero(N));\n}\n\n// shuffle tree given N-1 edges\nvpi shufTree(vpi ed) { return shufGraph(sz(ed) + 1, ed); }\n// randomly swap endpoints, rearrange labels\nvpi shufRootedTree(vpi ed) {\n\treturn relabelAndShuffle(ed, randPermZero(sz(ed) + 1));\n}\n\nvoid pgraphOne(int N, vpi ed) {\n\tps(N, sz(ed));\n\teach(e, ed) ps(1 + e.f, 1 + e.s);\n}\n\n////////////// GENERATING TREES\n\n// for generating tall tree\npi geoEdge(int i, db p) {\n\tassert(i > 0);\n\treturn {i, max(0, i - 1 - rng_geo(p))};\n}\n\n// generate edges of tree with verts [0,N-1]\n// smaller back -> taller tree\nvpi treeRand(int N, int back) {\n\tassert(N >= 1 && back >= 0);\n\tvpi ed;\n\tFOR(i, 1, N) ed.eb(i, i - 1 - rng_int(0, min(back, i - 1)));\n\treturn ed;\n}\n\n// generate path\nvpi path(int N) { return treeRand(N, 0); }\n\n// generate tall tree (large diameter)\n// the higher the p the taller the tree\nvpi treeTall(int N, db p) {\n\tassert(N >= 1);\n\tvpi ed;\n\tFOR(i, 1, N) ed.pb(geoEdge(i, p));\n\treturn ed;\n}\n\n// generate tall tree, then add rand at end\nvpi treeTallShort(int N, db p) {\n\tassert(N >= 1);\n\tint mid = (N + 1) / 2;\n\tvpi ed = treeTall(mid, p);\n\tFOR(i, mid, N) ed.eb(i, rng_int(0, i - 1));\n\treturn ed;\n}\n\n// lots of stuff connected to either heavy1 or heavy2\nvpi treeTallHeavy(int N, db p) {\n\tassert(N >= 1);  // + bunch of rand\n\tvpi ed;\n\tint heavy1 = 0, heavy2 = N / 2;\n\tFOR(i, 1, N) {\n\t\tif (i < N / 4) ed.eb(i, heavy1);\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\n\t\telse ed.pb(geoEdge(i, p));\n\t}\n\treturn ed;\n}\n\n// heavy tall tree + random\n// lots of verts connected to heavy1 or heavy2\nvpi treeTallHeavyShort(int N, db p) {\n\tassert(N >= 1);  // + almost-path + rand\n\tvpi ed;\n\tint heavy1 = 0, heavy2 = N / 2;\n\tFOR(i, 1, N) {\n\t\tif (i < N / 4) ed.eb(i, heavy1);\n\t\telse if (i <= heavy2) ed.pb(geoEdge(i, p));  // tall -> heavy1\n\t\telse if (i > heavy2 && i < 3 * N / 4) ed.eb(i, heavy2);\n\t\telse ed.eb(i, rng_int(0, i - 1));\n\t}\n\treturn ed;\n}\n\nint rand_prime(int l, int r) {\n\twhile (1) {\n\t\tint x = rng_int(l, r);\n\t\tbool bad = 0;\n\t\tfor (int i = 2; i * i <= x; ++i)\n\t\t\tif (x % i == 0) bad = 1;\n\t\tif (!bad) return x;\n\t}\n}\n\nstruct Frac {\n\tll n, d;\n\tbool operator<(const Frac &o) const { return n * o.d < o.n * d; }\n\tbool operator==(const Frac &o) const { return n * o.d == o.n * d; }  // OK\n};\n\nostream &operator<<(ostream &os, const Frac &f) {\n\tos << \"Frac(\" << f.n << \", \" << f.d << \")\";\n\treturn os;\n}\n\nstruct RangeInfo {\n\tpair<int, Frac> d0, d1;\n\tbool single_value() const { return d1.f == INT_MAX; }\n\tpair<int, Frac> first_dif(Frac f) const {\n\t\tif (d0.s == f) return d1;\n\t\treturn d0;\n\t}\n\tbool greater_than(Frac f) {\n\t\tauto [idx, val] = first_dif(f);\n\t\tif (idx == INT_MAX) return false;\n\t\tassert(!(f == val));\n\t\treturn f < val;\n\t}\n\tbool greater_or_equal(Frac f) {\n\t\tauto [idx, val] = first_dif(f);\n\t\tif (idx == INT_MAX) return true;\n\t\tassert(!(f == val));\n\t\treturn f < val;\n\t}\n};\n\nostream &operator<<(ostream &os, const pair<int, Frac> &p) {\n\tos << \"{\" << p.f << \", \" << p.s << \"}\";\n\treturn os;\n}\n\nostream &operator<<(ostream &os, const RangeInfo &i) {\n\tos << \"RangeInfo{\" << i.d0 << \", \" << i.d1 << \"}\";\n\treturn os;\n}\n\nRangeInfo operator+(RangeInfo l, RangeInfo r) {\n\tif (l.d0.f > r.d0.f) swap(l, r);\n\tassert(l.d0.f < r.d0.f);\n\treturn RangeInfo{l.d0, min(l.d1, l.d0.s == r.d0.s ? r.d1 : r.d0)};\n}\n\nstruct Info {\n\tint k, first_different;\n\tpi prev_pair;\n\tRangeInfo r;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n\tos << \"Info{\" << i.k << \", \" << i.first_different << \", \"\n\t   << \"{\" << i.prev_pair.f << \", \" << i.prev_pair.s << \"}\"\n\t   << \", \" << i.r << \"}\";\n\treturn os;\n}\n\nInfo info_single(int x, int w) {\n\treturn {0, INT_MAX, {-1, -1}, RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}};\n}\n\nint N, K;\nV<V<Info>> dp, stor;\nvi W;\nV<vi> adj;\nvl sum;\nvi num;\n\nV<Info> conv(const V<Info> &dp_l, const V<Info> &dp_r) {\n\t// dbg(\"COMPUTING\", sz(dp_l), sz(dp_r));\n\tint max_ops = min(dp_l.bk.k + dp_r.bk.k, K);\n\tV<vpi> cands(max_ops + 1);\n\tF0R(i, sz(dp_l)) F0R(j, sz(dp_r)) if (dp_l[i].k + dp_r[j].k <= K) {\n\t\tcands[dp_l[i].k + dp_r[j].k].pb({i, j});\n\t}\n\tauto better_pair = [&](pi a, pi b) {\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\n\t\tswap(a, b);\n\t\tif (a.f <= b.f && a.s <= b.s) return b;\n\t\tif (a.f > b.f) swap(a, b);\n\t\tassert(a.f < b.f && a.s > b.s);\n\t\tint min_dif_a = INT_MAX;\n\t\tFOR(i, a.f + 1, b.f + 1) ckmin(min_dif_a, dp_l.at(i).first_different);\n\t\tint min_dif_b = INT_MAX;\n\t\tFOR(i, b.s + 1, a.s + 1) ckmin(min_dif_b, dp_r.at(i).first_different);\n\t\tif (min_dif_a < min_dif_b) return b;\n\t\treturn a;\n\t};\n\tauto first_different = [&](pi a, pi b) {\n\t\tint min_dif = INT_MAX;\n\t\tFOR(i, min(a.f, b.f) + 1, max(a.f, b.f) + 1)\n\t\tckmin(min_dif, dp_l.at(i).first_different);\n\t\tFOR(i, min(a.s, b.s) + 1, max(a.s, b.s) + 1)\n\t\tckmin(min_dif, dp_r.at(i).first_different);\n\t\treturn min_dif;\n\t};\n\tvpi best;\n\tF0R(i, sz(cands)) {\n\t\twhile (sz(cands[i]) > 1) {\n\t\t\tend(cands[i])[-2] =\n\t\t\t    better_pair(end(cands[i])[-2], end(cands[i])[-1]);\n\t\t\tcands[i].pop_back();\n\t\t}\n\t\tif (sz(cands[i])) {\n\t\t\tif (sz(best) && better_pair(best.bk, cands[i].bk) == best.bk)\n\t\t\t\tcontinue;\n\t\t\tbest.pb(cands[i].bk);\n\t\t\t// ret.pb();\n\t\t}\n\t}\n\tV<Info> ndp;\n\tF0R(i, sz(best)) {\n\t\tauto [l, r] = best[i];\n\t\tndp.pb({dp_l[l].k + dp_r[r].k,\n\t\t        i == 0 ? INT_MAX : first_different(best.at(i - 1), best.at(i)),\n\t\t        {l, r},\n\t\t        dp_l[l].r + dp_r[r].r});\n\t}\n\treturn ndp;\n\t// V<Info> ndp;\n\t// F0R(ops, max_ops + 1) {  // SLOW\n\t// \tint l = 0, r = 0;\n\t// \tint last_mn = INT_MAX;\n\t// \twhile (true) {\n\t// \t\tint mn = INT_MAX;\n\t// \t\tpi best;\n\t// \t\tFOR(i, l + 1, sz(dp_l))\n\t// \t\tif (dp_l[i].k + dp_r[r].k <= ops) {\n\t// \t\t\tif (ckmin(mn, dp_l[i].first_different)) { best = {0, i}; }\n\t// \t\t} else break;\n\t// \t\tFOR(j, r + 1, sz(dp_r))\n\t// \t\tif (dp_l[l].k + dp_r[j].k <= ops) {\n\t// \t\t\tif (ckmin(mn, dp_r[j].first_different)) { best = {1, j}; }\n\t// \t\t} else break;\n\t// \t\tif (mn == INT_MAX) {\n\t// \t\t\tif (dp_l[l].k + dp_r[r].k == ops) {\n\t// \t\t\t\tndp.pb({ops, last_mn, {l, r}, dp_l[l].r + dp_r[r].r});\n\t// \t\t\t}\n\t// \t\t\tbreak;\n\t// \t\t} else {\n\t// \t\t\tif (best.f == 0) l = best.s;\n\t// \t\t\telse r = best.s;\n\t// \t\t\tlast_mn = mn;\n\t// \t\t}\n\t// \t}\n\t// }\n\t// return ret;\n}\n\nvoid construct(int x, int p) {\n\tsum[x] = W[x];\n\tnum[x] = 1;\n\tdp[x] = {info_single(x, W[x])};\n\n\t// {{INT_MAX, RangeInfo{{x, Frac{W[x], 1}}, {INT_MAX, {}}}}};\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tconstruct(y, x);\n\t\t\tsum[x] += sum[y];\n\t\t\tnum[x] += num[y];\n\t\t\tauto ndp = conv(dp[x], dp[y]);\n\t\t\tswap(dp[x], stor[y]);\n\t\t\tswap(dp[x], ndp);\n\t\t}\n\tFrac f{sum[x], num[x]};\n\tif (!dp[x][0].r.greater_than(f)) return;\n\tif (sz(dp[x]) > 1) {\n\t\tassert(dp[x].at(1).k == 1);\n\t\tif (!dp[x].at(1).r.greater_than(f)) return;\n\t}\n\tint idx = 1;\n\twhile (idx < sz(dp[x]) && dp[x][idx].r.greater_or_equal(f)) ++idx;\n\tV<Info> ndp{dp[x][0]};\n\t{\n\t\tRangeInfo r{{dp[x][0].r.d0.f, f}, {INT_MAX, {}}};\n\t\tndp.pb({1, dp[x][0].r.first_dif(f).f, {-1, -1}, r});\n\t}\n\tif (idx < sz(dp[x])) {\n\t\tFOR(i, idx, sz(dp[x])) {\n\t\t\tassert(!dp[x][i].r.greater_or_equal(f));\n\t\t\tif (i == idx) {\n\t\t\t\tdp[x][i].first_different = dp[x][i].r.first_dif(f).f;\n\t\t\t\tndp.pb(dp[x][i]);\n\t\t\t} else {\n\t\t\t\tndp.pb(dp[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dp[x], ndp);\n}\n\nvoid reconstruct(vi &ans, int idx, int x, int p) {\n\tif (idx == 0) return;\n\tassert(idx < sz(dp[x]));\n\tauto [lhs, rhs] = dp[x].at(idx).prev_pair;\n\tif (lhs == -1) {\n\t\tans.pb(x);\n\t\treturn;\n\t}\n\tassert(lhs >= 0 && rhs >= 0);\n\tR0F(y_idx, sz(adj[x])) {\n\t\tint y = adj[x][y_idx];\n\t\tif (y == p) continue;\n\t\tassert(lhs < sz(stor[y]));\n\t\tassert(rhs < sz(dp[y]));\n\t\treconstruct(ans, rhs, y, x);\n\t\ttie(lhs, rhs) = stor[y].at(lhs).prev_pair;\n\t}\n\tassert(lhs == -1 && rhs == -1);\n}\n\nstruct NaiveSol {\n\tV<pair<int, Frac>> result;\n\tvi moves;\n};\n\ntemplate <class T> V<T> operator+(V<T> a, V<T> b) {\n\ta.ins(end(a), all(b));\n\treturn a;\n}\n\nNaiveSol operator+(NaiveSol a, NaiveSol b) {\n\tNaiveSol c{a.result + b.result, a.moves + b.moves};\n\tsor(c.result);\n\treturn c;\n}\n\nV<NaiveSol> brute(int x, int p) {\n\tsum[x] = W[x];\n\tnum[x] = 1;\n\tV<NaiveSol> dp;\n\tdp.pb({{{x, Frac{W[x], 1}}}, {}});\n\tfor (int y : adj[x])\n\t\tif (y != p) {\n\t\t\tauto child_dp = brute(y, x);\n\t\t\tsum[x] += sum[y];\n\t\t\tnum[x] += num[y];\n\t\t\tV<NaiveSol> ndp;\n\t\t\tF0R(i, sz(dp)) F0R(j, sz(child_dp)) if (i + j <= K) {\n\t\t\t\tauto s = dp[i] + child_dp[j];\n\t\t\t\tif (i + j == sz(ndp)) {\n\t\t\t\t\tndp.pb(s);\n\t\t\t\t} else {\n\t\t\t\t\tif (s.result < ndp.at(i + j).result) ndp.at(i + j) = s;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp, ndp);\n\t\t}\n\t{\n\t\tauto result = dp.at(0).result;\n\t\teach(t, result) t.s = Frac{sum[x], num[x]};\n\t\tNaiveSol kill_sub{result, {x}};\n\t\tif (sz(dp) == 1) dp.pb(kill_sub);\n\t\telse if (kill_sub.result < dp[1].result) dp[1] = kill_sub;\n\t}\n\treturn dp;\n}\n\nvi solve1(int R) {\n\tauto cands = brute(R, 0);\n\tFOR(i, 1, sz(cands)) if (cands[i].result < cands[0].result) {\n\t\tcands[0] = cands[i];\n\t}\n\tvi ans = cands[0].moves;\n\treturn ans;\n}\n\nvi solve2(int R) {\n\tconstruct(R, 0);\n\tint k = dp[R].bk.k;\n\tvi ans;\n\treconstruct(ans, sz(dp[R]) - 1, R, 0);\n\tassert(sz(ans) == k);\n\treturn ans;\n}\n\n/**\n * Description: wraps a lambda so it can call itself\n * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\n */\n\nnamespace std {\n\ntemplate <class Fun> class y_combinator_result {\n\tFun fun_;\n\n  public:\n\ttemplate <class T>\n\texplicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\n\n\ttemplate <class... Args> decltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate <class Fun> decltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n}  // namespace std\n\nvoid y_comb_demo() {\n\tcout << y_combinator([](auto gcd, int a, int b) -> int {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t})(20, 30)\n\t     << \"\\n\";  // outputs 10\n}\n\nV<Frac> eval(int R, vi v) {\n\tV<Frac> res(N + 1);\n\t// dbg(\"EVAL\", R, v);\n\ty_combinator([&](auto dfs_set, int x, int p, Frac val) -> void {\n\t\tif (!val.d) {\n\t\t\tif (find(all(v), x) != end(v)) val = Frac{sum[x], num[x]};\n\t\t}\n\t\t// dbg(\"AT\", x, p, val);\n\t\tif (val.d) {\n\t\t\tres[x] = val;\n\t\t} else {\n\t\t\tres[x] = Frac{W[x], 1};\n\t\t}\n\t\tfor (int y : adj[x])\n\t\t\tif (y != p) dfs_set(y, x, val);\n\t})(R, 0, Frac{});\n\treturn res;\n}\n\nvoid solve(int tc, bool gen = true) {\n\t// dbg(\"DOING\", tc);\n\tint R;\n\tif (gen) {\n\t\tN = 6;\n\t\t// N = rng_int(2, 5);\n\t\tR = rng_int(1, N);\n\t\tK = rng_int(0, N);\n\t} else {\n\t\tre(N, R, K);\n\t}\n\tW.rsz(N + 1);\n\tint mx = rng_int(1, 10);\n\tFOR(i, 1, N + 1) {\n\t\tif (gen) {\n\t\t\tW[i] = rng_int(1, mx);\n\t\t} else re(W[i]);\n\t}\n\tadj = V<vi>(N + 1);\n\tFOR(i, 2, N + 1) {\n\t\tif (gen) {\n\t\t\tint u = rng_int(1, i - 1), v = i;\n\t\t\tadj[u].pb(v), adj[v].pb(u);\n\t\t} else {\n\t\t\tdef(int, u, v);\n\t\t\tadj[u].pb(v), adj[v].pb(u);\n\t\t}\n\t}\n\t// dbg(tc);\n\t// if (tc == 47336) { dbg(N, R, K, W, adj); }\n\tdp = {};\n\tdp.rsz(N + 1);\n\tstor = {};\n\tstor.rsz(N + 1);\n\tsum = vl(N + 1);\n\tnum = vi(N + 1);\n\n\t// vi ans = solve1(R);\n\tvi ans = solve2(R);\n\t// ps(eval(R, ans));\n\t// if (!gen) {\n\tps(sz(ans));\n\tps(ans);\n\t// } else {\n\t// \tif (eval(R, ans) != eval(R, ans2)) {\n\t// \t\tdbg(\"WHOOPS\", tc, N, R, K, W, adj);\n\t// \t\tdbg(ans, eval(R, ans));\n\t// \t\tdbg(ans2, eval(R, ans2));\n\t// \t\tFOR(i, 1, N + 1) dbg(i, dp[i]);\n\t// \t\texit(0);\n\t// \t}\n\t// }\n}\n\nint main() {\n\tsetIO();\n\t// RangeInfo r1{{1, Frac{2, 5}}, {2, Frac{2, 7}}};\n\t// RangeInfo r2{{3, Frac{2, 6}}, {4, Frac{2, 3}}};\n\t// auto r3 = r1 + r2;\n\t// dbg(r3.d0.f, r3.d1.f);\n\t// exit(0);\n\n\t// RangeInfo{{x, Frac{w, 1}}, {INT_MAX, {}}}\n\t// ps(Frac{1, 2} < Frac{2, 4});\n\t// ps(Frac{2, 4} < Frac{1, 2});\n\t// ps(Frac{1, 2} < Frac{2, 3});\n\t// exit(0);\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i, false);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Doremy s Average Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/121813",
    "editorial": "Let be the array with the smallest lexicographical order if you do at\r\nmost operations in the subtree of (only consisting of the elements in\r\nthe subtree of ). Let be the first position where is different from . To\r\nget the answer, we just need to calculate which gives us enough\r\ninformation to compare the lexicographical order between two choice. At\r\nthe same time we need to record the first number of (let the number be )\r\nand its label, and the first number in such that it is different from\r\nand its label, which gives us enough information to decide whether to do\r\nan operation on . The time complexity is .\r\n",
    "hint": []
}