{
    "link": "https://codeforces.com//contest/269/problem/C",
    "problemId": "2579",
    "problem_idx": "C",
    "shortId": "269C",
    "contest_number": "269",
    "problem_submissions": {
        "D": [
            3053877,
            3055065,
            3054931,
            3054689,
            3056716,
            3055520,
            3053752,
            3054402,
            3055502,
            3054293,
            3057110,
            3057596,
            3056040,
            3056997,
            3057208,
            3053865,
            3055067,
            3057592
        ],
        "C": [
            3050826,
            3048752,
            3050407,
            3050153,
            3051253,
            3053071,
            3055637,
            3051073,
            3052131,
            3049037,
            3051392,
            3054561,
            3051427,
            3053470,
            3051843,
            3058738,
            3051490
        ],
        "B": [
            3048348,
            3051384,
            3045845,
            3048240,
            3048947,
            3047226,
            3049184,
            3049029,
            3049342,
            3056628,
            3048885,
            3048750,
            3050057,
            3054096,
            3048888,
            3049991,
            3050429
        ],
        "A": [
            3047341,
            3050569,
            3047430,
            3046474,
            3046278,
            3047911,
            3047245,
            3055271,
            3046848,
            3055425,
            3047549,
            3047676,
            3051951,
            3048080,
            3058340,
            3045802,
            3047292,
            3046740
        ]
    },
    "name": "C. Flawed Flow",
    "statement": "Emuskald considers himself a master of flow algorithms. Now he has\r\ncompleted his most ingenious program yet it calculates the maximum flow\r\nin an undirected graph. The graph consists of vertices and edges.\r\nVertices are numbered from 1 to . Vertices and being the source and the\r\nsink respectively.However, his max-flow algorithm seems to have a little\r\nflaw it only finds the flow volume for each edge, but not its direction.\r\nHelp him find for each edge the direction of the flow through this\r\nedges. Note, that the resulting flow should be correct maximum flow.More\r\nformally. You are given an undirected graph. For each itâ€™s undirected\r\nedge (, ) you are given the flow volume . You should direct all edges in\r\nsuch way that the following conditions hold: for each vertex , sum of of\r\nincoming edges is equal to the sum of of outcoming edges; vertex with\r\nnumber has no incoming edges; the obtained directed graph .\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\nusing namespace std;\n\n#define TASKNAME \"C\"\n\ntypedef long long ll;\ntypedef long double ld;\n\nvector<int> g[210000];\nvector<int> w[210000];\nvector<int> id[210000];\nint n,m;\n\nint in[210000];\nint ans[210000];\nset<pair<int,int> > s;\n\nint main(){\n  #ifdef LOCAL\n    freopen(TASKNAME\".in\",\"r\",stdin);\n    freopen(TASKNAME\".out\",\"w\",stdout);\n  #endif\n    scanf(\"%d %d\",&n,&m);\n    for (int i = 0; i < m; i++){\n        int a,b,c;\n        scanf(\"%d %d %d\",&a,&b,&c);\n        --a,--b;\n        in[a] += c;\n        in[b] += c;\n        g[a].pb(b);\n        g[b].pb(a);\n        w[a].pb(c);\n        w[b].pb(c);\n        id[a].pb(i+1);\n        id[b].pb(-i-1);\n    }\n\n    in[0] = 0;\n    in[n-1] = 2100000000;\n\n    memset(ans,-1,sizeof(ans));\n\n    for (int i = 0; i < n; i++){\n        assert(in[i] % 2 == 0);\n        s.insert(mp(in[i]/=2,i));\n    }\n\n    while (s.size() != 1){\n//      cerr << in[0] <<\" \"<<in[1] << \" \"<<in[2] << endl;\n        assert(s.begin()->first == 0);\n        int v = s.begin()->second;\n        s.erase(s.begin());\n        for (int i = 0; i< (int)g[v].size(); i++){\n            if (ans[abs(id[v][i])-1] == -1){\n                if (id[v][i] < 0)\n                    ans[abs(id[v][i])-1] = 1;\n                else\n                    ans[abs(id[v][i])-1] = 0;\n                s.erase(mp(in[g[v][i]],g[v][i]));\n                in[g[v][i]] -= w[v][i];\n                s.insert(mp(in[g[v][i]],g[v][i]));\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++)\n        printf(\"%d\\n\",ans[i]);\n        \n\n      \n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "flows",
        "graphs",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Flawed Flow.json",
    "editorial_link": "https://codeforces.com//blog/entry/6596",
    "editorial": "The key element to solving the task is the following observation: if we know all the incoming edges of a vertex, all the remaining edges must be outgoing. The source has no incoming edges, so we already know that all its edges are outgoing. For all other vertices except the sink the amount of incoming and outcoming flow is the same, and is equal to half of the sum of the flow along its incident edges. The algorithm then is to repeatedly direct all the flow from the vertices for which all the incoming edges are known. This can be done with a single BFS: As the flow contains no cycles, we can sort the vertices topologically. Then we can be sure that, until all edge directions are known, we can put at least the first vertex with unknown edges in the queue, as all of its incoming edges will be from vertices with lower indices, but we took the first vertex with unknown edges.",
    "hint": []
}