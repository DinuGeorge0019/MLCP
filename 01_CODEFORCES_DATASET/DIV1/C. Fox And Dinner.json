{
    "link": "https://codeforces.com//contest/512/problem/C",
    "problemId": "21644",
    "problem_idx": "C",
    "shortId": "512C",
    "contest_number": "512",
    "problem_submissions": {
        "E": [
            9689055,
            9689637,
            9689329,
            9688006,
            9687653,
            9689489,
            9689150,
            9686860,
            9690989,
            9687876
        ],
        "D": [
            9687125,
            9687387,
            9685060,
            9686450,
            9688310,
            9687526,
            9848172,
            9687098,
            9689725
        ],
        "C": [
            9684294,
            9683675,
            9686457,
            9682885,
            9681860,
            9683241,
            9686129,
            9685822,
            9688905,
            9683891,
            9686124,
            9685967,
            9682813,
            9687765,
            9684696,
            9686605,
            9690364,
            9690022
        ],
        "B": [
            9681311,
            9680720,
            9682911,
            9680295,
            9679957,
            9680851,
            9679895,
            9681573,
            9681772,
            9685086,
            9682711,
            9681029,
            9681643,
            9680950,
            9691594,
            9680058
        ],
        "A": [
            9679078,
            9679241,
            9683617,
            9678600,
            9678498,
            9679465,
            9682231,
            9681794,
            9679166,
            9679612,
            9683011,
            9689408,
            9679816,
            9678578,
            9678585,
            9679972,
            9678357
        ]
    },
    "name": "C. Fox And Dinner",
    "statement": "Fox Ciel is participating in a party in Prime Kingdom. There are foxes\r\nthere (include Fox Ciel). The i-th fox is years old.They will have\r\ndinner around some round tables. You want to distribute foxes such that:\r\nEach fox is sitting at some table. Each table has at least 3 foxes\r\nsitting around it. The sum of ages of any two adjacent foxes around each\r\ntable should be a prime number. If foxes , , ..., are sitting around\r\ntable in clockwise order, then for : and are adjacent, and and are also\r\nadjacent.If it is possible to distribute the foxes in the desired\r\nmanner, find out a way to do that.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct TEdge {\n    int from, to;\n    int c, w;\n\n    TEdge(int from = 0, int to = 0, int c = 0)\n        : from(from)\n        , to(to)\n        , c(c)\n        , w(0)\n    {\n    }\n};\n\nconst int MAXN = 300;\nvector<TEdge> edges;\nvi e[MAXN];\nint vis[MAXN];\n\nvoid addEdge(int from, int to, int c) {\n    e[from].pb(edges.size());\n    edges.pb(TEdge(from, to, c));\n    e[to].pb(edges.size());\n    edges.pb(TEdge(to, from, 0));\n}\n\nbool dfs(int v, int t) {\n    if (v == t) return true;\n    if (vis[v]) return false;\n    vis[v] = 1;\n    forn(i, e[v].size()) {\n        TEdge w = edges[e[v][i]];\n        if (w.w >= w.c) continue;\n        if (dfs(w.to, t)) {\n            ++edges[e[v][i]].w;\n            --edges[e[v][i] ^ 1].w;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool isPrime(int x) {\n    for (int i = 2; i * i <= x; ++i) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nvi g[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vi a(N);\n    forn(i, N) cin >> a[i];\n    forn(i, N) {\n        if (a[i] % 2 == 0) addEdge(N, i, 2);\n        else addEdge(i, N + 1, 2);\n    }\n    forn(i, N) forn(j, i) {\n        if (!isPrime(a[i] + a[j])) continue;\n        if (a[i] % 2 == 0) addEdge(i, j, 1);\n        else addEdge(j, i, 1);\n    }\n    forn(i, N) {\n        forn(j, MAXN) vis[j] = 0;\n        if (!dfs(N, N + 1)) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n    forn(i, edges.size()) {\n        int x = edges[i].from, y = edges[i].to;\n        if (x < N && y < N && edges[i].w > 0) {\n            g[x].pb(y);\n            g[y].pb(x);\n        }\n    }\n\n    vvi ans;\n    forn(i, N) vis[i] = 0;\n    forn(i, N) {\n        if (vis[i]) continue;\n        int j = g[i][0], p = i;\n        vi res;\n        res.pb(i);\n        vis[i] = 1;\n        while (j != i) {\n            vis[j] = 1;\n            res.pb(j);\n            int t = 0;\n            while (g[j][t] == p) ++t;\n            p = j;\n            j = g[j][t];\n        }\n        ans.pb(res);\n    }\n    cout << ans.size() << '\\n';\n    forn(i, ans.size()) {\n        cout << ans[i].size();\n        for (int x: ans[i]) cout << ' ' << x + 1;\n        cout << '\\n';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graph matchings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Fox And Dinner.json",
    "editorial_link": "https://codeforces.com/blog/entry/16173",
    "editorial": "First finding is: if is a prime, then one of them is an odd number,\r\nanother is an even number. (that\u00e2\u0080\u0099s why we set ) Then we could find:\r\nevery odd number have exactly 2 even number as neighborhood, and every\r\neven number have exactly 2 odd number as neighborhood. And that means we\r\nneed to have a solution. So it looks like bipartite graph matching, but\r\nevery element matched 2 elements. And in fact it can be handled by\r\nmaxflow: For each odd number, we add a node on the left side and link it\r\nfrom source with capacity equals to 2, and for each even number, we add\r\na node on the right side and link it to sink with capacity equals to 2.\r\nAnd if sum of two numbers is a prime number, we link them with capacity\r\nequals to 1. Then we solve the max flow, it have solution if and only if\r\n. We can construct the answer(cycles) from the matches. Note: Actually\r\nthis task is still solvable if we allow . But you need some clever way\r\nto deal with it. We think it is too hard so we removed this case. What\r\ndo you think about this decision?\r\n"
}