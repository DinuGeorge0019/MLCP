{"link": "https://codeforces.com//contest/83/problem/C", "problemId": "444", "problem_idx": "C", "shortId": "83C", "contest_number": "83", "problem_submissions": {"E": [451947, 450977, 459818, 465914], "D": [449763, 448488, 452955, 452808, 452804, 448288, 449164, 450962, 452221, 451606, 451773, 451891, 450141, 449774, 449599, 450292, 449258, 450035, 450619], "C": [448521, 455889, 451494, 451794, 449865, 450165, 450276, 450602, 449657, 452977, 452829, 452759], "B": [447440, 452573, 449754, 447625, 448201, 447469, 450579, 448308, 447785, 447475, 447853, 448099, 447816, 448223, 447713, 447775], "A": [446362, 452366, 446401, 446361, 446485, 446374, 446375, 446560, 446585, 446384, 446420, 446524, 446437, 447399, 446502, 446789]}, "name": "C. Track", "statement": "You already know that Valery\u2019s favorite sport is biathlon. Due to your\r\nhelp, he learned to shoot without missing, and his skills are unmatched\r\nat the shooting range. But now a smaller task is to be performed, he\r\nshould learn to complete the path fastest.The track\u2019s map is represented\r\nby a rectangle in size divided into squares. Each square is marked with\r\na lowercase Latin letter (which means the type of the plot), with the\r\nexception of the starting square (it is marked with a capital Latin\r\nletters ) and the terminating square (it is marked with a capital Latin\r\nletter ). The time of movement from one square to another is equal to\r\nminute. The time of movement within the cell can be neglected. We can\r\nmove from the cell only to side-adjacent ones, but it is forbidden to go\r\nbeyond the map edges. Also the following restriction is imposed on the\r\npath: it is not allowed to visit more than of squares (squares of one\r\ntype can be visited an infinite number of times). Squares marked with\r\nand have no type, so they are not counted. But must be visited exactly\r\nonce at the very beginning, and must be visited exactly once at the very\r\nend.Your task is to find the path from the square to the square that\r\ntakes minimum time. Among all shortest paths you should choose the one.\r\nWhen comparing paths you should lexicographically represent them as a\r\nsequence of characters, that is, of plot types.\r\n", "solutions": ["#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n, m, k;\nchar a[50][50];\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\nbool u[256];\nint d[50][50];\npii q[2500];\n\nstring bfs () {\n\tseta (d, 255);\n\tpii S, T;\n\tforn (i, n)\n\t\tforn (j, m) {\n\t\t\tif (a[i][j] == 'S')\n\t\t\t\tS = mp (i, j);\n\t\t\tif (a[i][j] == 'T')\n\t\t\t\tT = mp (i, j);\n\t\t}\n\td[T.fs][T.sc] = 0;\n\tint h, t;\n\th = t = 0;\n\tq[h] = T;\n\twhile (h <= t) {\n\t\tpii v = q[h];\n\t\th ++;\n\t\tforn (i, 4) {\n\t\t\tpii w = mp (v.fs + dx[i], v.sc + dy[i]);\n\t\t\tif (0 <= w.fs && w.fs < n && 0 <= w.sc && w.sc < m && d[w.fs][w.sc] == -1 && u[a[w.fs][w.sc]]) {\n\t\t\t\td[w.fs][w.sc] = d[v.fs][v.sc] + 1;\n\t\t\t\tt ++;\n\t\t\t\tq[t] = w;\n\t\t\t}\n\t\t}\n\t}\n\tif (d[S.fs][S.sc] == -1)\n\t\treturn \"S\";\n\tstring res = \"\";\n\tvector <pii> V, W;\n\tV.pb (S);\n\tint cd = d[S.fs][S.sc];\n\twhile (cd > 1) {\n\t\tchar c = 'z';\n\t\tforn (i, V.size())\n\t\t\tforn (j, 4) {\n\t\t\t\tpii w = mp (V[i].fs + dx[j], V[i].sc + dy[j]);\n\t\t\t\tif (0 <= w.fs && w.fs < n && 0 <= w.sc && w.sc < m && cd - 1 == d[w.fs][w.sc])\n\t\t\t\t\tc = min (c, a[w.fs][w.sc]);\n\t\t\t}\n\t\tres += c;\n\t\tW.clear ();\n\t\tforn (i, V.size())\n\t\t\tforn (j, 4) {\n\t\t\t\tpii w = mp (V[i].fs + dx[j], V[i].sc + dy[j]);\n\t\t\t\tif (0 <= w.fs && w.fs < n && 0 <= w.sc && w.sc < m && cd - 1 == d[w.fs][w.sc] && a[w.fs][w.sc] == c)\n\t\t\t\t\tW.pb (w);\n\t\t\t}\n\t\tsort (all (W));\n\t\tW.resize (unique (all (W)) - W.begin());\n\t\tcd --;\n\t\tV = W;\n\t\tW.clear ();\n\t}\n\treturn res;\n}\n\nstring res;\n\nvoid calc (int cur, int la) {\n\tif (cur == 26) {\n\t\tstring tmp = bfs ();\n\t\tif (tmp == \"S\")\n\t\t\treturn;\n\t\tif (res == \"S\")\n\t\t\tres = tmp;\n\t\telse\n\t\tif (res.length() > tmp.length() || (res.length() == tmp.length() && res > tmp))\n\t\t\tres = tmp;\n\t\treturn;\n\t}\n\tcalc (cur+1, la);\n\tif (la == 0)\n\t\treturn;\n\tu[cur+'a'] = 1;\n\tcalc (cur+1, la-1);\n\tu[cur+'a'] = 0;\n}\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tcin >> n >> m >> k;\n\tforn (i, n)\n\t\tforn (j, m)\n\t\t\tcin >> a[i][j];\n\tseta (u, 0);\n\tu['S'] = 1;\n\tu['T'] = 1;\n\tres = \"S\";\n\tcalc (0, k);\n\tif (res == \"S\")\n\t\tcout <<\t-1 << endl;\n\telse\n\t\tcout << res << endl;\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["graphs", "greedy", "shortest paths"], "dificulty": "2400", "interactive": false}