{
    "link": "https://codeforces.com//contest/1299/problem/D",
    "problemId": "536066",
    "problem_idx": "D",
    "shortId": "1299D",
    "contest_number": "1299",
    "problem_submissions": {
        "E": [
            70686331,
            70660774,
            70672529,
            70679200,
            70746311,
            70716482,
            70681811,
            70790234,
            70723071
        ],
        "D": [
            70674287,
            70655315,
            70663097,
            70655518,
            70663548,
            70664397,
            70662876,
            70665818,
            70662357,
            70666704,
            70668591,
            70669155,
            70686750,
            70667002,
            70665737,
            71199373,
            70666543,
            70669128,
            70668132,
            70673600,
            70668620
        ],
        "C": [
            70635644,
            70641348,
            70637841,
            70635684,
            70637585,
            70645672,
            70638367,
            70644518,
            70637825,
            70637282,
            70642089,
            70641136,
            70646842,
            70640536,
            71199306,
            70645534,
            70641268,
            70637543,
            70642972,
            70649159
        ],
        "B": [
            70632114,
            70637553,
            70635893,
            70632956,
            70633376,
            70640030,
            70635212,
            70636081,
            70641111,
            70643564,
            70635522,
            70636070,
            70638648,
            70636548,
            71199268,
            70634654,
            70643537,
            70631220,
            70636193,
            70643457
        ],
        "A": [
            70629120,
            70629188,
            70630935,
            70629077,
            70628970,
            70632328,
            70630392,
            70630475,
            70630208,
            70630228,
            70630097,
            70629324,
            70630825,
            70631100,
            71199221,
            70629815,
            70629724,
            70628897,
            70629666,
            70629786
        ]
    },
    "name": "D. Around the World",
    "statement": "You are given a simple weighted undirected connected graph with n\r\nvertexes and m edges with the following restriction: there isn\u2019t any\r\nsimple cycle (i. e. a cycle which doesn\u2019t pass through any vertex more\r\nthan once) of length greater than 3 which passes through the vertex 1.\r\nThe cost of a path (not necessarily simple) in this graph is defined as\r\nthe XOR of weights of all edges in that path with each edge being\r\ncounted as many times as the path passes through it. You may choose any\r\nsubset of edges incident to the vertex 1 and remove them. How many are\r\nthere such subsets, that, when removed, there is not any nontrivial\r\ncycle with the cost equal to 0 which passes through the vertex 1 in the\r\nresulting graph? A cycle is called if it passes through some edge odd\r\nnumber of times. As the answer can be very big, output it modulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\n#define bit(x) (1ll<<(x))\n\nconst int N=101000;\nbool vis[N],br[N];\nint val[N],wt[N];\nll ps,st[N];\nmap<pair<ll,ll>,ll> hs;\nvector<PII> e[N];\nint n,m,mm,a,b,w,mat[N],pe[N];\narray<int,3> p[N];\nVI pd;\nvoid add(ll &s,int x) {\n\tif (s==-1) return;\n\tif (s&bit(x)) s=-1;\n\tll t=s;\n\trep(i,0,32) if (s&bit(i)) t|=bit(i^x);\n\ts=t;\n}\n\nll merge(ll s,ll t) {\n\tif (s==-1||t==-1) return -1;\n\tif ((s&t)!=1) return -1;\n\tif (hs.count(mp(s,t))) return hs[mp(s,t)];\n\tll ns=0;\n\trep(i,0,32) if (s&bit(i)) rep(j,0,32) if (t&bit(j)) ns^=bit(i^j);\n\treturn hs[mp(s,t)]=ns;\n}\n\nset<PII> ue;\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (auto p:e[u]) {\n\t\tint v=p.fi;\n\t\tif (!vis[v]) {\n\t\t\tval[v]=val[u]^p.se;\n\t\t\tue.insert(mp(u,v));\n\t\t\tdfs(v);\n\t\t} else {\n\t\t\tif (!ue.count(mp(u,v))&&!ue.count(mp(v,u)))\n\t\t\t\tadd(ps,val[u]^val[v]^p.se);\n\t\t\tue.insert(mp(u,v));\n\t\t}\n\t}\n}\n\nvoid upd(int &a,int b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\n\nint mid[410][410],fst[N],dp[5][410],pp[5][410];\nll lab[410];\nmap<ll,int> gid;\n\nint main() {\n\n\tset<ll> pst;\n\tpst.insert(1);\n\trep(i,0,32) {\n\t\tset<ll> qst=pst;\n\t\tfor (auto x:qst) {\n\t\t\tll y=x;\n\t\t\tadd(y,i);\n\t\t\tpst.insert(y);\n\t\t}\n\t\t//printf(\"%d %d\\n\",i,SZ(pst));\n\t}\n\tfor (auto x:pst) {\n\t\tlab[m]=x;\n\t\tgid[x]=m;\n\t\t++m;\n\t}\n\trep(i,0,m) rep(j,0,m) {\n\t\tll z=merge(lab[i],lab[j]);\n\t\tassert(gid.count(z));\n\t\tmid[i][j]=gid[z];\n\t}\n\n\tscanf(\"%d%d\",&n,&mm);\n\trep(i,0,mm) {\n\t\tscanf(\"%d%d%d\",&a,&b,&w);\n\t\tif (a>b) swap(a,b);\n\t\tp[i]={a,b,w};\n\t\tif (a==1) br[b]=1,wt[b]=w;\n\t}\n\trep(i,0,mm) {\n\t\ta=p[i][0]; b=p[i][1]; w=p[i][2];\n\t\tif (a==1) continue;\n\t\tif (br[a]&&br[b]) {\n\t\t\tmat[a]=1; mat[b]=2;\n\t\t\tpe[b]=w^wt[a]^wt[b];\n\t\t\tpd.pb(a); pd.pb(b);\n\t\t} else {\n\t\t\te[a].pb(mp(b,w));\n\t\t\te[b].pb(mp(a,w));\n\t\t}\n\t}\n\trep(i,1,n+1) if (br[i]&&!mat[i]) {\n\t\tpd.pb(i);\n\t}\n\trep(i,0,SZ(pd)) {\n\t\tps=1;\n\t\tdfs(pd[i]);\n\t\tst[i]=ps;\n\t}\n\tdp[0][1]=1;\n\trep(i,0,SZ(pd)) {\n\t\tint u=pd[i];\n\t\tif (mat[u]==2) {\n\t\t\tst[i]=st[i-1]=merge(st[i],st[i-1]);\n\t\t}\n\t}\n\n//printf(\"%d\\n\",m);\n\trep(i,0,SZ(pd)) {\n\t\tfst[i]=gid[st[i]];\n\t//\tprintf(\"%d %d\\n\",i,fst[i]);\n\t}\n\n\tassert(gid[-1]==0);\n\tdp[0][gid[1]]=1;\n\trep(i,0,SZ(pd)) {\n\t\trep(j,0,2) rep(k,0,m) pp[j][k]=dp[j][k],dp[j][k]=0;\n\t\tint gd=gid[bit(0)|bit(pe[pd[i]])];\n\t\trep(j,0,2) rep(k,0,m) if (pp[j][k]) {\n\t\t\tint ck=k;\n\t\t\tif (mat[pd[i]]!=2||j==0) ck=mid[ck][fst[i]];\n\t\t\tint dk=ck;\n\t\t\tif (mat[pd[i]]==2) {\n\t\t\t\tif (pe[pd[i]]==0) dk=0; else dk=mid[dk][gd];\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\",k,fst[i],ck);\n\t\t\tll val=pp[j][k];\n\t\t\trep(w,0,2) {\n\t\t\t\tif (w==1&&j==1) upd(dp[w][dk],val);\n\t\t\t\telse if (w==1) upd(dp[w][ck],val);\n\t\t\t\telse upd(dp[w][k],val);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\trep(j,0,2) rep(k,1,m) upd(ans,dp[j][k]);\n\tprintf(\"%d\\n\",ans);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dfs and similar",
        "dp",
        "graphs",
        "graphs",
        "math",
        "trees"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Around the World.json",
    "editorial_link": "https://codeforces.com//blog/entry/73763",
    "editorial": "It\u00e2\u0080\u0099s common knowledge that in an undirected graph there is some subset\r\n(not necessarily unique) of simple cycles called such that any Eulerian\r\nsubgraph (in connected graphs also known as a cyclic path) is a\r\nxor-combination of exactly one subset of basis cycles. In a given\r\nconnected graph consider any spanning tree; any edge which isn\u00e2\u0080\u0099t in that\r\nspanning tree forms a cycle with some tree\u00e2\u0080\u0099s edges of some cost . These\r\ncycles form the basis. A cost of a cyclic path is an XOR of costs of\r\nbasis cycles that form this path. Now we can move from cycle space to\r\nthe space of -dimensional vectors . If the costs of basis cycles are\r\nlinear dependent, then there is a cycle of cost , else they form the\r\nbasis of some subspace of .In the given graph there are two types of\r\n\"components\" connected to , and after removing the edges each component\r\ncontributes some subspace (possibly an empty one); these subspaces\r\nshouldn\u00e2\u0080\u0099t intersect. These two types are components connected with an\r\nedge and components connected with two edges: In the first picture, the\r\nbasis cycles are formed by the blue edges. We can cut the edge incident\r\nto or keep it; if we don\u00e2\u0080\u0099t cut that edge, this component contributes a\r\nsubspace formed by costs of basis cycles unless they are linear\r\ndependent, else it contributes the empty subspace.In the second picture,\r\nthe basis cycles are formed by the blue edges and the red edge. We can\r\ncut both edges, and then this component contributes an empty subspace;\r\nif we cut one edge, the red edge moves to the spanning tree and no\r\nlonger form a basis cycle, so this component contributes a subspace\r\nformed by costs of basis cycles formed by blue edges; if we don\u00e2\u0080\u0099t cut\r\nany edges, then this component contributes a subspace formed by costs of\r\nbasis cycles formed by blue and red edges.If any choice leads to keeping\r\na set of linear dependent basis cycles\u00e2\u0080\u0099 costs, then this choice is\r\ninvalid.Now for every component, we have from to valid choices of\r\nchoosing the contributing subspace. There are subspaces of , which can\r\nbe precalculated as well as their sums. Now we can calculate a dp the\r\nnumber of ways to get the subspace using the first components. The\r\ntransitions are obvious: if we can get the subspace at the -th\r\ncomponent, then for each existing subspace , if and don\u00e2\u0080\u0099t intersect, do\r\n, where is the sum of subspaces. The answer is a sum of dp values for\r\nthe last component.\r\n"
}