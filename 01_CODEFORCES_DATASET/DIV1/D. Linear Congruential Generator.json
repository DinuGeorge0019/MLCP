{
    "link": "https://codeforces.com//contest/1053/problem/D",
    "problemId": "223967",
    "problem_idx": "D",
    "shortId": "1053D",
    "contest_number": "1053",
    "problem_submissions": {
        "D": [
            43320967,
            43321366,
            43322493,
            43325653,
            43328216,
            43329157,
            43314103,
            43329594,
            43327708,
            43331398,
            43331864,
            43331980,
            43333170,
            43320772,
            43321907,
            43347759,
            43334692,
            43316971,
            43343476,
            43341620,
            43339949,
            43337790
        ],
        "C": [
            43307138,
            43309894,
            43312505,
            43313721,
            43312808,
            43316109,
            43324397,
            43311885,
            43312845,
            43316905,
            43321077,
            43314278,
            43317163,
            43317332,
            43329507,
            43330889,
            43311412,
            43324598,
            43338761,
            46354235,
            44718358,
            43709718,
            43709703,
            43709682,
            43515057,
            43515052,
            43483892,
            43465752,
            43464250,
            43421524,
            43400433,
            43400425,
            43385421,
            43385407,
            43354392,
            43354373,
            43354256,
            43354129,
            43354084,
            43353946,
            43353875,
            43353862,
            43338127,
            43337856,
            43317491
        ],
        "B": [
            43302550,
            43398321,
            43398298,
            43302971,
            43303874,
            43305537,
            43304419,
            43304489,
            43303672,
            43303860,
            43307726,
            43304869,
            43306808,
            43305251,
            43304148,
            43307156,
            43307659,
            43324162,
            43300449,
            43315267,
            43326866,
            43338204,
            43337888,
            43307003
        ],
        "A": [
            43297754,
            43298564,
            43298952,
            43299495,
            43299534,
            43304596,
            43317168,
            43299723,
            43304344,
            43300713,
            43301168,
            43300378,
            43300680,
            43298079,
            43302518,
            43299165,
            43304630,
            43311156,
            43322106,
            43301598
        ],
        "E": [
            43366979,
            43333450,
            44387266,
            43369111
        ]
    },
    "name": "D. Linear Congruential Generator",
    "statement": "You are given a tuple generator f^{(k)} = (f_1^{(k)}, f_2^{(k)},\r\ndots, f_n^{(k)}), where f_i^{(k)} = (a_i\r\ncdot f_i^{(k - 1)} + b_i)\r\nbmod p_i and f^{(0)} = (x_1, x_2,\r\ndots, x_n). Here x\r\nbmod y denotes the remainder of x when divided by y. All p_i are\r\nprimes.One can see that with fixed sequences x_i, y_i, a_i the tuples\r\nf^{(k)} starting from some index will repeat tuples with smaller\r\nindices. Calculate the maximum number of different tuples (from all\r\nf^{(k)} for k\r\nge 0) that can be produced by this generator, if x_i, a_i, b_i are\r\nintegers in the range [0, p_i - 1] and can be chosen arbitrary. The\r\nanswer can be large, so print the remainder it gives when divided by\r\n10^9 + 7\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,p[SZ],mr[2000555];\nbool np[2000555];\n#define S 6000000\nint fy[2000555];\nint ny[S],yy[S],an,cm[2000555];\nconst int MOD=1e9+7;\nmap<int,int> sb;\nbool go(int g)\n{\n\tint su=0;\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]>=y)\n\t\t\tcontinue;\n\t\tsu=1; mr[yy[t]]=y;\n\t}\n\treturn su;\n}\nint mc[2000555];\nvoid AA(int g)\n{\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]==y) ++mc[yy[t]];\n\t}\n}\nbool BB(int g)\n{\n\tbool must=0;\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]==y) must|=mc[yy[t]]==1;\n\t}\n\treturn must;\n}\nll zy[SZ]; int zn=0;\nint main()\n{\n\tfor(int i=2;i<=2000000;++i) if(!np[i])\n\t\tfor(int j=i;j<=2000000;j+=i)\n\t\t\t++an,yy[an]=i,ny[an]=fy[j],\n\t\t\tfy[j]=an,np[j]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",p+i),++sb[-p[i]];\n\tint aa=0;\n\tfor(auto g:sb)\n\t{\n\t\tif(g.se<2) continue;\n\t\tint w=-g.fi;\n\t\tif(!go(w)) aa=1;\n\t\telse zy[++zn]=w;\n\t\tfor(int j=1;j<g.se;++j)\n\t\t\tif(!go(w-1)) aa=1;\n\t\t\telse zy[++zn]=w-1;\n\t}\n\tfor(auto g:sb)\n\t{\n\t\tif(g.se!=1) continue;\n\t\tint w=-g.fi;\n\t\tif(go(w)) zy[++zn]=w;\n\t\telse if(go(w-1)) zy[++zn]=w-1;\n\t\telse aa=1;\n\t}\n\tfor(int i=1;i<=zn;++i)\n\t\tAA(zy[i]);\n\tfor(int i=1;i<=zn;++i)\n\t\tif(!BB(zy[i])) aa=1;\n\tll ans=1;\n\tfor(int i=1;i<=2000000;++i)\n\t\twhile(mr[i]--) ans=ans*i%MOD;\n\tans+=aa;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Linear Congruential Generator.json",
    "editorial_link": "https://codeforces.com//blog/entry/62013",
    "editorial": "Each generator f(k)i\n can be represented as functional graph so the number of different values equal to the legth of the cycle c\n plus the length of pre-period pp\n. Generalizing on tuples leads to next observation: number of different tuples equals to maxi=1..n(ppi)+lcmi=1..n(ci)\n.\n\n\u0097\u0097\u0097\u0097 Some proof \u0097\u0097\u0097\u0097\nLet's take a look at some generator fi\n to find out its possible ci\n and ppi\n. If ai=0\n then fi=xi,bi,bi,bi,\u0085\n. the ci=1\n and ppi=0\n or ppi=1\n. If ai=1\n then f(k)i=(xi+(k?1)bi)modpi\n. Since pi\n is a prime then ci=1\n or ci=pi\n and ppi=0\n.\n\nIf ai>1\n then exists a?1i\n and (ai?1)?1\n, thus ppi=0\n. Since there is not pre-period we need to find minimal positive k\n such that\nxi?akixi+bi?j=0k?1aji?xi?akixi+bi(aki?1)?(ai?1)?1?(aki?1)xi+bi(aki?1)?(ai?1)?1?0?(aki?1)(xi+bi?(ai?1)?1)?0modpi.\n\nSince pi\n is a prime if a?b?0\n then a?0\n or b?0\n. So if (xi+bi?(ai?1)?1)?0\n and since it doesn't depend on k\n then k=1\n, so ci=1\n and ppi=0\n. Otherwise, (aki?1)?0\n and by Lagrange's theorem k?(pi?1)\n. Finally, since pi\n is a prime there exist ai\n such that k=pi?1\n.\n\n\u0097\u0097\u0097\u0097 End of some proof \u0097\u0097\u0097\u0097\nAt the end we can understand that only three cases are matter: (ci=1,ppi=1)\n, (ci=pi,ppi=0)\n and (ci=pi?1,ppi=0)\n.\n\nHere some greedy ideas works: it always optimal try at first (pi,0)\n, then (pi?1,0)\n and only then (1,1)\n; we can process elements in the descending order. But there is one problem: since we maximaize maxi=1..n(ppi)+lcmi=1..n(ci)\n then there are cases, where we can make maxi=1..n(ppi)=1\n without lowering lcmi=1..n(ci)\n. Here comes two approaches:\n\nThe first solution (hard to prove correctness, the proven complexity):\n\nLet's add to some structure pi\n in non ascending order: let's maintain lcm\n as pairs: maximal power of prime aj\n and number of maximums cntj\n for each prime number up to 2?106\n .\n\nFor each pi\n we will try to add it as pi\n to the lcm\n. If this structure already have pi\n then we will add it as pi?1\n, so we need factorization of pi?1\n.\n\nAfter that we will iterate over all pi\n again and check \"can we remove it from structure without decreasing lcm\n\". We will check it in the next way: for index i\n just check for each prime divisor pdj\n of pi?1\n if it was added as pi?1\n (or of pi\n if it was added as pi\n) is it true that (apdj\n > power of pdj\n) or (apdj\n = power of pdj\n and cntpdj>1\n).\n\nIf we can remove some index i\n so we can make max(ppi)=1\n \u0097 profit. Otherwise, it's impossible to get max(ppi)=1\n. Here should be proof of correctness, but it is quite complicated (but I proved this solution to KAN and he agreed (hm, notorious coincidence)).\n\nAt the end, we need factorization of all numbers up to 2?106\n it can be done with Sieve of Eratosthenes if we will remember minimal divisor for each number. So, the result complexity is O((n+MAX)log(n))\n.\n\nThe second solution (the proven correctness, hard to prove the complexity):\n\nLet's maintain same structure for lcm\n but with some modification: we don't need cntj\n but for each prime we will have a flag markj\n \u0097 does this prime is occupied by pi\n from the input. Now, let's get to know a way to add arbitrary prime pi\n from the input to this structure. Name this function as insert(v)\n. If the structure doesn't have v\n \u0097 just add it (recalc av\n and markv\n flag). Otherwise, we'll move to v?1\n and for each prime divisor pdk\n of v?1\n we'll try to update pdk\n in the structure \u0097 final trick is next: if we update pdk\n which have markpdk\n we will unmark it call a insert(pdk)\n recursively.\n\nNow we can insert some pi\n. We will at first find maximum aj\n for each prime. Then we will make n\n quieries \u0097 calculate lcm\n without pi\n. This queries can be processed with dynamic connectivity. Final question is to evaluate number of operation done by insert(v)\n. We can limit it with number of prime divisors of all different primes we can reach from each v\n up to 2?106\n. It was less than D=30\n."
}