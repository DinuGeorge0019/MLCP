{"link": "https://codeforces.com//contest/1053/problem/D", "problemId": "223967", "problem_idx": "D", "shortId": "1053D", "contest_number": "1053", "problem_submissions": {"D": [43320967, 43321366, 43322493, 43325653, 43328216, 43329157, 43314103, 43329594, 43327708, 43331398, 43331864, 43331980, 43333170, 43320772, 43321907, 43347759, 43334692, 43316971, 43343476, 43341620, 43339949, 43337790], "C": [43307138, 43309894, 43312505, 43313721, 43312808, 43316109, 43324397, 43311885, 43312845, 43316905, 43321077, 43314278, 43317163, 43317332, 43329507, 43330889, 43311412, 43324598, 43338761, 46354235, 44718358, 43709718, 43709703, 43709682, 43515057, 43515052, 43483892, 43465752, 43464250, 43421524, 43400433, 43400425, 43385421, 43385407, 43354392, 43354373, 43354256, 43354129, 43354084, 43353946, 43353875, 43353862, 43338127, 43337856, 43317491], "B": [43302550, 43398321, 43398298, 43302971, 43303874, 43305537, 43304419, 43304489, 43303672, 43303860, 43307726, 43304869, 43306808, 43305251, 43304148, 43307156, 43307659, 43324162, 43300449, 43315267, 43326866, 43338204, 43337888, 43307003], "A": [43297754, 43298564, 43298952, 43299495, 43299534, 43304596, 43317168, 43299723, 43304344, 43300713, 43301168, 43300378, 43300680, 43298079, 43302518, 43299165, 43304630, 43311156, 43322106, 43301598], "E": [43366979, 43333450, 44387266, 43369111]}, "name": "D. Linear Congruential Generator", "statement": "You are given a tuple generator f^{(k)} = (f_1^{(k)}, f_2^{(k)},\r\ndots, f_n^{(k)}), where f_i^{(k)} = (a_i\r\ncdot f_i^{(k - 1)} + b_i)\r\nbmod p_i and f^{(0)} = (x_1, x_2,\r\ndots, x_n). Here x\r\nbmod y denotes the remainder of x when divided by y. All p_i are\r\nprimes.One can see that with fixed sequences x_i, y_i, a_i the tuples\r\nf^{(k)} starting from some index will repeat tuples with smaller\r\nindices. Calculate the maximum number of different tuples (from all\r\nf^{(k)} for k\r\nge 0) that can be produced by this generator, if x_i, a_i, b_i are\r\nintegers in the range [0, p_i - 1] and can be chosen arbitrary. The\r\nanswer can be large, so print the remainder it gives when divided by\r\n10^9 + 7\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,p[SZ],mr[2000555];\nbool np[2000555];\n#define S 6000000\nint fy[2000555];\nint ny[S],yy[S],an,cm[2000555];\nconst int MOD=1e9+7;\nmap<int,int> sb;\nbool go(int g)\n{\n\tint su=0;\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]>=y)\n\t\t\tcontinue;\n\t\tsu=1; mr[yy[t]]=y;\n\t}\n\treturn su;\n}\nint mc[2000555];\nvoid AA(int g)\n{\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]==y) ++mc[yy[t]];\n\t}\n}\nbool BB(int g)\n{\n\tbool must=0;\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]==y) must|=mc[yy[t]]==1;\n\t}\n\treturn must;\n}\nll zy[SZ]; int zn=0;\nint main()\n{\n\tfor(int i=2;i<=2000000;++i) if(!np[i])\n\t\tfor(int j=i;j<=2000000;j+=i)\n\t\t\t++an,yy[an]=i,ny[an]=fy[j],\n\t\t\tfy[j]=an,np[j]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",p+i),++sb[-p[i]];\n\tint aa=0;\n\tfor(auto g:sb)\n\t{\n\t\tif(g.se<2) continue;\n\t\tint w=-g.fi;\n\t\tif(!go(w)) aa=1;\n\t\telse zy[++zn]=w;\n\t\tfor(int j=1;j<g.se;++j)\n\t\t\tif(!go(w-1)) aa=1;\n\t\t\telse zy[++zn]=w-1;\n\t}\n\tfor(auto g:sb)\n\t{\n\t\tif(g.se!=1) continue;\n\t\tint w=-g.fi;\n\t\tif(go(w)) zy[++zn]=w;\n\t\telse if(go(w-1)) zy[++zn]=w-1;\n\t\telse aa=1;\n\t}\n\tfor(int i=1;i<=zn;++i)\n\t\tAA(zy[i]);\n\tfor(int i=1;i<=zn;++i)\n\t\tif(!BB(zy[i])) aa=1;\n\tll ans=1;\n\tfor(int i=1;i<=2000000;++i)\n\t\twhile(mr[i]--) ans=ans*i%MOD;\n\tans+=aa;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "number theory"], "dificulty": "2900", "interactive": false}