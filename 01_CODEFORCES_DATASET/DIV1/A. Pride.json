{
    "link": "https://codeforces.com//contest/891/problem/A",
    "problemId": "134540",
    "problem_idx": "A",
    "shortId": "891A",
    "contest_number": "891",
    "problem_submissions": {
        "D": [
            32405811,
            32403732,
            32402138,
            32430714,
            32405646
        ],
        "B": [
            32397173,
            32384884,
            32383268,
            32389067,
            32402095,
            32392144,
            32390145,
            32392706,
            32386797,
            32391950,
            32394619,
            32391275,
            32387784,
            32402908,
            32394168,
            32390852,
            32393424,
            32402498,
            32390071,
            32396268
        ],
        "C": [
            32396218,
            32388086,
            32389360,
            32395431,
            32392168,
            32396723,
            32397239,
            32390965,
            32393675,
            32398647,
            32398521,
            32396975,
            32390007,
            32404522,
            32396953,
            32387277,
            32386884,
            32403069
        ],
        "A": [
            32391368,
            32389450,
            32385263,
            32382597,
            32388551,
            32393309,
            32385252,
            32391318,
            32384125,
            32393321,
            32386822,
            32382673,
            32385160,
            32385074,
            32382459,
            32389480,
            32400282,
            32382452,
            32383065
        ],
        "E": [
            32389900,
            32397841,
            32401538,
            32399718,
            32400691,
            32399515,
            32401892,
            32401660,
            32405427,
            32400764,
            32394075,
            32405328,
            32405995,
            32402118,
            32511522,
            32397327
        ]
    },
    "name": "A. Pride",
    "statement": "You have an array with length , you can perform operations. Each\r\noperation is like this: choose two elements from , say and , and replace\r\none of them with , where denotes the greatest common divisor.What is the\r\nminimum number of operations you need to make all of the elements equal\r\nto ?\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=2010;\nint n,a[N];\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i);\n\tbool hav1=0;\n\trep(i,1,n+1) if (a[i]==1) hav1=1;\n\tif (hav1) {\n\t\tint cnt=0;\n\t\trep(i,1,n+1) if (a[i]!=1) cnt++;\n\t\tprintf(\"%d\\n\",cnt);\n\t\treturn 0;\n\t}\n\tint len=n+1;\n\trep(i,1,n+1) {\n\t\tint d=a[i];\n\t\trep(j,i,n+1) {\n\t\t\td=gcd(d,a[j]);\n\t\t\tif (d==1) len=min(len,j-i+1);\n\t\t}\n\t}\n\tif (len>n) puts(\"-1\"); else printf(\"%d\\n\",len-1+n-1);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Pride.json",
    "editorial_link": "https://codeforces.com//blog/entry/55841",
    "editorial": "Consider cnt1 as number of 1s in the a.\n\nIf 0?<?cnt1 then the answer is n?-?cnt1.\n\notherwise We should find a segment with its gcd equal to 1 and minimum length.\n\nconsider a segment as (L,?R) which L???R and it's gcd as D(L,?R)\n\nWe fix L and then iterate through all R in order. Consider we know that D(L,?R)?=?G then D(L,?R?+?1)?=?gcd(G,?A(R?+?1)).\n\nIf D(L,?R)?=?1 then you can make all the elements in (R?-?L?+?1)?+?(n?-?1).\n\nAnswer is minimum possible D(L,?R) over all possible segments."
}