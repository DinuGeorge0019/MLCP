{"link": "https://codeforces.com//contest/1548/problem/A", "problemId": "1062382", "problem_idx": "A", "shortId": "1548A", "contest_number": "1548", "problem_submissions": {"D2": [124590154, 124570151, 124631052, 124579457, 124595552, 124599986, 124598663, 124601582, 124596908, 124589080, 124589208, 124632567, 124602573], "E": [124581595, 124597899, 124590654, 124596843, 124594126, 124591964, 124592242, 124592323, 124856732, 124577426, 124619322, 124665492], "D1": [124546605, 124538296, 124561771, 124569958, 124572244, 124572070, 124558486, 124552145, 124565483, 124565312, 124554771, 124568265, 124563802, 124595327, 124572767, 124574319, 124573078, 124560440, 124570173, 124568828], "C": [124538722, 124546717, 124543126, 124552919, 124545964, 124599486, 124550051, 124554662, 124555634, 124559563, 124538097, 124558973, 124554365, 124565653, 124542584, 124561525, 124550009], "B": [124529066, 124526158, 124527209, 124533998, 124528094, 124540501, 124535175, 124539779, 124535743, 124537844, 124538815, 124529079, 124550340, 124533987, 124531668, 124543431, 124533588, 124530735, 124554398, 124534276], "A": [124521888, 124519192, 124532449, 124525950, 124521506, 124523964, 124524094, 124520315, 124522449, 124524250, 124550070, 124520590, 124556679, 124524509, 124523057, 124525430, 124522685, 124522322, 124531504, 124524318]}, "name": "A. Web of Lies", "statement": "Cersei Lannister, by George R. R. MartinThere are n nobles, numbered\r\nfrom 1 to n. Noble i has a power of i. There are also m \"friendships\". A\r\nfriendship between nobles a and b is always mutual.A noble is defined to\r\nbe if both of the following conditions are satisfied: the noble has at\r\nleast one friend, and of that noble\u2019s friends have a higher power. You\r\nwill have to process the following three types of queries. Add a\r\nfriendship between nobles u and v. Remove a friendship between nobles u\r\nand v. Calculate the answer to the following process. The process: all\r\nvulnerable nobles are simultaneously killed, and all their friendships\r\nend. Then, it is possible that new nobles become vulnerable. The process\r\nrepeats itself until no nobles are vulnerable. It can be proven that the\r\nprocess will end in finite time. After the process is complete, you need\r\nto calculate the number of remaining nobles.Note that the results of the\r\nprocess are carried over between queries, that is, every process starts\r\nwith all nobles being alive!\r\n", "solutions": ["//\u522b\u4e22\u5305\u4e86\uff01\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nset<int> r[maxn];\nint ans = 0;\nbool chk(int a) {\n    if (r[a].empty()) return 1;\n    if (*r[a].rbegin() <= a) return 1;\n    return 0;\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        r[u].insert(v), r[v].insert(u);\n    }\n    int q;\n    cin >> q;\n    int ans = 0;\n    for (int i = 1; i <= n; i++) ans += chk(i);\n    for (int i = 1; i <= q; i++) {\n        int t, u, v;\n        scanf(\"%d\", &t);\n        if (t == 3) printf(\"%d\\n\", ans);\n        else {\n            scanf(\"%d%d\", &u, &v);\n            ans -= chk(u), ans -= chk(v);\n            if (t == 1) r[u].insert(v), r[v].insert(u);\n            else r[u].erase(v), r[v].erase(u);\n            ans += chk(u), ans += chk(v);\n        }\n    }\n    return (0-0); //<3\n}"], "input": "", "output": "", "tags": ["brute force", "graphs", "greedy"], "dificulty": "1400", "interactive": false}