{
    "link": "https://codeforces.com//contest/1548/problem/E",
    "problemId": "1062387",
    "problem_idx": "E",
    "shortId": "1548E",
    "contest_number": "1548",
    "problem_submissions": {
        "D2": [
            124590154,
            124570151,
            124631052,
            124579457,
            124595552,
            124599986,
            124598663,
            124601582,
            124596908,
            124589080,
            124589208,
            124632567,
            124602573
        ],
        "E": [
            124581595,
            124597899,
            124590654,
            124596843,
            124594126,
            124591964,
            124592242,
            124592323,
            124856732,
            124577426,
            124619322,
            124665492
        ],
        "D1": [
            124546605,
            124538296,
            124561771,
            124569958,
            124572244,
            124572070,
            124558486,
            124552145,
            124565483,
            124565312,
            124554771,
            124568265,
            124563802,
            124595327,
            124572767,
            124574319,
            124573078,
            124560440,
            124570173,
            124568828
        ],
        "C": [
            124538722,
            124546717,
            124543126,
            124552919,
            124545964,
            124599486,
            124550051,
            124554662,
            124555634,
            124559563,
            124538097,
            124558973,
            124554365,
            124565653,
            124542584,
            124561525,
            124550009
        ],
        "B": [
            124529066,
            124526158,
            124527209,
            124533998,
            124528094,
            124540501,
            124535175,
            124539779,
            124535743,
            124537844,
            124538815,
            124529079,
            124550340,
            124533987,
            124531668,
            124543431,
            124533588,
            124530735,
            124554398,
            124534276
        ],
        "A": [
            124521888,
            124519192,
            124532449,
            124525950,
            124521506,
            124523964,
            124524094,
            124520315,
            124522449,
            124524250,
            124550070,
            124520590,
            124556679,
            124524509,
            124523057,
            124525430,
            124522685,
            124522322,
            124531504,
            124524318
        ]
    },
    "name": "E. Gregor and the Two Painters",
    "statement": "Two painters, Amin and Benj, are repainting Gregor\u2019s living room\r\nceiling! The ceiling can be modeled as an n\r\ntimes m grid.For each i between 1 and n, inclusive, painter Amin applies\r\na_i layers of paint to the entire i-th row. For each j between 1 and m,\r\ninclusive, painter Benj applies b_j layers of paint to the entire j-th\r\ncolumn. Therefore, the cell (i,j) ends up with a_i+b_j layers of\r\npaint.Gregor considers the cell (i,j) to be if a_i+b_j\r\nle x. Define a to be a connected component of badly painted cells, i. e.\r\na connected component of badly painted cells such that all adjacent to\r\nthe component cells are not badly painted. Two cells are considered\r\nadjacent if they share a side.Gregor is appalled by the state of the\r\nfinished ceiling, and wants to know the number of badly painted regions.\r\n",
    "solutions": [
        "//\u522b\u4e22\u5305\u4e86\uff01\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nint d[maxn];\nint lb (int x) {\n    return x & -x;\n}\nvoid ins(int pl, int x) {\n    while (pl < maxn) {\n        d[pl] += x;\n        pl += lb(pl);\n    }\n}\nint q(int a) {\n    int ans = 0;\n    while (a) {\n        ans += d[a]; a -= lb(a);\n    }\n    return ans;\n}\nvi u, v;\nstruct rg {\n    int p;\n    int l, r; // l >= 1, r < maxn\n    rg() {}\n};\nvector<pi> act[maxn], ask[maxn];\nll wk(vector<rg> a, vector<rg> b) {\n    for (auto v : a)\n        act[v.p].pb(mp(v.l, v.r));\n    for (auto v : b) {\n        ask[v.l - 1].pb(mp(v.p, -1));\n        ask[v.r].pb(mp(v.p, 1));\n    }\n    ll ans = 0;\n    for (int i = 1; i < maxn; i++) {\n        for (auto v : act[i])\n            ins(v.fi, 1), ins(v.se + 1, -1);\n        for (auto v : ask[i])\n            ans += q(v.fi) * v.se;\n    }\n    return ans;\n}\nint mx[maxn][20];\nint mb[maxn];\nint qmx(int l, int r) {\n    int len = r - l + 1;\n    int j = mb[len];\n    return max(mx[l][j], mx[r - (1 << j) + 1][j]);\n}\nint st[maxn], top = 0;\nint n, m, x;\nvector<rg> gt(vi a) {\n    #define ar3 array<int, 3>\n    int n = a.size();\n    vector<ar3> tot;\n    for (int i = 0; i < maxn; i++)\n        for (int j = 0; j < 20; j++)\n            if ((1 << j) <= i) mb[i] = j;\n    for (int i = 0; i < 20; i++)\n        for (int j = 0; j < n - (1 << i) + 1; j++) {\n            if (i == 0) mx[j][i] = a[j];\n            else {\n                mx[j][i] = max(mx[j][i - 1], mx[j + (1 << (i - 1))][i - 1]);\n            }\n        }\n    for (int s = 0; s < 2; s++) {\n        int top = 0;\n        for (int i = 0; i < n; i++) {\n            int cr = maxn;\n            while (top && a[st[top - 1]] > a[i]) \n                chkmin(cr, a[st[top - 1]]), top -= 1;\n            if (top) {\n                int fl = 1;\n                if (s == 1 && a[st[top - 1]] == a[i]) fl = 0;               \n                if (fl) {\n                    if (s == 0) tot.pb((ar3){st[top - 1], i, cr});\n                    else tot.pb((ar3){n - 1 - i, n - 1 - st[top - 1], cr});\n                }\n            }\n            st[top++] = i;\n        }\n        reverse(a.begin(), a.end());\n    }\n    vector<rg> res;\n    for (auto v : tot) {\n        int l = v[0], r = v[1], sc = v[2];\n        rg fn; fn.l = max(1, x + 1 - sc); fn.r = min(maxn - 1, x - max(a[l], a[r]));\n        fn.p = qmx(l, r);\n        if (fn.l > fn.r) continue;\n        res.pb(fn);\n    }\n    return res;\n}\nint fl[maxn];\nint sum = 0, s1 = 0;\nvoid inc(int x) {\n    fl[x] = 1;\n    if (fl[x - 1]) s1 += 1;\n    if (fl[x + 1]) s1 += 1;\n    sum += 1;\n}\nint main() {\n    cin >> n >> m >> x;\n    vi u[2];\n    vector<pi> s[2];\n    u[0].resize(n), u[1].resize(m);\n    for (int t = 0; t < 2; t++) {\n        for (int i = 0; i < u[t].size(); i++) {\n            scanf(\"%d\", &u[t][i]);\n            s[t].pb(mp(u[t][i], i + 1));\n        }\n        sort(s[t].begin(), s[t].end());\n    }\n    /*\n    for (int i = 0; i < u[0].size(); i++) {\n        for (int j = 0; j < u[1].size(); j++) {\n            if (u[0][i] + u[1][j] <= x) cout << \"1 \";\n            else cout << \"0 \";\n        }\n        cout << endl;\n    }\n    */\n    ll ans = wk(gt(u[0]), gt(u[1]));\n    //cout << ans << endl;\n    int pl = 0;\n    for (int g = 0; g < 2; g++) {\n        sum = s1 = 0; memset(fl, 0, sizeof(fl));\n        int p = 0;\n        for (int i = s[0].size() - 1; i >= 0; i--) {\n            while (p < s[1].size() && s[1][p].fi + s[0][i].fi <= x) {\n                inc(s[1][p].se);\n                p += 1;\n            }\n            ans -= s1;\n            if (g == 0) ans += sum;\n        }\n        swap(s[0], s[1]);\n    }\n    cout << ans << endl;\n    return (0-0); //<3\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "graphs",
        "greedy",
        "math"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Gregor and the Two Painters.json",
    "editorial_link": "https://codeforces.com//blog/entry/93586",
    "editorial": "SolutionThis editorial was written by enq, and inspired by 1392I - .For\r\nsimplicity let\u00e2\u0080\u0099s assume that all are distinct (and similarly, all ). If\r\nthis is not the case, we may break ties arbitrarily.Say that two badly\r\npainted cells are directly reachable from each other if they are in the\r\nsame row or column and all cells in between them are also badly painted.\r\nAlso, define the value of the cell at to be . Call a badly painted cell\r\na if no cell directly reachable from it has a smaller value than it.\r\nEvery connected component of badly painted cells contains exactly one\r\nrepresentative. Clearly every connected component contains at least one\r\nrepresentative; consider the cell(s) with the minimum value contained\r\nwithin it. To show that every connected component contains\r\ntextit{exactly} one representative, suppose that we are given a\r\nrepresentative that is directly reachable from for all and for all ,\r\nwhere and . Then the connected component containing is completely\r\ncontained within the rectangle , and is the unique cell with the minimum\r\nvalue within that rectangle. This implies that a representative is\r\nalways the unique cell with the minimum value within its connected\r\ncomponent.It remains to count the number of representatives. For each ,\r\nlet be the maximum index less than such that and be the minimum index\r\ngreater than such that . Then define to be . Any path from a cell in row\r\nto a cell in the same column with lower value must pass through a row\r\nwith value at least . Define for each similarly. It can be shown that is\r\na representative if and only if the following conditions hold: Computing\r\nand can be done in with any data structure supporting range min/max\r\nqueries (e.g. sparse tables), or in with a stack. It remains to count\r\nthe number of pairs that satisfy these conditions given , , , and .\r\nFirst initialize two binary indexed trees and . Then sort the pairs in\r\ndecreasing order. Now for every pair in the order, if it is of the form\r\n, then add to the answer the number of elements of that are in the range\r\n, and add to . The reasoning for the case is similar (query , update\r\n).The time complexity is for sorting the pairs and working with the two\r\nBITs.\r\n"
}