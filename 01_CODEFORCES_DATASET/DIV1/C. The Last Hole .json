{
    "link": "https://codeforces.com//contest/274/problem/C",
    "problemId": "2643",
    "problem_idx": "C",
    "shortId": "274C",
    "contest_number": "274",
    "problem_submissions": {
        "C": [
            3158978,
            3161367,
            3160459,
            3161088,
            3162848,
            3162836,
            3165392,
            3165808
        ],
        "D": [
            3157146,
            3154578,
            3158626,
            3159674,
            3155066,
            3154610,
            3154494,
            3162878,
            3155274,
            3154799,
            3156202,
            3154900,
            3156390,
            3156684,
            3157059,
            3155641,
            3157406,
            3158027,
            3156972,
            3156358
        ],
        "B": [
            3152846,
            3152029,
            3153572,
            3152338,
            3153369,
            3152405,
            3153123,
            3152132,
            3152478,
            3153001,
            3152618,
            3151871,
            3152600,
            3152514,
            3153029,
            3154367,
            3152641,
            3154376,
            3154181
        ],
        "A": [
            3151000,
            3150976,
            3151370,
            3151011,
            3151226,
            3150986,
            3151237,
            3151023,
            3151171,
            3151002,
            3150999,
            3152680,
            3151235,
            3150991,
            3151625,
            3151251,
            3169649,
            3151050,
            3151668,
            3151075
        ],
        "E": [
            3179779,
            3170504,
            3166357,
            3166349
        ]
    },
    "name": "C. The Last Hole ",
    "statement": "Luyi has circles on the plane. The -th circle is centered at . At the\r\ntime zero circles start to grow simultaneously. In other words, the\r\nradius of each circle at time is equal to . The circles are drawn as\r\nblack discs on an infinite white plane. So at each moment the plane\r\nconsists of several black and white regions. Note that the circles may\r\noverlap while growing. We define a as a closed, connected white region.\r\nFor instance, the figure contains two holes shown by red border. During\r\ngrowing some holes may be created and it is easy to see that each\r\ncreated hole will disappear eventually. Luyi asks you to find moment of\r\ntime such that the last hole disappears. In other words, you should find\r\nthe first moment such that no hole can be seen after that.\r\n",
    "solutions": [
        "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define eps 1.0E-12\n\nint N;\nint x[110],y[110];\nint dist[110][110];\ndouble sdist[110][110];\n\nstruct point {double x,y;};\npoint P[110];\n\ndouble func(double a, double b, double c){\n    a = sqrt(a); b = sqrt(b); c = sqrt(c);\n    return a * b * c / sqrt((a+b+c) * (-a+b+c) * (a-b+c) * (a+b-c));\n}\n\npoint circumcenter(point P, point Q, point R){\n    double x1 = Q.x - P.x, y1 = Q.y - P.y, x2 = R.x - P.x, y2 = R.y - P.y;\n    double x = (y2 * (x1*x1 + y1*y1) - y1 * (x2*x2 + y2*y2)) / 2.0 / (x1*y2 - x2*y1);\n    double y = -(x2 * (x1*x1 + y1*y1) - x1 * (x2*x2 + y2*y2)) / 2.0 / (x1*y2 - x2*y1);\n    point ans = {P.x + x, P.y + y};\n    return ans;\n}\n\nbool check(point P, double D){\n    double x2 = P.x, y2 = P.y;\n    int i;\n    REP(i,N){\n        double dx = x[i] - x2, dy = y[i] - y2;\n        if((dx * dx + dy * dy) / D < 1.0 - eps) return false;\n    }\n    return true;\n}\n\nint main(void){\n    int i,j,k,l;\n    \n    cin >> N;\n    REP(i,N) cin >> x[i] >> y[i];\n    \n    REP(i,N){\n        P[i].x = x[i];\n        P[i].y = y[i];\n    }\n    \n    double ans = -1.0;\n    \n    REP(i,N) REP(j,N){\n        int dx = x[i] - x[j], dy = y[i] - y[j];\n        dist[i][j] = dx * dx + dy * dy;\n        sdist[i][j] = sqrt(dist[i][j]);\n    }\n    \n    REP(k,N) REP(j,k) REP(i,j){\n        int d1 = dist[i][j], d2 = dist[j][k], d3 = dist[k][i];\n        if(d1 + d2 > d3 && d2 + d3 > d1 && d3 + d1 > d2){\n            double tmp = func(d1, d2, d3);\n            point O = circumcenter(P[i], P[j], P[k]);\n            if(check(O, tmp * tmp)) ans = max(ans, tmp); \n        }\n    }\n    \n    REP(i,N) REP(j,i){\n        bool found = false;\n        REP(k,N) REP(l,k){\n            if(!found && dist[i][j] == dist[k][l] && dist[i][k] == dist[j][l] && dist[i][l] == dist[j][k] && dist[i][j] > dist[i][k] && dist[i][j] > dist[i][l]){\n                found = true;\n                double tmp = sdist[i][j] / 2.0;\n                point O = {(x[i] + x[j]) / 2.0, (y[i] + y[j]) / 2.0};\n                if(check(O, tmp * tmp)) ans = max(ans, tmp);\n            }\n        }\n    }\n    \n    if(ans < -0.5){\n        cout << \"-1\" << endl;\n    } else {\n        printf(\"%.9f\\n\", ans);\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "geometry"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. The Last Hole .json",
    "editorial_link": "https://codeforces.com//blog/entry/6759",
    "editorial": "In the solution we will try to find the position of all points which are the last moments in holes. Here we claim that each minimal potential hole is one of these two forms:\n\nFor each three centers that form an acute triangle it\u0092s obvious that they form a potential hole. The last point in this hole would be the in triangle\u0092s circumcenter.\n\nFor each four centers which are sides of a square it\u0092s also obvious there\u0092s a potential hole with last point being the square\u0092s center.\n\nFor each potential hole we should check if the last point is not covered with any other circle in the last moment. The solution would be the hole with maximum distance from the centers which won\u0092t be covered by anything else.\n\nLet\u0092s remind some geometry facts. We know that circumcenter of a triangle is the point where the three perpendicular bisectors of the triangle meet. Also the circumcenter of the triangle lies inside the triangle if and only if the triangle is acute. Circumcenter is the point which has equal distance from each vertex of the triangle.\n\nUsing above information it\u0092s easy to prove that three circles make a hole if and only if the triangle they form is acute. Now what remains is to prove that in the last moment which the hole is disappearing there are 3 triangles or four forming a square enclosing the hole. I\u0092m not going into details but the proof would be like this. Consider the last point of a hole. There are some circles which form the border of the hole in the last moment. These centers have the same distance from the last point. We need to prove that only three of the centers or four of them which form a square do the same job. And all others can be ignored. Consider the circle which these centers lie on its perimeter. Here\u0092s a way to pick at most four of these points which make that hole. As long as there are three consecutive points which form make a obtuse triangle delete the middle point (why?). It\u0092s easy to see what will remain at the end is either a square or an acute triangle.\n\nThe implementation can be done in O(n4) with iterating through all triangles in O(n3) and checking them in O(n). Also there are at most O(n3) squares, because once you\u0092ve picked three of its vertices the fourth will be unique."
}