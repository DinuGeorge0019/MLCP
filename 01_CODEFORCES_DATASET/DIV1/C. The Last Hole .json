{"link": "https://codeforces.com//contest/274/problem/C", "problemId": "2643", "problem_idx": "C", "shortId": "274C", "contest_number": "274", "problem_submissions": {"C": [3158978, 3161367, 3160459, 3161088, 3162848, 3162836, 3165392, 3165808], "D": [3157146, 3154578, 3158626, 3159674, 3155066, 3154610, 3154494, 3162878, 3155274, 3154799, 3156202, 3154900, 3156390, 3156684, 3157059, 3155641, 3157406, 3158027, 3156972, 3156358], "B": [3152846, 3152029, 3153572, 3152338, 3153369, 3152405, 3153123, 3152132, 3152478, 3153001, 3152618, 3151871, 3152600, 3152514, 3153029, 3154367, 3152641, 3154376, 3154181], "A": [3151000, 3150976, 3151370, 3151011, 3151226, 3150986, 3151237, 3151023, 3151171, 3151002, 3150999, 3152680, 3151235, 3150991, 3151625, 3151251, 3169649, 3151050, 3151668, 3151075], "E": [3179779, 3170504, 3166357, 3166349]}, "name": "C. The Last Hole ", "statement": "Luyi has circles on the plane. The -th circle is centered at . At the\r\ntime zero circles start to grow simultaneously. In other words, the\r\nradius of each circle at time is equal to . The circles are drawn as\r\nblack discs on an infinite white plane. So at each moment the plane\r\nconsists of several black and white regions. Note that the circles may\r\noverlap while growing. We define a as a closed, connected white region.\r\nFor instance, the figure contains two holes shown by red border. During\r\ngrowing some holes may be created and it is easy to see that each\r\ncreated hole will disappear eventually. Luyi asks you to find moment of\r\ntime such that the last hole disappears. In other words, you should find\r\nthe first moment such that no hole can be seen after that.\r\n", "solutions": ["#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define eps 1.0E-12\n\nint N;\nint x[110],y[110];\nint dist[110][110];\ndouble sdist[110][110];\n\nstruct point {double x,y;};\npoint P[110];\n\ndouble func(double a, double b, double c){\n    a = sqrt(a); b = sqrt(b); c = sqrt(c);\n    return a * b * c / sqrt((a+b+c) * (-a+b+c) * (a-b+c) * (a+b-c));\n}\n\npoint circumcenter(point P, point Q, point R){\n    double x1 = Q.x - P.x, y1 = Q.y - P.y, x2 = R.x - P.x, y2 = R.y - P.y;\n    double x = (y2 * (x1*x1 + y1*y1) - y1 * (x2*x2 + y2*y2)) / 2.0 / (x1*y2 - x2*y1);\n    double y = -(x2 * (x1*x1 + y1*y1) - x1 * (x2*x2 + y2*y2)) / 2.0 / (x1*y2 - x2*y1);\n    point ans = {P.x + x, P.y + y};\n    return ans;\n}\n\nbool check(point P, double D){\n    double x2 = P.x, y2 = P.y;\n    int i;\n    REP(i,N){\n        double dx = x[i] - x2, dy = y[i] - y2;\n        if((dx * dx + dy * dy) / D < 1.0 - eps) return false;\n    }\n    return true;\n}\n\nint main(void){\n    int i,j,k,l;\n    \n    cin >> N;\n    REP(i,N) cin >> x[i] >> y[i];\n    \n    REP(i,N){\n        P[i].x = x[i];\n        P[i].y = y[i];\n    }\n    \n    double ans = -1.0;\n    \n    REP(i,N) REP(j,N){\n        int dx = x[i] - x[j], dy = y[i] - y[j];\n        dist[i][j] = dx * dx + dy * dy;\n        sdist[i][j] = sqrt(dist[i][j]);\n    }\n    \n    REP(k,N) REP(j,k) REP(i,j){\n        int d1 = dist[i][j], d2 = dist[j][k], d3 = dist[k][i];\n        if(d1 + d2 > d3 && d2 + d3 > d1 && d3 + d1 > d2){\n            double tmp = func(d1, d2, d3);\n            point O = circumcenter(P[i], P[j], P[k]);\n            if(check(O, tmp * tmp)) ans = max(ans, tmp); \n        }\n    }\n    \n    REP(i,N) REP(j,i){\n        bool found = false;\n        REP(k,N) REP(l,k){\n            if(!found && dist[i][j] == dist[k][l] && dist[i][k] == dist[j][l] && dist[i][l] == dist[j][k] && dist[i][j] > dist[i][k] && dist[i][j] > dist[i][l]){\n                found = true;\n                double tmp = sdist[i][j] / 2.0;\n                point O = {(x[i] + x[j]) / 2.0, (y[i] + y[j]) / 2.0};\n                if(check(O, tmp * tmp)) ans = max(ans, tmp);\n            }\n        }\n    }\n    \n    if(ans < -0.5){\n        cout << \"-1\" << endl;\n    } else {\n        printf(\"%.9f\\n\", ans);\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "geometry"], "dificulty": "2600", "interactive": false}