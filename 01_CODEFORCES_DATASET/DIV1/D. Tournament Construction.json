{
    "link": "https://codeforces.com//contest/850/problem/D",
    "problemId": "120878",
    "problem_idx": "D",
    "shortId": "850D",
    "contest_number": "850",
    "problem_submissions": {
        "E": [
            30079147,
            30079321,
            30076520,
            30070445,
            30072131,
            30067095,
            30068181,
            30093004,
            30078840,
            30069238,
            30121826,
            30081582,
            30080429,
            30062854,
            30075459,
            30063501
        ],
        "C": [
            30074039,
            30065285,
            30068848,
            30063413,
            30062879,
            30062229,
            30071925,
            30062969,
            30065613,
            30065926,
            30075756,
            30070129,
            30073758,
            30065190,
            30073153,
            30074735,
            30076259,
            30065744,
            30070888
        ],
        "A": [
            30069678,
            30056916,
            30058041,
            30057755,
            30055909,
            30056498,
            30059213,
            30058881,
            30065583,
            30059587,
            30062587,
            30059533,
            30059618,
            30080413,
            30064068,
            30056411,
            30066966,
            30056135,
            30056956,
            30066903
        ],
        "B": [
            30068250,
            30061127,
            30081762,
            30072437,
            30058838,
            30066243,
            30062293,
            30085846,
            30070994,
            30120525,
            30071520,
            30064497,
            30064013,
            30059633,
            30059864,
            30081342,
            30120546,
            30077952,
            30076711
        ],
        "F": [
            30064851,
            30071271,
            30075755,
            30077357,
            30079821,
            30089510,
            30071025
        ],
        "D": [
            30071702,
            30081255,
            30092254,
            30077349,
            30092387,
            30073378,
            30075318,
            30101681,
            30076176,
            30093362,
            30082776,
            30070573
        ]
    },
    "name": "D. Tournament Construction",
    "statement": "Ivan is reading a book about tournaments. He knows that a tournament is\r\nan oriented graph with exactly one oriented edge between each pair of\r\nvertices. The score of a vertex is the number of edges going outside\r\nthis vertex. Yesterday Ivan learned Landau\u2019s criterion: there is\r\ntournament with scores if and only if for all and .Now, Ivan wanna solve\r\nfollowing problem: given a of numbers , is there a tournament with given\r\nset of scores? I.e. is there tournament with sequence of scores such\r\nthat if we remove duplicates in scores, we obtain the required set ?\r\nFind a tournament with possible number of vertices.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VL vector<long long>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int SIZE = 1e6+10;\n#define FN 500010\n#define FM 4200010\n#define INF 1034567890\n#define FOR(it,c) for ( __typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++ )\nusing namespace std;\ntypedef long long LL;\nstruct E {\n    int k,c;\n    E(){}\n    E( int _k, int _c ):k(_k),c(_c){}\n} es[FM];\n\nstruct Flow {\n    int n,m,dis[FN];\n    int qq[FN],qr,ql;\n    vector<int> e[FN];\n    void init( int _n ) {\n        n=_n; m=0;\n        for ( int i=0; i<n; i++ ) e[i]=vector<int>();\n    }\n    void add_edge( int a, int b, int c ) {\n        e[a].push_back(m); es[m]=E(b,c); m++;\n        e[b].push_back(m); es[m]=E(a,0); m++;\n    }\n    bool BFS() {\n        memset(dis,-1,n*sizeof(int));\n        ql=qr=0;\n        qq[qr++]=0;\n        dis[0]=0;\n        while ( ql!=qr && dis[n-1]==-1 ) {\n            int p=qq[ql++];\n            FOR(it,e[p]) {\n                E ee=es[*it];\n                if ( ee.c==0 || dis[ee.k]!=-1 ) continue;\n                dis[ee.k]=dis[p]+1;\n                qq[qr++]=ee.k;\n            }\n        }\n        return dis[n-1]!=-1;\n    }\n    LL go( int p, LL c ) {\n        if ( p==n-1 ) return c;\n        LL ret=0,tmp;\n        FOR(it,e[p]) {\n            E &ee=es[*it];\n            if ( ee.c==0 || dis[p]+1!=dis[ee.k] ) continue;\n            tmp=go(ee.k,min(c-ret,(LL)ee.c));\n            ret+=tmp; ee.c-=tmp; es[(*it)^1].c+=tmp;\n            if ( ret==c ) break;\n        }\n        if ( ret==0 ) dis[p]=-1;\n        return ret;\n    }\n    LL maxflow() {\n        LL ret=0;\n        while ( BFS() ) ret+=go(0,1LL<<60);\n        return ret;\n    }\n} flow;\nint C2[100];\nint dp[32][2000][62],a[31];\nint rn;\nPII rd[100000];\nchar an[65][65];\nvoid go(int m,int ss,int nn){\n    printf(\"%d\\n\",nn);\n    VI d;\n    while(m){\n        int u=dp[m][ss][nn];\n        m--;\n        REP(i,u)d.PB(a[m]);\n        ss-=u*a[m];\n        nn-=u;\n    }\n    int n=SZ(d);\n    int ed=1+C2[SZ(d)]+SZ(d);\n    flow.init(ed+1);\n    REP(i,n)REP(j,i){\n        rn++;\n        rd[rn]=MP(j,i);\n        flow.add_edge(0,rn,1);\n        flow.add_edge(rn,C2[SZ(d)]+i+1,1);\n        flow.add_edge(rn,C2[SZ(d)]+j+1,1);\n    }\n    REP(i,SZ(d)){\n        flow.add_edge(C2[SZ(d)]+i+1,ed,d[i]);\n    }\n    flow.maxflow();\n    REP(i,SZ(d))REP(j,SZ(d))an[i][j]='0';\n    for(int i=0;i<flow.m;i+=2){\n        int x=es[i+1].k;\n        int y=es[i].k;\n        if(x<=C2[SZ(d)]&&y>C2[SZ(d)]&&!es[i].c){\n            int from=y-C2[SZ(d)]-1;\n            int to=rd[x].F+rd[x].S-from;\n            an[y-C2[SZ(d)]-1][to]='1';\n        }\n    }\n    REP(i,SZ(d))puts(an[i]);\n}\nint main(){\n    REP(i,100)C2[i]=i*(i-1)/2;\n    DRI(m);\n    REP(i,m)RI(a[i]);\n    sort(a,a+m);\n    dp[0][0][0]=INF;\n    REP(i,m){\n        int r=m-i-1;\n        REP(ss,2000)REP(nn,62){\n            if(!dp[i][ss][nn])continue;\n            int now_ss=ss;\n            for(int k=1;k+nn+r<=61;k++){\n                now_ss+=a[i];\n                if(now_ss>=C2[k+nn]){\n                    dp[i+1][now_ss][k+nn]=k;\n                }\n                else break;\n            }\n        }\n    }\n    for(int i=1;i<=61;i++){\n        if(dp[m][C2[i]][i]){\n            go(m,C2[i],i);\n            return 0;\n        }\n    }\n    return 0*puts(\"=(\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "graphs",
        "greedy",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Tournament Construction.json",
    "editorial_link": "https://codeforces.com//blog/entry/54317",
    "editorial": "Let be the number of players participating in the tournament. First of\r\nall, note that , since the total number of wins must be , and there can\r\nbe no more than , therefore , hence . Next, we find an appropriate ,\r\nbased on the criterion of the condition. We will go through all possible\r\nfrom 1 to 61 and use the dynamic programming method to determine whether\r\nthere can be a given number of participants, the parameters will be: the\r\ncurrent element in the sorted list how many participants are already\r\naware of their number of victories the total number of wins for the\r\nalready known participants From these parameters, we store whether it is\r\npossible for the remaining participants to assign any so that there is a\r\ntournament for these participants. Also, do not forget that each of\r\nshould be taken at least once. Further, if we did not find , then we\r\nprint . Otherwise, you can recover from the dynamics how many times we\r\ntook each , it remains to build a correct tournament on these values.To\r\ndo this, each time we take the player with the smallest number of wins,\r\nlet this number be , and we make him win other players with the least\r\nnumber of wins, and loose to the remaining players. Next, delete this\r\nplayer, recompute for each remaining player how many times they have to\r\nwin, and continue this process until all of the players are processed.\r\nThe proof that a correct tournament is always built by this algorithm\r\nfollows from the criterion.Thus, the first part works in the second part\r\nworks in .\r\n"
}