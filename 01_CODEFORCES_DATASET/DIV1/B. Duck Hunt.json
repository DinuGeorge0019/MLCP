{"link": "https://codeforces.com//contest/542/problem/B", "problemId": "27150", "problem_idx": "B", "shortId": "542B", "contest_number": "542", "problem_submissions": {"E": [10988594, 10988662, 10988040, 10988519, 10989472, 10986646, 10986386, 10987525, 10987889, 10997446, 10987208, 10988323, 10987814], "A": [10988183, 10988073, 10988917, 10988039, 10988066, 10988030, 10988339, 10987042, 10988676, 10988761, 10989522, 10985841, 10987459, 10994455], "D": [10986695, 10987150, 10987152, 10986150, 10986231, 10986943, 10990837, 10988365, 10989849, 10993982, 11035792, 11035777, 11035767, 11035727, 10990386, 10992159, 10990340, 10990120, 10987703, 10987627], "F": [10986005, 10986369, 10987577, 10990309, 10986553, 10985927, 10987236, 10985531, 10987038, 10986965, 10986721, 10986640, 10986454, 10985938, 10985827, 10985838, 10986342, 10986368], "C": [10985518, 10985721, 10985435, 10985462, 10985406, 10986200, 10986782, 10986530, 10985521, 10986222, 10986134, 10985353, 10985405, 10985560, 10985649, 10985787], "B": [10996302, 11060742, 11054057]}, "name": "B. Duck Hunt", "statement": "A duck hunter is doing his favorite thing, hunting. He lives in a two\r\ndimensional world and is located at point . As he doesn\u2019t like walking\r\nfor his prey, he prefers to shoot only vertically up (because in this\r\ncase, the ducks fall straight into his hands). The hunter doesn\u2019t reload\r\nthe gun immediately or more seconds must pass between the shots. When\r\nthe hunter shoots up, the bullet immediately hits all the ducks who are\r\ndirectly above the hunter.In a two dimensional world each duck is a\r\nhorizontal segment that moves horizontally in the negative direction of\r\nthe axis at the speed length unit per second. For each duck we know the\r\nvalues and the -coordinates of its head (the left end of the segment)\r\nand its tail (the right end of the segment) at time . The height where\r\nthe duck is flying isn\u2019t important as the gun shoots vertically up to\r\nthe infinite height and hits all the ducks on its way. What maximum\r\nnumber of ducks can the hunter shoot? The duck is considered shot by the\r\nhunter if at the moment of the shot at least one of its point intersects\r\nthe axis. After the hunter shoots the duck, it falls and it can\u2019t be\r\nshot anymore. The hunter cannot make shots before the moment of time 0.\r\n", "solutions": ["#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\nint n, d;\nstruct Node {\n\tint mx, ad;\n}seg[200010*12];\n\ntypedef pair<int, int> IV;\nIV inp[200010];\nmap<int, int> dis;\nint inv[200010*4];\n\nint cn = 0;\nint cmi = 0;\nint lav = -1;\nint cl = 0;\n\nvoid assignV(int ed) {\n\ttypeof(dis.begin()) it = dis.upper_bound(lav);\n\tfor(; it != dis.end() && it->first <= ed; ++it) {\n\t\t//printf(\"M: %d-%d\\n\", cn, it->first);\n\t\tinv[cn] = it->first;\n\t\tit->second = cn++;\n\t}\n\tlav = ed; \n}\n\nvoid s_add(int i, int l, int r, int st, int ed, int av) {\n\t//if (i == 0) printf(\"A: %d %d %d\\n\", st, ed, av);\n\tif (ed <= st) return;\n\tif (st == l && ed == r) {\n\t\tseg[i].mx += av;\n\t\tseg[i].ad += av;\n\t\treturn;\n\t}\n\tint m = (l+r)/2;\n\tif (m <= st) s_add(i*2+2, m, r, st, ed, av);\n\telse if (m >= ed) s_add(i*2+1, l, m, st, ed, av);\n\telse {\n\t\ts_add(i*2+1, l, m, st, m, av);\n\t\ts_add(i*2+2, m, r, m, ed, av);\n\t}\n\tseg[i].mx = max(seg[2*i+1].mx, seg[2*i+2].mx) + seg[i].ad;\n}\n\nint s_getMinId(int i, int l, int r, int av, int cv) {\n\t//printf(\"Q: %d %d %d %d\\n\", i, l, r, cv);\n\tif (seg[i].mx+av < cv) return r;\n\tif (l+1 == r) return l;\n\tint m = (l+r)/2;\n\tif (seg[2*i+1].mx+av+ seg[i].ad >= cv) return s_getMinId(i*2+1, l, m, av + seg[i].ad, cv);\n\telse return s_getMinId(i*2+2, m, r, av + seg[i].ad, cv);\n}\n\nvoid lemon() { \n\tscanf(\"%d%d\", &n, &d);\n\trep(i,0,n-1) {\n\t\tint s, t;\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tif (t < 0) i--, n--;\n\t\telse {\n\t\t\ts = max(s, 0);\n\t\t\tinp[i] = IV(t+1,s);\n\t\t\tdis[s]=0, dis[t+1]=0;\n\t\t}\n\t} \n\tsort(inp, inp+n);\n\tint maxd = n * 3 + 1;\n\tinv[maxd] = 1000000001;\n\n\trep(i,0,n-1) {\n\t\tint np = inv[s_getMinId(0, 0, maxd, 0, cmi+1)];\n\t\tnp += d;\n\t\t//printf(\"%d: [%d, %d) %d %d\\n\", i, inp[i].second, inp[i].first, np, cl);\n\t\tif (np < cl) np = cl;\n\t\tif (np <= inp[i].first) {\n\t\t\tcmi++;\n\t\t\tif (dis.find(np) == dis.end())dis[np] = 0;\n\t\t\tassignV(np);\n\t\t\ts_add(0, 0, maxd, dis[np], maxd, 1);\n\t\t\tcl = np;\n\t\t\ti--;\n\t\t} else {\n\t\t\tassignV(inp[i].first);\n\t\t\ts_add(0, 0, maxd, dis[inp[i].second], dis[inp[i].first], 1);\n\t\t\tcl = inp[i].first;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", seg[0].mx);\n}\nint main() {\n  ios::sync_with_stdio(true);\n  #ifndef ONLINE_JUDGE\n  //  freopen(\"\",\"r\",stdin);\n  #endif\n  lemon();\n  return 0;\n}"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "3100", "interactive": false}