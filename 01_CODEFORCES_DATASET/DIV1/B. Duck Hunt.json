{
    "link": "https://codeforces.com//contest/542/problem/B",
    "problemId": "27150",
    "problem_idx": "B",
    "shortId": "542B",
    "contest_number": "542",
    "problem_submissions": {
        "E": [
            10988594,
            10988662,
            10988040,
            10988519,
            10989472,
            10986646,
            10986386,
            10987525,
            10987889,
            10997446,
            10987208,
            10988323,
            10987814
        ],
        "A": [
            10988183,
            10988073,
            10988917,
            10988039,
            10988066,
            10988030,
            10988339,
            10987042,
            10988676,
            10988761,
            10989522,
            10985841,
            10987459,
            10994455
        ],
        "D": [
            10986695,
            10987150,
            10987152,
            10986150,
            10986231,
            10986943,
            10990837,
            10988365,
            10989849,
            10993982,
            11035792,
            11035777,
            11035767,
            11035727,
            10990386,
            10992159,
            10990340,
            10990120,
            10987703,
            10987627
        ],
        "F": [
            10986005,
            10986369,
            10987577,
            10990309,
            10986553,
            10985927,
            10987236,
            10985531,
            10987038,
            10986965,
            10986721,
            10986640,
            10986454,
            10985938,
            10985827,
            10985838,
            10986342,
            10986368
        ],
        "C": [
            10985518,
            10985721,
            10985435,
            10985462,
            10985406,
            10986200,
            10986782,
            10986530,
            10985521,
            10986222,
            10986134,
            10985353,
            10985405,
            10985560,
            10985649,
            10985787
        ],
        "B": [
            10996302,
            11060742,
            11054057
        ]
    },
    "name": "B. Duck Hunt",
    "statement": "A duck hunter is doing his favorite thing, hunting. He lives in a two\r\ndimensional world and is located at point . As he doesn\u2019t like walking\r\nfor his prey, he prefers to shoot only vertically up (because in this\r\ncase, the ducks fall straight into his hands). The hunter doesn\u2019t reload\r\nthe gun immediately or more seconds must pass between the shots. When\r\nthe hunter shoots up, the bullet immediately hits all the ducks who are\r\ndirectly above the hunter.In a two dimensional world each duck is a\r\nhorizontal segment that moves horizontally in the negative direction of\r\nthe axis at the speed length unit per second. For each duck we know the\r\nvalues and the -coordinates of its head (the left end of the segment)\r\nand its tail (the right end of the segment) at time . The height where\r\nthe duck is flying isn\u2019t important as the gun shoots vertically up to\r\nthe infinite height and hits all the ducks on its way. What maximum\r\nnumber of ducks can the hunter shoot? The duck is considered shot by the\r\nhunter if at the moment of the shot at least one of its point intersects\r\nthe axis. After the hunter shoots the duck, it falls and it can\u2019t be\r\nshot anymore. The hunter cannot make shots before the moment of time 0.\r\n",
    "solutions": [
        "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SIZE(x) (int((x).size()))\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\n#define repd(i,r,l) for (int i=(r); i>=(l); i--)\n#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#ifndef ONLINE_JUDGE\n#define debug(x) { cerr<<#x<<\" = \"<<(x)<<endl; }\n#else\n#define debug(x) {}\n#endif\nint n, d;\nstruct Node {\n\tint mx, ad;\n}seg[200010*12];\n\ntypedef pair<int, int> IV;\nIV inp[200010];\nmap<int, int> dis;\nint inv[200010*4];\n\nint cn = 0;\nint cmi = 0;\nint lav = -1;\nint cl = 0;\n\nvoid assignV(int ed) {\n\ttypeof(dis.begin()) it = dis.upper_bound(lav);\n\tfor(; it != dis.end() && it->first <= ed; ++it) {\n\t\t//printf(\"M: %d-%d\\n\", cn, it->first);\n\t\tinv[cn] = it->first;\n\t\tit->second = cn++;\n\t}\n\tlav = ed; \n}\n\nvoid s_add(int i, int l, int r, int st, int ed, int av) {\n\t//if (i == 0) printf(\"A: %d %d %d\\n\", st, ed, av);\n\tif (ed <= st) return;\n\tif (st == l && ed == r) {\n\t\tseg[i].mx += av;\n\t\tseg[i].ad += av;\n\t\treturn;\n\t}\n\tint m = (l+r)/2;\n\tif (m <= st) s_add(i*2+2, m, r, st, ed, av);\n\telse if (m >= ed) s_add(i*2+1, l, m, st, ed, av);\n\telse {\n\t\ts_add(i*2+1, l, m, st, m, av);\n\t\ts_add(i*2+2, m, r, m, ed, av);\n\t}\n\tseg[i].mx = max(seg[2*i+1].mx, seg[2*i+2].mx) + seg[i].ad;\n}\n\nint s_getMinId(int i, int l, int r, int av, int cv) {\n\t//printf(\"Q: %d %d %d %d\\n\", i, l, r, cv);\n\tif (seg[i].mx+av < cv) return r;\n\tif (l+1 == r) return l;\n\tint m = (l+r)/2;\n\tif (seg[2*i+1].mx+av+ seg[i].ad >= cv) return s_getMinId(i*2+1, l, m, av + seg[i].ad, cv);\n\telse return s_getMinId(i*2+2, m, r, av + seg[i].ad, cv);\n}\n\nvoid lemon() { \n\tscanf(\"%d%d\", &n, &d);\n\trep(i,0,n-1) {\n\t\tint s, t;\n\t\tscanf(\"%d%d\", &s, &t);\n\t\tif (t < 0) i--, n--;\n\t\telse {\n\t\t\ts = max(s, 0);\n\t\t\tinp[i] = IV(t+1,s);\n\t\t\tdis[s]=0, dis[t+1]=0;\n\t\t}\n\t} \n\tsort(inp, inp+n);\n\tint maxd = n * 3 + 1;\n\tinv[maxd] = 1000000001;\n\n\trep(i,0,n-1) {\n\t\tint np = inv[s_getMinId(0, 0, maxd, 0, cmi+1)];\n\t\tnp += d;\n\t\t//printf(\"%d: [%d, %d) %d %d\\n\", i, inp[i].second, inp[i].first, np, cl);\n\t\tif (np < cl) np = cl;\n\t\tif (np <= inp[i].first) {\n\t\t\tcmi++;\n\t\t\tif (dis.find(np) == dis.end())dis[np] = 0;\n\t\t\tassignV(np);\n\t\t\ts_add(0, 0, maxd, dis[np], maxd, 1);\n\t\t\tcl = np;\n\t\t\ti--;\n\t\t} else {\n\t\t\tassignV(inp[i].first);\n\t\t\ts_add(0, 0, maxd, dis[inp[i].second], dis[inp[i].first], 1);\n\t\t\tcl = inp[i].first;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", seg[0].mx);\n}\nint main() {\n  ios::sync_with_stdio(true);\n  #ifndef ONLINE_JUDGE\n  //  freopen(\"\",\"r\",stdin);\n  #endif\n  lemon();\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Duck Hunt.json",
    "editorial_link": "https://codeforces.com//blog/entry/17697",
    "editorial": "First of all, let\u00e2\u0080\u0099s say that ducks stay still and the one that moves is\r\nthe hunter. Let\u00e2\u0080\u0099s define the value as the minimum number of ducks among\r\nhaving the right end no further than , that we can\u00e2\u0080\u0099t shot if the last\r\nshot was in the point . In particular, the value includes all ducks\r\nlocated inside the segment . Values for let\u00e2\u0080\u0099s consider as undefined.\r\nLet\u00e2\u0080\u0099s look on as on a function of . This function is defined on all from\r\nto inclusive. The key idea is in investigating how differs from . Let\u00e2\u0080\u0099s\r\nfirst suppose that in point there is no end of the duck. Then in\r\ndefinition of we consider the same set of the ducks as for the\r\ndefinition f . That means that all values for are the same for . Let\u00e2\u0080\u0099s\r\nunderstand what happens with . It\u00e2\u0080\u0099s easy to see that the shot in point\r\ncan\u00e2\u0080\u0099t kill any of the ducks that end no further than (since we just\r\nsupposed that there are no ducks ending in exactly ). So, . Now let\u00e2\u0080\u0099s\r\nsuppose that in point the duck ends. In this case we can say that all\r\nvalues of should be increased by (since at the moment of shot in point\r\nthe duck can\u00e2\u0080\u0099t be killed yet). From the other hand, all values remain\r\nthe same since the last shot kills the newly added duck. Now let\u00e2\u0080\u0099s\r\nunderstand how to implement all this stuff. Function is piecewise\r\nconstant, so it can be stored in a Cartesian tree as a sequence of pairs\r\n(beginning of segment, value on segment). Such storage allows us to\r\neasily add on prefix and take minimum on prefix of a function. Now let\u00e2\u0080\u0099s\r\nthink that is defined on all posistive values but the values for do not\r\nsatisfy the definition of above. In other words, let\u00e2\u0080\u0099s just suppose that\r\nthe lats segment in structure is infinite in right direction. Let\u00e2\u0080\u0099s\r\nsweep with the variable . The function changes in comparsion to very\r\nrarely For example, the value is almost always the same as (that is\r\nequal to as said above). Indeed, if we suppose that there is no duck\r\nending in then and . So, there is an interesting event only if value is\r\nsmaller than the whole prefix before it. On the other hand, the value\r\ncan\u00e2\u0080\u0099t increase more than times by (each time when we pass through the\r\nright end of the duck) and so, it also can\u00e2\u0080\u0099t decrease more then times\r\n(since it is a non-negative value). So, the events \"we passed through\r\nthe right end of the duck\" and \"we should non-trivially calculate \" are\r\nin total linear. Each of them can be processed in operation with\r\nCartesian tree, that gives as totally an solution. Whooray!\r\n"
}