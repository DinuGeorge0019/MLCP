{
    "link": "https://codeforces.com//contest/1019/problem/E",
    "problemId": "207017",
    "problem_idx": "E",
    "shortId": "1019E",
    "contest_number": "1019",
    "problem_submissions": {
        "D": [
            41494541,
            41486235,
            41489624,
            41496428,
            41482324,
            41485058,
            41485821,
            41503084,
            41488961,
            41490515,
            41488550,
            41488663,
            41486677,
            41490916,
            41491659,
            41491114,
            41488916,
            41491612,
            41493392
        ],
        "C": [
            41485063,
            41566656,
            41496194,
            41491682,
            41552113,
            41499582,
            41487460,
            41530705,
            41652339,
            205457358
        ],
        "A": [
            41477821,
            41473071,
            41475477,
            41477205,
            41474279,
            41472040,
            41473278,
            41472687,
            41471212,
            41472351,
            41478347,
            41474071,
            41472848,
            41472443,
            41471416,
            41473130,
            41524142,
            41480834,
            41476724,
            41472604
        ],
        "B": [
            41472593,
            41477785,
            41479330,
            41486699,
            41478688,
            41476845,
            41477610,
            41476296,
            41475985,
            41478284,
            41482245,
            41489236,
            41477340,
            41477044,
            41480533,
            41484731,
            41486696,
            41478640
        ],
        "E": [
            41541275,
            41536720,
            41496541,
            41519405,
            41505368,
            41533475
        ]
    },
    "name": "E. Raining season",
    "statement": "By the year 3018, Summer Informatics School has greatly grown. Hotel\r\nBerendeetronik has been chosen as a location of the school. The camp\r\nconsists of n houses with n-1 pathways between them. It is possible to\r\nreach every house from each other using the pathways.Everything had been\r\nperfect until the rains started. The weather forecast promises that\r\nrains will continue for m days. A special squad of teachers was able to\r\nmeasure that the i-th pathway, connecting houses u_i and v_i, before the\r\nrain could be passed in b_i seconds. Unfortunately, the rain erodes the\r\nroads, so with every day the time to pass the road will increase by a_i\r\nseconds. In other words, on the t-th (from zero) day after the start of\r\nthe rain, it will take a_i\r\ncdot t + b_i seconds to pass through this road.Unfortunately, despite\r\nall the efforts of teachers, even in the year 3018 not all the students\r\nare in their houses by midnight. As by midnight all students have to go\r\nto bed, it is important to find the maximal time between all the pairs\r\nof houses for each day, so every student would know the time when he has\r\nto run to his house.Find all the maximal times of paths between every\r\npairs of houses after t=0, t=1, ..., t=m-1 days.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nusing ull=long double;\nint n1;\n\nint n, m;\n\nvector <pair<int,pll>> graf[nax];\n\nint bylcen[nax];\nint roz[nax];\nint maxr[nax];\n\nvi spo;\n\nint pie[nax];\nvi kied[nax];\nll wyn[nax];\n\npll najp[nax];\n\npll operator - (pll a, pll b)\n{\n\treturn {a.first-b.first, a.second-b.second};\n}\n\npll operator + (pll a, pll b)\n{\n\treturn {a.first+b.first, a.second+b.second};\n}\n\ninline bool ilowek(const pll &s, pll a, pll b)\n{\n\ta=a-s;\n\tb=b-s;\n\tconst ull raz=((ull)a.first)*((ull)b.second);\n\tconst ull dwa=((ull)b.first)*((ull)a.second);\n\treturn (raz>=dwa);\n}\n\nvoid dfs1(int v, int oj, pll trz)\n{\n\tnajp[v]=trz;\n\tfor (auto i : graf[v])\n\t\tif (i.first!=oj)\n\t\t\tdfs1(i.first, v, trz+i.second);\n}\n\nbool mniej1(int a, int b)\n{\n\treturn najp[a]<najp[b];\n}\n\nvi oto(const vi &wek, pll *wsp)\n{\n\tvi ret;\n\tfor (int i : wek)\n\t{\n\t\twhile(!ret.empty() && wsp[i].second>=wsp[ret.back()].second)\n\t\t\tret.pop_back();\n\t\tint r=ret.size();\n\t\twhile(r>1 && ilowek(wsp[ret[r-2]], wsp[ret[r-1]], wsp[i]))\n\t\t{\n\t\t\tr--;\n\t\t\tret.pop_back();\n\t\t}\n\t\tret.push_back(i);\n\t}\n\treturn ret;\n}\n\ninline ll eva(const pll &v, const ll &dzien)\n{\n\treturn v.first*dzien+v.second;\n}\n\npii znajdz(const vi &wek, ll dzien, pll *wsp, int start=0)\n{\n\tint tsa=start;\n\tint tsb=(int)wek.size()-1;\n\tint ts1, ts2;\n\twhile(tsa<tsb)\n\t{\n\t\tts1=(tsa+tsb)/2;\n\t\tts2=ts1+1;\n\t\tif (eva(wsp[wek[ts1]], dzien)>eva(wsp[wek[ts2]], dzien))\n\t\t\ttsb=ts1;\n\t\telse\n\t\t\ttsa=ts2;\n\t}\n\treturn {wek[tsa], tsa};\n}\n\nvoid dfs2(int v, int oj)\n{\n\tspo.push_back(v);\n\troz[v]=1;\n\tmaxr[v]=0;\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj || bylcen[i.first])\n\t\t\tcontinue;\n\t\tdfs2(i.first, v);\n\t\troz[v]+=roz[i.first];\n\t\tmaxr[v]=max(maxr[v], roz[i.first]);\n\t}\n}\n\npll odl[nax];\n\nvoid dfs3(int v, int oj, pll trz)\n{\n\todl[v]=trz;\n\tfor (auto i : graf[v])\n\t\tif (i.first!=oj && !bylcen[i.first])\n\t\t\tdfs3(i.first, v, trz+i.second);\n}\n\nint num[nax];\nvector <int> drz[nax];\n\nvoid dfs4(int v, int oj, int gdz)\n{\n\tdebug() << v << \" do \" << gdz;\n\tnum[v]=gdz;\n\tdrz[gdz+n1-1].push_back(v);\n\tfor (auto i : graf[v])\n\t\tif (i.first!=oj && !bylcen[i.first])\n\t\t\tdfs4(i.first, v, gdz);\n}\n\nbool mniej2(int a, int b)\n{\n\treturn odl[a]<odl[b];\n}\n\nvoid lacz(int v, int w)\n{\n\tdebug() << drz[v] << \"  \" << w << \"  \" << num[w];\n\tint ost=0;\n\tfor (int i : kied[w])\n\t{\n\t\tpii wez=znajdz(drz[v], i, odl, ost);\n\t\tint x=wez.first;\n\t\tost=wez.second;\n\t\tdebug() << w << \" \" << x;\n\t\twyn[i]=max(wyn[i], eva(odl[w], i)+eva(odl[x], i));\n\t}\n}\n\nvoid rek(int v, int a, int b, int graa, int grab, int w)\n{\n\tif (graa>grab)\n\t\treturn;\n\tif (a>grab || b<graa)\n\t\treturn;\n\tif (drz[v].empty())\n\t\treturn;\n\tif (a>=graa && b<=grab)\n\t{\n\t\tlacz(v, w);\n\t\treturn;\n\t}\n\trek((v<<1), a, (a+b)>>1, graa, grab, w);\n\trek((v<<1)^1, (a+b+2)>>1, b, graa, grab, w);\n}\n\nvoid opierdol(int v)\n{\n\tif (kied[v].empty())\n\t\treturn;\n\trek(1, 1, n1, 1, num[v]-1, v);\n\trek(1, 1, n1, num[v]+1, n1, v);\n}\n\nvoid szuk(int v)\n{\n\tif (bylcen[v])\n\t\treturn;\n\tspo.clear();\n\tdfs2(v, 0);\n\tint ss=spo.size();\n\tint c=-1;\n\tfor (int i : spo)\n\t\tif (maxr[i]*2<=ss && (ss-roz[i])*2<=ss)\n\t\t\tc=i;\n\t\n\tassert(c!=-1);\n\tdebug() << imie(c);\n\t\n\tdfs3(c, 0, {0LL, 0LL});\n\t\n\tn1=1;\n\twhile(n1<=(int)graf[c].size()+2)\n\t\tn1<<=1;\n\t\n\tfor (int i=0; i<=2*n1; i++)\n\t\tdrz[i].clear();\n\t\n\tfor (int i : spo)\n\t\tfor (int j : kied[i])\n\t\t\twyn[j]=max(wyn[j], eva(odl[i], j));\n\t\n\t\n\tint k=0;\n\tnum[c]=0;\n\tfor (auto i : graf[c])\n\t{\n\t\tif (bylcen[i.first])\n\t\t\tcontinue;\n\t\tk++;\n\t\tdfs4(i.first, c, k);\n\t\tsort(drz[k+n1-1].begin(), drz[k+n1-1].end(), mniej2);\n\t\tdrz[k+n1-1]=oto(drz[k+n1-1], odl);\n\t}\n\tfor (int i=n1-1; i; i--)\n\t{\n\t\tint a=i*2;\n\t\tint b=i*2+1;\n\t\tdrz[i].resize(drz[a].size()+drz[b].size());\n\t\tmerge(drz[a].begin(), drz[a].end(), drz[b].begin(), drz[b].end(), drz[i].begin(), mniej2);\n\t\tdrz[i]=oto(drz[i], odl);\n\t\tif (!drz[i].empty())\n\t\t\tdebug() << i << \" \" << drz[i];\n\t}\n\tfor (int i : spo)\n\t\topierdol(i);\n\t\n\tbylcen[c]=1;\n\t\n\tfor (auto i : graf[c])\n\t\tszuk(i.first);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpll fun;\n\t\tscanf(\"%lld%lld\", &fun.first, &fun.second);\n\t\tgraf[a].push_back({b, fun});\n\t\tgraf[b].push_back({a, fun});\n\t}\n\tdfs1(1, 0, {0LL, 0LL});\n\tvi dos;\n\tfor (int i=1; i<=n; i++)\n\t\tdos.push_back(i);\n\tsort(dos.begin(), dos.end(), mniej1);\n\tauto wez=oto(dos, najp);\n\tfor (int i=0; i<m; i++)\n\t\tpie[i]=znajdz(wez, i, najp).first;\n\tdebug() << range(pie, pie+m);\n\tfor (int i=0; i<m; i++)\n\t\tkied[pie[i]].push_back(i);\n\tszuk(1);\n\t\n\tfor (int i=0; i<m; i++)\n\t\tprintf(\"%lld \", wyn[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "trees"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Raining season.json",
    "editorial_link": "https://codeforces.com//blog/entry/61161",
    "editorial": "Letâs use centroid decomposition on edges of the tree to solve this\r\ntask.Centroid decomposition on edges is about finding an edge that\r\ndivides a tree of vertices into two subtrees, each of which contains no\r\nmore than vertices for some fixed constant . It is easy to see that such\r\ndecomposition has only logarithmic depth in terms of initial number of\r\nnodes.There is a problem it is easy to construct an example, where it is\r\nimpossible to choose such edge. For example, star tree with vertices and\r\nleaves is fine for that every edge has a leaf as one of its ends. To\r\nsolve this problem, we can add new vertices and edges to the tree. Letâs\r\nfix arbitrary root of the tree, and make tree binary: if some vertex has\r\nmore than two children , we may replace vertex to vertex with children\r\nand , with children and , and so on. Edge between and has the same\r\nlength as in initial tree between and , and edge between and has length\r\n0.It is easy to see that the distance between any pair of vertices in\r\nnew tree is the same as the distance between them in initial tree. Also,\r\nthe degree of the each vertex is at most three, so we can take the\r\ncentroid of the new tree, and there will be a subtree of centroid with\r\nvertices, so, we will wind an edge that we need in centroid\r\ndecomposition on edges.After choosing an edge for decomposition, we\r\nshould solve the problem recursively for subtrees, and find the\r\ndiameters which contain the chosen edge. It is quite easy we can\r\ncalculate a linear function of length of path from . After that we need\r\nto take one linear function from both subtrees and get the sum of these\r\nfunctions.We can say that if length of path looks like linear function ,\r\nthen we have a point on plane. Then it is obvious that we should only\r\nkeep points on the convex hull of this set. Instead of choosing pairs of\r\nvertices in subtrees of edge we can just build a Minkowski sum of their\r\nconvex hulls we will get exactly the diameters that contain the chosen\r\nedge in linear time.After computing the convex hulls of diameters\r\ncontaining each edge in decomposition, we can put all these points in\r\none big array and build one big convex hull for all these points again.\r\nThis way we get all interesting diameters in the tree. To get the length\r\nof diameter in time , we have to find the most distant point on convex\r\nhull in direction .Building the convex hull for all points for diameters\r\ncontaining the edge of decomposition works in , where is size of current\r\nconnected component. With knowledge that we have logarithmic depth of\r\ndecomposition, overall complexity is .\r\n",
    "hint": []
}