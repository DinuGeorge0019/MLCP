{
    "link": "https://codeforces.com//contest/1012/problem/B",
    "problemId": "203192",
    "problem_idx": "B",
    "shortId": "1012B",
    "contest_number": "1012",
    "problem_submissions": {
        "D": [
            40965345,
            40960627,
            40962755,
            40958672,
            40960130,
            40960868,
            40957816,
            40962185,
            40977537,
            40977026,
            40958559,
            40961785,
            40963025,
            40963296,
            40964134,
            40968496,
            40964728
        ],
        "E": [
            40960617,
            40966609,
            40966430,
            40968315,
            40959955,
            40968344,
            41293524,
            40971324,
            40961945,
            40965219,
            40964178,
            40964935,
            40966686
        ],
        "C": [
            40946223,
            40950962,
            40949847,
            40947169,
            40948884,
            40951113,
            40948032,
            40950863,
            40949840,
            40948978,
            40950249,
            40944733,
            40947497,
            40951510,
            40946864,
            40950557,
            40948982,
            40953572,
            40952480,
            40955310
        ],
        "B": [
            40942792,
            40947068,
            40945179,
            40941414,
            40943485,
            40944363,
            40943466,
            40948512,
            40943709,
            40942617,
            40946516,
            40941822,
            40945156,
            40945233,
            40943297,
            40953601,
            40943064,
            40946807,
            40947838,
            40944988
        ],
        "A": [
            40940407,
            40940426,
            40944393,
            40940053,
            40941238,
            40941590,
            40941675,
            40939828,
            40941205,
            40939974,
            40940704,
            40939790,
            40943152,
            40941982,
            40942155,
            40942198,
            40952349,
            40943555,
            40944486,
            40941409
        ],
        "F": [
            41294072,
            40975225,
            40975082,
            48927133,
            48926928,
            48926890,
            48926661,
            48926482,
            48926274,
            48926240,
            48926110,
            48925986,
            48925954,
            48925448,
            48924606
        ]
    },
    "name": "B. Chemical table",
    "statement": "Innopolis University scientists continue to investigate the periodic\r\ntable. There are known elements and they form a periodic table: a\r\nrectangle with rows and columns. Each element can be described by its\r\ncoordinates (, ) in the table.Recently scientists discovered that for\r\nevery four different elements in this table that form a rectangle with\r\nsides parallel to the sides of the table, if they have samples of three\r\nof the four elements, they can produce a sample of the fourth element\r\nusing nuclear fusion. So if we have elements in positions , , , where\r\nand , then we can produce element . Samples used in fusion are not\r\nwasted and can be used again in future fusions. Newly crafted elements\r\nalso can be used in future fusions.Innopolis University scientists\r\nalready have samples of elements. They want to obtain samples of all\r\nelements. To achieve that, they will purchase some samples from other\r\nlaboratories and then produce all remaining elements using an arbitrary\r\nnumber of nuclear fusions in some order. Help them to find the minimal\r\nnumber of elements they need to purchase.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 400400;\nint n, m, k;\nvector<int> g[N];\nbool used[N];\n\nvoid dfs(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) {\n\t\tif (used[u]) continue;\n\t\tdfs(u);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\twhile(k--) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;\n\t\tu += n - 1;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tint ans = -1;\n\tfor (int v = 0; v < n + m; v++) {\n\t\tif (used[v]) continue;\n\t\tdfs(v);\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "matrices"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Chemical table.json",
    "editorial_link": "https://codeforces.com/blog/entry/60920",
    "editorial": "One of the way to solve this problem is to interprete the cells in 2d\r\nmatrix as an edge in the bipartite graph, that is a cell is an edge\r\nbetween of the left part and of the right part.Note, that each fusion\r\noperation (we have edges , , and get edge ) doesnât change the connected\r\ncomponents of the graph.Moreover, we can prove, that we can obtain each\r\nedge in the connected component by fusion.Letâs examine example edge ,\r\nand some path between and (since they lay in one connected component).\r\nSince the graph is bipartite, the length of this path must be odd, and\r\nit is , otherwise the edge already exists.So we have this path. Take\r\nfirst three edges and make the corresponding fusion, replace this three\r\nedges with the brand new fused edge. The length of the path decreased by\r\n. Repeat until the path is a mere edge.This way, the number of edges to\r\nadd (cells to buy) is just number of connected components minus one.\r\n",
    "hint": []
}