{
    "link": "https://codeforces.com//contest/613/problem/D",
    "problemId": "45534",
    "problem_idx": "D",
    "shortId": "613D",
    "contest_number": "613",
    "problem_submissions": {
        "D": [
            15370174,
            15369060,
            15371636,
            15370471,
            15379384,
            15362600,
            15363979,
            15354167,
            15368389,
            15426084,
            15425641,
            15365392,
            15373098,
            18779257,
            15368296,
            15377483,
            15371351
        ],
        "C": [
            15363274,
            15363231,
            15359913,
            15359671,
            15371545,
            15371994,
            15368974,
            15427099,
            15373779,
            15500484,
            15359086,
            15366208,
            15362711,
            15361056,
            15365561,
            15365370
        ],
        "B": [
            15355133,
            15358358,
            15354489,
            15354211,
            15353308,
            15367695,
            15366228,
            15357588,
            15366815,
            15355551,
            15352746,
            15361105,
            15353369,
            15358156,
            15356015,
            15356798
        ],
        "A": [
            15349386,
            15350249,
            15349384,
            15362764,
            15355920,
            15349371,
            15350969,
            15352662,
            15350106,
            15372771,
            15354161,
            15348878,
            15349502,
            15352202,
            15349256,
            15352650
        ],
        "E": [
            15391423,
            16723541,
            16067912,
            16067870
        ]
    },
    "name": "D. Kingdom and its Cities",
    "statement": "Meanwhile, the kingdom of K is getting ready for the marriage of the\r\nKing\u2019s daughter. However, in order not to lose face in front of the\r\nrelatives, the King should first finish reforms in his kingdom. As the\r\nKing can not wait for his daughter\u2019s marriage, reforms must be finished\r\nas soon as possible.The kingdom currently consists of cities. Cities are\r\nconnected by bidirectional road, such that one can get from any city to\r\nany other city. As the King had to save a lot, there is only one path\r\nbetween any two cities.What is the point of the reform? The key\r\nministries of the state should be relocated to distinct cities (we call\r\nsuch cities ). However, due to the fact that there is a high risk of an\r\nattack by barbarians it must be done carefully. The King has made\r\nseveral plans, each of which is described by a set of important cities,\r\nand now wonders what is the best plan.Barbarians can capture some of the\r\ncities that are not important (the important ones will have enough\r\nprotection for sure), after that the captured city becomes impassable.\r\nIn particular, an interesting feature of the plan is the minimum number\r\nof cities that the barbarians need to capture in order to make all the\r\nimportant cities isolated, that is, from all important cities it would\r\nbe impossible to reach any other important city.Help the King to\r\ncalculate this characteristic for each of his plan.\r\n",
    "solutions": [
        "#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 100005;\n\nint n;\n\nvector<int> edge[N], edge2[N];\n\nvector<int> ord;\n\nconst int LOG = 17;\n\nint rnk[N], out[N], dep[N], fa[N][LOG];\n\nvoid dfs(int u) {\n    rnk[u] = ord.size();\n    ord.push_back(u);\n    for (int j = 0; j < (int)edge[u].size(); ++j) {\n        int v = edge[u][j];\n        if (v == fa[u][0]) {\n            continue;\n        }\n        fa[v][0] = u;\n        dep[v] = dep[u] + 1;\n        dfs(v);\n    }\n    out[u] = ord.size() - 1;\n}\n\nint lca(int u, int v) {\n    if (dep[u] < dep[v]) {\n        swap(u, v);\n    }\n    int delta = dep[u] - dep[v];\n    for (int i = LOG - 1; i >= 0; --i) {\n        if (delta >> i & 1) {\n            u = fa[u][i];\n        }\n    }\n    if (u == v) {\n        return u;\n    }\n    for (int i = LOG - 1; i >= 0; --i) {\n        if (fa[u][i] != fa[v][i]) {\n            u = fa[u][i];\n            v = fa[v][i];\n        }\n    }\n    return fa[u][0];\n}\n\nint vis[N], stamp;\n\nint sum[N << 1], tag[N << 1];\n\ninline int getID(int l, int r) {\n    return (l + r) | (l != r);\n}\n\nvoid init(int l, int r) {\n    int x = getID(l, r);\n    sum[x] = 0;\n    tag[x] = -1;\n    if (l != r) {\n        int m = (l + r) >> 1;\n        init(l, m);\n        init(m + 1, r);\n    }\n}\n\nvoid covern(int l, int r, int v) {\n    int x = getID(l, r);\n    tag[x] = v, sum[x] = v * (r - l + 1);\n}\n\nvoid update(int l, int r) {\n    int x = getID(l, r), m = (l + r) >> 1, lc = getID(l, m), rc = getID(m + 1, r);\n    sum[x] = sum[lc] + sum[rc];\n}\n\nvoid pushdown(int l, int r) {\n    int x = getID(l, r);\n    if (tag[x] != -1) {\n        int m = (l + r) >> 1;\n        covern(l, m, tag[x]);\n        covern(m + 1, r, tag[x]);\n        tag[x] = -1;\n    }\n}\n\nvoid cover(int l, int r, int a, int b, int v) {\n    if (b < l || r < a) {\n        return;\n    }\n    if (a <= l && r <= b) {\n        covern(l, r, v);\n    } else {\n        int m = (l + r) >> 1;\n        pushdown(l, r);\n        cover(l, m, a, b, v);\n        cover(m + 1, r, a, b, v);\n        update(l, r);\n    }\n}\n\nint getsum(int l, int r, int a, int b) {\n    if (b < l || r < a) {\n        return 0;\n    }\n    if (a <= l && r <= b) {\n        return sum[getID(l, r)];\n    } else {\n        int m = (l + r) >> 1;\n        pushdown(l, r);\n        return getsum(l, m, a, b) + getsum(m + 1, r, a, b);\n    }\n}\n\nbool byRnk(const int &i, const int &j) {\n    return rnk[i] < rnk[j];\n}\n\nbool byDep(const int &i, const int &j) {\n    return dep[i] < dep[j];\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; ++i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u, --v;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    memset(fa, -1, sizeof(fa));\n    dfs(0);\n    for (int j = 1; j < LOG; ++j) {\n        for (int i = 0; i < n; ++i) {\n            if (fa[i][j - 1] == -1) {\n                fa[i][j] = -1;\n            } else {\n                fa[i][j] = fa[fa[i][j - 1]][j - 1];\n            }\n        }\n    }\n    init(0, n - 1);\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        cover(0, n - 1, 0, n - 1, 0);\n        int m;\n        scanf(\"%d\", &m);\n        vector<int> us(m);\n        ++stamp;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d\", &us[i]);\n            --us[i];\n            vis[us[i]] = stamp;\n            cover(0, n - 1, rnk[us[i]], rnk[us[i]], 1);\n        }\n        bool flag = false;\n        for (int i = 0; i < m; ++i) {\n            int u = us[i];\n            if (fa[u][0] != -1 && vis[fa[u][0]] == stamp) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag) {\n            printf(\"-1\\n\");\n            continue;\n        }\n        sort(us.begin(), us.end(), byRnk);\n        vector<int> fs;\n        for (int i = 0; i < m; ++i) {\n            int u = us[i], v = us[(i + 1) % m];\n            fs.push_back(lca(u, v));\n        }\n        sort(fs.begin(), fs.end());\n        fs.erase(unique(fs.begin(), fs.end()), fs.end());\n        sort(fs.begin(), fs.end(), byDep);\n        int ans = 0;\n        for (int i = (int)fs.size() - 1; i >= 0; --i) {\n            int u = fs[i];\n            int k = getsum(0, n - 1, rnk[u], out[u]);\n            if (k > 1) {\n                if (vis[u] == stamp) {\n                    ans += k - 1;\n                    cover(0, n - 1, rnk[u] + 1, out[u], 0);\n                } else {\n                    ++ans;\n                    cover(0, n - 1, rnk[u], out[u], 0);\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "divide and conquer",
        "dp",
        "graphs",
        "sortings",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Kingdom and its Cities.json",
    "editorial_link": "https://codeforces.com//blog/entry/22832",
    "editorial": "Obviously, the answer is -1 iff two important cities are adjacent.\n\nIf there was a single query, can we answer it in O(n) time? Let's choose a root arbitrarily. We can note there is an optimal answer that erases two types of vertices: vertices that lie on a vertical path between two important vertices, or LCA of some pair of important vertices.\n\nLet's do a subtree DP that counts the answer for the subtree of v, as well as if there is any important vertex still connected to v in the answer. How do we count it? If v is important, then we should disconnect it from any still-connected vertices from below by erasing these children which contain them. If v is not important, then we erase it iff there are more than one still-connected important vertices below. All calculations are straightforward here.\n\nHow do we process many queries now? There are many possible approaches here (for reference, look at the accepted solutions). The author's solution was as follows: if we have a query with k important vertices, then we can actually build an auxiliary tree with O(k) vertices and apply the linear DP solution to it with minor modifications.\n\nHow to construct the auxiliary tree? We should remember the observation about LCAs. Before we start, let us DFS the initial tree and store the preorder of the tree (also known as \"sort by tin\"-order). A classical exercise: to generate all possible LCAs of all pairs among a subset of vertices, it suffices to consider LCAs of consecutive vertices in the preorder. After we find all the LCAs, it is fairly easy to construct the tree in O(k) time. Finally, apply the DP to the auxiliary tree. Note that important cities adjacent in the auxiliary tree are actually not adjacent (since we've handled that case before), so it is possible to disconnect them."
}