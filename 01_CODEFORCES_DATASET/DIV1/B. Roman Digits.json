{
    "link": "https://codeforces.com//contest/997/problem/B",
    "problemId": "194451",
    "problem_idx": "B",
    "shortId": "997B",
    "contest_number": "997",
    "problem_submissions": {
        "D": [
            39842612,
            39837685,
            39842379,
            39838295,
            39837935,
            39842740,
            39843076,
            39859781,
            39844833,
            39844190,
            39833354,
            39839922,
            39854124,
            39853938,
            39841292,
            39838113,
            39841101,
            39836594,
            39854271,
            39854180,
            39841626
        ],
        "E": [
            39838988,
            39839303,
            40677876,
            39860384,
            216157458,
            207265582
        ],
        "C": [
            39833262,
            39841343,
            39842130,
            39832983,
            39840312,
            39831596,
            39835919,
            39837971,
            39858804,
            39838178,
            39837144,
            39850195,
            39850032,
            39850007,
            39849997,
            39849695,
            39849346,
            39849204,
            39848619,
            39840597,
            39849012,
            39851642,
            39851588,
            39851576,
            39851518,
            39851506,
            39851317,
            39851202,
            39850994,
            39850828,
            39850773,
            39850608,
            39850592,
            39850571,
            39850194,
            39850131,
            39850042,
            39850008,
            39849917,
            39849907,
            39849611,
            39849473,
            39849310,
            39849195,
            39849073,
            39849029,
            39848917,
            39848844,
            39833638
        ],
        "B": [
            39825922,
            39826364,
            39827934,
            39825576,
            39828070,
            39839886,
            39829927,
            39831407,
            39858660,
            39828494,
            39832160,
            39839554,
            39828743,
            39833583,
            39835350,
            39842444,
            39828730,
            39826817
        ],
        "A": [
            39823476,
            39823484,
            39823390,
            39823892,
            39823506,
            39823245,
            39824375,
            39824053,
            39858605,
            39823570,
            39823352,
            39837740,
            39823612,
            39823561,
            39841314,
            39824552,
            39838338,
            39823711,
            39823355
        ]
    },
    "name": "B. Roman Digits",
    "statement": "Let\u2019s introduce a number system which is based on a roman digits. There\r\nare digits , , , which correspond to the numbers 1, 5, 10 and 50\r\nrespectively. The use of other roman digits is not allowed.Numbers in\r\nthis system are written as a sequence of one or more digits. We define\r\nthe value of the sequence simply as the sum of digits in it.For example,\r\nthe number evaluates to 35 and the number to 12.Pay attention to the\r\ndifference to the traditional roman system in our system any sequence of\r\ndigits is valid, moreover the order of digits doesn\u2019t matter, for\r\nexample means 11, not 9.One can notice that this system is ambiguous,\r\nand some numbers can be written in many different ways. Your goal is to\r\ndetermine how many distinct integers can be represented by n roman\r\ndigits , , , .\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nset<int> r[2333];\nll f[2333];\nint main()\n{\n\tr[0].insert(0);\n\tvector<int> v;\n\tfor(int i=0;i<50;++i)\n\t{\n\t\tfor(auto x:r[i])\n\t\t\tr[i+1].insert(x+1),\n\t\t\tr[i+1].insert(x+5),\n\t\t\tr[i+1].insert(x+10),\n\t\t\tr[i+1].insert(x+50);\n\t\tf[i]=r[i].size();\n\t}\n\tll n; cin>>n;\n\tif(n<=20)\n\t{\n\t\tcout<<f[n]<<\"\\n\";\n\t\treturn 0;\n\t}\n\tcout<<f[20]+(f[21]-f[20])*(n-20)<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Roman Digits.json",
    "editorial_link": "https://codeforces.com/blog/entry/60357",
    "editorial": "among all the sequences, select the one, which contains the maximum\r\nnumber of , in case of tie, select one with largest number of .\r\nBruteforce all configurations in such way, that each number is counted\r\nonly in it\u00e2\u0080\u0099s \"maximum\" configuration.Since the length of sequence is\r\nfixed, we can solve problem not for digits , but for digits .Let\u00e2\u0080\u0099s solve\r\nthe problem for digits first.We have a problem that some numbers have\r\nmany representations. But this, in fact, is easy to deal with if we have\r\nat least nine digits \"4\" than we can convert them no some number of \"9\"\r\ndigits, and fill the rest with zeroes.In this case, the solution is to\r\nbruteforce the number of \"4\" from to , and then from the remaining\r\ndigits select any arbitrary number of \"9\", each such choice leads to an\r\nunique number.Let\u00e2\u0080\u0099s return to the original problem with .In this case we\r\ncan also face the situation, when the number of can be increased. We\r\nneed to identify all pairs where , such that they can be transformed to\r\nother pair with detachment of few .We can bruteforce all , , , with four\r\nnested for-loops and check, that the sum of first differs from sum of\r\nlatter by few number of removed, in such case we mark the pair as\r\nbroken.We can also note, that if some pair is marked as broken, than all\r\n\"dominating\" pairs also marked as broken.When we discovered which pairs\r\nare good we can simply:for number_of_4for number_of_9if\r\npair_is_goodcount the answer, all remaining digits are either 0 or 49\r\nand all such alternatives are unique. : if you examine the solution\r\nabove precisely, you will notice that starting some reasonable (you can\r\neasy proof a lowerbound like or , but it is, in fact, ), the function\r\ngrows linearly.So if , you count the answer in any stupid way, and\r\notherwise, simply approximate it linearly using and .\r\n"
}