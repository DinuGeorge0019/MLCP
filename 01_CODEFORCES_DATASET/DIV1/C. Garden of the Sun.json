{
    "link": "https://codeforces.com//contest/1495/problem/C",
    "problemId": "920576",
    "problem_idx": "C",
    "shortId": "1495C",
    "contest_number": "1495",
    "problem_submissions": {
        "F": [
            109612449,
            109607835,
            109606482,
            109609150,
            109620903,
            109726650,
            109627363,
            109621999
        ],
        "E": [
            109601349,
            109614588,
            109615437,
            109622017,
            109595998,
            109609900,
            109608272,
            109611154,
            109618626,
            109616350,
            109613793,
            109616566,
            109663705,
            109745948
        ],
        "D": [
            109585527,
            109580228,
            109579316,
            109589541,
            109578458,
            109566916,
            109575841,
            109594019,
            109596254,
            109599839,
            109603208,
            109598498,
            109595100,
            109579185,
            109589312,
            109591284,
            109598520,
            109583665,
            109585365
        ],
        "C": [
            109580634,
            109591405,
            109587970,
            109577744,
            109586320,
            109593422,
            109611088,
            109582953,
            109580883,
            109580583,
            109587448,
            109605186,
            109581328,
            109584227,
            109579041,
            109577709,
            109589629,
            109602493
        ],
        "B": [
            109568471,
            109565101,
            109584053,
            109566115,
            109569156,
            109574304,
            109563074,
            109573615,
            109567542,
            109575207,
            109571021,
            109587658,
            109567505,
            109566798,
            109566339,
            109589966,
            109570284,
            109566248
        ],
        "A": [
            109557502,
            109557307,
            109557290,
            109557352,
            109558084,
            109569473,
            109557547,
            109559952,
            109558698,
            109558154,
            109557812,
            109558270,
            109557945,
            109558879,
            109557971,
            109558445,
            109560880,
            109558343,
            109559119
        ]
    },
    "name": "C. Garden of the Sun",
    "statement": "There are many sunflowers in the Garden of the Sun.Garden of the Sun is\r\na rectangular table with n rows and m columns, where the cells of the\r\ntable are farmlands. All of the cells grow a sunflower on it.\r\nUnfortunately, one night, the lightning stroke some (possibly zero)\r\ncells, and sunflowers on those cells were burned into ashes. In other\r\nwords, those cells struck by the lightning became empty. Magically,\r\n(neither edges nor corners).Now the owner wants to remove some (possibly\r\nzero) sunflowers to reach the following two goals: When you are on an\r\nempty cell, you can walk to any other empty cell. In other words, those\r\nempty cells are connected. There is simple path between any two empty\r\ncells. In other words, there is no cycle among the empty cells. You can\r\nwalk from an empty cell to another if they share a common edge.Could you\r\nplease give the owner a solution that meets all her requirements?Note\r\nthat you are not allowed to plant sunflowers. You to minimize the number\r\nof sunflowers you remove. It can be shown that the answer always exists.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nint n, m;\n\nchar wcz[nax][nax];\n\nvoid test()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%s\", wcz[i]+1);\n\tint g=-1;\n\tfor (int i=1; i<=3; i++)\n\t{\n\t\tint pie=n+7;\n\t\tint ost=0;\n\t\tfor (int j=i; j<=n; j+=3)\n\t\t{\n\t\t\tpie=min(pie, j);\n\t\t\tost=max(ost, j);\n\t\t}\n\t\tif (pie<=2 && ost>=n-1)\n\t\t\tg=i;\n\t}\n\tassert(g>0);\n\tfor (int i=g; i<=n; i+=3)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t\twcz[i][j]='X';\n\t}\n\tfor (int i=g; i+3<=n; i+=3)\n\t{\n\t\tint s=1;\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (wcz[i+1][j]=='X' || wcz[i+2][j]=='X')\n\t\t\t\ts=j;\n\t\twcz[i+1][s]=wcz[i+2][s]='X';\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tprintf(\"%c\", wcz[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n\tdebug();\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Garden of the Sun.json",
    "editorial_link": "https://codeforces.com//blog/entry/88533",
    "editorial": "When is the multiple of , itâs easy to construct a solution: First,\r\nremove all the sunflowers on column . This operation wonât form a cycle\r\nin the graph. Letâs take this as an example: After the operation, the\r\ngraph turns into: After that, you need to connect these columns to make\r\nthem connected but without forming a cycle. The green cells are all\r\nalternatives. This way of construction also works for . But you need to\r\nbe cautious about the case of because there is an extra column that may\r\nnot be connected with the left part. Donât forget to connect\r\nthem.Another approach is to remove column when . So there wonât be an\r\nextra column.The time complexity is for each test case.\r\n",
    "hint": []
}