{
    "link": "https://codeforces.com//contest/1943/problem/D2",
    "problemId": "2535043",
    "problem_idx": "D2",
    "shortId": "1943D2",
    "contest_number": "1943",
    "problem_submissions": {
        "E2": [
            251755986,
            251774166,
            251721110,
            251772938,
            251976046,
            251850394,
            251783692,
            252482559,
            251768795,
            251806219,
            251801786,
            251784602,
            251808955,
            251786442,
            251790915,
            251791945,
            252167133,
            254017076,
            252396752,
            251948632
        ],
        "E1": [
            251743400,
            251761808,
            251720570,
            251764606,
            251765135,
            251768616,
            251774247,
            251768081,
            251767041,
            251779764,
            251763055,
            251770682,
            251776382,
            251772657,
            253458372,
            251772270,
            251777192,
            251779122,
            251781255
        ],
        "D2": [
            251730537,
            251743841,
            251769783,
            251827860,
            251827638,
            251812685,
            251750876,
            251749250,
            251743677,
            251754133,
            251758370,
            251752785,
            251846892,
            251763163,
            251753145,
            251743858,
            251746564,
            251754334,
            251790796,
            253458316,
            251757628,
            251757687,
            251759092,
            251761488
        ],
        "D1": [
            251727886,
            251730644,
            251753185,
            251730641,
            251733326,
            251727921,
            251742335,
            251739558,
            251743910,
            251737861,
            251737457,
            251736749,
            251746112,
            251745451,
            251785836,
            252959932,
            251749532,
            251743349,
            251754372,
            251751101
        ],
        "C": [
            251715534,
            251721073,
            251747865,
            251720444,
            251722988,
            251756982,
            251730923,
            251730217,
            251735041,
            251727939,
            251724586,
            251722879,
            251721249,
            251735499,
            251732028,
            252959913,
            251731321,
            251736408,
            251741233,
            251741283
        ],
        "B": [
            251709195,
            251712754,
            251737904,
            251712353,
            251714193,
            252482757,
            251715199,
            251720530,
            251721280,
            251721320,
            251719084,
            251718139,
            251714047,
            251713923,
            251720644,
            251719922,
            252531274,
            251717454,
            251716526,
            251722194,
            252064777,
            251726935
        ],
        "A": [
            251701793,
            251702717,
            251723885,
            251701730,
            251702780,
            251702880,
            251702623,
            251701902,
            251707932,
            251702391,
            251707705,
            251702309,
            251701731,
            251703701,
            251706521,
            252531268,
            251732626,
            251703091,
            251704741,
            251703882
        ],
        "F": [
            251801182,
            252436931,
            251845260,
            251783880
        ]
    },
    "name": "D2. Counting Is Fun  Hard Version ",
    "statement": "An array b of m non-negative integers is said to be if all the elements\r\nof b can be made equal to 0 using the following operation some\r\n(possibly, zero) times: Select two indices l and r (1\r\nleq l\r\ncolor{red}{<} r\r\nleq m) and subtract 1 from all b_i such that l\r\nleq i\r\nleq r. You are given two positive integers n, k and a prime number\r\np.Over all (k+1)^n arrays of length n such that 0\r\nleq a_i\r\nleq k for all 1\r\nleq i\r\nleq n, count the number of good arrays.Since the number might be too\r\nlarge, you are only required to find it modulo p.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.03.2024 10:55:52\n**/\n// #undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k >> md;\n    vector<vector<Mint>> aux(4, vector<Mint>(n + 3));\n    for (int type = 0; type < 4; type++) {\n      vector<vector<Mint>> dp(n + 3, vector<Mint>(k + 1));\n      vector<vector<Mint>> dk(n + 3, vector<Mint>(k + 1));\n      dp[0][0] += 1;\n      if (type & 1) {\n        dp[0][k] += -1;\n      } else {\n        dp[0][1] += -1;\n      }\n      for (int i = 0; i + 2 <= n + 2; i += 2) {\n        for (int v = 0; v < k; v++) {\n          dp[i][v + 1] += dp[i][v];\n          dk[i][v + 1] += dk[i][v];\n          dp[i][v] += dk[i][v] * v;\n\n          auto val = dp[i][v] * (k - v);\n          dp[i + 2][0] += val;\n          dk[i + 2][0] += -dp[i][v];\n          dp[i + 2][k - v] -= val;\n          dk[i + 2][k - v] -= -dp[i][v];\n        }\n      }\n      int bound = (type & 2) ? k - 1 : 0;\n      for (int i = 2; i <= n + 2; i += 2) {\n        for (int v = 0; v <= bound; v++) {\n          aux[type][i] += dp[i][v];\n        }\n      }\n    }\n    vector<Mint> f(n + 3);\n    f[0] = 1;\n    for (int i = 0; i <= n + 1; i++) {\n      f[i + 1] += f[i] * (i == 0 || i == n + 1 ? 1 : k + 1);\n      for (int j = i + 2; j <= n + 1; j += 2) {\n        int type = (i == 0 ? 0 : 1) + (j == n + 1 ? 0 : 2);\n        f[j + 1] += f[i] * aux[type][j - i] * ((j - i) % 4 == 2 ? -1 : 1); \n      }\n    }\n    cout << f[n + 2] << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D2. Counting Is Fun  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/127195",
    "editorial": "Solution Since there are states in our dp, we will have to optimize the\nnumber of states somehow.Let us consider all arrays and not just good\narrays. An element is bad if .Suppose, gave us the number of arrays\nwhere each of are distinct and bad. (Note that other positions may be\nbad as well). Then, by PIE, the answer is . For example, for , we would\nwant to compute . Note that is simply as there are no restrictions\nplaced on the array.This has calculations, so we need to optimize it.\nFirst optimization : obviously, only matters and not the exact indices.\nThis means we only have to maintain the count of the number of indices\nwe have made sure are bad.Second optimization : only parity of matters,\ndue to the only dependence of being .We now define = number of arrays\nsuch that and the parity of bad elements (that we know of) till is\n.Transitions : Without (necessarily) creating a bad element : for all .\nWe might accidentally create more bad elements, but remember that PIE\nallows us to not worry about that. With creating a bad element : We view\nit as a transition from index , for it to bad, so fix , , and you get\n.The term comes from the ways to choose such that . Both the transitions\nare optimizable with some prefix sums and running totals to get a\nsolution.\n",
    "hint": [
        "Hint 1 Try to apply Principle of Inclusion Exclusion (PIE).",
        "Hint 2 You do not need to store both last elements! Only the last is enough."
    ]
}