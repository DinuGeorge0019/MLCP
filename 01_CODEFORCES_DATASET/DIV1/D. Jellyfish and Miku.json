{
    "link": "https://codeforces.com//contest/1874/problem/D",
    "problemId": "2236839",
    "problem_idx": "D",
    "shortId": "1874D",
    "contest_number": "1874",
    "problem_submissions": {
        "F": [
            226041334,
            226055202,
            226083158,
            226054781,
            226061315,
            226045179,
            226057161,
            226024417,
            226094016,
            226151126,
            226979730,
            226372437,
            226704730,
            226099033,
            226098861,
            226001871
        ],
        "B": [
            225998357,
            225944596,
            225961498,
            226022662,
            225970503,
            226048661,
            225965106,
            225956535,
            225974109,
            226024200,
            226979960,
            226057337,
            225972372,
            225968693,
            225962068,
            226040739,
            225981051,
            226047279,
            226046003,
            225948785
        ],
        "D": [
            225989950,
            226004287,
            225983656,
            225994935,
            225998958,
            226008015,
            225977564,
            226002115,
            225985427,
            226003081,
            225989658,
            226979804,
            225989175,
            226003010,
            226023529,
            226002830,
            226078484,
            226078353,
            226002716,
            226024255,
            226018418,
            226137164,
            225986804
        ],
        "E": [
            225973607,
            225981897,
            226000134,
            225978662,
            226074388,
            226073614,
            226073223,
            226072631,
            226071563,
            226069387,
            226068777,
            226021358,
            225958738,
            226070894,
            225983588,
            226039851,
            226021998,
            226007010,
            226979776,
            226006499,
            226036184,
            226038920,
            226053631,
            226068817,
            226063126,
            226059742,
            226057237
        ],
        "C": [
            225967620,
            225968755,
            225972644,
            225961410,
            225983858,
            225989707,
            225987635,
            225970993,
            225986658,
            225975231,
            226979908,
            225973609,
            225986638,
            225980254,
            225971024,
            227431342,
            225959672,
            225996237,
            225972869,
            226057682,
            225972171
        ],
        "A": [
            225936409,
            225922035,
            225921764,
            225934682,
            225931922,
            225937474,
            225923760,
            225922674,
            225923828,
            225922214,
            226979999,
            225944454,
            225937163,
            225922982,
            225921695,
            226083093,
            226083061,
            225937017,
            225941961,
            225925562,
            226022851,
            225923156
        ],
        "G": [
            226095099,
            226164597,
            226979660,
            226967841,
            230907178
        ]
    },
    "name": "D. Jellyfish and Miku",
    "statement": "There are n + 1 cities with numbers from 0 to n, connected by n roads.\r\nThe i-th (1\r\nleq i\r\nleq n) road connects city i-1 and city i bi-directionally. After\r\nJellyfish flew back to city 0, she found out that she had left her Miku\r\nfufu in city n.Each road has a level of . Denote the beauty of the i-th\r\nroad as a_i.Jellyfish is trying to find her fufu. Because of her poor\r\nsense of direction, she doesn\u2019t know which way to go. Every day, she\r\nrandomly chooses a road connected to the city she currently is in and\r\ntraverses it. Let s be the sum of the beauty of the roads connected to\r\nthe current city. For each road connected to the current city, Jellyfish\r\nwill traverse the road with a probability of\r\nfrac x s, where x is the beauty of the road, reaching the city on the\r\nother side of the road.Jellyfish will start at city 0, and she will get\r\nonly her fufu back when she reaches city n.You want to choose the beauty\r\nof the roads such that the expected number of days Jellyfish takes to\r\nfind her fufu will be the minimum possible. However, due to limited\r\nfunding, the sum of beauties of all roads must be less than or equal to\r\nm. Find the minimum expected number of days Jellyfish needs to get her\r\nfufu back if the beauty of the roads is chosen optimally.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 3007;\ndouble dp[N], ndp[N];\ndouble w[N], val[N];\nint n, m;\n\ninline double calc(int x, int y) {\n\treturn y > x ? (double) x / (y - x) : 1e9;\n}\nvoid solve(int l, int r, int sl, int sr) {\n\tif(l > r) return;\n\tint mid = (l + r) >> 1, fto = 0; \n\tdouble w = 1e9;\n\tL(i, sl, min(mid - 1, sr)) if(dp[i] + calc(i, mid) < w) w = dp[i] + calc(i, mid), fto = i;\n\tndp[mid] = w;\n\tsolve(l, mid - 1, sl, fto);\n\tsolve(mid + 1, r, fto, sr);\n}\n\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcout.precision(12); cout << fixed;\n\tcin >> n >> m;\n\tL(j, 0, m) dp[j] = 1e9;\n\tdp[0] = 0;\n\tL(i, 1, n) {\n\t\tL(j, 0, m) ndp[j] = 1e9;\n\t\tsolve(i, m, i - 1, m);\n\t\tswap(dp, ndp);\n\t}\n\tcout << dp[m] * 2 + n << '\\n'; \n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Jellyfish and Miku.json",
    "editorial_link": "https://codeforces.com//blog/entry/120943",
    "editorial": "TutorialLet\u00e2\u0080\u0099s assume that is given. We can use dynamic programming to\r\nsolve the problem.Let\u00e2\u0080\u0099s define as the expected number of days Jellyfish\r\nneeds to reach city from city .We will have: Let\u00e2\u0080\u0099s make it better: What\r\ndoes this inspire us to do? Let\u00e2\u0080\u0099s define , then we will get: By\r\ninduction, we will find . According to the definition, .Then we can use\r\ndynamic programming to solve the problem itself.Let\u00e2\u0080\u0099s define , then\r\n.Let\u00e2\u0080\u0099s define as the minimum value of when .We transit by enumerating\r\nthe values of , The transition is: .But the time complexity is , how can\r\nit becomes faster?Let\u00e2\u0080\u0099s take a closer look at . If there exists\r\nsatisfying . We can swap and , the answer will be better! so is a\r\nnon-decreasing array, which means .Because is , so if we only enumerate\r\nthe possible values of the time complexity will be .Time complexity:\r\nMemory complexity:\r\n"
}