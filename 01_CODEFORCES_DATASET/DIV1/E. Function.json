{"link": "https://codeforces.com//contest/455/problem/E", "problemId": "12121", "problem_idx": "E", "shortId": "455E", "contest_number": "455", "problem_submissions": {"E": [7394351, 7390143, 7393335, 7395556, 15950366, 7394387, 7394798], "D": [7390969, 7390195, 7391117, 7392248, 7394913, 7394348, 7389780, 7389657, 7393511, 7427462, 7392513, 7396567], "C": [7383856, 7385374, 7383929, 7385253, 7385742, 7386825, 7385353, 7386072, 7389234, 7384477, 7386261, 7393242, 7386556, 148174431, 7387128, 7390044, 7381535, 7386375, 7388516, 7385462], "B": [7380394, 7383005, 7381184, 7382059, 7379729, 7383546, 7382905, 7382344, 7384255, 7398378, 7387760, 7396316, 7385727, 7384109, 7413972, 7384883, 7405728, 7405656, 7398462, 7398419, 7381057], "A": [7377249, 7377722, 7377369, 7377768, 7390843, 7377960, 7377218, 7378095, 7377940, 7377402, 7377315, 7378476, 7377536, 7377288, 7378601, 7384879, 7385848, 7377439, 7377794]}, "name": "E. Function", "statement": "Serega and Fedor play with functions. One day they came across a very\r\ninteresting function. It looks like that: , . , , . Here is an integer\r\narray of length .Serega and Fedya want to know what values this function\r\ntakes at some points. But they don\u2019t want to calculate the values\r\nmanually. So they ask you to help them.\r\n", "solutions": ["#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 400010;\n\ndouble inter(pair <int, int> a, pair <int, int> b) {\n  return 1.0 * (b.second - a.second) / (a.first - b.first);\n}\n\nvector < pair <int, int> > st;\ndouble sx[N];\nint len;\n\nvoid init() {\n  st.clear();\n  len = 0;\n}\n\nvoid add(pair <int, int> u) {\n  while (len >= 2) {\n    double xx = inter(st[len - 1], u);\n    if (xx > sx[len - 2]) {\n      break;\n    }\n    st.pop_back();\n    len--;\n  }\n  if (len >= 1) {\n    sx[len - 1] = inter(st[len - 1], u);\n  }\n  st.push_back(u);\n  len++;\n}\n\nvector < pair <int, int> > p[N];\nint sz[N];\n\nint k[N], b[N];\n\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    p[x].push_back(make_pair(k[l], b[l]));\n    return;\n  }\n  int y = (l + r) >> 1;\n  build(x + x, l, y);\n  build(x + x + 1, y + 1, r);\n  init();\n  int ci = x + x, cj = x + x + 1;\n  int si = p[ci].size(), sj = p[cj].size();\n  int i = 0, j = 0;\n  while (i < si || j < sj) {\n    if (i == si) {\n      add(p[cj][j]);\n      j++;\n      continue;\n    }\n    if (j == sj) {\n      add(p[ci][i]);\n      i++;\n      continue;\n    }\n    if (p[ci][i].first == p[cj][j].first) {\n      if (p[ci][i].second < p[cj][j].second) {\n        add(p[ci][i]);\n      } else {\n        add(p[cj][j]);\n      }\n      i++; j++;\n      continue;\n    }\n    if (p[ci][i].first > p[cj][j].first) {\n      add(p[ci][i]);\n      i++;\n    } else {\n      add(p[cj][j]);\n      j++;\n    }\n  }\n  p[x] = st;\n  sz[x] = len;\n}\n\nint ptr[N];\n\nint ans;\n\nvoid solve(int x, int l, int r, int ll, int rr) {\n  if (l >= ll && r <= rr) {\n    int point = ll - 1;\n    int u = p[x][ptr[x]].first * point + p[x][ptr[x]].second;\n    if (u < ans) {\n      ans = u;\n    }\n    while (ptr[x] + 1 < sz[x]) {\n      int v = p[x][ptr[x] + 1].first * point + p[x][ptr[x] + 1].second;\n      if (v < ans) {\n        ans = v;\n      }\n      if (v <= u) {\n        ptr[x]++;\n        u = v;\n      } else {\n        break;\n      }\n    }\n    return;\n  }\n  int y = (l + r) >> 1;\n  if (ll <= y) {\n    solve(x + x, l, y, ll, rr);\n  }\n  if (y + 1 <= rr) {\n    solve(x + x + 1, y + 1, r, ll, rr);\n  }\n}\n\nint a[N], s[N];\n\npair < pair <int, int>, pair <int, int> > queries[N];\n\nint result[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  s[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", a + i);\n    s[i] = s[i - 1] + a[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    k[i] = -a[i];\n    b[i] = a[i] * (i - 1) - s[i - 1];\n  }\n  for (int i = 0; i < N; i++) {\n    p[i].clear();\n  }\n  build(1, 1, n);\n  memset(ptr, 0, sizeof(ptr));\n  int tt;\n  scanf(\"%d\", &tt);\n  for (int qq = 0; qq < tt; qq++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    queries[qq] = make_pair(make_pair(y - x, qq), make_pair(x, y));\n  }\n  sort(queries, queries + tt);\n  for (int qq = 0; qq < tt; qq++) {\n    int x = queries[qq].second.first;\n    int y = queries[qq].second.second;\n    ans = (int)2.1e9;\n    solve(1, 1, n, y - x + 1, y);\n    result[queries[qq].first.second] = s[y] + ans;\n  }\n  for (int qq = 0; qq < tt; qq++) {\n    printf(\"%d\\n\", result[qq]);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2900", "interactive": false}