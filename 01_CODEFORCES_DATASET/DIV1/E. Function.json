{
    "link": "https://codeforces.com//contest/455/problem/E",
    "problemId": "12121",
    "problem_idx": "E",
    "shortId": "455E",
    "contest_number": "455",
    "problem_submissions": {
        "E": [
            7394351,
            7390143,
            7393335,
            7395556,
            15950366,
            7394387,
            7394798
        ],
        "D": [
            7390969,
            7390195,
            7391117,
            7392248,
            7394913,
            7394348,
            7389780,
            7389657,
            7393511,
            7427462,
            7392513,
            7396567
        ],
        "C": [
            7383856,
            7385374,
            7383929,
            7385253,
            7385742,
            7386825,
            7385353,
            7386072,
            7389234,
            7384477,
            7386261,
            7393242,
            7386556,
            148174431,
            7387128,
            7390044,
            7381535,
            7386375,
            7388516,
            7385462
        ],
        "B": [
            7380394,
            7383005,
            7381184,
            7382059,
            7379729,
            7383546,
            7382905,
            7382344,
            7384255,
            7398378,
            7387760,
            7396316,
            7385727,
            7384109,
            7413972,
            7384883,
            7405728,
            7405656,
            7398462,
            7398419,
            7381057
        ],
        "A": [
            7377249,
            7377722,
            7377369,
            7377768,
            7390843,
            7377960,
            7377218,
            7378095,
            7377940,
            7377402,
            7377315,
            7378476,
            7377536,
            7377288,
            7378601,
            7384879,
            7385848,
            7377439,
            7377794
        ]
    },
    "name": "E. Function",
    "statement": "Serega and Fedor play with functions. One day they came across a very\r\ninteresting function. It looks like that: , . , , . Here is an integer\r\narray of length .Serega and Fedya want to know what values this function\r\ntakes at some points. But they don’t want to calculate the values\r\nmanually. So they ask you to help them.\r\n",
    "solutions": [
        "#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 400010;\n\ndouble inter(pair <int, int> a, pair <int, int> b) {\n  return 1.0 * (b.second - a.second) / (a.first - b.first);\n}\n\nvector < pair <int, int> > st;\ndouble sx[N];\nint len;\n\nvoid init() {\n  st.clear();\n  len = 0;\n}\n\nvoid add(pair <int, int> u) {\n  while (len >= 2) {\n    double xx = inter(st[len - 1], u);\n    if (xx > sx[len - 2]) {\n      break;\n    }\n    st.pop_back();\n    len--;\n  }\n  if (len >= 1) {\n    sx[len - 1] = inter(st[len - 1], u);\n  }\n  st.push_back(u);\n  len++;\n}\n\nvector < pair <int, int> > p[N];\nint sz[N];\n\nint k[N], b[N];\n\nvoid build(int x, int l, int r) {\n  if (l == r) {\n    p[x].push_back(make_pair(k[l], b[l]));\n    return;\n  }\n  int y = (l + r) >> 1;\n  build(x + x, l, y);\n  build(x + x + 1, y + 1, r);\n  init();\n  int ci = x + x, cj = x + x + 1;\n  int si = p[ci].size(), sj = p[cj].size();\n  int i = 0, j = 0;\n  while (i < si || j < sj) {\n    if (i == si) {\n      add(p[cj][j]);\n      j++;\n      continue;\n    }\n    if (j == sj) {\n      add(p[ci][i]);\n      i++;\n      continue;\n    }\n    if (p[ci][i].first == p[cj][j].first) {\n      if (p[ci][i].second < p[cj][j].second) {\n        add(p[ci][i]);\n      } else {\n        add(p[cj][j]);\n      }\n      i++; j++;\n      continue;\n    }\n    if (p[ci][i].first > p[cj][j].first) {\n      add(p[ci][i]);\n      i++;\n    } else {\n      add(p[cj][j]);\n      j++;\n    }\n  }\n  p[x] = st;\n  sz[x] = len;\n}\n\nint ptr[N];\n\nint ans;\n\nvoid solve(int x, int l, int r, int ll, int rr) {\n  if (l >= ll && r <= rr) {\n    int point = ll - 1;\n    int u = p[x][ptr[x]].first * point + p[x][ptr[x]].second;\n    if (u < ans) {\n      ans = u;\n    }\n    while (ptr[x] + 1 < sz[x]) {\n      int v = p[x][ptr[x] + 1].first * point + p[x][ptr[x] + 1].second;\n      if (v < ans) {\n        ans = v;\n      }\n      if (v <= u) {\n        ptr[x]++;\n        u = v;\n      } else {\n        break;\n      }\n    }\n    return;\n  }\n  int y = (l + r) >> 1;\n  if (ll <= y) {\n    solve(x + x, l, y, ll, rr);\n  }\n  if (y + 1 <= rr) {\n    solve(x + x + 1, y + 1, r, ll, rr);\n  }\n}\n\nint a[N], s[N];\n\npair < pair <int, int>, pair <int, int> > queries[N];\n\nint result[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  s[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", a + i);\n    s[i] = s[i - 1] + a[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    k[i] = -a[i];\n    b[i] = a[i] * (i - 1) - s[i - 1];\n  }\n  for (int i = 0; i < N; i++) {\n    p[i].clear();\n  }\n  build(1, 1, n);\n  memset(ptr, 0, sizeof(ptr));\n  int tt;\n  scanf(\"%d\", &tt);\n  for (int qq = 0; qq < tt; qq++) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    queries[qq] = make_pair(make_pair(y - x, qq), make_pair(x, y));\n  }\n  sort(queries, queries + tt);\n  for (int qq = 0; qq < tt; qq++) {\n    int x = queries[qq].second.first;\n    int y = queries[qq].second.second;\n    ans = (int)2.1e9;\n    solve(1, 1, n, y - x + 1, y);\n    result[queries[qq].first.second] = s[y] + ans;\n  }\n  for (int qq = 0; qq < tt; qq++) {\n    printf(\"%d\\n\", result[qq]);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Function.json",
    "editorial_link": "https://codeforces.com//blog/entry/13336",
    "editorial": "Solutions: 7407711, 7452418; In this problem you should quickly be able\r\nto compute the function described in the statement. You may notice that\r\nthis task is equivalent to next task: Go through the array , starting\r\nfrom the position of , making step. Step might be: step to the left or\r\nto stay in place. Function is calculated as follows: , how many times we\r\nvisited the th element of the array . For a fixed is clear, it is most\r\noptimally that a minimum on the interval has been visited by times, and\r\nall the other numbers once. You may notice that optimally to was a\r\nminimum. From all this we can conclude that for a fixed answer is ,\r\nwhere an array of prefix sums of array . Above formula can be written as\r\nfollows: You may notice that in brackets something like the equation of\r\nthe line . Thatâs very similar to the equation of the line: , where , ,\r\n. Now we must find minimum for all and fixed . We have lines, i. e. for\r\nevery element in array one line . Answer for query equal to: , where -th\r\nline. , . For fast answer calculation we must use Convex Hull Trick with\r\nsegment tree. In every vertex of segment tree we keep all lines for\r\nsegment of this vertex. This requires space, because each line lies in\r\nvertices. And we can answer query in operations. Because we visit\r\nvertices and each vertex need in operations. You can learn the theory\r\nabout Convex Hull Trick here.\r\n",
    "hint": []
}