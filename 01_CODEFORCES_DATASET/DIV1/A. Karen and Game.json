{"link": "https://codeforces.com//contest/815/problem/A", "problemId": "110359", "problem_idx": "A", "shortId": "815A", "contest_number": "815", "problem_submissions": {"B": [27864858, 27859364, 27903526, 27860492, 27852460, 27855418, 27859767, 27852085, 27859930, 27859903, 27854384, 27858144, 27855716, 27857016, 27852895, 27853886], "E": [27862063, 27864392, 27859827, 27862681, 27864496, 27861206, 27867128, 27865357, 27880319, 27880161], "D": [27858987, 27856145, 27857852, 27860187, 27858848, 27861659, 27861479, 27862104, 27862042, 27861841, 27863258, 27862833, 27864478, 27862444, 27863816, 27862729], "C": [27854913, 27853891, 27854000, 27853599, 27853527, 27856985, 27855683, 27858430, 27852703, 27859114, 27854140, 27852346, 27858894, 27853926, 27859017, 27859597, 27856510, 27857717], "A": [27848955, 27860238, 27848568, 27848584, 27855106, 27849560, 27848196, 27849865, 27848239, 27854177, 27850649, 27854333, 27856456, 27849527, 27857857]}, "name": "A. Karen and Game", "statement": "On the way to school, Karen became fixated on the puzzle game on her\r\nphone! The game is played as follows. In each level, you have a grid\r\nwith rows and columns. Each cell originally contains the number .One\r\nmove consists of choosing one row or column, and adding to all of the\r\ncells in that row or column.To win the level, after all the moves, the\r\nnumber in the cell at the -th row and -th column should be equal to\r\n.Karen is stuck on one level, and wants to know a way to beat this level\r\nusing the minimum number of moves. Please, help her with this task!\r\n", "solutions": ["//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=107;\nconst int inf=1e6;\n\nint n, m;\n\nint tab[nax][nax];\n\nvector < pair <int,int> > wek;\n\nvoid check()\n{\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tif (tab[i][j])\n\t\t\t{\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tscanf(\"%d\", &tab[i][j]);\n\t\t\t\n\tint naj=inf;\n\tfor (int i=1; i<=m; i++)\n\t\tnaj=min(naj, tab[1][i]);\n\t\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\twhile(tab[1][i]!=naj)\n\t\t{\n\t\t\tfor (int j=1; j<=n; j++)\n\t\t\t\ttab[j][i]--;\n\t\t\twek.push_back({0, i});\n\t\t}\n\t}\n\tnaj=inf;\n\tfor (int i=1; i<=n; i++)\n\t\tnaj=min(naj, tab[i][1]);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twhile(tab[i][1]!=naj)\n\t\t{\n\t\t\tfor (int j=1; j<=m; j++)\n\t\t\t\ttab[i][j]--;\n\t\t\twek.push_back({1, i});\n\t\t}\n\t}\n\t\n\tnaj=tab[1][1];\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\ttab[i][j]-=naj;\n\t\n\tif (n<m)\n\t{\n\t\tfor (int i=1; i<=n; i++)\t\n\t\t\tfor (int j=1; j<=naj; j++)\n\t\t\t\twek.push_back({1, i});\n\t}\n\telse\n\t{\n\t\tfor (int i=1; i<=m; i++)\t\n\t\t\tfor (int j=1; j<=naj; j++)\n\t\t\t\twek.push_back({0, i});\n\t}\n\t\n\tcheck();\n\tprintf(\"%d\\n\", (int)wek.size());\n\tfor (auto i : wek)\n\t{\n\t\tif (i.first)\n\t\t\tprintf(\"row \");\n\t\telse\n\t\t\tprintf(\"col \");\n\t\tprintf(\"%d\\n\", i.second);\n\t}\n\t\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "greedy", "implementation"], "dificulty": "1700", "interactive": false}