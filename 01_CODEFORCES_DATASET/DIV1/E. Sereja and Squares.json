{"link": "https://codeforces.com//contest/314/problem/E", "problemId": "3142", "problem_idx": "E", "shortId": "314E", "contest_number": "314", "problem_submissions": {"E": [30724544, 3841662, 3843754, 3843819, 3841502, 3860384, 3934694, 3845808], "D": [3838247, 3837490, 3833649, 3839672, 3836920, 3843899, 3843892, 3843887, 3839403, 3837634, 3841257, 3841298, 3842000, 3842070, 3840998, 3841422, 3840708, 3840797, 3839070, 3842300, 3841251], "C": [3835839, 3835172, 3835831, 3837510, 3837765, 3834791, 3833737, 3838762, 3839170, 3839102, 3834408, 3840072, 3836332, 3840999, 3838170, 3838751, 3836736, 3840325, 3839207, 3832923], "B": [3832474, 3833450, 3837630, 3835590, 3835615, 3836583, 3840262, 3835730, 3832871, 3835097, 3839185, 3834451, 3840037, 3832621, 3841872, 3837653, 3838448, 3841898, 3834701], "A": [3832264, 3841936, 3833100, 3832334, 3832542, 3835485, 3832690, 3839877, 3833260, 3832812, 3838983, 3836728, 3832398, 3833247, 3833000, 3833823, 3833650, 3835970]}, "name": "E. Sereja and Squares", "statement": "Sereja painted points on the plane, point number has coordinates . Then\r\nSereja marked each point with a small or large English letter. Sereja\r\ndon\u2019t like letter \"\", so he didn\u2019t use it to mark points. Sereja thinks\r\nthat the points are marked beautifully if the following conditions\r\nholds: all points can be divided into pairs so that each point will\r\nbelong to exactly one pair; in each pair the point with the lesser\r\nabscissa will be marked with a small English letter and the point with\r\nthe larger abscissa will be marked with the same large English letter;\r\nif we built a square on each pair, the pair\u2019s points will be the\r\nsquare\u2019s opposite points and the segment between them will be the\r\nsquare\u2019s diagonal, then among the resulting squares there won\u2019t be any\r\nintersecting or touching ones. Little Petya erased some small and all\r\nlarge letters marking the points. Now Sereja wonders how many ways are\r\nthere to return the removed letters so that the points were marked\r\nbeautifully.\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <complex>\n#include <sstream>\nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n \n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SIZE(c) ((int)((c).size()))\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n#define ALL(v) (v).begin(), (v).end()\n \n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MAXN = 1<<18;\nconst int MAGIC = 100000;\n\nint N;\n\nchar S[MAXN];\nunsigned int T[MAXN];\nint pleft[MAXN];\n\nunsigned brute() {\n    pleft[N] = 0;\n    FORD(i,N,0) {\n        pleft[i] = pleft[i+1];\n        if (S[i] == '?') ++pleft[i]; else --pleft[i];\n    }\n\n    T[0] = 1;\n    int L = 0, R = 0;\n    REP(i,N) {\n        FORD(j,R+2,L+1) T[j] = T[j-1];//[L+1,R+1];\n        T[L] = 0;        \n        ++L, ++R;\n        \n        if (S[i] == '?') {\n            L = max(0, L-2);\n            FOR(j,L,R+1) T[j] += T[j+2];        \n        }\n\n        while (R > pleft[i+1] + 1) {\n            T[R--] = 0;\n        }\n        \n\n    }\n    \n    unsigned int res = T[0];\n    REP(i,pleft[0] / 2) res *= 25;\n\n    return res;\n}\n\nint main() {\n    scanf(\"%d%s\",&N,S);\n    if (N%2) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    unsigned int r = brute();\n    printf(\"%u\\n\",r);\n}    "], "input": "", "output": "", "tags": ["dp"], "dificulty": "2900", "interactive": false}