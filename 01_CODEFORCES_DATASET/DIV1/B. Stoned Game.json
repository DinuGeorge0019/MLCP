{
    "link": "https://codeforces.com//contest/1396/problem/B",
    "problemId": "712375",
    "problem_idx": "B",
    "shortId": "1396B",
    "contest_number": "1396",
    "problem_submissions": {
        "E": [
            91420325,
            91433351,
            91395963,
            91403549,
            91401123,
            91402411,
            91409596,
            91414724,
            91398509,
            91431034,
            98258243,
            91413242,
            91418927,
            91416810,
            100070579,
            100069379,
            91404326
        ],
        "D": [
            91388366,
            91423836,
            91402660,
            91943822,
            91410504,
            91407249,
            91405665,
            91404955,
            92387331,
            91409139,
            91420254
        ],
        "C": [
            91373061,
            91380961,
            91375173,
            91383628,
            91383246,
            91370624,
            91378488,
            91375423,
            91372747,
            91401459,
            91603982,
            91437619,
            91381246,
            91378361,
            91395543,
            91392372,
            91380457,
            91391062,
            91392240,
            91390152,
            91380894
        ],
        "B": [
            91358979,
            91360664,
            91363530,
            91358594,
            91358724,
            91359119,
            91363085,
            91359172,
            91358745,
            91363826,
            91362155,
            91366158,
            91362751,
            91365359,
            91360322,
            91364106,
            91365992,
            91378262,
            91361724,
            91365744
        ],
        "A": [
            91354401,
            91357111,
            91359227,
            91352552,
            91352349,
            91355053,
            91358883,
            91356416,
            91355726,
            91357237,
            91356536,
            91360026,
            91358794,
            91362354,
            91356173,
            91360020,
            91356069,
            91361174,
            91357755,
            91354128
        ]
    },
    "name": "B. Stoned Game",
    "statement": "T is playing a game with his friend, HL.There are n piles of stones, the\r\ni-th pile initially has a_i stones. T and HL will take alternating\r\nturns, with T going first. In each turn, a player chooses a non-empty\r\npile and then removes a single stone from it. However, one cannot choose\r\na pile that has been chosen in the previous turn (the pile that was\r\nchosen by the other player, or if the current turn is the first turn\r\nthen the player can choose any non-empty pile). The player who cannot\r\nchoose a pile in his turn loses, and the game ends.Assuming both players\r\nplay optimally, given the starting configuration of t games, determine\r\nthe winner of each game.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 30.08.2020 17:42:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int mx = *max_element(a.begin(), a.end());\n    int sum = accumulate(a.begin(), a.end(), 0);\n    if (mx > sum - mx || sum % 2 == 1) {\n      cout << \"T\" << '\\n';\n    } else {\n      cout << \"HL\" << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "games",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Stoned Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/82142",
    "editorial": "Let denote a rectangle with opposite corners and . For convenience,\r\nassume and .Letâs try solving the problem if coordinates are in range .\r\nWe could easily do this by coordinates compression.First, letâs look at\r\nthe problem with fixed. We define to be the smallest integer such that\r\nand is a rectangle (If there is no such integer, let ). It can be proven\r\nthat is non-decreasing, i.e. if , then .Now, letâs see how changes when\r\nwe iterate over a fixed . It is hard to add points to the set, so we\r\nwill try to support deleting points operation. For point , we have the\r\nfollowing definitions:Let set . Let with the largest .Let set . Let with\r\nthe smallest .(Note that or might represent empty set).With these two\r\nfunctions, we could see how changes after we delete point . It looks\r\nsomething like this: For every such that ;We could support this\r\noperation using segment tree with lazy propagation. The total time\r\ncomplexity is .\r\n",
    "hint": []
}