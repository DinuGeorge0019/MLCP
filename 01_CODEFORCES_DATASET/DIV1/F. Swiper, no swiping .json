{
    "link": "https://codeforces.com//contest/1239/problem/F",
    "problemId": "445274",
    "problem_idx": "F",
    "shortId": "1239F",
    "contest_number": "1239",
    "problem_submissions": {
        "E": [
            63001388,
            63007812,
            63001212,
            62998603,
            62990662,
            63117343,
            63007827,
            63012207,
            63007702,
            63021047,
            63020870,
            63040886
        ],
        "D": [
            62993444,
            63002135,
            62996508,
            63001623,
            62995711,
            62993045,
            63000352,
            62994034,
            62999922,
            62999498,
            63002761,
            62998053,
            63001594,
            63004252,
            63000233,
            63002463,
            63005010,
            63003977,
            62998357
        ],
        "B": [
            62989194,
            62990960,
            62989442,
            62985984,
            62996888,
            63004499,
            62991996,
            62990441,
            62993848,
            62995834,
            62994077,
            62994574,
            62993602,
            63006960,
            62992838,
            62991953,
            62991668,
            63005078
        ],
        "A": [
            62977858,
            62978636,
            62977879,
            62980136,
            62977536,
            62989410,
            62977583,
            62981078,
            62979832,
            62980911,
            62979401,
            62984325,
            62979180,
            62979930,
            62979559,
            62978773,
            62979723,
            62981340,
            62977762,
            62982272
        ],
        "F": [
            63121011,
            63120329,
            63015127,
            63015060,
            63092303,
            63016718,
            63113841,
            63051142
        ],
        "C": [
            62999891,
            62991092,
            62996408,
            62989929,
            62996641,
            62997220,
            62997894,
            63001762,
            62998162,
            62999500,
            63034189,
            62998511,
            62992701,
            62998753,
            62995987,
            62998509,
            62994268
        ]
    },
    "name": "F. Swiper, no swiping ",
    "statement": "I\u2019m the Map, I\u2019m the Map! I\u2019m the MAP!!!MapIn anticipation of new\r\nadventures Boots wanted to do a good deed. After discussion with the Map\r\nand Backpack, they decided to gift Dora a connected graph. After a long\r\nsearch, Boots chose t graph\u2019s variants, which Dora might like. However\r\nfox Swiper wants to spoil his plan.The Swiper knows, that Dora now is\r\nonly able to count up to 3, so he has came up with a following idea. He\r\nwants to steal some non-empty set of vertices, so that the Dora won\u2019t\r\nnotice the loss. He has decided to steal some non-empty set of vertices,\r\nso that after deletion of the stolen vertices and edges adjacent to\r\nthem, every vertex wouldn\u2019t change it\u2019s degree modulo 3. The degree of a\r\nvertex is the number of edges it is adjacent to. It would\u2019ve been\r\nsuspicious to steal all the vertices, so Swiper needs another plan.Boots\r\nare sure, that the crime can not be allowed. However they are afraid,\r\nthat they won\u2019t be able to handle this alone. So Boots decided to ask\r\nfor your help. Please determine for every graph\u2019s variant whether the\r\nSwiper can perform the theft or not.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n#include <complex>\n \n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> pii;\n \nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n \nconst int N = 1000001;\nint n,m,x,y;\nvector<int> v[N];\n \nqueue<int> q;\nint dis[N];\nint prv[N];\nbool vst[N];\nbool ans[N]; \nint idx;\n \npii Z={0,0};\npii dfs(int cur, int prv, int h) {\n\tif(cur==h) return Z;\n\tif(vst[cur]) return {cur, prv};\n\tvst[cur]=true;\n\tfor(int nxt : v[cur]) {\n\t\tif(nxt==prv) continue;\n\t\tpii temp=dfs(nxt, cur, h);\n\t\tif(temp!=Z) return temp;\n\t}\n\treturn Z;\n}\nvoid print();\nbool findCycle(int h) {\n\tfor(int i=1; i<=n; i++) vst[i]=false;\n\tfor(int i=1; i<=n; i++) {\n\t\tif(vst[i]) continue;\n\t\tpii c=dfs(i,0,h);\n\t\tif(c!=Z){\n\t\t\t//i->c min path\n\t\t\tint s=c.first, e=c.second;\n\t\t\tfor(int j=1; j<=n; j++) dis[j]=INF;\n\t\t\tdis[s]=0;\n\t\t\tq.push(s);\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint cur=q.front(); q.pop();\n\t\t\t\tfor(int nxt : v[cur]) {\n\t\t\t\t\tif(cur==s && nxt==e) continue;\n\t\t\t\t\tif(cur==h) continue;\n\t\t\t\t\tif(dis[nxt]==INF) dis[nxt]=dis[cur]+1, prv[nxt]=cur, q.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=e; j!=s; j=prv[j]) ans[j]=true;\n\t\t\tans[s]=true;\n\t\t\tprint();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid print() {\n\tprintf(\"Yes\\n\");\n\tint cnt=0;\n\tfor(int i=1; i<=n; i++) if(!ans[i]) cnt++;\n\tprintf(\"%d\\n\", cnt);\n\tfor(int i=1; i<=n; i++) if(!ans[i]) printf(\"%d \", i);\n\tprintf(\"\\n\");\n}\nvoid mark(int cur) {\n\tif(ans[cur]) return;\n\tans[cur]=true;\n\tfor(int nxt : v[cur]) mark(nxt);\n}\nvoid unmark(int cur, int x, int y) {\n\tif(cur==x || cur==y) return;\n\tif(!ans[cur]) return;\n\tans[cur]=false;\n\tfor(int nxt : v[cur]) unmark(nxt,x,y);\n}\nvoid case1() {\n\tfor(int i=1; i<=n; i++) {\n\t\tif(sz(v[i])%3==1) {\n\t\t\tfor(int i=1; i<=n; i++) dis[i]=INF;\n\t\t\tdis[i]=0;\n\t\t\tq.push(i);\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint cur=q.front(); q.pop();\n\t\t\t\tfor(int nxt : v[cur]) if(dis[nxt]==INF) dis[nxt]=dis[cur]+1, prv[nxt]=cur, q.push(nxt);\n\t\t\t}\n\t\t\t\n\t\t\tint tt=INF;\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t    if(i!=j && sz(v[j])%3==1) tt=min(tt, dis[j]);\n\t\t\t}\n\t\t\tif(tt==n-1) {printf(\"No\\n\"); return;}\n\t\t\t\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\tif(i!=j && sz(v[j])%3==1 && dis[j]==tt) {\n\t\t\t\t\t\n\t\t\t\t\tfor(int c=j; c!=i; c=prv[c]) {\n\t\t\t\t\t\tans[c]=true;\n\t\t\t\t\t}\n\t\t\t\t\tans[i]=true;\n\t\t\t\t\tprint();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\nvoid case2() {\n\tfor(int i=1; i<=n; i++) if(sz(v[i])%3==1) {idx=i; break;}\n\n\tif(findCycle(idx)) return;\n\n\tfor(int i=1; i<=n; i++) {\n\t\tif(i==idx) continue;\n\t\tif(sz(v[i])>3) {\n\t\t\tfor(int i=1; i<=n; i++) ans[i]=true;\n\t\t\tint c=0;\n\t\t\tfor(int j=0; c<3; j++) {\n\t\t\t\tif(v[i][j]==idx) continue;\n\t\t\t\tunmark(v[i][j], i, idx);\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tprint();\n\t\t\treturn;\n\t\t}\n\t}\n\tif(sz(v[idx])==4) {printf(\"No\\n\"); return;} //clear\n\tans[idx]=true;\n\tint t=0;\n\tfor(int i=0; t<2; i++) {\n\t\tif(ans[v[idx][i]]) continue;\n\t\tmark(v[idx][i]);\n\t\tt++;\n\t}\n\tprint();\n}\nvoid case3() {\n\tbool flag=true;\n\tfor(int i=1; i<=n; i++) if(sz(v[i])!=2) {flag=false; break;}\n\tif(flag) {printf(\"No\\n\"); return;}\n\tfindCycle(0);\n}\nvoid proc() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i=1; i<=n; i++) v[i].clear(), ans[i]=false;\n\tfor(int i=0; i<m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\n\tif(n==1) {printf(\"No\\n\"); return;}\n\tfor(int i=1; i<=n; i++) {\n\t\tif(sz(v[i])%3==0) {\n\t\t\tans[i]=true;\n\t\t\tprint();\n\t\t\treturn;\n\t\t}\n\t}\n \n\tint cnt=0;\n\tfor(int i=1; i<=n; i++) if(sz(v[i])%3==1) cnt++;\n\tif(cnt>1) case1();\n\telse if(cnt==1) case2();\n\telse case3();\n\t\n}\nint main(void){\n\tint tc; scanf(\"%d\", &tc);\n\twhile(tc--) proc();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "implementation"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Swiper, no swiping .json",
    "editorial_link": "https://codeforces.com/blog/entry/70720",
    "editorial": "We will look only on set of vertex, that will stay after deleting.Let\r\nnode- node with degree equal .Let\u00e2\u0080\u0099s consider some cases: Node- exists.\r\nIt is the answer, except the case, when our graph consists of one node.\r\nCycle on nodes- exists. So exists irreducible cycle on nodes-. It is the\r\nanswer, except the case, when our graph is cycle. Way between nodes- on\r\nnodes- exists. So exists irreducible way with same conditions. It is the\r\nanswer, except the case, when our graph is way. Our graph contains one\r\nnode- and nodes- form forest. Let\u00e2\u0080\u0099s take two trees and delete all except\r\ntwo ways in this trees, such only endpoints are connected with node-.\r\nThose ways and node- are the answer, except the case, when our graph is\r\ntwho cycles with one common node. That\u00e2\u0080\u0099s all cases. Let\u00e2\u0080\u0099s show it:\r\nNodes- form forest. Exists at least one leaf, that is connected with\r\nnode-. So in that case node- always exists. Degree of node- equals sum\r\ndegree of nodes- minus doubled number of edges between nodes-. Let\r\nnumber of nodes-. So degree of node- equals . Contradiction. So forest\r\nconsist of at least two trees.\r\n"
}