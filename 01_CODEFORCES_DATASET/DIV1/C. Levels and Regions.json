{
    "link": "https://codeforces.com//contest/674/problem/C",
    "problemId": "59814",
    "problem_idx": "C",
    "shortId": "674C",
    "contest_number": "674",
    "problem_submissions": {
        "F": [
            17795703,
            17796640,
            17795248,
            17796731,
            17795284,
            17786875,
            17793312,
            17799447,
            17799059,
            17796927,
            17809648
        ],
        "E": [
            17791802,
            17792589,
            17793136,
            17792993,
            17792579,
            17790993,
            17797689,
            17793850,
            17793986,
            17790505,
            17793423,
            17807249,
            17795195,
            17795763,
            17827053,
            17796913
        ],
        "C": [
            17789698,
            17787708,
            17787067,
            17789946,
            17787511,
            17796571,
            17795757,
            17788550,
            17790663,
            17794959,
            17792670,
            17795899,
            17791267,
            17793511,
            17791551,
            17791808
        ],
        "B": [
            17783364,
            17783002,
            17794015,
            17783259,
            17783884,
            17783532,
            17788831,
            17784932,
            17787141,
            17784301,
            17785005,
            17785023,
            17784292,
            17783013,
            17783128,
            17786182,
            17784522
        ],
        "A": [
            17780055,
            17780264,
            17780741,
            17780847,
            17780248,
            17780121,
            17787726,
            17781230,
            17780294,
            17782551,
            17782250,
            17781088,
            17780155,
            17780065,
            17780569,
            17780629,
            17781843
        ],
        "D": [
            17798492,
            17808237
        ],
        "G": [
            17818293,
            17796240,
            17798313
        ]
    },
    "name": "C. Levels and Regions",
    "statement": "Radewoosh is playing a computer game. There are levels, numbered through\r\n. Levels are divided into regions (groups). Each region contains some\r\npositive number of consecutive levels.The game repeats the the following\r\nprocess: If all regions are beaten then the game ends immediately.\r\nOtherwise, the system finds the first region with at least one\r\nnon-beaten level. Let denote this region. The system creates an empty\r\nbag for tokens. Each token will represent one level and there may be\r\nmany tokens representing the same level. For each already beaten level\r\nin the region , the system adds tokens to the bag (tokens representing\r\nthe -th level). Let denote the first non-beaten level in the region .\r\nThe system adds tokens to the bag. Finally, the system takes a uniformly\r\nrandom token from the bag and a player starts the level represented by\r\nthe token. A player spends one hour and beats the level, even if he has\r\nalready beaten it in the past. Given , and values , your task is to\r\nsplit levels into regions. Each level must belong to exactly one region,\r\nand each region must contain non-empty consecutive set of levels. What\r\nis the minimum possible expected number of hours required to finish the\r\ngame?\r\n",
    "solutions": [
        "#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef long double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000;\ni64 a[maxn], ps[maxn];\nld sinv[maxn], P[maxn];\nld dp[2][maxn];\n\nld conv(pair<ld, ld> a, pair<ld, ld> b) {\n    return a.fi * b.fi + a.se * b.se;\n}\n\nbool ccw(pair<ld, ld> a, pair<ld, ld> b, pair<ld, ld> c) {\n    return (b.first - a.first) * (c.se - a.second) - (c.first - a.first) * (b.second - a.second) > 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, k;\n    cin >> n >> k;\n    forn(i, n) {\n        cin >> a[i];\n        ps[i + 1] = ps[i] + a[i];\n        sinv[i + 1] = sinv[i] + 1.0 / a[i];\n        P[i + 1] = P[i] + 1.0 * ps[i + 1] / a[i];\n    }\n    forn(i, n + 1) dp[0][i] = 1e18;\n    dp[0][0] = 0.0;\n    forn(j, k) {\n//        cerr << j << '\\n';\n        forn(i, n + 1) dp[1][i] = 1e18;\n        vector< pair<ld, ld> > st;\n        st.pb(mp(ps[j], dp[0][j] + ps[j] * sinv[j] - P[j]));\n        int opt = 0;\n        for (int i = j + 1; i <= n; ++i) {\n            pair<ld, ld> x = mp(-sinv[i], 1.0);\n            while (opt + 1 < st.size() && conv(x, st[opt]) > conv(x, st[opt + 1])) ++opt;\n            dp[1][i] = P[i] + conv(x, st[opt]);\n//            cerr << dp[1][i] << ' ';\n            pair<ld, ld> z = mp(ps[i], dp[0][i] + ps[i] * sinv[i] - P[i]);\n            while (st.size() > 1 && (!ccw(st[st.size() - 2], st.back(), z))) st.pop_back();\n            st.pb(z);\n        }\n//        cerr << '\\n';\n        forn(i, n + 1) dp[0][i] = dp[1][i];\n    }\n    cout << (double)dp[0][n] << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Levels and Regions.json",
    "editorial_link": "https://codeforces.com//blog/entry/44754",
    "editorial": "When we repeat something and each time we have probability p to succeed then the expected number or tries is , till we succeed. How to calculate the expected time for one region [low,?high]? For each i in some moment we will try to beat this level and then there will be S?=?tlow?+?tlow?+?1?+?...?+?ti tokens in the bag, including ti tokens allowing us to beat this new level. The probability to succeed is , so the expected time is . So, in total we should sum up values  for i?<?j. Ok, we managed to understand the actual problem. You can now stop and try to find a slow solution in O(n2·k). Hint: use the dynamic programming.\n\nLet dp[i][j] denote the optimal result for prefix of i levels, if we divide them into j regions.\nLet pre[i] denote the result for region containing levels 1,?2,?...,?i (think how to calculate it easily with one loop).\nLet sum[i] denote the sum of tj for all 1???j???i.\nLet rev[i] denote the sum of  for all 1???j???i.\nNow let's write formula for dp[i][j], as the minimum over l denoting the end of the previous region:\n\n\n\n\nSo we can use convex hull trick to calculate it in O(n·k). You should also get AC with a bit slower divide&conquer trick, if it's implemented carefully.",
    "hint": []
}