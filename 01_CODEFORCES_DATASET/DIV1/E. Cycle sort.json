{
    "link": "https://codeforces.com//contest/1012/problem/E",
    "problemId": "203195",
    "problem_idx": "E",
    "shortId": "1012E",
    "contest_number": "1012",
    "problem_submissions": {
        "D": [
            40965345,
            40960627,
            40962755,
            40958672,
            40960130,
            40960868,
            40957816,
            40962185,
            40977537,
            40977026,
            40958559,
            40961785,
            40963025,
            40963296,
            40964134,
            40968496,
            40964728
        ],
        "E": [
            40960617,
            40966609,
            40966430,
            40968315,
            40959955,
            40968344,
            41293524,
            40971324,
            40961945,
            40965219,
            40964178,
            40964935,
            40966686
        ],
        "C": [
            40946223,
            40950962,
            40949847,
            40947169,
            40948884,
            40951113,
            40948032,
            40950863,
            40949840,
            40948978,
            40950249,
            40944733,
            40947497,
            40951510,
            40946864,
            40950557,
            40948982,
            40953572,
            40952480,
            40955310
        ],
        "B": [
            40942792,
            40947068,
            40945179,
            40941414,
            40943485,
            40944363,
            40943466,
            40948512,
            40943709,
            40942617,
            40946516,
            40941822,
            40945156,
            40945233,
            40943297,
            40953601,
            40943064,
            40946807,
            40947838,
            40944988
        ],
        "A": [
            40940407,
            40940426,
            40944393,
            40940053,
            40941238,
            40941590,
            40941675,
            40939828,
            40941205,
            40939974,
            40940704,
            40939790,
            40943152,
            40941982,
            40942155,
            40942198,
            40952349,
            40943555,
            40944486,
            40941409
        ],
        "F": [
            41294072,
            40975225,
            40975082,
            48927133,
            48926928,
            48926890,
            48926661,
            48926482,
            48926274,
            48926240,
            48926110,
            48925986,
            48925954,
            48925448,
            48924606
        ]
    },
    "name": "E. Cycle sort",
    "statement": "You are given an array of n positive integers a_1, a_2,\r\ndots, a_n. You can perform the following operation any number of times:\r\nselect several distinct indices i_1, i_2,\r\ndots, i_k (1\r\nle i_j\r\nle n) and move the number standing at the position i_1 to the position\r\ni_2, the number at the position i_2 to the position i_3, ..., the number\r\nat the position i_k to the position i_1. In other words, the operation\r\ncyclically shifts elements: i_1\r\nto i_2\r\nto\r\nldots i_k\r\nto i_1.For example, if you have n=4, an array a_1=10, a_2=20, a_3=30,\r\na_4=40, and you choose three indices i_1=2, i_2=1, i_3=4, then the\r\nresulting array would become a_1=20, a_2=40, a_3=30, a_4=10.Your goal is\r\nto make the array sorted in non-decreasing order with the minimum number\r\nof operations. The additional constraint is that the sum of cycle\r\nlengths over all operations should be less than or equal to a number s.\r\nIf it\u2019s impossible to sort the array while satisfying that constraint,\r\nyour solution should report that as well.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 200600;\nint n, S;\nint a[N];\nint b[N];\nint xs[N];\nint k;\nvector<int> g[N];\nint m;\nvector<int> cycles[N];\nint p[N];\nbool used[N];\n\nvoid dfs(int v) {\n\twhile(!g[v].empty()) {\n\t\tint id = g[v].back();\n\t\tg[v].pop_back();\n\t\tdfs(a[id]);\n\t\tcycles[m].push_back(id);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &S);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\tsort(b, b + n);\n\tfor (int i = 0; i < n; i++)\n\t\txs[k++] = b[i];\n\tk = unique(xs, xs + k) - xs;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] = lower_bound(xs, xs + k, a[i]) - xs;\n\t\tb[i] = lower_bound(xs, xs + k, b[i]) - xs;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b[i]) continue;\n\t\tg[b[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tdfs(i);\n\t\tif (!cycles[m].empty()) m++;\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tS -= (int)cycles[i].size();\n\tif (S < 0) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tp[i] = i;\n\tfor (int id = 0; id < m; id++) {\n\t\tfor (int i = 0; i < (int)cycles[id].size(); i++) {\n\t\t\tint v = cycles[id][i], u = cycles[id][(i + 1) % (int)cycles[id].size()];\n\t\t\tp[u] = v;\n\t\t}\n\t}\n\tS = min(S, m);\n\tif (S > 1) {\n\t\tprintf(\"%d\\n\", 2 + m - S);\n\t\tprintf(\"%d\\n\", S);\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tprintf(\"%d \", cycles[i][0] + 1);\n\t\tprintf(\"\\n\");\n\t\tfor (int i = S - 1; i > 0; i--)\n\t\t\tswap(p[cycles[i][0]], p[cycles[i - 1][0]]);\n\t} else {\n\t\tprintf(\"%d\\n\", m);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tif (p[i] == i) {\n\t\t\tused[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> cur;\n\t\tint x = i;\n\t\twhile(!used[x]) {\n\t\t\tcur.push_back(x);\n\t\t\tused[x] = 1;\n\t\t\tx = p[x];\n\t\t}\n\t\tprintf(\"%d\\n\", (int)cur.size());\n\t\tfor (int z : cur)\n\t\t\tprintf(\"%d \", z + 1);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Cycle sort.json",
    "editorial_link": "https://codeforces.com/blog/entry/60920",
    "editorial": "Let\u00e2\u0080\u0099s solve an array if is permutation and the sum of cycle sizes is\r\nunlimited.It\u00e2\u0080\u0099s known that each permutation is composition of some\r\nnon-intersecting cycles. If permutation is sorted answer is . If\r\npermutation is cycle and some fixed indexes answer is , you should take\r\nthis cycle to get this answer. If permutation is composition of cycles\r\nanswer should be , because it\u00e2\u0080\u0099s impossible to use cycle. In this case\r\nit\u00e2\u0080\u0099s possible to make the answer with cycles. Let\u00e2\u0080\u0099s define inversed\r\npermutation for our permutation as composition of this cycles (all\r\ncycles, except cycles with length ). We can sort permutations using this\r\ncycles: (all cycles, written in a row) and (first elements of cycles in\r\ninversed order). This solution used sum of cycle sizes , there number of\r\nnon-fixed elements and number of cycles with size .Now let\u00e2\u0080\u0099s solve\r\nproblem for permutation, if we can use sum of cycle sizes . Each\r\nsolution should use sum of cycle sizes , because we should shift each\r\nnon-fixed element. So if answer is . Let\u00e2\u0080\u0099s call each cycle from cycles\r\nbad, if each of it\u00e2\u0080\u0099s element shifted exactly time in the answer. It can\r\nbe proved, that each bad cycle should be used in the answer. Let\u00e2\u0080\u0099s\r\ndefine as number of bad cycles and number of other cycles. So . Sum of\r\ncycles in the answer . So, ==> ==> . Number of cycles in the answer .\r\nIt\u00e2\u0080\u0099s true, because each of bad cycles are in answer and other cycles can\r\nbe sorted using cycles. We should take as maximal as possible, because\r\nif we increase by sum won\u00e2\u0080\u0099t increase. Minimal , that we can use is . So\r\nwe get (because ). So answer in this case if . We can build it, if we\r\nuse any of cycles, and for other cycles do same construction as in\r\nprevious case.Let\u00e2\u0080\u0099s solve problem for array. Let\u00e2\u0080\u0099s define as sorted\r\narray and as count of , such that . Our solution will sort some\r\npermutation , such that , for all . Answer for permutation is . In this\r\nformula fixed. So to minimize the answer we should minimize . So we\r\nshould sort array using array with as minumal as possible number of\r\ncycles. To do it let\u00e2\u0080\u0099s build directed graph: vertexes is number in\r\narray, let\u00e2\u0080\u0099s add edge from to for all , such that . It\u00e2\u0080\u0099s easy to see,\r\nthat we should take euler cycle in each component of this graph and\r\nbuild permutation with this cycles to make number of cycles in\r\npermutation as minimal as possible.To code this solution without\r\nbuilding graph let\u00e2\u0080\u0099s take first any sorting permutation. After that, we\r\ncan merge cycles. If and and in different cycles of permutation, we can\r\nmerge this cycles using . So let\u00e2\u0080\u0099s merge all possible cycles using DSU\r\nfor components.Time complexity: .\r\n"
}