{"link": "https://codeforces.com//contest/1012/problem/E", "problemId": "203195", "problem_idx": "E", "shortId": "1012E", "contest_number": "1012", "problem_submissions": {"D": [40965345, 40960627, 40962755, 40958672, 40960130, 40960868, 40957816, 40962185, 40977537, 40977026, 40958559, 40961785, 40963025, 40963296, 40964134, 40968496, 40964728], "E": [40960617, 40966609, 40966430, 40968315, 40959955, 40968344, 41293524, 40971324, 40961945, 40965219, 40964178, 40964935, 40966686], "C": [40946223, 40950962, 40949847, 40947169, 40948884, 40951113, 40948032, 40950863, 40949840, 40948978, 40950249, 40944733, 40947497, 40951510, 40946864, 40950557, 40948982, 40953572, 40952480, 40955310], "B": [40942792, 40947068, 40945179, 40941414, 40943485, 40944363, 40943466, 40948512, 40943709, 40942617, 40946516, 40941822, 40945156, 40945233, 40943297, 40953601, 40943064, 40946807, 40947838, 40944988], "A": [40940407, 40940426, 40944393, 40940053, 40941238, 40941590, 40941675, 40939828, 40941205, 40939974, 40940704, 40939790, 40943152, 40941982, 40942155, 40942198, 40952349, 40943555, 40944486, 40941409], "F": [41294072, 40975225, 40975082, 48927133, 48926928, 48926890, 48926661, 48926482, 48926274, 48926240, 48926110, 48925986, 48925954, 48925448, 48924606]}, "name": "E. Cycle sort", "statement": "You are given an array of n positive integers a_1, a_2,\r\ndots, a_n. You can perform the following operation any number of times:\r\nselect several distinct indices i_1, i_2,\r\ndots, i_k (1\r\nle i_j\r\nle n) and move the number standing at the position i_1 to the position\r\ni_2, the number at the position i_2 to the position i_3, ..., the number\r\nat the position i_k to the position i_1. In other words, the operation\r\ncyclically shifts elements: i_1\r\nto i_2\r\nto\r\nldots i_k\r\nto i_1.For example, if you have n=4, an array a_1=10, a_2=20, a_3=30,\r\na_4=40, and you choose three indices i_1=2, i_2=1, i_3=4, then the\r\nresulting array would become a_1=20, a_2=40, a_3=30, a_4=10.Your goal is\r\nto make the array sorted in non-decreasing order with the minimum number\r\nof operations. The additional constraint is that the sum of cycle\r\nlengths over all operations should be less than or equal to a number s.\r\nIf it\u2019s impossible to sort the array while satisfying that constraint,\r\nyour solution should report that as well.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 200600;\nint n, S;\nint a[N];\nint b[N];\nint xs[N];\nint k;\nvector<int> g[N];\nint m;\nvector<int> cycles[N];\nint p[N];\nbool used[N];\n\nvoid dfs(int v) {\n\twhile(!g[v].empty()) {\n\t\tint id = g[v].back();\n\t\tg[v].pop_back();\n\t\tdfs(a[id]);\n\t\tcycles[m].push_back(id);\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &S);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\tsort(b, b + n);\n\tfor (int i = 0; i < n; i++)\n\t\txs[k++] = b[i];\n\tk = unique(xs, xs + k) - xs;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] = lower_bound(xs, xs + k, a[i]) - xs;\n\t\tb[i] = lower_bound(xs, xs + k, b[i]) - xs;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b[i]) continue;\n\t\tg[b[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tdfs(i);\n\t\tif (!cycles[m].empty()) m++;\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tS -= (int)cycles[i].size();\n\tif (S < 0) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tp[i] = i;\n\tfor (int id = 0; id < m; id++) {\n\t\tfor (int i = 0; i < (int)cycles[id].size(); i++) {\n\t\t\tint v = cycles[id][i], u = cycles[id][(i + 1) % (int)cycles[id].size()];\n\t\t\tp[u] = v;\n\t\t}\n\t}\n\tS = min(S, m);\n\tif (S > 1) {\n\t\tprintf(\"%d\\n\", 2 + m - S);\n\t\tprintf(\"%d\\n\", S);\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tprintf(\"%d \", cycles[i][0] + 1);\n\t\tprintf(\"\\n\");\n\t\tfor (int i = S - 1; i > 0; i--)\n\t\t\tswap(p[cycles[i][0]], p[cycles[i - 1][0]]);\n\t} else {\n\t\tprintf(\"%d\\n\", m);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tif (p[i] == i) {\n\t\t\tused[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> cur;\n\t\tint x = i;\n\t\twhile(!used[x]) {\n\t\t\tcur.push_back(x);\n\t\t\tused[x] = 1;\n\t\t\tx = p[x];\n\t\t}\n\t\tprintf(\"%d\\n\", (int)cur.size());\n\t\tfor (int z : cur)\n\t\t\tprintf(\"%d \", z + 1);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dsu", "math"], "dificulty": "3100", "interactive": false}