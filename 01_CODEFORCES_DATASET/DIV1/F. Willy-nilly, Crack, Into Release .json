{
    "link": "https://codeforces.com//contest/1819/problem/F",
    "problemId": "1880637",
    "problem_idx": "F",
    "shortId": "1819F",
    "contest_number": "1819",
    "problem_submissions": {
        "E": [
            202225318,
            202223532,
            202223484,
            202225560,
            202308964,
            202224265,
            202225112,
            202221853,
            202253482,
            202237435,
            203635743,
            203096948,
            202225859,
            202369794
        ],
        "D": [
            202209352,
            202212141,
            202205538,
            202220831,
            202198559,
            202210822,
            202236119,
            202239190,
            202212242,
            202208889,
            202205391,
            202216800,
            203995136,
            202197649,
            202216978,
            202217768,
            202220492,
            202220964,
            202225376,
            202219172
        ],
        "C": [
            202201042,
            202203020,
            202193305,
            202202657,
            202190230,
            202199701,
            202199472,
            202200745,
            202199789,
            202199523,
            208251329,
            202218422,
            202204297,
            202216624,
            202204671,
            202205053,
            202201997,
            202201056,
            202198992
        ],
        "B": [
            202193365,
            202195322,
            202214813,
            202196120,
            202186520,
            202187817,
            202188682,
            202193750,
            202186708,
            202188527,
            202188957,
            202183110,
            202191595,
            202187157,
            202193385,
            202195604,
            202188109,
            202186084,
            202189411
        ],
        "A": [
            202182367,
            202180872,
            202181217,
            202181093,
            202180590,
            202180859,
            202181832,
            202181960,
            202180690,
            202180596,
            202180602,
            202180463,
            202182678,
            202180651,
            202182633,
            202181119,
            202181593,
            202180899,
            202180615
        ],
        "F": [
            202939012,
            206043011
        ]
    },
    "name": "F. Willy-nilly, Crack, Into Release ",
    "statement": "You have long dreamed of working in a large IT company and finally got a\r\njob there. You have studied all existing modern technologies for a long\r\ntime and are ready to apply all your knowledge in practice. But then you\r\nsit down at your desk and see a sheet of paper with the company\u2019s motto\r\nprinted in large letters: .The company\u2019s motto contains four main\r\nprinciples (Willi), (Nilli), (Crack), (Release). Therefore, you consider\r\nstrings of length n consisting of these four Latin letters. pairs of\r\nletters \"\", \"\", \"\", and \"\" in this motto are adjacent, so we will call\r\nsuch pairs of symbols . So, if you are given a string s of length n, and\r\nit is known that the unordered pair of symbols\r\n{ x, y\r\n} is good, then you can perform one of the following operations on the\r\nstring: if s_n = x, then you are allowed to replace this symbol with y,\r\nif there exists 1\r\nle i < n such that s_i = x and s_{i+1} =\r\nldots = s_n = y, then you are allowed to replace the i-th symbol of the\r\nstring with y, and all subsequent symbols with x. For example, the\r\nstring can be replaced with one of the strings , , or , and the string\r\ncan be replaced with or .A non-empty sequence of operations for the\r\nstring s will be called if the following two conditions are met: after\r\nperforming all operations, the string becomes s again, no string, except\r\nfor s, will occur more than once during the operations. At the same\r\ntime, the string s can occur exactly twice - before the start of the\r\noperations and after performing all operations. Now we are ready to move\r\non to the problem statement! You have a set of strings that is initially\r\nempty. Then, each of q queries adds another string t_i to the set, or\r\nremoves the string t_i from the set. After each query, you need to\r\noutput the minimum and maximum size of a correct sequence of operations\r\nin which each word occurs at least once. The choice of the initial\r\nstring s is up to you.\r\n",
    "solutions": [
        "#ifndef LOCAL\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT \u3067\u6570\u5217\u3092\u7ba1\u7406\u3059\u308b\u3068\u304d\u306b\u4f7f\u3046 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \u3057\u3066\u306a\u3044\u3084\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//\u30bd\u30fc\u30c8\u3057\u3066 i \u756a\u76ee\u304c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//\u4f8b\u3048\u3070 sortidx \u3067\u5f97\u305f idx \u3092\u4f7f\u3048\u3070\u5358\u306b\u30bd\u30fc\u30c8\u5217\u306b\u306a\u3063\u3066\u8fd4\u3063\u3066\u304f\u308b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nstruct N{\n\tN*to[4];\n\tint cnt=0,mn[4][4],mx[4][4];\n\tN(){\n\t\trep(i,4)to[i]=0;\n\t\trep(i,4)rep(j,4)mn[i][j]=inf;\n\t\trep(i,4)rep(j,4)mx[i][j]=-inf;\n\t}\n\tint gmi(int x,int y){\n\t\treturn min(mn[x][y],mn[y][x]);\n\t}\n\tint gma(int x,int y){\n\t\treturn max(mx[x][y],mx[y][x]);\n\t}\n\tvoid upd(){\n\t\tcnt=0;\n\t\trep(i,4)cnt+=to[i]->cnt;\n\t\trep(i,4){\n\t\t\tint cs=0,mis=0,mas=0;\n\t\t\tint x=i,y=i;\n\t\t\trep(_,4){\n\t\t\t\tint z=(y+1);\n\t\t\t\tif(z==4)z=0;\n\t\t\t\t\n\t\t\t\tcs+=to[y]->cnt;\n\t\t\t\tif(cs==cnt){\n\t\t\t\t\tmn[i][y]=mis+to[y]->gmi(x,y);\n\t\t\t\t\tmx[i][y]=mas+to[y]->gma(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tmn[i][y]=inf;\n\t\t\t\t\tmx[i][y]=-inf;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmis+=to[y]->gmi(x,z);\n\t\t\t\tmas+=to[y]->gma(x,z);\n\t\t\t\tchmin(mis,inf);\n\t\t\t\tchmax(mas,-inf);\n\t\t\t\tx=y;y=z;\n\t\t\t}\n\t\t}\n\t\trep(i,4)rep(j,4)chmin(mn[i][j],inf);\n\t\trep(i,4)rep(j,4)chmax(mx[i][j],-inf);\n\t}\n};\nconst int nmax=20;\nconst int qmax=100010;\nconst int smax=(nmax+1)*qmax;\nN buf[smax];\nint bufused=0;\nN* nn(){\n\treturn buf+bufused++;\n}\n\nvoid add(N*&cur,int i,const string&s){\n\t{\n\t\tN*tmp=nn();\n\t\t*tmp=*cur;\n\t\tcur=tmp;\n\t}\n\tif(i==si(s)){\n\t\tcur->cnt^=1;\n\t}else{\n\t\tint k=s[i]-'a';\n\t\tadd(cur->to[k],i+1,s);\n\t\tcur->upd();\n\t}\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tN* root;\n\t{\n\t\tvc<N*> ls(n+1);\n\t\trep(i,n+1)ls[i]=nn();\n\t\trep(i,4)rep(j,4){\n\t\t\tls[n]->mn[i][j]=1;\n\t\t\tls[n]->mx[i][j]=1;\n\t\t}\n\t\tper(i,n){\n\t\t\trep(j,4)ls[i]->to[j]=ls[i+1];\n\t\t\tls[i]->upd();\n\t\t}\n\t\troot=ls[0];\n\t}\n\trep(_,q){\n\t\tadd(root,0,readString());\n\t\tint tot=root->cnt;\n\t\tint mn=inf,mx=-inf;\n\t\tN*cur=root;\n\t\trep(lv,n){\n\t\t\tassert(cur->cnt==tot);\n\t\t\t//0-1-2-3\n\t\t\t{\n\t\t\t\tint mis=0,mas=0;\n\t\t\t\trep(y,4){\n\t\t\t\t\tint x=(y+3)%4,z=(y+1)%4;\n\t\t\t\t\tmis+=cur->to[y]->gmi(x,z);\n\t\t\t\t\tmas+=cur->to[y]->gma(x,z);\n\t\t\t\t\tchmin(mis,inf);\n\t\t\t\t\tchmax(mas,-inf);\n\t\t\t\t}\n\t\t\t\tchmin(mn,mis);\n\t\t\t\tchmax(mx,mas);\n\t\t\t}\n\t\t\trep(y,4){\n\t\t\t\tint z=(y+1)%4;\n\t\t\t\tif(cur->to[y]->cnt+cur->to[z]->cnt==cur->cnt){\n\t\t\t\t\tchmin(mn,cur->to[y]->gmi(z,z)+cur->to[z]->gmi(y,y));\n\t\t\t\t\tchmax(mx,cur->to[y]->gma(z,z)+cur->to[z]->gma(y,y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool upd=false;\n\t\t\trep(y,4){\n\t\t\t\tif(cur->to[y]->cnt==cur->cnt){\n\t\t\t\t\tcur=cur->to[y];\n\t\t\t\t\tupd=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!upd)break;\n\t\t}\n\t\tif(mn<=mx)print(mn,mx);\n\t\telse print(-1);\n\t}\n\t/*{\n\t\tN* cur=root;\n\t\tcur=cur->to[0];\n\t\tdmp(cur->mx[3][1]);\n\t\tdmp(cur->mx[1][3]);\n\t\tdmp(cur->mn[3][1]);\n\t\tdmp(cur->mn[1][3]);\n\t\tdmp(cur->to[1]->mn[1][2]);\n\t\tdmp(cur->to[2]->mn[1][3]);\n\t\tdmp(cur->to[3]->mn[2][3]);\n\t}*/\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Willy-nilly, Crack, Into Release .json",
    "editorial_link": "https://codeforces.com//blog/entry/115133",
    "editorial": "There are two ways to approach this problem. Let\u00e2\u0080\u0099s start with a solution\r\nthat does not involve associations with known images. Consider a cyclic\r\nsequence of strings that satisfies the condition of the problem.\r\nConsider the longest common prefix of all the strings in this sequence.\r\nIt is not very interesting to us, since by definition it does not change\r\nwith the operations.There are two cases. Either the sequence of\r\noperations has a length of , when we perform some action and then\r\nimmediately \"cancel\" it with a second action. This case is only possible\r\nif there are no more than two important strings in the set. In this\r\ncase, the required condition can be easily checked in time.Otherwise,\r\nour sequence consists of more than two operations and this is much more\r\nlike a cycle. Let\u00e2\u0080\u0099s say, for example, that the first non-constant\r\ncharacter in the sequence of strings initially equals \"\". Then after the\r\nfirst change it will be equal to either \"\" or \"\". Note that after this\r\nthe first character will no longer be able to immediately turn into \"\",\r\nsince the only way to do this is to \"cancel\" the operation , but this is\r\nonly possible in the first case. Thus, the first character will be\r\nrequired to go \"around the cycle\" . This cycle can be divided into four\r\nsegments based on the value of the first character of the string. In\r\neach of these segments, we are interested in the sequence of operations\r\nthat transforms the string with the suffix into a string that matches\r\nthe original in the prefix, but its suffix is , where and the pair of\r\ncharacters is \"good\".With the help of a not very complicated analysis of\r\ncases, we can see that for each prefix we are interested in groups of\r\npaths that connect strings whose characters, except for the suffix being\r\nconsidered, match, and these paths visit all important strings with the\r\nprefix being considered. Within each group of paths, we are interested\r\nin the minimum and maximum path, respectively. Note that these values\r\ncan be easily calculated using dynamic programming. We can calculate all\r\nthese states in time. Then we need to iterate over the length of the\r\ncommon prefix of all the strings and answer the query in time.So far, we\r\ncan only calculate the states of interest to us in some galactic time.\r\nBut this is not entirely scary! Let\u00e2\u0080\u0099s say, for example, that when we add\r\nor remove one string from the set of important strings, only states\r\nchange, since only the states responsible for the prefixes of the\r\nadded/deleted string will change. To some extent, this is reminiscent of\r\na segment tree, or rather, a quadtree.We just need to figure out how to\r\nget rid of the term in the asymptotic complexity. But this is also\r\nsimple. Let\u00e2\u0080\u0099s notice that if there are no strings with the given prefix\r\nin the set of important strings, then the states responsible for this\r\nprefix will depend only on the length of the remaining suffix, and all\r\nthese values can be precomputed in time. Thus, we store a trie with\r\nstrings from the queries, in each node of which we store the state of\r\nthe dynamic programming, and in case we need the values of the dynamic\r\nprogramming from non-existent trie nodes during recalculation, we can\r\nreplace them with precomputed values.Time complexity: .The author\u00e2\u0080\u0099s code\r\nis not very complicated, but if you suddenly want to understand it, I\r\nwarn you that it uses several \"hacks\" of questionable justification. For\r\nexample, instead of dynamic programming states, only really useful ones\r\nare stored there. The combinatorial structure is used to simplify the\r\nsupport of simultaneous maximum and minimum values, and much more. I\r\nthink that it will be especially useful for beginners to familiarize\r\nthemselves with how to simplify their lives in implementing\r\ncombinatorial problems.Now let\u00e2\u0080\u0099s turn to the geometric interpretation of\r\nthe problem. Imagine a square with a size of . In its corners, we can\r\ndraw squares with sizes of each. Let\u00e2\u0080\u0099s say that strings starting with\r\nthe character go to the upper-left square, strings starting with the\r\ncharacter go to the upper-right, the character corresponds to the\r\nlower-right corner, and the character corresponds to the lower-left.\r\nThen we can divide the four resulting squares into four parts each in\r\nthe same way and divide the strings by corners already by the second\r\ncharacter, and so on. In the end, each string is associated with an\r\ninteger point with coordinates from the interval . We also have lines\r\nfrom the drawn squares, which are naturally divided into vertical and\r\nhorizontal segments of length each.This picture is useful because it\r\ndepicts a graph whose vertices correspond to the strings being\r\nconsidered, and its edges connect pairs of strings that are obtained\r\nfrom each other by means of one move. Thus, looking at the picture, much\r\nof the structure of simple cycles in the problem being considered\r\nbecomes clear and obvious, and with the help of such a picture it is\r\nmuch easier to describe the transitions in the dynamic programming and\r\nnot get confused.\r\n"
}