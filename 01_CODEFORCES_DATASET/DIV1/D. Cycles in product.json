{"link": "https://codeforces.com//contest/997/problem/D", "problemId": "194453", "problem_idx": "D", "shortId": "997D", "contest_number": "997", "problem_submissions": {"D": [39842612, 39837685, 39842379, 39838295, 39837935, 39842740, 39843076, 39859781, 39844833, 39844190, 39833354, 39839922, 39854124, 39853938, 39841292, 39838113, 39841101, 39836594, 39854271, 39854180, 39841626], "E": [39838988, 39839303, 40677876, 39860384, 216157458, 207265582], "C": [39833262, 39841343, 39842130, 39832983, 39840312, 39831596, 39835919, 39837971, 39858804, 39838178, 39837144, 39850195, 39850032, 39850007, 39849997, 39849695, 39849346, 39849204, 39848619, 39840597, 39849012, 39851642, 39851588, 39851576, 39851518, 39851506, 39851317, 39851202, 39850994, 39850828, 39850773, 39850608, 39850592, 39850571, 39850194, 39850131, 39850042, 39850008, 39849917, 39849907, 39849611, 39849473, 39849310, 39849195, 39849073, 39849029, 39848917, 39848844, 39833638], "B": [39825922, 39826364, 39827934, 39825576, 39828070, 39839886, 39829927, 39831407, 39858660, 39828494, 39832160, 39839554, 39828743, 39833583, 39835350, 39842444, 39828730, 39826817], "A": [39823476, 39823484, 39823390, 39823892, 39823506, 39823245, 39824375, 39824053, 39858605, 39823570, 39823352, 39837740, 39823612, 39823561, 39841314, 39824552, 39838338, 39823711, 39823355]}, "name": "D. Cycles in product", "statement": "Consider a tree (that is, an undirected connected graph without loops)\r\nT_1 and a tree T_2. Let\u2019s define their T_1\r\ntimes T_2 in a following way.Let V be the set of vertices in T_1 and U\r\nbe the set of vertices in T_2.Then the set of vertices of graph T_1\r\ntimes T_2 is V\r\ntimes U, that is, a set of ordered pairs of vertices, where the first\r\nvertex in pair is from V and the second from U.Let\u2019s draw the following\r\nedges: Between (v, u_1) and (v, u_2) there is an undirected edge, if u_1\r\nand u_2 are adjacent in U. Similarly, between (v_1, u) and (v_2, u)\r\nthere is an undirected edge, if v_1 and v_2 are adjacent in V. Please\r\nsee the notes section for the pictures of products of trees in the\r\nsample tests.Let\u2019s examine the graph T_1\r\ntimes T_2. How much cycles (not necessarily simple) of length k it\r\ncontains? Since this number can be very large, print it modulo\r\n998244353.The sequence of vertices w_1, w_2, ..., w_k, where w_i\r\nin V\r\ntimes U called cycle, if any neighboring vertices are adjacent and w_1\r\nis adjacent to w_k. Cycles that differ only by the cyclic shift or\r\ndirection of traversal are still considered .\r\n", "solutions": ["#pragma GCC optimize(\"-O3\",\"-funroll-all-loops\")\n#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint k;\n#define SZ 233333\nll fac[SZ],rfac[SZ];\nconst int MOD=998244353;\nll kk[SZ];\nstruct Tree\n{\nint n; Edg\nvoid inpe()\n{\n\tfor(int i=1,a,b;i<n;++i)\n\t\tscanf(\"%d%d\",&a,&b),adde(a,b);\n}\nll cd[4005][88],cu[4005][88];\nint fa[4005];\nvoid d1(int x,int f=0)\n{\n\tfa[x]=f;\n\tfor esb(x,e,b) if(b!=f) d1(b,x);\n\tfor(int i=0;i<=k;++i) kk[i]=0;\n\tfor esb(x,e,b) if(b!=f)\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\tcd[x][0]=1;\n\tfor(int i=0;i<=k;++i)\n\t\tfor(int j=0;j<=i-2;++j)\n\t\t\t(cd[x][i]+=cd[x][i-j-2]*kk[j])%=MOD;\n}\nvoid d2(int x,int f=0)\n{\n\tfor(int i=0;i<=k;++i) kk[i]=cu[x][i];\n\tfor esb(x,e,b) if(b!=f)\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\tfor esb(x,e,b) if(b!=f)\n\t{\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]-=cd[b][i])%=MOD;\n\t\tcu[b][0]=1;\n\t\tfor(int i=0;i<=k;++i)\n\t\t\tfor(int j=0;j<=i-2;++j)\n\t\t\t\t(cu[b][i]+=cu[b][i-j-2]*kk[j])%=MOD;\n\t\tfor(int i=0;i<=k;++i)\n\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\t}\n\tfor esb(x,e,b) if(b!=f) d2(b,x);\n}\nll cyc[4005][88];\nvoid gencyc()\n{\n\td1(1); d2(1);\n\tfor(int x=1;x<=n;++x)\n\t{\n\t\tfor(int i=0;i<=k;++i) kk[i]=cu[x][i];\n\t\tfor esb(x,e,b) if(b!=fa[x])\n\t\t\tfor(int i=0;i<=k;++i)\n\t\t\t\t(kk[i]+=cd[b][i])%=MOD;\n\t\tcyc[x][0]=1;\n\t\tfor(int i=0;i<=k;++i)\n\t\t\tfor(int j=0;j<=i-2;++j)\n\t\t\t\t(cyc[x][i]+=cyc[x][i-j-2]*kk[j])%=MOD;\n\t}\n}\n}T1,T2;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nll s1[88],s2[88];\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<SZ;++i) fac[i]=fac[i-1]*i%MOD;\n\trfac[SZ-1]=qp(fac[SZ-1],MOD-2);\n\tfor(int i=SZ-1;i;--i) rfac[i-1]=rfac[i]*i%MOD;\n\tscanf(\"%d%d%d\",&T1.n,&T2.n,&k);\n\tif(k&1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tT1.inpe(); T2.inpe(); T1.gencyc(); T2.gencyc();\n\tll ans=0;\n\tfor(int i=1;i<=T1.n;++i)\n\t\tfor(int t=0;t<=k;++t)\n\t\t\t(s1[t]+=T1.cyc[i][t])%=MOD;\n\tfor(int i=1;i<=T2.n;++i)\n\t\tfor(int t=0;t<=k;++t)\n\t\t\t(s2[t]+=T2.cyc[i][t])%=MOD;\n\tfor(int t=0;t<=k;++t)\n\t\tans+=s1[t]*s2[k-t]%MOD\n\t\t*rfac[t]%MOD*rfac[k-t]%MOD,ans%=MOD; \n\tans=ans*fac[k]%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "divide and conquer", "trees"], "dificulty": "2900", "interactive": false}