{
    "link": "https://codeforces.com//contest/1588/problem/F",
    "problemId": "1186195",
    "problem_idx": "F",
    "shortId": "1588F",
    "contest_number": "1588",
    "problem_submissions": {
        "D": [
            135372629,
            135381098,
            135359109,
            135369800,
            135370088,
            135380867,
            135357823,
            135362201,
            135366407,
            135370846,
            135374380,
            135373580,
            135374295,
            135373419,
            135378493,
            135376601,
            135375978,
            135382040
        ],
        "C": [
            135363142,
            135352112,
            135379109,
            135361010,
            135362653,
            135375549,
            135350810,
            135353082,
            135359513,
            135351205,
            135365941,
            135366190,
            135366197,
            135366261,
            135798161,
            135798159,
            135798156,
            135798153,
            135793795,
            135353318,
            135359719,
            135363580,
            135376282,
            135360557
        ],
        "B": [
            135354041,
            135372942,
            135367733,
            135353235,
            135382607,
            135353847,
            135347088,
            135367644,
            135348462,
            135359847,
            135354086,
            135351940,
            135356516,
            135347194,
            135365557,
            135349342,
            135357424,
            135354885,
            135351181
        ],
        "A": [
            135347972,
            135342643,
            135342911,
            135343015,
            135342760,
            135342918,
            135342730,
            135343666,
            135342808,
            135352544,
            135343056,
            135344466,
            135342657,
            135342700,
            135342859,
            135345441,
            135343145,
            135343927,
            135342677
        ],
        "E": [
            135346443,
            135364189,
            135371530,
            135382787,
            135381160,
            135387683,
            135507210,
            135399676,
            135412491,
            135411131,
            135507958,
            135387301
        ],
        "F": [
            135608326,
            135531498,
            135406993,
            135398120,
            135395364
        ]
    },
    "name": "F. Jumping Through the Array",
    "statement": "You are given an array of integers a of size n and a permutation p of\r\nsize n. There are q queries of three types coming to you: For given\r\nnumbers l and r, calculate the sum in array a on the segment from l to\r\nr:\r\nsum\r\nlimits_{i=l}^{r} a_i. You are given two numbers v and x. Let’s build a\r\ndirected graph from the permutation p: it has n vertices and n edges i\r\nto p_i. Let C be the set of vertices that are reachable from v in this\r\ngraph. You should add x to all a_u such that u is in C. You are given\r\nindices i and j. You should swap p_i and p_j. Please, process all\r\nqueries and print answers to queries of type 1.\r\n",
    "solutions": [
        "// author: xay5421\n// created: Sun Nov 14 15:37:55 2021\n#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nusing LL=long long;\ninline char getc(){static char buf[1<<20],*p1=buf,*p2=buf;return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;}\ntemplate<class T>void rd(T&x){int f=0,c;while(!isdigit(c=getc()))f^=!(c^45);x=(c&15);while(isdigit(c=getc()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<class T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nconst int N=200005,B=500;\nint n,Q,p[N],q[N],cyc[N],len,bel[N],big[N],cnt;\nbool is[N],vis[N],hav[N];\nLL a[N],sum[N],tg[N];\nvector<int>vec[N];\ntuple<int,int,int>qs[N];\nint calc(vector<int>&v,int l,int r){\n\treturn upper_bound(v.begin(),v.end(),r)-lower_bound(v.begin(),v.end(),l);\n}\nvoid sol(int time_l,int time_r){\n\t//D(\"! %d %d\\n\",time_l,time_r);\n\tfill(vis+1,vis+1+n,0);\n\tfill(q+1,q+1+n,0);\n\tfill(is+1,is+1+n,0);\n\tfill(hav+1,hav+1+n,0);\n\trep(_,time_l,time_r){\n\t\tint x,y,z;\n\t\ttie(x,y,z)=qs[_];\n\t\tif(x==3){\n\t\t\tis[p[y]]=is[p[z]]=1;\n\t\t}\n\t\tif(x==2){\n\t\t\thav[y]=1;\n\t\t}\n\t}\n\trep(i,1,n)if(!vis[i]){\n\t\tint x=i;\n\t\tlen=0;\n\t\tint ok=0;\n\t\twhile(!vis[x]){\n\t\t\tvis[x]=1;\n\t\t\tcyc[++len]=x;\n\t\t\tok|=hav[x];\n\t\t\tx=p[x];\n\t\t}\n\t\tint lst=0;\n\t\tper(j,len,1){\n\t\t\tif(is[cyc[j]]){lst=cyc[j];break;}\n\t\t}\n\t\tif(!lst){\n\t\t\tif(ok){\n\t\t\t\tis[cyc[1]]=1;\n\t\t\t\tlst=cyc[1];\n\t\t\t}else{\n\t\t\t\trep(j,1,len)bel[cyc[j]]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trep(j,1,len){\n\t\t\tif(is[cyc[j]]){\n\t\t\t\tq[lst]=cyc[j];\n\t\t\t\tlst=cyc[j];\n\t\t\t}\n\t\t\tbel[cyc[j]]=lst;\n\t\t}\n\t}\n\tcnt=0;\n\trep(i,1,n){\n\t\tif(is[i]){\n\t\t\tbig[++cnt]=i,tg[i]=0;\n\t\t}\n\t}\n\t//D(\"cnt=%d\\n\",cnt);\n\trep(i,1,n){\n\t\tvec[i].clear();\n\t\t//vec[i].shrink_to_fit();\n\t}\n\trep(i,1,n){\n\t\tif(bel[i])vec[bel[i]].pb(i);\n\t}\n\trep(_,time_l,time_r){\n\t\tint x,y,z;\n\t\ttie(x,y,z)=qs[_];\n\t\tif(x==1){\n\t\t\tLL ans=sum[z]-sum[y-1];\n\t\t\trep(i,1,cnt){\n\t\t\t\tans+=1LL*tg[big[i]]*calc(vec[big[i]],y,z);\n\t\t\t}\n\t\t\tpt(ans,'\\n');\n\t\t}else if(x==2){\n\t\t\tint start=bel[y];\n\t\t\tint cur=start;\n\t\t\tdo{\n\t\t\t\ttg[cur]+=z;\n\t\t\t\tcur=q[cur];\n\t\t\t}while(cur!=start);\n\t\t}else if(x==3){\n\t\t\tswap(q[bel[y]],q[bel[z]]);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ta[i]+=tg[bel[i]];\n\t\tsum[i]=sum[i-1]+a[i];\n\t}\n\trep(_,time_l,time_r){\n\t\tint x,y,z;\n\t\ttie(x,y,z)=qs[_];\n\t\tif(x==3){\n\t\t\tswap(p[y],p[z]);\n\t\t}\n\t}\n}\nint main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\trd(n);\n\trep(i,1,n)rd(a[i]),sum[i]=sum[i-1]+a[i];\n\trep(i,1,n)rd(p[i]);\n\trd(Q);\n\trep(_,1,Q){\n\t\trd(get<0>(qs[_]));\n\t\trd(get<1>(qs[_]));\n\t\trd(get<2>(qs[_]));\n\t}\n\tfor(int l=1,r;l<=Q;l=r+1){\n\t\tr=min(Q,l+B-1);\n\t\tsol(l,r);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "graphs",
        "two pointers"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Jumping Through the Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/96953",
    "editorial": "Letâs call .Letâs divide an array into consecutive blocks of size .To\r\nanswer the query we will have to sum near the segmentâs bounds and sums\r\non blocks. Letâs try to calculate them fast.There are two types of\r\ncycles: : with length : with length If there is a second type query for\r\nthe small cycle it is easy to make it in time: letâs iterate over\r\ncycleâs elements and add into its and into its arrayâs block sum.It is\r\nharder to deal with big cycles. Letâs divide each big cycle into blocks,\r\neach having the size in . Initially, it is possible. After each query of\r\ntype it is possible to reconstruct this division fast: Letâs split two\r\nblocks with and . After that, it is possible to reconstruct the\r\ndivisions of each new cycle into blocks. After that, we should avoid\r\nsmall blocks (with size ). Letâs merge two consecutive blocks if one of\r\nthem has the size . After that, if the total block has size letâs split\r\nit into two equal blocks. Someone calls this method . So, maintaining\r\nthis structure we will have at most cycle blocks at any moment. If there\r\nis a second type query for the big cycle letâs add to the cycle blocks\r\nfor this cycle. To consider these values while answering the first type\r\nquery letâs maintain the last structure: For each cycle block letâs\r\ncalculate the values , where is the number of elements from the -th\r\ncycle block in the first arrayâs blocks. Using these values it is easy\r\nto consider additions to the cycle blocks in the subsegments sums\r\nqueries.And the values of can be recalculated during the cycleâs updates\r\nbecause we make splits and merges. During each split or merge we should\r\nrecalculate for rows (and this can be done in for one ). Also during\r\neach split or merge we should zero additions to blocks in operations\r\njust pushing the added value into the elements of the block (their\r\nnumber is smaller than ).The total complexity of the solution is .\r\n",
    "hint": []
}