{"link": "https://codeforces.com//contest/674/problem/G", "problemId": "59818", "problem_idx": "G", "shortId": "674G", "contest_number": "674", "problem_submissions": {"F": [17795703, 17796640, 17795248, 17796731, 17795284, 17786875, 17793312, 17799447, 17799059, 17796927, 17809648], "E": [17791802, 17792589, 17793136, 17792993, 17792579, 17790993, 17797689, 17793850, 17793986, 17790505, 17793423, 17807249, 17795195, 17795763, 17827053, 17796913], "C": [17789698, 17787708, 17787067, 17789946, 17787511, 17796571, 17795757, 17788550, 17790663, 17794959, 17792670, 17795899, 17791267, 17793511, 17791551, 17791808], "B": [17783364, 17783002, 17794015, 17783259, 17783884, 17783532, 17788831, 17784932, 17787141, 17784301, 17785005, 17785023, 17784292, 17783013, 17783128, 17786182, 17784522], "A": [17780055, 17780264, 17780741, 17780847, 17780248, 17780121, 17787726, 17781230, 17780294, 17782551, 17782250, 17781088, 17780155, 17780065, 17780569, 17780629, 17781843], "D": [17798492, 17808237], "G": [17818293, 17796240, 17798313]}, "name": "G. Choosing Ads", "statement": "One social network developer recently suggested a new algorithm of\r\nchoosing ads for users.There are slots which advertisers can buy. It is\r\npossible to buy a segment of consecutive slots at once. The more slots\r\nyou own, the bigger are the chances your ad will be shown to users.Every\r\ntime it is needed to choose ads to show, some segment of slots is picked\r\nby a secret algorithm. Then some advertisers are chosen. The only\r\nrestriction is that it should be guaranteed for advertisers which own at\r\nleast\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), _end_ = (b); i < _end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 150100;\n\nint n, m, p;\nint a[maxn + 5];\n\nint lim;\n\nstruct data\n{\n\tvector<pair<int, int> > all;\n\n\tdata() { }\n\n\tdata &operator+=(const data &x)\n\t{\n\t\tfor (auto &u : x.all)\n\t\t{\n\t\t\tbool find = 0;\n\t\t\tfor (auto &v : all)\n\t\t\t\tif (v.x == u.x)\n\t\t\t\t{\n\t\t\t\t\tfind = 1;\n\t\t\t\t\tv.y += u.y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!find)\n\t\t\t{\n\t\t\t\tif (SZ(all) < lim)\n\t\t\t\t{\n\t\t\t\t\tall.pb(u);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint Min = oo;\n\t\t\t\tfor (auto &v : all) chkmin(Min, v.y);\n\t\t\t\tif (Min >= u.y) for (auto &v : all) v.y -= u.y;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (auto &v : all) v.y -= Min;\n\t\t\t\t\tfor (auto &v : all) if (!v.y) { v.x = u.x, v.y = u.y - Min; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\n};\n\nstruct node\n{\n\tnode *c[2];\n\n\tint label;\n\tint sz;\n\tdata sum;\n\n\tnode(): label(-1) { memset(c, 0, sizeof c); }\n\n\tvoid flag_label(int _label)\n\t{\n\t\tlabel = _label;\n\t\tsum.all.clear();\n\t\tsum.all.pb(mp(_label, sz));\n\t}\n\n\tvoid push_down()\n\t{\n\t\tif (~label)\n\t\t{\n\t\t\tREP(i, 0, 2) if (c[i]) c[i]->flag_label(label);\n\t\t\tlabel = -1;\n\t\t}\n\t}\n\n\tvoid update()\n\t{\n\t\tsum = data();\n\t\tREP(i, 0, 2) if (c[i]) sum += c[i]->sum;\n\t}\n\n};\n\nnode *rt;\n\nnode nd[(maxn << 1) + 5];\nint cur = 0;\n\nnode *newnode() { return nd + (cur++); }\n\nvoid build(node *&rt, int l, int r)\n{\n\tif (!rt) rt = newnode(), rt->sz = r - l;\n\tif (r - l <= 1)\n\t{\n\t\trt->sum.all.clear();\n\t\trt->sum.all.pb(mp(a[l], 1));\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(rt->c[0], l, mid);\n\tbuild(rt->c[1], mid, r);\n\trt->update();\n}\n\nint seg_x, seg_y, seg_z;\n\ndata seg_ret;\n\nvoid assign(node *rt, int l, int r)\n{\n\tif (!rt) return;\n\tif (seg_x <= l && r <= seg_y) { rt->flag_label(seg_z); return; }\n\tint mid = (l + r) >> 1;\n\trt->push_down();\n\tif (seg_x < mid) assign(rt->c[0], l, mid);\n\tif (seg_y > mid) assign(rt->c[1], mid, r);\n\trt->update();\n}\n\nvoid query(node *rt, int l, int r)\n{\n\tif (!rt) return;\n\tif (seg_x <= l && r <= seg_y) { seg_ret += rt->sum; return; }\n\tint mid = (l + r) >> 1;\n\trt->push_down();\n\tif (seg_x < mid) query(rt->c[0], l, mid);\n\tif (seg_y > mid) query(rt->c[1], mid, r);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d%d%d\", &n, &m, &p);\n\tlim = 100 / p;\n\tREP(i, 0, n) scanf(\"%d\", a + i), --a[i];\n\tbuild(rt, 0, n);\n\tREP(i, 0, m)\n\t{\n\t\tint ty;\n\t\tscanf(\"%d%d%d\", &ty, &seg_x, &seg_y), --seg_x;\n\t\tif (ty == 1)\n\t\t{\n\t\t\tscanf(\"%d\", &seg_z), --seg_z;\n\t\t\tassign(rt, 0, n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tseg_ret = data();\n\t\t\tquery(rt, 0, n);\n\t\t\tprintf(\"%d\", SZ(seg_ret.all));\n\t\t\tfor (auto &x : seg_ret.all) printf(\" %d\", x.x + 1);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": [], "dificulty": "3200", "interactive": false}