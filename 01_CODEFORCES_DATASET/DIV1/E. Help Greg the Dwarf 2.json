{
    "link": "https://codeforces.com//contest/142/problem/E",
    "problemId": "759",
    "problem_idx": "E",
    "shortId": "142E",
    "contest_number": "142",
    "problem_submissions": {
        "D": [
            1037429,
            1033957,
            1037084,
            1113531,
            1036315,
            1036207,
            1039046,
            1039771,
            1035511,
            1039807
        ],
        "C": [
            1036084,
            1037803,
            1040168,
            1038580,
            1038178,
            1041260,
            1038906,
            1038902,
            1038753,
            1034775,
            1040737,
            1039056,
            1038416,
            1037153,
            1034481
        ],
        "B": [
            1032453,
            1035023,
            1033212,
            1031763,
            1032487,
            1041275,
            1033427,
            1034500,
            1033279,
            1036000,
            1032039,
            1042729,
            1042583,
            1032611,
            1033180,
            1033834,
            1032713,
            1034068,
            1032534
        ],
        "A": [
            1031075,
            1031753,
            1031668,
            1031166,
            1031287,
            1041290,
            1031330,
            1031886,
            1032150,
            1031269,
            1033203,
            1031404,
            1031249,
            1031261,
            1031962,
            1031577,
            1031132
        ],
        "E": [
            1356376,
            1131959,
            1131952,
            1131947
        ]
    },
    "name": "E. Help Greg the Dwarf 2",
    "statement": "Greg the Dwarf has been really busy recently with excavations by the\r\nNeverland Mountain. However for the well-known reasons (as you probably\r\nremember he is a very unusual dwarf and he cannot stand sunlight) Greg\r\ncan only excavate at night. And in the morning he should be in his crypt\r\nbefore the first sun ray strikes. That\u2019s why he wants to find the\r\nshortest route from the excavation point to his crypt. Greg has\r\nrecollected how the Codeforces participants successfully solved the\r\nproblem of transporting his coffin to a crypt. So, in some miraculous\r\nway Greg appeared in your bedroom and asks you to help him in a highly\r\npersuasive manner. As usual, you didn\u2019t feel like turning him down.After\r\nsome thought, you formalized the task as follows: as the Neverland\r\nmountain has a regular shape and ends with a rather sharp peak, it can\r\nbe represented as a cone whose base radius equals and whose height\r\nequals . The graveyard where Greg is busy excavating and his crypt can\r\nbe represented by two points on the cone\u2019s surface. All you\u2019ve got to do\r\nis find the distance between points on the cone\u2019s surface. The task is\r\ncomplicated by the fact that the mountain\u2019s base on the ground level and\r\neven everything below the mountain has been dug through by gnome (one\r\nmay wonder whether they\u2019ve been looking for the same stuff as Greg...).\r\nSo, one can consider the shortest way to pass not only along the side\r\nsurface, but also along the cone\u2019s base (and in a specific case both\r\npoints can lie on the cone\u2019s base see the first sample test)Greg will be\r\nsatisfied with the problem solution represented as the length of the\r\nshortest path between two points he can find his way pretty well on his\r\nown. He gave you two hours to solve the problem and the time is ticking!\r\n",
    "solutions": [
        "//\u00d2\u00db \u00cd\u00c0\u00d0\u00ca\u00ce\u00cc\u00c0\u00cd \u00d7\u00d2\u00ce \u00cb\u00c8 \u00d7\u00c8\u00d2\u00c0\u00d2\u00dc \u00dd\u00d2\u00ce\n\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <bitset>\n#include <sstream>\n \nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); ++i)\n#define for1(i, n) for(int i = 1; i <= int(n); ++i)\n#define ford(i, n) for(int i = int(n) - 1; i >= 0; --i)\n#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)\n#define sz(v) int((v).size())\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n#define X first\n#define Y second\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<ld, ld> pt;\n\ntemplate<typename T> T abs(T a) { return a < 0 ? -a : a; }\ntemplate<typename T> T sqr(T a) { return a*a; }\n\nconst int INF = (int)1e9;\nconst ld EPS = 1e-13;\nconst ld PI = 3.1415926535897932384626433832795;\n\nconst int MAGIC = 10;\nconst int ITER = 50;\n\nstruct pt3{\n    ld X, Y, Z;\n\n    pt3(){ X = Y = Z = 0; }\n    pt3(const ld& X, const ld& Y, const ld& Z) : X(X), Y(Y), Z(Z){}\n};\n\ninline ld dist(const pt3& a, const pt3& b){\n    return sqrtl(sqr(a.X - b.X) + sqr(a.Y - b.Y) + sqr(a.Z - b.Z));\n}\n\ninline ld dist2(const pt3& a, const pt3& b){\n    return (sqr(a.X - b.X) + sqr(a.Y - b.Y) + sqr(a.Z - b.Z));\n}\n\ninline ld leng(const pt3& a){\n    return sqrtl(a.X*a.X + a.Y*a.Y + a.Z*a.Z);\n}\n    \ninline pt3 operator - (const pt3& a, const pt3& b){\n    return pt3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);\n}\n\ninline pt3 norm(const pt3& a, const ld& nln){\n    ld ln = leng(a);\n    return pt3(a.X * (nln / ln), a.Y * (nln / ln), a.Z * (nln / ln));\n}\n\ninline ld distAng(const ld& a, const ld& b){\n    if(a > b)\n        return min(a - b, b + 2*PI - a);\n    else\n        return min(b - a, a + 2*PI - b);\n}\n\nld h, r;\npt3 a, b, ap, bp, t;\nld aa, ba, ard, brd, ad, bd, ar, br, trd;\n\ninline pt3 getPoint(const ld& ang){\n    return pt3(r*cos(ang), r*sin(ang), 0);\n}\n\ninline pt3 project(const pt3& a){\n    pt3 v = norm(a - t, sqrtl(sqr(a.Z) + dist2(a, t) - sqr(h - a.Z)));\n    return pt3(a.X + v.X, a.Y + v.Y, a.Z + v.Z);\n}\n\ninline ld distCon(const ld& z1, const ld& z2, ld ang){\n    /*\n    if(z1 > z2)\n        return distCon(z2, z1, ang);\n\n    if(abs(z2 - h) < EPS){\n        return trd * (h - z1) / h;\n    }\n    */\n\n    while(ang < 0)\n        ang += 2*PI;\n    while(ang > 2*PI)\n        ang -= 2*PI;\n    ang *= r / trd;\n\n    pt a(trd * (h - z1) / h, 0);\n    ld r2 = trd * (h - z2) / h;\n    pt b(r2 * cos(ang), r2 * sin(ang));\n\n    return sqrtl(sqr(a.X - b.X) + sqr(a.Y - b.Y));\n}\n\ninline ld distCon(const pt3& a, const pt3& b){\n    ld dif = atan2(a.Y, a.X) - atan2(b.Y, b.X);\n    while(dif < 0)\n        dif += 2*PI;\n    while(dif > 2*PI)\n        dif -= 2*PI;\n\n    //cerr << dif << \" \" << dif * nang << endl;\n\n    return min(distCon(a.Z, b.Z, dif), distCon(a.Z, b.Z, (2*PI - dif)));\n}\n                         \nld solve2(const pt3& ca){\n    if(abs(b.Z) < EPS)\n        return dist(ca, b);\n\n    int curMagic = (a.Z < EPS) ? (MAGIC * MAGIC) : (MAGIC);\n\n    ld d = 2*PI / curMagic;\n\n    ld ans = 1e100;\n\n    forn(i, curMagic){\n        ld lf = i*d;\n        ld rg = i*d + d;\n\n        forn(j, ITER){\n            ld d = (rg - lf) / 3;\n            ld ml = lf + d;\n            ld mr = rg - d;\n\n            pt3 pl = getPoint(ml), pr = getPoint(mr);\n\n            if(dist(ca, pl) + min(distCon(0, b.Z, ml - ba), distCon(0, b.Z, ba - ml)) > dist(ca, pr) + min(distCon(0, b.Z, mr - ba), distCon(0, b.Z, ba - mr))){  \n                lf = ml;\n            }else{\n                rg = mr;\n            }\n        }\n        \n\n        ans = min(ans, dist(ca, getPoint(lf)) + min(distCon(0, b.Z, lf - ba), distCon(0, b.Z, ba - lf)));\n    }\n\n    return ans;\n}\n    \nld solve1(){\n    if(abs(a.Z) < EPS)\n        return solve2(a);\n\n    ld d = 2*PI / MAGIC;\n\n    ld ans = 1e100;\n\n    forn(i, MAGIC){\n        ld lf = i*d;\n        ld rg = i*d + d;\n\n        forn(j, ITER){\n            ld d = (rg - lf) / 3;\n            ld ml = lf + d;\n            ld mr = rg - d;\n\n            pt3 pl = getPoint(ml), pr = getPoint(mr);\n\n            if(min(distCon(0, a.Z, ml - aa), distCon(0, a.Z, aa - ml)) + solve2(pl) > min(distCon(0, a.Z, mr - aa), distCon(0, a.Z, aa - mr)) + solve2(pr)){  \n                lf = ml;\n            }else{\n                rg = mr;\n            }\n        }\n\n        ans = min(ans, min(distCon(0, a.Z, lf - aa), distCon(0, a.Z, aa - lf)) + solve2(getPoint(lf)));\n    }\n\n    return ans;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"input.txt\", \"rt\", stdin);\n        //freopen(\"output.txt\", \"wt\", stdout);\n    #endif\n\n    cout.precision(10);\n    cout << fixed;\n\n    cin >> r >> h >> a.X >> a.Y >> a.Z >> b.X >> b.Y >> b.Z;\n\n    if(b.Z < EPS)\n        swap(a, b);\n\n    t = pt3(0, 0, h);\n    trd = sqrtl(r*r + h*h);\n\n\n    if(a.Z < EPS && b.Z < EPS){\n        cout << dist(a, b) << endl;\n        return 0;\n    }\n\n    if(a.X < EPS && a.Y < EPS && abs(a.Z - h) < EPS){\n        if(b.Z < EPS){\n            cout << trd + r - dist(b, pt3(0, 0, 0)) << endl;\n        }else{\n            cout << dist(a, b) << endl;\n        }\n\n        return 0;\n    }\n\n    if(b.X < EPS && b.Y < EPS && abs(b.Z - h) < EPS){\n        if(a.Z < EPS){\n            cout << trd + r - dist(a, pt3(0, 0, 0)) << endl;\n        }else{\n            cout << dist(a, b) << endl;\n        }\n        return 0;\n    }\n\n\n    if(abs(a.Z) > EPS){ \n        ap = project(a);\n        ad = dist(a, ap);\n        ard = sqrtl(r*r + h*h) / h * (h - a.Z);\n        aa = atan2(ap.Y, ap.X);\n        while(aa < 0)\n            aa += 2*PI;\n        ar = sqrtl(dist2(a, t) - sqr(h - a.Z));\n    }\n\n    if(abs(b.Z) > EPS){\n        bp = project(b);\n        bd = dist(b, ap);\n        brd = sqrtl(r*r + h*h) / h * (h - b.Z);\n        ba = atan2(bp.Y, bp.X);\n        while(ba < 0)\n            ba += 2*PI;\n        br = sqrtl(dist2(b, t) - sqr(h - b.Z));\n    }\n\n    ld conDist = 1e100;\n\n    if(abs(a.Z) > EPS && abs(b.Z) > EPS){\n        conDist = distCon(a, b);\n    }\n\n    //cerr << clock() << endl;\n\n    cout << min(conDist,solve1()) << endl;\n\n    cerr << clock() << endl;\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Help Greg the Dwarf 2.json",
    "editorial_link": "https://codeforces.com/blog/entry/3651",
    "editorial": "This problem was \"just\" about finding the shortest path on a cone. Unfortunately, even though jury lowered precision requirements to 10^-6 and included all possible general cases in pretests, nobody tried it =(\nFor solution, let's consider all possible cases of two points on the cone surface (including its basement):\n1. Both points on the basement. Here it is clear that Euclidean distance between points is the answer to our problem.\n2. Both points on the lateral surface. One may think that optimal path is also always lies on the lateral surface. In this case it is easy to find length of an optimal path from geometric considerations (by considering loft of the lateral surface). But 10-th pretest disproves that it is always optimal:\n\n100 100\n99 0 1\n-99 0 1\nAnswer: 202.828427124746210\n\nSo, optimal path may go through the basement. In this case it has two points that lie at the same time on the basement and on the lateral surface (let's call them A' and B'), so length of the path through this points is easy to find by adding length of the three different segments - AA', A'B' and B'B. So the problem is reduced to finding optimal positions of A' and B'? Let's assume that polar angle of the first point in XOY plane is a1 (0 <= a1 < 2*PI) and polar angle of the second point is a2 (0 <= a2 < 2*PI). Length of the shortest path between A and B passing through the points A' and B' (AA' + A'B' + B'B) is some function of two arguments that we want to minimize - f (a1, a2). One may minimize it using, for example, grid or any other suitable numerical approach.\n3. One point on the basement and another point on the lateral surface. This case is similar to the previous one - optimal path passes some point C' on the \"brink\" whose optimal polar angle we are to find. In this case we optimize function of one argument g(polar angle(C')) = AC' + C'B."
}