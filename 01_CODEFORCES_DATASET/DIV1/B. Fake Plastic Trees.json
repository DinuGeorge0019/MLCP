{"link": "https://codeforces.com//contest/1693/problem/B", "problemId": "1430889", "problem_idx": "B", "shortId": "1693B", "contest_number": "1693", "problem_submissions": {"F": [160880007, 160880972, 160861674, 160875588, 160882783, 160878948, 160890167, 160899913, 161040863, 160893311, 160892940], "E": [160864775, 160851833, 160876978, 160893451, 160863343, 160869365, 160873611, 160876701, 160883190, 160881001, 160869009, 160890042, 160889537, 160889370, 160888603, 160888570, 160884303], "D": [160848374, 160868923, 160880702, 160854200, 160854032, 160862911, 160859336, 160861278, 160860933, 160866823, 160880935, 160874455, 160855846, 160857826, 160858928, 160851586, 160859103], "C": [160833863, 160838237, 160831750, 160839496, 160831595, 160847471, 160845192, 160845432, 160842623, 160834916, 160845029, 160853816, 160836315, 160837724, 160840237, 160837127, 160842065, 160837528], "B": [160829995, 160831749, 160828393, 160835792, 160838408, 160836721, 160840343, 160837858, 160837790, 160829673, 160840637, 160838527, 160830551, 160831811, 160831387, 160832406, 160834629, 160831231], "A": [160824784, 160824733, 160824181, 160826982, 160842765, 160829489, 160836610, 160834230, 160827824, 160825693, 160827125, 160830489, 160824662, 160825298, 160825387, 160826936, 160829963, 160825879]}, "name": "B. Fake Plastic Trees", "statement": "We are given a rooted tree consisting of n vertices numbered from 1 to\r\nn. The root of the tree is the vertex 1 and the parent of the vertex v\r\nis p_v.There is a number written on each vertex, initially all numbers\r\nare equal to 0. Let\u2019s denote the number written on the vertex v as\r\na_v.For each v, we want a_v to be between l_v and r_v (l_v\r\nleq a_v\r\nleq r_v).In a single operation we do the following: Choose some vertex\r\nv. Let b_1, b_2,\r\nldots, b_k be vertices on the path from the vertex 1 to vertex v\r\n(meaning b_1 = 1, b_k = v and b_i = p_{b_{i + 1}}). Choose a\r\nnon-decreasing array c of length k of nonnegative integers: 0\r\nleq c_1\r\nleq c_2\r\nleq\r\nldots\r\nleq c_k. For each i (1\r\nleq i\r\nleq k), increase a_{b_i} by c_i. What\u2019s the minimum number of operations\r\nneeded to achieve our goal?\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint oj[nax];\nll dol[nax];\nll gor[nax];\nll tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=0;\n\tfor (int i=2; i<=n; i++)\n\t\tscanf(\"%d\", &oj[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld%lld\", &dol[i], &gor[i]);\n\tint wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]<dol[i])\n\t\t{\n\t\t\twyn++;\n\t\t\ttab[i]=gor[i];\n\t\t}\n\t\ttab[oj[i]]+=min(gor[i], tab[i]);\n\t}\n\tprintf(\"%d\\n\", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "trees"], "dificulty": "1700", "interactive": false}