{
    "link": "https://codeforces.com//contest/533/problem/F",
    "problemId": "26207",
    "problem_idx": "F",
    "shortId": "533F",
    "contest_number": "533",
    "problem_submissions": {
        "A": [
            10758806,
            41260125,
            10758808,
            10802245,
            10802137,
            10804672
        ],
        "F": [
            10756507,
            10757309,
            10756418,
            10756618,
            10756621,
            10756168,
            10757079,
            10756058,
            10757142,
            10756771,
            10757619,
            10759646,
            10756355,
            10754977,
            10755266,
            10757451,
            10757215
        ],
        "B": [
            10754115,
            10753181,
            10753247,
            10758386,
            10754046,
            10755412,
            10754879,
            10754156,
            10755561,
            10754427,
            10755399,
            10754294,
            10754859,
            10753587,
            10753864,
            10753648,
            10756961,
            10754716,
            10755774
        ],
        "E": [
            10753290,
            10754938,
            10754117,
            10754867,
            10757574,
            10755405,
            10753428,
            10753036,
            10753133,
            10753451,
            10753117,
            10753877,
            10753615,
            10753601,
            10754357,
            10753173,
            10756615,
            10756357,
            10753749,
            10753638
        ],
        "C": [
            10753054,
            10753925,
            10753515,
            10754395,
            10759452,
            10754436,
            10754096,
            10753898,
            10753485,
            10759228,
            10753726,
            10753443,
            10753028,
            10753108,
            10754551,
            10754248,
            10757723,
            10757684,
            10753241,
            10754870
        ],
        "D": [
            10759362,
            10758040,
            10759441,
            10756824,
            10799120,
            10799069
        ]
    },
    "name": "F. Encoding",
    "statement": "Polycarp invented a new way to encode strings. Let’s assume that we have\r\nstring , consisting of lowercase English letters. Let’s choose several\r\npairs of letters of the English alphabet in such a way that each letter\r\noccurs in at most one pair. Then let’s replace each letter in with its\r\npair letter if there is a pair letter for it. For example, if you chose\r\npairs (, ), (, ) and (, ), then word \"\" according to the given encoding\r\nprinciple transforms to word \"\".Polycarpus already has two strings, and\r\n. He suspects that string was obtained after applying the given encoding\r\nmethod from some substring of string . Find all positions in (), such\r\nthat can be obtained fro substring by applying the described encoding\r\noperation by using some set of pairs of English alphabet letters\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(\"%d\",&A)\n#define make2(A,B) scanf(\"%d%d\",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 210010\nconst int alp = 'z'-'a'+1;\nchar s[MAX],t[MAX];\nvector<int> wz[30],sl[30];\nint ost[30];\nint kmp[MAX*2];\nint ile[MAX];\nint q[MAX][alp];\nvector<int> gd[alp];\nvoid add(int nr,int i,int j){\n  if(nr < 0 || nr >= MAX)return;\n  if(q[nr][i]==0)q[nr][i] = j+1;\n  if(q[nr][j]==0)q[nr][j] = i+1;\n  if(q[nr][i] == j+1 && q[nr][j] == i+1)\n    ile[nr]++;\n}\nvoid licz(vector<int> &z,int il,int zy,int d){\n  int n = z.size();\n  int t = 0;\n  F(i,1,n){\n    while(t && z[i] != z[t])t = kmp[t-1];\n    if(z[i] == z[t])\n      t++;\n    kmp[i] = t;\n    if(t == il){\n      int poz = gd[d][i-il];\n      add(poz-ost[zy],zy,d);\n    }\n  }\n}\nint n,m;\nmain(){\n  make2(n,m);\n  scanf(\"%s%s\",s,t);\n  R(i,n)s[i] -= 'a';\n  R(i,m)t[i] -= 'a';\n  R(i,alp)ost[i] = -1;\n  R(i,n){\n    if(ost[s[i]]!=-1)\n      wz[s[i]].PB(i-ost[s[i]]);\n    ost[s[i]] = i;\n    gd[s[i]].PB(i);\n  }\n  R(i,alp)ost[i] = -1;\n  R(i,m){\n    if(ost[t[i]]!=-1)\n      sl[t[i]].PB(i-ost[t[i]]);\n    ost[t[i]] = i;\n  }\n  R(i,alp)sl[i].PB(-1);\n  R(i,alp)R(j,alp){\n    int pom = sl[i].size();\n    if(ost[i] == -1 || gd[j].size() == 0)continue;\n    if(pom == 1){\n      R(k,gd[j].size())\n        add(gd[j][k]-ost[i],i,j);\n      continue;\n    }\n    R(k,wz[j].size())\n      sl[i].PB(wz[j][k]);\n    licz(sl[i],pom-1,i,j);\n    sl[i].resize(pom);\n  }\n  int roz = 0;\n  R(i,alp)if(ost[i]!=-1)roz++;\n  vector<int> wyn;\n  R(i,n)if(ile[i] == roz)wyn.PB(i+1);\n  printf(\"%d\\n\",(int)wyn.size());\n  R(i,wyn.size())\n    printf(\"%d \",wyn[i]);\n  puts(\"\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Encoding.json",
    "editorial_link": "https://codeforces.com//blog/entry/17458",
    "editorial": "There are two possible ideas for solving this task.\n\nFix pair of letters x and y. Replace all letters x in S with 1s and all remaining letters with 0s. Do the same for y with string T. By using KMP algorithm or Z-function determine all positions where string T can be attached to string S so there is a match. If such condition is fullfilled for pair (x, y), and for pair (y, x) then this position is a possible match position if we use pair (x, y) and possibly some other pairs.\n\nNow for each suitable position we need to check if letters can be distributed in pairs according to the information we know. This can be done in O(sigma) where sigma?=?26  the size of the alphabet. So, this solution works in O(n?*?sigma2?+?n?*?sigma)?=?O(n?*?sigma2). It fits in time limit if implementation is efficient enough.\n\nAnother way is to perform such transformation with both strings that allows us to compare them up to letters renaming. Let's replace each letter with distance from it to the closes letter to the left from it that is the same (or with -inf if there is no such letter). Now for strings to be equal we just need to check that string T matches the substring of S in all positions except, possibly, first occurence of each letter in T. This can be done by modified prefix-function or by hashing.\n\nNow suppose we know that in some position string T is the same as string S up to renaming letters. It's not hard to determine the letter permutation for this renaming (by just checking what matches in S with first occurence of each letter in string T). Let's check that this permutation is a set of transpositions in O(sigma). So, we have a solution in O(n?*?sigma).",
    "hint": []
}