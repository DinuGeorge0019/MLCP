{
    "link": "https://codeforces.com//contest/383/problem/E",
    "problemId": "5726",
    "problem_idx": "E",
    "shortId": "383E",
    "contest_number": "383",
    "problem_submissions": {
        "B": [
            5756409,
            5751225,
            5757744,
            5753341,
            5808519,
            5808489,
            5808447,
            5758844,
            5759238,
            5752874,
            5755308,
            5752676,
            5753907,
            5753281,
            5756832,
            5755532
        ],
        "E": [
            5754649,
            5757705,
            5753388,
            5758136,
            5808454,
            5755553,
            5754159,
            5755881,
            5756030,
            5755626,
            5754883,
            5757327,
            5758405,
            5757943
        ],
        "D": [
            5753594,
            5752449,
            5752307,
            5754262,
            5808453,
            5751984,
            5752563,
            5753410,
            5753070,
            5753481,
            5755159,
            5755983,
            5755452,
            5753533,
            5756037,
            5756133,
            5757148,
            5756616,
            5755389,
            5756824
        ],
        "C": [
            5750456,
            5751886,
            5754923,
            5749119,
            5751328,
            5751146,
            5750311,
            5750868,
            5752299,
            5751003,
            5750201,
            5751936,
            5751653,
            5754669,
            5750989,
            5754841,
            5751430,
            5750434
        ],
        "A": [
            5747280,
            5747986,
            5747387,
            5747246,
            5808450,
            5747221,
            5747445,
            5747936,
            5747254,
            5748686,
            5747361,
            5747734,
            5747935,
            5748612,
            5748223,
            5747638,
            5747622,
            5749616,
            5757219
        ]
    },
    "name": "E. Vowels",
    "statement": "Iahubina is tired of so many complicated languages, so she decided to\r\ninvent a new, simple language. She already made a dictionary consisting\r\nof 3-words. A 3-word is a sequence of exactly lowercase letters of the\r\nfirst 24 letters of the English alphabet ( to ). She decided that some\r\nof the letters are vowels, and all the others are consonants. The whole\r\nlanguage is based on a simple rule: any word that contains at least one\r\nvowel is .Iahubina forgot which letters are the vowels, and wants to\r\nfind some possible correct sets of vowels. She asks Iahub questions. In\r\neach question, she will give Iahub a set of letters considered vowels\r\n(in this question). For each question she wants to know how many words\r\nof the dictionary are correct, considering the given set of\r\nvowels.Iahubina wants to know the of the squared answers to all the\r\npossible questions. There are different questions, they are all subsets\r\nof the set of the first 24 letters of the English alphabet. Help Iahub\r\nfind that number.\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nvoid norm(int *f) {\n  for (int m = (1 << 12) - 1; m >= 0; m--) {\n    int res = 0;\n    for (int sub = m;; sub = (sub - 1) & m) {\n      res += f[sub];\n      if (!sub) break;\n    }\n    f[m] = res;\n  }\n}\n\nint fir[(1 << 12) + 10], las[(1 << 12) + 10];\nint fpc[12][(1 << 12) + 10];\nint lpc[12][(1 << 12) + 10];\n\nint main() {\n  #ifdef DEBUG\n  freopen(\".in\", \"r\", stdin);\n  freopen(\".out\", \"w\", stdout);\n  #endif\n\n  int n;\n  while (scanf(\"%d\", &n) >= 1) {\n    memset(fir, 0, sizeof fir);\n    memset(las, 0, sizeof las);\n    memset(fpc, 0, sizeof fpc);\n    memset(lpc, 0, sizeof lpc);\n\n    const int FIM = (1 << 12) - 1;\n    const int LAM = FIM << 12;\n\n    vi msks(n);\n    for (int i = 0; i < n; i++) {\n      char s[4];\n      scanf(\"%s\", s);\n      int msk = 0;\n      for (int i2 = 0; s[i2]; i2++)\n        msk |= 1 << (s[i2] - 'a');\n      msks[i] = msk;\n\n      int a = msk & FIM, b = (msk & LAM) >> 12;\n      int apos = __builtin_ctz(a);\n      int bpos = __builtin_ctz(b);\n\n      if (__builtin_popcount(a) == 0) {\n        las[b]++;\n      } else if (__builtin_popcount(b) == 0) {\n        fir[a]++;\n      } else if (__builtin_popcount(a) == 1) {\n        lpc[apos][b]++;\n      } else if (__builtin_popcount(b) == 1) {\n        fpc[bpos][a]++;\n      } else {\n        assert(false);\n      }\n    }\n    eprintf(\"go\\n\");\n    norm(fir);\n    norm(las);\n    for (int i = 0; i < 12; i++)\n      norm(fpc[i]), norm(lpc[i]);\n    eprintf(\"go2\\n\");\n\n    int ans = 0;\n    for (int m = 0; m < (1 << 24); m++) { // consonant is 1, vowel is 0\n      int cnt = 0;\n     \n      // cnt <-- number of bad, that is, subsets if 'm'\n      cnt += fir[m & FIM];\n      cnt += las[(m & LAM) >> 12];\n      for (int i = 0; i < 12; i++) if (m & (1 << i))\n        cnt += lpc[i][(m & LAM) >> 12];\n      for (int i = 0; i < 12; i++) if (m & (1 << (12 + i)))\n        cnt += fpc[i][m & FIM];\n\n//      eprintf(\"cnt=%d\\n\", cnt);\n      cnt = n - cnt;\n\n/*      int rcnt = 0;\n      for (int i = 0; i < n; i++) {\n        rcnt += ((~m & msks[i]) != 0);\n      }\n      if (cnt != rcnt) {\n        eprintf(\"m=%d; found %d != expected %d\\n\", ~m & (FIM | LAM), cnt, rcnt);\n        exit(0);\n      }*/\n      ans ^= cnt * cnt;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Vowels.json",
    "editorial_link": "https://codeforces.com/blog/entry/10476",
    "editorial": "Let's iterate over all possible vowel sets. For a given set {x1, x2, ..., xk} we're interested in number of correct words from dictionary. After a precalculation, we can do it in O(k).\n\nSuppose our current vowel set is {x1, x2, ..., xk}. How many words are covered by the current vowels? By definition, we say a word is covered by a set of vowels if at least one of 3 letters of word is in vowel set. We can calculate this number using principle of inclusion and exclusion. Well denote by |v1, v2, v3, ...| = number of words containing ALL of vowels v1, v2, v3, ... . Using principle of inclusion and exclusion we get:\n\nnumber_of_words_covered = |x1| + |x2| + .. + |xk|  |x1, x2|  |x1, x3|  .... + |x1, x2, x3| + |x1, x2, x4| + .... + |xk-2, xk-1, xk|. This formula is simply a reformulation of principle of inclusion and exclusion. You can easily observe that |v1, v2, ..., vk| makes sense only when k is at most 3, as no word from input can contain 4 or more letters (and hence cant contain 4 or more vowels).\n\nExample:\n\nSuppose words are abc, abd and bcd.\n\n|a| = 2 (first 2 words both contain character a).\n\n|a, b| = 2 (as well, first 2 words contain characters a and b).\n\n|b| = 3 (all 3 words contain character b).\n\n|a, b, d| = 1 (only second word contains all 3 characters).\n\nAlso, note how principle of inclusion and exclusion works. number of words covered for vowels {a, b} is |a| + |b|  |a, b| = 2 + 3  2. Indeed, answer is 3.\n\nWe divide our problem in 3 subproblems. First one, for a vowel set, compute sum of |a|, where a is a letter from subset. Second, compute sum of |a, b|, where both a and b are letters from set. Third, compute sum of |a, b, c|, where a, b, c are letters from set. As stated, the answer is number_from_1st_step + number_from_3rd_step  number_from_2nd_step. If you followed me, youll see that we want to compute results for each subproblem in O(queryLetters).\n\nFirst subproblem can be solved trivially in O(queryLetters). Let array single[], with following meaning: single[c] is how many words contain character c. It can be trivially precomputed in O(24 * N). Note that if a word contains twice/third times a character c, it needs to be counted only one (e.g. word aba will add only 1 to single[a]). For compute result of this subproblem for a given set of vowels, Ill take all letters from set. If letter belongs to set, I add to result single[letter]. This step can be also be solved in O(1), but theres no need, since other subproblems allow only an O(queryLetters) solution.\n\nFor second and third subproblems its a little more difficult. Ill present here how to solve second subproblem and some hints for third one (if you understand second, with hints you should be able to solve third one by your own).\n\nSimilarly to first step, Ill define a matrix double[c1][c2] = how many words contain both characters c1 and c2. A trivially solution would be, for a given vowel set, take all combinations of letters c1 and c2 that belong to set and add to result value double[c1][c2]. However, this solves each query in O(queryLetters^2), which is too slow.\n\nNote, if wed have 12 letters, instead of 24, this approach would be fast enough. From here it comes a pretty classical idea in exponential optimization: meet in the middle attack. We split those 24 letters in 2 groups: first 12 letters and last 12 letters. The answer for a subset is sum of double[c1][c2] (when c1 and c2 belong to current vowel set) when\n\n1/ c1 and c2 belong to first 12 letters\n\n2/ c1 and c2 belong to last 12 letters\n\n3/ c1 belongs to first 12 letters and c2 belongs to last 12 letters\n\n1/ and 2/ can be immediately precalculated as stated above, in O(2 ^ 12 * 12 ^ 2). Well remember results for each half using bitmasks arrays. Let Half1[mask] = sum over double[c1][c2], when c1 and c2 are in first 12 letters and correspond to 1 bits of mask. Half2[mask] is defined similarly, but for last 12 letters (e.g. subset {a, c, d} corresponds to bitmask 2^0 + 2^2 + 2^3 = 13 in first half and subset {m, n, p} corresponds to bitmask 2^0 + 2^1 + 2^3 = 11 for second half). Now, for a given subset, one can answer first 2 parts in O(queryCount) worst case (read input for a query and convert it to bitmasks).\n\nHow to answer 3? With another precalculation, of course. We know c1 letter needs to be in first 12 letters and c2 needs to be in last 12 letters. The precalculation we do here is: mixed_half[mask][i] = sum over |c1, c2|, when c1 belongs to first half and is a 1 bit of mask and c2 is i-th character of second half. Hence, for a query, we can fix character from second half (c2, by iteration of query letters from second half) and know sums of |c1, c2| between it and all available characters from first half after we do this precalculation. Also, precalculation is done trivially in O(2 ^ 12 * 12^2): fix mask, fix i and then iterate over 1 bits from mask and add double[c1][c2].\n\nThird subproblem is left, but it can be done similarly to second one. Instead of double[c1][c2], well have triple[c1][c2][c3] = how many words contain all 3 characters c1, c2 and c3? We also do meet in the middle here, divide those 24 letters into 2 sets of 12 letters. We have 4 cases:\n\n1/ c1, c2, c3 belong to first half\n\n2/ c1, c2, c3 belong to second half\n\n3/ c1, c2 belong to first half and c3 to second half\n\n4/ c1 belongs to first half and c2, c3 to second half\n\n1/ and 2/ are done brute force, like in second subproblem (the only difference is we choose 3 characters instead of 2, having complexity O(2 ^ 12 * 12 ^ 3)). For 3/ and 4/ we also precompute 2 matrixes:\n\nmixed_two_one[mask][i] = c1 and c2 belong to mask from first half and c3 is i-th character from second half\n\nand\n\nmixed_one_two[mask][i] = c1 is i-th character from first half and c2, c3 belong to mask from second half.\n\nThose can also be calculated in O(2 ^ 12 * 12^3).\n\nSo precalculation part is O(2 ^ 12 * 12 ^ 3) = 7077888 operations.\n\nFor calculate answering queries complexity, take all numbers from 0 to 2^24  1 and sum their bit count. This is a well known problem, the sum is 0 * C(24, 0) + 1 * C(24, 1) + ... + 24 * C(24, 24) = 201326592. In total we get 208404480 operations. C++ source makes them in 2 seconds.",
    "hint": []
}