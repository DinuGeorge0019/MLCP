{"link": "https://codeforces.com//contest/1423/problem/J", "problemId": "749090", "problem_idx": "J", "shortId": "1423J", "contest_number": "1423", "problem_submissions": {"J": [95462948, 95462931, 95462795, 95462776, 95462759, 95462752, 95462749, 95445856, 95445842, 95445741, 95445735, 95445720, 95436077, 95435983, 94779119, 94773285, 94770663, 94778562], "C": [94789081], "I": [94786050], "F": [94784528, 94776365, 94779778, 94781062], "H": [94781814, 94783650, 94777878, 94784871], "L": [94780014, 94780685, 94786643, 94773659], "B": [94771096, 94770153, 94772426, 94771466], "K": [94770723, 94771588, 94773427, 94774938], "A": [], "D": [], "E": [], "G": []}, "name": "J. Bubble Cup hypothesis", "statement": "The Bubble Cup hypothesis stood unsolved for 130 years. Who ever proves\r\nthe hypothesis will be regarded as one of the greatest mathematicians of\r\nour time! A famous mathematician Jerry Mao managed to reduce the\r\nhypothesis to this problem:Given a number m, how many polynomials P with\r\ncoefficients in set {\r\n{0,1,2,3,4,5,6,7\r\n}} have: P(2)=m?Help Jerry Mao solve the long standing problem!\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.10.2020 16:10:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n\n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n\n  inline explicit operator bool() {\n    return cur != -1;\n  }\n\n  inline static bool is_blank(char c) {\n    return c <= ' ';\n  }\n\n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn't check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == '-') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - '0';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), \"%lf\", &n);\n    }\n    return *this;\n  }\n} fast_input;\n\n#define cin fast_input\n\nstatic struct FastOutput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t buf_pos = 0;\n  static constexpr int TMP_SIZE = 1 << 20;\n  char tmp[TMP_SIZE];\n  FILE *out = stdout;\n\n  inline void put_char(char c) {\n    buf[buf_pos++] = c;\n    if (buf_pos == BUF_SIZE) {\n      fwrite(buf, 1, buf_pos, out);\n      buf_pos = 0;\n    }\n  }\n\n  ~FastOutput() {\n    fwrite(buf, 1, buf_pos, out);\n  }\n\n  inline FastOutput& operator<<(char c) {\n    put_char(c);\n    return *this;\n  }\n\n  inline FastOutput& operator<<(const char* s) {\n    while (*s) {\n      put_char(*s++);\n    }\n    return *this;\n  }\n \n  inline FastOutput& operator<<(const string& s) {\n    for (int i = 0; i < (int) s.size(); i++) {\n      put_char(s[i]);\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline char* integer_to_string(T n) {\n    // beware of TMP_SIZE\n    char* p = tmp + TMP_SIZE - 1;\n    if (n == 0) {\n      *--p = '0';\n    } else {\n      bool is_negative = false;\n      if (n < 0) {\n        is_negative = true;\n        n = -n;\n      }\n      while (n > 0) {\n        *--p = (char) ('0' + n % 10);\n        n /= 10;\n      }\n      if (is_negative) {\n        *--p = '-';\n      }\n    }\n    return p;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {\n    return integer_to_string(n);\n  }\n\n  #if !defined(_WIN32) || defined(_WIN64)\n  inline char* stringify(__int128 n) {\n    return integer_to_string(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {\n    sprintf(tmp, \"%.17f\", n);\n    return tmp;\n  }\n\n  template <typename T>\n  inline FastOutput& operator<<(const T& n) {\n    auto p = stringify(n);\n    for (; *p != 0; p++) {\n      put_char(*p);\n    }\n    return *this;\n  }\n} fast_output;\n\n#define cout fast_output\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint d[123];\nMint dp[7];\nMint new_dp[7];\n\nint main() {\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long m;\n    cin >> m;\n    int len = 0;\n    while (m > 0) {\n      d[len++] = (m & 1);\n      m >>= 1;\n    }\n    for (int i = 0; i <= 6; i++) {\n      dp[i] = new_dp[i] = 0;\n    }\n    dp[0] = 1;\n    for (int it = len - 1; it >= 0; it--) {\n      if (d[it] == 0) {\n        // 0 -> 0..0\n        // 1 -> 0..2\n        // 2 -> 0..4\n        // 3 -> 0..6\n        // 4 -> 1..6\n        // 5 -> 3..6\n        // 6 -> 5..6\n        new_dp[0] = dp[0] + dp[1] + dp[2] + dp[3];\n        new_dp[1] = new_dp[2] = dp[1] + dp[2] + dp[3] + dp[4];\n        new_dp[3] = new_dp[4] = dp[2] + dp[3] + dp[4] + dp[5];\n        new_dp[5] = new_dp[6] = dp[3] + dp[4] + dp[5] + dp[6];\n      } else {\n        // 0 -> 0..1\n        // 1 -> 0..3\n        // 2 -> 0..5\n        // 3 -> 0..6\n        // 4 -> 2..6\n        // 5 -> 4..6\n        // 6 -> 6..6\n        new_dp[0] = new_dp[1] = dp[0] + dp[1] + dp[2] + dp[3];\n        new_dp[2] = new_dp[3] = dp[1] + dp[2] + dp[3] + dp[4];\n        new_dp[4] = new_dp[5] = dp[2] + dp[3] + dp[4] + dp[5];\n        new_dp[6] = dp[3] + dp[4] + dp[5] + dp[6];\n      }\n      swap(dp, new_dp);\n    }\n    cout << dp[0]() << '\\n';\n  }\n  debug(clock());\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "constructive algorithms", "dp", "math"], "dificulty": "2400", "interactive": false}