{
    "link": "https://codeforces.com//contest/103/problem/C",
    "problemId": "544",
    "problem_idx": "C",
    "shortId": "103C",
    "contest_number": "103",
    "problem_submissions": {
        "E": [
            594225,
            596662,
            39448090,
            39427579,
            39399437,
            595910,
            123375307,
            5405441
        ],
        "D": [
            592292,
            591569,
            591484,
            596181,
            596133,
            591648,
            592548,
            593008,
            592069,
            594057,
            593198,
            593774,
            593994,
            594003,
            593751,
            594358,
            594503,
            597893,
            597881,
            596124,
            595932,
            594188,
            592900,
            594112
        ],
        "C": [
            591729,
            592936,
            593120,
            596123,
            592928,
            591746,
            593864,
            593657,
            591747,
            592188,
            592501,
            592689,
            592235,
            591907,
            592739,
            592446,
            593652,
            592453
        ],
        "B": [
            589933,
            589502,
            590203,
            596103,
            590318,
            590585,
            590813,
            590526,
            590500,
            590943,
            590147,
            591873,
            590310,
            590700,
            590283,
            591089,
            590343,
            590573,
            591133
        ],
        "A": [
            589329,
            591835,
            589264,
            596085,
            589350,
            589466,
            589313,
            589253,
            593567,
            589432,
            589509,
            590045,
            589561,
            589677,
            589370,
            589409,
            590491
        ]
    },
    "name": "C. Russian Roulette",
    "statement": "After all the events in Orlando we all know, Sasha and Roma decided to\r\nfind out who is still the team\u2019s biggest loser. Thankfully, Masha found\r\nsomewhere a revolver with a rotating cylinder of bullet slots able to\r\ncontain exactly bullets, now the boys have a chance to resolve the\r\nproblem once and for all. Sasha selects any out of slots he wishes and\r\nputs bullets there. Roma spins the cylinder so that every of possible\r\ncylinder\u2019s shifts is equiprobable. Then the game starts, the players\r\ntake turns, Sasha starts: he puts the gun to his head and shoots. If\r\nthere was no bullet in front of the trigger, the cylinder shifts by one\r\nposition and the weapon is given to Roma for make the same move. The\r\ngame continues until someone is shot, the survivor is the winner. Sasha\r\ndoes not want to lose, so he must choose slots for bullets in such a way\r\nas to minimize the probability of its own loss. Of all the possible\r\nvariant he wants to select the lexicographically minimal one, where an\r\nempty slot is lexicographically less than a charged one. More formally,\r\nthe cylinder of bullet slots able to contain bullets can be represented\r\nas a string of characters. Exactly of them are \"\" (charged slots) and\r\nthe others are \"\" (uncharged slots). Let us describe the process of a\r\nshot. Suppose that the trigger is in front of the first character of the\r\nstring (the first slot). If a shot doesn\u2019t kill anyone and the cylinder\r\nshifts, then the string shifts left. So the first character becomes the\r\nlast one, the second character becomes the first one, and so on. But the\r\ntrigger doesn\u2019t move. It will be in front of the first character of the\r\nresulting string.Among all the strings that give the minimal probability\r\nof loss, Sasha choose the lexicographically minimal one. According to\r\nthis very string, he charges the gun. You have to help Sasha to charge\r\nthe gun. For that, each query must be answered: is there a bullet in the\r\npositions ?\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:60000000\")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint64 n, k;\nint p;\n\nint main ()\n{\n//\tfreopen (\"input.txt\", \"r\", stdin);\n//\tfreopen (\"output.txt\", \"w\", stdout);\n\tcin >> n >> k >> p;\n\tif (n == k) {\n\t\tforn (i, p)\n\t\t\tcout << \"X\";\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\tint64 l, r;\n\tl = 1;\n\tr = n;\n\tif (n < k*2) {\n\t\tint64 a = k*2-n;\n\t\tr -= a;\n\t\tn -= a;\n\t\tk -= a;\n\t}\n\tif ((n - k * 2) & 1) {\n\t\tn --;\n\t\tr --;\n\t\tk --;\n\t}\n\tif (n > k*2) {\n\t\tl += n-k*2;\n\t\tn = k*2;\n\t}\n\tforn (i, p) {\n\t\tint64 x;\n\t\tcin >> x;\n\t\tif (x < l)\n\t\t\tcout << \".\";\n\t\telse\n\t\tif (x > r)\n\t\t\tcout << \"X\";\n\t\telse {\n\t\t\tif ((x-l)&1)\n\t\t\t\tcout << \"X\";\n\t\t\telse\n\t\t\t\tcout << \".\";\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Russian Roulette.json",
    "editorial_link": "https://codeforces.com/blog/entry/2426?locale=en",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem when value is even. Obviously, if we should put\r\na bullet at most right position. For example, choose and our answer\r\nstring will be: .......X Let\u00e2\u0080\u0099s find probability of winning at this\r\nsituation. We will write zeros at losing positions and ones at winning\r\npositions: 10101010 The simple idea is to put every next bullet for\r\nnon-dropping down our winning chance as long as we can. After that we\r\nshould put bullets in lexicographically order with growing value of .\r\nLook for the answer for another \u00e2\u0080\u0099s with :\r\n.....X.X...X.X.X.X.X.X.X.X.X.XXX.X.XXXXX.XXXXXXXXXXXXXXX When is odd our\r\nreasoning will be the same with a little bit difference at the\r\nbeginning. Look at the answer with and :: ........X010101010 We may put\r\nsecond bullet as at even case. But there is exists another way, we may\r\nput our bullet at 1st position and turn left the cylinder, look here:\r\nX.......X => .......XX010101010 101010100 Obvioulsy probability of\r\nwinning was not changed but answer made better. Next steps of putting\r\nare equal to even case:\r\n.....X.XX...X.X.XX.X.X.X.XX.X.X.XXXX.X.XXXXXX.XXXXXXXXXXXXXXXXX There is\r\nno difficulties to give answers to queries.\r\n"
}