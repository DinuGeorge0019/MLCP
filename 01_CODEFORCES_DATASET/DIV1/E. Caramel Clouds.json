{
    "link": "https://codeforces.com//contest/833/problem/E",
    "problemId": "116223",
    "problem_idx": "E",
    "shortId": "833E",
    "contest_number": "833",
    "problem_submissions": {
        "E": [
            29083224,
            29083091
        ],
        "D": [
            29016770,
            29016294,
            29011617,
            29013958,
            29009345,
            29244474,
            29205082,
            29015261,
            29017136,
            29012336,
            29008041,
            29014134,
            29019073
        ],
        "C": [
            29008615,
            29008359,
            29015249,
            29038532,
            29038473,
            29013146,
            29010690,
            29004990,
            29014257,
            29023306,
            29012381,
            29014235,
            29007517,
            29015632,
            29016681
        ],
        "B": [
            29000858,
            28999434,
            29001150,
            29001528,
            29002115,
            29002974,
            29016798,
            29017661,
            29016482,
            29001800,
            29005534,
            29010788,
            29005299,
            29004648,
            29003078,
            29002266,
            29014197,
            29004174,
            28997722
        ],
        "A": [
            28994520,
            28994190,
            28994134,
            28993034,
            28994420,
            28995369,
            28994393,
            28997116,
            29011489,
            28992915,
            28994389,
            28993845,
            28993595,
            28996557,
            28993837,
            28993225,
            28994120,
            28993719,
            28995865,
            28994510
        ]
    },
    "name": "E. Caramel Clouds",
    "statement": "It is well-known that the best decoration for a flower bed in Sweetland\r\nare vanilla muffins. Seedlings of this plant need sun to grow up.\r\nSlastyona has seedlings, and the -th seedling needs at least minutes of\r\nsunlight to grow up.Most of the time it\u2019s sunny in Sweetland, but\r\nsometimes some caramel clouds come, the -th of which will appear at time\r\nmoment (minute) and disappear at time moment . Of course, the clouds\r\nmake shadows, and the seedlings can\u2019t grow when there is at least one\r\ncloud veiling the sun.Slastyona wants to grow up her muffins as fast as\r\npossible. She has exactly candies, which is the main currency in\r\nSweetland. One can dispel any cloud by paying candies. However, in order\r\nto comply with Sweetland\u2019s Department of Meteorology regulations,\r\n.Slastyona hasn\u2019t decided yet which of the seedlings will be planted at\r\nthe princess\u2019 garden, so she needs your help. For each seedling\r\ndetermine the earliest moment it can grow up if Slastyona won\u2019t break\r\nthe law and won\u2019t spend more candies than she has. Note that each of the\r\nseedlings is considered independently.The seedlings start to grow at\r\ntime moment .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int nax=1100*1007;\nconst int n1=(1<<19);\nusing ll=long long;\n\nint n;\nll c;\n\npair <ll,ll> prze[nax];\nll kosz[nax];\n\nint kt[nax];\nint gdz[nax];\n\nvector <pair <ll,int> > wek;\n\nll ost;\n\nll naj;\nll wolne;\n\nmap <int,ll> lo[nax];\nll best_lo[nax];\nll only[nax];\n\nll drz[nax];\n\nint m;\n\nint m_wsk;\npair <ll,int> zapy[nax];\nll wyn[nax];\n\nset <int> setel;\n\nvoid pisz(int v, ll w)\n{\n\tv+=n1-1;\n\twhile(v)\n\t{\n\t\tdrz[v]=max(drz[v], w);\n\t\tv>>=1;\n\t}\n}\n\nll czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t\treturn drz[v];\n\tif (a>grab || b<graa)\n\t\treturn 0;\n\treturn max(\n\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\n\t);\n}\n\nbool mniej(int a, int b)\n{\n\treturn kosz[a]<kosz[b];\n}\n\ninline void consider(int v)\n{\n\tif (kosz[v]>c)\n\t\treturn;\n\tnaj=max(naj, only[v]+best_lo[v]);\n\tint bsa=0;\n\tint bsb=n;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb+2)>>1;\n\t\tif (kosz[kt[bss]]+kosz[v]<=c)\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tnaj=max(naj, only[v]+czyt(1, 1, n1, 1, min(gdz[v]-1, bsa)));\n\tnaj=max(naj, only[v]+czyt(1, 1, n1, gdz[v]+1, bsa));\n}\n\nint main()\n{\n\tscanf(\"%d%lld\", &n, &c);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%lld%lld%lld\", &prze[i].first, &prze[i].second, &kosz[i]);\n\t\twek.push_back({prze[i].first, i});\n\t\twek.push_back({prze[i].second, -i});\n\t\tkt[i]=i;\n\t}\n\tsort(kt+1, kt+1+n, mniej);\n\tfor (int i=1; i<=n; i++)\n\t\tgdz[kt[i]]=i;\n\twek.push_back({2000*1000*1000, 0});\n\tsort(wek.begin(), wek.end());\n\tscanf(\"%d\", &m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tscanf(\"%lld\", &zapy[i].first);\n\t\tzapy[i].second=i;\n\t}\n\tsort(zapy+1, zapy+1+m);\n\tfor (auto i : wek)\n\t{\n\t\tll dlu=i.first-ost;\n\t\tost=i.first;\n\t\t\n\t\tif (setel.size()==0)\n\t\t{\n\t\t\twolne+=dlu;\n\t\t}\n\t\tif (setel.size()==1)\n\t\t{\n\t\t\tint x=(*setel.begin());\n\t\t\tonly[x]+=dlu;\n\t\t\tpisz(gdz[x], only[x]);\n\t\t\tconsider(x);\n\t\t}\n\t\tif (setel.size()==2)\n\t\t{\n\t\t\tauto it=setel.begin();\n\t\t\tint x=(*it);\n\t\t\tit++;\n\t\t\tint y=(*it);\n\t\t\tlo[x][y]+=dlu;\n\t\t\tlo[y][x]+=dlu;\n\t\t\tif (kosz[x]+kosz[y]<=c)\n\t\t\t{\n\t\t\t\tbest_lo[x]=max(best_lo[x], lo[x][y]+only[y]);\n\t\t\t\tbest_lo[y]=max(best_lo[y], lo[y][x]+only[x]);\n\t\t\t\tnaj=max(naj, only[x]+only[y]+lo[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(m_wsk<m && zapy[m_wsk+1].first<=wolne+naj)\n\t\t{\n\t\t\tm_wsk++;\n\t\t\twyn[zapy[m_wsk].second]=ost-(wolne+naj-zapy[m_wsk].first);\n\t\t}\n\t\t\n\t\tif (i.second>0)\n\t\t\tsetel.insert(i.second);\n\t\telse\n\t\t\tsetel.erase(-i.second);\n\t}\n\tfor (int i=1; i<=m; i++)\n\t\tprintf(\"%lld\\n\", wyn[i]);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "sortings"
    ],
    "dificulty": "3400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Caramel Clouds.json",
    "editorial_link": "https://codeforces.com//blog/entry/53567",
    "editorial": "scanline.The key idea is that only minutes which are covered by no more\r\nthan two clouds can contribute to the answer.Let us demonstrate how to\r\nsolve the problem for a fixed using scanline. Let\u00e2\u0080\u0099s create events: for\r\nthe start and the end of each cloud. We will then go through all the\r\nevents in ascending order of their coordinates, maintaining the\r\nfollowing values: the set of active clouds ; the count of sunny (from\r\nthe beginning!) minutes ; the array , which denotes the number of\r\nminutes covered solely by cloud ; the variable the largest number of\r\nsunny minutes we can obtain on a given prefix by deleting no more than\r\ntwo clouds; the sparse table , whose element holds the number of minutes\r\nof sunny minutes covered solely by and ; and finally, the array the\r\noptimal number of sunny minutes we can obtain if we dispel -th cloud as\r\none of the selected ones. We will also construct a treap (or BIT/segment\r\ntree if we want to), where each leaf has the index in form of the pair ,\r\nkeeping best index relative to in the subtree in each node.So, let us\r\nassume we are now considering some event with the coordinate , which is\r\ngoing to add some segment with length . If is empty, it\u00e2\u0080\u0099s enough to just\r\nincrease by . If contains exactly two elements (let\u00e2\u0080\u0099s denote them as and\r\n), we need to increase by and try to update via using and via using if\r\nit\u00e2\u0080\u0099s possible (i.e. if the sum of costs does not exceed the budget). The\r\ncase when only one element is the most interesting. We have to try to\r\nincrease both and by len consequently. What clouds may optima have also\r\nupdated for? Obviously, for every cloud which cost allows us to dispel\r\nit together the cloud . But it\u00e2\u0080\u0099s only necessary to update only for cloud\r\nwith maximal (don\u00e2\u0080\u0099t forget to delete from the tree) on range . Why? We\r\nleave this as an excercise for the reader. After that, we will either\r\nneed to remove the start of the cloud from if we are dealing with a\r\nclosing event, or to put it into otherwise.Along with aforementioned\r\noperations we can also update the variable . It\u00e2\u0080\u0099s not that hard to\r\nobserve that if , the answer would be some point of the last segment: we\r\ncan find it as .It\u00e2\u0080\u0099s also worth noting that if we are to order all the\r\nqueries in the non-descending order, the answers would be ordered the\r\nsame way. We can then process them in one go. .\r\n"
}