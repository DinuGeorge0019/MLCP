{"link": "https://codeforces.com//contest/815/problem/D", "problemId": "110362", "problem_idx": "D", "shortId": "815D", "contest_number": "815", "problem_submissions": {"B": [27864858, 27859364, 27903526, 27860492, 27852460, 27855418, 27859767, 27852085, 27859930, 27859903, 27854384, 27858144, 27855716, 27857016, 27852895, 27853886], "E": [27862063, 27864392, 27859827, 27862681, 27864496, 27861206, 27867128, 27865357, 27880319, 27880161], "D": [27858987, 27856145, 27857852, 27860187, 27858848, 27861659, 27861479, 27862104, 27862042, 27861841, 27863258, 27862833, 27864478, 27862444, 27863816, 27862729], "C": [27854913, 27853891, 27854000, 27853599, 27853527, 27856985, 27855683, 27858430, 27852703, 27859114, 27854140, 27852346, 27858894, 27853926, 27859017, 27859597, 27856510, 27857717], "A": [27848955, 27860238, 27848568, 27848584, 27855106, 27849560, 27848196, 27849865, 27848239, 27854177, 27850649, 27854333, 27856456, 27849527, 27857857]}, "name": "D. Karen and Cards", "statement": "Karen just got home from the supermarket, and is getting ready to go to\r\nsleep. After taking a shower and changing into her pajamas, she looked\r\nat her shelf and saw an album. Curious, she opened it and saw a trading\r\ncard collection.She recalled that she used to play with those cards as a\r\nchild, and, although she is now grown-up, she still wonders a few things\r\nabout it.Each card has three characteristics: , and . The values of all\r\ncharacteristics of all cards are positive integers. The maximum possible\r\nstrength any card can have is , the maximum possible defense is and the\r\nmaximum possible speed is .There are cards in her collection. The -th\r\ncard has a strength , defense and speed , respectively.A card another\r\ncard if at least two of its characteristics are than the corresponding\r\ncharacteristics of the other card.She now wonders how many different\r\ncards can beat all the cards in her collection. Two cards are considered\r\ndifferent if at least one of their characteristics have different\r\nvalues.\r\n", "solutions": ["//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst long long inf=1000*1000*1000+7;\nconst int n1=(1<<19);\n\nint n, p, q, r;\n\nstruct drz\n{\n\tdrz* lew=NULL;\n\tdrz* pra=NULL;\n\t\n\tlong long fixed=0;\n\tlong long freed=0;\n\t\n\tlong long czyt(int a, int b, int graa, int grab, long long poz)\n\t{\n\t\tif (a>=graa && b<=grab)\n\t\t{\n\t\t\t//debug() << \" na \" << a << \" \" << b << \" \" << imie(fixed) << \" \" << imie(freed);\n\t\t\treturn fixed+freed*(r-poz);\n\t\t}\n\t\tif (a>grab || b<graa)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn lew->czyt(a, (a+b)>>1, graa, grab, poz)+pra->czyt((a+b+2)>>1, b, graa, grab, poz);\n\t}\n\tdrz* fixuj(int a, int b, int cel, long long poz)\n\t{\n\t\tif (a>cel || b<cel)\n\t\t\treturn this;\n\t\tdrz *ret=new drz;\n\t\tif (a==b)\n\t\t{\n\t\t\tret->fixed=r-poz;\n\t\t\tret->freed=0;\n\t\t\treturn ret;\n\t\t}\n\t\tret->lew=lew->fixuj(a, (a+b)>>1, cel, poz);\n\t\tret->pra=pra->fixuj((a+b+2)>>1, b, cel, poz);\n\t\tret->fixed=ret->lew->fixed+ret->pra->fixed;\n\t\tret->freed=ret->lew->freed+ret->pra->freed;\n\t\treturn ret;\n\t}\n};\n\nint a[nax];\nint b[nax];\nint c[nax];\n\nvector <int> weka[nax];\nvector <int> wekc[nax];\n\ndrz* wys[nax];\n\nlong long wyn;\n\ndrz* start(int a, int b)\n{\n\tdrz* ret=new drz;\n\tif (a!=b)\n\t{\n\t\tret->lew=start(a, (a+b)>>1);\n\t\tret->pra=start((a+b+2)>>1, b);\n\t\tret->freed=ret->lew->freed+ret->pra->freed;\n\t}\n\telse\n\t{\n\t\tret->freed=(b<=q);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\", &n, &p, &q, &r);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n\t\tweka[a[i]].push_back(i);\n\t\twekc[c[i]].push_back(i);\n\t}\n\twys[r+1]=start(1, n1);\n\tint juz=0;\n\tfor (int i=r; i; i--)\n\t{\n\t\twys[i]=wys[i+1];\n\t\tfor (int j : wekc[i])\n\t\t{\n\t\t\twhile (b[j]>juz)\n\t\t\t{\n\t\t\t\tjuz++;\n\t\t\t\twys[i]=wys[i]->fixuj(1, n1, juz, i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint pra=0;\n\tint gor=0;\n\t\n\tfor (int i=p; i; i--)\n\t{\n\t\tfor (int j : weka[i])\n\t\t{\n\t\t\tpra=max(pra, b[j]);\n\t\t\tgor=max(gor, c[j]);\n\t\t}\n\t\t//debug() << \"dla \" << i << \" \" << imie(pra) << imie(gor);\n\t\twyn+=wys[gor+1]->czyt(1, n1, pra+1, q, gor);\n\t\t//debug() << wyn;\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "combinatorics", "data structures", "geometry"], "dificulty": "2800", "interactive": false}