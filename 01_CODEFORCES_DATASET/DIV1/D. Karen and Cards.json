{
    "link": "https://codeforces.com//contest/815/problem/D",
    "problemId": "110362",
    "problem_idx": "D",
    "shortId": "815D",
    "contest_number": "815",
    "problem_submissions": {
        "B": [
            27864858,
            27859364,
            27903526,
            27860492,
            27852460,
            27855418,
            27859767,
            27852085,
            27859930,
            27859903,
            27854384,
            27858144,
            27855716,
            27857016,
            27852895,
            27853886
        ],
        "E": [
            27862063,
            27864392,
            27859827,
            27862681,
            27864496,
            27861206,
            27867128,
            27865357,
            27880319,
            27880161
        ],
        "D": [
            27858987,
            27856145,
            27857852,
            27860187,
            27858848,
            27861659,
            27861479,
            27862104,
            27862042,
            27861841,
            27863258,
            27862833,
            27864478,
            27862444,
            27863816,
            27862729
        ],
        "C": [
            27854913,
            27853891,
            27854000,
            27853599,
            27853527,
            27856985,
            27855683,
            27858430,
            27852703,
            27859114,
            27854140,
            27852346,
            27858894,
            27853926,
            27859017,
            27859597,
            27856510,
            27857717
        ],
        "A": [
            27848955,
            27860238,
            27848568,
            27848584,
            27855106,
            27849560,
            27848196,
            27849865,
            27848239,
            27854177,
            27850649,
            27854333,
            27856456,
            27849527,
            27857857
        ]
    },
    "name": "D. Karen and Cards",
    "statement": "Karen just got home from the supermarket, and is getting ready to go to\r\nsleep. After taking a shower and changing into her pajamas, she looked\r\nat her shelf and saw an album. Curious, she opened it and saw a trading\r\ncard collection.She recalled that she used to play with those cards as a\r\nchild, and, although she is now grown-up, she still wonders a few things\r\nabout it.Each card has three characteristics: , and . The values of all\r\ncharacteristics of all cards are positive integers. The maximum possible\r\nstrength any card can have is , the maximum possible defense is and the\r\nmaximum possible speed is .There are cards in her collection. The -th\r\ncard has a strength , defense and speed , respectively.A card another\r\ncard if at least two of its characteristics are than the corresponding\r\ncharacteristics of the other card.She now wonders how many different\r\ncards can beat all the cards in her collection. Two cards are considered\r\ndifferent if at least one of their characteristics have different\r\nvalues.\r\n",
    "solutions": [
        "//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE'Y, MINIMALNE I MAKSYMALNE WEJ\u015aCIE I WYJ\u015aCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst long long inf=1000*1000*1000+7;\nconst int n1=(1<<19);\n\nint n, p, q, r;\n\nstruct drz\n{\n\tdrz* lew=NULL;\n\tdrz* pra=NULL;\n\t\n\tlong long fixed=0;\n\tlong long freed=0;\n\t\n\tlong long czyt(int a, int b, int graa, int grab, long long poz)\n\t{\n\t\tif (a>=graa && b<=grab)\n\t\t{\n\t\t\t//debug() << \" na \" << a << \" \" << b << \" \" << imie(fixed) << \" \" << imie(freed);\n\t\t\treturn fixed+freed*(r-poz);\n\t\t}\n\t\tif (a>grab || b<graa)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn lew->czyt(a, (a+b)>>1, graa, grab, poz)+pra->czyt((a+b+2)>>1, b, graa, grab, poz);\n\t}\n\tdrz* fixuj(int a, int b, int cel, long long poz)\n\t{\n\t\tif (a>cel || b<cel)\n\t\t\treturn this;\n\t\tdrz *ret=new drz;\n\t\tif (a==b)\n\t\t{\n\t\t\tret->fixed=r-poz;\n\t\t\tret->freed=0;\n\t\t\treturn ret;\n\t\t}\n\t\tret->lew=lew->fixuj(a, (a+b)>>1, cel, poz);\n\t\tret->pra=pra->fixuj((a+b+2)>>1, b, cel, poz);\n\t\tret->fixed=ret->lew->fixed+ret->pra->fixed;\n\t\tret->freed=ret->lew->freed+ret->pra->freed;\n\t\treturn ret;\n\t}\n};\n\nint a[nax];\nint b[nax];\nint c[nax];\n\nvector <int> weka[nax];\nvector <int> wekc[nax];\n\ndrz* wys[nax];\n\nlong long wyn;\n\ndrz* start(int a, int b)\n{\n\tdrz* ret=new drz;\n\tif (a!=b)\n\t{\n\t\tret->lew=start(a, (a+b)>>1);\n\t\tret->pra=start((a+b+2)>>1, b);\n\t\tret->freed=ret->lew->freed+ret->pra->freed;\n\t}\n\telse\n\t{\n\t\tret->freed=(b<=q);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d%d\", &n, &p, &q, &r);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n\t\tweka[a[i]].push_back(i);\n\t\twekc[c[i]].push_back(i);\n\t}\n\twys[r+1]=start(1, n1);\n\tint juz=0;\n\tfor (int i=r; i; i--)\n\t{\n\t\twys[i]=wys[i+1];\n\t\tfor (int j : wekc[i])\n\t\t{\n\t\t\twhile (b[j]>juz)\n\t\t\t{\n\t\t\t\tjuz++;\n\t\t\t\twys[i]=wys[i]->fixuj(1, n1, juz, i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint pra=0;\n\tint gor=0;\n\t\n\tfor (int i=p; i; i--)\n\t{\n\t\tfor (int j : weka[i])\n\t\t{\n\t\t\tpra=max(pra, b[j]);\n\t\t\tgor=max(gor, c[j]);\n\t\t}\n\t\t//debug() << \"dla \" << i << \" \" << imie(pra) << imie(gor);\n\t\twyn+=wys[gor+1]->czyt(1, n1, pra+1, q, gor);\n\t\t//debug() << wyn;\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "data structures",
        "geometry"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Karen and Cards.json",
    "editorial_link": "https://codeforces.com//blog/entry/52742",
    "editorial": "Let\u00e2\u0080\u0099s say we have one card, with , and . For simplicity, we have\r\n.Consider which cards will beat this one. Let\u00e2\u0080\u0099s fix the of our card, and\r\nsee what happens at all various : Note that a green cell at in grid\r\nrepresents that the card can beat the card . Hence, the total number of\r\ncards that can beat this card is simply the number of green cells across\r\nall grids.This representation is helpful, because we can easily account\r\nfor more cards. For example, let\u00e2\u0080\u0099s say we have another card , and : Now,\r\nwhat happens when we want to consider the cards that beat of these\r\ncards? Well, we simply have to consider the of both sets of grids!\r\nRemember that we are simply trying to count the total number of green\r\ncells in all grids.It turns out that trying to count the number of green\r\ncells directly is quite difficult. Instead, it is more feasible to count\r\nthe number of cells, and then simply subtract it from the number of\r\ncells .How could we do this? We should exploit some properties of the\r\ngrids.First, for any particular card , all the grids from to are the\r\nsame, and all the grids from to are the same. This means that we can\r\navoid a lot of redundancy, and only perform some sort of update when we\r\nreach the change.Second, if some cell is not green for some fixed , then\r\nneither are the cells for all and for the same . This means that we can\r\nreplace each grid with an array where is the largest for which is not\r\ngreen. Additionally, .Third, for any card, there are only at most two\r\ndistinct values in for any fixed in one card.Finally, for any card, no\r\nvalue in is less than in if .These properties are all pretty easy to\r\nobserve and prove, but they will form the bread and butter of our\r\nsolution.Let\u00e2\u0080\u0099s iterate cards from to . Suppose we maintain an array\r\nwhich will at first contain all . This will be the number of cells that\r\nare not green.We will update it for all grids first. For each card, we\r\nare essentially setting, for all , to .Of course, doing this for each\r\ngrid will take , which is too slow. To remedy this, initialize as a\r\ninstead. Now, we are basically just setting to for all cards .Because is\r\nessentially a maximum of a bunch of \u00e2\u0080\u0099s, which are all nonincreasing by\r\nthe second property, it follows that is also nonincreasing at all times.\r\nTherefore, these updates are easy to do; we are essentially setting to\r\nfor the smallest where . We can find using binary search. Binary\r\nsearching the segment tree can be done in time using an implicit binary\r\nsearch by going down the tree; an explicit binary search might have\r\ntrouble passing the time limit.Using the aforementioned procedure, we\r\nare able to generate corresponding to the layer in time. Using the\r\nsegment tree, we should also be able to get the sum of all values in at\r\nall times. This will allow us to count the number of not green\r\ncells.Now, we will go backwards from to . We should decrement , and then\r\nsee which grids changed. (Just sort the cards by and do a two-pointers\r\napproach.) All the newly-changed grids can then be updated in a similar\r\nmanner as before. When a grid changes, thanks to the fourth property,\r\nthere is no worry of any getting smaller than it was before; they can\r\nonly get bigger. So, we have to update two ranges to and to . The former\r\nis a simple range update, the latter can be done using binary search\r\nlike before.After we update all grids for a particular , get the range\r\nsum, and decrement again, and so on until we reach . We will have the\r\nfound the total number of not green cells in all , and from there we can\r\nrecover all the green cells, and hence the final answer.Sorting the\r\ncards by takes time, constructing the segment tree takes time, there are\r\nupdates each taking time, and iterating takes time. The final runtime is\r\ntherefore time, which is sufficient to solve this problem.This solution\r\ncan be modified to pass , too; however, this was not done as it uses\r\nonly standard ideas and just contains more tedious implementation. If\r\nyou want, you can try to implement it.\r\n"
}