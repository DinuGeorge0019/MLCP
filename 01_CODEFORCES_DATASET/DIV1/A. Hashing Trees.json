{
    "link": "https://codeforces.com//contest/901/problem/A",
    "problemId": "139712",
    "problem_idx": "A",
    "shortId": "901A",
    "contest_number": "901",
    "problem_submissions": {
        "D": [
            33426443,
            33425255,
            33425405,
            33421002,
            33428722,
            33432497,
            33430107,
            33431968,
            33434361,
            33433853,
            33432628,
            33428305,
            33435534,
            33423537,
            33424117,
            33433491,
            33424011,
            33435055
        ],
        "C": [
            33423246,
            33421544,
            33420578,
            33429910,
            33422327,
            33425977,
            33426202,
            33427669,
            33422440,
            33429447,
            33429169,
            33424756,
            33430999,
            33430059,
            33430695,
            33420864,
            33434365,
            33425416
        ],
        "B": [
            33419337,
            33427579,
            33429052,
            33425071,
            33431946,
            33418047,
            33432302,
            33420475,
            33497315,
            33497308,
            33496921,
            33426321,
            33423681,
            33433893,
            33426136,
            33434123
        ],
        "A": [
            33414182,
            33413377,
            33413379,
            33422716,
            33415121,
            33413643,
            33413547,
            33414284,
            33415005,
            33416374,
            33419687,
            33414307,
            33415289,
            33414435,
            33420715,
            33423860,
            33425257,
            33413347
        ],
        "E": [
            36988410
        ]
    },
    "name": "A. Hashing Trees",
    "statement": "Sasha is taking part in a programming competition. In one of the\r\nproblems she should check if some rooted trees are isomorphic or not.\r\nShe has never seen this problem before, but, being an experienced\r\nparticipant, she guessed that she should match trees to some sequences\r\nand then compare these sequences instead of trees. Sasha wants to match\r\neach tree with a sequence , where is the height of the tree, and equals\r\nto the number of vertices that are at distance of edges from root.\r\nUnfortunately, this time Sasha\u2019s intuition was wrong, and there could be\r\nseveral trees matching the same sequence. To show it, you need to write\r\na program that, given the sequence , builds two non-isomorphic rooted\r\ntrees that match that sequence, or determines that there is only one\r\nsuch tree.Two rooted trees are isomorphic, if you can reenumerate the\r\nvertices of the first one in such a way, that the index of the root\r\nbecomes equal the index of the root of the second tree, and these two\r\ntrees become equal.The height of a rooted tree is the maximum number of\r\nedges on a path from the root to any other vertex.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in[200050];\n\nint sum[200050];\n\nvector <int> Vl[200050];\nint main() {\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i <= N; i++) scanf(\"%d\", &in[i]);\n\n\tfor (i = 1; i < N; i++) if (in[i] > 1 && in[i + 1] > 1) break;\n\tif (i >= N) return !printf(\"perfect\\n\");\n\n\tint p = i;\n\tprintf(\"ambiguous\\n\");\n\tsum[0] = 1;\n\tfor (i = 1; i <= N; i++) sum[i] = sum[i - 1] + in[i];\n\n\tint st = 2;\n\tprintf(\"0 \");\n\tVl[0].push_back(1);\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = st; j <= sum[i]; j++) {\n\t\t\tprintf(\"%d \", Vl[i - 1][0]);\n\t\t\tVl[i].push_back(j);\n\t\t}\n\t\tst = sum[i] + 1;\n\t}\n\tprintf(\"\\n\");\n\tfor (i = 0; i <= N; i++) Vl[i].clear();\n\n\tst = 2;\n\tprintf(\"0 \");\n\tVl[0].push_back(1);\n\tfor (i = 1; i <= N; i++) {\n\t\tif (i != p+1) {\n\t\t\tfor (j = st; j <= sum[i]; j++) {\n\t\t\t\tprintf(\"%d \", Vl[i - 1][0]);\n\t\t\t\tVl[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d \", Vl[i - 1][1]);\n\t\t\tVl[i].push_back(st);\n\t\t\tfor (j = st + 1; j <= sum[i]; j++) {\n\t\t\t\tprintf(\"%d \", Vl[i - 1][0]);\n\t\t\t\tVl[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\tst = sum[i] + 1;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Hashing Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/56478",
    "editorial": "There are many ways to solve the problem. First of all you should build\r\nany single tree. To do this, you first build the longest path from the\r\nroot and then attach remained vertices on proper heights. Thus each\r\nvertex is either on the longest path or has parent on this path. To\r\nbuild the second tree you should use different vertices from previous\r\nlevels during construction to make it different from first tree. This is\r\nalways possible if there are two consecutive . Otherwise the tree is\r\ndetermined uniquely by sequence.\r\n"
}