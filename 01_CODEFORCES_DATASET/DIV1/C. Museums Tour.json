{
    "link": "https://codeforces.com//contest/1137/problem/C",
    "problemId": "309119",
    "problem_idx": "C",
    "shortId": "1137C",
    "contest_number": "1137",
    "problem_submissions": {
        "C": [
            51278692,
            51013174,
            51012138,
            51014594,
            51060015,
            51011758,
            51015377,
            51058095,
            51060423,
            51013462,
            51011929,
            51013820,
            51016620,
            51021729,
            51016142,
            51022376,
            51017039,
            51022733
        ],
        "D": [
            51022280,
            51016149,
            51021902,
            51016444,
            51017886,
            51022110,
            51022575,
            51017121,
            51017510,
            51026190,
            51017887,
            51020056,
            51071936,
            51020439,
            51057402,
            51015057,
            51021542,
            51016650
        ],
        "F": [
            51021456,
            51151872,
            51044265,
            208399382,
            208399328,
            51370362,
            51370305,
            56076657,
            51062431,
            51062375,
            51201422,
            51152102
        ],
        "E": [
            51015510,
            51019659,
            51017815,
            51022086,
            51024208,
            51025483,
            51015317,
            51021155,
            51026207,
            51019242,
            51116875,
            51022655,
            51043942,
            51019234,
            51021992,
            51040600
        ],
        "B": [
            51007898,
            51008699,
            51007790,
            51010637,
            51008661,
            51008854,
            51009928,
            51010030,
            51008543,
            51011271,
            51008351,
            51008938,
            51007902,
            51007130,
            51009176,
            51009835,
            51007086,
            51008751,
            51007248
        ],
        "A": [
            51006589,
            51007409,
            51005936,
            51007585,
            51007232,
            51007035,
            51007494,
            51006878,
            51006201,
            51013385,
            51006659,
            51007366,
            51005796,
            51010835,
            51007279,
            51007757,
            51009144,
            51007439,
            51005946
        ]
    },
    "name": "C. Museums Tour",
    "statement": "In the country N, there are n cities connected by m one-way roads.\r\nAlthough this country seems unremarkable, there are two interesting\r\nfacts about it. At first, a week lasts d days here. At second, there is\r\nexactly one museum in each city of the country N.Travel agency \"Open\r\nmuseums\" is developing a new program for tourists interested in museums.\r\nAgency\u2019s employees know which days each of the museums is open. The tour\r\nshould start in the capital the city number 1, and the first day of the\r\ntour must be on the first day of a week. Each day a tourist will be in\r\nsome city, watching the exposition in its museum (in case museum is open\r\ntoday), and by the end of the day, the tour either ends or the tourist\r\ngoes into another city connected by a road with the current one. The\r\nroad system of N is designed in such a way that traveling by a road\r\nalways takes one night and also all the roads are . It\u2019s allowed to\r\nvisit a city multiple times during the trip.You should develop such\r\nroute for the trip that the number of museums, possible to visit during\r\nit, is maximum.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100000;\nconst int M = 50;\n\nint n, m, d, tt, cc, last[N], scc[N][M], w[N * M], dp[N * M], px[N * M], py[N * M], qx[N * M], qy[N * M];\nvector<int> adj[N], rev_adj[N];\nbool open[N][M], visit[N][M];\n\nvoid dfs(int x, int y) {\n  visit[x][y] = true;\n  for (auto z : adj[x]) {\n    if (!visit[z][(y + 1) % d]) {\n      dfs(z, (y + 1) % d);\n    }\n  }\n  px[tt] = x;\n  py[tt] = y;\n  ++tt;\n}\n\nvoid dfs_rev(int x, int y) {\n  scc[x][y] = cc;\n  if (open[x][y] && last[x] != cc) {\n    last[x] = cc;\n    ++w[cc];\n  }\n  qx[tt] = x;\n  qy[tt] = y;\n  ++tt;\n  for (auto z : rev_adj[x]) {\n    if (scc[z][(y + d - 1) % d] == -1) {\n      dfs_rev(z, (y + d - 1) % d);\n    }\n  }\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> m >> d;\n  for (int i = 0; i < m; ++i) {\n    int from, to;\n    cin >> from >> to;\n    --from;\n    --to;\n    adj[from].push_back(to);\n    rev_adj[to].push_back(from);\n  }\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < d; ++j) {\n      open[i][j] = s[j] == '1';\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < d; ++j) {\n      if (!visit[i][j]) {\n        dfs(i, j);\n      }\n      scc[i][j] = -1;\n    }\n    last[i] = -1;\n  }\n  tt = 0;\n  for (int i = n * d - 1; ~i; --i) {\n    if (scc[px[i]][py[i]] == -1) {\n      dfs_rev(px[i], py[i]);\n      ++cc;\n    }\n  }\n  for (int i = n * d - 1; ~i; --i) {\n    int x = qx[i], y = qy[i];\n    dp[scc[x][y]] = max(dp[scc[x][y]], w[scc[x][y]]);\n    for (auto z : adj[x]) {\n      if (scc[z][(y + 1) % d] > scc[x][y]) {\n        dp[scc[x][y]] = max(dp[scc[x][y]], dp[scc[z][(y + 1) % d]] + w[scc[x][y]]);\n      }\n    }\n  }\n  cout << dp[scc[0][0]] << \"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "implementation"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Museums Tour.json",
    "editorial_link": "https://codeforces.com/blog/entry/65825",
    "editorial": "Let\u00e2\u0080\u0099s build a graph where the vertices are (, ) where u is the node for\r\noriginal graph and is a day modulo (days are indexed from to ). Then\r\nconnect (, ) to (, ) for all edges from original graph and find the\r\nstrongly connected components of this graph. For each of the SCC compute\r\nthe number of different opened museums in it. Then we just need to find\r\na path with maximum cost that begins in SCC which contains (, ). We can\r\ndo it with a dynamic programming on the DAG.The key fact is that if\r\nthere is a path from (, ) to (, ), then there is also a path from (, )\r\nto (, ) (simply go this path in original graph times more), so we won\u00e2\u0080\u0099t\r\ncount some museum twice in the dynamic programming on this graph.\r\n"
}