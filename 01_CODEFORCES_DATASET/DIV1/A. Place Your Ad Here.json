{
    "link": "https://codeforces.com//contest/542/problem/A",
    "problemId": "27149",
    "problem_idx": "A",
    "shortId": "542A",
    "contest_number": "542",
    "problem_submissions": {
        "E": [
            10988594,
            10988662,
            10988040,
            10988519,
            10989472,
            10986646,
            10986386,
            10987525,
            10987889,
            10997446,
            10987208,
            10988323,
            10987814
        ],
        "A": [
            10988183,
            10988073,
            10988917,
            10988039,
            10988066,
            10988030,
            10988339,
            10987042,
            10988676,
            10988761,
            10989522,
            10985841,
            10987459,
            10994455
        ],
        "D": [
            10986695,
            10987150,
            10987152,
            10986150,
            10986231,
            10986943,
            10990837,
            10988365,
            10989849,
            10993982,
            11035792,
            11035777,
            11035767,
            11035727,
            10990386,
            10992159,
            10990340,
            10990120,
            10987703,
            10987627
        ],
        "F": [
            10986005,
            10986369,
            10987577,
            10990309,
            10986553,
            10985927,
            10987236,
            10985531,
            10987038,
            10986965,
            10986721,
            10986640,
            10986454,
            10985938,
            10985827,
            10985838,
            10986342,
            10986368
        ],
        "C": [
            10985518,
            10985721,
            10985435,
            10985462,
            10985406,
            10986200,
            10986782,
            10986530,
            10985521,
            10986222,
            10986134,
            10985353,
            10985405,
            10985560,
            10985649,
            10985787
        ],
        "B": [
            10996302,
            11060742,
            11054057
        ]
    },
    "name": "A. Place Your Ad Here",
    "statement": "Ivan Anatolyevich’s agency is starting to become famous in the town.\r\nThey have already ordered and made TV commercial videos. Each video is\r\nmade in a special way: the colors and the soundtrack are adjusted to the\r\ntime of the day and the viewers’ mood. That’s why the -th video can only\r\nbe shown within the time range of (it is not necessary to use the whole\r\nsegment but the broadcast time should be within this segment).Now it’s\r\ntime to choose a TV channel to broadcast the commercial. Overall, there\r\nare TV channels broadcasting in the city, the -th one has viewers, and\r\nis ready to sell time to broadcast the commercial.Ivan Anatolyevich is\r\nfacing a hard choice: he has to choose exactly one video and exactly one\r\nTV channel to broadcast this video and also a time range to broadcast .\r\nAt that the time range should be chosen so that it is both within range\r\nand within range .Let’s define the of the broadcast as value the total\r\nsum of time that all the viewers of the TV channel are going to spend\r\nwatching the commercial. Help Ivan Anatolyevich choose the broadcast\r\nwith the maximum !\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 200100;\nconst int P = (1 << 19);\nconst int MAXP = (1 << 20) + 100;\n\nint N, M;\nmap <pair <int, int>, int> xmap;\nmap <pair <pair <int, int>, ll>, int> ymap;\npair <int, int> vid[MAXN];\npair <pair <int, int>, ll> chan[MAXN];\npair <int, int> crange[MAXN];\nll cscore[MAXN];\n\nll res;\npair <int, int> xres;\npair <pair <int, int>, ll> yres;\n\nint ncoord;\nmap <int, int> coord;\n\npair <int, int> arr[MAXP];\n\nvoid upd (int cloc, pair <int, int> cval)\n{\n    //cout << cloc << \" \" << cval.first << \" \" << cval.second << \"\\n\";\n    cloc += P;\n    while (cloc)\n    {\n        arr[cloc] = max (arr[cloc], cval);\n        cloc /= 2;\n    }\n}\n\npair <int, int> find (int x) // 0..x\n{\n    x++;\n    x += P;\n    pair <int, int> res = make_pair (-1e9, 0);\n    \n    while (x > 1)\n    {\n        if (x % 2 == 1)\n            res = max (res, arr[x-1]);\n        x /= 2;\n    }\n    \n    return res;\n}\n\nvoid run()\n{\n    sort (vid, vid + N);\n    sort (chan, chan + M);\n    \n    for (int i = 0; i < M; i++)\n    {\n        crange[i] = chan[i].first;\n        cscore[i] = chan[i].second;\n    }\n    \n    int cloc = 0, bmax = -1e9, bloc = 0;\n    for (int i = 0; i < M; i++)\n    {\n        while (cloc < N && vid[cloc].first <= crange[i].first)\n        {\n            if (vid[cloc].second > bmax)\n            {\n                bmax = vid[cloc].second;\n                bloc = cloc;\n            }\n            cloc++;\n        }\n        \n        if (bmax >= crange[i].first)\n        {\n            ll nval = (min (crange[i].second, bmax) - crange[i].first) * cscore[i];\n            if (nval > res)\n            {\n                //cout << bmax << \" \" << crange[i].second << \" \" << crange[i].first << \" \" << cscore[i] << \" \" << nval << \"\\n\";\n                res = nval;\n                xres = vid[bloc];\n                yres = chan[i];\n            }\n        }\n    }\n    \n    coord.clear();\n    for (int i = 0; i < N; i++)\n        coord[vid[i].second];\n    for (int i = 0; i < M; i++)\n        coord[chan[i].first.second];\n    \n    ncoord = 0;\n    for (map <int, int>::iterator it = coord.begin(); it != coord.end(); it++)\n    {\n        it->second = ncoord++;\n    }\n    \n    for (int i = 0; i < MAXP; i++)\n        arr[i] = make_pair (-1e9, 0);\n    \n    cloc = N - 1;\n    for (int i = M - 1; i >= 0; i--)\n    {\n        while (cloc >= 0 && vid[cloc].first >= crange[i].first)\n        {\n            upd (coord[vid[cloc].second], make_pair (vid[cloc].second - vid[cloc].first, cloc));\n            cloc--;\n        }\n        \n        pair <int, int> rval = find (coord[crange[i].second]);\n        if (rval.first * cscore[i] > res)\n        {\n            res = rval.first * cscore[i];\n            xres = vid[rval.second];\n            yres = chan[i];\n            \n            //cout << res << \" \" << crange[i].first << \" \" << crange[i].second << \" \" << cscore[i] << \" \" << vid[rval.second].first << \"\\n\";\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    \n    cin >> N >> M;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> vid[i].first >> vid[i].second;\n        xmap[vid[i]] = i + 1;\n    }\n    for (int i = 0; i < M; i++)\n    {\n        cin >> chan[i].first.first >> chan[i].first.second >> chan[i].second;\n        ymap[chan[i]] = i + 1;\n    }\n    \n    res = 0;\n    run();\n    \n    for (int i = 0; i < N; i++)\n        vid[i] = make_pair (-vid[i].second, -vid[i].first);\n    for (int i = 0; i < M; i++)\n        chan[i].first = make_pair (-chan[i].first.second, -chan[i].first.first);\n    \n    run();\n    \n    if (res == 0)\n    {\n        cout << res << \"\\n\";\n        return 0;\n    }\n    \n    if (xres.first < 0)\n        xres = make_pair (-xres.second, -xres.first);\n    if (yres.first.first < 0)\n        yres.first = make_pair (-yres.first.second, -yres.first.first);\n    \n    cout << res << \"\\n\";\n    cout << xmap[xres] << \" \" << ymap[yres] << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Place Your Ad Here.json",
    "editorial_link": "https://codeforces.com//blog/entry/17697",
    "editorial": "Letâs fix the TV channel window and look for a commerical having the\r\nlargest intersection with it. There are four types of commercials: lying\r\ninside the window, overlapping the window and partially intersecting the\r\nwindow from the left and from the right. Itâs easy to determine if there\r\nis overlapping commercial: itâs enough to sort commercials in increasing\r\norder of the left end and then while iterating over them from left to\r\nright, keep the minimum value of a right end of a commercial. If when we\r\npass the window and see that current value of the maximum right end is\r\nno less than then there exists a commercial overlapping our window and\r\nthe value is equal to the . Among all commercials that lie inside our\r\nwindow we need the longest one. It can be done by similar but a bit\r\nharder manner. Letâs use sweepline method. While passing through the end\r\nof the commercial , letâs assign in some data structure (like segment\r\ntree) the value in point . While passing through the end of a window,\r\nletâs calculate answer for it as a maximum on segment . By doing this,\r\nwe consider all commercials inside the window. We can process partially\r\nintersecting commercials in the similar way. While passing the right end\r\nof the commercial letâs put the value in the point in our data\r\nstructure. While passing through the right end of a window letâs\r\ncalculate the answer for it as a maximum on the segment minus . Among\r\nall answers for all commercials we need to choose the largest one. So we\r\nhave the solution in . Challenge. What if there are weights not only on\r\nwindows, but on commercials also, and those weights are multiplied with\r\nthe intersection length? You can solve this task in and get a virtual\r\nmedal!\r\n",
    "hint": []
}