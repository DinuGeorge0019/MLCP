{
    "link": "https://codeforces.com//contest/1120/problem/E",
    "problemId": "306945",
    "problem_idx": "E",
    "shortId": "1120E",
    "contest_number": "1120",
    "problem_submissions": {
        "E": [
            50758414,
            50756395,
            51349737
        ],
        "F": [
            50755440,
            50756775,
            50756923,
            50745238,
            50757783,
            50769406,
            57326050
        ],
        "D": [
            50750764,
            50751956,
            50743562,
            50751566,
            50752777,
            50751884,
            50753994,
            50750618,
            50751945,
            50752229,
            50752378,
            50752892,
            50753276,
            50756304,
            50749029,
            50755638,
            50755384,
            50755602,
            50754622
        ],
        "C": [
            50742812,
            50748170,
            50742079,
            50747757,
            50746596,
            50747930,
            50749515,
            50746554,
            50746940,
            50749954,
            50748511,
            50747866,
            50749223,
            50751278,
            50750205,
            50750042,
            50750814,
            50749510,
            50744496
        ],
        "B": [
            50741885,
            50746393,
            50748182,
            50754599,
            50753894,
            50755398,
            50768361,
            50757846,
            50749483,
            57329791
        ],
        "A": [
            50743197,
            50749514,
            50746437,
            50743945,
            50745821,
            50745101,
            50745374,
            50743501,
            50746721,
            50745328,
            50746455,
            73355086,
            50745671,
            50745395,
            50746139
        ]
    },
    "name": "E. The very same Munchhausen",
    "statement": "A positive integer a is given. Baron Munchausen claims that he knows\r\nsuch a positive integer n that if one multiplies n by a, the sum of its\r\ndigits decreases a times. In other words, S(an) = S(n)/a, where S(x)\r\ndenotes the sum of digits of the number x. Find out if what Baron told\r\ncan be true.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\nconst int vax=1007;\n//~ const int vax=3;\n\nint n;\n\nvi stos;\n\nbitset <2*vax> bylo[nax];\n\nconst int lim=500*1000;\n//~ const int lim=1e3;\n\nbool mniej(pair<pii,int> a, pair<pii,int> b)\n{\n\treturn abs(a.first.second)<abs(b.first.second);\n}\n\nvoid rek(int v, int roz, int juz, int gle)\n{\n\tif (abs(roz)>vax || gle>lim)\n\t\treturn;\n\tif (!v && !roz && juz)\n\t{\n\t\twhile((int)stos.size()>1 && !stos.back())\n\t\t\tstos.pop_back();\n\t\treverse(stos.begin(), stos.end());\n\t\tfor (int i : stos)\n\t\t\tprintf(\"%d\", i);\n\t\tprintf(\"\\n\");\n\t\texit(0);\n\t}\n\tif (bylo[v][roz+vax])\n\t\treturn;\n\tbylo[v][roz+vax]=1;\n\tvi szaf(10-(!juz));\n\tfor (int i=(!juz); i<10; i++)\n\t\tszaf[i-(!juz)]=i;\n\trandom_shuffle(szaf.begin(), szaf.end());\n\tfor (int i : szaf)\n\t{\n\t\tint x=(v+i*n);\n\t\tstos.push_back(i);\n\t\trek(x/10, roz+(x%10)*n-i, 1, gle+1);\n\t\tstos.pop_back();\n\t}\n}\n\nint main()\n{\n\t//~ srand(time(0));\n\tscanf(\"%d\", &n);\n\tfor (int h=0; h<10; h++)\n\t{\n\t\tfor (int i=0; i<nax; i++)\n\t\t\tbylo[i].reset();\n\t\trek(0, 0, 0, 0);\n\t}\n\tprintf(\"-1\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. The very same Munchhausen.json",
    "editorial_link": "https://codeforces.com//blog/entry/65679",
    "editorial": "Define the of a number as . By the balance of a digit string we mean the\r\nbalance of the corresponding number. We are gonna do the following: Find\r\nout if the solution exists. If no, print and exit. Find any string with\r\nnegative balance. Find any string with positive balance. Take their\r\nlinear combination with zero balance (maybe we pad the numbers we found\r\nby leading zeroes before this). By linear combination of several strings\r\nwe mean their concatenation where each of them can occur several times.\r\nIt is quite clear how to perform the last step. To perform the initial\r\nstep it\u00e2\u0080\u0099s convenient to introduce some lemmas. . It\u00e2\u0080\u0099s obvious more or\r\nless since if we write both numbers one under another and start\r\ncalculating their sum then the result will have sum of digits being\r\nequal to minus times the number of carries. . . Here the inequality\r\nholds according to Lemma 1. . Let . Then Now consider two cases. .Let .\r\nOne can see thatThat means that if then the answer doesn\u00e2\u0080\u0099t exist,\r\notherwise the number has non-positive balance. One can easily see that\r\nthe number always has non-negative balance, so in this case the problem\r\nis solved. has a prime divisor which is not and not .It turns out that\r\nin this case the answer always exists. Indeed, the decimal fraction is\r\ninfinite, that means that in nondecreasing and can be sufficiently\r\nlarge; and so can be since the number of trailing -s of is bounded.\r\nMeanwhile is bounded by, say, , so we always can find a string with\r\nnegative balance, and, as we mentioned above, the number always has\r\nnonnegative balance. We know two ways to perform the second step. Divide\r\nby and find the period. Let\u00e2\u0080\u0099s say that the period can be represented as\r\na string and the part before it by a string (possibly empty). Let have\r\nthe same length as and equal when being treated as an integer. We are\r\nlooking for a string of type with negative balance. One can calculate\r\nthe impact on balance of strings , and and therefore find the minimal\r\nrequired number of stings . Construct a weighted directed graph. Its\r\nvertices are numbers from to , and for each pair of numbers with and\r\nthere is an edge from to with weight and label . Informally, if we\r\ntraverse through some path from , and labels of the edges on this path\r\nare digits of some number from right to left, then the sum of weights\r\nare the current balance of (that is, if we consider only last digits\r\nwhen calculating the balance) and the last vertex represents the current\r\ncarry. Now we can find a negative cycle in this graph via Ford-Bellman\r\nalgorithm and then construct a path from to this cycle, go through the\r\ncycle required number of times (so that the final sum of weights is\r\nnegative) and then return to the zero vertex. This solution has a\r\ndisadvantage: the final answer can have a length up to . One workaround\r\nis to find, say, different possibilities of negative balance (by taking\r\nmore periods/negative cycles) and find the positive balance string by\r\ntrying all numbers from to and constructing a string with a small\r\nbalance divisible by any of negative balances. It can be done by a sort\r\nof knapsack on found positive balances. The idea is to get a big gcd of\r\nthe two found balances so that we don\u00e2\u0080\u0099t need to repeat the\r\nnegative-balance-string too many times (because among the two found\r\nstrings it is the one which can have a superlinear length). Imagine we\r\nhave infinite time and memory. Then we can say that we have states of\r\nkind similar to the states of the graph from solution 1, where for each\r\nstate and each digit (except state and digit at the same time) there is\r\na transition to . Our goal is to reach again. One can bfs over this\r\n(infinite) graph with creating new states, when needed. However,\r\ntraversing over this graph consume too much memory.It turns out that if\r\nwe don\u00e2\u0080\u0099t consider states with then there always is a solution, and this\r\nis relatively easy to come up with (and definitely easier to pass than\r\nthe previous one).\r\n"
}