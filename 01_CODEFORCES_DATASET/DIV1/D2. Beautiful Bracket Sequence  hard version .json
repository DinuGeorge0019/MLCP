{"link": "https://codeforces.com//contest/1264/problem/D2", "problemId": "486705", "problem_idx": "D2", "shortId": "1264D2", "contest_number": "1264", "problem_submissions": {"B": [66341401, 66322874, 66336572, 66329159, 66325790, 66330100, 66345009, 66330236, 66376038, 66331864, 66336631, 66328124, 66347648, 66329347, 66322983, 66344650, 66327116, 66327090, 66332056], "D2": [66339545, 66335577, 66343751, 66352069, 66344993, 66344301, 66348378, 66362083, 66352256, 66376168, 66345089, 138527512, 66378228, 66393120, 66349950, 66338137, 66353567, 66351786], "D1": [66334941, 66334668, 66343694, 66345117, 66344078, 66344165, 66344520, 66350440, 66349159, 66376114, 66339049, 66358201, 66357642, 66351611, 66357362, 66352980, 66346482, 66338263, 66345809, 66347614], "A": [66330725, 66323882, 66323064, 66323750, 66337390, 66323088, 66323240, 66323608, 66323803, 66375789, 66323639, 66328235, 66324332, 66323365, 66323990, 66326030, 66323496, 66322830, 66323987, 66323760], "C": [66326327, 66330012, 66334720, 66339910, 66341281, 66334697, 66340151, 66333112, 66337232, 66376069, 66331626, 66349943, 66341121, 66340814, 66329673, 66346210, 66334293, 66333006, 66337575, 66339417, 66355906], "E": [66322750, 66338115, 66328737, 66333356, 66334932, 66353827, 66331679, 66338428, 66427601, 66422500, 66422400, 66421563, 66419015, 66419013, 66380135, 66362673, 66361972, 66357957, 66377834, 66346874, 66338003, 66349170, 66358017, 66342846, 66355768, 66361241, 66346679], "F": [66498558, 115183857]}, "name": "D2. Beautiful Bracket Sequence  hard version ", "statement": "Let\u2019s define a correct bracket sequence and its depth as follow: An\r\nempty string is a correct bracket sequence with depth 0. If \"\" is a\r\ncorrect bracket sequence with depth d then \"\" is a correct bracket\r\nsequence with depth d + 1. If \"\" and \"\" are both correct bracket\r\nsequences then their concatenation \"\" is a correct bracket sequence with\r\ndepth equal to the maximum depth of s and t. For a (not necessarily\r\ncorrect) bracket sequence s, we define its depth as the maximum depth of\r\nany bracket sequence induced by removing some characters from s\r\n(possibly zero). For example: the bracket sequence s = \"\" has depth 2,\r\nbecause by removing the third character we obtain a correct bracket\r\nsequence \"\" with depth 2.Given a string a consists of only characters \u201d,\r\n\u201d and \u201d. Consider all (not necessarily correct) bracket sequences\r\nobtained by replacing all characters \u201d in a by either \u201d or \u201d. Calculate\r\nthe sum of all the depths of all these bracket sequences. As this number\r\ncan be large, find it modulo 998244353. in this problem can be done only\r\nif easy and hard versions of this problem was solved.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1001010;\nint lc[N],rc[N],qc[N],n;\nll s1[N],s2[N],fac[N],fnv[N];\nchar s[N];\nll ans;\nll comb(int x,int y) {\n\tif (y<0||y>x) return 0;\n\treturn fac[x]*fnv[y]%mod*fnv[x-y]%mod;\n}\nint main() {\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\trep(i,1,n+1) {\n\t\tlc[i]=lc[i-1]+(s[i]=='(');\n\t\trc[i]=rc[i-1]+(s[i]==')');\n\t\tqc[i]=qc[i-1]+(s[i]=='?');\n\t}\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tfnv[n]=powmod(fac[n],mod-2);\n\tper(i,1,n+1) fnv[i-1]=fnv[i]*i%mod;\n\tassert(fnv[0]==1);\n\tint p1=qc[n];\n\tfor (int i=0;i<=p1;i++) s1[i]=comb(p1,i);\n\tfor (int i=1;i<=p1;i++) s1[i]=(s1[i-1]+s1[i])%mod;\n\tif (p1>0) {\n\t\tint p2=qc[n]-1;\n\t\tfor (int i=0;i<=p2;i++) s2[i]=comb(p2,i);\n\t\tfor (int i=1;i<=p2;i++) s2[i]=(s2[i-1]+s2[i])%mod;\n\t}\n\tfor (int pos=1;pos<=n;pos++) {\n\t\tif (s[pos]==')') continue;\n\t\tint f=qc[pos-1], g=qc[n]-qc[pos];\n\t\tint a=1+lc[pos-1],b=(rc[n]-rc[pos]);\n\t\tint w=min(g+b-a,f+g);\n\t\tif (w>=0) {\n\t\t\tif (f+g==qc[n]) ans+=s1[w];\n\t\t\telse ans+=s2[w];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans%mod);\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "probabilities"], "dificulty": "2900", "interactive": false}