{
    "link": "https://codeforces.com//contest/1601/problem/A",
    "problemId": "1157777",
    "problem_idx": "A",
    "shortId": "1601A",
    "contest_number": "1601",
    "problem_submissions": {
        "F": [
            133036741,
            133030850,
            133053471,
            133036776,
            136096402,
            133146246
        ],
        "E": [
            133012503,
            133009950,
            133010165,
            133012509,
            133023042,
            133010446,
            133029069,
            133020546,
            133026708,
            133026848,
            133096129,
            133096027,
            133009106,
            133031363,
            133005130,
            133031540,
            133037221,
            133324190,
            133128643,
            133007675,
            133037406
        ],
        "D": [
            133003986,
            133005946,
            133003145,
            133019481,
            133007804,
            133008410,
            133020273,
            133009176,
            133009157,
            133008849,
            133009299,
            133026582,
            133008809,
            133014147,
            133008199,
            133009583,
            133010326,
            133056419,
            133004546,
            133008768
        ],
        "C": [
            132999482,
            132998781,
            132997710,
            132998487,
            133003047,
            133002651,
            133001118,
            133000071,
            133003217,
            132998126,
            133000279,
            133000540,
            133004698,
            133023294,
            133006018,
            133000684,
            132998660,
            133001622,
            133009000,
            133004643
        ],
        "B": [
            132991406,
            132991376,
            132992870,
            132992842,
            132992304,
            132995590,
            132995226,
            132992037,
            132995055,
            132990916,
            132993158,
            132995079,
            132994798,
            132993699,
            132996347,
            133113107,
            132993962,
            132993893,
            132997201,
            132995373,
            132994895
        ],
        "A": [
            132984771,
            132984572,
            132985020,
            132988648,
            132985081,
            132985096,
            132984905,
            132984874,
            132986113,
            132984658,
            132986695,
            132985767,
            132986320,
            132985605,
            132985251,
            132987796,
            132985532,
            132985036,
            132986108,
            132986609
        ]
    },
    "name": "A. Array Elimination",
    "statement": "You are given array a_1, a_2,\r\nldots, a_n, consisting of non-negative integers.Let\u2019s define operation\r\nof \"elimination\" with integer parameter k (1\r\nleq k\r\nleq n) as follows: Choose k distinct array indices 1\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nle n. Calculate x = a_{i_1} \u00a0\r\n& \u00a0 a_{i_2} \u00a0\r\n& \u00a0\r\nldots \u00a0\r\n& \u00a0 a_{i_k}, where\r\n& denotes the bitwise AND operation (notes section contains formal\r\ndefinition). Subtract x from each of a_{i_1}, a_{i_2},\r\nldots, a_{i_k}; all other elements remain untouched. Find all possible\r\nvalues of k, such that it\u2019s possible to make all elements of array a\r\nequal to 0 using a finite number of elimination operations with\r\nparameter k. It can be proven that exists at least one possible k for\r\nany array a.Note that you .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[200005], c[35];\nint gcd(int x, int y)\n{\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nvoid solve()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) scanf(\"%d\", &a[i]);\n\tmemset(c, 0, sizeof(c));\n\trep(i, n) rep(j, 30) if(a[i] >> j & 1) c[j] ++;\n\tint r = 0;\n\trep(i, 30) r = gcd(r, c[i]);\n\trep1(i, n) if(r % i == 0) printf(\"%d \", i); printf(\"\\n\");\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T --) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Array Elimination.json",
    "editorial_link": "https://codeforces.com//blog/entry/95865",
    "editorial": "Let\u00e2\u0080\u0099s note, that in one destruction for any bit () we either change all\r\n-th non-zero bits into zero bits, or nothing changes. So, the number of\r\n-th non-zero bits in the array either decreases by or doesn\u00e2\u0080\u0099t change. In\r\nthe end, all these numbers will be equal to . So, to be able to destruct\r\nthe array, the number of -th non-zero bits in the array should be\r\ndivisible by for all bits .Let\u00e2\u0080\u0099s prove, that it is enough to destruct\r\nthe array. Let\u00e2\u0080\u0099s make operations with non-zero AND, while we can make\r\nthem. In the end, there is at least one non-zero element, if we have not\r\ndestructed the array. So, there is at least one bit , for which the\r\nnumber of -th non-zero bits in the array is non-zero, so this number is\r\nat least (because it is divisible by ). So we can select numbers with\r\n-th non-zero bit to the next operation and make the new destruction,\r\nwhich is impossible.So the resulting solution is: for each bit () let\u00e2\u0080\u0099s\r\nfind the number of array\u00e2\u0080\u0099s elements with non-zero -th bit. Let\u00e2\u0080\u0099s find\r\nall common divisors () of these numbers.Time complexity is , where upper\r\nlimit on all numbers in the array.\r\n"
}