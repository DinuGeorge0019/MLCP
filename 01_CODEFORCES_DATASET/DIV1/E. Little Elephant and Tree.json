{"link": "https://codeforces.com//contest/258/problem/E", "problemId": "2446", "problem_idx": "E", "shortId": "258E", "contest_number": "258", "problem_submissions": {"D": [2814736, 2812430, 2814871, 2814961, 2812733, 2815597, 2815735, 3321861, 2817362, 2813664, 2817783, 2816087, 2814924], "E": [2813546, 2815005, 2813362, 2813842, 2813877, 2813261, 2811449, 2814046, 2814079, 2814422, 2814320, 2814528, 2814704, 2817438, 2817366, 2817363, 2817357, 2817344, 2817287, 2817270, 2814834], "C": [2811749, 2809654, 2812462, 2812301, 2814561, 2810964, 2812259, 2812879, 2811632, 2812613, 2812711, 2812609, 2811716, 2810788, 2813202, 2812348, 2813127], "B": [2809756, 2813180, 2810688, 2811171, 2811678, 2809679, 2814549, 2809883, 2810504, 2810872, 2811182, 2813077, 2812214, 2811807, 2810280, 2810608], "A": [2807475, 2810109, 2807417, 2807993, 2807422, 2807498, 2807514, 2808316, 2807507, 2807423, 2807995, 2807416, 2807421, 2807426, 2807559]}, "name": "E. Little Elephant and Tree", "statement": "The Little Elephant loves trees very much, he especially loves root\r\ntrees.He\u2019s got a tree consisting of nodes (the nodes are numbered from 1\r\nto ), with root at node number . Each node of the tree contains some\r\nlist of numbers which initially is empty. The Little Elephant wants to\r\napply operations. On the -th operation he first adds number to lists of\r\nall nodes of a subtree with the root in node number , and then he adds\r\nnumber to lists of all nodes of the subtree with root in node .After\r\napplying all operations the Little Elephant wants to count for each node\r\nnumber the number of integers , such that the lists of the -th and the\r\n-th nodes contain at least one common number.Help the Little Elephant,\r\ncount numbers for him.\r\n", "solutions": ["#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing std::vector;\nusing std::pair;\nusing std::make_pair;\n\n#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i) \n\nconst int N = 100000;\n\nint n, m, label_count, label[N], size[N], position[N];\nvector <int> tree[N];\n\nvoid dfs(int p, int u) {\n    label[u] = label_count ++;\n    position[label[u]] = u;\n    size[u] = 1;\n    foreach (iter, tree[u]) {\n        if (*iter != p) {\n            dfs(u, *iter);\n            size[u] += size[*iter];\n        }\n    }\n}\n\nint a[N], b[N];\n\nvector <pair <int, int> > events;\n\nint get_id(int l, int r) {\n    return l + r | l != r;\n}\n\nint cover[N << 1], total[N << 1];\n\nvoid update(int l, int r) {\n    int m = l + r >> 1;\n    total[get_id(l, r)] = total[get_id(l, m)] + total[get_id(m + 1, r)];\n    if (cover[get_id(l, r)]) {\n        total[get_id(l, r)] = r - l + 1;\n    }\n}\n\nvoid modify(int l, int r, int a, int b, int c) {\n    if (b < l || r < a) {\n        return;\n    }\n    if (a <= l && r <= b) {\n        cover[get_id(l, r)] += c;\n        if (l == r) {\n            total[get_id(l, r)] = cover[get_id(l, r)] > 0;\n        } else {\n            update(l, r);\n        }\n        return;\n    }\n    int m = l + r >> 1;\n    modify(l, m, a, b, c);\n    modify(m + 1, r, a, b, c);\n    update(l, r);\n}\n\nint answer[N];\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n - 1; ++ i) {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a --, b --;\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    label_count = 0;\n    dfs(-1, 0);\n    for (int i = 0; i < m; ++ i) {\n        scanf(\"%d%d\", a + i, b + i);\n        a[i] --;\n        b[i] --;\n        events.push_back(make_pair(label[a[i]], i << 1));\n        events.push_back(make_pair(label[a[i]] + size[a[i]], (i << 1) | 1));\n        events.push_back(make_pair(label[b[i]], i << 1));\n        events.push_back(make_pair(label[b[i]] + size[b[i]], (i << 1) | 1));\n    }\n    std::sort(events.begin(), events.end());\n    memset(cover, 0, sizeof(cover));\n    for (int now = 0, pt = 0; now < n; ++ now) {\n        while (pt < (int)events.size() && events[pt].first == now) {\n            int id = events[pt].second >> 1;\n            int delta = (events[pt].second & 1) ? -1 : 1;\n            modify(0, n - 1, label[a[id]], label[a[id]] + size[a[id]] - 1, delta);\n            modify(0, n - 1, label[b[id]], label[b[id]] + size[b[id]] - 1, delta);\n            pt ++;\n        }\n        answer[position[now]] = std::max(total[get_id(0, n - 1)] - 1, 0);\n    }\n    for (int i = 0; i < n; ++ i) {\n        printf(\"%d%c\", answer[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "trees"], "dificulty": "2400", "interactive": false}