{
    "link": "https://codeforces.com//contest/1483/problem/E",
    "problemId": "931274",
    "problem_idx": "E",
    "shortId": "1483E",
    "contest_number": "1483",
    "problem_submissions": {
        "F": [
            110657198,
            110657366,
            110680394,
            110676074,
            110665233,
            113439308,
            113059400,
            111430671,
            111430417
        ],
        "D": [
            110640647,
            110642867,
            110640739,
            110649362,
            110656109,
            110648351,
            110669875,
            110646025,
            110641671,
            110641253,
            110642818,
            110645567,
            110644771,
            110644923,
            110644779,
            110648343,
            110645625,
            110649200,
            110647913
        ],
        "C": [
            110637482,
            110639495,
            110638107,
            110639034,
            110636245,
            110643783,
            110646712,
            110639119,
            110637748,
            110637078,
            110639242,
            110639215,
            110640002,
            110638528,
            110640575,
            110640398,
            110641125,
            110641145,
            110641078,
            110642087
        ],
        "B": [
            110634536,
            110634072,
            110635529,
            110635361,
            110642670,
            110636167,
            110639544,
            110634766,
            110633516,
            110637084,
            110643607,
            110635632,
            110634992,
            110636625,
            110637243,
            110635431,
            110638777,
            110635673,
            110637846
        ],
        "A": [
            110629442,
            110628350,
            110629067,
            110628964,
            110631520,
            110629138,
            110634726,
            110632933,
            110628500,
            110629504,
            110630632,
            110632453,
            110628740,
            110630017,
            110629975,
            110630962,
            110628508,
            110633725,
            110630402,
            110630508
        ],
        "E": [
            110660726,
            110669157,
            204375141,
            110665918,
            110662689,
            110666386,
            110657015,
            113441196,
            113891758,
            110672789,
            111426124,
            110692107
        ]
    },
    "name": "E. Vabank",
    "statement": "Gustaw is the chief bank manager in a huge bank. He has unlimited access\r\nto the database system of the bank, in a few clicks he can move any\r\namount of money from the bank’s reserves to his own private account.\r\nHowever, the bank uses some fancy AI fraud detection system that makes\r\nstealing more difficult.Gustaw knows that the anti-fraud system just\r\ndetects any operation that exceeds some fixed limit M euros and these\r\noperations are checked manually by a number of clerks. Thus, any fraud\r\noperation exceeding this limit is detected, while any smaller operation\r\ngets unnoticed.Gustaw doesn’t know the limit M and wants to find it out.\r\nIn one operation, he can choose some integer X and try to move X euros\r\nfrom the bank’s reserves to his own account. Then, the following\r\nhappens. If X\r\nle M, the operation is unnoticed and Gustaw’s account balance raises by\r\nX euros. Otherwise, if X > M, the fraud is detected and cancelled.\r\nMoreover, Gustaw has to pay X euros from his own account as a fine. If\r\nhe has less than X euros on the account, he is fired and taken to the\r\npolice. Initially Gustaw has 1 euro on his account. Help him find the\r\nexact value of M in no more than 105 operations without getting him\r\nfired.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don't erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn't exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = \"{\"; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += \"}\"; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn \"{\"+ts_sep(v,\", \")+\"}\"; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += \",\";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = \" \"; if (i == 0) bef = \"{\";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += \"}\";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\"\",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << endl; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\" \",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,\" | \",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << \"Line(\" << line << \") -> [\" << names << \"]: \"; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << \"\\n\\n\" << ts_sep(ts_lev<lev>(t),\"\\n\") << \"\\n\" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don't actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(str s = \"\") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+\".in\"), setOut(s+\".out\"); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n// ll M;\n// const int BIG = 3001;\n// ll dp[BIG][BIG];\n\n// const ll BIG = 1e14;\nconst ll BIG = 1e14;\n\nmt19937_64 RNG;\n// ll _M = RNG()%BIG+1;\n// ll _M = 8117031;\nint max_cnt;\n\nvoid solve(int tc) {\n\tll cur = 1;\n\tll L = 0, R = BIG;\n\tauto ad = [&](ll x) {\n\t\tassert(x <= cur);\n\t\tps(\"?\",x);\n\t\tstr s; \n\t\t// if (x <= _M) s = \"Lucky\";\n\t\t// else s = \"F\";\n\t\tre(s);\n\t\tif (s[0] == 'L') {\n\t\t\tckmax(L,x);\n\t\t\tcur += x;\n\t\t} else {\n\t\t\tckmin(R,x-1);\n\t\t\tcur -= x;\n\t\t}\n\t};\n\tauto eval = [&](ll cur, ll L, ll R) -> db {\n\t\tif (R-L == 0) return -INF;\n\t\treturn log(R)-log(min(100*R,cur))+log(R-L);\n\t};\n\tint cnt = 0;\n\twhile (L < R) {\n\t\t++cnt;\n\t\t// dbg(\"HA\",cnt,cur,L,R);\n\t\tif (cur == 1 || cur <= L) {\n\t\t\tad(cur);\n\t\t\tcontinue;\n\t\t}\n\t\t// db mn = INF;\n\t\tll best_mov = -1;\n\t\tauto get_val = [&](ll i) {\n\t\t\tdb a = eval(cur+i,max(i,L),R);\n\t\t\tif (L < i) ckmax(a,eval(cur-i,L,i-1));\n\t\t\treturn a;\n\t\t};\n\t\tauto ternary = [&]() {\n\t\t\tll lo = 1, hi = min(cur-1,R);\n\t\t\twhile (lo < hi) {\n\t\t\t\tll mid = (lo+hi)/2;\n\t\t\t\tif (get_val(mid) < get_val(mid+1)) hi = mid;\n\t\t\t\telse lo = mid+1;\n\t\t\t}\n\t\t\tbest_mov = lo;\n\t\t};\n\t\t// auto ternary = [&]() {\n\t\t// \tfor (ll i = 1; i <= cur-1; ++i) if (cur+i <= R) \n\t\t// \t\tif (best_mov == -1 || get_val(i) < get_val(best_mov)) best_mov = i;\n\t\t// };\n\t\t\n\t\tternary();\n\t\t// dbg(\"BEST MOV\",cur,L,R,best_mov);\n\t\t\n\t\t// FOR(i,1,cur) if (cur+i <= R) {\n\t\t// \tdb a = eval(cur+i,max(cur+i,L),R);\n\t\t// \tif (L < cur+i) ckmax(a,eval(cur-i,L,cur+i-1));\n\t\t// \tif (a < mn) {\n\t\t// \t\tmn = a;\n\t\t// \t\tbest_mov = i;\n\t\t// \t}\n\t\t// }\n\t\tad(best_mov);\n\t}\n\tckmax(max_cnt,cnt);\n\t// assert(L == _M);\n\tps(\"!\",L);\n\t// re(M);\n\n\t// ll so_far = 0;\n\t// FOR(b,1,BIG) {\n\t// \tROF(a,1,b) { // somewhere in [a,b]\n\t// \t\tdp[a][b] = INF;\n\t// \t\tFOR(x,1,a) if (a+x <= b) {\n\t// \t\t\tll bes = dp[a+x][b]+1;\n\t// \t\t\tif (x > 1) {\n\t// \t\t\t\t// a to a+x-1\n\t// \t\t\t\t// a-x\n\t// \t\t\t\tll cur = a-x, ad = 1;\n\t// \t\t\t\twhile (2*cur < a) cur *= 2, ++ad;\n\t// \t\t\t\tckmax(bes,min(dp[cur][a+x-1]+ad,dp[a][a+x-1]+ad+1));\n\t// \t\t\t\t// ckmax(got,dp[a-x][a+x-1]);\n\t// \t\t\t\t// int ad = 1;\n\t// \t\t\t\t// int cur = a-x;\n\t// \t\t\t\t// while (2*cur < a) {\n\t// \t\t\t\t// \tcur *= 2;\n\t// \t\t\t\t// \t++ad;\n\t// \t\t\t\t// }\n\t// \t\t\t\t// ckmax(got,dp[cur][a+x-1]+ad);\n\t// \t\t\t\t// ckmax(got,dp[][])\n\t// \t\t\t}\n\t// \t\t\tckmin(dp[a][b],bes);\n\t// \t\t}\n\t// \t\tif (a == 1) ckmin(dp[a][b],dp[2*a][b]+1);\n\t// \t}\n\t// \tif (dp[1][b] > so_far) {\n\t// \t\tso_far = dp[1][b];\n\t// \t\tps(b,so_far);\n\t// \t}\n\t// \t// ps(b,dp[1][b]);\n\t// }\n\t// FOR(b,1,1001) {\n\t// \tll tmp = 0;\n\t// \tFOR(a,1,b+1) ckmax(tmp,dp[a][b]);\n\t// \tdbg(b,tmp);\n\t// }\n\n\t// ll a = 1, b = 1e14;\n\t// while (a < b) {\n\t// \t// a+x, b\n\t// \t// a-x, a+x-1\n\n\t// \t// a+1,b\n\t// \t// a-1,a\n\t// }\n}\n\nint main() {\n\tsetIO();\n\t// rep(10000) {\n\t// \t_M = rng()%BIG+1;\n\t// \tsolve(_);\n\t// \tdbg(max_cnt);\n\t// }\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "interactive"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Vabank.json",
    "editorial_link": "https://codeforces.com//blog/entry/88963",
    "editorial": "Our solution consists of two parts. First of all find an upper bound for M\n. To achieve this, we try to query 1\n, 2\n, 4\n, 8\n and so on until we fail. After the first unsuccessful query we will have 0\n euro and know that the answer is on some segment [2k,2k+1)\n. It takes at most 47 queries.\n\nNow one could do something like the following binary search: take the left border of our segment of money, then on each query try the left border and then the middle. If the queries are successful then all good, otherwise we lose L+R?L2\n, where L\n is taken at the beginning of this iteration, and all R?L2\n cannot sum up into something greater than the initial left border we obtained, because initially R?L=L\n, and each time R?L\n decreases twice. However, this solution requires another 2log(1014)\n queries, which is too much.\n\nLet's divide the segment into two non-equal parts sometimes. Note that if the left side of the partition doesn't exceed half of the segment then that extra L\n we have is enough to cover all our expenses. Also let's use that we actually get extra M?L+R2\n after successful middle queries.\n\nWe want our algorithm to look something like the following. Let the current segment equal [l,r]\n. and the current balance is at least l?y+(r?l)\n for some integer y\n. Then if y=0\n then we query l\n, and if y>1\n then we query whatever we want on the segment. It is easy to see that after an unsuccessful query our balance is at least l?(y?1)+(r?l)\n (for new l\n and r\n), and after a successful query, we will think that our balance is at least l?(y+1)+(r?l)\n (for new l\n or r\n). The latter is not always the case, we will discuss that later.\n\nNow our balance is described by the only integer y\n. Let dp[x][y]\n equal the maximal d\n so that it's possible to find the answer on [l,l+d]\n having y?l+d\n money initially. Then dp[x][y]=dp[x?1][y?1]+dp[x?1][y+1]\n, it is easy to compute and follow in the solution. One can show that dp[k][0]=(k[k/2])\n. It implies that k?49\n. This adds up to 97 queries.\n\nNow remember that, if we proceed from (l,r,y)\n to (m,r,y+1)\n, then our balance was y?l+(r?l)\n and became y?l+m\n, while we need (y+1)?m\n for our estimations. Hence we need some extra cash to cover such \"expenses\". It can be proven that they don't exceed three of initial L\n-s, which gives the total of 100 queries.",
    "hint": []
}