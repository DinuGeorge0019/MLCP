{
    "link": "https://codeforces.com//contest/781/problem/D",
    "problemId": "96952",
    "problem_idx": "D",
    "shortId": "781D",
    "contest_number": "781",
    "problem_submissions": {
        "B": [
            25258392,
            25257297,
            25250177,
            25250748,
            25251116,
            25249653,
            25250716,
            25250834,
            25250705,
            25251947,
            25250575,
            31121662,
            25252893,
            25252683,
            25253146,
            25255775,
            25252991,
            25253498
        ],
        "E": [
            25256397,
            25254067,
            25258825,
            25260075,
            26145785,
            25259028,
            25259758,
            25260563,
            25260848,
            25261488,
            25260086,
            25703349,
            25261912,
            25262169,
            25262264,
            25261946,
            25261665,
            25262876,
            25262009
        ],
        "D": [
            25252423,
            25259248,
            25255529,
            25254368,
            25256042,
            25256267,
            25256774,
            25256075,
            25254834,
            25256057,
            25266603,
            25256151,
            25257817,
            25258124,
            25258109,
            25258052,
            25258679,
            25258333
        ],
        "C": [
            25249500,
            25249747,
            25251802,
            25252056,
            25252378,
            25250971,
            25252726,
            25253382,
            25252087,
            25253151,
            25252105,
            25254478,
            25253975,
            25254827,
            25254070,
            25255284,
            25254950
        ],
        "A": [
            25247143,
            25247027,
            25247783,
            25247695,
            25248775,
            25247133,
            25247620,
            25248678,
            25249108,
            25249147,
            25247139,
            25249553,
            25248502,
            25248323,
            25249740,
            25249518,
            25247402
        ],
        "F": [
            25268984,
            25267317,
            25271843,
            25271410,
            25271394,
            25271157,
            25270611,
            26202615
        ]
    },
    "name": "D. Axel and Marston in Bitland",
    "statement": "A couple of friends, Axel and Marston are travelling across the country\r\nof Bitland. There are towns in Bitland, with some pairs of towns\r\nconnected by one-directional roads. Each road in Bitland is either a\r\npedestrian road or a bike road. There can be multiple roads between any\r\npair of towns, and may even be a road from a town to itself. However, no\r\npair of roads shares the starting and the destination towns along with\r\ntheir types simultaneously.The friends are now located in the town 1 and\r\nare planning the travel route. Axel enjoys walking, while Marston\r\nprefers biking. In order to choose a route diverse and equally\r\ninteresting for both friends, they have agreed upon the following\r\nprocedure for choosing the road types during the travel: The route\r\nstarts with a pedestrian route. Suppose that a beginning of the route is\r\nwritten in a string of letters P (pedestrain road) and B (biking road).\r\nThen, the string is appended to , where stands for the string with each\r\ncharacter changed to opposite (that is, all pedestrian roads changed to\r\nbike roads, and vice versa).In the first few steps the route will look\r\nas follows: P, PB, PBBP, PBBPBPPB, PBBPBPPBBPPBPBBP, and so on.After\r\nthat the friends start travelling from the town 1 via Bitlandian roads,\r\nchoosing the next road according to the next character of their route\r\ntype each time. If it is impossible to choose the next road, the friends\r\nterminate their travel and fly home instead.Help the friends to find the\r\nlongest possible route that can be travelled along roads of Bitland\r\naccording to the road types choosing procedure described above. If there\r\nis such a route with more than roads in it, print -1 instead.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:1000000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\n\nusing namespace std;\n\nint n;\nconst uint U1 = 1;\nconst int MAXN = 501;\n\nstruct matrix\n{\n\tbitset <MAXN> a[MAXN];\n};\n\nvoid make_null(matrix & m1)\n{\n\tfor (int i = 0; i < MAXN; i++) m1.a[i].reset();\n}\n\nmatrix mul(const matrix &m1, const matrix &m2)\n{\n\tmatrix ans;\n\tmake_null(ans);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (m1.a[i][j] == 0) continue;\n\t\t\tans.a[i] |= m2.a[j];\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nconst int MV = 62;\nmatrix mt[2][MV];\nbitset <MAXN> b;\nbitset <MAXN> nb;\nconst ll INF = 1000ll * 1000ll * 1000ll * 1000ll * 1000ll * 1000ll;\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tint m;\n\tcin >> n >> m;\n\tmake_null(mt[0][0]);\n\tmake_null(mt[1][0]);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u, v, t;\n\t\tcin >> u >> v >> t;\n\t\tmt[t][0].a[u][v] = 1;\n\t}\n\tfor (int i = 1; i < MV; i++)\n\t{\n\t\tmt[0][i] = mul(mt[0][i - 1], mt[1][i - 1]);\n\t\tmt[1][i] = mul(mt[1][i - 1], mt[0][i - 1]);\n\t}\n\tint ct = 0;\n\tll ans = 0;\n\tb.reset();\n\tb[1] = 1;\n\tfor (int i = MV - 1; i >= 0; i--)\n\t{\n\t\tnb.reset();\n\t\tfor (int st = 1; st <= n; st++)\n\t\t{\n\t\t\tif (!b[st]) continue;\n\t\t\tnb |= mt[ct][i].a[st];\n\t\t}\n\t\tif (nb.count() != 0)\n\t\t{\n\t\t\tb = nb;\n\t\t\tct = 1 - ct;\n\t\t\tans += (1ll << i);\n\t\t}\n\t}\n\tif (ans > INF) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "graphs",
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Axel and Marston in Bitland.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "Let us write for the binary string obtained after inverse-append steps,\r\nfor example, , , and so on. Let us also write . By definition we must\r\nhave , and .Let us store matrices and , with entries equal to 1 for\r\npairs of vertices such that there is a /-path from to . Note that and\r\nare exactly the adjacency matrices with 0- and 1-arcs respectively.Next,\r\nnote that if and only if there is a vertex such that , and a similar\r\ncondition can be written for . It follows that and can be computed using\r\nand in time (the method is basically boolean matrix multiplication: ,\r\n).To use the matrices and to find the answer, let us store the largest\r\nanswer found, and the set of vertices reachable from the vertex 1 in\r\nexactly steps. Let\u00e2\u0080\u0099s process by decreasing from a certain value , and\r\nsee if can be increased by . The next characters after -th position will\r\nform the string or depending on the popcount parity of . Let\u00e2\u0080\u0099s denote\r\nthe set of vertices reachable from following . If is non-empty, we can\r\nincrease by , and assign , otherwise, we don\u00e2\u0080\u0099t change anything. In the\r\nend, will be the maximal path length as long as it at less than .Note\r\nthat we can take since we don\u00e2\u0080\u0099t care about exact value of answer if it\r\nis greater than . This results in an solution, which is too slow.\r\nHowever, optimizing boolean multiplication with bitsets cuts the working\r\ntime times, and the solution is now fast enough.Complexity: time, and\r\nmemory. Here , and is the word length in bits.\r\n"
}