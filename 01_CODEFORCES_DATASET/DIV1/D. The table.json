{
    "link": "https://codeforces.com//contest/226/problem/D",
    "problemId": "1853",
    "problem_idx": "D",
    "shortId": "226D",
    "contest_number": "226",
    "problem_submissions": {
        "D": [
            2242483,
            2240843,
            2242697,
            2239811,
            2241181,
            2240471,
            2243151,
            2239681,
            2243648,
            2243129,
            2242567,
            2244564,
            2243396,
            2244004,
            2242755,
            2240654,
            2242232,
            2243688
        ],
        "C": [
            2240518,
            2242095,
            2241935,
            2242212,
            2245368,
            2243264,
            2242355,
            2244421,
            2245094,
            2240401,
            2245716,
            2240548,
            2245297,
            2273600,
            2246168,
            2251858
        ],
        "B": [
            2238162,
            2238317,
            2238835,
            2237653,
            2238869,
            2244282,
            2240573,
            2241479,
            2239690,
            2239960,
            2240247,
            2244047,
            2239779,
            2243326,
            2239668,
            2238560,
            2240587,
            2244817
        ],
        "A": [
            2237392,
            2237493,
            2237370,
            2238271,
            2237948,
            2237516,
            2239157,
            2243302,
            2237640,
            2237633,
            2237332,
            2273554,
            2237740,
            2237340,
            2237663,
            2237380,
            2241341,
            2242419
        ],
        "E": [
            3877418,
            2263890,
            2247800
        ]
    },
    "name": "D. The table",
    "statement": "Harry Potter has a difficult homework. Given a rectangular table,\r\nconsisting of cells. Each cell of the table contains the integer. Harry\r\nknows how to use two spells: the first spell change the sign of the\r\nintegers in the selected row, the second in the selected column. Harry’s\r\ntask is to make non-negative the sum of the numbers in each row and each\r\ncolumn using these spells.Alone, the boy can not cope. Help the young\r\nmagician!\r\n",
    "solutions": [
        "// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n// }}}\n// #defines {{{\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define SZ(x) ((int)(x).size())\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define PER1(i,a,b) for(int i=(b);i>=(a);i--)\n#define RI(x) scanf(\"%d\",&x)\n#define DRI(x) int x;RI(x)\n#define RII(x,y) scanf(\"%d%d\",&x,&y)\n#define DRII(x,y) int x,y;RII(x,y);\n#define RIII(x,y,z) scanf(\"%d%d\",&x,&y,&z)\n#define DRIII(x,y,z) int x,y,z;RIII(x,y,z);\n#define CASET int ___T,cas=1;scanf(\"%d\",&___T);while(___T--)\n#define CASEN0(n) int cas=1;while(scanf(\"%d\",&n)!=EOF&&n)\n#define CASEN(n) int cas=1;while(scanf(\"%d\",&n)!=EOF)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define SEP(x) ((x)?'\\n':' ')\n#define F first\n#define S second\ntypedef pair<int,int> PII;\ntypedef long long LL;\n// }}}\n\nbool rr[110],rc[110];\nint sr[110],sc[110];\nint in[110][110];\n\nint main(){\n    DRII(n,m);\n    REP(i,n)REP(j,m)RI(in[i][j]);\n    while(1){\n        MS0(sr);\n        MS0(sc);\n        REP(i,n)REP(j,m){\n            int a=in[i][j];\n            if(rr[i]^rc[j])a=-a;\n            sr[i]+=a;\n            sc[j]+=a;\n        }\n        bool f=0;\n        int mi=0,mp=0,mp2=0;\n        REP(i,n)if(sr[i]<mi){\n            mp=i;mp2=0;\n            mi=sr[i];\n            f=1;\n        }\n        REP(j,m)if(sc[j]<0){\n            f=1;\n            mp=j;mp2=1;mi=sc[j];\n        }\n        if(!f)break;\n        if(mp2)rc[mp]^=1;\n        else rr[mp]^=1;\n    }\n    int c1=0,c2=0;\n    REP(i,n)if(rr[i])c1++;\n    printf(\"%d\",c1);\n    REP(i,n)if(rr[i])printf(\" %d\",i+1);\n    puts(\"\");\n    REP(i,m)if(rc[i])c2++;\n    printf(\"%d\",c2);\n    REP(i,m)if(rc[i])printf(\" %d\",i+1);\n    puts(\"\");\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. The table.json",
    "editorial_link": "https://codeforces.com/blog/entry/5378",
    "editorial": "Letâs get the required table. Act in the following way: find any row or\r\ncolumn with negative sum and invert it. Notice, that sum of numbers in\r\nthe entire table will always increase (at least, by ). It canât increase\r\npermanently, because its maximal possible summary change is . So weâll\r\nget the required table anyway. It takes us not more than operations\r\n(applying of the spell), each of those is performed in or . So, weâve\r\nlearned how to get required table in not more than Â  operations. Now\r\nletâs restore the answer. Itâs easy to understand that it will contain\r\nthose rows and columns, which weâve inverted odd times. Implementation\r\n",
    "hint": []
}