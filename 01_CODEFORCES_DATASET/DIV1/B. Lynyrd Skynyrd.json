{
    "link": "https://codeforces.com//contest/1142/problem/B",
    "problemId": "322162",
    "problem_idx": "B",
    "shortId": "1142B",
    "contest_number": "1142",
    "problem_submissions": {
        "D": [
            52052698,
            52044696,
            52050424,
            52048816,
            52048203,
            52050242,
            52051279,
            52044155,
            52053707,
            52051199,
            52050499,
            52052944,
            52052302,
            52053535,
            52051490,
            52049907
        ],
        "E": [
            52047622,
            52057339,
            52048974,
            77087643,
            52277900,
            52277787,
            52050784
        ],
        "C": [
            52040660,
            52041212,
            52036496,
            52039629,
            52044262,
            52039609,
            52039348,
            52038404,
            52053341,
            52038044,
            52046718,
            52044023,
            52041812,
            52045982,
            52050483,
            52043132,
            52044496,
            52082020
        ],
        "B": [
            52036028,
            52037384,
            52034327,
            52035419,
            52038173,
            52037529,
            52042911,
            52035003,
            52038458,
            52035088,
            52037475,
            52037895,
            52038479,
            52041354,
            52037902,
            52038519,
            52055164,
            52037338
        ],
        "A": [
            52032007,
            52031522,
            52030850,
            52033382,
            52032139,
            52033225,
            52032107,
            52040214,
            52033698,
            52034088,
            52034385,
            52034757,
            52033255,
            52055588,
            52032995,
            52035070
        ]
    },
    "name": "B. Lynyrd Skynyrd",
    "statement": "Recently Lynyrd and Skynyrd went to a shop where Lynyrd bought a\r\npermutation p of length n, and Skynyrd bought an array a of length m,\r\nconsisting of integers from 1 to n. Lynyrd and Skynyrd became bored, so\r\nthey asked you q queries, each of which has the following form: \"does\r\nthe subsegment of a from the l-th to the r-th positions, inclusive, have\r\na subsequence that is a cyclic shift of p?\" Please answer the queries.A\r\nof length n is a sequence of n integers such that each integer from 1 to\r\nn appears exactly once in it.A of a permutation (p_1, p_2,\r\nldots, p_n) is a permutation (p_i, p_{i + 1},\r\nldots, p_{n}, p_1, p_2,\r\nldots, p_{i - 1}) for some i from 1 to n. For example, a permutation (2,\r\n1, 3) has three distinct cyclic shifts: (2, 1, 3), (1, 3, 2), (3, 2,\r\n1).A of a subsegment of array a from the l-th to the r-th positions,\r\ninclusive, is a sequence a_{i_1}, a_{i_2},\r\nldots, a_{i_k} for some i_1, i_2,\r\nldots, i_k such that l\r\nleq i_1 < i_2 <\r\nldots < i_k\r\nleq r.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nconst int LOG = 18;\nint a[N];\nint p[N];\nint nxt[N];\nint b[N][LOG];\nint sparse[LOG][N];\nint p2[N];\nint n, m, q;\n\nint getMin(int l, int r) {\n\tint k = p2[r - l];\n\treturn min(sparse[k][l], sparse[k][r - (1 << k)]);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &m, &n, &q);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tp[x] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[i] = p[x];\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(\"%d \", a[i]);\n\teprintf(\"\\n\");\n\t*/\n\tfor (int i = 0; i < m; i++)\n\t\tnxt[i] = n;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tb[i][k] = n;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint x = a[i];\n\t\tint y = x + 1;\n\t\tif (y == m) y = 0;\n\t\tb[i][0] = nxt[y];\n\t\tnxt[x] = i;\n\t}\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint w = b[i][k];\n\t\t\tb[i][k + 1] = b[w][k];\n\t\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = i;\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tif (((m - 1) >> k) & 1)\n\t\t\t\tx = b[x][k];\n\t\tsparse[0][i] = x;\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(\"%d \", sparse[0][i]);\n\teprintf(\"\\n\");\n\t*/\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i + (1 << (k + 1)) <= n; i++)\n\t\t\tsparse[k + 1][i] = min(sparse[k][i], sparse[k][i + (1 << k)]);\n\n\tfor (int i = 2; i < N; i++)\n\t\tp2[i] = p2[i / 2] + 1;\n\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tif (getMin(l, r) < r)\n\t\t\tprintf(\"1\");\n\t\telse\n\t\t\tprintf(\"0\");\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "math",
        "trees"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Lynyrd Skynyrd.json",
    "editorial_link": "https://codeforces.com//blog/entry/66301",
    "editorial": "For each if the number has position in , letâs find the greatest , such\r\nthat is less then and (letâs define ) We will call this position . This\r\ncan be done in time, just for each we will keep the last itâs position\r\nin while iterating over .Now letâs notice that using this info for each\r\nwe can find the beginning of right most subsequence of which is a ciclic\r\nshift of and ends exactly at . This can easily be done because if there\r\nis a subsequence of , which is the right most such subsequence, then is\r\n, is , and so on. So to find such subsequence and the position of itâs\r\nbeginning, we need to calculate times. To do it we can use binary\r\nlifting. Then we will have precalc and we will get the beginning of such\r\nsubsequence in time. Now for each prefix of letâs calculate the the\r\nbeginning of right most subsequence of it, which is a cyclic shift of .\r\nThis can be calculated in linear time, first we look at the answer for\r\nthis prefix without the last number, and then update it with the right\r\nmost subsequence, which ends at the end of prefix. Now we can answer\r\neach query in time, because we just need to find the beginning of the\r\nright most subsequence, which ends at prefix of length and compare it\r\nwith .\r\n",
    "hint": []
}