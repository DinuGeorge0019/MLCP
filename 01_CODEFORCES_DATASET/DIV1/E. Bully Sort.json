{
    "link": "https://codeforces.com//contest/1830/problem/E",
    "problemId": "1942559",
    "problem_idx": "E",
    "shortId": "1830E",
    "contest_number": "1830",
    "problem_submissions": {
        "F": [
            234326044,
            207652053,
            207663837,
            207807721,
            208075080,
            208075031,
            207678271
        ],
        "D": [
            207640246,
            207630410,
            207637627,
            207621354,
            207615321,
            207636175,
            207642613,
            207640107,
            207677598,
            207636486,
            207674640,
            207643231,
            207672649,
            207672513,
            207643891,
            207672422,
            207672033,
            207644310,
            207746469,
            207746389,
            207650197,
            207645186,
            207822601,
            207822565,
            207645978,
            207642565,
            207658410,
            207638831
        ],
        "C": [
            207608017,
            207600613,
            207612008,
            207600441,
            207604832,
            207598385,
            207603497,
            207608198,
            207613818,
            207614226,
            207616264,
            207606682,
            207610887,
            234877458,
            207617296,
            207626821,
            207621747,
            207647815,
            207622607,
            207619463
        ],
        "B": [
            207599759,
            207593405,
            207597186,
            207596843,
            207596098,
            207591556,
            207609227,
            207602206,
            207592261,
            207601856,
            207592644,
            207601118,
            207592805,
            207603544,
            207613114,
            207602486,
            207597786,
            207598115,
            207609684
        ],
        "A": [
            207586682,
            207582994,
            207583697,
            207581917,
            207581457,
            207583108,
            207588869,
            207586429,
            207584682,
            207584850,
            207583599,
            207583185,
            207584377,
            207587215,
            207597686,
            207589557,
            207585837,
            207585764,
            207588046
        ],
        "E": [
            207715760,
            207661818,
            207884996,
            207884714,
            207713105,
            208057779
        ]
    },
    "name": "E. Bully Sort",
    "statement": "On a permutation p of length n, we define a bully swap as follows: Let i\r\nbe the index of the largest element p_i such that p_i\r\nneq i. Let j be the index of the smallest element p_j such that i < j.\r\nSwap p_i and p_j. We define f(p) as the number of bully swaps we need to\r\nperform until p becomes sorted. Note that if p is the identity\r\npermutation, f(p)=0.You are given n and a permutation p of length n. You\r\nneed to process the following q updates.In each update, you are given\r\ntwo integers x and y. You will swap p_x and p_y and then find the value\r\nof f(p).Note that the updates are persistent. Changes made to the\r\npermutation p will apply when processing future updates.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define op(x) ((x&1)?x+1:x-1)\n#define odd(x) (x&1)\n#define even(x) (!odd(x))\n#define lc(x) (x<<1)\n#define rc(x) (lc(x)|1)\n#define lowbit(x) (x&-x)\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\nusing namespace std;\nconst int MAXN = 5e5+10,MAXM = 1.5e7+10;\nint n,q;\nint p[MAXN];\n\nll sum,inv;\nint V(int x){return 2*max(0,p[x]-x);}\nvoid output(){assert(inv<=sum);cout<<sum-inv<<\"\\n\";}\n\nstruct BIT{\n    int t[MAXN];\n    void mdf(int x,int v){for(;x<=n;x+=lowbit(x))t[x] += v;}\n    int qry(int x,int S=0){for(;x;x-=lowbit(x))S+=t[x];return S;}\n}bit;\n\nmt19937 rnd(0);\nstruct Node{\n    int lc,rc,key,sz,val;\n}t[MAXM];\nint tot;\n\nint cn(int val){\n    tot++;t[tot].key = rnd();t[tot].sz = 1;t[tot].val = val;\n    return tot;\n}\nvoid pushup(int x){\n    t[x].sz = 1 + t[t[x].lc].sz + t[t[x].rc].sz;\n}\nvoid split(int u,int lim,int& x,int& y){\n    if(!u)return (void)(x=y=0);\n    if(t[u].val <= lim){\n        x=u;\n        split(t[u].rc,lim,t[u].rc,y);\n    }else{\n        y=u;\n        split(t[u].lc,lim,x,t[u].lc);\n    }\n    pushup(u);\n}\nint merge(int x,int y){\n    if(!x || !y)return x+y;\n    if(t[x].key > t[y].key){\n        t[x].rc = merge(t[x].rc,y);\n        return pushup(x),x;\n    }else{\n        t[y].lc = merge(x,t[y].lc);\n        return pushup(y),y;\n    }\n}\n\nnamespace _{\n    void ins(int& rt,int val){\n        int x=0,y=cn(val),z=0;\n        split(rt,val-1,x,z);\n        rt = merge(merge(x,y),z);\n    }\n    void rmv(int& rt,int val){\n        int x=0,y=0,z=0;\n        split(rt,val-1,x,y);\n        split(y,val,y,z);\n        rt = merge(x,z);\n    }\n    int qry(int& rt,int L,int R){\n        if(L>R)return 0;\n        int x=0,y=0,z=0;\n        split(rt,L-1,x,y);\n        split(y,R,y,z);\n        int ret = t[y].sz;\n        rt = merge(merge(x,y),z);\n        return ret;\n    }\n};\n\nint rt[MAXN];\nvoid mdf(int x,int p,int v){\n    for(;x<=n;x+=lowbit(x)){\n        if(v==1){\n            _::ins(rt[x],p);\n        }else{\n            _::rmv(rt[x],p);\n        }\n    }\n}\nint qry(int x,int l,int r,int S=0){\n    for(;x;x-=lowbit(x)){\n        S += _::qry(rt[x],l,r);\n    }\n    return S;\n}\nint Q(int L,int R,int vl,int vr){\n    if(L>R)return 0;\n\n    return qry(R,vl,vr) - qry(L-1,vl,vr);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    cin>>n>>q;\n    rep(i,1,n){\n        cin>>p[i];\n        sum += V(i);\n    }\n    per(i,n,1){\n        inv+=bit.qry(p[i]);\n        bit.mdf(p[i],1);\n    }\n    \n    rep(i,1,n)mdf(i,p[i],1);\n\n\n    rep(i,1,q){\n        int x,y;cin>>x>>y;\n        sum -= V(x);sum -= V(y);\n        \n        inv -= Q(x+1,y-1,1,p[x]);\n        inv += Q(x+1,y-1,p[x],n);\n\n        inv += Q(x+1,y-1,1,p[y]);\n        inv -= Q(x+1,y-1,p[y],n);\n\n        if(p[x] > p[y])inv--;\n        else inv++;\n\n        mdf(x,p[x],-1);mdf(y,p[y],-1);\n        swap(p[x],p[y]);\n        mdf(x,p[x],1);mdf(y,p[y],1);\n        sum += V(x);sum += V(y);\n        \n        output();\n    }\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "math"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Bully Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "Solution First of all, we notice that if some element moves left, it will\nnever move right. ProofProving this is not hard, imagine to be the set\nof suffix minimas. Then if an element is in we know that .Since after\nevery bully swap an element cannot disappear from and after each bully\nswap, the swapped elements can only get closer to their desired\nposition, we conclude the proof.Obviously, if an element moves right, it\nwill never move left since it will continue to move right until it\nreaches its final position.By the claims above, we conclude that left\nand right movers are distinct.Now suppose we swap indicies and and note\nthat such swap kills inversions and the left mover moves steps.Now the\nmagic is that if we let be the sum over for all left movers we have ,\nthus our answer is just .Now to handle the data structure part, we just\nneed to be able to calculate inversions while being able to perform\npoint updates. There are many ways to do this, for example for using a\nfenwick tree and a bitwise trie/ordered_set in .\n"
}