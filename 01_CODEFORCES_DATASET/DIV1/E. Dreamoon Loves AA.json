{
    "link": "https://codeforces.com//contest/1329/problem/E",
    "problemId": "582577",
    "problem_idx": "E",
    "shortId": "1329E",
    "contest_number": "1329",
    "problem_submissions": {
        "E": [
            75408443,
            75525199,
            75525023,
            75681621,
            76019995,
            76016936,
            75967053,
            75966418
        ],
        "D": [
            75389063,
            75398925,
            75385191,
            75401307,
            75408075,
            75405008,
            75403445,
            75404364,
            75403371,
            75659972,
            75411387,
            75407920,
            75411250,
            75412465,
            75413663,
            75407247,
            75409435,
            75922378,
            75921522,
            75921098,
            75920566,
            75920416,
            75919758,
            75919734,
            75806069,
            75805925,
            75803536,
            75803307,
            75803058,
            75802910,
            75800662,
            75395261,
            75399040
        ],
        "C": [
            75374256,
            75371549,
            75396568,
            75381813,
            75372171,
            75376833,
            75380449,
            75377512,
            75386022,
            75659958,
            75378281,
            75378362,
            75487924,
            75487540,
            75487429,
            75487406,
            75386768,
            75380568,
            75386156,
            75382219,
            75387697,
            75369638,
            76036841,
            75372968,
            75421067
        ],
        "B": [
            75357516,
            75353754,
            75360937,
            75361445,
            75363313,
            75362516,
            75363699,
            75367490,
            75367087,
            75659949,
            75361718,
            75364241,
            75358119,
            75363158,
            75368163,
            75368647,
            75364635,
            75360193,
            76036829,
            75359511,
            75363649,
            75368965
        ],
        "A": [
            75354673,
            75356344,
            75356602,
            75357362,
            75359450,
            75355169,
            75357071,
            75359811,
            75354137,
            75659929,
            75354669,
            75356764,
            75372979,
            75355330,
            75359586,
            75360814,
            75615883,
            75354430,
            76036826,
            75355988,
            75360416,
            75354524
        ]
    },
    "name": "E. Dreamoon Loves AA",
    "statement": "There is a string of length n+1 of characters ’A’ and ’B’. The first\r\ncharacter and last character of the string are equal to ’A’.You are\r\ngiven m indices p_1, p_2,\r\nldots, p_m (0-indexation) denoting the other indices of characters ’A’\r\nin the string. Let’s denote the minimum distance between two neighboring\r\n’A’ as l, and maximum distance between neighboring ’A’ as r.For example,\r\n(l,r) of string \"ABBAABBBA\" is (1,4).And let’s denote the of a string as\r\nthe value of r-l.Now Dreamoon wants to change exactly k characters from\r\n’B’ to ’A’, and he wants to make the of the string as small as\r\npossible.Please calculate the required minimum possible value of balance\r\ndegree.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll INF = (ll)1e15 + 66;\nconst int N = 400400;\nll a[N];\nint n;\nll k;\npll b[N];\nint m;\n\nvoid read() {\n\tll s;\n\tscanf(\"%lld%d%lld\", &s, &n, &k);\n\tll lst = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tll x;\n\t\tscanf(\"%lld\", &x);\n\t\ta[i] = x - lst;\n\t\tlst = x;\n\t}\n\ta[n++] = s - lst;\n}\n\nll calcMin(ll x) {\n\tll res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += a[i] / x - 1;\n\treturn res;\n}\nll calcMax(ll x) {\n\tll res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += (a[i] - 1) / x;\n\treturn res;\n}\n\nvoid solve() {\n\tread();\n\tll l = 1, r = INF;\n\tfor (int i = 0; i < n; i++)\n\t\tr = min(r, a[i]);\n\tr++;\n\twhile(r - l > 1) {\n\t\tll x = (l + r) / 2;\n\t\tll z = calcMin(x);\n\t\tif (z < k)\n\t\t\tr = x;\n\t\telse\n\t\t\tl = x;\n\t}\n\tll L = l;\n\tl = 0; r = INF;\n\twhile(r - l > 1) {\n\t\tll x = (l + r) / 2;\n\t\tll z = calcMax(x);\n\t\tif (z > k)\n\t\t\tl = x;\n\t\telse\n\t\t\tr = x;\n\t}\n\tll R = r;\n\tassert(L <= R);\n\tm = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tll x = a[i] / L;\n\t\tll y = (a[i] - 1) / R + 1;\n\t\tif (x >= y) continue;\n\t\tb[m++] = mp(a[i] / y, (a[i] - 1) / x + 1);\n\t}\n\tsort(b, b + m);\n\tll ans = INF;\n\tb[m++] = mp(L, R);\n\tfor (int i = 0; i < m; i++) {\n\t\tans = min(ans, R - b[i].first);\n\t\tR = max(R, b[i].second);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Dreamoon Loves AA.json",
    "editorial_link": "https://codeforces.com//blog/entry/75559",
    "editorial": "The idea of this problem comes to my brain when I recall that Iâm\r\ncooking and I want to cut a carrot into many pieces and make the size of\r\neach piece as evenly as possible. I think this problem is very\r\ninteresting. So thatâs why I determine to prepare a Codeforces contest\r\nafter so many years. I hope I can share this problem with as many people\r\nas possible. There are some methods to solve this problem. I only show\r\nthe most beautiful one below. This method is given by isaf27 (And most\r\nAC users solve it with this method. I admire them very much).Firstly, we\r\ntranslate the problem into a more convenient model. Let , (), , and .\r\nThen the problem is equivalent to we want to do integer partition on\r\nintegers , such that is divided into positive integers where . Our\r\ntarget is to minimize the difference between the largest integer and\r\nsmallest integer after division.An important observation is, we always\r\ncan achieve our target by making the difference of the largest integer\r\nand the smallest integer that is divided from the same integer is at\r\nmost one. So our target is minimizing where and .There are two key\r\nvalues under the constraints and , one is the minimum value of (Letâs\r\ncall it after), another is the maximum value of (Letâs call it after).\r\nand can be calculated by binary searching with time complexity . (This\r\npart is relatively easy so I wonât mention it here.)There are two\r\nconditions after calculating and . One is, for all valid , there exists\r\nat least one positive integer such that . In this case, the answer is\r\njust . proof is as below.Let as the largest positive integer such that\r\nand as the smallest positive integer such that . By the define of and ,\r\nwe can get and . So we always can choose some d_i where such that and\r\n.Now the essential condition is resolved. Another condition is there are\r\nsome indices that we cannot find any positive integer such that . Letâs\r\ncall the set of these indices as . For each element , letâs calculate\r\nanother two key values for index . That is, we want to know the closest\r\ntwo values of near to range (one is above another is below ).\r\nFormulaically say, let be the smallest such that and call as . And let\r\nbe the largest such that and call as . Imaging we have a set initially\r\ncontains two positive integer and . Now for each , we want to choose\r\neither or to add to . Then the minimum possbile value of difference\r\nbetween largest element and smallest element in is the answer in this\r\ncondition. The minimum possible value can be calculated as\r\nbelow.Initially, for all , we choose to add to the set . Then iterate\r\nfrom largest to smallest . In each iteration, we remove from and add to\r\n. The minimum possible value will exist during the process. These steps\r\ncan also be done in time complexity .The proof of correctness of the\r\nsecond condition is almost same as the first condition. We always can\r\nadjust such that equal to for constructed result.The overall time\r\ncomplexity is for the above method.In the end, I want to thanks everyone\r\nwho takes part in this contest. The worth of the contest will reveal on\r\nyou, when you learn thing from these problems. Thanks a lot.\r\n",
    "hint": []
}