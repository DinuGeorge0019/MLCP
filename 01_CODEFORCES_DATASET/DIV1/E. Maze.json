{"link": "https://codeforces.com//contest/123/problem/E", "problemId": "656", "problem_idx": "E", "shortId": "123E", "contest_number": "123", "problem_submissions": {"E": [830840, 831942, 831247, 1154341], "C": [830171, 829602, 829696, 830545, 830265, 830647, 831072, 830094, 829962, 833283, 832903, 833096], "D": [829496, 830812, 1447203, 829637, 831873, 1185562, 836113, 832570, 831822, 839081, 831840, 834715, 834693, 831236, 831444, 830484, 833338, 833314, 833310, 830603, 830534, 831043, 833652, 831461, 831555, 831382, 831934], "B": [828403, 828703, 828120, 829057, 828829, 829690, 829686, 832376, 828694, 829613, 829313, 828996, 829196, 828023, 828574, 829940, 829279], "A": [827847, 827523, 827572, 827701, 827834, 828726, 828164, 828031, 832616, 827887, 828344, 829843, 828296, 829771, 827580, 829074, 828185]}, "name": "E. Maze", "statement": "A maze is represented by a tree (an undirected graph, where exactly one\r\nway exists between each pair of vertices). In the maze the entrance\r\nvertex and the exit vertex are chosen with some probability. The exit\r\nfrom the maze is sought by Deep First Search. If there are several\r\npossible ways to move, the move is chosen equiprobably. Consider the\r\nfollowing pseudo-code:DFS(x) if x == exit vertex then flag[x] <- TRUE\r\nrandom shuffle the vertices\u2019 order in V(x) // here all permutations have\r\nequal probability to be chosen for i <- 1 to length[V] do if flag[V[i]]\r\n= FALSE then count++; DFS(y); count++; is the list vertices adjacent to\r\n. The array is initially filled as . initially starts with a parameter\r\nof an entrance vertex. When the , variable will contain the number of\r\nmoves.Your task is to count the mathematical expectation of the number\r\nof moves one has to do to exit the maze.\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << \"(\" << i->first << \", \" << i->second << \") \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= ' '; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - '0') >= 10; ) { if (c == '-') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - '0'); } while ((uint)((c = getchar()) - '0') < 10); return x; }\n\n#define MAX 200010\n\nint N;\nint A[MAX], B[MAX];\ndouble X[MAX], Y[MAX];\nint m, ptr[MAX], next[MAX], zu[MAX];\n\nint dep[MAX], par[MAX];\nint que[MAX], *qb, *qe;\nvoid bfs(int root) {\n    int i, u, v;\n    qb = qe = que;\n    memset(dep, 0, N << 2);\n    dep[0] = root;\n    par[0] = -1;\n    *qe++ = 0;\n    for (; qb != qe; ) {\n        u = *qb++;\n        for (i = ptr[u]; ~i; i = next[i]) {\n            v = zu[i];\n            if (v != par[u]) {\n                dep[v] = dep[u] + 1;\n                par[v] = u;\n                *qe++ = v;\n            }\n        }\n    }\n}\n\ndouble sum1All, sumXAll;\ndouble sum1[MAX], sumX[MAX];\nvoid doit(int u) {\n    int i, v;\n    sum1[u] = 1;\n    sumX[u] = X[u];\n    for (i = ptr[u]; ~i; i = next[i]) {\n        v = zu[i];\n        if (v != par[u]) {\n            sum1[u] += sum1[v];\n            sumX[u] += sumX[v];\n        }\n    }\n}\ndouble calc(int u) {\n    int i, v;\n    double ret = 0.0;\n    for (i = ptr[u]; ~i; i = next[i]) {\n        v = zu[i];\n        if (v != par[u]) {\n            ret += sum1[v] * sumX[v];\n        }\n    }\n    ret += (sum1All - sum1[u]) * (sumXAll - sumX[u]);\n    ret *= Y[u];\n    return ret;\n}\n\nint main() {\n    int i, u, v;\n    int j;\n    \n    for (; ~scanf(\"%d\", &N); ) {\n        for (i = 0; i < N - 1; ++i) {\n            scanf(\"%d%d\", &A[i], &B[i]);\n            --A[i];\n            --B[i];\n        }\n        for (u = 0; u < N; ++u) {\n            scanf(\"%lf%lf\", &X[u], &Y[u]);\n        }\n        double XSum = accumulate(X, X + N, 0.0);\n        double YSum = accumulate(Y, Y + N, 0.0);\n        for (u = 0; u < N; ++u) {\n            X[u] /= XSum;\n            Y[u] /= YSum;\n        }\n        m = 0;\n        memset(ptr, ~0, N << 2);\n        for (i = 0; i < N - 1; ++i) {\n            u = A[i];\n            v = B[i];\n            next[m] = ptr[u]; ptr[u] = m; zu[m] = v; ++m;\n            next[m] = ptr[v]; ptr[v] = m; zu[m] = u; ++m;\n        }\n        int root = 0;\n        bfs(root);\n        memset(sum1, 0, N * sizeof(sum1[0]));\n        memset(sumX, 0, N * sizeof(sumX[0]));\n//cout<<\"que : \";pv(que,que+N);\n        for (j = N; j--; ) {\n            doit(que[j]);\n        }\n        sum1All = sum1[root];\n        sumXAll = sumX[root];\n        double ans = 0.0;\n        for (j = N; j--; ) {\n            ans += calc(que[j]);\n        }\n        printf(\"%.15f\\n\", ans);\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "probabilities", "trees"], "dificulty": "2500", "interactive": false}