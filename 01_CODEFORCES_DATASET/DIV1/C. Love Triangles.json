{
    "link": "https://codeforces.com//contest/553/problem/C",
    "problemId": "30215",
    "problem_idx": "C",
    "shortId": "553C",
    "contest_number": "553",
    "problem_submissions": {
        "D": [
            11744562,
            11744498,
            11745257,
            11745223,
            11745470,
            11745572,
            11744919,
            11745032,
            11745427,
            11746100,
            11746456,
            11746392,
            11746335,
            11745162,
            11746455,
            11746854,
            11746886,
            11745082
        ],
        "C": [
            11742306,
            11742552,
            11743239,
            11743506,
            11742528,
            11742781,
            11742831,
            11741480,
            11743177,
            11743672,
            11744065,
            11743860,
            11743962,
            11742856,
            11745114,
            11744324,
            11744734,
            11743321
        ],
        "B": [
            11740294,
            11741146,
            11741320,
            11741933,
            11744161,
            11741212,
            11741622,
            11743234,
            11743626,
            11740923,
            11740570,
            11741924,
            11742141,
            11741812,
            11743960,
            11742897,
            11743061,
            11741732
        ],
        "A": [
            11739123,
            11739635,
            11739748,
            11739276,
            11740077,
            11739044,
            11739303,
            11739327,
            11739192,
            11744185,
            11739212,
            11740023,
            11739776,
            11740185,
            11741127,
            11739503,
            11739666
        ],
        "E": [
            11751187,
            11762331
        ]
    },
    "name": "C. Love Triangles",
    "statement": "There are many anime that are about \"love triangles\": Alice loves Bob,\r\nand Charlie loves Bob as well, but Alice hates Charlie. You are thinking\r\nabout an anime which has characters. The characters are labeled from to\r\n. Every pair of two characters can either mutually love each other or\r\nmutually hate each other (there is no neutral state).You hate love\r\ntriangles (A-B are in love and B-C are in love, but A-C hate each\r\nother), and you also hate it when nobody is in love. So, considering any\r\nthree characters, you will be happy if exactly one pair is in love (A\r\nand B love each other, and C hates both A and B), or if all three pairs\r\nare in love (A loves B, B loves C, C loves A).You are given a list of\r\nknown relationships in the anime. You know for sure that certain pairs\r\nlove each other, and certain pairs hate each other. You\u2019re wondering how\r\nmany ways you can fill in the remaining relationships so you are happy\r\nwith every triangle. Two ways are considered different if two characters\r\nare in love in one way but hate each other in the other. Print this\r\ncount modulo .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nconst int MAXN = 2e5;\nconst int MAXM = 2e5;\n\nint N;\nint M;\n\nvector<pair<int, int>> adj[MAXN];\n\nint A[MAXM];\nint B[MAXM];\nint C[MAXM];\n\nint vis[MAXN];\n\nbool dfs(int a, int s = 1) {\n\tassert(s == 1 || s == -1);\n\tif(vis[a] == -s) {\n\t\treturn false;\n\t} else if(vis[a] == s) {\n\t\treturn true;\n\t} else {\n\t\tvis[a] = s;\n\t\tfor(auto it : adj[a]) {\n\t\t\tif(!dfs(it.first, it.second ? s : -s)) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> N >> M;\n\n\tfor(int i = 0; i < M; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i];\n\t\tA[i] --;\n\t\tB[i] --;\n\t\tadj[A[i]].push_back(make_pair(B[i], C[i]));\n\t\tadj[B[i]].push_back(make_pair(A[i], C[i]));\n\t}\n\n\tint res = (MOD + 1) / 2;\n\tfor(int a = 0; a < N; a++) {\n\t\tif(!vis[a]) {\n\t\t\tif(dfs(a)) {\n\t\t\t\tres *= 2;\n\t\t\t\tif(res >= MOD) res -= MOD;\n\t\t\t} else {\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res % MOD << '\\n';\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Love Triangles.json",
    "editorial_link": "https://codeforces.com//blog/entry/18842",
    "editorial": "Let\u00e2\u0080\u0099s look at the graph of characters who love each other. Each\r\nlove-connected component can be collapsed into a single node, since we\r\nknow that all characters in the same connected component must love each\r\nother. Now, we claim that the resulting collapsed graph with the hate\r\nedges has a solution if and only if the resulting graph is bipartite. To\r\nshow this, suppose the graph is not bipartite. Then, there is an odd\r\ncycle. If the cycle is of length 1, it is a self edge, which clearly\r\nisn\u00e2\u0080\u0099t allowed (since a node must love itself). For any odd cycle of\r\nlength more than 1, let\u00e2\u0080\u0099s label the nodes in the cycle . Then, in\r\ngeneral, we must have loves , since hate each other and hate each other\r\n(all indicies taken mod ). However, we can use the fact that the cycle\r\nis odd and eventually get that and love each other. However, this is a\r\ncontradiction, since we said they must originally hate each other. For\r\nthe other direction, suppose the graph is bipartite. Let be an arbitrary\r\nbipartition of the graph. If we let all nodes in love each other and all\r\nnodes in love each other, and every edge between and hate each other,\r\nthen we get a solution. (details are omitted, though I can elaborate if\r\nneeded). Thus, we can see that we have a solution if and only if the\r\ngraph is bipartite. So, if the graph is not bipartite, the answer is\r\nzero. Otherwise, the second part of the proof gives us a way to count.\r\nWe just need to count the number of different bipartitions of the graph.\r\nIt\u00e2\u0080\u0099s not too hard to see that this is just simply 2^(number of connected\r\ncomponents 1) (once you fix a node, you fix every node connected to it).\r\nThis entire algorithm takes time. Example code:\r\nhttp://codeforces.com/contest/553/submission/11767582\r\n"
}