{
    "link": "https://codeforces.com//contest/901/problem/C",
    "problemId": "139714",
    "problem_idx": "C",
    "shortId": "901C",
    "contest_number": "901",
    "problem_submissions": {
        "D": [
            33426443,
            33425255,
            33425405,
            33421002,
            33428722,
            33432497,
            33430107,
            33431968,
            33434361,
            33433853,
            33432628,
            33428305,
            33435534,
            33423537,
            33424117,
            33433491,
            33424011,
            33435055
        ],
        "C": [
            33423246,
            33421544,
            33420578,
            33429910,
            33422327,
            33425977,
            33426202,
            33427669,
            33422440,
            33429447,
            33429169,
            33424756,
            33430999,
            33430059,
            33430695,
            33420864,
            33434365,
            33425416
        ],
        "B": [
            33419337,
            33427579,
            33429052,
            33425071,
            33431946,
            33418047,
            33432302,
            33420475,
            33497315,
            33497308,
            33496921,
            33426321,
            33423681,
            33433893,
            33426136,
            33434123
        ],
        "A": [
            33414182,
            33413377,
            33413379,
            33422716,
            33415121,
            33413643,
            33413547,
            33414284,
            33415005,
            33416374,
            33419687,
            33414307,
            33415289,
            33414435,
            33420715,
            33423860,
            33425257,
            33413347
        ],
        "E": [
            36988410
        ]
    },
    "name": "C. Bipartite Segments",
    "statement": "You are given an undirected graph with vertices. There are no\r\nedge-simple cycles with the even length in it. In other words, there are\r\nno cycles of even length that pass each edge at most once. Let\u2019s\r\nenumerate vertices from to . You have to answer queries. Each query is\r\ndescribed by a segment of vertices , and you have to count the number of\r\nits subsegments (), such that if we delete all vertices except the\r\nsegment of vertices (including and ) and edges between them, the\r\nresulting graph is bipartite.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <int> conn[300050];\nint par[300050];\nint dep[300050];\nint low[300050];\nbool dchk[300050];\n\nvector <pii> Ve;\nvoid DFS(int n) {\n\tdchk[n] = true;\n\tlow[n] = dep[n];\n\tfor (auto it : conn[n]) {\n\t\tif (par[n] == it) continue;\n\t\tif (dchk[it]) {\n\t\t\tlow[n] = min(low[n], dep[it]);\n\t\t\tVe.emplace_back(n, it);\n\t\t\tcontinue;\n\t\t}\n\t\tpar[it] = n;\n\t\tdep[it] = dep[n] + 1;\n\t\tDFS(it);\n\n\t\tif (low[it] <= dep[n]) Ve.emplace_back(it, n);\n\t\tlow[n] = min(low[n], low[it]);\n\t}\n}\n\nint r[300050];\nint root(int x) {\n\treturn (x == r[x]) ? x : (r[x] = root(r[x]));\n}\nvector <int> Vl[300050];\n\nvector <pii> Vu;\nint mx[300050];\nll sum[300050];\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\t\tconn[t1].push_back(t2);\n\t\tconn[t2].push_back(t1);\n\t}\n\tfor (i = 1; i <= N; i++) if (!dchk[i]) DFS(i);\n\tfor (i = 1; i <= N; i++) r[i] = i;\n\tfor (auto it : Ve) r[root(it.first)] = root(it.second);\n\n\tfor (i = 1; i <= N; i++) Vl[root(i)].push_back(i);\n\n\tfor (i = 1; i <= N; i++) mx[i] = N;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (Vl[i].size() <= 1) continue;\n\t\tmx[Vl[i][0]] = min(mx[Vl[i][0]], Vl[i].back() - 1);\n\t}\n\tfor (i = N - 1; i >= 1; i--) mx[i] = min(mx[i], mx[i + 1]);\n\tfor (i = 1; i <= N; i++) sum[i] = sum[i - 1] + mx[i];\n\n\tint Q;\n\tscanf(\"%d\", &Q);\n\twhile (Q--) {\n\t\tint t1, t2;\n\t\tscanf(\"%d %d\", &t1, &t2);\n\n\t\tint st = t1, en = t2, mi, rv = t1 - 1;\n\t\twhile (st <= en) {\n\t\t\tmi = (st + en) / 2;\n\t\t\tif (mx[mi] <= t2) {\n\t\t\t\trv = mi;\n\t\t\t\tst = mi + 1;\n\t\t\t}\n\t\t\telse en = mi - 1;\n\t\t}\n\n\t\tll s1 = sum[rv] - sum[t1 - 1] + (ll)t2 * (t2 - rv);\n\t\tll s2 = (ll)(t1 + t2) * (t2 - t1 + 1) / 2 - (t2 - t1 + 1);\n\t\tprintf(\"%lld\\n\", s1 - s2);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Bipartite Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/56478",
    "editorial": "If two cycles of odd length intersect, then they can be bypassed so as\r\nto obtain an edge-simple cycle of even length.It follows that the given\r\ngraph is a vertex cactus, with cycles of odd length, then the vertex\r\nsegment is good - if there is no loop, that the vertex with the minimum\r\nnumber from this cycle is present on this segment and the vertex with\r\nthe maximum number from this cycle is present on this segment. Then we\r\ncan select all the cycles, and now we work with the segments.Let us find\r\nfor each vertex a maximal right boundary such that the interval .. is a\r\nbipartite graph.Then is equal to the minimal right boundary of the\r\nsegment, which was opened later .This can be considered a minimum on the\r\nsuffix, initially setting for all cycles [minimum on the cycle] =\r\nmaximum on the cycleTo answer the query, we need to take the sum over\r\nfor those who have and the sum over for those who have then we note that\r\nincreases and we simply need to find the first moment when becomes (we\r\ncan do it with binary search)And take two prefix sums - sum of () and\r\nsum of .\r\n"
}