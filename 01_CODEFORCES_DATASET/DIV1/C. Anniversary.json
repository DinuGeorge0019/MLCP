{
    "link": "https://codeforces.com//contest/226/problem/C",
    "problemId": "1852",
    "problem_idx": "C",
    "shortId": "226C",
    "contest_number": "226",
    "problem_submissions": {
        "D": [
            2242483,
            2240843,
            2242697,
            2239811,
            2241181,
            2240471,
            2243151,
            2239681,
            2243648,
            2243129,
            2242567,
            2244564,
            2243396,
            2244004,
            2242755,
            2240654,
            2242232,
            2243688
        ],
        "C": [
            2240518,
            2242095,
            2241935,
            2242212,
            2245368,
            2243264,
            2242355,
            2244421,
            2245094,
            2240401,
            2245716,
            2240548,
            2245297,
            2273600,
            2246168,
            2251858
        ],
        "B": [
            2238162,
            2238317,
            2238835,
            2237653,
            2238869,
            2244282,
            2240573,
            2241479,
            2239690,
            2239960,
            2240247,
            2244047,
            2239779,
            2243326,
            2239668,
            2238560,
            2240587,
            2244817
        ],
        "A": [
            2237392,
            2237493,
            2237370,
            2238271,
            2237948,
            2237516,
            2239157,
            2243302,
            2237640,
            2237633,
            2237332,
            2273554,
            2237740,
            2237340,
            2237663,
            2237380,
            2241341,
            2242419
        ],
        "E": [
            3877418,
            2263890,
            2247800
        ]
    },
    "name": "C. Anniversary",
    "statement": "There are less than 60 years left till the 900-th birthday anniversary\r\nof a famous Italian mathematician Leonardo Fibonacci. Of course, such\r\nimportant anniversary needs much preparations.Dima is sure that it’ll be\r\ngreat to learn to solve the following problem by the Big Day: You’re\r\ngiven a set , consisting of numbers , , , , ; let’s consider all its\r\n-element subsets; for each such subset let’s find the largest common\r\ndivisor of Fibonacci numbers with indexes, determined by the subset\r\nelements. Among all found common divisors, Dima is interested in the\r\nlargest one.Dima asked to remind you that Fibonacci numbers are elements\r\nof a numeric sequence, where , , for .Dima has more than half a century\r\nahead to solve the given task, but you only have two hours. Count the\r\nresidue from dividing the sought largest common divisor by .\r\n",
    "solutions": [
        "// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n// }}}\n// #defines {{{\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define SZ(x) ((int)(x).size())\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define PER1(i,a,b) for(int i=(b);i>=(a);i--)\n#define RI(x) scanf(\"%d\",&x)\n#define DRI(x) int x;RI(x)\n#define RII(x,y) scanf(\"%d%d\",&x,&y)\n#define DRII(x,y) int x,y;RII(x,y);\n#define RIII(x,y,z) scanf(\"%d%d\",&x,&y,&z)\n#define DRIII(x,y,z) int x,y,z;RIII(x,y,z);\n#define CASET int ___T,cas=1;scanf(\"%d\",&___T);while(___T--)\n#define CASEN0(n) int cas=1;while(scanf(\"%d\",&n)!=EOF&&n)\n#define CASEN(n) int cas=1;while(scanf(\"%d\",&n)!=EOF)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define SEP(x) ((x)?'\\n':' ')\n#define F first\n#define S second\ntypedef pair<int,int> PII;\ntypedef long long LL;\n// }}}\n\nint mod;\ninline int add(int a,int b){\n    a+=b;if(a>=mod)a-=mod;return a;\n}\ninline int mul(int a,int b){\n    return (b*(LL)a)%mod;\n}\nstruct XD{\n    LL x[2][2];\n    XD(){MS0(x);}\n    XD operator*(const XD& b)const{\n        XD c;\n        REP(i,2)REP(j,2)REP(k,2)c.x[i][k]=add(c.x[i][k],mul(x[i][j],b.x[j][k]));\n        return c;\n    }\n};\nint fib(LL x){\n    if(x<=2)return 1%mod;\n    XD a,m;\n    a.x[0][0]=a.x[1][1]=1;\n    m.x[0][0]=m.x[0][1]=m.x[1][0]=1;\n    x-=2;\n    while(x){\n        if(x%2)a=a*m;\n        m=m*m;\n        x/=2;\n    }\n    return add(a.x[0][0],a.x[0][1]);\n}\nLL l,r;\nLL k;\ninline bool f(LL x){\n    return r/x-(l+x-1)/x+1>=k;\n}\nint main(){\n    RI(mod);\n    scanf(\"%I64d%I64d\",&l,&r);\n    scanf(\"%I64d\",&k);\n    /*\n    //  For challenge.\n    long long ll=1,rr=r;\n    while(ll<rr){\n        long long mm=(ll+rr+1)/2;\n        if(r/mm-(l+mm-1)/mm+1>=k)ll=mm;\n        else rr=mm-1;\n    }\n    */\n    LL x;\n    LL sr=max((LL)sqrt(r),1LL);\n    LL ans=1;\n    for(x=1;x<=sr;x++){\n        if(f(x))ans=x;\n    }\n    for(x=1;x<=r/sr;x++){\n        LL d=r/x;\n        if(f(d))ans=max(ans,d);\n    }\n    printf(\"%d\\n\",fib(ans));\n}\n// vim: fdm=marker:commentstring=\\ \\\"\\ %s:nowrap:autoread\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "math",
        "matrices",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Anniversary.json",
    "editorial_link": "https://codeforces.com/blog/entry/5378",
    "editorial": "At first, let's prove the statement: GCD(Fn,?Fm)?=?FGCD(n,?m).\n\nLet's express Fn?+?k using Fn and Fk. We'll get the formula: Fn?+?k?=?Fk·Fn?+?1?+?Fk?-?1·Fn, which is easy to prove by induction.\n\nThen use the derived formula and notice, that GCD(Fn?+?k,?Fn)?=?GCD(Fk,?Fn).\n\nNow you are to notice an analogy with Euclidean algorithm and to understand, that we've got necessary equality for GCD of two Fibonacci numbers.\n\nSo, our current task is to find in the given set subset of k (or at least of k) elements with maximal possible GCD. To be exactly, to find this GCD.\n\nLet the answer be equal to q. Then  ?-? ??+?1???k (1) must be true.\n\nNotice, that for each summand from left part of inequality O(  ) segments exist, in which its value is constant. Moreover, we can find all these segments and values in . To be more precise, we are intersted in such q, that in the point q?-?1 value of at least one summand changes (obviously, increases). There are also  such values. Go over all of them and try to use each of them as the answer (i.e., check inequality (1) for each of them), and choose maximum from all satisfying numbers. The answer always exists, as q?=?1 is true for any input.\n\nSo, we've found index of required Fibonacci number. The number itself can be calculated by matrix exponentiation.",
    "hint": []
}