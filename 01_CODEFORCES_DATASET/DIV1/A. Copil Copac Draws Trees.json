{
    "link": "https://codeforces.com//contest/1830/problem/A",
    "problemId": "1942555",
    "problem_idx": "A",
    "shortId": "1830A",
    "contest_number": "1830",
    "problem_submissions": {
        "F": [
            234326044,
            207652053,
            207663837,
            207807721,
            208075080,
            208075031,
            207678271
        ],
        "D": [
            207640246,
            207630410,
            207637627,
            207621354,
            207615321,
            207636175,
            207642613,
            207640107,
            207677598,
            207636486,
            207674640,
            207643231,
            207672649,
            207672513,
            207643891,
            207672422,
            207672033,
            207644310,
            207746469,
            207746389,
            207650197,
            207645186,
            207822601,
            207822565,
            207645978,
            207642565,
            207658410,
            207638831
        ],
        "C": [
            207608017,
            207600613,
            207612008,
            207600441,
            207604832,
            207598385,
            207603497,
            207608198,
            207613818,
            207614226,
            207616264,
            207606682,
            207610887,
            234877458,
            207617296,
            207626821,
            207621747,
            207647815,
            207622607,
            207619463
        ],
        "B": [
            207599759,
            207593405,
            207597186,
            207596843,
            207596098,
            207591556,
            207609227,
            207602206,
            207592261,
            207601856,
            207592644,
            207601118,
            207592805,
            207603544,
            207613114,
            207602486,
            207597786,
            207598115,
            207609684
        ],
        "A": [
            207586682,
            207582994,
            207583697,
            207581917,
            207581457,
            207583108,
            207588869,
            207586429,
            207584682,
            207584850,
            207583599,
            207583185,
            207584377,
            207587215,
            207597686,
            207589557,
            207585837,
            207585764,
            207588046
        ],
        "E": [
            207715760,
            207661818,
            207884996,
            207884714,
            207713105,
            208057779
        ]
    },
    "name": "A. Copil Copac Draws Trees",
    "statement": "Copil Copac is given a list of n-1 edges describing a tree of n\r\nvertices. He decides to draw it using the following algorithm: Step 0:\r\nDraws the first vertex (vertex 1). Go to step 1. Step 1: For every edge\r\nin the input, in order: if the edge connects an already drawn vertex u\r\nto an undrawn vertex v, he will draw the undrawn vertex v and the edge.\r\nAfter checking every edge, go to step 2. Step 2: If all the vertices are\r\ndrawn, terminate the algorithm. Else, go to step 1. The number of\r\nreadings is defined as the number of times Copil Copac performs step\r\n1.Find the number of readings needed by Copil Copac to draw the tree.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\n#define rep1n(i, n) for (int i = 1; i <= (n); ++i)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define each(x, a) for (auto &x : a)\n#define ar array\n#define vec vector\n#define range(i, n) rep(i, n)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\n\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nint Bit(int mask, int b) { return (mask >> b) & 1; }\n\ntemplate<class T>\nbool ckmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool ckmax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int INFi = 1e9;\nconst ll INF = 3e18;\nconst int LG = 20;\nconst int maxN = 2e5 + 5;\n\nvpi g[maxN];\nint ans;\n\nvoid dfs(int v, int p, int ct) {\n    ans = max(ans, ct);\n    for(auto &[u, i] : g[v]) {\n        if (i == p) continue;\n        if (i < p) dfs(u, i, ct + 1);\n        else dfs(u, i, ct);\n    }\n}\n\nvoid solve() {\n    int n; cin >> n;\n    rep(i, n - 1) {\n        int u, v; cin >> u >> v;\n        g[v].emplace_back(u, i);\n        g[u].emplace_back(v, i);\n    }\n    ans = 1;\n    dfs(1, -1, 1);\n    for(int i = 1; i <= n; ++i) g[i].clear();\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(12) << fixed;\n    int t = 1;\n    cin >> t;\n    rep(i, t) {\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Copil Copac Draws Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "This problem can be solved via dynamic programming. From here on\nout, step from the statement will be called a \"scan\".Let be the number\nof scans needed to activate node , and be the index (in the order from\nthe input) of the edge which activated node .Intially, since only is\nactive, and .We will perform a dfs traversal starting from node . When\nwe process an edge , one of the following two cases can happen: If , we\ncan visit in the same scan as : , If , will be visited in the next scan\nafter : , The answer is .Time complexity per test case:\n",
    "hint": [
        "Hint 1 What is the answer if ?",
        "Hint 2 The previous case can be generalised to find the answer for any tree."
    ]
}