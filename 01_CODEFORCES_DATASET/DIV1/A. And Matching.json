{
    "link": "https://codeforces.com//contest/1630/problem/A",
    "problemId": "1275996",
    "problem_idx": "A",
    "shortId": "1630A",
    "contest_number": "1630",
    "problem_submissions": {
        "E": [
            144224769,
            144215907,
            144221628,
            144228274,
            144219804,
            144218158,
            144225764,
            144238591,
            144210990,
            144217838,
            144226182,
            144224358,
            144225778,
            144221770,
            144226514,
            144222722,
            144227026,
            144226268,
            144232930
        ],
        "F": [
            144210863,
            144246407,
            144239829,
            144237561,
            144242088,
            144244711,
            144244456,
            144246802,
            144259720,
            144255927,
            144333444,
            144255940,
            144608342,
            148502898,
            148434493,
            148432956
        ],
        "D": [
            144197307,
            144203996,
            144209276,
            144205176,
            144207016,
            144204010,
            144211325,
            144216890,
            144199054,
            144199808,
            144201432,
            144206931,
            144201023,
            144209262,
            144204729,
            144211122,
            144210123,
            144205407,
            144205842
        ],
        "C": [
            144191312,
            144195772,
            144199628,
            144200731,
            144196919,
            144198723,
            144205328,
            144206861,
            144191587,
            144193957,
            144195705,
            144198126,
            144190461,
            144203715,
            144198045,
            144205577,
            144200182,
            144197491,
            144198438
        ],
        "B": [
            144182123,
            144182453,
            144193080,
            144189508,
            144185231,
            144186871,
            144189030,
            144188822,
            144178499,
            144179435,
            144183325,
            144180542,
            144180237,
            144181268,
            144190041,
            144176578,
            144186138,
            144190693,
            144189698
        ],
        "A": [
            144175474,
            144175629,
            144182481,
            144180498,
            144176716,
            144180161,
            144180336,
            144179468,
            144172483,
            144171609,
            144171918,
            144172250,
            144173608,
            144173794,
            144181834,
            144190017,
            144177869,
            144180828,
            144177686
        ]
    },
    "name": "A. And Matching",
    "statement": "You are given a set of n (n is always a power of 2) elements containing\r\nall integers 0, 1, 2,\r\nldots, n-1 exactly once.Find\r\nfrac{n}{2} pairs of elements such that: Each element in the set is in\r\nexactly one pair. The sum over all pairs of the bitwise AND of its\r\nelements must be exactly equal to k. Formally, if a_i and b_i are the\r\nelements of the i-th pair, then the following must hold:\r\nsum_{i=1}^{n/2}{a_i\r\n& b_i} = k, where\r\n& denotes the bitwise AND operation. If there are many solutions, print\r\nany of them, if there is no solution, print -1 instead.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nvoid solve() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tif (n == 4 && k == 3) {\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\tif (k == 0) {\n\t\tfor (int x = 0; x < n / 2; x++) {\n\t\t\tprintf(\"%d %d\\n\", x, n - 1 - x);\n\t\t}\n\t} else if (k == n - 1) {\n\t\tprintf(\"0 %d\\n\", n / 2 - 2);\n\t\tprintf(\"%d %d\\n\", n / 2 - 1, n - 1);\n\t\tprintf(\"%d %d\\n\", n / 2, n / 2 + 1);\n\t\tfor (int x = 1; x < n / 2 - 2; x++) {\n\t\t\tprintf(\"%d %d\\n\", x, n - 1 - x);\n\t\t}\n\t} else {\n\t\tprintf(\"0 %d\\n\", n - 1 - k);\n\t\tprintf(\"%d %d\\n\", k, n - 1);\n\t\tfor (int x = 1; x < n / 2; x++) {\n\t\t\tif (x == k || x == n - 1 - k) continue;\n\t\t\tprintf(\"%d %d\\n\", x, n - 1 - x);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. And Matching.json",
    "editorial_link": "https://codeforces.com//blog/entry/99384",
    "editorial": "Constructive approach (easier)Let\u00e2\u0080\u0099s define , the compliment of ,\nas the number after changing all bits 0 to 1 and vice versa, for example\n.It can be shown that . Remember that since is a power of .We will\nseparate the problem into three cases. Case :In this case it is possible\nto pair with for , getting . Case :In this case it is possible to pair\neach element with its compliment except , , and , and then pair with and\nwith , and . Case :There are many constructions that work in this case,\nif there is no solution, if it is possible to construct the answer in\nthe following way:It is possible to pair with , with , with and all\nother elements with their compliments. , for example , for example , for\nexample All other elements can be paired with their complements and Note\nthat . Each case can be implemented in . Code Greedy approach\n(harder)Let\u00e2\u0080\u0099s define such that for and such that for .For example, for\nthey are: 1st element to swap 2nd element to swap after swap none none\nAll swaps are independent and are applied to the original and .After\nswapping two adjacent elements of (that have not been swapped) the sum\nwill change in for some positive integer .Then it is possible to solve\nthe problem by repeatedly swapping the pair that maximizes after the\nswap such that is held and none of its elements have been swapped\nyet.However, this only works for all values of if , the case can be\nhandled with brute force. Randomized approach (harder)Please read the\nprevious solution. Arrays and from it will also be used here. It is\npossible to start with and and repeatedly select and index randomly and\nswap with if holds until . We have no proof of this solution but it was\nstressed against each possible input to the problem and it worked\nquickly for , the case can be handled with brute force.\n"
}