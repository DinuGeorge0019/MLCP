{
    "link": "https://codeforces.com//contest/1071/problem/D",
    "problemId": "240849",
    "problem_idx": "D",
    "shortId": "1071D",
    "contest_number": "1071",
    "problem_submissions": {
        "D": [
            44637237,
            44635977,
            44641232,
            44642034,
            44645226,
            44644969,
            44641119,
            44687822,
            44647598,
            44647731,
            44636247,
            44657719,
            44657573,
            44656873,
            44656778,
            44656490,
            44656434,
            44656391,
            44656371,
            44656287,
            44656203,
            44656003,
            44655947,
            44655816,
            44655752,
            44655740,
            44655723,
            44655702,
            44655688,
            44655676,
            44655623,
            44655613,
            44655594,
            44655569,
            44655560,
            44655438,
            44655419,
            44655291,
            44647784,
            44642810,
            44645755,
            44645396,
            44646118,
            44644322,
            44654399
        ],
        "C": [
            44633806,
            44636722,
            44637213,
            44636382,
            44638429,
            44646089,
            44638832,
            44640208,
            44642096,
            44639762,
            44646904,
            44636416,
            44638641,
            44637725
        ],
        "B": [
            44628020,
            44627991,
            44628766,
            44629645,
            44629488,
            44629819,
            44628230,
            44629653,
            44629034,
            44630394,
            44631138,
            44629791,
            44632540,
            44629581,
            44629264,
            44627767,
            44636293,
            44628785
        ],
        "A": [
            44624756,
            44630092,
            44624598,
            44626465,
            44625487,
            44624461,
            44624565,
            44624711,
            44624763,
            44626685,
            44624210,
            44625000,
            44627102,
            44624838,
            44625068,
            44629237,
            44625506,
            44625349
        ],
        "E": [
            44647746,
            45395419,
            45395353,
            44682935,
            44682924
        ]
    },
    "name": "D. Familiar Operations",
    "statement": "You are given two positive integers a and b. There are two possible\r\noperations: multiply one of the numbers by some prime p; divide one of\r\nthe numbers on its prime factor p. What is the minimum number of\r\noperations required to obtain two integers having the same number of\r\ndivisors? You are given several such pairs, you need to find the answer\r\nfor each of them.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int d=500;\nconst int inf=1e9;\n\nint n;\n\nint sito[nax];\n\nvector <vi> setel;\n\nvi stos;\n\nvoid rek(int ogr, int dz)\n{\n\tsetel.push_back(stos);\n\tfor (int i=2; i<=ogr && dz*i<=d; i++)\n\t{\n\t\tstos.push_back(i-1);\n\t\trek(i, dz*i);\n\t\tstos.pop_back();\n\t}\n}\n\nmap <vi,vi> mapa;\n\nvoid uzu(const vi &wek)\n{\n\tmapa[wek].resize(d+1, inf);\n\tvi &widze=mapa[wek];\n\tfor (const vi &i : setel)\n\t{\n\t\tint odl=0;\n\t\tint ma=1;\n\t\tfor (int j=0; j<(int)i.size(); j++)\n\t\t\tma*=(i[j]+1);\n\t\tfor (int j=0; j<(int)max(i.size(), wek.size()); j++)\n\t\t{\n\t\t\tint x=0;\n\t\t\tint y=0;\n\t\t\tif (j<(int)i.size())\n\t\t\t\tx=i[j];\n\t\t\tif (j<(int)wek.size())\n\t\t\t\ty=wek[j];\n\t\t\todl+=abs(x-y);\n\t\t}\n\t\twidze[ma]=min(widze[ma], odl);\n\t}\n}\n\nvi daj(int w)\n{\n\tvi ter;\n\tint v=w;\n\twhile(v>1)\n\t{\n\t\tint a=sito[v];\n\t\tter.push_back(0);\n\t\twhile(!(v%a))\n\t\t{\n\t\t\tter.back()++;\n\t\t\tv/=a;\n\t\t}\n\t}\n\tsort(ter.begin(), ter.end());\n\treverse(ter.begin(), ter.end());\n\tif (!mapa.count(ter))\n\t\tuzu(ter);\n\treturn ter;\n}\n\nvoid query()\n{\n\tint a, b;\n\tscanf(\"%d%d\", &a, &b);\n\tvi raz=daj(a);\n\tvi dwa=daj(b);\n\tint wyn=inf;\n\tvi &x=mapa[raz];\n\tvi &y=mapa[dwa];\n\tfor (int i=0; i<=d; i++)\n\t\twyn=min(x[i]+y[i], wyn);\n\tprintf(\"%d\\n\", wyn);\n}\n\nint main()\n{\n\tfor (int i=2; i<nax; i++)\n\t\tif (!sito[i])\n\t\t\tfor (int j=i; j<nax; j+=i)\n\t\t\t\tsito[j]=i;\n\trek(240, 1);\n\tdebug() << imie(setel.size());\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\tquery();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Familiar Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/62612",
    "editorial": "Note that if a=?i=1kpxii\n then d(a)=?i=1k(xi+1)\n. This implies that we can map a\n to vector (x1,x2,,xk)\n, where x1?x2??xk\n, because the order of the powers doesn't matter. The operations correspond to adding 1 to some item or appending 1 to the end of the vector or decreasing 1 from some item and sorting the vector after that, erasing zeros. There are only 289 different such vectors for numbers up to 106\n, so we need to calculate only 41616 distances.\n\nThe first thought could be to just run Floyd-Warshall algorithm on these 289 vertices, which would fit in time. After that for each pair (x,d)\n we can find the minimum number of operations needed to make with vector x\n so that the generated number has d\n divisors. To find the answer for (x,y)\n, we could simply iterate over all possible values of d\n. But there are some tricky cases. For example, for numbers 219\n and 2236\n the answer is 1, because after multiplying the first number by 2 both numbers have 21 divisors. But the number 220>106\n, and the vector (20)\n is not among these 289 vertices. So, we need to consider some other vectors too.\n\nAnyway, let's run this algorithm to see what could be the maximal distance between the two numbers up to 106\n. It turns out that in 10 operations any two numbers can be led to have the same number of divisors when all numbers in the path don't exceed 106\n too.\n\nThis means that each possible number in the optimal path satisfies ?i=1kxi<30\n, because for the numbers in the input this sum doesn't exceed 19, and there can be no more than 10 operations with each number. This condition gives us all vectors of powers necessary to consider as middle points for the pairs which can be in the input. There are 28629 such vectors. Now we run 289 bfs instances on the generated graph with the start in each possible vector from the input and build the same data structure for pairs (x,d)\n as explained before, which allows us to find the answers for all vectors of numbers up to 106\n.\n\nThis solution works in 2.5s on cf servers, which is still too slow. But the thing is that we found answers for all pairs of the vectors from the input. So we can try to get rid of some unnecessary vertices and simply check if the sum of answers is unchanged. One of the possible speedups is to consider only vectors generating the number of divisors not more than some reasonable number. The maximum number of divisors of some necessary vector is 288, so magic constants like 300 or more will work. Another possible speedup is to decrease the border on the sum of powers from 30 to 22, which is precise.",
    "hint": []
}