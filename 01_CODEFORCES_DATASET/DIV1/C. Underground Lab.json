{
    "link": "https://codeforces.com//contest/781/problem/C",
    "problemId": "96951",
    "problem_idx": "C",
    "shortId": "781C",
    "contest_number": "781",
    "problem_submissions": {
        "B": [
            25258392,
            25257297,
            25250177,
            25250748,
            25251116,
            25249653,
            25250716,
            25250834,
            25250705,
            25251947,
            25250575,
            31121662,
            25252893,
            25252683,
            25253146,
            25255775,
            25252991,
            25253498
        ],
        "E": [
            25256397,
            25254067,
            25258825,
            25260075,
            26145785,
            25259028,
            25259758,
            25260563,
            25260848,
            25261488,
            25260086,
            25703349,
            25261912,
            25262169,
            25262264,
            25261946,
            25261665,
            25262876,
            25262009
        ],
        "D": [
            25252423,
            25259248,
            25255529,
            25254368,
            25256042,
            25256267,
            25256774,
            25256075,
            25254834,
            25256057,
            25266603,
            25256151,
            25257817,
            25258124,
            25258109,
            25258052,
            25258679,
            25258333
        ],
        "C": [
            25249500,
            25249747,
            25251802,
            25252056,
            25252378,
            25250971,
            25252726,
            25253382,
            25252087,
            25253151,
            25252105,
            25254478,
            25253975,
            25254827,
            25254070,
            25255284,
            25254950
        ],
        "A": [
            25247143,
            25247027,
            25247783,
            25247695,
            25248775,
            25247133,
            25247620,
            25248678,
            25249108,
            25249147,
            25247139,
            25249553,
            25248502,
            25248323,
            25249740,
            25249518,
            25247402
        ],
        "F": [
            25268984,
            25267317,
            25271843,
            25271410,
            25271394,
            25271157,
            25270611,
            26202615
        ]
    },
    "name": "C. Underground Lab",
    "statement": "The evil Bumbershoot corporation produces clones for gruesome\r\nexperiments in a vast underground lab. On one occasion, the corp cloned\r\na boy Andryusha who was smarter than his comrades. Immediately Andryusha\r\nunderstood that something fishy was going on there. He rallied fellow\r\nclones to go on a feud against the evil corp, and they set out to find\r\nan exit from the lab. The corp had to reduce to destroy the lab\r\ncomplex.The lab can be pictured as a connected graph with vertices and\r\nedges. clones of Andryusha start looking for an exit in some of the\r\nvertices. Each clone can traverse any edge once per second. Any number\r\nof clones are allowed to be at any vertex simultaneously. Each clone is\r\nallowed to stop looking at any time moment, but he must look at his\r\nstarting vertex at least. The exit can be located at any vertex of the\r\nlab, hence each vertex must be visited by at least one clone.Each clone\r\ncan visit at most vertices before the lab explodes.Your task is to\r\nchoose starting vertices and searching routes for the clones. Each route\r\ncan have at most vertices.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:1000000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n\n\nconst int MAXN = 500001;\nvector <int> e[MAXN];\nbool w[MAXN];\nint ans[MAXN], ac = 0;\n\nvoid dfs(int v)\n{\n\tans[ac++] = v;\n\tw[v] = true;\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tint u = e[v][i];\n\t\tif (w[u]) continue;\n\t\tdfs(u);\n\t\tans[ac++] = v;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tint mv = 1;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\t\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tmemset(w, 0, sizeof(w));\n\tdfs(1);\n\tint cn = (2 * n - 1) / k + 1;\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tint l = i * cn;\n\t\tl = min(l, ac - 1);\n\t\tint r = min(ac - 1, l + cn - 1);\n\t\tcout << r - l + 1;\n\t\tfor (int j = l; j <= r; j++) cout << \" \" << ans[j];\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Underground Lab.json",
    "editorial_link": "https://codeforces.com//blog/entry/50854",
    "editorial": "Let\u00e2\u0080\u0099s start a DFS at any vertex of the graph, and produce an Euler tour\r\nthe order of vertices visited by a DFS, where each vertex is written\r\ndown every time DFS visits it (in particular, when a recursive call made\r\nfrom terminates). Note that the Euler tour has exactly entries in it,\r\nhence it would be a correct answer for . For a general , cut the Euler\r\ntour into consecutive pieces of size at most , and yield it as an\r\nanswer. Note that each path of the answer has to contain at least one\r\nvertex.Complexity: time and memory.\r\n"
}