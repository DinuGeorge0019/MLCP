{"link": "https://codeforces.com//contest/494/problem/D", "problemId": "19367", "problem_idx": "D", "shortId": "494D", "contest_number": "494", "problem_submissions": {"D": [9118626, 9110497, 9186603, 9121795, 9113766, 9135685, 9135672, 9135646, 9135644, 9118440, 9118021, 9114872], "C": [9115660, 9117032, 9115729, 9112157, 9113416, 9118088, 9112989, 9113678, 9114840, 9114457, 9115024, 9116699, 9114578, 9115874, 9153533], "E": [9112090, 9123061, 9123029, 9114944, 9811638], "B": [9104681, 9106022, 9107594, 9107713, 9107377, 9105960, 9107410, 9107902, 9108808, 9108302, 9109468, 9108127, 9106911, 9107132, 9108038, 9109018], "A": [9103881, 9104046, 9103935, 9104128, 9103929, 9104036, 9104015, 9104004, 9104614, 9104250, 9104342, 9104831, 9104167, 9104248, 9104541, 9104804]}, "name": "D. Birthday", "statement": "Ali is Hamed\u2019s little brother and tomorrow is his birthday. Hamed wants\r\nhis brother to earn his gift so he gave him a hard programming problem\r\nand told him if he can successfully solve it, he\u2019ll get him a brand new\r\nlaptop. Ali is not yet a very talented programmer like Hamed and\r\nalthough he usually doesn\u2019t cheat but this time is an exception. It\u2019s\r\nabout a brand new laptop. So he decided to secretly seek help from you.\r\nPlease solve this problem for Ali. An -vertex weighted rooted tree is\r\ngiven. Vertex number is a root of the tree. We define as the sum of\r\nedges weights on the shortest path between vertices and . Specifically\r\nwe define . Also let\u2019s define for each vertex as a set containing all\r\nvertices such that . Function is then defined using the following\r\nformula:The goal is to calculate for each of the given pair of vertices.\r\nAs the answer can be rather large it\u2019s enough to print it modulo .\r\n", "solutions": ["#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 400010;\n\nvector < pair <int, int> > g[N];\nint cnt[N], sum[N], sumsq[N];\nint tin[N], tout[N], TIME = 0;\nint depth[N];\nint pv[N];\nconst int LOG = 20;\nint pr[N][LOG];\n\nvoid dfs(int v, int pr) {\n  tin[v] = ++TIME;\n  int sz = g[v].size();\n  cnt[v] = 1;\n  sum[v] = 0;\n  sumsq[v] = 0;\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    pv[u] = v;\n    int len = g[v][j].second;\n    depth[u] = depth[v];\n    add(depth[u], len);\n    dfs(u, v);\n    add(cnt[v], cnt[u]);\n    add(sum[v], sum[u]);\n    add(sum[v], mul(cnt[u], len));\n    add(sumsq[v], sumsq[u]);\n    add(sumsq[v], mul(cnt[u], mul(len, len)));\n    add(sumsq[v], mul(mul(2, len), sum[u]));\n  }\n  tout[v] = ++TIME;\n}\n\nbool anc(int x, int y) {\n  return (tin[x] <= tin[y] && tout[y] <= tout[x]);\n}\n\nint lca(int x, int y) {\n  if (anc(x, y)) return x;\n  for (int j = LOG - 1; j >= 0; j--)\n    if (!anc(pr[x][j], y)) x = pr[x][j];\n  return pv[x];\n}\n\nint ups[N];\nint up[N];\nint n;\n\nvoid get_up(int v, int pr) {\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    int len = g[v][j].second;\n    int no_s = sum[v];\n    add(no_s, md - sum[u]);\n    add(no_s, md - mul(cnt[u], len));\n    add(no_s, ups[v]);\n    int no_sq = sumsq[v];\n    add(no_sq, md - sumsq[u]);\n    add(no_sq, md - mul(cnt[u], mul(len, len)));\n    add(no_sq, md - mul(mul(2, len), sum[u]));\n    up[u] = up[v];\n    add(up[u], no_sq);\n    add(up[u], mul(n - cnt[u], mul(len, len)));\n    add(up[u], mul(mul(2, len), no_s));\n    ups[u] = ups[v];\n    int no_sss = sum[v];\n    add(no_sss, md - sum[u]);\n    add(no_sss, md - mul(cnt[u], len));\n    add(ups[u], no_sss);\n    add(ups[u], mul(n - cnt[u], len));\n    get_up(u, v);\n  }\n}\n\nint res[N];\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar, len;\n    scanf(\"%d %d %d\", &foo, &bar, &len);\n    foo--; bar--;\n    g[foo].push_back(make_pair(bar, len));\n    g[bar].push_back(make_pair(foo, len));\n  }\n  depth[0] = 0;\n  dfs(0, -1);\n  for (int i = 0; i < n; i++) pr[i][0] = pv[i];\n  for (int j = 1; j < LOG; j++)\n    for (int i = 0; i < n; i++) pr[i][j] = pr[pr[i][j - 1]][j - 1];\n  ups[0] = 0;\n  up[0] = 0;\n  get_up(0, -1);\n  for (int i = 0; i < n; i++) {\n    res[i] = sumsq[i];\n    add(res[i], up[i]);\n  }\n  int tt;\n  scanf(\"%d\", &tt);\n  while (tt--) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--; v--;\n    if (!anc(v, u)) {\n      int len = depth[v];\n      add(len, depth[u]);\n      int z = lca(v, u);\n      add(len, md - mul(2, depth[z]));\n      int good = sumsq[v];\n      add(good, mul(cnt[v], mul(len, len)));\n      add(good, mul(mul(2, len), sum[v]));\n      good = mul(good, 2);\n      add(good, md - res[u]);\n      printf(\"%d\\n\", good);\n    } else {\n      int len = depth[u];\n      add(len, md - depth[v]);\n      int good = up[v];\n      add(good, mul(n - cnt[v], mul(len, len)));\n      add(good, mul(mul(2, len), ups[v]));\n      good = (res[u] - good + md) % md;\n      good = mul(good, 2);\n      add(good, md - res[u]);\n      printf(\"%d\\n\", good);\n    }\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dp", "trees"], "dificulty": "2700", "interactive": false}