{
    "link": "https://codeforces.com//contest/590/problem/A",
    "problemId": "39111",
    "problem_idx": "A",
    "shortId": "590A",
    "contest_number": "590",
    "problem_submissions": {
        "D": [
            13843353,
            13843241,
            13846192,
            13845400,
            13845513,
            13845184,
            13845284,
            13846104,
            13845914,
            13848116,
            13848012,
            13846585,
            13846955,
            13840525,
            13846113,
            13846571,
            13847155,
            13846536,
            13845841
        ],
        "C": [
            13840565,
            13839464,
            13840329,
            13843147,
            13843128,
            13843106,
            13843875,
            13843172,
            13844215,
            13844757,
            13843685,
            13843265,
            13844084,
            13843699,
            13844122,
            13843229,
            13845260,
            13842294,
            13843462
        ],
        "B": [
            13838659,
            13841125,
            13841907,
            13840783,
            13840726,
            13840188,
            13840959,
            13840763,
            13840870,
            13840852,
            13844831,
            13840705,
            13841546,
            13846846,
            13841487,
            13840918,
            13842200,
            13844393,
            13849735
        ],
        "A": [
            13837458,
            13845623,
            13837970,
            13838181,
            13838474,
            13837720,
            13839193,
            13837760,
            13839312,
            13838940,
            13839590,
            13838409,
            13837478,
            13845897,
            13839666,
            13839453,
            13839053,
            13838125,
            13838135
        ],
        "E": [
            13864277,
            13874288,
            13867064,
            14107310,
            13924688,
            13922852,
            13869938
        ]
    },
    "name": "A. Median Smoothing",
    "statement": "A schoolboy named Vasya loves reading books on programming and\r\nmathematics. He has recently read an encyclopedia article that described\r\nthe method of (or median filter) and its many applications in science\r\nand engineering. Vasya liked the idea of the method very much, and he\r\ndecided to try it in practice.Applying the simplest variant of median\r\nsmoothing to the sequence of numbers will result a new sequence obtained\r\nby the following algorithm: , , that is, the first and the last number\r\nof the new sequence match the corresponding numbers of the original\r\nsequence. For value is equal to the of three values , and . The of a set\r\nof three numbers is the number that goes on the second place, when these\r\nthree numbers are written in the non-decreasing order. For example, the\r\nmedian of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is\r\nequal to 1.In order to make the task easier, Vasya decided to apply the\r\nmethod to sequences consisting of zeros and ones only.Having made the\r\nprocedure once, Vasya looked at the resulting sequence and thought: what\r\nif I apply the algorithm to it once again, and then apply it to the next\r\nresult, and so on? Vasya tried a couple of examples and found out that\r\nafter some number of median smoothing algorithm applications the\r\nsequence can stop changing. We say that the sequence is , if it does not\r\nchange when the median smoothing is applied to it.Now Vasya wonders,\r\nwhether the sequence always eventually becomes stable. He asks you to\r\nwrite a program that, given a sequence of zeros and ones, will determine\r\nwhether it ever becomes stable. Moreover, if it ever becomes stable,\r\nthen you should determine what will it look like and how many times one\r\nneeds to apply the median smoothing algorithm to initial sequence in\r\norder to obtain a stable one.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int N;\n    scanf(\"%d\", &N);\n    vi a(N);\n    forn(i, N) scanf(\"%d\", &a[i]);\n    vi b(N);\n    for1(i, N - 2) b[i] = a[i] != a[i - 1] && a[i] != a[i + 1];\n    int ans = 0;\n    int i = 1;\n    while (i < N - 1) {\n        if (!b[i]) ++i;\n        else {\n            int j = i;\n            while (b[j]) ++j;\n            uax(ans, (j - i + 1) / 2);\n            if ((j - i) % 2 == 1) for (int k = i; k < j; ++k) a[k] = a[i - 1];\n            else for (int k = i; k < j; ++k) a[k] = (k < (i + j) / 2 ? a[i - 1] : a[j]);\n            i = j;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    forn(i, N) printf(\"%d \", a[i]);\n    printf(\"\\n\");\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Median Smoothing.json",
    "editorial_link": "https://codeforces.com//blog/entry/21203",
    "editorial": "We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.\n\nNow we should take a look at how do stable elements affect their neighbors. Suppose ai?-?1?=?ai, meaning i?-?1 and i are stable. Additionaly assume, that ai?+?1 is not a stable element, hence ai?+?1???ai and ai?+?1???ai?+?2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai?=?ai?+?2 and applying a median smoothing algorithm to this sequence will result in ai?=?ai?+?1. That means, if there is a stable element in position i, both i?+?1 and i?-?1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.\n\nNote, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak?=?(ai?+?k?-?i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.\n\nThe solution is: calculate max(min(|i?-?sj|)), where sj are the initial stable elements. Time complexity is O(n).\n\nChallenge 1: hack the solution that just applies median smoothing until something changes.\n\nChallenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL)."
}