{"link": "https://codeforces.com//contest/1218/problem/E", "problemId": "412337", "problem_idx": "E", "shortId": "1218E", "contest_number": "1218", "problem_submissions": {"D": [60648151, 60643203, 60647260, 60645392, 60642748], "H": [60644806, 60638524], "E": [60642127, 60641056, 60641513, 60643564, 60648498], "I": [60640334, 60639607, 60640474, 60637390, 60638678], "F": [60638215, 60637531, 60635942, 60636552, 60636479], "C": [60637983, 60674902, 60648025], "B": [60648802], "A": [60645770]}, "name": "E. Product Tuples", "statement": "While roaming the mystic areas of Stonefalls, in order to drop legendary\r\nloot, an adventurer was given a quest as follows. He was given an array\r\nA = {a_1,a_2,...,a_N } of length N, and a number K.Define array B as\r\nB(q, A) = { q-a_1, q-a_2, ..., q-a_N }. Define function F as F(B,K)\r\nbeing sum of products of all K-tuples of elements in array B. For\r\nexample, if the array B is [2,3,4,5], and with K=3, sum of products of\r\nall 3-tuples is F(B, 3) = 2*3*4+2*3*5+3*4*5+2*4*5He was then given a\r\nnumber Q, number of queries of two types: Type 1: Given q, i, and d\r\ncalculate F(B(q, A), K) where we make change to initial array as A[i] =\r\nd. Type 2: Given q, L, R, and d calculate F(B(q, A), K) where we make\r\nchange to initial array as A[i] = A[i] + d for all i in range [L, R]\r\ninclusive. All changes are temporarily made to initial array, and don\u2019t\r\npropagate to following queries. Help the adventurer calculate the answer\r\nto a quest, and finally get that loot!\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing lint = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\ntypedef complex<double> base;\nvoid fft(vector<base> &a, bool inv){\n\tint n = a.size(), j = 0;\n\tvector<base> roots(n/2);\n\tfor(int i=1; i<n; i++){\n\t\tint bit = (n >> 1);\n\t\twhile(j >= bit){\n\t\t\tj -= bit;\n\t\t\tbit >>= 1;\n\t\t}\n\t\tj += bit;\n\t\tif(i < j) swap(a[i], a[j]);\n\t}\n\tdouble ang = 2 * acos(-1) / n * (inv ? -1 : 1);\n\tfor(int i=0; i<n/2; i++){\n\t\troots[i] = base(cos(ang * i), sin(ang * i));\n\t}\n\t/* In NTT, let prr = primitive root. Then,\n\tint ang = ipow(prr, (mod - 1) / n);\n\tif(inv) ang = ipow(ang, mod - 2);\n\tfor(int i=0; i<n/2; i++){\n\t\troots[i] = (i ? (1ll * roots[i-1] * ang % mod) : 1);\n\t}\n\tXOR Convolution : set roots[*] = 1.\n\tOR Convolution : set roots[*] = 1, and do following:\n    if (!inv) {\n        a[j + k] = u + v;\n        a[j + k + i/2] = u;\n    } else {\n        a[j + k] = v;\n        a[j + k + i/2] = u - v;\n    }\n\t*/\n\tfor(int i=2; i<=n; i<<=1){\n\t\tint step = n / i;\n\t\tfor(int j=0; j<n; j+=i){\n\t\t\tfor(int k=0; k<i/2; k++){\n\t\t\t\tbase u = a[j+k], v = a[j+k+i/2] * roots[step * k];\n\t\t\t\ta[j+k] = u+v;\n\t\t\t\ta[j+k+i/2] = u-v;\n\t\t\t}\n\t\t}\n\t}\n\tif(inv) for(int i=0; i<n; i++) a[i] /= n; // skip for OR convolution.\n}\n\nvector<lint> multiply(vector<lint> &v, vector<lint> &w){\n\tvector<base> fv(v.begin(), v.end()), fw(w.begin(), w.end());\n\tint n = 2; while(n < v.size() + w.size()) n <<= 1;\n\tfv.resize(n); fw.resize(n);\n\tfft(fv, 0); fft(fw, 0);\n\tfor(int i=0; i<n; i++) fv[i] *= fw[i];\n\tfft(fv, 1);\n\tvector<lint> ret(n);\n\tfor(int i=0; i<n; i++) ret[i] = (lint)round(fv[i].real());\n\treturn ret;\n}\nvector<lint> multiply(vector<lint> &v, vector<lint> &w, lint mod){\n\tint n = 2; while(n < v.size() + w.size()) n <<= 1;\n\tvector<base> v1(n), v2(n), r1(n), r2(n);\n\tfor(int i=0; i<v.size(); i++){\n\t\tv1[i] = base(v[i] >> 15, v[i] & 32767);\n\t}\n\tfor(int i=0; i<w.size(); i++){\n\t\tv2[i] = base(w[i] >> 15, w[i] & 32767);\n\t}\n\tfft(v1, 0);\n\tfft(v2, 0);\n\tfor(int i=0; i<n; i++){\n\t\tint j = (i ? (n - i) : i);\n\t\tbase ans1 = (v1[i] + conj(v1[j])) * base(0.5, 0);\n\t\tbase ans2 = (v1[i] - conj(v1[j])) * base(0, -0.5);\n\t\tbase ans3 = (v2[i] + conj(v2[j])) * base(0.5, 0);\n\t\tbase ans4 = (v2[i] - conj(v2[j])) * base(0, -0.5);\n\t\tr1[i] = (ans1 * ans3) + (ans1 * ans4) * base(0, 1);\n\t\tr2[i] = (ans2 * ans3) + (ans2 * ans4) * base(0, 1);\n\t}\n\tfft(r1, 1);\n\tfft(r2, 1);\n\tvector<lint> ret(n);\n\tfor(int i=0; i<n; i++){\n\t\tlint av = (lint)round(r1[i].real());\n\t\tlint bv = (lint)round(r1[i].imag()) + (lint)round(r2[i].real());\n\t\tlint cv = (lint)round(r2[i].imag());\n\t\tav %= mod, bv %= mod, cv %= mod;\n\t\tret[i] = (av << 30) + (bv << 15) + cv;\n\t\tret[i] %= mod;\n\t\tret[i] += mod;\n\t\tret[i] %= mod;\n\t}\n\treturn ret;\n}\n\nconst int N = 20005, M = 998244353;\n\nint n, k, q;\nll a[N], aa[N], b[N];\n\nvector<ll> f(int s, int e){\n    if(s == e){\n        vector<ll> v;\n        v.push_back(b[s]);\n        v.push_back(1);\n        return v;\n    }\n    vector<ll> lv = f(s, (s+e)/2);\n    vector<ll> rv = f((s+e)/2+1, e);\n    return multiply(lv, rv, M);\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> k;\n    for(int i = 1; i <= n; i++) cin >> a[i];\n    cin >> q;\n    for(int t, x, y, z, w; q--; ){\n        cin >> t >> x >> y >> z;\n        if(t == 1){\n            for(int i = 1; i <= n; i++) aa[i] = a[i];\n            aa[y] = z; \n        }\n        else{\n            cin >> w;\n            for(int i = 1; i <= n; i++) aa[i] = a[i];\n            for(int i = y; i <= z; i++) aa[i] += w;\n        }\n        for(int i = 1; i <= n; i++) b[i] = ((x - aa[i]) % M + M) % M;\n        cout << (f(1, n)[n - k] % M + M) % M << '\\n';\n    }\n}"], "input": "", "output": "", "tags": ["divide and conquer", "fft"], "dificulty": "2500", "interactive": false}