{
    "link": "https://codeforces.com//contest/317/problem/D",
    "problemId": "3169",
    "problem_idx": "D",
    "shortId": "317D",
    "contest_number": "317",
    "problem_submissions": {
        "B": [
            3893431,
            3887094,
            3885846,
            3887031,
            3886538,
            3889909,
            3893582,
            3888615,
            3887617,
            3888413,
            3888179,
            3889453,
            3887116,
            3887888,
            3894545,
            3895617,
            3886384,
            3887572
        ],
        "C": [
            3892027,
            3893534,
            3892980,
            3892836,
            3889579,
            3894319,
            3891793,
            3887685,
            3891002,
            3893514,
            3895626,
            3891853,
            3895456,
            3895311,
            3890113,
            3891161,
            3891706,
            3890677
        ],
        "D": [
            3888744,
            3888593,
            3888799,
            3890273,
            3892231,
            3885265,
            3887984,
            3892250,
            3893865,
            3891338,
            3894467,
            3893215,
            3890469,
            3890547,
            3891578,
            3893589,
            3896477,
            3896297
        ],
        "A": [
            3884031,
            3884987,
            3884002,
            3884136,
            3889852,
            3886867,
            3884602,
            3891904,
            3885568,
            3884656,
            3883909,
            3885144,
            3894966,
            3884417,
            3885139
        ],
        "E": [
            3932317,
            3896465,
            3896429
        ]
    },
    "name": "D. Game with Powers",
    "statement": "Vasya and Petya wrote down all integers from to to play the \"powers\"\r\ngame ( can be quite large; however, Vasya and Petya are not confused by\r\nthis fact).Players choose numbers in turn (Vasya chooses first). If some\r\nnumber is chosen at the current turn, it is forbidden to choose or all\r\nof its other positive integer powers (that is, , , ) at the next turns.\r\nFor instance, if the number is chosen at the first turn, one cannot\r\nchoose or later, while it is still allowed to choose or . The one who\r\ncannot make a move loses.Who wins if both Vasya and Petya play\r\noptimally?\r\n",
    "solutions": [
        "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nbool taken[40005];\n\nint val[] = {\n        0,\n        1,\n        2,\n        1,\n        4,\n        3,\n        2,\n        1,\n        5,\n        6,\n        2,\n        1,\n        8,\n        7,\n        5,\n        9,\n        8,\n        7,\n        3,\n        4,\n        7,\n        4,\n        2,\n        1,\n        10,\n        9,\n        3,\n        6,\n        11,\n        12\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    int res = 0;\n    int rem = n;\n    for (int i = 2; i * i <= n; ++i) {\n        if (taken[i]) {\n            continue;\n        }\n        int sz = 1;\n        int a = i;\n        taken[a] = true;\n        while (a * (LL) i <= n) {\n            a *= i;\n            ++sz;\n            if (a * (LL) a <= n) {\n                taken[a] = true;\n            }\n        }\n        rem -= sz;\n        res ^= val[sz];\n    }\n    res ^= (rem % 2);\n    cout << (res ? \"Vasya\" : \"Petya\") << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Game with Powers.json",
    "editorial_link": "https://codeforces.com//blog/entry/7956",
    "editorial": "For each numner denote sequence of its powers within as : Game proceeds\r\nas follows: on each step one player takes still available number from to\r\nand prohibits whole set . Who can\u00e2\u0080\u0099t make his turn loses. This game may\r\nbe decomposed in the sum of lesser games. Indeed, lets call number\r\nsimple (and corresponding sequence simple), if it is not a power of any\r\nnumber . Then: 1. for each there is simple , such that ; 2. for each\r\nsimple distinct and sets and do not intersect. Indeed, for a given there\r\nis exactly one simple such that is power of . This may be showed from\r\nfundamental theorem of arithmetic: if and , then . Hence set decomposes\r\ninto primitive sets , on each of those game proceeds independetly. Now\r\none may use Sprague Grundy theory to see that mexx of our game is just\r\nxor of all mexx of games on simple . For fixed , if , then mexx of the\r\ngame on depends only on , but not on . In our case runs from to , mexx\r\nfor all such may be directly precalculated. Now it is enough to find\r\nnumbers of simple with a given size of equal to (actually we are\r\ninterested in parity of not in itself). Our constraints allows to do it\r\ndirectly: run from to , if it is not crossed out, determine the size\r\n[increment corresponding ], and cross out all numbers from . This cycle\r\nfinds all simple sequences of length at least . Quantity of non-crossed\r\nnumbers is the number of all simple sequences of length . Now it is\r\nenough to look at parities of and xor coressponding mexx. However one\r\nmay find all for . Indeed lets look at the number and sequence . This\r\nsequence is not simple iff it is containd in some larger simple\r\nsequence. But number of subsequenes of size in a given sequence of size\r\nis easy to find: it is just . Recalling that simple sequences do not\r\nintersect one gets the reccurent formula: . Now it is easy to find all\r\nfrom to . Remark: while coding it is important to remeber simple number\r\n.\r\n"
}