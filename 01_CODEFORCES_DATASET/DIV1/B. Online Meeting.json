{
    "link": "https://codeforces.com//contest/420/problem/B",
    "problemId": "8699",
    "problem_idx": "B",
    "shortId": "420B",
    "contest_number": "420",
    "problem_submissions": {
        "D": [
            6447019,
            6443008,
            6912685,
            6445957,
            6445329,
            6443168,
            6444131,
            6443396,
            6445355,
            6451593,
            6451581,
            6451576,
            6445477,
            6445823,
            6445771,
            6446204,
            6445678,
            6446109,
            6446112,
            6453468,
            6446223,
            6446441
        ],
        "E": [
            6445798,
            6444814,
            6444979,
            6445922,
            97601411,
            6445707,
            6451168,
            6446265,
            6453470,
            6452703
        ],
        "B": [
            6443597,
            6444025,
            6443126,
            6443737,
            6443495,
            6442572,
            6444279,
            6445309,
            6444923,
            6442844,
            6443551,
            6443899,
            6443352,
            6444309,
            6444403,
            6443539,
            6442859,
            6444609,
            6443627
        ],
        "C": [
            6442567,
            6449379,
            6444178,
            6442191,
            6444286,
            6443894,
            6442929,
            6444396,
            6449718,
            6444138,
            6442459,
            6444175,
            6443120,
            6442842,
            6444661,
            6443838,
            6443047,
            6444348
        ],
        "A": [
            6440359,
            6440343,
            6443435,
            6440637,
            6440896,
            6440723,
            6443481,
            6440285,
            6440476,
            6440399,
            6440452,
            6440422,
            6440497,
            6442028,
            6443134,
            6440669,
            6440645,
            6440656,
            6441090
        ]
    },
    "name": "B. Online Meeting",
    "statement": "Nearly each project of the F company has a whole team of developers\r\nworking on it. They often are in different rooms of the office in\r\ndifferent cities and even countries. To keep in touch and track the\r\nresults of the project, the F company conducts shared online meetings in\r\na Spyke chat.One day the director of the F company got hold of the\r\nrecords of a part of an online meeting of one successful team. The\r\ndirector watched the record and wanted to talk to the team leader. But\r\nhow can he tell who the leader is? The director logically supposed that\r\nthe leader is the person who is present at any conversation during a\r\nchat meeting. In other words, if at some moment of time at least one\r\nperson is present on the meeting, then the leader is present on the\r\nmeeting.You are the assistant director. Given the \u2019user logged on\u2019/\u2019user\r\nlogged off\u2019 messages of the meeting in the chronological order, help the\r\ndirector determine who can be the leader. Note that the director has the\r\nrecord of only a continuous part of the meeting (probably, it\u2019s not the\r\nwhole meeting).\r\n",
    "solutions": [
        "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define N 100005\nusing namespace std;\n\nint n, m, cnt;\nint v[N], nod[N], a[N], L[N];\nchar op[N][5];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tCLR(v, -1);\n\tFOR(i,0,m){\n\t\tscanf(\"%s%d\", &op[i], &a[i]), --a[i];\n\t\tif (v[a[i]] == -1) v[a[i]] = (op[i][0] == '+' ? 1 : 0);\n\t}\n\t\n\tint sz = 0;\n\tFOR(i,0,n){\n\t\tif (v[i] == 0) ++cnt;\n\t\tif (v[i] == 1) L[sz++] = i;\n\t}\n\t\n\tif (cnt > 0){\n\t\twhile (sz) nod[L[--sz]] = 1;\n\t}\n\t\n\tFOR(i,0,m){\n\t\tif (op[i][0] == '+'){\n\t\t\tif (cnt > 0) nod[a[i]] = 1;\n\t\t\t++cnt;\n\t\t\twhile (sz){\n\t\t\t\t--sz;\n\t\t\t\tif (L[sz] != a[i]) nod[L[sz]] = 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t--cnt;\n\t\t\tif (cnt > 0) nod[a[i]] = 1;\n\t\t\tif (!nod[a[i]]) L[sz++] = a[i];\n\t\t}\n\t}\n\t\n\tint ret = n;\n\tFOR(i,0,n) ret -= nod[i];\n\tprintf(\"%d\\n\", ret);\n\tFOR(i,0,n) if (!nod[i]) printf(\"%d \", i + 1);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Online Meeting.json",
    "editorial_link": "https://codeforces.com//blog/entry/11871",
    "editorial": "Firstly lets add to the answer all the persons, that didn\u00e2\u0080\u0099t appear in\r\nthe log messages. Then we should consider two cases: 1) If there is a\r\nperson (with number ), that the first log message with him is in form .\r\nWe will call such persons X-persons. Consider all X-persons. Pick the\r\none from them that has the last first occurrence in the sequence of\r\nmessages. This person can be a leader, all others cannot be. Now we\r\nshould check if the picked person is a leader or not. For that reason we\r\nwill use the algorithm that is described below. This algorithm works\r\nfine only on special sequences of messages. So, we need to add all the\r\nX-persons to the beginning of the our list in the order they appear in\r\ninput (in the resulting sequence the picked person should be the first).\r\n2) There is no X-persons. That case only the first person from the list\r\ncan be a leader. Others cannot be. Check that person with the algorithm\r\ndescribed below. The Algorithm of check: The algorithm is very simple.\r\nJust to iterate throughout the sequence of messages and maintain\r\n-structure for the persons that are currently on the meeting. If we\r\nconsider log-on message, add the person to the set, if we consider\r\nlog-off message, erase the person from the set. Each time we perform an\r\noperation with set, we should check: either the set is empty or the\r\nleader is in set. The most tricky cases are 33 and 34. Will look at\r\nthem, the 33-th test: 4 4 + 2 - 1 - 3 - 2 Here the leader can be only\r\n4-th person. Others cannot be. The 34-th test: 3 3 - 2 + 1 + 2 The\r\nanswer for that test is only the 3-rd participant.\r\n"
}