{
    "link": "https://codeforces.com//contest/1830/problem/C",
    "problemId": "1942557",
    "problem_idx": "C",
    "shortId": "1830C",
    "contest_number": "1830",
    "problem_submissions": {
        "F": [
            234326044,
            207652053,
            207663837,
            207807721,
            208075080,
            208075031,
            207678271
        ],
        "D": [
            207640246,
            207630410,
            207637627,
            207621354,
            207615321,
            207636175,
            207642613,
            207640107,
            207677598,
            207636486,
            207674640,
            207643231,
            207672649,
            207672513,
            207643891,
            207672422,
            207672033,
            207644310,
            207746469,
            207746389,
            207650197,
            207645186,
            207822601,
            207822565,
            207645978,
            207642565,
            207658410,
            207638831
        ],
        "C": [
            207608017,
            207600613,
            207612008,
            207600441,
            207604832,
            207598385,
            207603497,
            207608198,
            207613818,
            207614226,
            207616264,
            207606682,
            207610887,
            234877458,
            207617296,
            207626821,
            207621747,
            207647815,
            207622607,
            207619463
        ],
        "B": [
            207599759,
            207593405,
            207597186,
            207596843,
            207596098,
            207591556,
            207609227,
            207602206,
            207592261,
            207601856,
            207592644,
            207601118,
            207592805,
            207603544,
            207613114,
            207602486,
            207597786,
            207598115,
            207609684
        ],
        "A": [
            207586682,
            207582994,
            207583697,
            207581917,
            207581457,
            207583108,
            207588869,
            207586429,
            207584682,
            207584850,
            207583599,
            207583185,
            207584377,
            207587215,
            207597686,
            207589557,
            207585837,
            207585764,
            207588046
        ],
        "E": [
            207715760,
            207661818,
            207884996,
            207884714,
            207713105,
            208057779
        ]
    },
    "name": "C. Hyperregular Bracket Strings",
    "statement": "You are given an integer n and k intervals. The i-th interval is\r\n[l_i,r_i] where 1\r\nleq l_i\r\nleq r_i\r\nleq n.Let us call a bracket sequence^{\r\ndagger,\r\nddagger} of length n if for each i such that 1\r\nleq i\r\nleq k, the substring\r\noverline{s_{l_i} s_{l_{i}+1}\r\nldots s_{r_i}} is also a regular bracket sequence.Your task is to count\r\nthe number of hyperregular bracket sequences. Since this number can be\r\nreally large, you are only required to find it modulo 998\r\n,244\r\n,353.^\r\ndagger A bracket sequence is a string containing only the characters \"\"\r\nand \"\".^\r\nddagger A bracket sequence is called regular if one can turn it into a\r\nvalid math expression by adding characters and . For example, sequences\r\n, , and the empty string are regular, while , , and are not.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\n#define rep1n(i, n) for (int i = 1; i <= (n); ++i)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define each(x, a) for (auto &x : a)\n#define ar array\n#define vec vector\n#define range(i, n) rep(i, n)\n\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\n\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nint Bit(int mask, int b) { return (mask >> b) & 1; }\n\ntemplate<class T>\nbool ckmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool ckmax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst int INFi = 1e9;\nconst ll INF = 3e18;\nconst int LG = 20;\n\n\nconst int md = 998244353; //1e9 + 7, 1e9 + 9\n\ninline int add(const int &a, const int &b) {\n    return a + b >= md ? a + b - md : a + b;\n}\n\ninline int sub(const int &a, const int &b) {\n    return a - b < 0 ? a - b + md : a - b;\n}\n\ninline int mul(const int &a, const int &b) {\n    return (1ll * a * b) % md;\n}\n\nint pw(int a, ll b) {\n    int res = 1;\n    for(; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n    return res;\n}\n\nint rev(int a) {\n    return pw(a, md - 2);\n}\n\nconst int maxN = 6e5 + 5;\nint fact[maxN];\nint rfact[maxN];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < maxN; ++i) fact[i] = mul(fact[i - 1], i);\n    rfact[maxN - 1] = rev(fact[maxN - 1]);\n    for (int i = maxN - 1; i >= 1; --i) {\n        rfact[i - 1] = mul(rfact[i], i);\n    }\n}\n\nint C(int n, int k) {\n    if (k < 0 || n < k) return 0;\n    return mul(fact[n], mul(rfact[k], rfact[n - k]));\n}\n\nint Catalan(int n) {\n    return sub(C(2 * n, n), C(2 * n, n - 1));\n}\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid solve() {\n    int n, k; cin >> n >> k;\n    vector<pair<ll, ll>> kek(n + 1);\n    rep(_, k) {\n        int l, r; cin >> l >> r;\n        l--;\n        pair<ll, ll> val;\n        val.first = rng();\n        val.second = rng();\n        kek[l].first ^= val.first;\n        kek[l].second ^= val.second;\n        kek[r].first ^= val.first;\n        kek[r].second ^= val.second;\n    }\n    rep(i, n) {\n        kek[i + 1].first ^= kek[i].first;\n        kek[i + 1].second ^= kek[i].second;\n    }\n    map<pair<ll, ll>, int> cnt;\n    rep(i, n) cnt[kek[i]]++;\n    int ans = 1;\n    for(auto &[x, y] : cnt) {\n        if (y % 2 == 1) {\n            ans = 0;\n            break;\n        }\n        ans = mul(ans, Catalan(y / 2));\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(12) << fixed;\n    int t = 1;\n    init();\n    cin >> t;\n    rep(i, t) {\n        solve();\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "greedy",
        "hashing",
        "math",
        "number theory",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Hyperregular Bracket Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/116527",
    "editorial": "Solution First and foremost, the number of regular bracket strings of\nlength is equal to .Secondly, for a bracket string , let: A bracket\nstring is a regular bracket string if both of the following statements\nare true: From now on weâll call a set of indices a group if must be an\nRBS.There are two main cases to consider, both of which can be proven\nwith the aforementioned conditions for a string to be an RBS: Case 1:\nIncluded intervalsLetâs consider two intervals and such that .The two\ngroups formed by these intervals are: Case 2: Partially overlapping\nintervalsLetâs consider two intervals and such that .The three groups\nformed by these two intervals are: By taking both of these cases into\naccount, we can conclude that all indices covered by the same subset of\nintervals are part of the same group.Finding the subset of intervals\nwhich cover a certain index can be implemented using difference arrays\nand xor hashing. How does xor hashing on difference arrays work?Each\ninterval will be assigned a random 64-bit value . The value of a subset\nof intervals is equal to .For each interval , , .The value of the subset\nof intervals which cover position is equal to .Time complexity: for\nprecomputing every , and per test case.\n",
    "hint": [
        "Hint 1 While not necessarily a hint, this problem cannot be solved without knowing that there are Regular Bracket Strings of length .",
        "Hint 2 What's the answer if ?",
        "Hint 3 What's the answer if and the two intervals partially overlap?",
        "Hint 4 Based on the previous hint, we can get rid of all partially overlapping intervals. The remaining intervals will have a tree-like structure.",
        "Hint 5 Finding the tree is actually unnecessary and also very difficult.",
        "Hint 6 The brackets on the positions covered by the same subset of intervals must form an RBS.",
        "Hint 7 Hashing. Xor hashing specifically."
    ]
}