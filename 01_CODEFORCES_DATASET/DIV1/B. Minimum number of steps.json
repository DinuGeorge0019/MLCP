{
    "link": "https://codeforces.com//contest/804/problem/B",
    "problemId": "105173",
    "problem_idx": "B",
    "shortId": "804B",
    "contest_number": "804",
    "problem_submissions": {
        "D": [
            26864569,
            26864084,
            26864065,
            26863844,
            26859532,
            26855737,
            26853547,
            26853205,
            26854566,
            26856630,
            26853214,
            26855855,
            26861591,
            26863648,
            26855151,
            26854613,
            26864015,
            26856289,
            26858468,
            26856391
        ],
        "C": [
            26847789,
            26844906,
            26857930,
            26847099,
            26856657,
            26848089,
            26857400,
            26856222,
            26845185,
            26848695,
            26846499,
            26847477,
            26843068,
            26846575,
            26859352,
            26846716,
            26860420,
            26846219,
            26852629
        ],
        "B": [
            26841209,
            26838692,
            26840551,
            26839159,
            26839206,
            26840437,
            26840273,
            26854727,
            26841332,
            26842906,
            26840147,
            26841623,
            26839518,
            26840190,
            26840304,
            26839516,
            26840017,
            26847973,
            26839966
        ],
        "A": [
            26838410,
            26837453,
            26837406,
            26837277,
            26841198,
            26837228,
            26837723,
            26837298,
            26837762,
            26837644,
            26837931,
            26837280,
            26837588,
            26838739,
            26837615,
            26837337,
            26846921,
            26837692
        ],
        "E": [
            26859757,
            26861113,
            26864419,
            26864227,
            26864109,
            26864035,
            26863863,
            26860566,
            26862404,
            26859605,
            26854745,
            26861397,
            26884422,
            26865231,
            26853306,
            26856744,
            26859172
        ]
    },
    "name": "B. Minimum number of steps",
    "statement": "We have a string of letters \u201d and \u201d. We want to perform some operations\r\non it. On each step we choose one of substrings \"\" in the string and\r\nreplace it with the string \"\". If we have no \"\" as a substring, our job\r\nis done. Print the minimum number of steps we should perform to make our\r\njob done modulo .The string \"\" appears as a substring if there is a\r\nletter \u201d right after the letter \u201d somewhere in the string.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n\n#include <assert.h>\n#include <type_traits>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n\n\n\ntemplate <typename T, typename = std::true_type>\nstruct IdentityHelper;\n\ntemplate <typename T>\nstruct IdentityHelper<T, typename std::is_arithmetic<T>::type> {\n\tstatic T identity() {\n\t\treturn 1;\n\t}\n};\n\ntemplate <typename T>\nT identity() {\n\treturn IdentityHelper<T>::identity();\n}\n\n\n\n/**\n* ax + by = result\n*/\ntemplate <typename T>\nT extendedGcd(T a, T b, T& x, T& y) {\n\tif (a == 0) {\n\t\tx = 0;\n\t\ty = 1;\n\t\treturn b;\n\t}\n\tT d = extendedGcd(b % a, a, y, x);\n\tx -= (b / a) * y;\n\treturn d;\n}\n\ntemplate <typename T>\nclass Zn {\npublic:\n\tZn(): value(0) {\n\t}\n\n\t/**\n\t* Instead of ctor, to allow not to normalize in ctor\n\t*/\n\tstatic Zn valueOf(int value) {\n\t\tint x = value % mod();\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn valueOf(long long value) {\n\t\tint x = static_cast<int>(value % mod());\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\tstatic Zn rawValueOf(int value) {\n\t\tSPCPPL_ASSERT(value >= 0 && value < mod());\n\t\treturn Zn(value);\n\t}\n\n\tZn& operator=(int rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator=(long long rhs) {\n\t\treturn *this = Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(const Zn& rhs) {\n\t\tvalue += rhs.value;\n\t\tif (value >= mod()) {\n\t\t\tvalue -= mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator+=(int rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator+=(long long rhs) {\n\t\treturn *this += Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(const Zn& rhs) {\n\t\tvalue -= rhs.value;\n\t\tif (value < 0) {\n\t\t\tvalue += mod();\n\t\t}\n\t\treturn *this;\n\t}\n\n\tZn& operator-=(int rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator-=(long long rhs) {\n\t\treturn *this -= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(const Zn& rhs) {\n\t\tlong long result = static_cast<long long>(value) * static_cast<long long>(rhs.value);\n\t\tvalue = static_cast<int>(result % mod());\n\t\treturn *this;\n\t}\n\n\tZn& operator*=(int rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator*=(long long rhs) {\n\t\treturn *this *= Zn::valueOf(rhs);\n\t}\n\n\tZn operator-() const {\n\t\tif (value == 0) {\n\t\t\treturn *this;\n\t\t}\n\t\telse {\n\t\t\treturn Zn(mod() - value);\n\t\t}\n\t}\n\n\tZn& operator/=(const Zn& rhs) {\n\t\treturn *this *= rhs.inversed();\n\t}\n\n\tZn& operator/=(int rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tZn& operator/=(long long rhs) {\n\t\treturn *this /= Zn::valueOf(rhs);\n\t}\n\n\tbool operator==(const Zn& rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tZn inversed() const {\n\t\tSPCPPL_ASSERT(value != 0);\n\n\t\tint x, y;\n\t\tint gcd = extendedGcd(value, mod(), x, y);\n\t\t(void) gcd;\n\t\tSPCPPL_ASSERT(gcd == 1);\n\n\t\tif (x < 0) {\n\t\t\tx += mod();\n\t\t}\n\t\treturn Zn(x);\n\t}\n\n\ttemplate <typename U>\n\tfriend std::ostream& operator<<(std::ostream&, const Zn<U>& zn);\n\n\ttemplate <typename U>\n\tfriend std::istream& operator>>(std::istream&, Zn<U>& zn);\n\n\tint intValue() const {\n\t\treturn value;\n\t}\n\nprivate:\n\t/**\n\t* No normalization performed\n\t*/\n\texplicit Zn(int value): value(value) {\n\t}\n\n\tint value;\n\n\tconstexpr static int mod() {\n\t\treturn T::value;\n\t}\n\n\ttemplate <int N = T::value>\n\tstatic constexpr bool positive_or_runtime(int) {\n\t\treturn N > 0;\n\t}\n\tstatic constexpr bool positive_or_runtime(...) {\n\t\treturn true;\n\t}\n\tstatic_assert(\n\t\t\tstd::is_same<typename std::decay<decltype(T::value)>::type, int>::value,\n\t\t\t\"T::value must be int\"\n\t);\n\tstatic_assert(positive_or_runtime(0), \"Mod has to be positive integer\");\n};\n\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, int rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(int lhs, const Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\ntemplate <typename T>\nbool operator==(const Zn<T>& lhs, long long rhs) {\n\treturn lhs == Zn<T>::valueOf(rhs);\n}\n\ntemplate <typename T>\nbool operator==(long long lhs, Zn<T>& rhs) {\n\treturn rhs == lhs;\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, int rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(int lhs, const Zn<T>& rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(const Zn<T>& lhs, long long rhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator!=(long long rhs, const Zn<T>& lhs) {\n\treturn !(lhs == rhs);\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(int lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy += rhs;\n}\n\ntemplate <typename T>\nZn<T> operator+(long long lhs, const Zn<T>& rhs) {\n\treturn rhs + lhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy -= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator-(long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) - rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(int lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy *= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator*(long long lhs, const Zn<T>& rhs) {\n\treturn rhs * lhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, const Zn<T>& rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, int rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(int lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(const Zn<T>& lhs, long long rhs) {\n\tZn<T> copy = lhs;\n\treturn copy /= rhs;\n}\n\ntemplate <typename T>\nZn<T> operator/(long long lhs, const Zn<T>& rhs) {\n\treturn Zn<T>::valueOf(lhs) / rhs;\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Zn<T>& zn) {\n\treturn stream << zn.value;\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Zn<T>& zn) {\n\tlong long value;\n\tstream >> value;\n\tzn.value = static_cast<int>(value % T::value);\n\treturn stream;\n}\n\ntemplate <typename T>\nstruct IdentityHelper<Zn<T>> {\n\tstatic Zn<T> identity() {\n\t\treturn Zn<T>::valueOf(1);\n\t}\n};\n\ntemplate <int m>\nusing ZnConst = Zn<std::integral_constant<int, m>>;\n\n\nusing namespace std;\n\nclass TaskB {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tstring s;\n\t\tin >> s;\n\t\tusing Z = ZnConst<1000000007>;\n\n\t\tZ pwr = Z::rawValueOf(1);\n\n\t\tZ ans;\n\t\tfor (char c: s) {\n\t\t\tif (c == 'a') {\n\t\t\t\tpwr *= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += pwr - 1;\n\t\t\t}\n\t\t}\n\n\t\tout << ans << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskB solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(0);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Minimum number of steps.json",
    "editorial_link": "https://codeforces.com/blog/entry/51846",
    "editorial": "If the answer is 2, other wise l.To prove this phrase, assume the answer\r\nis (), consider all of multiples of from to as . If , is also a correct\r\nanswer, otherwise numbers from to make at least even number, and for\r\neach multiple from to as , or is even, so 2 is also a correct\r\nanswer.Bounce: Find the maximum number, occurs maximum number of times\r\nin the segment.\r\n"
}