{
    "link": "https://codeforces.com//contest/196/problem/D",
    "problemId": "1427",
    "problem_idx": "D",
    "shortId": "196D",
    "contest_number": "196",
    "problem_submissions": {
        "C": [
            1798703,
            1791214,
            1788606,
            1793292,
            1791199,
            1789041,
            1791625,
            1799512,
            1791088,
            1791198,
            1791178,
            1796930,
            1790873,
            1791544
        ],
        "E": [
            1795709,
            1794289,
            1790345,
            1800573,
            1800569,
            1795140,
            1795262,
            1792160,
            1794470,
            1794856,
            1794312,
            1796014,
            1797704
        ],
        "D": [
            1795008,
            1796853,
            1794499,
            2860569,
            1792348,
            1798254
        ],
        "B": [
            1789001,
            1792087,
            1796669,
            1789699,
            1788889,
            1792321,
            1796356,
            1793004,
            1789434,
            1789111,
            1796367,
            1788833,
            1789314,
            1789678
        ],
        "A": [
            1787593,
            1787638,
            1787620,
            1788588,
            1787608,
            1788006,
            1789404,
            1787655,
            1787643,
            1794879,
            1787601,
            1787960,
            1787674,
            1788094,
            1787666,
            1787769
        ]
    },
    "name": "D. The Next Good String",
    "statement": "In problems on strings one often has to find a string with some\r\nparticular properties. The problem authors were reluctant to waste time\r\non thinking of a name for some string so they called it . A string is\r\ngood if it doesn\u2019t have palindrome substrings longer than or equal to .\r\nYou are given string , consisting only of lowercase English letters.\r\nFind a good string with length , consisting of lowercase English\r\nletters, which is lexicographically larger than . Of all such strings\r\nstring must be lexicographically minimum.We will call a non-empty string\r\na of string .A non-empty string is called if for all from to the\r\nfollowing fulfills: . In other words, palindrome read the same in both\r\ndirections.String is than string , if either and , or there exists such\r\nnumber , that and . Characters in such strings are compared like their\r\nASCII codes.\r\n",
    "solutions": [
        "#pragma comment(linker, \"/STACK:65777216\")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint d;\nstring s;\nll h1[555555];\nll r1[555555];\nll in[555555];\n\nconst int M1 = 31;\n\nconst ll MOD1 = 1000000007;\n\nll s1[555555];\n\nint START;\nbool addone(int pos){\n\twhile(pos>=0 && s[pos]=='z'){\n\t\ts[pos]='a';\n\t\tpos--;\n\t}\n\tif(pos<0) return 0;\n\ts[pos]++;\n\tSTART = pos;\n\treturn 1;\n}\n\nint getH(int pos,int len){\n\tll H1 = h1[pos];\n\tif(pos-len>=0) H1 -= h1[pos-len]*s1[len];\n\tH1 %= MOD1;\n\tif(H1<0) H1+=MOD1;\n\treturn H1;\n}\nll qp(ll c,ll st){\n\tll r = 1;\n\twhile(st){\n\t\tif(st&1) r*=c,r%=MOD1;\n\t\tc*=c,c%=MOD1;\n\t\tst>>=1;\n\t}\n\treturn r;\n}\nint getHr(int pos,int len){\n\tll H1 = r1[pos];\n\tif(pos-len>=0) H1 -= r1[pos-len];\n\tH1 %= MOD1;\n\tif(H1<0) H1 += MOD1;\n\tif(in[pos-len+1]==-1)\n\t\tin[pos-len+1]=qp(s1[pos-len+1],MOD1-2);\n\tH1 *= in[pos-len+1];\n\tH1 %= MOD1;\n\treturn H1;\n}\n\nbool ispal(int p1,int p2,int len){\n\treturn getHr(p1,len)==getH(p2,len);\n}\n\nbool ispal(int pos,int len){\n\t//cout<<\"ISP \"<<pos<<' '<<len<<endl;\n\tif(len%2){\n\t\treturn ispal(pos,pos-len/2-1,len/2);\n\t}else{\n\t\treturn ispal(pos,pos-len/2,len/2);\n\t}\n}\nbool ispal(int pos){\n\n\tif(pos+1>=d && ispal(pos,d)) return 1;\n\tif(pos+1>=d+1 && ispal(pos,d+1)) return 1;\n\treturn 0;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n#endif\n\ts1[0]=1;\n\tCL(in,-1);\n\tFOR(i,1,400001) s1[i]=s1[i-1]*M1,s1[i]%=MOD1;\n\t\n\tcin>>d>>s;\n\tif(d==1 || !addone(s.size()-1)){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\n\t//s=\"\";\n\t//REP(i,400000) s.pb(char('a'+rand()%26));\n\tint clFrom = s.size();\n\tfor(int i=0;i<s.size();i++){\n\t\tif(i>=clFrom) s[i]='a';\n\t\th1[i]=(i?h1[i-1]:0)*M1 + s[i]-'a'+1;h1[i]%=MOD1;\n\t\tr1[i]=(i?r1[i-1]:0) + (s[i]-'a'+1)*s1[i]; r1[i]%=MOD1;\n\t\tif(ispal(i)){\n\t\t\tif(!addone(i)){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclFrom = START+1;\n\t\t\ti = START-1;\n\t\t}\n\t}\n\tcout<<s<<endl;\n\n//\tcout<<r1[0]<<' '<<r1[1]<<endl;\n#ifdef LocalHost\n\tcerr<<endl<<endl<<\"TIME: \"<<clock()<<endl;\n#endif\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "hashing",
        "strings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. The Next Good String.json",
    "editorial_link": "https://codeforces.com//blog/entry/4717",
    "editorial": "Notice, that only palindromes with length and matter. Any palindrome\r\nwith greater length contains one of them. Let\u00e2\u0080\u0099s call these palindromes\r\nbad. First, find leftmost position , in which we surely should increase\r\nvalue of symbol. If there are no bad subpalindromes, , else is leftmost\r\nposition amongst all ends of bad palindromes. Increase . Increase it\r\nmore, while is end of bad subpalindrome. If you try increase \u00e2\u0080\u0099z\u00e2\u0080\u0099 symbol,\r\nyou should proceed to increasing previous symbol. If this way you\r\nreached situation when you need to increase first symbol, and it is \u00e2\u0080\u0099z\u00e2\u0080\u0099,\r\nanswer is \"Impossible\". Now, let pos be position of leftmost changed\r\nsymbol. We know, that prefix doesn\u00e2\u0080\u0099t contain bad palindromes. Now we can\r\ngreedily fill suffix : go over positions in ascending order, assign =\r\n\u00e2\u0080\u0099a\u00e2\u0080\u0099, and increase it, while is end of bad palindrome. Obviously, any of\r\nsuffix symbols will be \u00e2\u0080\u0099a\u00e2\u0080\u0099, \u00e2\u0080\u0099b\u00e2\u0080\u0099 or \u00e2\u0080\u0099c\u00e2\u0080\u0099. So we got algorithm, which\r\nrequires fast implementation of next operations assigning single symbol,\r\nand query: is given substring palindrome? You can perform this\r\noperations using hashes and Fenwick tree. Let\u00e2\u0080\u0099s learn, how to get hash\r\nof substring in dynamically changing string. If we can it, we will keep\r\nstring and it\u00e2\u0080\u0099s reversed copy. For query of second type we just need to\r\ncompare hashes of substring in and hash of corresponding substring in\r\nreversed copy. Let Fenwick tree store values , where is the prime number\r\nused for hashing. Then hash of substring equals to . For assigning , add\r\nvalue to . Both these operations Fenwick tree does in . Also we have\r\nfaster solution without hashes and data structures, it will be published\r\nsoon.\r\n"
}