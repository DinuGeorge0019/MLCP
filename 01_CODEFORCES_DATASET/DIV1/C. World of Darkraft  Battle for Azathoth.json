{
    "link": "https://codeforces.com//contest/1320/problem/C",
    "problemId": "551756",
    "problem_idx": "C",
    "shortId": "1320C",
    "contest_number": "1320",
    "problem_submissions": {
        "F": [
            72202332,
            72223011,
            72205107,
            72198337,
            72222998,
            72196293,
            72223902
        ],
        "E": [
            72193224,
            72190175,
            72191679,
            72192473,
            72195171,
            89517976,
            72207354,
            72207256,
            72196434,
            72194256,
            72192283,
            72199164,
            72195289,
            72197732,
            72223673,
            72193338,
            72195901,
            72200544,
            72200353,
            72200814,
            72198992,
            72200456
        ],
        "C": [
            72184867,
            72177670,
            72177948,
            72173628,
            72175737,
            72172966,
            72176352,
            72179230,
            72175568,
            72177066,
            72173843,
            72175840,
            72176052,
            72179445,
            72190361,
            72188981,
            72179839,
            72183510,
            72186001,
            72181401
        ],
        "B": [
            72179476,
            72169823,
            72171581,
            72177394,
            72169041,
            72168596,
            72168669,
            72172513,
            72171074,
            72169530,
            72169385,
            72171115,
            72178856,
            72172293,
            72186108,
            72169156,
            72173456,
            72185954,
            72172093,
            72178248
        ],
        "D": [
            72176425,
            72181800,
            72183448,
            72260282,
            72184393,
            72182092,
            72185033,
            72188594,
            72279361,
            72184633,
            72186338,
            72185288,
            72188013,
            72184398,
            72189053,
            72517140,
            72199444,
            72180732,
            72186150,
            72193094,
            72172140,
            72191769,
            72190479
        ],
        "A": [
            72166896,
            72166972,
            72167131,
            72166858,
            72166891,
            72166853,
            72166967,
            72167271,
            72166947,
            72166915,
            72167040,
            72167216,
            72167056,
            72167066,
            72166886,
            72170109,
            72167510,
            72181754,
            72167043,
            72167049
        ]
    },
    "name": "C. World of Darkraft  Battle for Azathoth",
    "statement": "Roma is playing a new expansion for his favorite game World of Darkraft.\r\nHe made a new character and is going for his first grind.Roma has a\r\nchoice to buy of n different weapons and of m different armor sets.\r\nWeapon i has attack modifier a_i and is worth ca_i coins, and armor set\r\nj has defense modifier b_j and is worth cb_j coins.After choosing his\r\nequipment Roma can proceed to defeat some monsters. There are p monsters\r\nhe can try to defeat. Monster k has defense x_k, attack y_k and\r\npossesses z_k coins. Roma can defeat a monster if his weapon’s attack\r\nmodifier is larger than the monster’s defense, and his armor set’s\r\ndefense modifier is larger than the monster’s attack. That is, a monster\r\nk can be defeated with a weapon i and an armor set j if a_i > x_k and\r\nb_j > y_k. After defeating the monster, Roma takes all the coins from\r\nthem. During the grind, Roma can defeat as many monsters as he likes.\r\nMonsters do not respawn, thus each monster can be defeated at most\r\none.Thanks to Roma’s excessive donations, we can assume that he has an\r\ninfinite amount of in-game currency and can afford any of the weapons\r\nand armor sets. Still, he wants to maximize the profit of the grind. The\r\nprofit is defined as the total coins obtained from all defeated monsters\r\nminus the cost of his equipment. Note that Roma purchase a weapon and an\r\narmor set even if he can not cover their cost with obtained coins.Help\r\nRoma find the maximum profit of the grind.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll inf = 2e12;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi;\n\tll mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vector<ll>& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tll query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, ll x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, ll x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nconst int MAXN = 1.1e6;\nvector<pair<int,ll> > monsters[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tvector<ll> wcost(MAXN, -inf);\n\n\tvector<ll> bcost(MAXN, -inf);\n\tint n, m, p;\n\tcin >> n >> m >> p;\n\tfor(int i = 0; i < n; i++){\n\t\tint a;\n\t\tll c;\n\t\tcin >> a >> c;\n\t\ta--;\n\t\twcost[a] = max(wcost[a], -c);\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tint b;\n\t\tll c;\n\t\tcin >> b >> c;\n\t\tb--;\n\t\tbcost[b] = max(bcost[b], -c);\n\t}\n\tNode segtree(wcost, 0, MAXN);\n\tfor(int i = 0; i < p; i++){\n\t\tint x, y;\n\t\tll z;\n\t\tcin >> x >> y >> z;\n\t\tmonsters[y].push_back({x, z});\n\t}\n\tll best = -inf;\n\tfor(int i = 0; i < MAXN; i++){\n\t\tfor(pair<int,ll> a : monsters[i]){\n\t\t\tsegtree.add(a.first, MAXN, a.second);\n\t\t}\n\t\tll cost = segtree.query(0, MAXN);\n\t\tcost += ll(bcost[i]);\n\t\tbest = max(best, cost);\n\t}\n\tcout << best << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. World of Darkraft  Battle for Azathoth.json",
    "editorial_link": "https://codeforces.com//blog/entry/74431",
    "editorial": "Let be the set of monsters which may be defeated with a weapon having\r\nattack . Then the profit we get, if we use weapon with attack and armor\r\nwith defense , is . We will iterate on weapons in non-descending order\r\nof their attack values and maintain . For each armor option, maintain\r\nthe value of . If armor sets are sorted by their defense value, adding a\r\nnew monster into adds some value on the suffix of . So we can maintain\r\nthe values of in a segment tree.So the solution is: Build a segment tree\r\non values of , where all armors are sorted by . Iterate on weapons and\r\nmonsters in sorted order (sort by / in non-descending order). For each\r\nnew weapon we should add all monsters which were not added yet (we can\r\nmaintain a pointer on the last added monster to find them quickly).\r\nAdding a monster means adding on suffix of . After that, for the current\r\nweapon we may try as the answer.\r\n",
    "hint": []
}