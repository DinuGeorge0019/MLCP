{
    "link": "https://codeforces.com//contest/860/problem/C",
    "problemId": "122866",
    "problem_idx": "C",
    "shortId": "860C",
    "contest_number": "860",
    "problem_submissions": {
        "E": [
            30442338,
            30439610,
            30443019,
            30443046,
            30440508,
            30432483,
            30439294,
            30445411,
            30436063,
            30437142,
            30437221,
            30481068,
            30480696,
            30454225,
            30453851,
            30453830,
            30453714,
            30453688,
            30451950,
            30438289,
            30430653,
            30450525
        ],
        "C": [
            30436281,
            30442840,
            30434064,
            30433549,
            30444395,
            30448672,
            30433775,
            30432045,
            30440377,
            30451948,
            30455922,
            30438248,
            30440061,
            30440352,
            30434684,
            30440440,
            30440439,
            30441823
        ],
        "D": [
            30433124,
            30431343,
            30438212,
            30436898,
            30431927,
            30428404,
            30445018,
            30435042,
            30427155,
            30430494,
            30439252,
            30433856,
            31966531,
            30430878,
            30431992,
            30442376,
            30442582,
            30437824,
            30433265,
            30433563,
            30431407
        ],
        "B": [
            30425955,
            30423718,
            30424479,
            30425464,
            30424782,
            30426033,
            30423375,
            30424915,
            30427560,
            30426303,
            30423664,
            30424888,
            30426149,
            30428815,
            30436103,
            30426185,
            30427070,
            30426587,
            30424713
        ],
        "A": [
            30423599,
            30422216,
            30422379,
            30422507,
            30422342,
            30423247,
            30422321,
            30422663,
            30422437,
            30424719,
            30423379,
            30422275,
            30422538,
            30422660,
            30423270,
            30433600,
            30422460,
            30423290,
            30423757,
            30422708
        ]
    },
    "name": "C. Tests Renumeration",
    "statement": "The All-Berland National Olympiad in Informatics has just ended! Now\r\nVladimir wants to upload the contest from the Olympiad as a gym to a\r\npopular Codehorses website.Unfortunately, the archive with Olympiad’s\r\ndata is a mess. For example, the files with tests are named arbitrary\r\nwithout any logic.Vladimir wants to rename the files with tests so that\r\ntheir names are distinct integers starting from without any gaps,\r\nnamely, \"\", \"\", ..., \"’, where is the total number of tests.Some of the\r\nfiles contain tests from statements (examples), while others contain\r\nregular tests. It is possible that there are no examples, and it is\r\npossible that all tests are examples. Vladimir wants to rename the files\r\nso that the examples are the first several tests, all all the next files\r\ncontain regular tests only.The only operation Vladimir can perform is\r\nthe \"\" command. Vladimir wants to write a script file, each of the lines\r\nin which is \"\", that means that the file \"\" is to be renamed to \"\". If\r\nthere is a file \"\" at the moment of this line being run, then this file\r\nis to be rewritten. After the line \"\" the file \"\" doesn’t exist, but\r\nthere is a file \"\" with content equal to the content of \"\" before the \"\"\r\ncommand.Help Vladimir to write the script file with the minimum possible\r\nnumber of lines so that after this script is run: all examples are the\r\nfirst several tests having filenames \"\", \"\", ..., \"\", where is the total\r\nnumber of examples; all other files contain regular tests with filenames\r\n\"\", \"\", ..., \"\", where is the total number of all tests.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring F[101010];\nint T[101010];\nint E;\n\nset<string> A,B;\nset<string> AB,BA,FA,FB;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>F[i]>>T[i];\n\t\tif(T[i]==1) E++;\n\t}\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tstring s=to_string(i);\n\t\tif(i<=E) A.insert(s);\n\t\telse B.insert(s);\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(A.count(F[i])) {\n\t\t\tA.erase(F[i]);\n\t\t\tif(T[i]==0) AB.insert(F[i]);\n\t\t}\n\t\telse if(B.count(F[i])) {\n\t\t\tB.erase(F[i]);\n\t\t\tif(T[i]==1) BA.insert(F[i]);\n\t\t}\n\t\telse {\n\t\t\tif(T[i]==0) FB.insert(F[i]);\n\t\t\telse FA.insert(F[i]);\n\t\t}\n\t}\n\t\n\tvector<pair<string,string>> R;\n\twhile(A.size() || B.size() || AB.size() || BA.size()) {\n\t\tif(A.size() && BA.size()) {\n\t\t\tR.push_back({*BA.begin(),*A.begin()});\n\t\t\tA.erase(A.begin());\n\t\t\tB.insert(*BA.begin());\n\t\t\tBA.erase(BA.begin());\n\t\t\tcontinue;\n\t\t}\n\t\tif(B.size() && AB.size()) {\n\t\t\tR.push_back({*AB.begin(),*B.begin()});\n\t\t\tB.erase(B.begin());\n\t\t\tA.insert(*AB.begin());\n\t\t\tAB.erase(AB.begin());\n\t\t\tcontinue;\n\t\t}\n\t\tif(A.size() && FA.size()) {\n\t\t\tR.push_back({*FA.begin(),*A.begin()});\n\t\t\tA.erase(A.begin());\n\t\t\tFA.erase(FA.begin());\n\t\t\tcontinue;\n\t\t}\n\t\tif(B.size() && FB.size()) {\n\t\t\tR.push_back({*FB.begin(),*B.begin()});\n\t\t\tB.erase(B.begin());\n\t\t\tFB.erase(FB.begin());\n\t\t\tcontinue;\n\t\t}\n\t\tassert(AB.size()==BA.size() && AB.size());\n\t\tA.insert(*AB.begin());\n\t\tR.push_back({*AB.begin(),\"zzzzz\"});\n\t\tAB.erase(AB.begin());\n\t\tFB.insert(\"zzzzz\");\n\t}\n\t\n\tcout<<R.size()<<endl;\n\tFORR(r,R) cout<<\"move \"<<r.first<<\" \"<<r.second<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Tests Renumeration.json",
    "editorial_link": "https://codeforces.com//blog/entry/54604",
    "editorial": "Firstly we will get rid of all tests that are already named correctly. After this, let's call samples \"tests of 1 type\", and system tests \"tests of 2 type\".\n\nLet's denote \"free positions\" such indices  such that there is currently no test with the name i. If there are no any free positions, then we can't rename each test using only one operation move because firstly we have to make its index a free position.\n\nLet's show that one free position is always enough. If there is one, then let's put some test of the corresponding type which has wrong name (a name that doesn't coincide with its type) into this position. It is clear that there will be at least one such test  otherwise all tests of corresponding type are at their positions, and there is no free position of this type. Then there are two cases  either we free a correct position (then we will have another free position) or we move a test which had illegal name (so we don't create any free positions).\n\nIt's better to move a test which occupies some position so we will have a new free position after it. It is clear that when there are no tests such that their names are correct numbers, but they are in position of different type, then we can't keep the quantity of free positions as it is, and after moving any test this quantity will decrease.\n\nThis approach is optimal because we will have to perform either cnt (cnt is the number of tests that aren't correctly named initially) or cnt?+?1 operations. cnt?+?1 will be the answer only if we have to make an operation that will create a free position (if there are no free positions initially).\n\nThis number of operations is optimal because if we have cnt incorrectly named tests, then we can't rename them in less than cnt operations; and this is possible only if we have at least one free position initially; otherwise we have to free some position.",
    "hint": []
}