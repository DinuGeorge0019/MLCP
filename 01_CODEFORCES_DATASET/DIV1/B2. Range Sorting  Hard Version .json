{
    "link": "https://codeforces.com//contest/1827/problem/B2",
    "problemId": "1922411",
    "problem_idx": "B2",
    "shortId": "1827B2",
    "contest_number": "1827",
    "problem_submissions": {
        "B1": [
            205909125,
            205871229,
            205860094,
            205853484,
            205858214,
            205884799,
            205855785,
            205857268,
            205859721,
            205854125,
            205853990,
            205854393,
            205857685,
            205856108,
            205871852,
            205864517,
            205849753,
            205856355,
            206036248,
            205883111,
            205857458,
            205852308
        ],
        "C": [
            205887704,
            205865086,
            205862189,
            205877784,
            205865401,
            205880693,
            205873972,
            205883370,
            205896807,
            205874900,
            205883582,
            205869590,
            205872529,
            205865317,
            205875560,
            205870203,
            205870915,
            206036332,
            205857923,
            205878002,
            205869836
        ],
        "E": [
            205882857,
            205890682,
            205893722,
            205893207,
            205891321,
            205895989,
            205901490,
            205897572,
            205894529,
            205889627,
            205900528,
            205921803,
            205921497,
            205921364,
            205921183,
            205920554,
            205920187,
            205928602,
            205907318,
            205907019,
            205906136,
            205905793,
            205905368,
            205905221,
            205903986
        ],
        "B2": [
            205871376,
            205860123,
            205854465,
            205857731,
            205884857,
            205854446,
            205857708,
            205859949,
            205855049,
            205892922,
            205864074,
            205856597,
            205855367,
            205871926,
            205864651,
            205863717,
            205856284,
            206036255,
            205889062,
            205869038,
            205876542
        ],
        "D": [
            205863885,
            205875931,
            205878262,
            205884073,
            205878863,
            205877520,
            205881913,
            205884050,
            205871773,
            205899731,
            205892557,
            205885814,
            205881313,
            205883473,
            205884864,
            205888365,
            205888201,
            206036361,
            205877449,
            205886393,
            205963414,
            205889611
        ],
        "A": [
            205845172,
            205844037,
            205843466,
            205843847,
            205844462,
            205843511,
            205844799,
            205845695,
            205844273,
            205843867,
            205845548,
            205843654,
            205843208,
            205846139,
            205845358,
            205843530,
            206036234,
            205846931,
            205848794,
            205843958
        ],
        "F": [
            207299235,
            207299224,
            207299166,
            207299023,
            207298779,
            207298502,
            207298128
        ]
    },
    "name": "B2. Range Sorting  Hard Version ",
    "statement": "You are given an array a, consisting of n distinct integers a_1, a_2,\r\nldots, a_n. Define the of an array p_1, p_2,\r\nldots p_k as the minimum amount of time needed to sort this array using\r\nan arbitrary number of operations. In each range-sort operation, you\r\nwill do the following: Choose two integers l and r (1\r\nle l < r\r\nle k). Sort the subarray p_l, p_{l + 1},\r\nldots, p_r in r - l seconds. Please calculate the sum of beauty over all\r\nsubarrays of array a.A subarray of an array is defined as a sequence of\r\nconsecutive elements of the array.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor(int& x : A) cin >> x;\n\n\tvector<int> aord(N);\n\tfor(int i = 0; i < N; i++) aord[i] = i;\n\tsort(aord.begin(), aord.end(), [&](int x, int y) { return A[x] < A[y]; });\n\tll ans = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tans += ll(i) * ll(N - i);\n\t}\n\tset<int> loc0, loc1;\n\tfor(int i = 0; i < N; i++) loc1.insert(i);\n\tloc0.insert(-1); loc0.insert(N);\n\tloc1.insert(-1); loc1.insert(N);\n\tfor(int x : aord){\n\t\tloc0.insert(x);\n\t\tloc1.erase(x);\n\t\tauto f = loc1.lower_bound(x);\n\t\tint c0 = x - *prev(f);\n\t\tint l1 = *f;\n\n\t\tint c1 = 0;\n\t\tif(l1 < N){\n\t\t\tc1 = *loc0.lower_bound(l1) - l1;\n\t\t}\n\t\tans -= ll(c0) * ll(c1);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B2. Range Sorting  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116109",
    "editorial": "Solution Let denotes the subarray .Observation 1: In an optimal sequence\nof operations for one subarray, there will be no two operations that\nintersect each other. In other words, a subarray will be divided into\nnon-overlapping subarrays, and we will apply a range-sort operation to\neach subarray.Proof: Suppose there are two operations and that intersect\neach other, we can replace them with one operation which does not\nincrease the cost.Observation 2: Consider positions , then we can sort\nsubarrays independently iff for all .Proof: The obvious necessary and\nsufficient condition required to sort subarrays independently is for all\n, here we denote and . It is not hard to prove that this condition is\nequal to the one stated above.With these observations, we can conclude\nthat the answer for a subarray equals the minus the number of positions\nsuch that and . Let us analyze how to calculate the sum of this value\nover all possible and .Consider a position (), letâs count how many\ntriplets satisfy and . It means that must be the closest position to the\nleft of satisfying . Denotes as the closest position to the left of such\nthat , and as the closest position to the right of such that . We can\nsee that a triplet with and will match our condition. In other words, we\nwill add to the answer .In the easy version, we can find such values of\nfor each in and end up with a total complexity of . We can further\noptimize the algorithm by using sparse table and binary lifting and\nachieve a time complexity of , which is enough to solve the hard\nversion.There is an solution described here.\n",
    "hint": [
        "Hint 1 What is the minimum cost to sort just one subarray?",
        "Hint 2 What happens when two operations intersect each other?",
        "Hint 3 When can we sort two adjacency ranges independently?",
        "Hint 4 Try to calculate the contribution of each position."
    ]
}