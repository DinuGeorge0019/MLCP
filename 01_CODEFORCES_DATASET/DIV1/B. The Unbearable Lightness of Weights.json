{
    "link": "https://codeforces.com//contest/1078/problem/B",
    "problemId": "257667",
    "problem_idx": "B",
    "shortId": "1078B",
    "contest_number": "1078",
    "problem_submissions": {
        "D": [
            45940862,
            45933303,
            45935766,
            45933853,
            45930995,
            45936488,
            45940747,
            45943827,
            45939112,
            45949887,
            45939231,
            45940966,
            45940947,
            45958692,
            45958625,
            45928396,
            45942294,
            45942258,
            45942248,
            45942159,
            45942142,
            45942044,
            45941921,
            45940689
        ],
        "E": [
            45937493,
            45942033,
            45960731,
            45946630
        ],
        "B": [
            45928126,
            45925305,
            45926274,
            45926072,
            45923067,
            45926568,
            45940774,
            45920994,
            45922995,
            45940934,
            45949871,
            45927955,
            45922044,
            45923855,
            45923008,
            45958814,
            45932880,
            45923428,
            45938791,
            45941333,
            45925850,
            45924600,
            45924279
        ],
        "C": [
            45926441,
            45929882,
            45930167,
            45929211,
            45934188,
            45931921,
            45926885,
            45928260,
            45930909,
            45932518,
            45925565,
            45924426,
            45931751,
            45929018,
            45958808,
            45923916,
            45927809,
            45932834,
            45932060,
            45934408
        ],
        "A": [
            45921892,
            45921151,
            45920874,
            45923123,
            45920460,
            45920490,
            45920725,
            45923466,
            45934579,
            45920717,
            45924554,
            45958821,
            45927000,
            45931917,
            45930488,
            45922107,
            45922245,
            45921493
        ]
    },
    "name": "B. The Unbearable Lightness of Weights",
    "statement": "You have a set of n weights. You know that their masses are a_1, a_2,\r\n..., a_n grams, but you don’t know which of them has which mass. You\r\ncan’t distinguish the weights.However, your friend does know the mass of\r\neach weight. You can ask your friend to give you exactly k weights with\r\nthe total mass m (both parameters k and m are chosen by you), and your\r\nfriend will point to any valid subset of weights, if it is possible.You\r\nare allowed to make this query only once. Find the maximum possible\r\nnumber of weights you can reveal after this query.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst LL MOD = 1001000027;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<int> freq(101, 0);\n\tvector<vector<LL> > knap(101, vector<LL>(11000, 0));\n\tknap[0][0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\tfreq[a[i]]++;\n\t\tvector<vector<LL> > s(101, vector<LL>(11000, 0));\n\t\tfor(int b = 0; b <= 100; b++){\n\t\t\tfor(int f = 0; f <= 10000; f++){\n\t\t\t\tif(knap[b][f] == 0) continue;\n\t\t\t\ts[b][f] += knap[b][f];\n\t\t\t\ts[b][f] %= MOD;\n\t\t\t\ts[b+1][f+a[i]] += knap[b][f];\n\t\t\t\ts[b+1][f+a[i]] %= MOD;\n\t\t\t}\n\t\t}\n\t\tknap = s;\n\t}\n\tLL ncr[110][110];\n\tfor(LL n = 0; n <= 100; n++){\n\t\tfor(LL k = 0; k <= 100; k++){\n\t\t\tif(k > n){\n\t\t\t\tncr[n][k] = 0;\n\t\t\t} else if(k == 0 || k == n){\n\t\t\t\tncr[n][k] = 1;\n\t\t\t} else {\n\t\t\t\tncr[n][k] = (ncr[n-1][k] + ncr[n-1][k-1]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tint best = 0;\n\tint types = 0;\n\tfor(int d = 1; d <= 100; d++){\n\t\tif(freq[d] > 0) types++;\n\t}\n\tfor(int d = 1; d <= 100; d++){\n\t\tfor(int num = 1; num <= freq[d]; num++){\n\t\t\tif(knap[num][d*num] == ncr[freq[d]][num]){\n\t\t\t\tbest = max(best, num);\n\t\t\t\tif(num == freq[d] && types <= 2){\n\t\t\t\t\tbest = n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << best << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. The Unbearable Lightness of Weights.json",
    "editorial_link": "https://codeforces.com//blog/entry/63324",
    "editorial": "Suppose the numbers a1,a2,,an\n can have only up to two different values. Then we can unambiguously determine the masses of all the weights (e.g., suppose there are t\n weights with a mass of w\n each, then we can ask our friend about a set of t\n weights with a total mass of t?w\n; the only thing he can do is to return all the weights with the mass w\n, so we can reveal the masses of all the weights).\n\nIf the masses of the weights have at least three different values then the only thing we can do is to determine several weights of the same mass (because if the friend tells us a set having distinct masses, we cannot distinguish them from one another; the same holds for the set of remaining weights). So we need to ask our friend such values (k,m)\n that the only way to obtain the mass m\n using k\n weights is to take k\n weights of mass mk\n each.\n\nSo now we have reduced our problem to finding for every w??i=1nai\n and every number of weights k?n\n the number of ways (regardless of the order of the weights) to obtain a mass of w\n using precisely k\n weights. This value cnt(w,k)\n can be computed via a simple dynamic programming.\n\nFinally, the answer will be equal to the maximum such k\n that for some b\n there exist at least k\n weights with mass b\n each and the mass k?b\n can be obtained uniquely.\n\nOne should note that it's sufficient to calculate, say, min(2,cnt(w,k))\n instead of cnt(w,k)\n since the latter can be quite large.",
    "hint": []
}