{
    "link": "https://codeforces.com//contest/348/problem/C",
    "problemId": "3553",
    "problem_idx": "C",
    "shortId": "348C",
    "contest_number": "348",
    "problem_submissions": {
        "C": [
            4588342,
            4590159,
            4593135,
            4588912,
            4585853,
            4589632,
            4585524,
            4586580,
            4585883,
            4581239,
            4588365,
            4618235
        ],
        "B": [
            4580097,
            4582356,
            4579942,
            4582963,
            4589468,
            4587659,
            4577354,
            4585315,
            4580326,
            4582274,
            4579794,
            4606814,
            4580277,
            4584510,
            4582530,
            4581233,
            4588037,
            4582260,
            4589608
        ],
        "A": [
            4576873,
            4574641,
            4574230,
            4576431,
            4576985,
            4585961,
            4574860,
            4576105,
            4577005,
            4576961,
            4574398,
            4574642,
            4577358,
            4575644,
            4582569,
            4583556,
            4575731,
            4575526
        ],
        "D": [
            4576020,
            4578123,
            4580839,
            4584931,
            4582728,
            4580253,
            4592562,
            4587185,
            4588035,
            4587652,
            4587737,
            4590796,
            4582015
        ],
        "E": [
            4583454,
            4855776,
            4616595,
            4820950,
            4618329
        ]
    },
    "name": "C. Subset Sums",
    "statement": "You are given an array and sets of indices of elements of this array.\r\nLet\u2019s denote . In other words, is some element from set .In this problem\r\nyou have to answer queries of the two types: Find the sum of elements\r\nwith indices from set : . The query format is \"\". Add number to all\r\nelements at indices from set : is replaced by for all . The query format\r\nis \"\". After each first type query print the required sum.\r\n",
    "solutions": [
        "#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define pb push_back\n#define mp make_pair\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nconst int64 mod = 2184057LL;\n\nconst int maxn = 105 * 1000;\n\nconst int BUBEN = 350;\n\nvi g[maxn];\nbool bad[maxn];\nbitset<maxn>* b[maxn];\n\nint main() {\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int64> a(n);\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    a[i] = x;\n  }\n  vi baddies;\n  vector<int64> bb(n, 0);\n  vector<int64> bbb(n, 0);\n  vector<int64> ss(n, 0);\n  for (int i = 0; i < m; ++i) {\n    int cnt;\n    scanf(\"%d\", &cnt);\n    ss[i] = cnt;\n    if (cnt >= BUBEN) {\n      bad[i] = true;\n      baddies.pb(i);\n      b[i] = new bitset<maxn>();\n      for (int j = 0; j < cnt; ++j) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        (*(b[i]))[x] = true;\n        bbb[i] += a[x];\n      }\n    } else {\n      bad[i] = false;\n      for (int j = 0; j < cnt; ++j) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        g[i].pb(x);\n      }\n    }\n  }\n  int** d = new int*[m];\n  for (int i = 0; i < m; ++i) {\n    d[i] = new int[baddies.size()];\n    for (int j = 0; j < baddies.size(); ++j)\n      d[i][j] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (bad[i]) {\n      for (int j = 0; j < baddies.size(); ++j)\n        d[i][j] = ((*(b[i])) & (*(b[baddies[j]]))).count();\n    } else {\n      for (int j = 0; j < sz(g[i]); ++j) {\n        int x = g[i][j];\n        for (int t = 0; t < baddies.size(); ++t)\n          if (b[baddies[t]]->operator[](x)) {\n            d[i][t] += 1;\n          }\n      }\n    }\n  }\n\n  for (int i =0 ; i < q; ++i) {\n    char c[5];\n    scanf(\"%s\", c);\n    if (c[0] == '?') {\n      int k;\n      scanf(\"%d\", &k);\n      --k;\n      int64 res = 0;\n      if (!bad[k]) {\n        for (int j = 0; j < sz(g[k]); ++j)\n          res += a[g[k][j]];\n        for (int j = 0; j < sz(baddies); ++j)\n          res += bb[baddies[j]] * (int64)(d[k][j]);\n      } else {\n        res = bbb[k];\n      }\n      printf(\"%I64d\\n\", res);\n    } else {\n      int k, x;\n      scanf(\"%d%d\", &k, &x);\n      --k;\n      if (!bad[k]) {\n        for (int j = 0; j < sz(g[k]); ++j)\n          a[g[k][j]] += x;\n      } else {\n        bb[k] += x;\n      }\n      for (int j = 0; j < sz(baddies); ++j)\n         bbb[baddies[j]] += x * (int64)(d[k][j]);\n    }\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Subset Sums.json",
    "editorial_link": "https://codeforces.com//blog/entry/9031",
    "editorial": "This problem is about data structures. First step of the solution is to\r\ndivide sets to heavy and light. Light ones are those that contains less\r\nthan elements. All other sets are heavy. Key observation is that every\r\nlight set contains less than elements and number of heavy sets doesn\u00e2\u0080\u0099t\r\nexceed because we have upper bound for sum of the sizes of all sets. In\r\norder to effectively answer queries, for every set (both light and\r\nheavy) we calculate size of the intersection of this set and each heavy\r\nset. It can be done with time and memory . For every heavy set we create\r\nboolean array of size . In -th cell of this array we store how many\r\nelements in given set. Then for each element and each heavy set we can\r\ncheck for time whether element is in the set. Now let\u00e2\u0080\u0099s consider 4\r\npossible cases: Add to the light set. Traverse all numbers in the set\r\nand add the value from the query to each of them. Then traverse all\r\nheavy sets and add (size of intersection * the value from the query).\r\nTime is . Add to the heavy set. Just update the counter for the heavy\r\nset. Time is . Answer to the query for the light set. Traverse all\r\nnumbers in the set and add values to the answer. Then traverse all heavy\r\nsets and add to the answer (answer for this heavy set * size of\r\nintersection with the set in the query). Time is . Answer to the query\r\nfor the heavy set. Take already calculated answer, then traverse all\r\nheavy sets and add (answer for this heavy set * size of intersection\r\nwith the set in the query). Time is . We have queries so total time is .\r\n"
}