{"link": "https://codeforces.com//contest/348/problem/C", "problemId": "3553", "problem_idx": "C", "shortId": "348C", "contest_number": "348", "problem_submissions": {"C": [4588342, 4590159, 4593135, 4588912, 4585853, 4589632, 4585524, 4586580, 4585883, 4581239, 4588365, 4618235], "B": [4580097, 4582356, 4579942, 4582963, 4589468, 4587659, 4577354, 4585315, 4580326, 4582274, 4579794, 4606814, 4580277, 4584510, 4582530, 4581233, 4588037, 4582260, 4589608], "A": [4576873, 4574641, 4574230, 4576431, 4576985, 4585961, 4574860, 4576105, 4577005, 4576961, 4574398, 4574642, 4577358, 4575644, 4582569, 4583556, 4575731, 4575526], "D": [4576020, 4578123, 4580839, 4584931, 4582728, 4580253, 4592562, 4587185, 4588035, 4587652, 4587737, 4590796, 4582015], "E": [4583454, 4855776, 4616595, 4820950, 4618329]}, "name": "C. Subset Sums", "statement": "You are given an array and sets of indices of elements of this array.\r\nLet\u2019s denote . In other words, is some element from set .In this problem\r\nyou have to answer queries of the two types: Find the sum of elements\r\nwith indices from set : . The query format is \"\". Add number to all\r\nelements at indices from set : is replaced by for all . The query format\r\nis \"\". After each first type query print the required sum.\r\n", "solutions": ["#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <bitset>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define pb push_back\n#define mp make_pair\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\nconst int64 mod = 2184057LL;\n\nconst int maxn = 105 * 1000;\n\nconst int BUBEN = 350;\n\nvi g[maxn];\nbool bad[maxn];\nbitset<maxn>* b[maxn];\n\nint main() {\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<int64> a(n);\n  for (int i = 0; i < n; ++i) {\n    int x;\n    scanf(\"%d\", &x);\n    a[i] = x;\n  }\n  vi baddies;\n  vector<int64> bb(n, 0);\n  vector<int64> bbb(n, 0);\n  vector<int64> ss(n, 0);\n  for (int i = 0; i < m; ++i) {\n    int cnt;\n    scanf(\"%d\", &cnt);\n    ss[i] = cnt;\n    if (cnt >= BUBEN) {\n      bad[i] = true;\n      baddies.pb(i);\n      b[i] = new bitset<maxn>();\n      for (int j = 0; j < cnt; ++j) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        (*(b[i]))[x] = true;\n        bbb[i] += a[x];\n      }\n    } else {\n      bad[i] = false;\n      for (int j = 0; j < cnt; ++j) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        g[i].pb(x);\n      }\n    }\n  }\n  int** d = new int*[m];\n  for (int i = 0; i < m; ++i) {\n    d[i] = new int[baddies.size()];\n    for (int j = 0; j < baddies.size(); ++j)\n      d[i][j] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (bad[i]) {\n      for (int j = 0; j < baddies.size(); ++j)\n        d[i][j] = ((*(b[i])) & (*(b[baddies[j]]))).count();\n    } else {\n      for (int j = 0; j < sz(g[i]); ++j) {\n        int x = g[i][j];\n        for (int t = 0; t < baddies.size(); ++t)\n          if (b[baddies[t]]->operator[](x)) {\n            d[i][t] += 1;\n          }\n      }\n    }\n  }\n\n  for (int i =0 ; i < q; ++i) {\n    char c[5];\n    scanf(\"%s\", c);\n    if (c[0] == '?') {\n      int k;\n      scanf(\"%d\", &k);\n      --k;\n      int64 res = 0;\n      if (!bad[k]) {\n        for (int j = 0; j < sz(g[k]); ++j)\n          res += a[g[k][j]];\n        for (int j = 0; j < sz(baddies); ++j)\n          res += bb[baddies[j]] * (int64)(d[k][j]);\n      } else {\n        res = bbb[k];\n      }\n      printf(\"%I64d\\n\", res);\n    } else {\n      int k, x;\n      scanf(\"%d%d\", &k, &x);\n      --k;\n      if (!bad[k]) {\n        for (int j = 0; j < sz(g[k]); ++j)\n          a[g[k][j]] += x;\n      } else {\n        bb[k] += x;\n      }\n      for (int j = 0; j < sz(baddies); ++j)\n         bbb[baddies[j]] += x * (int64)(d[k][j]);\n    }\n  }\n  return 0;\n}"], "input": "", "output": "", "tags": ["brute force", "data structures"], "dificulty": "2500", "interactive": false}