{"link": "https://codeforces.com//contest/1053/problem/B", "problemId": "223965", "problem_idx": "B", "shortId": "1053B", "contest_number": "1053", "problem_submissions": {"D": [43320967, 43321366, 43322493, 43325653, 43328216, 43329157, 43314103, 43329594, 43327708, 43331398, 43331864, 43331980, 43333170, 43320772, 43321907, 43347759, 43334692, 43316971, 43343476, 43341620, 43339949, 43337790], "C": [43307138, 43309894, 43312505, 43313721, 43312808, 43316109, 43324397, 43311885, 43312845, 43316905, 43321077, 43314278, 43317163, 43317332, 43329507, 43330889, 43311412, 43324598, 43338761, 46354235, 44718358, 43709718, 43709703, 43709682, 43515057, 43515052, 43483892, 43465752, 43464250, 43421524, 43400433, 43400425, 43385421, 43385407, 43354392, 43354373, 43354256, 43354129, 43354084, 43353946, 43353875, 43353862, 43338127, 43337856, 43317491], "B": [43302550, 43398321, 43398298, 43302971, 43303874, 43305537, 43304419, 43304489, 43303672, 43303860, 43307726, 43304869, 43306808, 43305251, 43304148, 43307156, 43307659, 43324162, 43300449, 43315267, 43326866, 43338204, 43337888, 43307003], "A": [43297754, 43298564, 43298952, 43299495, 43299534, 43304596, 43317168, 43299723, 43304344, 43300713, 43301168, 43300378, 43300680, 43298079, 43302518, 43299165, 43304630, 43311156, 43322106, 43301598], "E": [43366979, 43333450, 44387266, 43369111]}, "name": "B. Vasya and Good Sequences", "statement": "Vasya has a sequence a consisting of n integers a_1, a_2,\r\ndots, a_n. Vasya may pefrom the following operation: choose some number\r\nfrom the sequence and swap any pair of bits in its binary\r\nrepresentation. For example, Vasya can transform number 6 (\r\ndots 00000000110_2) into 3 (\r\ndots 00000000011_2), 12 (\r\ndots 000000001100_2), 1026 (\r\ndots 10000000010_2) and many others. Vasya can use this operation any\r\n(possibly zero) number of times on any number from the sequence.Vasya\r\nnames a sequence as one, if, using operation mentioned above, he can\r\nobtain the sequence with bitwise exclusive or of all elements equal to\r\n0.For the given sequence a_1, a_2,\r\nldots, a_n Vasya\u2019d like to calculate number of integer pairs (l, r) such\r\nthat 1\r\nle l\r\nle r\r\nle n and sequence a_l, a_{l + 1},\r\ndots, a_r is good.\r\n", "solutions": ["#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 333333\nint n,b[SZ],q[SZ],c[SZ],q1[SZ],n2[SZ],qq[2][SZ];\nll a[SZ];\nll work(int u)\n{\n\tn2[n+1]=n+1;\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tif(c[i]==2) n2[i]=i;\n\t\telse n2[i]=n2[i+1];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tq1[i]=q1[i-1]+(c[i]==1);\n\tint r=0; ll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\twhile((q1[r]-q1[i-1]==0\n\t\t||q[r]-q[i-1]<u)&&r<=n) ++r;\n\t\tif(r>n) break;\n\t\tif(r<n2[i])\n\t\t\tans+=qq[q[i-1]&1][n2[i]-1]\n\t\t\t-qq[q[i-1]&1][r-1];\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",a+i),\n\t\tb[i]=__builtin_popcountll(a[i]),\n\t\tq[i]=q[i-1]+b[i];\n\t\tqq[0][i]=qq[0][i-1]+(q[i]%2==0);\n\t\tqq[1][i]=qq[1][i-1]+(q[i]%2==1);\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=64;++i)\n\t{\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tif(b[j]<i) c[j]=0;\n\t\t\telse if(b[j]==i) c[j]=1;\n\t\t\telse c[j]=2;\n\t\t}\n\t\tans+=work(i+i);\n\t}\n\tcout<<ans<<\"\\n\";\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dp"], "dificulty": "2000", "interactive": false}