{"link": "https://codeforces.com//contest/295/problem/E", "problemId": "2838", "problem_idx": "E", "shortId": "295E", "contest_number": "295", "problem_submissions": {"E": [3511398, 3511419, 3511437, 3511617, 3512460, 3509679, 3512315, 3510900, 3508827, 3511729, 3510067, 3513473, 3512096, 3510503, 3513504, 3513446, 3513998, 3513357, 3512431], "D": [3509428, 3508084, 3508466, 3509763, 3509435, 3512601, 3509591, 3512430, 3510879, 3510319, 3512308, 3511034, 3506982, 3509190, 3509840, 3509472, 3580137], "C": [3508174, 3509402, 3509512, 3507449, 3507654, 3508191, 3508111, 3508096, 3513124, 3512841, 3513121, 3508464, 3508663, 3507348, 3507241, 3508781, 3507476, 3507076, 3507577, 3507688], "B": [3506807, 3505379, 3506165, 3505888, 3506089, 3506387, 3506261, 3505484, 3505919, 3507043, 3506794, 3509222, 3505786, 3505827, 3505874, 3505560, 3506566, 3506119], "A": [3505050, 3504656, 3505453, 3504455, 3504863, 3505059, 3505155, 3504693, 3504542, 3504788, 3504749, 3508036, 3504910, 3507685, 3504620, 3504661, 3556448, 3505140, 3504565]}, "name": "E. Yaroslav and Points", "statement": "Yaroslav has points that lie on the axis. The coordinate of the first\r\npoint is , the coordinate of the second point is , ..., the coordinate\r\nof the -th point is . Now Yaroslav wants to execute queries, each of\r\nthem is of one of the two following types: Move the -th point from\r\nposition to position . At that, it is guaranteed that after executing\r\nsuch query all coordinates of the points will be distinct. Count the sum\r\nof distances between all pairs of points that lie on the segment . In\r\nother words, you should count the sum of: . Help Yaroslav.\r\n", "solutions": ["#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstring>\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define fup FOR\n#define fdo FORD\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define siz SZ\n#define CLR(x) memset((x), 0, sizeof(x))\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second \n#define FI X\n#define SE Y\n#define SQR(a) ((a)*(a))\n#define DEBUG 1\n#define debug(x) {if (DEBUG)cerr <<#x <<\" = \" <<x <<endl; }\n#define debugv(x) {if (DEBUG) {cerr <<#x <<\" = \"; FORE(it, (x)) cerr <<*it <<\", \"; cout <<endl; }}\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<LL, LL>P;\ntypedef pair<LL, P> PP;\ntypedef vector<int>VI;\nconst int INF=1E9+7;\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n#define MAXN (1<<18)\n#define ILE X\n#define PREF Y.X\n#define SUM Y.Y\n\nLL n, xx[MAXN], act[MAXN], m, t[MAXN];\nvector<LL> wsp;\n\nPP join(PP A,PP B){\n    return PP(A.ILE+B.ILE, P(A.PREF+B.PREF, A.SUM+B.SUM+B.PREF*A.ILE-A.PREF*B.ILE));\n}\n\nstruct Tree{\n    LL is[2*MAXN];\n    PP dp[2*MAXN];\n\n    void add(int a, int val, int x=1, int ll=1, int rr=MAXN) {\n//        if(x == 1) cout << \"add \" << a << \" \" << val << endl;\n        if(a < ll || rr < a) return;\n        if(ll == rr) {\n            is[x] += val;\n            dp[x] = (is[x] ? PP(1,P(wsp[ll-1],0)) : PP(0,P(0,0)));\n            return;\n        }\n        add(a,val,2*x,ll,(ll+rr)/2);\n        add(a,val,2*x+1,(ll+rr+1)/2,rr);\n        dp[x] = join(dp[2*x], dp[2*x+1]);\n//        cout << \"ile \" << x << \" \" << dp[x].ILE << endl;\n    }\n\n    PP get(int l, int r, int x=1, int ll=1, int rr=MAXN) {\n//        if(x == 1) cout << \"get \" << l << \"-\" << r << endl;\n        if(r < ll || rr < l) return PP(0,P(0,0));\n        if(l <= ll && rr <= r) return dp[x];\n        return join(get(l,r,2*x,ll,(ll+rr)/2), \n                get(l,r,2*x+1,(ll+rr+1)/2,rr));\n    }\n};\n\nTree tree;\nLL l[MAXN],r[MAXN];\n\nLL nr(LL x) {\n        return lower_bound(ALL(wsp), x) - wsp.begin() + 1;\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n    cout << setprecision(15) << fixed;\n\t//in\n    cin >> n;\n    FOR(i,1,n) cin >> xx[i];\n    cin >> m;\n    FOR(i,1,m) cin >> t[i] >> l[i] >> r[i];\n    //wsp\n    wsp.PB(2E9);\n    wsp.PB(-2E9);\n    FOR(i,1,n) {\n        act[i] = xx[i];\n        wsp.PB(act[i]);\n    }\n    FOR(i,1,m) if(t[i] == 1)\n        wsp.PB(act[l[i]] += r[i]);\n    sort(ALL(wsp));\n    wsp.erase(unique(ALL(wsp)),wsp.end());\n\t//sol\n    FOR(i,1,n) {\n        act[i] = xx[i];\n        tree.add(nr(xx[i]),1);\n    }\n//    cout << tree.dp[1].ILE << \"!!!\" << endl;\n    FOR(i,1,m) if(t[i] == 1) {\n        int old = nr(act[l[i]]);\n        act[l[i]] += r[i];\n        int next = nr(act[l[i]]);\n        tree.add(old, -1);\n        tree.add(next, 1);\n    } else {\n        int a = nr(l[i]);\n        int b = nr(r[i]);\n        if(wsp[b-1] > r[i]) b--;\n        LL res = 0;\n//        cout << a << \"-\" << b << endl;\n        if(a<=b) {\n//            PP pp = tree.get(a,b);\n//            cout << pp.ILE << \" pref \" << pp.PREF << \" s\" << pp.SUM << endl;\n            res = tree.get(a,b).SUM;\n        }\n        cout << res << endl;\n    }\n\t//out\n\treturn 0;\n}\n\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2500", "interactive": false}