{"link": "https://codeforces.com//contest/983/problem/E", "problemId": "183243", "problem_idx": "E", "shortId": "983E", "contest_number": "983", "problem_submissions": {"E": [38286454, 38283020, 38289482, 38292735, 38289453, 38293779, 38302472, 38293561, 38300012, 38293577, 38302643, 38302639, 38302635, 38302629, 38300139, 38300133, 38300000, 38293677, 38332361, 38290750, 38296688, 38287165, 38281146, 38282245, 38289240, 38294540, 38292692], "C": [38282068, 38290172, 38281090, 38284331, 38284560, 38280127, 38285062, 38284712, 38287114, 38296797, 38287523, 38296777, 38305865, 38421418, 38281072, 38282940], "B": [38275765, 38281040, 38275649, 38277253, 38280013, 38275961, 38274648, 38276342, 38282348, 38281288, 38277599, 38291629, 38284850, 38285475, 38285545, 38278223, 38284828, 38274818, 38274252], "A": [38273115, 38279677, 38273911, 38271977, 38277206, 38393404, 38274395, 38272239, 38278413, 38325576, 38319214, 38319178, 38319075, 38319020, 38318977, 38318949, 38318775, 38311499, 38311463, 38311378, 38273182, 38332311, 38276058, 38279900, 38288950, 38281038, 38282952, 38280788, 38276091, 38275298, 38271513, 38271658], "D": [38430702, 38334183, 38527958]}, "name": "E. NN country", "statement": "In the NN country, there are n cities, numbered from 1 to n, and n - 1\r\nroads, connecting them. There is a roads path between any two\r\ncities.There are m bidirectional bus routes between cities. Buses drive\r\nbetween two cities taking the shortest path with stops in every city\r\nthey drive through. Travelling by bus, you can travel from any stop on\r\nthe route to any other. You can travel between cities only by bus.You\r\nare interested in q questions: is it possible to get from one city to\r\nanother and what is the minimum number of buses you need to use for it?\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 200000\n#define K 18\nstruct edge{int nx,t;}e[MN*2+5];\nint h[MN+5],en,d[MN+5],u[K][MN+5],fa[K][MN+5],l[MN+5],r[MN+5],cnt;\nint A[MN+5],B[MN+5],a[MN+5],b[MN+5],c[MN+5],s[MN+5],t[MN+5];\nvector<int> v[MN+5];\nvoid add(int x){for(;x<=MN;x+=x&-x)++t[x];}\nint sum(int x){int res=0;for(;x;x-=x&-x)res+=t[x];return res;}\ninline void ins(int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nvoid dfs(int x)\n{\n\tl[x]=++cnt;\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa[0][x])\n\t\tfa[0][e[i].t]=x,u[0][e[i].t]=d[e[i].t]=d[x]+1,dfs(e[i].t);\n\tr[x]=cnt;\n}\nint lca(int x,int y)\n{\n\tint k=d[x]-d[y],i;\n\tif(k<0)k=-k,swap(x,y);\n\tfor(i=0;k;k>>=1,++i)if(k&1)x=fa[i][x];\n\tif(x==y)return x;\n\tfor(i=K;i--;)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\nvoid dp(int x)\n{\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa[0][x])\n\t\tdp(e[i].t),u[0][x]=min(u[0][x],u[0][e[i].t]);\n}\nint up(int x,int y)\n{\n\tfor(int i=0;y;y>>=1,++i)if(y&1)x=fa[i][x];\n\treturn x;\n}\nvoid solve(int x)\n{\n\tfor(int i=0;i<v[x].size();++i)\n\t\tif(v[x][i]>0)s[v[x][i]]-=sum(r[b[v[x][i]]])-sum(l[b[v[x][i]]]-1);\n\tfor(int i=0;i<v[x].size();++i)\n\t\tif(v[x][i]<0)add(l[-v[x][i]]);\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa[0][x])solve(e[i].t);\n\tfor(int i=0;i<v[x].size();++i)\n\t\tif(v[x][i]>0)s[v[x][i]]+=sum(r[b[v[x][i]]])-sum(l[b[v[x][i]]]-1);\n}\nint main()\n{\n\t//freopen(\"bus.in\",\"r\",stdin);\n\t//freopen(\"bus.out\",\"w\",stdout);\n\tint n,t,m,i,j,l;\n\tn=read();\n\tfor(i=2;i<=n;++i)ins(i,read());\n\tdfs(1);\n\tfor(l=1;l<K;++l)for(i=1;i<=n;++i)fa[l][i]=fa[l-1][fa[l-1][i]];\n    t=read();\n\tfor(i=1;i<=t;++i)\n\t{\n\t\tl=lca(A[i]=read(),B[i]=read());\n\t\tu[0][A[i]]=min(u[0][A[i]],d[l]);\n\t\tu[0][B[i]]=min(u[0][B[i]],d[l]);\n\t\tv[A[i]].push_back(-B[i]);\n\t\tv[B[i]].push_back(-A[i]);\n\t}\n\tdp(1);\n\tfor(i=1;i<=n;++i)u[0][i]=up(i,d[i]-u[0][i]);\n\tfor(l=1;l<K;++l)for(i=1;i<=n;++i)u[l][i]=u[l-1][u[l-1][i]];\n    m=read();\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tl=lca(a[i]=read(),b[i]=read());\n\t\tif(b[i]==l)swap(a[i],b[i]);\n\t\tif(a[i]==l)\n\t\t{\n\t\t\tfor(j=K;j--;)if(d[u[j][b[i]]]>d[l])b[i]=u[j][b[i]],c[i]+=1<<j;\n\t\t\tif(d[u[0][b[i]]]>d[l])c[i]=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=K;j--;)if(d[u[j][a[i]]]>d[l])a[i]=u[j][a[i]],c[i]+=1<<j;\n\t\tfor(j=K;j--;)if(d[u[j][b[i]]]>d[l])b[i]=u[j][b[i]],c[i]+=1<<j;\n\t\tif(d[u[0][a[i]]]>d[l]||d[u[0][b[i]]]>d[l])c[i]=-1;\n\t\telse ++c[i],v[a[i]].push_back(i);\n\t}\n\tsolve(1);\n\tfor(i=1;i<=m;++i)\n\t{\n        if(c[i]+1-bool(s[i])==0)\n          printf(\"-1\\n\");\n        else\n          printf(\"%d\\n\",c[i]+1-bool(s[i]));\n    }\n\t//fclose(stdin);fclose(stdout);\n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "trees"], "dificulty": "2800", "interactive": false}