{"link": "https://codeforces.com//contest/156/problem/C", "problemId": "961", "problem_idx": "C", "shortId": "156C", "contest_number": "156", "problem_submissions": {"E": [1251034, 1250912, 1253282, 1312001, 1252010, 1252212], "D": [1249184, 1247144, 1248677, 1244853, 1248432, 1249652, 1248827, 1249495, 1249499, 1249691, 1251015, 1250308, 1250503, 1250715, 1247775, 1249330, 1248752, 1249953], "C": [1246457, 1246202, 1245021, 1245780, 1246904, 1247167, 1247068, 1245810, 1248007, 1247482, 1246141, 1247596, 1248235, 1246808, 1249384, 1245140, 1248141, 1247379], "B": [1245938, 1245171, 1246054, 1247267, 1245759, 1246347, 1246009, 1246866, 1246408, 1246550, 1245203, 1246446, 1245623, 1245940, 1248731, 1247154, 1246738, 1246814], "A": [1244965, 1244119, 1244125, 1246346, 1244442, 1244222, 1247281, 1244463, 1247485, 1245043, 1244152, 1244905, 1244423, 1244550, 1252481, 1251048, 1252049]}, "name": "C. Cipher", "statement": "Sherlock Holmes found a mysterious correspondence of two VIPs and made\r\nup his mind to read it. But there is a problem! The correspondence\r\nturned out to be encrypted. The detective tried really hard to decipher\r\nthe correspondence, but he couldn\u2019t understand anything. At last, after\r\nsome thought, he thought of something. Let\u2019s say there is a word ,\r\nconsisting of lowercase Latin letters. Then for one you can choose a\r\ncertain position () and perform one of the following actions: either\r\nreplace letter with the one that alphabetically it and replace letter\r\nwith the one that alphabetically it; or replace letter with the one that\r\nalphabetically it and replace letter with the one that alphabetically\r\nit. Let us note that letter \"\" doesn\u2019t have a defined following letter\r\nand letter \"\" doesn\u2019t have a defined preceding letter. That\u2019s why the\r\ncorresponding changes are not acceptable. If the operation requires\r\nperforming at least one unacceptable change, then such operation cannot\r\nbe performed.Two words iff one of them can be transformed into the other\r\none as a result of zero or more operations.Sherlock Holmes needs to\r\nlearn to quickly determine the following for each word: how many words\r\ncan exist that coincide in their meaning with the given word, but\r\ndiffers from the given word in at least one character? Count this number\r\nfor him modulo .\r\n", "solutions": ["#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nconst int MOD = 1e9 + 7;\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= MOD) a -= MOD;\n}\n\nconst int MAXL = 110;\nchar s[MAXL + 1];\n\nconst int MAXV = 25;\nconst int MAXS = MAXL * MAXV;\n\nint d[MAXL + 1][MAXS + 1];\n\nint main() {\n  #ifdef DEBUG\n  freopen(\"std.in\", \"r\", stdin);\n  freopen(\"std.out\", \"w\", stdout);\n  #endif\n\n  memset(d, 0, sizeof d);\n  d[0][0] = 1;\n  for (int l = 0; l < MAXL; l++)\n  for (int ps = 0; ps <= MAXS; ps++)\n    for (int nv = 0; nv <= MAXV && ps + nv <= MAXS; nv++)\n      add(d[l + 1][ps + nv], d[l][ps]);\n\n  int TC;\n  assert(scanf(\"%d\", &TC) >= 1);\n  while (TC --> 0) {\n    scanf(\"%s\", s);\n    int l = strlen(s), sum = 0;\n    for (int i = 0; i < l; i++)\n      sum += s[i] - 'a';\n    int res = d[l][sum];\n    add(res, MOD - 1);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2000", "interactive": false}