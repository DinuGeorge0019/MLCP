{
    "link": "https://codeforces.com//contest/1205/problem/E",
    "problemId": "390601",
    "problem_idx": "E",
    "shortId": "1205E",
    "contest_number": "1205",
    "problem_submissions": {
        "B": [
            59042855,
            59008277,
            59009392,
            59009099,
            59017750,
            59011582,
            59017246,
            59016172,
            59010044,
            59012507,
            59016410,
            59014372,
            59018459,
            59016311,
            59014609,
            59017774,
            59016256,
            59018790,
            59017251,
            59019103
        ],
        "F": [
            59040509,
            83365787,
            73837920,
            59054768,
            59706336,
            59497174,
            59084173,
            59131512
        ],
        "E": [
            59035128,
            59036458,
            59034704,
            59041033,
            59039150,
            59045402,
            59080765,
            59062429
        ],
        "D": [
            59016188,
            59026535,
            59028832,
            59032222,
            59023841,
            59032667,
            59050800,
            59047976,
            59037746,
            59038899,
            59036700,
            59037946,
            59034393,
            59042000,
            59040164,
            59037017,
            59039734,
            59041481,
            59041292,
            59040370,
            59040328
        ],
        "A": [
            59004226,
            59002142,
            59002328,
            59003907,
            59002592,
            59003675,
            59003063,
            59008409,
            59005394,
            59004820,
            59012388,
            59002589,
            59006476,
            59006648,
            59014700,
            59002817,
            59005001,
            59008957,
            59004360,
            59003394
        ],
        "C": [
            59022089,
            59020944,
            59025032,
            59033727,
            59026494,
            59026517,
            59028041,
            59025931,
            59027756,
            59033147,
            59024700,
            59031289,
            59032853,
            59030231,
            59031302,
            59030790,
            59030100,
            59029442,
            59031718
        ]
    },
    "name": "E. Expected Value Again",
    "statement": "You are given integers n, k. Let\u2019s consider the alphabet consisting of k\r\ndifferent elements.Let f(s) of the string s be the number of indexes i,\r\n1\r\nle i<|s|, for which prefix of s of length i equals to suffix of s of\r\nlength i. For example, beauty of the string abacaba equals 2, as for i =\r\n1, 3 prefix and suffix of length i are equal.Consider all words of\r\nlength n in the given alphabet. Find the expected value of f(s)^2 of a\r\nuniformly chosen at random word. We can show that it can be expressed as\r\nfrac{P}{Q}, where P and Q are coprime and Q isn\u2019t divided by 10^9 + 7.\r\nOutput P\r\ncdot Q^{-1}\r\nbmod 10^9 + 7.\r\n",
    "solutions": [
        "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nconst int MOD=1e9+7;\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\tb%=(MOD-1);\n\twhile(b<0) b+=MOD-1;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint mu[SZ];\nbool ip[SZ];\nll ps(ll k,ll n)\n{\n\tif(k==1) return n+1;\n\t//k^0+k^1+...+k^n\n\treturn (qp(k,n+1)-1)*qp(k-1,MOD-2)%MOD;\n}\nll ps(ll k,ll l,ll r)\n{\n\treturn qp(k,l)*ps(k,r-l)%MOD;\n}\nll pp(ll k,ll n)\n{\n\t//S=k+2k^2+3k^3+nk^n\n\t//kS=k^2+2k^3+3k^4+...+nk^(n+1)\n\t//kS-S=nk^(n+1)-k^n-k^(n-1)-...-k^2-k\n\treturn (n*qp(k,n+1)-ps(k,1,n))%MOD*qp(k-1,MOD-2)%MOD;\n\tll ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tans+=i*qp(k,i),ans%=MOD;\n\treturn ans;\n}\nll su(ll l,ll r)\n{\n\tl%=MOD; r%=MOD;\n\treturn (l+r)*(r-l+1)/2%MOD;\n}\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tif(n==1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(k==1)\n\t{\n\t\tll w=n-1;\n\t\tw=w*w%MOD;\n\t\tcout<<w<<\"\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i) mu[i]=1;\n\tfor(int i=2;i<=n;++i) if(!ip[i])\n\t{\n\t\tfor(int j=i;j<=n;j+=i)\n\t\t{\n\t\t\tip[j]=1;\n\t\t\tif((j/i)%i==0) mu[j]=0;\n\t\t\telse mu[j]=-mu[j];\n\t\t}\n\t}\n//\tfor(int i=1;i<=n;++i)\n//\t\tcout<<mu[i]<<\",\";\n//\tcout<<\"\\n\";\n\tll ans=0;\n\tfor(int s=1;s<=n;++s)\n\t{\n\t\t//i+j<=n+s, i,j<n, gcd(i,j)=s\n\t\tint u=(n+s)/s,r=(n-1)/s;\n\t\tll cd=0,ap=0;\n\t\t//-k^(i+j-n)\n\t\tfor(int x=1;x<=r;++x)\n\t\t{\n\t\t\tll ux=u/x,rx=r/x;\n\t\t\tll K=qp(k,x*s);\n\t\t\tll R=min(ux,rx+1);\n\t\t\tcd+=mu[x]*su(1,R-1);\n\t\t\tap+=mu[x]*K*pp(K,R-1);\n//\t\t\tfor(int p=2;p<=R;++p)\n//\t\t\t{\n//\t\t\t\tint rr=p-1;\n//\t\t\t\tcd+=mu[x]*rr;\n//\t\t\t\tap+=mu[x]*rr*qp(K,p);\n//\t\t\t\tcd%=MOD; ap%=MOD;\n//\t\t\t}\n\t\t\tcd+=mu[x]*rx*(ux-R);\n\t\t\tap+=mu[x]*rx*ps(K,R+1,ux); \n\t\t\tcd%=MOD; ap%=MOD;\n//\t\t\tfor(int p=R+1;p<=ux;++p)\n//\t\t\t{\n//\t\t\t\tint rr=rx;\n//\t\t\t\tcd+=mu[x]*rr;\n//\t\t\t\tap+=mu[x]*rr*qp(K,p);\n//\t\t\t\tcd%=MOD; ap%=MOD;\n//\t\t\t}\n//\t\t\tfor(int p=1;p<=r/x;++p)\n//\t\t\t\tfor(int q=1;q<=r/x;++q) if(p+q<=ux)\n//\t\t\t\t\tcd+=mu[x],\n//\t\t\t\t\tap+=mu[x]*qp(K,p+q);\n\t\t\t\t\t//ans-=mu[x]*qp(k,p*x*s+q*x*s-n);\n\t\t}\n\t\tcd%=MOD,ap%=MOD;\n\t\tans+=qp(k,s)*cd;\n\t\tans-=ap*qp(k,-n);\n\t\tans%=MOD;\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tans+=ps(k,i+1-n,i+n-1-n);\n\tans=ans%MOD*qp(k,n*(ll)(MOD-2))%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<\"\\n\";\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "strings"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Expected Value Again.json",
    "editorial_link": "https://codeforces.com/blog/entry/69158",
    "editorial": "Let be a function of the string equal to if the prefix and suffix of\r\nlength are equal, and equal to otherwise. We need to calculate (using\r\nlinearity of expectation) .We will call the number the period of the\r\nstring if for all . Moreover, the length of is not required to be\r\ndivided by .** Statement 1: ** is the period of the string is .** Proof:\r\n** that is equivalent to , which is equivalent to the fact that for from\r\nto .** Statement 2: ** .** Proof: ** The probability that is , since\r\neach of the last characters is uniquely determined from the previous\r\nones.** Statement 3: ** Let . Then .** Proof: ** Assume that . We know\r\nthat the string is and -periodic. Consider a graph of string positions,\r\nand draw edges between positions at distances . Then the number of\r\ndifferent strings satisfying is , where is the number of connected\r\ncomponents of our graph. Then . Thus, we need to show that .The case of\r\nis obvious: in this case, by subtracting and adding we can show that the\r\nstring has period , in this case . We now consider the case when\r\n.Without loss of generality, . We write out in a circle numbers from to\r\n. They denote the components of connectivity when we draw only the edges\r\nconnecting the positions at a distance of . Now we need to add edges of\r\nthe form for (here ). Moreover, we know that .We will add these edges\r\none at a time and observe how the connected components change. If we\r\nconnected two positions that were not connected yet, then we reduced the\r\nnumber of connected components by . Otherwise, we connected two already\r\nconnected vertices and formed a cycle. When does a cycle form at all? If\r\nwe consider all the edges of the form , then our graph is divided into\r\ncycles - components, each of which contains all positions giving the\r\nsame residues when divided by . Thus, it is necessary to calculate how\r\nmany of these cycles we form. If cycles are formed, then the number of\r\ncomponents will be .How many cycles will we create? Let\u00e2\u0080\u0099s see if the\r\ncycle consisting of positions giving the remainder when divided by\r\ncloses. It closes only if all its vertices are in . This is equivalent\r\nto the fact that among the positions in , not a single number gives the\r\nremainder of when dividing by . If , then this cannot happen for any , ,\r\nand . Otherwise, there will be exactly , where . Thus, the statement is\r\nproved.Further reasoning is standard. We have shown that depends only on\r\nand . It remains for to count the number of pairs such that , , . We\r\nwill do it as follows: if , , , then we rewrite it as , , . Now we just\r\nneed to find the number of numbers coprime to on the segment . This can\r\nbe done for , where is the number of prime divisors of .It can be shown\r\nthat this gives the asymptotics of (If you have a better one, please\r\nshare in the comments!)\r\n"
}