{"link": "https://codeforces.com//contest/338/problem/E", "problemId": "3400", "problem_idx": "E", "shortId": "338E", "contest_number": "338", "problem_submissions": {"D": [4295147, 4299466, 4295982, 4299910, 4297907, 4322675, 4322635, 4296295, 4300603, 4303747], "C": [4293877, 4292949, 4296119, 4290785, 4294450, 4290995, 4292819, 4294306, 4289507, 4319214, 4292496, 4292285, 4293888, 4293909, 4292095, 4292420], "A": [4292482, 4289057, 4289014, 4297071, 4289608, 4292907, 4298719, 4290998, 4292048, 4294562, 4288621, 4289027, 4288252, 4289309], "E": [4291715, 4297382, 4294190, 4295220, 4296654, 4297161, 4295153, 4304466, 4296200, 4296272, 4296355, 4296995, 4392972, 4307055], "B": [4289897, 4290803, 4292502, 4296197, 4291687, 4294720, 4290858, 4290695, 4291375, 4290406, 4289563, 4290575, 4290335, 4290751, 4293818, 4293496]}, "name": "E. Optimize ", "statement": "Manao is solving a problem with the following statement: He came up with\r\na solution that produces the correct answers but is too slow. You are\r\ngiven the pseudocode of his solution, where the function getAnswer\r\ncalculates the answer to the problem:getAnswer(a[1..n], b[1..len], h)\r\nanswer = 0 for i = 1 to n-len+1 answer = answer + f(a[i..i+len-1], b,\r\nh, 1) return answerf(s[1..len], b[1..len], h, index) if index = len+1\r\nthen return 1 for i = 1 to len if s[index] + b[i] >= h mem = b[i] b[i] =\r\n0 res = f(s, b, h, index + 1) b[i] = mem if res > 0 return 1 return\r\n0Your task is to help Manao optimize his algorithm.\r\n", "solutions": ["#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 2000010;\n\nint mx[N], add[N], a[N], b[N];\n\nvoid modify(int x, int l, int r, int ll, int rr, int v) {\n  if (l > rr || ll > r) return;\n  if (l >= ll && r <= rr) {\n    add[x] += v;\n    return;\n  }\n  if (add[x] != 0) {\n    add[x + x] += add[x];\n    add[x + x + 1] += add[x];\n    add[x] = 0;\n  }\n  int y = (l + r) >> 1;\n  modify(x + x, l, y, ll, rr, v);\n  modify(x + x + 1, y + 1, r, ll, rr, v);\n  mx[x] = mx[x + x + 1] + add[x + x + 1];\n  if (mx[x + x] + add[x + x] > mx[x]) mx[x] = mx[x + x] + add[x + x];\n}\n\nint main() {\n  int n, len, h;\n  scanf(\"%d %d %d\", &n, &len, &h);\n  for (int i=1;i<=len;i++) scanf(\"%d\", b+i);\n  sort(b + 1, b + len + 1);\n  reverse(b + 1, b + len + 1);\n  for (int i=1;i<=n;i++) {\n    int foo;\n    scanf(\"%d\", &foo);\n    int ll = 0, rr = len;\n    while (ll < rr) {\n      int mid = (ll + rr + 1) >> 1;\n      if (foo + b[mid] >= h) ll = mid;\n      else rr = mid - 1;\n    }\n    a[i] = ll;\n  }\n  memset(mx, 0, sizeof(mx));\n  memset(add, 0, sizeof(add));\n  for (int i=1;i<=len;i++) modify(1, 0, len, i, i, -i);\n  for (int i=1;i<=len-1;i++) modify(1, 0, len, a[i], len, 1);\n  int ans = 0;\n  for (int i=len;i<=n;i++) {\n    modify(1, 0, len, a[i], len, 1);\n    if (mx[1] + add[1] == 0) ans++;\n    modify(1, 0, len, a[i - len + 1], len, -1);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2600", "interactive": false}