{
    "link": "https://codeforces.com//contest/1446/problem/D2",
    "problemId": "797259",
    "problem_idx": "D2",
    "shortId": "1446D2",
    "contest_number": "1446",
    "problem_submissions": {
        "D2": [
            98488179,
            98479602,
            98464320,
            98467493,
            98464495,
            98464291,
            98477056,
            98482171,
            98496133,
            98469225,
            98470769,
            98488185,
            98481918,
            98482926,
            98479038
        ],
        "F": [
            98482236,
            98470414,
            98500090,
            98497700,
            98476856,
            98476210,
            98484136,
            98489678,
            98481827,
            98491554,
            98484171,
            98504348,
            98502497,
            98493379,
            98482100,
            98486768,
            98492674,
            98490163,
            98501084
        ],
        "E": [
            98475344,
            98498258,
            98500804,
            98495217,
            115705388,
            106404746
        ],
        "D1": [
            98457158,
            98460382,
            98456556,
            98456978,
            98464440,
            98464426,
            98466567,
            98470196,
            98464176,
            98472990,
            98478320,
            98479479,
            98482287,
            98493368,
            98460232,
            98466662,
            98460275,
            98466691,
            98472979,
            98478998
        ],
        "C": [
            98450996,
            98452840,
            98450218,
            98453943,
            98450946,
            98452214,
            98452223,
            98455447,
            98455497,
            98455239,
            98461758,
            98461392,
            98466665,
            98466780,
            98453580,
            98454283,
            98455611,
            98457408,
            98454698,
            98458074
        ],
        "B": [
            98446682,
            98448334,
            98447974,
            98447142,
            98452896,
            98448193,
            98448567,
            98451491,
            98449697,
            98450934,
            98454616,
            98452183,
            98446811,
            98455267,
            98447295,
            98450250,
            98449344,
            98450158,
            98450376,
            98449480
        ],
        "A": [
            98444992,
            98445944,
            98444925,
            98445065,
            98445347,
            98445666,
            98444771,
            98446535,
            98446420,
            98447534,
            98447441,
            98445935,
            98450208,
            98461593,
            98445099,
            98445257,
            98445487,
            98446333,
            98447509,
            98445254
        ]
    },
    "name": "D2. Frequency Problem  Hard Version ",
    "statement": "You are given an array [a_1, a_2,\r\ndots, a_n]. Your goal is to find the length of the longest subarray of\r\nthis array such that the most frequent value in it is unique. In other\r\nwords, you are looking for a subarray such that if the most frequent\r\nvalue occurs f times in this subarray, then at least 2 different values\r\nshould occur exactly f times.An array c is a subarray of an array d if c\r\ncan be obtained from d by deletion of several (possibly, zero or all)\r\nelements from the beginning and several (possibly, zero or all) elements\r\nfrom the end.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint a[N];\nint d[N][2];\nint n;\nint cnt[N];\nvector<int> posForX[N];\nint ans = 0;\n\nint countLower(int b, int x) {\n\treturn lower_bound(posForX[b].begin(), posForX[b].end(), x) - posForX[b].begin();\t\n}\n\nvoid solve(int b, int c) {\n\tset<int> intPos;\n\tfor (int i = 0; i < cnt[c]; i++) {\n\t\tint x = posForX[c][i];\n\t\tint z = countLower(b, x);\n\t\tint bal = cnt[b] - z + i;\n\t\tintPos.insert(bal);\n\t\tintPos.insert(bal + 1);\n\t}\n\tfor (int x : intPos) {\n\t\td[x][0] = n;\n\t\td[x][1] = -1;\n\t}\n\tset<int> setik;\n\tsetik = intPos;\n\tvector<int> pp;\n\tpp.push_back(-1);\n\tfor (int x : posForX[c])\n\t\tpp.push_back(x);\n\tpp.push_back(n);\n\tfor (int i = 1; i < (int)pp.size(); i++) {\n\t\tint x = pp[i], y = pp[i - 1];\n\t\tint maxBal = cnt[b] - countLower(b, y) + i - 1;\n\t\tint minBal = cnt[b] - countLower(b, x) + i - 1;\n\t\twhile(true) {\n\t\t\tauto it = setik.lower_bound(minBal);\n\t\t\tif (it == setik.end()) break;\n\t\t\tint bal = *it;\n\t\t\tif (bal > maxBal) break;\n\t\t\tint toW = bal;\n\t\t\tsetik.erase(it);\n\t\t\tbal = cnt[b] - bal + i - 1;\n\t\t\tassert(bal >= 0);\n\t\t\tif (toW == maxBal) {\n\t\t\t\td[toW][0] = y + 1;\n\t\t\t} else {\n\t\t\t\tassert(bal > 0);\n\t\t\t\td[toW][0] = posForX[b][bal - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tsetik = intPos;\n\tfor (int i = (int)pp.size() - 1; i > 0; i--) {\n\t\tint x = pp[i], y = pp[i - 1];\n\t\tint maxBal = cnt[b] - countLower(b, y) + i - 1;\n\t\tint minBal = cnt[b] - countLower(b, x) + i - 1;\n\t\twhile(true) {\n\t\t\tauto it = setik.lower_bound(minBal);\n\t\t\tif (it == setik.end()) break;\n\t\t\tint bal = *it;\n\t\t\tif (bal > maxBal) break;\n\t\t\tint toW = bal;\n\t\t\tsetik.erase(it);\n\t\t\tbal = cnt[b] - bal + i - 1;\n\t\t\tassert(bal >= 0);\n\t\t\tif (toW == minBal) {\n\t\t\t\td[toW][1] = x;\n\t\t\t} else {\n\t\t\t\td[toW][1] = posForX[b][bal];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x : intPos)\n\t\tans = max(ans, d[x][1] - d[x][0]);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tposForX[a[i]].push_back(i);\n\t\tcnt[a[i]]++;\n\t}\n\tint b = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (cnt[i] > cnt[b])\n\t\t\tb = i;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (posForX[i].empty()) continue;\n\t\tif (i == b) continue;\n\t\tsolve(b, i);\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D2. Frequency Problem  Hard Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/82067",
    "editorial": "If an element V\n appears more than n???\n times, we can simply brute-force this pair with partial sums (D,V)\n in O(n)\n.\n\nFor the other elements, for all the appearances of V\n we'll consider only at most |V|+1\n neighboring occurrences of D\n to search for the optimal interval. We can generalize the brute-force solution to work for this case too, by writing a function that solves just for a vector of interesting positions. Don't forget to take into account extending intervals with zeroes as well.\n\nWith proper preprocessing, this gives a solution in O(|V|2)\n per value V\n. Therefore, total runtime is bounded by O(nn???)\n.",
    "hint": []
}