{
    "link": "https://codeforces.com//contest/1785/problem/B",
    "problemId": "1767285",
    "problem_idx": "B",
    "shortId": "1785B",
    "contest_number": "1785",
    "problem_submissions": {
        "F": [
            192340988,
            192367706,
            192347284,
            192344077,
            192349198,
            192347771,
            192385993,
            192336126,
            192406311,
            192343375,
            192348787,
            192366544,
            192344262,
            192411258,
            192345259,
            192363821,
            192484658
        ],
        "E": [
            192334775,
            192378839,
            192330680,
            192327219,
            192332119,
            192339722,
            192385982,
            192341740,
            192412077,
            192337184,
            192336634,
            192325309,
            192324682,
            192330314,
            192339341,
            192328941,
            192342934,
            192342640,
            192343285,
            192338492,
            192348718
        ],
        "D": [
            192309677,
            192304720,
            192308363,
            192312353,
            192300737,
            192385972,
            192323435,
            192411822,
            192411698,
            192411631,
            192411452,
            192307092,
            192297940,
            192289422,
            192305735,
            192292206,
            192306351,
            192303021,
            192324811,
            192312541,
            192301962,
            192316529,
            192316093,
            192321567,
            192314574
        ],
        "C": [
            192301226,
            192367208,
            192300659,
            192294893,
            192304774,
            192305847,
            192385966,
            192316174,
            192318962,
            192301773,
            192292324,
            192299527,
            193510779,
            192315363,
            192293483,
            192308504,
            192291605,
            192310063,
            192307486,
            192299043,
            192314808,
            192308858
        ],
        "B": [
            192291042,
            192291589,
            192316742,
            192291514,
            192291590,
            192385951,
            192288659,
            192292597,
            192289761,
            192297426,
            192300042,
            192305089,
            192297247,
            192288814,
            192295447,
            192337551,
            192290254,
            192297732,
            192303838,
            192303907,
            192291091
        ],
        "A": [
            192284331,
            192283441,
            192283155,
            192282660,
            192283131,
            192385935,
            192282844,
            192284622,
            192283277,
            192290652,
            192292611,
            192296096,
            192286915,
            192282931,
            192283418,
            192285228,
            192283044,
            192283110,
            192282987,
            192288048,
            192282867
        ]
    },
    "name": "B. Letter Exchange",
    "statement": "A cooperative game is played by m people. In the game, there are 3m\r\nsheets of paper: m sheets with letter \u201d, m sheets with letter \u201d, and m\r\nsheets with letter \u201d.Initially, each person is given three sheets\r\n(possibly with equal letters).The goal of the game is to allow each of\r\nthe m people to spell the word \"\" using their sheets of paper. In other\r\nwords, everyone should have one sheet with letter \u201d, one sheet with\r\nletter \u201d, and one sheet with letter \u201d.To achieve the goal, people can\r\nmake . Two people participate in each exchange. Both of them choose\r\nexactly one sheet of paper from the three sheets they own and exchange\r\nit with each other.Find the shortest sequence of exchanges after which\r\neveryone has one \u201d, one \u201d, and one \u201d.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<string> s(N);\n\tfor(string& x : s) cin >> x;\n\tvector<vector<vector<int> > > need(3, vector<vector<int> > (3));\n\tfor(int z = 0; z < N; z++){\n\t\tvector<int> freq(3, -1);\n\t\tfor(char c : s[z]){\n\t\t\tif(c == 'w') freq[0]++;\n\t\t\tif(c == 'i') freq[1]++;\n\t\t\tif(c == 'n') freq[2]++;\n\t\t}\n\t\tvector<int> pos, neg;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(freq[i] > 0) for(int j = 0; j < freq[i]; j++) pos.push_back(i);\n\t\t\tif(freq[i] < 0) for(int j = 0; j < -freq[i]; j++) neg.push_back(i);\n\t\t}\n\t\tassert(pos.size() == neg.size());\n\t\tfor(int j = 0; j < pos.size(); j++){\n\t\t\tneed[pos[j]][neg[j]].push_back(z);\n\t\t}\n\t}\n\tstring win = \"win\";\n\tvector<tuple<int, char, int, char> > ans;\n\tfor(int i = 0; i < 3; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\twhile(!need[i][j].empty() && !need[j][i].empty()){\n\t\t\t\tint x = need[i][j].back();\n\t\t\t\tneed[i][j].pop_back();\n\t\t\t\tint y = need[j][i].back();\n\t\t\t\tneed[j][i].pop_back();\n\t\t\t\tans.push_back({x, win[i], y, win[j]});\n\t\t\t}\n\t\t}\n\t}\n\twhile(!need[0][1].empty()){\n\t\tint x = need[0][1].back();\n\t\tint y = need[1][2].back();\n\t\tint z = need[2][0].back();\n\t\tans.push_back({x, win[0], y, win[1]});\n\t\tans.push_back({y, win[0], z, win[2]});\n\t\tneed[0][1].pop_back();\n\t\tneed[1][2].pop_back();\n\t\tneed[2][0].pop_back();\n\t}\n\twhile(!need[0][2].empty()){\n\t\tint x = need[0][2].back();\n\t\tint y = need[2][1].back();\n\t\tint z = need[1][0].back();\n\t\tans.push_back({x, win[0], y, win[2]});\n\t\tans.push_back({y, win[0], z, win[1]});\n\t\tneed[0][2].pop_back();\n\t\tneed[2][1].pop_back();\n\t\tneed[1][0].pop_back();\n\t}\n\tcout << ans.size() << '\\n';\n\tfor(auto [a, b, c, d] : ans){\n\t\tcout << (a+1) << ' ' << b << ' ' << (c+1) << ' ' << d << '\\n';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Letter Exchange.json",
    "editorial_link": "https://codeforces.com//blog/entry/112875",
    "editorial": "For each person, there are three essential cases of what they could\r\ninitially have: Three distinct letters: \"\". No need to take part in any\r\nexchanges. Two equal letters and another letter, e.g. \"\". An extra \u00e2\u0080\u009d\r\nmust be exchanged with someone\u00e2\u0080\u0099s \u00e2\u0080\u009d. Three equal letters, e.g. \"\". One \u00e2\u0080\u009d\r\nmust be exchanged with someone\u00e2\u0080\u0099s \u00e2\u0080\u009d, another \u00e2\u0080\u009d must be exchanged with\r\nsomeone\u00e2\u0080\u0099s \u00e2\u0080\u009d. Let\u00e2\u0080\u0099s create a graph on three vertices: \u00e2\u0080\u009d, \u00e2\u0080\u009d, \u00e2\u0080\u009d. Whenever\r\nperson has an extra letter and is lacking letter , create a directed\r\nedge marked with .Once the graph is built, whenever you have a cycle of\r\nlength , that is, , it means person needs to exchange for , while person\r\nneeds to exchange for . Thus, both of their needs can be satisfied with\r\njust one exchange.Finally, once there are no cycles of length , note\r\nthat the in-degree and the out-degree of every vertex are equal. If e.g.\r\nthere are edges \u00e2\u0080\u009d \u00e2\u0080\u009d, it follows that there are edges \u00e2\u0080\u009d \u00e2\u0080\u009d and edges \u00e2\u0080\u009d \u00e2\u0080\u009d.\r\nIt means we can form cycles of length . (The cycles could also go in the\r\nopposite direction: \u00e2\u0080\u009d \u00e2\u0080\u009d \u00e2\u0080\u009d \u00e2\u0080\u009d.) In any case, each cycle of length can be\r\nsolved using exchanges.\r\n"
}