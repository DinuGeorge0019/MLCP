{
    "link": "https://codeforces.com//contest/1470/problem/C",
    "problemId": "855304",
    "problem_idx": "C",
    "shortId": "1470C",
    "contest_number": "1470",
    "problem_submissions": {
        "E": [
            103440669,
            103450045,
            103444324,
            103446807,
            103456209,
            103459429,
            103458872,
            103449311,
            103444803,
            103455366,
            103427287,
            103523513,
            103512117,
            107007766,
            103497278
        ],
        "C": [
            103424863,
            103419731,
            103412394,
            103420749,
            103473095,
            103443608,
            103423946,
            103436573,
            103483233,
            103668985,
            103426627,
            103424859,
            103478420,
            103478404,
            103478387,
            103478371,
            103478354,
            103478316,
            103478307,
            103478286,
            103478261,
            103478250,
            103415351,
            103438274,
            103450179,
            103434430,
            103429394,
            103442814,
            103435400
        ],
        "D": [
            103415926,
            103427083,
            103428552,
            103423208,
            103420751,
            103429115,
            103425438,
            103418855,
            103424458,
            103422509,
            103452603,
            103410374,
            103430035,
            103428165,
            103418606,
            103410543,
            103439473,
            103434901,
            103425306,
            103416679
        ],
        "B": [
            103406584,
            103402617,
            103400867,
            103408140,
            103415671,
            103407933,
            103428755,
            103407002,
            103406514,
            103413492,
            103439686,
            103403315,
            103398826,
            103407557,
            103405634,
            103400232,
            103409460,
            103410649,
            103414139,
            103409541
        ],
        "A": [
            103395440,
            103396207,
            103392457,
            120480996,
            103397804,
            103473156,
            103473127,
            103399272,
            103396942,
            103393409,
            103401022,
            103396664,
            103398098,
            103431488,
            103391970,
            103392128,
            103393954,
            103394467,
            103391951,
            103398410,
            103401147,
            103400351,
            103410763
        ],
        "F": [
            128458334,
            128458191,
            105649646,
            105647576
        ]
    },
    "name": "C. Strange Shuffle",
    "statement": "n people sitting in a circle are trying to shuffle a deck of cards. The\r\nplayers are numbered from 1 to n, so that players i and i+1 are\r\nneighbours (as well as players 1 and n). Each of them has exactly k\r\ncards, where k is . The left neighbour of a player i is player i - 1,\r\nand their right neighbour is player i + 1 (except for players 1 and n,\r\nwho are respective neighbours of each other).Each turn the following\r\nhappens: if a player has x cards, they give\r\nlfloor x / 2\r\nrfloor to their neighbour on the left and\r\nlceil x / 2\r\nrceil cards to their neighbour on the right. This happens for all\r\nplayers simultaneously.However, one player p is the impostor and they\r\njust give all their cards to their neighbour on the right. You know the\r\nnumber of players n and the number of cards k each player has initially,\r\nbut p is unknown to you. Your task is to determine the value of p, by\r\nasking questions like \"how many cards does player q have?\" for an index\r\nq of your choice. After each question all players will make exactly one\r\nmove and give their cards to their neighbours. You need to find the\r\nimpostor by asking no more than 1000 questions.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 05.01.2021 18:11:34       \n**/\n#undef LOCAL\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n, k);\n  vector<int> b(n);\n  #ifdef LOCAL\n  mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  int secret = rng() % n;\n  debug(secret);\n  int Q = 0;\n  #endif\n  auto Ask = [&](int pos) {\n    #ifdef LOCAL\n    Q += 1;\n    int res = a[pos];\n    for (int i = 0; i < n; i++) {\n      b[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      int R = (i + 1) % n;\n      int L = (i + n - 1) % n;\n      if (i == secret) {\n        b[R] += a[i];\n      } else {\n        b[L] += a[i] / 2;\n        b[R] += (a[i] + 1) / 2;\n      }\n    }\n    swap(a, b);\n    return res;\n    #else\n    cout << \"? \" << pos + 1 << endl;\n    int foo;\n    cin >> foo;\n    return foo;\n    #endif\n  };\n  const int WAIT = 500;\n  for (int i = 0; i < WAIT; i++) {\n    Ask(0);\n  }\n  int step = (n + 399) / 400;\n  int L = -1;\n  int R = -1;\n  for (int i = 0; i < n; i += step) {\n    int x = Ask(i);\n    if (x > k) {\n      L = i - (n + 1) / 2;\n      R = i;\n      while (L + 1 < R) {\n        int M = L + (R - L) / 2;\n        x = Ask((M % n + n) % n);\n        if (x > k) {\n          R = M;\n        } else {\n          L = M;\n        }\n      }\n      int res = (L % n + n) % n;\n      cout << \"! \" << res + 1 << endl;\n      #ifdef LOCAL\n      debug(res);\n      debug(Q);\n      assert(res == secret);\n      #endif\n      return 0;\n    }\n    if (x < k) {\n      L = i;\n      R = i + (n + 1) / 2;\n      while (L + 1 < R) {\n        int M = L + (R - L) / 2;\n        x = Ask((M % n + n) % n);\n        if (x < k) {\n          L = M;\n        } else {\n          R = M;\n        }\n      }\n      int res = (R % n + n) % n;\n      cout << \"! \" << res + 1 << endl;\n      #ifdef LOCAL\n      debug(res);\n      debug(Q);\n      assert(res == secret);\n      #endif\n      return 0;\n    }\n  }\n  assert(false);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Strange Shuffle.json",
    "editorial_link": "https://codeforces.com//blog/entry/86464",
    "editorial": "note that, during the first iterations the number of people with more\r\nthan cards, increases. Let\u00e2\u0080\u0099s find at least one such person. To do this,\r\nlet\u00e2\u0080\u0099s wait for iterations. After this there is always a continuous\r\nsegment of length with elements . To find it, we can split the array\r\ninto blocks of size , ask one element from each block, and find the\r\ndesired integer . Then we can use binary search to find the position .\r\nIn total we need queries. let\u00e2\u0080\u0099s use induction to prove that players that\r\nare located from the same distance from the player always have cards in\r\ntotal. It is obviously true initially. After one operation, when the\r\narray is transformed to the array , and let\u00e2\u0080\u0099s consider a pair of\r\nelements located on the same distance from position : and . Note that,\r\n(excluding the neighbours of ). It proves that the player will always\r\nhave cards.Now let\u00e2\u0080\u0099s prove that the number of cards that players have is\r\nnot increasing. Again, if we consider a single step: .During the first\r\niterations, the number of elements that are greater than , is\r\nincreasing. Before -th iteration we have . After -th iteration , because\r\nis even.The rest of the solution is described in the short version of\r\nthe solution above.\r\n"
}