{
    "link": "https://codeforces.com//contest/321/problem/C",
    "problemId": "3265",
    "problem_idx": "C",
    "shortId": "321C",
    "contest_number": "321",
    "problem_submissions": {
        "D": [
            3996276,
            3980026,
            3983272,
            3983312,
            12592698,
            3984131
        ],
        "E": [
            3980136,
            4452055,
            3980389,
            3985877,
            3982432,
            3983276,
            3983985,
            3983546,
            3989402,
            3982283,
            3982901,
            3987486,
            3986621,
            3986597,
            3984324
        ],
        "B": [
            3977018,
            3976497,
            3975346,
            3975457,
            3977862,
            3977933,
            3976248,
            3977096,
            3975835,
            3975367,
            3981509,
            3977308,
            3981308,
            3976604,
            3978354,
            23607133
        ],
        "C": [
            3976574,
            3973635,
            80179378,
            80179360,
            80178543,
            80177368,
            3977407,
            3978721,
            3979609,
            3977413,
            3979117,
            3980301,
            3977480,
            3978832,
            3979230,
            3979055,
            3978017,
            3980667,
            3983932,
            3980825
        ],
        "A": [
            3973735,
            3982224,
            3988924,
            3983503,
            3973922,
            3973057,
            3973436,
            3974764,
            3973866,
            3973513,
            3973909,
            3973666,
            3985547,
            3973654,
            3974568
        ]
    },
    "name": "C. Ciel the Commander",
    "statement": "Now Fox Ciel becomes a commander of Tree Land. Tree Land, like its name\r\nsaid, has cities connected by undirected roads, and for any two cities\r\nthere always exists a path between them.Fox Ciel needs to assign an\r\nofficer to each city. Each officer has a rank a letter from ” to ”. So\r\nthere will be 26 different ranks, and ” is the topmost, so ” is the\r\nbottommost.There are enough officers of each rank. But there is a\r\nspecial rule must obey: if and are two distinct cities and their\r\nofficers have the same rank, then on the simple path between and there\r\nmust be a city that has an officer with higher rank. The rule guarantee\r\nthat a communications between same rank officers will be monitored by\r\nhigher rank officer.Help Ciel to make a valid plan, and if it’s\r\nimpossible, output \"\".\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\n\nstruct Edge {\n\tint t;\n\tEdge(int t) :\n\t\t\tt(t) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\n\nbool del[MAX_N];\n\nint n;\n\nint size[MAX_N], opt[MAX_N];\nvector<int> all;\n\nvoid dfs(int u, int par) {\n\tall.push_back(u);\n\tsize[u] = 1;\n\topt[u] = 0;\n\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tif (e->t != par && !del[e->t]) {\n\t\t\tdfs(e->t, u);\n\t\t\tsize[u] += size[e->t];\n\t\t\topt[u] = max(opt[u], size[e->t]);\n\t\t}\n\t}\n}\n\nchar how[MAX_N];\n\nvoid solve(int rt, char ch) {\n\n\tall.clear();\n\tdfs(rt, -1);\n\n\tint minOpt = int(1e9), who = -1;\n\n\tfor (int i = 0; i < (int) all.size(); ++i) {\n\t\tint u = all[i];\n\t\topt[u] = max(opt[u], size[rt] - size[u]);\n\t\tif (opt[u] < minOpt) {\n\t\t\tminOpt = opt[u];\n\t\t\twho = u;\n\t\t}\n\t}\n\n\trt = who;\n\thow[rt] = ch;\n\tdel[rt] = true;\n\n\tfor (vector<Edge>::iterator e = E[rt].begin(); e != E[rt].end(); ++e) {\n\t\tif (!del[e->t]) {\n\t\t\tsolve(e->t, ch + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\tE[a].push_back(Edge(b));\n\t\tE[b].push_back(Edge(a));\n\t}\n\n\tsolve(0, 'A');\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(\"%c \", how[i]);\n\t}\n\tputs(\"\");\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "divide and conquer",
        "greedy",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Ciel the Commander.json",
    "editorial_link": "https://codeforces.com//blog/entry/8192",
    "editorial": "This is a problem with construction on trees. And for these kind of\r\nproblems, we usually use two method: up-down or down-up. So we have 1\r\nsolution for each method: = 1. up-down construction = Suppose we assign\r\nan officer with rank A at node x. Then for two distinct subtree rooted\r\nby x, says T1 and T2: There canât be any invalid path cross T1 and T2,\r\nbecause it is blocked by node x. (Itâs clear that we canât make 2 rank A\r\nofficer.) So we can solve these subtree independently: the only\r\ndifferent is that we canât use rank A anymore. Then the question is:\r\nwhich node should x be? It could be good if any subtree will has a small\r\nsize. And if you have the knowledge of \"centroid of tree\", then you can\r\nquickly find that if x be the centroid of this tree, the subtreeâs size\r\nwill be no more than half of the original tree. So we only needs about\r\nlog2(n) nodes and 26 is enough. = 2. down-up construction = The above\r\nsolution involves the concept of \"centroid of tree\" but you might not\r\nheard about that, donât worry, we have another solution can solve this\r\nproblem without knowing that, and itâs easier to implement. Suppose we\r\nchoose 1 as the root and consider it as a directed tree, and on some day\r\nwe have the following problem: We have some subtree rooted at T1, T2,\r\n..., Tk, and they are already assigned an officer, we need to assign an\r\nofficer to node x and link them to this node. Well, a normal idea is: we\r\nchoose one with lowest possible rank. The rank of x should satisfy: So\r\nwe can use this rule to choose the lowest possible rank. But can it\r\npasses? Yes, it can, but the proof is not such easy, Iâll introduce the\r\nmain idea here:\r\n",
    "hint": []
}