{"link": "https://codeforces.com//contest/321/problem/C", "problemId": "3265", "problem_idx": "C", "shortId": "321C", "contest_number": "321", "problem_submissions": {"D": [3996276, 3980026, 3983272, 3983312, 12592698, 3984131], "E": [3980136, 4452055, 3980389, 3985877, 3982432, 3983276, 3983985, 3983546, 3989402, 3982283, 3982901, 3987486, 3986621, 3986597, 3984324], "B": [3977018, 3976497, 3975346, 3975457, 3977862, 3977933, 3976248, 3977096, 3975835, 3975367, 3981509, 3977308, 3981308, 3976604, 3978354, 23607133], "C": [3976574, 3973635, 80179378, 80179360, 80178543, 80177368, 3977407, 3978721, 3979609, 3977413, 3979117, 3980301, 3977480, 3978832, 3979230, 3979055, 3978017, 3980667, 3983932, 3980825], "A": [3973735, 3982224, 3988924, 3983503, 3973922, 3973057, 3973436, 3974764, 3973866, 3973513, 3973909, 3973666, 3985547, 3973654, 3974568]}, "name": "C. Ciel the Commander", "statement": "Now Fox Ciel becomes a commander of Tree Land. Tree Land, like its name\r\nsaid, has cities connected by undirected roads, and for any two cities\r\nthere always exists a path between them.Fox Ciel needs to assign an\r\nofficer to each city. Each officer has a rank a letter from \u201d to \u201d. So\r\nthere will be 26 different ranks, and \u201d is the topmost, so \u201d is the\r\nbottommost.There are enough officers of each rank. But there is a\r\nspecial rule must obey: if and are two distinct cities and their\r\nofficers have the same rank, then on the simple path between and there\r\nmust be a city that has an officer with higher rank. The rule guarantee\r\nthat a communications between same rank officers will be monitored by\r\nhigher rank officer.Help Ciel to make a valid plan, and if it\u2019s\r\nimpossible, output \"\".\r\n", "solutions": ["#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\nusing namespace std;\n\nconst int MAX_N = int(1e5) + 10;\n\nstruct Edge {\n\tint t;\n\tEdge(int t) :\n\t\t\tt(t) {\n\t}\n};\n\nvector<Edge> E[MAX_N];\n\nbool del[MAX_N];\n\nint n;\n\nint size[MAX_N], opt[MAX_N];\nvector<int> all;\n\nvoid dfs(int u, int par) {\n\tall.push_back(u);\n\tsize[u] = 1;\n\topt[u] = 0;\n\n\tfor (vector<Edge>::iterator e = E[u].begin(); e != E[u].end(); ++e) {\n\t\tif (e->t != par && !del[e->t]) {\n\t\t\tdfs(e->t, u);\n\t\t\tsize[u] += size[e->t];\n\t\t\topt[u] = max(opt[u], size[e->t]);\n\t\t}\n\t}\n}\n\nchar how[MAX_N];\n\nvoid solve(int rt, char ch) {\n\n\tall.clear();\n\tdfs(rt, -1);\n\n\tint minOpt = int(1e9), who = -1;\n\n\tfor (int i = 0; i < (int) all.size(); ++i) {\n\t\tint u = all[i];\n\t\topt[u] = max(opt[u], size[rt] - size[u]);\n\t\tif (opt[u] < minOpt) {\n\t\t\tminOpt = opt[u];\n\t\t\twho = u;\n\t\t}\n\t}\n\n\trt = who;\n\thow[rt] = ch;\n\tdel[rt] = true;\n\n\tfor (vector<Edge>::iterator e = E[rt].begin(); e != E[rt].end(); ++e) {\n\t\tif (!del[e->t]) {\n\t\t\tsolve(e->t, ch + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\tE[a].push_back(Edge(b));\n\t\tE[b].push_back(Edge(a));\n\t}\n\n\tsolve(0, 'A');\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(\"%c \", how[i]);\n\t}\n\tputs(\"\");\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "dfs and similar", "divide and conquer", "greedy", "trees"], "dificulty": "2100", "interactive": false}