{
    "link": "https://codeforces.com//contest/1889/problem/E",
    "problemId": "2253922",
    "problem_idx": "E",
    "shortId": "1889E",
    "contest_number": "1889",
    "problem_submissions": {
        "F": [
            230286542,
            230266065,
            230262442
        ],
        "E": [
            230256898,
            230246832
        ],
        "D": [
            230235941,
            230232857,
            230224566,
            230272022,
            230272005,
            230271882,
            230271768,
            230230795,
            230267581,
            230266453,
            230266166,
            230265951,
            230226552,
            230234432,
            230236469,
            230251974,
            230254932,
            230230502,
            230243460,
            230250152,
            230249726,
            230244428,
            230257470,
            230253116,
            230249203,
            230254701,
            230259645,
            230251139
        ],
        "C2": [
            230210010,
            230217978,
            230434330,
            230213058,
            230214943,
            230216126,
            230223427,
            230223092,
            230233645,
            230213601,
            230231558,
            230237014,
            230233479,
            230223561,
            230227068,
            230237154,
            230230576,
            230236721,
            230222800,
            230220319
        ],
        "C1": [
            230200664,
            230217626,
            230211402,
            230212701,
            230201726,
            230298285,
            230199777,
            230209649,
            230223226,
            230202866,
            230195160,
            230217294,
            230211164,
            230200107,
            230209171,
            230227585,
            230205456,
            230230794,
            230222696,
            230222982,
            230220187
        ],
        "B": [
            230195225,
            230190509,
            230206755,
            230191485,
            230197446,
            230193895,
            230198878,
            230202551,
            230190822,
            230262085,
            230199606,
            230196726,
            230195700,
            230203093,
            230203643,
            230199184,
            230213572,
            230204206,
            230194309,
            230191500
        ],
        "A": [
            230190808,
            230198511,
            230201631,
            230187953,
            230191913,
            230188070,
            230191494,
            230197747,
            230187919,
            230186845,
            230194401,
            230191161,
            230186018,
            230251033,
            230195006,
            230188313,
            230193522,
            230193269,
            230187554,
            230187719
        ]
    },
    "name": "E. Doremy s Swapping Trees",
    "statement": "Consider two undirected graphs G_1 and G_2. Every node in G_1 and in G_2\r\nhas a label. Doremy calls G_1 and G_2 similar if and only if: The labels\r\nin G_1 are distinct, and the labels in G_2 are distinct. The set S of\r\nlabels in G_1 coincides with the set of labels in G_2. For every pair of\r\ntwo distinct labels u and v in S, the corresponding nodes are in the\r\nsame connected component in G_1 if and only if they are in the same\r\nconnected component in G_2. Now Doremy gives you two trees T_1 and T_2\r\nwith n nodes, labeled from 1 to n. You can do the following operation\r\nany number of times: Choose an edge set E_1 from T_1 and an edge set E_2\r\nfrom T_2, such that\r\noverline{E_1} and\r\noverline{E_2} are similar. Here\r\noverline{E} represents the graph which is given by only reserving the\r\nedge set E from T (i.e., the edge-induced subgraph). In other words,\r\noverline{E} is obtained from T by removing all edges not included in E\r\nand further removing all isolated vertices. Swap the edge set E_1 in T_1\r\nwith the edge set E_2 in T_2. Now Doremy is wondering how many distinct\r\nT_1 you can get after any number of operations. Can you help her find\r\nthe answer? Output the answer modulo 10^9+7.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I'll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 1e9 + 7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for read\");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? \",\" : \"\"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n'\n\t\t                                                             : ' ';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << '{';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << '}';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << '(';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << ')';\n\t\t} else static_assert(IsTuple<T>::value, \"No matching type for print\");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << \"\\033[0;31m\";\n\t\tImpl(t);\n\t\tif (debug) os << \"\\033[0m\";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << '\\n'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"\n\t     << \" | \"\n\t     << \"\\u001b[34m\" << func << \"\\033[0m\"\n\t     << \":\"\n\t     << \"\\u001b[34m\" << line << \"\\033[0m\"\n\t     << \" - \"\n\t     << \"[\" << args << \"] = \";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), \"w\", stdout); }\nvoid setIO(str s = \"\") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + \".in\"), setOut(s + \".out\");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: modular arithmetic operations\n * Source:\n * KACTL\n * https://codeforces.com/blog/entry/63903\n * https://codeforces.com/contest/1261/submission/65632855 (tourist)\n * https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate <int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; }  // primitive root for FFT\n\tint v;\n\texplicit operator int() const {\n\t\treturn v;\n\t}  // explicit -> don't silently convert to int\n\tmint() : v(0) {}\n\tmint(ll _v) {\n\t\tv = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD;\n\t}\n\tbool operator==(const mint &o) const { return v == o.v; }\n\tfriend bool operator!=(const mint &a, const mint &b) { return !(a == b); }\n\tfriend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }\n\tfriend istream &operator>>(istream &is, mint &a) {\n\t\tll x;\n\t\tis >> x;\n\t\ta = mint(x);\n\t\treturn is;\n\t}\n\tfriend ostream &operator<<(ostream &os, mint a) {\n\t\tos << int(a);\n\t\treturn os;\n\t}\n\n\tmint &operator+=(const mint &o) {\n\t\tif ((v += o.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmint &operator-=(const mint &o) {\n\t\tif ((v -= o.v) < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmint &operator*=(const mint &o) {\n\t\tv = int((ll)v * o.v % MOD);\n\t\treturn *this;\n\t}\n\tmint &operator/=(const mint &o) { return (*this) *= inv(o); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1;\n\t\tassert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a)\n\t\t\tif (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mint inv(const mint &a) {\n\t\tassert(a.v != 0);\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tmint operator-() const { return mint(-v); }\n\tmint &operator++() { return *this += 1; }\n\tmint &operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint &b) { return a += b; }\n\tfriend mint operator-(mint a, const mint &b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint &b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint &b) { return a /= b; }\n};\n\nusing mi = mint<MOD, 5>;  // 5 is primitive root for both common mods\nusing vmi = V<mi>;\nusing pmi = pair<mi, mi>;\nusing vpmi = V<pmi>;\n\nV<vmi> scmb;  // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ, vmi(SZ));\n\tscmb[0][0] = 1;\n\tFOR(i, 1, SZ)\n\tF0R(j, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);\n}\n\n/**\n * Description: Disjoint Set Union with path compression\n * and union by size. Add edges and test connectivity.\n * Use for Kruskal's or Boruvka's minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e, num, mx;\n\tvoid init(int N) {\n\t\te = vi(N, -1);\n\t\tnum = vi(N, 0);\n\t\tmx = vi(N, -1);\n\t}\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tbool unite(int x, int y) {  // union by size\n\t\tx = get(x), y = get(y);\n\t\tif (x == y) return 0;\n\t\tif (e[x] > e[y]) swap(x, y);\n\t\te[x] += e[y];\n\t\te[y] = x;\n\t\tnum[x] += num[y];\n\t\tckmax(mx[x], mx[y]);\n\t\treturn 1;\n\t}\n};\n\n/**tcT> T kruskal(int N, vector<pair<T,pi>> ed) {\n    sort(all(ed));\n    T ans = 0; DSU D; D.init(N); // edges that unite are in MST\n    each(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;\n    return ans;\n}*/\n\n// DSU D;\n\nstruct AdjList {\n\tvi head;\n\tvi nxt;\n\tvi val;\n\tvoid extend(int N) {\n\t\twhile (sz(head) < N) head.pb(-1);\n\t}\n\tvoid ae(int x, int y) {\n\t\textend(max(x, y) + 1);\n\t\tint e = sz(nxt);\n\t\tval.pb(y);\n\t\tnxt.pb(head.at(x));\n\t\thead.at(x) = e;\n\t}\n\tint size() { return sz(head); }\n};\n\n/**\n * Description: Tarjan's, DFS once to generate\n * strongly connected components in topological order. $a,b$\n * in same component if both $a\\to b$ and $b\\to a$ exist.\n * Uses less memory than Kosaraju b/c doesn't store reverse edges.\n * Time: O(N+M)\n * Source: KACTL\n * https://github.com/kth-competitive-programming/kactl/blob/master/content/graph/SCC.h\n * Verification: https://cses.fi/problemset/task/1686/\n */\n\nstruct SCC {\n\tint ti = 0;\n\tAdjList adj;\n\t// V<vi> adj;\n\tvi disc, comp, stk, comps;\n\tvi comp_cnt;\n\t// void init(int _N) { adj.rsz(_N); }\n\tvoid ae(int x, int y) {\n\t\tadj.ae(x, y);\n\t\t// while (sz(adj) <= max(x, y)) adj.eb();\n\t\t// adj.at(x).pb(y);\n\t}\n\tint dfs(int x) {\n\t\tint low = disc[x] = ++ti;\n\t\tstk.pb(x);\n\t\t// for (int ey =)\n\t\t// each(y, adj[x])\n\t\tfor (int ey = adj.head[x]; ey != -1; ey = adj.nxt[ey]) {\n\t\t\tint y = adj.val[ey];\n\t\t\tif (comp[y] == -1)                  // comp[y] == -1,\n\t\t\t\tckmin(low, disc[y] ?: dfs(y));  // disc[y] != 0 -> in stack\n\t\t}\n\t\tif (low == disc[x]) {  // make new SCC\n\t\t\t// pop off stack until you find x\n\t\t\tcomps.pb(x);\n\t\t\tfor (int y = -1; y != x;) comp[y = stk.bk] = x, stk.pop_back();\n\t\t}\n\t\treturn low;\n\t}\n\tint N;\n\tvoid gen() {\n\t\tN = sz(adj);\n\t\tdisc.rsz(N), comp.rsz(N, -1);\n\t\tF0R(i, N) if (!disc[i]) dfs(i);\n\t\treverse(all(comps));\n\t}\n\tint finish(vi special) {\n\t\tDSU D;\n\t\tD.init(N);\n\t\t// vi comp_cnt(N), comp_max(N, -1);\n\t\teach(t, special) {\n\t\t\tint c = comp.at(t);\n\t\t\t++D.num[c];\n\t\t\tckmax(D.mx[c], t);\n\t\t}\n\t\tauto orig_num = D.num;\n\t\treverse(all(comps));\n\t\tvb finished(N);\n\t\tAdjList comp_adj;\n\t\tcomp_adj.extend(N);\n\t\t// V<vi> comp_adj(N);\n\t\tF0R(i, N) {\n\t\t\tfor (int ey = adj.head[i]; ey != -1; ey = adj.nxt[ey]) {\n\t\t\t\tint j = adj.val[ey];\n\t\t\t\tint ci = comp[i], cj = comp[j];\n\t\t\t\tif (ci != cj) comp_adj.ae(ci, cj);\n\t\t\t}\n\t\t\t// \tfor (int j : adj[i]) {\n\t\t\t// }\n\t\t}\n\t\tset<pi> pairs;\n\t\tfor (int c : comps)\n\t\t\tif (orig_num[c]) {\n\t\t\t\t{\n\t\t\t\t\tqueue<int> q;\n\t\t\t\t\tq.push(c);\n\t\t\t\t\twhile (sz(q)) {\n\t\t\t\t\t\tint x = q.ft;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tif (finished[x]) continue;\n\t\t\t\t\t\tfinished[x] = 1;\n\t\t\t\t\t\tfor (int ey = comp_adj.head[x]; ey != -1;\n\t\t\t\t\t\t     ey = comp_adj.nxt[ey]) {\n\t\t\t\t\t\t\tint y = comp_adj.val[ey];\n\t\t\t\t\t\t\tassert(x != y);\n\t\t\t\t\t\t\tD.unite(x, y);\n\t\t\t\t\t\t\tq.push(y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// for (int y : comp_adj[x]) {\n\t\t\t\t\t\t// \tassert(x != y);\n\t\t\t\t\t\t// \tD.unite(x, y);\n\t\t\t\t\t\t// \tq.push(y);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x = D.get(c);\n\t\t\t\tdbg(\"GOT\", x, D.num[x]);\n\t\t\t\tif (D.num[x] > 1) pairs.ins({D.num[x], D.mx[x]});\n\t\t\t}\n\t\treturn sz(pairs);\n\t}\n};\n\n/**\n * Description: wraps a lambda so it can call itself\n * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\n */\n\nnamespace std {\n\ntemplate <class Fun> class y_combinator_result {\n\tFun fun_;\n\n  public:\n\ttemplate <class T>\n\texplicit y_combinator_result(T &&fun) : fun_(std::forward<T>(fun)) {}\n\n\ttemplate <class... Args> decltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate <class Fun> decltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n}  // namespace std\n\nvoid y_comb_demo() {\n\tcout << y_combinator([](auto gcd, int a, int b) -> int {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t})(20, 30)\n\t     << \"\\n\";  // outputs 10\n}\n\nvoid solve(int tc) {\n\tdef(int, N);\n\tAR<V<vi>, 2> adj;\n\tAR<vpi, 2> edges;\n\tF0R(i, 2) {\n\t\tedges[i].rsz(N - 1);\n\t\tre(edges[i]);\n\t}\n\tAR<V<AR<int, 18>>, 2> par;\n\tAR<vi, 2> depth;\n\tF0R(i, 2) {\n\t\tpar[i].rsz(N + 1);\n\t\tadj[i].rsz(N + 1);\n\t\tdepth[i].rsz(N + 1);\n\t\tfor (auto [l, r] : edges[i]) { adj[i][l].pb(r), adj[i][r].pb(l); }\n\t\ty_combinator([&](auto dfs, int x) -> void {\n\t\t\tfor (int y : adj.at(i)[x])\n\t\t\t\tif (y != par.at(i)[x].at(0)) {\n\t\t\t\t\tpar[i].at(y).at(0) = x;\n\t\t\t\t\tdepth[i].at(y) = depth[i].at(x) + 1;\n\t\t\t\t\tFOR(k, 1, 18)\n\t\t\t\t\tpar[i].at(y).at(k) =\n\t\t\t\t\t    par[i][par[i].at(y).at(k - 1)].at(k - 1);\n\t\t\t\t\tdfs(y);\n\t\t\t\t}\n\t\t})(1);\n\t}\n\t// dbg(\"GEN PAR\");\n\tauto hsh = [&](int i, int v, int k) {\n\t\tassert(v > 0);\n\t\treturn (i * N + (v - 1)) * 18 + k;\n\t};\n\tSCC S;\n\tF0R(i, 2)\n\tFOR(v, 2, N + 1) {\n\t\tassert(par[i][v].at(0));\n\t\tint a = v, b = par[i][v].at(0);\n\t\tassert(a && b);\n\t\tif (depth[i ^ 1].at(a) < depth[i ^ 1].at(b)) swap(a, b);\n\t\tR0F(k, 18) if (depth[i ^ 1].at(a) >= depth[i ^ 1].at(b) + (1 << k)) {\n\t\t\tS.ae(hsh(i, v, 0), hsh(i ^ 1, a, k));\n\t\t\ta = par[i ^ 1][a][k];\n\t\t}\n\t\tassert(depth[i ^ 1].at(a) == depth[i ^ 1].at(b));\n\t\tR0F(k, 18) if (par[i ^ 1][a][k] != par[i ^ 1][b][k]) {\n\t\t\tS.ae(hsh(i, v, 0), hsh(i ^ 1, a, k));\n\t\t\tS.ae(hsh(i, v, 0), hsh(i ^ 1, b, k));\n\t\t\ta = par[i ^ 1][a][k], b = par[i ^ 1][b][k];\n\t\t}\n\t\tif (a != b) {\n\t\t\tS.ae(hsh(i, v, 0), hsh(i ^ 1, a, 0));\n\t\t\tS.ae(hsh(i, v, 0), hsh(i ^ 1, b, 0));\n\t\t}\n\t}\n\tF0R(i, 2) FOR(v, 2, N + 1) FOR(k, 1, 18) if (depth[i][v] >= (1 << k)) {\n\t\tS.ae(hsh(i, v, k), hsh(i, v, k - 1));\n\t\tS.ae(hsh(i, v, k), hsh(i, par[i][v].at(k - 1), k - 1));\n\t}\n\t// dbg(\"GEN SCC\");\n\tS.gen();\n\t// dbg(\"DONE GEN SCC\");\n\tvi special;\n\tFOR(v, 2, N + 1) special.pb(hsh(0, v, 0));\n\tint c = S.finish(special);\n\tps(pow(mi(2), c));\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON'T GET STUCK ON ONE APPROACH\n */\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "3500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Doremy s Swapping Trees.json",
    "editorial_link": "https://codeforces.com//blog/entry/121813",
    "editorial": "We can construct a new directed graph, where we can consider each edge\r\nin and as a node. Let the node representing the edge in tree be .For\r\neach node , let the simple path between and in be , and for all we add\r\nan edge from to in the new graph. And for each node , let the simple\r\npath between and in be , and for all we add an edge from to in the new\r\ngraph.Then we calculate the number of strongly connected components with\r\nthe size bigger than in the new graph. If it is , the answer is .To\r\nreduce the time complexity to , we need to build the new graph with\r\nbinary lifting or heavy-light decomposition or centroid decomposition or\r\nsomething like those. More specifically, we just build the data\r\nstructure as normal, but replace the \"modify\" operation with \"add edge\"\r\noperation, which allows us to add edges from one node to a range of\r\nnodes with low time complexity.Proof: it is obviously that the edge set\r\nwe choose in each operation must be a closed subgraph in the new graph.\r\nAnd at the same time, it can be easily proved that every closed subgraph\r\nin the new graph is a valid edge set. The another thing we need to prove\r\nis that the set of valid closed subgraph won\u00e2\u0080\u0099t change after an\r\noperation. We can easily prove this by the relationship between the\r\nnumber of edges and the number of nodes in a tree.\r\n"
}