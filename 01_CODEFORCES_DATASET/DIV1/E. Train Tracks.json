{"link": "https://codeforces.com//contest/1344/problem/E", "problemId": "600706", "problem_idx": "E", "shortId": "1344E", "contest_number": "1344", "problem_submissions": {"E": [79212522, 79191531, 80590953, 79212872, 79212690, 79200320, 79201434, 79211282, 79212433, 79201854], "F": [79198229, 79194392, 79201012, 79200076, 79187834, 79207199, 79809754, 79207634, 79321670, 79237209], "D": [79171968, 79177519, 79172745, 79182190, 79179127, 79200953, 79290388, 79290327, 79290278, 79290202, 79290106, 79289995, 79289887, 79289860, 79289837, 79289762, 79289686, 79289607, 79289576, 79289521, 79289422, 79289347, 79289280, 79289191, 79289098, 79289025, 79288951, 79288889, 79288802, 79288740, 79288714, 79288657, 79288619, 79288562, 79288537, 79288505, 79288461, 79288426, 79288386, 79288343, 79288285, 79288204, 79288164, 79288116, 79288088, 79288039, 79288012, 79287980, 79287919, 79287860, 79287808, 79287736, 79287668, 79287637, 79287604, 79287566, 79287547, 79287511, 79287459, 79287434, 79287397, 79287350, 79287296, 79287262, 79287211, 79287167, 79287127, 79287079, 79286996, 79286949, 79286890, 79286845, 79286781, 79286728, 79286696, 79286656, 79286614, 79286579, 79286534, 79286474, 79286420, 79286389, 79286352, 79286300, 79286206, 79286092, 79286033, 79286000, 79285960, 79285920, 79285841, 79285783, 79285724, 79285687, 79285642, 79285596, 79285548, 79285495, 79285449, 79285406, 79285333, 79285275, 79285210, 79285148, 79285111, 79285080, 79284856, 79284810, 79284730, 79284667, 79284608, 79284558, 79284511, 79284467, 79284408, 79284359, 79276900, 79215004, 79179390, 79207200, 79185960, 79183492, 79185743, 79185899, 79187272, 79188204, 79183059, 79193595, 79192774, 79231073, 79194712, 79198266], "C": [79163958, 79167940, 79163314, 79167454, 79171067, 79172648, 79188375, 79171587, 79170701, 79174750, 79169461, 79175789, 79173516, 79172995, 79172803, 79176868, 79181841, 79172312, 79173542, 79175559], "B": [79155063, 79159060, 79154263, 79156872, 79158896, 79185288, 79162853, 79161753, 79161038, 79159421, 79159787, 79164882, 79163754, 79164480, 79160984, 79160540, 79164542, 79181585, 79178109, 79166538], "A": [79148759, 79148909, 79148790, 79148832, 79148971, 79151724, 79149355, 79151000, 79150191, 79163668, 79149361, 79149785, 79152609, 79150965, 79162044, 79148915, 79156438, 79149648, 79150451, 79148779]}, "name": "E. Train Tracks", "statement": "There are n stations and m trains. The stations are connected by n-1\r\none-directional railroads that form a tree rooted at station 1. All\r\nrailroads are pointed in the direction from the root station 1 to the\r\nleaves. A railroad connects a station u to a station v, and has a\r\ndistance d, meaning it takes d time to travel from u to v. Each station\r\nwith at least one outgoing railroad has a switch that determines the\r\nchild station an incoming train will be directed toward. For example, it\r\nmight look like this: Here, stations 1 and 3 have switches directed\r\ntoward stations 2 and 4, respectively. Initially, no trains are at any\r\nstation. Train i will enter station 1 at time t_i. Every unit of time,\r\nstarting at time 1, the following two steps happen: You can switch at\r\nmost one station to point to a different child station. A switch change\r\ntakes effect before step 2. For every train that is on a station u, it\r\nis directed toward the station v indicated by u\u2019s switch. So, if the\r\nrailroad from u to v has distance d, the train will enter station v in d\r\nunits of time from now. Every train has a destination station s_i. When\r\nit enters s_i, it will stop there permanently. If at some point the\r\ntrain is going in the wrong direction, so that it will never be able to\r\nreach s_i no matter where the switches point, it will immediately\r\nexplode.Find the if you change switches optimally, or determine that you\r\ncan direct every train to its destination so that no explosion occurs.\r\nAlso, find the to achieve this.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: Link-Cut Tree. Given a function $f(1\\ldots N)\\to 1\\ldots N,$ \n \t* evaluates $f^b(a)$ for any $a,b.$ \\texttt{sz} is for path queries; \n \t* \\texttt{sub}, \\texttt{vsub} are for subtree queries. \\texttt{x->access()} \n \t* brings \\texttt{x} to the top and propagates it; its left subtree will be \n \t* the path from \\texttt{x} to the root and its right subtree will be empty. \n \t* Then \\texttt{sub} will be the number of nodes in the connected component\n \t* of \\texttt{x} and \\texttt{vsub} will be the number of nodes under \\texttt{x}.\n \t* Use \\texttt{makeRoot} for arbitrary path queries.\n * Time: O(\\log N)\n * Usage: FOR(i,1,N+1)LCT[i]=new snode(i); link(LCT[1],LCT[2],1);\n * Source: Dhruv Rohatgi, Eric Zhang\n\t* https://sites.google.com/site/kc97ble/container/splay-tree/splaytree-cpp-3\n\t* https://codeforces.com/blog/entry/67637\n * Verification: (see README for links)\n\t* ekzhang Balanced Tokens\n\t* Dynamic Tree Test (Easy)\n\t* https://probgate.org/viewproblem.php?pid=578 (The Applicant)\n */\n\nvi cool;\n\nll dist[MX];\nvpl inter;\n\ntypedef struct snode* sn;\nstruct snode { //////// VARIABLES\n\tsn p, c[2]; // parent, children\n\tsn extra; // extra cycle node for \"The Applicant\"\n\tbool flip = 0; // subtree flipped or not\n\tint val, sz; // value in node, # nodes in current splay tree\n\tint lst = 0, lazy = 0;\n\tint sub, vsub = 0; // vsub stores sum of virtual children\n\tsnode(int _val) : val(_val) {\n\t\tp = c[0] = c[1] = extra = NULL; calc(); }\n\tfriend int getSz(sn x) { return x?x->sz:0; }\n\tfriend int getSub(sn x) { return x?x->sub:0; }\n\tvoid prop() { // lazy prop\n\t\tif (lazy) {\n\t\t\tlst = lazy; \n\t\t\tF0R(i,2) if (c[i]) c[i]->lazy = lazy;\n\t\t\tlazy = 0;\n\t\t}\n\t\tif (!flip) return;\n\t\tswap(c[0],c[1]); flip = 0;\n\t\tF0R(i,2) if (c[i]) c[i]->flip ^= 1;\n\t}\n\tvoid calc() { // recalc vals\n\t\tF0R(i,2) if (c[i]) c[i]->prop();\n\t\tsz = 1+getSz(c[0])+getSz(c[1]);\n\t\tsub = 1+getSub(c[0])+getSub(c[1])+vsub;\n\t}\n\t//////// SPLAY TREE OPERATIONS\n\tint dir() {\n\t\tif (!p) return -2;\n\t\tF0R(i,2) if (p->c[i] == this) return i;\n\t\treturn -1; // p is path-parent pointer\n\t} // -> not in current splay tree\n\t// test if root of current splay tree\n\tbool isRoot() { return dir() < 0; } \n\tfriend void setLink(sn x, sn y, int d) {\n\t\tif (y) y->p = x;\n\t\tif (d >= 0) x->c[d] = y; }\n\tvoid rot() { // assume p and p->p propagated\n\t\tassert(!isRoot()); int x = dir(); sn pa = p;\n\t\tsetLink(pa->p, this, pa->dir());\n\t\tsetLink(pa, c[x^1], x); setLink(this, pa, x^1);\n\t\tpa->calc(); calc();\n\t}\n\tvoid splay() {\n\t\twhile (!isRoot() && !p->isRoot()) {\n\t\t\tp->p->prop(), p->prop(), prop();\n\t\t\tdir() == p->dir() ? p->rot() : rot();\n\t\t\trot();\n\t\t}\n\t\tif (!isRoot()) p->prop(), prop(), rot();\n\t\tprop();\n\t}\n\t//////// BASE OPERATIONS\n\tvoid access() { // bring this to top of tree, propagate\n\t\tfor (sn v = this, pre = NULL; v; v = v->p) {\n\t\t\tv->splay(); // now switch virtual children\n\t\t\tif (pre) v->vsub -= pre->sub;\n\t\t\tif (v->c[1]) v->vsub += v->c[1]->sub;\n\t\t\tv->c[1] = pre; v->calc(); pre = v;\n\t\t}\n\t\tsplay(); assert(!c[1]); // right subtree is empty\n\t}\n\tvoid ACCESS(int ti) {\n\t\tdbg(\"ACCESS\",ti,val);\n\t\tsplay();\n\t\tfor (sn v = this->p, pre = this; v; v = v->p) {\n\t\t\tv->splay(); // now switch virtual children\n\t\t\tll d = dist[v->val];\n\t\t\tdbg(\"HA\",v->val,d,v->lst,ti);\n\t\t\tif (v->lst == 0) inter.pb({1,ti+d});\n\t\t\telse inter.pb({v->lst+d+1,ti+d});\n\t\t\tif (pre) v->vsub -= pre->sub;\n\t\t\tif (v->c[1]) v->vsub += v->c[1]->sub;\n\t\t\tv->c[1] = pre; v->calc(); pre = v;\n\t\t}\n\t\tsplay(); assert(!flip && !lazy);\n\t\tif (c[0]) {\n\t\t\tc[0]->lazy = ti;\n\t\t\t//dbg(\"HUH\",val,c[0]->val);\n\t\t}\n\t}\n\tvoid makeRoot() { \n\t\taccess(); flip ^= 1; access(); assert(!c[0] && !c[1]); }\n\t//////// QUERIES\n\tfriend sn lca(sn x, sn y) {\n\t\tif (x == y) return x;\n\t\tx->access(), y->access(); if (!x->p) return NULL;\n\t\tx->splay(); return x->p?:x;\n\t} // access at y did not affect x -> not connected\n\tfriend bool connected(sn x, sn y) { return lca(x,y); } \n\t// # nodes above\n\tint distRoot() { access(); return getSz(c[0]); } \n\tsn getRoot() { // get root of LCT component\n\t\taccess(); auto a = this; \n\t\twhile (a->c[0]) a = a->c[0], a->prop();\n\t\ta->access(); return a;\n\t}\n\tsn getPar(int b) { // get b-th parent on path to root\n\t\taccess(); b = getSz(c[0])-b; assert(b >= 0);\n\t\tfor (sn a = this;;a->prop()) {\n\t\t\tint z = getSz(a->c[0]);\n\t\t\tif (b == z) { a->access(); return a; }\n\t\t\tif (b < z) a = a->c[0];\n\t\t\telse a = a->c[1], b -= z+1;\n\t\t}\n\t} // can also get min, max on path to root, etc\n\t//////// MODIFICATIONS\n\tvoid set(int v) { access(); val = v; calc(); } \n\tfriend void link(sn x, sn y, bool force = 0) { \n\t\tassert(!connected(x,y)); \n\t\tif (force) y->makeRoot(); // make x par of y\n\t\telse { y->access(); assert(!y->c[0]); }\n\t\tx->access(); setLink(y,x,0); y->calc();\n\t}\n\tfriend void cut(sn y) { // cut y from its parent\n\t\ty->access(); assert(y->c[0]);\n\t\ty->c[0]->p = NULL; y->c[0] = NULL; y->calc(); }\n\tfriend void cut(sn x, sn y) { // if x, y adj in tree\n\t\tx->makeRoot(); y->access(); \n\t\tassert(y->c[0] == x && !x->c[0] && !x->c[1]); cut(y); }\n};\nsn LCT[MX];\n\nint n,m,par[MX],lst[MX];\nvpi adj[MX];\n\nvoid dfsAccess(int x) {\n\tLCT[x]->access();\n\ttrav(t,adj[x]) {\n\t\tdist[t.f] = dist[x]+t.s;\n\t\tdfsAccess(t.f);\n\t}\n}\n\nvoid process() {\n\tint s,t; re(s,t);\n\tcool.clear();\n\tLCT[s]->ACCESS(t);\n\t//dbg(\"HA\",inter);\n\t//dbg(cool);\n}\n\nint main() {\n\tsetIO(); re(n,m);\n\tFOR(i,1,n+1) LCT[i] = new snode(i);\n\tF0R(i,n-1) {\n\t\tint u,v,d; re(u,v,d);\n\t\tadj[u].pb({v,d});\n\t\tpar[v] = u;\n\t}\n\tFOR(i,2,n+1) link(LCT[par[i]],LCT[i]);\n\tdfsAccess(1);\n\tF0R(i,m) process();\n\tpriority_queue<ll,vl,greater<ll>> pq;\n\tsort(all(inter));\n\t// dbg(inter);\n\tint ind = 0;\n\tfor (ll i = 1; ;++i) {\n\t\tif (ind == sz(inter) && !sz(pq)) break;\n\t\tif (!sz(pq)) i = inter[ind].f;\n\t\twhile (ind < sz(inter) && inter[ind].f == i) {\n\t\t\tpq.push(inter[ind].s);\n\t\t\tind ++;\n\t\t}\n\t\tif (sz(pq)) pq.pop();\n\t\tif (sz(pq) && pq.top() == i) {\n\t\t\t//fin(i);\n\t\t\tint cnt = 0; trav(t,inter) cnt += t.s < i;\n\t\t\tps(i,cnt);\n\t\t\texit(0);\n\t\t}\n\t}\n\tps(-1,sz(inter));\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "3100", "interactive": false}