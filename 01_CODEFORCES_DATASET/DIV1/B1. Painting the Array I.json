{"link": "https://codeforces.com//contest/1479/problem/B1", "problemId": "889626", "problem_idx": "B1", "shortId": "1479B1", "contest_number": "1479", "problem_submissions": {"D": [106806356, 106798804, 106791682, 106791766, 106783633, 106814882, 106806404, 106823371, 106808799, 106822218, 106817839, 106848882, 106812415, 106835076, 106827553, 106802594, 106816382, 106815777, 106820515, 106838550, 106850875, 106833526], "C": [106782305, 106781616, 106813281, 106777792, 106806652, 106785851, 106790598, 106804329, 106788311, 106797179, 106801693, 106797158, 106799023, 106802871, 106833768, 106794280, 106835769, 106791359, 106812286, 106805528], "B2": [106767251, 106763833, 106764524, 106766365, 106766872, 106772583, 106777899, 106776623, 106772714, 106777329, 106781346, 106839134, 106782598, 106789550, 106774779, 106781374, 106779953, 106776541, 106784819, 106807842], "B1": [106761871, 106761547, 106772762, 106765327, 106765110, 106769139, 106770176, 106777978, 106783437, 106765790, 106777195, 106759777, 106771397, 106771604, 106765950, 106772183, 106778477, 106775679, 106771753, 106783453], "A": [106755900, 106753726, 106756482, 106751012, 106869291, 106756412, 106753230, 106749820, 106752580, 106752067, 106756325, 106758074, 106749882, 106753072, 106759686, 106753472, 106830245, 106764145, 106862156, 106753714, 106755663], "E": [106862710, 106861209, 106848127, 128939200, 106847859, 106846880, 112187125]}, "name": "B1. Painting the Array I", "statement": "Homer likes arrays a lot. Today he is painting an array a_1, a_2,\r\ndots, a_n with two kinds of colors, and . A painting assignment for a_1,\r\na_2,\r\ndots, a_n is described by an array b_1, b_2,\r\ndots, b_n that b_i indicates the color of a_i (0 for white and 1 for\r\nblack).According to a painting assignment b_1, b_2,\r\ndots, b_n, the array a is split into two new arrays a^{(0)} and a^{(1)},\r\nwhere a^{(0)} is the sub-sequence of all white elements in a and a^{(1)}\r\nis the sub-sequence of all black elements in a. For example, if a =\r\n[1,2,3,4,5,6] and b = [0,1,0,1,0,0], then a^{(0)} = [1,3,5,6] and\r\na^{(1)} = [2,4].The number of segments in an array c_1, c_2,\r\ndots, c_k, denoted\r\nmathit{seg}(c), is the number of elements if we merge all adjacent\r\nelements with the same value in c. For example, the number of segments\r\nin [1,1,2,2,3,3,3,2] is 4, because the array will become [1,2,3,2] after\r\nmerging adjacent elements with the same value. Especially, the number of\r\nsegments in an empty array is 0.Homer wants to find a painting\r\nassignment b, according to which the number of segments in both a^{(0)}\r\nand a^{(1)}, i.e.\r\nmathit{seg}(a^{(0)})+\r\nmathit{seg}(a^{(1)}), is as as possible. Find this number.\r\n", "solutions": ["/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass B1PaintingTheArrayI {\n public:\n  void solveOne() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) {\n      cin >> x;\n      --x;\n    }\n    vector<vector<int>> occs(n);\n    for (int i = 0; i < n; ++i) {\n      occs[a[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i) occs[i].push_back(n);\n    int x = -1;\n    int y = -1;\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n      int z = a[i];\n      if (z == x) {\n        if (z == y) {\n\n        } else {\n          y = z;\n          ++res;\n        }\n      } else if (z == y) {\n        x = z;\n        ++res;\n      } else {\n        int px = x < 0 ? n : *lower_bound(all(occs[x]), i);\n        int py = y < 0 ? n : *lower_bound(all(occs[y]), i);\n        if (px < py) {\n          x = z;\n        } else {\n          y = z;\n        }\n        ++res;\n      }\n    }\n    cout << res << \"\\n\";\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    B1PaintingTheArrayI solver;\n\n\n    solver.solve();\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "data structures", "dp", "greedy", "implementation"], "dificulty": "1900", "interactive": false}