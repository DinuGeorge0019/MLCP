{
    "link": "https://codeforces.com//contest/1479/problem/B1",
    "problemId": "889626",
    "problem_idx": "B1",
    "shortId": "1479B1",
    "contest_number": "1479",
    "problem_submissions": {
        "D": [
            106806356,
            106798804,
            106791682,
            106791766,
            106783633,
            106814882,
            106806404,
            106823371,
            106808799,
            106822218,
            106817839,
            106848882,
            106812415,
            106835076,
            106827553,
            106802594,
            106816382,
            106815777,
            106820515,
            106838550,
            106850875,
            106833526
        ],
        "C": [
            106782305,
            106781616,
            106813281,
            106777792,
            106806652,
            106785851,
            106790598,
            106804329,
            106788311,
            106797179,
            106801693,
            106797158,
            106799023,
            106802871,
            106833768,
            106794280,
            106835769,
            106791359,
            106812286,
            106805528
        ],
        "B2": [
            106767251,
            106763833,
            106764524,
            106766365,
            106766872,
            106772583,
            106777899,
            106776623,
            106772714,
            106777329,
            106781346,
            106839134,
            106782598,
            106789550,
            106774779,
            106781374,
            106779953,
            106776541,
            106784819,
            106807842
        ],
        "B1": [
            106761871,
            106761547,
            106772762,
            106765327,
            106765110,
            106769139,
            106770176,
            106777978,
            106783437,
            106765790,
            106777195,
            106759777,
            106771397,
            106771604,
            106765950,
            106772183,
            106778477,
            106775679,
            106771753,
            106783453
        ],
        "A": [
            106755900,
            106753726,
            106756482,
            106751012,
            106869291,
            106756412,
            106753230,
            106749820,
            106752580,
            106752067,
            106756325,
            106758074,
            106749882,
            106753072,
            106759686,
            106753472,
            106830245,
            106764145,
            106862156,
            106753714,
            106755663
        ],
        "E": [
            106862710,
            106861209,
            106848127,
            128939200,
            106847859,
            106846880,
            112187125
        ]
    },
    "name": "B1. Painting the Array I",
    "statement": "Homer likes arrays a lot. Today he is painting an array a_1, a_2,\r\ndots, a_n with two kinds of colors, and . A painting assignment for a_1,\r\na_2,\r\ndots, a_n is described by an array b_1, b_2,\r\ndots, b_n that b_i indicates the color of a_i (0 for white and 1 for\r\nblack).According to a painting assignment b_1, b_2,\r\ndots, b_n, the array a is split into two new arrays a^{(0)} and a^{(1)},\r\nwhere a^{(0)} is the sub-sequence of all white elements in a and a^{(1)}\r\nis the sub-sequence of all black elements in a. For example, if a =\r\n[1,2,3,4,5,6] and b = [0,1,0,1,0,0], then a^{(0)} = [1,3,5,6] and\r\na^{(1)} = [2,4].The number of segments in an array c_1, c_2,\r\ndots, c_k, denoted\r\nmathit{seg}(c), is the number of elements if we merge all adjacent\r\nelements with the same value in c. For example, the number of segments\r\nin [1,1,2,2,3,3,3,2] is 4, because the array will become [1,2,3,2] after\r\nmerging adjacent elements with the same value. Especially, the number of\r\nsegments in an empty array is 0.Homer wants to find a painting\r\nassignment b, according to which the number of segments in both a^{(0)}\r\nand a^{(1)}, i.e.\r\nmathit{seg}(a^{(0)})+\r\nmathit{seg}(a^{(1)}), is as as possible. Find this number.\r\n",
    "solutions": [
        "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n// Actual solution is at the bottom\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef int64_t int64;\ntypedef pair<int, int> ii;\n\nclass B1PaintingTheArrayI {\n public:\n  void solveOne() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) {\n      cin >> x;\n      --x;\n    }\n    vector<vector<int>> occs(n);\n    for (int i = 0; i < n; ++i) {\n      occs[a[i]].push_back(i);\n    }\n    for (int i = 0; i < n; ++i) occs[i].push_back(n);\n    int x = -1;\n    int y = -1;\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n      int z = a[i];\n      if (z == x) {\n        if (z == y) {\n\n        } else {\n          y = z;\n          ++res;\n        }\n      } else if (z == y) {\n        x = z;\n        ++res;\n      } else {\n        int px = x < 0 ? n : *lower_bound(all(occs[x]), i);\n        int py = y < 0 ? n : *lower_bound(all(occs[y]), i);\n        if (px < py) {\n          x = z;\n        } else {\n          y = z;\n        }\n        ++res;\n      }\n    }\n    cout << res << \"\\n\";\n  }\n\n  void solve() {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne();\n    }\n  }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    B1PaintingTheArrayI solver;\n\n\n    solver.solve();\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B1. Painting the Array I.json",
    "editorial_link": "https://codeforces.com//blog/entry/87598",
    "editorial": "Formally, for every sequence , and we assume that are positive integers,\r\nthe number of segments in is defined to be where , and if the Boolean\r\nexpression is true and otherwise.Let\u00e2\u0080\u0099s restate the problem as. Given a\r\nsequence , divide it into two disjoint subsequences and such that is as\r\nlarge as possible.. We will construct two disjoint subsequences by\r\nscanning through the sequence . Initial setting: and are two empty\r\nsequences, and remains not scanned. Move on: Suppose the last elements\r\nof and are and , respectively, and (resp. ) if (resp. ) is empty. Let be\r\nthe current element scanning through . Our greedy strategy is described\r\nin two cases: Greedy Strategy I: If equals to one of and , then assign\r\nto the opposite subsequence. That is, if , then append after ; and if ,\r\nthen append after . In particular, if equals to both and , the\r\nassignment could be arbitrary. Greedy Strategy II: If differs from both\r\nand , then append after the one with the nearest next same value. That\r\nis, let denote the next position where appears in after , then append\r\nafter if , and after otherwise. The greedy strategy is intuitive, and\r\nwith this strategy, an algorithm is immediately obtained. However, its\r\nproof turns out to be complicated. We append its proof for\r\ncompleteness.Consider any optimal assignment , we will show that our\r\nstrategy is not worse than it. Let be the subarray of . Now suppose we\r\nare at some position , where the optimal assignment conflicts with our\r\nstrategy. We assume that ends with , and ends with , and . Greedy\r\nStrategy I: If conflicts with Greedy Strategy I, then we must have and\r\nwithout loss of generality, we assume that . Greedy Strategy I suggests\r\nwe append after but suggests we append after . Suppose results in the\r\ntwo subarrays , while there is indeed another optimal assignment that\r\nagrees with our strategy and results in .Greedy Strategy II: If\r\nconflicts with Greedy Strategy II, then we must have , and are distinct\r\nand without loss of generality, we assume that the next occurrence of\r\ngoes in front of that of . Greedy Strategy II suggests we append after\r\nbut suggests we append after . Suppose results in the two subarrays .\r\nConsider two cases.. If does not start with , then there is another\r\noptimal assignment that agrees with our strategy and results in .. If\r\nstarts with , i.e. , then since the first occurrence of is in front of\r\nthat of , we have that must be in , and assume that . The result of is\r\nrestated as . We find that there is another optimal assignment that\r\nagrees with our strategy and results in (Note that does not contain any\r\nor in it).The number of alternations in a sequence starting with is\r\ndefined to be where . We note that .Let denote the maximal possible sum\r\nof numbers of alternations in the two disjoint subsequences and of ,\r\ni.e. where and ranges over all possible pairs of disjoint subsequences\r\nof . It is obvious that the order of and does not matter, i.e. . We note\r\nthat our goal is to compute .Let denote the least index such that , i.e.\r\n. In case no such index exists, is defined to be .In fact, our problem\r\ncan be solved by DP regardless of the time complexity. (Dynamic\r\nProgramming). For and every , In particular, for empty sequence , we\r\nhave We can obtain some immediate properties of by the above DP\r\nrecurrence.. For every , . Moreover, if , then .After some observations,\r\nwe have. For every and sequence , .: By induction on the length of\r\nsequence . . It is trivial for the case since the left hand side is\r\nalways and the right hand side is always . . Suppose true for the case ,\r\ni.e. holds for every sequence of length . Now consider a sequence of\r\nlength . . . It is trivial that . . . We should prove that . By\r\nProposition 1, we need to prove that The second inequality is obvious.\r\nThe first inequality becomes which holds by induction. . . We should\r\nprove that . By Proposition 1, we only need to prove that which is\r\nobvious. . and . By Proposition 1, is equivalent to . . The left hand\r\nside becomes by induction that . The right hand side becomes by\r\ninduction that . The inequality holds immediately. . . The left hand\r\nside becomes by induction that . The right hand side becomes By\r\ninduction that and , the inequality holds. . . The left hand side\r\nbecomes The right hand side becomes by induction that . The inequality\r\nimmediately holds as appears in both sides (and can be eliminated\r\ntogether). . . The left hand side becomes The right hand side becomes By\r\ninduction that , the inequality holds. The inequality holds for all\r\ncases. Therefore, the inequality holds for . . The inequality holds for\r\nevery . . Suppose is a sequence. For every distinct , i.e. and , if ,\r\nthen .: By induction on the length of sequence . . It is trivial for the\r\ncase since the both hand sides are . . Suppose true for the case , i.e.\r\nholds for every sequence of length . Now consider a sequence of length .\r\n. . By Proposition 1 and 3, the left hand side becomes and the right\r\nhand side becomes The inequality holds immediately. . . By Proposition\r\n1, the left hand side becomes and the right hand side becomes By\r\nProposition 2, we have and therefore, the inequality holds. . . This is\r\nimpossible because , i.e. there is an element of value in front of the\r\nfirst element of value . . . The left hand side becomes The right hand\r\nside becomes . If , then by induction we have and (because , ) The\r\ninequality holds. . If , then by induction we have and (because , ) The\r\ninequality holds. The inequality holds for all cases. Therefore, the\r\ninequality holds for . . The inequality holds for every . (Greedy\r\nStrategy I). Suppose is a sequence. For every , if , then : By\r\nProposition 1, we have By Proposition 3, we have Combining with the both\r\nabove yields the proof. (Greedy Strategy II). Suppose is a sequence. For\r\nevery with , if , then : If , by Proposition 4, we have Therefore, by\r\nProposition 1, we have . The same statement holds for .\r\n"
}