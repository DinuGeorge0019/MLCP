{
    "link": "https://codeforces.com//contest/843/problem/E",
    "problemId": "119865",
    "problem_idx": "E",
    "shortId": "843E",
    "contest_number": "843",
    "problem_submissions": {
        "D": [
            86210957,
            86210473,
            29756854,
            34937670,
            29781848,
            29781833,
            29781501,
            29855864,
            30128230,
            42158478,
            42158439,
            30022222,
            29772717
        ],
        "C": [
            29753044,
            29759187,
            29746479,
            29758195,
            29749173,
            29747919,
            29747700,
            29750057,
            29750292,
            29751827,
            29751575,
            29754184,
            29754916,
            29751833,
            29755015,
            29755103,
            29756089,
            29752710
        ],
        "E": [
            29748360,
            29749250,
            29756319,
            29752227,
            29761679,
            29956114,
            29762394,
            35205556,
            29781472,
            29754090,
            29761229,
            29762324,
            42187009
        ],
        "A": [
            29740862,
            29750546,
            29737212,
            29736679,
            29736752,
            29736447,
            29736902,
            29737823,
            29737375,
            29738506,
            29737473,
            29738082,
            29739251,
            29737566,
            29736802,
            29738724,
            29737891,
            29739246,
            29738315
        ],
        "B": [
            29755133,
            29757158,
            29758427,
            29740669,
            29739815,
            29741358,
            29743424,
            29741532,
            29745306,
            29741855,
            29742825,
            29744139,
            29742831,
            29742430,
            29744161,
            29746567,
            29746080,
            29746122
        ]
    },
    "name": "E. Maximum Flow",
    "statement": "You are given a directed graph, consisting of vertices and edges. The\r\nvertices and are marked as source and sink correspondingly.\r\nAdditionally, there are no edges ending at and there are no edges\r\nbeginning in .The graph was constructed in a following way: initially\r\neach edge had capacity . A maximum flow with source at and sink at was\r\nconstructed in this flow network. Let’s denote as the value of flow\r\npassing through edge with index . Next, all capacities and flow value\r\nwere erased. Instead, indicators were written on edges if flow value\r\npassing through edge was positive, i.e. if and otherwise.Using the graph\r\nand values , find out what is the possible number of edges in the\r\ninitial flow network that could be saturated (the passing flow is equal\r\nto capacity, i.e. ). Also construct the corresponding flow network with\r\nmaximum flow in it.A flow in directed graph is described by flow values\r\non each of the edges so that the following conditions are satisfied: for\r\neach vertex, except source and sink, total incoming flow and total\r\noutcoming flow are equal, for each edge A flow is maximum if the\r\ndifference between the sum of flow values on edges from the source, and\r\nthe sum of flow values on edges to the source (there are no such in this\r\nproblem), is maximum possible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\n// ========================================================================= //\nnamespace dinic {\n    int const INF = 100 + (int) 1e9;\n    ll const INFL = 100 + (ll) 1e18;\n    int const N = 200200;\n\n    struct edge_t {\n        int to, cap, flow;\n        \n        edge_t(int to, int cap)\n            : to(to)\n            , cap(cap)\n            , flow(0)\n        {}\n    };\n\n    vector<edge_t> all;\n    vector<int> g[N];\n    int index[N], dist[N];\n\n    void add_edge(int from, int to, int cap1, int cap2) {\n        g[from].push_back(all.size());\n        all.emplace_back(to, cap1);\n        g[to].push_back(all.size());\n        all.emplace_back(from, cap2);\n    }\n\n    void init_graph(int n) {\n        all.clear();\n        for (int i = 0; i < n; ++i) {\n            g[i].clear();\n        }\n    }\n\n    void clear_flow() {\n        for (auto& edge : all) {\n            edge.flow = 0;\n        }\n    }\n\n    int dfs(int v, int sink, int flow) {\n        if (v == sink || flow == 0) {\n            return flow;\n        }\n        for (int& i = index[v]; i < (int)g[v].size(); ++i) {\n            int x = g[v][i];\n            auto& e = all[x];\n            int to = e.to;\n            int diff = e.cap - e.flow;\n            if (diff > 0 && dist[v] - 1 == dist[to]) {\n                int now = dfs(to, sink, min(flow, diff));\n                if (now > 0) {\n                    e.flow += now;\n                    all[x ^ 1].flow -= now;\n                    return now;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(int source, int sink, int n) {\n        clear_flow();\n        ll ret = 0;\n        while (true) {\n            static int q[N];\n            memset(dist, 63, sizeof(int) * n);\n            int tail = 0;\n            dist[q[tail++] = sink] = 0;\n            for (int i = 0; i < tail; ++i) {\n                int v = q[i];\n                for (int x : g[v]) {\n                    int to = all[x].to;\n                    if (all[x ^ 1].flow < all[x ^ 1].cap && dist[to] > INF) {\n                        dist[q[tail++] = to] = dist[v] + 1;\n                    }\n                }\n            }\n            if (dist[source] > INF) {\n                break;\n            }\n            memset(index, 0, n * sizeof(int));\n            while (int flow = dfs(source, sink, INF)) {\n                ret += flow;\n            }\n        }\n        return ret;\n    }\n}\n\n//void add_edge(int from, int to, int cap1, int cap2) {\n//void init_graph(int n) {\n//ll max_flow(int source, int sink, int n) {\n\nconst int N = 111;\n\nstruct Edge {\n    bool g;\n    int x, y;\n    int cap = 0, flow = 0;\n};\n\nint n, m, s1, s2;\nvector < int > e[N], eb[N];\nvector < Edge > es;\n\nbool vis[N];\nbool vis11[N];\n\nvoid dfs1(int v) {\n    if (vis11[v])\n        return;\n    vis11[v] = true;\n    for (int i : dinic::g[v]) {\n        dinic::edge_t edge = dinic::all[i];\n        if (edge.cap != edge.flow)\n            dfs1(edge.to);\n    }\n}\n\nbool dfs2(int v, int fin) {\n    if (v == fin)\n        return true;\n    if (vis[v])\n        return false;\n    vis[v] = true;\n    for (int i : e[v]) {\n        Edge &ee = es[i];\n        if (!ee.g)\n            continue;\n        ++ee.cap;\n        ++ee.flow;\n        if (dfs2(ee.y, fin))\n            return true;\n        --ee.cap;\n        --ee.flow;\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    scanf(\"%d%d%d%d\", &n, &m, &s1, &s2);\n    --s1; --s2;\n    dinic::init_graph(n);\n    for (int i = 0; i < m; ++i) {\n        int x, y, g;\n        scanf(\"%d%d%d\", &x, &y, &g);\n        --x;\n        --y;\n        e[x].push_back(sz(es));\n        Edge ce;\n        ce.x = x;\n        ce.y = y;\n        ce.g = g;\n        es.push_back(ce);\n        if (g) {\n            dinic::add_edge(x, y, 1, 0);\n            dinic::add_edge(y, x, dinic::INF, 0);\n        } else {\n            dinic::add_edge(x, y, dinic::INF, 0);\n        }\n    }\n\n    int flw = dinic::max_flow(s1, s2, n);\n\n    dfs1(s1);\n    for (Edge &ee : es) {\n        if (ee.g) {\n            ++ee.flow;\n            ++ee.cap;\n            memset(vis, 0, sizeof(vis));\n            dfs2(s1, ee.x);\n            memset(vis, 0, sizeof(vis));\n            dfs2(ee.y, s2);\n            if (!(vis11[ee.x] && !vis11[ee.y])) {\n                ++ee.cap;\n            }\n        } else\n            ee.cap = 1;\n    }\n\n    cout << flw << \"\\n\";\n    for (Edge const& ee : es)\n        cout << ee.flow << \" \" << ee.cap << \"\\n\";\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graphs"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Maximum Flow.json",
    "editorial_link": "https://codeforces.com//blog/entry/54029",
    "editorial": "Letâs find a minimal set of saturated edges. We will create new flow\r\nnetwork consisting of the same set of vertices and a little bit\r\ndifferent edges.For an each edge from original graph without any flow\r\nletâs create a new edge with the same direction and carrying capacity.\r\nFor every edge with a flow letâs create two edges: the first one with\r\nthe same direction and capacity and the second edge with reversed\r\ndirection and .In the new network, we have to find the minimum cut, it\r\nwill consist of edges with , corresponding edges of the initial graph\r\nwill be a desired minimal set.If this minimal set was equal to infinity\r\nthe description of the problem wouldnât be about maximum flow because it\r\nhad to be increasing for sure.So now itâs enough to create a non-zero\r\nflow for all edges needed in the task and to make on edges which we\r\nchose to be saturated and on the rest. Letâs consider directed graph\r\nwith edges with a flow. In the first situation we might make a\r\ncirculation on a cycle , in the second case, we can put a flow on the\r\nway from the source to the stream of . Thus, for each edge on which\r\nsomething is to flow, something will flow. Suppose the contrary. Letâs\r\ntake the edge of the form ->. Well then, there is no way from to or no\r\nway from to . Let the second be true without loss of generality. Letâs\r\nconsider the set of vertices attainable from . If there are in this set,\r\nthere is a cycle. Otherwise, this set is \"bad\", cause there are no , in\r\nit something flows in and nothing follows, in a correct network this is\r\nimpossible.\r\n",
    "hint": []
}