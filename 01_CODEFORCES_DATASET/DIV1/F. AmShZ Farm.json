{
    "link": "https://codeforces.com//contest/1528/problem/F",
    "problemId": "994167",
    "problem_idx": "F",
    "shortId": "1528F",
    "contest_number": "1528",
    "problem_submissions": {
        "F": [
            117241784,
            117237625,
            117249711,
            117251014,
            117237719,
            117247531,
            117250487,
            117296792,
            117362083
        ],
        "C": [
            117229826,
            117199788,
            117206577,
            117201851,
            117204674,
            117206245,
            117218212,
            117196904,
            117210131,
            117210736,
            117206890,
            117212730,
            117208145,
            117211669,
            117203428,
            117211467,
            117203007,
            117206081,
            117210746,
            117210824
        ],
        "E": [
            117212844,
            117230561,
            117222959,
            117226469,
            117224989,
            117238353,
            117239558,
            117216115,
            117234224,
            117239827,
            117237600,
            117238423,
            117244129,
            117238121,
            117240390,
            117239904,
            117240349,
            117240625,
            117238487,
            117240173
        ],
        "D": [
            117201259,
            117208270,
            117212623,
            117211738,
            117242708,
            117216479,
            117225362,
            117203170,
            117222650,
            117216984,
            117223735,
            117223429,
            117215498,
            117223732,
            117224661,
            117222534,
            117223454,
            117224387,
            117255573,
            117255349,
            117255220,
            117226605,
            117221662
        ],
        "B": [
            117190972,
            117190286,
            117191599,
            117193984,
            117197139,
            117198582,
            117200082,
            117188842,
            117200429,
            117191737,
            117195913,
            117196829,
            117195712,
            117199801,
            117193006,
            117201359,
            117211353,
            117194542,
            117198721,
            117194778
        ],
        "A": [
            117185385,
            117182301,
            117183363,
            117182330,
            117185042,
            117182254,
            117192623,
            117181878,
            117188021,
            117186007,
            117186714,
            117183913,
            117183194,
            117189883,
            117184967,
            117183486,
            117187212,
            117183227,
            117187339,
            117198905
        ]
    },
    "name": "F. AmShZ Farm",
    "statement": "To AmShZ, all arrays are equal, but some arrays are than others.\r\nSpecifically, the arrays consisting of n elements from 1 to n that can\r\nbe turned into permutations of numbers from 1 to n by adding a\r\nnon-negative integer to each element.Mashtali thinks that an array b\r\nconsisting of k elements is compatible with a array a consisting of n\r\nelements if for each 1\r\nle i\r\nle k we have 1\r\nle b_i\r\nle n and also a_{b_1} = a_{b_2} =\r\nldots = a_{b_k}.Find the number of pairs of arrays a and b such that a\r\nis a more-equal array consisting of n elements and b is an array\r\ncompatible with a consisting of k elements modulo 998244353.Note that\r\nthe elements of b are , same holds for a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define M_PI 3.14159265358979323846264338327950288\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nnamespace ecnerwala {\nnamespace fft {\n\nusing std::swap;\nusing std::vector;\nusing std::min;\nusing std::max;\n\ntemplate<class T> int sz(T&& arg) { using std::size; return int(size(std::forward<T>(arg))); }\ninline int nextPow2(int s) { return 1 << (s > 1 ? 32 - __builtin_clz(s-1) : 0); }\n\n// Complex\ntemplate <typename dbl> struct cplx { /// start-hash\n\tdbl x, y;\n\tcplx(dbl x_ = 0, dbl y_ = 0) : x(x_), y(y_) { }\n\tfriend cplx operator+(cplx a, cplx b) { return cplx(a.x + b.x, a.y + b.y); }\n\tfriend cplx operator-(cplx a, cplx b) { return cplx(a.x - b.x, a.y - b.y); }\n\tfriend cplx operator*(cplx a, cplx b) { return cplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n\tfriend cplx conj(cplx a) { return cplx(a.x, -a.y); }\n\tfriend cplx inv(cplx a) { dbl n = (a.x*a.x+a.y*a.y); return cplx(a.x/n,-a.y/n); }\n};\n\n// getRoot implementations\ntemplate <typename num> struct getRoot {\n\tstatic num f(int k) = delete;\n};\ntemplate <typename dbl> struct getRoot<cplx<dbl>> {\n\tstatic cplx<dbl> f(int k) {\n\t\tdbl a=2*M_PI/k;\n\t\treturn cplx<dbl>(cos(a),sin(a));\n\t}\n};\ntemplate <int MOD> struct primitive_root {\n\tstatic const int value;\n};\ntemplate <> struct primitive_root<998244353> {\n\tstatic const int value = 3;\n};\ntemplate <int MOD> struct getRoot<modnum<MOD>> {\n\tstatic modnum<MOD> f(int k) {\n\t\tassert((MOD-1)%k == 0);\n\t\treturn pow(modnum<MOD>(primitive_root<MOD>::value), (MOD-1)/k);\n\t}\n};\n\ntemplate <typename num> class fft {\n\tstatic vector<int> rev;\n\tstatic vector<num> rt;\n\npublic:\n\tstatic void init(int n);\n\ttemplate <typename Iterator> static void go(Iterator begin, int n);\n\n\tstatic vector<num> scratch_a;\n\tstatic vector<num> scratch_b;\n};\n\ntemplate <typename num> vector<int> fft<num>::rev({0,1});\ntemplate <typename num> vector<num> fft<num>::rt(2, num(1));\ntemplate <typename num> vector<num> fft<num>::scratch_a;\ntemplate <typename num> vector<num> fft<num>::scratch_b;\n\ntemplate <typename num> void fft<num>::init(int n) {\n\tif (n <= sz(rt)) return;\n\trev.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\trev[i] = (rev[i>>1] | ((i&1)*n)) >> 1;\n\t}\n\trt.reserve(n);\n\tfor (int k = sz(rt); k < n; k *= 2) {\n\t\trt.resize(2*k);\n\t\tnum z = getRoot<num>::f(2*k);\n\t\tfor (int i = k/2; i < k; i++) {\n\t\t\trt[2*i] = rt[i], rt[2*i+1] = rt[i]*z;\n\t\t}\n\t}\n}\n\ntemplate <typename num> template <typename Iterator> void fft<num>::go(Iterator begin, int n) {\n\tinit(n);\n\tint s = __builtin_ctz(sz(rev)/n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i < (rev[i]>>s)) {\n\t\t\tswap(*(begin+i), *(begin+(rev[i]>>s)));\n\t\t}\n\t}\n\tfor (int k = 1; k < n; k *= 2) {\n\t\tfor (int i = 0; i < n; i += 2 * k) {\n\t\t\tIterator it1 = begin + i, it2 = it1 + k;\n\t\t\tfor (int j = 0; j < k; j++, ++it1, ++it2) {\n\t\t\t\tnum t = rt[j+k] * *it2;\n\t\t\t\t*it2 = *it1 - t;\n\t\t\t\t*it1 = *it1 + t;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate <typename num> struct fft_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tvector<num>& fa = fft<num>::scratch_a;\n\t\tvector<num>& fb = fft<num>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<num>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\t\tcopy(ia, ia+sza, fa.begin());\n\t\tfill(fa.begin()+sza, fa.begin()+n, num(0));\n\t\tcopy(ib, ib+szb, fb.begin());\n\t\tfill(fb.begin()+szb, fb.begin()+n, num(0));\n\t\tfft<num>::go(fa.begin(), n);\n\t\tfft<num>::go(fb.begin(), n);\n\t\tnum d = inv(num(n));\n\t\tfor (int i = 0; i < n; i++) fa[i] = fa[i] * fb[i] * d;\n\t\treverse(fa.begin()+1, fa.begin()+n);\n\t\tfft<num>::go(fa.begin(), n);\n\t\tcopy(fa.begin(), fa.begin()+s, io);\n\t}\n};\n\ntemplate <typename num>\nstruct fft_inverser {\n\ttemplate <typename IterA, typename IterOut>\n\tstatic void inverse(IterA ia, int sza, IterOut io) {\n\t\tvector<num>& fa = fft<num>::scratch_a;\n\t\tvector<num>& fb = fft<num>::scratch_b;\n\n\t\tif (sza == 0) return;\n\t\tint s = nextPow2(sza) * 2;\n\t\tfft<num>::init(s);\n\t\tif (sz(fa) < s) fa.resize(s);\n\t\tif (sz(fb) < s) fb.resize(s);\n\t\tfb[0] = inv(*ia);\n\t\tfor (int n = 1; n < sza; ) {\n\t\t\tfill(fb.begin() + n, fb.begin() + 4 * n, num(0));\n\t\t\tn *= 2;\n\t\t\tcopy(ia, ia+min(n,sza), fa.begin());\n\t\t\tfill(fa.begin()+min(n,sza), fa.begin()+2*n, 0);\n\t\t\tfft<num>::go(fb.begin(), 2*n);\n\t\t\tfft<num>::go(fa.begin(), 2*n);\n\t\t\tnum d = inv(num(2*n));\n\t\t\tfor (int i = 0; i < 2*n; i++) fb[i] = fb[i] * (2 - fa[i] * fb[i]) * d;\n\t\t\treverse(fb.begin()+1, fb.begin()+2*n);\n\t\t\tfft<num>::go(fb.begin(), 2*n);\n\t\t}\n\t\tcopy(fb.begin(), fb.begin()+sza, io);\n\t}\n};\n\ntemplate <typename dbl>\nstruct fft_double_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tvector<cplx<dbl>>& fa = fft<cplx<dbl>>::scratch_a;\n\t\tvector<cplx<dbl>>& fb = fft<cplx<dbl>>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<cplx<dbl>>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\n\t\tfill(fa.begin(), fa.begin() + n, 0);\n\t\t{ auto it = ia; for (int i = 0; i < sza; ++i, ++it) fa[i].x = *it; }\n\t\t{ auto it = ib; for (int i = 0; i < szb; ++i, ++it) fa[i].y = *it; }\n\t\tfft<cplx<dbl>>::go(fa.begin(), n);\n\t\tfor (auto& x : fa) x = x * x;\n\t\tfor (int i = 0; i < n; ++i) fb[i] = fa[(n-i)&(n-1)] - conj(fa[i]);\n\t\tfft<cplx<dbl>>::go(fb.begin(), n);\n\t\t{ auto it = io; for (int i = 0; i < s; ++i, ++it) *it = fb[i].y / (4*n); }\n\t}\n};\n\ntemplate <typename mnum>\nstruct fft_mod_multiplier {\n\ttemplate <typename IterA, typename IterB, typename IterOut>\n\tstatic void multiply(IterA ia, int sza, IterB ib, int szb, IterOut io) {\n\t\tusing cnum = cplx<double>;\n\t\tvector<cnum>& fa = fft<cnum>::scratch_a;\n\t\tvector<cnum>& fb = fft<cnum>::scratch_b;\n\n\t\tif (sza == 0 || szb == 0) return;\n\t\tint s = sza + szb - 1;\n\t\tint n = nextPow2(s);\n\t\tfft<cnum>::init(n);\n\t\tif (sz(fa) < n) fa.resize(n);\n\t\tif (sz(fb) < n) fb.resize(n);\n\n\t\t{ auto it = ia; for (int i = 0; i < sza; ++i, ++it) fa[i] = cnum(int(*it) & ((1<<15)-1), int(*it) >> 15); }\n\t\tfill(fa.begin()+sza, fa.begin() + n, 0);\n\t\t{ auto it = ib; for (int i = 0; i < szb; ++i, ++it) fb[i] = cnum(int(*it) & ((1<<15)-1), int(*it) >> 15); }\n\t\tfill(fb.begin()+szb, fb.begin() + n, 0);\n\n\t\tfft<cnum>::go(fa.begin(), n);\n\t\tfft<cnum>::go(fb.begin(), n);\n\t\tdouble r0 = 0.5 / n; // 1/2n\n\t\tfor (int i = 0; i <= n/2; i++) {\n\t\t\tint j = (n-i)&(n-1);\n\t\t\tcnum g0 = (fb[i] + conj(fb[j])) * r0;\n\t\t\tcnum g1 = (fb[i] - conj(fb[j])) * r0;\n\t\t\tswap(g1.x, g1.y); g1.y *= -1;\n\t\t\tif (j != i) {\n\t\t\t\tswap(fa[j], fa[i]);\n\t\t\t\tfb[j] = fa[j] * g1;\n\t\t\t\tfa[j] = fa[j] * g0;\n\t\t\t}\n\t\t\tfb[i] = fa[i] * conj(g1);\n\t\t\tfa[i] = fa[i] * conj(g0);\n\t\t}\n\t\tfft<cnum>::go(fa.begin(), n);\n\t\tfft<cnum>::go(fb.begin(), n);\n\t\tusing ll = long long;\n\t\tconst ll m = mnum::MOD;\n\t\tauto it = io;\n\t\tfor (int i = 0; i < s; ++i, ++it) {\n\t\t\t*it = mnum((ll(fa[i].x+0.5)\n\t\t\t\t\t\t+ (ll(fa[i].y+0.5) % m << 15)\n\t\t\t\t\t\t+ (ll(fb[i].x+0.5) % m << 15)\n\t\t\t\t\t\t+ (ll(fb[i].y+0.5) % m << 30)) % m);\n\t\t}\n\t}\n};\n\ntemplate <class multiplier, typename num>\nstruct multiply_inverser {\n\ttemplate <typename IterA, typename IterOut>\n\tstatic void inverse(IterA ia, int sza, IterOut io) {\n\t\tif (sza == 0) return;\n\t\tint s = nextPow2(sza);\n\t\tvector<num> b(s,num(0));\n\t\tvector<num> tmp(2*s);\n\t\tb[0] = inv(*ia);\n\t\tfor (int n = 1; n < sza; ) {\n\t\t\t// TODO: could be square instead of multiply\n\t\t\tmultiplier::multiply(b.begin(),n,b.begin(),n,tmp.begin());\n\t\t\tint nn = min(sza,2*n);\n\t\t\tmultiplier::multiply(tmp.begin(),nn,ia,nn,tmp.begin());\n\t\t\tfor (int i = n; i < nn; i++) b[i] = -tmp[i];\n\t\t\tn = nn;\n\t\t}\n\t\tcopy(b.begin(), b.begin()+sza, io);\n\t}\n};\n\ntemplate <class multiplier, typename T> vector<T> multiply(const vector<T>& a, const vector<T>& b) {\n\tif (sz(a) == 0 || sz(b) == 0) return {};\n\tvector<T> r(max(0, sz(a) + sz(b) - 1));\n\tmultiplier::multiply(begin(a), sz(a), begin(b), sz(b), begin(r));\n\treturn r;\n}\n\ntemplate <typename T> vector<T> fft_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_multiplier<T>, T>(a, b);\n}\ntemplate <typename T> vector<T> fft_double_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_double_multiplier<T>, T>(a, b);\n}\ntemplate <typename T> vector<T> fft_mod_multiply(const vector<T>& a, const vector<T>& b) {\n\treturn multiply<fft_mod_multiplier<T>, T>(a, b);\n}\n\ntemplate <class inverser, typename T> vector<T> inverse(const vector<T>& a) {\n\tvector<T> r(sz(a));\n\tinverser::inverse(begin(a), sz(a), begin(r));\n\treturn r;\n}\ntemplate <typename T> vector<T> fft_inverse(const vector<T>& a) {\n\treturn inverse<fft_inverser<T>, T>(a);\n}\ntemplate <typename T> vector<T> fft_double_inverse(const vector<T>& a) {\n\treturn inverse<multiply_inverser<fft_double_multiplier<T>, T>, T>(a);\n}\ntemplate <typename T> vector<T> fft_mod_inverse(const vector<T>& a) {\n\treturn inverse<multiply_inverser<fft_mod_multiplier<T>, T>, T>(a);\n}\n\n}} // namespace ecnerwala::fft\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n, k;\n\tcin >> n >> k;\n\tnum ans = 0;\n\n\tint f = min(n, k);\n\tvector<num> s1(f+1, 0);\n\tvector<num> sa(f+1, 0);\n\tfor(int a = 1; a <= f; a++){\n\t\tsa[a] = pow(num(a), k) * ifact[a];\n\t}\n\tfor(int i = 0; i <= f; i++){\n\t\ts1[i] = ifact[i] * pow(num(-1), i);\n\t}\n\tvector<num> res = ecnerwala::fft::multiply<ecnerwala::fft::fft_multiplier<num>>(s1, sa);\n\tnum ncb = 1;\n\tfor(int b = 1; b <= f; b++){\n\t\tncb *= (n+1 - b);\n\t\tncb /= b;\n\t\tans += res[b] * ncb * fact[b] * pow(num(n+1), n-b);\n\t}\n\tcout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "fft",
        "math"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. AmShZ Farm.json",
    "editorial_link": "https://codeforces.com//blog/entry/91058",
    "editorial": "Consider the following problem: cars want to enter a parking lot one by\r\none. The parking lot has slots numbered , the -th of the cars wants to\r\npark in the -th slot.When the -th car drives in, it will park in the\r\nfirst empty slot such that .An array is Good if all of the cars are\r\nparked in some slot after the end of the procedure.Good arrays can be\r\nmapped to more-equal arrays, because it can be proved that in any sorted\r\nGood array , same goes for the more-equal arrays.Now let\u00e2\u0080\u0099s modify the\r\nabove problem a bit, consider a circular parking lot with free slots.\r\ncars want to park in it, -th of which wants to park in the -th slot\r\n.When the -th car drives in, it will park in the first empty slot such\r\nthat is the first empty slot after (including) in the clockwise\r\ndirection.It\u00e2\u0080\u0099s obvious that one slot will be empty after the end of the\r\nprocedure, let\u00e2\u0080\u0099s call this slot .Arrays in which can also be mapped to\r\nmore-equal arrays, let them be good arrays. let the other arrays be\r\ncalled bad arrays (arrays in which ).Every good can mapped to bad\r\narrays, just add to all of elements of , formally speaking for each , .\r\nThis can also be viewed as a circular shift of the elements/final\r\npositions.Note that the number of arrays compatible with stays the same\r\nin this proccess.Thus the number of bad arrays is equal to of all the\r\npossible arrays.We know that , assume , let\u00e2\u0080\u0099s fix , let be the number of\r\noccurrences of in . The number of compatible arrays such that is equal\r\nto .So the number of pairs of arrays and where is a compatible array\r\nwith the more-equal array is equal to .There are ways to choose , also\r\nwe had to divide the result by because we were previously counting bad\r\narrays as well, so we can simplify both of this terms with each\r\nother.The sum mentioned above is equal to , where refers to Stirling\r\nnumbers of the second kind. All of can be found in using FFT.So overall\r\nwe can solve the task in .\r\n"
}