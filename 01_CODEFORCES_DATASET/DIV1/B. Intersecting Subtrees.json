{
    "link": "https://codeforces.com//contest/1074/problem/B",
    "problemId": "249087",
    "problem_idx": "B",
    "shortId": "1074B",
    "contest_number": "1074",
    "problem_submissions": {
        "E": [
            45303620,
            45300249,
            45344571,
            45304718,
            45304862,
            45306309,
            45306510,
            45315681,
            45302002,
            45303642
        ],
        "F": [
            45297925,
            45302412,
            45298748,
            45300083,
            45299480,
            45298818,
            45299827,
            45300561,
            45300985,
            45300910,
            45302087,
            45302359,
            45302549,
            45302342,
            45306149,
            45302208,
            45303449,
            45304102,
            45303226
        ],
        "D": [
            45294973,
            45293128,
            45295261,
            45296109,
            45292313,
            45291734,
            45297119,
            45297694,
            45297259,
            45298710,
            45297635,
            45297369,
            45298399,
            45297846,
            45294290,
            45297091,
            45296770,
            45296596,
            45297365,
            45299859
        ],
        "C": [
            45293553,
            45291475,
            45293844,
            45294044,
            45293914,
            45294012,
            45293608,
            45295772,
            45294886,
            45297284,
            45296110,
            45294396,
            45293720,
            45296080,
            45292596,
            45294430,
            45294994,
            45295210,
            45294620,
            45296058
        ],
        "B": [
            45292377,
            45294890,
            45292284,
            45297195,
            45296274,
            45295787,
            45291944,
            45293450,
            45293244,
            45294291,
            45295233,
            45293263,
            45291573,
            45294870,
            45303353,
            45293540,
            45298407,
            45293034,
            45292582,
            45292571
        ],
        "A": [
            45289520,
            45289825,
            45289616,
            45289578,
            45294985,
            45294783,
            45289998,
            45290374,
            45289949,
            45291060,
            45291837,
            45290090,
            45295330,
            45290627,
            45290102,
            45291029,
            45290582,
            45297889,
            45289941,
            45289786
        ]
    },
    "name": "B. Intersecting Subtrees",
    "statement": "You are playing a strange game with Li Chen. You have a tree with n\r\nnodes drawn on a piece of paper. All nodes are unlabeled and\r\ndistinguishable. Each of you labeled the vertices from 1 to n. Neither\r\nof you know the other\u2019s labelling of the tree.You and Li Chen each chose\r\na subtree (i.e., a connected subgraph) in that tree. Your subtree\r\nconsists of the vertices labeled x_1, x_2,\r\nldots, x_{k_1} in , Li Chen\u2019s subtree consists of the vertices labeled\r\ny_1, y_2,\r\nldots, y_{k_2} in . The values of x_1, x_2,\r\nldots, x_{k_1} and y_1, y_2,\r\nldots, y_{k_2} are known to both of you. You want to determine whether\r\nyour subtrees have at least one common vertex. Luckily, your friend\r\nAndrew knows both labelings of the tree. You can ask Andrew at most 5\r\nquestions, each of which is in one of the following two forms: : Andrew\r\nwill look at vertex x in your labeling and tell you the number of this\r\nvertex in Li Chen\u2019s labeling. : Andrew will look at vertex y in Li\r\nChen\u2019s labeling and tell you the number of this vertex in your labeling.\r\nDetermine whether the two subtrees have at least one common vertex after\r\nasking some questions. If there is at least one common vertex, determine\r\none of your labels for any of the common vertices.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint n;\nvi graf[nax];\n\nvi moje, jego;\n\nvi read()\n{\n\tvi ret;\n\tint x, y;\n\tscanf(\"%d\", &x);\n\twhile(x--)\n\t{\n\t\tscanf(\"%d\", &y);\n\t\tret.push_back(y);\n\t}\n\treturn ret;\n}\n\nint czyw(vi &wek, int v)\n{\n\tfor (int i : wek)\n\t\tif (i==v)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nint dfs(int v, int oj)\n{\n\tif (czyw(moje, v))\n\t{\n\t\tprintf(\"A %d\\n\", v);\n\t\tff();\n\t\tint w;\n\t\tscanf(\"%d\", &w);\n\t\tif (czyw(jego, w))\n\t\t\treturn v;\n\t\treturn -1;\n\t}\n\tfor (int i : graf[v])\n\t{\n\t\tif (i!=oj)\n\t\t{\n\t\t\tint x=dfs(i, v);\n\t\t\tif (x>0)\n\t\t\t\treturn x;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid test()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tgraf[i].clear();\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tmoje=read();\n\tjego=read();\n\tprintf(\"B %d\\n\", jego[0]);\n\tff();\n\tint x;\n\tscanf(\"%d\", &x);\n\t//~ if (czyw(moje, x))\n\t//~ {\n\t\t//~ printf(\"C %d\\n\", x);\n\t\t//~ ff();\n\t\t//~ return;\n\t//~ }\n\tint w=dfs(x, 0);\n\tprintf(\"C %d\\n\", w);\n\tff();\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "interactive",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Intersecting Subtrees.json",
    "editorial_link": "https://codeforces.com//blog/entry/62985",
    "editorial": "I\u00e2\u0080\u0099ll split this into two parts, first is the solution, second is why it\r\nworks.The intended solution only uses two questions. Choose an arbitrary\r\n, and ask \"\". Let the response be . Find a node that is the closest to\r\nnode . This can be done with a BFS or DFS. Ask \"\". Let the response be .\r\nIf is one of , print \"\", otherwise, print \"\". Here is why it works.\r\nLet\u00e2\u0080\u0099s use the fact that if the two subtrees don\u00e2\u0080\u0099t intersect, there is an\r\nedge in the tree such that if we cut the tree on this edge, it will\r\nsplit it into two components, each containing one of the\r\nsubtrees.Suppose we did step 1 and we have . Let\u00e2\u0080\u0099s root our tree at .\r\nThere is a unique node that has lowest depth in this tree which we can\r\nfind (given that form a subtree).Now, we claim that the two subtrees\r\nintersect if and only if Li Chen owns a node that lies in the subtree\r\nrooted by (and in particular, we will show it is sufficient to only\r\ncheck node ).If none of Li Chen\u00e2\u0080\u0099s nodes lie in the subtree rooted by ,\r\nthen the edge to its parent cuts the tree into two components with one\r\nsubtree completely lying in one component and the other in the second,\r\nso the two subtrees are disjoint.Otherwise, there is a node that is in\r\nLi Chen\u00e2\u0080\u0099s subtree that lies in the subtree rooted by . All nodes in the\r\npath of to must also belong to Li Chen\u00e2\u0080\u0099s subtree, and in particular this\r\nincludes node , so the two trees intersect. This also shows we can just\r\ncheck if belongs in Li Chen\u00e2\u0080\u0099s subtree by asking a question about it.\r\n"
}