{
    "link": "https://codeforces.com//contest/993/problem/B",
    "problemId": "190655",
    "problem_idx": "B",
    "shortId": "993B",
    "contest_number": "993",
    "problem_submissions": {
        "F": [
            39315278,
            39320695,
            39316458,
            39677099
        ],
        "E": [
            39303954,
            44679848,
            44679803,
            39298654,
            39318832,
            39301524,
            39298924,
            39298197,
            39302275,
            39302298,
            39298229,
            39298156,
            39300839,
            39300092,
            39352453,
            39352393,
            39352354,
            39303455,
            39304019,
            39307250,
            39300445,
            39304215,
            39295908,
            39310154
        ],
        "D": [
            39301603,
            39306272,
            39305543,
            39303758,
            39301872,
            39306720,
            39307619,
            39312577,
            39306349,
            39308036,
            39310122,
            39446648,
            39311312,
            39310199,
            39311258,
            39311908,
            39309211,
            39312503,
            41629328,
            39305033
        ],
        "C": [
            39298935,
            39297300,
            39298508,
            39300315,
            39304660,
            39297439,
            39298052,
            39296218,
            39303022,
            39303419,
            39304668,
            39300073,
            39299818,
            39298805,
            39302281,
            39300110,
            39306526,
            39299493
        ],
        "B": [
            39297062,
            39295065,
            39295700,
            39296902,
            39295145,
            39299299,
            39296202,
            39294546,
            39301730,
            39301559,
            39302344,
            39295884,
            39296798,
            39301508,
            39306228,
            39297394,
            39303701,
            39296320
        ],
        "A": [
            39295010,
            39292992,
            39292988,
            39294233,
            39305393,
            39293507,
            39294073,
            39292365,
            39300142,
            39294094,
            39296117,
            39292842,
            39294818,
            39295302,
            39304183,
            39295611,
            39298852,
            39293790
        ]
    },
    "name": "B. Open Communication",
    "statement": "Two participants are each given a pair of distinct numbers from 1 to 9\r\nsuch that there\u2019s exactly one number that is present in both pairs. They\r\nwant to figure out the number that matches by using a communication\r\nchannel you have access to without revealing it to you.Both participants\r\ncommunicated to each other a set of pairs of numbers, that includes the\r\npair given to them. Each pair in the communicated sets comprises two\r\ndifferent numbers.Determine if you can with certainty deduce the common\r\nnumber, or if you can determine with certainty that both participants\r\nknow the number but you do not.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nint n, m;\nint a[20][2];\nint b[20][2];\nbool canBe[10];\n\nint solve(int A, int B, int C, int D) {\n\tif (A == C && B == D) return -1;\n\tif (A == C) return A;\n\tif (A == D) return A;\n\tif (B == C) return B;\n\tif (B == D) return B;\n\treturn -1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\tif (a[i][0] > a[i][1]) swap(a[i][0], a[i][1]);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\tif (b[i][0] > b[i][1]) swap(b[i][0], b[i][1]);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = solve(a[i][0], a[i][1], b[j][0], b[j][1]);\n\t\t\tif (x != -1)\n\t\t\t\tcanBe[x] = 1;\n\t\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < 10; i++)\n\t\tcnt += canBe[i];\n\tif (cnt == 0) throw;\n\tif (cnt == 1) {\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tif (canBe[i])\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint ans = -1;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = solve(a[i][0], a[i][1], b[j][0], b[j][1]);\n\t\t\tif (x == -1) continue;\n\t\t\tif (ans == -1) ans = x;\n\t\t\tif (ans != x) ans = -2;\n\t\t}\n\t\tif (ans == -2) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint ans = -1;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint x = solve(a[j][0], a[j][1], b[i][0], b[i][1]);\n\t\t\tif (x == -1) continue;\n\t\t\tif (ans == -1) ans = x;\n\t\t\tif (ans != x) ans = -2;\n\t\t}\n\t\tif (ans == -2) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"0\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Open Communication.json",
    "editorial_link": "https://codeforces.com//blog/entry/60047",
    "editorial": "One way to approach this problem is to\n\n1. Iterate over each pair p1\n communicated by the first participant, and do the following:\n\nIterate over all pairs p2\n of the second participant that are not equal to p1\n and count whether the first number of p1\n appears in any of them and whether the second number of p1\n appears in any of them. If only one of them appears, that number is a candidate to be the matching number. If after iterating over all pairs communicated by the first participant only one candidate number was observed, then we know with certainty that that number is the one, and can immediately return it.\n\n2. Do (1) but iterating over the numbers communicated by the second participant in the outer loop.\n\n3. If at this point no number was returned, the answer is either -1 or 0. It is -1 iff for some pair (a,b)\n communicated by one of the participants, there are both pairs (a,c)\n and (b,d)\n among pairs communicated by the other participants, such that c?b\n and d?a\n (but possibly c=d\n), since in that case if the first participant indeed has the pair (a,b)\n, they can't tell whether the actual number is a\n or b\n. Otherwise the answer is 0."
}