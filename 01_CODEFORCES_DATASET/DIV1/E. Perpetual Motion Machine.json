{
    "link": "https://codeforces.com//contest/830/problem/E",
    "problemId": "114246",
    "problem_idx": "E",
    "shortId": "830E",
    "contest_number": "830",
    "problem_submissions": {
        "D": [
            28594647,
            28515632,
            28517135,
            28522787,
            28518930,
            28520136,
            28522520,
            28522651,
            28522385,
            28521029,
            28522173,
            28931336,
            28518846,
            28520792,
            28518779,
            28524006,
            28523790,
            28523582,
            28514145,
            28518855
        ],
        "E": [
            28524957,
            28527227,
            28776493,
            28776475,
            31868930,
            28528205
        ],
        "C": [
            28513312,
            28514258,
            28526449,
            28512880,
            28515933,
            28516073,
            28513800,
            28513739,
            28515967,
            28518241,
            29799228,
            29796538,
            28519327,
            28516487,
            28931386,
            28515691,
            28524374,
            28513589,
            28518503,
            28515655,
            28517033,
            28528492,
            28534968
        ],
        "B": [
            28508342,
            28509379,
            28507817,
            28511318,
            28509260,
            28508546,
            28510695,
            28510689,
            30628707,
            30615033,
            30614998,
            28512995,
            28509425,
            28513558,
            28509785,
            28511054,
            28519867,
            28511755,
            28512387,
            28511965,
            28515860,
            28511432
        ],
        "A": [
            28506433,
            28506738,
            28506322,
            28516214,
            28513064,
            28506171,
            28506332,
            28506901,
            28509003,
            28511010,
            28512266,
            28526236,
            28507144,
            28507136,
            28519649,
            28517536,
            28508069
        ]
    },
    "name": "E. Perpetual Motion Machine",
    "statement": "Developer Petr thinks that he invented a perpetual motion machine.\r\nNamely, he has a lot of , which work in the following way.Each element\r\nhas one controller that can be set to any non-negative real value. If a\r\ncontroller is set on some value , then the controller consumes energy\r\nunits per second. At the same time, any two elements connected by a wire\r\nproduce energy units per second, where and are the values set on their\r\ncontrollers.Petr has only a limited number of wires, so he has already\r\nbuilt some scheme of elements and wires, and is now interested if it’s\r\npossible to set the controllers in such a way that the system produces\r\npower as it consumes, and at least one controller is set on the value\r\ndifferent from . Help him check this, and if it’s possible, find the\r\nrequired values that should be set.It is guaranteed that if there exist\r\ncontrollers’ settings satisfying the above conditions, then there exist\r\nrequired integer values not greater than .\r\n",
    "solutions": [
        "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstruct bian{\n\tint next,point;\n}b[210000];\nint p[110000],d[110000],n,m,pd[110000],len,ans[110000];\nvector<int>A,x[10];\nint compare(vector<int>A,vector<int>B){\n\treturn A.size()<B.size();\n}\nvoid ade(int k1,int k2){\n\tb[++len]=(bian){p[k1],k2}; p[k1]=len; d[k1]++;\n}\nvoid add(int k1,int k2){\n\tade(k1,k2); ade(k2,k1);\n}\nvoid dfs(int k){\n\tpd[k]=1; A.push_back(k);\n\tfor (int i=p[k];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (pd[j]==0) dfs(j);\n\t}\n}\nvoid print(){\n\tprintf(\"YES\\n\");\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]); printf(\"\\n\");\n}\nvoid dfs2(int k1,int k2,int k3){\n\tx[k3].push_back(k1);\n\tfor (int i=p[k1];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (j!=k2) dfs2(j,k1,k3);\n\t}\n}\nint solveextra(int k){\n\tint tot=0;\n\tfor (int i=0;i<3;i++) x[i].clear();\n\tfor (int i=p[k];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tdfs2(j,k,tot); tot++;\n\t}\n\tsort(x,x+3,compare);\n\tint a=x[0].size(),b=x[1].size(),c=x[2].size();\n//\tcout<<\"fa \"<<k<<\" \"<<a<<\" \"<<b<<\" \"<<c<<endl; \n\tint lima=0,limb=0,limc=0;\n\tif (a>1&&b>1&&c>1){\n\t\tlima=3; limb=3; limc=3;\n\t} else if (a==1&&b==1) return 0;\n\telse {\n\t\tlima=2;\n\t\tint flag=0;\n\t\tfor (int i=2;i<=b+1;i++){\n\t\t\tdouble now=1/4.0+1.0*(i-1)/2/i+(1.0)*(c)/2/(c+1);\n\t\t//\tcout<<\"fa \"<<i<<\" \"<<c<<\" \"<<now<<endl;\n\t\t\tif (now+1e-9>1){\n\t\t\t\tlimb=i; limc=c+1; flag=1; break;\n\t\t\t}\n\t\t}\n\t\tif (flag==0) return 0;\n\t}\n\ttot=lima;\n\ttot=tot*limb/__gcd(tot,limb);\n\ttot=tot*limc/__gcd(tot,limc);\n\tans[k]=tot; int lim[3];\n\tlim[0]=lima; lim[1]=limb; lim[2]=limc;\n\tfor (int i=0;i<3;i++){\n\t\tint K=tot/lim[i];\n\t\tfor (int j=0;j<x[i].size();j++){\n\t\t\tans[x[i][j]]=max(1ll*K,tot-1ll*K*(j+1));\n\t\t}\n\t}\n\tprint(); return 1;\n}\nvoid solve(){\n\tscanf(\"%d%d\",&n,&m); len=0;\n\tfor (int i=1;i<=n;i++) p[i]=d[i]=pd[i]=ans[i]=0;\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2);\n\t\tadd(k1,k2);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (pd[i]==0){\n\t\t\tA.clear();\n\t\t\tdfs(i); int totm=0;\n\t\t\tfor (int j=0;j<A.size();j++) totm+=d[A[j]];\n\t\t\ttotm/=2; //cout<<totm<<\" \"<<A.size()<<endl;\n\t\t\tif (totm>=A.size()){\n\t\t\t\tfor (int j=0;j<A.size();j++) ans[A[j]]=1;\n\t\t\t\tprint(); return;\n\t\t\t}\n\t\t\tint num=0;\n\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\tif (d[A[j]]==1) num++;\n\t\t\tif (num>=4){\n\t\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\t\tif (d[A[j]]==1) ans[A[j]]=1; else ans[A[j]]=2;\n\t\t\t\tprint(); return;\n\t\t\t}\n\t\t\tif (num==3){\n\t\t\t\tint where=0;\n\t\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\t\tif (d[A[j]]==3) where=A[j];\n\t\t\t\tif (solveextra(where)) return;\n\t\t\t}\n\t\t}\n\tprintf(\"NO\\n\");\n}\nint main(){\n\tint t; scanf(\"%d\",&t);\n\tfor (;t;t--) solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "graphs",
        "implementation",
        "math",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\E. Perpetual Motion Machine.json",
    "editorial_link": "https://codeforces.com//blog/entry/53302",
    "editorial": "By default, all vertices contain . We will solve problem in few steps,\r\ngetting answer for our question in different cases. Graph contains\r\ncycle. In this case, solution exists, all vertices of cycle contain ,\r\nsum would be . Graph contains vertex with degree more than . Solution\r\nexists, this vertex has and its neighbours . Sum will be when . Graph\r\ncontains more than one vertex of degree . In this case we can reduce to\r\nprevious case: we put in the between these vertices and ones in other\r\nneighboors. Doing this, we \"contract\" path between vertices to one with\r\nthe number and obtain vertex of degree . Graph contains just one vertex\r\nof degree . It is the most complicated point in our solution. We just\r\nstate this and prove it later.: There is only one vertex with degree ,\r\nwith âtailsâ of sizes , (length of the tail = how many vertices lay on\r\nit). In this case expression can take only non-positive values if . All\r\ngraphâs vertices have degree less than . This case can be easily reduced\r\nto previous one, having . We are going to prove this by two ways.: Letâs\r\nlook on tail, sized , having form of the bamboo. Numbers in vertices are\r\nand have sum . We are going to minimize . As one can see,Let , , , ,\r\n..., . While So we have and we want to choose numbers with sum so that\r\nsum of their squares is as small as possible. One can prove, that best\r\nchoice is , while having sum . In this case .We will use induction for\r\nproof. Base () is evident. Step : optimal sum of squares if one of\r\nnumbers is . We shall minmize this function. This is nearly equal to\r\nderivative being zero. , what we wanted to prove.Now we get back to\r\nconstruction where are three tails of sizes , are connected to 3-degree\r\nvertex. Number in 3-degree vertex is , value of the whole graph is , and\r\nvalues of tails are , . . If we fix , when, as it was shown before\r\noptimal values of tails are i, , . We have . It means that can be only\r\nif .:Let the tail of size have numbers in vertices counting from the\r\nleaf, size - , size - . Root we will define as .Let We want to compute\r\n.One can see that Actually, if we calculate this expression, we will\r\nhave Each term with features once on both adjacent terms and gives the\r\nsum When, Because all , we should have other expression not greater than\r\nzero. However, , because in this case for having all squares zero all\r\nnumbers would be zero. Because of this, . :Necessity of this criterion\r\nis proved. Sufficiency can be seen from definition in the second proof -\r\nwe should put arithmetic progressions on all tails.In case of graph\r\nhaving form of bamboo, we have , equal to while , what is obviously\r\nimpossible. So answer is always .All mentioned above is made with few\r\ndepth-first searches, so complexity of this solution is .\r\n",
    "hint": []
}