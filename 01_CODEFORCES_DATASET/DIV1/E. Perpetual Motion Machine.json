{"link": "https://codeforces.com//contest/830/problem/E", "problemId": "114246", "problem_idx": "E", "shortId": "830E", "contest_number": "830", "problem_submissions": {"D": [28594647, 28515632, 28517135, 28522787, 28518930, 28520136, 28522520, 28522651, 28522385, 28521029, 28522173, 28931336, 28518846, 28520792, 28518779, 28524006, 28523790, 28523582, 28514145, 28518855], "E": [28524957, 28527227, 28776493, 28776475, 31868930, 28528205], "C": [28513312, 28514258, 28526449, 28512880, 28515933, 28516073, 28513800, 28513739, 28515967, 28518241, 29799228, 29796538, 28519327, 28516487, 28931386, 28515691, 28524374, 28513589, 28518503, 28515655, 28517033, 28528492, 28534968], "B": [28508342, 28509379, 28507817, 28511318, 28509260, 28508546, 28510695, 28510689, 30628707, 30615033, 30614998, 28512995, 28509425, 28513558, 28509785, 28511054, 28519867, 28511755, 28512387, 28511965, 28515860, 28511432], "A": [28506433, 28506738, 28506322, 28516214, 28513064, 28506171, 28506332, 28506901, 28509003, 28511010, 28512266, 28526236, 28507144, 28507136, 28519649, 28517536, 28508069]}, "name": "E. Perpetual Motion Machine", "statement": "Developer Petr thinks that he invented a perpetual motion machine.\r\nNamely, he has a lot of , which work in the following way.Each element\r\nhas one controller that can be set to any non-negative real value. If a\r\ncontroller is set on some value , then the controller consumes energy\r\nunits per second. At the same time, any two elements connected by a wire\r\nproduce energy units per second, where and are the values set on their\r\ncontrollers.Petr has only a limited number of wires, so he has already\r\nbuilt some scheme of elements and wires, and is now interested if it\u2019s\r\npossible to set the controllers in such a way that the system produces\r\npower as it consumes, and at least one controller is set on the value\r\ndifferent from . Help him check this, and if it\u2019s possible, find the\r\nrequired values that should be set.It is guaranteed that if there exist\r\ncontrollers\u2019 settings satisfying the above conditions, then there exist\r\nrequired integer values not greater than .\r\n", "solutions": ["#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstruct bian{\n\tint next,point;\n}b[210000];\nint p[110000],d[110000],n,m,pd[110000],len,ans[110000];\nvector<int>A,x[10];\nint compare(vector<int>A,vector<int>B){\n\treturn A.size()<B.size();\n}\nvoid ade(int k1,int k2){\n\tb[++len]=(bian){p[k1],k2}; p[k1]=len; d[k1]++;\n}\nvoid add(int k1,int k2){\n\tade(k1,k2); ade(k2,k1);\n}\nvoid dfs(int k){\n\tpd[k]=1; A.push_back(k);\n\tfor (int i=p[k];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (pd[j]==0) dfs(j);\n\t}\n}\nvoid print(){\n\tprintf(\"YES\\n\");\n\tfor (int i=1;i<=n;i++) printf(\"%d \",ans[i]); printf(\"\\n\");\n}\nvoid dfs2(int k1,int k2,int k3){\n\tx[k3].push_back(k1);\n\tfor (int i=p[k1];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tif (j!=k2) dfs2(j,k1,k3);\n\t}\n}\nint solveextra(int k){\n\tint tot=0;\n\tfor (int i=0;i<3;i++) x[i].clear();\n\tfor (int i=p[k];i;i=b[i].next){\n\t\tint j=b[i].point;\n\t\tdfs2(j,k,tot); tot++;\n\t}\n\tsort(x,x+3,compare);\n\tint a=x[0].size(),b=x[1].size(),c=x[2].size();\n//\tcout<<\"fa \"<<k<<\" \"<<a<<\" \"<<b<<\" \"<<c<<endl; \n\tint lima=0,limb=0,limc=0;\n\tif (a>1&&b>1&&c>1){\n\t\tlima=3; limb=3; limc=3;\n\t} else if (a==1&&b==1) return 0;\n\telse {\n\t\tlima=2;\n\t\tint flag=0;\n\t\tfor (int i=2;i<=b+1;i++){\n\t\t\tdouble now=1/4.0+1.0*(i-1)/2/i+(1.0)*(c)/2/(c+1);\n\t\t//\tcout<<\"fa \"<<i<<\" \"<<c<<\" \"<<now<<endl;\n\t\t\tif (now+1e-9>1){\n\t\t\t\tlimb=i; limc=c+1; flag=1; break;\n\t\t\t}\n\t\t}\n\t\tif (flag==0) return 0;\n\t}\n\ttot=lima;\n\ttot=tot*limb/__gcd(tot,limb);\n\ttot=tot*limc/__gcd(tot,limc);\n\tans[k]=tot; int lim[3];\n\tlim[0]=lima; lim[1]=limb; lim[2]=limc;\n\tfor (int i=0;i<3;i++){\n\t\tint K=tot/lim[i];\n\t\tfor (int j=0;j<x[i].size();j++){\n\t\t\tans[x[i][j]]=max(1ll*K,tot-1ll*K*(j+1));\n\t\t}\n\t}\n\tprint(); return 1;\n}\nvoid solve(){\n\tscanf(\"%d%d\",&n,&m); len=0;\n\tfor (int i=1;i<=n;i++) p[i]=d[i]=pd[i]=ans[i]=0;\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2);\n\t\tadd(k1,k2);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (pd[i]==0){\n\t\t\tA.clear();\n\t\t\tdfs(i); int totm=0;\n\t\t\tfor (int j=0;j<A.size();j++) totm+=d[A[j]];\n\t\t\ttotm/=2; //cout<<totm<<\" \"<<A.size()<<endl;\n\t\t\tif (totm>=A.size()){\n\t\t\t\tfor (int j=0;j<A.size();j++) ans[A[j]]=1;\n\t\t\t\tprint(); return;\n\t\t\t}\n\t\t\tint num=0;\n\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\tif (d[A[j]]==1) num++;\n\t\t\tif (num>=4){\n\t\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\t\tif (d[A[j]]==1) ans[A[j]]=1; else ans[A[j]]=2;\n\t\t\t\tprint(); return;\n\t\t\t}\n\t\t\tif (num==3){\n\t\t\t\tint where=0;\n\t\t\t\tfor (int j=0;j<A.size();j++)\n\t\t\t\t\tif (d[A[j]]==3) where=A[j];\n\t\t\t\tif (solveextra(where)) return;\n\t\t\t}\n\t\t}\n\tprintf(\"NO\\n\");\n}\nint main(){\n\tint t; scanf(\"%d\",&t);\n\tfor (;t;t--) solve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "dp", "graphs", "implementation", "math", "trees"], "dificulty": "3100", "interactive": false}