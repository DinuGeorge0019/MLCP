{
    "link": "https://codeforces.com//contest/1500/problem/B",
    "problemId": "922993",
    "problem_idx": "B",
    "shortId": "1500B",
    "contest_number": "1500",
    "problem_submissions": {
        "F": [
            109882523,
            156894272,
            156888570,
            109926929,
            109926191,
            109893056,
            109892507,
            110407942
        ],
        "E": [
            109869658,
            109880186,
            109882627,
            109869772,
            109883572,
            110177251,
            112227681,
            112227008,
            112226855
        ],
        "C": [
            109851937,
            109858563,
            109855424,
            109847448,
            109897897,
            109858583,
            109868120,
            109862817,
            109862820,
            109847704,
            109864051,
            109866901,
            109862545,
            109862473,
            109864278,
            109866655,
            109866161,
            109873497,
            109866235,
            109876064
        ],
        "A": [
            109847522,
            109845877,
            109846878,
            109889115,
            109845620,
            109845386,
            109845664,
            109845260,
            109853758,
            109847140,
            109849368,
            109845237,
            109845429,
            109846259,
            109846562,
            109868273,
            109864425,
            109846842,
            109854328
        ],
        "B": [
            109845439,
            109853012,
            109858233,
            109878921,
            109849145,
            109848615,
            109856685,
            109852114,
            109880910,
            109854120,
            109859099,
            109849597,
            109849728,
            109854205,
            109854819,
            109853965,
            109859327,
            109857020,
            109863440
        ],
        "D": [
            109866969,
            109867253,
            109854472,
            109863287,
            109861346,
            109868138,
            109875304,
            109871552,
            109879597,
            109878283,
            109877726,
            109880816,
            109873581,
            109879840,
            109875506,
            109884990,
            109881921,
            109883609
        ]
    },
    "name": "B. Two chandeliers",
    "statement": "Vasya is a CEO of a big construction company. And as any other big boss\r\nhe has a spacious, richly furnished office with two crystal chandeliers.\r\nTo stay motivated Vasya needs the color of light at his office to change\r\nevery day. That\u2019s why he ordered both chandeliers that can change its\r\ncolor cyclically. For example: red brown yellow red brown yellow and so\r\non. There are many chandeliers that differs in color set or order of\r\ncolors. And the person responsible for the light made a critical mistake\r\nthey bought two different chandeliers.Since chandeliers are different,\r\nsome days they will have the same color, but some days different. Of\r\ncourse, it looks poor and only annoys Vasya. As a result, at the k-th\r\ntime when chandeliers will light with different colors, Vasya will\r\nbecome very angry and, most probably, will fire the person who bought\r\nchandeliers.Your task is to calculate the day, when it happens (counting\r\nfrom the day chandeliers were installed). You can think that Vasya works\r\nevery day without weekends and days off.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 13.03.2021 12:07:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  T p = b / a;\n  T g = extgcd(b - p * a, a, y, x);\n  x -= p * y;\n  return g;\n}\n\ntemplate<typename T>\nbool diophantine(T a, T b, T c, T &x, T &y, T &g) {\n  if (a == 0 && b == 0) {\n    if (c == 0) {\n      x = y = g = 0;\n      return true;\n    }\n    return false;\n  }\n  if (a == 0) {\n    if (c % b == 0) {\n      x = 0;\n      y = c / b;\n      g = abs(b);\n      return true;\n    }\n    return false;\n  }\n  if (b == 0) {\n    if (c % a == 0) {\n      x = c / a;\n      y = 0;\n      g = abs(a);\n      return true;\n    }\n    return false;\n  }\n  g = extgcd(a, b, x, y);\n  if (c % g != 0) {\n    return false;\n  }\n  T dx = c / a;\n  c -= dx * a;\n  T dy = c / b;\n  c -= dy * b;\n  x = dx + (T) ((__int128) x * (c / g) % b);\n  y = dy + (T) ((__int128) y * (c / g) % a);\n  g = abs(g);\n  return true;\n  // |x|, |y| <= max(|a|, |b|, |c|) [tested]\n}\n\nbool crt(long long k1, long long m1, long long k2, long long m2, long long &k, long long &m) {\n  k1 %= m1;\n  if (k1 < 0) k1 += m1;\n  k2 %= m2;\n  if (k2 < 0) k2 += m2;\n  long long x, y, g;\n  if (!diophantine(m1, -m2, k2 - k1, x, y, g)) {\n    return false;\n  }\n  long long dx = m2 / g;\n  long long delta = x / dx - (x % dx < 0);\n  k = m1 * (x - dx * delta) + k1;\n  m = m1 / g * m2;\n  assert(0 <= k && k < m);\n  return true;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  long long k;\n  cin >> n >> m >> k;\n  int sz = 2 * max(n, m);\n  vector<int> pa(sz, -1);\n  vector<int> pb(sz, -1);\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    --a[i];\n    pa[a[i]] = i;\n  }\n  vector<int> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n    --b[i];\n    pb[b[i]] = i;\n  }\n  vector<long long> good;\n  long long md = -1;\n  for (int i = 0; i < sz; i++) {\n    if (pa[i] != -1 && pb[i] != -1) {\n      long long x, y;\n      if (crt(pa[i], n, pb[i], m, x, y)) {\n        good.push_back(x);\n        assert(md == -1 || md == y);\n        md = y;\n      }\n    }\n  }\n  if (md == -1) {\n    cout << k << '\\n';\n    return 0;\n  }\n  sort(good.begin(), good.end());\n  good.resize(unique(good.begin(), good.end()) - good.begin());\n  long long low = 0, high = (long long) 4e18;\n  while (low < high) {\n    long long mid = (low + high) >> 1;\n    long long cc = mid;\n    cc -= (mid / md) * (long long) good.size();\n    long long r = mid % md;\n    for (long long x : good) {\n      if (x < r) {\n        cc -= 1;\n      }\n    }\n    if (cc >= k) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n  cout << low << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "chinese remainder theorem",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Two chandeliers.json",
    "editorial_link": "https://codeforces.com//blog/entry/88591",
    "editorial": "A formal statement of the problem: there are two sequences of distinct\r\nintegers, whose are infinitely cycled. You need to find prefix of\r\nminimal length which contains exactly positions such that .Let\u00e2\u0080\u0099s notice\r\nthat we can use binary search. So we need to count number of positions\r\nsuch that on prefix of length .Because all integers in are distinct (and\r\nalso in ), we need to calculate number of non-negative solutions: If and\r\nare coprime, the value can be calculated with Chinese remainder theorem.\r\nSolution\u00e2\u0080\u0099s complexity will be .If and are not coprime, participant can\r\nmake transition , solve new equations, and then make reverse\r\ntransition.After that, you need to optimize this solution. There are\r\nmany ways to do this, for example, you can precalculate solutions of all\r\nequations. And complexity becomes\r\n"
}