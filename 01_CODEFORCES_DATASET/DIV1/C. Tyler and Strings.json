{
    "link": "https://codeforces.com//contest/1648/problem/C",
    "problemId": "1318591",
    "problem_idx": "C",
    "shortId": "1648C",
    "contest_number": "1648",
    "problem_submissions": {
        "E": [
            148585486,
            148584955,
            148581597,
            148589473,
            148591135,
            148593463,
            148593416,
            148597505,
            148594995,
            148595032,
            148597135,
            148605923,
            148598836,
            148596396,
            148600942,
            148602000,
            148600796,
            148581620,
            148583646,
            148661874,
            148661844,
            148587369
        ],
        "D": [
            148564585,
            148566578,
            148571497,
            148568116,
            148573822,
            148573519,
            148574211,
            148573964,
            148574945,
            148580191,
            148578139,
            148578497,
            148607894,
            148582725,
            148577475,
            148577301,
            148585962,
            148619534,
            148575997,
            148608357
        ],
        "C": [
            148552509,
            148552464,
            148553813,
            148558198,
            148558432,
            148554501,
            148557954,
            148555117,
            148558520,
            148556243,
            148554082,
            148553770,
            148555702,
            148554883,
            148560099,
            148557117,
            148552206,
            148558570,
            148554233,
            148559666
        ],
        "B": [
            148545010,
            148546110,
            148555976,
            148548495,
            148550449,
            148545480,
            148551044,
            148549564,
            148551420,
            148544796,
            148546968,
            148558793,
            148547056,
            148545781,
            148549549,
            148547973,
            148544722,
            148548048,
            148546238,
            148550231
        ],
        "A": [
            148541636,
            148541670,
            148541532,
            148543210,
            148543257,
            148541615,
            148546248,
            148544655,
            148547990,
            148541584,
            148542460,
            148542006,
            148542056,
            148542119,
            148542975,
            148543237,
            148541644,
            148542337,
            148541655,
            148542140
        ],
        "F": [
            148613542,
            151414821,
            211208832,
            211208769,
            211208727,
            211208586
        ]
    },
    "name": "C. Tyler and Strings",
    "statement": "While looking at the kitchen fridge, the little boy Tyler noticed\r\nmagnets with symbols, that can be aligned into a string s.Tyler likes\r\nstrings, and especially those that are lexicographically smaller than\r\nanother string, t. After playing with magnets on the fridge, he is\r\nwondering, how many distinct strings can be composed out of letters of\r\nstring s by rearranging them, so that the resulting string is\r\nlexicographically smaller than the string t? Tyler is too young, so he\r\ncan\u2019t answer this question. The alphabet Tyler uses is very large, so\r\nfor your convenience he has already replaced the same letters in s and t\r\nto the same integers, keeping that different letters have been replaced\r\nto different integers.We call a string x lexicographically smaller than\r\na string y if one of the followings conditions is fulfilled: There\r\nexists such position of symbol m that is presented in both strings, so\r\nthat before m-th symbol the strings are equal, and the m-th symbol of\r\nstring x is smaller than m-th symbol of string y. String x is the prefix\r\nof string y and x\r\nneq y. Because the answer can be too large, print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\n\nconstexpr int N = 2E5;\n\ntemplate <typename T>\nstruct Fenwick {\n    const int n;\n    std::vector<T> a;\n    Fenwick(int n) : n(n), a(n) {}\n    void add(int x, T v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] += v;\n        }\n    }\n    T sum(int x) {\n        T ans = 0;\n        for (int i = x; i > 0; i -= i & -i) {\n            ans += a[i - 1];\n        }\n        return ans;\n    }\n    T rangeSum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> s(n), t(m);\n    for (int i = 0; i < n; i++) {\n        std::cin >> s[i];\n        s[i]--;\n    }\n    for (int i = 0; i < m; i++) {\n        std::cin >> t[i];\n        t[i]--;\n    }\n    \n    std::vector<int> cnt(N);\n    \n    Fenwick<Z> fen(N);\n    \n    std::vector<Z> fac(n + 1), invfac(n + 1), inv(n + 1);\n    fac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fac[i] = fac[i - 1] * i;\n    }\n    invfac[n] = fac[n].inv();\n    for (int i = n; i; i--) {\n        invfac[i - 1] = invfac[i] * i;\n        inv[i] = invfac[i] * fac[i - 1];\n    }\n    \n    for (auto x : s) {\n        cnt[x]++;\n        fen.add(x, 1);\n    }\n    Z cur = 1;\n    for (int i = 0; i < N; i++) {\n        cur *= invfac[cnt[i]];\n    }\n    \n    Z ans = 0;\n    for (int i = 0; i < std::min(n, m); i++) {\n        ans += cur * fen.sum(t[i]) * fac[n - i - 1];\n        if (cnt[t[i]] == 0) {\n            break;\n        }\n        cur *= cnt[t[i]];\n        cnt[t[i]]--;\n        fen.add(t[i], -1);\n    }\n    \n    if (n < m && cnt == std::vector(N, 0)) {\n        ans += 1;\n    }\n    \n    std::cout << ans.val() << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\C. Tyler and Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/100592",
    "editorial": "Let be the size of the alphabet, that is, the number of the maximum\r\nletter that occurs in it.First, let\u00e2\u0080\u0099s calculate how many different\r\nstrings can be composed if we have letters of the th type, letters of\r\nthe th type, , letters of the type. This is the school formula:to\r\nquickly calculate it for different pre-calculate all factorials and\r\ntheir reciprocals modulo in O()In order for the string to be less than\r\nthe string t, they must have the same prefix. Let\u00e2\u0080\u0099s iterate over the\r\nlength of this matching prefix from to . If strings and have the same\r\nfirst characters, then we know exactly how many letters we have left. To\r\nsupport this, let\u00e2\u0080\u0099s create an array cnt, at the -th position of which\r\nthere will be the number of remaining letters of type .Let\u00e2\u0080\u0099s iterate\r\nover the letter that will appear immediately after the matching prefix.\r\nFor the resulting string to be less than , this letter must be strictly\r\nless than the corresponding letter in , and all subsequent letters can\r\nbe arranged in any order. Let\u00e2\u0080\u0099s calculate the number of rows considered\r\nin this way according to the formula above.The only case where the\r\nresulting string can be lexicographically less than , which we will not\r\ncount, is when it is a prefix of the string , but has a shorter length.\r\nWe will separately check whether we can get such a string, and if so,\r\nadd 1 to the answer.Since at each of at most steps we need to go through\r\nat most options for the next letter, and we calculate each option in\r\nO() - we get the asymptotics O()To speed up the resulting solution,\r\nlet\u00e2\u0080\u0099s create an array , in the -th cell of which we store how many ways\r\nit will be possible to arrange the remaining letters if the letter is\r\nput in the current position. In fact If we learn how to maintain this\r\narray, then at each step we only need to take the sum of the elements at\r\nsome of its prefix. Let\u00e2\u0080\u0099s see how it changes if the next letter in the\r\nstring is , i.e. should decrease by 1.For all cells is replaced by . To\r\napply modifications to the entire array, let\u00e2\u0080\u0099s create a separate\r\nvariable , by which we need to multiply the value in the cell to get the\r\nvalue that should be there.For cell , will be replaced by . And taking\r\ninto account the fact that we applied a modifier to all cells, it is\r\nenough to multiply the value of by With this optimization, we now spend\r\nonly O(K) actions at each step to calculate the prefix sum, and O() to\r\ncalculate what to multiply the array cells by. We get the asymptotics\r\nO() To get rid of asymptotically, note that the only thing we want to do\r\nwith the array is take the sum at the prefix and change the value at the\r\npoint. This can be done in O( using the Fenwick Tree or the Segment\r\nTree. Applying them, we get the final asymptotic O().In fact, in the\r\nasymptotics can be eliminated by precalculating modulo reciprocals for\r\nall numbers from to faster than O(), but in this task was not required.\r\n"
}