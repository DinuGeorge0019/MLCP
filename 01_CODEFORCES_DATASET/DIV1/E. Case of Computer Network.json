{"link": "https://codeforces.com//contest/555/problem/E", "problemId": "30423", "problem_idx": "E", "shortId": "555E", "contest_number": "555", "problem_submissions": {"E": [11801002, 11802846, 11800102, 11803583, 11800123, 11802210, 11798298, 11804601, 11804794, 11814374, 11814369, 11812993, 11798643, 11801381, 11801970, 11807078, 11805652, 11807059, 11806770], "D": [11798292, 11797684, 11802341, 11798935, 11804707, 11798722, 11803791, 11799483, 11805705, 11790452, 11894849, 11797513, 11795485, 11794677, 11798421], "B": [11793605, 11787993, 11791939, 11792335, 11794935, 17186416, 11790076, 11792803, 11790163, 11791786, 11798665, 11793439, 11790680, 11788414, 11791421, 11789757], "A": [11791498, 11789364, 11789864, 11794544, 11805322, 17186185, 11803610, 11791903, 11786622, 11787094, 11786902, 11800059, 11789582, 11786965, 11790812, 11786427, 11786182], "C": [11790530, 11794079, 11795417, 11789940, 11791044, 11793448, 11793773, 11801897, 11796749, 11801939, 11797130, 11796059, 11798373, 11795041, 11798751, 11798577, 11794820]}, "name": "E. Case of Computer Network", "statement": "Andrewid the Android is a galaxy-known detective. Now he is preparing a\r\ndefense against a possible attack by hackers on a major computer\r\nnetwork.In this network are vertices, some pairs of vertices are\r\nconnected by undirected channels. It is planned to transfer important\r\nmessages via this network, the -th of which must be sent from vertex to\r\nvertex via one or more channels, perhaps through some intermediate\r\nvertices.To protect against attacks a special algorithm was developed.\r\nUnfortunately it can be applied only to the network containing directed\r\nchannels. Therefore, as new channels can\u2019t be created, it was decided\r\nfor each of the existing undirected channels to enable them to transmit\r\ndata only in one of the two directions.Your task is to determine whether\r\nit is possible so to choose the direction for each channel so that each\r\nof the messages could be successfully transmitted.\r\n", "solutions": ["#include <iostream>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int MAX = 200005;\nvector<int> adj[MAX];\nint from[MAX], to[MAX], low[MAX], d[MAX], color[MAX], cc[MAX], par[20][MAX];\nbool iscut[MAX], mark[MAX], ans = true;\nvoid dfs(int p, int v)\n{\n\tmark[v] = true;\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint id = adj[v][i];\n\t\tif (id == p)\n\t\t\tcontinue;\n\t\tint u = from[id] + to[id] - v;\n\t\tif (mark[u])\n\t\t{\n\t\t\tif (d[low[v]] > d[u])\n\t\t\t\tlow[v] = u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td[u] = d[v] + 1;\n\t\t\tdfs(id, u);\n\t\t\tif (d[low[u]] > d[v])\n\t\t\t\tiscut[id] = true;\n\t\t\tif (d[low[v]] > d[low[u]])\n\t\t\t\tlow[v] = low[u];\n\t\t}\n\t}\n}\nvoid go(int v, int c)\n{\n\tcolor[v] = c;\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint id = adj[v][i];\n\t\tif (iscut[id])\n\t\t\tcontinue;\n\t\tint u = from[id] + to[id] - v;\n\t\tif (color[u] == -1)\n\t\t\tgo(u, c);\n\t}\n}\nvoid init(int p, int v, int c)\n{\n\tcc[v] = c;\n\tpar[0][v] = p;\n\tfor (int i = 1; i < 20; i++)\n\t\tpar[i][v] = par[i - 1][par[i - 1][v]];\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint u = adj[v][i];\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\td[u] = d[v] + 1;\n\t\tinit(v, u, c);\n\t}\n}\nint get_parent(int v, int k)\n{\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1 << i) & k)\n\t\t\tv = par[i][v];\n\treturn v;\n}\nint lca(int u, int v)\n{\n\tif (d[u] < d[v])\n\t\tswap(u, v);\n\tu = get_parent(u, d[u] - d[v]);\n\tif (u == v)\n\t\treturn u;\n\tfor (int i = 19; i >= 0; i--)\n\t\tif (par[i][u] != par[i][v])\n\t\t{\n\t\t\tu = par[i][u];\n\t\t\tv = par[i][v];\n\t\t}\n\treturn par[0][v];\n}\nint down[MAX], up[MAX];\nvoid fin(int p, int v)\n{\n\tfor (int i = 0; i < adj[v].size(); i++)\n\t{\n\t\tint u = adj[v][i];\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\tfin(v, u);\n\t\tdown[v] += down[u];\n\t\tup[v] += up[u];\n\t}\n\tif (down[v] > 0 && up[v] > 0)\n\t\tans = false;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tmemset(color, -1, sizeof(color));\n\tfor (int i = 0; i < MAX; i++)\n\t\tlow[i] = i;\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcin >> from[i] >> to[i];\n\t\tfrom[i]--;\n\t\tto[i]--;\n\t\tadj[from[i]].push_back(i);\n\t\tadj[to[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (!mark[i])\n\t\t\tdfs(-1, i);\n\tint c = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (color[i] == -1)\n\t\t\tgo(i, c++);\n\tfor (int i = 0; i < n; i++)\n\t\tadj[i].clear();\n\tfor (int i = 0; i < m; i++)\n\t\tif (iscut[i])\n\t\t{\n\t\t\tadj[color[from[i]]].push_back(color[to[i]]);\n\t\t\tadj[color[to[i]]].push_back(color[from[i]]);\n\t\t}\n\tmemset(cc, -1, sizeof(cc));\n\tmemset(d, 0, sizeof(d));\n\tn = c;\n\tc = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (cc[i] == -1)\n\t\t\tinit(i, i, c++);\n\twhile (q--)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--;\n\t\tv--;\n\t\tu = color[u];\n\t\tv = color[v];\n\t\tif (cc[u] != cc[v])\n\t\t\tans = false;\n\t\telse\n\t\t{\n\t\t\tint p = lca(u, v);\n\t\t\tup[u]++;\n\t\t\tup[p]--;\n\t\t\tdown[p]--;\n\t\t\tdown[v]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (par[0][i] == i)\n\t\t\tfin(i, i);\n\tif (ans)\n\t\tcout << \"Yes\\n\";\n\telse\n\t\tcout << \"No\\n\";\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "trees"], "dificulty": "2800", "interactive": false}