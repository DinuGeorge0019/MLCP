{
    "link": "https://codeforces.com//contest/1967/problem/F",
    "problemId": "2620326",
    "problem_idx": "F",
    "shortId": "1967F",
    "contest_number": "1967",
    "problem_submissions": {
        "E2": [
            258916135,
            258921598,
            280919018,
            283055351,
            258925888,
            258925224,
            258926598,
            259116859,
            258926070,
            258925546,
            259722295,
            258957419
        ],
        "E1": [
            258904834,
            258921659,
            258894575,
            258912226,
            258903044,
            258906344,
            258912831,
            258915891,
            258918877,
            258922310,
            259006535,
            258965622,
            258951459,
            258945783,
            258913874,
            258917530,
            258919711,
            258921338,
            258917617,
            258919765,
            259722116,
            258915462,
            258933640,
            258908305,
            258913393,
            258909598
        ],
        "D": [
            258893511,
            258891796,
            258909116,
            258896081,
            258913757,
            258931804,
            258897887,
            258899842,
            258900877,
            258900605,
            258900883,
            258903500,
            258906692,
            258903262,
            258903546,
            258905322,
            258906645,
            259721880,
            258919184,
            258918997,
            258920966,
            258894127
        ],
        "C": [
            258884312,
            258885547,
            258878790,
            258885577,
            258886778,
            258891500,
            258888513,
            258894435,
            258891427,
            258888089,
            258895759,
            258890296,
            258893524,
            258896216,
            258896443,
            258888021,
            258883737,
            258891226,
            258889628,
            258879732
        ],
        "B2": [
            258880311,
            258879319,
            258874379,
            258880426,
            258874860,
            258887764,
            258882431,
            258886567,
            258994245,
            258885903,
            258878827,
            258889665,
            258882193,
            258884237,
            258880372,
            258891352,
            258877071,
            258876977,
            258886917,
            258884212
        ],
        "B1": [
            258869431,
            258871590,
            258870854,
            258865105,
            258869777,
            258876404,
            258873073,
            258874727,
            258869407,
            258874121,
            258875290,
            258873932,
            258869896,
            258873122,
            258871143,
            258871635,
            258872574,
            258874952,
            258869924,
            258867671
        ],
        "A": [
            258865187,
            258866636,
            258865467,
            258874287,
            258866222,
            258865534,
            258866742,
            258868436,
            258867130,
            258868014,
            258872371,
            258870129,
            258865415,
            258868641,
            258868839,
            258866810,
            258868141,
            258871863,
            258867322,
            258865436
        ],
        "F": [
            283293514,
            273029197
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129027",
    "editorial": "Consider an array with length . For each integer from to , consider s.t.\r\n, we tag the untagged (that is, a position will not be tagged for a\r\nsecond time) positions in the range . By examining the total number of\r\npositions tagged, we haveSymmetrically on the other side, we only have\r\nto compute . We want to maintain all in a sorted order, so that queries\r\ncan be done using binary search.This can be done with the help of\r\nchunking. Let the length of each block be . In each block, we divide the\r\npositions into two categories: Positions with the maximum (hereinafter\r\nreferred to as ) and positions without the maximum (hereinafter referred\r\nto as ). We sort the positions by for A and for B respectively.How does\r\nan update affect the values? For the block that the new number is\r\ninserted, we brutely reconstruct it. For an affected complete block, the\r\nupdate is or . A operation can just be handled with a lazy tag.For a\r\noperation, if it only affects the elements with maximum , it can be done\r\nlazily, otherwise you can reconstruct the whole block.Let the potential\r\nof a block . Similar to the segment tree beats, each insertion increases\r\nby at most , and each brute reconstruction takes time and decreases by\r\nat least . Therefore the overall time complexity for the insertion part\r\nwould be .To answer a query, we iterate over all the different blocks.\r\nIf we precalculate the prefix sums of in the sorted order, with a simple\r\nbinary search, this part can be done easily in .Let . The time\r\ncomplexity would be , while the space complexity is . Merge sorting or\r\nfractional cascading will make the time complexity , but it runs slower\r\nthan the previously mentioned solution.\r\n",
    "name": "F. Next and Prev",
    "statement": "Let p_1,\r\nldots, p_n be a permutation of [1,\r\nldots, n].Let the q-subsequence of p be a permutation of [1, q], whose\r\nelements are in the same relative order as in p_1,\r\nldots, p_n. That is, we extract all elements not exceeding q together\r\nfrom p in the original order, and they make the q-subsequence of p.For a\r\ngiven array a, let pre(i) be the largest value satisfying pre(i) < i and\r\na_{pre(i)} > a_i. If it does not exist, let pre(i) = -10^{100}. Let\r\nnxt(i) be the smallest value satisfying nxt(i) > i and a_{nxt(i)} > a_i.\r\nIf it does not exist, let nxt(i) = 10^{100}.For each q such that 1\r\nleq q\r\nleq n, let a_1,\r\nldots, a_q be the q-subsequence of p. For each i such that 1\r\nleq i\r\nleq q, pre(i) and nxt(i) will be calculated as defined. Then, you will\r\nbe given some integer values of x, and for each of them you have to\r\ncalculate\r\nsum\r\nlimits_{i=1}^q\r\nmin(nxt(i) - pre(i), x).\r\n",
    "solutions": [
        "//Author: Kevin#include<bits/stdc++.h>#pragma GCC optimize(3)#pragma GCC target(\"sse3\",\"sse2\",\"sse\")#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")using namespace std;#define ll long long#define ull unsigned ll#define pb emplace_back#define mp make_pair#define ALL(x) (x).begin(),(x).end()#define rALL(x) (x).rbegin(),(x).rend()#define srt(x) sort(ALL(x))#define rev(x) reverse(ALL(x))#define rsrt(x) sort(rALL(x))#define sz(x) (int)(x.size())#define inf 0x3f3f3f3f#define pii pair<int,int>#define lb(v,x) (int)(lower_bound(ALL(v),x)-v.begin())#define ub(v,x) (int)(upper_bound(ALL(v),x)-v.begin())#define uni(v) v.resize(unique(ALL(v))-v.begin())#define longer __int128_tvoid die(string S){puts(S.c_str());exit(0);}const int B=400;int p[300300],pos[300300],n;vector<int> vq[300300];vector<ll> vans[300300];int nxt[300300];vector<ll> vec[300300],psum[300300],vec2[300300],psum2[300300];int cur;int cnt[300300],cnt2[300300],tag[300300],tag2[300300];int mx[300300],mx2[300300];inline int get_ind(int x){return cnt[x/B]+cnt2[x];}void calc(){\tmemset(cnt,0,sizeof(int)*(n+10));\tmemset(cnt2,0,sizeof(int)*(n+10));\tmemset(tag,0,sizeof(int)*(n+10));\tmemset(nxt,inf,sizeof(int)*(n+10));\tmemset(tag2,0,sizeof(int)*(n+10));\tmemset(mx,-inf,sizeof(int)*(n+10));\tmemset(mx2,-inf,sizeof(int)*(n+10));\tfor(int i=0;i<=n/B;i++)\t{\t\tvec[i].clear();\t\tvec2[i].clear();\t\tpsum2[i]={0};\t\tpsum[i]={0};\t}\tfor(cur=1;cur<=n;cur++)\t{\t\tint po=pos[cur];\t\tint b=po/B;\t\tfor(int i=b+1;i<=n/B;i++)\t\t{\t\t\tcnt[i]++;\t\t\ttag[i]++;\t\t}\t\tfor(int i=po+1;i/B==b&&i<=n;i++)\t\t\tcnt2[i]++;\t\tint L=max(1,b*B),R=min(n,b*B+B-1);\t\tint ind=get_ind(po);\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t\tif(nxt[j]==mx[b])\t\t\t\t\tnxt[j]+=tag2[b];\t\ttag2[b]=0;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t\tnxt[j]+=tag[b];\t\ttag[b]=0;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t{\t\t\t\tif(j>po)\t\t\t\t\tnxt[j]++;\t\t\t\telse\t\t\t\t\tnxt[j]=min(nxt[j],ind);\t\t\t}\t\tmx[b]=-inf;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<=cur)\t\t\t\tmx[b]=max(mx[b],nxt[j]);\t\tmx2[b]=-inf;\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur)\t\t\t\tif(nxt[j]<mx[b])\t\t\t\t\tmx2[b]=max(mx2[b],nxt[j]);\t\tvec[b].clear();\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur&&nxt[j]<mx[b])\t\t\t\tvec[b].pb(nxt[j]-get_ind(j));\t\tvec2[b].clear();\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur&&nxt[j]==mx[b])\t\t\t\tvec2[b].pb(nxt[j]-get_ind(j));\t\tsrt(vec[b]);\t\tpsum[b].clear();\t\tpsum[b].pb(0);\t\tfor(auto x:vec[b])\t\t\tpsum[b].pb(psum[b].back()+x);\t\tsrt(vec2[b]);\t\tpsum2[b].clear();\t\tpsum2[b].pb(0);\t\tfor(auto x:vec2[b])\t\t\tpsum2[b].pb(psum2[b].back()+x);\t\tfor(int j=0;j<b;j++) if(tag[j]+mx[j]+tag2[j]>ind)\t\t{\t\t\tif(tag[j]+mx2[j]<ind)\t\t\t{\t\t\t\ttag2[j]=ind-mx[j]-tag[j];\t\t\t\tcontinue;\t\t\t}\t\t\tint L2=max(1,j*B),R2=min(n,j*B+B-1);\t\t\tfor(register int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<cur)\t\t\t\t\tif(nxt[j2]==mx[j])\t\t\t\t\t\tnxt[j2]+=tag2[j];\t\t\ttag2[j]=0;\t\t\tfor(register int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<cur)\t\t\t\t{\t\t\t\t\tnxt[j2]+=tag[j];\t\t\t\t\tnxt[j2]=min(nxt[j2],ind);\t\t\t\t}\t\t\ttag[j]=0;\t\t\tmx[j]=-inf;\t\t\tfor(register int j2=L2;j2<=R2;j2++) if(p[j2]<=cur)\t\t\t\tmx[j]=max(mx[j],nxt[j2]);\t\t\tmx2[j]=-inf;\t\t\tfor(register int j2=L2;j2<=R2;j2++) if(p[j2]<=cur) if(nxt[j2]!=mx[j])\t\t\t\tmx2[j]=max(mx2[j],nxt[j2]);\t\t\tvec[j].clear();\t\t\tfor(int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<=cur) if(nxt[j2]<mx[j])\t\t\t\t\tvec[j].pb(nxt[j2]-get_ind(j2));\t\t\tsrt(vec[j]);\t\t\tpsum[j].clear();\t\t\tpsum[j].pb(0);\t\t\tfor(auto x:vec[j])\t\t\t\tpsum[j].pb(psum[j].back()+x);\t\t\tvec2[j].clear();\t\t\tfor(int j2=L2;j2<=R2;j2++) if(p[j2]<=cur) if(nxt[j2]==mx[j])\t\t\t\tvec2[j].pb(nxt[j2]-get_ind(j2));\t\t\tsrt(vec2[j]);\t\t\tpsum2[j].clear();\t\t\tpsum2[j].pb(0);\t\t\tfor(auto x:vec2[j])\t\t\t\tpsum2[j].pb(psum2[j].back()+x);\t\t}\t\tfor(int qind=0;qind<sz(vq[cur]);qind++) if(!qind||vq[cur][qind]!=vq[cur][qind-1])\t\t{\t\t\tint X=vq[cur][qind];\t\t\tfor(int j=0;j<=n/B;j++)\t\t\t{\t\t\t\tint pos=lb(vec[j],X);\t\t\t\tvans[cur][qind]+=psum[j][pos]+1ll*X*(sz(vec[j])-pos);\t\t\t\tint pos2=lb(vec2[j],X-tag2[j]);\t\t\t\tvans[cur][qind]+=psum2[j][pos2]+1ll*tag2[j]*pos2+1ll*X*(sz(vec2[j])-pos2);\t\t\t}\t\t}\t}}int main(){\tios_base::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tint t;\tcin>>t;\twhile(t--)\t{\t\tcin>>n;\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tcin>>p[i];\t\t\tpos[p[i]]=i;\t\t}\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tint k;\t\t\tcin>>k;\t\t\tvq[i].resize(k);\t\t\tvans[i]=vector<ll>(k,0);\t\t\tfor(auto &x:vq[i])\t\t\t\tcin>>x;\t\t}\t\tcalc();\t\treverse(p+1,p+n+1);\t\tfor(int i=1;i<=n;i++)\t\t\tpos[p[i]]=i;\t\tcalc();\t\tfor(int i=1;i<=n;i++)\t\t\tfor(int j=0;j<sz(vq[i]);j++)\t\t\t\tif(!j||vq[i][j]!=vq[i][j-1])\t\t\t\t\tvans[i][j]-=i+vq[i][j]-1;\t\t\t\telse\t\t\t\t\tvans[i][j]=vans[i][j-1];\t\tfor(int i=1;i<=n;i++)\t\t\tfor(auto x:vans[i])\t\t\t\tcout<<x<<'\\n';\t}\treturn 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Next and Prev.json"
}