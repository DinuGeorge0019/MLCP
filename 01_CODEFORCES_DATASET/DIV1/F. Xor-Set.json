{
    "link": "https://codeforces.com//contest/1261/problem/F",
    "problemId": "479751",
    "problem_idx": "F",
    "shortId": "1261F",
    "contest_number": "1261",
    "problem_submissions": {
        "F": [
            65647116,
            65658053,
            65657980,
            65657931,
            65651526,
            65649568,
            65649392,
            65651843,
            65651789,
            65643329,
            65715623,
            65660068,
            66569502,
            66569457,
            66569446,
            66563643,
            66529592,
            66529450,
            66529001,
            66528877,
            66527265,
            66527166,
            202179447,
            65759590,
            65736891,
            65656177,
            65801900,
            65656900,
            65653812
        ],
        "E": [
            65640839,
            65636308,
            65639924,
            65632814,
            65644428,
            65645126,
            65649634,
            65644543,
            65648074,
            65645492,
            65646710,
            65643401,
            65649412,
            65647298,
            65649626,
            65646791,
            65647214,
            65650131,
            65673025
        ],
        "D2": [
            65637210,
            65632855,
            65635634,
            65636824,
            65639345,
            65639544,
            65635456,
            65639090,
            65637689,
            65685918,
            65636623,
            65641288,
            65630575,
            65640353,
            65641640,
            65638704,
            65642981,
            65642369,
            65636523,
            65640625
        ],
        "D1": [
            65637138,
            65632929,
            65635559,
            65636922,
            65639374,
            65639684,
            65633638,
            65639276,
            65637859,
            65636779,
            65641185,
            65630619,
            65640390,
            65641739,
            65638754,
            65643069,
            65642429,
            65636584,
            65639802
        ],
        "C": [
            65632448,
            65642046,
            65632919,
            65640324,
            65637319,
            65636062,
            65629189,
            65635829,
            65634638,
            65686469,
            65686406,
            65686240,
            65686235,
            65686196,
            65686121,
            65686065,
            65686054,
            65686032,
            65685983,
            65685973,
            65685956,
            65633182,
            65639316,
            65636734,
            65647142,
            65634479,
            65636999,
            65635515,
            65637442,
            65637462,
            65658341,
            65640232,
            65635038
        ],
        "B1": [
            65629099,
            65627296,
            65628841,
            65642477,
            65630053,
            65629451,
            65645427,
            65631701,
            65629375,
            65639182,
            65631034,
            65637262,
            65630223,
            65630435,
            65630786,
            65631879,
            65632451,
            65627736,
            65630111
        ],
        "B2": [
            65629029,
            65627239,
            65628722,
            65642378,
            65629995,
            65629248,
            65645596,
            65631497,
            65629280,
            65720078,
            65685862,
            65639011,
            65631167,
            65637207,
            65630166,
            65630277,
            65630671,
            65631817,
            65632276,
            65627619,
            65630224
        ],
        "A": [
            65626424,
            65626236,
            65626313,
            65643924,
            65627202,
            65627360,
            65650514,
            65628121,
            65627165,
            65626869,
            65627525,
            65634172,
            65626632,
            65626977,
            65627953,
            65628262,
            65627833,
            65631529,
            65627297
        ]
    },
    "name": "F. Xor-Set",
    "statement": "You are given two sets of integers: A and B. You need to output the sum\r\nof elements in the set C =\r\n{x | x = a\r\noplus b, a\r\nin A, b\r\nin B\r\n} modulo 998244353, where\r\noplus denotes the bitwise XOR operation. Each number should be counted\r\nonly once.For example, if A =\r\n{2, 3\r\n} and B =\r\n{2, 3\r\n} you should count integer 1 only once, despite the fact that you can\r\nget it as 3\r\noplus 2 and as 2\r\noplus 3. So the answer for this case is equal to 1 + 0 = 1.Let\u2019s call a\r\nsegment [l; r] a set of integers\r\n{l, l+1,\r\ndots, r\r\n}.The set A is given as a union of n_A segments, the set B is given as a\r\nunion of n_B segments.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nint inverse(int a, int m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  int b = m, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nconst int LOG = 60;\n\nusing num = modnum<998244353>;\nusing num2 = modnum<1004535809>;\nusing ll = long long;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<num2> bin(LOG + 1);\n  bin[0] = 1;\n  for (int i = 0; i < LOG; ++i) {\n    bin[i + 1] = bin[i] * 2;\n  }\n  int na;\n  cin >> na;\n  vector<pair<ll, num2>> a(na * 2);\n  for (int i = 0; i < na; ++i) {\n    cin >> a[i * 2].first;\n    a[i * 2].second = -1;\n    cin >> a[i * 2 + 1].first;\n    a[i * 2 + 1].first++;\n    a[i * 2 + 1].second = 1;\n  }\n  na *= 2;\n  int nb;\n  cin >> nb;\n  vector<pair<ll, num2>> b(nb * 2);\n  for (int i = 0; i < nb; ++i) {\n    cin >> b[i * 2].first;\n    b[i * 2].second = -1;\n    cin >> b[i * 2 + 1].first;\n    b[i * 2 + 1].first++;\n    b[i * 2 + 1].second = 1;\n  }\n  map<ll, num2> sum;\n  auto solve = [&](ll x, ll y, num2 z) {\n    for (int rot = 0; rot < 2; ++rot) {\n      for (int i = LOG - 1; ~i; --i) {\n        if (x >> i & 1) {\n          ll fix = (((x >> i) ^ 1) << i) ^ (y >> i << i);\n          num2 add = 0;\n          for (int j = i - 1; ~j; --j) {\n            if (y >> j & 1) {\n              add += bin[j];\n            }\n          }\n          sum[fix] += z * add;\n          sum[fix + (1ll << i)] -= z * add;\n        }\n      }\n      swap(x, y);\n    }\n    for (int i = LOG - 1; ~i; --i) {\n      if ((x >> i & 1) && (y >> i & 1)) {\n        ll fix = (((x >> i) ^ 1) << i) ^ (((y >> i) ^ 1) << i);\n        sum[fix] += z * bin[i];\n        sum[fix + (1ll << i)] -= z * bin[i];\n      }\n    }\n  };\n  for (auto aa : a) {\n    for (auto bb : b) {\n      solve(aa.first, bb.first, aa.second * bb.second);\n    }\n  }\n  num ans = 0;\n  num2 cur = 0;\n  auto get = [&](ll l, ll r) {\n    return (num) (l + r - 1) * (r - l) / 2;\n  };\n  for (auto it = sum.begin(); it != --sum.end(); ++it) {\n    cur += it->second;\n    if (cur != 0) {\n      ans += get(it->first, next(it)->first);\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "divide and conquer",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\F. Xor-Set.json",
    "editorial_link": "https://codeforces.com/blog/entry/71740",
    "editorial": "Consider a segment tree over the interval , a node representing a\r\nsegment of length would represent all numbers with the first bits same,\r\nwith all possible last n bits. In other words, the binary representation\r\nof any number in the segment would be , where all and is either 0 or 1.\r\nto would be fixed and all s can be arbitrarily chosen. We can observe\r\nthat if we have two segments and in the tree, all possible numbers that\r\nequals the xor sum of a number in and a number in also forms a segment\r\nin the tree, with the length of , and the unchanging bits is equal to\r\nthe xor sum of the two segment\u00e2\u0080\u0099s unchanging bits.Using this observation\r\nwe would get an or algorithm, depending on the sorting method. First, we\r\nget all segments that compose the intervals in and , we can get\r\nresulting segments. Then we are left with evaluating the sum in the\r\ncombination of segments. We can sort these segments to get the answer.\r\nThis algorithm will get an MLE in practice since the number of resulting\r\nsegments could easily exceed .To improve this algorithm, we can make\r\nanother observation that when segments of different sizes are combined\r\nas described above, the smaller segment is equivalent to the ancestor of\r\nthe same size as the bigger segment. Let\u00e2\u0080\u0099s call all the segments in the\r\ndecomposition of the input the \"real\" segments, and all segments with a\r\n\"real\" segment in the subtree as \"auxiliary\" segments. Then we could\r\niterate over 60 possible values of the size of the segment, and for each\r\nvalue, we could iterate over the \"real\" segments of set and \"auxiliary\"\r\nsegments of set and add the results to the set. We can prove that the\r\nnumber of both \"real\" and \"auxiliary\" segments of any size is not\r\ngreater than . Thus, the solution runs at or algorithm, depending on the\r\nsorting method.\r\n"
}