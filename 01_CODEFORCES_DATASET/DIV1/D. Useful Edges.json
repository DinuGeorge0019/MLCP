{
    "link": "https://codeforces.com//contest/1483/problem/D",
    "problemId": "931273",
    "problem_idx": "D",
    "shortId": "1483D",
    "contest_number": "1483",
    "problem_submissions": {
        "F": [
            110657198,
            110657366,
            110680394,
            110676074,
            110665233,
            113439308,
            113059400,
            111430671,
            111430417
        ],
        "D": [
            110640647,
            110642867,
            110640739,
            110649362,
            110656109,
            110648351,
            110669875,
            110646025,
            110641671,
            110641253,
            110642818,
            110645567,
            110644771,
            110644923,
            110644779,
            110648343,
            110645625,
            110649200,
            110647913
        ],
        "C": [
            110637482,
            110639495,
            110638107,
            110639034,
            110636245,
            110643783,
            110646712,
            110639119,
            110637748,
            110637078,
            110639242,
            110639215,
            110640002,
            110638528,
            110640575,
            110640398,
            110641125,
            110641145,
            110641078,
            110642087
        ],
        "B": [
            110634536,
            110634072,
            110635529,
            110635361,
            110642670,
            110636167,
            110639544,
            110634766,
            110633516,
            110637084,
            110643607,
            110635632,
            110634992,
            110636625,
            110637243,
            110635431,
            110638777,
            110635673,
            110637846
        ],
        "A": [
            110629442,
            110628350,
            110629067,
            110628964,
            110631520,
            110629138,
            110634726,
            110632933,
            110628500,
            110629504,
            110630632,
            110632453,
            110628740,
            110630017,
            110629975,
            110630962,
            110628508,
            110633725,
            110630402,
            110630508
        ],
        "E": [
            110660726,
            110669157,
            204375141,
            110665918,
            110662689,
            110666386,
            110657015,
            113441196,
            113891758,
            110672789,
            111426124,
            110692107
        ]
    },
    "name": "D. Useful Edges",
    "statement": "You are given a weighted undirected graph on n vertices along with q\r\ntriples (u, v, l), where in each triple u and v are vertices and l is a\r\npositive integer. An edge e is called if there is at least one triple\r\n(u, v, l) and a path (not necessarily simple) with the following\r\nproperties: u and v are the endpoints of this path, e is one of the\r\nedges of this path, the sum of weights of all edges on this path doesn\u2019t\r\nexceed l. Please print the number of useful edges in this graph.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ntemplate <typename T, int NDIMS> struct tensor_view {\n\tstatic_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tT* data;\n\n\ttensor_view(std::array<int, NDIMS> shape_, std::array<int, NDIMS> strides_, T* data_) : shape(shape_), strides(strides_), data(data_) {}\n\npublic:\n\ttensor_view() : shape{0}, strides{0}, data(nullptr) {}\n\nprotected:\n\tint flatten_index(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) { res += idx[i] * strides[i]; }\n\t\treturn res;\n\t}\n\tint flatten_index_checked(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) {\n\t\t\tassert(0 <= idx[i] && idx[i] < shape[i]);\n\t\t\tres += idx[i] * strides[i];\n\t\t}\n\t\treturn res;\n\t}\n\npublic:\n\tT& operator[] (std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index(idx)];\n\t}\n\tT& at(std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index_checked(idx)];\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type operator[] (int idx) const {\n\t\tstd::array<int, NDIMS-1> nshape; std::copy(shape.begin()+1, shape.end(), nshape.begin());\n\t\tstd::array<int, NDIMS-1> nstrides; std::copy(strides.begin()+1, strides.end(), nstrides.begin());\n\t\tT* ndata = data + (strides[0] * idx);\n\t\treturn tensor_view<T, NDIMS-1>(nshape, nstrides, ndata);\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type at(int idx) const {\n\t\tassert(0 <= idx && idx < shape[0]);\n\t\treturn operator[](idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 == D), T&>::type operator * () const {\n\t\treturn *data;\n\t}\n\n\ttemplate <typename U, int D> friend struct tensor_view;\n\ttemplate <typename U, int D> friend struct tensor;\n};\n\ntemplate <typename T, int NDIMS> struct tensor {\n\tstatic_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tint len;\n\tT* data;\n\npublic:\n\ttensor() : shape{0}, strides{0}, len(0), data(nullptr) {}\n\n\texplicit tensor(std::array<int, NDIMS> shape_, const T& t = T()) {\n\t\tshape = shape_;\n\t\tstrides[NDIMS-1] = 1;\n\t\tfor (int i = NDIMS-1; i > 0; i--) {\n\t\t\tstrides[i-1] = strides[i] * shape[i];\n\t\t}\n\t\tlen = strides[0] * shape[0];\n\t\tdata = new T[len];\n\t\tstd::fill(data, data + len, t);\n\t}\n\n\ttensor(const tensor& o) : shape(o.shape), strides(o.strides), len(o.len), data(new T[len]) {\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tdata[i] = o.data[i];\n\t\t}\n\t}\n\n\ttensor& operator=(tensor&& o) noexcept {\n\t\tusing std::swap;\n\t\tswap(shape, o.shape);\n\t\tswap(strides, o.strides);\n\t\tswap(len, o.len);\n\t\tswap(data, o.data);\n\t\treturn *this;\n\t}\n\ttensor(tensor&& o) : tensor() {\n\t\t*this = std::move(o);\n\t}\n\ttensor& operator=(const tensor& o) {\n\t\treturn *this = tensor(o);\n\t}\n\t~tensor() { delete[] data; }\n\n\tusing view_t = tensor_view<T, NDIMS>;\n\tview_t view() {\n\t\treturn tensor_view<T, NDIMS>(shape, strides, data);\n\t}\n\toperator view_t() {\n\t\treturn view();\n\t}\n\n\tusing const_view_t = tensor_view<const T, NDIMS>;\n\tconst_view_t view() const {\n\t\treturn tensor_view<const T, NDIMS>(shape, strides, data);\n\t}\n\toperator const_view_t() const {\n\t\treturn view();\n\t}\n\n\tT& operator[] (std::array<int, NDIMS> idx) { return view()[idx]; }\n\tT& at(std::array<int, NDIMS> idx) { return view().at(idx); }\n\tconst T& operator[] (std::array<int, NDIMS> idx) const { return view()[idx]; }\n\tconst T& at(std::array<int, NDIMS> idx) const { return view().at(idx); }\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type operator[] (int idx) {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<T, NDIMS-1>>::type at(int idx) {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<const T, NDIMS-1>>::type operator[] (int idx) const {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 < D), tensor_view<const T, NDIMS-1>>::type at(int idx) const {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 == D), T&>::type operator * () {\n\t\treturn *view();\n\t}\n\ttemplate <int D = NDIMS>\n\ttypename std::enable_if<(0 == D), const T&>::type operator * () const {\n\t\treturn *view();\n\t}\n};\n\ntemplate <typename T> void setmin(T& a, T b) { if (b < a) a = b; }\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint N, M; cin >> N >> M;\n\tvector<pair<array<int, 2>, int64_t>> edges(M);\n\tfor (auto& e : edges) {\n\t\tint u, v; int64_t w; cin >> u >> v >> w; u--, v--;\n\t\te = {{u, v}, w};\n\t}\n\tconst int64_t INF = 1e18;\n\ttensor<int64_t, 2> dist({N, N}, INF);\n\tfor (const auto& e : edges) {\n\t\tsetmin(dist[{e.first[0], e.first[1]}], e.second);\n\t\tsetmin(dist[{e.first[1], e.first[0]}], e.second);\n\t}\n\n\tfor (int k = 0; k < N; k++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tsetmin(dist[{i,j}], dist[{i,k}] + dist[{k,j}]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint Q; cin >> Q;\n\ttensor<int64_t, 2> dist_2({N, N}, INF);\n\tfor (int q = 0; q < Q; q++) {\n\t\tint u, v; int64_t l; cin >> u >> v >> l; u--, v--;\n\t\tsetmin(dist_2[{u,v}], -l);\n\t\tsetmin(dist_2[{v,u}], -l);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tsetmin(dist_2[{i,j}], dist_2[{i,k}] + dist[{k,j}]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tsetmin(dist_2[{i,j}], dist[{i,k}] + dist_2[{k,j}]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (const auto& e : edges) {\n\t\tif (e.second + dist_2[e.first] <= 0) {\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\D. Useful Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/88963",
    "editorial": "Find all distances between vertices via Floyd's algorithm for O(n3)\n. Consider all triples with fixed endpoint, say, v\n. Let's find all useful edges corresponding to such triples.\n\nAn edge (a,b,w)\n is useful, if there is a triple (v,ui,li)\n with\n\ndist(v,a)+w+dist(b,ui)?li??li+dist(ui,b)??w?dist(v,a).\n\nNote that the right hand side depends only on the fixed vertex v\n and the edge itself, so we are going to minimize the left hand side over all possible triples. It can be done using Dijkstra in O(n2)\n if we initialize the distance to all ui\n with ?li\n. After we are done for all vertices v\n, there only remains to check for each edge whether it has been marked useful for any vertex v\n."
}