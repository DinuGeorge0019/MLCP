{"link": "https://codeforces.com//contest/590/problem/D", "problemId": "39114", "problem_idx": "D", "shortId": "590D", "contest_number": "590", "problem_submissions": {"D": [13843353, 13843241, 13846192, 13845400, 13845513, 13845184, 13845284, 13846104, 13845914, 13848116, 13848012, 13846585, 13846955, 13840525, 13846113, 13846571, 13847155, 13846536, 13845841], "C": [13840565, 13839464, 13840329, 13843147, 13843128, 13843106, 13843875, 13843172, 13844215, 13844757, 13843685, 13843265, 13844084, 13843699, 13844122, 13843229, 13845260, 13842294, 13843462], "B": [13838659, 13841125, 13841907, 13840783, 13840726, 13840188, 13840959, 13840763, 13840870, 13840852, 13844831, 13840705, 13841546, 13846846, 13841487, 13840918, 13842200, 13844393, 13849735], "A": [13837458, 13845623, 13837970, 13838181, 13838474, 13837720, 13839193, 13837760, 13839312, 13838940, 13839590, 13838409, 13837478, 13845897, 13839666, 13839453, 13839053, 13838125, 13838135], "E": [13864277, 13874288, 13867064, 14107310, 13924688, 13922852, 13869938]}, "name": "D. Top Secret Task", "statement": "A top-secret military base under the command of Colonel Zuev is\r\nexpecting an inspection from the Ministry of Defence. According to the\r\ncharter, each top-secret military base must include a top-secret troop\r\nthat should... well, we cannot tell you exactly what it should do, it is\r\na top secret troop at the end. The problem is that Zuev\u2019s base is\r\nmissing this top-secret troop for some reasons.The colonel decided to\r\ndeal with the problem immediately and ordered to line up in a single\r\nline all soldiers of the base entrusted to him. Zuev knows that the of\r\nthe -th soldier from the left is equal to . Zuev wants to form the\r\ntop-secret troop using leftmost soldiers in the line, thus he wants\r\ntheir total loquacity to be as small as possible (as the troop should\r\nremain top-secret). To achieve this, he is going to choose a pair of\r\nsoldiers and swap them. He intends to do so no more than times. Note\r\nthat any soldier can be a participant of such swaps for any number of\r\ntimes. The problem turned out to be unusual, and colonel Zuev asked you\r\nto help.Determine, what is the minimum total loquacity of the first\r\nsoldiers in the line, that can be achieved by performing no more than\r\nswaps of two consecutive soldiers.\r\n", "solutions": ["#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint dp[2][76][25000];\nint a[200];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int N, K, S;\n    cin >> N >> K >> S;\n    forn(i, N) cin >> a[i];\n    bool sw = false;\n    if (K > N / 2) {\n        K = N - K;\n        reverse(a, a + N);\n        forn(i, N) a[i] = -a[i];\n        sw = true;\n    }\n    dp[0][0][0] = 0;\n    forn(i, N) {\n        forn(j, min(i + 1, K) + 1) forn(l, (i + 1) * N + 1) dp[1][j][l] = 1e9;\n        forn(j, min(i, K) + 1) forn(l, i * N + 1) {\n            if (j < K) uin(dp[1][j + 1][l + abs(i - j)], dp[0][j][l] + a[i]);\n            uin(dp[1][j][l + abs(i - (K + i - j))], dp[0][j][l]);\n        }\n        forn(j, min(i + 1, K) + 1) forn(l, (i + 1) * N + 1) dp[0][j][l] = dp[1][j][l];\n    }\n    int ans = 1e9;\n    forn(d, min(N * N, 2 * S) + 1) uin(ans, dp[0][K][d]);\n    if (sw) forn(i, N) ans -= a[i];\n    cout << ans << '\\n';\n\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2300", "interactive": false}