{
    "link": "https://codeforces.com//contest/587/problem/B",
    "problemId": "38259",
    "problem_idx": "B",
    "shortId": "587B",
    "contest_number": "587",
    "problem_submissions": {
        "B": [
            13648546,
            13631319,
            13641731,
            13630364,
            13633855,
            13635275,
            13633091,
            13631092,
            13632489,
            13636118,
            13634961,
            13633410,
            13637437,
            13631295,
            13631061,
            13631176,
            13632360,
            13636955,
            13631513,
            13651693
        ],
        "F": [
            13647165,
            15306413,
            17349765,
            13654656
        ],
        "E": [
            13635518,
            13645026,
            13634711,
            13645375,
            13645998,
            13646627,
            13648041,
            13649025,
            13654642,
            13649552,
            13647771,
            13647562,
            13649838,
            13647318,
            13650802,
            13654796,
            13653392,
            13655928
        ],
        "A": [
            13627098,
            13626726,
            13642310,
            13627311,
            13628719,
            13627650,
            13627049,
            13626772,
            13626754,
            13627918,
            13626713,
            13628042,
            13629897,
            13626736,
            13627142,
            13626620,
            13626815,
            13629767,
            13626766,
            13627175
        ],
        "C": [
            13638605,
            13644702,
            13638823,
            13638488,
            13639824,
            13640040,
            13637207,
            13636153,
            13640829,
            13642556,
            13639860,
            13642332,
            13636367,
            13653829,
            13637091,
            13635819,
            13636868,
            13633329,
            13636406,
            13632991
        ],
        "D": [
            16774884,
            14175098,
            13654446,
            13648717
        ]
    },
    "name": "B. Duff in Beach",
    "statement": "While Duff was resting in the beach, she accidentally found a strange\r\narray consisting of positive integers. This array was strange because it\r\nwas extremely long, but there was another (maybe shorter) array, that\r\ncan be build from with formula: where denoted the remainder of dividing\r\nby . Duff is so curious, she wants to know the number of subsequences of\r\nlike (), such that: For each , For each , . i.e this subsequence is\r\nnon-decreasing. Since this number can be very large, she want to know it\r\nmodulo .Duff is not a programmer, and Malek is unavailable at the\r\nmoment. So she asked for your help. Please tell her this number.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << \"=\" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int ,int> PII;\ntypedef pair< int , PII> pii;\n\nconst int INF = ~0U>>1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1, a = 1ll * a * a % Mod)\n        if (x & 1) ret = 1ll * ret * a % Mod;\n    return ret; \n}\n\nconst int N=1010000;\nint n,k,a[N],ans,c[N];\nPII p[N];\nll l,dp[N],ss[N];\n\nint main() {\n\tscanf(\"%d%lld%d\",&n,&l,&k);\n\trep(i,0,n) scanf(\"%d\",a+i);\n\trep(i,0,n*k) p[i]=mp(a[i%n],i);\n\tsort(p,p+n*k);\n\trep(j,0,n*k) {\n\t\tint i=p[j].se;\n\t\tif (i<n) dp[i]=1;\n\t\telse dp[i]=ss[i/n-1];\n\t\tss[i/n]=(ss[i/n]+dp[i])%Mod;\n//\t\tprintf(\"%d %lld\\n\",i,dp[i]);\n\t\tif (i<l) {\n\t\t\tll x=(l-1-i+n)/n;\n\t\t\tans=(ans+(x%Mod)*dp[i])%Mod;\n\t\t}\n\t}\n\tif (ans<0) ans+=Mod;\n\tprintf(\"%d\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\B. Duff in Beach.json",
    "editorial_link": "https://codeforces.com//blog/entry/20971",
    "editorial": "If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).\n\nFor the problem above, let dp[i][j] be the number of valid subsequences of b where x?=?j and  and . Of course, for every i, dp[i][1]?=?1. For calculating value of dp[i][j]:\n\nFor this purpose, we can sort the array a and use two pointer:\n\nif p0,?p1,?...pn?-?1 is a permutation of 0,?...,?n?-?1 where for each 0???t?<?n?-?1, apt???apt?+?1:\n\nNow, if  and x?=?l?-?1 mod n, then answer equals to  (there are c?-?j?+?1 valid different values of  for the first group and c?-?j for the second group)."
}