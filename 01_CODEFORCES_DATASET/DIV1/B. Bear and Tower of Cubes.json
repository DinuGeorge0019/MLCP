{"link": "https://codeforces.com//contest/679/problem/B", "problemId": "61895", "problem_idx": "B", "shortId": "679B", "contest_number": "679", "problem_submissions": {"D": [18322762, 18323626, 18322971, 18323450, 18324701, 18327443, 18345837, 18345768, 18345680, 18345642, 18327111, 18328820, 18327048, 18328042, 18328483, 18329243, 18329178, 18324869, 18324693], "B": [18314677, 18309080, 18312175, 18311888, 18312358, 18312942, 18316455, 18317342, 18309354, 18307663, 18316385, 18308970, 18308226, 18309465, 18308416, 18312030, 18314147], "C": [18310021, 18317790, 18318340, 18317148, 18319639, 18318992, 18320837, 18322274, 18315941, 18322904, 18316017, 18318363, 18318389, 18317725, 18315473, 18314694], "A": [18303717, 18304196, 18305388, 18304702, 18306194, 18307513, 18307982, 18303929, 18304410, 18304102, 18305596, 18304174, 18305099, 18303722, 18303574, 18304076, 18305438, 18304649], "E": [200103409, 18853172, 18325979, 18447386, 188767815]}, "name": "B. Bear and Tower of Cubes", "statement": "Limak is a little polar bear. He plays by building towers from blocks.\r\nEvery block is a cube with positive integer length of side. Limak has\r\ninfinitely many blocks of each side length.A block with side has volume\r\n. A tower consisting of blocks with sides has the total volume .Limak is\r\ngoing to build a tower. First, he asks you to tell him a positive\r\ninteger the required total volume of the tower. Then, Limak adds new\r\nblocks greedily, one by one. Each time he adds the biggest block such\r\nthat the total volume doesn\u2019t exceed .Limak asks you to choose not\r\ngreater than . Also, he wants to maximize the number of blocks in the\r\ntower at the end (however, he still behaves greedily). Secondarily, he\r\nwants to maximize .Can you help Limak? Find the maximum number of blocks\r\nhis tower can have and the maximum that results this number of blocks.\r\n", "solutions": ["#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#define pli pair<long long,int>\nusing namespace std;\nint D[1010000], res, T[1010000], P[1010000];\nlong long m;\npli Get(long long m){\n    if(m<=1000000){\n        return pli(P[m],T[m]);\n    }\n    double tt = pow((double)m,1.0/3);\n    long long K = (long long)(tt+0.5);\n    while(K*K*K>m) K--;\n    pli t1 = Get(m-K*K*K);\n    pli t2 = Get(3*K*K - 3*K);\n    if(t1.second >= t2.second){\n        return pli(K*K*K + t1.first, t1.second + 1);\n    }\n    return pli((K-1)*(K-1)*(K-1) + t2.first, t2.second + 1);\n}\nint main(){\n    int i, pv = 1;\n    for(i=1;i<=1000000;i++){\n        while(i>=(pv+1)*(pv+1)*(pv+1))pv++;\n        D[i] = 1 + D[i-pv*pv*pv];\n    }\n    scanf(\"%lld\",&m);\n    for(i=1;i<=1000000;i++){\n        T[i] = max(D[i],T[i-1]);\n        if(T[i]==D[i])P[i]=i;\n        else P[i] = P[i-1];\n    }\n    pli tp = Get(m);\n    printf(\"%d %lld\\n\",tp.second,tp.first);\n}\n"], "input": "", "output": "", "tags": ["binary search", "dp", "greedy"], "dificulty": "2200", "interactive": false}