{"link": "https://codeforces.com//contest/1423/problem/H", "problemId": "749088", "problem_idx": "H", "shortId": "1423H", "contest_number": "1423", "problem_submissions": {"J": [95462948, 95462931, 95462795, 95462776, 95462759, 95462752, 95462749, 95445856, 95445842, 95445741, 95445735, 95445720, 95436077, 95435983, 94779119, 94773285, 94770663, 94778562], "C": [94789081], "I": [94786050], "F": [94784528, 94776365, 94779778, 94781062], "H": [94781814, 94783650, 94777878, 94784871], "L": [94780014, 94780685, 94786643, 94773659], "B": [94771096, 94770153, 94772426, 94771466], "K": [94770723, 94771588, 94773427, 94774938], "A": [], "D": [], "E": [], "G": []}, "name": "H. Virus", "statement": "In Bubbleland a group of special programming forces gets a top secret\r\njob to calculate the number of potentially infected people by a new\r\nunknown virus. The state has a population of n people and every day\r\nthere is new information about new contacts between people. The job of\r\nspecial programming forces is to calculate how many contacts in the last\r\nk days a given person had. The new virus has an incubation period of k\r\ndays, and after that time people consider as non-infectious. Because the\r\nnew virus is an extremely dangerous, government mark as suspicious\r\neverybody who had direct or indirect contact in the last k days,\r\nindependently of the order of contacts.This virus is very strange, and\r\npeople can\u2019t get durable immunity.You need to help special programming\r\nforces to calculate the number of suspicious people for a given person\r\n(number of people who had contact with a given person).There are 3 given\r\ninputs on beginning n where n is population, q number of queries, k\r\nvirus incubation time in days. Each query is one of three types: (x, y)\r\nperson x and person y met that day (x\r\nneq y). (z) return the number of people in contact with z, counting\r\nhimself. The end of the current day moves on to the next day.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 05.10.2020 17:41:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q, k;\n  cin >> n >> q >> k;\n  vector<pair<int, int>> e;\n  vector<int> day;\n  vector<int> where;\n  int cur_day = 0;\n  int ptr = 0;\n  vector<int> eid;\n  vector<int> match;\n  for (int i = 0; i < q; i++) {\n    int type;\n    cin >> type;\n    if (type == 1) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      where.push_back((int) eid.size());\n      eid.push_back((int) e.size());\n      match.push_back(-1);\n      e.emplace_back(x, y);\n      day.push_back(cur_day);\n    }\n    if (type == 2) {\n      int z;\n      cin >> z;\n      --z;\n      eid.push_back(~z);\n      match.push_back(-1);\n    }\n    if (type == 3) {\n      cur_day += 1;\n      while (ptr < (int) e.size() && day[ptr] <= cur_day - k) {\n        match[where[ptr]] = (int) eid.size();\n        eid.push_back(ptr);\n        match.push_back(where[ptr]);\n        ptr += 1;\n      }\n    }\n  }\n\n  vector< pair<int, int> > ops[123];\n  vector<int> p(n);\n  vector<int> sz(n);\n  for (int i = 0; i < n; i++) {\n    p[i] = i;\n    sz[i] = 1;\n  }\n\n  auto rollback = [&](int level) {\n    while (!ops[level].empty()) {\n      int i = ops[level].back().first;\n      int j = ops[level].back().second;\n      if (i >= 0) {\n        p[i] = j;\n      } else {\n        sz[~i] = j;\n      }\n      ops[level].pop_back();\n    }\n  };\n\n  auto set_p = [&](int a, int b, int level) {\n    ops[level].emplace_back(a, p[a]);\n    p[a] = b;\n  };\n\n  auto set_sz = [&](int a, int b, int level) {\n    ops[level].emplace_back(~a, sz[a]);\n    sz[a] = b;\n  };\n\n  function<int(int, int)> get = [&](int x, int level) {\n    if (x != p[x]) {\n      set_p(x, get(p[x], level), level);\n    }\n    return p[x];\n  };\n\n  auto join = [&](int eid, int level) {\n    int x = get(e[eid].first, level);\n    int y = get(e[eid].second, level);\n    if (x != y) {\n      if (sz[x] > sz[y]) {\n        swap(x, y);\n      }\n      set_p(x, y, level);\n      set_sz(y, sz[y] + sz[x], level);\n    }\n  };\n\n  function<void(int, int, int)> solve = [&](int L, int R, int level) {\n    if (L == R) {\n      if (eid[L] < 0) {\n        int v = ~eid[L];\n        int par = get(v, level);\n        cout << sz[par] << '\\n';\n        rollback(level);\n      }\n      return;\n    }\n    int M = (L + R) / 2;\n    for (int i = M + 1; i <= R; i++) {\n      if (eid[i] >= 0 && (match[i] >= 0 && match[i] < L)) {\n        join(eid[i], level);\n      }\n    }\n    solve(L, M, level + 1);\n    rollback(level);\n    for (int i = L; i <= M; i++) {\n      if (eid[i] >= 0 && (match[i] == -1 || match[i] > R)) {\n        join(eid[i], level);\n      }\n    }\n    solve(M + 1, R, level + 1);\n    rollback(level);\n  };\n  solve(0, (int) eid.size() - 1, 0);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dsu", "graphs"], "dificulty": "2500", "interactive": false}