{
    "link": "https://codeforces.com//contest/1965/problem/A",
    "problemId": "2614995",
    "problem_idx": "A",
    "shortId": "1965A",
    "contest_number": "1965",
    "problem_submissions": {
        "F": [
            258465624,
            258627065,
            263837667,
            258481689
        ],
        "D": [
            258447727,
            258460812,
            258466117,
            258450218,
            258464835,
            258457510,
            258458513,
            258465971,
            259573719,
            258506961,
            258454027,
            258456282,
            258483429,
            258453210,
            258453791
        ],
        "C": [
            258425895,
            258434352,
            258433902,
            258442030,
            258433331,
            258429762,
            258434494,
            258427059,
            258424566,
            258435014,
            258430069,
            258434394,
            258430905,
            258434841,
            258457386,
            258428580,
            258429520,
            258434274
        ],
        "B": [
            258420424,
            258428605,
            258430303,
            258433453,
            258426877,
            258424079,
            258428403,
            258433720,
            259639909,
            258437552,
            258428917,
            258424298,
            258428062,
            258424086,
            258427169,
            258427222,
            258425398,
            258424422,
            258426595
        ],
        "A": [
            258418141,
            258418841,
            258425010,
            258419725,
            258419999,
            258418044,
            258419071,
            258418897,
            258418989,
            258419441,
            258418664,
            258419165,
            258419761,
            258418751,
            258419361,
            258418280,
            258427816,
            258420207
        ],
        "E": [
            258446500,
            258464809,
            258455602,
            258503208,
            258466942,
            258468402,
            258463371,
            258447373,
            258452406,
            258457290,
            258460561,
            258509487,
            258461569,
            302317911,
            258464177,
            258450702,
            258478527
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128914",
    "editorial": "If the smallest pile is of size , then Alice must choose in her first\r\nmove. Therefore, we can imagine subtracting from all piles, and\r\ndetermining who wins given that Bob goes first. We can repeat this\r\nprocess, switching the first player back and forth, until there is no\r\nlonger a pile of size . At this point, we are in one of two states: If\r\nthere are no piles remaining, the first player loses, because they\r\ncannot make any moves Otherwise, the smallest pile is of size . We can\r\nshow that the first player will always win. To do this, consider what\r\nhappens if the first player chooses : If this would create a losing\r\nstate for the next player, then the first player can choose and win.\r\nOtherwise, the state reached by choosing is a winning state for the next\r\nplayer to move. So the first player can choose , forcing the second\r\nplayer to choose . The first player will now be in the winning state and\r\ncan proceed to win the game. To implement this solution, we only need to\r\nkeep track of the largest pile size , and the smallest positive integer\r\nthat is not a pile size (essentially the MEX of the pile sizes,\r\nexcluding ).If , then Alice and Bob will be forced to choose until the\r\nend of the game, so the parity of determines the winner. Otherwise, they\r\nwill eventually reach a state with minimum pile size at least , so the\r\nparity of determines the winner.Complexity: or depending on\r\nimplementation\r\n",
    "name": "A. Everything Nim",
    "statement": "Alice and Bob are playing a game on n piles of stones. On each player\u2019s\r\nturn, they select a positive integer k that is at most the size of the\r\nsmallest pile and remove k stones from nonempty pile at once. The first\r\nplayer who is unable to make a move (because all piles are empty)\r\nloses.Given that Alice goes first, who will win the game if both players\r\nplay optimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;\u00a0void solve() {    int n;    std::cin >> n;        std::vector<int> a(n + 1);    for (int i = 1; i <= n; i++) {        std::cin >> a[i];    }    std::sort(a.begin(), a.end());        int win = 0;    for (int i = n; i >= 1; i--) {        int v = a[i] - a[i - 1];        if (v > 0) {            if (win == 0) {                win = 1;            } else if (v == 1) {                win = 0;            }        }    }        std::cout << (win ? \"Alice\" : \"Bob\") << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "games",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\DIV1\\A. Everything Nim.json"
}